00:00 - almost all software developers should
00:01 - have some understanding of uml
00:04 - uml is a way to use diagrams to
00:06 - visualize a system or database it's used
00:09 - frequently in software development to
00:12 - plan out software systems
00:14 - this introduction to uml is from ava
00:16 - coders and welcome to the uml course for
00:19 - beginners we'll look into the most
00:21 - widely used diagrams they're basic
00:23 - notation and applications each diagram
00:26 - that we will study in this course will
00:28 - be supported with a practical example of
00:31 - a system or a situation that can be
00:34 - modeled with its help i like to start
00:36 - this course with a little introduction
00:38 - to uml and a brief overview of each
00:41 - diagram how does it look like and what
00:43 - is it actually used for first of all uml
00:46 - stands for unified modeling language
00:49 - which according to the legend was
00:51 - developed when some serious it people
00:54 - were fed up with an ambiguous variety of
00:56 - circles dashes stars and clouds uml 2.0
01:00 - that we're going to study in this course
01:02 - consists of an integrated set of
01:05 - diagrams of various agreed shapes and
01:07 - forms designed to help system and
01:10 - software developers to define design
01:12 - visualize and document software system
01:15 - artifacts and in some cases some
01:17 - business models uml is a set of best
01:20 - engineering practices that has proven to
01:22 - be effective in modeling large and
01:25 - complex systems and is a very important
01:28 - part of object-oriented software
01:30 - development uml mainly uses graphical
01:33 - notation to express the software
01:35 - project's design uml helps teams to
01:37 - communicate explore potential designs
01:40 - and validate software architectural
01:42 - designs the purpose of uml is to provide
01:46 - a standardized annotation that can be
01:48 - used by all object-oriented methods as
01:51 - well as selecting and integrating best
01:54 - elements of the precursor notations uml
01:57 - has been designed for a wide range of
01:59 - applications hence it provides
02:02 - constructs for a wide variety of systems
02:05 - and activities for example distributed
02:07 - systems analysis system design and
02:11 - deployment uml diagrams can be divided
02:14 - into two main types structure diagrams
02:16 - and behavior diagrams there are seven
02:19 - types of structure diagrams composite
02:22 - structure diagram
02:23 - deployment diagram
02:25 - package diagram
02:27 - profile diagram
02:28 - class diagram
02:30 - object diagram and component diagram
02:33 - behavior diagrams include activity
02:35 - diagram use case diagram state diagram
02:39 - sequence diagram
02:41 - communication diagram
02:43 - interaction overview diagram
02:45 - and timing diagram now a few words about
02:48 - each one of them class diagram is this
02:51 - central modeling technique that is used
02:53 - in almost all object oriented methods
02:56 - this diagram describes the types of
02:58 - objects in the system and different
03:00 - kinds of static relationships that exist
03:03 - between them the three most important
03:05 - types of relationships in class diagrams
03:08 - but there are actually more of them are
03:10 - association which represents
03:12 - relationships between instances of types
03:15 - for example a person works for a company
03:18 - or a company has multiple offices
03:20 - inheritance which corresponds directly
03:22 - to inheritance in object oriented design
03:25 - and aggregation which is a form of
03:28 - object composition in object oriented
03:30 - design component diagrams illustrate how
03:33 - components are put together to form
03:36 - larger components or software systems
03:38 - and illustrates the architecture of
03:40 - software components and dependencies
03:43 - between them these software components
03:45 - can include
03:46 - runtime components executable components
03:49 - and source code components deployment
03:51 - diagram helps to model the physical
03:53 - aspect of an object-oriented software
03:56 - system this is a block diagram that
03:58 - shows the system architecture as
04:00 - deployment or distribution of software
04:03 - artifacts artifacts represent specific
04:06 - elements in the physical world that are
04:08 - the result of the development process
04:10 - the diagram simulates the runtime
04:13 - configuration in a static view and
04:15 - visualize the distribution of artifacts
04:18 - in the application in most cases this
04:20 - involves simulating hardware
04:22 - configurations along with the software
04:25 - components that host them object diagram
04:27 - is an instance of the class diagram it
04:30 - shows a detailed snapshot of the system
04:32 - state at a particular point in time the
04:35 - difference is that the class diagram is
04:37 - an abstract model of classes and their
04:39 - relationships however the object diagram
04:42 - represents an instance at a specific
04:45 - moment which is concrete in nature the
04:47 - use of object diagrams is rather limited
04:50 - namely to show examples of data
04:53 - structures package diagram is a
04:55 - structural diagram that shows packages
04:57 - and dependencies between them it allows
05:00 - us to display different views of the
05:02 - system for example it is easy to
05:04 - simulate a layered application composite
05:06 - structure diagram is similar to the
05:09 - class diagram and it is a kind of a
05:11 - component diagram used mainly in micro
05:14 - level system modeling but it depicts
05:16 - individual parts instead of whole
05:18 - classes this is a type of static
05:20 - structure diagram that shows the
05:22 - internal structure of a class and
05:25 - interactions that the structure makes
05:27 - possible this diagram can include
05:29 - internal parts ports through which the
05:32 - parts can communicate with each other or
05:34 - through which the class instances can
05:36 - communicate with various parts and with
05:38 - the outside world as well as connectors
05:40 - between parts and ports composite
05:42 - structure diagram is a set of
05:44 - interrelated elements that interact at
05:47 - runtime to achieve a specific goal each
05:50 - element has a dedicated role in this
05:52 - collaboration profile diagram allows us
05:55 - to create domain and platform specific
05:57 - stereotypes and define relationships
06:00 - between them we can create stereotypes
06:02 - by drawing shapes of stereotypes and
06:04 - linking them to composition or
06:06 - generalization through a resource
06:09 - oriented interface we can also define
06:11 - and visualize stereotype values use case
06:14 - diagram describes the functional
06:16 - requirements of a system in terms of use
06:18 - cases in essence it is a model of
06:21 - intended functionality of the system use
06:24 - cases and its environment actors use
06:27 - cases allow us to link what we need from
06:30 - the system with how the system meets
06:32 - those needs activity diagrams are
06:34 - graphical representations of workflows
06:37 - of stepwise activities and actions with
06:40 - the support of choice iteration and
06:42 - concurrency they describe the control
06:44 - flow of the target system such as
06:46 - exploring complex business rules and
06:49 - operations as well as describing the use
06:51 - cases and business processes in uml
06:54 - activity diagrams are meant for modeling
06:57 - both computational and organizational
06:59 - processes state machine diagram is a
07:02 - type of diagram used in uml to describe
07:05 - system behavior which is based on david
07:08 - harrell's concept of state diagrams
07:10 - state machine diagrams depict permitted
07:13 - states and transitions as well as events
07:15 - that affect those transitions this
07:17 - diagram helps to visualize the entire
07:19 - life cycle of objects and thus helps to
07:22 - better understand state-based systems
07:25 - sequence diagram models the interaction
07:28 - of object based on a time sequence it
07:30 - shows how objects interact with each
07:33 - other in a particular use case similar
07:35 - to sequence diagram the communication
07:37 - diagram is also used to model the
07:40 - dynamic behavior of a use case when
07:42 - compared to sequence diagram
07:43 - communication diagram focuses more on
07:46 - showing object collaborations rather
07:48 - than the time sequence in fact
07:51 - communication diagrams and sequence
07:53 - diagrams are semantically equivalent and
07:56 - one can be generated from another
07:58 - interaction overview diagram focuses on
08:01 - the overview of the flow of control of
08:04 - the interactions this is a variant of
08:06 - activity diagram where the nodes
08:08 - depicted are the interactions or
08:10 - interaction occurrences interaction
08:12 - overview diagram describes interactions
08:15 - in which messages and lifelines are
08:17 - hidden we can link up the real diagrams
08:20 - and achieve a high degree of navigation
08:23 - between diagrams within an interaction
08:25 - of your diagram timing diagram shows the
08:28 - behavior of the object or objects at a
08:31 - given time period in fact this is a
08:33 - special form of a sequence diagram and
08:36 - the differences between them are that
08:38 - the axes are swapped so that the time
08:40 - increases from left to right and the
08:42 - lifelines are displayed in separate
08:44 - compartments arranged vertically so why
08:47 - are there so many diagrams the reason
08:50 - for this is that this can help to
08:52 - examine the system at different angles
08:54 - and there can be many participants
08:57 - involved in software development for
08:59 - example analysts architectures coders
09:02 - testers quality control customers
09:05 - technical authors these people are all
09:07 - interested in different aspects of the
09:10 - system and each requires a different
09:12 - level of details for example a coder
09:15 - would want to understand the design of
09:17 - the system to be able later to convert
09:20 - this design into some low-level code in
09:23 - contrast a technical writer is
09:25 - interested in the behavior of the system
09:27 - as a whole and would want to understand
09:30 - the product's features uml tries to be a
09:32 - language that all those participants can
09:34 - benefit from and possibly use at least
09:37 - one of its diagrams uml class diagram
09:40 - illustrates the structure of the system
09:42 - by describing
09:44 - classes their attributes methods and
09:46 - relationships between them just before
09:48 - we begin discussing the diagram let's
09:51 - remind ourselves what is a class in a
09:54 - nutshell class is a template for
09:56 - creating objects as well as representing
09:59 - objects initial state attributes and
10:02 - behavior methods each attribute has its
10:04 - own type each method has its own
10:07 - signature but in the class diagram only
10:09 - the class name is mandatory and it makes
10:12 - sense because even the best psychics
10:15 - will not be able to guess what this
10:17 - nameless square supposed to mean or what
10:19 - it generally refers to so let's take a
10:22 - look at the building blocks of a class
10:24 - diagram starting with the class itself
10:26 - the name of the class is written in the
10:28 - uppermost partition followed by the
10:30 - class attributes with their types
10:33 - written after the column and finally the
10:35 - last partition contains methods the type
10:38 - that the method can return is written
10:40 - after the column in the method signature
10:43 - you've probably noticed the minuses and
10:45 - pluses before the class attributes and
10:47 - methods these are the access modifiers
10:50 - or class visibility notation plus means
10:53 - public minus private hash protected and
10:58 - tilde means package local each parameter
11:01 - in a method can also be described in
11:03 - terms of its direction with the respect
11:06 - to the caller in out in out for example
11:10 - method 1 uses p1 as an input parameter
11:14 - and the value of p1 is somehow used by
11:17 - the method and the method does not
11:20 - change p1 method 2 accepts p2 as an
11:23 - input output parameter the p2 value is
11:27 - somehow used by the method and it
11:29 - accepts the output value of the method
11:32 - and the method itself can change p2
11:35 - method 3 uses p3 as the output parameter
11:39 - in other words the parameter serves as a
11:42 - repository for the output value of the
11:45 - method we can use class diagrams at
11:47 - different stages of the software
11:49 - development lifecycle therefore we might
11:52 - want them to reflect a different levels
11:55 - of specification and thankfully there
11:57 - are three different perspectives or
11:59 - levels of specification that we can use
12:02 - a conceptual perspective is when class
12:05 - diagrams are interpreted as describing
12:08 - entities of the real world thus if we
12:10 - choose conceptual perspective we
12:13 - construct a diagram that represents the
12:16 - concepts in the domain these concepts
12:18 - relate to classes that implement them
12:21 - the conceptual perspective is considered
12:23 - language independent a specification
12:26 - perspective is when diagrams are
12:28 - interpreted as describing abstractions
12:31 - of software or components with
12:33 - specification and interfaces but without
12:36 - any reference to a specific
12:38 - implementation thus if you look at the
12:40 - specification perspective you can
12:42 - generally see some software interfaces
12:45 - but not necessarily their implementation
12:48 - and finally the implementation
12:50 - perspective is when diagrams are
12:52 - interpreted as a description of software
12:55 - implementations in a particular
12:57 - technology or programming language thus
12:59 - if you choose to use this perspective
13:02 - you can choose to depict the actual
13:04 - software implementation now let's have a
13:06 - look at the relationships between
13:08 - classes i will describe the six main
13:11 - types of notation that are most common
13:14 - these are association
13:16 - inheritance
13:18 - implementation dependency aggregation
13:22 - and composition similar to relationships
13:24 - connecting objects associations connect
13:27 - classes in order for there to be a
13:29 - connection between classes there must be
13:31 - an association between them if we assume
13:34 - that we have two classes that interact
13:36 - with each other a continuous connecting
13:39 - line should be drawn between them
13:41 - indicating the association in the
13:43 - diagram often we can also see a verb
13:46 - written above the line that conveys its
13:48 - meaning in addition we can also specify
13:51 - the multiplicity that is the number of
13:54 - objects that can take part in the
13:56 - relationship multiplicity is specified
13:59 - as a comma separated list of intervals
14:02 - where each interval is represented as a
14:04 - minimum maximum for example one student
14:08 - can learn from many tutors and a tutor
14:11 - can teach many students inheritance
14:14 - sometimes it is also called
14:16 - generalization as the name implies this
14:19 - is a schematic representation of the
14:21 - relationship between the parent class
14:24 - and its descendants the hollow arrow is
14:27 - always directed towards the parent class
14:29 - a classic example of inheritance depicts
14:32 - a square class a rectangle class and a
14:35 - circle class as descendants of their
14:38 - common parent class we can connect each
14:40 - class with their parent class separately
14:43 - or combine those lines and draw one
14:45 - common arrow line that connects all
14:48 - common descendants with their parent if
14:50 - the sentence inherits from an abstract
14:53 - class then the name of such parent class
14:55 - is written in italics realization
14:58 - usually this refers to the relationships
15:00 - between an interface and objects that
15:03 - implement this interface for example the
15:06 - owner interface has methods for buying
15:09 - and selling private property and the
15:11 - relationships between the owner
15:13 - interface and the person and corporation
15:16 - classes that implement this interface
15:19 - are depicted by a dashed line with an
15:21 - arrowhead pointing at the interface
15:24 - dependency when an object one class uses
15:27 - an object of another class in its method
15:30 - and this object is not stored in any
15:32 - field then this kind of relationship is
15:36 - modeled as a dependency dependency is
15:39 - essentially a special case of the
15:41 - association of two classes in this case
15:44 - changes in one class will inexorably
15:46 - entail changes in the other for example
15:49 - this person class has a has read method
15:52 - with a book as an input parameter which
15:55 - returns true if for example the person
15:58 - has read the book dependency is drawn
16:00 - with a dashed line with arrowhead
16:03 - pointing towards the class on which the
16:05 - method of another class could depend
16:08 - aggregation a special type of
16:10 - relationship between classes when one
16:12 - class is a composite part of another for
16:15 - example a programmer's workstation could
16:17 - consist of a chair a desk a computer and
16:22 - a fan but when we delete the workstation
16:25 - class we still have all these classes
16:28 - but on their own they no longer form an
16:30 - aggregate class workstation aggregation
16:33 - is shown as a continuous align with an
16:36 - unfilled diamond connected to the class
16:39 - which represents the aggregate
16:41 - composition is a type of aggregation but
16:44 - this time classes that form the
16:46 - aggregator class are destroyed when the
16:49 - aggregator class is destroyed for
16:51 - example our body is made up of organs
16:55 - but they can't function by themselves
16:57 - composition is depicted similarly to
17:00 - aggregation but this time the diamond is
17:03 - solid and as a conclusion to this topic
17:06 - i just want to remind you that uml is
17:08 - not so much about a pretty picture uml
17:12 - is actually a powerful tool in the
17:14 - programmers toolkit if you can
17:16 - understand and utilize it properly say
17:18 - get in the habit of drawing your class
17:21 - diagram before you sit down and actually
17:23 - code your next e-commerce gaming
17:26 - financial and whatnot project time
17:28 - invested in drawing assets synth and
17:30 - clear uml diagram will eventually pay
17:33 - off and can save your project from
17:35 - design flows and other errors you might
17:38 - encounter without a proper plan in front
17:41 - of you uml component diagrams are used
17:44 - for modeling physical aspects of object
17:47 - oriented systems that are used for
17:49 - visualizing defining and documenting
17:52 - component-based systems as well as
17:54 - construction executable systems using
17:57 - forward and reverse engineering
17:59 - component diagrams are essentially class
18:02 - diagrams that focus on system components
18:05 - that are often used to model the static
18:07 - implementation view of a system
18:10 - component diagram breaks down the system
18:12 - under development into various high
18:15 - levels of functionality each component
18:18 - is responsible for one clear goal within
18:21 - the entire system and interacts with
18:23 - other essential elements only on a need
18:26 - to know basis so how does it work data
18:29 - for example account and inspection id
18:32 - flows into the component through the
18:34 - port on the right and gets converted to
18:37 - a format that internal components can
18:39 - utilize interfaces on the right are
18:42 - known as required interfaces they
18:45 - represent the services the component
18:48 - needs to fulfill its responsibilities
18:50 - data then passes through various
18:53 - connections and other components before
18:55 - it is output through the ports on the
18:58 - left those interfaces on the left are
19:00 - also known as provided interfaces and
19:04 - other components of the system can
19:06 - interact with them in order to take
19:08 - advantage of the output results of the
19:11 - component it is important to note that
19:14 - the internal components are surrounded
19:16 - by a large box which can represent the
19:19 - system as a whole in that case there
19:22 - will be no component symbol in the upper
19:24 - right corner or a subsystem or component
19:27 - of the overall system in this case the
19:30 - box itself is a component a component is
19:34 - a modular part of a system that
19:36 - encapsulates its content in uml 2.0 a
19:40 - component is drawn as a rectangle with
19:43 - optional compartments arranged
19:45 - vertically the following example shows
19:47 - two types of interface components
19:50 - provided interface is drawn with a
19:52 - complete circle at its end and
19:54 - represents the interface that the
19:56 - component provides to the system this
19:59 - symbol is known by the nickname lollipop
20:02 - and is a shorthand for a realization
20:04 - relationship of an interface classifier
20:07 - required interface is indicated by a
20:10 - semicircle at the end and as you might
20:13 - guess it indicates the interface that a
20:16 - component needs to perform a task in
20:18 - both cases the interface's name is
20:21 - placed next to the interface symbol
20:24 - subsystem classifier is a special kind
20:26 - of a component classifier because of
20:29 - this the subsystem notation element
20:31 - inherits the same rules as the component
20:34 - notation element the only difference is
20:36 - that the subsystem element is marked
20:39 - with the keyword subsystem instead of
20:41 - the keyword component ports are depicted
20:44 - with a square drawn along the edge of
20:47 - the system or a component a port is
20:50 - mainly used to expose required and
20:52 - provided component interfaces
20:55 - graphically a component diagram
20:57 - resembles a system of components and
21:00 - logical nodes connecting them in general
21:02 - some relationships might already be
21:04 - familiar to you as they are widely used
21:07 - in the class diagram but there are some
21:09 - unique ones association an association
21:12 - defines the semantic relationship that
21:14 - can occur between typed instances it is
21:17 - drawn as a straight line connecting two
21:19 - or more components of the system
21:22 - composition composite aggregation is a
21:24 - strong form of aggregation that requires
21:28 - a part instance to be included in at
21:30 - most one composite at a time if a
21:34 - composite is deleted all its parts are
21:36 - usually deleted with it aggregation very
21:40 - similar to composition but in this case
21:42 - the child component can exist on its own
21:45 - even without being a part of the
21:47 - aggregator class aggregation is drawn
21:50 - with a hollow diamond pointing towards
21:52 - the aggregator constraint a condition or
21:55 - restriction expressed as a text in a
21:58 - natural language or in a
22:00 - machine-readable language in order to
22:02 - declare some of the semantics of an
22:05 - element dependency dependency is a
22:08 - relationship where an element or set of
22:10 - elements require other elements for
22:13 - their specification or implementation
22:16 - this means that the full semantics of
22:18 - the dependent elements are either
22:20 - semantically or structurally dependent
22:23 - on the definition of the supplier
22:25 - element or elements inheritance
22:28 - inheritance or generalization is a
22:31 - taxonomic relationship between a more
22:33 - general classifier and a more specific
22:36 - classifier each instance of a specific
22:39 - classifier is also an indirect instance
22:42 - of the general classifier thus the
22:44 - specific classifier inherits the
22:46 - features of the more general classifier
22:49 - let's have a look at some use cases
22:51 - consider a typical step-by-step process
22:54 - of modeling a source code that shows how
22:57 - we would approach creating a component
22:59 - diagram for a program first of all with
23:02 - the help of forward or reverse
23:04 - engineering we determine the set of
23:07 - source code files of interest and model
23:10 - them as components for larger systems we
23:13 - can use entire packages to display
23:15 - groups of files don't forget about tags
23:18 - that indicate the version of the source
23:21 - code file in use you can also specify
23:23 - its author or the date and time of the
23:26 - last change we can also model the
23:28 - compilation dependencies between these
23:31 - files using dependencies and now let's
23:34 - have a look at a step-by-step process
23:36 - for modeling an executable release first
23:39 - we define a set of components that we
23:42 - want to model typically this will
23:44 - include some or even all components that
23:47 - are on a single node or a distributed
23:50 - system of these sets of components
23:52 - across all nodes in the model it's worth
23:55 - considering the type of each component
23:58 - in this set for most systems there is
24:00 - only a small number of different kinds
24:03 - of components such as executable files
24:06 - libraries tables other files and
24:09 - documents we can also use uml
24:12 - extensibility mechanisms to provide
24:14 - visual cues for these types it is
24:17 - important not to forget to consider the
24:19 - relationship of each element in the
24:22 - system with its neighbors most often
24:24 - this will be associated with interfaces
24:27 - that are exported or realized by certain
24:30 - components and then imported or used by
24:33 - others but if we want our model to be at
24:36 - a higher level of abstraction then we
24:38 - can exclude these intermediate
24:40 - interfaces that hold such relations
24:43 - together showing only dependencies among
24:46 - the components themselves and finally in
24:49 - modeling a physical database first we
24:52 - identify the classes that will represent
24:55 - our logical database schema then we
24:58 - choose a mapping strategy for mapping
25:00 - these classes to tables it is also worth
25:03 - taking into account the physical
25:04 - distribution of our database because the
25:08 - mapping strategy will also be affected
25:10 - by the location in which you want to
25:12 - store data after the databases
25:15 - deployment to visualize define build and
25:18 - document our mapping we need to create a
25:20 - component diagram that will contain
25:23 - these components as tables uml
25:26 - deployment diagram illustrates the
25:28 - configuration of runtime processing
25:30 - nodes and the components that live on
25:33 - them deployment diagram is a kind of a
25:35 - structural diagram used in modeling the
25:38 - physical aspects of an object-oriented
25:40 - system they're often used to simulate a
25:43 - static representation of a system
25:46 - deployment for example topology of the
25:48 - hardware deployment diagrams show the
25:51 - structure of the runtime system they
25:53 - model the elements of physical hardware
25:56 - and the ways of communicating between
25:58 - them they can be used to plan a system
26:01 - architecture they can also be useful for
26:04 - documenting the deployment of software
26:06 - components or nodes these diagrams are
26:10 - important for visualizing defining and
26:12 - documenting embedded client server and
26:15 - distributed systems as well as managing
26:18 - runtime systems through forward or
26:21 - reverse engineering a deployment diagram
26:24 - is just a special kind of a class
26:26 - diagram that focuses on system nodes
26:29 - graphically deployment diagram looks
26:32 - like a collection of vertices and arcs
26:35 - deployment diagrams usually contain the
26:37 - following notation a 3d box represents a
26:41 - node either software or hardware
26:43 - hardware node may be marked with a
26:46 - stereotype notation connections between
26:49 - nodes are represented with a line with
26:51 - optional stereotype notation nodes can
26:54 - reside within other nodes the diagram
26:57 - can also reflect dependencies
27:00 - associations as well as nodes or
27:02 - restrictions these are the steps that
27:05 - are normally taken to model an embedded
27:07 - system identify devices and nodes that
27:11 - are unique to your system provide visual
27:14 - cues especially for unusual devices
27:16 - using uml extensibility mechanisms to
27:20 - identify system stereotypes with
27:22 - matching icons you will also want to
27:24 - distinguish between processes that
27:26 - contain software components and devices
27:29 - that at this level of abstraction do not
27:32 - directly contain software model the
27:35 - relationships between these processors
27:37 - and devices in a deployment diagram
27:40 - similarly specify the relationships
27:42 - between the components in the
27:44 - implementation view of your system and
27:46 - the nodes in the deployment view of your
27:49 - system if necessary expand the
27:51 - capabilities of any smart devices by
27:54 - modeling their structure with a more
27:57 - detailed deployment scheme here are the
27:59 - steps for modeling a client server
28:02 - system identify the nodes that represent
28:05 - the client and server processors of your
28:08 - system highlight those devices that are
28:10 - related to the behavior of your system
28:12 - for example you can simulate special
28:15 - devices such as credit card readers icon
28:18 - readers and display devices other than
28:21 - monitors since placement of the latter
28:23 - in the system's hardware topology is
28:26 - likely to be of a great architectural
28:28 - importance provide a visual cues for
28:30 - these processors and devices through
28:33 - stereotyping model the topology of these
28:36 - nodes in the deployment diagram
28:38 - similarly specify the relationships
28:40 - between the components in the
28:42 - implementation view of your system and
28:44 - the nodes in the deployment view of your
28:46 - system and here are the steps you will
28:48 - need to take when modeling a distributed
28:51 - system identify the devices and
28:54 - processors of the system as for simpler
28:57 - client server systems if you need to
28:59 - reason about the network performance or
29:02 - the impact of changes on this network be
29:05 - sure to simulate communication devices
29:07 - at a level of detail that is sufficient
29:10 - to conduct these estimates pay
29:12 - particular attention to logical groups
29:14 - of nodes that you can specify with
29:17 - packages where possible use tools that
29:19 - discover the topology of your system by
29:22 - walking your system's network if you
29:24 - need to focus on the dynamics of your
29:26 - system use the use case diagram to
29:29 - indicate the types of behavior you're
29:32 - interested in and expand this use cases
29:34 - with interaction diagrams when modeling
29:37 - a fully distributed system it is common
29:39 - to transform or represent the network
29:42 - itself as a node that is the internet
29:45 - lan or one might be depicted as nodes in
29:49 - the form of a single box rather than a
29:51 - combination of elements when you develop
29:54 - a deployment plan for your company you
29:56 - might discover that you don't know where
29:58 - to start and what to focus on the
30:01 - following checklist can give you some
30:03 - ideas for planning your deployment how
30:05 - will your system be installed who will
30:08 - install it how long will it take where
30:10 - the installation can possibly fail how
30:12 - long can it take to install your system
30:15 - what backups do you need before the
30:16 - installation will data conversion be
30:19 - necessary how did you know that the
30:21 - installation was successful if different
30:24 - versions of the system work
30:25 - simultaneously how will you resolve the
30:27 - conflicts what physical sites do you
30:30 - need to deploy and in what order how
30:33 - will you train your support and
30:34 - operational staff will it be necessary
30:37 - to deploy a production support system so
30:39 - that support staff will use their own
30:41 - environment to model problems how will
30:44 - you train your users what documentation
30:47 - and in what formats and languages do
30:49 - your users as well as support team and
30:52 - operation specialists need how will
30:54 - documentation updates be deployed what
30:57 - existing systems should the new system
31:00 - interact with or integrate how reliable
31:03 - should the system be will any additional
31:05 - equipment be required in the event of a
31:07 - system failure what or who will connect
31:11 - or interact with the system and how will
31:13 - they do it what software including the
31:16 - operating systems and communication
31:18 - protocols will the system use what
31:21 - hardware and software will users
31:23 - interact directly with pcs network
31:26 - computers browsers etc how will you
31:29 - control the system after deployment how
31:31 - secure
31:32 - should the system be does it needs a
31:34 - firewall physically safe equipment etc
31:38 - answering these questions will save you
31:40 - a lot of time in the future and protect
31:43 - you and your team from unpleasant
31:45 - surprises during and after the
31:47 - deployment of the system uml object
31:50 - diagram is an instance of a class
31:52 - diagram it captures a snapshot of the
31:54 - detailed state of the system objects and
31:57 - their relationship at a specific point
32:00 - in time it can be considered as a
32:02 - special case of a class diagram or a
32:05 - communication diagram the use of the
32:07 - object diagrams is quite limited and
32:10 - mainly comes down to demonstrating
32:12 - examples of data structures during the
32:14 - project analysis phase you can create a
32:17 - class diagram to describe the structure
32:19 - of the system and then create a set of
32:22 - object diagrams as test cases to verify
32:25 - the accuracy and completeness of the
32:27 - class diagram prior to creating a class
32:30 - diagram you can create an object diagram
32:32 - to find out facts about specific model
32:35 - elements and their relationships or to
32:38 - illustrate specific examples of the
32:40 - required classifiers the object diagram
32:43 - illustrates the relation between the
32:45 - instantiated classes and the defined
32:48 - class as well as the relationship
32:50 - between the objects in the model system
32:52 - at a fixed point in time it's fair to
32:55 - say that it's a snapshot of your system
32:58 - at a certain point in time which will
33:00 - depict system objects in a certain state
33:03 - which will directly represent real
33:05 - instances and prototypes these diagrams
33:08 - are useful for example when you want to
33:10 - depict a small part of a large system in
33:13 - which case the use of a class diagram
33:16 - would be an overkill as well as in case
33:18 - you want to model recursive
33:20 - relationships or to study the behavior
33:23 - of a system at a particular moment in
33:25 - time the best way to show what an object
33:28 - diagram looks like is to show an object
33:30 - diagram derived from the corresponding
33:33 - class diagram this humble class diagram
33:36 - illustrates a simple example in which a
33:38 - department depicted consisting of many
33:41 - other departments and this object
33:43 - diagram is nothing more than a detailed
33:46 - representation of the previous class
33:48 - diagram with examples and links let's
33:51 - walk through the basic notation of an
33:53 - object diagram each object is drawn as a
33:56 - rectangle the name of the object and its
33:58 - class are usually underlined and
34:01 - separated with a column the name of the
34:03 - object is on the left the name of the
34:05 - class is on the right the attributes of
34:08 - an object are listed in a separate
34:10 - compartment under the name of the class
34:12 - or object and must indicate the values
34:15 - assigned to them links in general are
34:17 - varieties of associations between
34:20 - classes and are discussed in detail in
34:22 - the video about class diagrams since uml
34:25 - object diagrams provide a snapshot of
34:28 - instances and the relationships between
34:30 - them in the system we can create object
34:33 - diagrams by instantiating the model
34:35 - elements on class diagrams deployment
34:38 - diagrams components and use case
34:40 - diagrams for example we can represent a
34:43 - part of the company's structure with the
34:45 - object diagram a communication diagram
34:48 - without any messages can also be called
34:50 - an object diagram and relationships
34:53 - between objects can be called links an
34:55 - object diagram must be a valid instance
34:58 - of a static class diagram objects must
35:01 - have classes and relationships between
35:03 - objects must be the instances of
35:06 - associations between classes that is
35:08 - relationships between objects will
35:11 - essentially be similar to relationships
35:13 - between classes let's look at some steps
35:16 - for modeling object structures first of
35:18 - all define the mechanism that you would
35:20 - like to model this mechanism can
35:22 - represent some function or behavior of
35:24 - the part of the system that you are
35:26 - modeling which is basically the result
35:28 - of the interactions between classes
35:31 - interfaces and other elements therefore
35:34 - it is necessary to identify the classes
35:37 - interfaces and elements for each
35:39 - mechanism that participate in this model
35:42 - and determine the relationships between
35:44 - them after that consider for example one
35:47 - scenario that walks through this
35:49 - mechanism and at a certain point in time
35:52 - renders each object that participates in
35:54 - the mechanism expand the state and
35:56 - attribute values of each such object to
35:59 - understand this scenario a kind of
36:01 - analogy would be the mechanical clocks
36:03 - imagine it is noon and we pretend to
36:06 - freeze the time to examine the elements
36:09 - of the mechanism what do they do where
36:11 - do the hour and minute hands point to
36:13 - which gears and sprockets are involved
36:16 - and so on let's have a look at another
36:18 - example robot moving behavior here one
36:21 - object represents the robot itself r is
36:24 - an instance of a robot and r is
36:26 - currently in a state marked moving this
36:29 - object has a link to w an instance of
36:32 - the world which is an abstraction of a
36:34 - model of the world for the robot this
36:37 - object is linked with several objects
36:39 - consisting of instances of the element
36:42 - that represents entities that the robot
36:45 - has identified but has not yet assigned
36:48 - in its world view these elements are
36:50 - marked as part of the global state of
36:53 - the robot currently w is associated with
36:57 - two instances of area one of them a2 is
37:01 - shown with its own links to the three
37:03 - wall objects and one door object each of
37:06 - these walls has an attribute width and
37:09 - each wall is linked with neighboring
37:11 - walls by and large this diagram
37:14 - graphically shows how the robot
37:16 - recognizes this enclosed area which has
37:19 - walls on three sides and a door on the
37:22 - fourth the next example is deriving an
37:24 - object structure similar to
37:26 - communication diagram in addition to
37:29 - displaying the state of objects at a
37:31 - certain point in time an object diagram
37:33 - can also be used for example to
37:35 - represent the occurrences of
37:37 - interactions between classes during the
37:40 - runtime uml package diagram is a kind of
37:43 - a structural diagram that shows the
37:45 - location and organization of model
37:48 - elements in a medium scale and large
37:50 - scale projects a package diagram can
37:53 - display both this structure and the
37:55 - dependencies between subsystems or
37:58 - modules illustrating various kinds of
38:00 - systems such as a layered application
38:03 - for example if the system is of a
38:05 - significant size it should be divided
38:08 - into smaller subsystems each with its
38:11 - own class diagram in uml notation these
38:14 - partitions or subsystems are called
38:16 - packages a package is a group of
38:19 - elements of the model and it can also be
38:21 - used in other uml diagrams packages
38:24 - themselves can be nested in other
38:26 - packages which is basically a uml
38:28 - version of folders package diagrams are
38:31 - usually used when it is necessary to
38:33 - group a related eml elements and
38:36 - determine the scope of their names or
38:38 - when you need to provide a way to
38:40 - visualize dependencies between parts of
38:43 - the system as well as to provide some
38:45 - support for analysis or determine the
38:48 - compilation order package diagrams are
38:50 - used to structure high-level system
38:53 - elements when modeling a package diagram
38:56 - you should bear in mind that a package
38:58 - is a uml mechanism for grouping elements
39:01 - including other packages each package
39:04 - has its own namespace in which all names
39:07 - must be unique each model element
39:09 - belongs to a single package packages
39:12 - form a hierarchy packages are displayed
39:15 - as rectangles with small tabs at the top
39:18 - package's name is normally written on
39:20 - its tab or dedicated rectangle namespace
39:23 - dotted lines with arrows depict
39:26 - dependencies one package is said to be
39:28 - dependent on another if changes in that
39:31 - other package can cause changes in the
39:34 - first one as well a system could be
39:36 - depicted in the form of a package with
39:38 - the stereotype system and it represents
39:41 - all the elements of the model that are
39:43 - relevant to a particular project you can
39:46 - also break the system apart into
39:48 - business systems and application systems
39:51 - when creating more detailed models to
39:53 - make them smaller but more efficient
39:56 - package diagram can also display the
39:58 - logical architecture of a system a
40:01 - subsystem is a group of model elements
40:03 - that are part of some larger system
40:06 - since the system or subsystem is a
40:08 - stereotypical package it has all the
40:11 - properties of the package and it also
40:13 - follows the rules of the package and all
40:16 - those model elements that are contained
40:18 - inside the system or the subsystem will
40:20 - also belong to the package and follow
40:23 - the same rules now what does this word
40:26 - stereotype actually mean stereotype is a
40:28 - high level classification of an object
40:31 - that gives some idea of what the object
40:34 - is classes can be grouped by stereotypes
40:37 - their names are written inside the angle
40:39 - brackets above the class name stereotype
40:42 - allows us to extend uml to fit our
40:45 - modeling needs more specifically in
40:47 - other words stereotyping a uml element
40:50 - makes it act as something that has
40:52 - specific properties elements in packages
40:55 - may also have different visibility of
40:58 - elements of other packages and this also
41:00 - needs to be taken into account during
41:02 - the process of modeling of a system
41:05 - elements of a package with public
41:07 - visibility are available outside the
41:10 - package while elements with private
41:12 - visibility are available only for other
41:15 - elements within the package in uml
41:18 - public protected and private
41:19 - visibilities correspond to a class that
41:22 - is a public protected or private a
41:25 - public element is visible to all
41:28 - elements that can access the content of
41:30 - the namespace to which it belongs public
41:33 - visibility is represented by the plus
41:36 - sign a protected element is visible to
41:38 - elements related to generalization
41:41 - relationship to the namespace that owns
41:44 - it protected visibility is represented
41:46 - by the hash sign a package element is
41:49 - owned by a namespace that is not a
41:52 - package and is visible to all elements
41:54 - that are in the same package package
41:56 - visibility is marked by a tilde a
41:59 - private element is visible only inside
42:02 - the namespace that owns it private
42:05 - visibility is represented by the minus
42:08 - sign let's look at the types of
42:09 - dependency relationships represented by
42:12 - the stereotypes the element in the
42:14 - client package uses the public element
42:17 - in the supplier package the client
42:19 - depends on the supplier if the package
42:22 - dependency is shown without a stereotype
42:25 - then it should be marked with a use
42:27 - stereotype public elements of the
42:29 - supplier namespace are added as public
42:32 - elements to the client namespace
42:35 - elements in the client's namespace can
42:37 - access all public elements in the
42:39 - supplier namespace using unqualified
42:42 - names public supplier namespace elements
42:45 - are added as private elements to the
42:48 - client namespace elements in the client
42:50 - namespace can access all public elements
42:53 - in the supplier namespace using
42:55 - unqualified names trace normally
42:58 - represents a historical development of
43:01 - one element into another more developed
43:03 - version usually this is the relationship
43:06 - between models not elements public
43:08 - elements of the supplier package are
43:11 - combined emerge with the client package
43:13 - elements the dependency is used only in
43:17 - metamodeling and the chance of
43:19 - encountering it in the modern object
43:21 - oriented analysis and design is even
43:23 - less than encountering an elephant in
43:26 - the central london next we will analyze
43:28 - an example diagram of the order tracking
43:31 - scenario for an online store in this
43:33 - diagram the track order module is
43:36 - responsible for providing tracking
43:39 - information for product ordered by our
43:42 - customers the types of customers are
43:44 - encrypted inside the tracking number
43:47 - truck order module refers to the system
43:50 - and updates the current delivery status
43:53 - for the customer based on the
43:54 - description of the project first we must
43:57 - determine what packages will be present
43:59 - in the system and figure out the
44:01 - relationships between them so how to
44:04 - determine which packages do we need to
44:06 - model the system suppose that we have a
44:09 - module that tracks an order it could be
44:11 - some sort of a tracking module and in
44:13 - order to perform its duty it must
44:16 - communicate with another module in order
44:18 - to figure out the details of the order
44:20 - let's call this module order details
44:23 - after receiving the details of the order
44:25 - it needs to know the shipping details so
44:27 - let's introduce a shipping module and
44:30 - now let's determine the dependencies
44:32 - between them the track order module must
44:35 - receive the order details from the order
44:37 - details module in response order details
44:40 - module requires to know the information
44:43 - provided by the client two modules
44:45 - communicate with each other which
44:47 - provides the access dual dependency to
44:50 - learn the shipping information the
44:52 - shipping module can import the truck or
44:55 - the module to make the navigation easier
44:57 - finally the truck order is dependent on
45:00 - the ui framework and this completes our
45:03 - order processing subsystem design
45:06 - composite structure diagram contains
45:08 - classes interfaces packages and their
45:11 - relationships and it provides a logical
45:14 - representation of a software system or
45:16 - its part this diagram is one of the new
45:19 - artifacts added in uml 2.0 and it shows
45:23 - the internal structure including parts
45:25 - and connectors of a structured
45:27 - classifier or collaboration the
45:30 - composite structure diagram plays a role
45:32 - similar to the class diagram but allows
45:35 - you to delve into details of the
45:37 - internal structure of multiple classes
45:40 - and show the interactions between them
45:42 - you can graphically represent inner
45:44 - classes and parts and show associations
45:47 - both between classes and within them in
45:50 - other words composite structure diagrams
45:53 - show the internal parts of a class the
45:56 - part's name is usually constructed with
45:58 - parts name then column then parts type
46:02 - with multiplicity stated inside the
46:05 - square brackets aggregated classes are
46:07 - parts of a class but parts are not
46:10 - necessarily classes a part is any
46:13 - element that is used to make up the
46:15 - containing class suppose we are modeling
46:18 - a system for an online store in which
46:20 - customers can join a loyalty program
46:23 - that provides them with some benefits
46:25 - discounted shipping for example in order
46:28 - to allow such a feature we expanded the
46:31 - customer object so now we have a regular
46:34 - customer and a member of our loyalty
46:37 - program let's start by simulating an
46:39 - online store using a class diagram we
46:42 - have a class for item which can be
46:45 - aggregated by the order class which is
46:48 - composed by the customer class which
46:50 - itself is composed by the store manager
46:54 - class we have many objects that end up
46:57 - within other objects on the diagram
46:59 - everything looks as if it ends up inside
47:02 - the store manager so we can create a
47:05 - composite structure diagram to clearly
47:07 - demonstrate what this manager consists
47:10 - of composite structure diagram shows us
47:12 - a clear picture of the store manager
47:15 - from its own point of view instead of
47:17 - this system as a whole store manager
47:20 - directly contains two types of objects
47:23 - customer and item as indicated by the
47:26 - two composition arrows in the class
47:28 - diagram the composite structure diagram
47:30 - here shows the inclusion of customer
47:33 - subtypes explicitly please note that the
47:36 - type of both parts is declared as
47:38 - customer because the store treats both
47:41 - objects as customer objects we also see
47:44 - a connector that shows the relationship
47:46 - between item and order order is not
47:50 - contained directly in the store manager
47:52 - class but we can show relationships with
47:55 - parts nested in the object that it
47:57 - aggregates the question is do these two
48:00 - diagrams essentially describe the same
48:02 - thing or have the same meaning well in
48:05 - the class diagram the relationship
48:07 - between the description and pricing is
48:10 - ambiguous strictly speaking there are
48:12 - not exactly the same the class diagram
48:15 - shows that description will have a
48:17 - reference to the pricing object but this
48:20 - does not specify whether the link
48:22 - between the two objects is contained
48:24 - inside the item explicitly if we use a
48:27 - composite structure diagram the
48:28 - relationship between the description and
48:31 - pricing objects becomes obvious specific
48:34 - implementations of an object's activity
48:36 - can be clearly modeled composite
48:38 - structure diagrams are good for
48:40 - describing aggregation but in this case
48:43 - models will also need to contain
48:45 - references to objects outside the class
48:48 - that we are modeling references to
48:50 - external objects are shown with a dashed
48:53 - rectangle even if they refer to an
48:56 - object outside the class the link itself
48:59 - is inside the model class and it is an
49:02 - important step in demonstrating its
49:04 - implementation the key object of
49:06 - composite structure specified in the uml
49:09 - 2.0 are structured classifiers parts
49:12 - ports connectors and collaborations
49:14 - collaboration describes the structure of
49:17 - collaborating parts and their roles in
49:19 - the interaction and is used when we want
49:21 - to determine only those roles and
49:23 - connections that are necessary to
49:25 - achieve a specific goal of such
49:28 - collaboration for example the purpose of
49:30 - a collaboration may be to define the
49:32 - roles of components of a classifier
49:35 - having identified the main roles the
49:37 - collaboration simplifies the structure
49:39 - and clarifies the behavior of elements
49:42 - in the model itself in this example the
49:45 - wheels and the engine are parts of the
49:47 - collaboration and front axle and rear
49:50 - axle are connectors a car is a composite
49:54 - structure that shows parts and
49:56 - connections between parts a part is a
49:58 - diagram element that represents a set of
50:01 - one or more instances owned by a
50:03 - structured classifier a part describes
50:06 - the role of the instance in the
50:08 - classifier we can create parts in the
50:10 - structure compartment of the classifier
50:13 - and in several uml diagrams such as
50:16 - composite structure diagram class
50:18 - diagram object diagram component diagram
50:21 - deployment diagram and package diagram a
50:24 - port defines the point of interaction
50:26 - between the classifier instance and its
50:29 - environment or between the behavior of
50:31 - the classifier and its internal parts
50:34 - composite structure diagram supports the
50:36 - notation for provided and required
50:39 - interfaces if necessary interfaces can
50:42 - be shown or hidden in the diagram a line
50:45 - that represents the relationships within
50:47 - the model is called a connector when
50:50 - modeling the internal structure of a
50:52 - classifier we can use a connector to
50:55 - indicate a link between two or more
50:57 - instances of a part or a port a
51:00 - connector defines the relationships
51:02 - between the objects or instances that
51:05 - are associated with the roles in the
51:07 - same structured classifier and defines
51:10 - the communication between those roles as
51:13 - an example here's a simplified composite
51:16 - structured diagram for a computer system
51:18 - which includes the following components
51:21 - power supply unit hard disk dvd
51:24 - motherboard central processing unit and
51:27 - memory module you can pause the video
51:29 - here to study the diagram profile
51:32 - diagram is one of the uml structural
51:34 - diagrams it is well known for providing
51:37 - a general extension mechanism for
51:40 - customizing uml models for specific
51:42 - domains and platforms profiles are
51:45 - defined using stereotypes tag value
51:48 - definitions and constraints that apply
51:51 - to specific elements of the model such
51:53 - as classes attributes operations and
51:56 - actions a profile is a set of extensions
51:59 - that jointly configure uml for a
52:02 - specific domain for example aerospace
52:05 - medical or financial or specific
52:07 - platforms such as j2ee or net profile
52:11 - diagrams have three major types of
52:14 - extension mechanisms
52:16 - stereotypes tags and constraints
52:19 - stereotypes allow us to increase the
52:21 - vocabulary of uml you can add and create
52:24 - new model elements derive from the
52:26 - existing ones but having more specific
52:29 - properties that are suitable for a
52:31 - specific domain stereotypes are used to
52:34 - introduce new building blocks that speak
52:36 - the language of your domain and look
52:39 - primitive this allows you to introduce
52:41 - new graphical symbols for example when
52:44 - modelling a network you may need
52:46 - annotation for router switch hub etc a
52:50 - stereotype allows you to make these
52:52 - things appear as primitive as possible
52:55 - why would you need that for example a
52:57 - box labeled with a stereotype button
52:59 - makes more sense than a picture of green
53:02 - rooster that was added to the schema
53:04 - just because someone ran out of
53:06 - meaningful symbols tags are used to
53:08 - extend the properties of uml so you can
53:11 - add additional information to the
53:13 - specification of a model element this
53:16 - allows you to specify keyword value
53:19 - pairs of a model where keywords are
53:21 - attributes tagged values are graphically
53:24 - displayed as strings enclosed by the
53:26 - curly braces for example imagine a team
53:29 - that is responsible for assembling
53:31 - testing and deploying a system for them
53:34 - it is necessary to monitor the version
53:37 - and test results of the main subsystem
53:40 - and this is where tags come in handy
53:42 - tags can also be useful to add
53:44 - properties to the model such as code
53:46 - generation version control configuration
53:49 - management and authorship constraints
53:51 - are properties used for semantics or
53:54 - conditions that should always be
53:56 - satisfied they allow us to expand the
53:58 - semantics of the uml building blocks by
54:01 - adding new protocols a constraint is
54:04 - displayed as a string enclosed by the
54:06 - square brackets next to the
54:08 - corresponding element for example when
54:10 - developing a real-time system it is
54:13 - necessary to supplement the model with
54:16 - some necessary information such as
54:18 - response time for instance constraints
54:20 - may be placed on attributes derived
54:22 - attributes and associations they can
54:25 - also be attached to one or more model
54:28 - elements shown as a node as an
54:30 - alternative to creating a new matter
54:32 - model you can also expand and modify the
54:35 - uml metamodel according to your
54:37 - requirements in uml this is called a
54:40 - lightweight extension based on
54:42 - stereotypes and profiles a uml profile
54:46 - can be defined in one of the following
54:48 - ways creation of a new meta-model
54:51 - extension and modification of the uml
54:54 - metamodel extension of the uml meta
54:57 - model with language inherent mechanisms
55:00 - uml 2.0 allows you to use arbitrary data
55:04 - structures for extended elements which
55:06 - means that wider and more accurate
55:09 - extensions of the model are now possible
55:11 - the profile mechanism is not a first
55:14 - class extension mechanism because it
55:16 - does not allow changing existing or
55:19 - creating new meta models profile only
55:22 - allows adaptation or customization of an
55:26 - existing meta model in uml 2.0 or above
55:29 - profiles can also be dynamically
55:32 - combined so that multiple profiles can
55:34 - be applied on the same model at the same
55:37 - time a stereotype can extend from one or
55:40 - more meta classes such extension is
55:42 - depicted as an arrow with a continuous
55:45 - align and filled arrowhead that goes in
55:48 - the direction from the stereotype to the
55:51 - meta class stereotypes can be presented
55:53 - in the form of text or graphics the
55:56 - normal class box can also be replaced by
55:59 - the icon for example people often use
56:01 - these three stereotype class
56:03 - representations to model the mvc
56:06 - software infrastructure to use
56:08 - stereotypes in a specific application
56:11 - you must first integrate a profile
56:13 - containing stereotypes you do this with
56:16 - a dashed arrow its open arrowhead is
56:18 - pointing away from the application
56:21 - package towards the profile this arrow
56:24 - is marked with a keyword apply a profile
56:27 - is applied to another package to make
56:29 - stereotypes in the profile available for
56:32 - this package this diagram shows the
56:35 - network telecommunications and software
56:37 - profiles that apply to the it company
56:41 - suite in this diagram we define the ejb
56:44 - profile as a package the bean itself
56:47 - expands from the component metamodel as
56:49 - an abstract bean an abstract bean can be
56:52 - instantiated as an entity bean or
56:55 - session bean ejb has two types of remote
56:58 - and home interfaces ejb also contains a
57:02 - special kind of an artifact called a jar
57:04 - file for storing a collection of java
57:07 - code use case diagrams are fairly simple
57:10 - they summarize some of the relationships
57:12 - between use cases actors and systems but
57:15 - they don't show the order in which steps
57:18 - to achieve the goals of each use case
57:20 - are taken they usually contain only a
57:22 - few simple figures therefore if you have
57:25 - more than 20 use cases you are probably
57:28 - using the diagram incorrectly there are
57:30 - many different uml diagrams that serve
57:33 - various purposes very often it is
57:35 - possible to describe the details of a
57:37 - system using other uml diagrams and link
57:41 - them together with use cases because use
57:43 - cases represent only the functional
57:45 - requirements of the system other
57:47 - requirements such as business rules
57:50 - quality of service requirements and
57:52 - implementation restrictions must be
57:54 - presented separately again with other
57:56 - uml diagrams use case diagrams are
57:59 - usually constructed at an early stage of
58:02 - development and are often used for the
58:04 - following purposes to specify a system
58:07 - context to capture system requirements
58:10 - to validate system architecture and to
58:13 - drive implementation and generate test
58:15 - cases and usually all this is developed
58:18 - by analysts together with domain experts
58:21 - so what does the use case diagram
58:23 - consists of
58:25 - actor in a broad sense one who interacts
58:28 - with the system and in most cases one
58:31 - who creates a use case actor is usually
58:34 - drawn as a little genderless humanoid
58:36 - with a name on it acta plays a role in
58:39 - the business process quite similar to
58:41 - the concept of a user but the user and
58:44 - this is important can play different
58:46 - roles for instance a professor can be a
58:49 - lecturer at the uni as well as a
58:51 - scientist in some kind of a research lab
58:54 - so in this case the professor plays two
58:56 - roles in two different systems actor
58:59 - triggers use cases in other words actors
59:03 - interaction with the system and how the
59:05 - system reacts to those interactions form
59:08 - the use case acta also has some
59:10 - expectations from interactions with the
59:13 - system if we expect one thing but get
59:15 - something completely different then the
59:17 - system function responsible for the use
59:20 - case may have been either improperly
59:22 - modeled or improperly implemented use
59:25 - case
59:26 - it is a system function or a process
59:28 - that can be either automatic or manual
59:31 - the name is usually constructed from a
59:33 - combination of verb and a noun or
59:35 - phrases that guide to do something each
59:39 - actor must be associated with a use case
59:42 - while some use cases might not be
59:44 - associated with actors use cases
59:46 - determine the expected behavior that is
59:49 - what should happen but they don't
59:51 - describe how to make this happen use
59:54 - cases can be indicated in text or
59:57 - graphic form for example in the form of
60:00 - a use case diagram the main point of
60:02 - modeling the use cases is to help us to
60:05 - design the system from the perspective
60:07 - of the end user by indicating all
60:10 - possible actions of the system that may
60:12 - be externally visible communication link
60:15 - actors can be connected with use cases
60:18 - via associations indicating that the
60:21 - actor and the use case communicate with
60:23 - each other through messages this is
60:25 - graphically shown with a solid line
60:28 - system boundaries for large and complex
60:30 - systems each module may be the boundary
60:33 - of the system but potentially it may be
60:35 - the entire system for instance if we'll
60:38 - have a look at an erp system each one of
60:41 - the modules such as personnel payroll or
60:43 - accounting can form a system boundary
60:46 - for use cases specific to each of these
60:49 - business functions the entire system can
60:51 - span through all of these modules
60:54 - displaying the overall boundary of the
60:56 - system use cases form various kinds of
60:59 - relationships the duty of defining the
61:02 - relationships between two use cases
61:04 - falls on the shoulders of software
61:06 - analysts of the use case diagram reusing
61:09 - an existing use case with other types of
61:11 - relationships reduces the overall effort
61:14 - required to develop a system let's look
61:17 - at the main relationships between use
61:19 - cases use case diagram illustrates a set
61:22 - of use cases for the system an example
61:25 - subjects and relationships between
61:27 - subjects and use cases extends indicates
61:31 - that for example use case invalid
61:33 - password may include under the
61:35 - conditions specified in the extension
61:38 - the behavior specified in the base use
61:40 - case login into account imagine that we
61:44 - have a use case that describes the
61:46 - interaction of an actor with an account
61:48 - for example the possibility of a login
61:51 - the basic use case is extended by two
61:54 - other use cases for example the already
61:56 - mentioned invalid password in which case
61:58 - the system will react in one way and on
62:01 - the contrary correct password in which
62:03 - case the system will most likely react
62:06 - differently extensions are important
62:08 - because they show additional
62:10 - functionality or system behavior this
62:12 - type of relationship is used to include
62:15 - optional behavior of the use case that
62:17 - extends the base use case in our example
62:20 - the student requests a schedule and this
62:23 - requires the extension of the base use
62:25 - case request schedule with the use case
62:28 - search when one use case is shown using
62:31 - the functionality of another use case
62:33 - the relationship between them is
62:35 - indicated by their include stereotype
62:38 - this type of relationship means that an
62:40 - instance of the base use case will
62:43 - include the behavior as specified in the
62:46 - child use case and it is indicated by a
62:49 - dashed arrow with its tip pointing to
62:52 - the child use case include adds
62:54 - additional functionality not specified
62:56 - in the base use case and is used to add
62:59 - general behavior from the included use
63:02 - case to the basis case in order to
63:04 - support the re-usage of the common
63:06 - behavior generalization or inheritance
63:09 - this is a parent-child relationship
63:11 - between use cases where the child use
63:13 - case is an extension of its parent use
63:16 - case generalization is depicted by a
63:19 - solid line with a triangular arrowhead
63:21 - pointing at the parent use case in this
63:24 - type of relationship the child use case
63:26 - inherits the behavior and semantic
63:29 - component from the parent use case a
63:31 - child use case may add or override the
63:34 - behavior of its parents in this example
63:37 - the parent use case search has two
63:39 - children search by lecturer and search
63:42 - by date this use case diagram depicts a
63:45 - car sale system and you can probably
63:47 - notice that even such a complicated
63:49 - system can be described with just 10 use
63:52 - cases here you can observe extensions
63:55 - inclusions and associations that connect
63:58 - actors with use cases now a couple of
64:01 - tips to model a use case diagram more
64:03 - efficiently in case you will decide to
64:05 - do so in your project always structure
64:07 - and organize a use case diagram from the
64:10 - perspective of actors use cases should
64:12 - start off simple and at the highest view
64:16 - possible only then we can move towards
64:18 - refinement and high digitalization use
64:21 - case diagrams are based on functionality
64:24 - and therefore should focus on what and
64:27 - not on the how activity diagram is
64:30 - another important uml behavioral diagram
64:33 - used to describe the dynamic aspects of
64:36 - a system activity diagram is essentially
64:38 - an extended version of a flowchart that
64:41 - models the transition from one activity
64:44 - to another and it shows how system
64:46 - activities are coordinated to provide a
64:48 - service that can be at a different level
64:51 - of abstraction first of all let's go
64:54 - over the basic notation of the elements
64:57 - in the diagram and move on to the
64:59 - examples initial node it starts the flow
65:02 - when the activity is called from the
65:04 - outside control flow it shows the
65:07 - sequence of execution of flow action a
65:10 - task to be performed decision node it
65:13 - represents a test condition to ensure
65:16 - that the control flow or object flow
65:18 - only goes down one path merge node it
65:21 - merges the various threads that were
65:24 - created after the decision node fork
65:26 - node splits behavior into a set of
65:30 - parallel or concurrent flows of
65:32 - activities join node it combines several
65:35 - parallel flows usually separated by a
65:38 - fork node object represents an object in
65:42 - a thread that is being acted upon this
65:45 - is an optional element of the diagram
65:47 - but in some cases it is necessary to
65:50 - show the object initiating the execution
65:53 - of activities or being created as a
65:56 - result of some early initiation activity
65:59 - final note it terminates all flows in an
66:02 - activity swim lane a way to group
66:05 - activities performed by the same actor
66:08 - on an activity diagram or simply group
66:10 - them in a single thread the following
66:13 - steps of the activity diagram describe
66:16 - the workflow for creating a document in
66:18 - a text editor open the text editor
66:22 - create a document save the document
66:24 - enter the text if graphics are necessary
66:28 - import them into the document if a table
66:31 - or a spreadsheet is necessary create the
66:33 - required table or spreadsheet and import
66:36 - it into the document save the document
66:39 - print the document exit the text editor
66:42 - seems pretty logical and simple now
66:44 - let's imagine that we were given a task
66:47 - to simulate the order processing
66:49 - workflow using an activity diagram the
66:51 - description of the process is as follows
66:54 - once the order is received the
66:56 - activities split into two parallel flows
66:59 - one fulfills and sends the order and the
67:02 - other process the invoices on the order
67:05 - processing side the delivery method is
67:07 - determined depending on the conditions
67:10 - of the order and transformed into action
67:13 - overnight delivery or regular delivery
67:16 - after sending the invoice for the goods
67:18 - the payment process side is going to
67:20 - receive payment hopefully finally to
67:22 - parallel flows join and finalize the
67:25 - order processing another example is the
67:28 - process for student enrolment in
67:30 - programming courses a student decides
67:33 - that he or she wants to become a super
67:35 - coding guru goes online discovers some
67:38 - online courses and commits to enroll
67:41 - then fills in the registration form on
67:43 - the company's website if the form is
67:45 - filled in correctly then the student is
67:48 - registered if not the student is
67:51 - notified to correct the errors and try
67:53 - again after that the student can check
67:56 - out our free introductory course after
67:58 - completing or skipping it the student
68:01 - can start our full-fledged course
68:03 - straight away finally the student needs
68:06 - to pay for the course success but there
68:08 - is another interesting way to add
68:10 - clarity to the diagram i suspect that
68:12 - the person who has invented the first
68:15 - activity diagram was probably a
68:17 - passionate swimmer because he or she
68:19 - introduced the concept of a swim lane as
68:22 - a part of the diagram swimlane is a way
68:24 - of grouping activities performed by the
68:27 - same actor in a single thread let's have
68:30 - a look at the activity diagram that
68:32 - describes the business process of
68:34 - onboarding a new client first of all we
68:37 - reach out to our potential client and
68:39 - arrange a meeting depending on whether
68:42 - there will be a meeting and whether it
68:43 - will be in our company's office or in
68:46 - the client's office we are preparing
68:48 - either a conference room or just take
68:51 - our laptop with us but regardless of
68:53 - where the meeting is going to take place
68:56 - we know that the client wants to meet
68:58 - with us after the meeting we'll normally
69:00 - send a follow-up letter to the client we
69:03 - just had a meeting with decision point
69:05 - if we have a deal then we prepare the
69:08 - contract and we also add the comment
69:11 - that there is another a separate
69:13 - activity diagram that reflects this
69:15 - process and needs to be followed we send
69:18 - the contract to the client and we get to
69:20 - the point where the process finalizes by
69:23 - the way we come here even if we didn't
69:25 - get the deal and here is the schema of
69:28 - the same process but this time we're
69:30 - using swimlane you can see that now it
69:32 - looks much more accurate because this
69:35 - time the process is divided into areas
69:37 - of responsibility for the salesperson
69:40 - who organizes the appointment as well as
69:43 - writes a follow-up letter to the client
69:45 - and the consultant who prepares the
69:47 - presentation for the client holds a
69:49 - meeting and crafts and sends the
69:51 - contract and a secretary whose task
69:54 - includes preparing the conference room
69:56 - in case the meeting takes place in our
69:59 - company's own office
70:01 - the behavior of an entity is not only a
70:03 - direct result of the input but it also
70:06 - depends on its preceding state uml state
70:09 - machine diagram or sometimes referred to
70:12 - simply as state diagram or state machine
70:15 - or state chart shows the various states
70:18 - of entities state machine diagrams can
70:20 - also show how an entity reacts to
70:23 - various events moving from one state to
70:26 - another and can be used to model the
70:28 - dynamic nature of the system state
70:31 - machine diagram is typically used to
70:33 - describe the state-dependent behavior of
70:35 - an object an object reacts differently
70:38 - to the same event depending on the state
70:41 - it is in although state diagrams are
70:44 - mainly applied to objects they can be
70:46 - applied to any element that changes
70:48 - behavior in relation to other objects
70:51 - such as actors use cases methods
70:54 - subsystems systems etc and they're
70:58 - usually used in conjunction with
71:00 - sequence diagrams state machine diagram
71:03 - describes all events as well as states
71:06 - and transitions for a single object a
71:09 - sequence diagram describes the events
71:11 - for a single interaction across all
71:13 - objects involved let's have a look at
71:15 - the notation used in the state machine
71:18 - diagrams state is a constraint or a
71:21 - situation in the life cycle of an object
71:24 - in which a constraint holds the object
71:26 - performs a certain activity or expects
71:29 - an event an event is a significant
71:32 - occurrence allocated in time and space
71:34 - in the context of states an event is the
71:38 - occurrence of a stimulus that can
71:40 - initiate a state transition guard
71:42 - condition is evaluated after the state
71:45 - transition trigger event occurs you can
71:48 - have several transitions from the same
71:50 - initial state and with the same event
71:53 - trigger if only the guard condition do
71:55 - not overlap a guard condition is
71:57 - evaluated only once for the transition
72:00 - at the time when the event occurs the
72:02 - boolean expression can refer to the
72:04 - state of the object a transition is a
72:08 - relationship between two states
72:10 - indicating that an object from the first
72:12 - state will enter the second state when
72:14 - the specified event occurs and the
72:17 - specified conditions are satisfied an
72:20 - action is an executable atomic
72:23 - computation that changes the state of
72:25 - the model or returns a value a state is
72:28 - a point in the life cycle of a model
72:31 - element that satisfies some condition
72:33 - where some specific action is performed
72:36 - or where some event is expected there
72:38 - are also two states with a specific
72:41 - predefined role first one is the initial
72:44 - state which is indicated by a solid
72:46 - circle a transition from the state will
72:48 - show the first real state and the final
72:52 - state which is shown as a concentric
72:55 - circle in case of an open loop state
72:57 - machine an object may terminate before
73:00 - the system terminates while a
73:02 - closed-loop state machine diagram does
73:04 - not have a final state if it is the case
73:08 - then the object lives until the entire
73:11 - system terminates events are occurrences
73:14 - that cause objects to transition from
73:16 - one state to another an event can be one
73:19 - of four types signal event corresponds
73:22 - to the arrival of an asynchronous
73:24 - message or signal call event corresponds
73:27 - to the arrival of a procedural call to
73:29 - an operation time event occurs after a
73:32 - specified time has elapsed and change
73:36 - event occurs whenever the specified
73:39 - condition is met transition lines depict
73:42 - movement from one state to another each
73:44 - transition line is marked with an event
73:47 - that triggers the transition considering
73:49 - a system as a collection of states and
73:51 - transitions between states is very
73:54 - useful for describing complex behavior
73:56 - understanding state transitions is an
73:58 - important part of system analysis and
74:01 - design transitions between states occur
74:04 - as follow the item is in its original
74:07 - state event occurs
74:09 - action is performed
74:11 - element enters target state multiple
74:14 - transitions occur either when different
74:17 - events lead to the termination of the
74:19 - state or when there are guard conditions
74:22 - on their transitions transition without
74:25 - an event an action is known as automatic
74:28 - transition action is an executable
74:31 - atomic computation which includes
74:33 - operation calls the creation or
74:35 - destruction of another object or sending
74:38 - of a signal to an object the action is
74:41 - associated with the transitions during
74:43 - which the action is not interruptable
74:46 - for example entry or exit this diagram
74:49 - shows the state of the my bk copy object
74:52 - from the book copy class entry action is
74:55 - any action that is executed whenever an
74:58 - object enters the specified state exit
75:02 - action is any action that is executed
75:05 - whenever an object leaves the state now
75:08 - let's talk about substates a simple
75:10 - state is a state that does not have a
75:13 - substructure a state that has substates
75:16 - or nested states is called a composite
75:18 - state substates can be nested at any
75:21 - level a nested state can have at most
75:24 - one initial state and one final state
75:27 - substates are used to simplify complex
75:30 - state diagrams showing that some states
75:32 - are possible only within a specific
75:34 - context state diagrams are often used
75:37 - for deriving test cases here is a list
75:40 - of possible test ideas idle state
75:42 - receives to hot event idle state
75:46 - receives to called event the calling
75:49 - startup state receives the compressor
75:51 - start event calling ready state receives
75:54 - a fun run event the calling run state
75:58 - receives ok event
76:00 - calling run state receives a failure
76:03 - event failure state receives error reset
76:06 - event heating state receives an ok event
76:09 - heating state receives a failure event
76:12 - nested states are necessary when the
76:15 - activity involves concurrent
76:17 - sub-activities in this diagram an
76:19 - auction was modeled with two concurrent
76:22 - substates bid processing and payment
76:25 - limit authorization in this example the
76:27 - state machine first entering the auction
76:30 - requires a fork at the start into two
76:33 - separate threads each substate has an
76:35 - exit state to mark the end of the thread
76:39 - if there is no abnormal exit which is
76:41 - cancellation or rejection then the exit
76:44 - from the composite state occurs when
76:46 - both substates exit unless it's
76:49 - specified otherwise when a transition
76:51 - enters a composite state the action of
76:54 - the nested state machine starts over
76:56 - again at the initial state unless the
76:59 - transition is aimed directly at the
77:01 - substate history states allow the state
77:03 - machine to re-enter the last sub-state
77:06 - that was active prior to leaving the
77:09 - composite state a history state is
77:11 - indicated by a circle with the letter h
77:14 - inside uml sequence diagrams are
77:17 - interaction diagrams that detail how
77:19 - operations are performed they capture
77:22 - the interaction between objects in the
77:24 - context of collaboration and show how
77:27 - elements interact over time and are
77:30 - organized with respect to object
77:32 - horizontally and time vertically the
77:35 - horizontal axis shows elements that
77:38 - participate in the interaction and they
77:41 - can appear in any order typically
77:43 - objects participating in an operation
77:46 - are listed from left to right according
77:48 - to when they participate in the message
77:51 - sequence the vertical axis shows the
77:54 - progressing time but note that time in
77:56 - the sequence diagram is denoted in the
77:58 - context of the execution order that is
78:02 - the sequence itself and not the actual
78:04 - duration there are timing diagrams just
78:06 - for that the vertical space in the
78:08 - interaction diagram has nothing to do
78:11 - with the duration of interaction as an
78:13 - example we will consider the hotel
78:16 - booking service the object that
78:18 - initiates the message sequence is the
78:20 - reservation window note that class and
78:23 - object diagrams are static model views
78:26 - but interaction diagrams are dynamic
78:28 - let's look at the basic notation of the
78:31 - sequence diagram actor a type of role
78:34 - played by the instance that interacts
78:37 - with the subject for example by
78:39 - exchanging signals and data actors
78:42 - represent the roles played by users
78:45 - external equipment or other actors actor
78:48 - does not necessarily represent a
78:51 - specific physical entity but simply a
78:54 - specific role of some entity a person
78:57 - can play the role of several different
78:59 - actors and conversely an actor may be
79:02 - represented by multiple different people
79:05 - lifeline he represents an individual
79:08 - participant in the interaction and
79:11 - displays the passage of time activation
79:14 - the thin rectangle on the lifeline
79:17 - indicates the period during which the
79:19 - element performs an operation top and
79:21 - bottom of the rectangle are aligned with
79:24 - the start and end of a specific function
79:27 - call message used to call procedures
79:30 - execute operations or designate
79:33 - individual nested control flows one end
79:35 - of the arrow always touches the control
79:38 - focus or lifeline of the client object
79:41 - that triggers the message the tip of the
79:43 - arrow points at the lifeline of the
79:45 - object that receives the message and
79:48 - takes action as a result at the same
79:50 - time this object also often receives a
79:53 - control focus becoming active the
79:56 - message can be synchronous depicted with
79:59 - a filled arrow when the client sends a
80:01 - message for example to the server and
80:04 - waits for a response before doing
80:06 - anything else and a synchronous depicted
80:09 - with a regular arrow when the client
80:11 - continues to perform operations without
80:14 - waiting for a response return message
80:16 - return message identifies the specific
80:19 - communication between the lifelines of
80:21 - an interaction and represents the
80:24 - transfer of information to the caller of
80:26 - the corresponding message self message a
80:29 - participant sends a message or command
80:32 - to itself create message in the case of
80:35 - creating a participant we draw an arrow
80:38 - pointing at the participant's rectangle
80:40 - if the participant will perform
80:42 - something immediately after his creation
80:44 - then straight after the participants a
80:46 - rectangle we will need to draw the
80:49 - activation destroy message the
80:51 - destruction of a participant is
80:53 - indicated by a large x with an arrow
80:56 - pointing from the participant that
80:58 - initiates the destruction towards the
81:01 - one that is going to be destroyed if the
81:04 - x is drawn at the end of the
81:06 - participant's lifeline and there is no
81:09 - arrow from another object then this
81:11 - means that the object deletes itself in
81:14 - other words self-destructs note or
81:17 - comment gives the ability to attach
81:19 - various nodes to elements a comment
81:22 - carries no semantic force but may
81:24 - contain useful information focus of
81:27 - control this is essentially any point in
81:30 - interaction where something happens and
81:32 - it is drawn as a tall thin rectangle on
81:36 - the lifeline since the control focus
81:38 - represents a period during which an
81:40 - element is performing some operation the
81:43 - top and bottom of the rectangle are
81:45 - aligned with the initiation and
81:47 - completion time respectively uml 2.0
81:51 - introduces sequence or interaction
81:53 - fragments a sequence fragment is
81:56 - represented as a box called a combined
81:59 - fragment that includes some of the
82:01 - interactions within the sequence diagram
82:04 - the fragment operator in the top left
82:06 - corner indicates the type of fragment
82:09 - which can be one of the following alt
82:12 - multiple alternative fragments only the
82:15 - one whose condition is true is executed
82:18 - message or group of messages is
82:21 - separated from each other by horizontal
82:23 - dashed line this type is used to
82:26 - simulate conditional statements like if
82:29 - then else and select statements case or
82:32 - switch opt the fragment is executed only
82:36 - if the provided condition is true and it
82:38 - is a call to an additional message or
82:41 - group of messages under some condition
82:44 - it is similar to the old fragment when
82:46 - the shorthand conditional statement if
82:49 - then is used
82:51 - parallel message processing message or
82:54 - group of messages processed in parallel
82:56 - are separated from each other by
82:58 - horizontal dashed lines loop as obvious
83:01 - as it looks it is used to simulate loops
83:04 - break early termination of message
83:07 - processing on condition used as a part
83:10 - of other fragments usually loop
83:13 - critical exclusively processed message
83:16 - or group of messages used as a part of
83:18 - other fragments usually par implies the
83:21 - suspension of any messages processing in
83:24 - a more general fragment for the duration
83:26 - of message processing inside the
83:28 - critical subfragment neck message or
83:32 - event generated as a result of the
83:34 - inability to process another received
83:37 - message for example if the time for
83:39 - entering the password has expired then
83:42 - instead of returning the password the
83:44 - timeout message will be generated assert
83:47 - it's when a message or group of messages
83:50 - executed after some condition has been
83:52 - pre-checked if the condition is negative
83:55 - then no message is sent in programming
83:58 - this technique is always used to
84:00 - localize errors strict sequential
84:03 - message handling consecutively processed
84:05 - messages are separated from each other
84:08 - by horizontal dashed line and processed
84:11 - strictly in turn from top to bottom sec
84:14 - non-strict sequential message processing
84:17 - messages are separated from each other
84:19 - by horizontal dashed lines and can be
84:21 - processed in any order except for
84:24 - messages received by one object ignore
84:27 - messages that can potentially occur in
84:30 - the fragment and that are listed after
84:32 - the word ignore in curly braces will be
84:35 - ignored ref a reference to a portion of
84:38 - the interaction defined elsewhere
84:41 - perhaps in a different diagram this
84:43 - element is similar to predefined
84:45 - processes in flowcharts or interaction
84:48 - overview diagrams sd used to surround
84:51 - the entire sequence diagram now that we
84:54 - know what's what let's use our knowledge
84:57 - to model a script that consists of some
85:00 - use cases in our case customer
85:02 - requirements are described as use cases
85:05 - that are formalized in the script as a
85:07 - reminder a use case is a set of
85:10 - interactions between external actors and
85:13 - a system to be more precise a
85:15 - specification of a sequence of actions
85:17 - including variants that a system or
85:20 - object can perform interacting with
85:22 - actors of the system a script is a
85:25 - thread that describes a sequence of
85:27 - events that occur during one particular
85:30 - execution of a system that is often
85:33 - represented by sequence diagram for
85:35 - example in this sequence diagram there
85:37 - are two scenarios the main one and the
85:40 - alternative one following the main
85:42 - scenario the buyer enters the author's
85:45 - name in a search box and clicks the
85:48 - search button the system validates the
85:50 - search query if the validation passes
85:53 - the system searches the catalog for the
85:55 - author's books when the search is
85:57 - complete the system displays its results
86:00 - an alternative scenario is rather short
86:03 - if the buyer did not enter the author's
86:05 - name but clicked on the search button
86:07 - then the system displays an error
86:10 - message similar to sequence diagrams
86:12 - communication diagrams are subtypes of
86:15 - interaction diagrams and show how
86:18 - objects interact with each other
86:20 - communication diagrams or as they were
86:22 - called prior to uml 2.0 collaboration
86:25 - diagrams essentially are the extensions
86:28 - of object diagrams that show these
86:30 - objects along with the messages that
86:33 - objects sent to each other the main
86:35 - purpose of communication diagrams is
86:38 - model the messages passing between
86:40 - objects or roles that deliver the
86:42 - functionalities of use cases and
86:45 - operations model mechanisms within the
86:48 - architectural design of the system
86:50 - capture interactions that show the past
86:53 - messages between objects and roles in
86:55 - collaborations model alternative
86:58 - scenarios within use cases or operations
87:01 - that involve the collaboration of
87:03 - various objects and interactions and
87:05 - support for identification of objects
87:08 - hands classes and their attributes in
87:11 - this case message parameters and
87:13 - operations messages that are involved in
87:17 - use cases let's analyze a simple example
87:20 - of a communication diagram where objects
87:23 - for example actors in use cases are
87:25 - drawn as rectangles the objects are
87:28 - object 1 object
87:31 - object n-1 and so on until object m
87:35 - messages passed between these objects
87:37 - are represented by a labeled arrows that
87:40 - start with the sending object or actor
87:42 - and with the receiving object examples
87:45 - of messages passed between objects are
87:47 - marked as
87:48 - message 1 message 2 message 3 etc where
87:53 - the numeric prefix of the message name
87:55 - indicates its order in sequence object 1
87:59 - first sends message 1 to object 2.
88:02 - object 2 in turn sends object n minus 1
88:06 - message 2 and so on messages that
88:09 - objects send to themselves are referred
88:11 - to as loops for example message five or
88:15 - here is another example hotel room
88:17 - reservations each message in the diagram
88:20 - has a sequence number the top level
88:22 - message is number one messages sent
88:25 - during the same call have the same
88:27 - decimal prefix but surfaces 1 2 etc
88:31 - depending on when they occur
88:33 - communication and sequence diagrams are
88:35 - similar they are semantically equivalent
88:37 - it means they represent the same
88:40 - information and we can turn a
88:42 - communication diagram into a sequence
88:44 - diagram and vice versa the main
88:46 - difference between them is that in the
88:48 - communication diagram the elements are
88:51 - organized according to space and in the
88:54 - sequence diagram according to time so in
88:56 - which case we would want to use a
88:58 - communication diagram instead of a
89:00 - sequence diagram first of all
89:01 - communication diagrams are very useful
89:04 - for visualizing relationships between
89:06 - objects that collaborate with each other
89:08 - to perform a specific task this is
89:11 - difficult to determine from a sequence
89:13 - diagram in addition communication
89:15 - diagram can also help to determine the
89:17 - accuracy of a static model for example
89:20 - class diagram here is a real world
89:22 - example where we can compare both
89:24 - diagrams in action the process of
89:26 - returning a book to the library imagine
89:29 - a student brings a book to the library
89:32 - and a librarian brings up records to
89:35 - check whether the book was returned on
89:37 - time and whether the borrowing period
89:39 - was exceeded in that case there may be a
89:42 - fine in essence both diagrams contain
89:45 - objects and messages and it becomes
89:47 - obvious that it is much easier to
89:49 - determine the time ordering of messages
89:52 - by looking at the sequence diagram but
89:54 - it's easier to see the relationships
89:56 - between objects by looking at the
89:59 - communication diagram objects involved
90:01 - in communication are of two types
90:04 - supplier and client supplier objects are
90:07 - objects that supply the method that is
90:09 - being called and therefore receive the
90:11 - message client objects call methods on
90:14 - supplier objects and therefore send
90:17 - messages connectors drawn between
90:19 - objects in communication diagram are
90:21 - links that allow to establish
90:24 - relationships between objects and show
90:27 - the ability of objects to send messages
90:29 - to each other if an object sends message
90:31 - to itself then such a link is
90:34 - represented as a loop icon the loop can
90:37 - be seen on both the ui object and the
90:40 - transaction object messages in
90:42 - communication diagrams are shown as
90:44 - arrows pointing from the client object
90:47 - to the supplier object typically
90:49 - messages represent a client invoking an
90:52 - operation on a supplier object message
90:55 - icons have one or several messages
90:57 - associated with them messages are
90:59 - composed of message text prefixed with a
91:02 - sequence number this sequence number
91:04 - indicates the time ordering of the
91:07 - message for example in this diagram we
91:09 - can follow the sequence numbers to
91:11 - determine the order of messages between
91:14 - objects the first message in the
91:16 - communication diagram is always numbered
91:19 - one the second two and so on we can
91:21 - indicate that the message is nested
91:24 - within the parent message by adding a
91:26 - decimal point and additional digit to
91:28 - the parent's ordinal for example the
91:31 - message carl amt can borrow that is
91:34 - calculate for how long the book can be
91:36 - borrowed is the first nested message in
91:39 - the inquire borrower literally request
91:42 - the details of a person who borrows and
91:45 - is given a serial number 1.1 the second
91:48 - nested message in inquire borrower is
91:51 - display invalid msg that is display an
91:54 - error message therefore is given a
91:56 - sequence number 1.2 let's look at the
91:59 - example of transition from a sequence
92:01 - diagram to a communication diagram the
92:04 - client creates a transaction and
92:06 - performs an operation with messages a d
92:10 - and o after that another two
92:12 - transactions put values of p1 p2 p3 and
92:16 - p4 to the database more after that the
92:19 - client receives a message that the
92:22 - transaction was completed and finally
92:24 - the transaction is destroyed and now the
92:27 - same sequence of operations only on the
92:30 - communication diagram the client creates
92:32 - a transaction performs an operation with
92:35 - messages a d and o next to transactions
92:38 - put values of p1 p2 p3 p4 to the
92:42 - database and after that the client
92:44 - receives a message that the transaction
92:47 - was completed finally the transaction is
92:50 - destroyed there are a few things to
92:52 - watch out for control focus
92:54 - also known as execution occurrence or
92:56 - activation shown as a tall thin
92:59 - rectangle denoting the period during
93:01 - which an element performs an operation
93:04 - the top and bottom of the rectangle
93:06 - match the start time and end time
93:09 - respectively in a communication diagram
93:11 - the control focus is explicit and can
93:14 - thus be represented by the message nest
93:17 - numbering finally i would like to show a
93:19 - communication diagram in a format that
93:22 - is also used in some occasions and is
93:24 - called the reliability diagram format we
93:27 - can model objects and instances of
93:29 - actors in communication diagrams along
93:32 - with links and messages describing how
93:35 - they are related and how they interact
93:37 - the deposit element in the diagram
93:39 - describing the recycling machine system
93:42 - describes what happens to the particular
93:45 - objects in terms of how the objects
93:47 - interact send messages to each other and
93:50 - so on you can create a communication
93:52 - diagram for each variant of the use case
93:54 - flow events uml interaction overview
93:58 - diagram illustrates the flow of control
94:01 - of the interactions with the notes that
94:03 - consist of interactions or interaction
94:06 - occurrences in other words it is a high
94:08 - level abstraction that illustrates the
94:11 - flow of activity between diagrams
94:13 - basically overview interaction diagram
94:16 - is like an activity diagram in which the
94:18 - elements were replaced by small sequence
94:21 - diagrams or is like a sequence diagram
94:24 - broken down by the markup of the
94:26 - activity diagram that illustrates the
94:29 - flow of control here are the main nodes
94:31 - used in the diagram initial node
94:34 - decision node
94:35 - fork node
94:36 - join node and activity final node there
94:40 - are several node types such as
94:42 - interaction diagram marked as sd
94:45 - sequence diagram of any kind it may
94:48 - appear in line as an activity invocation
94:51 - reference to the interaction marked as
94:54 - ref also called interaction use with its
94:57 - help large and complex sequence diagrams
95:00 - can be greatly simplified it is also
95:02 - common to reuse some interaction between
95:05 - several other interactions so let's
95:07 - analyze the diagram step by step the
95:10 - diagram shows an example of an
95:12 - onboarding process the employee must
95:15 - first accept or reject the offer note
95:18 - that second option does not contribute
95:20 - to the onboarding process after
95:22 - accepting the offer the employee must
95:25 - register with hr and apply for a company
95:28 - car after both actions were completed
95:30 - the employee must actually begin to work
95:33 - for example on board new customers if
95:35 - the employee doesn't do that after a
95:38 - certain probation period the contract
95:40 - gets terminated here are a few more
95:43 - examples to examine here is how we can
95:45 - depict the interaction with the code
95:47 - lock on the door using the interaction
95:50 - of view diagram interaction use and the
95:53 - code first appears with the argument
95:55 - invalid code then the interaction
95:57 - follows indicate that the code is
95:59 - entered incorrectly which is displayed
96:02 - on the diagram using the built-in
96:04 - fragment from the sequence diagram the
96:06 - following is a decision node with a
96:08 - valid pin code interaction constraint
96:11 - this means that only if the code is
96:13 - entered correctly the grant access
96:16 - interaction follows this is followed by
96:18 - an interaction use let's call it door
96:20 - opening the door is now unlocked end of
96:23 - story but if the code was entered
96:25 - incorrectly nothing will happen however
96:28 - we'll also be redirected to the activity
96:31 - final note and here is a simple hotel
96:34 - room reservation scheme however this
96:36 - time we utilize only the interaction use
96:39 - notes to provide a high level of
96:41 - abstraction register the website select
96:43 - available room type and dates there are
96:46 - no rooms available for these dates we
96:48 - are redirected back to where we can
96:50 - choose other rooms or dates if all goes
96:53 - well then we proceed to checkout if
96:56 - everything is fine there as well the
96:57 - room is booked of course this is a
97:00 - primitive example and we would
97:01 - potentially append the diagram with many
97:04 - more additional interactions but it
97:06 - still gives you a sense of how the
97:08 - interaction of a view diagram works
97:10 - timing diagrams are uml interaction
97:13 - diagrams that are used when the main
97:15 - purpose of a diagram is to indicate the
97:18 - intervals between state changes of
97:20 - various objects timing diagrams focus on
97:24 - conditions changing within and among
97:27 - lifelines along the time axis and
97:29 - describe the behavior of both individual
97:32 - classifiers and their interactions
97:34 - focusing attention on time of events
97:37 - causing changes in the modeled
97:39 - conditions of the lifelines transition
97:42 - from one state to another is a change in
97:45 - the level of the lifeline during the
97:47 - period of time when the object is in a
97:49 - given state the timeline runs parallel
97:52 - to that state a change in state is
97:54 - displayed as a vertical change from one
97:57 - level to another the reason for the
97:59 - change as in the case of a state or
98:02 - sequence diagram is the receipt of a
98:05 - message or request of an event that
98:07 - causes a change the so-called stimulus
98:10 - or it could be that the change of the
98:12 - system state occurred by itself
98:14 - triggered by the passage of time this
98:17 - diagram shows alternative notations of
98:19 - the uml timeline diagram in particular
98:22 - the state of the object depicted between
98:25 - two horizontal lines that intersect each
98:28 - other on each change of the state the
98:30 - lifeline is an element that represents
98:33 - an individual participant in the
98:35 - interaction usually it is horizontally
98:38 - aligned to be read from left to right
98:41 - multiple lifelines may be stacked within
98:44 - the same frame to model the interaction
98:46 - between them the state timeline is a set
98:49 - of valid states of elements and time
98:52 - states are stacked on the left margin of
98:55 - the lifeline from top to bottom it is
98:57 - possible to stack several lifelines of
99:00 - different objects in the same timing
99:02 - diagram placing one lifeline above the
99:06 - other messages sent from one object to
99:08 - another can be displayed using simple
99:11 - arrows the stats and the end points of
99:14 - each arrow indicate when each message
99:17 - was sent and when it was received the
99:19 - state lifeline indicates the change of
99:22 - state of an element over time the x-axis
99:26 - displays elapsed time in any selected
99:29 - units while the y-axis is marked with a
99:32 - list of states the value lifeline
99:34 - illustrates the change of elements of
99:36 - value over time the x-axis displays
99:40 - elapsed time in any selected units
99:43 - similar to the state lifeline the value
99:45 - is written between a pair of horizontal
99:48 - lines that intersect each time the value
99:50 - changes we can use the length of the
99:53 - timeline to show how long the object
99:55 - remains in a certain state reading it
99:58 - from left to right in this diagram the
100:00 - login event is received after three
100:03 - units of time from the start of the
100:05 - sequence to show relative times we can
100:07 - mark a specific instance in time using a
100:11 - variable name this diagram marks the
100:13 - time when sendmail event was received
100:16 - using the letter t we can use a relative
100:19 - timestamps in constraints to indicate
100:22 - that a message must be received within a
100:25 - certain amount of time state and value
100:28 - lifelines can be stacked together in any
100:30 - combination messages can be transmitted
100:33 - from one lifeline to another each state
100:36 - or value transition can have a certain
100:39 - time limited event which indicates when
100:42 - it should happen and a duration
100:44 - constraint that indicates how long the
100:46 - object will be in that state or will be
100:49 - affected by the certain values here is
100:51 - an example where we simulate a carpark
100:54 - system using this sequence diagram it
100:57 - shows the consistency of the model
100:59 - between two interaction diagrams the
101:02 - timing diagram must always match the
101:05 - sequence diagram and state diagram in
101:07 - order to achieve this we can attach
101:10 - states to the lifeline of each object in
101:12 - the sequence diagram in this case we can
101:15 - derive the corresponding timing diagram
101:17 - much easier by checking the messages
101:20 - sent between objects against the states
101:22 - attached to the lifeline so here is the
101:25 - same car park system presented in the
101:28 - form of a timing diagram