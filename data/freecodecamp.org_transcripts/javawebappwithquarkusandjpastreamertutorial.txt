00:00 - in this course you'll learn how to use
00:01 - corus and jpa streamer to build a rest
00:04 - web application corus is an open source
00:07 - framework tailored for Java optimized
00:10 - for building Speedy Cloud native
00:12 - microservices and serverless
00:13 - applications especially in containerized
00:16 - environments like kubernetes jpa
00:18 - streamer on the other hand is a Java
00:20 - library that simplifies database
00:22 - interactions by allowing jpa entities to
00:25 - harness the expressiveness of java
00:27 - stream operations when combined corus's
00:30 - rapid startup and minimal memory
00:32 - footprint works well with jpa streamer
00:35 - intuitive database quering offering
00:38 - developers a seamless efficient and
00:40 - cohesive environment Julia gustofson
00:42 - teaches this course she is an
00:44 - experienced Java developer with speed
00:46 - minint corus provided a grant to make
00:49 - this course possible hello and welcome
00:51 - again to the free code Camp YouTube
00:53 - channel my name is Julia and I'm a Java
00:56 - developer and today I'm very excited to
00:58 - be introducing you to two fairly recent
01:00 - additions to the Java ecosystem corcus
01:03 - and jpa
01:05 - streamer so the reason I pair these two
01:07 - tools up for this tutorial is because I
01:09 - believe that they have the potential of
01:11 - changing the way you perceive Java
01:13 - development and really my hope is for
01:16 - this tutorial that at the end of it you
01:18 - will approach Java development with much
01:20 - more excitement than before so the
01:23 - reason I'm saying this is because I feel
01:25 - like in recent years the Java language
01:27 - has felt a bit outdated in comparison to
01:29 - something like type script or python
01:31 - which comes with these environments
01:32 - where you can recompile your code really
01:33 - quickly whenever you make a small change
01:36 - and the nature of the language being
01:38 - objectoriented and types safe sometimes
01:40 - got in the way of making it like
01:42 - intuitive to write and read because you
01:44 - have to create a lot of objects and
01:45 - things that may seem unintuitive at the
01:47 - time and then also of course Java
01:50 - applications are known to be slow to
01:52 - start and have a large memory footprint
01:54 - and that sometimes makes them unsuitable
01:56 - for cloud
01:57 - deployment but quirkus is really here to
02:00 - redraw the map for us because it's an
02:02 - open source Java development platform
02:04 - that gives you a lot of value at first
02:06 - go so unlike many other platforms
02:08 - quirkus doesn't come with a steep
02:10 - learning curve you can really write your
02:13 - applications as normal but it's the
02:15 - build process which is completely
02:17 - reimagine and that means you're going to
02:19 - be able to restart your application in a
02:21 - split second whenever you're developing
02:23 - using the quirkus dev mode and you're
02:25 - also going to be able to perform
02:27 - continuous testing without the tests
02:29 - getting in the way your productivity and
02:32 - finally once you're ready for deployment
02:34 - the native build capabilities of corkus
02:37 - is going to boost your performance
02:39 - significantly both in terms of the
02:40 - startup time and it's going to reduce
02:42 - your memory footprint by a lot to show
02:45 - off cor is I'm going to be taking you
02:46 - along while developing a rest web
02:48 - application from scratch on the corcus
02:50 - platform and that's going to be reading
02:52 - data from a film database using
02:54 - hibernate and jpa streamer so JP
02:56 - streamer is the second component that I
02:58 - would like to introduce you to today
02:59 - today and that's because it addresses
03:01 - the other problem that I mentioned about
03:03 - Java being sometimes wordy and
03:06 - unintuitive so basically JP streer is an
03:08 - extension for hybernate that doesn't
03:10 - impact how you would use hybernate
03:11 - normally but it does extend the API with
03:15 - the capability to express your queries
03:17 - as Java streams so what that means is
03:19 - that you can use the stream API as a way
03:22 - of expressing your SQL query and upon
03:25 - execution it will be automatically
03:26 - translated to SQL to ensure that it's
03:28 - still efficiently executed in the
03:30 - database rather than in the
03:32 - jbm during development I'm going to be
03:34 - showing you all the relevant features of
03:36 - both corkus and JP streamer and at the
03:39 - end of it all I'm sure you're going to
03:40 - have enough knowledge to go out and
03:42 - utilize these tools on your own if you
03:44 - enjoy them as much as I do but before we
03:46 - get into coding I want to provide you
03:48 - with a little bit more background on
03:49 - what makes quirkus and JP streamers such
03:52 - good
03:55 - libraries so quirkus was initiated by
03:58 - red hat but being being an open source
04:00 - project it has grown a lot since with
04:03 - contributions from various individuals
04:04 - and other
04:05 - organizations I often see described as a
04:08 - cuttingedge cloud native framework
04:10 - that's tailored to the needs of both
04:12 - Java and cotlin applications but why is
04:15 - this important today well its mission is
04:18 - really to tackle some of the challenges
04:19 - that have shadowed Java in recent years
04:22 - because Java has struggled a bit to fit
04:23 - into the modern Cloud environments and
04:26 - that is not to say that Java isn't a
04:28 - great development language it's just a
04:31 - result of the fact that at the time Java
04:33 - came about there was different
04:34 - priorities you were used to building
04:36 - monoliths that would just deployed and
04:38 - ran for extended periods of time but
04:41 - then came the cloud environments and now
04:43 - we need to be much more concerned with
04:44 - the amount of resources for application
04:46 - consumes otherwise it's going to get
04:47 - really expensive and if we consider
04:50 - serverless we need to be really
04:52 - concerned with the startup times because
04:54 - we don't want our clients to wait
04:55 - several seconds for application to
04:58 - respond but the Great thing is that with
05:00 - corkus you can actually say goodbye to
05:02 - Long application startup periods the
05:04 - high memory consumption and to some
05:06 - extent even the rather slow development
05:09 - experience in my opinion now is also a
05:11 - really good time to learn corkus because
05:13 - as it's been maturing for the past few
05:15 - years all of the major Java libraries
05:17 - has become available on the corkus
05:19 - platform so that means you can use
05:21 - hibernate spring junit and all of those
05:23 - libraries just like you're used to doing
05:26 - for some developers the lower startup
05:28 - times and the model application
05:30 - footprint is definitely going to be
05:31 - perceived as the main perks of corkus
05:34 - but for me personally the biggest
05:36 - advantage of corkus is really the
05:38 - life-changing developer mode I've always
05:40 - envied no developers who can rebuild
05:42 - their applications in a split second
05:44 - when they're making these small
05:45 - incremental changes to an app so when I
05:47 - first tried the quirkus live reload
05:49 - feature I was just thrilled to learn
05:51 - that Java developers can also enjoy such
05:52 - a fluid development experience and as
05:55 - you'll see later on all the changes that
05:57 - I apply to my applications are reflected
05:59 - immediately and I don't ever have to
06:01 - wait for the application to make a full
06:03 - restart before I can validate that
06:04 - things are
06:05 - working so as part of the demonstration
06:08 - of the corcus platform I also wanted to
06:10 - show you a library that you may not have
06:12 - heard of before but that is really
06:14 - useful in the context of database
06:17 - applications and it's called jpa
06:19 - streamer like corkus jpa streamer is
06:22 - also an open source project but this one
06:23 - was initiated by per mbor who is
06:25 - actually working full-time as an oracle
06:27 - core Java developer today and this is a
06:30 - library that simplifies database access
06:32 - in Java applications that uses the Java
06:34 - persistence API or jpa so it can pretty
06:38 - much be viewed as a lightweight
06:39 - hibernate extension that will extend the
06:41 - API of your existing application to
06:43 - include this really expressive and
06:45 - typesafe stream query API that makes the
06:48 - coding experience much less error prone
06:50 - and it will help increase your
06:52 - productivity so to better understand
06:54 - what JP streamer is doing I'm going to
06:56 - show you this example because this is a
06:58 - stream query that will fetch 10 films
07:00 - from a database each starting with a
07:02 - letter a and are at least 1 hour long
07:05 - can you see how simple that is to
07:08 - read so critics will say that this is
07:11 - going to be the same as using
07:12 - hibernate's built-in method get result
07:14 - stream and then just apply the same
07:16 - stream pipeline but there is actually a
07:18 - fundamental difference in working with
07:20 - streams in the current hibernate API and
07:22 - working with jpa streamer because if you
07:24 - call get res stream to stream an entire
07:27 - table you're going to materialize every
07:29 - entity and that can get very expensive
07:31 - if your table is big but with JB
07:34 - streamer your pipeline is going to be
07:35 - translated to an hql query and that
07:37 - ensures that only the resulting entities
07:39 - are materialized as if you were using
07:41 - SQL all along so hopefully this made you
07:44 - inspired to follow along and learn
07:46 - quirkus and JP streamer in the upcoming
07:49 - tutorial so to follow along you're going
07:51 - to need a basic understanding of how to
07:54 - use Java and Java streams and I'm also
07:57 - going to expect that you have worked
07:58 - with SQL and some kind of jpa Provider
08:01 - such as hibernate before so that you
08:03 - understand how to set up the jpa
08:04 - entities because I'm not going to be
08:06 - going over hibernate in any
08:10 - detail your Dev environment also needs
08:12 - to comply with these requirements so
08:14 - we're working with Java 11 that's the
08:16 - earliest release of java that's
08:18 - compatible with quirkus and jpa streamer
08:20 - you're also going to need some kind of
08:22 - build tool in my case I'm using a recent
08:24 - version of Maven so that's going to be
08:26 - Maven
08:27 - 391 but if you're more comfortable
08:29 - working with Gradle I'm sure you're
08:30 - going to be able to adapt many of the
08:32 - steps to Gradle instead the same goes
08:34 - for your IDE you're free to choose
08:36 - whatever you like of course but I'm
08:37 - working with intellig and it's going to
08:39 - be easier to follow along if you're
08:40 - using intellig as well the final
08:44 - requirement is Docker because I'm going
08:45 - to be using a sample database that's
08:47 - available as a Docker image Docker is
08:50 - also going to be used for the native
08:52 - compilation Step at the end but you can
08:54 - also choose to install grow VM locally
08:57 - rather than using the grvm
09:00 - distribution so with that covered we're
09:03 - going to start building our applications
09:05 - so next up is the project
09:07 - setup once you have your jdk and IDE
09:10 - ready it's time to create a new corcus
09:13 - project and there are a couple ways you
09:15 - can do this either using the corcus
09:17 - command line interface leveraging your
09:19 - ide's corcus integration or using the
09:21 - corcus project
09:23 - configurator to keep the number of
09:25 - installations down to minimum I will
09:27 - refrain from using the corkus command
09:28 - line inter face in this video although I
09:30 - do recommend that you check it out if
09:32 - you wish to continue using quirkus in
09:34 - future
09:35 - projects configuring the project in
09:37 - intell has worked really well for me in
09:39 - the past but if you want to make sure
09:40 - that you find all available corkus
09:42 - extensions I recommend that you use the
09:44 - corus project configurator as I will do
09:47 - here the project configurator is
09:49 - available on the corkus website so
09:52 - that's corkus doio and you find it under
09:54 - the start coding tab on top here so this
09:58 - page is going to going to allow us to
10:00 - configure our project and that means
10:02 - naming it selecting what build tool to
10:04 - use what Java version and also adding in
10:06 - any dependencies that we need for the
10:09 - application we also need to select a
10:11 - corcus version and in this case I would
10:13 - be sticking with the latest one which is
10:15 - 3.2 3.2 also happens to be a long-term
10:19 - supported release which means it's going
10:20 - to be maintained for a long time since
10:23 - we're using hibernate for the database
10:25 - integration I also just want to note
10:27 - that quirkus 3 is compatible with
10:29 - hibernate 6 and later for anyone
10:32 - starting out fresh that's not really
10:34 - going to have any implications I'm
10:35 - simply saying that because there may be
10:37 - someone watching who has hibernate code
10:39 - in an existing project that they wish to
10:41 - reuse and in that case just pay
10:43 - attention to any breaking changes
10:44 - between hibernate 5 and six when you
10:47 - import that
10:48 - code moving ahead I'm going to give my
10:52 - project a group ID of org. freec cod
10:54 - camp and an artifact ID of corkus
10:58 - tutorial
11:00 - as my build tool I'm going to stick with
11:01 - Maven simply because that's what I'm
11:03 - most used to working with but you can
11:05 - also choose grle for example if that's
11:08 - what you prefer looking at the other
11:10 - options here I'm going to stick with the
11:12 - version number and I'll be selecting
11:15 - Java 17 as my Java version I'm also
11:19 - deselecting the starter code option
11:22 - simply because I know what application
11:23 - I'm going to build and I don't need a
11:25 - template for it otherwise if you select
11:27 - a dependency that has starter code that
11:29 - will be included in the zip file that
11:31 - you download so now we can go ahead and
11:34 - add in our dependencies and as the
11:36 - application will be using a mySQL
11:38 - database I'm going to start off by
11:40 - adding the jdbc driver for
11:43 - MySQL next I'm going to go ahead and add
11:45 - our GP provider which in this case is
11:47 - hibernate with a flavor of panach and
11:50 - panach is corcus specific so therefore
11:54 - if you're a hybernate user but never
11:56 - heard of panage you should just know
11:58 - that you can still write your hibernate
12:00 - applications just the same way you would
12:02 - in a regular job application but panach
12:05 - comes with some really neat
12:06 - features so next we're going to need the
12:09 - rest EC Jackson dependency as that will
12:11 - allow us to create rest end points very
12:15 - quickly and let's not forget about jpa
12:17 - streamer that I introduced in the
12:18 - beginning of the video which is going to
12:20 - allow us to express our queries as Java
12:22 - streams and finally I'm adding in small
12:25 - R open API which is going to allow us to
12:27 - use Swagger to test our endpoints
12:30 - so now that I have all the dependencies
12:31 - I'll just go ahead and click generate
12:33 - your application to download a project
12:36 - zip
12:37 - folder then I'll just go ahead and unzip
12:40 - that folder to reveal the contents and
12:42 - as you can tell it contains the palom
12:44 - XML which indicates that this is a maven
12:46 - project so I'll be opening it up in
12:50 - intellig and I'm just going to start by
12:52 - expanding my window to full size and
12:54 - then I'm selecting
12:56 - open and I'm locating the pom XML file
13:00 - because in my experience this works well
13:02 - when importing Maven projects so I'll
13:04 - open that as a project and intell will
13:07 - automatically add it as a maven project
13:09 - for me so the first thing you'll see is
13:12 - a read me which contains some
13:14 - instructions on how to run your
13:16 - application with corkus but as we're
13:18 - going through this together I'm not
13:20 - going to show you that now instead we're
13:22 - going to look in the sources directory
13:25 - and you can tell that there's an empty
13:26 - Java
13:27 - folder and if we peek into the pom XML
13:30 - file we find the dependencies I just
13:33 - selected including corcus itself
13:35 - hibernate with panach jpa streamer and
13:38 - the jtbc driver at the bottom here you
13:40 - can also see that the testing Library
13:42 - junit 5 was automatically added for us
13:44 - in the testing scope so our project is
13:47 - mostly set up but we're missing a very
13:49 - important piece of infrastructure which
13:50 - is the
13:52 - database so when I play around with new
13:55 - technologies I often find it useful to
13:57 - use something like a sample database
13:58 - base just to get up and running quickly
14:01 - and in this case I'm going to be using
14:02 - the seila database which is provided for
14:05 - free by Oracle the Aila database doesn't
14:08 - have a very descriptive name but it
14:10 - models an old-fashioned video rental
14:12 - store like the ones where you would
14:13 - actually bring your film home on tape or
14:16 - DVD and as you can expect most Central
14:18 - to the database in this case is the film
14:21 - table but there are various other tables
14:23 - that support the overall business of
14:25 - renting out films such as inventory
14:27 - customer and payment
14:29 - for this application though I'm going to
14:30 - be focusing on films and the actors that
14:33 - star in those films almost as if we were
14:35 - building an IMDb like service therefore
14:39 - our job application is also going to
14:40 - have to model the actor table and the
14:42 - film actor table which represents the
14:44 - many to Mena relationships between films
14:46 - and actors because a film can star many
14:49 - actors and an actor can star in many
14:53 - films the database is available as a
14:56 - Docker image on Docker Hub so I'm just
14:58 - going to be using Docker run to download
15:01 - and spin up the image in a container as
15:03 - I've used this database many times
15:05 - before I happen to know that it was
15:07 - actually built for Linux amd64
15:09 - infrastructure and I'm currently on an
15:11 - M1 Mac and that means that Docker will
15:13 - by default go out looking on Docker hub
15:16 - for images that were built for my
15:18 - platform meaning the
15:19 - M1 in my experience the image still
15:22 - works fine on the M1 I just need to
15:24 - force Docker to accept Linux images by
15:26 - adding the platform flag and specify the
15:28 - Linux amd64
15:30 - platform the D flag will detach this
15:33 - process from my terminal once it's up
15:35 - and running and I will publish my
15:37 - runting service on Port 3306 here making
15:40 - a mapping between the internal and
15:42 - external
15:43 - ports I will name the running container
15:47 - seila and finally I specify the name of
15:49 - the image that I want to fetch namely
15:51 - rest SQL MySQL sakila so running this
15:55 - command you can see that the image is
15:57 - being downloaded as a wasn't located
15:59 - locally and then finally once the image
16:02 - is pulled the container is started great
16:07 - if you have Docker desktop installed you
16:09 - can also try opening up the app and
16:11 - looking under containers to just confirm
16:14 - that the container seems to be up and
16:15 - running and in this case our cila
16:17 - container is there and it's looking
16:19 - healthy before we go on I usually think
16:22 - it's helpful to kind of inspect what's
16:24 - in the database so I'm using intell to
16:26 - connect to it selecting data source and
16:29 - MySQL as that's our database
16:32 - type and this will pop up this dialogue
16:35 - and I just need a few settings firstly
16:37 - the username is root and the password is
16:39 - sakila the name of the database and I'm
16:41 - also specifying here in the connection
16:44 - string that the name is sakila and the
16:46 - port is 3306 which is
16:50 - correct let's see if it connects yeah
16:53 - perfect it found it so then let's look
16:57 - at the contents H okay so this often
17:00 - happens to me in and what usually works
17:02 - is just making a
17:04 - refresh of the databased content so yeah
17:08 - perfect that
17:09 - worked opening that up we can see that
17:12 - we have 23 tables and that includes of
17:15 - course the film table which is Central
17:16 - to our app that has the film ID as its
17:21 - primary key and a number of other values
17:23 - associated with films and I'm just going
17:25 - to open that up real quick because this
17:26 - database contains totally made of movies
17:28 - and it seems like the person who came up
17:30 - with these descriptions had quite a fun
17:32 - time take this one for example Fair
17:34 - Prejudice the description reads a
17:37 - fancyful documentary we have a frisbey
17:38 - and a lumberjack who must chase a monkey
17:40 - in a shark tank well this would have
17:43 - been easy with chat TPT but I'm pretty
17:45 - sure that this database far predates
17:47 - it so if we also have a look into the
17:50 - acture table you'll see that we find
17:53 - lots more of these half madeup names how
17:56 - about zero cage
17:59 - well and apart from first and last name
18:01 - we have an actor ID that acts as the
18:03 - primary
18:05 - key then finally as I mentioned before
18:08 - there's one table that defines the
18:10 - relationship between these entities and
18:11 - that's called film and actor and in here
18:14 - you just find actor IDs and film IDs so
18:16 - that's foreign keys to the other tables
18:19 - now our goal is of course not to just
18:21 - view this data in intelly we really want
18:23 - to serve this up and be able to
18:25 - manipulate it via some endpoints so next
18:29 - we're going to need to make hibernate
18:31 - aware of our database and we do that by
18:35 - setting up the configuration and the
18:37 - configuration resides in the resources
18:39 - folder as you can see here it's called
18:41 - application properties and this is
18:43 - really the corkus configuration files so
18:45 - that means anything Quirk is related
18:47 - that needs configuration is going to be
18:49 - done in here it's also good to know that
18:51 - the database config that we're going to
18:53 - apply can be picked up by any dependency
18:56 - that needs a database so that means
18:58 - means the configuration is not going to
19:00 - be specific to
19:01 - hibernate however it is pretty similar
19:04 - to what we did before when connecting to
19:05 - the database and intellig we just first
19:08 - need to specify what jdbc driver to use
19:10 - and in this case again it's a mySQL
19:12 - database so that means we're using the
19:13 - MySQL driver which we have on the class
19:15 - path we're also specifying our jdbc
19:19 - connection URL and that's referring to
19:22 - Local Host 3306 where the database is
19:25 - running and then we pass along the user
19:28 - name which is root and the password
19:31 - which is
19:34 - sakila finally I would like to tell
19:37 - hibernate to log every query that we
19:39 - issue in the database and that's simply
19:41 - because it's going to be easier to
19:42 - follow when we use jpa streamer to see
19:45 - what queries it
19:48 - renders okay so far we've only been
19:50 - concerned with the setup but now we're
19:52 - going to move on to the fun part which
19:53 - is coding so in the next section I'll be
19:56 - creating the entity classes and setting
19:58 - up the jpa repository so saying that we
20:01 - were going to start coding was almost a
20:03 - lie because I'm actually going to use
20:04 - intellig to generate the jpa entities
20:07 - and the reason I prefer to do it this
20:08 - way is because I tend to avoid writing
20:11 - boilerplate and in the case of jpa
20:13 - entities it's mostly just beans with
20:15 - Getters and Setters so I generate the
20:17 - bulk of the code that I need and then I
20:19 - adjust it slightly to fit my needs so
20:22 - I'll revisit the database tab on the top
20:24 - right here and right click on my
20:26 - database and on the bottom I have the
20:29 - option of generating a persistence
20:31 - mapping and then I just specify in what
20:34 - package I would like to place the
20:35 - generated entities and start by
20:38 - deselecting all the tables because I
20:41 - simply want to generate entities for the
20:43 - actor table and the film
20:46 - table and lastly I make sure that the
20:48 - option generate jpa annotations is
20:54 - selected as you can see my entities were
20:56 - placed in the package that I spef speci
20:58 - ified and if I open up the film class I
21:02 - see that I have mappings for each and
21:03 - every one of my columns and this is
21:05 - going to cover most of our needs for
21:07 - this application but there's a ton of
21:10 - annotations that you can use to
21:11 - customize these entities further however
21:14 - as this is not a full course on
21:16 - hibernate I'm just going to show you
21:18 - what we need to get this application
21:20 - working and one of the columns that
21:22 - needs better specification is the
21:23 - ratings column and by rating I don't
21:26 - refer to a rating on a 1 to 10 scale
21:28 - like a one you would see on Rotten
21:30 - Tomatoes but rather the recommended age
21:32 - rating so going back to our database
21:34 - view again on the right we can see that
21:36 - the ratings column holds an enum that
21:38 - can take on five different values G PG
21:41 - PG-13 R and
21:43 - nc17 by adding this information to our
21:46 - column definition we're going to help
21:49 - hybernate the values of the
21:57 - database
22:26 - for
22:38 - now the rest of the columns we can leave
22:40 - as is and I just need to add one more
22:42 - annotation to our entity as a whole
22:43 - because I know that hibernate will need
22:45 - to know what table this entity maps to
22:48 - and in this case that's a table called
22:50 - film in the schema seila and then I need
22:53 - to open up the actra table and add the
22:55 - same table annotation to this class but
22:57 - now I'll specify that the entity maps to
22:59 - the actor table but the schema name is
23:03 - of course the
23:06 - same I also know that intell hasn't
23:09 - helped me to specify the relationship
23:11 - between these two tables so I'm just
23:13 - going to go ahead and add that manually
23:15 - as I mentioned before they have a many
23:17 - to many relationship and this is going
23:20 - to be described mainly by the field
23:22 - actor in the film table I'm going to set
23:23 - that up in a second and to be able to
23:26 - interact with the films that an actor
23:27 - starson I'm going to set up this field
23:29 - which is a set of all the films that
23:32 - this actress starson and this field also
23:36 - needs a getter and Setter in order for
23:38 - it to be read or updated and next I'm
23:41 - going to have to go back to the film
23:42 - table to make a more detailed
23:44 - specification of this join or this
23:47 - relationship so again this is not a jpa
23:49 - tutorial and I will not explain
23:51 - everything that's going on here there
23:53 - are much greater resources on how to
23:55 - express jpa relationships and I
23:56 - recommend that you check them out if you
23:58 - want to learn more about this specific
24:00 - topic but in short I just need to
24:02 - specify the fact that film actor is our
24:05 - joint table and then I'm saying that my
24:08 - film entities are characterized by the
24:10 - main join column which is the film ID
24:14 - and secondly as my invers join column
24:18 - I'll say that I'm referencing the
24:21 - primary key in the actor table which is
24:23 - actor ID and I'm going to facilitate
24:26 - interactions with the actors that star
24:29 - in a film with a list of
24:32 - actors and just as in the case of the
24:35 - actor table I'm going to create Getters
24:37 - and Setters for this field so that we
24:39 - can read it and update
24:42 - it that completes the creation of the
24:45 - jpa entity model and from that we're
24:47 - going to go ahead and generate the jpa
24:49 - streamer meta model so why the need of
24:51 - two meta models you may ask well that's
24:53 - a good question but it has to do with
24:55 - the fact that JB streamer is going to
24:57 - translate your stream pipelines into SQL
24:59 - queries and in order to do that it needs
25:02 - some extra meta information uh about the
25:05 - columns basically that you wish to
25:08 - query so as you may have noticed a
25:11 - pipeline like this could have been
25:12 - expressed using regular lambdas but
25:14 - those lambdas are quite Anonymous and
25:16 - doesn't contain any information about
25:18 - the database columns that we need at all
25:21 - so looking at this query that I showed
25:22 - you previously you can notice the
25:24 - presence of a film dollar sign entity
25:27 - and that is part of the jpa streamer
25:29 - meta model and will expose any fields
25:32 - that belongs to that table so that you
25:33 - can easily construct these predicates
25:35 - which are interpretable by JP
25:38 - streamer luckily though generating this
25:40 - meta model is as easy as rebuilding your
25:43 - application so let's do
25:49 - it once your application has been
25:51 - rebuilt it's going to place the meta
25:53 - model in the Target folder and as you
25:56 - can see here an extra entity has been
25:58 - generated from both the film and actor
26:00 - entity usually however this folder is
26:03 - not considered a source folder in
26:05 - intellig so you have to manually mark it
26:08 - as a generated sources
26:10 - route by doing so we ensure that these
26:13 - classes will be made available to the
26:15 - application I should also note that the
26:17 - jpa streamer documentation contains
26:19 - instructions for how to place these
26:21 - generated classes in a different package
26:24 - or to name them something else than just
26:27 - The Entity named followed by a dollar
26:30 - sign but I'll leave that for you to
26:32 - check out if that's something you want
26:33 - to
26:34 - do so that finishes the section on meta
26:38 - models and now we can go ahead and build
26:39 - our application and just as a bit of a
26:42 - reminder the goal here is to provide a
26:44 - number of endpoints that serves
26:45 - information about films to clients so
26:49 - I'm going to structure this application
26:51 - using a repository pattern simply
26:53 - because I think that does a good job of
26:55 - separating the data layer from the rest
26:56 - of the application
26:59 - so here's an overview of what the
27:00 - architecture will look like once we're
27:02 - done starting from the bottom we have
27:04 - the sakila database and it's going to be
27:07 - the repository layer just above that
27:09 - that is going to handle all the database
27:10 - interactions in the Java realm our
27:13 - resource class on top of the repository
27:15 - is going to define the rest end points
27:17 - and we'll call the repository whenever
27:19 - it needs some information from the
27:21 - database so that means any requests
27:23 - performed by the clients are going to
27:25 - Cascade down the hierarchy hit the
27:26 - database and go back up to the client so
27:29 - all in all a very basic architecture
27:31 - nothing really strange here but it's
27:33 - still a very effective and useful way of
27:35 - structuring your applications and with
27:38 - that overview I think we're ready to
27:39 - start implementing our film repository
27:41 - and film
27:44 - resource so I'm starting by creating my
27:47 - film resource and please ignore my
27:50 - mistake of placing this in the model
27:51 - package I would rather move it one level
27:53 - up but I discovered it after recording
27:56 - the entire tutorial but as it doesn't
27:58 - impact the functionality at all I'm just
28:00 - going to leave it and go ahead with
28:02 - implementing this class I'm using
28:05 - decarta to Define my rest endpoints and
28:07 - by annotating this class with the path
28:10 - annotation my application will
28:11 - automatically pick up the end points
28:13 - that I'm going to Define in here I'm
28:15 - leaving the base path empty simply
28:17 - because I'm only having one resource in
28:18 - this
28:19 - application so there's no better way to
28:21 - test something out than creating a hello
28:24 - world base case right so that's what
28:27 - we're doing it's not creative it's not
28:28 - original but at least it's a good way to
28:30 - just see that we get the basic concepts
28:33 - so here I'm creating a get endpoint that
28:36 - is available at the path hello world and
28:39 - it will return a simple text string so
28:43 - basically we're just returning hello
28:45 - world so with that we just defined our
28:48 - first endpoint and I'm going to go ahead
28:50 - and fire up the quirkus development mode
28:53 - so that we can test that everything is
28:54 - working as we
28:56 - expect so the read me that we got from
28:59 - our template contains instructions on
29:02 - how to run the development mode and as
29:04 - you can tell the command is pretty
29:06 - simple
29:07 - mvnw compile quirkus Dev and it takes a
29:12 - little while to fire
29:14 - up okay seems like something's
29:17 - malfunctioning let's see what that
29:20 - is okay great we got some instant
29:22 - feedback from hibernate saying that
29:25 - there's something wrong with our jpa
29:27 - model
29:28 - specifically the special features
29:33 - field oh apparently I said this was an
29:35 - enum it's actually a set I
29:39 - believe yeah okay so it's a set of
29:42 - features that's allowed not just one so
29:44 - we're just going to go ahead and change
29:46 - that and if I go down to my terminal and
29:50 - press S I will restart the
29:54 - application and now it works since I
29:57 - haven't specified any ports it's running
29:59 - on the default port 8080 however the
30:02 - base URL does not contain any content so
30:06 - the corkus demoe desperately tries to
30:07 - provide me with other options including
30:09 - a link to Swagger UI and if you haven't
30:12 - heard of swagger it's a really neat tool
30:15 - that I recommend if you're working with
30:16 - rest applications simply because it
30:18 - picks up or detects all the available
30:20 - endpoints and allow you to test them
30:21 - interactively in the browser so
30:24 - thankfully it picked up our hello world
30:26 - endpoint and since it doesn't accept any
30:28 - parameters I'm just going to execute it
30:30 - and see what it says hm our response
30:33 - body contains hello world so that's all
30:36 - good and now I'm just going to take the
30:38 - opportunity to show you just how easy it
30:40 - is to make incremental changes to your
30:43 - applications that are instantly detected
30:45 - by corcus so in this case I'm just
30:47 - adding a second hell World
30:49 - endpoint I'm restarting the application
30:51 - by pressing s on the keyboard returning
30:54 - to my browser refreshing the page
30:58 - and there we go I have a second endpoint
31:00 - just like that and again I can execute
31:03 - it and you can see that it returns hello
31:05 - world 2 and this live reload feature is
31:08 - the thing I love most about corus I
31:10 - believe simply because it's just so nice
31:13 - to be able to stay in the Flow by
31:15 - avoiding these 3 to 5c latencies every
31:18 - time you need to rebuild and restart
31:19 - your application
31:20 - manually okay back to the practice of
31:23 - show don't tell so I'm just about to set
31:26 - up my first real endpoint but to do that
31:30 - I first need to create the film
31:31 - repository that is going to serve
31:33 - content from the database and again I
31:36 - wish I place this repository package one
31:38 - level up but we're going to ignore it
31:41 - again so here's our film repository and
31:45 - since we're using jpa streamer for our
31:47 - queries I just start by injecting a jpa
31:49 - streamer instance to give us a handle
31:52 - for our queries I'm then starting out
31:54 - really simple by creating a and point
31:57 - that can be used to fetch a film given
32:00 - its ID so the reason we're having an
32:03 - optional as a return value is that we're
32:06 - only going to populate this value if we
32:08 - find a film with a matching ID so now
32:11 - it's time to use jpa streamer in our
32:13 - application and our first query is going
32:15 - to remind you of the example that I
32:17 - showed earlier and we're basically just
32:19 - going to query the film table and look
32:21 - for films with a matching ID and
32:23 - considering the ID is the primary key
32:26 - there can only be one such film so if we
32:29 - find anything that's the value we return
32:32 - just like with a SQL query the jpa
32:34 - streamer query starts with the a select
32:36 - statement or in this case JP streamer
32:38 - stream film class which says that we're
32:41 - interested in streaming the film
32:44 - entities and the stream that this method
32:46 - returns is a standard Java Stream So any
32:49 - operations that can be applied to Java
32:50 - stream can be applied to this stream
32:53 - however you need to be a bit mindful
32:55 - about the fact that JP streamer can only
32:57 - translate jpa streamer predicates
32:59 - efficiently and not regular lambdas but
33:02 - they're not hard to use and I'll show
33:03 - you how that's done if you're used to
33:05 - SQL queries this would have been a worse
33:07 - statement but in the realm of streams
33:09 - we're applying a filter to check if the
33:12 - column film ID matches the given film
33:15 - ID and using the databased rumor meta
33:17 - model is generally not any harder than
33:20 - this you simply just specify which
33:22 - column you would like to use for your
33:24 - predicate and all of the common
33:27 - operators for comparisons are available
33:30 - the execution of the query is delayed
33:32 - until we apply a terminal operator and
33:34 - in this case I'm using find first so
33:37 - with a query in place I want to go ahead
33:38 - and create an endpoint that allow
33:40 - clients to fetch films based on their
33:42 - IDs so I need to start by injecting my
33:45 - film repository so that I can call the
33:47 - method I just created and from there I
33:50 - create an mpoint much like the ones we
33:51 - already have but with the one exception
33:53 - that I'm going to take in a parameter
33:57 - and that's done by placing a variable
33:59 - name inside curly brackets like
34:02 - this making sure that your method here
34:05 - accepts a parameter that shares the same
34:08 - name that it knows what to match it to
34:11 - and now we just simply need to call the
34:12 - method we just created but since we're
34:14 - getting back an optional I'm going to
34:16 - check if there is any value present
34:19 - because if there isn't then I know that
34:21 - there was no film in the database with a
34:23 - matching
34:24 - ID so if a film is present then I'll get
34:27 - that and I'm just going to print the
34:29 - title and otherwise I'll just print a
34:31 - message saying that there was no
34:33 - matching
34:36 - film okay so let's test that we'll
34:40 - restart our application oops I thought
34:44 - so um corus is again telling me
34:46 - something is
34:49 - wrong
34:51 - okay I miss the fact that when I want to
34:54 - inject my film repository here I need to
34:57 - make sure that it has an annotation that
34:58 - allows it to be injected so in this case
35:01 - I'll be using application scope to
35:03 - indicate that regardless of how many
35:05 - other classes that injects this class I
35:08 - want there to be only one instance of it
35:11 - even intellig seems to think that this
35:13 - looks more healthy so restarting it
35:15 - again looks much
35:17 - better so back to Swagger to test this
35:21 - out this time I have to provide a film
35:24 - ID so why not try it with the
35:27 - 35 and apparently that has a title that
35:30 - I won't even try to pronounce but it
35:33 - contains the word roller coaster and I
35:35 - can go back to my database and intell
35:38 - and look if this seems to be
35:41 - correct so opening up the film table
35:44 - scrolling down to 35 oh there it is all
35:49 - seems to work if you pay attention to
35:51 - the terminal logs now you can see that
35:53 - our application has printed the query
35:55 - that was issued by JP streamer but we're
35:57 - going to take a closer look at that in
35:59 - just a
36:00 - second I've already started here on our
36:03 - next query and that's going to be a
36:05 - paged one so we're basically going to
36:08 - look for films that are at least a
36:10 - certain length and then we're going to
36:12 - return the results in a paged manner so
36:16 - our page size is going to be
36:20 - 20 and we're creating the stream much
36:23 - like before we're streaming the film
36:25 - class meaning the film
36:30 - table and we're applying a filter to
36:33 - check whether the length is at least the
36:35 - minimum
36:36 - length so length greater than Min
36:42 - length and then to achieve our paging
36:44 - I'm going to skip a certain number of
36:47 - results in this case the page I want to
36:49 - access times the page size and you may
36:53 - notice that this is going to be a zero
36:55 - index paging
36:58 - and then we'll limit our results to our
37:00 - page
37:01 - size and just for fun we're also going
37:03 - to sort the films according to their
37:08 - length so to test this out I'm going to
37:10 - need another endpoint so let's go back
37:12 - to our film resource and craft another
37:16 - endpoint in this case I'm calling it
37:20 - page
37:21 - films and I'm taking in the page number
37:24 - and the minimum length
37:32 - and again it produces just plain
37:45 - text
37:46 - so this time we don't need to look for
37:50 - any optional values we're simply going
37:51 - to stream any results we get back and
37:54 - format
37:55 - them
37:57 - so once we get a list of films back from
38:00 - our page query we are mapping each film
38:03 - to their title and their length so that
38:07 - we can check that we're actually sorting
38:09 - them according to the sort order and
38:13 - also that we don't get back any films
38:15 - that are shorter than the specified
38:22 - length and then I'm using the terminal
38:25 - operator collect and I'm collect using
38:28 - the joining operator and I'll make a
38:31 - line break between each of the
38:35 - results okay so we're going to restart
38:37 - our application again to test this
38:41 - out and this time it all seems to work
38:44 - right from the start good so our new
38:47 - endpoint is detected by
38:49 - Swagger and I'm providing a minimum
38:52 - length of 1 hour and let's go with page
38:56 - three
38:59 - three perfect here we have a list of
39:02 - films and none of them is shorter than 1
39:05 - hour and they're sorted and if we check
39:08 - out page
39:09 - four yeah we get longer films which is
39:11 - what we expected but now let's go back
39:14 - and look at our query that was issued in
39:16 - the
39:18 - database so even though we expressed our
39:20 - query as a Java stream this is what's
39:23 - being executed on the back end we have
39:25 - our rare predicate checking for the
39:26 - length condition and our sword operator
39:29 - expressed as an ordered by on the SQL
39:32 - end but you may notice that we're
39:34 - selecting all of the columns but we're
39:36 - only really printing two so I think we
39:40 - can do a bit better here by making a
39:43 - projection to only fetch the columns
39:45 - that we're interested
39:48 - in so to do this I'll have to modify my
39:51 - query slightly and in this case I'm
39:53 - going to modify the stream Source
39:55 - because in our select state I'm going to
39:56 - make a projection instead and that
39:59 - projection is going to refer to the two
40:02 - columns that I'm interested in but it
40:03 - also needs to have the primary key which
40:06 - is the
40:07 - ID we also need to have a matching
40:10 - Constructor for our film object because
40:14 - when JP streamer gets these three values
40:16 - back it doesn't know how to populate the
40:18 - other
40:21 - fields so you're going to see here that
40:23 - if we just try to run
40:25 - this with again a minimum length of 1
40:28 - hour and page number
40:30 - three we get an exception saying that
40:33 - there's no matching constructure and one
40:35 - or more arguments were not
40:38 - defined so this is easy to resolve by
40:40 - just making sure that our film entity
40:43 - here has a Constructor that matches the
40:46 - arguments that we're going to pass in so
40:47 - in this case we need a Constructor that
40:50 - accepts the ID the
40:52 - title and the
40:55 - length and then we just simply initiate
40:57 - our uh Fields with these
41:09 - values and that should work but we'll
41:13 - see what happens if we try it
41:21 - again okay so our results look the same
41:24 - as before but what about our query did
41:27 - anything change on the sequel
41:32 - side yes great so now we're only
41:34 - selecting the three fields of Interest
41:37 - meaning we're saving ourselves from
41:40 - fetching a lot of data that we're just
41:41 - going to throw away
41:43 - anyway so for our third query we're
41:46 - going to make a join because now I'm
41:49 - interested not only in the films but
41:51 - also the actors that star in those films
41:54 - and if I want to fetch information about
41:56 - the actors that relates to certain film
41:59 - I need to join in the actor table so in
42:02 - this case our join is constructed with a
42:05 - stream configuration and that's
42:06 - basically just a way of saying that we
42:09 - want to fetch the film table still but
42:11 - we want to join in all their Associated
42:14 - actors and if you remember from before
42:16 - our film entity has annotations that
42:20 - describes this join already so we really
42:22 - only have to say that we're now
42:24 - interested in joining in these objects
42:27 - and then we simply replace what used to
42:29 - be our film class with this new stream
42:32 - configuration that describes a slightly
42:34 - more complex stream source and from here
42:37 - we're free to manipulate our film
42:39 - entities just as we did previously so
42:41 - first applying a filter here to check
42:43 - for films with a title that starts with
42:45 - a past in
42:47 - string and then I'm going to sort these
42:49 - films again according to their length
42:54 - but this time I'll reverse the order
42:55 - just to show you how easy it is to do
43:00 - that and that's all I'm going to do for
43:02 - this query so again I'm copying this
43:05 - time the other endpoint and making small
43:08 - modifications to it so accepting a
43:11 - starts with
43:13 - value passing that
43:20 - in and then calling my new join
43:25 - method but this time the formatting is
43:27 - going to be a bit more complex because I
43:30 - have a stream of films and I'm GNA start
43:33 - by printing out the again the title of
43:36 - the film followed by its length and then
43:38 - I will list all the actors that stars in
43:41 - the
43:43 - film so the first value here is going to
43:46 - correspond to the title and secondly the
43:49 - length but then my film actor field
43:53 - actually returns a list of actors so to
43:57 - print that I'm going to stream over the
43:59 - list of
44:00 - actors and I'm going to map each of the
44:02 - actors to their first name and last
44:10 - name so just simply concatenating
44:12 - together those
44:17 - values and then joining them with the
44:19 - collector
44:20 - operator separated by
44:25 - commas
44:27 - and finally I'm again joining all my
44:30 - film entities separated by line
44:38 - breaks okay so simple restart of the
44:41 - application will give me access to my
44:44 - newest member of the rest endpoint
44:47 - family and I'm trying it with the
44:49 - character
44:51 - a and here we get back a list of all the
44:54 - films that starts with an a and you can
44:57 - see all the actors that relates to those
45:01 - films and now again if we go back to
45:04 - look at the query you can see that the
45:05 - join is being applied in the SQL
45:08 - query and of course I'm not saying that
45:11 - you should come back to the sequel that
45:13 - JP streamer generates every time but I
45:16 - do recommend it as a great way of
45:18 - understanding what JB streer does
45:20 - especially if you're starting out and
45:22 - want to understand what your pipelines
45:24 - are being translated to especially if
45:26 - you're working with large data sets in
45:29 - which case the performance is going to
45:30 - be critical and you may have to optimize
45:33 - your queries in certain
45:35 - ways so before we move on I'm just going
45:37 - to show you quickly how easy it is to
45:39 - combine multiple predicates so here I'm
45:42 - just combining both of the predicates
45:44 - that we worked with before checking that
45:46 - our title starts with a certain string
45:48 - and also checking that the length meets
45:50 - a certain
45:52 - condition and for that to be effective
45:55 - on the rest endpoint side I'm just
45:57 - adding that second parameter
46:07 - here
46:09 - restarting and
46:16 - testing so let's do two hours now and an
46:21 - a as our star character
46:24 - again
46:29 - yeah we don't get back anything shorter
46:31 - than 2 hours but let's make it a bit
46:34 - more restrictive so that it's easier to
46:36 - see that we're actually getting the
46:37 - right
46:39 - results yeah nothing's shorter than 170
46:42 - minutes and all of them start with
46:46 - a I'm also going to show you how you can
46:48 - actually use JB streammer to filter out
46:51 - films you would like to
46:53 - update so we can in this case up update
46:56 - the rental rate of our films and the
46:57 - rental rate is of course what you would
46:59 - charge to rent out one of the
47:02 - movies for demonstration purposes we're
47:05 - going to use a rather unconventional
47:07 - algorithm in this case so we're going to
47:09 - set the price of the movies that are
47:12 - longer than a given
47:14 - length oh I also just recall that the
47:16 - type of rental rate is actually a
47:19 - float so updating the movies that match
47:22 - this griven predicate is really simple
47:24 - you just again use datas streumer to
47:26 - select the films of interest and then
47:29 - apply the for each operator to set a new
47:33 - rental rate of each of the movies that
47:35 - remain in the
47:36 - pipeline and that's really all there's
47:38 - to it but before I create another
47:40 - endpoint to facilitate these updates I'm
47:43 - going to create a small utility method
47:46 - for my response value that just sends
47:49 - back all the movies that have been
47:50 - updated and their newest
47:52 - price so again just creating a stream of
47:55 - all the films filtering them to make
47:57 - sure that they are longer than the given
47:59 - length and then sorting them by
48:02 - length Okay so for some reason this is
48:04 - not compiling found an extra parenthesis
48:07 - there perfect so this is going to be our
48:09 - final endpoint and in this case we are
48:12 - actually going to perform updates so
48:14 - let's make sure that what we just did is
48:18 - working so I'm naming this one update
48:22 - and then I'm accepting a minimum length
48:24 - and a new rental rate
48:26 - you know the drill by now
48:30 - right just updating my method
48:34 - parameters so I'm just going to start of
48:37 - course by updating the
48:39 - prices by calling the method update
48:41 - rental rate that we just
48:45 - created and then we'll call the utility
48:47 - method to return back all the movies
48:49 - that should have been affected by our
48:51 - update so just get the films of a
48:54 - certain minimum length and then I'm
48:56 - updating my string formatting here to
48:58 - include the rental rate as well so that
49:00 - we can see the new
49:02 - price okay restarting the application
49:05 - let's see how this
49:09 - goes my new endpoint is there looking
49:12 - all
49:14 - good so now let's just update a few of
49:17 - the really long ones so minimum length
49:19 - of 170 and a rental rate of
49:22 - $10 okay so I see no price change
49:25 - whatsoever and this could be explained
49:27 - by two things either we didn't make any
49:29 - updates at all or the updates were not
49:32 - reflected in my second query just
49:34 - fetching the films again but we're going
49:37 - to take a look okay so looking in the
49:39 - database none of the prices have
49:41 - actually changed so that means my update
49:44 - wasn't effective at all and I must admit
49:47 - I did this intentionally just to point
49:49 - out that your updates are not going to
49:51 - have an effect unless you apply the
49:53 - keyword transactional to your your
49:56 - update method so The transactional
49:58 - annotation here indicates that we would
50:00 - like to persist any updates that we make
50:03 - on our film entities in this
50:08 - method so if all goes well this should
50:11 - fix our
50:12 - problem and thankfully it did so now you
50:15 - can see that our updates have taken
50:17 - effect and the new price of our movies
50:20 - is
50:22 - $10 and if we now go back to the
50:25 - database it's going to be a different
50:26 - story because this time I'm sure that
50:29 - the prices are reflected okay first
50:32 - update yeah there we go our new prices
50:35 - are showing so up until now we've been
50:39 - testing the application manually just
50:40 - going back and forth to the database
50:42 - printing things and this is of course
50:45 - not the way to do testing this is way
50:47 - too error prone so corkus has this
50:50 - really cool feature built into its
50:52 - development mode that allows you to
50:53 - create tests that are run every time
50:56 - basically your application is restarted
50:58 - and that way you get instant feedback on
51:00 - whether or not things are working the
51:02 - way you intended them to so with that
51:04 - said let's go on to make some continuous
51:06 - junit
51:08 - tests so if youve been following long
51:10 - from start using the corkus starter page
51:14 - then you should be all set up in terms
51:15 - of dependencies but I'm just going to
51:18 - restate what is needed to get the
51:19 - continuous testing working the way I'm
51:21 - going to show you now so first off you
51:24 - need to have the porus junit 5
51:26 - dependency and this should be
51:27 - automatically added for you but if you
51:29 - don't have it make sure to add it and as
51:32 - a final less obvious step you need to
51:34 - set your Maven Shire plug-in version and
51:37 - that is because the default version does
51:38 - not come with support for junit 5 so
51:41 - make sure you set it to something recent
51:43 - in this case I'm using
51:45 - 3.00 from this point on testing is
51:47 - really not much different from creating
51:49 - your regular Jun tests so to start I
51:52 - just need to create the standard Maven
51:54 - test folder which which didn't exist
51:56 - from
51:58 - before and then I'm going to go ahead
52:00 - and create a film resource test since I
52:03 - will be testing out our rest end
52:06 - points then to have them run
52:08 - automatically when you rebuild your
52:10 - application I'm applying The annotation
52:12 - quirkus
52:16 - test and from here I'm sticking with the
52:19 - Jun annotation test to create my first
52:22 - test of the rest endpoint hello world
52:26 - as we're testing rest end points I also
52:28 - want to take the opportunity to show you
52:30 - a really convenient Library that's
52:32 - specifically designed to test end points
52:35 - this is of course totally optional but
52:36 - if you want to use it then add the
52:38 - dependency rest assured just as I'm
52:41 - doing here and I'm also going to put it
52:43 - in the test scope since I don't need it
52:45 - for my
52:47 - application so rest assured in
52:49 - combination with corkus is really
52:51 - powerful since this will allow you to
52:54 - run integration tests T only by
52:57 - specifying what the endpoint is that you
52:59 - would like to call what parameters to
53:01 - call it with and then Define the
53:04 - expected result so here I'm saying that
53:06 - I want to call the endpoint film with an
53:10 - ID of
53:11 - 343 and then I expect the status code to
53:14 - be okay namely 200 and I also expect
53:17 - that my body contains a certain string
53:20 - in this case I'm expecting it to contain
53:21 - the title of that film and I just need
53:24 - to quickly check in the database what
53:27 - I'm really expecting
53:28 - here so I'm going over to the film table
53:32 - looking for it
53:35 - frantically there it is okay I figured I
53:39 - might as well pick another ID which is
53:40 - more easily available so I'm going to
53:43 - change the ID to five and I'm expecting
53:45 - it the title to be African
53:49 - egg so all I need to trigger this test
53:52 - is to reround my application and you can
53:54 - see on the bottom that it says press R
53:55 - to resume testing so I'm pressing the
53:57 - key R and now it says running one of one
54:01 - all tests
54:04 - passed and that's great so that means
54:07 - the title was actually African egg but I
54:09 - can add in a second test to also show
54:11 - you what it looks like if the test is
54:14 - failing so if again I'm querying the
54:17 - same
54:19 - endpoint film with an ID of five and
54:22 - still expecting the status code to be
54:24 - 200 however I'm going to put in a
54:27 - different string for the body to show
54:28 - you that it's going to warn you if it's
54:30 - wrong so in this case I'm expecting it
54:32 - to be Titanic pressing R again to rerun
54:35 - my tests and now we can immediately tell
54:38 - that something is wrong because we got
54:41 - back African egg and we were expecting
54:44 - Titanic so there's a number of aspects
54:46 - of this that I just find so powerful
54:49 - since a lot of this tutorial has been
54:51 - focusing on developer experience again
54:54 - this is a Fant fantastic example of an
54:56 - API that is so fluid and smooth to work
54:59 - with we also didn't have to do any
55:02 - special
55:03 - configurations um letting quers know how
55:05 - to run our services where to find these
55:07 - endpoints all of that just works out of
55:09 - the box it will spin up the services for
55:12 - you on a designated test port and then
55:14 - execute all of your
55:16 - tests even though I find this part more
55:19 - impressive it's also of course really
55:21 - useful to be able to just perform unit
55:23 - tests rather than integration tests
55:25 - so I'm also going to add in a film
55:28 - repository test and that is just to show
55:30 - you how you can perform unit testing
55:31 - meaning in this case we're going to test
55:33 - the film repository class
55:36 - directly so again I'm adding in the
55:39 - corcus test annotation to allow corkus
55:41 - to pick up my tests and then I'm
55:43 - injecting my film repository just like
55:46 - we did earlier for the film
55:49 - resource and then I can just go ahead
55:51 - and create a normal junit test where I'm
55:55 - going to call the film method directly
55:58 - to get one of the films for Simplicity
56:00 - I'm using the same argument as before so
56:03 - that we know that the title of the film
56:05 - is African
56:06 - egg but as this method returns an
56:09 - optional I'm actually first going to
56:11 - assert that the optional is not empty
56:13 - meaning there is a value present in this
56:20 - variable and after that I'll assert that
56:23 - the title is African EG
56:36 - okay let's rerun the
56:38 - tests oh I'm going to get rid of the
56:41 - failing test in the other class just
56:44 - to have our output show us that all of
56:47 - the tests are passing there we go so now
56:51 - you know how to perform both regular
56:52 - unit tests and also integration tests
56:55 - with corkus continuous testing luckily
56:58 - in this case uh both of our simple tests
57:00 - were passing but if we discover that one
57:03 - of our tests were failing and we didn't
57:04 - know why then it might be useful to use
57:07 - the debugger that's built in in intell
57:10 - so next I'm going to show you how you
57:11 - can attach the debugger to the corkus
57:13 - dev mode so that you can try your arm
57:16 - points in Swagger and hit break points
57:17 - in your code due to the order in which I
57:20 - was recording this uh we've gotten back
57:22 - the failing test on top here but let's
57:24 - ignore that for now and restart our
57:26 - development mode with an extra flag
57:28 - namely D debug and that's going to fire
57:31 - up uh the corcus development mode in
57:33 - debug
57:34 - mode so now I'm just going to go ahead
57:36 - and create a run configuration which
57:38 - will allow me to attach intellig
57:40 - debugger to my corcus application so in
57:43 - this dialogue I need to select the
57:45 - little plus sign on the top left here to
57:48 - create a new configuration and in this
57:49 - case it's going to be a remote jvm debug
57:53 - so let me just find that option
57:55 - and the default settings are actually
57:57 - fine here because uh the corkus log said
57:59 - that the corus is listening on Port
58:03 - 55 so I'm basically just naming my R
58:06 - configuration and then uh restart corkus
58:09 - and also starting my debugging process
58:12 - in
58:12 - int and it instantly says that it's been
58:15 - connected to my target versal machine on
58:17 - Port
58:18 - 50005 so let's just go ahead and add in
58:21 - a break point to see that it's all
58:23 - working so I'm using this simple
58:25 - endpoint get film and just like before I
58:29 - can make a request from
58:31 - Swagger and this should hit my
58:33 - breakpoint if everything's working out
58:35 - fine yeah it did I'm pretty sure that
58:38 - you already know how to use intelligence
58:40 - debugger from here so I'm not going to
58:42 - go into any more depth I just wanted to
58:44 - show you what it looks like working with
58:46 - intell debugger and the quirkus dev mode
58:48 - at the same time now that we actually
58:51 - have a working application I think it's
58:53 - time to think about how we can improve
58:55 - the application's
58:56 - performance because as I stated early on
58:59 - when introducing corus native
59:01 - compilation is one of the reasons why
59:03 - you should consider using this framework
59:06 - so we're going to have a look at how
59:07 - much we can improve our startup time um
59:10 - by building the corcus application in
59:12 - two different ways the first one is
59:15 - using the corcus build command and this
59:18 - is the standard way if you just want to
59:20 - package your application as a standard
59:22 - Java
59:23 - jar and the build process is of course
59:26 - also going to run the test that we've
59:28 - created to assure that our application
59:30 - seems to be
59:31 - working and once the build process is
59:33 - done we can find the jar in the Target
59:36 - folder at the root level here you can
59:38 - see that there's a corcus tutorial one
59:41 - snapshot jar and that's your regular
59:44 - Maven build jar um so that's not
59:46 - runnable it Just contains all the
59:48 - classes and resources for your
59:51 - project however if you look into the
59:53 - quirkus app folder you can see that
59:54 - there's is a corkus run jar and that jar
59:58 - can be used to execute your
60:00 - application however if you want to
60:02 - deploy your application somewhere like
60:03 - in a container then you would have to
60:05 - deploy the entire corcus app directory
60:07 - because this jar is not an Uber jar it
60:10 - doesn't contain all the dependencies
60:12 - that your application needs to run but
60:14 - since we have access to this folder now
60:16 - we can run the application from with
60:18 - inside that
60:20 - folder so here I'm just using the
60:22 - regular Java command to run a jar
60:31 - file so as the application starts it's
60:33 - going to tell us how long it took to
60:35 - fire it up in this case 1.7 seconds
60:38 - while we're at it I'm also again just
60:40 - going to test that this works so opening
60:42 - up Local Host 8080 but this time I'm not
60:45 - running in the corkus dev mode but
60:46 - rather um running the actual built
60:49 - application so an ID of 34 gives us back
60:53 - Arabia DOA
60:55 - and the logs are still showing that we
60:58 - executed a query so the REM file that we
61:01 - got with our project template actually
61:04 - contains instructions on how to build
61:06 - your application natively as well so
61:08 - there are two versions of this script
61:11 - the first one uses grvm and the second
61:14 - is using a container based version of
61:15 - grvm in case you don't have grvm locally
61:19 - but since I do have grvm installed I'm
61:21 - running the First Command you're going
61:23 - to notice that this takes uh quite a
61:26 - long time compared to the regular build
61:29 - but that's totally according to plan
61:31 - because what we want to achieve when
61:32 - compiling natively is really to first
61:34 - off get rid of all the unnecessary
61:36 - unused code uh which is going to require
61:38 - some code analysis and grvm is also able
61:42 - to build up some of the state that we're
61:45 - going to need at the time when we start
61:47 - up our application and that's also going
61:49 - to save us some time here I've been
61:51 - speeding up the process so you wouldn't
61:53 - get bored but it took me about 4 and 1/2
61:55 - minutes to complete the native build and
61:59 - the result is a runner script that can
62:01 - be executed just like any other shout
62:04 - script and you'll find this runner in
62:06 - the root of your target folder so here
62:08 - it is corkus tutorial one0 snapshot
62:12 - Runner so I'm firing that up in my
62:15 - terminal and immediately you can see
62:18 - that my application now started in a
62:20 - tenth of a second so this is a massive
62:23 - Improvement from what we had before okay
62:26 - that marks the end of this tutorial and
62:29 - I would like to thank you so much for
62:30 - watching I hope you picked up some new
62:33 - Java skills along the way and I also
62:35 - hope that you like Java a bit more now
62:37 - that you've seen what quirkus and date
62:39 - based RoR can do as a reminder they're
62:42 - both free to use so I encourage you to
62:43 - go out and check out their documentation
62:46 - that is linked in the description below
62:48 - because there's so much more to discover
62:50 - that I didn't have time to cover in this
62:52 - video