00:00 - develop as a 2d cross platform free and open 
source game engine. Wesley and Max teach this  
00:06 - course. They're both game developers 
and teachers. And this course is the  
00:11 - best way to get started with G develop. Hey 
there, my name is Wesley, and this is Max.  
00:17 - And we're going to take you from zero knowledge 
to releasing a game with G develop. In this video,  
00:22 - I'm going to start us off with the general layout 
of G develop. When you first download G develop,  
00:32 - you'll be met with this screen. From here you can 
open an existing project or start a brand new one.  
00:37 - When you click on create a new project, you'll 
be given a bunch of options for starter games  
00:42 - and examples. We're going to skip all those for 
now and just go straight for a blank game. When  
00:48 - you start from scratch like this, you need to 
add a new scene, which is where you'll actually  
00:53 - make the game. To keep things organized, it's 
important to make sure that you give your scenes  
00:58 - appropriate titles. Since we opened a blank game 
project, we need to open some of the panels. Up  
01:05 - here in the top right corner, you'll see some of 
the options. You'll also have the ability to add  
01:10 - a grid to your game project to help organize 
things. And to change the level of zoom. Let's  
01:16 - start with the object panel. This is where you're 
going to import and manage your game objects.  
01:20 - Everything from your characters to your 
tiles to your particle effects will all  
01:26 - show up in this panel. We'll start by creating 
a sprite the most commonly used game object,  
01:32 - you should make sure to give this a title that 
makes sense. Click add an animation, find the  
01:37 - art that you want to use, and open it, be sure 
to click Apply to save any work that you've done.  
01:42 - And then you can just drag the object 
straight from the panel into the game space.  
01:48 - You can drag to click on multiple objects 
at a time and use the middle mouse button to  
01:52 - move the scene around and zoom in and out. 
The next panel over is for object groups.  
01:58 - It's a useful tool that lets you target a group of 
objects as opposed to each individual one when you  
02:03 - want to do things with them. For example, I could 
have a bunch of parts and potions and food items  
02:09 - and call all of them healing items. And then I 
can make a single event that makes it so that  
02:14 - if the player is in collision with one 
of those healing items, they get healed,  
02:18 - instead of making a different event 
for every single item in the list.  
02:22 - Next up is the Properties panel. When this 
panel is open, and you click on an object,  
02:27 - you'll get to see their position, Z order angle, 
and so on. And from this panel, you can actually  
02:32 - control all of those things, moving them around 
changing their angle and changing the Z order,  
02:38 - which is what decides whether an object 
is behind or in front of another one.  
02:42 - And that's a good transition to talking about 
layers. With the Layers panel you can create  
02:46 - different layers to place objects on. So you can 
create a foreground mid ground and background  
02:51 - as well as UI layers and menu layers. 
Typically, you'll put most for game  
02:56 - objects on the base layer, and have that 
camera following the player while having  
03:00 - all of your UI objects and menus on different 
layers where the camera is stationary. From this  
03:06 - panel, you can also add effects to layers, edit 
their properties, and toggle their visibility.  
03:14 - Back to the Properties panel. You can 
also use this panel to resize objects.  
03:23 - But be careful while doing this because changing 
an images resolution can really make it blurry.  
03:30 - The last panel is for the instance list. This 
can be a useful tool for finding where things  
03:35 - are in your game project, especially once they've 
gotten so big that you can't tell where things  
03:40 - are anymore. You'll notice these window tabs up 
top, the start page and then your main scene page  
03:46 - where all of the game building is done. 
And then that scenes event list where  
03:51 - all of the black magic happens. But we'll get 
to that in another video. Up in the top left,  
03:57 - you can open your project manager. And in 
the game settings, you'll find properties.  
04:01 - This is where you'll do things like change 
the game's name, give it a version number,  
04:06 - a package name an author, login with your 
profile, and change the games resolution, which  
04:12 - is something you should definitely do because 
very few devices are defaulted to 800 by 600. You  
04:18 - can also tell the engine here how to expand the 
game to meet the size of the screen that it's in,  
04:22 - as well as tweaking the max and min 
frame rates that the game will run at.  
04:26 - for mobile devices. You can choose whether the 
game runs in portrait mode or landscape mode,  
04:31 - and then you can turn on and off anti aliasing. 
The only real reason you would turn this feature  
04:36 - off is if your game uses pixelart. And if your 
game is running ads, then this is where you  
04:41 - would slot in your app ID. You can also edit 
the game's initial loading screen from here.  
04:47 - The rest of the project Game Settings has global 
variables, which we'll get to at another time  
04:53 - icons, which are your desktop and mobile app icons 
and resources. Which is where you can go and see  
05:01 - all the assets that are in your game file. There 
are a few options here that you might need, like  
05:06 - when individual objects are blurry or if an object 
or sound effect is stuttering before it loads in.  
05:12 - The rest of the Project tab has the scenes that 
we've already talked about external events and  
05:18 - layouts, which we plan to explain in another 
video. And then functions and behaviors. And  
05:25 - if you wanted to use the prebuilt extensions that 
include things like giving the enemy's health and  
05:31 - different movement systems, then this would 
be the place to get those. And we're going to  
05:36 - tackle that in another video as well. Let's close 
this project and open one of the starter games.  
05:45 - You'll see that all of the games objects 
have loaded into the objects panel,  
05:48 - as well as the events and the game 
itself. Now in the top left corner,  
05:52 - the two last things to talk about are the Export 
button, which is what you would use when you're  
05:57 - finished building your game and you want to 
release it to the public. And the Preview button,  
06:01 - which is what you would use to play test your 
own game. When you click this button, it will  
06:06 - play from whichever scene you're on currently, 
it'll open up a window, and I can just play  
06:11 - one last thing that before you go. This is 
something that I didn't know about. Even  
06:15 - though I've used the engine for over two years. 
And to see all these panels, they can all move.  
06:21 - Now this isn't revolutionary. But this 
does allow you to customize your workspace  
06:26 - and set it up so that it works best for you. 
Though this is probably not how the developers  
06:31 - top people would use it. Next, I'm going 
to go over the object types in G develop.  
06:41 - We start off with the basic scene. And on 
the right hand side you'll see the objects  
06:45 - that have imported into the game. We're going to 
click on add a new object. And from here you're  
06:50 - going to see all the options. We're going 
to begin though with the most commonly used  
06:54 - object which is a sprite, which we already 
have labeled in the scene as the player.  
07:01 - Sprites are able to have different animations 
where you add in each frame of the animation.  
07:05 - Pick the speed that the animation plays at and 
decide whether or not it should loop. You can also  
07:10 - label animations to make them easier to use later. 
To add more animations to a sprite, just click  
07:16 - add an animation. Down here in the bottom left 
corner, you can edit the sprites collision mask,  
07:22 - you can also edit points that are on the 
sprite on the bottom left hand side as well.  
07:27 - Every object can be given behaviors and effects. 
Behaviors are prebuilt game logic that you can  
07:33 - use to help make your game faster. So if we give 
the player character the platform or behavior,  
07:39 - you can see there's a bunch of numbers in here 
that you can tweak. But you can leave those as  
07:42 - default if you want to. And then if we give 
the player character, the drop shadow effect,  
07:47 - we get a character that has a drop shadow, and 
one that can move when you press the arrow keys.  
07:53 - A quick side note for the platformer behavior. If 
you don't give the ground that they're standing on  
07:57 - the platform behavior, then your character 
will just fall out of the screen.  
08:02 - Speaking of the ground, let's move on to the 
next object, which is a tiled Sprite, we use  
08:08 - tiled sprites, because if you grab a regular 
sprite and try to change the size, it will scale,  
08:14 - whereas tiled sprites will duplicate instead of 
changing size. So you can use this for a bunch  
08:19 - of different things like level design and UI. The 
next object type is text, you can change the size,  
08:27 - color and font of this object, and then write 
in whatever you would like to to fill it in.  
08:32 - And then you can use the event system to change 
what's written in this object during your game.  
08:38 - Next up is the particle emitter, you can use the 
particle emitter for a whole range of things.  
08:43 - But the two most important parts are particle 
kind, which come in point line and texture,  
08:50 - texture being one that you can import yourself 
to create whatever kind of particle you want.  
08:54 - And the number of particles in tank. 
If this is set to negative one,  
08:59 - the particle emitter will stay there forever 
in your game. If it's set to a positive number,  
09:03 - then it will use that many particles and 
then stop. You can either place them in scene  
09:08 - to start when the scene starts, or use the 
event system to spawn them where we need them.  
09:13 - Next is the nine patch panel Sprite, you 
import an image. And then it's easiest to  
09:18 - show you this from the wiki. You put the size of 
your margins into the nine patch panel Sprite.  
09:24 - And then it will expand in the way that you see 
on screen, maintaining the ratios of the outside  
09:29 - edges. And this can be used for dialog boxes, 
UI design, and a bunch of different things.  
09:35 - The shape Painter is also easiest to 
explain from the example in the wiki.  
09:41 - Basically, this can be used to create a range 
of shapes for UI way points, selection tools,  
09:48 - and things like that. The text entry object is 
used to enter text, you create the object, put  
09:55 - it in scene, and then using this simple event and 
the Hello World text object that we made earlier,  
10:02 - the game will record and display what I'm typing 
into my keyboard. Next is the BB text, which is  
10:09 - very similar to the basic text object. But you're 
able to do more things with fonts and effects.  
10:14 - If you don't need to use these effects, you're 
better off just using the basic text object.  
10:19 - The light object can be used to create some 
dynamic shadows, I just create the object,  
10:24 - place it in scene, and then give the player 
character the light obstacle behavior. And then  
10:29 - you can see that the light is being obstructed by 
the players collision mask that we set up earlier.  
10:35 - The last object type video is pretty 
straightforward. You just pick the videos,  
10:40 - opacity, volume, and then import the video, it's 
best to use an mp4 For compatibility reasons.  
10:46 - And then you can control the stopping and 
starting of the video through the event system.  
10:51 - Now that that's out of the way, we can 
start talking about the event system  
10:58 - will begin with a scene that I've 
set up and go into the event sheet.  
11:02 - From here, we can add an event. And 
we'll zoom in to make it more readable.  
11:07 - So the easiest way to think of the no code 
system is to think of if then, so if this side,  
11:15 - the condition side is true, then this 
side, the action side will happen.  
11:23 - So I'm going to set up a simple event, I'm going 
to search for key pressed, and then type in D.  
11:30 - And then for an action, I could search for 
this again. But I can also click on an object,  
11:36 - and it will give me a list of things 
that will only relate to that object,  
11:39 - I could search down this list to find the things 
that I want. But because I know what I want,  
11:45 - I'm just going to type in force and select 
Add a force is going to give it a positive  
11:51 - power in the x direction, and then zero in the y 
direction. And I'm going to leave it at instant  
11:55 - because an instant force will only apply while 
the condition is true, whereas a permanent force  
12:00 - will stay with that object permanently. And now 
when I press preview, and hold down the D key,  
12:06 - the player object will very slowly move 
to the right. Back in the event sheet,  
12:11 - I can add more events by clicking here, here, 
or by right clicking and selecting new event.  
12:18 - Now I can drag this event over and turn it into 
a sub event of our original event. I'll add the  
12:24 - action, rotate, select the player and give it 
an angular speed. I'm also going to increase  
12:30 - the speed for the apply force event. And now when 
I press D, the character rotates and moves faster.  
12:37 - What's happening is the main event is being 
checked to see if its conditions are true.  
12:42 - And if those conditions are true, then it 
will move down and check the sub events.  
12:46 - But if we drag this event over and turn it back 
into a regular event, it has no conditions. So  
12:53 - when we preview the game, now, the character 
will be rotating constantly. But still, when I  
12:58 - press the D key, it will move over. I can copy and 
paste existing events rather than just constantly  
13:03 - creating new ones. And then I can modify this to 
make an effect a different object. Realizing that  
13:09 - this might be a little hard to see, I'm going to 
create one final event, I could click on other  
13:14 - conditions and manually search for the condition 
that I need. But since I know what I want already,  
13:19 - I'm just going to search for at the beginning of 
scene, which is a condition that only triggers  
13:24 - once at the beginning of the scene. And 
then I'll add zoom camera and type into.  
13:32 - You can delete individual actions and conditions 
by selecting them and pressing Delete as well  
13:37 - as entire events. And then you can press Ctrl Z 
or ctrl y to undo or redo anything you've done.  
13:45 - You can right click an event 
and move it into a group  
13:48 - groups are useful to help organize your 
project. Giving these appropriate names  
13:52 - is incredibly important. There are a few other 
things that you can add to your event sheet  
13:57 - like comments, which will help you label your 
game events to remind you of what each one does.  
14:02 - A couple of the more useful event types 
that you can add are for each object,  
14:07 - which is an event that will repeat every frame 
for every object of that type in the game.  
14:12 - So if I have 20 player objects in the game, 
then it will repeat for all 20 player objects.  
14:17 - Another commonly used event type is 
repeat, which, as the name implies,  
14:22 - is one that you can set up to repeat X number 
of times per frame. And speaking of per frame,  
14:29 - the engine reads the event list once per 
frame. If you go to the project manager,  
14:35 - you can see that the game is defaulted to force 
the game to run between 20 frames per second and  
14:40 - 60 frames per second. You can edit those if you 
need to. But I would generally leave this alone.  
14:46 - Let's quickly talk about organization. 
And I'll show you why it's important after  
14:50 - if we open up one of the starter games that you 
can use. You can see how nicely set up everything  
14:56 - is with comments and sub events set up to make 
sure that it's easy You'd understand at a glance,  
15:01 - rather than having to read every event to see what 
each one does. But you can further organize your  
15:06 - game using groups to group everything together, 
you can then pick a color for the group header,  
15:14 - and comments. To show you why organization 
is so important, I'll open up the events  
15:21 - for a game jam game that I made. If you don't 
organize your events from the beginning,  
15:26 - you'll find it getting out of hand really 
quickly, till you get to the point where  
15:31 - it's almost impossible to fix anything in your 
game. Because you don't know where the event is,  
15:36 - you can use the search bar to try to find 
it. But sometimes that's just not enough.  
15:42 - And now that we have an event complicated 
enough to show you how this works, I'm going  
15:45 - to really quickly go over how the engine checks 
events. So every frame the event list is checked.  
15:51 - But it checks the event list from top to bottom, 
checking each condition from top to bottom.  
15:57 - And then if that condition is true, 
then all of these actions will happen  
16:01 - from top to bottom. Now that you know the 
basics of the event system, I can go over all  
16:07 - the tools that G develop has integrated into the 
engine to help you jump right into making games.  
16:14 - When you open G develop, you'll be given the 
option to create a new project or open an existing  
16:19 - one. If you click on Create new project, you'll 
see a list of starter games and examples that  
16:25 - you can learn from and build off of, which 
are all under the MIT license. Which means  
16:30 - that you're free to use anything here for your 
projects that are just for fun, or commercially.  
16:36 - If we go back to these starter games, and click 
on one, you can see that it's loaded in all of the  
16:41 - objects and events required for this game. If I 
click on Preview, I can just play this game as is.  
16:48 - Most of these starter games are just the base 
logic you need for that type of game. So they'll  
16:53 - usually only have one example level in them. 
But you can build on those if you want to.  
16:58 - If we go back to the game that I was using in 
the previous video, I can show you behaviors,  
17:03 - behaviors or pre built logic that will help you 
make your games faster. You'll see that there's  
17:08 - a bunch of these that come with the engine. But 
we also have community built behaviors created  
17:13 - by other game developers that you can find by 
clicking here and searching those behaviors.  
17:18 - A quick side note here, these community built 
behaviors are the same thing as community built  
17:23 - extensions, the only difference being that 
they're filtered to only show you the ones  
17:28 - that apply to the object. If you'd like to see the 
full list of extensions, you can find that here.  
17:34 - If we go back to the default behaviors, we 
can click on top down movement and turn off  
17:39 - rotation. And then we have a character that'll 
move around on screen when I press the arrow keys.  
17:47 - So now if I go back in, I can add another 
behavior. And I'm going to pick draggable object.  
17:53 - So now I've got a character that can move around 
with the arrow keys. And I can drag it around with  
17:57 - the mouse. But now that I'm done with those, I 
can delete them. And now we'll talk about Pisco,  
18:05 - the engines built in image editor. I've mostly 
used this to correct the orientation of an image  
18:11 - by flipping it or rotating it. But you can use 
this to make brand new images or to edit existing  
18:17 - ones. Next up is the sound creation tool. J 
FXR. If you put in the action play a sound,  
18:25 - you'll see a prompt that will let you open up J 
FX are a tool that can be used to create a range  
18:31 - of different sounds by manually correcting 
sliders, or by randomizing them like this.  
18:51 - Next up is the engines Asset Library. If you click 
on add a new object, you can click here to create  
18:57 - one from scratch. Or you can search the asset 
library, which is currently a manually curated  
19:03 - collection of art assets that you can freely 
use in your games. When you click on an asset  
19:07 - that you like, you'll be able to see which artists 
created it and what license the assets are under,  
19:14 - you can click on the license to be brought to 
a page that will explain the license to you.  
19:19 - The CC zero license for example, means 
that you're allowed to use these assets  
19:23 - in your game, whether it be commercial or 
not, without having to credit the artist.  
19:29 - Other assets in the library, though, 
might be under a different license  
19:32 - that would require you to credit the artist. 
If you like a particular piece of art,  
19:37 - you can click on the name of the artist and 
it'll bring you to more works by the artist.  
19:42 - This for example is Kenny art, which is an 
artist whose work I'm actually using right now.  
19:47 - So to continue using their art, I'm 
going to grab this background tile,  
19:51 - click to add it to the game. And then I'm going 
to create a background layer and put the image  
19:55 - on it. Making sure to put the background 
layer below the base layer so it's behind it  
20:00 - And tada, my game now has a more interesting 
background. So those are some of the tools  
20:07 - that G develop has brought together to 
help you in jumpstarting the game making  
20:10 - process. You've got starter games and examples 
built in and community built behaviors. Pistol  
20:16 - for image editing, J effects are to help you 
with your sound effects, and the assets library.  
20:27 - So if I give the player character, the platform or 
behavior, give the ground the platform behavior.  
20:34 - And we'll give the B the physics engine 2.0 
behavior and then for giggles will give the ground  
20:41 - the physics behavior as well.  
20:56 - For the next portion, Max is going to take over 
and explain how variables work in G develop.  
21:06 - So variables are used whenever you want to store 
some information about your game. For example,  
21:11 - maybe the players health or the player score. 
And she developed a variable can live in one of  
21:17 - three places. It can live in the scene, which 
is useful for things like a level score that  
21:22 - is explicitly tied to a particular scene. It can 
live on the object which is useful for things like  
21:28 - enemy health that are tied to particular objects, 
in this case enemies, or it can live globally,  
21:34 - which is useful for things like say a player 
selected username that needs to be accessed  
21:38 - from everywhere within your project. Let's 
start by taking a look at scene variables.  
21:46 - As you can see, we have here a basic platformer. 
However, when we go to pick up a coin,  
21:51 - the score does not increase. We can fix this using 
variables. Start by going to the scene properties  
22:01 - and then clicking on the 
Edit scene variables button.  
22:05 - Here you can view all of your seen variables and 
also add new ones. We'll start by adding a new  
22:12 - score variable and setting its initial value to 
zero. Then when the player collides with a coin,  
22:19 - we'll add a new change a scene variable action 
which adds to the variable score the value one.  
22:29 - Then we add a new action without a condition 
which modifies the scene text object,  
22:34 - we'll use the variable string function which 
allows us to access a scene variable from  
22:39 - anywhere and then specify the score variable. 
And then finally put the text score in front  
22:46 - using the concatenation or plus operator 
to join the text with the variable.  
22:54 - Sure enough, our score counter 
is now working as intended.  
23:00 - Next, let's take a look at object variables. 
Right now our slime enemy does not move and  
23:06 - what we'd like is for it to move back 
and forth between these two markers.  
23:12 - We can start by opening the drop down menu on 
the slime object and selecting the Edit object  
23:17 - variables option. This will give us a list of all 
of our object variables on this particular object,  
23:24 - we can start by adding a new direction variable 
with an initial value of left. Then in our event  
23:31 - sheet, we can add to the slime a text of an object 
variable action, which sets the direction to left.  
23:40 - We call this one the slime is in 
collision with the left marker.  
23:44 - And then we can do the same 
thing for the right as well.  
23:48 - We can then use the text of an object variable 
condition to test the direction variable.  
24:00 - When it's left, we'll incorporate our game 
logic for moving the slider to the left.  
24:04 - In this case, adding a force and setting 
the flip state. And then we can do the  
24:09 - same for the right direction as well. And 
now our slime is no longer stationary.  
24:17 - Note that while we've written all of the events 
ourselves for this example, to demonstrate  
24:21 - variables, there's plenty of great behaviors 
out there to do this for you. We should have a  
24:26 - video on behavior soon if that is foreign to you. 
Finally, let's take a look at global variables.  
24:34 - Let's say that our platformer has multiple levels. 
If we look at the score as we transition between  
24:40 - these levels, you'll see that it resets. 
While this may be what we want, we also  
24:45 - might want more of a global score that stays 
the same when we transition between two levels.  
24:51 - We can start by going to the project manager 
where we will find the global variables button  
24:58 - then we can add these For variable 
much like we did earlier for the scene  
25:05 - now all we have to do is change our scene 
variable action to the corresponding global one  
25:16 - and then replace our variable string function 
with the global variable string function.  
25:25 - And now, sure enough, our score will carry 
on through seeing transition. Very nice.  
25:33 - Now that we've gotten through variables, 
I can show you the expression builder.  
25:41 - So to begin with, I'll show you 
where the Expression Builder is,  
25:44 - we go to the event sheet and pick an action, 
we picked the be enemy and select Rotate.  
25:51 - And trust me, the engine can do a lot more 
things than just rotate an object. But it  
25:54 - just seems like the thing that I picked the most. 
If I put a one in here, the be enemy will rotate  
26:00 - at an angular speed of one. But if I go to 
the expression builder here on the right,  
26:05 - you'll see there's a big list of things 
I can search from. These can range from  
26:10 - the size and width of an object to the distance 
between two objects, which I'm going to use now.  
26:17 - You'll see that I've multiplied it by 
one. And that's just to show you that this  
26:21 - basically works the same way as an algebra 
equation, when you're sticking to numbers.  
26:25 - So you can add, subtract, multiply, divide, 
use brackets, the whole nine yards. And then  
26:31 - if we go back to the main scene, and give the 
player object, the draggable object behavior,  
26:37 - and we press preview, we can then drag the 
player closer to the B. And as we do that,  
26:42 - you can see it's slowing down. And that's because 
the distance between the B and the player object  
26:47 - is getting smaller. So it's rotating at a slower 
speed. But if we move the player away from the B,  
26:53 - it speeds back up again, because it's getting 
further away. So the number is bigger.  
26:59 - Now let's get rid of that. And I'll show you 
an actual game related example. So I made these  
27:04 - objects earlier, we have a hard object, that's a 
sprite, and they hurt object that's a tile Sprite.  
27:11 - So if we put the tile sprite into the 
scene, within the camera's default border,  
27:17 - and then put it on the UI layer that I made 
earlier, then we can build this first event where  
27:23 - when I release the left mouse button, one time, 
we'll create the heart sprite object at the x&y  
27:29 - position of the mouse, then we'll make a second 
event with the condition if player is in collision  
27:36 - with heart, and then we'll make the action to 
modify the object variable of the player. If we  
27:42 - click on this tool button to the right will 
be shown this objects object variable list.  
27:47 - And since it didn't have any, I'm going to click 
Add and give it an object variable of health,  
27:52 - and then two as the number. So now when 
I click here, it'll show me my options.  
27:57 - And I'll select Add, because what I'm 
trying to do is add to the players health,  
28:01 - and one. And then I'm going to create 
an action that shows that the player's  
28:05 - health has changed. So if I select the heart 
UI object, and select the width of the object,  
28:12 - I'll select it to set to and then click on the 
Expression Builder tool, search for object and  
28:17 - select objects variable. Select the player as the 
object. And you can see I can click here again,  
28:25 - to display this objects variables. I'm going to 
select Health. And because I know the size of the  
28:30 - heart that I made earlier, it's 64 pixels by 64 
pixels, I'm going to multiply this width by 64.  
28:38 - This is only going to work because it's a tiled 
Sprite, if I pick the regular heart object, which  
28:42 - is a sprite, it would just get all squished up. 
Now let's move this into its own event. So it's  
28:48 - checking this every frame. And then as a final 
action, we're going to add, delete the heart.  
28:55 - And just to show you that the player doesn't have 
to be the thing that gets the platformer controls,  
28:59 - you can literally put these behaviors on any 
object, I'm going to put it on the heart. So  
29:05 - what's happening here is that each frame we're 
changing the heart UIs size to match the player's  
29:10 - health. And every frame that the left mouse button 
is released will create one hurt object at the  
29:16 - mouse position. And every frame that the player 
is in collision with a heart, it will add one  
29:22 - to the object variable health of the player 
object, and then it will delete that hurt.  
29:27 - So now if we press preview, you'll see the 
health UI is up at the top showing two hurts  
29:32 - because it's expanded to two times 64 Because 
the players object variable health starts at two.  
29:40 - And now if I release the left mouse button, 
it creates a heart at the x&y coordinates  
29:44 - of the mouse. And it does this every time I 
click. If I drop one directly on the player,  
29:50 - you'll see that it's added one to the object 
variable health because it's being displayed  
29:55 - up top and it will keep adding health 
as long as they keep giving it hurts  
30:02 - In the next portion, Max is 
going to go over extensions.  
30:09 - You'll see here I've made a fairly simple dungeon 
crawler with one enemy and one piece of treasure  
30:15 - to find. As it stands, though, our game leaves 
a lot to be desired. For example, maybe we want  
30:21 - to be able to hold down our mouse and shoot at 
a fixed cooldown rather than having to click a  
30:26 - button each time. Maybe we want a smart enemy 
that can Pathfinder around walls to get to us,  
30:31 - rather than just running into them. And maybe we'd 
like the one to point at the cursor. For a more  
30:36 - interactive gameplay experience. We could try to 
implement this functionality ourselves, or we can  
30:42 - use functions and behaviors known more broadly as 
extensions. Extensions allow us as game creators  
30:49 - to spend less time reinventing the wheel and more 
time actually making our game. As an added bonus,  
30:54 - you'll find that using extensions leads to a 
much cleaner event sheet, which will help a  
30:58 - lot as your project grows. So let's take a look at 
how to use them. We can get started with behaviors  
31:05 - by opening the drop down menu for an object 
and selecting the Edit behaviors menu option.  
31:12 - You can then add a behavior with the added 
behavior button. And then you'll be presented  
31:16 - with a list of built in behaviors native to do 
develop. There's also a plethora of community  
31:22 - made behaviors available through the search new 
behaviors option. For this project, we'll select  
31:27 - the fire bullets behavior and install it. And 
then we'll see it in our list of new behaviors,  
31:33 - we can then add it to our object by clicking on 
it. And then we'll find the behavior properties  
31:39 - here. These give us some more control over how the 
behavior will act. So in this case, we can set the  
31:45 - cooldown when we fire a bullet. Now when 
we select our objects in the event sheet,  
31:51 - we'll find that it's been basically 
supercharged with new abilities. In this case,  
31:56 - our one now has a fire a bolt action, which 
we can use to fire bullets towards the mouse.  
32:09 - Now, another problem with our game is that, well, 
our AI is a little bit more a than I, we can fix  
32:17 - this by implementing pathfinding, which is just 
another behavior in our list, but with a behemoth  
32:23 - of a behavior property list. We'll go over how 
to actually implement this in a future video.  
32:34 - Finally, in addition to behaviors, there 
are also functions, which can be accessed  
32:38 - from the Project Properties panel, followed by 
opening the function slash behaviors menu. This  
32:44 - is where you can find community made functions as 
well as behaviors. As for using functions. Well,  
32:50 - there are a lot like behaviors, but 
they're not tied to specific objects.  
32:53 - They can do things like for example, align stuff 
in your scene, or in the case of this project,  
33:00 - rotate a wand about a character and pointed at 
the cursor. looks much better now. But you think.  
33:19 - Now that we've gone through everything 
that I consider to be the basics,  
33:22 - we're going to build a game. More specifically, 
we're going to recreate asteroids.  
33:31 - I won't be showing you how I'm creating these 
events, just the ones that I'm using, but I  
33:36 - will be showing you what I'm doing. So to begin 
with, I'm going to be using this space shooter  
33:42 - Redux pack. And I'm going to jump right into 
a blank game project. I'll create a new scene,  
33:48 - and I'll create a sprite object named Player. For 
this example, I'm going to take advantage of the  
33:54 - physics behavior that comes with G developed 
by default. And I'm going to start by leaving  
33:59 - everything alone except for changing the gravity 
to zero, so that the object doesn't just fall  
34:04 - out of the sky. So now we'll move over to the 
event sheet, and start with a player movement  
34:10 - with the condition if the W key is pressed, and 
then the action, apply a physics force towards  
34:17 - the angle the player is facing. And then I'm going 
to move the origin of the sprite into the center,  
34:22 - so that we can use that origin point as 
the point where forces will be applied.  
34:27 - And then we'll copy our condition for our first 
event, and then paste those for the A and D key  
34:32 - presses. And then we'll apply a torque to the 
player object based on which key is being pressed.  
34:38 - Take note, this is not just the rotate an object 
action. This is apply a torque. It's specific to  
34:45 - the physics behavior. And I'm using this because I 
want to make sure that all of the forces are being  
34:50 - applied using the same kind of rules. And now 
I have a character that spins out of control.  
34:58 - The problem here is that the sprite isn't the 
wrong orientation. So I'm going to open up Pisco,  
35:03 - change its orientation, and then save it. With 
that part fixed, I'm going to move on to firing  
35:09 - bullets, using the conditions when the spacebar 
is released, and once. And as you can see,  
35:15 - I've created the bullet object already. And since 
the bullet is a really bright color, I'm going to  
35:20 - change the background of the scene to black, so 
it stands out better. And now for the bullet, we  
35:26 - put the action create object and add a force and 
rotate object. But moving the Rotate action above  
35:34 - the apply a force action, because we want to make 
sure that it's rotated before it starts moving.  
35:39 - And the bullets orientation is off just like 
the players was. So I could go into pistol and  
35:43 - change the orientation of the bullet just like I 
did with the player. Or I can add 90 degrees to  
35:49 - the rotation and changes so that the players angle 
is the thing that tells it which direction to go.  
35:55 - And after we tweaked the origin of the 
bullet, just like we did the player,  
35:59 - it works just fine. Though I do have to change 
the Z order, so that the bullet spawns below  
36:05 - the player and not on top. And that's the player 
basically done. Next, we'll make another event  
36:11 - for the beginning of scene, where we're going to 
change the center of the camera to the zero point  
36:16 - and change the zoom to 0.5. Changing the camera 
to the 0.2 so that we could easily do screen wrap.  
36:23 - And zooming the camera out was just so that we 
would have a better scale for an asteroid game.  
36:29 - Now let's add some asteroids will add in some 
animations and give them the physics 2.0 behavior  
36:35 - plays a couple of scene. And we'll do that 
again with medium and small asteroids. And  
36:41 - now because everything has the physics behavior, 
I can start knocking things around like marbles.  
36:46 - And just like an asteroids, we're going to make 
it so that when you shoot an asteroid, it blows up  
36:50 - into smaller parts. So we'll create a for each 
instance event where the object being picked  
36:55 - is the big asteroid, use the condition. If bullet 
is in collision with asteroid, then we will create  
37:02 - two medium asteroids, give them a random rotation, 
and then apply a force in whichever direction  
37:08 - they're facing. And then we delete the original 
asteroid and the bullet. And then we do that two  
37:14 - more times. With the only real difference being 
that the small asteroid doesn't spawn anything,  
37:19 - it just gets deleted, we're getting 
pretty close to this being asteroids,  
37:23 - we're just missing a couple of things. The 
most noticeable one is the screen wrap.  
37:28 - So we're going to create a for each instance 
event. And for the object pick this time,  
37:32 - it'll actually be the group everything. 
Because I put everything in one group,  
37:38 - this games resolution is 800 by 600. And 
because we moved our camera to center on zero,  
37:44 - then we can use this condition. If an object in 
the group, everything goes beyond 800 in the x  
37:50 - direction, or goes behind negative 800 in the 
x direction, then it will have its exposition  
37:56 - times find negative one, which will flip it to the 
other side. And then we just do the same thing for  
38:02 - the y direction. And now we're almost there. The 
last thing that's needed for this to be a game  
38:08 - is a failed state. So we're going to go 
to the project manager and look for the  
38:12 - extension health. We'll add that to the project. 
And now we'll go to the player and select Health,  
38:20 - giving a three as its total, and a five 
second cooldown until it can be damaged again.  
38:25 - Then we'll create a tiled sprite and 
call it lives. Place it in screen into  
38:30 - the default border of the camera, putting 
it onto the UI layer that I made earlier.  
38:36 - And then we use the physics condition 
if the player collides with everything.  
38:41 - Note that this will ignore the bullet because 
the bullet doesn't have the physics behavior. And  
38:46 - then we'll add the action damage player from the 
health extension and then add an action to change  
38:52 - the width of the tile Sprite. And then we'll copy 
that action and put it at the beginning of scene  
38:57 - so that it modifies the width of the sprites 
at the beginning of the scene as well.  
39:01 - And the one last thing we need 
now is for the players to die.  
39:07 - This specific condition comes from the health 
extension, and then we'll delete the player.  
39:12 - But on top of that, I'm going to create a text 
object called game over and put that on screen  
39:18 - and have it hide during the beginning of the 
scene and show up again when the player dies.  
39:24 - And that's how long it takes to recreate asteroids 
in G develop. The only real problem being that the  
39:29 - game doesn't have any sound. And it isn't very 
much fun to play. It's technically a game, but  
39:35 - it's missing all of its life. We need to add sound 
effects and screen shake and particle effects and  
39:40 - all that stuff. So let's get started. For now, 
when the player dies, they just get deleted.  
39:47 - So instead we're going to create a particle 
effect. To replace that. We're going to make  
39:52 - sure that the ship has a minimum rotation 
and that there's only one particle in tank  
39:57 - and we'll make sure to rotate the particles 
so it starts with a player stopped.  
40:02 - And now we have a ship that 
kind of falls into space.  
40:06 - And we'll use the second particle using 
some points to give it a little more flair.  
40:12 - And we could definitely make our game 
over text look a little more impressive.  
40:16 - So we're going to give it a custom font, this 
being the font that I use for everything developer  
40:20 - related. And then if I give it the glitch effect 
from the effects menu, it will look like this,  
40:27 - which is certainly an improvement. Next, we're 
going to create some debris for the asteroids  
40:32 - for when they explode. And just like the ship, 
we'll be using the texture of the asteroids to  
40:37 - make the effect. And doing this just makes it 
more satisfying to look at when the asteroids  
40:43 - explode. A big problem with this game so far is 
the lack of player feedback. Specifically when  
40:49 - you get hit, so we're going to go to behaviors, 
and add the flash or blink behavior to the project  
40:57 - will slot that action into the event where 
the player gets hurt. And now you can see  
41:02 - that the player flashes when they get hit. Another 
aspect of player feedback would be sound effects,  
41:09 - something that this game really needs. So we're 
going to open up GFX there, randomize the sound  
41:15 - effect until we get something that we like. And 
then title it laser fire and save it. You may  
41:21 - want to put it in a variable for the sound here, 
but I'm just going to put it in 150. For now,  
41:26 - for sounds that happen once in a while, you can 
just put one here, but for sounds are going to  
41:30 - happen over and over again, you want to have 
a randomized pitch. Otherwise, you're going  
41:35 - to drive your players insane. So to randomize 
something, all we have to do is type in random,  
41:40 - and it will show us our options. And I'm going 
to pick random float in range, and put in 0.9  
41:46 - and 1.1. This means that every time the sound 
effect is played, it will pick a number between  
41:52 - 0.9 and 1.1. To play at, I'll slide that 
action over to where the laser effect is  
41:58 - actually happening. But we're going to do this for 
everything in the game, which includes a collision  
42:03 - effect when the player runs into an asteroid and 
an explosion sound when the asteroids explode.  
42:08 - And now we need just one more thing as far as 
effects go. And that's the camera shake. So we're  
42:13 - going to add that to the project, and then go to 
the getting hurt event and adding it as an action.  
42:20 - And there we go. And now for a little more polish, 
we gave all the asteroids a bunch of animations.  
42:27 - So we're going to go to the beginning 
of scene event and use the action  
42:31 - change the number of the animation. And 
this time, we're going to use random three,  
42:35 - because the big asteroid has four 
animations, and the zero counts as a number.  
42:40 - And now if we start the scene, you'll see 
that they've all picked a different image.  
42:45 - And now for the somewhat tedious part of tweaking 
things, making sure that your collision masks make  
42:50 - sense with the objects, and then play testing 
it. And then making sure that your speeds and  
42:55 - densities are all the way you want them. And then 
you play test it again, and again. And again.  
43:01 - And again. And again. And again. And again. And 
again. And again. And this is a bit subjective,  
43:09 - but you keep play testing and tweaking 
it until the game feels good to play.  
43:19 - Now that we've created a game, we should 
do a few things before we export it.  
43:23 - So we're going to go to the Properties manager, 
go to game settings and open up properties. We're  
43:28 - going to give the game the proper name, give 
it its version number, change its package name,  
43:35 - make sure that you're listed 
as one of or the only author.  
43:40 - Make sure that you've chosen the right option 
for how the game should expand in a screen.  
43:45 - And of course, for mobile games, you want to make 
sure that you've chosen your device's orientation.  
43:50 - And finally, make sure that you've put in 
a publisher name. One more thing to do too,  
43:56 - is to give your game icons. All you have to 
do is click up here, give it a square image,  
44:01 - and it will turn that image into an 
appropriate size for all the devices.  
44:06 - Once that's all done, we can export our 
game, we go up to file, click on Export.  
44:14 - And right now we're given two options, share 
with friends, which will give you a link that  
44:18 - you can share with your friends or people that 
you want to play test the game or publisher game.  
44:25 - You can build it manually if you know how. 
But I'm just going to click on the button  
44:29 - that gets the engine to build it for 
you. We're showing four different tabs,  
44:33 - starting with the web build, which will create a 
HTML file that can be played in browser. Next is  
44:40 - the mobile export, where you can release 
an APK to be used on devices generally,  
44:46 - or an Android app bundle, which is the kind 
of bundle that you need to submit a game to  
44:51 - Google Play. The next type is for exporting a 
game to Windows, Linux or Mac iOS. And finally  
45:00 - There's instant games, which are posted to 
Facebook with a Facebook developer account.  
45:05 - Now, g develop is free, entirely free to use and 
export from. But there are restrictions for these  
45:12 - automated builds. Because it cost you develop 
money to host the servers that they're built on.  
45:17 - So with G develop, you get two free builds per 
day from mobile or desktop. If you pay for a  
45:22 - subscription to a G develop account, you get more 
exports per day. But publishing a HTML build is  
45:30 - unlimited. So excuse me for breaking the illusion 
for one second. Oh, no, I'm on a regular old PC.  
45:41 - Okay, so we create a new folder called game, or 
whatever your game is called. Go back into the  
45:48 - engine, click choose folder, find that folder and 
select it. And then just press export. So now all  
45:56 - of the game's files are in this folder and ready 
to go. All you have to do is compress it to a zip  
46:00 - folder. And that zip folder is your game. But let 
me quickly show you how to do it for a PC build.  
46:08 - So we go to exports publisher store, make sure 
that Windows auto installer file is selected,  
46:14 - and then just click package. And then you just 
wait. You'll get this notification here down  
46:22 - at the bottom. And if you click that button, 
you'll get a periodic email that gives you some  
46:26 - stats about your game. And if you just click 
that Windows button there, it will download  
46:31 - to your download folder. And then you'll have 
your game on your computer. I hope this video  
46:37 - was able to help anybody out there who wanted 
to try out g develop and making their own games,  
46:42 - but just didn't know where to start. Thank you 
for watching, and best of luck with your games.