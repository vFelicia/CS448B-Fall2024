00:00 - hello thanks for tuning in this is a
00:02 - recording of an online training session
00:04 - which was a beginner level class on the
00:05 - node.js runtime this was a freestyle
00:08 - interactive no slides just me typing
00:11 - good and talking about it so let me
00:12 - apologize in advance for all the speech
00:15 - fillers I did however cut out the pauses
00:18 - and the not useful parts so you can
00:20 - watch the whole training here on YouTube
00:22 - in one video it's 2.5 hours but it's
00:25 - also available at Gia's complete dot-com
00:27 - /gs and 19 where i split it by topic
00:30 - into many videos you can also use the
00:32 - timestamps links in the description to
00:33 - navigate to the different sections if
00:35 - you think of any questions while you
00:37 - watch this please feel free to join the
00:39 - JISC complete slack channel I just
00:41 - complete that comm slash help and ask us
00:43 - there I hope you enjoyed this class and
00:45 - please share it with your network if you
00:47 - know anyone who plans on exploring
00:49 - nodejs let's get started so this is a
00:53 - beginner class on node so uh no
00:55 - assumptions about what you know about no
00:57 - this is your first steps you know I
01:00 - might be assuming that you know a little
01:03 - bit of JavaScript and I am definitely
01:05 - assuming that you know programming in
01:07 - general so depending on on your skills
01:09 - you might be you might be overwhelmed or
01:12 - you might be disappointed with the
01:13 - content we all have different skills and
01:15 - this is natural but I hope most of you
01:19 - will learn a few things anyway the class
01:21 - is recorded so if you're lost in the
01:24 - class go fill the gap in your knowledge
01:26 - and come back and watch the recorded
01:28 - class so my name is Sam Urbana and I
01:32 - have been doing an ode for a while
01:34 - currently I do note on the back end and
01:38 - I do react on the front end but before
01:41 - that I did a lot of other programming
01:43 - languages I did some tickle Ruby I did a
01:46 - lot of pee sequel but now it's all node
01:49 - so and I am a really big fan of node and
01:53 - everything all the libraries that make
01:56 - that are added on top of the JavaScript
01:59 - language which itself is very flexible
02:01 - and it can do whatever you want it to do
02:04 - so if you want to see the stuff that I
02:06 - do I put links here feature links on on
02:09 - this website and also I publish
02:11 - everything I do on juice
02:12 - complete calm so there are video courses
02:15 - books interactive labs and a lot more
02:18 - Jes complete calm by the way is a node
02:20 - project so this is written in node and
02:23 - react on the front end so I have been
02:27 - hacking on this platform and it's really
02:30 - fun so no no this node is really funny
02:33 - well at least for me so let me set some
02:37 - expectations about the class today
02:40 - before we begin so this is not going to
02:44 - make you an expert on node right this is
02:47 - just your first step so just to get you
02:50 - familiar to raise your confidence in the
02:52 - platform and to get you started on the
02:56 - right path to learning node because I
02:58 - think a lot of people learn node the
03:00 - wrong way they focus on the packages
03:03 - that that comes with node or like that
03:05 - the third-party packages that are very
03:07 - useful but I think there is a big
03:11 - benefit in to learning the internal you
03:14 - know the the raw runtime before you go
03:17 - and use the packages and and that
03:19 - knowledge is gonna make you make your
03:22 - use of those packages much better so uh
03:25 - the one thing that you need for sure is
03:27 - you need node so so if you have a node
03:32 - version let me make this a little bit
03:35 - bigger if you have a node version that
03:38 - is 10 or higher you're fine I think it
03:42 - will be fine too but if you have an
03:43 - older node version so go ahead and
03:45 - install node I encourage you to always
03:49 - experiment with the latest and greatest
03:52 - always have the at least the latest LTS
03:55 - release but I actually do my development
03:58 - on the current version even if it's an
04:01 - odd number because odd number they're
04:02 - not gonna be LTS so the way this works
04:05 - is even numbers are LTS which is long
04:08 - term support odd numbers are not so
04:11 - right now we don't have any odd numbers
04:13 - this is an even number but it's not
04:14 - LTS yet it goes into LTS maybe in a few
04:19 - months right so LTS will become no 12
04:21 - will become LTS and they start with node
04:23 - 13 which is not LTS it's
04:25 - experimental but always try to have the
04:28 - latest node so that you get to start
04:31 - exploring the new features that come to
04:33 - language and so that you detect problems
04:35 - going away because once you have the
04:37 - latest if you using something that is
04:39 - deprecated you're gonna get warnings and
04:41 - it's just so much better overall but
04:44 - definitely you have to test your systems
04:47 - on the LTS that is that you're gonna use
04:51 - in production right so for example just
04:55 - complete comm is running right now on
04:57 - this LTS so even though I develop I'm
05:00 - and I add features on 12440 if I have it
05:04 - I still locally I still switch things to
05:08 - the LTS and test things on LTS just give
05:12 - the whole system I go on the LTS before
05:14 - releasing a big release so there are
05:17 - tools for you to switch around so if
05:21 - you're on Mac you should definitely have
05:23 - homebrew homebrew is just the best way
05:25 - to to this one the missing package
05:29 - manager from node the best way to
05:32 - install node and install many other
05:33 - packages around node but there's also
05:38 - nvm so nvm and there's a version for it
05:41 - for Windows as well is note version
05:43 - manager so if you have nvm install now
05:46 - you can install node and you can install
05:48 - different versions of node and you can
05:50 - switch between these versions with the
05:54 - press of a command so you get to
05:56 - experiment with many versions of node
05:59 - and that's that's great so what is what
06:03 - is node exactly so when you have the
06:05 - node command when you install node you
06:07 - get three commands you get the node
06:09 - command you get the NPM command and you
06:13 - get the npx command all of these comes
06:15 - built in with node
06:17 - so node is a wrapper around v8 so v8 if
06:24 - you're not familiar with v8 v8 is the
06:27 - JavaScript engine not the juice the
06:29 - JavaScript engine man the a JavaScript
06:34 - the JavaScript engine that powers chrome
06:38 - itself
06:39 - so I am in Chrome right now and if I go
06:43 - in here and open up the console and put
06:46 - in any JavaScript so map the random for
06:49 - example this is a JavaScript function
06:51 - this is the JavaScript standard library
06:53 - and chrome just executed that JavaScript
06:56 - it did that through v8 so they extracted
07:00 - everything JavaScript from chrome into
07:02 - this v8 engine and of course every
07:04 - browser has its ancient a different
07:06 - engine so IE has a chakra there's chakra
07:10 - there's spider monkey and and a few of
07:14 - them now this is different then
07:18 - executing a browser API so for example
07:21 - if I do document dot get element by ID
07:25 - right and or get element by whatever
07:28 - that is that is Dom API that has nothing
07:34 - to do with JavaScript it just have a
07:36 - JavaScript interface so the this is a
07:40 - JavaScript object document is a
07:42 - JavaScript object but get element by ID
07:44 - is an API on that object
07:46 - same thing for things like set timer set
07:49 - timeout set interval these are just
07:51 - functions that gives you access to the
07:53 - browser API these are not JavaScript so
07:56 - set time app is not implemented by v8
07:59 - it's implemented by the browser itself
08:01 - so when you get the browser you have two
08:03 - things you have v8 that runs everything
08:04 - JavaScript and you have the browser
08:06 - itself that runs everything DOM and
08:10 - scrolling for example a handle scrolling
08:13 - and handle resizing all of these events
08:15 - are coming from the browser but here's
08:17 - the thing everything runs in a single
08:19 - thread so if you have a big giant for
08:23 - loop in here that takes for a billion
08:25 - times that loop is gonna block the
08:27 - browser from doing things like scrolling
08:29 - so if the for loop is running the
08:31 - background the user cannot scroll your
08:33 - page so it is important for you to
08:36 - understand that this is a single
08:37 - threaded environment however the browser
08:40 - gives you an API a synchronous API is to
08:44 - do things asynchronously so that you
08:46 - don't have to block as a single thread
08:49 - that you have the exact same story is
08:53 - note so note just like the browser is
08:56 - also a wrapper around v8 so you get to
08:59 - execute so if we have the note command
09:02 - just type in the note command node and
09:05 - you get into this node that we call
09:07 - grapple mode run eval print loop and
09:11 - it's the exact same mode that you get
09:13 - when you open the browser's console this
09:15 - is also a rebel mode so in here you can
09:19 - just do math dot random math dot random
09:21 - and you get the exact same thing so this
09:24 - is through node right but note we really
09:27 - didn't do anything here know just pass
09:29 - this command to v8 and v8 executed math
09:32 - dot random v8 old node what the result
09:35 - of math.random is and note printed it to
09:38 - our screen right here so it's going back
09:41 - and forth between node and mv8
09:44 - so the question is why can't we just use
09:46 - the eight directly you can of course but
09:49 - no it comes with a lot of other benefits
09:52 - around the the core standard library
09:54 - right for example there is let's say
09:58 - nationally to be server you can just
10:00 - start using an HTTP servers there was a
10:02 - package here called HTTP and it gives
10:05 - you access to starting and HTTP server
10:07 - and just like HTTP there is a lot of
10:10 - them in fact let's take a look at all of
10:13 - them right away so I'd like to point
10:16 - your attention to a very very important
10:19 - key on your keyboard ready it is the tab
10:22 - key which is above the caps lock right
10:27 - this tab key is important because of the
10:30 - discoverability it gives you discover
10:32 - discoverability powers so for example if
10:35 - you are if array is a javascript class
10:39 - right and it has many methods if you tap
10:42 - DoubleTap on array dot so just do array
10:45 - dot and double tap you get everything
10:48 - that the available on array this is this
10:51 - is a great discoverability because I
10:53 - don't have to look up the things that
10:55 - you can do especially if you have an
10:56 - object like a mystery object that you
10:58 - don't know what it is right so if you
11:00 - have give you em and you don't know what
11:02 - M is you can just see all the methods
11:04 - that you can do
11:06 - that look like em is an array because I
11:07 - get to join and split than Keys and
11:10 - splice and reverse so it isn't the radio
11:12 - everything I can do and if you double
11:14 - tap on an empty screen on an empty line
11:19 - you get everything that you can start
11:22 - with so all the JavaScript classes
11:25 - you'll see here all the JavaScript
11:26 - classes because you know it's a
11:28 - wraparound JavaScript but also get
11:30 - everything that is note so you see HTTP
11:33 - HTTPS everything that starts with a
11:36 - lowercase letter most of the things that
11:38 - start with a lowercase letter here are
11:40 - built in node so libraries that just
11:44 - come with node you don't have to install
11:45 - them those are things that you can just
11:47 - start using so node is not a product
11:52 - from chrome node is an open-source
11:55 - community managed project but it uses a
12:00 - product from Google which is v8 so v8 is
12:02 - Google Google manages v8 and a node uses
12:06 - v8 and it uses other stuff not just v8
12:08 - for example it uses open SSL and a few
12:13 - other libraries like that also you can
12:16 - use node with other VMs so you don't
12:18 - have to so there's an experiment or a
12:20 - project where you can use node with
12:22 - chakra which is the chakra core the ie
12:25 - thing you know the powers IP edge so you
12:30 - can run node without v8 with using
12:33 - chakra core but by default when you
12:36 - install node you get the node that's
12:38 - wrapped around v8 ok cool so this list
12:43 - here is really important in fact I would
12:46 - say if you want a master node you have
12:48 - to learn every single item on this list
12:50 - I still I'm still learning new stuff
12:53 - because new stuff comes all the time but
12:57 - most of this stuff is JavaScript so if
13:00 - you are not familiar with things like
13:02 - date function not a number errors object
13:06 - reflect simple these are JavaScript
13:09 - things week map modern JavaScript right
13:12 - it buffers array integers array floats
13:15 - are a map promise regular Express
13:19 - Shen's weeks that all of these are
13:21 - modern JavaScript that you get to use
13:23 - out of the box with note and the other
13:27 - stuff that I'd like to point out to the
13:29 - things that we will explore today we so
13:34 - console is is a the same library that
13:38 - the same you know object that you have
13:40 - in your in your browser's console and
13:41 - they try to mirror the exact same
13:45 - interface for it in node but console is
13:48 - not-it's not v8 it's written in node and
13:50 - it's in the browser it's not v8 it's the
13:52 - browser itself so today we're going to
13:55 - talk about console we're going to talk
13:56 - about the module object will mention
13:59 - path will mention timers we're going to
14:01 - talk about timers in general we're also
14:04 - gonna talk about HTTP maybe a little bit
14:07 - of net so there's a question what is M
14:10 - p.m. how is it related to u node we're
14:12 - gonna talk about that so you're running
14:14 - node.js on shell on Mac what I should
14:17 - run on Windows command prompt yeah so on
14:20 - Windows you can run the CMD I would
14:23 - recommend that you instead of CMD that
14:27 - you install PowerShell so power fell by
14:30 - in Microsoft is just a much better
14:33 - terminal than CMD and by the way there
14:36 - is a new terminal coming to Windows so
14:38 - that is gonna be much better right but
14:41 - PowerShell is the way to give for now
14:44 - what is the IDE tool to cold the IDE
14:48 - that I'm gonna use is called vs code so
14:52 - it is probably the most popular editor
14:59 - so if you wanna run anything I'm working
15:02 - on we're gonna use it today and I would
15:04 - recommend that you use it now in fact it
15:06 - on Windows I vs code will give you a
15:09 - better terminal so you can use the
15:11 - terminal in vs good instead of using you
15:14 - know the command prompt or anything all
15:17 - right
15:18 - what is I term to so I turn to is just a
15:20 - replacement for the built in terminal
15:23 - it's just a little bit better than the
15:26 - built in terminal has better team ox
15:28 - integration but you don't have to use it
15:30 - but get put
15:31 - only less explore it if you if you see
15:34 - node is not a recognized command that
15:37 - means you have to fix the path so you
15:40 - have to put the node that was installed
15:43 - in the path so we talked a little bit
15:46 - about node rebel right node also is a
15:49 - command-line tool so if you do node - H
15:53 - you get everything that you can do in
15:56 - node as a command-line tool we see a lie
15:59 - of node so this is this is the CLI
16:01 - that's gonna run a script in general but
16:04 - it also you can use it with other
16:07 - options so you'll see the usage here
16:09 - node options and then you give it a
16:11 - script if you want it to run a script
16:13 - another another usage is node inspector
16:16 - we'll talk about that how to inspect a
16:18 - script in node and all of these options
16:20 - just scan through them they're handy I'd
16:23 - like to point out one particularly or a
16:29 - few particularly helpful options if you
16:31 - want to check the syntax of an ood file
16:33 - and not run it just check the syntax -
16:36 - see if you want to execute don't use e
16:39 - use P because P is execute and print so
16:44 - I'll sure let's let's explore that so if
16:47 - I have no - P and you just give it any
16:51 - JavaScript and it will execute it and
16:53 - print it right away so that p is for
16:56 - print a handy to just do things really
17:00 - quick and and you and the other one that
17:03 - i'd like to point your attention to is
17:05 - v8 options v8 options so if you do - -
17:09 - v8 options what you get is a big list of
17:13 - all the options that node can pass to v8
17:18 - so let's let's explore that I'm gonna
17:19 - pipe it on less so that we get at page
17:21 - by page so if he ate options so in here
17:24 - you're gonna see a lot of things right
17:26 - you're gonna see harmony flags you're
17:30 - gonna see tracing flags and this listed
17:33 - like 400 or 500 options that you can do
17:36 - and and these are options that note pass
17:38 - directly to v8 so if you wanna change
17:43 - the way v8 be
17:44 - change the or a little optimization of
17:48 - the way v8 behaves or or change some
17:51 - experimental flags right if you want to
17:53 - experiment with you know webassembly
17:56 - right here there's a flags from rep
17:57 - assembly so most of these options are
17:59 - actually advanced I just want you to
18:01 - know of them so you can come to these
18:04 - options and and and search if you if
18:07 - you're looking to do party some
18:08 - something particular with with the like
18:11 - something advanced like like for example
18:13 - if you're if you're to work with the
18:15 - garbage collector in the a drive v8 has
18:17 - a garbage collector you have some
18:20 - options here to control the garbage
18:23 - pointer to expose the garbage collector
18:25 - to manually run the garbage collector so
18:27 - you'll come here and see all the options
18:30 - that you can do alright cool
18:32 - another thing that you should be
18:34 - familiar with is node environment
18:37 - variables so when you run a node process
18:42 - right when you run the node command
18:44 - whether you put in a file or you just
18:46 - run it with you know the rebel mode well
18:49 - what I did here is I started an
18:51 - operating system process right a process
18:55 - with a process ID and node I exposed
18:59 - this process object so there's a process
19:02 - object that has a few methods a lot of
19:04 - methods actually and this process object
19:07 - is basically the interface between your
19:10 - node environment and the operating
19:13 - system environment so if you need to
19:15 - read anything from the operating system
19:17 - or if you need to write anything to the
19:19 - operating system then you use this
19:22 - process object so it's the interface so
19:25 - this interface for example exposes the
19:28 - environment variables so all the
19:30 - environment variables that you have in
19:31 - your system just with process the in
19:33 - this give you access to everything
19:35 - invite in the environment that you have
19:38 - which is a cool way to customize your
19:41 - notes session so you just put something
19:43 - in the environment hopefully I don't
19:44 - have any passwords in here you put
19:46 - something in the environment and you can
19:48 - just access it in node right including
19:52 - things like you know including
19:58 - the built-in environment variables so so
20:01 - so the built-in environment variables
20:03 - are special environment variables that
20:07 - if you set them if you set them then you
20:10 - you get to change the behavior of note
20:13 - however before I talk about that let me
20:15 - show you how to control the environment
20:16 - is this is this is important so let's
20:19 - say no - P and let's let's print process
20:24 - the end the user user is a standard
20:30 - environment variable right so this is
20:31 - the user that I'm using if you want to
20:33 - change that all you need to do is just
20:35 - specify a different user right and no it
20:39 - will just use a new value that you put
20:41 - in here instead of you know that's set
20:43 - in value because I changed the
20:44 - environment variable before executing
20:47 - node and of course I can do export or
20:49 - step on Windows to change it for to
20:53 - change it forever you cannot change
20:55 - there's a very good question from Amith
20:58 - you cannot change the environment
20:59 - variable through process the end it's
21:01 - not it's read-only things although you
21:04 - can actually change it so you can do you
21:08 - know equal tests but this will not
21:11 - change the environment variable here
21:14 - okay so I think if you do that right and
21:18 - try to echo a dollar sign user after
21:21 - that it did not change it so node will
21:25 - not tell you that oh you can't change it
21:27 - it's not really immutable but you get a
21:33 - copy you don't you get a copy of the
21:36 - object all right so let's keep going
21:38 - if you have so if you want to change
21:40 - some kind of behavior I'd like to point
21:42 - your attention to a few of these
21:45 - environment variables one one one handy
21:49 - in particular is note debug so if you do
21:53 - if you use a library like for example
21:55 - HTTP and you'd like node to debug more
21:59 - information about what it's doing in
22:02 - HTTP you can you can do something like
22:05 - this so you can note debug I think you
22:07 - just do HTTP and then run your node
22:09 - command
22:10 - and this will tell node to debug more
22:12 - information when it uses the HTTP
22:14 - library so very handy when you start
22:17 - running into problems you can change its
22:19 - a path so this is another important one
22:22 - that we're gonna talk about we're gonna
22:23 - actually talk about that next it is how
22:26 - to control how no discover modules so
22:30 - let's go ahead and jump into the more
22:32 - serious mode which is to run node in to
22:36 - run a script so I'm gonna create a
22:38 - directory so node I'll just do 0 6 19
22:45 - and I'm gonna go into this directory not
22:48 - this one and I'll just run vs code on
22:55 - this directory to start exploring things
22:57 - and I'll actually let me just do
22:58 - everything in vs code so let's see I'll
23:02 - have the terminal in here yes good and
23:05 - make it bigger so if you have vs code
23:11 - you can use the terminal built in
23:13 - terminal otherwise you can still use the
23:16 - other terminal so I'm gonna do is I'm
23:18 - gonna create a file in here and call
23:20 - this file index dot JSP things in index
23:24 - Tijs so don't worry about yes lint for
23:28 - now so in here you can do anything that
23:31 - we just did so you can do math dot
23:33 - random right and now math at random and
23:37 - you can execute this file however it
23:40 - will not output anything because it just
23:42 - executed executed a value so this is not
23:45 - rebel node so if we execute node index
23:47 - that yes it will do nothing output
23:49 - nothing because we're not a rebel mode
23:51 - now we're in script execution mode which
23:54 - means if you want to output something to
23:57 - the operating system the operating
23:59 - system that's running the process then
24:01 - you have to use the interface to the
24:03 - operating system for example you can do
24:05 - process so process the STD out don't
24:09 - worry about the syntax dot right and in
24:12 - here you would do math dot random and it
24:15 - will probably not work because right
24:17 - expects a string so let's try that I
24:21 - think it will not work
24:22 - yep
24:23 - did not work because right here expects
24:26 - a string so what do you do well you can
24:28 - change this to two string so in here
24:30 - what I did is JavaScript this is a
24:33 - JavaScript expression I just made it
24:35 - interesting let's make sure this is
24:36 - working
24:37 - yep this works so this is a JavaScript
24:39 - expression right and I fed it to a node
24:43 - API so this is a node API process the
24:46 - STD I'll write is a node API now of
24:50 - course this is very raw a you know lower
24:54 - level because you have the console
24:56 - object the console object is also
24:58 - supported so I can do math dot random
25:00 - through the console object and that is
25:03 - going to output it as well and then it's
25:06 - a lot easier I didn't have to cast it
25:08 - into a string I did not have to put a
25:10 - new line after the output it actually
25:13 - colored it differently so console.log is
25:16 - another node API and actually if you go
25:21 - find the source code to a console dot
25:23 - log for node you'll find that it uses
25:25 - process the STD out there right so there
25:27 - are many many ways to do things there
25:29 - are lower-level api's and higher level
25:32 - API what if you console dot log an
25:34 - object what if we console the log
25:36 - process for example process is an object
25:39 - what's gonna happen well it's gonna it's
25:42 - gonna print a huge this is the default
25:45 - behavior for console to log it will
25:47 - print a huge object and go through all
25:50 - the nesting so everything that you can
25:52 - do on not just the first level
25:56 - properties for process but everything in
25:58 - it including arrays and all the
26:00 - environment variables right so this is
26:03 - not a very handy output what what do you
26:05 - do to make it handy well you can use
26:08 - other higher-level api's for example the
26:11 - dirt one might be a little bit better
26:13 - let's actually the third one is exactly
26:15 - the same but the dirt one accepts depth
26:18 - I think or like it accepts an object and
26:23 - in here you can say depth is zero I
26:26 - think so let's try that yeah so it gave
26:29 - me only the first level so without any
26:32 - nesting what is the first level of
26:35 - properties that you have on
26:37 - process object so this is a cool trick
26:39 - where you can start exploring so it did
26:42 - not expand the big things that you have
26:44 - in process so this is me executing a
26:47 - script right so we're gonna talk about
26:49 - how node does this magic how does it
26:52 - execute a script can you turn on the
26:55 - buggin for all libraries using no debug
26:57 - I don't think so I think you can I have
27:00 - a comma separated list so you can do
27:03 - like FS and paths but usually you want
27:07 - to debug one library because if you turn
27:09 - on everything there will be thousands
27:11 - and thousands of debugging lines and
27:13 - it's not really helpful alright so I am
27:17 - going to ask you a question and let's
27:20 - pretend that we are in an interview and
27:22 - I'm interviewing you for an old position
27:26 - so I'm gonna ask you an interview
27:28 - question I am gonna so you know the
27:32 - about the you know function X right and
27:37 - function X and we're gonna call it and
27:41 - function X is gonna console.log
27:46 - arguments so arguments is a special
27:48 - keyword that present everything that you
27:51 - pass to X as an argument right so let's
27:53 - pass X three arguments so one seven and
27:57 - nine so what is arguments in this case
27:59 - if I execute this code it will be one
28:02 - seven and nine now you'll notice that
28:04 - arguments looks like an object not an
28:07 - array that's because arrays in
28:09 - JavaScript are just objects they're just
28:11 - special objects where the properties are
28:14 - numeric just like that so it is this is
28:16 - an array all right cool so you
28:18 - understand that right now my question is
28:20 - what is gonna happen if I just
28:24 - console.log arguments without any
28:26 - function what is the output in this case
28:28 - so that's your first interview question
28:29 - tell me what is the output in this case
28:31 - and if your answer is going to be
28:37 - undefined you're gonna be surprised
28:41 - arguments in this case is another array
28:44 - there is an array here with how many
28:46 - arguments with five exact arguments
28:51 - so what are these five arguments and why
28:54 - is arguments working here arguments is
28:57 - something that you get in a function
28:59 - right why is it working top level not
29:02 - what we're not in a function and what
29:04 - are these five arguments that you get
29:06 - this is core knowledge in node so the
29:10 - reason arguments worked is because node
29:13 - has this concept of wrapping wrapping
29:16 - modules right so this is what it does it
29:19 - wraps your code in a function so you get
29:22 - this if e by default you everything you
29:24 - do in node gets this if e if he is
29:29 - immediately invoked function expression
29:31 - immediately invoked function expression
29:33 - so you get this if e by default no just
29:36 - does this wrapping automatically and it
29:40 - also does other stuffs for example it
29:43 - returns something from your from your
29:45 - file we're gonna talk about that but
29:48 - just in general I want you to know that
29:49 - you get this if e by default this is why
29:52 - arguments work so kind of like this no
29:55 - it has this Fe and it executed it
29:56 - immediately that's what you get and the
30:00 - arguments that you get are mod one of
30:06 - them is module one of them is exports
30:08 - one of them is a file name and learning
30:13 - so let's actually take a look at them
30:16 - real quick I think I'm missing one yeah
30:19 - so require is the first one what exports
30:22 - is the first one yeah exports is the
30:25 - first one I think and then you get
30:28 - required and then you get module exports
30:32 - is the first one then acquire then
30:34 - module you can actually take a look at
30:36 - them if you just do
30:37 - if you require module you can take a
30:41 - look at the wrapper require module dot
30:51 - wrapper you see that require module dot
30:53 - wrapper
30:56 - require module dot wrapper so this is
30:58 - exactly what you get exports require
31:00 - module filename and earning this is the
31:03 - actual wrapper that you know uses it's
31:06 - exactly that all right cool
31:08 - so here's the thing if you if you have
31:13 - two files right so we're gonna have
31:15 - another file in here index 1 and index 2
31:18 - index 1 and index 2 GS and I'm just
31:22 - gonna split them split down alright so
31:25 - you've got index 1 and index 2 right
31:28 - what I want you to know is that every
31:31 - function every file that you initialize
31:33 - gets this magic Fe right so if I if I
31:39 - constant log exports in here
31:41 - right experts is something that you get
31:43 - from the arguments right and I
31:45 - console.log it in here these exports are
31:48 - different right they're not the exact
31:50 - same object although if you execute them
31:54 - they're exactly the same it's an empty
31:56 - object right but this empty object Oh
32:00 - index to save this empty object that you
32:04 - get in index to analytics 1 these are
32:06 - different objects they're not exactly
32:08 - the same object why because they're
32:10 - coming from an argument that no passes
32:12 - to your iffy function so that's
32:14 - important so all of them are different
32:15 - right exports require module file name
32:18 - and their name file name is of course
32:19 - the name of the file that you're
32:21 - executing and their name is the name of
32:23 - the directory where your file is that
32:25 - you're executing so you need to learn
32:29 - about exports and and acquired these are
32:33 - two basic things in in node this is the
32:35 - node you know module dependency system
32:39 - so next we're gonna talk about these two
32:41 - in rebel mode you don't have arguments
32:45 - because you're not really executing a
32:47 - file this is when you execute a file
32:49 - this is how node manages files and
32:51 - modules
32:53 - how is console.log working when you run
32:55 - node file name as console.log is
32:57 - available only in browser yes console
32:59 - lock is available in node so node tries
33:02 - to mirror the browser's API right so
33:05 - when it comes to input and output not
33:09 - so there's no time you can't do document
33:11 - you can't in here you can't say oh look
33:14 - anywhere really you can't say document
33:19 - document dot get element by ID that is
33:22 - not going to work why because you don't
33:24 - have Dom so this will tell you undefined
33:27 - some kind of error document is not
33:30 - defined right so it's not exactly the
33:32 - browser however node opted to implement
33:36 - things like console like set timeout and
33:41 - many and a few other things that exist
33:43 - in a browser environment but they're not
33:45 - JavaScript right so these api's are
33:49 - built in node and their implementation
33:52 - is different than the implementation of
33:53 - the browser so and v8 has nothing to do
33:58 - with them v8 is just gonna organize the
34:01 - execution of functions and callbacks but
34:03 - these these api's are not-- cool that's
34:08 - why so if you go grab the source code of
34:11 - node you're gonna find the console
34:13 - object and a lot function in the node
34:15 - source code right not in v8 and not for
34:19 - any browsers okay cool no questions keep
34:21 - them coming
34:22 - so we're look we're learning about this
34:26 - iffy function if he wrapping function
34:30 - right cool so what is exports exports is
34:33 - an object that you can change so exports
34:37 - is a mutable object so we can say
34:39 - exports dot answer is 42 and you can put
34:44 - any number of properties on exports and
34:47 - when we execute this file exports is
34:49 - gonna be whatever you define it so it's
34:52 - just a special object that is available
34:54 - globally for you it's also an alias to
34:59 - module duck exports so if I do module
35:02 - the exports the another answer then I am
35:07 - changing the exact same property so you
35:11 - see how I changed it here and I change
35:12 - it it bear so exports is just an alias
35:15 - to module the exports cool and here's
35:17 - the thing node when it manages a file it
35:21 - returned
35:21 - module exports so whatever you put on
35:25 - exports that would be the return value
35:28 - of the index file the index module now
35:32 - why is this handy because another file
35:35 - might require your module so let's call
35:39 - this module one this index is your
35:41 - module right and you want index two to
35:44 - use your module to use index what you do
35:46 - is you require you just use require and
35:50 - you pass in a string and you say index
35:53 - two is gonna require index one
35:55 - Dodge's just like that index two is
35:58 - gonna require in this one so note what's
36:02 - gonna happen and in here I'm not gonna
36:07 - console.log I'm just gonna console.log
36:09 - let's console.log in index dot yes right
36:15 - let's pass a lot of an index digest so
36:17 - just by requiring index if I execute
36:20 - index two what can happen is note is
36:24 - going to look at this find require and
36:26 - it will require this file so it will
36:28 - execute this file so I'm gonna get the
36:30 - console log message although I'm
36:32 - executing index two so that's that's the
36:35 - story of require but here's how it's
36:38 - helpful it's helpful because require
36:40 - gives you access to whatever this module
36:44 - the export things is returning so
36:46 - whatever you put in module the exports
36:48 - you get it in here so in here you get an
36:51 - object index I'm just gonna call it
36:55 - index and I'm just gonna log index so
36:58 - guess what index is going to be index
37:00 - after index that in in index digest this
37:03 - here you get the exported module so this
37:09 - is module two exports so whatever you
37:11 - put on module the exports or its alias
37:13 - exports you get it out when you require
37:16 - a file so require is dependencies module
37:19 - dependencies it's similar to import and
37:22 - export in JavaScript in fact you can
37:25 - also use import and export and I'm going
37:27 - to show you how that because this is new
37:29 - this is new in node you get to use
37:31 - exports and imports all so any questions
37:34 - about
37:35 - and this exports business because that
37:38 - is that is core knowledge all all the
37:41 - packages out there that are written for
37:44 - note they use this syntax they use
37:47 - exports and require all right cool so
37:53 - I'm going to clean all this and just
37:56 - console.log hello and in here
38:00 - I am going to require index that yes and
38:04 - I'm gonna execute the file that's
38:06 - requiring so this will output hello
38:09 - right cool here is your second interview
38:14 - question what's gonna happen if I do
38:16 - that if I require index three times
38:21 - what's gonna happen so go ahead and try
38:25 - and answer this will output hello one
38:29 - time what why the output hello one time
38:32 - and not three times right and the reason
38:36 - is note has this required function in
38:39 - node has some magic caching it doesn't
38:43 - evaluate the file every time you require
38:46 - it it evaluated once and then the second
38:50 - time it reads it from the cache so this
38:54 - is why in a in an application say to
38:56 - react application or an angular
38:58 - application you require react all over
39:01 - the place you require angular all over
39:03 - the place multiple files are gonna
39:05 - require react or angular or view and
39:07 - only the first require is gonna actually
39:11 - do the work the second require will just
39:12 - read it from the cache so well another
39:16 - interview question is what if I do want
39:19 - this file to console.log hello every
39:22 - time I require it and the answer is you
39:26 - really can't you require you get cash
39:29 - that's just that's just the reality
39:32 - however you can delay what you execute
39:35 - in the file by making it return a
39:39 - function
39:39 - so remember module to export right
39:41 - module the export is our API so instead
39:45 - of having the
39:48 - console.log directly you can't have it
39:51 - export a closure you can have an export
39:53 - a function closure and you execute that
39:56 - function every time you want it so if I
39:58 - make module de exports into a function
40:02 - and I'm gonna use error function in here
40:04 - but you can just use a regular function
40:06 - and I make this function console.log
40:08 - hello instead of that now I have delayed
40:11 - execution now every time I require index
40:15 - dot yes
40:15 - what do I get every time I require index
40:18 - suggest I get back a function it does
40:21 - not have any code it will just cache the
40:23 - function reference and I can just
40:26 - execute this function that I get back
40:28 - from index that yes so if I do that and
40:31 - I execute this I get hello three times
40:34 - so we use this trick a lot in node we
40:37 - make Lee module exports a function and
40:40 - we execute the code in that function so
40:43 - it's a little bit of delayed execution
40:46 - what gets cached is the function itself
40:48 - not the function execution cool alright
40:52 - so there are many cases where you get me
40:56 - you want to execute something in a file
40:58 - multiple times right so this is how you
41:02 - do it you always execute a function in
41:04 - fact if you need the file to have
41:06 - multiple capabilities what you do is you
41:10 - make it export an object and in the
41:13 - object you have your capabilities you do
41:15 - like function one function to function
41:17 - three right so this is another way to
41:20 - export API so how would you do that
41:22 - how would you invoke function one now
41:25 - what you get back is an object right
41:27 - it's not a function it's an object and
41:29 - because it's an object it's an object
41:31 - that has F one I can do dot F one right
41:35 - dot F one because it's an object and
41:37 - execute F one right and this will work
41:40 - as well so whatever you put in here this
41:45 - require is just gonna use it right so
41:47 - and you can put anything right you can
41:49 - put primitive values you can put arrays
41:51 - objects or you can have like a proxy
41:54 - anything that is supported by the
41:56 - language you can use it as the exports
41:59 - value in your
42:01 - and you get to use it exactly as we
42:04 - define it right whatever you have we
42:05 - have an object has an f1 property so
42:08 - I'll just cut like get the f1 property
42:11 - and then because the f1 property itself
42:13 - is a function I can execute f1 right so
42:17 - there's nothing magic in here it's just
42:18 - JavaScript mixed with the API that no
42:22 - gives you to require functions now this
42:25 - is a little bit different than the
42:26 - import-export syntax that is that is
42:29 - native to the JavaScript language right
42:31 - this module require business is nodes
42:34 - way to do module dependency and it
42:37 - existed since day one in node so like
42:40 - ten years before JavaScript decided to
42:42 - have a module dependency as well now the
42:44 - problem is you have two systems one has
42:47 - been used for ten years and the
42:50 - brand-new one that everybody is gonna
42:52 - start using because it works in browsers
42:54 - as well
42:56 - so what do you do well here's what you
42:59 - do you really understand require module
43:01 - to export as to understand it really
43:03 - good because you're gonna have to deal
43:04 - with packages that are written in this
43:06 - sentence for at least five to ten years
43:09 - into the future if you're working in
43:11 - node project but in your own parting a
43:13 - node project today I would recommend
43:15 - that you use the import/export syntax
43:17 - not the required syntax now they have
43:21 - different implementation and I'm gonna
43:24 - tell you about that in just a little bit
43:26 - just so that you aware but I'm going to
43:28 - show you the import-export n tax first
43:30 - so let's go ahead and do that so let's
43:33 - do this exact same example but instead
43:35 - of working with require let's do it with
43:39 - with important export right so here's
43:44 - the thing if you have node twelve right
43:47 - if you have node twelve you can use
43:49 - import and export out of the box it's
43:51 - actually supported but remember that
43:53 - it's not LTS so no twelve is not
43:56 - Althea's yet
43:57 - what's the MV m LS system no twelve
44:03 - so nvm use system
44:09 - MVM LS remote while we're talking about
44:14 - it I'm just gonna get the latest and
44:15 - greatest node which is V 1214 and I'll
44:18 - use that so MDM install this thing and
44:23 - this will install the latest so what do
44:25 - you do here is you create a package that
44:27 - JSON file to start managing your
44:30 - dependencies right let's actually name
44:33 - this m1 and m2 because they're kind of
44:37 - different so m1 and m2 and I'm just
44:40 - gonna call em two in here m1 m1 that is
44:45 - N 1 and n 2 so exact same example I just
44:47 - named them in m1 and m2 instead of what
44:51 - I had before all right and and you can
44:56 - run them with the latest node so this
44:58 - syntax is not going anywhere so although
45:01 - we have node V 12 now we can still run
45:04 - m2 and we get the exact same behavior so
45:07 - export and require is exactly the same
45:09 - but what I'm to do is I'm gonna change
45:11 - this into important export but to do
45:14 - that I need the package JSON file
45:17 - so what is a package that JSON file a
45:19 - package that JSON file is the file that
45:22 - you can use to manage meta information
45:25 - about your node projects so every node
45:28 - package out there has a package that
45:31 - JSON file to tell you its name its
45:34 - version its get repository how to run
45:37 - things in it so you create a package
45:39 - that JSON file with the NPM command
45:42 - so what NPM is the node package manager
45:44 - and we're going to talk about it in the
45:46 - next hour after the break but for now
45:49 - the first step is to use the NPM init
45:52 - command to create a package dot JSON
45:55 - file that we can use to control things
45:58 - in nodes so @p a minute and this will
46:01 - ask you a few questions us or it can
46:05 - detect if you do - Y which is for yes it
46:08 - says just try to detect whatever you can
46:10 - detect from this this object and just
46:12 - give me a package JSON file so this will
46:15 - create a package of the JSON file using
46:17 - the name of the directory using a
46:19 - default version it will try to find if
46:20 - you have git installed it will
46:23 - to find the get remote that you have it
46:25 - just detects a few things so in package
46:28 - that Jason you get to specify
46:31 - information about your package so for
46:34 - example if you put your name on the
46:35 - package so that when you push it people
46:37 - know if you want to have keywords so
46:39 - people can find your package in the
46:41 - search you can use this meta information
46:44 - so there is a new by the way the only
46:49 - two required properties in package that
46:52 - jason are just name and version these
46:53 - are the only required everything else is
46:55 - optional so the new the new property
46:59 - that you can use here on package that
47:01 - jason is the type property and if you
47:05 - specify your type as module instead of
47:08 - commonjs
47:09 - so the other one I think is common
47:10 - common jazz which is the name that is
47:13 - that we use for you know the require
47:16 - exports thing but if you specify your
47:19 - type as module then node will switch
47:23 - gears and just assume that you're just
47:26 - gonna use your ECMO script modules all
47:29 - over the place so there's no require and
47:31 - exports in fact I think if we try to
47:33 - execute it now it will not execute it
47:36 - will not be happy it will say well I
47:39 - actually executed that does not work oh
47:42 - we need a flag so we need the
47:46 - experimental modules there you go see
47:49 - so this flag is actually gonna go away
47:51 - when node goes into LTL I'm not sure
47:55 - when they're gonna remove it but they
47:56 - will remove it but this is this is how
47:58 - node is gonna behave when it switches to
48:00 - the ECMO script the ASM module loader
48:02 - see this is now the ESM module loader so
48:05 - it tells you I don't know require
48:07 - because I'm assuming that you are in um
48:09 - in a neck massager
48:11 - right you're not in a node module you're
48:14 - an ECMO script module which means you
48:15 - cannot use exports you cannot use
48:17 - require so what can you use you use
48:20 - export default and in here you pass in
48:24 - the object that you'd like to export so
48:26 - it's kind of similar to what you did but
48:28 - in here where we have a little bit of
48:31 - different syntax export default so
48:33 - instead of module de exports you do
48:35 - export default
48:36 - and instead of require what you do is
48:38 - you import you use the import keyword so
48:41 - import m1 from dot slash m1 dot yes well
48:47 - import m1 from the slash in Monda yes
48:49 - and now you get to do m1 dot f1 and
48:53 - execute that three times so you'll see a
48:56 - little bit of different syntax but it's
49:02 - basically the same module dependency so
49:04 - this works right you get a warning that
49:06 - it is experimental but it's really just
49:08 - it works fine they're just making sure
49:12 - that the API is stable so it is the
49:14 - exact same thing except there's no
49:16 - require there's no module the expert
49:18 - cool now we have a big question
49:21 - what is a module so that is an important
49:24 - question what is a module so I'm gonna
49:26 - give you the short answer and I'll give
49:28 - you the long answer after the break
49:30 - so the short answer is a module is just
49:33 - a file it's just a bunch of code lines
49:36 - of code in a file but it can also be
49:38 - multiple files right and we get to we
49:43 - now we need to understand what happens
49:45 - when you require or import a module I'll
49:48 - just I'll just use import in here what's
49:51 - gonna happen when you import not a local
49:54 - file so in here what we imported is a
49:56 - local file right and one what happens if
49:59 - you import say HTTP from HTTP what
50:06 - happens if you do that because this is
50:08 - not local because there is no even this
50:11 - this dot slash means a file on the same
50:14 - level trying to file a find a file on
50:17 - the same level or a folder on the same
50:18 - level so if you don't have duck slash or
50:20 - dot dot slash that means go find this in
50:24 - a special somewhere and this special
50:27 - somewhere is what we're going to talk
50:28 - about next is called the node modules
50:30 - directory and I want to tell you how
50:32 - node modules tie in to NPM and other
50:36 - package managers and how things work
50:38 - magically now HTTP is a built in module
50:42 - so it doesn't really go and look for it
50:44 - in the node modules directory it just
50:46 - take it from the built-in core the
50:50 - comes installed out-of-the-box with
50:51 - known but if you do import from Express
50:54 - for example which is a package that you
50:57 - can use to replace hdtb then you need to
51:00 - have Express installed this is not a
51:02 - third-party package they said this is
51:04 - not a built-in package it's a
51:05 - third-party package so you have to
51:08 - install it you have to let NPM install
51:09 - this before you can use it so we'll do
51:12 - that right after the break so can we
51:16 - have a library of components and import
51:20 - it as a module for another project
51:22 - definitely the answer is big yes that's
51:25 - how node works in fact when we import
51:27 - HTTP what we're importing is a small
51:30 - library of things that we can use and
51:33 - you can explore this right away by
51:37 - console logging HTTP so let's take a
51:38 - look at what we get when we import HTTP
51:41 - and in here we're just gonna execute m1
51:43 - format from now on m1 and you get a
51:46 - library a little library object with a
51:49 - few methods so there is status codes for
51:54 - example all the HTTP status codes are
51:55 - here so if you want to look them up all
51:57 - you need to do is HTTP status codes you
52:01 - get a few important methods and and
52:05 - objects and classes in here and the most
52:08 - important one is create server so HTTP
52:11 - that create server creates an HTTP
52:13 - server that's what we're gonna use next
52:15 - if you have node 10 this is not going to
52:20 - work what we're doing here import HDB is
52:22 - not going to work so you have two
52:24 - options either upgrade to node 12 and
52:26 - use that or you can use the ESM package
52:30 - and this is how you do it you add cam
52:32 - installed ESM and this will download ESM
52:38 - from the internet and place it under a
52:41 - node modules folder so we're going to
52:43 - talk about that in just a little bit a
52:45 - place ESM under a node modules folder
52:47 - you see that and what you what you need
52:50 - to do to run things with the sm is
52:52 - instead of experimental modules you do -
52:55 - or yes em - are yes i'm so on more time
53:00 - - re sm so this will work
53:03 - on node ten and eight and everything is
53:06 - just a shim around experimental module
53:10 - so you don't have you don't need no
53:11 - twelve and it is it works actually
53:14 - really good so that's our ESM so two new
53:18 - things just happen we use the - our flag
53:21 - what is - our so - our is you require a
53:27 - module before you execute your code so
53:29 - that's our is kind of like a wrapper
53:31 - that you can inject a module into your
53:34 - system before node executes your actual
53:37 - module which is m1 degeus so that that's
53:41 - that's our and ESM is just a package
53:44 - that we downloaded so we can now import
53:47 - ESM from node modules so before we talk
53:50 - about HTTP I wanna I want to talk about
53:52 - node modules right so if you import
53:56 - let's say you want to import from like
53:59 - or just import and you pass in something
54:04 - you import something right what happens
54:08 - here is when you put something
54:10 - what node looks at something here
54:14 - there's something string and it figures
54:16 - out that this is not a built-in library
54:19 - right it's not part of the built-in
54:21 - library it's also not a local file
54:24 - because you know it doesn't start with
54:27 - dot slash or dot dot slash so if it's
54:29 - start with dot slash or dot dot slash
54:32 - that means it's a local file go find it
54:35 - locally where we're importing but
54:37 - because it does not start with dot or
54:39 - dot dot slash that means it's not a
54:41 - local file so know by default will tell
54:44 - you that I don't know what something is
54:46 - cannot find module something because it
54:49 - looks under node modules so it tries to
54:53 - find something dot yes under node
54:56 - modules so if we go to your node modules
54:58 - and we put something dot yes and we and
55:03 - we do something we do and we put
55:05 - anything here in digest so this is just
55:09 - a test so what I did is I put something
55:12 - just under node modules and guess what
55:15 - now
55:16 - I am importing something and there is
55:18 - something that is under node modules it
55:20 - will find it so there's no magic here it
55:23 - just looks for things under node modules
55:25 - that's that's what node does right and
55:28 - you can actually make this into a folder
55:31 - instead of a file so you can have a
55:33 - folder called something under node
55:35 - modules you can make a folder and name
55:37 - it something and put your code under
55:41 - this folder and by default node looks
55:43 - for index dot yes under the folder so
55:46 - just a test here from a folder right and
55:50 - you and if you import something here
55:54 - right you I can import the folder and it
55:57 - will look for the index that you has
55:59 - file under that folder and that's
56:01 - exactly how note resolved your external
56:04 - dependencies so if we npm install lodash
56:11 - for example if we npm install lo - hello
56:14 - - is a javascript library that you can
56:16 - use it has a lot of cool utility
56:19 - functions that you can use in in our
56:21 - missing JavaScript you can use them
56:23 - so what MPM does is it just places let's
56:28 - refresh this it places lo - just like I
56:32 - did for something it places lo - under
56:34 - your nose modules directory that's what
56:36 - IPM does it has nothing to do with
56:37 - import and export it just download slow
56:40 - - and put it under the node modules
56:42 - folder in your project then here we can
56:45 - import lo - because it is no module it
56:50 - is under node modules then it is
56:51 - something that I can just import and
56:54 - import directly means just execute so
56:57 - I'm not really interested in anything
56:59 - that the library returns like whatever
57:01 - the library exports right but if you
57:03 - want to not use whatever the library
57:06 - exports and you have to give it a name
57:07 - usually lo - we do import underscore
57:09 - from lo - and now we get to do use the
57:13 - lodash functions for example we can sum
57:15 - in the range so this is one two three
57:17 - and it will summon array of course we
57:20 - need to console.log that so you want to
57:23 - put it in a console log m1 and it is not
57:27 - working is it at all
57:30 - get it put it in a race it doesn't some
57:32 - an argument it will summon irate okay
57:35 - cool so this is how we use external
57:38 - libraries we use NPM to download them
57:41 - and place them under the node modules
57:43 - folder then we use node package
57:47 - management to import them into the
57:49 - project and use their API in in the
57:51 - project that's how that's the story of
57:54 - node packages and how to use them in
57:57 - general how do I make my library
58:00 - available for people to use it as
58:02 - imports in their project very good
58:04 - question
58:05 - what if our something that yes is turn
58:08 - turns out to be handy and we want to
58:11 - make it available for other people to
58:13 - use it what we do is we publish it under
58:16 - NPM now or we publish it under a
58:19 - repository in general right but if I
58:22 - want to publish my something that you
58:24 - ask all I need to do is I need to help
58:28 - make it have a package.json and then I
58:30 - can just NPM pop lish this this thing
58:34 - NPM publish now to publish NPM you have
58:37 - to have an account with NPM and NPM GS
58:40 - comm right and it has to be a valid
58:43 - package and you have to have the right
58:45 - to push through this package if it's a
58:47 - new package if NPM doesn't have a
58:49 - package named something already so the
58:51 - name is unique then it will allow you to
58:54 - push it but if you're trying to push
58:56 - through a package that exists you need
58:57 - to have rights to it so they need to add
59:00 - you as a contributor to that package and
59:02 - of course you can publish to github
59:04 - directly github in fact if we look for
59:09 - lodash in here
59:12 - github low - low - right you can
59:15 - actually install low - directly from
59:18 - github or let's let's let's talk about
59:21 - Express so I'm gonna I'm gonna do that
59:22 - for you next Express not here Express
59:29 - Express is a framework a web framework
59:33 - that you can use to replace STD so we're
59:36 - I'm gonna install Express from github
59:39 - directly so the minute you push
59:41 - something to github it's
59:44 - available for people to use it with
59:46 - their node projects so let's use let's
59:48 - MPM Express from github so when I do in
59:53 - here NPM install Express just like that
59:58 - that will install it from the NPM
60:01 - registry it will not install it from
60:02 - anywhere else because I'm doing NPM
60:04 - install the default is the NPM registry
60:07 - but if I use this expression here which
60:11 - is you know just Express the GS /
60:13 - Express instead of Express NPM will
60:17 - detect that you mean go get express from
60:20 - github by default this expression means
60:23 - oh this looks like you know older slash
60:26 - repository so it must be from github so
60:30 - what it what exactly does it do it will
60:32 - get the exact latest commits the one
60:34 - that happens 25 days ago so it will give
60:37 - you the latest and greatest of Express
60:39 - so it's not the published package so the
60:42 - final published package was in NPM if
60:45 - you go to NV MGS comm and you look for
60:48 - Express this has expressed this is this
60:52 - is the package that you get if you just
60:54 - install it directly from Express and the
60:56 - final package was 417 one and it is 25
61:00 - days ago so it looks like they match but
61:02 - if someone pushed something to get to
61:04 - Express today and then you do did NPM
61:07 - install Express / Express you get the
61:09 - exact same commits that happened today
61:13 - not the actual final published package
61:16 - but this is how easy for you to get
61:19 - something from github so if you push
61:21 - your package to github you can get it
61:23 - github also has a package registry that
61:25 - they're working on so you can install
61:27 - things from github directly as well but
61:32 - the package has to exist exist somewhere
61:34 - you have to publish it somewhere right
61:36 - all right cool good questions keep them
61:39 - coming
61:39 - how does the repository validate the
61:43 - authors right to upload very good
61:45 - question so you'll have to have some
61:48 - kind of authentication and by default it
61:51 - asks you for to login so there is you
61:53 - create an account with NPM j/s and you
61:55 - login with an email
61:57 - and password so if you do npm publish
61:59 - you will ask you for you log in it you
62:02 - log in and password but you can also use
62:03 - SSH keys if you want to say you know
62:06 - just like you push to a github
62:07 - repository and just like how github
62:09 - validate that you have commit access to
62:12 - that repository using a succession
62:13 - education but you do need to
62:15 - authenticate somehow and after you
62:18 - authenticate because they know your
62:20 - identity they're gonna do the
62:21 - authorization they're gonna validate in
62:23 - their system does this person have the
62:27 - right to push to this repository or to
62:29 - this package alright great questions
62:32 - keep them coming so we were talking
62:35 - about import and export so I think that
62:40 - is that is basically all the time we
62:42 - have to talk about node modules and
62:44 - import and export because we need to
62:46 - explore other things in in the node
62:47 - ecosystem so if you have any questions
62:50 - about what we did so far before we move
62:52 - on about all the import and export stuff
62:55 - the require the the ACMA script modules
62:58 - the node modules directory package jason
63:02 - and how these things work together
63:04 - definitely now is the time to ask them
63:06 - but otherwise we're gonna explore the
63:09 - HTTP package so we're gonna create
63:12 - certain fact I'm gonna call it server
63:14 - Dodge's I'm gonna create a server here
63:17 - so I'll delete everything I'll just keep
63:19 - server degeus and I don't really need
63:22 - any of those things so I'm gonna show
63:25 - you how to get rid of them and then just
63:28 - delete everything and just keep oh man
63:34 - we have a lot of stuff that came from
63:36 - Express but I'll show you how to clean
63:38 - this up so what I'm gonna do is I'm
63:40 - gonna create a server not here sorry in
63:45 - here we're gonna create server JS file
63:47 - and we're gonna execute the server
63:50 - digest file so in here we're gonna pass
63:52 - a log hello node and we're gonna execute
63:56 - so what are we executing here is just oh
63:59 - man no it's zero sink yeah all right I'm
64:05 - gonna just execute no - re SM and server
64:09 - digest
64:10 - we're gonna actually create a web server
64:12 - in here and we're gonna do it first
64:14 - natively with node and then we'll do it
64:16 - with Express all right so are we gonna
64:18 - talk can modules be installed globally
64:21 - yes so if you want to install a module
64:24 - globally all you need to do is npm
64:26 - install dash G so that G flag means
64:29 - install this module globally for example
64:31 - I want to have a module to create a
64:34 - react project or create react app create
64:36 - react tab is a candidate for something
64:40 - that you want to have globally because
64:42 - it just creates a react app for you it's
64:45 - not really part of a dependency like
64:48 - lodash or Express you don't depend on it
64:50 - you just use it to create something
64:52 - another module that is a good candidate
64:56 - for a global is es lint you won't have
64:58 - es lens in all your node projects so
65:00 - maybe just manage it globally although
65:03 - it is probably a better idea to manage
65:05 - things locally even for even es lint
65:08 - because you want to make sure that the
65:10 - whole team uses the exact same version
65:12 - and they don't depend on a global
65:15 - dependency so I would avoid global
65:17 - dependencies unless you know it's a
65:20 - thing that you use globally for
65:22 - everything it's a command basically
65:24 - unless it's a command that gives you
65:25 - about a binary executable command
65:28 - just use local dependencies so let me
65:31 - mention a few more things about packaged
65:33 - on Jason we're limited on time but I'll
65:36 - talk a little bit more about it so one
65:39 - thing that you can do is use scripts so
65:42 - probably the most important part of
65:45 - package that Jason for me in a big
65:46 - project is the user scripts in fact if
65:49 - we go I'm gonna show you a sneak peek
65:52 - into the package that Jason for the J's
65:55 - complete project so let's take a look at
65:57 - the package that JSON this is the Jas
66:00 - complete calm this is packaged in JSON
66:02 - for J's complete that form and you'll
66:04 - see that I have so many things under the
66:07 - scripts directory see that all of these
66:10 - are a tasks that we use to run things
66:13 - J's complete some of them are
66:15 - development tasks so things that we do
66:17 - for development and some of them are
66:19 - production tasks the things that we do
66:21 - for production and these are different
66:23 - so
66:24 - any any person who uses who works on the
66:27 - J's complete project they know exactly
66:30 - how to start a dev process they know
66:32 - exactly how to bundle things for dev
66:34 - they know exactly how to send all the
66:38 - gist drops emails or update all the
66:40 - email templates or log things in
66:42 - production so these texts these tasks
66:44 - are unified let me know we always have
66:47 - to do it this way so how do we do that
66:51 - in in our project so let's let's create
66:54 - a task so for example instead of always
66:56 - doing node - our ESM server yes right
67:00 - and if you if you bring someone new to
67:03 - the team you have to tell them oh you
67:05 - have to use - or ESM in our project
67:07 - instead of doing that you can have a
67:09 - start script you can say you know what
67:11 - we're gonna put this in a start script
67:13 - so the start script is node - art ESM
67:18 - server yes this is how you start our
67:21 - system and now it's a global knowledge
67:23 - because all I need to do is NPM start
67:25 - because I can run the script directly
67:28 - NPM start I don't have and if you bring
67:30 - someone new to that table they know they
67:33 - they know to look for NPM start right
67:35 - because you know it's a it's a global
67:37 - language there's what can I do for this
67:39 - project well you can start it and boom
67:41 - hello node it is running the - Ari sm
67:45 - server so you will have a lot more in
67:47 - here for example what do we do to test
67:49 - things right maybe are we using mocha
67:54 - are we using just where where do we look
67:56 - up the tests so maybe that will be like
67:58 - oh just just under you know star star
68:01 - type or whatever things that you do and
68:04 - now you can do NPM test and it will run
68:07 - just now I don't have just installed so
68:09 - this will tell me where what is just I
68:11 - don't know just but you get the idea
68:13 - so these are special commands that you
68:18 - can do with just NPM start and NPM test
68:20 - but they're equivalent to doing NPM run
68:22 - start so NPM start is equivalent to
68:25 - doing NPM run start it's just a special
68:28 - one that has a shortcut but in general
68:30 - if you do something like let's say I
68:35 - want to do it dev start not
68:37 - not just start or prod how do you start
68:39 - for production for example how do you
68:41 - start things for a production well in
68:43 - production I'm gonna use the I'm gonna
68:47 - use node in the equal production for
68:50 - example and then do not know - re SM
68:53 - server that yes right so I slightly
68:56 - different to run things in production
68:58 - then in development right so you have a
69:02 - different tasks for production run and
69:04 - if you want to run this task then you
69:06 - have to use npm run prod start because
69:10 - it doesn't have a shortcut so at 10 p.m.
69:12 - run prod script in fact these things are
69:14 - called run scripts because he uses in
69:16 - with npm run cool you can also use yard
69:20 - so if you're using the yarn yarn is
69:23 - gonna run into yarn will funny so you
69:25 - don't need to do yarn run so it's a
69:27 - little bit different in how the package
69:29 - manager is using so since I mentioned
69:31 - npx
69:32 - I want to quickly talk about MPX so MPX
69:35 - is NPM x-cubed right so let's say you
69:38 - wanna NPM install - G create react app
69:42 - create yak tab is just an example so
69:45 - don't have worry about it in fact I'm
69:47 - gonna use react so so react was just
69:49 - another one that I use and if you if you
69:52 - have we actually install then you can do
69:54 - react new I think project this is the
70:00 - command that you get react full react
70:03 - react full so you get a binary react
70:05 - full new project and it will create a
70:08 - reacts full project for you so this is
70:09 - the command that you can use but this
70:12 - will install reacts full globally and
70:15 - then use it right so a month from now if
70:19 - I come back to the project and I do
70:21 - another react full command
70:23 - react full new project to then it will
70:26 - install then I will use the exact same
70:28 - reaction package that I installed a
70:31 - month ago if I want to get the latest
70:34 - and greatest every time I use the react
70:37 - Ville command instead of NPM install
70:40 - global I can just use npx react ville
70:44 - and then invoke the
70:49 - and px react for new project and what
70:52 - this command is going to do it will
70:54 - install a temporary copy of react ville
70:57 - so it will download the temp copy of
71:01 - react ville use it and then delete it so
71:04 - I don't have a local copy anymore every
71:06 - time I want to use the react Ville
71:07 - project I can just download it with MPX
71:11 - in one command and it will download the
71:13 - latest and greatest and then use it use
71:16 - the command that comes with it because
71:18 - the command matches the the package name
71:20 - cool so this is MPX to install something
71:23 - globally and download it but it's also
71:27 - available if you if you're in your
71:30 - project if you have something that you
71:34 - need to execute for example let's say
71:37 - that we installed - - - - dev so I'm
71:43 - gonna install - G this is another thing
71:45 - that we need to talk about and I'm gonna
71:47 - install the eslint right es lint so - D
71:50 - means development dependency it means we
71:53 - don't really need it in production this
71:55 - is just in development so if I do - D it
71:59 - will it will put it not under
72:03 - dependencies but rather under dev
72:05 - dependencies you see that so when you
72:08 - run things in production if you have
72:10 - this production flag if you have note n
72:14 - equal production and you run things with
72:16 - the production flag it will not install
72:19 - the dev dependencies right it will just
72:22 - ignore them
72:22 - it will only install the local
72:23 - dependencies because the eslint is not
72:25 - something that you want to have in
72:26 - production yes light is a good quality
72:28 - check that will check things while you
72:30 - develop developing them but here's the
72:33 - thing because just because we npm
72:36 - install the eslint doesn't mean that we
72:38 - get to execute the es link command there
72:40 - is no es linked command where is the es
72:42 - link command the es link command is deep
72:45 - under the node modules folder under dot
72:47 - bin so you can you can execute it from
72:50 - node modules been yes lint and and this
72:53 - will execute the node the es link
72:55 - command fine so it's it's not under it's
72:58 - under node modules right because NPM
73:00 - just install things under the node
73:02 - modules folder
73:03 - so if you want to execute it without
73:05 - figuring out where it is or you know how
73:09 - to execute it you can't just use the MPX
73:11 - command here as well
73:12 - and PXE eslint and this will try to find
73:15 - it under the node modules folder for you
73:18 - so MPX is a handy tool to do that
73:20 - that comes with with NPM of course if
73:24 - you have yarn you can just do the same
73:26 - thing with the arm so you're in just one
73:27 - command and it will you do that it will
73:30 - find the package for you
73:32 - now if you put things in in a in a
73:36 - script so if here we do check for
73:39 - example and we do es Linde NPM is also
73:42 - smart enough to figure out that so check
73:46 - in here to figure out where to look for
73:49 - es wins so we can just NPM check I mean
73:52 - run Jack right and it will also work as
73:56 - well so it will execute the ps1 command
73:58 - all right so this is dependencies dev
74:01 - dependencies and scripts very important
74:05 - things in package that Jason if I delete
74:07 - a dependency from package that Jason
74:09 - would it eliminate it from the project
74:11 - very good question in fact let's go
74:13 - ahead and delete lo - right so if we
74:16 - delete lo - because we not we're not
74:20 - gonna use it it does not eliminate it
74:23 - from and by default and still under node
74:27 - modules so the package that JSON file is
74:31 - just a documentation of what
74:32 - dependencies were installed but lo - is
74:36 - still under the node modules folder
74:39 - right so I will it go away if I do NPM
74:44 - install so if you do NPM install it
74:48 - reads everything that you have in
74:50 - package that JSON and it gives you all
74:52 - the missing dependencies right but it
74:54 - does not remove the you know the
74:57 - dependencies that you do not depend on
74:59 - anymore so this is just the NPM be I
75:01 - think yarn behavior is different but
75:03 - here's the thing you should not really
75:04 - do it this way if you want to kill the
75:06 - dependency you should do NPM uninstall
75:10 - lodash NPM uninstall lo - so this will
75:13 - remove it from the node modules and it
75:16 - will remove
75:16 - from packaged that Jason so my advice is
75:20 - do not touch dependencies and dev
75:22 - dependencies manually in your package to
75:25 - Jason you can only change the meta
75:27 - information you can add scripts manually
75:29 - that's fine it's just dependencies and
75:31 - dev dependencies make them go through
75:34 - the NPM command itself right this is
75:36 - just the advice unless you want to
75:38 - change the this weird character here the
75:43 - caret character which means give me
75:45 - anything that is compatible with three
75:49 - three so basically so three three would
75:52 - be fine here three four would be fine
75:54 - but not four so it says like give me
75:56 - everything that is compatible with three
75:58 - so it might give you minor version as
76:01 - well so if you want to change this and
76:03 - say you know what I want this dependency
76:05 - to be exact
76:06 - do not when you update your package
76:08 - always use the exact same dependency and
76:10 - not give me any a new version or give me
76:14 - just the patch so there are like special
76:16 - meanings for all these some things but
76:19 - this is a bit advanced these you can
76:21 - change them if you want to you can also
76:24 - just say star in here which means give
76:26 - me the latest and greatest even if it
76:28 - was es m5 I don't care just give me the
76:30 - latest so a major minor we call this you
76:34 - know that the semver string and this is
76:37 - the semper version here so major minor
76:42 - and patch so you have to learn about sin
76:44 - Verte and how how to manage those
76:46 - alright so we'll go ahead and talk about
76:49 - a HTTP next so this is how you create a
76:52 - node web server you import HTTP from
76:56 - HTTP and then you do HTTP dot create
77:04 - server so this API is from note STP duck
77:09 - crate server and it's gonna teach us a
77:11 - few things about about node so what you
77:14 - get back from here depends on the API so
77:17 - you can name it anything right in here
77:19 - you can name it anything so you don't
77:21 - have to stick with the API this this
77:24 - name here has to be create server
77:26 - because that's the function the API
77:27 - exposes but here we can name it anything
77:29 - usually I name
77:30 - this server right so this is the server
77:32 - and you make server listen on some kind
77:39 - of port so we make it listen on port
77:41 - 3000 for example so this is the API to
77:45 - create a web server now if you npm start
77:49 - because that's the script that we put
77:51 - the npm start you'll notice that node
77:54 - did not exit the process did not exit
77:58 - right I did not go back to the terminal
78:02 - command and this is because of the
78:04 - listen so if I kill the listen and read
78:06 - this again it will create a server and
78:09 - then it will exit I am back to the
78:11 - terminal
78:12 - right it did not it did not continue
78:14 - running so it is important for you to
78:17 - understand that node will only continue
78:20 - running if it has a reason to continue
78:23 - to run right if it has a reason to
78:25 - continue to run and that reason is do we
78:28 - have any asynchronous calls that are
78:31 - listening do we have any handlers for
78:34 - example I can have a set timeout set
78:37 - timeout is a timer right that we can run
78:40 - say after five seconds so it gives in
78:43 - here in milliseconds and let's just do
78:46 - nothing right set timeout after five
78:49 - seconds just for just to keep node busy
78:52 - for five seconds so because there is a
78:54 - reason for node to stick around for five
78:57 - seconds when we run this code node will
78:59 - not exit for five seconds and then after
79:03 - the five seconds it will have no reason
79:05 - to stay running and it will just exit
79:07 - right so that's extremely important note
79:10 - processes will exit if they don't have a
79:12 - reason to stay running so for example if
79:15 - in here if we do server that listen
79:19 - which is a reason for node to stay
79:21 - running forever right because it's
79:22 - listening right it's listening forever
79:24 - so it's a reason for it to start just to
79:26 - stick around forever but if this listen
79:29 - function deep internally through an
79:31 - error if there's an error then that
79:34 - error is gonna make the process crash
79:36 - and exit because there's no reason for
79:38 - note to stick around there's an error so
79:40 - that process the state of that listening
79:42 - server is
79:44 - so Note will crash from exit so what
79:46 - does that mean for you in production
79:48 - that means is note by itself the note
79:51 - command by itself is not enough in
79:53 - production because if you're just
79:55 - running a single node process in
79:56 - production that process might crash and
79:58 - exit at any point so you'll have to
80:01 - monitor this process and you'll have to
80:03 - have a cluster of processes and maybe
80:06 - even a cluster of servers if you need to
80:08 - so that if one process crashes and exits
80:11 - another process is automatically started
80:14 - because it is normal for a node process
80:17 - to crash and exit and if it has no
80:20 - reason to stay around it will not stay
80:23 - around alright now this server is
80:25 - listening when we emit you will not exit
80:28 - unless there is a crash and error right
80:31 - it will not exit but it is doing nothing
80:34 - right it's just listening there is no
80:36 - handler for what to do when an HTTP
80:39 - connection comes in so this is an HTTP
80:42 - server right so there is no information
80:45 - about what to do when an HTTP connection
80:47 - comes in so right now it will probably
80:51 - say undefined if we try to access
80:53 - anything if we go to localhost localhost
80:57 - and we go to port 3000 right it will
81:02 - probably not do anything waiting for
81:04 - localhost and it will timeout because
81:06 - there is no instruction but here's the
81:08 - thing the HTTP server received the
81:12 - request it just did not handle the
81:14 - request and the way it does this is
81:17 - through the event the events concept so
81:22 - everything is handled with events so
81:25 - when when I hit that localhost port 3000
81:27 - in the browser I the the HTTP in the
81:30 - server object is going to emit an event
81:34 - that says oh I received a connection
81:36 - what should I do with it so to handle
81:39 - the connection I just handle the event I
81:41 - do something like server dot on and I
81:45 - specify the event that I'm interested in
81:47 - which is a request for Connect I don't
81:51 - know I don't know what it is I think
81:52 - it's request we'll see and in here you
81:56 - get
81:58 - what you do stuff in here so what do you
82:01 - want to do on request now if you don't
82:03 - know what the event is you can so so
82:09 - here's the thing if if if you're using a
82:11 - library like typescript for example
82:13 - which I recommend that you check out
82:15 - then you'll immediately get all the
82:18 - discoverability of everything because
82:19 - server is a typed object and we know all
82:22 - the events on it we know all the stuff
82:25 - in it but if you don't if you don't have
82:26 - this signature around then just look at
82:29 - the documentation know the API
82:31 - documentation czar really really good so
82:34 - you just go to the node API and you look
82:36 - for HTTP and you look for the on the on
82:41 - socket that on connect you look for
82:44 - connect there's no there's a lot of in
82:47 - here but I think what we're looking for
82:49 - is request right so you'll find that the
82:52 - request event here right and you can
82:56 - feel like find examples what is happen
82:59 - this is the event request right and
83:01 - here's what you get when you handle the
83:03 - event request you get a request object
83:05 - and the response object right and this
83:08 - is exactly what we're gonna do here
83:09 - we're gonna get a request object and the
83:11 - response object this is when I handle
83:13 - the request so in here you can do
83:18 - anything to new computations you can go
83:20 - ask the database for information
83:21 - whatever you need to do this function
83:23 - here which we call the callback function
83:25 - but it's really more like a handler
83:28 - function in this case is going to be
83:30 - invoked every time there is a request
83:32 - every time I put on localhost port 3000
83:35 - and hit enter that's a request right so
83:38 - let's console.log a request and let's
83:45 - response send something so hello
83:49 - HTTP so this is how you do it response
83:52 - that's the dot right not send response
83:55 - dot right hello HTTP and then response
84:00 - the end
84:00 - now don't worry about the API yet this
84:02 - this will eventually learn because these
84:05 - things the response object here is a
84:07 - stream
84:08 - we need to stream information this is
84:10 - why we needed to do that in for the HTTP
84:12 - protocol to say oh I'm done but I want
84:15 - to show you that response that right now
84:17 - we need to restart this process every
84:20 - time you change something in a node
84:22 - project you have to restart node know
84:24 - does not have the development mode
84:26 - out-of-the-box
84:27 - so you have to restart it and now if I
84:29 - go to localhost port 3000 I will see
84:33 - hello HTTP so the message that I wrote
84:36 - Suresh túcume and note how I did all of
84:39 - this without any libraries I'm not using
84:43 - Express I installed Express but I'm not
84:45 - using it I'm just using the built-in
84:47 - HTTP library now if you look at the
84:50 - terminal for the thing that we just did
84:52 - you'll notice that we have two requests
84:55 - not just one request although i refresh
84:57 - the browser just once I ask for that
85:00 - page just once so for some reason this
85:03 - handler is being called twice
85:06 - every time we request so why well you
85:11 - need to discover why so to discover why
85:14 - maybe you can print information about
85:16 - the request why am I doing this request
85:18 - and I know that there is a request that
85:20 - URL that you can use to figure out what
85:23 - URL is being requested so now if we go
85:26 - back and write and we have to restart
85:28 - the server remember we have to restart
85:29 - the server if we go back and refresh the
85:32 - browser once and go back to see what
85:36 - requests are being made here Oh check it
85:39 - out so we're requesting that and we're
85:41 - requesting the fav icon so the browser
85:44 - is requesting the Fath icon by default
85:46 - that's chrome just trying to find the
85:47 - fab I come for that website so you have
85:50 - to be aware of these things right that
85:52 - you invoke the the request every time
85:57 - there is a request from the browser and
86:01 - the browser might do requests internally
86:04 - for its own rendering write an apple an
86:08 - iPhone might request the you know I'd
86:10 - the Apple compressed icon for the tablet
86:14 - and Apple compressed icon for the iPhone
86:17 - right it will request the four things
86:19 - actually so
86:21 - you have to handle these right now how
86:25 - do you handle right how do you say Oh
86:28 - what should we do if the request is I
86:30 - have I can request we should serve a
86:33 - small image so you would need to come in
86:37 - here and because of how limited this
86:40 - library is you would need to come in
86:42 - here and say something you know what if
86:43 - the request that URL is to have icon
86:46 - then do something different right you
86:50 - would have to do something like this to
86:52 - handle routes basically right maybe in
86:56 - here you just want to respond response
86:59 - not right nothing no I don't have a 5
87:01 - icon else else right hello HTTP right so
87:06 - now the 5 icon is not gonna get any
87:08 - response where previously it got a
87:11 - string response right so you'll have to
87:12 - you have to have extra logic to deal
87:15 - with routing basically because this is a
87:18 - very raw HTTP package that has no no you
87:24 - know rich API for dealing with routes or
87:26 - dealing with files what if you want to
87:28 - send the file to the browser right what
87:31 - if I want to go to like you know give me
87:33 - slash a dot PNG right if I want to get a
87:37 - file an image I don't have a way to do
87:41 - that I have to use a different library
87:43 - to read the image from the operating
87:46 - system and then write the binary
87:50 - information that I get by reading the
87:52 - image from the operating system into the
87:55 - response stream in here so you have
87:57 - limited capabilities but everything is
88:01 - possible you can still do that you can
88:03 - still read from the file system and and
88:06 - and use the the the node response stream
88:10 - to write to it but there is a better way
88:14 - for dealing with this which is to
88:15 - introduce a library specialized in that
88:17 - kind of stuff all the basic needs for
88:20 - you when you do a web server and that
88:22 - library the most popular library is
88:25 - Express so Express GS is well it's
88:29 - really a framework around web servers
88:32 - and every
88:35 - all expect no developers to be familiar
88:37 - with at least one web framework and
88:40 - Express is just the popular one out
88:43 - there so how to use Express that's what
88:45 - we're gonna do next but before we do
88:47 - that before we do that you might see
88:50 - this handler written in a different way
88:54 - instead of server the on request you
88:57 - might see it in here directly as a
89:00 - parameter to create server so this is
89:03 - just a different syntax that you can use
89:06 - without dealing with the dot on request
89:09 - kind of thing so so actually hides the
89:13 - dot on request
89:15 - thing but I don't like this syntax
89:17 - because I I need you to learn that this
89:20 - is an event right and just like requests
89:23 - there are other events there's connect
89:25 - and disconnect and and many other events
89:27 - and node packages are really burst into
89:32 - this event nature so everything is an
89:35 - event emitter we call server here an
89:37 - event emitter so and you probably need
89:41 - to learn your own event emitting skills
89:45 - you have to be able to create an event
89:47 - emitter and listen to and make it emit
89:50 - events and listen to events because this
89:52 - this this observer model in general we
89:57 - call this the observer model you observe
89:58 - something on something else and it
90:01 - allows you to abstract your libraries so
90:04 - that they don't depend on each other
90:05 - they just send messages right and you
90:08 - listen to messages and you act on four
90:11 - messages
90:11 - so this react fullness for the in the
90:15 - observer model is really handy and this
90:17 - is why it's all over the place in in in
90:19 - note by default note has a limited
90:24 - mechanism to to handle asynchronous
90:28 - calls which is the callbacks and we
90:31 - should probably talk about it a little
90:32 - bit after after in the third hour I'm
90:34 - going to talk a little bit about
90:35 - callbacks and promises in general
90:37 - because this is this is shifting from
90:39 - node into modern JavaScript but in the
90:43 - next five or ten minutes let's explore
90:46 - Express so here's how you
90:49 - a server would Express instead of
90:51 - importing from HTTP we don't need an
90:52 - HTTP you import Express from Express now
90:58 - what do you get here when you import
91:00 - Express you get a function so if you go
91:03 - to the source code of Express you'll see
91:05 - that the top-level import is a function
91:08 - just like the function that we used when
91:10 - we were testing you know the multiple
91:11 - calls so if you want to use Express and
91:15 - I'm just gonna comment out everything
91:16 - here just to keep things just for
91:19 - Express if you want to use Express you
91:20 - because it's a function you just call it
91:22 - and by calling a function what you get
91:25 - back is a server instance so basically
91:28 - just like you know the create server
91:31 - function this Express function top-level
91:33 - is equivalent to the create server
91:35 - function all right so the listen is
91:38 - actually exactly the same you just
91:39 - listen on a port so 3000 just like that
91:42 - you listen on a port 3000 just like you
91:45 - did for the HTTP API but the route
91:48 - handling is a little bit different right
91:51 - the route handling is a little bit
91:54 - different so instead of doing server dot
91:56 - on you would do server got get and this
92:02 - takes in an actual route get slash and
92:06 - this will give you access to request and
92:09 - response right so similar to dot on now
92:13 - it's but it's now get so and you get
92:16 - access to request and response just like
92:19 - that but you also the response is a
92:21 - wrapper around the raw stream response
92:24 - that you get from node so in here you
92:27 - can do other things you can do send or
92:30 - send file if you want to this does not
92:32 - exist in you know the regular actually
92:38 - to be library so in here I can even send
92:40 - an object if I want to send an object so
92:44 - message is hello HTTP so you see how
92:48 - hello express right because now we're in
92:51 - Express so you have some and you don't
92:53 - have to do response that end send is
92:55 - gonna deal with this so it will abstract
92:58 - some of these complexities in here and
93:00 - also you get to be
93:02 - very clean in the way you define your
93:04 - routes because now I can also do fav
93:08 - icon have icon ICO in fact I can do fab
93:14 - icon star so if you call five I conduct
93:17 - PNG I'm gonna respond to this route
93:19 - there's like globbing going on here in
93:22 - the routes so this and in here you would
93:25 - send file you know the file icon
93:28 - whatever the path does have icon so you
93:30 - send the file directly in here right and
93:33 - and express is gonna deal with reading
93:36 - the file from the file system and
93:38 - streaming it to the requester see how
93:42 - this rich API is it's really still basic
93:47 - but it gives you some capabilities to
93:50 - just do features out of the box instead
93:52 - of having to deal with this complexity
93:54 - here but it is a wrapper around the raw
93:58 - HTTP in fact what you get here this
94:01 - listen method is exactly it's just
94:03 - forwarded to the HTTP listen method
94:05 - because express itself is just a wrapper
94:07 - around the built in HTTP framework that
94:12 - you get with note now we didn't really
94:16 - talk about the difference between import
94:17 - and export and require there is a slight
94:20 - difference and and that you need to be
94:23 - aware of which is import is statically
94:28 - evaluated while required is dynamically
94:31 - evaluated so what does that mean that
94:34 - means import is always top level you
94:38 - can't for example import something
94:40 - inside another function you can't do
94:43 - that you can't import something inside
94:44 - the function that is invalid JavaScript
94:47 - syntax why because import is statically
94:50 - evaluated while you can totally require
94:54 - something inside a function when if it's
94:58 - note is why I require you can require
95:00 - something inside a function because
95:02 - require is dynamically evaluated and
95:04 - then cached so that's a big difference
95:07 - between import and export between import
95:10 - and require now what if you want to
95:12 - dynamically import something with echo
95:16 - modules not with note if you make the
95:19 - decision to use a coma script modules
95:21 - and you want to lazily import something
95:23 - basically you still have the option
95:25 - because there is an import function as
95:27 - well so ACMA script has an import
95:29 - function which behaves kind of like
95:31 - require in in in how it you can
95:35 - dynamically call it and it gives you
95:37 - back a promise so what this gives you
95:40 - back is a promise now this is how import
95:43 - is different than required which is
95:45 - required although dynamically evaluated
95:48 - it is synchronous so require is
95:50 - synchronous while import is asynchronous
95:54 - so we're gonna talk another five minute
95:56 - break and come back top of the hour and
95:58 - talk about synchronous and asynchronous
95:59 - talk about callbacks and promises and
96:03 - I'm well I'll go over some lore of lore
96:06 - of the modern features in JavaScript
96:09 - that you can use out of the box in nodes
96:11 - and it will make your code for node
96:12 - better and then we'll leave some some
96:14 - some time for questions because I'm
96:16 - pretty sure you're gonna have some all
96:18 - right so no requires not really better
96:20 - than import but it is just different
96:25 - capabilities so if you want to have
96:28 - something synchronously imported then
96:31 - you can have a wrapper around this
96:33 - import something it's just require
96:35 - existed before Xmas script decided on
96:39 - this import export syntax and its future
96:42 - is probably that it's gonna exist in
96:46 - node but it's not the way to go
96:49 - but not for a few years we still need a
96:52 - few years to stabilize this
96:53 - import/export but I would say starting
96:56 - node 14 no one is gonna remember I
96:58 - require everyone is just gonna use
97:00 - import and export and the reason is this
97:03 - is going to work natively in the browser
97:05 - so you can take the code as is and it
97:08 - will work in the browser and the browser
97:10 - is gonna do this the smartest thing to
97:12 - try to fetch things in parallel from
97:16 - locations so you would have to import
97:20 - from an edge to actually be URL of
97:21 - course you would have to import from
97:23 - like github.com slash Express and and
97:26 - things will work just like that and you
97:29 - me too bundle things because right now
97:31 - when we ship things to a browser we need
97:35 - to bundle them we need to bundle them
97:37 - into one file so that the browser can
97:39 - understand them but in the very near
97:41 - future and by near-future I mean it is
97:44 - possible already but it's still
97:47 - experimental but it's probably next year
97:49 - or the year after that we will just ship
97:53 - the same code to the browser and the
97:55 - browser will work all right so what is
97:58 - bundling really quick bundling is when
98:00 - you take a front-end pack a front-end
98:02 - application that exists over many files
98:06 - and and you pack them into a single file
98:09 - we call this bundling and then you ship
98:11 - a single file to the browser so before
98:15 - we talk about callbacks and promises a
98:20 - little bit more about events let me let
98:24 - me tell you about so if you have if if
98:27 - you if you wanna when you develop your
98:30 - node applications you're gonna be
98:31 - editing files often right and having to
98:37 - restart things is gonna be is gonna get
98:39 - annoying really fast because it's a
98:42 - running server right if you have a
98:43 - running server so let's keep this
98:45 - running a way to keep the server or any
98:50 - file running is to do process the STD
98:54 - end resume now this is advanced but
98:58 - don't worry about it so if I have a
98:59 - server that's running and I want to
99:02 - change things having to restart to the
99:05 - server is annoying so what you can do is
99:07 - you can use tools to watch the files and
99:11 - trigger or restart on save and one of
99:14 - them is node 1 so we get NPM install -
99:19 - dev node 1 node mom for nude monitor and
99:23 - all you need to do is just switch your
99:25 - node command to use node mod instead of
99:29 - nodes so instead of node here
99:31 - node mod and then it will auto restart
99:35 - things for you when you save the files
99:38 - so now that we're running with node mod
99:39 - if I change the string and just
99:43 - save it will automatically restart note
99:45 - for me so this is handy in development
99:48 - so because otherwise it's gonna be
99:50 - annoying you can hate it of course there
99:52 - are a few other tools you can use p.m.
99:54 - to itself you there's a forever NPM
99:57 - package though there's plenty of
100:00 - packages to do that the thing and this
100:02 - is general in terms of note in general
100:06 - when you need you need a single feature
100:07 - you have a lot of options to pick from
100:10 - for example a web framework like Express
100:14 - there are hundreds of them not not tens
100:17 - hundreds of them and and and every one
100:21 - of them has different advantages and
100:23 - disadvantages so you're gonna you're
100:26 - gonna have to make decisions on what
100:27 - libraries to use and I would and there
100:32 - are some guidelines on how to pick a
100:34 - library but I would go for the popular
100:36 - library that is maintained and tested so
100:39 - try to see if libraries maintain the
100:41 - tested and oh and it's responsive or
100:45 - it's closing issues on github its
100:47 - responding to issues on github and also
100:49 - take a look at the code so don't be
100:51 - afraid of the code and take a look at
100:53 - how the library is written and are they
100:56 - using clean code practices are they
100:58 - using good things like typescript for
101:00 - example that's a good sign if the
101:02 - library is using typescript in its code
101:03 - base that means they care about you know
101:05 - tithes they care about their API all
101:09 - right so this is node mom now let's talk
101:15 - about callbacks and promises so I'm just
101:17 - gonna kill this restart so it's a clean
101:20 - exit nothing to do and what I'm going to
101:22 - talk about is the callback pattern that
101:25 - you're gonna see so if you have a
101:28 - function that is wired for the callback
101:34 - function let's let's use the execute
101:37 - command so if you want to execute a
101:39 - command from within your node process
101:42 - you can use child processes what we call
101:46 - the child process library child process
101:49 - so this is how you use the child process
101:51 - you just require I mean import import
101:57 - something from the child process and I'm
101:59 - going to talk about this syntax in just
102:00 - a little bit so you import something
102:02 - from child processing you use it now you
102:05 - have a few things that you can import
102:06 - from child process I'm gonna import the
102:08 - exact method the exact methods from
102:11 - child process so this exact method takes
102:14 - two arguments or three I don't I'm not
102:17 - sure we'll check the API if we need to
102:19 - the first argument is the command to be
102:23 - executed
102:24 - so let's LS / right this is the command
102:29 - to be executed so I'm gonna execute LS /
102:31 - from within node from within node and it
102:36 - gives you access to the output through a
102:42 - callback so this is the callback that it
102:45 - will invoke so in here you get a
102:47 - function so the callback is just a
102:48 - function I'm using arrow functions here
102:50 - but you can use a regular one and I
102:52 - think it gives access to out and error
102:56 - I'm not sure maybe it gives X so I have
103:00 - no idea what the API is but the
103:04 - documentation to the rescue so let's go
103:06 - look up child processes child processes
103:12 - and go for exec what is the API for
103:15 - exact command options callback so you
103:19 - need to get comfortable reading by the
103:20 - way this this weird syntax that they use
103:23 - for documentation so this weird syntax
103:25 - means this exact command takes the
103:28 - command which is a string and then it
103:30 - takes an optional options so these
103:32 - square brackets around options mean
103:35 - they're optional and also it takes an
103:37 - optional callback and the options is an
103:40 - object so you can skip it the callback
103:41 - is a function and these are the three
103:43 - arguments that you get their STD Adam
103:45 - st-pierre I would name them exactly the
103:47 - same so error STD out STD air these are
103:51 - the things that you get now I'm not
103:54 - focusing about the API itself what I
103:56 - want to focus on is the callback
103:58 - mechanism in here so if I'm interested
104:00 - in the output I just do STD out right so
104:04 - if I execute this file with NPM start
104:09 - because it's why are we
104:11 - some and everything then we will get a
104:14 - module not found child
104:17 - process as a child processes child
104:22 - process
104:23 - oh I misspelled it so its child process
104:27 - and check it out
104:28 - boom I see the LS / the output of that
104:33 - last slash you see that so x AK executed
104:37 - LS slash and then it gave me access to
104:40 - the SD be out now if the command have
104:43 - STD error it will give me access to us
104:46 - TV error instead but why do we have two
104:49 - errors there's an error here and then
104:51 - there is an STD in here and the reason
104:53 - is this error is related to the callback
104:56 - itself not to the command right so it
105:01 - depends on how you deal with it but the
105:03 - callback pattern in general is that
105:05 - there's always an error first argument
105:08 - this is the callback pattern this is
105:10 - what happens if we have an error in
105:13 - executing the command not an actual
105:15 - error from STD error itself not an
105:18 - because every command might also result
105:20 - in an error right every every string
105:23 - that you pass in here might result in an
105:24 - error in that case you get it an STD air
105:26 - but also exec itself
105:28 - might might have an error maybe it's
105:32 - executing a command over as SSH and
105:35 - network is slow so there's plenty of
105:38 - ways for a command to fail so you always
105:40 - get this error first argument and you
105:43 - have to handle it because if you don't
105:45 - handle it
105:46 - the error is uh swallowed them it's not
105:49 - cached
105:50 - it's not cached and that means you have
105:52 - a bug so because the command is gonna
105:54 - continue to run STD out will probably be
105:57 - undefined and because he did not handle
106:00 - the error so you always have to handle
106:02 - the air what do you want to do if there
106:04 - is an error right what do you want to do
106:07 - if there's an error and depends on how
106:10 - this module is used you have to do
106:14 - something you can for example throw
106:16 - there this is the safest thing you can
106:18 - do is throw the error again because if
106:20 - you don't it's not again it's not cached
106:23 - at all and it will
106:24 - just go silent but throwing an error
106:27 - will make that process will make the
106:29 - error poeple up to the consumer of this
106:32 - of this module you can also say you know
106:35 - what if there's an error here something
106:38 - serious
106:38 - it happened and I don't know and I
106:40 - didn't want to risk it I'm gonna process
106:42 - that exit
106:43 - I'm gonna make the process crash on exit
106:44 - because I don't know what happened so
106:47 - I'm gonna make it crash and exit with a
106:49 - status code of 1 which means this is not
106:51 - a clean exit we don't know what happened
106:53 - and error happened and let's just crash
106:55 - and exit because you don't want to have
106:57 - a process running in an unknown state
106:59 - and when you get an error you kind of
107:01 - have an unknown state because you don't
107:03 - know what there is if you want to handle
107:06 - some kind of error you can you can have
107:08 - an if statement here it says oh if the
107:10 - error is kind of this kind you know one
107:13 - kind or another kind if the error is
107:15 - file not found or command not found I'm
107:18 - gonna deal with it right but otherwise
107:21 - process and exit this is how you handle
107:23 - error you should crash the process and
107:25 - exit and then the monitor is gonna start
107:28 - a new process that does not have this
107:30 - error state all right so this is the
107:32 - error first the error first callback
107:36 - signature is that the callback itself is
107:40 - the last argument to the host function
107:43 - so we call this the host function right
107:45 - it might have a series of commands and
107:47 - then the callback is a function that is
107:49 - the last parameter for that the function
107:54 - is gonna receive it so it's the the last
107:56 - parameter for that function and then the
107:59 - callback itself has three parameters
108:01 - error STD out and STD I mean at least at
108:06 - least one parameter which is error and
108:08 - then you get the data through the second
108:10 - and the third and the fourth parameter
108:12 - if if they exist right so it's we call
108:15 - this pattern the error first callback
108:18 - pattern and this is what existed in node
108:20 - since day one and it's still and it's
108:23 - still supported today but there is a
108:26 - different pattern today which is to use
108:28 - promises instead of this callback
108:30 - mechanism
108:31 - so if exec was a promised based function
108:36 - then this is how you would use it you
108:38 - would say exact and you give it the
108:40 - command LS right and this gives you back
108:45 - the SDV act just like that just as if it
108:49 - was not asynchronous the reason we
108:52 - needed callback here is because exact is
108:54 - asynchronous it needs to go to the
108:57 - operating system instruct the operating
109:00 - system to do something and then take
109:02 - results from when the operating system
109:04 - is done which might be a few seconds
109:06 - later and then do something with the
109:09 - results so this is an asynchronous
109:10 - function so it's not synchronous I
109:13 - cannot just I cannot I cannot do that I
109:16 - cannot call it synchronously I have to
109:19 - call it asynchronously
109:20 - but if exact is promise based then I can
109:24 - await or first let's do that then
109:27 - I can do dot then yeah let's just do a
109:31 - wait so I'm not gonna like we don't have
109:33 - time to talk about that then and you
109:34 - should really just use awake anyway so
109:36 - you just await on exact but to await on
109:40 - a function you have to wrap it in an
109:44 - async function so you would do you would
109:47 - like define a main function for example
109:49 - and you label it as async right and then
109:54 - you call the main function because this
109:56 - is a thing so you cannot just await on
109:58 - something you have to await on something
110:00 - inside an async function but this is a
110:04 - cleaner than the other part here the
110:06 - other callback mechanism here because
110:09 - callback has many problems and the
110:12 - probably the most famous problem is how
110:16 - when you start making operations depend
110:20 - on each other you would have to start
110:22 - nest callbacks so you would nest
110:24 - callback to in callback one you would
110:26 - nest callback three in callback - and we
110:29 - call this the Pyramid of doom
110:31 - you know the callback help problem but
110:33 - that's not really the most important
110:36 - problem at that callbacks the most
110:37 - important problem about callbacks
110:39 - is that you lose control when you have
110:43 - when you do things in a callback because
110:45 - unless you have trust in the system
110:47 - unless you have trust that exact is
110:49 - gonna actually invoke the call
110:51 - one time right then you don't have
110:55 - control you don't know exact might call
110:57 - your callback five times I don't know
110:59 - you don't have control over that while
111:02 - here you have a little bit more control
111:04 - you have a little bit more trust that
111:06 - this exact is a promise and because it's
111:09 - a promise it's gonna either resolve or
111:11 - reject and it's gonna resolve or reject
111:13 - only once so by moving it into a promise
111:17 - based API you have a little bit more
111:19 - trust into how this API is gonna behave
111:23 - and this is especially important if
111:25 - you're using something that's not
111:27 - built-in not exact if you're using
111:29 - something from Express to not built-in
111:31 - so you're really relying on the
111:33 - maintainer zuv Express package the
111:36 - people who are wrote the code for the
111:37 - Express package you're depending on
111:39 - their coding skills right and you never
111:43 - know but if they give you the interface
111:46 - as a promise then you get back a little
111:48 - bit more trust because you know the
111:51 - promise is an echo script you know a
111:53 - built in JavaScript thing that is going
111:55 - to either resolve or reject and it will
111:57 - do that either of these once so you have
111:59 - a little bit more trust and also you
112:01 - have a little bit more control into the
112:03 - flow of the program you get STD out and
112:06 - you can do something after a speedy out
112:08 - and if you want to nest dependencies you
112:11 - can just do them in line you don't have
112:13 - to nest callback functions you happen
112:15 - you don't have to do anything so it's
112:16 - much cleaner and better way to just
112:21 - handle asynchronous in general so here's
112:24 - my advice to me unless you have to deal
112:26 - with something that only supports
112:29 - callbacks and nothing else
112:31 - do not use callbacks always use promises
112:34 - now here's the thing exact is not a
112:36 - promise based function so this will not
112:39 - work if we try to console the log STD
112:43 - out it will not work because because
112:48 - actually no it did not work it gives me
112:51 - an error here a big error and I did not
112:53 - handle the error right you remember that
112:55 - I did not handle the error so in here I
112:58 - got some kind of object child process
113:02 - it's not really the output them
113:04 - interested in
113:05 - so how do you make it how do you promise
113:09 - if I this how do you make it into a
113:11 - promise well luckily note has a tool
113:15 - it's called
113:18 - you tell you tells you tells liking so
113:23 - if this comes built-in and one of the
113:26 - utilities the utility functions is is
113:32 - promise if I so you can call you tells
113:35 - the promise of I and you pass an exact
113:41 - and it gives you back a promise fight
113:43 - version of exact so we can make it like
113:47 - exactly the promise version in here
113:49 - right and in here since we have a
113:52 - promise of I'd version of exact now we
113:53 - can use the promise if I'd version of
113:56 - exact and things will work fine unless
114:00 - you tells is it you tell yeah there you
114:05 - go so we got STD out it looks like it
114:08 - returns back an object so it's util not
114:10 - utils it returns back an object right
114:13 - and this object has STD out and it has
114:16 - STV error right so if you have an object
114:19 - like this and you want to extract the
114:22 - STD out all you need to do is destructor
114:24 - the STD out and now we're back into the
114:27 - same the same thing that's be beyond
114:29 - cool
114:31 - now what about STD air and air so STD
114:35 - air is just another one so if you want
114:36 - STD error you get it here STD error if
114:39 - you want error itself that's a special
114:42 - case because now we're using a promise
114:45 - that means we have to we have to use the
114:47 - promise API to work with error so we can
114:50 - we can do that we can do dot catch in
114:53 - here because this is a promise and this
114:56 - will give you access to the air or you
114:58 - can do the following you can use
115:00 - javascript native error caching
115:02 - mechanism you put everything in a
115:04 - try-catch statement so you put your code
115:07 - in a try-catch statement and this will
115:09 - give you access to the error that
115:11 - happens when you execute stuff so in
115:13 - here you would do something with there
115:15 - and here you will process the exit if if
115:17 - you catch something that you
115:19 - know that you're you know you're
115:20 - unfamiliar with or or just throw it
115:23 - again report it and throw it and ignore
115:25 - it whatever you want to do with the
115:27 - error right so this API is better on so
115:31 - many levels and and again the the the
115:36 - two main important levels here are trust
115:39 - and control but also imagine that you
115:41 - want to do asynchronous calls in in a
115:44 - loop like if you want to do a loop and
115:47 - every iteration of the loop you have to
115:49 - do an asynchronous call if you're doing
115:51 - it with callbacks it gets ugly because
115:54 - you have to define the boundaries of
115:58 - your loop manually you have to keep it
116:00 - counter and and and check the counter to
116:03 - do things in the loop but if you want to
116:05 - do the asynchronous operation that is
116:11 - promise based in a loop all you have to
116:13 - do is just stick it inside the loop and
116:15 - things will just work so there are many
116:17 - benefits now some api's
116:20 - are promised by default right so every
116:25 - light every decent library out there now
116:27 - supports promises right including node
116:30 - itself node itself is going to support
116:32 - promises so you would do something like
116:35 - slash promises for example and it will
116:38 - give you a version that support promises
116:40 - out-of-the-box now they're working on
116:42 - that the the FS the FS module for
116:45 - example have a promise based API so if
116:48 - you look up the FS module which is
116:50 - something that you need to explore which
116:53 - is have to work with the file system in
116:56 - node so if you look up FS in here
116:58 - fastest them how to read files and write
117:01 - to files and create copy files and
117:03 - rename files and delete directories this
117:05 - is the biggest module in node right and
117:07 - it is the most used module because we
117:11 - work with files a lot right but if you
117:13 - look at it you'll see that it has a
117:15 - promises API so you don't even need to
117:18 - promise if I things you get promises out
117:20 - of the box and and many other libraries
117:26 - support both callbacks and promises they
117:29 - support callbacks for backwards
117:31 - compatibility but they also
117:33 - promises because that's that's the
117:34 - direction where we're going with
117:36 - asynchronous with asynchronous calls now
117:39 - if you notice I didn't really use the
117:41 - promised API I didn't do dot Ven or duck
117:43 - catch I just used async await right
117:45 - because it's just so much better
117:47 - dot then so the promise it sells gives
117:50 - you back the trust but async away gives
117:53 - you much better flow control so you flow
117:56 - your your your code in in a better way
117:59 - you control what happens with your code
118:02 - so you and you don't need to nest
118:04 - functions right so there's much benefits
118:06 - to async await so that is it about
118:11 - callbacks and promises so if you have
118:15 - any questions about that shoot up now
118:17 - callback some promises both of them
118:19 - really are limited in terms of handling
118:24 - handling multiple events right handling
118:28 - multiple events so there are there this
118:30 - is appropriate here because we have a
118:33 - single event this asynchronous nature
118:35 - here is a single event that we need to
118:37 - execute a single command and get back a
118:39 - single output right but what if we have
118:42 - like a monitor of commands what if we
118:46 - are monitoring the memory for example
118:48 - right we're monitoring the memory this
118:50 - application is using we would need to
118:53 - pull many commands on an interval we
118:56 - need we need many events right or we're
119:00 - monitoring the memory and we're
119:01 - interested in knowing what's gonna
119:03 - happen when it reaches certain
119:06 - thresholds like after 100 me 200 me
119:08 - right so if you have an asynchronous
119:11 - operation that has multiple events this
119:15 - is where you need to use an event
119:17 - emitter you need to use an event emitter
119:19 - and using an event emitter is
119:22 - straightforward because it comes it's
119:24 - supported in node itself so this is this
119:26 - is something that you need to get
119:28 - familiar with you import event emitter
119:30 - from events this is also built-in you
119:34 - import event in metal from events and
119:36 - you create an event emitter an event a
119:41 - matter object using this syntax new
119:44 - event
119:45 - emitter and now you can if it emit
119:50 - events you can say okay FET the matter
119:52 - I'm going to emit this event just let's
119:55 - call it change something has changed you
120:00 - can you can omit any event right you can
120:02 - omit the same event multiple times right
120:05 - and to listen on these events and do
120:08 - something you just do the on method just
120:11 - like the server because the server is an
120:13 - event Mary you just do on change and
120:15 - what do you want to do on change well
120:18 - let's just console.log something has
120:21 - changed right console.log something has
120:23 - changed so this is the syntax for event
120:28 - emitting right now here's your interview
120:30 - question what's gonna happen when I
120:31 - execute this code and your answer is
120:36 - will I see this three times because I
120:39 - emitted three times and then I'm
120:40 - listening to the unchanged event and the
120:43 - answer is no you will not see it at all
120:45 - why because I started listening after I
120:49 - emitted the three events right I started
120:51 - listening after I emitted the three
120:54 - events and the order here matters so if
120:56 - we change the order to put the listen
120:59 - first listen and then emit three times
121:01 - then you'll see something has changed
121:03 - three times so the order matter in fact
121:05 - everything here is synchronous there's
121:07 - nothing asynchronous yet however what
121:10 - you can do is you can start emitting
121:12 - things asynchronously
121:14 - for example let's do let's do a set
121:17 - interval and emit something has changed
121:21 - every second right now we have set
121:25 - interval that runs every second and in
121:28 - here we can you know emit some emit
121:32 - event event emitter dot emit change
121:37 - right so in here now what's gonna happen
121:41 - is if something has changed is gonna be
121:44 - emitted every second and our handler is
121:47 - gonna call it our handler is gonna be
121:50 - called so this is our handler basically
121:51 - we're handling this event by just
121:54 - constant logging it right so this is
121:56 - what you use if you have
121:58 - multiple events going on you would use
122:00 - an event emitter and here's the thing
122:02 - everything in node is based on this
122:05 - event emitter logic so when you get an
122:07 - HTTP server or when you get a stream
122:10 - right if they're all event emitting
122:15 - object right so the you remember when we
122:19 - did server get and we did that and we
122:23 - get request and response right we did
122:27 - request and response and we did
122:28 - something with request and response
122:29 - guess what
122:30 - server is an event emitter request is an
122:33 - event emitter response is an event
122:35 - emitter they all have events and you can
122:37 - listen to these events and you can make
122:40 - them emit events right can we make the
122:45 - emitter use async/await instead of a
122:47 - callback yes you can in fact this is
122:50 - supported if we the not async/await in
122:56 - general but an event emitter is also can
122:59 - be consumed as a generator because this
123:02 - is this ties into the generator concept
123:05 - in JavaScript right because JavaScript
123:07 - has this generator concept so if you
123:10 - wanna if you wanna look that out if you
123:12 - want more information about that look up
123:14 - generators in in JavaScript and have to
123:17 - consume new event emitter objects in
123:20 - node through the generators and X all
123:23 - right so this is all the time we have
123:24 - for events I'm gonna try to cover a few
123:28 - more topics in modern JavaScript but
123:30 - definitely keep that questions coming
123:32 - because I know there's a lot of
123:33 - information here I just want you to dick
123:36 - to get a taste of everything that you
123:38 - can do in node and really tease your
123:41 - knowledge into the the capabilities that
123:44 - you have built in before even installing
123:47 - anything like Express or lodash the
123:50 - other big thing that you need to learn
123:53 - here before I switch gears into the
123:56 - modern JavaScript just review is streams
123:59 - so you need to learn about streams in
124:03 - node and streams are big in them so what
124:05 - what are streams in general so streams
124:10 - are like they're kind of
124:11 - like array of data but instead of having
124:15 - this data over space you have it over
124:17 - time right so it's not available all at
124:22 - once it's not available for you in
124:24 - memory you're just getting it over time
124:26 - so every time you have a chunk we call
124:29 - it a chunk right a chunk of data becomes
124:32 - available and you can use it in your
124:34 - stream and after a while you get another
124:37 - chunk of data and you can use it in your
124:41 - stream so what our stream is good for
124:43 - they're good if you have huge amounts of
124:46 - data that you need to process in your
124:49 - code if you need to process a huge
124:52 - amount of data in your code you have to
124:54 - do it with streams but here's the thing
124:56 - here's the general advice I'm gonna give
124:58 - you you should just use streams all the
125:00 - time even if you have to process small
125:02 - amounts of data because they because you
125:04 - never know when the data is going to
125:06 - grow and you never know what's gonna
125:10 - happen in that case
125:11 - so streams are basically just like pipes
125:14 - yes and you can pipe streams on each
125:16 - other so an example of handling data
125:19 - that you should do through streams is
125:21 - the HTTP example for requests are asking
125:26 - for an image right if a requester is
125:28 - asking for a file in general you should
125:31 - really use streams to handle that you
125:33 - should read the file as a stream and
125:36 - write the file as a stream so when you
125:39 - do that your application will not
125:41 - consume the size of the file in memory
125:43 - so let's say you're you're trying to
125:46 - serve a 1 gigabyte video file in your
125:50 - web server right if you don't use
125:52 - streams you will buffer one gigabyte of
125:55 - data in memory and that's how much
125:59 - memory your node process is gonna
126:01 - consume but if you're using streams you
126:04 - can get these chunks you know 660
126:09 - kilobyte at a time or whatever the
126:11 - default chunk size is and you get chunk
126:14 - one chunk and stream it to the requester
126:17 - and they get to play while your stream
126:20 - binary data because it's supported right
126:22 - video streaming is supported but this is
126:24 - how you do it you stream at one
126:26 - chunk at a time you do not send the
126:28 - whole thing you do not buffer the whole
126:29 - thing you do not send the whole thing
126:31 - now note comes stream ready out of the
126:35 - box so the note the note HTTP package is
126:38 - stream ready because everything is
126:39 - streams and all the wrappers around it
126:43 - our streams ready so when you do duck
126:45 - send file for example in Express Express
126:47 - is gonna do the right thing and stream
126:49 - it you just need to be aware that you're
126:51 - dealing with streams you're not dealing
126:52 - with buffers you're dealing with streams
126:54 - in general and and when you run into
126:58 - problems you'll run into stream related
127:01 - problems right you have to be aware of
127:04 - that so if you get any errors about
127:05 - chunks and you know stream interrupted
127:09 - or one stream is slower than the other
127:11 - right because if a stream is slower than
127:14 - if the sending stream is lower than the
127:16 - receiving stream then the streams have
127:19 - to do it have to do some you know back
127:22 - pressure kind of thing so there's a lot
127:24 - of science around streams you just need
127:26 - to know that you're dealing with streams
127:28 - all the time you can also create your
127:30 - own streams in node using the stream
127:33 - package that comes built-in and you also
127:37 - get streams out of the box for example
127:40 - there is the zip package there is the
127:43 - crypto package that you get in node and
127:46 - these have functions that work with
127:48 - streams so if you want to gzip something
127:51 - or unzip something if you want to
127:53 - encrypt or decrypt something you get to
127:55 - do it with streams because all of these
127:58 - work on can work on large data you never
128:01 - know if the thing that you want to
128:03 - encrypt is small or big if it's bigger
128:06 - than you know a few megabytes you should
128:08 - definitely use stream this is why by
128:10 - default you should use stream so there
128:12 - are a few types of stream but the most
128:15 - important the most interesting type is
128:16 - the transform stream the transform
128:19 - stream so there's readwrite there is
128:21 - duplex stream but really the most
128:25 - interesting type is the transform stream
128:27 - which is what you get when you use the
128:28 - zip and crypto is where you get one
128:32 - source one readable source and you write
128:35 - to a writable destination so you read
128:38 - from a readable source
128:39 - and you write a writable destination we
128:41 - call these transform streams all right
128:44 - cool
128:45 - the other thing that I want you to
128:47 - explore and I'm gonna give you some
128:49 - resources at the end for what's next but
128:53 - the other thing that you want to explore
128:54 - is scaling in general so how to scale a
128:59 - node application because if you can't
129:00 - scale another application you should not
129:02 - be right you should not be running milli
129:03 - right node has scalability out of the
129:07 - box like built-in and the way it does
129:10 - this is through the cluster module so
129:12 - the cluster module gives you a way to
129:15 - load balance a few processes together
129:18 - and you should always run your node
129:21 - application in production under a
129:23 - cluster you should not run a single
129:25 - process even if your server is only
129:27 - capable of running a single process that
129:30 - single process should be a cluster so
129:32 - your server is gonna have is gonna run
129:36 - as many processes as it has a virtual
129:41 - cores right so you so for example this
129:44 - machine and we can look at the virtual
129:46 - cores here using OS the CPUs which is a
129:50 - function dot link so this particular Mac
129:54 - machine has 12 cores
129:55 - right which means I can run 12 note
129:59 - processes and the operating system is
130:01 - gonna be fine with it right and they all
130:03 - can run in parallel so if I'm running a
130:08 - production server here I would have a
130:10 - cluster of 12 processes all running the
130:13 - same thing and I would have a load
130:15 - balancer that balanced between them and
130:17 - the same process is gonna monitor 12
130:22 - processes and it will automatically
130:24 - start a new process if one crashes and
130:27 - we can also do a zero downtime restart
130:30 - by restarting one process at a time so
130:32 - we're worst at one process and wait
130:34 - until that process finishes any pending
130:37 - requests you know and then when it's
130:40 - done we'll start a replacement so we
130:43 - call this zero downtime restart so
130:46 - there's plenty of things that you can do
130:47 - and you can do it all through the
130:49 - cluster module but it's kind of like the
130:52 - story of
130:53 - you know HTTP and Express you know the
130:55 - raw versus rich API so instead of
130:59 - cluster you can use the PM to package or
131:02 - something similar PM 2 is just one of
131:05 - the one of my favorite packages and this
131:07 - is what we use in J's complete it is a
131:10 - wrapper around the cluster module and it
131:13 - gives you rich features out of the box
131:16 - with just a few commands so that's not
131:18 - only take a look at PM - if you want to
131:21 - run a node application in production I
131:23 - would strongly recommend that you
131:25 - started with PN - so we just take a
131:28 - quick look at the big list that we
131:31 - started with and see if we missed
131:33 - anything important I'll mention a few
131:38 - things here but I I kind of want to show
131:42 - you the inspection it's important how
131:44 - you debug new applications so this is
131:46 - this is definitely on the list but I'll
131:48 - mention a few things here DNS if you
131:51 - want to do DNS enquiries eval something
131:53 - should never use write this actually
131:55 - it's JavaScript path if you want to work
131:58 - with you know paths on the operating
132:01 - system so if you want to look up a file
132:04 - you need to specify a path however paths
132:06 - are gonna be different on Windows than
132:08 - they are on Linux and Mac so if you want
132:11 - to do it in an operating system agnostic
132:12 - way you do it through the path the path
132:15 - module here read line if you need to
132:18 - actually write a CLI command then you
132:21 - need to take input from the user you can
132:23 - use this read line method there are few
132:26 - utilities that we didn't cover but
132:29 - really it util is kind of going away
132:31 - because things are coming natively to
132:34 - the language right so util was just a
132:36 - replacement but there's definitely a few
132:38 - things that you can do here what's what
132:45 - else what else crypto domain don't use
132:47 - that events again is the most important
132:49 - net we didn't really talk about net and
132:52 - net is big so that if you want to do any
132:55 - TCP programming in node if you want to
132:58 - do TCP communication and socket
133:00 - communication you would use this
133:02 - built-in net library if you
133:06 - interface with v8 you can use v8 this
133:08 - this package v8 gives you a few methods
133:12 - to access v8 directly assert is
133:16 - something that you get out of the box
133:17 - which is kind of like a very mini
133:19 - assertion library that you can use in
133:20 - your tests so this would replace this is
133:23 - just like chai for example it has a few
133:26 - built in assertions that you can use FS
133:28 - is huge right this is the file system OS
133:31 - is read information from the operating
133:34 - system stream if you want to create
133:37 - streams not if you want to use them if
133:39 - you want to create streams you would use
133:41 - this stream package string decoder if
133:46 - you are using binary information and you
133:49 - want to decode it into a string you
133:50 - would use this one Z Lib if you want to
133:53 - zip things and unzip things oh this is
133:56 - all built-in you don't install anything
133:58 - this is all built-in power right which
134:00 - is really great
134:02 - and finally query string and URL if you
134:06 - want to work with with parson and format
134:09 - URLs all right so there's plenty of
134:11 - things for you to to learn you got yeah
134:13 - you kind of have to learn like the
134:16 - capabilities of all these packages and
134:18 - of course I skipped everything
134:18 - JavaScript but there's a lot of
134:20 - JavaScript in here I want to show you
134:23 - how to debug a node application so let's
134:25 - say that we have
134:29 - we have an array and we wanna a map and
134:36 - like be equal aid up map and in here
134:40 - let's say we want to function and in
134:47 - here we want to return e times e so some
134:50 - kind of some kind of code that we need
134:52 - to debug right and console the log B so
135:00 - this this debugging thing that I'm gonna
135:01 - show you is gonna work no matter what
135:03 - even if you have a server running you
135:05 - can debug node with with the following
135:09 - so if I'm running this server node
135:12 - server that is cool things are worth
135:16 - working so we have a bug here like we're
135:19 - passing a plus B instead of star we
135:21 - don't know like what is going on and I
135:23 - need to debug what is going on why is it
135:25 - not doubling the elements instead of why
135:27 - is it doubling the elements instead of
135:29 - squaring them and I need to debug that
135:32 - so what I can do is I can run node with
135:36 - inspect you just do note inspect just
135:39 - like that node inspect server dodged as
135:42 - a sorry node - - inspect server digest -
135:47 - - inspect surfer that yes and this will
135:51 - this will run the file through the
135:54 - inspector but this file does not run
135:57 - forever right because it does not run
135:59 - forever it will exit so although we run
136:01 - it through the inspector we also exited
136:04 - and the inspector accident so what you
136:07 - can do is instead of - - inspect do - -
136:10 - inspect BRK which means inspect and
136:13 - break on the first line so don't don't
136:16 - exit inspect and break on the first line
136:19 - so what this does is it will create a
136:23 - WebSocket server listening on this URL
136:26 - and you can use a dev tool kind of tool
136:32 - to connect to this web socket and issue
136:34 - commands for node to you know break on a
136:39 - breakpoint or go to the next line or go
136:42 - you know jump over step over a function
136:45 - the thing is chrome support this out of
136:49 - the box all you need to do is go to
136:51 - chrome inspect and it will see all the
136:56 - listening processes right here so you
136:59 - see my node server that justice right
137:01 - here all I need to do is click inspect
137:02 - and it will give me ready for a dev
137:06 - tools for my node script right there and
137:09 - I can do everything I can do in the dev
137:11 - tools that I use with my you know
137:14 - front-end application I can resume
137:16 - script execution step over go here step
137:20 - in to inspect the variables local in
137:24 - this case is one and then step next one
137:27 - he is two and the return value is that
137:29 - everything that you have in the very
137:32 - rich dev tools experience you can use it
137:35 - with node just with the dash dash
137:37 - inspect or dash dash inspect BRK and you
137:40 - can set breakpoints and set expressions
137:44 - call stack watch expressions everything
137:47 - right so how cool is that right very
137:49 - very very cool and every time you pause
137:52 - in here you can do manual operations on
137:55 - on the variables that you have so this
138:00 - is inspection with with nodes just use
138:04 - the that just use the chrome dev tools
138:07 - integration with the dash dash inspect
138:09 - now if you need to inspect a node
138:11 - application on like a server where you
138:15 - don't have a graphical interface you can
138:18 - use the dash you can use the inspect
138:20 - itself so if you just do inspect not - -
138:23 - inspect if you just do inspect you get a
138:26 - terminal debugger so you can debug here
138:28 - in the terminal and you see how it
138:30 - stopped on the debugger one I thought I
138:32 - had it stopped right here and you can
138:34 - debug everything you can go into I think
138:37 - you can have to type rebel and now you
138:39 - can debug things in in the rebel and you
138:43 - can type in and you can control see to
138:45 - exit the rebel type and help to see what
138:46 - you can do in here you can have commands
138:49 - to break point and continue and
138:52 - and watch things and all the this so we
138:55 - call this a terminal debugger and it's
138:57 - handy if you're debugging things in
138:59 - production on a server where you don't
139:01 - have a graphical user interface and
139:02 - there's a case where it only happens in
139:04 - that server and it you can't reproduce
139:07 - it locally so that terminal debugger is
139:10 - something that you can use as well all
139:12 - right cool
139:14 - so there is a lot of modern JavaScript
139:17 - that you need to to learn if you if you
139:20 - want to work with node projects and the
139:22 - reason you need to learn these modern
139:24 - JavaScript is that everyone is using
139:26 - them so you look at any node based
139:29 - project and the project that is gonna be
139:32 - you know any if you're if you want to
139:35 - join a team they're probably using
139:36 - modern JavaScript now I wrote a lot
139:40 - about modern JavaScript I'm gonna try
139:41 - and find the three article so in the J's
139:45 - complete library jobs I think it's
139:48 - JavaScript for react all the jobs you
139:51 - need to use before react so I wrote this
139:54 - for react but it really applies to
139:56 - everything so I am kind of like focusing
139:58 - on and this is free you can just read it
140:00 - here I just complete I'm focusing on the
140:02 - features that are specific to react but
140:07 - for node you need all of this and more
140:10 - so that is the whole subset that you
140:12 - need to learn so I'm just gonna go over
140:15 - really quick and just mention what's
140:19 - important what's really important in
140:21 - modern JavaScript that you need to know
140:22 - block scopes are good not very important
140:25 - oh that we have a list here arrow
140:28 - functions yes we use this all the time
140:30 - they are a little bit different but
140:32 - what's important for you to understand
140:33 - is how they behave in terms of closures
140:36 - right so error functions and closure and
140:40 - this is this article is your first good
140:42 - step into understanding these but you
140:45 - get an expand on that after that literal
140:47 - notation not really new but we we do a
140:50 - lot of stuff expressions destructuring
140:52 - another big one here is these
140:54 - structuring so I'm gonna quickly tell
140:56 - you about it so this is the D
140:59 - structuring syntax that we have here
141:00 - this we use D structuring with arrays
141:02 - and objects and so this is what Airways
141:05 - this is with objects destructuring with
141:07 - objects and its really equivalent to
141:10 - doing this here so the D structure in
141:13 - ovaries is equivalent to what I did here
141:14 - you just take the items as they are
141:18 - positioned in the array and you give
141:20 - them local names in the scope in the
141:23 - local scope you give them names in your
141:24 - local scopes and that works for object
141:30 - properties and array items by their
141:32 - position right so very very very big we
141:35 - use destruction all the time because
141:37 - it's a much better syntax you can also
141:40 - use it in function parameters so you can
141:43 - D structure a function parameter if that
141:45 - parameter is an object or an array you
141:48 - can D structure the properties that
141:50 - you're interested in right there inside
141:52 - the function parentheses where you
141:55 - define the parameters of the function
141:56 - alright spread and rest the three dots
142:00 - operator the three dot syntax here is
142:03 - magic if you use it with destructuring
142:05 - like this it's a rest operator basically
142:08 - you're capturing the rest of the array
142:11 - elements after the structuring the first
142:13 - one into another array so you use it to
142:15 - capture part of an array or an object
142:19 - and you can also use it later on to
142:22 - spread an array into another array so in
142:25 - here the three dot operator is spreading
142:28 - array one in two array two and
142:31 - introducing more items into already do
142:32 - and I'm spreading object two into
142:34 - another object you spread one object
142:36 - into another object cool so this is this
142:38 - is the spread syntax another important
142:44 - things is promises and async await so I
142:46 - told you a little bit about it this is
142:47 - more details here about promises and
142:49 - async await and we also talked about
142:52 - module important export a little bit
142:54 - more details here about named imports
142:56 - and named exports and default imports
142:58 - and default experts and the rest of this
143:00 - article here is just not modern
143:02 - JavaScript but more geared toward react
143:06 - so in react we use a lot map filter and
143:08 - reduce we use conditional expressions
143:10 - and we if you need to use timers you
143:13 - would need to use set time and set
143:16 - intervals there's some examples here
143:18 - about that
143:19 - so I do want to leave a few minutes for
143:21 - any last-minute questions but I'm gonna
143:23 - give you a little bit more what's next
143:27 - so I have this is not completely free
143:31 - but I'm writing but I think parts of it
143:33 - are so I'm writing this complete intro
143:36 - to node.js which is going to be a mini
143:39 - book for for you to start with nodejs it
143:43 - covers a lot of what we cover today in
143:44 - more details so this is a good next step
143:48 - if you want to venture into that and
143:50 - after that I have the node beyond the
143:55 - basics book which is gonna be a huge one
143:58 - I'm still working on that so it will
143:59 - hopefully be published in in the next
144:02 - few months but this is really the
144:04 - advanced book after you're done with
144:06 - just the basics this is what are you
144:08 - actually gonna learn no this is where
144:10 - you learn the modules and the
144:11 - event-driven architecture in the stream
144:13 - that a child process and how to scale
144:14 - will cluster so deep dive into the node
144:18 - concepts that we mentioned today and
144:20 - there are a lot of them there's a lot of
144:22 - details now you can learn all of this
144:25 - through the official documentation just
144:27 - read the API documentation in fact this
144:29 - is how I learned stuff is just by
144:31 - reading the documentation in here and
144:34 - the examples are not too bad it's just
144:36 - when you when you put big things
144:37 - together and work through the context
144:40 - example that you relate to it's a lot
144:43 - easier to learn so that's what I'm doing
144:46 - in the next few months is I am fleshing
144:49 - out the beyond the basics book to have
144:52 - like one place where you can learn all
144:54 - the advanced stuff about node runtime
144:57 - itself not note packages but no runtime
145:00 - itself so I don't cover things like
145:03 - Express or lodash or socket IO I don't
145:07 - cover any packages I'm just focusing on
145:08 - what you get built in out-of-the-box
145:12 - with node and the capabilities that that
145:15 - gives you so you can build your systems
145:17 - on top of them because if you can avoid
145:20 - introducing a new package to your
145:22 - dependencies you should so you should
145:25 - not really bring in low - just to summon
145:27 - array because you can summon array in
145:29 - three in two lines of in one line of
145:31 - code in
145:33 - in modern JavaScript right so you should
145:35 - avoid getting a dependency unless like
145:37 - your whole system is designed around
145:39 - that dependency for example you're using
145:42 - react you would have react as a
145:44 - dependency but think so many times
145:47 - before you introduce the dependency and
145:49 - if you can do it natively you should do
145:51 - it natively first all right cool
145:54 - so we're coming to an end so I'm gonna
145:56 - leave some time for questions so if you
145:58 - have any final last minute questions now
146:01 - is the time we've got seven minutes left
146:04 - so we have we can we can handle that so
146:06 - I'll give you a few minutes to type any
146:08 - questions that you have and I'll see
146:12 - which bits of JavaScript should you
146:13 - avoid if in node if possible oh man that
146:18 - is a big question so what should you
146:20 - avoid in node and the answer is not
146:23 - there's nothing special in node you
146:25 - should avoid bad JavaScript and
146:28 - JavaScript has a lot of bad parts right
146:32 - now modern JavaScript solved many of
146:36 - these bad parts right so you don't
146:39 - really have to deal with them but you
146:43 - should for example always use strict
146:45 - right so this is one thing so use strict
146:47 - is important so if you go in here by
146:50 - default node does not use strict by
146:52 - default so I can define a variable
146:54 - without var for example and that's bad
146:56 - you should not do that you should not be
146:58 - able to define a variable without far
147:00 - because JavaScript is gonna do the
147:02 - hoisting thing and confuse your code so
147:05 - this should not be allowed and you can
147:08 - put use strict in your in your files
147:12 - just use strict and this will make you
147:17 - know the strict mode this will activate
147:19 - the strict mode out-of-the-box for you
147:22 - but a better way to just adding this use
147:25 - strict everywhere is just to instruct
147:27 - node to always use strict and you
147:30 - there's a flag for that you can just do
147:33 - - - use strict and this flag is actually
147:35 - v8 so if you do - - use strict and you
147:40 - try to define a variable with that far
147:41 - that tells you you cannot do that a is
147:43 - not defined what are you doing if you
147:45 - want to define a variable you
147:46 - war or consulate right so this is a form
147:49 - of protection against bad practices in
147:52 - JavaScript is to always use strict and
147:54 - if you're using a bundler like for
147:57 - example if you're using babel by default
147:59 - babel is gonna use strict for you so or
148:03 - if you're using typescript for example
148:05 - you can tell type scripts you always use
148:07 - strict all the time assume strict mode
148:09 - and type scripts gonna give you errors
148:11 - into using type scripts into using a
148:13 - non-standard or like bad practices in
148:17 - fact i would definitely advise you to
148:22 - explore typescript next because
148:24 - typescript is gives you a huge value but
148:29 - the problem is it also comes with a lot
148:31 - of package for you basically that you
148:36 - need to you need to deal with types you
148:39 - need to deal with missing tags you have
148:41 - to define you have to add write extra
148:43 - code but give it a few weeks not a few
148:46 - days give typescript a few weeks and
148:48 - after a few weeks of working with
148:50 - typescript you're gonna see the value
148:52 - typescript is on is next on my list of
148:55 - things to write about
148:57 - so we use typescript at JS complete and
149:00 - it is a huge value for us so in fact my
149:03 - next Pluralsight course might be on
149:05 - typescript and now definitely there will
149:08 - be in the future a book about typescript
149:10 - so try to use the good practices and try
149:14 - to have a type checker in your system
149:17 - but there's also es lint es lint is big
149:21 - so if you can't use typescript if it's a
149:23 - big decision for you just start with es
149:26 - lint and start with recommended rules
149:28 - for your system so es let is another
149:32 - code quality tool that you can use and
149:35 - it's it integrates into your editor so
149:37 - if you do something bad es lint is going
149:39 - to complain right away in your editor
149:42 - and it can also auto fix bad problems
149:45 - some bad problems for you so definitely
149:49 - take a look at es lint and configure
149:52 - your system to have you know the
149:55 - amended rules like for example a
149:58 - recommended rule is to always use
150:00 - semicolons this is recommended rule you
150:03 - should not write your javascript without
150:05 - semicolons unless you have in your flow
150:07 - something that will fix that most cases
150:10 - for you and warn you if you do you know
150:14 - if you if you do something like this
150:15 - because javascript is gonna assume you
150:18 - want to do that without a semicolon
150:20 - right so definitely yes lint is
150:23 - something that needs to be in your flow
150:26 - even if you're using typescript right es
150:28 - length is just a different different
150:29 - category of protection against you know
150:33 - what you should not be using in your
150:36 - code so I'm gonna stop at this point
150:39 - thank you all for attending and see you
150:43 - in other sessions