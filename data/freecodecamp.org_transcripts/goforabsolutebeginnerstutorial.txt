00:00 - learn the fundamentals of go by building
00:01 - a full stack payment application go is a
00:05 - powerful and efficient language designed
00:07 - for modern software development you'll
00:09 - learn everything from basic syntax and
00:11 - data types to Advanced features like go
00:14 - routines and concurrency patterns
00:16 - Georgio tonson developed this course by
00:19 - the end of this course you'll have the
00:21 - skills to build robust high performance
00:23 - applications using go hey what's up
00:26 - everybody my name is Georgio and I'm
00:28 - going to be your instructor for this go
00:30 - programming course in this course you're
00:33 - going to learn everything that you need
00:34 - to know to get started programming in
00:37 - the go programming language although go
00:39 - is a relatively new language It's
00:42 - Quickly becoming one of the more popular
00:44 - languages for large companies to
00:46 - introduce new products and services and
00:49 - has been used in some very popular
00:52 - Technologies such as kubernetes and
00:54 - Docker this means that if you're looking
00:57 - for a job this is a very useful tool to
01:00 - have in your tool belt in this course
01:02 - I'll teach you everything that you need
01:04 - to know to get started programming and
01:06 - go we're going to go over all of the
01:08 - Core Concepts and go and we're going to
01:10 - build a backend for this beautiful
01:13 - minimalist front-end product store Page
01:17 - now the front end or user interface that
01:19 - I just showed you isn't so much going to
01:22 - be what we're going to be focusing on
01:24 - because go is primarily a backend
01:27 - programming language and by backend I I
01:30 - mean everything that happens behind this
01:33 - pretty web page to make the process and
01:35 - functionality of purchasing a product
01:38 - possible so essentially our Focus as
01:41 - backend Engineers is the internal
01:43 - functionality that happens behind the
01:45 - user interface which is hidden from the
01:48 - user which happens to be the most
01:50 - important part of any functioning
01:53 - application now if you've never built a
01:55 - website before or you've never coded
01:58 - before don't worry I'm going to to teach
02:00 - you everything from scratch and if
02:02 - you're a complete beginner again don't
02:04 - worry I designed this course for anybody
02:07 - interested in learning how to program
02:09 - using the go programming language you're
02:12 - not too old and you're not too young the
02:14 - c-programming language is so Compact and
02:17 - minimalist that there's really not much
02:20 - in terms of memorization and I'm
02:23 - confident that I can help to get you
02:25 - over that initial difficulty curve that
02:28 - most people experience when they're
02:29 - First Learning a programming language
02:32 - I'm super excited to have the
02:34 - opportunity to be able to teach you the
02:36 - go programming language so I hope that
02:38 - you stick around and learn this
02:40 - beautiful and Powerful programming
02:43 - language so let's take some time to go
02:46 - over what we're actually going to be
02:48 - building here so we're essentially going
02:50 - to be creating the back end for this
02:54 - product page so this product page is
02:57 - essentially a place where a customer can
03:00 - select a product to purchase and the
03:03 - customer will input their information
03:06 - such as their shipping address and their
03:09 - payment details and when the customer
03:11 - actually fills out this form and fills
03:14 - out their payment details we're actually
03:16 - going to send those payment details to a
03:19 - payment processing platform on the back
03:22 - end and that payment processing platform
03:25 - is called stripe and this is Stripes
03:28 - documentation you don't have to worry
03:29 - too much about what's happening here now
03:32 - we're going to get to that soon but
03:34 - basically here's a list of test credit
03:36 - cards that we can use to actually test
03:39 - the functionality of our application so
03:41 - we can use this dummy credit card here
03:44 - and we can go ahead and put that credit
03:46 - card number into our checkout and we can
03:50 - put any expiration date and any
03:55 - CVC and when we select pay now it's
03:58 - actually going to send that request to
04:01 - the backend so actually if we bring up
04:04 - our backend here so I'm currently
04:07 - running our backend server on this
04:10 - system and if you don't know what I mean
04:13 - by that don't worry because we're going
04:15 - to get into all of that but this is just
04:17 - to give you a general idea of what we're
04:20 - going to be doing so don't worry too
04:22 - much about this part yet but yeah the
04:24 - code that we're going to be writing for
04:26 - the backend server is actually going to
04:28 - be capable of processing real credit
04:31 - card payments like we're actually going
04:33 - to be creating something that could be
04:35 - used in a real world situation maybe if
04:38 - you wanted to sell your own product and
04:41 - since that is the case you're going to
04:43 - learn a lot about how to protect the
04:46 - customer and security while learning the
04:48 - go programming language okay so before
04:51 - we get started there are a couple of
04:53 - things that I should mention so this
04:55 - entire course is going to be done on Mac
04:59 - OS it is possible for Windows users to
05:02 - follow this course but the OS Specific
05:05 - Instructions are going to be Mac
05:08 - OS specifically Mac OS monter version
05:13 - 12.6 and with that being said the next
05:15 - thing that we need to direct our
05:17 - attention to is the installation of the
05:20 - go programming language and a code
05:23 - editor but before we get to that point
05:26 - we're going to need to go ahead and
05:28 - select our LaunchPad and I want you to
05:31 - type into the search bar the word
05:33 - terminal and you should see this
05:35 - terminal application which comes default
05:38 - on all Mac OS systems now this
05:41 - application is going to be very
05:43 - important so there are some Basics about
05:46 - how to use this that I'm going to need
05:48 - to go over with you before we can
05:50 - install the go programming language so
05:53 - let's start by opening this terminal
05:55 - application now throughout this tutorial
05:58 - whenever you see me making use of this
06:00 - black box this is the terminal
06:02 - application that I'm using and you're
06:04 - going to want to become familiar with
06:06 - this application because this
06:08 - application's going to be used for many
06:11 - purposes in the development or
06:13 - programming world and for this course
06:15 - you're going to need to follow along
06:17 - with some of the commands that I execute
06:20 - within this black box and you don't need
06:23 - to have any experience with this I'm
06:25 - going to walk you through every command
06:26 - that I use and every time that I make
06:29 - use of this terminal I'll explain
06:32 - exactly what it is that I'm doing so for
06:34 - now let's start with our first command
06:37 - and we're just going to type CD into
06:40 - this terminal window so this here CD is
06:43 - a command and it means change directory
06:46 - so if we go ahead and hit enter you'll
06:48 - see that nothing really happened because
06:51 - when we type in the CD command without
06:54 - anything after CD it's just going to
06:57 - move us to the user home directory and
07:01 - what I mean by that is this so our
07:03 - current user is going to be shown here
07:07 - to the left of the at symbol so whatever
07:09 - your username is it's going to be shown
07:12 - here so that's the current user right
07:14 - typing in CD without anything after it
07:16 - and hitting enter is going to take us to
07:19 - this user's home directory so if we go
07:21 - ahead and select our finder here we
07:23 - should be able to find the current
07:25 - user's home directory and on Mac this
07:29 - home directory is hidden from us by
07:30 - default so we're actually going to
07:33 - change a couple of the settings for our
07:35 - finder here to make the explanation of
07:37 - this terminal more intuitive so let's go
07:40 - ahead and make sure we have our finder
07:44 - open and then in this bar up here we're
07:47 - going to click View and we're going to
07:49 - select show path bar and what that's
07:52 - going to do is it's going to have a bar
07:54 - down here that's going to show us
07:56 - exactly the path to the folder that
07:58 - we're currently in so if we select
08:00 - desktop it'll show the path down here so
08:03 - this is our systems HD and then we're in
08:05 - the users folder and we're in the conton
08:08 - user and we're in this user's desktop
08:12 - now this folder here that has the same
08:14 - name as the user that is the user's home
08:18 - folder so if we go to users here you can
08:21 - even see that it has a house in it this
08:24 - is the home folder for my user here so
08:28 - if we go into that folder we'll see all
08:31 - of these folders within that folder
08:33 - right if we go back to our terminal here
08:38 - and we type in the command LS it's going
08:40 - to list the folders in our current
08:44 - directory or the current folder that
08:46 - we're in and as you can see these
08:48 - folders here are the same as the folders
08:52 - here and you might be confused cuz this
08:54 - Library folder shows here but it doesn't
08:56 - show here but that's just another
08:58 - annoying thing that Mac OS does they
09:00 - hide the library folder from the
09:02 - graphical user interface for some reason
09:04 - there's a way to make it visible but I
09:07 - don't feel like trying to figure out how
09:08 - to do that right now but as you can see
09:11 - in our terminal we're currently in my
09:14 - users home directory so what CD does is
09:18 - it changes the folder or directory that
09:21 - you're in so if we want to move into one
09:24 - of these folders so say for example we
09:27 - want to move into the desktop folder
09:29 - relative to the folder that we're in we
09:32 - can move to the desktop folder so we can
09:35 - just type CD and then desktop since the
09:38 - desktop folder is in our current folder
09:41 - and this will take us to the desktop
09:43 - folder and you might get this warning
09:45 - here just hit okay and then you can see
09:47 - here what folder you're actually in
09:50 - currently and if we LS here we get
09:52 - nothing because in the desktop folder
09:55 - there's nothing right but we can
09:56 - actually create a new folder and call it
09:59 - Tex test and you can see it shows up on
10:01 - our desktop here because this desktop
10:04 - folder is in fact our desktop and now in
10:08 - the terminal since we're in the desktop
10:10 - folder if we list the contents of this
10:12 - folder you'll see that this test folder
10:15 - is now here and we can change directory
10:18 - to test as well and if we LS in test you
10:21 - see that there's nothing because in test
10:23 - there's nothing and if we change
10:25 - directory and we dot do slash it'll move
10:28 - us back one One Directory so now we're
10:31 - back in the desktop folder and if we do
10:33 - it again we're back in our home folder
10:36 - so this Tilda here means home directory
10:39 - so we can actually change to a directory
10:41 - by using the absolute path as well so we
10:44 - can do change directory Tilda which is
10:47 - home SL desktop SL
10:52 - test and this moves us back into this
10:55 - test
10:56 - folder and if we LS here we have nothing
11:00 - but if we add a new test folder inside
11:02 - of here and let's just rename it to
11:05 - avoid
11:06 - confusion we'll say test
11:09 - two if we LS here now we're now in test
11:12 - we now can see the test two folder so
11:15 - these are the basics of navigating the
11:18 - terminal so if we type in CD with
11:20 - nothing after it it's going to take us
11:22 - all the way back to our home folder the
11:25 - Tilda here and as you can see when we
11:27 - list the contents it's the contents of
11:29 - our home folder so both CD and LS are
11:33 - commands that I'm going to use quite
11:36 - frequently throughout this tutorial and
11:38 - these are the basic commands that you
11:40 - can use to navigate the file system of
11:43 - your computer via the terminal
11:46 - essentially all this terminal is is a
11:49 - way to interact and navigate the
11:51 - operating system without making use of
11:54 - the graphical user interface like the
11:56 - operating system doesn't need all of
11:58 - these pretty windows and application
12:01 - icons and everything to work you can
12:04 - navigate and run programs within the
12:07 - operating system entirely through the
12:09 - terminal the graphical user interface
12:12 - which makes everything look pretty and
12:14 - intuitive is actually something that's
12:17 - installed on top of the base operating
12:20 - system but anyways we're going to make
12:22 - heavy use of this terminal and we'll
12:24 - learn more about how to use this
12:26 - terminal throughout the rest of this
12:27 - course so whenever I say to open your
12:30 - terminal or make use of the terminal
12:32 - you're just going to go to this terminal
12:33 - application so for now we can go ahead
12:35 - and close that but we're going to need
12:37 - to revisit that soon once we install go
12:40 - but we can go ahead and move this folder
12:42 - to the trash and we'll move this to
12:45 - trash as well and we can go ahead and
12:47 - close the finder as well so the next
12:50 - thing that we want to do is we want to
12:53 - install the go programming language so
12:56 - with any programming language in order
12:58 - to make use of it we need to have it
13:00 - installed onto our system now some
13:03 - programming languages come pre-installed
13:04 - on your system and some don't and go
13:07 - isn't one that comes pre-installed on
13:09 - Mac so we're going to need to go install
13:12 - it ourselves so we'll open a browser and
13:15 - actually I can't stand Safari so I'm
13:18 - just going to download Chrome really
13:20 - quick so we can just go ahead and open a
13:23 - web browser and you can just type in go
13:28 - programming
13:29 - language and then you can click this
13:32 - first result and you can go ahead and
13:34 - select download now on this page you're
13:36 - going to be presented with all of these
13:39 - different options for downloading so
13:41 - obviously if you're on Windows you would
13:44 - use this one and for Mac users depending
13:46 - on if you're using an apple chip or an
13:48 - Intel chip you would pick one of these
13:50 - so I'm using an apple chip so I'll
13:52 - select arm 64 and Linux you would use
13:55 - this one so I'm going to go ahead and
13:57 - select this one
14:02 - and once the downloads complete I can
14:04 - just use this installer so I'll just hit
14:06 - continue install and put in my password
14:11 - here and once that's finished we can go
14:14 - ahead and close do you want to move go
14:16 - installer to the trash yes and once it's
14:18 - installed you want to go ahead and open
14:20 - up your terminal again and you want to
14:23 - type in
14:24 - go-- version and if everything installed
14:28 - correctly when you type in this go--
14:31 - version command actually I typed in the
14:34 - wrong uh flag for the command it's
14:37 - actually just go version so let's go to
14:40 - the bottom here and I'll just type Go
14:43 - version and in that case you should see
14:46 - the version of go that's installed on
14:48 - your system so another command that we
14:50 - can use is the clear command and it's
14:53 - just going to completely clean up our
14:55 - terminal window and then we can just
14:57 - type go the go command and then press
15:00 - enter and then this is going to tell us
15:03 - all of the sub commands available to the
15:06 - go command and we'll get to what these
15:09 - do when we need them but we don't have
15:11 - to go over all of them right now so I'll
15:14 - go ahead and type clear again to clean
15:16 - things up now just like CD which is to
15:19 - change directory and LS which is to list
15:22 - the contents of the directory go is also
15:24 - its own command and all of these
15:27 - commands have their own doc
15:29 - documentation so for the commands that
15:31 - come pre-installed in the system you can
15:33 - type in man and then the name of the
15:35 - command and it'll show you the
15:37 - documentation for that command so you
15:40 - will see here LS command list directory
15:43 - contents and it gives you a whole bunch
15:45 - of additional information about flags
15:47 - that you can use to modify the command
15:51 - or make the command do different things
15:54 - like for example this a flag include
15:56 - directory entries whose names begin with
15:59 - the dot which are hidden files and
16:01 - directories so for example if I LS here
16:06 - you see that I just get the same
16:08 - contents of my home directory but if I
16:10 - do LS and then do the a flag you see
16:14 - that it now shows these files here that
16:17 - have the dot in front of them so these
16:18 - are like hidden files in your operating
16:20 - system so you don't need to know what
16:22 - all of these hidden files do I'm just
16:24 - trying to teach you what these modifiers
16:27 - do to the command so so same with the CD
16:30 - command we can type in man and then CD
16:34 - and it'll show some documentation for
16:36 - the CD command and we can also do man
16:38 - man because man is the command that
16:40 - we're using to show the documentation
16:43 - for each individual Command right but
16:45 - that in itself is a command as well and
16:47 - you can see the description format and
16:49 - display the online manual pages but
16:52 - you'll notice that if we type man go
16:54 - there's no manual entry for go because
16:57 - we installed go ourself that doesn't
16:59 - come pre-installed on the system so let
17:02 - me clear this so for go what we can do
17:04 - is you can type in go and it'll show you
17:08 - the different flags and sub commands
17:10 - available and If you read here in the
17:13 - documentation for the go command you can
17:15 - also use go help and then the name of
17:17 - the sub command for more information
17:19 - about that command so for example
17:22 - there's go clean which remove object
17:24 - files and cached files so if we type go
17:28 - help clean it'll give us more
17:31 - information about the subcommand clean
17:34 - so you can see here we typed go help
17:36 - clean and it gives more information
17:38 - clean removes object files from package
17:40 - Source directories etc etc now again you
17:43 - don't need to memorize or know any of
17:45 - this stuff this is just me trying to get
17:48 - you familiar with how the terminal works
17:50 - so we just installed go so now we have
17:52 - this new command the go command and
17:55 - we're going to be using this go command
17:57 - throughout the rest of this tutorial so
17:59 - again once you've installed go if you
18:02 - type in Go version you should get the
18:04 - version of go that you installed if that
18:07 - doesn't work then it means that you
18:08 - didn't install Go properly so that's how
18:11 - you install go so the next thing that we
18:13 - need to install is a code editor or an
18:16 - IDE so I can go ahead and close Safari
18:20 - and let's open Chrome again and we're
18:23 - going to go ahead and type in go
18:26 - land and you'll see this jet brains
18:29 - goand you want to select
18:33 - that and we're going to install the free
18:36 - trial version of goand so goand is
18:40 - actually a paid IDE but there's a 30-day
18:43 - free trial that we can use which is more
18:45 - than enough for you to get through this
18:47 - course and you don't need to bother
18:49 - yourself too much with what IDE is just
18:52 - know that this application or this tool
18:55 - is going to be what we use to write and
18:58 - edit our code so you can see images of
19:01 - its usage here like we're basically
19:03 - going to be writing and editing our code
19:06 - inside of this tool so this isn't a very
19:09 - good comparison but just think of this
19:11 - as like the Microsoft Word for code so
19:14 - we're going to go ahead and hit
19:17 - download and then once it's done
19:19 - downloading we can go ahead and just
19:22 - move it to our applications folder
19:30 - and we can open our
19:32 - Launchpad and opened
19:39 - goand we'll select open so for those of
19:43 - you on an M1 Mac you might be asked to
19:46 - install Rosetta and when you hit install
19:50 - you might get this installation failure
19:52 - you can go ahead and hit done and then
19:55 - just type this command into your
19:58 - terminal so the command is software
20:00 - update D- install D Rosetta and then hit
20:04 - enter and then you'll get this I have
20:06 - read and agree to the terms blah blah
20:08 - blah type A and press return to agree so
20:11 - you just type A and hit
20:14 - enter and you should be able to
20:16 - successfully install Rosetta via the
20:19 - terminal this way then we'll just hit
20:21 - clear and once that's installed you can
20:24 - just open Goan now and of course you
20:27 - need to sell your soul then go ahead and
20:33 - continue and once goand opens it's
20:36 - immediately going to open up this second
20:38 - window about licenses and instead of
20:41 - hitting this activate goand we're going
20:43 - to do start trial because we can use a
20:45 - free trial and if you don't have a jet
20:48 - brains account which I assume you don't
20:51 - we're going to hit register and you can
20:53 - go ahead and create a jet brains account
20:55 - so I'll just use my Google account now
20:58 - once once you've registered an account
21:00 - you should be able to go back to goand
21:03 - and log into jet brain's account but as
21:06 - you can see I've already registered my
21:09 - account and I've already signed up for a
21:11 - free trial but for you to do the same
21:13 - you're just going to want to log in to
21:15 - Jet brain's account and then once you
21:17 - log in successfully you should see this
21:19 - authorization successful screen and then
21:22 - you should be able to go back to the IDE
21:24 - and then there's a button here that says
21:27 - start trial and you should be able to
21:29 - just select that button to start your
21:31 - trial and after that you should get this
21:33 - message that tells you how long your
21:35 - subscription will be active and then you
21:37 - can just hit continue and at that point
21:40 - you'll be free to use the goand IDE for
21:44 - 30 days now before we get started we
21:47 - actually need to do one more thing so
21:50 - you want to go ahead and open up your
21:52 - terminal again and we want to type in CD
21:56 - to make sure you're in your home
21:58 - directory remember the Tilda means that
22:00 - you're in the home directory and let's
22:02 - go ahead and open our finder as well
22:04 - just so we can see what we're doing and
22:06 - we'll go to the home
22:09 - folder so remember home directory and
22:12 - home folder they're synonymous they're
22:13 - the same thing so if we list the
22:16 - contents here it's going to be the same
22:19 - as as the contents here so now we're
22:22 - going to introduce a new command called
22:25 - mkdir and this command stands for make
22:28 - directory so if we type in the man
22:31 - command and then do
22:33 - mkdir we can see that this command makes
22:36 - directories and a directory is just a
22:38 - folder right and I forgot to mention
22:40 - this before but to leave this manual
22:43 - page once you use that man command you
22:46 - can just type Q so in our home directory
22:50 - or our home folder we want to create
22:53 - another folder using this
22:55 - mkdir command and we'll call that folder
22:59 - go and then we'll just hit enter and you
23:01 - can see now that the go folder appears
23:04 - in our home folder and also if we LS
23:07 - here it's here as well cuz they're both
23:09 - the same place so now we want to change
23:12 - directory into the go folder and let's
23:14 - clear and here we can just open the go
23:17 - folder as well and we want to make three
23:19 - more folders
23:21 - mkdir the first one we're going to call
23:23 - PKG the second one we're going to call
23:27 - SRC and the third one we're going to
23:29 - call Bin and you don't need to concern
23:33 - yourself with what these folders are for
23:35 - right now this it's not important just
23:37 - know that the source folder is where
23:39 - we're going to put our project so the
23:42 - code that we're writing is going to go
23:44 - in this Source folder but actually this
23:48 - Source folder is supposed to contain all
23:50 - of our projects so let's say for example
23:53 - we had let's change directory to Source
23:56 - let's say for example we had three
23:57 - separate projects
23:59 - we would have makeer project 1 makeer
24:03 - Project 2 makeer project 3 so the source
24:07 - folder whenever we start a new project
24:09 - in go we're going to put a folder for
24:12 - that project inside of this Source
24:15 - folder so in our case we're just going
24:18 - to make a folder called go
24:22 - tutorial and in this folder is where
24:25 - we're going to put all of our code which
24:29 - is going to be the code that's going to
24:31 - be the backend for that front-end user
24:35 - interface that I showed you at the
24:37 - beginning of this video the one where
24:39 - the user or the customer can purchase a
24:42 - product so remember we're creating the
24:44 - backend for that user interface and
24:47 - it'll become more clear what that means
24:50 - as we continue throughout this course so
24:53 - we can clear this and actually we can
24:56 - just leave these example projects there
24:58 - just so you can see what I mean by this
25:00 - Source directory being where we
25:03 - centralize all of our projects for go so
25:06 - now we can close the finder and we can
25:09 - close the terminal and what we're going
25:11 - to do is in goand we're going to start a
25:14 - new project and remember this new
25:17 - project is in our home folder in the go
25:21 - Source directory and it seems goand
25:24 - already knows that except for the name
25:27 - of the project is wrong it's it's not
25:28 - awesome project so we'll go ahead and
25:30 - hit that and you can see our project in
25:33 - the source directory here go tutorial so
25:37 - the location of our project is in users
25:40 - your username the go folder that we just
25:43 - created The Source folder that we just
25:45 - created the Cod tutorial folder that we
25:48 - just created and we can go ahead and
25:49 - create this project now in the beginning
25:52 - you're going to have to wait for it to
25:54 - load up some things but while it's
25:57 - loading I just wanted explain something
25:59 - these idees or these code editors
26:02 - they're they're very daunting when you
26:04 - first look at them but honestly there's
26:07 - like only 30% of the stuff in this code
26:10 - editor we're going to be using there's
26:12 - so many tools and features and like
26:14 - quality of life stuff in these idees
26:17 - like a lot of the stuff you might not
26:19 - even use so you don't need to worry
26:20 - about how daunting it looks or if it
26:22 - looks overwhelming in the beginning you
26:24 - just need to focus on a couple of key
26:26 - things so the main main thing we want to
26:29 - focus on is this project tab here so
26:33 - this is our current project it's the
26:35 - tree structure it's like the folder
26:37 - structure of our project so right now
26:41 - this is the project folder right if we
26:43 - expand this it'll show the file that's
26:46 - inside of the project folder and
26:48 - actually this file was just created by
26:51 - the IDE so I'll show you what I mean by
26:54 - that in a second but first I need to
26:56 - explain to you another cool thing that's
26:58 - available in this codee editor or IDE
27:01 - you can actually use the terminal from
27:04 - here so if we hit this terminal tab
27:07 - it'll open a terminal here same as the
27:09 - one that we've been using but now it's
27:11 - just integrated with the IDE so if we LS
27:15 - here we see this go mod file and we can
27:18 - also CD and it'll take us back to our
27:22 - home directory and we can LS and we see
27:26 - all of the folders in our home directory
27:28 - same as before so our go
27:31 - directory is where our source folder is
27:35 - and in our source folder we have our go
27:38 - tutorial project and if we LS go
27:42 - tutorial we see that this go mod file is
27:45 - now inside of this go tutorial project
27:48 - folder and that's because the IDE or the
27:50 - code editor automatically created this
27:52 - file for US you don't need to know what
27:54 - this file is for right now so don't even
27:56 - think about it don't worry about it at
27:58 - all but yeah this project tab here is
28:01 - basically going to show us the structure
28:04 - the tree structure containing all of the
28:06 - files so we could even for example
28:09 - create a new go file here and for now
28:12 - we'll just name it main.go and you can
28:15 - even do simple application so it'll
28:18 - initialize the file with some code but
28:21 - it's just like the initial code for
28:24 - creating a application so we can just go
28:28 - ahead and let it do simple
28:32 - application so now you can see in our go
28:36 - tutorial folder we have this main.go
28:39 - file and it's a simple application so it
28:43 - has some code in it already and you're
28:45 - not going to know what this code means
28:47 - yet but I'm going to explain all of this
28:50 - in due time so if we clear our terminal
28:53 - here and we change directory to go
28:56 - tutorial and we LS again you you can see
28:58 - we now have this main.go file and this
29:01 - go mod file same as what's represented
29:04 - here in this tree structure now that is
29:07 - the setup now we're going to start
29:10 - getting into the fun part which is
29:11 - actually writing the code for our
29:14 - application okay for starters let's set
29:16 - up the front end for the back end that
29:18 - we're going to build so you can go ahead
29:21 - and open up your terminal application
29:24 - here and once you have that opened up
29:26 - you can go ahead and open up a web
29:27 - browser browser and head over to my
29:30 - GitHub page I'll have it linked in the
29:32 - description and you want to select this
29:34 - repositories Tab and here you'll see a
29:37 - repository called Go for beginners front
29:40 - end and what you want to do is Select
29:42 - that repository and on this page you'll
29:45 - see that there's the instructions for
29:48 - how to set up the front end for this
29:51 - tutorial so step one we're going to
29:53 - build the client app and The Client app
29:56 - is just the client for for our backend
29:59 - so it's just the front end for our
30:01 - backend and then it gives the
30:03 - instructions on how to run the client
30:05 - app or run the front-end app and also
30:08 - gives the URL where you can access that
30:12 - front end that I showed you earlier so
30:14 - what we want to do is we want to go up
30:17 - here to the top where it says code in
30:20 - green and you want to click that and you
30:22 - just want to copy this here and once
30:25 - you've copied that you want to go back
30:27 - to your terminal and just type in get
30:30 - clone and then paste in that URL that
30:33 - you just copied and from there you
30:35 - should be able to just hit enter and it
30:38 - should clone that repository or that
30:41 - front-end application to your home
30:44 - directory because currently we are in
30:47 - our home directory so if we LS here we
30:51 - can see that this go for beginners
30:53 - frontend folder has been added to our
30:55 - home directory so now we can just change
30:58 - directory to that go for beginners
31:02 - folder and then we can LS again and now
31:05 - you can see the contents of the actual
31:09 - repository here that you
31:12 - cloned this is these are the contents so
31:15 - we have a public folder a source folder
31:17 - and some
31:18 - files those now exist on your local
31:21 - machine in this go for beginners
31:24 - frontend folder in your users home
31:26 - directory so so once again if we go
31:28 - ahead and hit the finder here and we
31:31 - access our home directory and then we
31:34 - access this go for beginners front-end
31:37 - folder these are the contents that you
31:39 - just copied to your system and these are
31:42 - the files that comprise our front
31:45 - front-end application now this front-end
31:47 - application isn't going to be the focus
31:50 - of this course so basically the front
31:53 - end application is already pre-built so
31:56 - we're not actually going to build this
31:57 - front end we're only going to build the
31:59 - back end that the front end needs to
32:02 - communicate with because this is a go
32:04 - tutorial so we're building the backend
32:06 - in go but for the purposes of actually
32:09 - integrating a front end with the back
32:11 - end that we build I pre-built this front
32:14 - end that we can use to interface with
32:17 - our backend essentially so since it's
32:19 - already pre-built we should actually be
32:21 - able to just run this front end from our
32:24 - machine right now as it is so we can go
32:27 - ahead and close close this and in our
32:29 - terminal we can clear and remember we're
32:31 - still in this go for beginners front end
32:35 - folder now in order to run this
32:37 - front-end application we're actually
32:39 - going to need to install a couple of
32:42 - things a couple of dependencies that are
32:44 - necessary to run this front end because
32:47 - there are some commands that we need to
32:49 - be able to install to run this but as I
32:52 - go through this just remember that these
32:54 - commands that we need to use and these
32:57 - dependencies that we need to install you
32:59 - don't need to have more than a basic
33:01 - understanding of what we're doing you
33:02 - don't need to understand what each
33:03 - command is or what dependencies are what
33:06 - you only need to understand that we're
33:08 - basically installing some things that we
33:10 - need in order to run our front end and
33:13 - basically from there everything is
33:16 - already pre-built so let's just go ahead
33:18 - and attempt to follow the instructions
33:21 - so these instructions here let's attempt
33:23 - to follow them so it's saying that we
33:25 - need to run this command in order to
33:28 - build this app the front end app so we
33:31 - can just copy
33:33 - this and paste it into our terminal and
33:38 - hit enter but as you can see we get
33:41 - command not found mpm and that's because
33:45 - we don't have node installed now node is
33:48 - just one of the dependencies we need to
33:50 - run this front-end application so
33:52 - actually if we just copy
33:56 - this and head over to Google and paste
34:00 - that in there and press enter you can
34:02 - see this stack Overflow result will tell
34:05 - us like if it's not there install
34:08 - node.js again but basically what I'm
34:11 - trying to say is the reason I pasted
34:12 - that into Google is just to kind of give
34:14 - you an idea of how you should handle
34:16 - situations where you get stuck in the
34:18 - future but for now of course I'm going
34:20 - to walk you through all of this but
34:22 - that's just kind of a hint towards the
34:24 - future but yeah essentially we need to
34:27 - inst install nodejs so install nodejs
34:32 - now again you don't need to know what
34:33 - nodejs is if you're beginner you just
34:36 - need to know that we need to install
34:37 - this in order to run the front end so
34:40 - let's go ahead and select this download
34:43 - nodejs and I'm going to select the Mac
34:46 - OS installer and once I have the
34:49 - installer I can just select this and
34:52 - using this installer we can go ahead and
34:55 - install node.js
34:58 - and you will need to put in your
35:01 - password and from there the installation
35:04 - should be self-explanatory so we can go
35:06 - ahead and close that and yeah we'll go
35:08 - ahead and move that to trash and now we
35:11 - should be able to do this mpm install
35:24 - command now you'll see a lot of noise
35:26 - while this MP install command is running
35:29 - but don't worry about it as long as you
35:31 - don't get an error things should be fine
35:33 - so let's actually just clear this up to
35:36 - make it look cleaner and we can go back
35:38 - up here and close this node.js download
35:41 - and now we did this first step so the
35:44 - second step is to run the client app so
35:46 - she we should be able to just use this
35:49 - mpm start command so we can copy
35:53 - that and paste it and hit enter
35:58 - now you might get something like this
35:59 - you can just go ahead and allow it and
36:02 - here we're getting the site can't be
36:04 - reached so let's go ahead and check our
36:06 - terminal for the the issue now as you
36:08 - can see we have an error here that's not
36:11 - allowing us to actually access our front
36:14 - end or run the front end and I actually
36:17 - already know what the solution to this
36:19 - error is so I'll just show you what it
36:21 - is so what we're going to do is we're
36:23 - going to clear this and let's just
36:26 - change directory back to our home
36:29 - directory and here you should type LS L
36:34 - and if you don't see a file here that
36:36 - says zshrc then you should create that
36:41 - file so I don't have that file so I'm
36:43 - going to create it and you can create it
36:46 - by typing in the command touch and then
36:49 - you can just put zshrc and then hit
36:53 - enter and if you
36:55 - lsla doz
36:58 - shrc you'll see that we now have this
37:02 - file that exists in our home directory
37:06 - so now I just want you to type in the
37:08 - command cat and after cat you're going
37:11 - to type quote export
37:16 - node options
37:19 - equals dash dash open
37:24 - SSL
37:25 - Legacy provider and then end quote now
37:29 - here you don't need to know what this is
37:31 - doing this isn't a part of the tutorial
37:33 - at all this is just the initial setup
37:36 - that we need to do so after you type
37:38 - that you want to put an arrow and then
37:41 - space and let me make this wider so you
37:44 - don't get confused by it looking like
37:46 - it's on a new line it's on the same line
37:48 - then you put
37:50 - zshrc and then there you should press
37:53 - enter and actually I just had a complete
37:56 - brain glitch we're not using cat command
37:58 - we should be using the echo command so
38:01 - we're going to type in the exact same
38:03 - thing that we just typed but instead of
38:06 - cat we're going to type in the word Echo
38:08 - and then press enter and to confirm that
38:11 - this worked correctly if you type in
38:15 - cat. zshrc
38:18 - it should show this export that we just
38:22 - wrote in this initial Echo command and
38:26 - once you do that you should be able to
38:28 - just type
38:30 - source. zshrc and then hit enter and
38:34 - lastly you want to type in
38:37 - EnV pipe
38:40 - grep node and then hit enter and you
38:44 - should see this node options equals open
38:47 - SSL Legacy provider now I know that was
38:51 - a lot but you don't need to understand
38:53 - any of what we just did this is just
38:55 - preparation for being able to run the
38:57 - front FR in application so if you can
38:59 - just follow the instructions as I
39:01 - presented them then you should be fine
39:04 - now we should be able to clear here and
39:06 - we want to change directory back to the
39:09 - Go for beginners frontend directory and
39:13 - once again we should try step two of the
39:16 - instruction so this one here mpm
39:20 - start and this should work now
39:31 - so now as you can see we have our
39:33 - frontend running as expected so if we go
39:36 - ahead and enlarge this you can see we
39:39 - have our products here and we can select
39:41 - a product so we should be able to input
39:45 - a address here and from there we should
39:48 - be able to hit next and here at the
39:51 - point where we reached the checkout we
39:53 - shouldn't be able to do anything yet
39:55 - because we haven't implemented the
39:56 - backend that needs to be called in order
39:59 - for a customer to check out and make the
40:01 - payment but if you're able to reach this
40:03 - point then you've successfully set up
40:06 - your front end for the back end that
40:08 - we're going to build using the go
40:10 - programming language so for now we can
40:12 - just close this and we can close this as
40:15 - well and here the front end application
40:18 - is going to be running so you just want
40:20 - to press contrl C and that will stop it
40:24 - from running and you'll get back to the
40:26 - command prompt and you can type in clear
40:29 - and yeah we've set up the front end so
40:32 - now it's time to start building the back
40:34 - end for the front end now let's take a
40:37 - couple of minutes to actually explain
40:39 - what we're building here up until this
40:42 - point you'll notice that there are some
40:43 - key wordss that I've been using that you
40:45 - may or may not understand yet and those
40:48 - words are server graphical user
40:51 - interface front end and backend now a
40:54 - server we can just think of as a
40:56 - physical computer computer and we'll get
40:58 - back to that later on in the course a
41:01 - graphical user interface or guei is the
41:04 - interface that a user uses to interact
41:07 - with an application or web application
41:10 - so if we think of the word interface in
41:12 - a general sense it's really just a
41:14 - device or system that two unrelated
41:17 - entities can use to interact for example
41:20 - two people from entirely different
41:22 - countries can communicate or interact
41:25 - with one another via a shared language
41:28 - that language serves as the interface
41:30 - between the two people similarly a human
41:34 - can interact with a computer via the
41:36 - buttons and navigation Tools in an
41:39 - application or on a web page those
41:42 - graphical buttons and navigation tools
41:44 - serve as the interface between a person
41:47 - and a computer more specifically the
41:50 - graphical user interface now the
41:53 - graphical user interface is the part of
41:56 - the application that the the user can
41:57 - see this part of the application is
42:00 - called the front end but in the deepest
42:03 - and darkest depths of the application in
42:06 - a place where no user has gone before
42:09 - there exists the core functionality of
42:11 - the application which is not visible to
42:14 - the user this is called the backend and
42:17 - all of the code that comprises this back
42:19 - end generally exists on a server so that
42:23 - means that the front end needs to be
42:25 - able to communicate or interface with
42:28 - the backend server right so our backend
42:31 - needs to provide an interface for the
42:33 - front-end application to use so that
42:36 - these two entities can communicate with
42:38 - one another now so far we've learned how
42:41 - the two entities human and computer can
42:45 - interact and that's via a graphical user
42:48 - interface right because a human can
42:51 - easily navigate a GUI using buttons and
42:53 - text inputs Etc and those interactions
42:56 - are relate to the computer so we
42:59 - understand how a human interfaces with a
43:01 - computer but how does a computer
43:04 - interface with another computer well a
43:07 - computer interacts with a computer by
43:09 - making use of an interface as well this
43:12 - interface is called an application
43:15 - programming interface and is more
43:18 - commonly referred to as an API now an
43:21 - API is a type of software interface and
43:24 - it just so happens to be what we're
43:26 - going to be writing the code for or
43:29 - building in this course so we'll be
43:31 - creating the interface that the front
43:33 - end will use to interact with our
43:35 - backend and through that interface the
43:38 - front end will be able to trigger
43:40 - certain functionality related to a
43:43 - customer purchasing a product from an
43:45 - online
43:48 - store okay so after everything we've
43:51 - learned up until this point you should
43:53 - have a firm understanding of what part
43:55 - of the application were built building
43:57 - here so let's go ahead and open goand
44:00 - and you'll recall that we made this
44:02 - main.go file in our go tutorial
44:06 - directory when we were going over how
44:09 - this IDE works and if you haven't
44:11 - created that file you can just
44:13 - rightclick on the go tutorial folder and
44:15 - then go to new and then hit go file and
44:20 - here you're just going to name the file
44:23 - Main and I'm pretty sure it should
44:25 - automatically add the file extension .go
44:28 - and remember you want to select simple
44:29 - application when you create the file so
44:32 - it'll automatically populate the file
44:34 - with this initial code so yeah with
44:36 - everything that we've learned up until
44:38 - this point you should understand that
44:40 - the part of the application that we're
44:42 - building is the code the backend code
44:45 - that's going to run on the backend
44:47 - server and that code is going to be the
44:50 - application programming interface or API
44:53 - that the frontend is going to use to
44:56 - communicate with the backend or
44:58 - interface with the backend and that
45:00 - project or that server code or that API
45:03 - code is all going to be contained within
45:06 - this project go tutorial so all of the
45:09 - code that we're writing for this backend
45:11 - is going to be in this go tutorial
45:13 - folder which is the project folder at go
45:16 - Source go tutorial so now we can start
45:19 - getting into how a go program actually
45:22 - works like what is a go program what is
45:25 - a go application essentially the
45:28 - application is this file this main.go
45:31 - file and the code contained within this
45:34 - file is the code for the application so
45:36 - essentially what we're going to be able
45:38 - to do is we're going to be able to write
45:40 - some code here and we're going to be
45:42 - able to run this file and when we run
45:44 - the file the code that we have written
45:47 - inside of the file is going to be
45:48 - executed so let me just show you what I
45:51 - mean by that and you don't need to
45:53 - understand what this package main Funk
45:55 - main means yet so for now let me just
45:57 - show you something so if we write in
46:00 - these brackets this
46:03 - fmt print line and we put inside of it
46:08 - hello world we've now written some code
46:11 - inside of this main.go file so if we run
46:15 - this file and don't worry about this
46:17 - this was automatically added by goand
46:20 - I'll explain to you what this import
46:21 - format does as well but first I just
46:24 - want to show you something so this
46:26 - main.go file if we run this file it
46:29 - should print hello world like print
46:32 - means it's just going to print something
46:35 - to the terminal so that's the function
46:37 - of this print line it's just going to
46:39 - print something to the terminal and what
46:41 - we want to print we can put it inside of
46:44 - these parentheses so if we wanted to
46:45 - print hello world we just type hello
46:48 - world inside of these
46:50 - parentheses and when we run this file
46:53 - it's going to print hello world so if we
46:56 - open our terminal and we can make this a
46:58 - little bit larger if we LS here you see
47:01 - our main.go file is here because we're
47:04 - in the go tutorial folder so we're in
47:07 - this folder right so we can see our
47:09 - main.go file and if you recall we
47:11 - installed the go command the go command
47:15 - is what we installed and if you recall
47:16 - further the go command has its own sub
47:19 - commands so if we go ahead and enlarge
47:22 - this for a second and we just type go
47:25 - and hit enter and we scroll up
47:30 - here you'll see that go has these
47:35 - commands so there's this list of
47:37 - commands here right and one of these
47:39 - commands is called run and it says here
47:42 - that it will compile and run a go
47:44 - program now right now you don't need to
47:46 - know what compile means but run a go
47:48 - program is pretty self-explanatory it's
47:51 - going to run the program and if we
47:54 - scroll up a little bit here we can see
47:56 - how to to use these sub commands so the
47:58 - usage is here so first we'll type go
48:02 - which is the go command that we
48:03 - installed and then whatever sub command
48:06 - that we want to use and then arguments
48:08 - now in this case we're going to type go
48:11 - and then the command the sub command
48:13 - that we want to use from this list is
48:14 - going to be run and the argument is
48:17 - going to be the go file that we want to
48:19 - run so if we go back to the bottom here
48:22 - and let's just clear so we have some
48:24 - space and we can LS here so you can see
48:26 - we have our main.go file here with the
48:29 - code here that's going to print hello
48:32 - world right so if we type go run and
48:35 - then the file name main.go and then we
48:38 - hit enter you see that hello world gets
48:40 - printed to the terminal screen because
48:43 - that's what function we wrote here
48:45 - that's that's what we're doing in the
48:47 - code within this file so this G run
48:50 - main.go is equivalent to like when you
48:54 - run an application on your operating
48:56 - system like if you click one of the
48:58 - applications icons it'll start up the
49:00 - application right that's the same thing
49:03 - G run is doing like you can just imagine
49:05 - this main.go file is one of these
49:08 - applications but there's just no icon
49:10 - for it and when we type go run in the
49:13 - name of the file we're essentially
49:15 - clicking the application and starting
49:17 - the application so that's like a really
49:19 - simple explanation for what's happening
49:21 - here so our main.go file is the
49:24 - application right and we could actually
49:26 - name this this whatever we want we can
49:28 - go in here and we can hit refactor
49:30 - rename and we can name this hello. go
49:35 - and refactor it and now here we would
49:37 - type G run hello. go because that's the
49:41 - name of the file now right if we LS here
49:44 - we renamed the file to hello. go so we
49:46 - can go run hello. go and it will still
49:49 - be the same code because we didn't
49:51 - change the code here but if we change
49:53 - the code here to
49:57 - hello my friend and then we go run
50:00 - hello. go you see that what prints to
50:04 - the screen changes to hello my friend so
50:07 - that's the basics of how an application
50:11 - in go actually works we essentially
50:14 - write the code inside of a file with the
50:19 - extension. go and we can run that file
50:22 - to actually run the application now
50:24 - there are some other things in here that
50:26 - you might be a bit confused about so let
50:29 - me explain so first of all we have this
50:31 - function here this main this funk main
50:34 - this is called a function so if you look
50:36 - at this line here that says Funk main
50:39 - this is the name of the function and
50:42 - everything in between these brackets are
50:45 - the instructions for that function so we
50:47 - can even do this multiple times so we
50:50 - can even print four times within this
50:53 - one function so it means that whenever
50:55 - we run this function that's called main
50:58 - it's going to print this to the screen
51:00 - four times so if we hit the terminal
51:03 - again and we do go run hello. go you see
51:07 - that it prints four times right so this
51:10 - is a function so we could actually go
51:13 - ahead and create another function if we
51:15 - wanted to we can do Funk and then we can
51:17 - name the function whatever we want so
51:20 - I'll just name it my function and any
51:23 - instructions inside of this function
51:25 - would be executed if I were to run this
51:28 - function so what do I mean by run this
51:30 - function so I can actually take this and
51:34 - cut it from my main function and I can
51:37 - just put it in my function so now these
51:40 - instructions are grouped into my
51:44 - function and actually let's just change
51:46 - this to step one step two step three
51:51 - step four and I just did that because it
51:55 - shows you that when you run a function
51:58 - the instructions are ran in order so
52:01 - this one step one will be printed first
52:04 - step two will be printed second step
52:06 - three and four Etc so this function is
52:09 - just a function is just a a set of
52:12 - instructions it's just grouping together
52:15 - instructions so basically now our Funk
52:17 - main from our Funk main we can actually
52:20 - run another function so from inside of a
52:24 - function we can call or run another
52:26 - function so we can actually do my
52:29 - function and this is how you actually
52:32 - run a function or invoke a function so
52:35 - you put the name of the function and
52:36 - then you put these parentheses here to
52:39 - invoke the function so when we actually
52:42 - run this main function it's going to
52:46 - call this function which is going to run
52:48 - all of the steps in here so if we open
52:51 - up the terminal and we do go run hello.
52:54 - go again you see that it prints out step
52:57 - one step two step three step four and
53:00 - what just happened here is a key thing
53:03 - that you need to understand so whenever
53:06 - you run the hello. go file this is
53:09 - automatically going to call this main
53:11 - function it's not calling my function my
53:14 - function is being called from the main
53:17 - function so if we don't run this main
53:19 - function my function won't even be
53:21 - called so to show that let me remove
53:25 - this invocation or this call to my
53:28 - function from the main function so now
53:30 - when we run the file nothing's going to
53:32 - get printed to the screen because this
53:34 - my function isn't getting called from
53:37 - the main function and when you run the
53:39 - file only the main function is called if
53:42 - we run this file my function won't be
53:44 - called automatically only the main
53:47 - function will be called so if we go
53:49 - ahead and clear and we go
53:54 - run hello. go you see nothing gets
53:57 - printed and that's because we didn't
53:59 - call my function in main now this brings
54:03 - me to the important point this main
54:06 - function we can't change the name of
54:08 - this function like this function isn't
54:10 - our function to change this is the entry
54:13 - point to the application so every go
54:15 - Application needs to have this main
54:18 - function it's essentially you're telling
54:21 - go where the application instructions
54:24 - start so the entry point is the main
54:26 - function so regardless of what you name
54:29 - the file you have to have the main
54:31 - function inside of the file if we were
54:35 - to delete this and try and run the file
54:37 - with just my function in it it wouldn't
54:41 - work so when we try to run it as you can
54:44 - see it says function main is Undeclared
54:47 - in the main package which brings me to
54:50 - the other thing that's important about
54:51 - go main the main package every go
54:55 - Application has to have a main package
54:58 - now I know you don't know what a package
54:59 - means so let me explain so we can go
55:02 - ahead and undo that deletion now at the
55:06 - top of the file you see package main so
55:09 - this is the starting point of any go
55:11 - Application you need the main package on
55:13 - the first line of the file and to
55:16 - explain what a package is I think it's
55:18 - best for us to just create our own
55:21 - package so you can see how it works so
55:24 - let's see if we can do that so so if we
55:27 - go ahead and create another folder
55:29 - inside of our go tutorial folder so
55:32 - we'll do
55:33 - new directory and we'll just name it
55:37 - test and then we hit enter we now have
55:39 - another folder inside of our project
55:42 - directory called test and in here we can
55:45 - create a go file and just call it test
55:48 - now the IDE is trying to create a main
55:51 - package for this folder but that's
55:52 - actually incorrect you can only have one
55:54 - main package in a go program so
55:57 - essentially a package is just like a
55:59 - package of code so like a package of
56:02 - functions that can be used if that
56:05 - package is imported so let me explain
56:07 - what I mean so let's say that we have
56:10 - this package here called test all of the
56:12 - files that we create inside of this test
56:15 - package will contain the code and all of
56:17 - that code comprises the test package so
56:20 - let's go to our hello. go file and let's
56:23 - just take this my function out of it let
56:26 - copy
56:27 - it and then let's go put it into this
56:31 - test
56:32 - file and we also need to delete this
56:37 - main function and we need to change the
56:39 - package name to test and actually let's
56:43 - name this test
56:46 - package and we'll just refactor and
56:49 - rename this one to test package as
56:54 - well so this is a package here right we
56:57 - created a package so this folder is our
57:00 - package right and there's some code in
57:01 - this package so we have a function in
57:04 - this package and the function in this
57:05 - package will just print step one step
57:07 - two step three step four now in hello go
57:11 - we can import that package so we can
57:14 - type in
57:15 - import and quotes and remember the name
57:19 - of our project is go tutorial so that
57:21 - means that go tutorial is part of the
57:25 - path to the pack package so you can see
57:27 - here it'll automatically show up as go
57:30 - tutorial SL test package as the location
57:33 - of this package so if we select that
57:35 - we're now importing test package so if
57:39 - we go here in our main function we can
57:41 - type test package and then we can do my
57:45 - function but there's a problem here as
57:48 - well so if we hover over my function you
57:50 - can see down here on the bottom left of
57:53 - the screen it says unexported function
57:56 - my function usage so basically it's
57:58 - saying we're trying to use this function
58:01 - from test package that we created here
58:04 - we're trying to use this function but we
58:06 - didn't export it and exporting it just
58:09 - means that from within our package we
58:12 - allow other packages to use our function
58:15 - now in go the way that you allow other
58:19 - packages to use a function is very
58:20 - simple you just make sure the name of
58:22 - the function has a capital letter for
58:25 - the first letter so if we change my
58:28 - function to capital M my function the
58:31 - function is now being exported like now
58:34 - other packages can use test packages my
58:38 - function function so if we go back to
58:40 - hello. go and we change this to what
58:43 - it's actually called because right now
58:45 - it's not working because we changed the
58:47 - name of the function right so now we're
58:49 - trying to call a function called my
58:51 - function with a small M from text from
58:54 - test package but there is no function
58:56 - called my function with a small m in the
58:59 - test package because it's Big M so
59:01 - that's something important to note like
59:04 - case sensitivity is very important in
59:07 - programming so if we go here and we
59:09 - change this to capital M my function now
59:14 - we have no more errors so here we're
59:17 - importing this test package that we
59:20 - created and since we imported it we can
59:23 - do test package that we can do the name
59:25 - of the package dot the name of the
59:27 - function in the package and if we go
59:29 - ahead and run this if we go to the
59:32 - terminal and let's clear this and let's
59:34 - LS again so you can see we have our test
59:36 - package here right and we still have our
59:39 - hello. go file if we do go run hello. go
59:44 - you see it prints 1 2 3 4 because we're
59:47 - calling test packages function from our
59:51 - main function now you might be wondering
59:53 - like what what is all what's the point
59:55 - of all this confusion with these
59:56 - packages but it's really important that
59:59 - we organize our code so a very simple
60:01 - explanation this is the only explanation
60:03 - you need right now for the reasoning
60:06 - behind like using packages is we want to
60:09 - segregate specific types of
60:11 - functionality for example maybe we might
60:14 - create a package that's only responsible
60:16 - for like arithmetic and then we create a
60:18 - separate package that's only responsible
60:21 - for something completely unrelated to
60:23 - arithmetic like we just want to keep
60:25 - everything organize so that's a very
60:27 - simple explanation of why we might want
60:29 - to use packages for now that's all you
60:31 - need so back to our hello. go file so I
60:35 - said before hello. go is the entry point
60:38 - to our application and the entry point
60:41 - means that it's the starting point of
60:43 - the application so this is the start of
60:46 - our application so anything that we put
60:49 - in this main function it's going to
60:52 - comprise all of the steps in our
60:54 - application so maybe we want to call my
60:56 - function many times in our main function
60:59 - just think of the main function as the
61:02 - parent function to any other code that
61:05 - gets ran in your application and import
61:08 - is the keyword that we use to import
61:12 - another package now circling all the way
61:14 - back to what package main is package
61:17 - main is the entrypoint package to the
61:19 - application so you can really just think
61:21 - of it like this the same way that we're
61:24 - importing test package
61:26 - and running it here the same way that
61:28 - we're doing that you can imagine that
61:31 - when we run this gun hello. go go go the
61:37 - go programming language under the hood
61:39 - it's importing our main package and it's
61:42 - calling our main function and that's how
61:45 - it's executing our application that's
61:48 - how it's running our application so
61:50 - that's what the main package is and the
61:51 - main function is the entry point the
61:53 - start of our code the start of the
61:55 - application
61:56 - I hope that makes sense cuz that's very
61:58 - important for you to understand so at
62:00 - this point you should have an
62:01 - understanding of what a function is so
62:04 - remember this is a function and the
62:06 - keyword for a function is Funk when we
62:08 - want to create a function we'll type in
62:10 - Funk and then the name of our function
62:12 - and if we want to create a function
62:14 - that's public for other packages to use
62:17 - it has to have a capital letter at the
62:19 - beginning of the function name and if we
62:21 - want the function to be private like we
62:23 - only want it to be accessible from
62:26 - inside of our package we make the first
62:29 - letter
62:30 - lowercase so this is my private function
62:35 - so nobody can use this function outside
62:37 - of our package so if we go to hello. go
62:41 - and let's delete that and we do test
62:45 - package. my
62:49 - private function you see that we get the
62:52 - error unexported function my private
62:54 - function meaning we can't use this
62:56 - function from the main
62:59 - package so yeah that is what a function
63:04 - is and that is what the main package and
63:08 - the main function is those things are
63:10 - very important to understand now there's
63:12 - one more thing I want to explain as well
63:15 - so let me just delete this because we
63:16 - can't do that so if we go back to this
63:19 - test file you see here that we're
63:22 - importing this fmt package now this
63:26 - package we didn't create this package
63:28 - right and you might be wondering where
63:30 - this package came from and we're using
63:31 - this package here see the package name
63:34 - is fmt and we're calling this package's
63:37 - function called print line same way that
63:40 - we were calling this test package is my
63:43 - function we're doing the exact same
63:46 - thing here we're calling format the
63:48 - package format we're calling its
63:50 - function that's called print line and
63:52 - you can see it's a capital P because
63:54 - it's a exported function it's it's
63:56 - usable by other packages but you're
63:58 - probably wondering where format came
64:00 - from and format is actually part of Go's
64:04 - standard Library so go has a standard
64:07 - library of many useful packages that it
64:10 - has functions for common things that you
64:12 - do in the programming world like
64:14 - printing something to the terminal is a
64:17 - very common thing that we do in the
64:19 - programming world so it's a function
64:22 - available in go one of Go's packages
64:26 - and that package is part of Go's
64:27 - standard Library so there's many
64:30 - packages in go standard Library we don't
64:32 - need to memorize any of them or know any
64:34 - of them until we need to use them so
64:37 - right now it's okay to only know about
64:39 - the format package like we used it right
64:41 - so you know about it but you don't need
64:43 - to sit around and try and memorize
64:45 - things that you're not using whenever
64:46 - you're trying to find some functionality
64:48 - you'll end up needing to search for if
64:50 - it's available in GH standard Library
64:52 - anyway so there's no no no use in trying
64:55 - to memorize all of this stuff just know
64:57 - that when we're importing format here
64:59 - we're not importing our own package that
65:01 - we made we're importing one of Go's
65:03 - package that they made now there's
65:05 - another thing that we need to go over as
65:07 - well as part of the basics here so as
65:10 - you can see here we're able to pass in
65:12 - an argument to this print function so
65:14 - basically it prints whatever we ask it
65:17 - to print and that's because we're using
65:19 - and we're passing an argument to the
65:21 - function which brings me to the next
65:24 - thing that we need to learn about and
65:26 - that is function parameters or arguments
65:29 - so it's basically just a way to add more
65:33 - functionality or customization to a
65:35 - function like for example right now when
65:38 - we call my function we have no control
65:41 - over what gets printed here right like
65:43 - we have no control like it's always
65:45 - going to print step one step two step
65:47 - three step four we can't control that
65:49 - but the creator of the function can
65:51 - actually allow the person that calls the
65:53 - function to change what what gets called
65:56 - here and we do that by adding parameters
65:59 - to the function definition now let me
66:02 - take a step back before I explain adding
66:05 - parameters to the function definition so
66:07 - I just mentioned that when we call this
66:10 - function we have no control over what's
66:13 - being printed and since we're actually
66:15 - the creators of this function and the
66:18 - callers of this function so here we're
66:20 - creating this function and in hello. go
66:24 - we're actually calling this function
66:25 - function it's kind of hard to
66:27 - distinguish between the Creator and the
66:30 - caller because we're both in this case
66:32 - so when I say that when we call this
66:34 - function we have no control over what's
66:36 - printed I want you to imagine that as
66:39 - the caller of the function here we're
66:41 - the caller of the function like we're
66:43 - importing this function from this
66:45 - package and then we're calling it I want
66:47 - you to imagine that as the caller of the
66:49 - function we're not the creator of the
66:51 - function and what I mean by that is if
66:53 - we go to this test package we're calling
66:56 - this print line function from this fmt
66:59 - package right but we didn't write this
67:01 - fmt package so if this print line
67:04 - function doesn't give us the option to
67:07 - pass in an argument to print since we're
67:10 - not the ones responsible for creating
67:12 - this function we wouldn't have any
67:14 - control over that so that's what I mean
67:16 - when I say when we call this function we
67:19 - have no control over what's being
67:22 - printed here because this function gives
67:24 - no option to pass in any parameters to
67:28 - impact what's being printed like of
67:30 - course we can go ahead and alter this
67:32 - function to change what's being printed
67:34 - but I'm talking about when we call the
67:37 - function we have no way of impacting
67:39 - what's being printed because when we
67:41 - call this function these instructions
67:44 - are executed so I just want you to
67:47 - differentiate in your mind between the
67:49 - calling of the function and the actual
67:52 - function definition I want you to
67:55 - imagine
67:56 - that a separate person is creating this
67:58 - function definition from the person
68:01 - that's actually calling it so in that
68:03 - case we have no control over what my
68:05 - function does because we're imagining
68:08 - that we're not the ones who created this
68:10 - function we're just imagining that we're
68:12 - importing the package and we're using
68:15 - this function similar to what we're
68:17 - doing here we have no way of altering
68:20 - the way that this print line function
68:21 - works we can import it and make use of
68:24 - it but the the way that it's supposed to
68:26 - be used is defined in the actual
68:29 - function definition which we didn't have
68:31 - any part in making so we just need to
68:34 - conform to the constraints of the
68:37 - function that's provided to us so that's
68:40 - what I mean when I say we have no way to
68:43 - alter what's being printed here when we
68:45 - call my function I hope that makes sense
68:47 - but as the creators of my functions so
68:50 - now I want you to change roles in your
68:52 - mind now we're the creator of my
68:54 - function right and maybe somebody else
68:57 - wants to use my function so maybe
68:59 - somebody wants to import our package and
69:02 - use this my function function so as the
69:05 - people that actually defined this
69:07 - function remember the funk keyword is
69:10 - where we're defining the function if
69:11 - they want to use our function we can
69:14 - give them the power to alter what's
69:17 - being printed here by way of arguments
69:20 - and we Define them as function
69:23 - parameters so if we were to add some
69:26 - parameters into these parentheses for
69:28 - now we'll just add one parameter for
69:31 - example we can add the parameter step
69:34 - and we can put int here now you don't
69:36 - know what this int means yet but don't
69:38 - worry about it yet we'll get to it but
69:41 - we're adding this parameter here step so
69:43 - that means that the caller of the
69:45 - function which in this case is us but
69:47 - let's imagine that somebody else is
69:49 - using our package and calling this
69:51 - function now they're going to be
69:53 - required to provide an argument now you
69:56 - might be confused like argument
69:58 - parameter what's the difference and
70:00 - there really is no difference so the
70:02 - parameter is what we Define when we're
70:06 - defining our function so when we're
70:08 - creating the function we'll call it
70:10 - parameter when we're creating the
70:11 - function when we're defining these
70:13 - parameters that can be passed to the
70:15 - function and when we're calling the
70:17 - function we call it an argument like
70:19 - we're passing the argument to fulfill
70:21 - the parameter from the function
70:23 - definition so sometimes you'll hear the
70:25 - word parameter and argument used
70:26 - interchangeably so it might be confusing
70:28 - sometimes but basically the argument is
70:31 - what's being passed into the function
70:34 - and the parameter is the definition of
70:37 - what can be passed into the function so
70:39 - when we're writing the function we're
70:41 - adding this step parameter but when
70:44 - we're calling the function we're passing
70:47 - in an argument to fulfill the step
70:51 - parameter so if we go back to this my
70:54 - function we see that there's a step
70:56 - parameter and after we have this int
70:59 - word it looks like there's two
71:00 - parameters right but this is only one
71:02 - parameter and this int is just the data
71:05 - type of the parameter for example if we
71:08 - wanted two parameters we'd put a comma
71:10 - and we can just put another parameter
71:14 - and this will be int two so this is how
71:18 - we add multiple parameters to a function
71:21 - that we're defining so each parameter is
71:23 - separated by a comma so before it seemed
71:26 - like this was two parameters because we
71:28 - have step int but int is just the type
71:31 - of Step the step parameter and int is
71:34 - integer so it means that the the type of
71:38 - Step needs to be an integer and it's
71:41 - going to be a bit confusing right now
71:43 - because I haven't taught you about types
71:45 - yet but just bear with me I'm going to
71:48 - get to it so let's just stick with doing
71:51 - one parameter here and it's called step
71:53 - and the type needs to be an in so if we
71:56 - go back to hello. go you see that we're
71:58 - getting an error here because we need to
72:01 - pass an integer an integer a number like
72:04 - a step into the function and at this
72:07 - point we can start getting into the
72:09 - basic data types of go so in go and any
72:13 - other programming language we're able to
72:16 - Define variables and in go we do that
72:19 - using the keyword VAR which stands for
72:23 - variable and we're going to use VAR to
72:25 - Define a variable so we do the VAR key
72:28 - word and we put the name that we want
72:31 - the variable to be like we we put the
72:33 - name of the variable what do we want to
72:35 - call it like how are we going to
72:37 - reference it in our code and after the
72:40 - name of the variable we put the type of
72:43 - the variable so the data type of the
72:46 - variable and following the type we
72:49 - assign a value to the variable by using
72:52 - the equal sign so in this case we'll say
72:54 - that we're creating the variable called
72:57 - step and it's an integer and the value
73:00 - that we want to assign to that variable
73:02 - is one now what does this mean so
73:04 - basically this means that we're storing
73:06 - this value one in memory like we're
73:09 - saving it in memory and in order for us
73:11 - to reference it later on we're giving it
73:14 - a name so for example right now you'll
73:16 - see that we're getting an error here cuz
73:18 - it says unused variable step so like
73:21 - we're storing this value one in memory
73:23 - but we're never referencing it cuz we're
73:25 - never referencing the variable name but
73:28 - if we add step into here now the
73:31 - variable is being used and we're no
73:34 - longer getting that error so what does
73:36 - this mean this means that whenever we
73:38 - reference this variable step it's going
73:41 - to be the value one and it's a type
73:45 - integer so since we're passing step to
73:48 - my function we're actually passing the
73:51 - value one to my function so defining a
73:54 - variable is just saving a value in
73:57 - memory and giving it a name and we have
73:59 - to specify the type of the variable so
74:02 - if we go to my function now since we're
74:04 - passing in the value one as step we can
74:07 - use what's called a conditional
74:10 - statement to decide which one of these
74:13 - steps we want to print so we can do if
74:17 - step equals
74:19 - 1 we can print step one now this is a
74:25 - conditional statement and it's basically
74:27 - saying if step is equal to one then do
74:31 - what's ever inside of these brackets so
74:34 - if step were two in this case if we were
74:37 - passing in two as an argument this code
74:40 - wouldn't execute because this code in
74:43 - these brackets of this conditional
74:45 - statement will only execute if step is
74:48 - equal to one and you might be confused
74:51 - about us using two equal signs here so
74:53 - two equal signs means equals like it
74:56 - means the condition equals and that's
74:59 - because we're use we use one equal sign
75:02 - to assign a value to a variable right
75:05 - and that's like built into the
75:07 - programming language like so if we were
75:09 - to try and use one equal sign here go
75:12 - might think that we're trying to assign
75:14 - the value one to step but like you don't
75:17 - you don't actually need to understand in
75:20 - detail why we use two equal signs as
75:22 - opposed to one just know that two equal
75:24 - signs means equals to and for example
75:28 - less than is less than so if step is
75:31 - less than one then the code in this
75:33 - block executes and the same thing with
75:37 - less than or equal to or greater than or
75:40 - equal to or just greater than but
75:43 - anyways here we want to know if step is
75:46 - equal to one if step is equal to one
75:50 - then execute this code so this is called
75:53 - a conditional statement and so we we
75:56 - have something that we do if step is
75:59 - equal to one but what if step is equal
76:00 - to 2 3 and four well here we would add
76:04 - else if and then another condition so
76:07 - else if step is equal to two and then
76:11 - another set of brackets so else if step
76:14 - is equal to two we do what we put inside
76:17 - of these two brackets so we can take
76:20 - this and do that so if step is equal to
76:24 - two we'll print print step two and we do
76:26 - the same thing for three and four so
76:29 - we'll do else if step equal 3 we'll
76:34 - print step three and then else if step
76:38 - equals
76:39 - 4 we'll print step four so this is one
76:43 - way we control the flow of the
76:46 - application like we can do different
76:48 - things depending on different conditions
76:52 - right so if step is one step one will
76:55 - get printed but Step 2 3 and four will
76:57 - never get printed because we'll never
76:59 - satisfy this condition step equals 2
77:02 - Step equal 3 step equals 4 because step
77:04 - is equal to one right so it'll print
77:06 - this and then all of this gets skipped
77:09 - and then the function will end now what
77:11 - if step is equal to something other than
77:13 - 1 2 3 4 well we can add at the end here
77:16 - just else and then the brackets here and
77:20 - we can just
77:22 - print step not support
77:25 - Ed so this means that we have a
77:29 - condition for 1 2 3 and four but
77:32 - anything other than that else else if
77:35 - anything else essentially then we're
77:37 - just going to say that step isn't
77:39 - supported so let's actually go ahead and
77:41 - test this out so if we go back to hello.
77:44 - go we're setting step equal to one and
77:48 - then we're passing step into my
77:51 - function and my function takes the argu
77:54 - argument step because it has this step
77:57 - integer parameter and it checks to see
77:59 - if step is equal to one and if step is
78:02 - equal to one it will print this it won't
78:06 - reach these else conditions if step is
78:09 - equal to one so let's go ahead and try
78:11 - that out so we can open our terminal
78:13 - here and remember we already have this
78:18 - code inside of our main function so it's
78:20 - going to run it's going to set the
78:21 - variable step equal to one and then it's
78:24 - going to pass step to my function and
78:26 - call my function so as you can see here
78:28 - we're still invoking the function or
78:30 - calling the function using parentheses
78:32 - but if there are arguments required for
78:35 - the function we just put the arguments
78:37 - inside of the parentheses so it should
78:40 - mirror what we have here so if we go
78:44 - back to hello. go and then let's just do
78:47 - go run hello. go you see that step one
78:50 - gets printed but nothing else gets
78:52 - printed because this condition was met
78:55 - but these other conditions were not met
78:58 - right so let's try changing the step
79:02 - right let's change this to step let's
79:05 - just do step four let's change it to
79:06 - step four so now we're assigning the
79:08 - value four to this variable step and
79:12 - we're passing that variable into my
79:14 - function and if we do go
79:16 - run hello. go you see that step four
79:20 - gets printed because we didn't meet this
79:23 - condition so then it checked for for
79:24 - this condition we didn't meet that
79:26 - condition so then it checked for this
79:28 - condition we didn't meet that condition
79:30 - so then it checked for this condition
79:32 - and we did meet that condition so it
79:34 - printed step
79:35 - four now let's do one more here what if
79:38 - we change this to 10 I'm sure you can
79:40 - guess what's going to happen here so
79:42 - let's just clear this and do go run
79:45 - hello. go and you can see we print step
79:48 - not supported because in our function we
79:51 - don't have support for step 10 it only
79:54 - goes up to four so if anything beyond
79:56 - that is passed then we're just going to
79:59 - say step is not supported so in this
80:02 - function definition we added a parameter
80:05 - called Step so the caller of the
80:07 - function needs to pass an argument of
80:11 - Step which is in this case we're passing
80:14 - in the value 10 as step and it's the
80:16 - same thing that's happening here in this
80:20 - print line function that we imported
80:23 - when we imported the format package
80:25 - print line expects an argument so we're
80:27 - passing an argument to print line and it
80:29 - prints whatever we pass it now let's go
80:33 - back to hello. go and continue with
80:37 - trying to understand what types are so
80:41 - the basic types that you need to
80:42 - understand right now for go are int
80:45 - which you just learned about int is a
80:48 - number essentially so if we were to
80:50 - create another int and we were to call
80:53 - it left
80:55 - and then we create another one and we
80:57 - call it right and we'll change left to
81:00 - five and right is 10 and we'll once
81:03 - again use print line from the format
81:06 - package if we were to print left plus
81:11 - right since these are both numbers left
81:14 - plus right is going to add these two
81:17 - numbers together and print them so for
81:18 - now let's delete this step and let's
81:21 - delete the call to the test package to
81:23 - avoid confusion
81:28 - so if we run
81:31 - this you see that 15 gets printed
81:34 - because we assigned the variable left
81:38 - this value five and we gave the variable
81:41 - right this value 10 so when we do left
81:44 - plus right we get the sum of those two
81:46 - values and we can do the same thing with
81:48 - subtraction or any other arithmetic for
81:51 - example so let's run it with subtraction
81:57 - and you see we get5 because 5 - 10 is5
82:01 - so that is the int type the basic type
82:05 - int another type that we're going to be
82:08 - making use of is the string type so
82:11 - we'll say VAR name and we'll call it
82:15 - string and we'll set it equal to
82:19 - James so here if we print name let's
82:23 - delete this left if if we print name
82:26 - it's going to print this value
82:34 - James and as you can see here Prince
82:36 - James now this is a string value and a
82:40 - string value is just a string of
82:43 - characters and you can recognize a
82:45 - string by the use of these quotations
82:48 - here for example if we try to put an
82:51 - integer here we're going to get an error
82:53 - because this isn't a string this is an
82:56 - integer but if we were to add these
82:59 - quotation marks here it becomes a string
83:02 - so if we were to
83:05 - create
83:06 - left
83:08 - right and print left plus right here
83:12 - what's going to happen is probably
83:13 - unexpected to you as a beginner like you
83:16 - would think maybe it's going to add them
83:18 - together and it would be 22 right but
83:20 - it's not because it's not an integer so
83:22 - you can't do arithmetic on it so it's a
83:25 - string of characters so when we add them
83:28 - together we'll do go run hello. go we
83:32 - get one 2 1 0 because what it's doing is
83:35 - it's just concatenating the characters
83:38 - and concatenating just means it's just
83:40 - doing this it's just merging them
83:43 - together to a longer string of
83:45 - characters like you can't see the
83:47 - parentheses here but when it's being
83:49 - printed to the terminal it's actually
83:50 - printing a string and not an integer and
83:53 - let me use a different an example to
83:55 - kind of exemplify what I'm saying here
83:58 - so if we put James
84:01 - here and put Smith here and we select
84:04 - the terminal and go run hello. go you
84:08 - see that it just concatenates James and
84:11 - Smith and makes it into one string James
84:16 - Smith and strings can also include
84:20 - spaces so if we put a space here that's
84:23 - a character as well space is a character
84:26 - as well so it'll be James space Smith
84:29 - when we add them together so if we go go
84:32 - run hello. go you see now it's James
84:36 - Smith with the space now I encourage you
84:39 - to go and mess around with these types
84:41 - to kind of see how they work that's a
84:43 - general explanation of a string and an
84:45 - integer so remember integers we can use
84:47 - arithmetic on them but remember for
84:50 - Strings if we add them together it's
84:52 - just going to concatenate them so what
84:54 - do you think might happen if we try to
84:56 - subtract them well we get an error
84:58 - because we can't do arithmetic on
85:00 - strings cuz they're not integers they're
85:02 - not numbers so it says invalid operation
85:05 - left minus right the operator is not
85:08 - defined on string and this just means of
85:10 - course we can't subtract a string from a
85:13 - string because they're not
85:15 - integers and one more type that we need
85:18 - to take into consideration is we'll do
85:22 - is happy and we'll change this to bull
85:25 - and a bull is just true or false so
85:29 - let's delete these and we can change in
85:32 - here to is
85:37 - happy so when we do go run hello. go you
85:40 - see true is going to get printed to the
85:42 - screen now if we change this to
85:48 - false and we do go run hello. go you see
85:53 - false gets printed to the screen and you
85:55 - might be wondering how are these bull
85:57 - variables useful and to that I say you
86:00 - don't need to know how the bull variable
86:02 - is useful yet because we're not making
86:04 - use of it yet so don't worry about why
86:07 - it's useful yet you just need to know
86:09 - that there is a data type called bull
86:12 - which is true or false and we can assign
86:15 - that to a variable so yeah just keep in
86:18 - mind that we have these three data types
86:27 - and don't worry about these variable
86:28 - names I just wrote anything just to show
86:31 - these three data types so remember we
86:33 - have a bull which is true or false we
86:36 - have a string which is a string of
86:38 - characters and we have an integer which
86:40 - is an integer a number so let's go ahead
86:43 - and delete
86:44 - that so now at this point you should
86:47 - have an understanding of function
86:50 - parameters and their types so let me
86:53 - just explain a a little bit more about
86:55 - this function parameter so like the type
86:57 - has to be an INT it's required to be an
86:59 - INT if you call this function if you try
87:02 - to pass in a string it's not going to
87:04 - work because this function only accepts
87:06 - an INT so if we
87:09 - go and we do test package my function
87:14 - and we pass in this is a string you see
87:18 - that it's red here it's not going to
87:20 - work so it says cannot use this is a
87:22 - string type string as type int of course
87:26 - because it accepts only a type int and
87:29 - if we go to my function and we change
87:32 - this to string it's still going to break
87:35 - because now we're trying to compare a
87:38 - string to an integer and you can't
87:41 - compare the two because they're not the
87:42 - same type so if we changed these numbers
87:46 - here to string then we could compare
87:50 - them like you see the error goes away
87:51 - for this one but these ones are still
87:53 - wrong we're comparing a string to an
87:56 - integer and yeah I hope you understand
87:59 - what I'm saying with that but if you're
88:01 - not fully grasping this if you if you
88:04 - grasp most of it but you're still not
88:06 - fully grasping it it's fine to continue
88:08 - on with the video because things will
88:10 - become more clear as we actually use
88:13 - these things to build what we're
88:15 - building but if you completely don't
88:17 - understand what I'm talking about here I
88:20 - encourage you to rewind the video and go
88:22 - back and go over these fundamentals
88:25 - again because they're necessary you need
88:27 - to be able to understand these things to
88:29 - be able to continue with the rest of the
88:31 - tutorial now as we continue with the
88:34 - tutorial I'll introduce new things as
88:37 - we're building our backend and
88:40 - everything that I introduce I'll explain
88:42 - it so yeah I think it's okay for us to
88:45 - move on at this point so you should
88:48 - understand the following things at this
88:49 - point you should understand what a
88:52 - function is and you should understand
88:54 - how to export a function using the
88:57 - capital letter when you name the
88:58 - function you should understand what a
89:01 - package is and you should understand how
89:03 - to import a package and call a packages
89:07 - function and you should understand
89:09 - function parameters and how we can use
89:12 - them to make our functions more
89:16 - configurable or customizable by the
89:19 - caller you should understand what a
89:21 - private function is and you should
89:23 - understand that private functions can
89:25 - only be used within the package that
89:27 - they're defined so we actually didn't go
89:30 - over that part so a private function
89:32 - since it's not exported since we're not
89:34 - using a capital letter here it means
89:37 - that it can only be used inside of the
89:39 - package where it's defined so this
89:41 - private function is defined in this test
89:44 - package so for example in my function we
89:48 - could call my private function my
89:51 - private function
89:54 - and you can see we don't have to prefix
89:56 - this with the name of the package
89:58 - because we're calling the function from
89:59 - within the package so inside here we can
90:02 - call my private
90:05 - function but in our main package or our
90:09 - entry point we can't call my private
90:12 - function because let's delete that if we
90:15 - do test
90:18 - package my private
90:21 - function you see that we get the error
90:24 - here unexported function my private
90:26 - function and you also see here that we
90:28 - have to prefix the function name with
90:30 - the package when we're calling it from a
90:33 - package that's not the package where the
90:35 - function is actually defined so that's
90:38 - what you need to know about that and you
90:39 - also need to know about the main
90:41 - function like you need to know about how
90:43 - the main function is the entry point to
90:45 - the application and how the main package
90:48 - is the package where the entry point is
90:52 - defined and I already told you how you
90:54 - can imagine that this main package is
90:56 - being imported by go behind the scenes
91:00 - and you should also have an
91:02 - understanding of types more specifically
91:05 - the basic types string Bull and integer
91:08 - and you should have understanding with
91:10 - variables and how we actually Define
91:12 - variables by naming
91:15 - them and putting the
91:18 - type and then putting a value for the
91:20 - variable so yeah that's everything that
91:23 - you you need to understand up until this
91:25 - point if any of these things are
91:27 - confusing to you or you don't grasp them
91:29 - at least like 80% then I suggest that
91:31 - you go back and rewatch the part of the
91:33 - video where I explain these things
91:35 - because these are basically the
91:37 - prerequisites that you need to
91:39 - understand in order to actually build
91:41 - this API that we're going to build and
91:44 - like I said whatever new things that I
91:47 - introduce I'll explain them as I
91:49 - introduce them but those are just the
91:50 - fundamentals that's the Baseline
91:52 - understanding that you need to have in
91:54 - order to move forward so yeah if you've
91:56 - made it up until this point we are going
91:59 - to now start to actually build the API
92:02 - that's going to be called by the front
92:04 - end that we spun up earlier or the
92:07 - pre-built front end that we downloaded
92:09 - and started up earlier which is the
92:11 - product page so we're now building the
92:14 - application programming interface that's
92:16 - going to run on the backend server that
92:18 - the front end code is going to call and
92:21 - if you don't know what I mean by that
92:23 - you should go back back and rewatch the
92:25 - part where I explained the key terms
92:28 - prior to explaining the fundamental
92:31 - things that you need to be able to code
92:33 - the project so yeah from here we can
92:36 - make our main function vanilla like we
92:38 - can remove everything from it and just
92:41 - have our main package with the main
92:43 - function with no code in it yet so right
92:45 - now this is just an empty application
92:48 - but it contains the minimum requirements
92:50 - for a go application so like explained
92:53 - for the go Application you need to have
92:56 - this package Main and you need to have
92:58 - the entry point so you can actually run
93:01 - this right now G run hello. go nothing
93:06 - happens but it actually called this
93:08 - function but there's nothing in the
93:09 - function so that's why nothing shows up
93:12 - here so we'll have this minimum
93:15 - requirement which is main.go and then
93:18 - this package we actually don't need this
93:20 - package this was just an example I just
93:23 - wanted to show you what a package is so
93:25 - you can close that package folder and
93:28 - just delete the whole folder and it'll
93:31 - ask if you want to delete the directory
93:33 - test package just delete it and we can
93:36 - just change the name of this back to
93:39 - main.go
93:42 - and now you should have a completely
93:45 - empty go Application the file main.go
93:49 - and that's just in the go tutorial
93:52 - folder the project folder so the next
93:54 - thing that we need to do is we need to
93:58 - start building our actual backend API so
94:01 - in order to do that like I explained
94:03 - before we're going to use a payment
94:06 - processing platform called stripe so the
94:09 - code that we're going to be writing here
94:11 - is going to make heavy use of that
94:14 - payment processing platform and you'll
94:17 - understand what I mean by that soon but
94:19 - first we need to make sure we create a
94:21 - stripe account so that we can make use
94:23 - of it it so you can go ahead and open up
94:27 - a browser and you can just type in
94:30 - stripe payment and you can just go ahead
94:33 - and select this first one here and then
94:36 - select start now and here you will
94:39 - create your account now I already have
94:42 - an account so once you've finished
94:44 - creating your account you can go ahead
94:45 - and sign in to your account now once
94:48 - you've created and set up your account
94:51 - and you've logged in you should be taken
94:53 - to this is dashboard. stripe.com and it
94:56 - should be/ test dashboard if you're not
94:59 - on the test dashboard then just put SL
95:03 - test dashboard in the URL and hit enter
95:06 - and you'll be brought to this test
95:08 - dashboard now the first thing that we
95:10 - want to do as soon as we access this
95:12 - dashboard is we need to look down here
95:15 - to the right side and see if you have
95:19 - these publishable key and secret keys
95:22 - and you're going to to copy this
95:25 - publishable key copy the publishable key
95:28 - click it and copy it to your clipboard
95:30 - and then go and open up your terminal
95:33 - and from your terminal you want to
95:35 - change directory to that front end that
95:38 - we downloaded before Go for beginners
95:43 - frontend and then you should change
95:46 - directory to the folder called
95:49 - SRC and then you can LS here and there's
95:52 - a file here called stripe payment. jsx I
95:56 - want you to open this file with a text
95:59 - editor that should be already
96:01 - pre-installed on your system if you're
96:03 - using Mac and it's called Nano so you'll
96:06 - type
96:07 - Nano stripe payment. jsx and then press
96:12 - enter so this should open the file like
96:15 - so and you should be able to use the
96:18 - arrow keys on your keyboard to go down
96:21 - down down all the way until you get get
96:23 - to this string here that has this long
96:26 - key in IT PK test 51 N9 blah blah blah
96:30 - and I want you to go all the way to the
96:33 - end
96:36 - here all the way till you get to the end
96:38 - quote and once you get to the end quote
96:41 - here I just want you to hit backspace
96:44 - and delete everything inside of the
96:46 - quotation marks and then you should be
96:49 - able to paste in that key that you
96:51 - copied from the actual dashboard of your
96:55 - account and when you paste it in it
96:57 - might mess up the spacing so just go all
97:00 - the way back to the beginning of the
97:03 - key to the beginning quote and then hit
97:06 - Tab and then backspace twice and after
97:10 - that you want to type in control X and
97:14 - it's going to say here save modified
97:17 - buffer answering no will destroy changes
97:20 - you want to type the letter Y to save
97:23 - the changes that we just made so just
97:25 - type Y and then it'll say file name to
97:29 - write and we still want to keep the same
97:31 - file name so you can just hit enter and
97:34 - that should save the file and after that
97:37 - you can just go ahead and close your
97:38 - terminal but yeah it's very important
97:40 - that you change that key inside of that
97:42 - file so make sure you do that and
97:44 - confirm that you have the proper key
97:47 - that's from your dashboard stored in
97:49 - that file and I can't stress it enough
97:51 - not having the proper key there will
97:54 - break the application for you like you
97:55 - won't be able to complete the tutorial
97:57 - so make sure you confirm that it's the
98:00 - proper key but anyways now that we have
98:02 - a stripe account we can start writing
98:05 - our backend code and our backend code is
98:08 - going to make use of that stripe account
98:11 - so if you recall our backend code is the
98:14 - server code that provides an interface
98:17 - for our front end to use to communicate
98:20 - so our front end is going to need to be
98:22 - able to send request to our backend
98:26 - server and this is the code that's going
98:28 - to handle those requests so that request
98:32 - is going to be sent over the Internet so
98:34 - the frontend is going to send a request
98:37 - to our backend server over the internet
98:40 - and that request is called an HTTP
98:43 - request so we're actually going to need
98:45 - to import one of Go's packages from its
98:48 - standard library that helps us to handle
98:51 - these types of requests coming from
98:53 - front in clients so let's just start off
98:56 - by writing out some imports now in go
99:00 - before you saw that we were importing
99:02 - single packages like this with quotation
99:05 - marks right but in go you can actually
99:07 - import a list of packages so instead of
99:09 - doing import import name of package we
99:12 - can just import all of them in the same
99:15 - list so let me show you what I mean so
99:18 - we want to import the package called net
99:21 - SL http
99:23 - and remember this is a package provided
99:26 - by the go programming language and we
99:27 - can use this to handle requests sent
99:31 - from the front end to our backend server
99:33 - but we're also going to want to import
99:36 - format again just for our testing
99:39 - purposes now instead of using the import
99:42 - keyword twice we can just use it once we
99:45 - can just do it like this
99:54 - so using these parentheses we're able to
99:57 - import multiple packages at once but
99:59 - don't get these parentheses confused
100:01 - with the parentheses that we use when we
100:03 - create and invoke functions they're not
100:05 - the same thing this is a completely
100:07 - separate thing this is just us importing
100:08 - multiple packages using the same import
100:11 - keyword instead of listing import
100:13 - multiple times so like I said we need to
100:16 - be able to accept the HTTP requests from
100:19 - our front end so we need to provide the
100:22 - interface for the front end to be able
100:25 - to send these requests and the way that
100:27 - we do that in go is we'll use this HTT
100:30 - packages function called handle Funk and
100:34 - this function is going to take two
100:36 - arguments and this leads us to something
100:39 - that we're actually going to need to
100:40 - familiarize oursel with in this goand
100:43 - IDE so as we discussed before these
100:46 - packages provide functions for us to use
100:48 - right so we're using this HTTP packages
100:51 - function called handle funk but there
100:54 - are cases where we're going to want to
100:55 - know more information about the function
100:57 - and how to use it so in that case in
101:01 - goand you can just hover over the
101:03 - function and it'll give you all of this
101:05 - additional information about the
101:07 - function so as you can see up here
101:10 - handle Funk takes the parameter pattern
101:13 - and the parameter Handler and it tells
101:15 - you that this pattern parameter is a
101:17 - string and this Handler parameter is
101:20 - actually a function and this function
101:22 - actually needs to take response writer
101:25 - and request parameter and both of these
101:27 - come from the HTTP package now this part
101:31 - is not necessary to understand fully at
101:34 - the moment so don't worry too much about
101:36 - this part just know that this handle
101:38 - Funk takes a pattern which is a string
101:40 - and a Handler which is a function so
101:42 - we're going to need to write a function
101:44 - to pass to this function and you'll see
101:47 - what I mean by that soon but first I
101:49 - need to explain to you what this pattern
101:52 - is and to do that I need to explain to
101:55 - you what it means to send a request to a
101:58 - server so I want you to imagine that
102:00 - this entire screen is the internet and
102:03 - let's say for example we have our server
102:06 - and our frontend at different locations
102:09 - in the internet so here's our server and
102:12 - here's our front
102:14 - end and maybe this server is hosted in
102:17 - some entirely different country or
102:18 - whatever the point is these two entities
102:21 - they're not hosted in the same location
102:23 - are on the same server so this is the
102:26 - backend server and this is the front end
102:29 - that needs to call the backend so how
102:31 - does the front end access the backend
102:34 - server Maybe This Server is hosted in
102:36 - Brazil or something so how does this
102:38 - frontend make a call to a server among
102:43 - many other servers on the internet
102:45 - because of course it's the internet so
102:48 - maybe there are many other servers so
102:50 - again we want to Target a specific
102:53 - server we don't want to Target any of
102:54 - these other servers like maybe this is
102:56 - Google's server maybe this is like
102:58 - Yahoo's server and this is the server
103:00 - that we want to Target for our frontend
103:03 - right so how does our frontend access
103:05 - This Server well it's similar to the way
103:08 - you know how to send mail to somebody in
103:11 - the real world you know their address
103:13 - and it's the same thing with the
103:14 - internet in the internet servers have
103:16 - addresses and I'm sure you're already
103:18 - familiar with the concept of an IP
103:20 - address so that's what I'm talking about
103:22 - here so the way that our frontend will
103:26 - access this server is by accessing its
103:29 - Associated IP address so maybe our
103:32 - server's IP address looks like this so
103:35 - that would mean that our front end can
103:37 - send requests to this IP address so
103:40 - maybe the front end wants to send a
103:41 - request it knows the IP address of the
103:44 - server that it needs to send the request
103:45 - to so it can send the request to that IP
103:48 - address now just CU our front end has
103:51 - the IP address to the server it doesn't
103:54 - mean that the front end can actually
103:56 - interface with our server because on the
103:58 - server's operating system there are
104:01 - actually these numbers called ports and
104:04 - these ports are basically at the OS
104:07 - level so you don't need to know about
104:08 - that just know that the server's
104:10 - operating system will have ports that
104:13 - are used for network connections like a
104:16 - server may or may not have ports opened
104:19 - for receiving Internet traffic from
104:22 - another location but in our case you
104:25 - don't need to think about any of that
104:26 - stuff we're just going to imagine that
104:28 - we do have a port that our frontend can
104:31 - use and the range available for ports is
104:35 - actually 0 to
104:40 - 65353 now there are some ports that are
104:42 - reserved and some ports that we
104:43 - shouldn't use and stuff like that Etc
104:45 - but again for this tutorial you don't
104:47 - need to know that much detail about this
104:49 - just know that on the operating system
104:51 - level the server is going to have a
104:54 - range of ports available and each Port
104:57 - can be used to connect to the server if
104:59 - the server allows it essentially so when
105:01 - the front end uses the IP address to
105:04 - call our server it also needs to provide
105:06 - a port so what that's going to look like
105:09 - is this so the front end will send the
105:11 - request so this is the request to our
105:14 - server's IP address including the port
105:18 - and in our case we're using Port
105:21 - 4242 so now our front end can send a
105:24 - request to our server using the IP
105:26 - address and a specific Port so that Port
105:29 - is going to allow our front end to
105:31 - essentially connect to our server
105:34 - because the port on the operating system
105:36 - level is used for the connection if
105:39 - there's no port to use then sending a
105:41 - request to just the IP address would be
105:43 - useless so in our backend code we're
105:46 - actually going to listen on this port so
105:49 - any request that comes into this IP
105:52 - address on this Port will get picked up
105:54 - by our server cuz in the code we're
105:57 - actually going to listen on Port 4242
105:59 - but we have another issue here so like
106:02 - if the frontend sends a request to our
106:04 - server how does our server know what the
106:07 - frontend wants us to do the front end
106:10 - essentially sends us a request to do
106:12 - something right and the backend code
106:15 - needs to have some way of knowing what
106:17 - the frontend wants us to do right and if
106:19 - the frontend is just sending requests to
106:21 - our IP address on our port that we're
106:23 - listening on I mean we get the request
106:25 - but we don't know what the front end
106:26 - wants us to do with that request so
106:29 - that's why we need to provide the
106:31 - interface for the front end to use so
106:34 - the way that we do that is we provide
106:37 - API end points essentially it's like a
106:40 - path to a specific functionality so in
106:44 - our case our server let's just do some
106:47 - bubbles here is going to provide an
106:50 - endpoint called create payment
106:53 - intent and this endpoint is going to map
106:57 - to some functionality on our server so
107:01 - when we receive a request to this
107:03 - inpoint specifically we're going to
107:06 - trigger some code that creates the
107:09 - payment intent does exactly what this
107:11 - says so that means that our front end is
107:13 - only able to ask us to create payment
107:15 - intent if we only have this endpoint if
107:17 - the front end needs additional
107:19 - functionality they need to ask us to
107:21 - build that or ADD additional endpoints
107:23 - to support that additional functionality
107:26 - but in the beginning in this tutorial
107:28 - the endpoint is create payment intent so
107:31 - the front end is going to send us a
107:32 - request to create the payment intent and
107:36 - that's going to trigger a function on
107:37 - our code that will actually create the
107:40 - payment intent on the back end so you're
107:42 - probably wondering when the front end
107:43 - sends this request how do they specify a
107:46 - particular endpoint in this example
107:49 - create payment intent well they just
107:51 - appended this endpoint to the address
107:54 - when they're sending the request so it
107:56 - would look like this so instead of just
107:58 - having the IP address and the port we'd
108:02 - also add this part to the end so then
108:05 - when the front end sends the request to
108:08 - our IP address at our Port that we're
108:11 - listening on specifying that it wants to
108:14 - create a payment intent then in our code
108:17 - we know what functionality we need to
108:19 - trigger and we're going to be building
108:21 - this or writing the code for this and go
108:23 - so exactly what I'm explaining here
108:25 - right now having this end point mapped
108:28 - to some functionality in our code when
108:32 - the front end sends a request to that
108:34 - endpoint that's what we're going to be
108:36 - building here now this is a very simple
108:39 - explanation of how this stuff works you
108:42 - can dive deeper into like networking
108:44 - stuff and how domain names and IP
108:47 - addresses are resolved and stuff like
108:49 - that but for the purposes of this
108:50 - tutorial I don't want to go too deep
108:52 - into networking stuff because it'll just
108:54 - cause confusion when you're trying to
108:56 - focus on learning the programming
108:58 - language you really only need to know
109:00 - these surface level details to
109:02 - understand how a frontend sends a
109:05 - request to an API and how that request
109:07 - is mapped to some specific functionality
109:10 - on the backend server okay so now that
109:12 - you have an understanding of what it
109:14 - means to actually send a request to a
109:16 - server and how the URL is essentially
109:19 - the address for that server the pattern
109:21 - that's expected for this hand handle
109:23 - Funk is actually just the pattern at the
109:26 - end of the URL so for example when the
109:29 - front end sends a request to our server
109:33 - it's going to send the request to the
109:35 - address where our server is hosted right
109:38 - and since we're building the application
109:40 - we're hosting the server on our local
109:42 - machine and we're using Port 4242 but
109:46 - that's the base URL like that's the
109:48 - address for our entire server but the
109:51 - interface that we provide to the front
109:52 - end needs a specific end point like we
109:55 - want to essentially assign different URL
109:59 - paths to different functionality for
110:01 - example the first functionality that we
110:03 - need to provide to the front end is
110:05 - going to be called create payment intent
110:09 - so whenever the front end needs to
110:11 - initialize a payment so that's
110:13 - essentially when the user reaches the
110:15 - checkout page the front end is going to
110:17 - need to create a payment intent for that
110:20 - user or a better way of explaining it is
110:22 - the front end is going to need us to
110:24 - create the payment intent for the user
110:26 - so the way that the frontend asks us to
110:28 - do that is they send a request to a
110:30 - specific endpoint so for example we
110:33 - might have many different types of
110:35 - endpoints so a usual endpoint is like a
110:38 - health endpoint and this just checks to
110:40 - see if the server is up like the front
110:42 - end has no way of knowing if our server
110:45 - is running right because they're calling
110:47 - us from a different location or a remote
110:50 - location so maybe they just want to
110:51 - check and see if the server is up they
110:53 - can send a request to this health
110:55 - endpoint and we'd need to provide that
110:57 - functionality to them so for example
111:00 - here we're going to provide the
111:02 - functionality to create payment intent
111:06 - and there should be a forward slash here
111:07 - and in order to provide this
111:09 - functionality to them we need to give
111:11 - them the actual end point to call so in
111:14 - this case they'll call the create
111:16 - payment intent endpoint so it would look
111:18 - like this so this is the address the
111:21 - front end would send the requ request to
111:23 - to create a payment intent and if we
111:25 - wanted to give them the health
111:27 - functionality as well we'd need to
111:29 - create an endpoint for that as well so
111:31 - now at this point we're providing the
111:33 - front end with the interface to actually
111:37 - trigger our code but you're probably
111:40 - wondering so where do we write our code
111:41 - we're just giving them this address or
111:44 - this endpoint but there's no
111:46 - functionality triggered by any of this
111:49 - well that's where this handle Funk
111:51 - function comes in so if you see here it
111:53 - says handle Funk registers the Handler
111:56 - function for the given pattern so that
111:59 - means that handle Funk is going to
112:02 - register the function that we create and
112:05 - it's going to essentially map it to the
112:07 - given pattern so when the front end
112:09 - calls this end point or pattern we're
112:12 - going to have a function that gets
112:14 - triggered and that function is going to
112:16 - be called handle create payment intent
112:20 - now you can see this is red here right
112:22 - right and it's red here because we
112:24 - haven't created this function so we need
112:26 - to create this function so we can go
112:29 - down under Main and we'll do Funk handle
112:33 - create payment intent and remember this
112:35 - function needs to take in two things so
112:39 - if we go back to our handle Funk
112:43 - documentation here you see that the
112:45 - function they expect the Handler is the
112:47 - function they expect to be passed to
112:49 - this handle Funk as an argument and it's
112:51 - saying the function has to take in a
112:53 - response writer and a pointer to a
112:56 - request this star means pointer but you
112:58 - don't need to know what a pointer is yet
113:00 - just just know that it needs to take in
113:02 - response writer and request now this
113:05 - response writer and request comes from
113:07 - this HTTP package they're types provided
113:11 - by the HTTP package now remember the
113:14 - types that we went over string Bull and
113:16 - int well in go you can actually create
113:19 - your own types as well and this HTTP
113:22 - pack package created the response writer
113:24 - type and request type for us and we can
113:26 - use these types so when we create our
113:30 - function parameters we can say w that's
113:33 - what we're going to name the response
113:34 - writer and we can just from the HTTP
113:38 - package use the response writer type
113:41 - this type here and if we hover over this
113:44 - you can see where they're creating this
113:46 - type using the type keyword response
113:48 - writer and you don't need to know all of
113:50 - this stuff yet just know that this is a
113:52 - type that was created by the HTTP
113:55 - package and we need to accept that into
113:58 - the function that we use here now I know
114:00 - it sounds confusing but just bear with
114:03 - me things will become more
114:05 - clear so remember we need to pass the
114:08 - response writer and a pointer to request
114:11 - so for request we'll just call it R and
114:14 - the type that we need to use is pointer
114:16 - to http do
114:20 - request so now we've met the minimum
114:23 - conditions with this function to pass it
114:26 - to handle Funk right so now we can just
114:30 - finish writing this
114:32 - function and we can comment this out for
114:35 - now and I haven't explained to you what
114:37 - it means to comment out code so let me
114:39 - explain it now so just now I added these
114:42 - two forward slashes to the beginning of
114:44 - this line of code that makes the code
114:47 - commented out like when you run the
114:50 - program this code won't be executed
114:52 - it'll be ignored so for example if I
114:55 - comment this one out it'll be ignored as
114:57 - well so when we run Funk main nothing
114:59 - will happen cuz both of the lines of
115:00 - code have been commented out but if you
115:02 - remove those forward slashes they become
115:05 - active like this this line of code will
115:07 - execute when we run main now I just
115:09 - wanted to comment out this health one
115:11 - right now because I just want to show
115:13 - you how handle Funk actually works and
115:16 - also let me collapse this so you can
115:18 - collapse this side Thing by just
115:20 - selecting project and I'm just
115:21 - collapsing it so you guys can see all of
115:23 - the code here now you understand that in
115:25 - order for the front end to call our back
115:28 - end they need to use this address or if
115:31 - we implement this health one down here
115:34 - this address but right now we haven't
115:37 - implemented this or provided this to
115:39 - them we're just doing this one for now
115:41 - so remember the handle Funk basically
115:44 - registers the function that's going to
115:47 - be called whenever the front end calls
115:49 - this end point so the end point is just
115:52 - the path after the address of the server
115:55 - so the front end calls this endpoint
115:58 - this this function gets triggered so
116:01 - that means that if we do format. print
116:04 - line here and we just type endpoint
116:07 - called whenever a request is sent to
116:10 - this endpoint endpoint called is going
116:13 - to get printed to the screen now we'll
116:15 - get to that in a second so we need to
116:17 - actually remove this here this was just
116:19 - to explain but we can't have that there
116:21 - cuz it the code won't work in that case
116:23 - and you might see these green lines
116:25 - under our Imports here and if you hover
116:27 - over it you see that it says Imports are
116:30 - not sorted and that's just because our
116:32 - Imports aren't in alphabetical order so
116:35 - what we can do is go has its own
116:37 - formatter that like organizes your code
116:40 - for you so if we hit project again and
116:42 - we rightclick our main.go file you can
116:45 - just go ahead and select reformat code
116:49 - and then it'll say optimize Imports make
116:51 - sure that box is checked clean up code
116:53 - make sure that box is checked and then
116:55 - you just hit okay and as you can see it
116:57 - reorganized the import so that they're
116:59 - in alphabetical order so whenever you've
117:01 - wrote some code just go ahead and get in
117:03 - the habit of formatting it using this
117:06 - reformat code tool but let's minimize
117:09 - that again and we're not going to add
117:10 - the health end point yet because I just
117:12 - want to show you guys how this end point
117:15 - is working like how it's going to
117:17 - trigger this function now right now we
117:20 - have the end Point maps to a function
117:24 - right but we don't have any code that's
117:27 - telling this file that it's going to be
117:29 - a running server like if you recall last
117:33 - time we were running our go file this
117:35 - funk main would execute all the code
117:37 - inside of it and then it would just be
117:39 - done after that right but for a server
117:41 - for an API for Server code we need
117:44 - what's called a long living application
117:47 - like the the application needs to run
117:49 - continuously because it needs to always
117:51 - be listening to these requests coming in
117:54 - from the front end right so that means
117:56 - that it always needs to be running so
117:58 - servers need to always be running
118:00 - servers active servers always need to be
118:02 - running so we can't have it finish this
118:04 - Main and then stop running we need it to
118:07 - run continuously and this HTTP package
118:10 - provides that functionality for us as
118:12 - well and it provides that functionality
118:14 - with a function called listen and serve
118:19 - and this function needs to take in some
118:22 - arguments as well first of all it needs
118:24 - to take in the address and in our case
118:27 - the address is just going to be Local
118:29 - Host and then Port 4242 and we can check
118:33 - what else it needs to take if we just
118:35 - hover over this so we see it needs to
118:37 - take an address which is a string and a
118:39 - Handler but we don't need to worry about
118:41 - the Handler part in our case we're just
118:43 - going to put null for this or nil in go
118:47 - so nil just means nothing like we're not
118:49 - going to pass anything there so you can
118:51 - see here is a pred declared identifier
118:53 - representing the zero value for a
118:55 - pointer a channel Funk Etc like whenever
118:58 - you want to know what something is you
119:00 - can just hover over it and the IDE will
119:04 - explain to you what it is so we can
119:06 - hover over this HTTP package and it
119:08 - tells you package HTTP provides HTTP
119:12 - client and server implementations so
119:14 - just get in the habit of trying to read
119:16 - this stuff and understand what's
119:18 - happening here right anyways so we can
119:20 - hover over listen and search and it says
119:22 - listen and serve listens on the TCP
119:25 - Network address addr which is the
119:28 - variable this variable here that is
119:30 - expects this argument here that it
119:31 - expects so it listens on that address
119:34 - and then calls serve with the Handler to
119:37 - handle requests on incoming connections
119:40 - so when the front end connects to our
119:43 - address depending on which path is
119:46 - appended to the address like with which
119:48 - path comes after 4242 it will Tri
119:52 - trigger whatever handle or function is
119:54 - associated with that endp point so
119:57 - running this is actually going to run
119:59 - the server but there's something new
120:01 - here that I need to explain to you so
120:03 - like this function as you can see here
120:05 - it has these two parameters right but it
120:08 - also has another type here right and
120:11 - that's because this function actually
120:13 - returns a value but it only returns a
120:16 - value if an error occurs now that's a
120:19 - bit confusing to understand so I have to
120:22 - go ahead and explain that to you right
120:24 - now so if we create a function here and
120:27 - we'll just call it Returns value in the
120:30 - beginning when we were creating
120:31 - functions we just did it simply like
120:33 - this and maybe we had like a parameter
120:36 - like something which was a string right
120:38 - and when this function gets called it
120:40 - just executes whatever code is inside of
120:42 - it and then that's it right but actually
120:45 - functions are capable of returning
120:47 - things back to the caller and how to do
120:50 - that is after the parentheses where the
120:53 - function parameters are you'll put the
120:55 - type of value that gets returned now
120:58 - this function is required to return
121:00 - something so you get this red line here
121:02 - right it says missing the return
121:03 - statement at the end of the function a
121:05 - return statement you literally just type
121:08 - the return word and you return something
121:11 - but that something has to be the same
121:14 - type that you're saying gets returned
121:16 - here so this is where we're saying what
121:18 - type of something gets returned so if
121:21 - this is int then it's going to say this
121:24 - is an error we're returning a string
121:26 - here but it should be an INT right but
121:28 - here let's
121:29 - say it's string so that means that we
121:32 - can do this so they can pass in
121:35 - something as a parameter right and that
121:37 - parameter is a string right we're
121:39 - expecting a string as the argument so we
121:41 - can just return that back to
121:44 - them and maybe using something for the
121:46 - argument and the return value is a bit
121:49 - confusing but I think you'll understand
121:50 - the point so let me
121:52 - just go ahead and comment out this code
121:55 - here in Main and then we'll just call
121:58 - return Returns value we'll call it and
122:01 - we'll pass in the value that we want to
122:03 - be returned something so what do we want
122:05 - to we'll just put hello I will return
122:09 - this back to you so now since this
122:12 - Returns value actually when we call it
122:15 - it's going to return a value we need to
122:18 - catch that value right so we can catch
122:20 - that value by creating a variable and we
122:23 - could just call it cot value and it's a
122:25 - string and we set it equal to the result
122:28 - of this function so this Returns value
122:31 - is going to return this string that we
122:33 - pass into it right and we want to catch
122:35 - it and store it in this cot value and
122:38 - then after that we can print it so we'll
122:40 - just print cot value and and I spelled
122:44 - format wrong here so I think you can
122:46 - guess what's going to happen here but
122:47 - let's just run it anyway so we can see
122:49 - what happens so we'll do go run run and
122:52 - we Chang the name of the file to main.go
122:54 - so and as you can see what gets printed
122:57 - is hello I will return this back to you
123:00 - now this is very important to understand
123:02 - so it basically combines everything
123:05 - we've learned up until this point and it
123:08 - also includes returning values from a
123:11 - function so we're creating this variable
123:15 - here right remember a variable is a way
123:17 - to assign a name to some value so that
123:20 - we can reference it later so we're
123:22 - assigning this cot value name to the
123:25 - result of this Returns value function
123:28 - and this Returns value function takes in
123:30 - the argument which is a string and it
123:33 - just returns that string back to us and
123:35 - that's represented here this is telling
123:37 - us the return value of this function is
123:39 - a string so since when we call this
123:41 - function it returns this string right
123:43 - back to us this string just gets put in
123:46 - this box this cop value box or variable
123:50 - and then later we can reference that cot
123:52 - value because we named it right and then
123:54 - we can print it and that's how return
123:56 - values work in functions so let's go
123:58 - ahead and delete
124:01 - this and let's delete this cop value as
124:04 - well and this print statement and we'll
124:06 - uncomment this and now back to the
124:09 - reason I had to explain to you what a
124:11 - return value is this listen and serve
124:14 - returns a value as well it returns type
124:17 - error remember the type that comes after
124:19 - the parentheses where the parameter are
124:22 - defined in the function definition
124:25 - that's the type that's being returned
124:26 - from the function so we need to accept a
124:29 - type error so here when we call this
124:32 - function we need to catch its return
124:34 - value in a variable and it's the error
124:37 - so we'll just call it error and it's
124:39 - type
124:40 - error now we've reached another
124:43 - important checkpoint in go go whenever
124:46 - there's an error expected to potentially
124:49 - return from a function so whenever a go
124:52 - function returns an error it doesn't
124:54 - mean that whenever you call the function
124:56 - an error will be returned it means that
124:59 - there's a potential for an error to be
125:01 - returned so it means that it's possible
125:03 - that when this function gets called an
125:05 - error gets returned but it might not
125:07 - return an error so listen and serve
125:09 - basically it's going to start our server
125:13 - our long running or long living
125:15 - application it's going to run our server
125:17 - and listen to requests coming in but if
125:20 - there's an error with listen and serve
125:22 - then it'll return an error and in that
125:25 - case as the people writing the code we
125:27 - need to handle that error so we need to
125:30 - potentially accept the error so we're
125:34 - assigning the error to this variable so
125:36 - if listen and serve returns an error
125:39 - it's going to be put in this box in this
125:41 - variable but we're not doing anything
125:44 - with that variable right now so even now
125:46 - with catching this error if it happens
125:49 - we're not doing anything with it so we
125:51 - still wouldn't know if there's an error
125:53 - so what we need to do is under this VAR
125:56 - error error equals listen and serve we
125:59 - need to check if that error exists so we
126:02 - say if error not equal nil so if error
126:07 - is not nil so remember I told you what
126:09 - nil is nil means it's like an identifier
126:12 - for nothing so if the error is not
126:14 - nothing meaning if there is an error
126:17 - then we need to do whatever is in these
126:19 - brackets here and in our case if there's
126:21 - an error we're going to use Go's log
126:24 - package another package that we'll
126:25 - import and then there's a function in
126:27 - that package called fatal and you can
126:29 - see here that log automatically gets
126:32 - imported by the IDE and there's a
126:34 - function in that package called fatal
126:36 - and this fatal function is just going to
126:38 - basically print out what the error is
126:41 - then it's going to completely exit the
126:42 - application so we need to pass it the
126:44 - error and this is how error handling is
126:47 - done in go so any function that
126:49 - potentially returns an error we're going
126:52 - to need to check and see if that error
126:55 - gets returned from the function and if
126:57 - it is we're going to need to handle that
126:58 - error in some way now you don't need a
127:01 - deep understanding of this point just
127:03 - yet just know that that's a general
127:05 - overview of how error handling is done
127:07 - and go so for this particular listen and
127:11 - serve function what we're doing is we're
127:13 - running the application continuously and
127:16 - we're just listening for request coming
127:17 - in and if there's no error then we'll
127:19 - never get to this point but if there is
127:21 - an error it'll get caught into this
127:23 - variable and then we'll do whatever code
127:26 - is inside of these brackets now I know
127:29 - that was a lot to understand so I think
127:31 - we need to solidify this knowledge by
127:33 - actually testing this code out and I
127:36 - encourage you if you're following along
127:37 - with this tutorial to be writing out and
127:39 - testing out everything that I'm
127:40 - explaining here because it's one thing
127:42 - to just hear me explain something to you
127:44 - but you're not going to fully grasp and
127:47 - retain the information unless you
127:49 - actually take action and do what I'm
127:52 - doing like follow along with what I'm
127:54 - doing and practice and mess around with
127:56 - things and Tinker like that's how you
127:58 - learn how to code like you don't learn
127:59 - how to code by just listening to
128:01 - somebody talk and explain things to you
128:03 - because it doesn't matter how detailed I
128:05 - am in explaining these things if you're
128:07 - not actually following along and getting
128:09 - a feel for how this stuff works so I
128:11 - just want to put that out there because
128:14 - I don't want you guys to be wasting your
128:16 - time like you really need to follow
128:18 - along and really try to get a feel for
128:20 - these things so let's go head and test
128:22 - this and we're going to try to solidify
128:24 - your understanding of how to handle HTTP
128:27 - requests in go like how to create this
128:30 - API like right now what we're creating
128:32 - is the API that I told you about before
128:35 - the application programming interface
128:37 - this API is used by the front end so
128:40 - let's go ahead and get our hands dirty
128:41 - and try and test this out so before we
128:43 - can test this out we have to install a
128:46 - tool and this tool is going to allow us
128:49 - to act as the front end without actually
128:52 - being the front end and you'll see what
128:54 - I mean once we install the tool so what
128:56 - you want to do is you want to just go
128:58 - ahead and open your
129:08 - browser and just go to Google and search
129:11 - for Postman and you can just select this
129:15 - first option here and we're just going
129:17 - to download the desktop app so I'm using
129:20 - Mac so I'll select the Mac one and I
129:22 - have an apple chip so I'll use the Apple
129:24 - chip one once that's finished installing
129:27 - you can just go ahead and unzip
129:31 - it and after you unzip it you can just
129:34 - move this to the applications folder and
129:37 - we can just go ahead and open up this
129:40 - application called
129:47 - Postman and it looks like mine is a bit
129:50 - broken but I'm just going to hit Skip
129:51 - and go to the app and that looks fine
129:54 - anyways what this tool is going to do is
129:57 - it's going to allow us to send HTTP
130:00 - request the request that I explained to
130:02 - you before to a given address or URL so
130:06 - what we're going to do is we're just
130:07 - going to put the URL inside of this bar
130:11 - here and it's hard to see cuz my app is
130:13 - messing up but we're going to put the
130:15 - URL into here and then we're just going
130:17 - to send the request to our server and
130:21 - our server is actually going to be
130:22 - running on our local machine so actually
130:26 - let me just quickly explain to you what
130:28 - I mean by that cuz that might be a bit
130:29 - confusing now you should recall from the
130:32 - explanation about the server and US
130:36 - sending the request to the server from
130:38 - the front end a diagram that looked
130:40 - something like this so in a real world
130:43 - situation or a situation where our
130:46 - application is actually deployed to a
130:49 - production server requ would come in
130:51 - from the front end wherever it is to our
130:54 - backend server remember this is the
130:56 - request but while we're actually
130:58 - developing as you saw before we were
131:00 - running our front end on our server so
131:04 - if we just make this larger and we can
131:06 - move that so while we're developing our
131:08 - front end's actually running on our
131:11 - server and while we're developing
131:12 - another thing that's running on our
131:14 - server is the server code which is
131:17 - that's that's normal for the server code
131:19 - to run on the server right but this is
131:21 - is what it looks like when we're
131:22 - developing the front end's running on
131:24 - the server and our server codes running
131:26 - on the server so when we're testing in
131:29 - development we want to send a request
131:32 - from the front end that's running on our
131:34 - server to our server code or our API
131:38 - that's running on our server the go
131:40 - application so this is the go
131:42 - application which is different from what
131:44 - we wouldd be doing if this were actually
131:47 - deployed to production in production the
131:49 - front end wouldn't be running on our
131:52 - backend server it would just be running
131:54 - somewhere else and it would be sending
131:56 - requests over the Internet to the server
131:58 - but while we're developing it's running
132:01 - on our server so that means that the
132:03 - address that the front end needs to send
132:06 - requests to is the same address that
132:09 - it's running on it's the same server but
132:11 - that's just because we're developing
132:12 - this application on our local machine in
132:15 - this case the server is our local
132:17 - machine but in real life we wouldn't run
132:20 - a back-end server from our local machine
132:24 - but while we're developing we use our
132:26 - local machine your laptop or PC or
132:29 - whatever to host both the server code
132:32 - and the front end application just so
132:33 - you can have an easy development flow so
132:36 - if you understand that your local
132:38 - machine is actually the server in this
132:40 - case while we're developing then you
132:42 - also understand that your local machine
132:44 - has an address or if you don't
132:46 - understand that I'm explaining that to
132:48 - you now so your local machine it has an
132:50 - ADD address it has a local IP address
132:54 - which is an internal IP address and this
132:57 - IP address is just called Local Host but
133:01 - that's just a name for an actual IP
133:03 - address like under the hood your local
133:06 - machine has an internal IP address that
133:09 - is
133:10 - 127.0.0.1 but this IP address can be
133:14 - referenced by just using the name Local
133:17 - Host within your system because there's
133:19 - actually a file that Maps this IP
133:21 - address to the name Local Host so
133:24 - they're actually interchangeable you can
133:26 - use this IP address or the name Local
133:28 - Host as the address if you want to
133:31 - access your local systems internal IP
133:35 - address so that means that we have this
133:36 - internal IP address and both our
133:38 - frontend and our server are using the
133:41 - same IP address but they're using
133:44 - different ports that's why we're able to
133:45 - run both of these on the same system or
133:49 - server or computer because they're
133:51 - running on different ports so what's
133:53 - essentially going to happen is we're
133:55 - going to run our server then we're going
133:57 - to run our front end and our server is
134:00 - going to be running on one port which is
134:05 - 4242 and our front end is going to run
134:07 - on some other Port but in order for our
134:09 - front end to send requests to our server
134:12 - code our go program it's just going to
134:15 - need to send a request to Local Host at
134:17 - this port so it'll send the request to
134:21 - Local Host 4242 and sorry if that's too
134:24 - small using the endpoint so that's what
134:26 - this Local Host means and when we run
134:29 - the server I'll show you a little bit
134:31 - more of what I mean about this but this
134:34 - is essentially the setup that you'll
134:36 - usually use like for your development
134:38 - flow when you're developing an
134:40 - application or an API you'll usually
134:42 - have a setup similar to this you'll be
134:44 - running everything from your local
134:45 - machine even the server code but when
134:48 - you actually deploy to a produ uction
134:51 - server the code gets put onto another
134:55 - server like maybe like some AWS server
134:57 - or Google server something like that the
135:00 - actual backend isn't going to run from
135:01 - your local machine your local machine
135:03 - isn't powerful enough to handle the type
135:06 - of traffic that go like that hits a
135:08 - typical like web application that has
135:10 - any level of popularity so this is just
135:13 - how we're developing we're developing on
135:15 - our local machine and this is how it's
135:17 - working so I hope that makes sense okay
135:20 - so I actually ended up needing to
135:23 - install an older version of Postman
135:25 - because the newer version was just
135:27 - wasn't working for me it was just broken
135:29 - so I installed an older one so if you
135:32 - need to do the same thing you can just
135:35 - go to Google and type in download older
135:39 - version of Postman and then I just
135:42 - selected this one and just selected this
135:44 - link provided here and then I just went
135:48 - down to downloading Postman V8 and I
135:51 - just downloaded the V8 one for 64-bit
135:55 - Mac OS because it's still possible to
135:58 - run it on this M1 Mac using that Rosetta
136:01 - thing I believe so yeah that's the one
136:03 - that I'm using if the newer version
136:05 - works for you then you don't need to do
136:06 - this part but if the newer version is
136:09 - breaking for you like it was for me then
136:10 - you can go ahead and download an older
136:12 - version and I'm just going to dismiss
136:14 - this update available because the update
136:17 - doesn't work for me and yeah it's pretty
136:20 - much the same thing like we need to put
136:23 - the URL or the address to the backend
136:26 - server in this uh text input here and
136:30 - then we'll just send the request so
136:33 - remember with this we're emulating the
136:35 - front end like we'll be sending the same
136:37 - request that the front-end is going to
136:38 - be sending to our backend server this
136:41 - just gives us an easy way to trigger the
136:44 - requests getting sent to the backend to
136:46 - test our backend so let's go ahead and
136:48 - open goand up again and let let's just
136:51 - continue where we left off so before we
136:54 - go ahead and test this endpoint like the
136:57 - calling of this endpoint using Postman
136:59 - there are a couple of things that I
137:00 - still want to go over or I want to
137:02 - elaborate on some things that we already
137:04 - talked about so first of all I want to
137:07 - elaborate a bit more on error handling
137:10 - and go because I think there's still
137:11 - some things you might be confused about
137:13 - even after the before explanation so the
137:16 - first thing I want to elaborate on is
137:19 - this error type so this error type is a
137:23 - built-in type provided by go so just
137:26 - like string and bull and int go provides
137:30 - this error type as well and functions
137:33 - that return errors they return this
137:36 - error type so I want to explore that a
137:39 - bit more so let's just create a function
137:41 - here really quick so we'll do Funk
137:44 - returns error and remember to return
137:47 - something we have to put the return type
137:49 - here so this function is going to return
137:53 - this error type now this function either
137:55 - has to return an error or it has to
137:58 - return nil so for example if we do
138:01 - return nil you see that we don't get any
138:04 - errors and if we do return some string
138:08 - you see that we do get an error so it
138:10 - has to either return an error or nil and
138:12 - we can actually create our own errors
138:14 - using a package from go standard Library
138:17 - called errors and then we can use a
138:19 - function from that package P called new
138:22 - and we can just say an error occurred we
138:25 - just pass a string into this function
138:28 - and as you can see here we're getting no
138:30 - error because this new function returns
138:33 - an error here so new returns an error
138:36 - that formats as the given text so it's
138:39 - basically changing our string into an
138:41 - error so what we can do is we can go
138:45 - ahead and add a function parameter which
138:48 - we'll just call password and and it'll
138:51 - be a string and what we can do is we can
138:54 - have the caller of the function pass in
138:56 - a password and if the password is
139:00 - correct we can return nil so no error
139:04 - and if the password is incorrect we can
139:06 - return this error so we'll just say
139:10 - VAR secret password string equals super
139:16 - secret password and then we'll say if
139:19 - password equals
139:21 - secret password return nil else return
139:27 - error invalid password so what this is
139:30 - doing is we're going to have the caller
139:32 - pass in some string as a password and in
139:36 - the function we're going to define the
139:38 - actual password right so this we're
139:41 - defining the actual password then here
139:44 - we're checking to see if the password
139:46 - passed in by the caller of the function
139:49 - here is equal to our secret password and
139:53 - if it is if it's equal then we'll return
139:56 - nil there's no error so we'll just
139:58 - return nil else if the password is not
140:00 - equal we're going to return this error
140:03 - here invalid password so if we go back
140:06 - into Main and again we're just going to
140:09 - comment this out and we call returns
140:12 - error and we pass in wrong password now
140:16 - in this case we're passing the wrong
140:18 - password so an error is going to be
140:20 - returned by the function right but right
140:24 - now we're not catching this error so I'm
140:26 - sure you can guess what's going to
140:27 - happen if we run this function then so
140:30 - if we do go run main.go you see nothing
140:33 - happens so an error actually was
140:36 - returned from our function but we have
140:38 - no way of seeing it as the person
140:40 - developing this code or as the person
140:42 - debugging this code we'll have no way of
140:45 - knowing what happened the application is
140:47 - just not working but we don't know
140:49 - what's happening because we're not C
140:50 - catching the error and we're not
140:52 - handling the error so in go it's your
140:55 - responsibility to handle the errors so
140:58 - if you're calling a function that's
140:59 - going to return an error you need to
141:02 - catch the error and you need to catch it
141:04 - in a variable so we'll do VAR and the
141:07 - conventional name variable name for
141:09 - errors in go is er RR for error and then
141:13 - the type is error and we'll set it equal
141:15 - to returns error right and you're going
141:18 - to see the same pattern a lot you're
141:20 - just going to always see this same
141:22 - pattern here if error not equal nil then
141:26 - do something so in this case we're not
141:28 - going to do log fatal we're just going
141:30 - to print the error so here we're
141:33 - catching the error that gets returned
141:36 - from this returns error function into
141:40 - this variable called error err which is
141:43 - the conventional name that we use in go
141:45 - when we catch errors and then we're
141:47 - checking if that error is nil cuz
141:49 - remember if there's no error we'll just
141:52 - return nil right if if the password is
141:54 - correct we just return nil but if the
141:56 - password's incorrect we return the error
141:58 - so that means that we need to check if
142:00 - the error is not nil and if it's not nil
142:03 - it means the password was incorrect
142:05 - which means we received the error and
142:07 - that's when we're going to print it so
142:09 - let's go to the terminal here again and
142:11 - do G run main.go and now you can see
142:15 - invalid password gets printed to the
142:17 - screen because we actually handled the
142:19 - error that time and we're just printing
142:21 - it to the screen but there in in a usual
142:24 - scenario you'll actually do something to
142:27 - handle the error depending on the
142:28 - functionality of your application but
142:30 - you don't need to worry about that part
142:31 - right now just know that we need to
142:34 - catch and handle the errors otherwise
142:37 - they'll just be hidden from us and we
142:39 - might be writing bugs into our code or
142:41 - something and we have no idea what's
142:42 - going on so that's what is meant when
142:44 - we're doing if error not equals nil even
142:47 - up here for our call to this listen and
142:50 - serve function like the function will
142:53 - either actually return nil or return an
142:56 - error but in the case for the listen and
142:59 - serve function it's actually a little
143:01 - bit different so I'll show you what that
143:03 - what what's happening here as well so
143:05 - first let's go ahead and delete this and
143:07 - we can delete this returns error example
143:10 - function and we can remove the comments
143:13 - from here now the way listen and serve
143:16 - works like the way the error handling is
143:18 - happening here is a bit different like
143:21 - of course the same Concepts apply like
143:23 - we're going to catch the eror and if
143:25 - it's not nil this in this case we're
143:27 - going to completely shut down the
143:29 - application but let me explain what I
143:31 - mean by that so listen and serve like I
143:34 - like I told you before is what's
143:36 - allowing us to create a longlived
143:38 - application like the application's going
143:40 - to run continuously so in the case of
143:43 - listen and serve nothing should actually
143:46 - ever be returned it should always just
143:48 - run continuously so if any anything is
143:51 - ever returned from listen and serve it
143:53 - means that there was some issue that's
143:55 - why here we're using log. fatal cuz log.
143:58 - fatal will completely exit the
144:00 - application so in the example before we
144:02 - were just printing out the error right
144:04 - we weren't like completely shutting down
144:05 - the application when we received the
144:07 - error but in this case an error is
144:10 - actually fatal to the application like
144:12 - if if listen and serve isn't working our
144:14 - application isn't working so we need to
144:16 - just completely close the application so
144:18 - the way listen and serve works is it
144:21 - won't return anything it'll just keep
144:22 - running and if something happens then it
144:25 - Returns the error so in our case if
144:27 - something happens we'll catch that error
144:30 - and shut down the application and print
144:32 - the error to the screen basically but in
144:34 - our code we should never actually reach
144:37 - this line we should just the application
144:39 - should just be running here and we
144:41 - should never actually reach this line
144:43 - unless something bad happens and let me
144:45 - show you what I mean so if we do G run
144:49 - main.go
144:50 - you see that the application is just
144:52 - running continuously like you see
144:55 - nothing's being printed but our our
144:57 - terminal prompt is never coming up again
145:00 - cuz the application is just running
145:01 - right now so the program's just running
145:04 - right so in order for us to stop this
145:06 - program right now we'd have to press
145:07 - contrl C and as you can see now we can
145:10 - input commands into our terminal so when
145:13 - we actually run this server code the
145:15 - server is just supposed to run
145:17 - continuously it's not supposed to stop
145:19 - it's supposed to keep running and
145:21 - actually let's change the name actually
145:23 - we can change the name of this file so
145:25 - it makes more sense let's change this
145:27 - from main.go let's hit refactor rename
145:31 - and let's rename it to server. go and
145:33 - then hit refactor so now our file is
145:36 - called server. go because that's
145:38 - actually what it is this is the server
145:39 - code like when this code is deployed to
145:42 - some production server it'll run on the
145:45 - server so we do run G run server. go on
145:49 - the server and then now our server code
145:51 - is running like it's it's going to it's
145:53 - a longlived application it just
145:54 - continues to run and it's just while
145:57 - it's running it can listen to request
145:59 - from the front end it can listen to and
146:02 - receive the request and handle the
146:04 - requests so right now as this servers is
146:06 - running we're the the code is on this
146:09 - line of code here it's just running
146:11 - listen and serve it's just running it
146:13 - continuously now if there's an error
146:16 - then an error will be returned from this
146:18 - and the the server will stop running so
146:21 - let's try and see what that looks like
146:24 - so we'll press contrl C here to stop the
146:26 - server again and let's move this out of
146:28 - the way so let's see what happens if we
146:31 - put some invalid address here so let's
146:35 - just change this to
146:38 - invalid and then let's go back to our
146:41 - terminal and try to run the server now
146:44 - and let's enlarge this here so now as
146:47 - you can see we ran the server and it
146:49 - tried to listen on the address we
146:52 - provided but the address we provided was
146:54 - just a string that says invalid there's
146:57 - no Port so the port is missing in the
146:59 - address so in that case the error got
147:03 - returned and it got put into this
147:05 - variable and then we checked to see if
147:08 - the error is nil the error wasn't nil so
147:12 - we logged the error and this is the
147:14 - error that got logged so we can actually
147:18 - comment this out and we can just do
147:20 - format. print
147:22 - line something bad happened and then
147:26 - let's try and run this again and now you
147:28 - can see it prints something bad happened
147:31 - because when the error wasn't nil we
147:34 - just logged our own message but before
147:36 - we were logging the error that was
147:38 - actually returned but you'll also notice
147:40 - that we didn't use log. fatal we just
147:42 - used print line but the application
147:44 - still ended but that's because if this
147:47 - function returns an error then it's not
147:49 - going to run un continuous anymore like
147:51 - if it's returning an error it means it's
147:53 - stopped so then we arrived at this line
147:56 - and we printed it and then this block of
147:59 - code was finished and then the function
148:01 - is finished but yeah that's how the
148:03 - error handling is working with this
148:05 - listen and serve with this longlived
148:08 - application and that's how air handling
148:10 - in go Works in general so I hope that
148:13 - makes sense to you because we'll be
148:15 - continuing to use this error handling
148:18 - throughout the rest of this tutorial so
148:20 - anyways we can go ahead and start
148:23 - testing out our endpoint now actually
148:26 - wait there's one more thing that I
148:27 - wanted to go over so it's quite simple
148:31 - actually so this handle create payment
148:33 - intent function so if you remember when
148:38 - I first introduced functions to you I
148:40 - just I explained how the definition of
148:43 - the function is this here like this is
148:45 - where we're creating the function right
148:47 - and then I explained that to actually
148:49 - call or invoke the function you have to
148:51 - use the the parentheses right and in
148:55 - this case we need to pass in parameters
148:58 - or arguments here so we're getting an
149:00 - error under the parentheses but the
149:03 - point is invoking or calling the
149:05 - function you need to use the parentheses
149:07 - right but you might notice here we're
149:09 - not using any parenthesis we're just
149:12 - passing the function and this is because
149:15 - we're not calling the function here like
149:17 - we're not invoking the function here
149:19 - we're just passing it to this handle
149:22 - Funk function and this handle Funk
149:24 - function is going to call the function
149:26 - for us and actually to explain what I
149:29 - mean by that I have to actually show you
149:32 - so let's go ahead and create two
149:36 - functions here so we're going to do Funk
149:39 - function one and function one is going
149:42 - to take in function two as an argument
149:45 - so we're we're going to create a
149:47 - parameter called function two which is
149:49 - going to be a function that takes in no
149:52 - arguments so it's just going to be a
149:54 - function that takes in no no parameters
149:57 - and when Function One receives function
149:59 - two it's going to invoke function two so
150:03 - we're going to actually use the
150:04 - parenthesis here because function one is
150:07 - actually going to call this function
150:09 - two and then we'll create function two
150:13 - and just keep in mind that this function
150:15 - two doesn't actually need to be called
150:17 - function two like function two is the
150:19 - name that we're calling it within
150:21 - function one but we can pass any
150:24 - function that fulfills this type a
150:27 - function with no parameters into
150:29 - function one and it'll be called
150:31 - function two within this function so
150:34 - actually to show that let me just name
150:36 - this something other than function 2 so
150:39 - we'll do
150:40 - Funk another function and it takes no
150:43 - parameters and what this function does
150:46 - is it prints another function was is
150:51 - called so now inside of here once again
150:54 - let's comment this out we're going to
150:57 - call function one so we're going to call
151:00 - function one but Function One expects us
151:02 - to pass in another function so we have
151:05 - to pass in the other function that we
151:07 - created which is called another function
151:10 - so we'll pass that in another function
151:13 - but as you can see when we're passing it
151:14 - in we're not invoking it like that's
151:17 - going to cause an error we're not
151:18 - invoking it because we're we're not the
151:20 - ones who who are going to call it it's
151:22 - going to get called inside of function
151:24 - one so we're just going to pass in the
151:26 - function so we're actually we're
151:28 - invoking function one and we need to
151:30 - pass in another function as an argument
151:32 - so we're going to invoke function one
151:34 - and as you can see function one's
151:36 - definition is here and what it's going
151:38 - to do is it's going to actually invoke
151:40 - function two and function two we're
151:42 - passing in another function as function
151:45 - two here so then this is going to get
151:47 - invoked which means this is going to get
151:49 - printed to the screen so if we go to the
151:52 - terminal here and let's clear and do G
151:56 - run server. go and as you can see
151:59 - another Funk was called because in go
152:02 - you're able to pass actual functions as
152:05 - arguments to other functions and in
152:08 - programming this is called a language
152:10 - that supports first class functions so
152:13 - the fact that we're able to pass
152:15 - functions as arguments to other
152:17 - functions means that the go programming
152:19 - language supports first class functions
152:21 - but the reason I explained that is
152:23 - because I want you to understand what's
152:25 - actually happening
152:27 - here we're passing in this function here
152:30 - right but we're not invoking it but this
152:33 - handle Funk function that we're passing
152:36 - this function to it's going to invoke
152:39 - this function for us only if it receives
152:42 - a request to this end point so that's
152:45 - exactly what's happening with this
152:46 - handle Funk function so that should be
152:49 - clear to you at at this point so let's
152:51 - go ahead and delete that and now finally
152:54 - we can get into testing out the actual
152:59 - sending of requests to our server so
153:03 - remember whenever this handle create
153:05 - payment intent is invoked we're just
153:08 - going to print endpoint called and this
153:10 - will only be invoked if our server
153:14 - receives a request to this create
153:16 - payment intent then this gets invoked so
153:19 - handle function
153:20 - is basically mapping this endpoint to
153:23 - the calling of this function and when we
153:26 - do listen and serve the HTTP package
153:29 - internally it knows which endpoints
153:32 - we're listening on because we Define
153:34 - them here so we're defining this this
153:36 - endpoint here with this functionality
153:39 - and internally this HTTP listen and
153:42 - serve it knows about this line of code
153:45 - that we have here where we're assigning
153:47 - this endpoint to this function so
153:50 - when we call our end point from our
153:54 - front end or in our case from Postman
153:57 - cuz we're going to use Postman to
153:58 - emulate the front end we're not going to
154:00 - call it from the actual front end the
154:02 - post Postman is essentially like instead
154:04 - of sending the request from the front
154:06 - end we're just going to send it from
154:07 - Postman and it's easier to test that way
154:10 - but later on we'll also test it with the
154:12 - actual front end so you'll be able to
154:14 - see it done both ways but for now we're
154:16 - going to test it with Postman so we're
154:18 - going to run our server and we're going
154:20 - to send a request from Postman to this
154:22 - endpoint and what's expected to happen
154:24 - is this function should be called which
154:27 - prints out endpoint called and remember
154:30 - the address that's being listened on is
154:32 - our local host which I explained to you
154:35 - and actually you can also use 127
154:39 - 0.0.1 that's also the same as Local Host
154:43 - as I explained to you before so if we
154:44 - did this G run server. go you see we get
154:48 - no error it's running on Local Host
154:50 - which is this IP address which is your
154:53 - internal IP address it's actually called
154:56 - the loop back address but like if you
154:58 - want to dig deeper into that then you
154:59 - can go ahead but for the purposes of
155:01 - this video the explanation I gave you
155:03 - before of what the Local Host IP address
155:06 - is that's good enough so let's stick
155:10 - with calling it Local Host though just
155:12 - because it's easier so this is our
155:14 - address that we're listening on and this
155:16 - is the port that we're listening on so
155:17 - on Postman we should be able to send the
155:19 - request to this address this port this
155:22 - endpoint so let's try that but first we
155:24 - have to run the server so let's clear
155:27 - and do Go Runs server. go and our
155:30 - server's running actually to make it
155:33 - easier to see that our server is running
155:35 - let's contrl C on that and right before
155:38 - we call listen and serve let's just
155:41 - log. print line and we'll just print out
155:46 - listening on Local Host port 4242 so
155:51 - whenever we run the server right before
155:54 - it starts listening it's going to print
155:56 - that it's listening so we can actually
155:58 - see that the server is running so we'll
156:01 - clear this and do G run server. go and
156:05 - now you see it gives the date and the
156:07 - time that's because this log package's
156:09 - print line prints the date and the time
156:13 - and then it says our message listening
156:14 - on Local Host
156:16 - 4242 and actually to make it look more
156:19 - like it's listening we could put dot dot
156:21 - dot
156:22 - here so now we have listening on Local
156:25 - Host
156:26 - 4242 so now we should be able to go to
156:28 - postman and actually send a request to
156:31 - this address at this end point and then
156:34 - in the terminal here it should print
156:36 - endpoint called so let's try that so
156:39 - let's go and open
156:42 - Postman and we'll just do local host
156:47 - 4242 slash
156:49 - create payment intent and let's try and
156:53 - send this now down here you see that it
156:57 - says that the response that we got was
156:59 - 200 okay and 200 just means okay
157:02 - essentially it's the standard response
157:04 - for a successful HTTP request so 200 is
157:07 - the standard response when the request
157:09 - was successful so if we go back into
157:13 - goand we should see that endpoint was
157:15 - called now what do you think is going to
157:18 - happen if we try to call an endpoint
157:20 - that doesn't exist on our server right
157:22 - now we only have create payment intent
157:25 - right so what if we call some other
157:27 - endpoint that we don't have so maybe
157:29 - let's try and call the health endpoint
157:31 - that we never made and then we hit send
157:33 - you can see now the response is 404 not
157:36 - found now 404 the requested resource
157:40 - could not be found that's because we
157:42 - don't have the endpoint or the interface
157:45 - for the health endpoint on our server
157:48 - code so the response is that resource
157:50 - isn't found that endpoint is not
157:53 - found but we can go ahead and add it
157:56 - here so let's go ahead and add another
157:59 - handle Funk and we'll call this one
158:02 - Health and we'll name the function
158:05 - handle health and now we need to create
158:08 - the function handle health so we can
158:10 - just copy this function and we'll change
158:12 - the name to handle health and we'll
158:15 - change this to okay and then we'll need
158:19 - to restart our server so we'll do go run
158:23 - server. go and then let's go ahead and
158:26 - try and send a request to that endpoint
158:28 - again and now you can see we get 200
158:30 - status okay so if we go back here you
158:33 - can see okay gets printed to the screen
158:36 - but that actually doesn't tell the
158:38 - sender of the request anything because
158:41 - we're printing this to the serers
158:43 - terminal like the the sender the person
158:46 - sending the request to our server
158:48 - doesn't get this message but just like
158:51 - it's possible for the sender to send us
158:53 - a request it's possible for the server
158:56 - to send the sender a response so now
159:00 - that's what we need to go over we need
159:01 - to go over how to send a response back
159:04 - to the person sending the request so
159:06 - let's go ahead and contrl c and stop our
159:09 - server and let's write some code in our
159:12 - health endpoint to send a response to
159:15 - the front end or the person calling our
159:18 - server letting them know that our server
159:20 - is running and up now in order to
159:22 - explain how we can send a response to
159:24 - whoever is sending the request to our
159:26 - server I need to introduce another
159:29 - concept to you so we're going to come
159:31 - back to this health handle health
159:33 - function and for now let's just comment
159:36 - everything out in main so I need to
159:39 - introduce the concept of storing a list
159:43 - of values in memory so so far we've
159:46 - learned about storing single values in
159:48 - memory as variables so for example maybe
159:51 - we have VAR name String equals James so
159:55 - that's how we store a a single string
159:58 - value a single name but what if we want
160:00 - to store multiple names in the same
160:04 - variable so instead of just having name
160:06 - what if we want it to have a variable
160:08 - names plural well in that case we need
160:11 - to use what is called a slice and in go
160:15 - a slice is a list of items essentially
160:19 - and to declare a slice we would use
160:22 - these two brackets here so we'd first
160:25 - put the two brackets and then right
160:27 - after those brackets we'd put the type
160:30 - of item we want to store in the slice so
160:33 - for example if we want to store multiple
160:37 - names string names then we'd put these
160:40 - two brackets slice of string essentially
160:43 - and what that looks like is we'll set it
160:46 - equal to and essentially what we're
160:48 - trying to create is something that looks
160:50 - like this so just a list of names
160:53 - enclosed in these brackets right but you
160:55 - notice we have an error here and that's
160:57 - because the syntax in go for actually
161:00 - creating a structure like this is
161:03 - actually a bit confusing to be honest so
161:05 - let me show you how to actually create a
161:09 - list that looks like this in go so we're
161:12 - trying to create names right and it's a
161:16 - slice or a list of string value use as
161:19 - the names so in go we have to actually
161:22 - put the type like so and then here we
161:26 - have to put these curly brackets and now
161:30 - as you can see we no longer get an eror
161:32 - here so we're essentially creating a
161:35 - list of names and the names that are
161:37 - included in the list are these names so
161:40 - if we were to print names and we can
161:44 - just delete this single name and open
161:46 - our terminal and do go run on server. go
161:50 - you'd see that it prints out this list
161:53 - of names James Bill and Jack and these
161:57 - lists are actually zero indexed so what
162:01 - I mean by that is each one of these
162:04 - names can be accessed using an index and
162:08 - an index is just the count from zero to
162:13 - the last name so this list here or this
162:17 - slice has three names in it right so the
162:20 - length of this slice is three there's
162:22 - three names in the slice but the index
162:24 - starts from zero so actually Jack here
162:28 - isn't the third index it's the second
162:30 - because it would be 0 1 2 so if we want
162:34 - to access Jack we can print names to the
162:37 - index two and then we go to terminal G
162:41 - run server. go and as you can see now it
162:44 - prints the single name Jack so that
162:46 - means that if we want to get just the
162:49 - individual name the first the first name
162:52 - in the list it would have to be zero
162:54 - because they're zero index remember 0 1
162:56 - 2 it's not 1 2 3 it's 0 one 2 and this
163:00 - applies to any programming language the
163:03 - lists are zero indexed so if we want to
163:07 - print the name James we have to print
163:10 - name at index0 and as you can see here
163:13 - we just use these brackets to access a
163:15 - specific index of names so we'll do go
163:18 - run server. go and you can see now it
163:22 - prints James and as you can probably
163:24 - guess Bill the index would be one so if
163:26 - we want to print Bill we will change
163:28 - this index here to one so that is called
163:31 - a slice in go which is just a list of
163:34 - values now this slice in particular
163:36 - contains strings right but what if we
163:39 - wanted to contain something else so we
163:41 - can change the type to for example int
163:45 - and of course we have to change this to
163:47 - int but now you see we're getting is
163:49 - here because these aren't ins we can't
163:51 - store strings inside of a slice of int
163:54 - so we need to change all of these to
163:57 - inss so we can do 1 2 3 and actually to
164:01 - make it less confusing let's just do 50
164:04 - 60 and 70 and if we print names zero
164:08 - it's going to print
164:13 - 50 so as you can see it prints 50 so
164:17 - it's the same it's the same concept it's
164:19 - just we're changing the type so in go
164:22 - you have to be specific like you have to
164:24 - say what type for everything that you
164:27 - declare so that means that go is a type
164:30 - safe language but there are other
164:31 - programming languages out there that are
164:33 - dynamically typed where you don't have
164:36 - to specify the types of variables but in
164:39 - my opinion that's just a recipe for
164:41 - disaster so it's good to have the
164:44 - strictness of the type safety in my
164:46 - opinion so anyways that is is a slice
164:49 - and go and we're going to need to make
164:51 - use of that when we're actually
164:53 - responding to whoever sends the request
164:55 - to our server so let me show you what I
164:58 - mean so let's go ahead and delete this
165:00 - and let's remove the comments from our
165:04 - main code and let's go back down here to
165:07 - our handle health function so here's
165:10 - where we actually realize what this
165:13 - response writer and request is so
165:16 - remember the functions that we passed to
165:19 - handle Funk they need to take in as
165:24 - parameters the response writer and the
165:26 - request types which are provided by the
165:28 - HTTP package and the reason they need to
165:31 - do that is because these types are the
165:34 - types that we need to use to both
165:36 - respond to the requester and read the
165:39 - request from the requester for example
165:41 - when we're responding to whoever sends
165:43 - the request to our server we're going to
165:45 - use this response writer which we have
165:48 - as w here so w just stands for writer
165:51 - it's just a short way to do it like you
165:53 - could if you wanted to just put writer
165:55 - here instead of w and here you could put
166:00 - request and maybe let's just do that to
166:03 - be more verbose so you can kind of
166:07 - understand what we're using these
166:09 - variables for or what we're using these
166:11 - parameters for so we're not going to
166:12 - print okay anymore so when the requestor
166:16 - sends a request to the health inpoint we
166:18 - want want to send them a response that
166:20 - essentially tells them that the server
166:22 - is up and running and the response is
166:25 - going to be a slice of btes now it's
166:30 - going to look super confusing right now
166:32 - when I write this out but don't worry
166:33 - I'm going to explain it so just bear
166:36 - with me so first we're going to create a
166:38 - variable and we're going to call it
166:40 - response and the type of this variable
166:43 - is going to be a slice of bite and we
166:47 - have an error here because I forgot to
166:49 - write VAR so remember you have to have
166:51 - VAR when you're actually assigning
166:53 - values to these variables actually
166:55 - there's another way to do it where you
166:57 - don't need to use VAR which I'll show
166:58 - you in a second but first let me just
167:00 - show you this so we're going to create a
167:03 - slice the same as the one I just showed
167:05 - you but the type of the values inside of
167:09 - the slice are going to be bite now bite
167:12 - I haven't introduced this type to you
167:13 - yet so I'm introducing it now
167:16 - essentially I'm going to tell you what
167:17 - it is now but first let's let's finish
167:19 - writing this out so we're going to
167:20 - create a variable called response and
167:22 - it's going to be a slice of bite and
167:24 - we're going to set it equal to slice
167:27 - byte parentheses server is up and
167:31 - running now let me explain this part so
167:35 - this syntax here where we're using
167:37 - parentheses here after the type this is
167:40 - the Syntax for converting one type into
167:43 - another type now let me show you what I
167:45 - mean by that if we have VAR sum number
167:50 - type int and we set it equal to 22 and
167:53 - then we do string parentheses and then
167:57 - put some number in there and we set this
168:00 - to VAR number as string string equals
168:05 - here we're converting some number which
168:08 - is an integer into a string so if we
168:11 - were to print number as string it would
168:14 - look like this it'd be a string version
168:17 - of this integer because since we're
168:19 - using the type plus the parentheses
168:22 - after and we're putting the number in
168:23 - there we're converting this number which
168:26 - is an integer into a string here and
168:28 - that's the same thing we're doing here
168:31 - we're converting this string that says
168:34 - server is up and running into a slice of
168:39 - bytes now what a bite is I have to
168:42 - explain what a bite is so actually let
168:45 - me cut this from here and let me put
168:47 - this in Main and once again comment out
168:50 - our main code for now because it's
168:52 - important that you understand this and
168:54 - then let's just do let's let's let's
168:57 - assign this string here to a variable to
169:00 - make it clear that it's a string so
169:01 - we'll do VAR response string string
169:05 - equals server is up and running and then
169:08 - we'll change what gets passed into here
169:12 - to response string so now we're creating
169:16 - the response string variable here which
169:19 - is this string and then we're putting it
169:21 - in here which is going to convert it to
169:24 - a slice of bite and then let's format
169:28 - print line response and let's open our
169:31 - terminal and go run server. go now as
169:37 - you see here it's printing out this list
169:40 - of numbers right and this might be quite
169:42 - confusing to you but let me explain to
169:44 - you what this is so each of these
169:47 - numbers is a bite because remember this
169:50 - is a slice of bite and a bite is just a
169:54 - utf8 encoding now that's going to sound
169:57 - confusing right now but I'm just going
169:58 - to show you let me just show you what
170:00 - that is so we can go to
170:04 - Google and we can type in
170:08 - utf8
170:09 - chart and then we can go here and select
170:12 - this utf8 code page and we can go down
170:15 - here and we'll see this chart here right
170:19 - and we can go back to our editor and we
170:24 - can see this bite here is number 83
170:27 - right so keep 83 in mind now in this
170:30 - chart we can search for the number 83 so
170:33 - here 83 so the decimal value 83 is
170:39 - equivalent to all of these different
170:41 - values right so in HEX 83 is equivalent
170:45 - to this in utf8 HEX 83 is equival
170:48 - equalent to 53 and the character that
170:51 - it's equivalent to is a capital S so the
170:54 - Latin capital letter s now it's the 83
170:58 - is equivalent to the Latin capital
171:00 - letter S and if we go here and we see
171:02 - this string here the first letter of the
171:05 - string is the capital letter s so that
171:08 - means that each one of these characters
171:11 - is a bite and that's including the space
171:14 - here so if we do if we count it so 1 2 3
171:19 - 4 5 6 7 so the seventh bite in here 1 2
171:24 - 3 4 5 6 7 32 should map to a space so if
171:29 - we go back to Chrome and we go for 32 so
171:33 - 32 here the decimal value 32 you can see
171:36 - here it's space it's the character space
171:40 - so that's all a bite is a bite is just
171:44 - the what it maps to the decimal value of
171:47 - the character
171:49 - so what we're doing here is we're
171:52 - converting this string into a slice of
171:56 - bittes so it's taking every character in
171:59 - this string and putting it into this
172:01 - list of bytes as its bite value so if
172:04 - you literally went through each one of
172:06 - these letters and the spaces included
172:09 - and even the punctuation included every
172:11 - character in this string if you went
172:13 - through everyone and translated it using
172:16 - that chart this is the list you would
172:17 - get and that's what we're we're doing
172:18 - we're converting the string into a slice
172:22 - of these bytes here and that's because
172:25 - when we send the response over the wire
172:28 - this is how we have to send it and when
172:30 - the requestor receives the response
172:32 - they're going to be able to on their end
172:35 - translate this stuff back to something
172:37 - that's human readable but you don't need
172:39 - to know the details about that you just
172:40 - need to know that when we send the
172:42 - response in go we need to send it as a
172:46 - slice of bites so I hope that makes
172:48 - makes sense so now you should know what
172:51 - we're doing here we're converting the
172:53 - string that we want the receiver to read
172:56 - into a slice of bite and I just
172:59 - explained what bytes are so now we can
173:01 - move this stuff back to where we got it
173:04 - from our handle health
173:08 - function and don't forget to remove the
173:10 - comments from your main code so now we
173:13 - have the response that we want to send
173:16 - to the person sending the request to our
173:18 - server to check the health so we want to
173:21 - send them the server is up and running
173:23 - so now to send the response to them all
173:26 - we have to do is take our writer which
173:29 - is this variable here that that HTTP
173:33 - package provides for us we take the
173:35 - writer and we do the function write and
173:37 - if we hover over this function you see
173:39 - that WR takes a slice of bite and it
173:42 - returns an integer and an error now we
173:46 - don't need to worry about this integer
173:48 - return value Val but we do need to check
173:50 - the error cuz I remember because
173:51 - remember I told you in go we need to
173:53 - we're responsible for handling errors on
173:55 - our own so if an error gets returned we
173:57 - do need to handle it so since this right
174:00 - function takes a slice of bite we can
174:03 - just pass in this response that we just
174:05 - created up here because it's a slice of
174:07 - bite but we need to handle the error and
174:09 - ignore this integer so to ignore the
174:13 - integer so in go okay so here's a New
174:16 - Concept so in go go you can receive
174:20 - multiple different values in a response
174:23 - from a function so like for example if
174:26 - we created a function here called
174:29 - returns multiple here we could return
174:33 - multiple things we could return a string
174:35 - an INT an error so in this case we want
174:40 - this this function can return this
174:41 - function will return three things right
174:43 - three values so return string and int
174:48 - and let's not do error cuz I don't feel
174:49 - like importing the error package let's
174:51 - just do bull and a bull so this function
174:54 - is returning three separate values right
174:57 - so that means that when we store the
174:59 - response from this function in a
175:01 - variable we have to store three
175:03 - different values so if we go here and we
175:05 - try to do it with just one value so
175:07 - let's do VAR something string
175:11 - equals returns multiple now you see if
175:14 - we do this we get an error it says
175:16 - assignment count mismatch one we only
175:19 - have one variable that we're assigning a
175:22 - value to but it expects three cuz you
175:24 - can see here Funk returns multiple
175:26 - returns string int bull but we're only
175:28 - catching a string so here we need to
175:31 - catch three values but to catch these
175:33 - three values in a clean way I need to
175:35 - teach you a new way of actually
175:38 - assigning values to variables so to
175:41 - catch all three of these we can do
175:45 - this now you'll notice some new syntax
175:49 - here so usually we have to use VAR and
175:53 - then the type with the name of the
175:55 - variable right and usually we just use
175:57 - this regular equal sign to assign the
175:59 - value to the variable right but here
176:01 - we're using this weird colon equal sign
176:05 - right well this colon equal sign is like
176:07 - a shortcut like go can actually infer
176:11 - the type based on the function like the
176:15 - function tells go that a string int and
176:17 - bull is returned so go can just infer
176:21 - from that that these three variables
176:24 - should be inch string and bull and the
176:27 - same if we were to create a string we
176:30 - can create this is a
176:34 - string and we can do the colon equals
176:37 - and we could put string here and go
176:39 - knows this is a string so it can infer
176:42 - that this is a string so this is
176:44 - actually okay we can do this way so this
176:46 - is like the shortcut to this long long
176:48 - way that we've been doing it but the
176:49 - reason I've been doing it the long way
176:51 - is because I wanted you to learn about
176:53 - the variable keyword and assigning
176:57 - specific values with specific types but
177:00 - from here on out we're going to start to
177:02 - use this shorter syntax like this this
177:05 - shortcut here with a colon equal signs
177:08 - and have go just infer the type of the
177:11 - variable so these are perfectly valid
177:13 - lines of code the only reason they're
177:14 - red here is because we're not using the
177:16 - variables so go wants you to use a
177:19 - variable if you assign a value to a
177:21 - variable so if we did format. print
177:25 - Line This is a string it's no longer red
177:29 - and the same thing would happen if we
177:31 - printed these but yeah this is the easy
177:33 - way to actually assign a value to a
177:35 - variable without needing to write VAR
177:37 - and then the type and all that so we can
177:39 - remove that and here we can actually
177:42 - just do colon here and you can see
177:45 - there's an error because we need to
177:47 - delete the this and delete this but now
177:50 - you can see go just infers that this is
177:52 - a slice of bite so the colon is very
177:56 - useful you can just use this instead of
177:58 - needing to write out the long stuff that
178:00 - I taught you in the beginning and we're
178:01 - doing the same here so we're take we're
178:04 - we're receiving three values from this
178:07 - function and we're using this colon so
178:09 - go can just infer the types and from
178:12 - from left to right like the same order
178:15 - that the values are returned so the same
178:17 - order here so the string is the leftmost
178:20 - value the int is the middle value and
178:23 - the bull is the rightmost value so when
178:25 - we return it we do the string as the
178:27 - leftmost value the int as the middle one
178:29 - and the bull as the rightmost value so
178:31 - we're returning three values and we
178:34 - could do like format. print line and we
178:37 - can do it for each
178:40 - value and I keep accidentally forgetting
178:43 - the T and in this case some string would
178:46 - get printed first then the int would get
178:48 - printed and then the bull true would get
178:51 - printed now I explained all of that the
178:53 - part about returning multiple values
178:55 - from a function because this writer.
178:58 - write function it returns two values but
179:02 - one of the values we want to ignore so
179:05 - what we can do is to ignore a value we
179:08 - can just put an underscore and then we
179:10 - don't want to ignore the error of
179:12 - course so we can do it like this so this
179:16 - right function returns an integer and an
179:18 - error we want to ignore the integer so
179:21 - for the first variable we just put an
179:23 - underscore we just ignore it and then
179:25 - the second one we use the conventional
179:27 - name ER r r for error and remember we
179:31 - need to check and see if the error is
179:32 - nil that's how we handle errors and go
179:35 - so just get in the habit of doing this
179:37 - so if airor not equals nil then we have
179:40 - to do something and in our case we're
179:43 - just going to print we're just going to
179:46 - print the error we're not going to do
179:47 - anything crazy we'll just print the
179:49 - error but yeah you're going to see this
179:51 - if error not equals nil all over go code
179:54 - and you're going to need to write it all
179:55 - over go code as well so just get used to
179:58 - this pattern here so we we catch the
180:02 - error potentially catch the error so if
180:05 - the error is not equal nil we'll do this
180:07 - code here but if the error is equal nil
180:10 - then we skip this part and we'll go down
180:12 - here right but the function doesn't have
180:15 - anything after this so the function
180:17 - would just end so now when we send a
180:20 - request to this handle health via
180:22 - Postman we're just going to send the
180:24 - response server is up and running and
180:27 - then that's it the function's going to
180:29 - end if there's an error sending the
180:31 - response the error will get printed and
180:33 - then the function's going to end so
180:36 - let's go ahead and run the server and
180:38 - try this out so we'll go to the terminal
180:41 - let's clear G run server. go so now our
180:45 - server is running so now let's go back
180:46 - to postman
180:49 - and it's going to just keep asking me to
180:51 - update anyway so we have our Local Host
180:54 - 4242 health will send the request now as
180:59 - you can see here we get a 200 response
181:01 - which is means it's a successful request
181:04 - and we received the message server is up
181:07 - and running because we returned that in
181:09 - the response we wrote that to the
181:12 - response that's what the response writer
181:14 - is it writes to the response that gets
181:18 - sent back to the caller which is right
181:21 - now it's us sending the request from
181:24 - Postman so if we go back in here and we
181:27 - stop running the server this is this is
181:29 - the point of the the health the health
181:31 - check end point we want to check the
181:34 - health of the server so if we go back to
181:37 - postman so remember we're we're an
181:39 - entity that's not part of the server so
181:42 - like we don't know if the server is
181:43 - running or not so we would want to what
181:45 - if we wanted to check and see if the is
181:48 - running we'd send this request to the
181:49 - health endpoint and you see we get could
181:52 - not send requests because the server is
181:53 - not running so we'd know then like oh
181:56 - the server is not running we can't we
181:57 - can't access the health endpoint like we
181:59 - we check the health server is not
182:01 - running so if we go run server. go send
182:06 - the request again now we know the server
182:08 - is
182:09 - running so that's the response writer
182:14 - that's the writer that's where we're
182:15 - we're we're writing to the response that
182:18 - gets sent back to the caller but the
182:20 - request is the request that we receive
182:24 - from the caller so we're going to leave
182:26 - this health check code here because we
182:28 - want to have the functionality for the
182:31 - caller of our server to be able to check
182:33 - the health but let's also see what this
182:36 - request does and we'll just test that
182:39 - out in our actual handle create payment
182:43 - intent endpoint so we don't need to
182:45 - print that anymore so here let's also
182:47 - change it it to change the variable name
182:50 - of the parameter to request and writer
182:52 - just to be more verbose and I don't know
182:55 - it's a bit long so it's kind of hard to
182:58 - see but yeah the end of this function
183:00 - you basically know what it is it's the
183:02 - request and the writer those are the
183:04 - parameters so if the person sending the
183:07 - request actually sends us some type of
183:09 - message in the request we could actually
183:11 - read it inside of this function and
183:14 - coincidentally in our handle create
183:17 - payment intent code that's actually
183:19 - something that we're going to have to do
183:21 - and we're also going to have to make
183:24 - sure that the person calling this
183:27 - endpoint is using the proper request
183:30 - method so when sending HTTP request
183:34 - there are different request methods that
183:37 - you can use so if we go to postman here
183:40 - this here is the request method so if
183:43 - you hit this drop down you can see all
183:46 - of the methods available to us now in
183:49 - this tutorial we're only going to be
183:50 - working with the post method but if you
183:52 - want to dive deeper into the rest of the
183:55 - methods feel free to do that as well but
183:58 - we're not going to go too deep into all
183:59 - of the methods in this tutorial but the
184:02 - names of the methods kind of give you a
184:04 - general idea of what each one does so
184:07 - maybe there's an endpoint to delete some
184:10 - resource on some server you would use
184:13 - delete or maybe you want to patch some
184:17 - resource or copy some resource but the
184:20 - most common ones you're going to see are
184:21 - get and post so those are the ones that
184:23 - we'll focus on so G is the one that you
184:26 - use to retrieve data from a server and
184:28 - posts were generally going to be trying
184:31 - to provide data to the server so for
184:34 - example our health check inpoint we
184:36 - could just use a git the git method
184:38 - because we just want to get some
184:39 - information so what gets returned from
184:42 - the server the information the server is
184:45 - up and running that's the information
184:47 - that we want to get but in the case of
184:50 - creating customer payment intent we want
184:52 - to post some data which is basically
184:56 - information about what the customer
184:57 - wants to buy from that product store
184:59 - Page we want to post that data to the
185:02 - server we want to send that data to the
185:04 - server and with that information the
185:06 - server is going to be able to do
185:07 - something to to create the actual
185:10 - customer intent which I I haven't
185:12 - explained exactly what that part of the
185:14 - flow is yet but I'll get to it but first
185:17 - I want to go over the fundamentals that
185:18 - you need to know to actually do this so
185:21 - we need to make sure the request method
185:25 - is a post method on our server and
185:28 - that's for when they call the create
185:29 - payment intent create payment intent
185:32 - when they call this endpoint this
185:34 - endpoint we're going to require it to be
185:36 - a post method
185:39 - endpoint and we can see what the request
185:41 - method is by using this request variable
185:44 - or parameter which is the type request
185:47 - from the HTTP package so let's see what
185:50 - I mean by that so we're going to say if
185:53 - request. method so as you can see this
185:56 - request parameter the HTTP package
185:59 - provides the functionality to check the
186:02 - method of the request in its own type
186:04 - that it gives us that
186:06 - HTTP request type which is here so we
186:09 - can check the request method so we say
186:12 - if request method is not equal to post
186:16 - then we can do something now let me take
186:18 - a step back here you probably have never
186:21 - seen this before so this just means not
186:23 - equal remember equal when we check if
186:26 - something is equal to we do two equal
186:30 - signs but to check if something's not
186:32 - equal to we'll do exclamation and then
186:34 - equal not equal so if request method is
186:37 - not equal and I said you never saw that
186:40 - before but actually we've been using
186:41 - that for this if a is not equal null so
186:45 - I should have explained that earlier but
186:46 - I hope you understood when I was saying
186:48 - if error not equal null but yeah this
186:50 - means not equals so if request method is
186:52 - not equal to post we want to return an
186:55 - error and actually the HTTP package
186:59 - provides a function for us to return the
187:03 - error or to return specific types of
187:05 - Errors to the caller without actually
187:08 - needing to write to the response writer
187:11 - manually like we've been doing with the
187:14 - health endpoint so with this endpoint we
187:17 - wrote wrote to the response writer this
187:19 - message we did it manually right we us
187:21 - the writer's write method here but here
187:25 - we're just going to use the HTTP
187:28 - package. error and this function takes
187:32 - in the response writer and the string
187:35 - that we want to return as an error and
187:38 - the error code that we want to send them
187:41 - now the code is the part that I've been
187:44 - showing you so the code is this part
187:47 - here so if we go back to postman this is
187:49 - the code so if the resp response is
187:52 - successful the code is 200 right well
187:54 - there's multiple different codes for
187:56 - different types of response in the
187:58 - networking and programming world so the
188:01 - HTTP package actually provides all of
188:04 - these for us so let me just show you
188:07 - what I mean so we can pass in our writer
188:09 - right which this error we're passing in
188:13 - this response writer and this error
188:16 - function is going to to use this right
188:19 - function for us we're not going to have
188:20 - to do this it's going to do it for us
188:22 - under the hood so we're going to pass in
188:24 - the writer and we also have to pass in
188:27 - the error string and the code right we
188:30 - don't even have to write out the error
188:31 - string ourself we can just use HTTP do
188:35 - status text which is another function
188:38 - from the HTTP package so status text and
188:42 - you can see here status text returns a
188:44 - text for the HTTP status code so so here
188:48 - we just put in the code so HTTP Dot and
188:51 - the code that we want to use is the
188:54 - status method not allowed code now you
188:56 - can see here all of these codes that the
188:59 - HTTP package provides for us so we can
189:02 - just type status method not allowed now
189:05 - this is provided for us by the HTTP
189:09 - package as you can see status method not
189:11 - allowed is going to be translated to the
189:14 - code 405 so this is the code that we
189:18 - send the HTTP Response Code that we send
189:22 - when somebody tries to send a request
189:25 - using a method that we don't support for
189:28 - that particular endpoint so this
189:30 - endpoint we're creating it so that it
189:32 - only supports post so if it's any other
189:35 - method we're going to say that we don't
189:38 - support that method by sending the code
189:40 - 405 and these codes are are convention
189:44 - like these codes are used throughout the
189:46 - networking and progam progamming world
189:48 - like so a 405 is a universal thing so
189:52 - you don't want to just be making up your
189:53 - own status codes or whatever you need to
189:55 - look up the proper status codes for the
189:58 - proper types for the types of response
190:00 - that you want to SP that you want to
190:01 - send and this HTTP package makes it easy
190:04 - for us because it provides basically the
190:07 - code given the name of the error that we
190:11 - want to return so status method not
190:13 - allowed like we don't want to allow
190:15 - anything other than post so this error
190:17 - HTTP error function takes the writer
190:20 - then it takes the status text the status
190:23 - text is created by passing in the code
190:26 - to this status text function then the
190:28 - status text function it knows what text
190:31 - to send back as the error because it
190:33 - knows the code it knows what the code
190:35 - means basically it knows the code 405
190:37 - means that the method's not allowed so
190:39 - the text that it's going to send back is
190:42 - going to basically say something like
190:43 - the method's not allowed and you'll see
190:45 - what I mean by that soon and then for
190:47 - the code we put the same thing HTTP do
190:52 - status method not allowed and this is
190:55 - just going to be the code not the not
190:57 - the text just the actual number because
190:59 - we're not passing it to the status text
191:01 - function like here and then after that
191:03 - we're just going to return and return in
191:06 - this case just means like return out of
191:08 - the function like the function's
191:09 - finished we want to finish the function
191:11 - here if they send a request that's an
191:14 - invalid method we want to send that
191:16 - response and just finish the function we
191:18 - don't want to continue with the function
191:20 - but if they do send the right uh method
191:23 - then this will get skipped over so we
191:25 - wouldn't return out of the function and
191:26 - we'd continue down here with the rest of
191:28 - the code and you'll see what I mean soon
191:30 - but first let's just test this part here
191:33 - where we're resend where we're sending
191:35 - this HTTP response basically saying that
191:38 - the method's wrong so let's open our
191:40 - terminal and restart our server go run
191:44 - server. go and let's open up Postman
191:48 - and let's do a get request to this
191:51 - endpoint now remember we only accept
191:53 - post requests to this endpoint and let's
191:55 - send it now as you can see here we get
191:58 - 405 method not allowed and you can see
192:01 - the text method not allowed the text
192:04 - that got sent back that got written to
192:06 - the response based on just passing this
192:09 - 405 into that text function so let me
192:12 - show you so remember this is taking the
192:15 - writer and then the error as a string
192:18 - so this method which is just a number
192:21 - 405 is getting mapped to a text to text
192:25 - and maybe I can just show you what I
192:26 - mean by that by printing so if we do
192:28 - format print line HTTP do status method
192:34 - not allowed and let's just take this and
192:37 - put it into our main
192:39 - function and let's comment out our main
192:43 - code and let's just run this and see
192:46 - what gets printed and actually I need to
192:48 - put a t here now let's stop running the
192:51 - server and do go run server. go again
192:53 - and you can see it just prints the
192:55 - number 405 because this is just a
192:58 - variable name for the number 405 that
193:01 - the HTTP package provides now that means
193:04 - that we could even just change this to
193:07 - 405 but that's not a good way to do it
193:10 - because it's possible for us to put the
193:12 - wrong number in here or something or
193:14 - maybe we don't know the exact code that
193:16 - it's supposed to be and it also makes
193:18 - the code harder to read so yeah but when
193:21 - you pass 405 into status text it's going
193:24 - to print out the text version of the
193:28 - code so for example if we just copy this
193:32 - and we paste it and we do format. print
193:36 - line so now we're going to print the
193:38 - result of this function we're going to
193:40 - print what's returned from this function
193:43 - so we could do go run server. go now you
193:45 - can see it gets printed is method not
193:47 - allowed because we're passing in the
193:49 - code to the function and the function
193:51 - Returns the string it Returns the string
193:54 - value of the code I hope that makes
193:56 - sense so we can delete that and let's
193:58 - uncomment our main code again and now
194:01 - let's go here and do print line and
194:05 - we'll do request method was
194:09 - correct so when we run the server now if
194:13 - a request gets sent to this endpoint
194:15 - with a method that's not post it's going
194:17 - to return the error right and actually
194:19 - let's change this back to the actual one
194:21 - that's
194:22 - provided anyways if a request gets sent
194:25 - to this endpoint and it's a method other
194:27 - than post then of course we're going to
194:29 - return this this error the status 405
194:31 - error right method not allowed but if
194:34 - they do send a post method this gets
194:37 - skipped and then we go down to this line
194:38 - of code and then after this gets printed
194:41 - the function finishes so if the method's
194:44 - post then we should see request method
194:46 - was correct correct so let's run the
194:50 - server open Postman and let's send it
194:53 - again with the wrong method you see 405
194:55 - method not allowed but now let's send
194:58 - with post so you see 200 which is an
195:02 - okay and then we go back to goand and
195:04 - you see request method was correct so
195:07 - what we're doing here is in this block
195:10 - of code we're validating that they're
195:12 - giving us the right request method if
195:14 - they're not we're going to return an
195:15 - error if they do give us the right
195:17 - request method we'll continue with the
195:19 - function and from there we'll continue
195:22 - with the functionality of handle create
195:25 - payment intent but before we write out
195:28 - the rest of the functionality for this
195:29 - function I need to actually explain to
195:32 - you the flow of what's going to actually
195:34 - happen when a user wants to purchase a
195:37 - product on that frontend web page and
195:40 - the frontend sends the request to create
195:42 - the user's payment intent to our backend
195:45 - server because I haven't explained that
195:46 - yet and you need to understand that to
195:49 - understand what's actually being built
195:51 - here so let's get into that explanation
195:54 - so the stripe payment flow is going to
195:57 - involve three entities and those
195:59 - entities are the frontend the stripe
196:02 - server and our server where we're
196:05 - writing the API in go so stripe has its
196:09 - own servers and its own apis and both
196:12 - our server and the frontend are actually
196:14 - going to be communicating with this
196:16 - strip server so what's going to happen
196:18 - is if the customer wants to buy a
196:21 - product they will select the product
196:23 - they want to buy and go to the checkout
196:25 - page when the customer hits that
196:26 - checkout page on the front end a request
196:29 - is going to get sent to our server and
196:33 - that request is going to be the create
196:36 - payment intent request now when our
196:39 - server receives this request to create
196:42 - payment intent from the customer our
196:44 - server is going to send a request to
196:46 - strike API to create that payment intent
196:49 - so the actual payment intent gets
196:52 - created on the stripe server so let's
196:55 - just say this this purple ball is the
196:57 - payment intent so when we send the
196:59 - request to stripe to create the payment
197:02 - intent it's going to spit out this
197:03 - purple ball and send it back to us and
197:06 - this payment intent actually has like a
197:08 - secret key associated with the customer
197:11 - that the frontend sent the original
197:14 - payment intent for so our ser is going
197:17 - to return that secret key to the front
197:21 - end so we'll say customer key so this
197:24 - customer key essentially Maps this
197:26 - payment intent to this customer now
197:29 - something important to note here is
197:31 - stripe has access to this same payment
197:34 - intent so essentially stripe just sent
197:37 - us a copy of this payment intent so
197:39 - stripe has this same payment intent and
197:42 - ours is essentially just a copy of that
197:45 - one so just to recap step one the front
197:48 - end sends the payment intent to our
197:50 - server step two we send create payment
197:54 - intent to the stripe server step three
197:57 - the stripe server creates this payment
197:59 - intent object and gives us a copy of it
198:03 - and that object has an Associated key
198:06 - with it then step four our server sends
198:10 - that key back to the front end so now
198:13 - the front end has the key for the
198:16 - payment intent that we requested to be
198:17 - created by the stripe server on our
198:20 - server so now when the customer actually
198:24 - confirms their payment the front end has
198:26 - a stripe library or like a stripe
198:29 - backend built into it like so the front
198:32 - end that I pre-built for you it has the
198:35 - functionality built into it so it can
198:37 - contact the stripe server so when we
198:40 - return this customer key to the front
198:42 - end when the customer confirms their
198:44 - payment on the front end the front will
198:47 - send a request to the stripe server to
198:50 - confirm payment and how does the stripe
198:53 - server know whose payment we trying to
198:55 - confirm well when they send the
198:57 - confirmed payment request to the front
198:59 - end they provide the customer key in the
199:01 - request the stripe server can then
199:03 - associate this customer key with this
199:06 - customer's payment intent because
199:08 - remember the payment intent object is
199:10 - still on the stripe server as well so
199:12 - once the payment is confirmed on the
199:16 - stripe end stripe will send a response
199:18 - back to the front end telling the front
199:20 - end the payment was successful and then
199:22 - from there the front end can redirect
199:24 - the customer to a su payment successful
199:28 - page now there are some Advanced things
199:31 - that would need to be added to our
199:33 - server code and to this overall payment
199:36 - flow if we were to actually deploy this
199:40 - to a production server for example since
199:43 - the front end confirms the payment with
199:45 - stripe directly using the customer key
199:48 - our server doesn't at the moment have
199:51 - any way of knowing if the payment was
199:53 - successful so additional functionality
199:55 - that we might want to add to our server
199:58 - later on down the line is we would want
200:00 - to create what's called a web hook which
200:04 - is basically an API endpoint that we
200:07 - provide to the stripe server so Stripes
200:11 - so the stripe server can send us a
200:14 - request telling us that the customer
200:16 - successfully completed their payment but
200:19 - we're actually not going to do that in
200:20 - this video maybe I'll create a second
200:23 - video down the line where we add that
200:25 - functionality but we're not going to add
200:27 - that to this server for this video so
200:29 - this is the payment flow so remember the
200:32 - front end sends the create payment
200:34 - intent request to our server then we
200:37 - send a request to stripe telling them to
200:40 - create this payment intent object stripe
200:42 - creates the object and gives us a copy
200:44 - of it that object contains the customer
200:47 - key associated with this payment intent
200:50 - we send that customer key back to the
200:52 - front end then whenever the customer
200:54 - confirms their payment on the front end
200:56 - the front end sends a confirmed payment
200:59 - request to the stripe API or stripe
201:02 - server with that customer key stripe
201:05 - then Associates that key with the
201:08 - payment intent object that it has on its
201:10 - server and will confirm the payment and
201:13 - send a response back to the front end
201:15 - saying the payment was successful and we
201:18 - can access the funds for the payments
201:21 - that we receive by logging into our
201:23 - stripe account that we that we logged
201:25 - into earlier the one where we had the
201:27 - stripe dashboard and we had to copy our
201:30 - keys so that's how the payment flow is
201:33 - working with stripe and our backend API
201:37 - so I just realized that I've been
201:38 - showing you guys all of these tools
201:41 - provided by the HTTP package such as
201:45 - this status text function and like these
201:48 - status methods that the HTTP package
201:51 - provides and you're probably wondering
201:53 - like how do I know about all these tools
201:55 - provided by this package for example
201:58 - this this HTTP package is one of Go's
202:01 - packages in its standard library right
202:03 - but like how do I just know that we can
202:05 - whip out these tools like how do I know
202:07 - about these things that we're using and
202:11 - essentially before ever working with
202:13 - this package I didn't know about these
202:15 - tools so how do I know about them now I
202:18 - guess is what I'm saying so this is a
202:20 - very important part of programming so I
202:23 - should have mentioned this sooner but
202:24 - actually this is probably one of the
202:26 - main things you'll do as a programmer
202:29 - and that is reading documentation so
202:32 - basically if we go to the top of the
202:34 - file here the package that we're using
202:37 - all these tools from is this net HTTP
202:40 - package right and this is a package in
202:43 - go standard Library so the reason I know
202:46 - to use all of these different tools
202:49 - provided by this package is because I
202:51 - read through their documentation or
202:53 - rather I started reading through their
202:55 - documentation when I first started
202:57 - making apis in the go programming
202:59 - language so their documentation is quite
203:01 - extensive so of course I didn't read all
203:04 - of the documentation but I've I've read
203:06 - a lot of the documentation for the
203:09 - things that I use the tools that I use
203:11 - provided by this package and I just want
203:13 - you guys to get in the habit of doing
203:15 - that because that's basically how you're
203:17 - going to build things on your own when
203:18 - you're not following tutorials you're
203:20 - going to have to look into different
203:22 - packages provided by the language and
203:25 - there are external packages as well that
203:27 - aren't provided by by go like that
203:30 - aren't part of go standard library but
203:32 - are still very useful packages that the
203:34 - community uses so for example we can
203:37 - just search for this net HTTP goang and
203:41 - it'll take us to the go programming
203:43 - languages like package page and all of
203:46 - the packages in goh standard Library the
203:49 - documentation for all of them can be
203:50 - found on this site here and this site
203:55 - provides information about like getting
203:58 - started with the package the things that
203:59 - the package the type of things you can
204:01 - do with the package additional
204:03 - information there's a whole index here
204:05 - that tells you about every aspect of the
204:08 - package so essentially when I'm building
204:10 - something and go I'll for the packages
204:12 - that I'm using I'll go online and I'll
204:14 - read through their documentation to see
204:16 - what tools are available to me and I'll
204:19 - just make use of those tools as as I see
204:22 - fit like if I see something that's
204:23 - useful to what I'm building I'll just
204:25 - make use of it and then from doing that
204:27 - you start to familiarize yourself with
204:29 - certain tools like this HTTP package is
204:32 - a very common tool in go so like you'll
204:36 - find yourself using it very often as a
204:38 - backhand engineer So eventually you
204:41 - start to become familiar with the
204:42 - different tools that it provides and you
204:44 - start to kind of get like a ro routine
204:46 - going when you build an API maybe you
204:48 - have like a skeleton that you always use
204:51 - to create your apis or something like
204:53 - that and that's basically how I know
204:55 - about all of these tools that I'm that
204:58 - I'm using and showing to you provided by
205:00 - this package in particular and any other
205:03 - package that I use I know about the
205:05 - tools because I've read through the
205:07 - documentation for them online so like
205:09 - you can do the same thing with this goes
205:11 - log package like there's a lot of tools
205:13 - available to us in this log package as
205:16 - as well so we can just go back to go
205:19 - here and then docs and then hit standard
205:22 - library and we can just look through
205:24 - here and look for the log package so you
205:26 - see the log package here and you also
205:29 - see the format package which we've been
205:32 - using a lot as well but yeah you can see
205:34 - the log package here and you can click
205:36 - the log package and get more information
205:38 - about that one and this is how I'm
205:41 - getting information about all these
205:42 - packages as I'm building things so
205:45 - you're going to need to get in the habit
205:46 - of doing this as well as a programmer
205:48 - you're going to have to get in the habit
205:50 - of reading
205:51 - documentation and understanding how
205:54 - certain tools can help you to build
205:56 - things and when you become more advanced
205:59 - you're going to need to start learning
206:00 - how to reverse engineer code and
206:03 - understand how code is working cuz
206:05 - sometimes people write code and there's
206:07 - no real documentation to tell you how
206:09 - the code works or how you can use
206:11 - certain tools provided by the code so
206:13 - you have to learn how to reverse
206:14 - engineer code as well but that's a more
206:16 - advanced technique for now I just want
206:19 - you to know how I'm actually coming up
206:21 - with these things like this status
206:24 - method not allowed here like how did I
206:27 - know that this even existed it's because
206:29 - of the
206:30 - documentation and also you can actually
206:33 - go to where this exists in the HTTP
206:38 - packages code by pressing control or
206:41 - command and then click and if you hit
206:44 - command click it'll take you to the
206:46 - actual code where this is written like
206:48 - this is the code where it's saying that
206:51 - this value is equal to 405 and these are
206:55 - all constants like they're variables but
206:58 - they're variables that don't change like
207:00 - we it would always this variable would
207:02 - always be uh 300 the value would always
207:05 - be 300 for this variable because it's a
207:07 - constant and you can see here we use the
207:09 - keyword const to make these constant
207:12 - variables so if we go back to our our
207:15 - code here here if we type in const does
207:21 - does not change and we set it equal
207:25 - to does not change if we go into Main
207:29 - and we try to assign does not change a
207:32 - different value so does not change
207:35 - equals another value if you hover over
207:38 - this you see that we cannot assign to
207:41 - does not change because once we set a
207:42 - value for a constant it can't be changed
207:45 - can't we can't assign a different value
207:47 - to it but if we create a a regular
207:51 - variable so does change and we'll use
207:54 - that new syntax I taught you can be
207:57 - changed and then we change does change
208:01 - to it was changed you can see if we do
208:06 - print line does change the first time
208:10 - and then the second time it's going to
208:12 - print a different value the first and
208:14 - the second time we print it oh and
208:16 - that's another thing I forgot so this
208:18 - colon here it can only be used the first
208:22 - time you assign a value to a variable
208:25 - the second time you don't need to use it
208:28 - so if we hover over this here it says no
208:30 - new variables on the left side of the
208:33 - colon equals because this variable
208:35 - already exists here we already declared
208:37 - the variable here so if we're using this
208:40 - it's declaring and assigning the
208:41 - variable but we only need to assign a
208:43 - value to it not declare it because we
208:45 - already declared it here so we can go
208:47 - ahead and remove that so that's the
208:49 - difference between declaring and
208:51 - assigning a variable so since we're
208:54 - while we're at it let me just explain
208:55 - that as well so we can declare a
208:57 - variable without actually giving it a
208:59 - value so we can do VAR variable name and
209:03 - we can just say it's a
209:04 - string and then later on we can do
209:07 - variable name equals some
209:11 - string and then we can print it
209:16 - now this here is declaring the variable
209:19 - like we're setting this variable up and
209:22 - we can assign values to this variable
209:24 - but we didn't assign a value here as you
209:26 - can see we're just declaring that
209:27 - there's a variable named variable name
209:30 - that's going to be a string and here is
209:32 - where we're assigning a value to the
209:34 - variable now this syntax the semicolon
209:38 - and the equals it declares and assigns
209:41 - the value to the variable the same way
209:43 - we were doing it before when we were
209:44 - doing VAR variable name String equals
209:49 - something when we were doing this before
209:51 - we're both declaring and assigning a
209:54 - value to the variable and that's what
209:56 - this does this is a shorthand syntax to
209:59 - do this long thing declare and assign
210:01 - the
210:02 - value but you can also declare a
210:04 - variable without assigning a value to it
210:06 - and then you can assign a value to it
210:08 - separately so that's the difference
210:10 - between declaring and assigning a value
210:12 - to a variable so this does both right so
210:16 - since this does both if we try to do it
210:18 - again it's an error because it's trying
210:20 - to declare the variable again because
210:23 - this shorthand syntax also declares the
210:26 - variable for example if we tried to do
210:28 - this again it would be an error you can
210:31 - see variable name redeclared in this
210:33 - block and let me change the name of this
210:35 - so it's not so confusing so let's just
210:37 - call it something and now here you see
210:41 - something the variable named something
210:43 - redeclared in this block you can't
210:46 - declare a variable twice you only can do
210:47 - it once now that went a little bit off
210:50 - topic but yeah that's declaring and
210:52 - assigning values to variables and that's
210:54 - constants as well and going back to what
210:57 - I was explaining before get get
210:59 - comfortable with using the documentation
211:02 - or reading through documentation for
211:04 - tools that you think might be
211:05 - interesting to use like as you become
211:08 - more familiar with programming and you
211:09 - start to like it more you're going to
211:11 - actually start to get excited if you if
211:13 - you read the if you get a chance to read
211:15 - some document mentation about a tool
211:16 - that's interesting to you like maybe
211:18 - some new tech will come out and then the
211:21 - documentation page might seem exciting
211:23 - for you to read cuz you know that you
211:25 - can like read through the tools
211:27 - available to you and and think of things
211:29 - that you can build with it so just get
211:31 - comfortable with reading the docs that's
211:32 - how I'm coming up with this stuff like
211:35 - this constant using this constant here
211:38 - using this function and also another
211:41 - cool thing you can actually read the
211:43 - code for the functions that you use from
211:45 - these standard Library packages as well
211:47 - so like again you can press command and
211:49 - click and it'll actually take you to
211:51 - where the function is defined like this
211:53 - is the function definition and the
211:56 - people that wrote this library for go
211:58 - like wrote this code just like you're
212:00 - writing code for whatever it is that
212:01 - you're building so this is the function
212:04 - status text and it takes in an integer
212:08 - and it returns a string as we already
212:10 - know and then this is the code for it
212:12 - it's really just a long switch statement
212:15 - so if the code is some code it'll return
212:18 - some text and it's just a super long
212:21 - switch statement and a switch statement
212:23 - is essentially like if else statement
212:25 - that we went over before so like if code
212:28 - is status unauthorized return
212:30 - unauthorized Etc but you don't really
212:33 - need to know what a switch statement is
212:34 - right now because right now we're just
212:35 - making use of the if else conditional
212:38 - statements and they serve the same
212:40 - purpose there's some situations when you
212:42 - might want to use a switch instead but
212:44 - we don't need to worry about about that
212:46 - right now so anyways we can leave that
212:49 - but yeah that's how you like dive deeper
212:52 - into the code that you're using like the
212:54 - libraries that you're using like you can
212:55 - check the code you can read the
212:57 - documentation try to understand things
212:59 - that you're using try to dig deeper and
213:01 - see what's happening under the hood like
213:02 - that's how you become a better
213:04 - programmer like reading other people's
213:06 - code reading documentation learning how
213:09 - things work and you eventually become a
213:11 - better programmer when you do stuff like
213:13 - that but anyways sorry for the long rant
213:16 - but yeah so let's move on with the rest
213:19 - of this tutorial so it's time for us to
213:22 - actually finish writing the code for
213:24 - this handle create payment intent
213:26 - function and essentially where we left
213:28 - off was receiving the request from
213:31 - whoever is sending us the request
213:33 - receiving that request and checking the
213:35 - method right we checked the method and
213:37 - made sure it's post for this endpoint
213:39 - but remember I told you that post a post
213:42 - method is sending some type of like
213:44 - payload to our end point to actually
213:47 - trigger some sort of action and the
213:50 - action needs to use the payload that's
213:53 - provided in the request so what I mean
213:55 - by that is we're going to receive from
213:58 - the front end a structure of data that
214:01 - contains the information that we need to
214:04 - actually create the payment intent
214:07 - object that I told you about so we're
214:09 - going to create that object in code and
214:12 - we're going to use the information
214:15 - provid it to to us in this request to
214:17 - create that object so let me show you
214:19 - what I mean by that and to show you what
214:21 - I mean by that I need to introduce to
214:24 - you another type in go which is called a
214:27 - struct so we're going to say VAR req for
214:31 - request since we're already using
214:32 - request here we won't use that req
214:36 - struct and then brackets now if we hover
214:39 - over this you can see that a struct is a
214:42 - sequence of named elements called Fields
214:44 - Each of which has a name and a type so
214:48 - this is essentially going to be the
214:50 - Paradigm for the data that we're
214:53 - receiving from the person sending the
214:55 - request to this endpoint and what I mean
214:57 - by that is we're going to define the
215:00 - structure of the data that gets sent to
215:02 - this endpoint and whoever sends requests
215:05 - to this endpoint is going to be required
215:07 - to conform to that structure we're
215:10 - creating the structure so let me show
215:12 - you what I mean by that so we're going
215:13 - to list the fields that we need in the
215:15 - data that gets sent in this request so
215:18 - the first field is going to be product
215:21 - ID and it's going to be a string and
215:23 - when they send it to us we're going to
215:26 - define the format of what this field is
215:30 - supposed to look like and you'll see
215:32 - what I mean it's going to look confusing
215:34 - right now but I'll show you what this
215:35 - means soon so we're going to put product
215:38 - ID here and then the next field is going
215:41 - to be first name and all of these fields
215:43 - are going to be strings and and we're
215:45 - going to do last name address city state
215:49 - ZIP code and
215:55 - Country and as you can see here it's
215:57 - getting a little bit messy like the type
215:59 - names aren't lined up so we can go here
216:03 - and rightclick our file and do reformat
216:09 - code and as you can see it lines things
216:11 - up all nice and pretty so we can close
216:14 - that so when a request is sent to this
216:17 - endpoint we we're going to expect the
216:19 - request to be this structure so we're
216:22 - defining the structure here and what
216:24 - we're going to do is we're going to take
216:27 - the request body from here and we're
216:30 - just going to put it into our own
216:34 - request structure and by the way all of
216:37 - these have to be capitalized so just
216:39 - keep that in mind and they need to be
216:40 - capitalized because we need to export
216:43 - these values and we need to export these
216:46 - values because we're we're going to need
216:47 - to pass this into another packages
216:50 - function so they're going to need to be
216:52 - able to use or access these values and
216:55 - if we do them in lowercase they won't be
216:57 - exported the same way to export a
216:59 - function from a package it has to be
217:01 - capitalized it's the same with this so
217:04 - let's go down here and now that we have
217:07 - the structure that we want the request
217:09 - to be in we're going to use another
217:12 - package provided by go called Json
217:16 - and then we're going to do new decoder
217:18 - and we're going to decode the request
217:22 - and see this Jason here if we go up to
217:24 - the top you can see it automatically got
217:26 - imported this encoding Jason but anyways
217:30 - we're going to decode this request so
217:33 - here we're going to do request Dot and
217:36 - what we're decoding is the body of the
217:39 - request so we'll do body now if we hover
217:42 - over body here you see body is the
217:45 - request body so remember this request is
217:49 - from up here this is the request coming
217:51 - from the front end or in the case when
217:54 - we test this it's going to be coming
217:55 - from Postman cuz we're going to be
217:57 - sending the request but this is that
217:58 - request and the request is going to have
218:01 - this body attribute like it's going to
218:03 - be the body of the request so let me
218:05 - show you so if we go to postman here
218:08 - when we're make when we're sending this
218:09 - post request down here there's a tab
218:12 - called body and in here we can select
218:15 - Raw
218:16 - and we're going to provide the body and
218:18 - it's going to be in the same format as
218:21 - that structure that we built in our code
218:24 - because if we send it in a different
218:26 - format we're not going to accept it so
218:28 - I'll show you what I mean by that in a
218:30 - second but the request body is going to
218:32 - essentially look like this it's going to
218:34 - have these brackets and remember I told
218:37 - you that the way that we're asking for
218:39 - it to be formatted in the request is
218:41 - like this so in our code we're we're
218:44 - we're calling it product ID with capital
218:46 - P and capital I and they're like
218:49 - together but in the actual request we're
218:51 - going to expect it to be snake case so
218:53 - this is called snake case so we're going
218:55 - to expect it to be all lowercase and
218:59 - each word is going to be separated by an
219:01 - underscore so it's going to be product
219:03 - ID first name last name address one
219:05 - address 2 city state ZIP
219:08 - country so here we'll do
219:11 - product ID and we'll call it test
219:14 - product ID so these are all going to be
219:18 - key value pairs so this is the key and
219:21 - then this is the value so product ID the
219:24 - product ID's value is going to be test
219:27 - product
219:30 - ID so here we have our request body and
219:34 - the way that we're writing this is
219:35 - actually called Jason so instead of
219:38 - having it as text we're going to change
219:39 - this to Jason and when we do it that way
219:42 - it'll actually give us some like syntax
219:43 - highlighting and it'll tell us if we're
219:45 - doing something wrong in the Json format
219:48 - so Json is just a a way to format the
219:50 - string data so this is what Json looks
219:53 - like essentially like key value Pairs
219:55 - and we're missing a comma here so after
219:58 - every key value there should be a comma
220:01 - and all these keys and values should be
220:03 - enclosed in these brackets so this is
220:06 - our request body and in Postman so you
220:09 - don't have to keep writing this stuff
220:10 - out you can actually just save this so
220:12 - now it's saved here but this is the
220:14 - request body so let's go back to the
220:16 - code now you see here we have our
220:19 - structure we're going to receive a
220:22 - request body that's in Json so that's
220:25 - why we're using this Json decoder like
220:27 - we want to decode the Json and then we
220:30 - want to put it into this go code
220:33 - structure so we're going to take the
220:35 - request body that's in Json format and
220:39 - we're simply going to decode it and when
220:43 - we decode it we have to decode it into a
220:46 - pointer to the object that we want to
220:49 - put it into so this is the object that
220:52 - we want to put it
220:54 - into this and symbol is just a pointer
220:58 - but again you don't need to understand
220:59 - pointers for this so just know that
221:01 - we're decoding this Json request body
221:05 - and we're putting it inside of this
221:08 - object here this structure here so we're
221:11 - storing it in memory in this structure
221:14 - so we can actually reference this
221:16 - structure and reference the individual
221:18 - Fields passed in so for example after
221:22 - this line of code we're actually going
221:24 - to be able to do like
221:26 - request. City and that's going to give
221:29 - us like the value for city that was
221:32 - passed in from the request body but
221:35 - first we need to actually check this for
221:38 - errors because this returns an error so
221:40 - we're going to have to do error
221:43 - equals and you guessed it if if error
221:46 - not equal nil will log. print error now
221:51 - actually if we get an error from this it
221:54 - potentially means that the person
221:56 - sending the request here sent the
221:58 - request in the wrong structure so
222:00 - actually what we're going to need to do
222:02 - is we're going to need to send an error
222:05 - response if this gives us an error but
222:07 - first I just want to show you how this
222:09 - code is working so we're going to return
222:11 - after this so it's going to return out
222:13 - of the function we're not going to keep
222:15 - doing the function after that we're
222:16 - going to finish the function if an error
222:18 - gets returned there and let's test out
222:20 - what we have so far so let's run our
222:23 - server G run server. go and let's go
222:28 - back to postman so let's go here and
222:31 - let's send some invalid structure so
222:34 - let's just copy take this out for now
222:37 - and we'll just send like text this is
222:40 - invalid and let's go ahead and send that
222:43 - and you see that we get a 200
222:45 - okay response here but that's just the
222:47 - default that gets returned when we don't
222:49 - return a response from the function so
222:52 - let me show
222:53 - you if you go here you can see that we
222:55 - got an error that says invalid character
222:57 - T looking for beginning of value but the
222:59 - reason we got a successful response is
223:01 - because if we don't use this writer like
223:04 - if we never use this writer we get to
223:06 - the end of this function and we've never
223:08 - written any response to the writer the
223:11 - the default response that gets written
223:13 - to the writer is a success so what we
223:16 - actually want to do is if there's an
223:18 - error here instead of printing the error
223:21 - we want to do the same thing HTTP error
223:24 - again like we did last time and in this
223:26 - case the error can either be something
223:28 - internal like some issue with the Json
223:31 - decoding or it can be an issue with the
223:34 - way that the request was sent to the
223:36 - server and usually we'd want to actually
223:39 - validate each parameter sent to the
223:41 - reserver in the request but we're not
223:43 - going to do all of that in this tutorial
223:44 - so we're just going to return an
223:46 - internal server error if we get an error
223:49 - from this decoder so we need to pass in
223:52 - the writer and for the string we'll just
223:54 - pass in the error but since the error is
223:56 - type error we have to convert it to a
223:59 - string by doing this so as you can see
224:02 - this error function on this error it
224:05 - returns a string so this is how you
224:07 - return an error as a string and then the
224:09 - code will be HTTP do status internal
224:14 - server error and then what we can do is
224:16 - we can print out all of these values so
224:19 - you can see them coming from the actual
224:22 - front end so we can do
224:25 - format. print line and then remember
224:28 - it's in this request object here so
224:31 - we'll do request DOT first
224:35 - name last name address one address to
224:41 - city state ZIP
224:46 - country and we can go into our terminal
224:49 - and let's restart the server and now
224:51 - when we go back into Postman we can
224:54 - actually we can change this back to
224:55 - Jason and then put in our actual Jason
224:59 - object and we can send it and as you can
225:02 - see we didn't get the error returned to
225:04 - us so that's good news and as you can
225:06 - see here everything got printed to the
225:09 - screen first name last name address one
225:12 - address two city state ZIP code so
225:15 - that's how we're receiving the request
225:18 - body using this request up here from the
225:22 - person sending the request to the server
225:24 - and this is where we're defining the
225:26 - structure so we're decoding that Json
225:29 - object into a go structure and then now
225:32 - we have access to these values and we
225:35 - can now use these values to actually
225:38 - finish writing the code for this
225:40 - endpoint now this endpoint actually the
225:43 - the most important value that we need
225:45 - from the request is the one product ID
225:50 - this is the one that we're going to use
225:51 - to create the payment intent because
225:54 - with the product ID we're going to know
225:57 - the price of the product so we know how
226:00 - much we're going to charge the user now
226:03 - this data here is to send the product to
226:06 - the user but this data isn't going to be
226:08 - used on the stripe end like we're not
226:10 - sending this data to the stripe server
226:12 - this we're going to well we're not going
226:14 - to in this tutori tutorial but this what
226:15 - we would do with it is we might say for
226:18 - example store this data in a database
226:21 - with like an order number and then
226:24 - associate the order number with that
226:26 - customer's uh payment intent somehow and
226:29 - then later on when we received
226:32 - confirmation that the customer confirmed
226:34 - the payment from stripe then we could
226:37 - access that customer's like shipping
226:39 - information in a database or something
226:40 - and send the product but in this
226:42 - tutorial we're not doing the database
226:44 - for this at all we're only going to
226:45 - focus on the payment so what we're going
226:48 - to need for the code that we're actually
226:50 - going to write is this request product
226:54 - ID which is the first field in this Json
226:59 - object and it's also the first field in
227:01 - our G struct so now we can start writing
227:04 - the code to create the payment
227:07 - intent and to create the payment intent
227:10 - we actually need to import some packages
227:13 - from stripe so stripe actually has tools
227:16 - written in go that integrate with go
227:18 - code so if you go to your your web
227:23 - browser and you type in go stripe you
227:26 - see this go library for stripe API so
227:29 - you go to this GitHub page and you
227:32 - scroll all the way down to the
227:34 - documentation and it tells you how to
227:37 - install it here installation so
227:39 - essentially what we're going to need to
227:41 - do we don't need to do this part because
227:43 - goand already did this part for
227:48 - Force so let's just try to First write
227:51 - the code for creating a payment intent
227:54 - and then doing the Imports after that so
227:56 - let's see if we can do that so to write
227:58 - the code to create a payment intent we
228:01 - first need to create the parameters that
228:04 - we need to pass to the stripe API to
228:06 - create the intent so we're going to say
228:10 - pams equals and then the and symbol
228:13 - stripe do
228:16 - payment
228:17 - intent prams and we're going to do it
228:20 - like that so we're going to go back to
228:24 - Chrome and here we're going to use this
228:26 - command here to install the
228:29 - packages and let's go back and inside of
228:34 - our directory our project directory we
228:37 - can paste this command and paste it in
228:39 - and then press enter so then it added
228:42 - those so now we should be a to go here
228:46 - and import them actually it's saying
228:49 - it's indexing the dependencies okay so
228:51 - it added that for us then so now if we
228:54 - go back down here this is working fine
228:57 - now okay so this here comes from the
229:01 - stripe library and so does this payment
229:04 - intent perams so this is basically a
229:07 - struct as well so we just created a
229:09 - struct right so to request for a stripe
229:13 - to create the payment in intent object
229:15 - for us we need to give them these
229:17 - parameters here and they're not all
229:18 - required only some of them are required
229:20 - so let's fill those in to create the
229:23 - pams so these are the pams we're going
229:25 - to send to the stripe API and then based
229:28 - on these pams the stripe API is going to
229:31 - send us the payment intent object so the
229:33 - first Pam is going to be the amount and
229:36 - the amount is going to need to use
229:39 - Stripes type
229:41 - called int 64 and an amount and the way
229:46 - that we're going to do this amount is
229:48 - we're going to create our own function
229:51 - called calculate order
229:54 - amount and it's going to take in the
229:57 - request. product ID now let me explain
230:00 - what we're doing here so we need to give
230:03 - a value to amount to give to the stripe
230:06 - server and I explained to you we have to
230:08 - send this information to the stripe
230:10 - server so they can send us the payment
230:12 - and sent object back the same one that I
230:14 - explained when I went over it with the
230:16 - Blackboard now stripe has its own N64
230:20 - type and whatever we return from our
230:23 - function we need to convert it to
230:25 - Stripes int64 type and remember earlier
230:28 - I explained to you how to convert one
230:31 - type into another type remember I told
230:33 - you for example we can do string and
230:35 - then put an INT in there and it would
230:38 - convert this in into a string which
230:40 - would end up being looking like this so
230:43 - we're doing the same thing
230:46 - here with stripes own int64 type we're
230:49 - converting the return value of this
230:51 - function we're going to create into
230:53 - Stripes own int64 type so we need to
230:58 - create this calculate order amount
230:59 - function so we can go down here under
231:02 - our health function and we'll create
231:05 - another Funk called calculate order
231:07 - amount and it's going to take in a
231:10 - string which is the product ID
231:15 - and remember this product ID is coming
231:18 - from the request remember we're asking
231:20 - for product ID in the request and this
231:22 - is how we're going to know how much to
231:23 - charge the person CU we only have a
231:25 - select number of products and based on
231:28 - the product ID we know the price of the
231:30 - product and I'll show you what I mean by
231:32 - that soon so we're going to need to take
231:34 - the product ID into this function that
231:37 - we create and our function is going to
231:39 - need to return a normal int64 so go has
231:43 - go has a type called int64 as well and
231:47 - you don't have to know what 64 means
231:49 - just think of it as an integer it's just
231:50 - a differ size integer just think of it
231:52 - as an integer and we're going to return
231:55 - int
231:56 - 64 from our calculate order amount
232:00 - function and our calculate order amount
232:02 - functions going to be simple it's just
232:04 - going to return a price depending on
232:08 - what the product is and we'll just go
232:10 - ahead and use a switch St statement here
232:13 - so switch statement
232:15 - is basically just a conditional
232:17 - statement so we'll do
232:19 - switch
232:21 - product ID and then we'll do
232:24 - brackets and we'll say case and if the
232:27 - product ID is forever pants will return
232:32 - the price for forever pants and we'll
232:35 - say they're
232:37 - 26,000 but this is because we're doing
232:40 - the money in cents so this is actually
232:42 - just
232:42 - $260 and then we'll do case forever
232:46 - shirt and the forever shirt's going to
232:48 - cost
232:50 - $155 and we'll do case forever
232:53 - shorts and the shorts will be $300 and
232:57 - if it's none of those we'll just return
233:00 - zero and it actually should never be
233:02 - none of them but we're not doing any
233:05 - validation on the input from the person
233:08 - sending the requests so it's possible so
233:10 - we'll just return zero so this is our
233:12 - calculate order amount function
233:15 - and here to get the amount for this
233:18 - struct that we're going to use to send
233:21 - the request to the stripe API we're
233:23 - going to call the calculate order amount
233:25 - function with the product ID which is
233:28 - going to be the name of the product so
233:30 - it's the product ID is either going to
233:32 - be forever pants forever shirt or
233:34 - forever shorts and it's going to return
233:37 - the corresponding price and that price
233:40 - is going to get converted to stripes in
233:42 - 64 instead of goes in in 64 so that's
233:47 - going to be the amount and the next
233:48 - field that we need to fill in and let me
233:51 - just clarify here this is the same thing
233:54 - as if we were to do if product ID equals
233:58 - forever pants return this if product ID
234:02 - equals forever shirt return this but
234:04 - switch is just like a cleaner way to do
234:06 - it like we can just do switch and
234:09 - product ID if product ID is this one
234:12 - then return this if product ID is this
234:15 - one then return this if product ID is
234:17 - this one then return this so it's the
234:19 - same thing it's like a conditional thing
234:21 - anyways so after we add the amount to
234:24 - that struct we need to add another field
234:27 - and that field is going to be currency
234:30 - and we're just going to default this one
234:33 - so it's going to be a stripe string and
234:35 - then we're going to just convert into a
234:37 - string stripe.
234:41 - currencyusd now this currency USD is
234:44 - provided by stripe and the type is
234:48 - currency strip's currency type stripe
234:50 - has its own currency type so that's why
234:53 - we need to convert it into a regular
234:55 - string here and then we're converting
234:57 - the regular string into Stripes string
235:00 - now I know that's kind of confusing but
235:03 - you don't really need to know the
235:04 - details about that actually I think they
235:06 - stripe should make it so that you can
235:07 - convert their currency type into their
235:11 - string type but apparently you can't so
235:14 - I tried it this way and I'm actually not
235:16 - able to convert their currency type into
235:19 - their own string type so it says cannot
235:21 - use stripe currency type currency as
235:24 - type string so yeah we need to convert
235:29 - it to a string first and then convert it
235:31 - into their string but anyways that's
235:33 - currency so after we fill in currency we
235:37 - need to fill in this automatic payment
235:41 - methods and this one's going to be
235:43 - stripe
235:45 - do payment intent automatic payment
235:49 - method pams now I know this is starting
235:52 - to look really confusing but again this
235:55 - is only a struct so this is just another
235:59 - struct provided by stripe it just has a
236:01 - really long name so stripe wants us to
236:05 - provide an automatic payment methods
236:07 - field for this payment intent param
236:11 - struct so like each of these are
236:13 - parameters that we're going to need to
236:16 - give the stripe API to create a payment
236:18 - intent right so that's why this struct
236:21 - is called payment intent params this one
236:24 - here it's called payment intent params
236:26 - because it's the parameters that we need
236:28 - to ask stripe to create a payment intent
236:32 - so the parameter one is amount parameter
236:34 - two is currency and the other parameter
236:35 - we need is this automatic payment
236:37 - methods but this automatic payment
236:39 - methods the value for this parameter is
236:42 - another struct and this struct is called
236:45 - payment intent automatic payment methods
236:48 - perams which is a long name but all they
236:51 - want is a bull here and it says when
236:55 - enabled this payment intent will accept
236:57 - payment methods that you have enabled in
236:59 - the dashboard and are compatible with
237:01 - this payments other parameters so
237:03 - basically in the dashboard that I showed
237:05 - you earlier where we got those keys from
237:07 - if we enable this we can use the payment
237:10 - methods that we have enabled on the
237:12 - dashboard so we're just going to go
237:13 - ahead and pass a bull of True to this
237:16 - long name here so we'll set enabled the
237:19 - field enabled equal to stripe bull true
237:24 - and you'll notice if we hover over this
237:26 - struct the field that it expects is
237:29 - enabled and it's a bull so we're filling
237:32 - in the field and we're giving it a value
237:35 - of a bull but it has to be converted to
237:37 - a stripe type but we're giving it the
237:39 - value of true so that's all of the
237:41 - payment intent prams we need to use I
237:43 - know there's a bunch of them here but we
237:44 - only need to use these these three thank
237:47 - God so now we have this payment intent
237:50 - params object that we can send to the
237:53 - stripe server and request that they
237:55 - create the payment intent so this thing
237:58 - that we created just now that we filled
238:00 - in it's going to be assigned to this
238:02 - variable here pams and we're going to
238:05 - pass this pams variable to the stripe
238:07 - server and I know this is getting a bit
238:10 - tedious but just bear with me I hope
238:12 - that I'm able to to help you to
238:15 - understand what we're doing here so once
238:17 - we've created the pams for the payment
238:19 - intent we can actually send a request to
238:22 - stripe to create the payment intent so
238:25 - we'll say payment intent and error cuz
238:29 - it potentially returns an error equals
238:33 - payment intent. new and this payment
238:36 - intent here also comes from stripe it's
238:38 - a it's a package from stripe just it's
238:41 - just that goand auto imported it so we
238:44 - go to the top up here we see that we
238:46 - have this package payment intent from
238:48 - from strip go so we're calling this
238:50 - payment intent function called new so
238:52 - this is how you create a payment intent
238:54 - you call this new functions you see
238:56 - function new and the prams it expects is
239:00 - a stripe. payment intent params and
239:03 - that's what we created here so this can
239:06 - go in here so we'll do params and if you
239:11 - check here you can see that EX it
239:14 - expects a pointer and we're giving it
239:17 - and we're creating a pointer here this
239:19 - is a pointer we're creating but remember
239:21 - you don't need to know about pointers
239:22 - yet that's something that you'll learn
239:24 - later on so yeah we're passing in this
239:28 - object here with these values that we've
239:30 - created here so we're passing that into
239:33 - this new function and since it
239:36 - potentially returns an error we have to
239:39 - handle the error if one exists so if
239:41 - error not equals nil in this case we'll
239:45 - return an internal server error the same
239:48 - as this one from when we decoded the
239:51 - Json we're going to return that if the
239:53 - error is not nil so we're doing the
239:55 - exact same thing here if if creating the
239:57 - payment intent with the stripe server
240:00 - returns an error to us we're going to
240:02 - return an error to the front end with
240:05 - the error as a string and an internal
240:08 - server error status but if we're
240:10 - successful we'll have the payment intent
240:13 - because look we're in we're assigning
240:15 - payment intent to this variable payment
240:17 - intent right so that means that we'll
240:19 - have the payment intent if we don't get
240:22 - an error here so down here we'll have
240:25 - the payment intent and remember when I
240:27 - showed you in the Blackboard the payment
240:30 - intent going to have a customer key like
240:32 - a secret ass assigned to it and it's
240:35 - going to be called client secret this is
240:37 - the customer key that I was explaining
240:39 - to you in the in the Blackboard using
240:42 - the Blackboard so remember this client
240:45 - secret is going to get sent back to the
240:47 - front end and then when the customer
240:50 - confirms the order the front end's going
240:52 - to send this client secret and the order
240:55 - confirmation to the the stripes payment
240:58 - confirm API and that's going to confirm
241:01 - the payment for the customer so we need
241:03 - to send this client secret back to the
241:06 - front end but first let's go ahead and
241:08 - test out what we have so far so we'll
241:10 - just print this for now so print line
241:14 - now remember this new function this new
241:18 - function is actually going to call
241:20 - Stripes API like there it's going to
241:22 - call stripe server so it looks like it's
241:24 - just a function in our code that just
241:26 - handles that just triggers some code in
241:29 - this package right but this code that
241:31 - gets triggered actually sends a request
241:34 - to Stripes API to create this payment
241:37 - intent and Stripes API Returns the
241:39 - payment intent to us here they either
241:42 - return the error or the payment intent
241:44 - and when we get the payment intent it's
241:47 - actually from the stripe server and
241:49 - we're going to print the client secret
241:50 - that we got from the stripe server and
241:53 - this is still all of this code is still
241:57 - inside of our handle create payment
241:59 - intent
242:00 - endpoint so let's test this out let's go
242:03 - ahead and yeah test it out and we have
242:06 - to make sure when we give the product ID
242:08 - we have to use one of
242:10 - these so yeah let's run our server go
242:13 - run server. go and let's go open Postman
242:17 - and let's change our product ID here to
242:20 - one of the ones we actually have a price
242:22 - for and let's send this and actually we
242:25 - got an internal server error and that's
242:27 - because we didn't provide so you can see
242:31 - let me try and make this larger so you
242:33 - can see the response that we got from
242:35 - the API and our API is actually just
242:38 - returning the response that we got from
242:40 - stripe when we try to send the request
242:43 - so strip type tells us you did not
242:45 - provide an API key you need to provide
242:48 - your API key in the authorization header
242:50 - so I forgot to actually show you that we
242:53 - need to do this so when we're calling
242:55 - Stripes API from our server so we're
242:58 - calling when we're calling Stripes
242:59 - server from our server we need to have a
243:01 - key an API key to access their API so
243:05 - that's why we got the error here we
243:06 - didn't provide the key so you need to go
243:10 - to your stripe dashboard so open the
243:13 - brow browser and do stripe stripe
243:17 - dashboard and stripe login and sign into
243:21 - your stripe account and once you're sh
243:24 - signed into your stripe account on your
243:26 - dashboard you're going to see this
243:27 - secret key here now this secret key is
243:31 - the key that you need and it's just a
243:32 - test key so don't worry but yeah this
243:34 - one you want to copy so you're going to
243:37 - copy this secret key and then you're
243:39 - going to go back to your go code and
243:44 - let's minimize that and we're going to
243:46 - go back up to our main function area now
243:49 - in a real world situation you'd never
243:51 - store your key any type of secret key or
243:54 - any type of Secret in your code in your
243:57 - actual code this is like a huge security
243:59 - vulnerability but this is a test key and
244:02 - this is a tutorial so yeah I just need
244:04 - to make that clear so you guys don't
244:06 - think that this is a common practice or
244:08 - something you should do in a real world
244:09 - scenario in a real world scenario this
244:11 - is not how you should hand handle your
244:14 - secrets so I'm just going to do stripe.
244:18 - key so this is a variable from stripe
244:21 - and we can set it equal to the key that
244:24 - we just
244:25 - copied so this stripe key if you hover
244:29 - over it key it says key is a stripe API
244:32 - key used globally in The Binding so if
244:35 - we assign our key to this to this
244:38 - variable that comes from stripe stripe's
244:40 - going to be able to use this key when it
244:42 - makes calls to the API so when it makes
244:45 - a call to the API down here in this new
244:49 - function it's going to make a call to
244:51 - the API and it's going to use the key
244:53 - from that variable that we just gave it
244:55 - but I have to say this again this is not
244:58 - something that you would ever do in a
245:00 - production application you'd never just
245:01 - store the secret in the code like this
245:03 - like right in the open this is just a
245:06 - test key and this is just for purposes
245:09 - of teaching you how to do this and
245:11 - teaching you the go programming language
245:13 - but this isn't a practice that you
245:14 - should get in the habit of doing but of
245:16 - course I don't have time to teach you
245:19 - how to actually handle secrets in an
245:22 - application in this tutorial because
245:24 - it's not the focus of this tutorial but
245:26 - just just please remember that that this
245:28 - is not don't don't get in the habit of
245:30 - doing this but anyway so this is our API
245:33 - key we're assigning it to Stripes key
245:35 - variable and stripe's going to use it
245:37 - when it calls its own
245:39 - API in this new function in this new
245:42 - function here where we're we're asking
245:44 - stripe to create the payment intent and
245:46 - send it back to us so we can go down
245:49 - here contrl C and let's clear that and
245:52 - go run server. go again and now let's go
245:56 - back to postman and let's send it again
245:59 - now this time you see we got a 200
246:01 - status okay so that means if we go back
246:04 - to
246:05 - our code our server here you see that
246:09 - our our customers secret the client
246:13 - Secret gets printed to the screen and
246:15 - again we're not going to be you're not
246:17 - going to want to print this secret to
246:19 - the screen you never want to print
246:20 - secrets to the terminal but we're doing
246:22 - this for testing purposes and of course
246:25 - this isn't a real client secret this is
246:28 - a test client secret so anyways just
246:30 - keep those things in mind so we've got
246:33 - the application working up until this
246:35 - point so now we just need to send this
246:38 - client secret back to the front end so
246:41 - the front end whenever the custom
246:43 - customer confirms the order can actually
246:45 - use this client secret when sending the
246:48 - confirmation of the payment to the
246:50 - stripe server so to do that we're going
246:53 - to create another struct and we're going
246:55 - to call it response so the same way we
246:59 - created this struct for the request up
247:02 - here we're going to create another one
247:04 - for the response that we're sending back
247:06 - to the front end because we're going to
247:09 - send it back to them in Json basically
247:13 - the same way they sent the request body
247:15 - to us so we'll just call this response
247:18 - and it's going to have client secret and
247:21 - it's going to be a string and it's Jason
247:24 - equivalent is going to be client and
247:27 - we'll do Secret we're not going to do
247:29 - snake case this time because the front
247:30 - end is going to use camel case so let's
247:33 - we're going to send it like this so now
247:35 - we have this structure right that it
247:38 - only has one field which is client
247:39 - secret but it's empty right now so this
247:42 - response is empty so we need to take
247:44 - this response do client secret and we
247:48 - need to assign the client secret a value
247:51 - of this client secret here so from the
247:54 - payment intent that we got here we can
247:56 - get the client secret so we'll do
247:58 - payment intent. client
248:02 - secret so now our response has the
248:06 - client Secret in this field here so now
248:10 - we can send this response back to the
248:13 - caller of our API endpoint so now
248:16 - instead of decoding the Json like we did
248:19 - before so before remember we were
248:22 - decoding the Json
248:26 - because from the request we're sending
248:29 - Jason this is Jason see here Jason so
248:31 - we're sending Jason to the server so we
248:34 - need to decode
248:36 - that into go code right so we needed to
248:40 - decode it into go code but now we're
248:42 - doing the reverse we need to convert go
248:46 - code this struct here is go code right
248:49 - we need to convert this struct into
248:51 - Jason so now we need to encode so we
248:54 - need to use json. new
248:57 - encoder and we need to encode it into
249:02 - what we call a buffer so we'll just say
249:04 - VAR buff is bytes. buffer and you don't
249:09 - need to know details about this bytes.
249:12 - buffer here so just know that we need to
249:14 - send it back in bytes and I explained to
249:16 - you some stuff about bytes when we went
249:18 - over the slice the B slice so into this
249:23 - buffer we want to encode our
249:28 - response so this response here so this
249:31 - response we want to encode it using this
249:34 - encoder into this buffer and remember
249:36 - this returns an error so we want to do
249:39 - error equals and then do if error not
249:43 - equal nil and then we need to handle the
249:45 - error and remember I forgot I told you
249:48 - we can't declare a variable again
249:51 - remember so we have to not use that
249:53 - since we already declared this error up
249:55 - here somewhere here so we already
249:57 - declared the variable so now we can just
249:59 - use error equals here and then if error
250:02 - not equal nil we're going to do the
250:04 - exact same thing that we did with when
250:08 - we were
250:09 - decoding which is the same thing that we
250:12 - did here as well when we sent the
250:14 - request to the stripe API to get the
250:17 - payment intent object we're going to
250:20 - return the same error in this case an
250:22 - internal server error so if we can't
250:24 - encode this response then we're going to
250:28 - return this error to the person sending
250:30 - the request but if we can after it's
250:33 - encoded we're going to send it back to
250:36 - the person that sent the request to this
250:38 - endpoint and we're going to do that
250:41 - using our writer remember the writer
250:43 - that we used before it's at the top of
250:45 - this function the writer here we're
250:47 - going to do writer. header do set and
250:51 - we're just going to do content type
250:54 - application Json now all this is doing
250:57 - is it's adding a header to the response
251:00 - and it's essentially like a tag that
251:02 - we're adding to the response that labels
251:04 - this response with content type Json
251:08 - because we're sending back a Json object
251:10 - to the caller so we're sending adjacent
251:14 - object similar to this one but ours is
251:15 - only going to have one field which is
251:17 - the client secret but we're still
251:19 - sending adjacent object back so here
251:21 - we're just essentially adding like a tag
251:24 - to the response saying that it's
251:26 - adjacent object and then after we do
251:28 - that we need to actually do something
251:31 - that's going to look super complicated
251:33 - but I'm going to explain to you what
251:34 - it's doing so we're going to do io. copy
251:37 - and we're going to pass in our writer
251:40 - and that buff that we created now if I
251:43 - hover over this copy so IO is another
251:46 - package from GH standard Library so if
251:49 - you scroll to the top you see that it
251:50 - automatically got imported now if I
251:53 - hover over this copy you see that copy
251:56 - copies from source to destination until
251:59 - in file eof means in file is reached on
252:03 - Source or an error occurs now into file
252:06 - just means exactly what it says into
252:08 - file so imagine that that Json object is
252:11 - just a stream of data and we're
252:13 - streaming it into the writer that's all
252:16 - this io. copy is doing so it says copy
252:19 - copies from source to destination until
252:21 - end file so once that stream reaches the
252:23 - end there's nothing left to stream into
252:25 - writer right so at that point the entire
252:29 - buffer is has been written to writer and
252:31 - that's essentially what this io. copy is
252:34 - doing in simple terms so we'll go ahead
252:37 - and it's going to return an it it
252:39 - potentially returns an error so we have
252:41 - to do error
252:44 - equals and then if actually it returns
252:48 - something else too but we're just going
252:49 - to ignore it so we'll do if a not equals
252:53 - nil in that case we're not going to be
252:56 - able to return anything because we've
252:58 - already we'd already be done with the
253:00 - writer at that point and the writer is
253:02 - how we return things to the caller the
253:05 - person calling our endpoint so at that
253:07 - point we would just print line if
253:09 - there's an error we'll just print the
253:11 - error and I forgot to add the the
253:13 - package and that is everything for this
253:17 - endpoint that is the code for this
253:20 - create payment intent endpoint so at
253:23 - this point you can go to project and let
253:26 - me close that and format your server. go
253:35 - file and now we can go ahead and test
253:38 - this out so so here we're creating we're
253:43 - sending the request to the stripe server
253:45 - to create the payment intent and it's
253:47 - sending us back the payment intent
253:48 - object in this payment intent variable
253:51 - here and then we're printing it here but
253:53 - we don't need to print it anymore that
253:55 - was just for testing then we're creating
253:58 - a a response struct this is the
254:00 - structure of the data that we're going
254:01 - to return and I'll show you what that is
254:03 - in a second so this is what gets
254:05 - returned to the person calling our
254:07 - endpoint this this is what the structure
254:09 - is it's going to have a field client
254:11 - secret with a value
254:13 - then we're setting this client secret
254:15 - fied in this empty struct to the client
254:19 - secret which is inside of the payment
254:21 - intent object here the one that we got
254:24 - from the stripe API and then we're
254:26 - creating this empty buffer and then
254:28 - we're encoding our response the one that
254:32 - we created up here into adjacent string
254:35 - essentially and then we're adding this
254:37 - header here which is essentially like
254:38 - just a tag saying that this response is
254:41 - going to be of type application Jason
254:43 - which is Jason and then we're copying
254:46 - from that buffer that Jason string into
254:49 - the writer and the writer is the
254:51 - response writer so this is what the
254:54 - caller of the API is going to be able to
254:56 - read from so let's test it out so let's
254:59 - stop running our server and then do go
255:01 - run server. go and let's go to postman
255:05 - and the moment of truth let's send this
255:08 - request and as you can see what we get
255:11 - back is the this Json structure that has
255:15 - a field client secret the same as I
255:17 - showed you in the backend code and it
255:19 - contains the client secret so we've
255:22 - successfully implemented our backend and
255:26 - now all that's left to do is connect it
255:29 - to the front end so yeah this is the
255:31 - response body so this is the body that
255:34 - we send to the front end and the front
255:36 - end is going to take this client secret
255:39 - and when the customer confirms the
255:41 - payment the front end's going to send
255:43 - this client Secret in a call to the
255:46 - stripe API to confirm the payment and
255:48 - from there you should be able to view
255:50 - the payments in your stripe dashboard
255:54 - now let's take a second to actually have
255:56 - a look at this dashboard so we can
255:58 - actually get a feel for the flow that I
256:01 - explained to you in the Blackboard by
256:04 - making use of this dashboard before we
256:06 - connect the front end so we'll get back
256:08 - to connecting the front end soon but
256:10 - let's just go over this dashboard so
256:12 - make sure you're logged into your
256:14 - dashboard and since we've been messing
256:16 - around with um our backend code and
256:20 - attempting to send requests to the
256:21 - stripe API we might have some data on
256:25 - our dashboard already some unexpected
256:28 - data so in order to test this out let's
256:31 - go ahead and click this developers
256:34 - button up here and then at the bottom
256:36 - here you want to select delete all test
256:39 - data this is going to delete everything
256:42 - that may have been created as we were
256:44 - trying to test things out and we'll just
256:46 - do start deletion and you need to
256:48 - confirm your password to delete and then
256:50 - just hit continue and once the data has
256:52 - been deleted we can go ahead and test
256:54 - this out so we're going to start by
256:56 - testing it out just using Postman so
256:58 - we're going to first test out the
257:00 - payment intent like I want to show you
257:02 - guys what it looks like when the
257:04 - customer creates a payment intent but we
257:07 - don't confirm the payment yet so if you
257:10 - select this payments tab up here on your
257:13 - dashboard in all payments you should see
257:16 - nothing right now because we deleted all
257:18 - of the data there should be just this
257:20 - here but if we go ahead and open up
257:24 - goand and we start up our server so
257:27 - we'll do go run server. go and then we
257:30 - open up Postman we're going to send a
257:34 - payment intent for the product ID
257:36 - forever pants so if we go into the code
257:40 - and we go down to where're we're
257:43 - actually defining the prices for the
257:46 - products in that function that we
257:47 - created called calculate order amount we
257:50 - can see forever Pants cost
257:52 - $260 so this is $260 in cense so if we
257:57 - go to postman and we send this request
258:01 - to create a payment intent to our back
258:03 - end we get the client secret back here
258:06 - and we can go ahead and copy this client
258:09 - secret and then we can head back to the
258:11 - dashboard and we can refresh this
258:14 - payments page and now you'll see here
258:16 - that we have a payment it's an
258:18 - incomplete payment because it's only the
258:20 - payment intent the customer hasn't
258:22 - confirmed the payment yet but it's for
258:25 - $260 and if we select it and we scroll
258:29 - down if you press command F to search
258:32 - the page and then paste in that client
258:35 - secret that you got from the response
258:38 - and you have to delete part of it cuz it
258:40 - doesn't show the full thing so you're
258:42 - going to just delete all the way back
258:45 - until you get to where it says secret
258:48 - here and then delete this underscore
258:50 - secret uncore and if you do that and
258:52 - then you press enter you see that this
258:55 - is the payment intent that we received
258:59 - the client secret
259:01 - for here so we've created the payment
259:04 - intent and we can see it on our
259:06 - dashboard and if you scroll up here you
259:08 - can see that there's no customer
259:10 - information or payment method
259:12 - information or anything like that
259:13 - because that's going to be updated on
259:16 - stripe or populated on stripe once the
259:19 - front end sends the confirmation of the
259:21 - payment to the actual stripe server so
259:25 - now we need to connect our frontend to
259:28 - set up the functionality to actually
259:30 - complete the payment so we can go to
259:33 - home and there's one thing that you
259:35 - definitely need to check here to make
259:37 - sure this is working and we went over
259:39 - this before this publishable key this
259:42 - key is needed on the front end the front
259:46 - end needs to provide this key when it
259:48 - calls Stripes apis so that point in the
259:52 - video where I told you to update that
259:54 - file on the front end with this key it's
259:57 - very important like it won't work you
259:58 - won't be able to confirm the payment if
260:00 - you haven't updated this key on your
260:02 - front end code so let's go and open our
260:09 - terminal and let's change directory to
260:13 - that front end code go for beginners
260:15 - front end and let's LS here now remember
260:19 - in this folder there's another folder
260:21 - called source so we change directory to
260:24 - source and then we LS here and in this
260:27 - Source directory there's a file called
260:30 - stripe payment. jsx and actually maybe
260:33 - we can just open this file with goand
260:37 - even though it's not a go file I'm
260:39 - pretty sure we can still just open this
260:41 - file with goand so it's easier to see so
260:43 - let's go to goand and we can stop
260:46 - running our server for now and let's
260:48 - just select project here actually we can
260:50 - just hit file up here and then just
260:52 - select open and then here you should be
260:54 - able to open this go for beginners
260:58 - frontend in the source folder and you
261:00 - should be able to open this stripe
261:02 - payment. jsx file so select that file
261:05 - and then just hit open now let's
261:07 - minimize that so you should be able to
261:10 - see in the code here we have this thing
261:13 - that says const stripe promise and load
261:16 - stripe and in there we have this key you
261:20 - need to make sure that this key is the
261:22 - key from your dashboard so if you go to
261:25 - the dashboard it has to be this
261:28 - publishable key if it's not there your
261:30 - front end is not going to work it's not
261:31 - going to integrate with our backend
261:34 - correctly so just make sure you did that
261:38 - and now all we need to do is go back to
261:41 - our terminal and let's just change
261:43 - directory back One Directory so let's
261:46 - move back one folder so you should be
261:48 - back in the Go for beginners front in
261:50 - folder and let's
261:52 - clear and then open your goand IDE again
261:57 - and you can leave this page once you've
261:58 - changed that to your publishable key and
262:02 - then you can just select terminal and we
262:04 - need to run the server again so we we
262:06 - need to have the server running so our
262:07 - front end can connect to it so we'll do
262:09 - G run server. go and with the server
262:12 - running you can open up your terminal
262:14 - again and in your terminal you should be
262:16 - able to just type in mpm
262:22 - start and this should open up the
262:25 - product page at Local Host 3000 SL
262:29 - product and from here you should be able
262:32 - to select a product so whatever product
262:34 - you select that's going to be the price
262:36 - that shows up for the payment on your
262:38 - stripe dashboard so for example I'll
262:40 - select this shirt I'll just select buy
262:43 - now and from here you should simply be
262:45 - able to input some fake data so I'll
262:48 - just put in like John do but you can
262:51 - actually put in whatever you want here
262:53 - because remember we're not going to add
262:55 - the functionality to actually store the
262:58 - shipping address and stuff like that in
263:00 - the database for this tutorial so
263:02 - although this will be sent in the
263:04 - payload to our backend we're not going
263:06 - to do anything with it at the moment so
263:08 - just go ahead and put in some dummy data
263:10 - here and then you can just hit next
263:13 - and at that point after you hit next
263:16 - after inputting that dummy data and we
263:18 - end up on this enter your credit card
263:21 - information page that means that at that
263:23 - point the payment intent has been
263:26 - created so on our backend or rather when
263:29 - the front end reaches this page it sends
263:31 - a request to our back end immediately to
263:33 - create the payment intent so on our
263:35 - backend we should have already sent the
263:37 - request to the stripe server to create
263:39 - the payment intent so we should be able
263:41 - to see that on our dashboard so if we go
263:44 - to the dashboard and we go to payments
263:47 - again you should see the payment here
263:49 - for whatever product you picked so I
263:51 - picked the one that cost
263:53 - $155 so it created the payment intent
263:56 - for that one and it shows is incomplete
263:58 - right now but once I confirm the payment
264:01 - on the front end this should become
264:03 - complete so if we go to our front end
264:05 - here you notice that we need to input
264:07 - credit card information now stripe has
264:10 - test credit cards that we can use that
264:12 - actually will work for this like we can
264:15 - the the credit cards will get sent to uh
264:18 - Stripes API and those test credit cards
264:21 - will actually work so let's go to Google
264:24 - and type in stripe test credit card
264:29 - numbers and here you see test cards just
264:33 - select that and we can scroll down here
264:35 - and we see this is one of them but
264:37 - there's actually multiple different ones
264:39 - that we can use give me one second so if
264:40 - we scroll down to here here we see that
264:43 - there's different ones depending on
264:46 - whatever brand you want to use so all of
264:48 - these cards simulate a successful
264:50 - payment and the billing country for each
264:52 - test card is set to the United States so
264:55 - let's just do American Express we'll
264:57 - just copy a card you can do whatever one
264:58 - you want just copy one of these card
265:00 - numbers and go back to the page and just
265:03 - paste it in and you can see it shows up
265:05 - as an American Express card and actually
265:09 - for the CVC you can use any three digits
265:11 - and for the date you can use any future
265:13 - date so as long as it's not a date in
265:15 - the past the expiration can be any
265:17 - future date so we can just do 01
265:20 - 2024 and then the CVC we can do any
265:23 - three digits and for the email let's
265:25 - just do a test email so you can just do
265:28 - like email gmail.com and you can select
265:32 - this save your info for secure oneclick
265:35 - checkout with link or whatever but you
265:37 - don't need to do that so you can just
265:38 - hit pay now and when you hit pay now our
265:42 - front end's going to send a request to
265:45 - the stripe server using the customer
265:48 - like the client secret for that payment
265:50 - intent that we originally initiated when
265:53 - we picked the product that we wanted to
265:55 - buy and it's going to confirm the
265:56 - payment and that should show up on our
265:58 - dashboard so let's hit pay
266:00 - now and you see we get directed to this
266:03 - payment successful page or payment has
266:05 - been processed successfully you will see
266:07 - you will you will receive email
266:08 - confirmation of your order shortly and
266:11 - we didn't implement the email
266:12 - confirmation there wasn't enough time so
266:14 - don't worry about that but now if you go
266:16 - back to your dashboard and you refresh
266:19 - this page you should see that this
266:21 - payment is now succeeded and if we
266:24 - select it now there's customer
266:26 - information so we have the customer
266:28 - email here we have the credit card
266:31 - information here and for me it's
266:32 - converting it to JPY because I'm in
266:34 - Japan but you get all this additional
266:37 - information here because when the front
266:39 - end sent that payment confirmation
266:43 - to the stripe server stripe updated all
266:45 - of the information for the original
266:47 - payment intent so now this is no longer
266:50 - a payment intent this is an actual
266:52 - payment successful payment it starts off
266:54 - as a payment intent and then once it's
266:56 - confirmed it becomes a successful
266:58 - payment and that is the front end
267:03 - communicating with our backend and
267:05 - everything is now integrated so we've
267:07 - integrated our front end here with our
267:10 - backend server that we have running on
267:12 - our local machine which is communicating
267:15 - with the stripe servers and we've
267:18 - successfully implemented this product
267:21 - payment application and like I said
267:23 - there are more things that we can do to
267:26 - make this application more realistic
267:28 - like actually storing the customers
267:31 - shipping data and creating a websocket
267:34 - for stripe to send us a request to our
267:38 - server letting us know that the payment
267:39 - confirmation is complete and all of
267:41 - those things but of course we don't have
267:43 - time to get into that in this video this
267:46 - was an introduction to programming in
267:48 - the go programming language so I didn't
267:50 - want to overload you with too much
267:53 - complex information so as it stands
267:55 - right now you can have customers
267:58 - purchase products on a site or whatever
268:00 - and you can just manually go and check
268:04 - which customers actually purchased a
268:07 - particular product and actually I
268:09 - recommend that you try and build this
268:11 - out more to to make it more functional
268:13 - like more functional in a real world
268:15 - situation and I think that would be a
268:17 - good learning opportunity for you but
268:19 - actually there's one more thing I need
268:21 - to mention as well so this front end it
268:25 - runs on Local Host uh 3000 right now
268:29 - right and right now we're just using
268:32 - regular HTTP but actually whenever
268:36 - you're dealing with sensitive data like
268:39 - in general these days you shouldn't be
268:40 - using just HTT P so if we actually hit
268:43 - this thing here it says your connection
268:45 - to this site is not secure you should
268:47 - you should not enter any sensitive
268:49 - information on this site for example
268:50 - passwords or credit cards because it
268:52 - could be stolen by attackers now the
268:54 - reason for that is because we're running
268:55 - this on our local server we didn't
268:57 - Implement TLS and what that would look
269:00 - like is it would be
269:02 - https but if we hit enter here it
269:05 - doesn't exist we're not we don't have we
269:07 - don't have TLS on this site so actually
269:12 - the site is insecure as it stands right
269:15 - now you wouldn't deploy this to
269:16 - production without using TLS so if you
269:19 - go to Google and just type in what is
269:21 - TLS and we can just hit this one from
269:23 - internet Society so it says TLS or
269:27 - transport layer security encrypts data
269:29 - sent over the internet to ensure that
269:31 - ease droppers and hackers are unable to
269:33 - see what you transmit which is
269:34 - particularly useful for private and
269:36 - sensitive information blah blah blah
269:38 - like well not really blah blah blah
269:40 - because this is actually very serious so
269:42 - if you're ever to deploy something like
269:45 - this to a production environment you
269:47 - need to use TLS because if you don't
269:50 - when the customer in inputs their
269:52 - information and their credit card
269:54 - information and it gets sent to the
269:55 - backend server that payload that's
269:58 - getting sent to the backend server can
270:00 - be intercepted by anybody with access to
270:04 - whatever Network you're on so if you're
270:06 - in like a Starbucks or something
270:08 - somebody in that Starbucks on the same
270:10 - network can just intercept that payload
270:13 - and read your credit card information
270:15 - from that payload because when you don't
270:17 - use TLS those payloads aren't encrypted
270:20 - and you know that a site's not using TLS
270:23 - when it's just HTTP and not https so the
270:27 - beginning of a URL has that HTTP part
270:31 - right so if it just says HTTP like this
270:34 - that site's not using TLS don't put any
270:36 - sensitive information don't even use
270:37 - that site because in this day and age
270:40 - all sites should have TLS so I I feel
270:42 - like it's important to stress that like
270:44 - if it's de deployed to a production
270:47 - environment it should say https like you
270:50 - should use TLS you should be encrypting
270:52 - the payloads that you're sending those
270:54 - requests should be encrypted the ones
270:56 - that you're sending to the back end if
270:58 - they're not they can be intercepted by
271:00 - anybody on the network and that
271:02 - information can just be extracted
271:04 - because there's no encryption on that
271:05 - payload it's just visible like easily
271:07 - visible like you can just read it it's
271:09 - human readable you can just use wire
271:11 - shark or something to to intercept the
271:12 - packet and just read all of the customer
271:14 - sensitive data so I I went on this rant
271:17 - because it's something that is important
271:20 - to stress whenever you're talking about
271:22 - building some sort of payment service or
271:24 - some sort of payment application or
271:26 - anything that involves customer data
271:28 - like you need to be very careful about
271:29 - customer data so I had to mention that
271:33 - even though it's sort of a complex topic
271:35 - if we were ever to to deploy this to
271:39 - production or to a production server or
271:41 - something or anywhere other than just
271:43 - our local environment where we're
271:44 - testing it we would need to take the
271:47 - time to actually learn about TLS and
271:50 - understand the implications of not using
271:53 - it so yeah that's just the last thing I
271:55 - wanted to leave you with I hope that
271:57 - you'll take some time to look into this
271:59 - because it's actually a very important
272:02 - part of programming especially if you're
272:05 - making applications that involve any
272:07 - sort of customer data or anything like
272:09 - that so yeah I just wanted to mention
272:11 - that but but other than that we've
272:13 - officially reached the end of this
272:15 - tutorial I sincerely hope that I was
272:17 - able to teach you something and if you
272:19 - have any questions or you get stuck
272:21 - anywhere please leave a comment in the
272:23 - comment section I answer all of my
272:25 - comments so even if it takes me some
272:27 - time to get back to you I'll answer your
272:29 - question and I'll help you out so yeah I
272:32 - also have a Discord that'll be linked in
272:34 - the description and it's linked on the
272:36 - channel description and stuff like that
272:38 - but yeah if you've made it to the end of
272:40 - this and you're able to complete this
272:41 - tutorial you should have enough of a
272:44 - grasp of the go programming language to
272:46 - start attempting to build some things on
272:48 - your own or at least expanding on this
272:50 - application that we built together and I
272:52 - encourage you to do that as a final note
272:55 - if you've enjoyed this content I put a
272:57 - lot of effort into the videos that I
272:59 - make I really try to take the time to
273:02 - help people to understand things like
273:03 - this that are seemingly complex or
273:06 - difficult to understand so yeah if
273:07 - you're interested in those types of
273:09 - videos then go ahead and subscribe to
273:11 - the channel and leave a like of course
273:12 - if you made it all the way to the end of
273:14 - this video you should leave a like
273:15 - because I doubt you finished a 5H hour
273:17 - plus video without actually getting
273:19 - something of value from it so yeah in
273:21 - that case you should leave a like so
273:23 - other people can get exposed to this
273:25 - type of content as well anyways
273:27 - congratulations on completing this
273:28 - tutorial and I'll see you in the next
273:30 - one