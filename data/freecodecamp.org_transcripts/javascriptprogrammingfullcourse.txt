00:00 - This is a complete JavaScript course taught
by the founder of Scrimba.com.
00:04 - it is a great place to start your JavaScript
journey.
00:07 - Hi there freeCodeCampers, and welcome to
this fun and practical introduction to JavaScript.
00:13 - In this course, you are going to solve over
100 different coding challenges, you can do
00:18 - that in two ways, either by cloning the GitHub
repository, and then solving it locally on
00:23 - your computer. Or you can head over to scrim
block comm where there's an interactive version
00:28 - of this course, so that you can solve the
challenges directly in your browser up to
00:33 - you what you want to do. Links are, of course,
provided below. Now, there's no JavaScript
00:38 - prerequisites for this course. But I do assume
that you know, a little bit of HTML and CSS
00:43 - as we're going to build a few projects that
needs some HTML and CSS. But if you don't
00:48 - care about that, you can skip those challenges
if you want, no worries, whatever the reason
00:53 - is that this course is actually a part we
larger front end developer career path, which
00:58 - we have a screen bar, which takes people from
zero to hireable, as front end developers.
01:03 - And of course, then HTML and CSS are also
part of that. Now, if you have feedback for
01:09 - me, feel free to reach out to me on twitter
at Pierre borgan. And if you liked this video,
01:13 - please give it a LIKE, I'd really appreciate
that. And with that, good luck. Hey, good
01:21 - old buddy, old pal, and welcome to learn JavaScript
eight practical introduction. I am so excited
01:29 - about teaching you this course. And who am
I? Well, my name is Pierre. I'm the CEO of
01:33 - scribble. And I'm also a front end developer
who's taught a bunch of courses and over 100,000
01:38 - students have enrolled in these courses, when
I'm not coding My hobby is to take photography's
01:44 - of myself posing in front of a fast course.
But more about that later. What do I mean
01:50 - by this mean? A Practical introduction? Well,
it means that you will write the code, I'm
01:54 - not going to write the code for you. I'm just
going to show you how to do it after you've
01:58 - given it a shot first, because the only way
to learn how to code is to write a lot of
02:03 - code. A clever man once said that, however,
there are many ways to write code. There's
02:08 - the old, boring, theoretical, I met school
way of learning to code. And then there's
02:13 - the much more fun way of learning to code
where you actually build stuff from the get
02:17 - go. And that's what you're going to do, we
are going to start by building a subway passenger
02:22 - counter so that you can count people on the
subway in case that's one of your interests.
02:26 - For me, it actually was frippery or it was
my full time job when I was 19. So back in
02:31 - the days, I would actually need the suction,
then we are going to move on with a game the
02:36 - blackjack game, oh, I just love gambling.
So this is going to be so much fun. And then
02:42 - at the end, we're going to be a bit more serious
and build a tool for salespeople, namely,
02:47 - a so called lead tracker. And what's so insane
about this lead tracker is that it will be
02:53 - a Chrome extension that will deploy to Chrome
so that you can use it out in the wild or
02:58 - send it off to a salesperson who might need
such a tool, because it solves one of the
03:03 - biggest problems salespeople have, which is
to browse the web and collect and gather leads
03:09 - that they later can reach out to. So when
you have completed these three apps, you will
03:14 - have the ultimate superpower in today's world,
which is the power of knowing JavaScript is
03:20 - a very low percentage of people in today's
world who know JavaScript. So you will no
03:25 - longer be like everyone else at that point.
I am so ready to start this course. I hope
03:31 - you are too. So let's just jump into it. You're
very first exposure to JavaScript will come
03:40 - through building a passenger counter app.
Now you might ask yourself, Well, why on earth?
03:45 - Should we build a passenger counter app? And
what's the point of that? Well, you'd be surprised.
03:50 - Because when I was 19, right around this time,
my full time job was to count people who entered
03:55 - the subway. So every day I would stand outside
in the cold and be like, Oh, so there's 123456
04:02 - people and bring the subway this morning,
How interesting. And that I would bring up
04:06 - my pen and paper and note down the number
six, which at times was really cold. So it
04:11 - would have been so much better if I had a
little people counter app on my Nokia phone
04:15 - so that I could just tap these buttons while
having the phone in my pocket. But this was
04:20 - long before I learned to code. So instead,
we are going to build this passenger counter
04:24 - app together so that you will learn the basics
of JavaScript and so that you are prepared
04:29 - in case you one time in the future have to
stand outside in the cold counting people
04:34 - who enter the subway.
04:39 - Welcome to this lesson where we are going
to take a look at the setup for our people
04:42 - counter app. Here you can see we have a basic
HTML structure which probably looks familiar
04:48 - to you can see we have the HTML tag the head
tag and inside of the body, we only have two
04:53 - elements, the h1 and h2. That is the title
up here and our counter element will To have
05:00 - some styling in our index dot CSS, you can
check it out here, this is just very basic
05:05 - styling that we're not going to go through
because you want to get into the JavaScript
05:08 - as soon as possible. So the first thing we're
going to do actually, is to simply inside
05:13 - of our body tag, create a so called script
tag, like that looks just like any other HTML
05:20 - time, it just says script. Inside of here,
we can actually write JavaScript. So inside
05:26 - of this time, I'm going to write a pretty
long JavaScript expression that you probably
05:30 - find a little bit frightening. But don't worry
about that you're not meant to really understand
05:34 - it. In this lesson, I just want to demonstrate
that this works. So I'm going to start by
05:38 - writing documents, that refers to the HTML
document itself. And then I'll do dot get
05:44 - element, I ID and then open and close parentheses.
Then inside of the parentheses, I'm going
05:53 - to copy the ID of our h2 element. So here,
we're saying, hey, HTML document, I
05:59 - want to get
06:00 - an element and I want to get it by its ID,
and the ID, is this count out? So what do
06:06 - you think we get as a reply? Well, we grab
ahold of this element right here. And then
06:10 - we can do dot inner text, set that equal to,
for example, five, find out run this code,
06:19 - you'll see that boom, we have changed the
text on the inside of the h2 element, this
06:25 - one right here, from zero to five, using JavaScript,
and that opens up a whole world of opportunities,
06:32 - it essentially gives us the power to breathe
life into our application and turn it into
06:37 - a real world product that solves problems
for people. That's why this is so cool to
06:43 - learn. However, we are not going to write
our JavaScript this way. Here, it's kind of
06:47 - an amateurish way to do it. But we rather
want to do is create an index.js file like
06:53 - that. Here is our index.js file, it's currently
empty. What I'm going to do is copy this line
06:59 - here, then paste it into the index.js file.
07:04 - And now
07:05 - out, add an attribute to my script tag called
SRC, which is short for source. And then inside
07:14 - of here, I'm just going to write index dot
j. s, we are in the HTML file, and the JavaScript
07:19 - file is in the same folder. So I don't need
to navigate into any folder or typing a complicated
07:24 - path here, stripe the name of the file. If
we now run this code, again, you can see that
07:29 - yes, it still works. So now we have a proper
setup for our app, and we are ready to get
07:35 - started building our people counter. Let's
move on. So today is actually a really important
07:44 - day in your life, because you're going to
create your first lines of JavaScript. And
07:48 - that is just such a powerful thing to do.
Because you take the first step into a world
07:55 - of opportunities with different shapes your
life. So in a year, you might want to celebrate
07:59 - this day as the anniversary the day you met
JavaScript and changed your life for the better.
08:06 - Anyway, you're going to write it's not this
long one right here, it's a little bit too
08:10 - difficult. At the moment, I'm actually going
to add a double slash in front of it like
08:14 - that. And you can see that grayed out, it
means the JavaScript will ignore this, since
08:19 - this is now a code comment, not real code.
So if we run the code here in the browser,
08:26 - we can see that now we are not modifying the
h2 tag anymore. So we are ready here down
08:33 - at line three to write our first lines of
code. Now, let's think a little bit. What
08:38 - do we need actually, to build this subway
passenger counter app? Well, the first thing
08:43 - we need is some way to store the count. And
that's a natural job for JavaScript, because
08:49 - it's kind of like the data we need to store.
And when you need to store data, you need
08:53 - to create so called variables to store the
data in, and I'm now going to create a variable
08:58 - called count. And the way we do that is we
write let count equal zero. Now we have a
09:06 - variable called count. And that holds a tiny
piece of data, namely, the number zero. And
09:10 - the way you can read this in English, it's
actually let count be zero. So really natural.
09:18 - And let's actually try and verify that actually,
our count variable does indeed equal zero,
09:24 - we can do that by using a tool that every
single developer uses every single day. It's
09:28 - called console dot log, then open and close
parentheses. And inside of these parentheses,
09:34 - you can put almost whatever you want. And
in our case, we are going to put this count
09:39 - variable here. We now run the code. You can
see that down in the console. At the bottom,
09:45 - we printed out the number zero, and the console
is something that the browser provides us
09:50 - with. It's there mainly for debugging purposes
for checking our code, like we're doing here,
09:55 - verifying that actually yeah, I want to take
a look at at count on and print that out to
09:59 - the controller. See my own eyes that it is
what I think it is. And indeed it was. And
10:05 - this console you see here is Rambus implementation
of the console. If you want to check out the
10:09 - real world console in the Chrome browser,
you can, for example, head over to google.com,
10:13 - or any page basically, and then right click
and choose the inspect option, you click that,
10:20 - it'll open up this tool called developer tools,
shows you a bunch of HTML. As for now, we're
10:26 - not going to worry about that, instead, just
click on the console option, that'll open
10:30 - up a blank console, where you actually in
addition to printing out stuff, which we did
10:34 - down here in the script console, can write
JavaScript as well. So if you want to write
10:39 - let count equals five, and then hit enter,
then write console, log and then pass in count
10:44 - in the parentheses, and then hit enter, you'll
see that it'll log out five as well. So the
10:50 - console is available to you in all browsers.
And it's a tool that developers use every
10:54 - single day. So I'm really happy that you've
learned about it this early on. Now I actually
10:59 - have a challenge for you, I want you to do
two things. First, you're going to create
11:03 - a variable called my H and then set its value
to your H, and then log the my h variable
11:11 - to the console. So go ahead and do this right
now. And then I will show you how to do it
11:15 - as well, when you come back. Okay, hopefully,
that went well, let's do it together, let
11:25 - my age, I happen to be 35 at the moment, then
console, log out my age, I'll do console dot
11:32 - log, open and close parentheses, my age, we
run this code. Now we are printing out both
11:40 - account and also my age. So we have verified
that our variables indeed work as expected.
11:47 - Before we move on, there's one thing I want
to show you. And that is to take this line
11:51 - console logging of my age, and place
11:53 - it above the my age variable declaration.
So now we try to console up my age before
11:59 - we define it, since JavaScript starts reading
at the top and works its way downwards. So
12:05 - what do you think then will happen if I now
remove these other console logs, and only
12:09 - keep the My Aged console log?
12:12 - Let's take a guess.
12:13 - Well, what happens is that we get a reference
error cannot access my age before initialization.
12:21 - So JavaScript actually understands what we're
trying to do. And we're actually referencing
12:25 - your value before it has been initialized.
And that simply doesn't work. So now that
12:31 - you are aware of that, let's move on. Okay,
so let's return back to our count variable,
12:39 - learn some more advanced concepts, which is
that you can actually use JavaScript kind
12:43 - of as a calculator. So instead of just writing
left count equals five, you can do let count
12:49 - equals five plus seven, for example. And when
you run that code, you will see 12 in the
12:54 - console, you can do minus, of course, that'll
result in minus two in the control or given
12:59 - divide, that'll be 0.71, a bunch of numbers
after that. And of course, multiply gives
13:05 - us 35. So there's a lot of mathematical operations
built into JavaScript. And you're not gonna
13:10 - learn about all of them now, because now instead
of just hard coding raw numbers, let's try
13:15 - to use variables here instead. Because oftentimes,
you won't see this kind of operation, you'll
13:20 - normally see numbers represented as variables
in real world code bases. So removing this
13:26 - right here, for example, let first batch equals
five. So this was the batch of people that
13:36 - first enter the subway wagon, and instead
of hard coding five here yet again, we're
13:40 - just going to do count equals first box. Well,
what do you think will be logged out here,
13:45 - then?
13:46 - quite correctly, it's five. Because first
matches five count is set to the same as five.
13:52 - And perhaps there was another batch as well
let second max group of people that entered
13:58 - just before the doors closed, maybe that was
seven people, well, then we can do. count
14:05 - equals first batch plus second batch. Yes,
this works well. So this is a much more common
14:10 - thing to see in JavaScript that a variable
is set to the value of, for example, two other
14:15 - variables added together. Now, I want to comment
out this, like that, if you're wondering how
14:20 - I did that magic have the alt multiple lines
at once, I did simply command plus k plus
14:26 - C, or replacing this with Ctrl if you're on
a Windows machine, because what I want to
14:32 - do now I want to gather this code up here.
And then I want to give you eight three parts
14:38 - challenge, where you are going to convert
your age into dog years. So first, create
14:43 - two variables my age and human dog ratio,
that is the ratio between human ears and dog
14:50 - ears. And for the sake of simplicity, we're
going to say that one human year is about
14:54 - seven dog years. Now the calculation is actually
a little bit more complicated than that, but
14:59 - that's not bad. And then the important thing
here is learning. So set, then the human dog
15:03 - ratio to seven, then multiply the two variables
together and store the result in my dog age.
15:11 - Finally, log my dog age to the console, this
is great practice, it's important to build
15:16 - up your muscle memory. So go ahead and do
this right now. And then return back to the
15:20 - screencast, when you want to see how I solved
that as well. Okay, hopefully that went well.
15:29 - Now let's do it together, remove the consoles,
we can get some more space here. And we'll
15:34 - start with my H, which still is 35. And we'll
do a human dog ratio. And that should be seven.
15:45 - Finally, the my dog age should be my age,
multiplied with human dog ratio. Let's verify
15:55 - that this works by logging out my dogs in
the court, and yes, we can see in the console,
16:02 - we get 245 my god, I would be an old dog if
I was really god. I'm human actually. So let's
16:11 - move on. Okay, so let's return back to our
count example. Now you've learned how to initialize
16:21 - a variable and even how to do mathematical
operations on it both with hard coded numbers
16:25 - and with other variables if we need that.
And that's all great. However, up until now,
16:31 - we've just been working on the initialization
or the so called assignment of the variable.
16:36 - What if you want to reassign it or in plain
English, if you want to change the variable?
16:42 - Well, then you can do that, for example, down
here on line five, just to count equals three.
16:46 - And if we now run the code, you can see that
we log out three as opposed to five, because
16:51 - JavaScript starts from the top and runs down
and uses the latest value it can find for
16:57 - any variable defined with the let keyword.
Now there are other types of variables that
17:02 - you can't reassign like this, but we'll get
to that later. As for now, we're just going
17:07 - to work with the let. And you can do this
as many times as you want. If I want to change
17:11 - it even further down down to one, you can
see now that JavaScript is only taking into
17:16 - account the line seven reassignment of the
count variable. So this is all good. But it
17:21 - doesn't really help us if we want to increment
our people entered count with one every time
17:27 - we for example, click a button, what we then
want to do is something like count as one,
17:31 - because we want to take the current count,
keep track of how many we've counted up until
17:36 - now and then just increment with one. The
way to do that is actually by simply doing
17:42 - like this. This might look a little bit weird,
since we have count on both sides of the equal
17:48 - mark. And probably you've learned at school
that the left and right hand side of the equal
17:53 - Mark should be completely equal in mathematics.
That's not how it works in JavaScript. Here
17:59 - we are assigning this variable to take on
this value. First, you want to calculate the
18:05 - value and the value is this point five plus
one will then count now will be equal to six.
18:13 - Let's run this code and see that it works.
Yes. And let's say we want it to incremented
18:18 - by two, then we do two and now it's seven
because five plus two is seven, do the same
18:25 - thing again. This time we can increment This
was 10. Now we're at 17. And minus that was
18:32 - two again, and then we're down at 15. I think
you get the point. Now I have a challenge
18:37 - for you. Okay, so you are to create a variable
18:40 - bonus points. So this could, for example,
be a game where your bonus points goes up
18:44 - and down. And I want you to initialize it
as 50 and then increase it to 100, decrease
18:50 - it down to 25. And then finally increase it
up to 70 again, and you're to use the same
18:55 - technique that we use here with account where
you reassign the variable to the old value
19:00 - of the variable and then adding or subtracting
the value. And I want you to console log the
19:06 - value after each step. So go ahead and do
this right now. And then I will show you the
19:10 - solution as well.
19:14 - Okay, hopefully this went well. Let's do this
together. We'll start with let bonus points
19:23 - be 15. So logging it out. And then we're going
to do bonus points equals bonus points. 50
19:31 - because we want to get to 100. Again, I'm
soloing it Next up, bonus points equals bonus
19:37 - points, minus 75 because we want to get down
to 25 logging it out again. Finally, bonus
19:46 - points equals bonus points. Now we need to
increase it with 45 to get to 70. Let's comment
19:54 - out this code up here and run the code bring
up the console and yes 50 125 70 Great job.
20:01 - Let's move on. Okay, now you know enough JavaScript
for us to move on to the HTML and build the
20:11 - interface for our app. And it's not a lot
of interface, it's to begin with just a button.
20:19 - And later down the line, we're going to create
another button. But it has to be written.
20:24 - And you are going to do that. So I want you
to follow these instructions, you're to create
20:28 - an increment button that has the text of the
button with the ID of increment dash btn.
20:36 - So go ahead and do this right now.
20:37 - Okay,
20:38 - hopefully that went well. Now, let's do together.
But then I'll create the closing tag inside
20:48 - of here. All right, increment cowritten. counter,
I think increment is more of a technically
20:54 - descriptive words. So let's use an ID increment
dash btn. Like that, if we run this code,
21:04 - you will see yes, we indeed have this button.
And that is already styled How convenient.
21:08 - Let's check out the CSS for that we have a
general styling for buttons, which are reused
21:14 - across both of our buttons. This is their
using the button selector, and then our increment
21:19 - button. And our Save button has a specific
background, each of them their dark red and
21:24 - dark green. Great job doing this. Now the
question is, how do we make this button interactive,
21:29 - because right now, nothing happens if I click
it? Well, in the next lecture, we'll go through
21:35 - exactly how to do that. Okay, so now we're
going to put the different pieces in this
21:44 - puzzle together, and also add a whole new
piece. And in order to free up some space
21:49 - in our JavaScript file error, let's just remove
this previous exercise and actually write
21:53 - out in pseudocode, the procedures that we
need to do in order to make this work. So
21:59 - first, know that we need to store the count
somewhere. And we know that we want to initialize
22:03 - it as zero. And then as I said in the previous
lesson, we need to kind of listen for clicks
22:08 - on this button here. When it's clicked, we
need to increment our count. Then finally,
22:15 - which we aren't going to do just yet. But
I just want to write that procedure out as
22:18 - well, Joe, do you know what to expect? We
need to change the count del, this paragraph
22:26 - right here in the HTML reflect the new count.
So we know how to initialize the count to
22:34 - zero. And we know how to increment the count
variable. So to achieve these first three
22:39 - needs to do this task that is listening for
clicks on the increment button. And that can
22:43 - be done in a multitude of ways. The easiest
one is simply in the HTML,
22:49 - defining an on click event listener, you simply
write on click equals, and then something
22:56 - in between quotes. So this is an attribute
and the HTML, just like the ID is an attribute
23:03 - as well.
23:04 - Inside of here, you write the function that
you want to be triggered when the button is
23:09 - clicked. So I'm gonna write, increment, and
open and close parentheses. Now, that probably
23:15 - looks really weird for you. And that's totally
okay, if you're confused by what's going on
23:19 - here. Because we've seen nothing of the word
increment in our JavaScript yet, so rightfully
23:24 - so we need to create that function. I'll do
that down here. And I'll use the keyword function,
23:29 - then the name, increment, open, close parentheses,
and then open and close square brackets. So
23:36 - pretty funky syntax right there. And the first
time you type them, it feels weird, but over
23:42 - time, it becomes second nature. What you write
inside of these curly brackets is the so called
23:47 - body of the function. And that piece of code
that is in the body will be executed, every
23:53 - time this function is called, are invoked
as the same thing. So just to see it in action,
24:00 - right console log button was clicked like
that. If we run the code, and I click the
24:08 - button, you can see that in the console, we
see the button was clicked, if I do it again,
24:12 - and again and again and again. So every single
time the button is clicked, this piece of
24:17 - code runs, and it runs because we in the HTML
are saying, JavaScript, when this button is
24:23 - clicked on the on click event, I want you
to run a function called increment. And that's
24:31 - what's happening here. And then JavaScript
is like, Yeah, for sure, sits ready and listens
24:37 - for that specific click event. And JavaScript
can do that it pays attention to what the
24:41 - user does on the screen. And when it sees
someone clicking on this button, it fires
24:46 - off this piece of code. This was probably
a lot of information to parse in one go. So
24:52 - before we move on, and continue on turning
our pseudocode into real JavaScript, let's
24:58 - take a closer look at functions over The next
few castes so that you get rights and functions
25:02 - as well, and build up your understanding and
muscle memory.
25:07 - Okay, so let's pretend that we are building
a race card game. So here I have some comments,
25:16 - which are meant as pseudocode for the functionalities
of the game. And the only real functional
25:20 - part of it is these five console logs, which
are counting down from five to one. So we
25:26 - start the game by setting up the race. And
then we do 54321. If I run the code, you can
25:31 - see that is log to the console. That means
that it's go players are to start racing,
25:36 - and they will be running the race, and then
they're racist finished and a winner is declared.
25:42 - And then of course, we are getting ready for
a new race. However, with the current knowledge
25:48 - we have about JavaScript, the way we would
count down for a new race would have to be
25:52 - to copy all of these lines and paste them
in down here. So that now when we run it,
25:58 - we get 54321, printed two times to the console.
However, this isn't good. Anytime you see
26:05 - this kinds of repetitions in your code, you
should try to think is there any way we can
26:10 - extract this into a function, that is exactly
what we are going to do, we are going to refactor
26:16 - this so that it instead uses a function. Another
word for function could be command. So we
26:21 - are asking JavaScript to kind of remember
a command so that we can use it later on as
26:26 - well. And that command can be as comprehensive
as you want. In our case, it's going to be
26:31 - to countdown from five to one. So let's just
do this to see it in action to create a function,
26:36 - as I talked about in the previous cast, we
use the function keyword, and then the name
26:41 - of the function, I'm going to call this function
count down, then open and close parentheses,
26:48 - then open and close curly brackets. And all
of the action happens inside of the curly
26:53 - brackets. So I'm going to break that into
a new line. And I'm going to copy all of these
26:58 - console logs, and then paste them inside here,
like that. And here, I'm tabbing it out, just
27:05 - to highlight that this code is inside of that
function. This is not something JavaScript
27:11 - cares about to make our code easy to read
for humans. So now I have declared our function.
27:16 - However, if we remove this on here, and now
try to run the code, nothing happens. Because
27:23 - it is only been declared, it hasn't been what
we call invoked, or also called as this code
27:31 - inside of here will only run if we call the
function. So if JavaScript was a dog, and
27:37 - we've taught our dog to roll around, then
in order to get our dog to actually roll around,
27:42 - we have to say, roll around. Same thing here,
we have taught JavaScript to countdown, but
27:48 - in order for it to actually do the counting,
we have to say, countdown. And to do that,
27:54 - like this writing countdown with opening close
parentheses. Now you can see when I run the
28:01 - code, it indeed does the counting. But if
I comment this out, it does nothing. So what
28:07 - I'm going to do now is I'm going to take this
countdown, and I'm going to put it all the
28:10 - way here at the top. And then I'm going to
call it when we are ready to start the first
28:15 - race, and then also call it when we are ready
to start the second race. Now if I run the
28:21 - code, you can see that we indeed count down
two times before the first race and before
28:26 - the second race. And this is much better than
typing out all five console logs, both here
28:32 - on line 11 and on line 19. So we have compressed
our code a lot. So with this knowledge fresh
28:39 - in mind, let's move on to the next cast where
you are to write your first function. Okay,
28:49 - now it's your turn, you are going to create
a function that logs out the number 42 to
28:54 - the console. And you can decide the name of
the function. And when you've done that, make
28:59 - sure you call or invoke the function as well
to go ahead and do this right now. Okay, let's
29:09 - do this. I call it my logger. Opening closed
brackets. And then inside of the body, do
29:18 - console dot log 42. Now we decode my logger,
like that, we run the code. And yes, you can
29:27 - see we are logging 42 to the console. Great
job. Okay, time for a new challenge. So in
29:37 - our race car game, we have certain laps, and
of course we track how much time our players
29:42 - use to race through the laps. And here we
have three lap times in the variable lap one
29:47 - lap two and lap three. And the thing is, if
you create a function down here on line six,
29:52 - it will be able to access these three variables
from within the function. So what I want you
29:57 - to do now is create a function that simply
logs out the sum of all the three laps, so
30:03 - that'll be the total racing time
30:04 - for a player. So you decide what name you
want to get it, just write that function that
30:09 - logs out the total lap time, and then run
the function as well. Okay, hopefully that
30:19 - went, well, let's do this function. I'm gonna
call this function, log laptime, open and
30:27 - close parentheses. Here, I can either first
create a variable, let total time for example,
30:35 - lap one plus lap, two plus lap, three, and
then console, log out total lap time, like
30:44 - that. And then log lifetime, invoke the function
down here on line 11. If we now run the code,
30:51 - we can see yes, we are logging out 203. This
is one way of doing it. Alternatively, I could
30:56 - have skipped creating this variable in here.
And simply added the variables inside of the
31:04 - console log that will give me as you can see
the exact same result. Now, the reason I wanted
31:10 - to create this variable here, though, is to
just show you one thing, just that while this
31:16 - function could access these variables, from
the so called global scope, the outer scope,
31:24 - which is not on the inside of the function,
but on the outside of it, this doesn't work
31:29 - the other way around. If I now let's try to
console log total time, from the outer scope.
31:37 - If we run this gets a total time is not defined.
That is because when you define a let variable
31:43 - inside of this scope, it only exists inside
of this block of code. This is the scope in
31:51 - which the function lives. And that's why we
call let variables block scoped. So that might
31:56 - be a little bit confusing, that the lap could
go from the outside of the function and to
32:01 - the inside of the function. But total time
couldn't go from the inside of the function
32:07 - to the outside of the function. Don't worry
too much about this JavaScript will tell you
32:12 - when something isn't defined, and you can
be sure that you will miss step a times. But
32:17 - that's just a part of the process. Let's now
move on to the next challenge. Okay, so now
32:26 - we have to combine some of the things you've
learned up until now, in order to build this
32:30 - lap counter feature, because in our racing
game, we want to keep track of how many laps
32:36 - a player has completed. So I've created this
variable called laps completed, and initialize
32:41 - it to zero. So what I want you to do now is
create a function that increments the laps
32:47 - completed variable with one, every time you
run the function, then I want you to run or
32:53 - call or invoke or whatever you want to call
it, this function three times, so that on
32:59 - line nine, here, the value that's logged out,
will be three. Now, if you're wondering how
33:05 - to increment a variable in JavaScript, just
look back if you cast because we did that
33:11 - previously. So now we have to combine that
knowledge with your freshly acquired knowledge
33:15 - about writing functions to go ahead and give
this your best try right now. Okay, hopefully
33:25 - that went well. If not, no worries, let's
do this together. So that you get to see how
33:30 - we do it. function. And I'm going to call
this function, increment lock like that. Open
33:36 - and close parentheses, then open and close
curly brackets. And here after increment this
33:41 - variable, just as we did a few casts ago,
by doing laps completed, equals the old value
33:48 - of laps completed. Last one like that, right
now run, increment last one time, you'll see
33:56 - that we're logging out one, good stuff, let's
invoke it three times. There, we can see we
34:04 - are logging out three to the console. So great
job doing this. If you didn't manage it, just
34:10 - go back and try again, now that you've seen
my solution, because it's really important
34:15 - that you actually write the code here, so
that you build up that important muscle memory.
34:20 - Okay, we're back at the subway counter app.
And as you can see, I've deleted the increment
34:28 - function, because I want you to write it instead,
it's much better than me writing everything.
34:32 - You want to do it as a part of turning these
first three lines of pseudocode into real
34:38 - code. So you're going to initialize the counter
zero, you're going to listen for clicks on
34:42 - the increment button. And thus you have to
create that function that's triggered when
34:47 - the increment button is clicked, and then
you are going to increment the count. Matter,
34:51 - find a little challenge here and that is to
log it out after the count variable has been
34:56 - incremented. So go ahead and do this right
now. And then afterwards, of course, showing
35:00 - you the solution as well.
35:04 - Okay, hopefully that went well, let's do this
together, we'll do function increment, open
35:12 - and close parentheses, open and close curly
brackets. And we have the button, let's verify
35:18 - that it works. Good thing to do after every
single step. So that you know, at some point
35:23 - get a bug, you will have a better understanding
of where it happens is you know which steps
35:27 - you were able to get to without triggering
any bugs. So I'll do clicked, run the code,
35:34 - click the button, the Yes, that works. Okay,
not wanting to increment the count. So we're
35:39 - going to do that inside here. And of course,
then we need the count initialized to begin
35:44 - with. So count equals zero. Here, as you remember,
it's just as we're simply going to do what
35:50 - we did up with line four, we'll do equals
count, plus, now, finally, console, log count.
35:58 - I'm going to remove this and run the code,
hit increment. Yes, we see one, and two, and
36:06 - three, and four. Nice. So then we have done
these three parks, remove this helper code
36:14 - right here, we have the final part left. And
we can finally start understanding what this
36:20 - weird piece of code here on line one that
we worked with, in the very beginning of the
36:25 - course, actually means. Let's do that in the
next lecture. Okay, so we are ready to add
36:36 - the final piece of the puzzle, just to change
the count L. That is the age to buy care,
36:43 - which currently has zero. So that reflects
the new counts. And the view count is down
36:49 - here, which we are logging out. So we have
to do something down here at line nine. And
36:54 - what we're going to do is take this line right
here, which has just been lying here in the
36:58 - background all along. Now, in order to properly
understand this expression, I think we should
37:04 - break it into two, take the first part where
we're actually asking for the HTML element.
37:09 - The second part, we're actually modifying
the HTML element. So starting with the first
37:14 - part, I'm going to store this in a variable
called count L, like that, and do document
37:22 - get element by ID, close parentheses, passing
in count, l. Exact string right here. Notice
37:34 - that we're using different naming convention
here in the JavaScript. This is called camel
37:40 - case like that, where you capitalize the first
letter of the second word, but not the first
37:46 - letter of the first word. This is how you
want to write JavaScript variables. It's a
37:50 - very normal convention. Also, if we were to
try to use the same convention, as we've been
37:55 - using in our HTML and CSS, JavaScript would
actually tell us Ah, you can't do that. Because
38:00 - IE, we are getting a red line under this character,
which is Java scripts way of complaining to
38:05 - us because it's not a valid variable name
when you stash. So we got to remove it like
38:10 - that. Now, it's always what do you think we
should do now now that we've taken one step
38:15 - into the unknown? Well, of course, we're going
to use our good old friend console lock, because
38:20 - we have to verify at every single step that
we're actually on track. We haven't introduced
38:24 - any bugs. So I'll do console dot log, and
logging out, count out. And if we bring up
38:30 - the console, we see actually, we're getting
what looks like an HTML element in the console.
38:36 - That's pretty interesting. Now, it's actually
not a real HTML element. It's more of a representation.
38:41 - It's a model of an HTML element. And it gives
us a lot of other opportunities to change
38:46 - it using JavaScript as well. But for now,
it's perfectly fine to think of this as just
38:51 - yeah, that is the element that we are seeing
right here. It's a JavaScript representation
38:57 - of that element. Because remember, we said,
Hey, HTML document, why don't you get me the
39:02 - element that has the ID of count l? And the
HTML, I was like, yeah, sure, just take it.
39:10 - And then you stored that in the count variable.
And now you, as a JavaScript developer, have
39:15 - control over this element, and you can manipulate
it, which is exactly what we're going to do
39:20 - down here at line 14. Because now we're going
to move on to the second part of this big
39:24 - expression, which is modifying the element
itself, dot inner text equals five, or in
39:29 - our case, how would we write this? Well, we've
turned this big thing here into this variable.
39:37 - So we'll use this variable dot enter text,
that is enter text like that equals, and we're
39:45 - not going to set it to five because I wouldn't
make any sense. What are we going to set it
39:49 - to think a second about that? Neither is the
count, because we know from console logging
39:55 - earlier on that the count does indeed increment
correctly. And now we're just saying that
39:59 - Won't be enter text
40:01 - is the text on the inside of the tags, we
want it to be the count, we'll run the code,
40:09 - hit the increment button. And yes, it works.
Now we are incrementing, we are counting people
40:14 - really good job of reaching this point, your
JavaScript skills are starting to become dangerous,
40:19 - as you now know how to create interactive
apps. Now, before we move on, there's one
40:24 - thing I want to mention, which is that this
get element by ID here. And this dot log,
40:32 - both are functions in the same way, our increment
function is a function. Now they are hooked
40:38 - on to the document object and the console
object. But that's just new ones. They're
40:43 - still functions or methods as we call functions
that are hooked on to so called objects. If
40:49 - that sounds confusing, it's because it should
be at this point, because you haven't learned
40:53 - about the objects yet. And methods on objects.
But don't worry about that. Just think of
40:58 - them as functions. Actually, the thing we've
been doing here of adding something in between
41:04 - the parentheses of the function when we are
calling it is called to pass in arguments,
41:09 - which means that we are giving the function
some data to work with like here, we're specifying
41:15 - the ID of the element we want to grab. Otherwise,
if we didn't do that, this function will just
41:20 - be running in the wild and not know what to
look for. Likewise, in this dot log here,
41:26 - we're passing in which variable we want to
log to the console. If we didn't do this,
41:30 - the log function wouldn't know what to log.
So speaking in analogies, if the function
41:35 - is a CEF, that are to cook a meal for you,
then the arguments you pass in are the ingredients
41:41 - that chef uses to cook that meal. So hopefully,
that made everything a bit more clear. Let's
41:47 - clean up this code and move on. Now, before
we move on, I want to talk a little bit about
41:55 - what we're doing here where we're saying documents
dot get element by ID, because you'll often
42:01 - hear developers refer to this technique as
working with the DOM. And that's one of those
42:07 - three letter acronyms in web development.
sounds super complicated. And I was really
42:13 - confused about this when I was learning to
code. And I want you to avoid that confusion.
42:17 - So let's just unpack this expression. It's
short for a document object model. That sounds
42:23 - really fancy. However, it's actually just
how you use JavaScript to modify a website.
42:29 - It's just that the people naming this wanted
to give it a really abstract name. But if
42:34 - we look at each of the words separately, the
name actually does make sense. Let's do that
42:38 - starting with a document. Why that? Well,
that's because what you're interacting with
42:42 - an HTML document object? Well, that's because
the document keyword in JavaScript is of the
42:50 - data type object, meaning they've taken the
HTML document and shoved it into a JavaScript
42:55 - object. Of course, that's a little bit of
a simplification, but that's the essence.
42:59 - So this word document of the data type object.
Now, you haven't learned about objects yet,
43:05 - though, you're going to do that a little bit
later. Finally, there's Model Model is basically
43:11 - a representation or a model ation, kind of
like, you know, there's a real Saturn five
43:16 - rocket that NASA built. And then there's the
Lego model. And that's how it is here as well.
43:22 - There's the real HTML element, which you've
written in your dot html file, then there's
43:27 - the JavaScript model, the representation you
have over this element in JavaScript. So don't
43:33 - be frightened when people talk about the DOM,
just in your head to translate it to how to
43:38 - use JavaScript to modify websites. With that
out of the way, let's move on with the coding.
43:48 - Or actually, before we move on, I have to
say I fooled you a little bit. Because the
43:53 - problem with the previous lecture was that
I wrote the code. And that's just wrong, you
43:58 - are going to write the code. That's how you
learn. So I've removed the two lines of code
44:02 - that I wrote, namely, grabbing the counter
element and storing it in a count l variable.
44:08 - And also setting the count else enter text
through the count. So just do that. And if
44:13 - you struggle, just go back and look at my
solution. It's no need for me to write this
44:17 - out for you yet again, just go ahead and give
it your best shot and refer to that if you
44:22 - need help. And I will see you in the next
lecture. Okay, it's time for you to build
44:32 - some muscle memory, because you are going
to create a Save button and a save function.
44:36 - You're going to start with a function. Here's
the instructions create a function called
44:40 - save logs out the count when it's called.
We're going to modify this to do some other
44:46 - stuff afterwards. But that's for now I wanted
to just log out the count.
44:50 - Secondly, in the HTML, you are going to create
the Save button. You're gonna set the ID as
44:55 - save btn and have it call the Save function
when that is clicked. So, go ahead and do
45:01 - this right now and then return back to the
screencast when you want to see my solution.
45:06 - Okay, hopefully that went well, let's do this
function save, open and close parentheses,
45:18 - then the body of the function will console
log account. If we want to check that this
45:24 - actually works. Now we can call the same function,
run the code there, we can see yes, that the
45:29 - account is indeed locked out as a consequence
of us calling the function here on line 15.
45:33 - Okay, let's remove that. Going over to the
HTML, we're going to create the Save button,
45:39 - and we do open button tag, then I'll just
close it right away. Alright, the save in
45:46 - between the tags and give it the ID of saved
up BTM. Now we can actually run it to see
45:52 - that renders. Yes, it indeed does. But nothing
happens when we click it. And that's because
45:57 - we have to do on click, we want to run the
Save function. Here, we have to invoke it
46:04 - with the opening close parentheses, otherwise,
it won't call the function. So we're running
46:09 - the code and hitting save, yes, there we are
logging out zero, because of this line. Now
46:15 - we can increment a couple of times and see
Oh, now we're logging out six, pretty nice.
46:22 - Now we're starting to get somewhere, it's
only a matter of saving the count to the website
46:27 - as well and rendering it out under the buttons.
But before that, there are some new concepts
46:32 - you need to learn. So I'll see you in the
next test. Okay, so now it's time for us to
46:41 - build this little functionality here, which
allows us to save the number of people who
46:46 - have entered into the subway at each of the
departures. However, this requires you to
46:51 - work with this full paragraph, which actually
includes both numbers, which you can see but
46:56 - also like regular text, previous entries and
some symbols as well. And once you move away
47:02 - from just straight out numbers in JavaScript,
you're moving into the land of so called strings.
47:07 - And strings is a data type in JavaScript.
And in case you're wondering, yes, numbers
47:12 - is also a data type. And if you think the
word string is a little bit weird, well, you
47:17 - can also think of this as just text, the strings
you work with in JavaScript are normally meant
47:21 - to be text that the user reads on the page.
Now, we have been working with text here before
47:26 - and we've hard coded in some text here and
there in the HTML. And actually, as far as
47:31 - HTML knows, everything is strings doesn't
even know about numbers, HTML can do calculations
47:37 - for you. So when I'm talking about strings
and numbers, I'm talking about it in the context
47:41 - of JavaScript. And even though you've probably
not even aware of it, you've actually written
47:46 - the string already appear on line one, you've
wrapped the count dash l inside of two quotes.
47:53 - And that is how you create a string in JavaScript.
But you've had far from enough practice to
47:58 - start working with strings in our people counter
app. So in the next lesson, we're going to
48:03 - go over the basics of it. And then we're going
to solve some challenges so that we build
48:07 - up that muscle memory and make you capable
of using strings in our app. I'll see you
48:11 - there. So strings are used all over the place
and software, let's say that you, for example,
48:21 - are building an app where people can authenticate,
well, then most likely, you have to store
48:26 - some kind of username for your users, that
would most likely be stored as a screen, for
48:32 - example, Pear, wrapped in double quotes, then
this string, just like we did with numbers
48:39 - will be stored in a variable. So let user
name equals pair. Now we can console log out
48:47 - username, get pair logged to the console.
Now, one thing I want to mention is that I'm
48:55 - using double quotes here to create this string.
I could use single quotes instead, if I want
49:01 - to, you can see that works. However, I cannot
start with a single quote and end with a double
49:06 - quote. As you can see, now, our editor tells
us that this syntax is off. And if we try
49:13 - to run the code, we are getting a syntax error.
So you got to stick with one or the other.
49:18 - And I usually use double quotes, but that's
just a matter of preference. If you prefer
49:22 - single quotes, go ahead. Now I want to give
you a challenge. Here you are to create a
49:28 - variable message that stores the string, you
have three new notifications. Go ahead and
49:35 - do that right now. Okay, hopefully, that went
well. Let's do this message equals
49:49 - this string right here. Now what we want to
do here is combine this string with this string
49:56 - because this string right here is probably
the result have us checking in the database
50:01 - and seeing that, oh, there's three new notifications
that Pierre hasn't seen. So render out this
50:07 - ring right here. And then of course, we need
to combine it with the name. So what we want
50:12 - to do is message plus username like that,
when we add a plus here, we so called concatenate
50:21 - the two strings together. So let's have a
look at what happens when we run the code
50:24 - becomes a slightly ugly string, we have three
new notifications pair with no space in between
50:31 - the strings, so it kind of becomes like, this
isn't really what we wanted. What we then
50:38 - also can do is add a third string in between
here, which includes a comma and a space.
50:43 - Now if we run it, you have three new notifications
pair. And maybe we even want to add a exclamation
50:50 - mark at the end like that. As you can see,
when we use the plus for strings, simply concatenate
50:58 - the characters together. Okay, now I have
a new challenge for you. You are to create
51:04 - a variable message to user that contains the
message we have locked. By that I mean the
51:11 - entire message in here, this should be a new
variable. And then afterwards, I would log
51:17 - it out just to make sure that you have configured
the message to user in the correct way. Why
51:22 - don't do this right now. Okay, to do this,
you do left message to user equals message
51:35 - plus, comma space, plus username, plus, exclamation
mark. Now, we can replace all of this with
51:47 - message to user and running the code again,
we get the exact same string, which is just
51:53 - what we want it. Great job.
51:58 - Okay, time for another talent, you have to
create two variables, name and greeting. And
52:06 - the main variable should store your name.
And the greeting should store for example,
52:10 - Hi, my name is. And then you are to create
a third variable, my greeting that concatenates
52:15 - the two strings. And finally, log the my greeting
variable to the console. So this is just to
52:21 - give you some muscle memory. We had to do
this right now. Okay, let's do this. I'll
52:31 - do left knee equals pair, Harold, Oregon,
then let greeting. Hi, my name is and then
52:41 - a space at the end. And then finally, let
my greeting equals reading last name Ben.
52:49 - To see how this went. We do console log my
greeting. running the code? Yes, we get Hi,
52:57 - my name is Pierre Harold Bergen. Now, notice
that here, I added the space inside of one
53:05 - of the strings as opposed to doing something
like that. Forever being that would work the
53:12 - exact same way. So great job solving this
challenge.
53:16 - Let's move on. Okay, now let's mix it up a
little bit. And say
53:23 - that my name isn't pure Harold Bergen. It's
actually 42. a strange name. But anyway, what
53:29 - do you think will happen when we have one
number and one string? What will the result
53:32 - be? Let's do it. Actually, Hi, my name is
42. So the 42 here has actually been turned
53:38 - into string, and has been added into like
this. And that's kind of what happens in a
53:44 - wrestling game between a string and a number,
and the string always wins. Now this was a
53:49 - little bit of a weird example. So let's take
one that's a bit more interesting. Let's try
53:53 - let points equals four. And then let's say
bonus points. This is some kind of game that
54:01 - is 10. Lead total points equals points plus
bonus points, total points. Now, what do you
54:11 - think we'll log out here? I'm going to comment
out this one right here. Take two seconds
54:17 - to think about what the result will be. Okay,
let's run this. The result is 410. That is
54:24 - weird, because perhaps you expect them 14.
No, as I said, the string always wins. So
54:31 - when we see four plus 10, which is the values
of these variables, the form will be turned
54:37 - into a string. And the result when you concatenate
two strings, it's just very easy to see by
54:42 - just removing this fluff in between them.
410 if the numbers one, the wrestling game
54:48 - will be like this, it would indeed log out
14, but it didn't. So I'm gonna give you a
54:55 - couple of challenges here. What do you think
these four console logs will log out? Take
54:59 - a minute to think about That potentially write
your solutions in a code comment either above
55:04 - or perhaps even after each of the lines and
then return back to the screencast. And then
55:09 - we'll have a look at it together.
55:14 - Okay, here we have a number and a number.
So this will end up as a number as well, four
55:20 - plus five is nine. As far as I can remember,
your a string plus a string, even though they
55:25 - are number characters inside of the strings,
that doesn't matter. JavaScript still sees
55:29 - this as a string, and the result will be a
string of 24. Here, a wrestling match between
55:34 - a string and a number. Sadly, the number always
loses. So this will be history one. Finally,
55:41 - again, wrestling match between a number and
a string, the result is always at the string
55:46 - when so this will be 100 100. Like that, let's
run the code. Yes. You also can see from the
55:53 - console, the way the scribble console highlights
the difference between numbers and strings.
55:56 - As with the color, the strings are white,
whereas the numbers are blue. So great job,
56:02 - let's move on. Okay, it's time for a challenge.
This time, you are going to create a feature
56:11 - that we already have unscramble, because on
the dashboard, we welcome our users by saying
56:15 - welcome by compare Harold Morgan. That's a
normal thing a lot of apps do. So it makes
56:19 - sense to try to implement it. And we want
to do it is through grabbing a hold of this
56:24 - paragraph here, which I've given an ID of
welcome dash L. That is the first part of
56:29 - the challenge, you're going to store that
paragraph in a variable called welcome URL
56:34 - using this camel case convention. And then
you are to create two variables name and greeting
56:40 - that contains your name, and the greeting
we want to render on the page. In our case,
56:44 - that is Welcome back. Finally, you are going
to render the entire welcome message using
56:49 - welcome l dot inner text. So go ahead and
give this one a shot. And then I will show
56:54 - you the solution when you return back to this
cast.
56:59 - Okay, let's do this. We'll start by grabbing
the welcome l paragraph. Let welcome L equals
57:09 - document dot get element by ID passing in
the ID we have here. Like that. Now we need
57:17 - to create the two variables let name my name
is pair Harold, Oregon. Let greeting. Welcome
57:27 - back. And finally rendering it out. I just
done by doing welcome l doc. enter text equals
57:39 - greeting plus name. Now if we run this, we
can see we are rendering out Welcome back
57:45 - to pair Harold Oregon. But there's no space
between welcome back and my name that can
57:50 - easily be resolved by just adding a space
after Welcome back. Or we could of course
57:54 - hard coded in in between these two variables
when we concatenated the string as well. But
57:59 - that doesn't really matter that much in this
case. So let's just stick with this and move
58:03 - on to the next lesson.
58:06 - Okay, now there's one more thing you want
to do. Because Personally, I think this welcome
58:14 - message could be a little bit more lively
and fun. And what would help there is to add
58:19 - an emoji, for example, this emoji right here,
that would look pretty nice. So I want you
58:23 - to add that to the welcome element enter text.
However, there's a catch. You are not allowed
58:30 - to modify the code over line nine, you have
to write it below. So the question is, how
58:35 - can you add this emoji to the end here in
the browser by simply writing more code not
58:42 - by modifying any of the existing code. And
to give you a hint, you need to remember back
58:48 - what you did. When you increment the numbers,
this technique here, you can do the same thing
58:53 - with welcome l dot enter text. So go ahead
and give this a shot. Okay, hopefully that
59:03 - went well. If not, no worries, we'll do this
together. We're simply going to do here is
59:09 - instead of using count going to use welcome
l dot enter text instead of the one, we're
59:14 - going to use an emoji. So here we'll do welcome
l dot enter. Text equals the old welcome.
59:24 - Else, enter text, plus this new movie right
here. And an emoji is just a string. Like
59:32 - all other characters, it's just rendered out
a little bit fancy. So if we run this to see
59:36 - yes, we indeed get the emoji at the end. Now,
before we leave, I want to teach you a little
59:42 - trick. Because this line here is pretty clunky
writing the welcome l dot inner text twice.
59:48 - It's not something you'll see out in the wild
because there's a shorter version of writing
59:53 - this and that is simply using the plus equal
operator. What it does, it takes The current
60:01 - value you have, and then adds this one after
it fits the exact same thing that you were
60:05 - doing here. timbit weird. This plus equal
sign here was trying remember that it simply
60:11 - takes what you have here and adds this to
it. So that after this line, I'll come down
60:17 - to enter text consists of the entire thing
here. Okay, with that in mind, let's go back
60:23 - to our passenger counter app. Okay, just a
minor thing, before we start using strings
60:31 - in our app, I want you to use the plus equals
technique instead of this slightly longer
60:36 - count equals count plus one technique. Go
ahead and do that. Okay, hopefully, that went
60:46 - well, by simply doing like this count plus
equals one, run the code. Yes, it works. Let's
60:54 - move on. Okay, so now you're going to solve
a super cool challenge, you're going to take
61:01 - everything you've learned about JavaScript
up until now and use it to create this save
61:06 - feature can see it says previous entries,
and then four 511, with dashes that separate
61:13 - them. And these are, of course, added every
time you hit the Save button. Now, there's
61:17 - a dash after the three numbers as well. Don't
worry about that, it might look a little bit
61:22 - weird, but it's the easiest way to do this.
And we want to do it the easiest way. Now
61:26 - that you were building stuff like this first
time around, we don't worry about details,
61:30 - make it work first, then make it better. That's
my philosophy. So we're just going to make
61:34 - this work. Okay. So your three challenges
are listed as comments here in the JavaScript
61:40 - and the HTML, I'm going to write the paragraph
for you so that you have something to work
61:45 - with. So this is a p tag should say previous.
And Chris, like that, and I'm going to give
61:53 - it an ID equals save dash l for save element,
then you're going to grab the Save element
62:00 - paragraph and store it in a variable called
save L. And then in the Save function, which
62:05 - is triggered when the Save button is clicked
on, you are going to create a variable that
62:09 - contains both account, that is the number
and the dash separator. It'll look something
62:15 - like this, like 12 space dash space. And then
you are to render this newly created variable
62:22 - into the Save element using enter text. However,
you must make sure that you don't delete the
62:28 - existing content from the same old paragraph.
Because you do want to concatenate the string,
62:33 - not wipe it out entirely and replace the paragraph
with the latest entry. So you've got to remember
62:38 - your plus equal, luckily, you know how to
use plus equals and that might be helpful
62:43 - in this situation. Finally, one thing I want
to mention is that you might struggle a little
62:47 - bit with the spaces here and it might end
up slightly different than what you can see
62:51 - here. And that is perfectly okay. Don't worry
about that. The next cast actually we are
62:56 - going to do some searching online to figure
out if there are some alternative methods
63:00 - we can do this on, which will help us keep
these spaces. That's a critical part of web
63:05 - development, searching for solutions
63:07 - online. So I've left a little gotcha for you
here. So we get a nice little problem to solve
63:12 - using Google and some online docs in the next
guest. Don't worry about that. Just go ahead
63:17 - and give this your best shot. And if you need
help just revert to the screencast. And I
63:21 - will show you the solution as well. Okay,
hopefully this went well. If not, no worries,
63:31 - let's do it together. We are going to do let's
save our Adobe document dot get element by
63:38 - ID. And we are going to get the Save bash
l like that. Always I like to console log,
63:46 - just to see that I have the correct element
fetched. Let's run this code and he is bringing
63:51 - up the console, we see that we have grabbed
the correct element, then we can move on.
63:56 - First create a variable that contains both
the account and the dash separator. So what
64:02 - are we going to call this variable? I intentionally
didn't give you a name for it because I wanted
64:06 - you to think what could be a suitable name
for this string. And there's no right or wrong
64:11 - answer. But one thing you could call it would
be count string or count str. Like that. So
64:16 - it is the count. But we've turned it into
a string. So count string, kind of make sense.
64:22 - And the value of it will be count applause.
And then the string, a lot of space, a dash
64:28 - and a space or right three, render the variable
using enter text. Okay, let's do it down here.
64:35 - We'll do save l dot txt and then you might
have been tempted to do equal count r but
64:43 - that won't work. Let's just try it. run the
code, we increment we'd save boom, then we
64:49 - suddenly remove the previous entries. txt.
We will clear that out of course because we
64:54 - set all the intertext to be just this count
string. That doesn't work we have to take
64:59 - into account what was there Previously as
well. So we add plus equals like that increment
65:04 - increment increment save. Yes, that works
far right. So it works really well actually.
65:11 - However, this dash in there is gone, as is
our space here in the paragraph. And that
65:18 - is a bit weird, because we want to keep those
spaces. However, it's also a great opportunity
65:23 - to do some searching online in order to solve
this problem, which is a critical skill for
65:28 - any developers, namely, finding answers online.
We'll do that in the next cast. Okay, so we
65:39 - have this little problem here, which is that
our spaces aren't working in the way we want
65:43 - them to work. Basically, this space here gets
lost on the way somewhere, I don't know where
65:49 - but it happens. How do we go about figuring
out what's wrong? Well, looking at these two
65:55 - lines, which is where we deal with this save
element, paragraph, you think what would be
66:00 - a suspect which tool that we're using would
be a good suspect? And I'm gonna point to
66:05 - this one right here. Because I happen to know
that that is actually the guilty one, the
66:10 - inner text, and say, you'd guessed that as
well. How do you go about finding another
66:16 - tool that doesn't work this way? Well, one
thing you can do, is you can right enter text
66:21 - alternative. And then MDN, put that into Google
and see what it returns. MDN is short for
66:28 - Mozilla developer networks. And it's a great
resource. So if we do that, type that into
66:34 - Google, you can see the very first result
is node text content. Okay, that's interesting.
66:40 - Let's click into that. There, we land on an
interface, we're going to get very familiar
66:45 - with the MDN web docs that says node dot txt
content. Don't worry about this note here,
66:51 - it's kind of fancy way of saying HTML element,
sort of not entirely, but just translated
66:57 - to HTML element right now, and you'll be good,
then you can read the text content property
67:02 - of the HTML element represents the text content
of the element, okay. Seems pretty useful
67:08 - to me. And then we can scroll a little bit
down. And then you see they've actually listed
67:13 - up the differences between inner text and
text content. Here, if we scan through this,
67:19 - you can see that inner text only shows human
readable elements. And yet again, enter text
67:24 - is aware of styling, and won't return the
text of hidden elements. Okay, so it seems
67:30 - to be that the inner text somehow struggles
a little bit to return things that are hidden
67:36 - or not human readable. And like, yeah, space
is certainly not not human readable as a character.
67:42 - So maybe we can just change it then to dot
text content that said, let's try that. Text,
67:50 - content. Code, increment, increment increment,
save, oh, oh, yes, indeed, now we get the
67:59 - spaces. And one thing I want to highlight
here is that
68:04 - while the Mozilla web docs is a great resource,
it's very comprehensive, the language you'll
68:09 - see in these kinds of documentation sites
is often very technical. That's why I kind
68:13 - of skimmed through and found some hints of
human readable and hidden, and I kind of didn't
68:17 - worry too much about going into depth. And
I think you as well should think when you
68:22 - see a page like this, don't feel that you
need to understand everything. And for the
68:27 - love of God, don't try to learn the code by
just reading documentation. Some people say
68:31 - that's a good idea, I think it's a terrible
idea. You want to slowly learn how to get
68:35 - comfortable reading documentation. But you
also want to ignore all of the complex stuff
68:40 - that it's very often wrapped within. And there
are other sites as well, that explained things
68:44 - in various degrees of difficulty. For example,
there's also something called w three schools,
68:48 - which is very good there, Stack Overflow,
and many more. And you're going to see more
68:52 - of this as you progress in the course as we're
going to come back to this debugging concepts
68:56 - later on as well. But just for now, we've
just had a little sneak peek on the Mozilla
69:00 - Developer Network. And actually, it's kind
of trash talking the dot inner text here and
69:05 - saying that it's also computationally expensive.
So me, I've gotten enough hints that I actually
69:11 - want to use dot text content instead of enter
text. I'm going to change this up here as
69:16 - well.
69:17 - Like that,
69:20 - it still works great. Now our app is almost
complete, there's only one more thing we need
69:25 - to do. And we'll do that in the next guest.
Okay, so now we are going to put the final
69:33 - pieces in our puzzle, because we need to fix
the fact that if I increment this, and then
69:39 - hit save, and then the subway leaves the station,
and I'm going to count a new group of people
69:44 - then with the current solution, we'll be counting
further on from six like 789. And that's not
69:50 - what we want. We want this one to be set back
to zero every time we hit save. And to do
69:55 - this, you need to write two lines of code.
And at this point, I want to just throw you
69:59 - into the deep end of the pool and see how
you swim, if I'm not going to give you any
70:03 - hints or write any pseudocode, or tell you
where you're going to write these two lines,
70:08 - now you really have to think and think for
yourself, what do you need to do here in order
70:12 - to make this work. And feel free to hack a
little bit on it to try a solution, run the
70:16 - code, see how it works, console, log out the
values, just hack away at it and give it your
70:20 - best shot. And if you don't manage to do it,
no worries at all, because I will show you
70:24 - how to do it again, of course, when you return
back to the screencast. So then you can just
70:28 - try to do it again, after you've seen my solution.
Anyway, enough talk, jump into the code here
70:33 - and give this a shot. Okay, now let's solve
this together. So what we need to do is write
70:44 - a couple of lines in this save function, because
this is where the magic should happen, because
70:48 - it's when we hit the Save button that we want
this value to be set back to zero. And how
70:54 - do we set this element to be zero? Well, it
is the count element, which we've worked with
71:00 - previously. and setting it to zero. We know
how to do that we can do count l dot constant
71:06 - and set that equal to zero like that. By rerun
the code, increment the increment the increment,
71:12 - increment it save, and yes, it's now zero.
But if I now try to hit the increment again,
71:18 - you'll see Oh, five. That's weird. Why is
that? That's because we have indeed set the
71:25 - text content of the count element to zero.
So this is true right here. But in the JavaScript,
71:32 - we're still keeping track of the count. And
that count has been incremented, this point
71:37 - five times. So what we needed to do here,
when we set the text content to zero is to
71:44 - also set the count back to zero as well, because
JavaScript remembers what we've done previously,
71:50 - unless we refresh the entire browser, even
though JavaScript can see that, yeah, you're
71:53 - setting the text content of this element here
to zero, it still keeps track of the count
71:58 - here. And JavaScript can't deduct that, since
you want to set this here to zero. You also
72:03 - want this to zero, no, you got to give JavaScript
very specific instructions. So you need to
72:08 - do here, count equals zero as well. Now, if
we run the code, bam, bam, bam, save, it's
72:15 - at zero. And yes, we indeed start at zero
again. So great job reaching this far. So
72:29 - you have built your very first Javascript
app from scratch, congratulations, that is
72:34 - a huge accomplishment, that's all give yourself
a pat on the back, you have really learned
72:39 - a lot in this section. And to prove that you
are actually going to do a little recap. So
72:44 - you get to see in front of you, all of the
new concepts you've shoved into your brain
72:48 - at this point. So we started out with the
script tag, if you remember, we had it here
72:53 - in the index dot HTML file, and we wrote our
JavaScript internally, in this file. However,
72:59 - we realized that that wasn't the way we want
it to go. So we instead pointed this script
73:04 - tag to a source, namely the index.js file
so that we could write our JavaScript there
73:08 - instead. Then we moved on quickly and learned
about variables, namely the left variable,
73:14 - and we set its value to a number, which brings
us to your very first data type numbers, you
73:20 - learned how to work with numbers, do mathematical
operations, and even increment numbers here
73:24 - on line six, and also reassign the count variable
to zero, here on line 14. So a lot of work
73:32 - with numbers in this up. But you also learned
about strings, which was your second data
73:36 - type, here, you added a string to build the
same feature. And also you console log out
73:41 - a few strings along the way with code that
we have deleted now, so I added the list console
73:46 - log here to remind you about it. Because that
is a truly important concept in developing
73:50 - and you will use it throughout your entire
career. Also, another thing you will use constantly
73:55 - as a developer is functions. You learned how
to create functions like this increment and
74:00 - save function, and also how to call them aka
invoke them from the HTML file here on the
74:06 - button clicks. And that brings us to the next
concept which you learned a ton about, which
74:11 - is the DOM or the Document Object Model, or
what I like to call it,
74:16 - how to use JavaScript to change the website.
So we interact with with the DOM at several
74:22 - places. For example, up here we we did document
dot get element by ID, that's one you're going
74:27 - to get very familiar with. Throughout this
module, we passed in the ID as a string. So
74:33 - the JavaScript was able to head into the HTML
and fetch out the content you told it to look
74:39 - for. And another way we interacted with the
DOM was through the inner text property. We
74:45 - use that here instead of text content, but
then we googled our way to the Mozilla Developer
74:51 - Network, realize that actually, next content
is a better solution. So we learned about
74:57 - that and oh my god, this is a lot of concepts
to learn. totally understand if you're a little
75:02 - bit overwhelmed. And if you feel that you
are on thin ice on a few of these concepts,
75:07 - that's totally okay, we are going to repeat
all of these things over and over again throughout
75:11 - the module. But don't worry about that. Actually,
we are going to jump directly into a section
75:17 - where you are going to get assignments that
test you for the skills just to give you that
75:21 - repetition and muscle memory you need in order
to make these concepts become second nature.
75:26 - So let's go ahead and get some repetition.
And then once we've done with that, we'll
75:30 - move on to our next big project, the blackjack
app, which is going to be so much fun to build.
75:37 - So I can't wait to see you there. For now,
let's jump into a few quick fire challenges.
75:44 - Okay, in this challenge, you're going to repeat
variables. So first, you're going to create
75:52 - two variables, first name and last name. And
obviously, I want you to set their values
75:57 - to your first name and your last name. And
then concatenate the two variables into a
76:03 - third variable called full name so that you
have your full name. Finally, log full name
76:08 - out to the console, go ahead and give this
a shot right now. And then I will show you
76:13 - my solution when you return back to this screencast.
76:18 - Okay, let's do this. I'll do first name equals
here. And then I'll do let last name equals
76:29 - Morgan like that. Then we need to concatenate
the two together, let name equals first name,
76:39 - plus last name, like that. Finally, I want
to log it to the console. Console dot log,
76:47 - full name. Now I can run the code. And as
you can see, we're logging here borgen to
76:53 - the console. But there's no space in between
the two names. So I could achieve this in
76:58 - a multitude of ways, either by adding a space
here, now it's better or adding a space before
77:06 - Morgan. Still good. However, neither of these
are optimal, since I want the first name and
77:12 - last name to be the name and the name only
not an extra space. So what I'll do instead
77:18 - is in between here, add an extra space like
that. running the code, there we go. Now,
77:25 - first name and last name, contain only the
characters of my name, but we still get the
77:30 - space by adding this third string here, when
we create full name. So no matter how you
77:36 - did it, great job, let's move on. In this
challenge, you are going to create a function
77:45 - that logs out Hi there, Linda, when called.
And you have to use the name and the greeting
77:51 - variable inside of the body of your function.
And also there's a comma and an exclamation
77:55 - mark, you also have to include so that you
get this exact string log to the console.
78:01 - So go ahead and solve this one. And then I
will show you the solution afterwards as well.
78:07 - Okay, let's do this create a function, I'll
call it greet Linda like that. Here, we are
78:15 - going to console log, first the greeting,
we're going to have to plus the comma and
78:21 - the space, and then plus again, then the name
and then plus again. And then the exclamation
78:27 - mark like that final step to check our code,
we need to run it greet Linda like that, running
78:34 - the code. And there we see this exact string
in the console. Great job. In this challenge,
78:44 - you are going to practice your incrementing
and decrementing skills. So let's say that
78:49 - you are building a game and the player is
collecting points, which currently are at
78:53 - three and you need to create two functions
one which is called add three points, and
78:58 - one which is called remove one point and of
course then have these add and remove they're
79:02 - given points from or to the my points variable.
So remove one point should decrease my points
79:10 - with one add three points should add three
points to the my points variable. And your
79:16 - job is to create those two functions and then
call them however many times you need to call
79:21 - them in order for this line down here to log
out the number 10. So you are going to write
79:28 - your code in between here, you can add as
many lines as you want. That when you eventually
79:33 - run the code, my points should be 10. And
you should only have changed my points via
79:40 - calling these two functions a number of times.
So go ahead and give this one your best shot
79:45 - and then I of course will show you the solution
afterwards as well. Okay, hopefully that went
79:55 - well. Let's do it together. We'll do function
add three points. what that'll do is take
80:02 - my points and plus equal three. function,
remove one point. And that should do my points
80:14 - minus equal one like that. Okay, now we have
them, which means that we just need to call
80:21 - them a couple of times, we are at three, and
we need to get it up to 10. What I will do
80:25 - then is I'll first do adds three points, call
that three times, because then we'll go up
80:32 - to 12. My calculation is correct. From this.
Yes, we are indeed logging 12. That means
80:42 - that we can remove 1.2 times that should get
us to 10. Yes, we are logging out Tim. So
80:51 - we have solved the challenge. Great job. Okay,
it's time for some strings and numbers repetition,
81:02 - you're going to add a bunch of strings and
numbers together and try to predict what the
81:05 - result is. So here, after each one of these
lines, I've added two slashes, that means
81:11 - that you can write your prediction, try to
go through all these, and then run the code
81:16 - and see how you get it. And then I will give
it a shot afterwards as well. Good luck.
81:24 - Okay, starting on the number two is a string
plus a number, we know that JavaScript then
81:31 - turns both of these into strings. So it becomes
22. Here, 11 plus seven, that's just two numbers,
81:40 - we get 18. And as a number this time and not
as a string, six plus five, you might be fooled
81:46 - to think that JavaScript would treat this
as a number calculation since the number is
81:51 - first But no, actually, the string wins, and
it becomes 65. Likewise, with this one, here,
81:59 - it's very natural to think that what you want
to do is add these two points together so
82:03 - that it's my points is 14. But no, since you
have a string here, everything will be turned
82:07 - into a string. And the result will be my points,
colon 59, two plus two, that's for just a
82:16 - number. And finally, two strings, of course,
becomes a string 1114. Like that. Let's run
82:22 - this. And indeed, all of my predictions were
correct. That was good. Otherwise, I would
82:28 - lose all my integrity. So I'm really happy
about that. Let's move on. Okay, let's imagine
82:37 - that you are working on an ecommerce website.
And this website sells shoes. So here you
82:41 - can see a Nike shoe with a purchase button.
The HTML is located here, of course, with
82:47 - an image tag the paragraph for the Nike shoe,
the button, but then there's also an empty
82:53 - error paragraph. And this is pretty common,
because in case there's an error going happening,
82:58 - for example, the purchase didn't go through
or some kind of bug costly operation to fail,
83:03 - or whatever it is, we want to render something
inside of this paragraph. So that is your
83:09 - job. In this challenge, you are going to set
up the JavaScript so that when the user clicks
83:13 - on the purchase button, you are to render
out something went wrong, please try again,
83:18 - in the paragraph that has the ID of error.
That's, of course, this one. And the button
83:23 - they will click is of course, that one, you
can see there is some CSS here, but you're
83:28 - not going to worry about that, because this
challenge is all about the JavaScript. And
83:33 - of course, also hooking up the onclick event
listener on this button, you should know how
83:38 - to do that by now. And you should also know
how to render text inside of a paragraph.
83:44 - So go ahead and give this one a shot. And
then of course, I will show you the solution
83:47 - afterwards as well. So there are two parts
to this challenge. First, there's registering
83:56 - that the user clicks on the button, and then
there is rendering out the text in the DOM.
84:02 - So let's take First things first the button.
So I'll head over to the button and do an
84:07 - on click event listener. And here we need
to specify which function we want to run.
84:12 - We haven't written any function yet. So let's
do that. We'll do a function. I'll call it
84:17 - Curtis, because that's what the user is trying
to do. Open and close curly brackets. Now
84:23 - I can take this function and specify that
when the user clicks the button, we want to
84:28 - call this function. Good stuff. Let's just
console log out. Button clicked. On this code,
84:38 - try to click the button
84:39 - and yes, we are rendering out button clicked
good. The next step is to grab a hold of the
84:44 - paragraph that we are going to render text
inside of. So we'll do
84:49 - let
84:50 - error paragraph and do document dot get element
by ID. I think in or like that. Again, we
85:01 - can do console log, just to verify that we
have grabbed a hold of the right paragraph,
85:06 - we run the code and bring up the console.
And yes, we can see that we have the paragraph.
85:11 - Then inside of the purchase function, this
is where we want to trigger the rendering
85:16 - of the error text, other error paragraph dot
text content equals this string right here.
85:26 - Now, if we rerun the code, click the purchase
button. Yes, something went wrong, please
85:33 - try again. And as you can see, it's rendered
out in red text, which is very common, because
85:37 - we want to grab the users attention and tell
them that something wrong has happened. And
85:41 - that is, of course, something we have specified
in the CSS. But this challenge is not about
85:46 - CSS, it was about JavaScript. So great job
of solving this, let's move on. Okay, in this
85:54 - challenge, you're going to create a very basic
calculator. As you can see, in the browser,
85:59 - here, I've set up the UI for you. Here, we
have two buttons, here we have the numbers,
86:05 - eight, and two. And then there's four buttons,
add, subtract, divide and multiply. If I try
86:10 - to click one of these, now, nothing happens.
What do you then of course want to happen
86:14 - is that, for example, if you hit subtract,
you're to take eight minus two, which is six,
86:19 - and then render that out in the sum here,
so that it'll say some colon six. Taking a
86:25 - look at the HTML, we can see that the numbers
at the top number one L and num, two L, that's
86:31 - the eight and two are simply spans However,
they are empty. So how can we have competent
86:38 - them when they are rendered? Well, that is
because I'm doing that in the JavaScript,
86:42 - first defining two let variables num one and
m two, and setting them to eight and two,
86:48 - and then doing document, get element by ID
fetching out num, one L and num, two L, and
86:54 - setting each of their text contents to num,
one and number two, and that's why we're rendering
87:00 - out these numbers moving on to the buttons,
you can see that they are very simple. Only
87:06 - the tag and the text, I have not created the
event listeners, because that's your job.
87:11 - And then finally, the span with the ID of
some L is where you are going to render out
87:16 - the result of the calculation. So summing
this up, you are to create four functions
87:21 - here in the JavaScript file, add, subtract,
divide and multiply. And then you need to
87:26 - call the correct function when the user clicks
on one of the buttons. So obviously, when
87:30 - the user clicks the Add button, you are to
call the add function and vice versa with
87:35 - all the others, then inside of the function,
you are to perform the given calculation.
87:39 - So in odd, you need to add num one a num two
together, and subtract, you will take num
87:45 - one minus num two and divide, and so on. Finally,
render the result of the calculation in the
87:51 - paragraph that has the ID of some element.
So go ahead and give this one a shot. And
87:56 - then of course, return back to the screencast
when you want to see my solution.
88:02 - Okay, let's do this. I'm going to start by
creating here an on click event handler and
88:13 - call this function add because when the user
clicks the Add button, we want to invoke a
88:17 - function which ought to be named up. And then
we need to create the functional function
88:22 - ad. Here, what do we want to do? First, we
just want to check that it works. And the
88:32 - code ad Yes, we are logging out now then we
need to grab ahold of the some paragraph.
88:39 - So I'll do let some L equals document, get
element by ID. The ID is some dash l like
88:50 - that. Here, I'm just going to see if it works
by doing some l dot txt equals num one plus
89:00 - num two. rerunning the code. And yes, there
we can see, we're rendering out 10 however,
89:09 - we wanted to render out some colon equals
10. So let's try adding some colon, plus num
89:16 - one plus num two, running record hitting add.
And now we have come into a situation where
89:23 - actually, JavaScript is turning all of our
three values into strings. As you remember,
89:29 - when you add strings and numbers together,
they're all turned into strings. What we need
89:34 - to do here is first perform the calculation
and then concatenate that with the screen.
89:40 - So we'll do let result equals number one plus
number two, because here we're only adding
89:45 - numbers together and JavaScript will treat
them as numbers and thus perform a mathematical
89:50 - calculation and not a string concatenation.
So then we can replace this expression here
89:55 - with result. rerunning the code, clicking
add, add Yes, there we go. Great stuff. Now,
90:04 - I'm a little bit lazy. So I'm just going to
copy this, paste it in, and do sub tract and
90:12 - simply replace this with a minus, add the
on click equals sub drags like that running
90:22 - the code, quaking, subtract, six, brilliant.
Now we'll just copy paste again divide should
90:34 - get this use the division symbol and multiply
should use the multiplication symbol. Now
90:43 - we only need to add the last two event handlers
vide is the name of that function. Bass hair
90:55 - and multiply is the name of the final function,
running the code trying to add it was 10 brilliant,
91:02 - subtract give sex, that's correct divide rightfully
gives four and multiply 16 we have made a
91:08 - calculator. Good job, you have all reason
to be proud of yourself now. And if you didn't
91:13 - manage to do this one, if you found that a
bit too hard. Now that you've seen the solution,
91:17 - just go back and try it again. That's great
practice and gives you the muscle memory you
91:21 - need. And when you're ready, I'll see you
in the next cast. He and welcome to building
91:29 - blackjack. I'm so excited about this one because
you are going to learn JavaScript while building
91:34 - one of the most iconic casino games ever.
Here is a sneak peek of the app we are going
91:39 - to build. And while it's not a full blown
blackjack app, of course, it does share a
91:44 - lot of the functionalities with blackjack
apps you can play on online casinos. Speaking
91:48 - of that, that's actually a huge market, people
spend over $20 billion per year gambling on
91:55 - online casinos. And personally, I love playing
poker and blackjack. I think my life actually
92:01 - peaked when I want 100 euros on a casino in
Prague in 2016 made me feel like such a gangster,
92:07 - we spent the rest of the weekend squatting
in front of fast cars, like this Mercedes,
92:12 - this Hummer, this BMW and this Bentley. So
vital this section, of course, is to make
92:18 - you feel as cool as I did in 2016. And with
that out of the way, let's just get started.
92:26 - Okay, so we're going to kick this off with
a challenge, you are going to create two variables,
92:34 - the first card and the second card, then you're
going to set their values to a random number
92:38 - between two and 11. So that's the values you
can draw from the deck of cards in blackjack.
92:44 - Secondly, you are going to create a variable
sum and set it to the sum of the two cards.
92:50 - So go ahead and do this right now. Okay, let's
do this. Start with the first card, we're
93:01 - gonna set it to six, and the second card after
nine, then the sum, of course, equals first
93:09 - card. last card. Let console log out the sun,
run the code. And yes, indeed, we get 15.
93:19 - Great job. Let's move on. Okay, so we are
ready to build the logic of our blackjack
93:27 - game. Now let's have a look at how blackjack
works before we try to formulate this in JavaScript.
93:32 - So the point of the blackjack is to get a
hand that sums up to exactly 21. And if you
93:38 - don't get 21, at least you want to get as
close to 21 as possible, but never above 21.
93:44 - Because if so you're out of the game. So here
are three scenarios, one where you have two
93:48 - cards on your hand, that's your starting hand,
and they amount to 15. So you're still in
93:52 - the game, no big reason to either cry or celebrate.
And then there's the other case where you
93:57 - have a king and an ace. And since the ACE
here equals 11, and the king equals 10. You've
94:03 - got blackjack. So Woohoo. And the third scenario,
we started out with a 10 and a six. And then
94:09 - you asked for new card, but then you ended
up at 22. So you're over 21. And sadly, you've
94:15 - lost your money. So now the question is, how
do we translate these things into JavaScript?
94:21 - Sadly, JavaScript isn't as smart as you are
who can understand this, but just hearing
94:25 - me talk about it. JavaScript is kind of stupid.
And it needs you to describe the logic 100%
94:31 - correct. So let's just do that. So you get
to see it in action. We start off with writing
94:36 - if and then open and close parentheses. And
then it's the sum of our cards that we're
94:42 - going to check to say if sum is less than
21, just like we were doing here. So this
94:49 - crocodile mouth is something you might recognize
from your maths class at school. And it kind
94:53 - of makes sense because here on the right hand
side, you can see that's where the gap between
94:56 - the teeth of the alligator is the largest
verse at the left hand side here, the gap
95:01 - between the teeth is the smallest. So small
value here, large value here. If this condition
95:07 - is true, meaning that sum is less than 21.
Well, then we add two curly brackets and tell
95:13 - JavaScript that we want to execute the piece
of code inside of those curly brackets. So
95:17 - we'll do console log, do you want to roll
a new card, since that's what you can do in
95:27 - this scenario, you are still in the game.
And you can draw another card if you want
95:30 - to. But there are cases where this isn't true.
And we need to account for those as well.
95:35 - We do that by writing, else F, an open and
close parentheses, and here we write some
95:41 - equal equal equal 21. This is else if sum
equals 21, then we want this code to be executed.
95:53 - This triple equal operator is different. From
this one right here. Here, we are saying that
95:58 - we want the sum to become first card plus
second card. But here we're asking is the
96:03 - sum strictly equal to 21? You say strictly
equal when you see three equal marks, and
96:09 - don't worry about why it's three and not necessarily
two. We're going to get back to that later.
96:14 - For now on just use three equal marks. When
you write elsif statements, we are checking
96:19 - if a variable is exactly some kind of value.
So if the sum is 21, what is the case? Well,
96:25 - who the player has blackjack folder for log?
You've got, like back like that. And then
96:37 - the third scenario, we'll do else if yet again,
some. What do you think we'll use here, of
96:43 - course, we'll use this one right here. Because
if the sum is larger than 21, then the user
96:48 - has lost, some is greater than 21, open and
closed, curly brackets, console log, you're
96:56 - out of the game. I got lucky, let's have these
emojis as well. There we go. Now, one little
97:04 - thing I want you to notice here is that here,
I have to use double quotes to wrap this,
97:11 - as I'm using single quotes to create this
you've and your words, because if I was using
97:17 - single quotes here, it would be completely
off because JavaScript would have thought
97:22 - that I was intending to close off this string
right here, when I'm not intending that I
97:27 - was just writing you've instead of you have.
So just a little digression there. Now let's
97:32 - run this code and see how it works. We'll
hit run. And yes. Do you want to draw a new
97:37 - card? We triggered this, which seems correct,
since I'm plus six is 15. And that is indeed
97:42 - less than 21.
97:43 - Let's try to do n and 11. So this is blackjack?
Yes. JavaScript triggered line eight, which
97:51 - is what we wanted. And finally, let's say
that we got 17. On the first two cards, and
97:57 - we really wanted a new card, we wanted to
take the times, but we bombed out by getting
98:01 - six, if so are some would be 23. And what
do you think will happen? Yes, this line of
98:07 - code should be run, I'm gonna run the code,
and boom, you're out of the game. Now a final
98:12 - thing I want to tell you about before we move
on is that could actually skip all of this
98:17 - code if we wanted to do like that. Because
if some it's not less than 21. And it's not
98:24 - exactly 21, either, meaning we've jumped to
the third clause in our if else clause, then
98:30 - it must be over 21 mean, there's no other
alternative in the entire universe. So there's
98:36 - no point specifying that some here should
be over 21. For this block of code to be executed,
98:44 - meaning we can just skip it. So do we have
if sum is less than 21, execute this if sum
98:50 - is exactly 21. execute that and In all other
cases, execute this, this will work as you
98:56 - see by running the code in the exact same
way. Okay, now that you know that, let's move
99:02 - on.
99:10 - Now it is your turn to write an if else statement,
you're to check if a person is old enough
99:15 - to enter the nightclub, which has a lower
age limit at 21. And then you are to log a
99:21 - suitable message to the console in both cases.
And by that I mean if the user is less than
99:26 - 21, or if the user is 21, or older. So I've
defined the age variable here and also written
99:33 - pseudocode. If less than 21, then a suitable
message would be for example, you cannot enter
99:38 - the club else meaning all other cases because
if they're not less than 21, it has to be
99:43 - 21 or above, then you have to log something
like welcome. Go ahead and give this a shot.
99:49 - And if you have forgotten how to write in
a false statement, just go back and rewatch
99:53 - the previous lesson. And notice here that
I don't have an else if statement in between
99:58 - here. I only have the first If and the final
else, not the elsif, which we had in the previous
100:05 - lesson, and that is because I want you to
think for yourself and try to figure out,
100:09 - well, how do you write this with only an IF
and an else and not the if else in between,
100:15 - let's give it a shot. And I will show you
the solution as well when you return back
100:18 - to the screencast.
100:22 - Okay, hopefully that went well, let's do this.
If less than 21 we have to do age is less.
100:32 - Remember this alligator mouth here, and 21
like that, this means the person is maximum
100:40 - 20 years old, then we are to do following
well, console dot log, you cannot enter the
100:50 - club, and then we simply do else. Then we
open close curly brackets. and here we can
100:58 - console log allcom. running the code we get
welcome not correct. Trying to lower the age
101:06 - to 20 we get you cannot enter the club. Now
a final thing I want to point out is that
101:12 - you could also solve this by using another
comparison operator, which is the less than
101:18 - or equal to that means a slightly different
thing though, because it checks that this
101:23 - value is less than or equal to 21. So if we
take this back to 21, and run it can see we
101:32 - get you cannot enter the club, which obviously
is wrong, they should be able to enter the
101:36 - club at this point. So if we're using the
smaller than or equal to operator, we have
101:41 - to use 20. Because then we include 20, that
is an upper range that is inclusive of that
101:47 - number. So now it works. Whether you prefer
using less than or equal to or just the less
101:55 - than is up to you, you just need to keep in
mind all that changes the entire expression.
101:59 - With that, let's move on. Let's practice if
else statements a bit more, because in Norway,
102:08 - we have this super cool tradition where when
you reach 100 years old, you get a personal
102:14 - birthday card from the king. This is the king
King Harold, the fifth of Norway. And in this
102:18 - challenge, we are going to code the logic
for this. So here it is in pseudocode. If
102:25 - less than 100. And here I'm talking about
the age variable, of course, then you are
102:30 - to log something like not illegible to the
console. Else. If the age variable is exactly
102:36 - 100, you're to log something like here is
your birthday card from the king. And else
102:41 - In all other cases, meaning they're over 100
years old, you get not illegible, you have
102:46 - already gotten one because if they're 105
years old, they got their birthday card from
102:50 - the king five years ago. Okay, go ahead and
give this one a shot. And then I will show
102:55 - you the solution afterwards as well.
102:59 - Okay, let's do this. If age is less than 100,
we'll console log, not likable. And then we
103:13 - have to do the else if and specify the condition.
Age is exactly 100. When we console log, here
103:22 - is your birthday card from the cake. And else
In all other cases, the person is over 100
103:28 - years old, they have already gotten their
card, the previous birthday, so not electrical,
103:35 - let's run the code. Yes 100, you are getting
the card at 45. You are not legible. At 145.
103:45 - You are not illegible either. Finally, before
you leave, let's take a closer look at this
103:51 - triple equals here because it might seem like
a little bit of an overkill to have three
103:55 - equal signs after each other. And that is
a valid point, you could use two. If we run
104:01 - the code, it still works with 145. And actually
with 100 as well, it would still work, you
104:08 - are getting your birthday card. However, the
thing with two equals so called the double
104:12 - equals is that it's a little less strict.
So let's say that you by mistake asked in
104:18 - a string here as well, which has the same
value of 100. But it's a string and not a
104:23 - number. If we run the code, you can see it
still works. However, with the triple equals
104:28 - running the code, then it doesn't work. Now
it says not illegible, even though 100 is
104:33 - here as a number and 100 is here as a string.
So double equals ignores the fact that this
104:40 - is a string. And this is a number basically
converts this into a number if it's a number
104:46 - on the left hand side as well, so that this
entire thing would be true. However, that's
104:52 - not what we want. We actually want to be strict
in our code, which is why I would recommend
104:57 - you to only use triple equals ignore double
equals, this forces you, as a developer to
105:02 - be a bit more mindful about how you are checking
your conditionals, you need to make sure that
105:07 - if you're starting out with a number up here,
you're also comparing it with a number down
105:11 - in the conditional. But that's just good practice
being thoughtful as to what kind of data type
105:17 - you are using in your code. Just stick with
triple equals, and you'll be just fine. With
105:23 - that, let's move on. Okay, so now we're back
at our blackjack game. And you might have
105:32 - noticed that we've lost the code that we previously
had. Well, that's the point of scrim, but
105:36 - you are going to write the code, not me. So
I want you to rewrite the conditional that
105:41 - I created previously. But with a slightly
different take, you have to follow the logic
105:46 - that I lay out in the pseudocode here. So
you have to use in the first if clause, the
105:52 - less than or equal to operator, so you have
to set it to less than or equal to 20. And
105:57 - then in the elsif clause, you can use the
strictly equal to check if the sum is exactly
106:02 - 21. And finally, you're going to use the else
clause and not an else F on the third conditional,
106:08 - which I did previously. So go ahead and do
this. And if you can't do it, or want to see
106:12 - my solution just returned back to this screencast.
And I will show you how to do it as well.
106:20 - Good luck.
106:22 - Okay, let's do this. First, there's the if
sum is less than or equal to 20, then we are
106:32 - console, logging out this string right here.
And then we do else if the same as we did
106:40 - last time, some triple equals 21. That's the
blackjack case. And here, I'm lazy. So I'll
106:47 - just copy paste this one. And then this one
in here. And then finally, Mark doing elsif.
106:55 - And checking for the condition, just doing
the else all other cases, and then pasting
107:01 - in this, you are out of the game, string like
that. Good stuff. Let's run the code. And
107:08 - yes, we have 17 here, and we rightfully so
logged out. Do you want to draw new harder?
107:14 - Good stuff. If we try to hit one more time?
with another 10? We are out of the game? Good
107:21 - stuff? And how about for blackjack? Oh, great
job. Let's move on.
107:27 - Okay, so our game is coming along really nicely
here. However, there's a big problem. And
107:37 - that is, let's say that you are playing this
game and you get blackjack. So you get a 10
107:41 - and an ace and boom, you've got back back
down here at line 13. You of course want to
107:47 - cash out your money and get the pot on the
table. However, at this point down on line
107:51 - 13 JavaScript has no way of knowing which
console log it logged out. It doesn't remember
107:57 - that. So what we need to do then is introduce
a new variable that keeps track of this state,
108:03 - you can call it the state of the game, like
has the user gotten blackjack? Or maybe house
108:08 - the user last, or whatever it is. So what
we then want to do is for the scenario, have
108:14 - a variable that reflects whether or not the
player has blackjack. And when I say whether
108:19 - or not yes or no, is there a data type in
JavaScript that you think might be suitable
108:24 - for describing such a state? If you guessed
a Boolean, a true or false, it is correct.
108:30 - So what we'll do sudo, let pass backtrack
like that. And set that initial value of course
108:37 - defaults because default, you don't have blackjack,
then here inside of the if clause that describes
108:47 - the blackjack case, we're simply going to
reassign the Hass blackjack value to true
108:53 - instead. Now down at line 16. If we log this
out, has blackjack value and then run this
109:02 - code, boom, you can see that we're both logging
out on line nine, and we have persisted the
109:09 - state. So the line 16, for example, can start
writing the code for taking the cash that's
109:13 - on the table that now is rightfully yours,
and then deposited into your account. So now
109:18 - we have an app that keeps track of the data
of the state in a much more sensible way.
109:23 - I want you of course to write this kind of
logic yourself. So in the next cast, I'm going
109:28 - to give you another challenge so that we can
keep track of even more of the state of this
109:33 - game.
109:34 - I'll see you there.
109:36 - Okay, so now it's your turn, and you are going
to make the state of our game a little bit
109:43 - more robust, because at this point, we're
only tracking if the player actually gets
109:48 - blackjack. If the player busts out and gets
22 or more, we're not tracking it. And obviously
109:53 - we have to do that. So I want you to create
a variable called s alive and start by assigning
109:59 - it to And then you're going to flip that value
to false inside of the appropriate code block.
110:06 - So there's three code blocks, the if block,
the elsif, block, and the else block. And
110:12 - you of course, then have to pick the correct
code block, and then write that line of code
110:16 - that flips the value to false. And finally
logging out to check that you're doing everything
110:21 - correctly. So good luck, go ahead and do this.
And then I will show you the solution afterwards
110:25 - as well. Okay, let's do this. starting up
here, we're going to create a loop variable
110:34 - called s alive and assign that to true, because
when you're starting out, the player is still
110:40 - alive. And at which point is the player no
longer alive, meaning out of the game? Well,
110:46 - that's obviously here in the else block, because
that's the case if the sum is 22 or more.
110:50 - So here, we'll do this alive equals false.
And then finally, we'll console log is alive
110:59 - like that. We got true, because actually,
we have blackjack, and rightfully so, player
111:04 - is not dead. How about if we pretend that
we add a third card here, really stupid idea
111:10 - because there was card after you've gotten
blackjack, but let's just pretend that run
111:15 - the code, and boom, false, no longer alive.
Great job solving this challenge. Let's keep
111:21 - up the pace and move on.
111:27 - Now that you've learned about Booleans, let's
take a look back at the conditional you wrote,
111:32 - because one thing you probably didn't think
too much about when you wrote your conditionals
111:37 - is that the expressions inside of the parentheses
would be translated by JavaScript eventually
111:44 - into a Boolean. So it would be either true
or false. That's always the case with expressions
111:53 - passed into conditionals. Because here we
are comparing two numbers, and one of them
111:59 - are either larger than the other, or they
are two equal numbers. So the claim you come
112:04 - with has to be either true or false. Let's
try to play this out using an example. For
112:10 - example, when you've gotten two cards, a 10,
and an 11, meaning you have blackjack, in
112:14 - that case, some will be 21. And the claim
you come with inside of the first if statement,
112:20 - obviously, that is a lie. Meaning it gets
evaluated to false. In the second condition,
112:28 - though, you're saying that sum is equal to
21. And we know we are going to translate
112:32 - the sum into 21. Because that's what it is.
So here, you're saying 21, triple equals 21?
112:39 - Well, yes, that is a true statements. So that
becomes the true Boolean. And here, you can
112:46 - read through it. If false, well, then we're
going to skip the body of this statement.
112:51 - Else. If true, yes, we like true, then we
are going to execute that piece of code. So
112:56 - this is essentially what happens when you
run the code with specific values for these
113:02 - variables. rewinding it back. What I want
to do now is stress test your comparison and
113:10 - Boolean skills. So I'm going to paste in a
bunch of console logs here, and then comment
113:17 - out our blackjack game. Now your job is to
look at each of these expressions, and predict
113:24 - whether true or false is logged to the console.
So write either true or false after these
113:30 - two slashes on each of the lines from one
to seven. And then of course, when you've
113:35 - given it a shot, run the code and see how
it went. And then I will do the same thing
113:38 - afterwards as well. Go ahead and do this right
now.
113:44 - Okay, let's do this. First, Fort cripple equals
three. Obviously, that's wrong. gonna log
113:54 - out false. Five is greater than two. That
is true. And 12 is greater than 12. No. 12
114:04 - is not greater than 12. It's exactly the same.
So this will be a false statement. We is less
114:10 - than zero. Again, that's also false. Three
is larger than or equal to three. Yes, that
114:18 - will be a true statement. Because it's not
larger than but it is equal to. So 11 is less
114:27 - or equal to 11. Again, it's not less than
11. But it is equal to 11. So it's true. And
114:35 - three is less or equal to two, no three is
actually larger than two, meaning that this
114:40 - is going to be false. So this is my prediction.
Let's run the code. Bring up the console.
114:47 - And yes, I was right. Very good. Let's move
on. Welcome back, my friend. I hope you are
114:57 - ready for a new challenge because that is
Exactly what I have in store for you. Now,
115:01 - actually, it's a three part challenge, because
you are going to make our program a little
115:06 - bit more robust in the sense that it might
be that these console logs here that we're
115:11 - just throwing out into the void log into the
console and forgetting all about can be used
115:16 - later on down the line, or that we have some
reason to want to keep track of them maybe
115:20 - want to render it out at multiple locations
in the app, maybe there's some notification,
115:25 - and there's text, there's a log of messages
you've gotten. Maybe we want to repeat it,
115:29 - I don't know, there's tons of reasons for
keeping this data. Very few reasons for just
115:34 - logging it out. Want to keep it in a variable,
just like we've done here, with the house
115:39 - blackjack, and it's alive. So your three part
challenge is to first declare a variable called
115:45 - message, and then assign its value to an empty
string. And then you are going to reassign
115:50 - the message variable to the string, we're
logging out, notice here and I'm using some
115:54 - fancy words like I'm seeing the clear instead
of creative variable, I'm seeing a sign instead
116:00 - of set its value. That's because I think you
now we're ready to hear some of these fancy
116:03 - JavaScript words. Because there are subtle
differences between these words, like here,
116:07 - we are actually declaring the variable. And
then we are assigning it when we set the value
116:13 - to true. This is, after all call to the assignment
operator in JavaScript, and then naturally,
116:19 - so when we change a variable or assign it
yet, again, we re assign it. So I just want
116:26 - to use the correct terminology here. But I
think it's important that you don't get put
116:31 - off by all of these words, and think that
you have to remember them all you do not,
116:35 - it's perfectly fine to talk about this, using
your own words, create change, set the value,
116:41 - whatever, I just want you to also be exposed
to these technically correct ways of expressing
116:46 - it. Anyway, enough talk, as I said, step two,
you are going to reassign the message variable
116:52 - to the string that we're logging out. So I
don't want any more console logs inside of
116:57 - these three code blocks. Because the only
code block is the one you're going to create
117:02 - in part three of the challenge when you are
going to log out the message variable. So
117:06 - go ahead and give this your best shot and
then return back to this screencast when you
117:10 - want to see my solution.
117:14 - Okay, hopefully that went well. If not, no
worries, let's do this together. First, we'll
117:22 - start by declaring this let variable, we'll
call it message. And we'll set it to an empty
117:28 - string. Then on line 1113, and 16, we need
to replace the console. log with a message
117:36 - equals like that, and also remove this, close
parentheses, do the same thing here, move
117:41 - this one, and the close parentheses and then
write message equals, finally, here as well.
117:49 - And then we are ready to log it out. Down
here at line 21. While log out the message,
117:55 - run the code. And as you can see, we're logging
you are out of the game. That is correct,
118:00 - because we have this really stupid move where
we got blackjack, but we asked for new card
118:04 - to remove this, run the code. Yes, you have
blackjack, again with for example, 14. And
118:11 - yes, I can now grow a new card. So great job
reaching this far. Let's move on. Okay, now
118:22 - it's time to fix our biggest flaw in our blackjack
game, which is that it has no user interface.
118:27 - If we want this to be a hugely successful
online blackjack game, it has to use HTML
118:32 - and CSS so that users can play it via a browser.
And I've actually set up the basics for you.
118:38 - Here, you can see an HTML file with a head
and a body. And then inside of the body, we
118:44 - have an h1 with text blackshark. And also,
we are linking to the JavaScript file here
118:48 - on line eight. And as you can see, if we bring
up the mini browser, this just renders out
118:53 - the h1 tag. So your job now is to link this
HTML file to the CSS file. You can see I've
119:01 - created just one CSS rule in this file. And
it will be applied, changing the color of
119:06 - the title when you manage to add a link to
the CSS file here on line five. So I almost
119:13 - every single time have to search on Google
for how to link to CSS from HTML, I end up
119:18 - at something like this. So I want you to do
the same thing. And one tip would be to find
119:23 - this w three schools right here, as they often
pop up on Google and contain the necessary
119:28 - information. So go ahead and figure this out
on your own, and then I will show you the
119:32 - solution afterwards as well. Okay, hopefully,
you nailed that one. If not, no worries, let's
119:42 - first check out Google. Then if we click into
the W three school site, you'll see the following.
119:49 - And it tells us that there are three ways
to insert CSS external, internal and inline.
119:53 - And we are using an external CSS file. So
we want to scroll down to external CSS. If
119:59 - we do that, we see The code here and the line
we're looking for is this one, Link REL equals
120:03 - stylesheet href equals my style dot CSS. Okay,
good. Let's do link rel, and that is short
120:12 - for it relation. So what is the relation between
this HTML file and the current file, you're
120:18 - going to point two now while it is that the
file you are pointing to, say stylesheet,
120:22 - because as you remember, CSS is short for
Cascading Style Sheets. And then it is the
120:27 - href, which in our case is index dot CSS,
we are in the same directory. So we don't
120:34 - need to navigate into a folder or anything
like that will just write index dot CSS. And
120:39 - the href attribute is something you should
be familiar with by now as that's also what
120:43 - we use when we are creating links. Now let's
run this code boom, you can see the color
120:48 - has changed, meaning we are indeed importing
this stylesheet. Great. Okay, now it's time
120:58 - for you to style this app. Because as you
can see, it looks kind of bad. I've added
121:03 - a few more paragraphs here, as you can see
one, which says want to play around and has
121:07 - an ID of message shell, and then just two
other paragraphs that will display the cards
121:12 - and some eventually, your job now is to take
this HTML and make it look like this. If we
121:18 - head into the index dot CSS file, you can
see it says complete the CSS styling according
121:23 - to the provided the sign in here I've created
two new selectors for you the body and the
121:28 - message. Oh, and the thing is, you can create
this entire design by only using these two
121:34 - selectors. So that's why I have them here
for you. I've also added a table dot png,
121:39 - inside of an images folder. That is for the
zero background that we are using here. And
121:45 - you've learned all about how to do this styling
in previous modules of the career path. So
121:49 - if you struggle, you can go back and rewatch
some of those lectures if you want. Now, before
121:53 - you start solving this challenge, I'm going
to add the font family for you. Because we're
121:58 - using the treble Shea font here. And you haven't
really learned how to do that. So I'm going
122:02 - to do it for you. We do font family up in
the body. And here I specify treble Shea.
122:09 - And as you noticed, what happened now was
that the editor
122:12 - gave me a bunch of other fonts as well. And
this is called a font stack. And the reason
122:17 - we use font stacks, because if your operating
system doesn't have treble Shea ms installed,
122:23 - well, then your browser can't show that font,
unless you've also imported it from Google
122:28 - fonts, for example, or included in your project,
neither of which we have done right now. So
122:33 - if your operating system can show Trevor Shea
ms, then we're telling it to look for new
122:38 - CSS Unicode, then, if you don't have that,
either, we'll look for Lucy around they and
122:42 - so on, and so on. So it's kind of ensures
that at least we'll find a somewhat similar
122:47 - file as it moves downwards in the stack. And
at least find a sans serif font here, which
122:52 - is our final choice. But let's start with
fonts there, I don't want to get deeper into
122:56 - it. Now we have the crib sheet font visible
and hopefully it's visible on your end as
123:01 - well, because crochet is one of those fonts
that are so called web safe, meaning that
123:06 - almost all operating systems have them installed,
so it's safe to use. Now, I want you to take
123:12 - a look at this design and add whatever CSS
you need to the body and the message shell
123:18 - so that you turn this boring page into what
looks much more like a real blackjack game
123:23 - to go ahead and do this right now. Okay, hopefully
that went well. I'm gonna start with the background
123:33 - image. So I'm gonna write a background image,
then fetch this table up PNG here, I can do
123:39 - URL open and close parentheses, then navigate
into the images folder, grab ahold of the
123:45 - table dot png, like that. Now we can see we
have the nice background. However, if I drag
123:52 - this wide, I can see that some point we reached
the end of the image and CSS adds the image
123:58 - yet again, after that, we get this ugly looking
line we should don't want, we instead want
124:03 - to use the background size property and set
that to cover. Now no matter how wide you
124:09 - make it, these image still covers the full
width. Okay, next step is to center this text
124:16 - and make it white. So we can do text align
center to center everything and polar white
124:26 - like that. So with this, we are turning everything
into right, except for the atrium, which you
124:33 - can see it here we have specifically specified
that the atrium should be colored goldenrod
124:39 - and that overwrites the color right on the
body element. Next up, you see here the text
124:46 - is a bit bolder, so we want to do that as
well. We want to do font, weight, bold like
124:51 - that.
124:53 - Starting to look good.
124:55 - There's just one final thing to start you
can see the message element which is The message
125:00 - for the user is an italic. Here, it's still
just normal. So in the message l will do font
125:07 - style and set back to italic. Like that. There
we have a nice looking blackjack game. So
125:14 - with that, let's move on. Okay, so now we
need to enable our user to click a button
125:23 - to play the game. And we're going to do this
through a challenge. Of course, I'm really
125:28 - excited about this one, because it includes
both HTML, CSS, and JavaScript. So this is
125:34 - the first time where you'll use all three
languages to solve a problem. And the reason
125:40 - this is so cool, is because this is how it
works. In real life, when you get a job as
125:43 - a professional developer, you'll juggle between
HTML, CSS, and JavaScript all the time. And
125:49 - this is an opportunity to start practicing
exactly that. So it's a three part challenge,
125:55 - starting here in the HTML, where you are going
to create a button that says start game, and
126:01 - it should call a start game function when
it's clicked. So obviously, then you also
126:06 - need to create that start game function, you'll
do that in the index dot j s. Here we are
126:11 - to create the start getting friction, and
move the conditional below line 11 to 20 knots,
126:18 - these lines into the body of the function
so that this code is run when the button is
126:24 - clicked. And then finally, you have to make
the button look good for the user, you are
126:29 - going to style it according to the provided
design. And that is exactly here, you can
126:34 - see the Start button. So just click to open
this slide whenever you need to take another
126:38 - look at it. I'm doing this translating a design
into CSS is something the front end developers
126:44 - do every single day. So it's great practice,
I've given you three values for properties
126:49 - here is the color of the text that should
have this hex value, the width should be 150
126:55 - pixels, and the background should be golden
Rob, same as the text color on the A Tron.
127:01 - This is a big one. So I can totally understand
if you'll struggle a bit going through this
127:05 - one, but give it your best shot, and then
return to this screencast when you want to
127:09 - see my solution. Good luck. Okay, hopefully
that went well. Now, let's do this. Here,
127:21 - we'll do like up opening tag, and then I'll
do the closing tag as well. And inside All
127:28 - right, start game like that. Let's run the
colon looks not particularly good, but it's
127:35 - at least there and it's actually centered.
The reason for that is because here on the
127:40 - body, we are centering all of our texts, and
that also centers the button. Next up, we
127:47 - need to call the start game function when
it's clicked. And if you remember how that
127:52 - was, then you'd write on click equals, and
then the start game with open close parentheses
128:00 - inside of a screen right here. So when the
button is clicked, we're going to call or
128:03 - invoke the start game function, then we need
to create that function. And if you remember
128:09 - how to do that, it is through the function
keyword function, start game, open and close
128:15 - parentheses and then curly brackets for the
body on the function. Inside of here, we are
128:21 - going to take this code, copy it, paste it
in, I'm going to give it a tab so that it
128:26 - looks better like that, and remove the empty
lines. Now we have this let's rerun the code
128:33 - and see if it works. Yes. Previously, we got
this console log just by refreshing the page.
128:39 - But that doesn't happen. Now I have to actually
click the Start game. Then we run this then
128:45 - we console out the message. Great job. Now
let's move on to the CSS. Okay, this is how
128:50 - we want it to look. Let's take the first three
provided the sign hints and see how close
128:55 - we get just by implementing them. next color.
Notice the color property that hardly see
129:04 - it since the text is so thin, but that's okay.
For now. Let's just set the width with 150
129:10 - pixels like that. Okay, looks a little bit
better. And the background should be golden
129:18 - Rob. Okay, so looking a little bit better.
Not quite this design here. As you can see,
129:25 - it has some space above and below the text,
versus this one is much more cramped. Let's
129:31 - add that. And if you remember from the CSS
section, you could add that space by using
129:35 - the padding. That's padding top and padding
bottom. Five pixels. looks about right. padding.
129:45 - Five pixels there as well. Yeah, not too bad.
However, as I mentioned, this text is really
129:51 - thin. And here it's much thicker. So let's
actually do font weight. bold. Yes. About
130:00 - looks much better. Now, the next thing I want
to fix is the border around the button. Because
130:06 - you can see it's totally clean here and has
no border. But the default styling that our
130:11 - browser provides has this little border. So
we want to do border, none. Okay? Now it's
130:18 - actually pretty similar or almost identical,
but only one thing separates them. And that
130:24 - is that you can see the edges are sharp on
this one, where's the edges are a bit rounder
130:30 - on our provided the site. So that is the border,
radius. And pretty subtle. So I'm going to
130:39 - try to pixels. And yes, that looks as far
as I can see, identical. So this was a huge
130:46 - challenge. And you had to context switch between
HTML, CSS, and JavaScript. So be really proud
130:52 - of yourself for reaching this far. If you
struggled, and didn't really manage to get
130:56 - to the finish line on your own, I think you
should just go back and try it again. Now
131:01 - that you've seen my solution, that's a great
thing to do to reinforce what you've just
131:05 - learned, whatever you do, I will see you in
the next lesson.
131:09 - Okay, so now our player can click the Start
game button like this. However, we're only
131:18 - logging out the message. Obviously, we don't
want to do that, we want to display that info
131:23 - on the page, along with, of course, information
about the cards and the sum. But starting
131:28 - with the message, I want you to solve a two
part challenge. First, you are going to store
131:33 - the message l paragraph, that is this one
right here in a variable called message l
131:41 - using the camel case naming convention. And
then you're going to display the message using
131:47 - message l dot txt content, then, of course,
you can remove the console log right here,
131:52 - since we don't need it anymore, as the message
will pop up here in our app instead. So go
131:57 - ahead and give this a shot and return back
to me when you want to see my solution.
132:04 - Okay, so the way to do this is, if you remember,
first by creating a variable with length message,
132:14 - l, and then using the document keyword, dot
get element by I Li passing in the ID, which
132:23 - we can see from the HTML and just copy from
there actually paste them in here. That's
132:31 - always Ctrl logging to see that we are on
the right track running this code. And yes,
132:38 - there we can see we are logging out to that
element. Now it's just a matter of deleting
132:43 - this line being messaged l dot text content.
And what we want to set the text content to.
132:52 - We want to set it to message like that. If
we now run the code, hit the start game button.
132:58 - Yes, there we go. Do you want to draw a new
card? Great job. Now there's one thing I want
133:03 - to do before we round off, that is actually
to remove these emojis because when they are
133:08 - italicized, they don't look that good. And
while that isn't the most complicated thing
133:13 - to fix, it's not something I think you should
learn. Right now, I want to keep up the pace.
133:17 - And also when we see this text here rendered
on the page. It's kind of our dealer speaking
133:21 - to us in metallic text. And I don't think
our dealer should show that much emotion.
133:26 - So it makes sense to remove these modules
like this. And also maybe make it a bit more
133:31 - neutral dealers will just tell us that we
have blackjack on shout out. Whoo. So makes
133:37 - more sense on your card. Yeah, looks good.
If we get blackjack. Yeah, I think that looks
133:42 - good. So with that, let's move on. Okay, so
let's make our game a little bit more useful,
133:52 - because now you can click the Start game button.
And indeed, we get the message from the dealer.
133:56 - But we have no idea what are some cards are,
so we obviously need to render that out. And
134:01 - we're going to start with the some though
it's a three part challenge where you first
134:05 - have to head into the HTML. And there give
the some paragraph that is this one, an ID
134:12 - of some dash L, then you are to store the
sum paragraph in a variable called sum l like
134:18 - this in camel case, finally render the sum
out. So here I'm talking about the actual
134:24 - numeric sum on the page using this format,
so some colon and then the given some you
134:31 - have up here. So here you have to keep this
text which is already in the DOM intact, but
134:39 - we have done that before. So hopefully you'll
manage it. If not, no worries, you can just
134:43 - revert back to this screencast and I will
show you how to do it as well. Go ahead and
134:48 - give this your best shot right now. Okay,
let's do this. First, we'll give this an ID
134:59 - of Some bash L, moving over to the JavaScript
will do let some l with the camel case this
135:08 - time, do document, get element by ID open
and close parentheses and the quotes passing
135:17 - in the ID that we just added to the HTML element,
some bash L. Now, just to be certain, let's
135:24 - just console log the sum L, from the code.
Yes, indeed, we are grabbing the element.
135:32 - And then we need to render out the string
of some, and then the actual sum, which in
135:38 - this case is 14, from this variable up here,
into the element itself. And the way I'll
135:45 - do that is I'll use some L, and then text
content, which you should see in a few times
135:51 - by now, and set that equal true, not only
the sum, because if we do that, let's rerun
135:58 - the code and stop the game, then we simply
just clear out the existing text verse, we
136:03 - want to keep the sum there. And we can do
that in multiple ways. But we all do it is
136:08 - simply just write some colon space, and then
plus here. So let me just reconstruct
136:15 - the default text as well, in addition to the
sum, I think this is a nice way of doing it.
136:21 - If we run the code, stop the game. Yes, there
we go. Now, before we move on, I want to teach
136:27 - you about a another way of grabbing elements
from the DOM. Because we've used to get element
136:33 - by ID a few times now. So I'm assuming you're
comfortable with this technique, and are ready
136:37 - to learn another one. And that is something
called the query selector. And to learn that,
136:43 - but comment out this one, and copy it to a
new line where we can change it. And here,
136:50 - instead of get element by ID, we'll do a query
selector like that. Since this is a more dynamic
136:58 - method, we have to be a bit more specific
in the value we pass into it. So here, we
137:03 - actually have to pass in a hashtag in front
of the summer to tell the query selector,
137:08 - that it's actually the element with the ID
of some URL that we're looking for. Because
137:14 - unlike the get element by ID, we're not specifying
that it's an ID. In the method name, it's
137:20 - just called query selector, which is kind
of a broader expression. So query, that's
137:25 - another word for question. And selector that
refers to CSS selectors. So we're kind of
137:31 - asking for an element by its selector. And
then we specify the given selector inside
137:37 - of the parentheses. So here, if we run this
start gate, the exact same thing happens.
137:43 - Now if you've forgotten what a CSS selector
is, we can head over to the CSS, and it's
137:48 - these guys right here, the body, that's just
selecting the body element, this one. And
137:55 - then there's the id selector right here, you
can see we are using the hashtag, grab the
138:00 - message L, because this paragraph has an ID
of message dash L. Likewise, some has an ID
138:08 - as well. So we're using the hashtag, to tell
query selector that this sum dash l comes
138:14 - in the form of an ID. Now, this means that
we could change this to a class instead. However,
138:24 - then we also have to change this hashtag and
replace it with a dot. Hopefully, you remember
138:28 - that the way to select CSS classes is by using
the.we. Run this, it still works. And actually,
138:36 - we could even pass in just the element name
as well, we could do body right here. However,
138:42 - it would break our hop since we're now Okay,
just clearing out the entire body when we
138:50 - are running this piece of code down here on
line 11, because now somehow actually refers
138:55 - to this entire body. So as you probably understand
queries lecture is very powerful. And you
139:02 - will see it used in a lot of tutorials here
on schema master right now, I just wanted
139:07 - to show it to you so that you are prepared
once you see it in other tutorials and out
139:11 - in the wild. In the near future, I am going
to stick with the document dot get element
139:18 - by ID as not just a job for us. And it's also
a very simple method to understand. So I'd
139:24 - like to avoid the added complexity of jumping
between get element by ID and query selector
139:29 - if we can. Without let's just move on. Okay,
let's continue building that muscle memory
139:39 - of yours you are going to do almost the exact
same thing as you did with the sum. But this
139:44 - time with the cards because obviously when
you start the game you can see or some now
139:48 - but you can't see your cards that has to be
fixed. So it's the same three part challenge
139:53 - starting in the HTML where you are to give
the cards paragraph, an ID of card cell, then
139:58 - in the JavaScript, you are stored the cards
paragraph in a variable called card cell with
140:03 - camel case, and then finally rendered out
in this format right here. So go ahead and
140:09 - do this right now. And then I will show you
how I will do it when you revert back to the
140:13 - screencast as well. Okay, let's do this first,
giving this an ID of
140:26 - cartel.
140:27 - Then storing the card paragraph in a variable
called also cartel, let cards l in camel case,
140:35 - this time, document dot get element by ID,
passing in cards, bash shell like that. Now,
140:45 - I'm just going to jump straight to this line
here and do cards l dot text content equals
140:53 - constructing the entire contents of the paragraph
this time, so we're clearing out the text
140:58 - that's already there and replacing it with
a new cards column. This will be actually
141:05 - cleared out and replaced using JavaScript,
then plus the first card and then have to
141:12 - add a space between the first card and the
second card. And then the second card like
141:19 - that. If I run this code, start the game.
And there we go, we have both of the cards
141:25 - rendered out. Great job. Let's move on. So
our game really starts taking shape. Now we
141:36 - hit the start game button, and we get the
message the cards in the sun. However, the
141:40 - critical part of blackjack is the ability
to draw a new card from the deck. So we need
141:44 - to start building that feature. And we are
going to first begin with creating the new
141:49 - card button, as you can see on the slide here.
So in this three part challenge, you are going
141:53 - to first head into the HTML and create that
new card button, then make it run a new card
141:59 - function when it's clicked, and then in the
JavaScript, you have to create that new card
142:04 - function. And for now, it should just log
out drawing a new card from the deck. Then
142:10 - in the CSS, you need to make sure that when
these two buttons are rendered out vertically,
142:16 - like this, so above each other, you'll need
to make sure that this small space between
142:21 - them is added because it won't be added by
default. Now, if you enlarge this browser,
142:26 - make it wider, they will render out besides
each other. But you are not to worry about
142:30 - that layout. So make sure that you keep this
browser window a little bit narrow so that
142:35 - the are rendered out under each other. And
then make sure that you get this little gap
142:40 - here. So this is again, a very holistic challenge.
You're to write JavaScript, HTML, and CSS
142:48 - just like it is out in the real world. So
go ahead and give this your best shot right
142:53 - now. Okay,
142:59 - hopefully that went well. If not, no worries,
let's do this together. In the HTML, we are
143:06 - starting with the button opening closing tag,
new card like that, I'll just render it out.
143:14 - Oh, there we got it actually got them beside
each other, we want them vertically
143:19 - like this. So there, we can already see that
we are missing in the gap, but that we want
143:24 - it. That's the CSS or the challenge. Let's
continue on with the HTML and get that wrapped
143:29 - up. We'll do on click equals and then run
this new card function which we haven't created
143:37 - yet, which we are going to create right now
down here. function, new card open and close
143:44 - parentheses. And then the curly brackets for
the body of the function inside here, logging
143:49 - out this string got provided in the comment
like that, I will run this code hit new card.
143:57 - And indeed, we are logging it out. Now final
step is to add this gap right here, we need
144:03 - to head into the CSS. And there are multiple
ways to do this. One way is to just say that
144:09 - we want any button to have a little bit of
margin below them. So this is about four pixels.
144:14 - So we can do
144:17 - margin bottom four pixels like that there
we see that our button works. Alternatively,
144:25 - let's say that we in some case, end up with
a situation where something comes too close
144:28 - to the button on the top side of it. Well,
maybe we need some margin on top of it as
144:33 - well. We find now add margin bottom and margin
top four pixels here, margin top four pixels,
144:40 - what you'll see is that the gap here became
twice as wide because it has the top margin
144:45 - that pushes it down, and also the start game
button that uses its margin bottom to get
144:49 - the gap even larger. So what we then instead
can do is take two pixels on each now we have
144:58 - something that looks very much like this.
We have created our buttons so that they always
145:02 - have some space below and above themselves.
I think that makes a lot of sense as buttons
145:07 - usually want a little bit of space around
them. With that, let's move on.
145:14 - Okay, let's make our new card function a bit
more useful, because now it's just rendering
145:21 - out the string for people wanting to do is
to actually draw a new card, and then add
145:27 - that new card to the sum, and then rerun the
code that is inside of the start game function
145:33 - so that the sum is added to the page. And
actually later down the line, we also want
145:37 - to show the new part of course, but as for
now, we're just going to worry about the sum.
145:42 - So this is a three part challenge where you
are to first create a card variable. And we're
145:48 - still just working with hard coded card variables,
you're just going to coat it to a number between
145:53 - two and 11, then we are going to add this
new card to the sum variable. And the sum
145:59 - variable as the one up here, of course, which
currently is the first card plus the second
146:03 - card. And in this case, it will be plus the
third card as well as you need to plus equal
146:09 - the sum variable. And then finally, you are
going to just call the start game function.
146:14 - Because what does the start game function
actually do? Well, first, it renders out the
146:19 - two cards. In our case, now we'll have added
the third card. So this will still be wrong.
146:25 - But line 13 will render out actually the new
sum, because at this point, some will have
146:30 - changed since we will have modified it down
here. And then it'll show the message based
146:36 - upon the new updated some. Actually, it seems
that we can use this start game function even
146:41 - after we've drawn a new card. And thus, we're
going to rename it a bit later. But for now,
146:46 - let's just keep it how it is. and your job
is just to call the start game function here
146:49 - on line 33. So go ahead and give this challenge
your best shot. And then I will show you the
146:55 - solution as well afterwards. Okay, let's do
this. So, let card here we'll set that to
147:07 - a random number between two and 11. I'll do
seven, and then we're going to add the new
147:11 - card to the sum variable. If you remember
how we add numbers to an existing variable,
147:16 - it's via the plus equal operator. So we'll
do some plus equal card, and then we'll call
147:21 - start in. So again, like that, let's rerun
the code first to start game. Okay, do you
147:29 - want to draw a new card, I happen to want
to do that. So I'll hit new card, and boom,
147:32 - I drew the seven card, which then made the
sum reach 21, which then again, made our dealer
147:37 - tell us that we got blackjack. So that is
exactly what we want. Now, let's see what
147:42 - happens if we instead of a seven, got an eight.
For now, rerun the entire code, start game
147:48 - and then hit new card, bam, then we're out
of the game since we have some equals 22.
147:54 - And if we got a six instead, rerun the code
start game your card, then we still get the
147:59 - Do you want to draw a new card text since
we're still below 21. Now I can actually hit
148:04 - the new card yet again. And then we are out
of the game. Now we're at 26. So this works
148:09 - for multiple cards. Of course, it's only the
sum that's reflected right now, not the card.
148:14 - So we'll have to fix that in a bit. But for
now, let's just move on and first fix this
148:18 - little problem. That's the start game function
name doesn't really make sense anymore. Since
148:24 - we're calling start game here at a point where
the game has already started so semantically,
148:29 - it doesn't really add up. So let's move on
to the next cast. So the problem now is that
148:39 - the start game function is triggered both
when we hit the start game button, which makes
148:43 - a lot of sense, but also when we click the
new card button, because even though the new
148:50 - card button triggers the new card function,
which is this one right here, that function
148:56 - itself calls start game as well. And while
this makes sense, because we want to run this
149:02 - code, the fact that start game still is called
start game doesn't really make sense. Because
149:07 - if another developer comes in here and looks
at that code, he'll be like, Why are restarting
149:12 - the game all over again, when clicking a new
card that doesn't semantically add up. So
149:17 - what we want to do here is actually just change
the name of the start game function, for example,
149:23 - to render game, because that's essentially
what we're doing, we're rendering out the
149:27 - current state of the game. So we can do render
game, just rename this one. And this one does
149:33 - that. So far, so good. But then the problem
becomes that we're actually calling start
149:38 - game here. And we could do a render game like
this. But actually, I want to keep this stock
149:44 - game function intact. Because down the line,
there might be some other things you want
149:48 - to do in this game initialization function.
So I want you now to create a function that
149:54 - uses the name, start game and then just calls
or invokes render game. That's all it should
149:59 - To show that this start game button will work,
because now I can see it doesn't work. When
150:05 - I click it, we're actually getting a reference
error saying that start game is not defined,
150:10 - because we're trying to call a function that
no longer exists. So go ahead and create the
150:15 - start game function here on line 12. And make
it just call this render game function right
150:20 - here, go ahead
150:21 - and do this right now. Okay, hopefully that
went well, the way to do it is through function,
150:32 - and then start game, open and close parentheses,
open close curly brackets, and inside here
150:39 - just called render game like that. let's rerun
the project, hit start game, and yes, now
150:46 - it works again. Great job. Okay, so now we
need to fix up with the rendering of the carts.
150:56 - Because if I hit start game, and I get the
two cards out and then hit new card, indeed
151:00 - are some increases, but our cards paragraph
are displaying only two of the three cards
151:05 - we've pulled from the deck, because we have
a 10 and a four, and a six, whereas we're
151:10 - only showing the 10 and the four in the browser,
because that is hard coded here to only do
151:16 - that, no matter how many cards we pulled from
the back, this line 16 will always just render
151:22 - out the first card and the second card. So
this line here in pseudocode says render out
151:29 - first card and second card. But what we instead
need is something that says render out all
151:38 - the cards we have, regardless of how many
cards if we have five cards to render out
151:44 - five cards, if we have two cards that should
render out two cards. But that's not possible
151:48 - with the current implementation. And what
we need is a central way of storing all of
151:53 - our cards, we need to store all of our cards
in one variable, regardless of how many cards
151:58 - it is. And the way to do this is actually
to use what's called an array, which is essentially
152:03 - a list of items. And I'm going to create an
array here, and it's totally okay, if you
152:09 - now feel confused, I just want to give you
a little sneak peek at it, before we take
152:13 - a deep dive and give you some practice on
it. I'm gonna do let cards equals and then
152:18 - open and close square brackets. That's the
notation for creating a race and inside of
152:23 - these square brackets, I'm going to paste
the first card, and then a comma, and then
152:29 - the second card. So this is now a cards array
that includes both cards ordered by the first
152:35 - card first and the second card Second, you
can call this an ordered list of items. Now
152:43 - we're down at what's line 18 now and replace
the first card by referring to the array instead.
152:51 - And doing open and close square bracket and
zero. Don't worry about that you understand
152:57 - that in a minute. Let's just now do the same
things for the second card will be cards open
153:02 - and closed square brackets, and one. This
is referring to this one right here. And one
153:11 - is referring to this item right here. And
that is because arrays are so called zero
153:17 - indexed, they start at zero and one. And if
we add a third card here, that would be index
153:24 - number two, but we don't have a third card.
So let's remove that. Now even though you
153:30 - might feel a little bit confused, now let's
just run the code, hit the start game and
153:35 - see yes, that still works. So this way of
doing it was the exact same as what we had
153:40 - previously, when you just hard coded in first
card and second card like this. Now this opens
153:44 - the possibility later down the line to render
out all of our cards in a dynamic way inside
153:51 - of the cards element regardless of how many
cards we have inside of our carts array. So
153:56 - almost a lot of information. Now we're going
to take a step back, work with race, get your
154:01 - hands dirty, so don't worry, if you didn't
quite understand this as you will surely do
154:06 - that after the next few lessons.
154:10 - Okay, so arrays are ordered lists of items.
However, that's a little bit abstract. So
154:19 - let's instead look at a real world product
and see if we can recognize any components
154:24 - that most likely use a race as a data structure.
So here we have a LinkedIn profile. This is
154:30 - Justin, he's a previous scribus student. And
looking at this, there's immediately multiple
154:35 - components that most likely use arrays to
render stuff out. You can see here on the
154:40 - right hand side, there are some promotions
actually three of them, and that's basically
154:44 - a list of items. And while their order might
be a little bit random, they still have a
154:49 - specific order. Likewise, with the people
also viewed here, that's a list of four people.
154:55 - Let's also scroll a bit down. Here we can
see even in the main section There's this
155:00 - component that says featured that is featured
posts. And that's basically just a list of
155:05 - items. So LinkedIn probably uses an array
to describe this data in JavaScript. So actually,
155:12 - let's just create that array, let featured
posts like that then equals opening closed
155:20 - brackets. The first one was actually just
in sharing the Netflix clone he built through
155:26 - a course here on scramble, and he actually
deployed it as well. So he's going above and
155:29 - beyond to check out my Netflix, clone like
that. The second one is actually a link just
155:37 - in the shared to source code, he's pushed
to GitHub, which is also a great thing to
155:41 - do, if you want to attract employers. So here's
code for my projects. Simplifying, of course,
155:52 - the data here because there are multiple parks
have this there's an image, there's text,
155:57 - there's comments, and so forth. But as for
now, we're just simplifying it into streets.
156:01 - The third item here is actually just in sharing
the portfolio he has built through a scrim,
156:05 - of course as well. So I've relaunched my portfolio
like that, there, we have an array with three
156:14 - items. This line is pretty long. So sometimes
you'll see an array formatted like this, as
156:21 - it makes it easier to see that it is indeed
three items. And a key thing to observe here
156:26 - is that we add commas after the items, but
not after the final item. So only between
156:33 - items, basically. So going back to LinkedIn,
there are tons of components here, that's
156:39 - probably utilizes a race, for example, the
work experience as a list of previous jobs,
156:46 - or licenses and certifications. So that's
a list of licenses, you can see the front
156:50 - end path right here, and skills and endorsements.
So a ton of examples. Now what I want you
156:56 - to do is to create an array that lists your
experience, or education, or licenses or skills,
157:04 - or something similar you are to choose what
you want this array to contain. But try to
157:08 - think how can you best describe your either
experience education skills, or whatever in
157:13 - a way that would make your LinkedIn profile
look tempting for recruiters as that's a smart
157:19 - thing to think a little bit about already,
even though you're very early in your coding
157:23 - journey. So go ahead and do that. And remember
that the items should just be strings, just
157:28 - as I've done up here,
157:30 - go ahead and do this right now. Okay, hopefully,
that went well. Now, I'm going to do that
157:39 - as well. So I'll do let and then experience.
157:41 - That's what I want to create my array about
my work experience. And I'm currently the
157:46 - CEO app scrim ba. Before that, I was a front
end developer at sometta. That's a Oslo based
157:55 - company for seafreight analytics. And also,
as you probably remember, from our subway
157:59 - counter app, I worked as a people counter
out in the cold, a company called Knorr stock.
158:06 - So that is my experience. Now, before you
move on to the next cast, I want to highlight
158:12 - the importance of actually being able to describe
your background and your skills in a good
158:17 - way on LinkedIn, just in here, the person
behind the LinkedIn profile we looked at,
158:21 - he actually lost his job in the petroleum
industry due to the coronavirus pandemic.
158:26 - And less than one year later, he now works
as a professional software developer. And
158:30 - as I said, he did that mostly through scrim
Ba, and was a super engaged student at our
158:35 - discord channel. And what's so cool about
how he did it is that he sent out over 100
158:40 - job applications without getting much luck,
then went into optimizing his LinkedIn. And
158:46 - then suddenly, he got two job offers. And
the job he got actually came through a recruiter
158:52 - that found his LinkedIn profile as a result
of keyword searches. Actually, he ended up
158:58 - tweaking his LinkedIn profile so that he attracted
the right recruiter who got him an amazing
159:03 - job as a developer. So I wanted to share this
with you. And if you click on this image,
159:09 - you'll be taken to the page for the podcast
interview with did with Justin, so that you
159:14 - can listen to his story if you want to. For
example, when you're riding the bus or out
159:18 - walking or cleaning or whatever, I don't want
you to interrupt the course and listen to
159:22 - this. Instead of coding. It's more important
that you code. But you can keep it in mind
159:27 - for next time that you have half an hour or
something. Because I think you'll learn a
159:30 - ton about Justin who at the age of 33 did
his career shift. So with that little plug
159:36 - out of the way less
159:42 - important thing to know about race is that
they are so called zero indexed. And that
159:48 - means that you want to grab the first item
of the array, you do it through using the
159:53 - zero index, not the first index. And let me
show you what that means in practice beats
159:59 - posts. That's our rate. And I want to grab
the first item, the checkout mine Netflix
160:06 - clone. I'll do that through open and close
square brackets, and then passing in the number
160:11 - zero right now console, log this. And we run
the code, you can see yes, that we are indeed
160:17 - logging out that string. So this isn't entirely
intuitive since we as humans normally start
160:23 - counting at one. But in the race, you start
counting at zero. So if this is the zeroeth
160:30 - index, which index does this item have? Take
a guess? Well, it has the index of two, even
160:39 - though it is the third item, I run the code.
Now see that passing into logs out, I've just
160:46 - relaunched my portfolio. So here is the zero
index. This is the first and here is the second.
160:54 - Now, with this in mind, I want you to practice
this. So you are to take my experience array
161:00 - here and log out the following to the console.
And in this order. So we are to start with
161:07 - the front end developer in this net, and then
the people counter and then CEO, what scramble.
161:12 - So first, this one, then this one, and then
the first one. So you have to write three
161:17 - console logs, and place them in order here,
starting from line 18. So that I'm sure that
161:24 - you actually understand the concept of a race
being zero index, I'm going to comment out
161:29 - this one right here, so it doesn't disturb
you. Now go ahead and solve this challenge.
161:34 - Okay, hopefully, that went well. Let's do
this together. We're going to do console log,
161:46 - I want the front end developer at sonet. Ah,
that is not the first but the second item.
161:53 - And in terms of indexes, it's the zeros and
then the first index, so then I need to do
161:58 - variance. Okay, copy this one, paste it in
again. Now I'm going to log out the third
162:06 - item, which is the second index. So that is
experience. And finally, I'm going to log
162:13 - out this item right here that has the index
of zero. If I run this code, you can see in
162:19 - the console that we are indeed logging out
the items in this order. Now, before we move
162:25 - on, I'm going to confuse you a little bit.
Because let's actually delete all of this,
162:31 - this, remove the console and just go back
to this featured posts. If I now do featured
162:38 - posts, dot length, then console dot log this
out, which number do you think we'll see printed
162:47 - to the console? Take a guess? Well, the answer
is three. And that might be a little bit confusing,
162:54 - because I've just taught you that arrays are
zero index. So the first is zero, the second
162:59 - is 1/3 is two. So it would be natural to believe
that the dot length property of this feature
163:05 - posts is two because the final index is two.
But whereas indexes are zero indexed, the
163:13 - length is not zero indexed, we count the length
of an array in just the same way you would
163:19 - count anything in life, which is starting
at the number one. So that also means that
163:24 - the length property of an array is always
one larger than the final index. So this is
163:30 - one of those things that are a little bit
unintuitive and confusing when learning JavaScript.
163:35 - And you probably will mix it up a couple of
times. That's not a problem, just trust me
163:39 - when I say that, eventually, this will become
second nature for you. So let's move on. Okay,
163:51 - up until now, or erase have either included
only strings, or only numbers, whatever, they're
163:59 - not limited to that actually put any data
type you want into an array, and you can mix
164:04 - as much as you want. So you can think of an
erase as kind of a composition of multiple
164:09 - data types and their values. So this is why
arrays are what we call a composite data type.
164:15 - You can say it's composed by its items if
you needed to make semantically sense.
164:20 - And you'll often hear this also referred to
as complex data types, that is erase and also
164:25 - for example, objects, which you're going to
learn about later. They stand in contrast
164:30 - to the primitive data types you have worked
with, up until now. The three primitives you
164:36 - have learned are strings, numbers, and billions
because they are more primitive than arrays.
164:42 - They're not composed of many other data types,
which are race off an hour. So one analogy
164:47 - you can use is that the primitive data types
are the Lego blocks versus the array, the
164:54 - composite data types. It's kind of like the
full Lego model. For example, after you've
164:58 - built a little house with your Lego blocks.
But anyway, you shouldn't worry too much about
165:03 - this. If you find it a little bit abstract
and complex, as a developer, you don't go
165:07 - around thinking about Oh, is this a primitive
data type or a complex data type, it just
165:12 - becomes second nature and you don't even think
about it. So you shouldn't be put off by this,
165:16 - even though it's a little bit theoretical.
Instead, I think you should just practice,
165:22 - I want you to create an array that describes
yourself and use all the three primitive data
165:27 - types that you've learned so far. So it should
contain your name, which is a string, your
165:31 - age, which is a number, and whether or not
you like pizza, which should be a Boolean.
165:36 - So go ahead and do this right now.
165:39 - Okay, hopefully, that went well. Now, let's
do it together, I'm gonna create an array
165:49 - called pair. And my name is pair, Harold Morgan,
I am 35 years old. And I do happen to like
165:57 - pizza. And I especially like pizza with pineapple.
It's the best though I know that a lot of
166:04 - you don't agree with me. So let's not get
into a discussion about that, let's just move
166:08 - on with the course. One of the most common
operations you'll perform on a race is adding
166:17 - items to the end of it. That's, for example,
what you're going to do in our blackjack game,
166:21 - where you start with two cards, and then you
want to draw a new card that'll naturally
166:26 - then be put at the end of the array, for example,
six. However, the way to do that is not through
166:31 - actually changing it by rapidly, which I did.
Now, you use a method, which is called push,
166:37 - which allows you to well push things into
the array. So you do carts dot push, and then
166:45 - open and close parentheses, and inside of
these parentheses, you place whatever you
166:49 - want to push. So for example, six, if we now
saw log the cards underneath our push operation,
166:58 - you can see we have added six to the array.
So this here is actually called eight method,
167:03 - which is just a fancy way of saying a function
on an object. And you haven't really learned
167:08 - about objects yet. So don't worry about if
you think this sounds a little bit abstract,
167:12 - but this operation here is pretty similar
as the console dot log, and then passing in,
167:18 - for example, hello, do you think we have the
first object cards or console, that we have
167:24 - the methods to either log or push, then we
have whatever we pass into these methods when
167:31 - we call them. So this hair cards push is conceptually
very similar to what you've been doing
167:37 - all along.
167:38 - Let's now make sure that you build muscle
memory on this by solving a challenge. So
167:45 - I want you to imagine that you're building
a chat application, for example, the one I
167:49 - showed you here on LinkedIn, and the data
structure we'll use is, of course, a race.
167:54 - And we'll pretend that each of these messages
is an item in the array. So when someone types
168:00 - in a new message, and since it, well, you
want to push that new message to the array.
168:04 - So here you are to push the new message variable,
that's this one down here, into the messages
168:10 - array. That's this one here. And then you
are to log out the array to just verify that
168:16 - you actually succeeded in pushing the item.
Go ahead and do that right now. And then I
168:21 - will show you the solution afterwards as well.
168:25 - Okay, hopefully, that went well. Now, let's
do this, Lw messages dot push, and inside
168:35 - of the parentheses will pass in a new message
like that referring to the variable and not
168:41 - the hard coded value, which we did up here
when we passed in six. So a little bit different,
168:46 - but still the same concept. Now, let's console
dot log messages, and then run this code.
168:54 - If we bring up the console, we have pushed
the new message to the array, because we're
168:59 - logging out the array with same here at the
end. Now, a little mini challenge before you
169:05 - leave, let's say that you want to regret sending
this message, same here. And you want it to
169:11 - remove it from the messages to rate. How can
you do that? If you haven't learned this yet,
169:18 - this is a golden opportunity for you to google
it out and try to figure out how can you remove
169:23 - the last item in an array? So just see if
you can find the answer on Google and then
169:28 - try to remove the last item of the messages
array here on line 18. Go ahead and do that
169:34 - right now.
169:38 - Okay, maybe that's worked, maybe not, if not,
no worries at all. This is just a bonus. What
169:46 - you do is do messages, dot pop, and then open
and close parentheses. Now. If we log the
169:57 - messages again, and then run the code to open
up the console, you see, we are logging two
170:04 - versions of this array, one from line 15,
where the same hair string is included as
170:11 - the last item. And once again from line 19,
where the array is back to how it originally
170:18 - was like this. So pop is kind of the opposite
of push, and not as commonly used. But I just
170:26 - wanted to give you a sneak peek at it as you
might come across it here and there in your
170:30 - development journey. With that, let's move
on. Okay, now it's time for some repetition,
170:39 - you are going to do the exact same thing as
I did before we had our little arrays deep
170:43 - dive. So you're first going to create a new
array of cards that contain the first card
170:48 - and the second card. And then in the render
game, you are going to change line 18 so that
170:54 - it refers to the cards array when rendering
them out. So not referring to first card and
170:59 - second card this way, but doing it via our
freshly created cards array. So go ahead and
171:05 - do this right now. Okay, let's do this together.
First, we'll do let carts equals opening closed
171:17 - square brackets, and then we'll set the first
card as the first item in the array and the
171:22 - second card as the second item. And as you
hopefully remember, we can now refer to these
171:28 - values by doing cards, zero, cards, one like
that. We'll run the code kickstart game, and
171:36 - yes, indeed it works. Great job. Let's move
on. Now that we have the first card and the
171:46 - second card in the cards array, you'll have
to of course, add the new card to the cards
171:51 - array. So quick little challenge. After this
card has been created, and it has been added
171:56 - to the sum, we also need to push the card
to the cards array. So go ahead and do this
172:02 - right now. Alright, the way to do this is
by writing cards, dot, push, open, close parentheses,
172:15 - and then pass in the newly created card, like
that. And in order to verify that this actually
172:21 - works, we can on the next line console, log
out the cards array like that, let's run this
172:28 - again, start game, hit new card. And there
we can see in the console. Now the cards array
172:34 - has been logged out with all the three cards,
10, four, and six. So we still aren't rendering
172:40 - out the third card though. And to achieve
that, you have to learn how to count in JavaScript,
172:46 - or Strictly speaking, you have to learn how
to write for loops. So over the next few casts,
172:51 - we are going to take a deep dive into four
loops, and then later return back to the blackjack
172:56 - game so that we can fix it up. Let's move
on. Okay, so now you're going to learn how
173:08 - to count with JavaScript. That might sound
really silly. I mean, counting is so easy
173:12 - if you ask a human to count. For example,
if you say pair count to 10, I would go Yeah,
173:18 - sure. 1-234-567-8910. However, JavaScript
is like that annoying person who then replies
173:23 - and said, well, where exactly do you want
me to start counting? by counting to 10? Do
173:28 - you mean, including 10? Or should I stop before
10? And also, should I count every single
173:34 - number? Or do you want me to, for example,
only count the odd numbers are the even numbers
173:37 - or whatever. So JavaScript is really like
that annoying person that takes everything
173:43 - you say 100% literal. So when you ask JavaScript
to count, you have to be super specific, we
173:50 - need to specify where we start counting where
the finish line is, and what the step size
173:54 - S here, I've already written the code for
you. So let's just dissect it. We start with
174:01 - the for keyword. And that's because this is
a so called for loop. But don't worry about
174:06 - that. Let's now look at the things that are
inside of the parentheses here. Here, you
174:11 - can see our starting condition, let's count
equals one. So we're going to start our count
174:16 - at one. Then we have a semi colon. And then
we specify our finish condition where it says
174:22 - count is less than 11. So we want count to
always be less than 11. So maximum 10. In
174:30 - other words, we're never going to count over
this number. And finally, the step size is
174:37 - that for
174:38 - each counting, you're going to increment with
one. So count plus equals one. Now these three
174:44 - conditions together describe to JavaScript
how many times we want to run the code inside
174:50 - of the curly brackets and what the value of
count will be at every single iteration. So
174:58 - here we are going to run this code 10 times
and the variable count will change its value
175:04 - in every single iteration starting at one
and going up to 10. Jumping one number at
175:10 - a time. So we will count to them. Let's run
this code. And there you can see in the console,
175:16 - we get the numbers from one and up to 10.
If we now changed this here to true, what
175:22 - do you think will happen? Well, then we get
13579. Because we still start at one, we're
175:29 - going to end before 11. So maximum 10. And
we're going to jump with two. So in the first
175:36 - iteration, count equals to one. It's what
we said we wanted to start with. But then
175:41 - in the second iteration, we've told JavaScript
that we want to increase by two every single
175:46 - time. So then it's three, and then it's five,
and then it's seven, and then it's nine. And
175:50 - then at the last iteration, it's like, okay,
now I'm going to be 11. But that doesn't work.
175:56 - that violates our finish condition here. So
JavaScript stops the loop before that happens,
176:04 - and then continues on with whatever it has
to do underneath the loop. So let's take this
176:10 - back to one. Can you modify this one, so that
it count from one to 20? How would you do
176:17 - that? Hopefully, you identified that what
you want to change is the finish condition
176:25 - and set that to less than 21. We run this
because he in the console that we're logging
176:31 - out one to 20. Now, how would we change this,
if we want to count from 10 to 20, go ahead
176:39 - and try that
176:40 - right now.
176:42 - Okay, hopefully, you figured out that it is
the starting condition you want to modify,
176:50 - you're going to write 10 here. So that starts
at 10 ends before 21 counts one at a time
176:58 - we run the code is he we get from 10 to 20,
logged out to the console. So hopefully, you've
177:03 - gained a little bit of intuition on this.
Now, let's move on to the next cast. Okay,
177:12 - let's first walk through how to create a loop
from scratch. And then I want you to create
177:17 - your own loop or at least try according to
the specifications here on line three, and
177:21 - four. But to begin with, we'll create a loop
loop count from zero to five. So to do that
177:27 - will be for opening close parentheses, and
then inside of the parentheses, we have to
177:31 - define our starting point, our finish line
and how big our steps will be. This is done
177:37 - through a counter variable. So we could do
let count equals zero and then semicolon to
177:44 - end the starting statement. Because zero is
where we want to start with or worse count
177:50 - is a very semantically good word for this
variable. A common convention in JavaScript
177:56 - is to use the letter I instead, I could have
named it whatever we want. And you can use
178:01 - count if you think that's easier, but I'm
gonna use it from now on. Then there's the
178:06 - finish line, which we also need to define,
we want to count to five, so I should be less
178:13 - than six, and then semi colon again. So this
finds that I should always be less than six.
178:20 - And obviously then the last point where it
will stop when counting upwards is five. And
178:25 - then finally, we have to define how big our
steps should be. Now I'm going to do i plus
178:31 - equals one. Here, we don't have to use a semicolon
to end because this is the last condition.
178:38 - Actually, I can space it out a little bit,
we follow the same structure for all of our
178:44 - conditions. And then the opening close square
brackets for the body of our for loop. Then
178:49 - inside of here, we'll do console dot log.
Hi from the code, omega t 012345. Good. Okay,
178:59 - now that you've seen this, I want you to try
to create a for loop that count from 10, up
179:05 - to 100 in steps of 10. So it should count
10 2030 4050 and so on, including 100. And
179:14 - I want you to use console log, as I am doing
here to log out the count at each step of
179:19 - the iteration. So go ahead and do this
179:21 - right now.
179:22 - Okay, hopefully that went well. If not, no
worries, let's do this together. Blue for
179:33 - let in here. You might wonder if while we've
already used the I variable, can we reuse
179:39 - it down here? And the answer is yes. AI is
only defined inside of the curly brackets
179:45 - of the for loop when you do it like this.
So outside of it. For example, down here at
179:49 - line eight. JavaScript won't remember this
I variable. So whatever you've configured
179:54 - it to mean up here inside of the curly brackets.
doesn't affect whatever you set it We're down
180:00 - here. So we can do let i n equals 10. That's
where we want to start, I should be this time
180:06 - less than not 100, because then we'll stop
at 99 needs to be less than 101. Finally,
180:12 - I should not be plus equals one, oh should
be plus equals 10. Because at each step in
180:18 - iteration, you want to increase I with 10.
console log, I am going to comment this one
180:26 - out, run the code. And there we see 10 2030
4050, and so on all the way up to 100. So
180:34 - great job. Okay, now you're going to experience
how powerful for loops are when combining
180:43 - them with a race, because let's say that we
are building a china application like the
180:48 - one that LinkedIn has, which I showed you
earlier. And these messages might just well
180:52 - be items in a race, let's just pretend that
each of these messages are exactly that. And
180:58 - ignore all the metadata around the messages,
like the time and the profile, picture, and
181:04 - name and stuff like that. And just pretend
that we have the data structure, which contains
181:07 - a bunch of messages inside of an array. Basically,
just what we have here, the exact same array
181:12 - we've worked with earlier as well. Now pretend
that this is a console based array, so everything
181:17 - basically need to do is log out of these messages
to the console. But in order to do that, we
181:22 - can't just console log out messages, because
then we'll just get a long array. And that's
181:28 - not what we want, we want each of the messages
on its own line, and not with the square bracket
181:33 - and stuff like that around. So the hard way
to do this is by doing like this. It's one
181:40 - messages, two messages, we like to take the
index from zero to three and log all of them
181:47 - out. There we go. Now we have what looks like
a chart in the console. But this is a really
181:54 - bad way of doing it, we are repeating ourselves
again and again. And that's a general anti
181:59 - pattern, there's something called dry for,
don't repeat yourself, don't write more code
182:07 - than you need to, especially not if you're
just repeating the same code. And also, this
182:11 - doesn't scale because ads now at the end of
the array, and run the code, I'm not logging
182:17 - out the last one, I have to manually update
my code. So what we instead want to do is
182:23 - combine this array with a for loop. Now let's
comment out this. And write for let i equals
182:33 - zero semicolon. And then we want to buy to
stop before it reaches five. Anyone I to increment
182:43 - by one, every single iteration. Now inside
of this for loop, we log the value I see in
182:52 - the console that we get from zero to four.
And that actually resembles quite a lot. What
182:59 - we did the hair, however, we've even added
the index of the latest item as well. So how
183:04 - about we instead of just logging out, I simply
do miss suggests open square brackets, close
183:11 - square brackets, use the eye as the index,
and then run the code. And boom, there we
183:18 - go. We have all of the items logged out in
order one after another brilliant. However,
183:25 - there's still a little problem here that if
I add yet another message here, maybe an emoji
183:31 - and I run the code, the emoji isn't logged
to the console. browser, change this to six
183:36 - again. So it's still not fully like dynamic.
However, I have a trick, because how can I
183:42 - get a hold of the number six in a dynamic
way? Well, you might remember that race has
183:50 - a property called length. And that will refer
to the actual length of the array. If we use
183:58 - that we can be sure that our loop counts up
to the final index all the way up to the end
184:05 - of the array. If we now run the code, yes,
there we have all of our messages, regardless
184:12 - of how long the messages array is. So this
was a lot of typing from my end, though. So
184:17 - let's move on to a challenge so that you get
to practice this as well.
184:22 - Okay, so now let's return back to the example
of having cards in an array like we have in
184:30 - our blackjack game. So here I've created an
array that has three cards of the value seven,
184:35 - three, and nine. And I want you to create
a for loop that logs out all of these cards
184:40 - to the console, however, not by hard coding,
where the loop should stop counting, but using
184:46 - the cards dot length property. So go ahead
and do this right now. And then I will of
184:51 - course show you the solution as well afterwards.
Okay, oh This went well, let's do it before
185:03 - open close parentheses, and then let i equals
zero, because we're going to start at zero.
185:09 - And next, I should be less than carts dot.
And I should be increased with one at every
185:18 - except in that region. Oh, here for this last
condition, I actually want to show you another
185:24 - trick, because what you can do here is actually
do i plus plus, that'll do the exact same
185:30 - thing as this, it's just syntactical sugar
and the JavaScript provides us with to make
185:35 - our code a little bit neater. So I plus plus
increments I with one. So now we can do console
185:43 - log cards, and then passing in the I run the
code. And there we can see seven, three, and
185:50 - nine printed to the console.
185:53 - Great job.
185:56 - Okay, this is so cool, because now you're
going to combine what you've learned about
186:01 - arrays, and for loops with what you know about
manipulating the DOM. So we're going to pull
186:06 - the strings together and have you render out
this sentence inside of this greeting L. So
186:13 - you can see we have in our HTML, just an empty
paragraph, which has the ID of greeting L,
186:18 - we have fetched that element from the HTML
and stored it in this greeting l variable.
186:23 - And your job is to render the sentence that
is the array here. So you're to render all
186:29 - of these items inside of the array in the
greeting paragraph. And the way to do that
186:34 - is to use a for loop to loop through it and
render each of them into the greeting l using
186:40 - dot text content. So a lot of stuff you have
to keep track of here, but give it your best
186:45 - shot. And then I of course will show you the
solution when you return back to the screencast.
186:50 - Okay, hopefully that was well. Now let's do
this before, let i equals zero, because we
187:00 - want to start at the zeroeth index in our
array, we'll do is less than sentence dot
187:07 - length. And then we do i plus plus, because
we want to increment one time. Here, we need
187:15 - to grab a hold of the greeting L and then
do text confidence. And here, you might have
187:20 - been tempted to do equal and open and close
square brackets and passing in the index,
187:26 - that will just end up with rendering pair
because first it renders Hello. And then it
187:32 - clears out all the text content and renders
the second word, but then for every single
187:37 - time in this loop, it clears out all the text
content, we end up with just the result after
187:43 - the last iteration. And that was the last
word in the array. So what we have to do,
187:48 - we have to keep the previous content intact
inside of the paragraph. And as you might
187:53 - remember, we do that with plus equals. So
running the code again. Yes, now it works.
187:58 - Now though, I have a bonus challenge for you,
which is the following. How do you keep the
188:02 - spaces between the words if I remove these
spaces from the array? That is if I do like
188:08 - this, like this, like this and like this,
and we render it out? Because we have no more
188:15 - spaces? It looks like one long, weird word.
How can we on this line seven, modify it so
188:20 - that we get spaces between the words, go ahead
and try that. Okay, what we will do is we'll
188:31 - simply, at the end here, add a plus, and concatenate
our given item in the array with a space.
188:40 - So now we add a space after each of the words.
If we're under this, you can see yes, we get
188:46 - now the sentence exactly how we want it. Great
job. Let's move on. Okay, back at our blackjack
188:58 - game, it's time for you to create a for loop
that renders out all the cards in the cards
189:03 - array instead of just the two first ones,
which we are doing up here. So you are going
189:08 - to start your for loop down here at line 19.
I'm going to help you out a little bit because
189:14 - we are going to keep this first setting of
the text contents here. So we have the default
189:20 - text inside of the paragraph. And then you
are going to render out the cards. After this
189:26 - text inside of the paragraph. Go ahead and
create that for loop so that our blackjack
189:31 - game supports any number of cards inside of
the cards array and will render all of them
189:36 - out regardless of how many it is to give it
to a restaurant and returned back to me when
189:41 - you want to see my solution.
189:42 - Okay, hopefully that went well. If not, no
worries, we'll do it together. We'll start
189:52 - with four and then open and close parentheses.
Of course inside of the parentheses, we need
189:57 - to define that we want to start our increments
At zero, and we want to stop it before it
190:03 - reaches the length of the cards array. How
do we do that? Well by i is less than cards
190:10 - dot length, and then a semicolon. And we want
to increment i, at every iteration, the body
190:18 - of the for loop with curly brackets here,
we are going to plus equal on to this paragraph.
190:24 - So we'll do cards, l dot text content, plus
equals, let's start by just adding the cards,
190:32 - and then passing in the current value of i
our iterator, which will start at zero and
190:38 - to begin with, and before 201, and then run
the code start game. And yes, it works. However,
190:47 - it looks like it says 104 here, because we
haven't added a space between our numbers.
190:53 - So the way to do that is simply by concatenating.
A space after been card. Now if we run it,
191:01 - start game, yes, we've got it. And if we hit
new card, now we can see both the sum and
191:07 - the cards are now correct, according to the
state of our game. Great job. Let's move on.
191:14 - Okay, so our blackjack game is actually turning
out pretty good now, start the game and hit
191:22 - a new card 20, I can even hit yet another
card, boom, I'm out of the game, it's it's
191:28 - almost fun to play, though, you'll get pretty
tired of it's as you played multiple times,
191:33 - since you every single time get the exact
same cards. So not exactly an exciting blackjack
191:38 - game. And of course, that is because we have
hard coded the variables for our first card
191:42 - and second card here and also hard coded the
value for our third and fourth and every proceeding
191:48 - card here on line 40 will always get 10 4666666,
and so forth. So what we need to do is instead
191:57 - create a function, get random card that returns
a random number. So that we instead of hard
192:03 - coding the number 10 up here on line one,
we can do get random card and call that function.
192:10 - This function will then return a random card
that the first card variable will be set to.
192:16 - And we can do the same with the second card.
And also down here in the new card function,
192:22 - we can do get random card there as well. This
way we'd get a functional backtracking. However,
192:27 - there's a few thing you haven't learned yet,
which you need to learn in order to create
192:31 - this get random card function. So let's rewind
a little bit here. Get back to the hard coded
192:36 - numbers. And over the next few casts, you're
going to learn how to return values in functions,
192:42 - and also how to generate random numbers inside
of a function. Let's go ahead and do exactly
192:48 - that. Okay, let's return back to our racing
game example in order to learn about returning
192:57 - values and functions. So here we have two
players who've raced through the game and
193:02 - player one got the time 102 and player two
got the time 107. And our job is to create
193:08 - a function that returns the fastest race time.
So in order to do that, we first have to do
193:12 - a function, I'm gonna call this get fastest
base time, quite a long word, but at least
193:20 - it's the script. And inside of the body of
the function, we have to first check which
193:24 - of these times were fastest. So we'll do an
if statement and say, if player one time is
193:31 - less than player two time, well, then we are
going to return player one time. Because if
193:40 - it's less than player two, then it's the fastest
race time and we are going to return it. Now
193:46 - this return keyword here might now seem a
bit weird. And you probably don't understand
193:51 - yet what it means. But don't worry about that
right now. It'll be clear as we move on. And
193:55 - then we're going to do else if the next condition
is if we are to was faster than player one
194:00 - is your time is less than player one time.
So we are going to return player to time like
194:10 - that. Then an else f actually these two are
equal. So none of these expressions evaluate
194:19 - to true. Well, then the fastest time as any
players time because they have the exact same
194:25 - time could either return player one time or
player two time it doesn't matter. I'm just
194:29 - going to return player one time. Okay. Now
what we can do is we can do let us race I'm
194:36 - going to call this variable x. And now I'm
going to define that declare that variable
194:42 - as the result of invoking this function. So
I'm gonna do get asked disgrace time like
194:50 - that. Now, the value of fast race time will
be whatever this function has returned. And
194:58 - if we console log So it's race time, we can
see, we get 102. That's correct, because this
195:07 - function compared player one and player two,
and rightfully recognize that player one was
195:12 - faster than player two, and thus returned
player one time. What you might think now
195:17 - is, well, we're just console logging out the
value here. What's the point? Why couldn't
195:21 - we just, instead of these returns, let's do
console dot log, to do that directly inside
195:28 - of the function, do that first and run it
and see, yes, we are now indeed, running this
195:36 - line six. Here, we're console, logging out
the value.
195:39 - Briefly down here, try to see what is the
value of fastest race at this point,
195:45 - and run the code, you can see that we're getting
102. First from this line, then we're getting
195:50 - undefined from line 16. Because now, the fastest
race variable simply isn't defined because
195:57 - this function didn't return anything. And
it's actually quite valuable to have stored
196:02 - the fastest race time inside of this value,
as opposed to just having console log that
196:07 - out appear. Because now we can use this variable
for something else. So let's like this, and
196:14 - return instead, move over and remove the parentheses
as well. We're wondering how I got the cursor
196:21 - to be on multiple lines at the same time,
it's a trick where you first select a word,
196:27 - and then do Command D. Or if you're not on
a Mac, Ctrl C plus D, like the word Command
196:34 - D, one three times and now I have selected
all of the return e works so that I can delete
196:40 - them or retype them. That was just a quick
little tip. Now it's time for a challenge.
196:47 - So you are going to write a function that
returns the total race time, then you are
196:52 - going to call or invoke the function and then
store the return value in a new variable,
196:56 - you have to decide for yourself what you're
going to call that variable. And what you're
197:00 - going to call this function. Then finally,
you are going to log your variable out just
197:04 - to check that everything has worked. So go
ahead and do this right now. Okay, hopefully
197:14 - this went well, let's do this. Okay, function
get portal race, five. And the way to do that
197:23 - is simply to return layer one time plus layer
two time, then we can create a new variable
197:30 - called Lex. total time equals get total race
time. Now we can console log total time, thing
197:43 - like that, running the code. And indeed, we
get 209 in the console, which sounds just
197:48 - about right. So great job, let's move on.
Okay, it's time to take what you've learned
197:58 - about returning values and functions, and
implement that technique into our app. This
198:04 - is a three part challenge. First, you're going
to create a function get random card, that
198:09 - always returns the number five. And then you're
going to use get random card to set the values
198:14 - of the first card and the second card, and
then use it to set the value of the card variable
198:20 - down here in the new card function as well.
So you are going to write your function, get
198:25 - random card here, starting on line 14. And
now you might think, Well, that doesn't make
198:31 - sense. Because we have previously learned
that if you define a variable down here on
198:35 - line 14, we can't use it up on line two, and
three, that's at least how it is with variables
198:41 - you define using the let keyword. That is
exactly right. But when you create functions
198:46 - in the way we do, there's an exception. So
I want you to just try this and see if it
198:50 - works. And then I'm going to explain afterwards,
why it works. Go ahead and give this your
198:55 - best shot, and then I will show you the solution
as well afterwards.
198:58 - Okay, hopefully that went well. Now let's
do this, we'll do function get random part
199:10 - like that. Then inside of the body of the
function will simply return five, we need
199:16 - to use this pair app line to get random card
and on line three, get random card. What's
199:25 - happening here is we're calling this function
it will return five and thus second card and
199:32 - first card will be initialized with the value
five, as will our part down here. If we do
199:38 - get random card and call it these two really
important, otherwise it won't work but with
199:44 - them card will now have the value five. So
let's run our blackjack game. Stop the game.
199:51 - Oh, we got two fives. Nah, yet another five.
What's the chance? Obviously it is 100% at
199:58 - the moment, but that doesn't matter. Because
we now have the setup for inside of this function,
200:04 - writing the logic for getting an actual random
card back. So that's great. Finally, I promised
200:10 - to talk a little bit about the fact that we're
creating the function down here on line 14,
200:14 - and then using it on line two, that seems
to go against what we learned about variables
200:18 - early on. However, when you write functions
like this, which is called function declarations,
200:24 - the function gets so called hoisted to the
top, meaning that it's accessible even at
200:29 - line one, regardless of how far down you define
the function, we could have written this function
200:33 - on line 10,000, it would still be accessible
online one. Now there are other ways of creating
200:39 - functions don't give the function this extra
benefit. But as for now, we're only going
200:44 - to write functions in this way. So don't worry
about that. Because now you have another thing
200:49 - to worry about. And that is, how do we actually
modify this get random function so that it
200:54 - actually returns a random card? So from the
next lesson on, we are going to dive into
200:59 - exactly how to do that. I'll see
201:02 - you there.
201:07 - So I remember when I was learning this slightly
clunky way of generating random numbers in
201:11 - JavaScript and thinking, Well, why do I really
need to generate random numbers is that really
201:17 - such a common thing to do for developers?
Actually, it is, of course, there's our use
201:22 - case where we're building a card game, obviously,
we need to have some kind of randomness in
201:26 - which card you get. Otherwise it would be
meaningless. But also imagine all games that
201:30 - use dices a dice is basically a physical randomness
function with gives you a random number between
201:36 - one and six. But randomness is only important
in these kind of casino ish games, I would
201:40 - say all computer games randomness plays some
kind of role. For example, in this popular
201:46 - iPhone game crossy road where you are to cross
a road as a duck without getting hit by a
201:52 - car. Surely, there's some randomness underneath
here, which decides which cars appear on the
201:56 - road and when they appear, but it doesn't
stop there with games. Actually, cybersecurity
202:02 - random numbers is a key component in order
to authenticate yourself and generate keys
202:07 - as with in cryptocurrencies. So for example,
Bitcoin uses random numbers as well. The random
202:12 - numbers plays a role in the crypto economy
as well. And most importantly, we use random
202:17 - numbers in order to generate the suggested
tweet text in our JavaScript Miss advent calendar.
202:23 - So you can understand random numbers are everywhere.
And you need to learn the most basic way of
202:29 - generating that in JavaScript. And that is
through something that we call the math object.
202:35 - That's something that's already provided to
you in JavaScript or by the browser to be
202:40 - specific. And you can type math wherever you
want, with a capital M, and then do dot random,
202:47 - and then open close parentheses so that you
call this function or method. And don't worry,
202:53 - if you don't quite understand what's going
on under the hood here, you're not meant to
202:56 - do that right now. All you're meant to know
is that that will return a number to you,
203:01 - which is now stored in a variable called random
number. And then I'm logging out this random
203:06 - number. What I want you to do now is pause
this screencast and run this code a few times,
203:12 - so that you get to see a few of the values
that our random number variables can take.
203:16 - And then try to ask, succinctly and specifically
as possible, write your answer at what you
203:23 - think math dot random Deus, what does it return,
try to formulate that and write it down, then
203:29 - return back to the screencast when you think
you have the answer.
203:38 - So the way I would write this is that it generates
a random number between zero and one, and
203:49 - the parentheses, not inclusive of one. So
we generate a random number, including zero,
203:55 - and one, but not including one. So from 0.00000
to 0.99999999, kind of bunch of nines after
204:05 - that. So if we were to visualize this slightly,
say that math dot random, gives you a number
204:11 - from 0.000. And the bunch of zeros after that
I just didn't couldn't bother writing all
204:17 - of them to 0.99999999, basically a bunch of
nines as well. That is the range you are given
204:24 - when you give JavaScript this command. So
if we run this, you can see we get 0.68 and
204:32 - a bunch of numbers 0.95 and a bunch of numbers
0.88 0.001. Yeah, as you can see, we've already
204:40 - been almost very close to zero to very close
to one. Now, before we go, there's one thing
204:47 - I need to point out, which is that the randomness
here while it looks completely random for
204:52 - us humans, it's not truly random. There is
some deterministic variables going on under
204:58 - the hood here and it's actually a Really hard
problem and computer science to generate truly
205:04 - random numbers. But for our use cases, we're
not going to worry about that. As far as we
205:08 - hear these numbers regenerate with math look
random, or more than random enough for our
205:13 - use case, this is not a PhD in cybersecurity,
but but rather getting you started with web
205:18 - development. So with that, let's move on.
Okay, so now we know how to create a random
205:28 - number between zero and up to but not including
one. However, it's not entirely clear how
205:34 - we utilize math dot random in order to create
something useful, like, for example, a dice
205:40 - function. So let's take this one step at a
time towards creating such a function. And
205:45 - the first step we're going to take is simply
by multiplying math at random with six. Now
205:52 - I want you to do the same thing that you did
previously, which is to pause the screencast,
205:57 - run this code a few times and see what we
log to the console, and then answer the following
206:02 - question. Which range will a random number
be now? So from which number to which other
206:09 - number? It used to be from zero to 0.99999?
Now, it's something else, and you have to
206:16 - figure that out. So go ahead and do that right
now. Okay, the answer is that it still starts
206:26 - at zero. Now goes all the way up to 5.99999.
And a bunch of nines, I'm not going to type
206:34 - all of them. So if math dot random gave us
a number from zero to 0.999, Math dot random
206:41 - times six will give us a number from zero,
because zero times six is still zero to 5.999.
206:49 - Because zero or in a bunch of nines times
six is not entirely six, but it's almost six.
206:55 - So it's five point a bunch of nines. So now
we have kind of expanded our range, roughly
207:00 - speaking from being between zero and one to
being between zero and six. We did that by
207:06 - multiplying it to the six. Let's move on to
the next step. Okay, so now we need to learn
207:15 - another method on the math object. And that
is math dot floor. Florida's s, a takes some
207:22 - input a number and then does something with
that number. Return set filters, you can store
207:27 - that in a new variable, for example, like
Florida number right here, that is the Florida
207:32 - version of this number. So I want you to pause
the screencast, run this code a few times
207:38 - and answer the question, What does math floor
do to positive numbers? And the reason I'm
207:43 - saying positive numbers is I don't want you
to add negative numbers in here, because the
207:47 - mental model is slightly easier if you only
think about positive numbers. And it's a bit
207:51 - easier to write a concise answer to it and
my opinion. And finally, I've never used math
207:56 - floor on negative numbers anyway, it's usually
used on positive numbers. So try this, feel
208:02 - free to add a few different numbers in here
and run the code. And once you're ready, just
208:06 - type out your personal explanation. What do
you think math floor does go ahead and do
208:10 - this right now. Now, the way I think of math
floor is that it simply removes the decimals.
208:21 - If we run this, it returns three, we have
12.40, even 12.9999999. Still 12. Okay, so
208:33 - great job with that knowledge in mind.
208:35 - Let's move on to the next lesson. Okay, so
just as a quick recap, math dot random gave
208:45 - us a number between zero and almost one. And
math random times six, then gave us a number
208:51 - between zero and almost six. And now we are
going to combine this with a math dot floor,
208:57 - which you learned in the previous lesson.
I'm going to add it here. I'm going to write
209:01 - math dot floor and then wrap our entire previous
expression inside the parentheses of math
209:08 - floor. Now, what I want you to do is run this
code a few times, and then write down possible
209:15 - values. Random number now can hold. So there's
a limited number of them and your job is to
209:21 - figure out exactly which wants to go ahead
and do this right now.
209:26 - Okay,
209:27 - hopefully that went well. Now let's run this
together. See, we got 44014025 Hmm. Okay,
209:44 - so it seems we are getting the numbers between
zero and five. That actually makes a lot of
209:50 - sense because if we take this range here between
zero and almost six and shove it into the
209:56 - math dot floor function, then it will basically
remove All of the decimals and if we remove
210:02 - the decimals from this entire range, which
numbers are we then left with? It's just the
210:07 - whole numbers from zero all the way up to
five. So the right answer was 012345. Like
210:15 - that, okay, hopefully, you're still hanging
on, let's move on to the final step of our
210:20 - dice function. Okay, now we are going to complete
our dice feature, because we know that with
210:29 - this expression, currently get a whole number
from zero to five. So the question then remains,
210:34 - how do we turn this range into rather a range
between one and six, which is essentially
210:40 - the same as a dice, and I want you to try
this for yourself. Try to modify the expression
210:46 - so that we get a range from one to six instead
of zero to five. Go ahead and give that a
210:51 - shot right now. Okay, hopefully that went?
Well. To understand what we need to do, we
211:01 - can compare each of the numbers here can see
that first number here is one and the first
211:07 - number there is zero. And how do we go from
zero to one, we add one. And the same goes
211:13 - for all of the numbers here of how to go from
one to two, well, we add one, and from five
211:17 - to six, we add one. So basically, what we
can do is just two plus one at the very end.
211:23 - And then if we run the code, you see we get
to we get 6356 to one, yes, we indeed get
211:33 - the entire range of a dice. So really good
job reaching this far. Now I only have one
211:40 - last challenge for you. Let's create a function
called roll dice that returns a random number
211:47 - between one and six. So basically, you're
going to take what we've done here, and wrap
211:52 - it into a function and then return the results.
Go ahead and do that. Okay, to do this, I'll
212:00 - do function, roll dice, open and close parentheses,
open and close brackets. And inside of here,
212:08 - I'm just going to copy this line straight
in, and then return a random number like that.
212:18 - Now after you remove it from a pair, because
up here on line two random number isn't even
212:23 - defined, so we can't log it out. Random number
is now only defined inside of the role bytes
212:28 - function and the value of it gets returned.
So if we console log, and inside of the parentheses,
212:36 - we call the roll dice function like that.
Get, yes, a random number between one and
212:45 - six. Really good job reaching this far, this
was complicated stuff. So if you feel a little
212:50 - bit shaky with this, that's totally okay.
You can go back and rewatch it and retry all
212:54 - of the challenges if you want to. And then
when you feel ready, we'll move on and use
212:58 - this knowledge to make our blackjack game
much better. Okay, we're back at our blackjack
213:06 - game. And we are going to fix up this get
random card function, but we'll do it step
213:11 - by step. So to begin with, I want you to make
it return a random number between one and
213:17 - 13. So here, you can pretend that we are working
with the regular values that a deck of cards
213:23 - usually has. So with the ACE being the one,
the numbers from two to 10, of course being
213:28 - their respective numbers, then the jack being
11, Queen being 12, and King being 13. So
213:35 - from one to therapy like this, go ahead and
give this your best shot. And then of course,
213:41 - I
213:42 - will show you how to do it afterwards as well.
Okay, now let's do this. We know that if we
213:52 - do math dot random, we are going to generate
a number between 0.000 and a bunch of decimals
213:59 - after that,
214:00 - until 0.999, and a bunch of lines after that
as well. So the first thing we need to do
214:06 - in order to get this range to look more like
this one is to multiply this entire thing
214:12 - with 13 0.000 times 13 is still 0.000 is still
zero. And 0.999 times 13 is actually just
214:23 - 12.999. Or we have a bunch of nines after
that as well. So we're getting to something
214:28 - remotely similar. It's just a matter of how
many nines we have after the dots. But this
214:33 - is roughly the range we're working with with
this expression right here. So we want to
214:38 - remove the decimals. And how do we do that?
Well, if you remember from Previously, we
214:43 - can use the math dot floor function to wrap
the entire thing inside of the parentheses
214:49 - of math dot floor. Now we take this expression
here, this one and we n floor it which gives
214:56 - you like that and like that. So, zero to 12.
That's what we're returning here. The question
215:05 - remains, how do we go from zero to 12? One
to 13? Well, that's only a matter of adding
215:10 - a one to any given number. Let's do like that.
That should return a number between one and
215:16 - 13. Let's try to start this game and pull
a bunch of cards to see if we actually get
215:20 - the entire range. Seven for looking good so
far. 10. Okay, 13. Yes, file a bunch of other
215:27 - numbers. getting way too many numbers here.
Let's get that one. Yes, there we got it,
215:32 - a one. So we have the entire range from 13
to one. And then just about everything in
215:37 - between. This was not a normal blackjack round,
but at least prove the point that this generates
215:43 - a random number between one and 13. So great
job reaching this far. But of course, we have
215:49 - to modify it because in blackjack, we're not
following the usual value sequence for cards,
215:54 - so we need to modify our function a little
bit, but we'll do that in the next test. Now,
216:02 - we need to change our get random card function,
because in blackjack, the jack, queen and
216:07 - king are all worth 10, and the ACE is worth
11. Or, strictly speaking, the ACE can be
216:12 - worth both one and 11, you get to choose as
a player, what suits you best is the value
216:18 - you use. However, for the sake of simplicity,
we are just going to treat the ACE as 11.
216:24 - In our case, as having a dual value for this
card would add a lot of complexity to our
216:29 - game. And it's not something I want to focus
on. It's rather something you can, for example,
216:33 - do as a stretch goal later if you want to
modify the game at the end of this course.
216:37 - So for now, we're going to treat our ace as
11. So this means we need to modify our get
216:42 - random card function. If the number it returns
is one, then we should change it to 11. And
216:47 - likewise, if the number of returns is either
1112, or 13, we should rather return 10. To
216:54 - go ahead and modify this function so that
these exceptions are followed,
217:00 - you're going to have to define a variable
that this random number is stored in and also
217:07 - has some kind of conditional that checks for
these conditions, and returns the appropriate
217:12 - value. So go ahead and give this a shot. And
then I will of course show you the solution
217:16 - afterwards as well.
217:19 - Okay, hopefully that went well. If not, no
worries, we'll do it together. First, I'm
217:27 - going to instead of returning this directly,
turn it into our random number dropped, then
217:34 - we need to write our conditional to account
for these special cases, I'm going to start
217:39 - from the very top and check if a random number
is more than 10, meaning that card is either
217:45 - the jack queen or the king. So if a random
number is more than 10, what are we going
217:52 - to return then well, then we are going to
return 10 because that is the value of the
217:57 - jack, queen and king, I'm going to do elsif.
And now I'm going to count for the ACE itself.
218:04 - And for that I'm going to use the triple equals
random number, triple equals one. And I'm
218:11 - going to return 11 then In all other cases,
I can just do else like that no other cases,
218:17 - it must mean that we have drawn in row 23456789
or 10. If so, we're just going to return that
218:25 - value. So then we're just going to return
the random number directly like that, let's
218:31 - run the code. Start game. Okay, five, five,
I'm gonna hit the bunch of cards to see that
218:36 - we get the entire range. And indeed, it seems
that we have a two here we have an 11 here
218:41 - and have almost every single word in between.
I'm 100% sure that if we continue hitting
218:46 - the new card in the long run, we'll just get
random numbers across our entire defined range.
218:52 - So great job, we're almost reaching the end
of our blackjack game, you should really be
218:56 - proud of yourself for reaching this far, this
is starting to get advanced. But there's even
219:00 - more to learn. So let's just keep up the pace
and move on. Okay, there's one really weird
219:09 - thing with our blackjack game. And that's
easily exposed. If we console log out to the
219:13 - cards here at line 12. And then refresh the
page there we can see I got two and seven.
219:19 - And the reason that's weird is because I haven't
even clicked the start game button, I kind
219:23 - of just entered the casino and the casino
was already decided what cards I am to be
219:28 - dealt. That's fishy, we don't want that I
want the cards to be generated as I click
219:32 - on the Start game button. So the first card
and the second card should be generated inside
219:38 - of the start game function. And thus the cards
and the sum also needs to be reassigned inside
219:44 - of the start game function. And also the is
alive shouldn't be set to true by default.
219:49 - before I've even click the Start game button.
I'm not alive. I'm not even playing the game.
219:53 - I'm going to use that as an example. Set it
to false first, then inside of the start game
219:58 - function. I'm going to do is alive equals
true. So now we have the correct starting
220:05 - state before I've entered the game appear
in line six, and the correct value once I've
220:10 - started the game down on line 26. So what
I want you to do is make it so that the same
220:16 - thing happens with cards rate because it should
not be set here. And the first and second
220:21 - card shouldn't even be defined up here and
the sum should be zero by default. This is
220:28 - how the state of the game is before I've started
playing the game. Now, what you need to do
220:33 - down here at line 23, and 24 is generate two
random numbers, then reassign the cards and
220:40 - the some variables so that the game can start.
So you might find this a bit tricky, but do
220:45 - your best, there's no shame in trying and
failing, because I will of course, also show
220:49 - you how to do it when you return back to this
cast. Good luck. Okay, let's do this. We'll
221:00 - start by defining first card and second card.
And they should be defined by running the
221:05 - get random card function, I don't give them
we get random card function. Second card equals
221:12 - no card as well. Now we can set the parts
array to first card, the second card, and
221:21 - the sum to first card, plus second card like
that. And also actually get this console logged
221:31 - back in again. and rerun the browser you can
see now it's empty. The casino hasn't decided
221:37 - which card slam to get very good. So it's
start game and there I got my blackjack. Oh
221:42 - my god. That's amazing. And with that, I have
nothing more to say. I'll see you in the next
221:48 - caste. The next thing I want to fix is our
new card button because it's kind of broken.
221:57 - Let's see why. If I now start the game, and
I get two cards, and I draw a third card and
222:03 - a fourth card and I'm out of the game. At
this point, I shouldn't be able to draw more
222:07 - cards, but actually I am I can hit it and
I got another 10. So I'm at 34 shouldn't be
222:12 - possible to get to that number in blackjack.
So we need to stop it when the game is over.
222:18 - And also we refresh the browser able to I
shouldn't be able to start with just one card
222:23 - either,
222:24 - but I actually can. So there's two conditions,
we need to check both if I'm still in the
222:29 - game, basically if the is alive is true. And
also I can't have blackjack either. Now this
222:35 - requires us to learn something called logical
operators, which lets you combine multiple
222:40 - conditions inside of an if statement so that
a piece of code should only be run if multiple
222:45 - conditions are satisfied. So let's take a
little detour and learn about logical operators
222:50 - in the next casts.
222:53 - Okay, let's learn about logical operators.
Here we have a little bit of boilerplate code,
223:00 - namely two variables and a function. And the
imagine scenario here is a course platform
223:06 - much like scramble. And what we're trying
to solve is to figure out whether or not a
223:10 - user should get a certificate, that is whether
or not we should call this get certificate
223:16 - function. Because the deal is we only want
to call this function if two conditions are
223:21 - true. And that is has completed course. In
other words, the user has completed 100% of
223:26 - the course. And secondly, gives certificate
that is whether or not this is the type of
223:33 - course it makes the user eligible for a certificate.
Because you can imagine that very short courses
223:38 - doesn't give you a certificate to the course
has to be of a certain size to reward you
223:42 - with a certificate. So what we need to do
is figure out how we can check if both of
223:49 - these conditions are true, because then and
only then do we want to call this generates
223:54 - certificate function, you could actually achieve
this with the concepts you've learned so far,
224:00 - by simply nesting if statements. For example,
you could do if has completed course, equals
224:07 - to true, and then add the body of the if statement.
And then inside of the body, you could nest
224:13 - another if statement if gives certificate
equals true potential. So you get two F's
224:23 - inside of each other and the inside of the
inner if you do generate certificate. Now
224:31 - if we run this code, you can see yes, we are
indeed generating the certificates. And if
224:36 - we flip one of them to false, we are not generating
the certificate because here, this condition
224:43 - was not fulfilled. So neither of the code
lines inside of the body was run. JavaScript
224:49 - just jumped over the entire if statement.
However, this is a very clunky way of doing
224:54 - it a better way would be to actually remove
the inner if statement. For now, let's just
225:00 - comment it out. And then inside of the parentheses
here, we can add another condition by writing
225:08 - a double ampersand. And then the next condition
gave us certificate equals true, we now move
225:18 - this line, this line and uncomment, this one,
run this code, we see nothing happens because
225:26 - this condition here is false. And with the
AND operator, both of the expressions before
225:35 - an after the operator need to evaluate to
true for this entire expression to evaluate
225:41 - to true. So if we flip this to true, and run
this, now it works. But it's much better to
225:48 - have it on one line. And a little extra thing
we can do is actually omit the script equals
225:55 - true, because now, what was this and this
evaluator? Well, it's simply true, and, and
226:06 - true and true equals false true. But as for
now, in order to be explicit about the condition
226:12 - we are checking for, actually want to keep
these cripple equals here as well. So one
226:19 - way to read this in plain English is, if this
is true, and this is true, then run this code.
226:30 - Hopefully that makes sense, because in the
next class, I'm going to give you a challenge,
226:34 - so that you get your hands dirty with this
as well.
226:38 - Okay,
226:40 - let's continue on with our course platform
example. So in this challenge, you are to
226:45 - imagine that you are writing the code that
is to be run, after the student has struggled
226:50 - with the challenge for a little while, or
maybe the student has clicked a button and
226:54 - signaled to the platform that that she is
stuck. And the first one to check has the
226:59 - student solve the challenge she's trying to
solve, and has the students enter, hence left,
227:05 - because if the student has any hints left,
she can go and open those hints. But if she's
227:09 - used all of our hands, and she hasn't solved
the challenge yet, then we are to run this
227:15 - show solution function and just show her the
solution. Obviously, it just logs out a string,
227:21 - but you can imagine that it will show the
solution. So your job is to create an if statement
227:26 - that checks that both variables are false.
I mean, these two variables, and then if so,
227:33 - run the show solution function, go ahead and
give this a shot. And then I will of course,
227:38 - show you the solution when you return back
to the screencast. Okay, the way to solve
227:47 - this S, almost similar to what we did in the
previous cast will be F and then open and
227:52 - close parentheses. And here we need to use
a logical AND operator because we're going
227:57 - to check if both has solved the challenge.
cripple equals false. And the double ampersand
228:06 - has hints left is also false. Then, if the
user hasn't solved the challenge, and has
228:16 - no hints left, it's time to give her some
slack and show this solution. So then will
228:22 - trigger show solution like that. Let's run
the code. And indeed, this triggers the code
228:29 - because both of them are false. If we try
to flip them to true, then the code is not
228:35 - triggered. We're not logging anything to the
console, meaning that our logical operator
228:39 - that governs our if statement actually works.
Great job. So now that you've learned the
228:49 - AND operator, let's take a look at it's close
relative, Li OR operator. What does that do?
228:56 - Well, it allows you to check if either this
condition is true, or this condition is true.
229:03 - And if so, the body of the if statement will
be executed. So if you're in a situation where
229:09 - we only need one of two cases to be valid,
well, then you want to use the OR operator.
229:14 - As for this example, it doesn't really make
sense. It will now run since actually both
229:19 - of these are true. But if the gift certificate
is false, it will also run. But that doesn't
229:26 - make any sense. Because if the course doesn't
give any certificates at all, you're not supposed
229:31 - to generate any certificates regardless of
the user having completed the course. So let's
229:35 - use another example. instead. Imagine here
that you're building Netflix, and you've just
229:41 - launched this amazing new documentary, The
fire festival. I don't know if you've seen
229:45 - this, but it's truly amazing about a guy who
creates a festival that aims to be the celebrity
229:51 - Hot Shots festival of the world that just
becomes a disaster. It's really good. After
229:56 - this has been launched. You probably want
to recommend it to a ton of your users. And
230:00 - what you want to do is you want to check if
the user likes documentaries. Or if the user
230:05 - like startups, they don't have to like both
but definitely like one of these themes, then
230:11 - most likely, they will enjoy the fire festival
documentary. So I want you now to try to use
230:17 - the or statement that is the two lines you
can see here, you can copy them if you want,
230:21 - if you don't know how to get them from your
keyboard, and you're going to use this to
230:25 - call recommend movie if either of the variables
this the likes documentary, or like startups
230:30 - are true. I'm pushing you out on thin ice
here, I haven't written a complete or statement
230:36 - for you, but it works in just the same way
as the and statement. So I think you can do
230:40 - it if you just give it a shot. And if you
don't, no worries, I will show you the solution
230:44 - afterwards as well. Okay, let's do this. Let
likes documentaries. set that to true. And
230:59 - we'll do let likes startups to bathroo false
for example. And if likes documentaries, if
231:08 - that is true. Or if likes startups, it's true.
Well, then we want to recommend this movie
231:18 - like that. running the code, we can see we
are recommending the movie, even though this
231:24 - one is false, flipping both of them to false.
Now, if I run the code, nothing happens, because
231:31 - at least one of them needs to be true, this
or this.
231:35 - And if we make both true and run the code,
then of course, if both are true, then one
231:42 - or the other is also true. So that would satisfy
the condition, great job doing this challenge.
231:48 - Let's keep up the pace and move on. Now, you
are going to take what you've learned about
231:56 - the logical AND operator and modify this new
card function, so that you only allow the
232:02 - player to get a new card if she is alive,
and does not have blackjack. So those are
232:09 - the two conditions that need to be filled
for you to actually run this code. So give
232:15 - this a shot. And I will of course show you
the solution afterwards as well. Okay, so
232:24 - the way to do this is if open and close parentheses,
and then actually just open the body of the
232:32 - conditional and paste in this code. And when
are we going to run this code? Well, she has
232:38 - to be alive, we're going to do is alive. And
then if that equals to true as the first condition.
232:46 - And the second condition, which we also want
to be true, since we're using this logical
232:51 - AND operator should be that the house black
jack should be equal to false like that. If
233:00 - it's alive is true, and has blackjack is false,
then the dealer should be willing to give
233:05 - the player a new card. So let's try this we'll
start the game 15 new card 25 you're out of
233:12 - the game, let's try to ask the dealer if we
can please get one more card. Nothing happens.
233:17 - Works brilliant, really good job doing this
challenge. Okay, so our blackjack game is
233:26 - almost complete, there's just a tiny little
feature I would like to add as well. Because
233:31 - if you've ever played online blackjack, or
poker, what you normally see as your own name,
233:36 - and your credits or your chips somewhere on
the screen. So what I mean by that is something
233:41 - along the lines of this, like that, so you
see your name and how many credits you have,
233:48 - or chips or whatever. And this is nice because
then it's possible to later implement the
233:52 - concept of winning ever increasing your trips
and of losing as you're betting or playing
233:57 - rounds for critical components of any blackjack
game. However, I wouldn't want to hardcoded
234:02 - in the HTML like this, we of course, when
I represent this data and our JavaScript,
234:07 - that gives us the ability to change it. Now
I'm going to just show you how we could do
234:11 - this to begin with, by first giving this an
idea of player dash L and removing the competence
234:20 - of it. Then in the JavaScript, we could do
let play your name equals pair and let player
234:31 - chips equals 145 for example, and then we
could grab the element, player L equals document
234:41 - dot get element by ID, passing in the ID we
just created. And then do the player algo
234:49 - text content which you know by now, your name,
colon and a space and then $1 sign and then
234:57 - plus the player chips like that. If we now
run this, you can see yes that we render it
235:04 - in the exact same way. However, now we've
come into a situation where two values that
235:09 - are inherently connected together, like the
player and his chips, which currently live
235:15 - in two different variables, what would make
more sense in this situation would be to somehow
235:21 - combine this into a single unity. And that
is where so called objects come into play.
235:28 - That is another data type, which resembles
a race a little bit. But they are also different
235:33 - in fundamental ways, but they are kind of
also buckets where you store data. So in our
235:38 - case, we would perhaps want to create a player
object in which we can store both the player's
235:43 - name and the chips. So I'm going to show you
how to do this, you might feel a little bit
235:48 - confused as you see it. But over the next
few casts, you're going to practice objects
235:53 - yourself. So what I'll do, right let player
equals open close curly brackets. You've seen
236:01 - these before, they're used often in JavaScript.
But when you see them in a context like this,
236:06 - after the assignment operator, they mean that
we are creating an object. And inside of here,
236:11 - what I essentially want to do is add this
data right here, however, you can see that
236:18 - something is wrong here with all these red
lines. And that's because the syntax for creating
236:23 - items inside of our object is different from
how we define variables. First of all, we
236:29 - don't use the let keyword dump of the names.
And secondly, we replace the assignment with
236:37 - a colon. And thirdly, just as we have in a
race, we separate the items with commerce,
236:45 - but we don't do that on the last item. Finally,
here, it would make sense to omit the player
236:51 - as we've already used that name as the name
of the entire object. So we can just rather
236:58 - do name and I'm not going to capitalize it
and chips like that. Now we have taken our
237:04 - two variables and group them together in this
little bucket which we are calling player
237:10 - and the way we now can refer to these
237:13 - Values pair. And 145 is by using the first
the object name, player. And then the given
237:19 - key. Nice name. This is called a key, and
its value. So name is the key and Paris the
237:27 - value. Also chips is a key, and 145 is a value.
So to replace player chips with the reference
237:34 - to the trips inside of the player object,
we will instead do player dot chips. If I
237:41 - run this code, and see we get the exact same
result, you're probably a little bit confused
237:47 - now. So don't worry, if you think this was
hard over the next few casts, you are going
237:52 - to practice objects for yourself, so that
this becomes a second nature to you.
237:57 - Let's move on.
237:59 - One way to think of objects is that they give
you the ability to store data in depth. And
238:08 - with that in mind, we'll know that objects
are so called complex data types are also
238:13 - called composite data types. Because we use
numbers, strings, Boolean, or even a race
238:18 - in order to compose objects, so they often
store quite a lot of data. And they can even
238:24 - store objects within objects, that kind of
nested data structure, it's not something
238:28 - you're going to think about now. For now,
just think of it as key value pairs. And let's
238:33 - look this through the lens of a real world
example. That's always easier. So here on
238:39 - screen Ba, we represent our courses as objects
was here, you can see the CSS Grid course,
238:44 - actually, the very first course we launched
back in the days, and it has a bunch of different
238:49 - data, for example, it has the title, the number
of lessons, and the creator of the course,
238:54 - the length of the course and the level of
it. So let's actually translate this course
238:59 - into JavaScript into how the data structure
actually looks. So good. Let course equals
239:05 - open and closed curly brackets start with
a title, like that title, colon, learn CSS
239:12 - Grid for free. Now we have one key value pair,
title is the key. And the string here is the
239:19 - value, then the lessons that is natural to
represent as a number. So it was 16 lessons,
239:25 - the creator, which again, is a string. But
then we have the length, which while it says
239:31 - one hour here, that's actually not how we
represent that data in our database in this
239:36 - in this object, break it down into minutes.
So perhaps this course is actually 63 minutes.
239:43 - But as for the user interface, we don't go
into detail that much, we round it to the
239:47 - closest hour. And finally, there's the level
and here it says intermediate. That's also
239:52 - one of those cases where the data in the user
interface differs slightly from the data in
239:56 - the database. So our levels are represented
from zero to three, where zero is complete,
240:03 - noobs and three are in the advanced courses.
So the intermediate course, you can see here,
240:07 - we type out intermediate here, if this value
is set to two, now you don't have to worry
240:12 - about how our design. And what we say to the
user differs from the underlying data. It's
240:17 - just something I wanted to give you a little
heads up about, because it's very normal in
240:21 - real world code bases. It looks like we're
kind of done here. But we're actually not
240:26 - because there's a lot more data for a course
actually the North's represented here, for
240:30 - example, whether or not it's free or paid,
that's a Boolean. So it's either true or false
240:36 - like that it's free true. And this course
isn't free. And we also have tags for courses.
240:41 - And that's an array because we want to have
the ability to add multiple tags to one course.
240:47 - So we need a complex data type here as well
as the value of this tags key. So for example,
240:52 - this CSS Grid course has the tags, HTML, and
CSS. So this is a very real world example
241:00 - of an object. Now, if we want to access any
of these values here, for example, the length
241:05 - we do that through something we call the dot
notation, worse dot length, like that. Console,
241:13 - log outfits and run the code, you can see
that we log out 63. So course dot length gives
241:19 - us back 63. And you've used this dot notation
quite a lot, actually, up until now, even
241:25 - though you probably haven't been aware of
it, you have been using objects all along,
241:29 - like, what are we doing here? console dot
log, what kind of data type Do you think the
241:34 - console is? Well, it's an object. And just
to give you one more example, if let's say
241:39 - we want to log out this array here, well,
then we simply do course, dot tags from the
241:45 - code. When we open the console, we can see
that we are logging out and a radio because
241:49 - this entire array is the value that we get
back when we ask for the tags. Now, one thing
241:55 - I want to point out before we move on that
you can replace this start with an open square
242:00 - bracket, and then add a closing square bracket
and then turn the key name into a string.
242:07 - This is called the bracket notation. If we
run the code, we get the exact same thing
242:11 - back now, there There are reasons for why
you sometimes want to use bracket notation.
242:16 - But we're not going to get into that right
now. Because in the foreseeable future, you
242:20 - are not going to end up in a situation where
you have to do that. So I'm just going to
242:24 - tell you now to use the dot notation. It's
simpler. It's shorter, less code, read less
242:30 - code, right? It's very understandable. It's
actually what most developers prefer to use
242:34 - if they get to truce. So now I've been talking
for far too long. I want you to write code.
242:39 - Of course, this is grim. But that's what we're
all about. So in the next cast, you are going
242:43 - to write your own object, I'll see you. One
thing I like to do, if I'm bored is to search
242:51 - for epic places to live on Airbnb, for example,
castles like this wish list I came across
242:56 - right here, which contains a bunch of more
or less affordable castles to rent
243:00 - across Europe. So for example, this really
neat looking castle right here only costs
243:05 - $190. I mean, that's what people pay for,
like 10 square meters in a hotel room in central
243:10 - London. So pretty cool that you can rent a
castle for that same price. But anyway, the
243:14 - point being that these listings here on Airbnb,
most likely take advantage of the object data
243:20 - structure in order to store all of the data
that they need to present to the user. So
243:25 - this can also be a great exercise for you.
So that we can build up that object muscle
243:28 - memory of yours, I want you to basically create
an object that represents an Airbnb Castile
243:34 - listing, it should contain at least one Boolean,
one string, one number, and one array can
243:41 - contain a bunch more if you want to, if you
want to go above and beyond forever, that's
243:44 - the minimum requirements. And at the end,
I want you to log out at least two of the
243:49 - keys using the dot notation.
243:51 - So go ahead and do this right now. Okay, hopefully,
that went well. Let's do this together. I'll
244:01 - do let hostel equals open and close brackets,
we can use the title level like Chang and
244:10 - my thought like that. That's for the
244:13 - number, I think the price it's very natural
to use price. $190. And what about the Boolean?
244:20 - Which components here naturally lend themselves
well to using a boolean data type under the
244:24 - hood? Well, I think the fact that two of these
are super hosts. And the third is not points
244:29 - to this being a suitable piece of data for
the boolean data type. Because you're either
244:34 - a super host, or you're not. So yes, super
host. This one happens to be true. And then
244:41 - finally, there's the array. What kind of data
here? Would it make sense to place inside
244:45 - of an array?
244:46 - Well,
244:47 - it could be that these kind of bullet points
here are arrays that are pulled out of the
244:53 - underlying data on are kind of the featured
selling points that Airbnb wants to list out.
244:58 - Or, actually, you can see that there's multiple
images here, if you see this carousel indicator,
245:03 - so the images it's very natural to have inside
of an array. And also the reviews, that's
245:08 - definitely a list of many items. So doesn't
matter what you choose. Or if you choose something
245:13 - completely different. The point is just that
I wanted you to write an array inside of an
245:17 - object. So I'm gonna choose images like that,
make that an array. And here we probably have
245:23 - URLs to the specific images, who it might
be I am ri slash aspell, one dot png, empty
245:31 - slash Castile, two dot png, and so on and
so on. I won't bother writing anymore. Now,
245:39 - let's log out to these using the dot notation,
console log caspo dot price, assault log caspo.is
245:51 - Super host, we'll run this. And indeed, we
print out 190 and truth to the console. Meaning
246:00 - we have completed the rate jobs holding this
one. Let's move on.
246:07 - Okay, welcome back. Now it's your time to
render out the players name and his or her
246:14 - chips on the page. So it's a four part challenge.
First, you're to create a paragraph with an
246:19 - ID of player out. Then you're to move over
to the JavaScript and create the player object
246:25 - here at the very top and you have to give
it two keys name and chips. Then you are to
246:30 - move down to where you are grabbing elements
from the DOM and then grab hold of the player
246:35 - l paragraph and store it in a variable called
player L. Then you are to render the player's
246:41 - name and chips inside of playoff. So pretty
big challenge. But you've seen me do it before
246:47 - and you've practice how to work with objects.
So I think you're gonna nail this one. Give
246:51 - it your best shot and then I will show you
how to do it as well afterwards. Okay, hopefully
247:01 - that went well. If not, no worries, let's
do it together. First, we'll do a paragraph
247:06 - here. And we'll give it the ID of player Nashville
like that. Nothing happens because It's moving
247:15 - over to the Java scripts we are to create
the player object. Player equals closed curly
247:22 - brackets are to define its name, my case pair,
use a comma to separate the items. And then
247:30 - ships. Let's say I have $200 in chips right
now, three, grab a hold of the player l paragraph
247:38 - and store it in a variable called player L.
Okay, we know how to do that. Let player L
247:45 - equals document dot get element by ID, passing
in the player dash L, which is what we created
247:55 - right here. At this point, let's console log
out player L. And indeed, we are fetching
248:04 - it from the DOM. Finally, we are to render
the players name and tips inside of player
248:09 - L. We know how to do that as well. Player
l dot text content equals, and here we have
248:16 - to concatenate the string and dig into the
object to find the correct values. So we'll
248:22 - start with the player dot name is Frank, I
have a colon and a space, and then the dollar
248:30 - sign in front of the tips. And then do plus
again, play your dot chips. Now, this is all
248:38 - set up, let's run the project. And there we
go. We have rendered great job solving this
248:44 - challenge.
248:47 - Now that you've learned about objects, I want
to tell you about a specific coding pattern
248:55 - that we've actually been using quite a lot
here that that we aren't going to implement
248:59 - from scratch ourselves in this module. But
since we still are exposed to it, I want you
249:04 - to understand what's going on under the hood.
And that pattern is to create functions inside
249:09 - of objects, something which we also call methods,
because let's say that, for example, we create
249:14 - another key here, we'll just say, Hello, and
then a colon, and then as the value will actually
249:20 - write a function like this, we won't give
it a name, it'll just be an anonymous function.
249:27 - And inside will console log. So that's how
the inner region. And now if we want to invoke
249:33 - this function, we'll do player dot say, Hello,
and then open and close parentheses. If we
249:41 - run the code, now, you can see Indeed, we
are logging heizung to the console. And now
249:46 - the reason I wanted to show this to you is
because Don't you think this syntax looks
249:51 - a little bit familiar, like first a variable,
and then a dot, and then a function that you're
249:57 - calling with the parentheses at the end. Because
actually, that's the exact same thing we're
250:02 - doing here, when we're saying document dot
get element by ID, and the parentheses. And
250:08 - here, we're also passing in a value, but it's
essentially the same thing. And also here
250:13 - down at math dot random, also the same thing,
math is an object, and random is a function
250:20 - on that object, also called a method. And
even our girlfriend console dot log is the
250:28 - exact same thing, object with a method. So
this is not something we are going to implement
250:35 - ourselves in this module. But I just wanted
you to be aware of that. So that when I speak
250:40 - about methods, you know that they are simply
functions that are attached to objects. So
250:46 - with that, let's move on.
250:52 - So you have built
250:53 - your very first JavaScript game congrats with
that this is perhaps the first of many games,
250:58 - you're going to build perhaps the start of
a career as a game developer, I don't know.
251:03 - Anyway, give yourself a pat on the back, you
have learned a ton. And actually, let's do
251:07 - a little recap. So we remind yourself about
all the awesome things you've learned throughout
251:12 - this section. One thing, which was key to
our app, and it's key to basically every web
251:17 - app out there is the erase, we define a card
array. And also when you reassign the array
251:23 - down in the start game function where you
define it with items. And then all the way
251:27 - down at the new card button. You also pushed
to the array, so you're starting to get some
251:32 - serious array skills. Also, we worked with
objects up here we created our player object.
251:39 - And the object, as you remember, contains
key value pairs. And it's also a data type
251:44 - that is used in basically every single web
app out there. The third data type you learned
251:50 - was Booleans. Namely the true and false for
the house blackjack and it's alive variables.
251:56 - we flipped them around. So we set is alive
to true down here and has backtrack set to
252:03 - true down here and thus creating country state
for our game. This brings us to the next important
252:09 - concept you learned what is the if else statements
that are wrapped the Boolean and so many other
252:15 - things. This is key, you cannot build apps
without these kinds of conditional statements.
252:20 - Both the if the else if and the else are absolutely
key in any programming language. And in order
252:27 - to make these if else statements would work,
we used comparison operators, that's the skies
252:32 - in here less than or equal to or triple equal,
they helped us define the conditions as to
252:37 - when we wanted to render the blocks of code
in the FL statement. Moving on, we also did
252:44 - logical operators, the AND operator, which
check that both this condition and this condition
252:51 - was true in order for us to run this code
in the block of the if statement. And something
252:58 - we also learned was the for loops. It was
here in the render game function where we
253:03 - used the for loop to loop through our cards
array and render out each of the cards, again,
253:09 - for loop is just one of those foundational
things in programming, because so much of
253:14 - programming is evolved around looping through
data and doing things based upon the data,
253:19 - whether that's rendering it out making calculations,
sending it off from a server to a client,
253:24 - or just summing it together, for example,
it doesn't matter. It's just something you'll
253:27 - do again and again. So I'm really happy that
you've learned it as early as Now, another
253:32 - useful tool you've learned is the math object.
That allowed us to create this get random
253:37 - card function by using math dot random, which
gives us a number between zero and one and
253:43 - math dot floor, which basically floors the
numbers to the nearest whole number moving
253:48 - downwards. And you build upon your further
knowledge of functions and learned how to
253:53 - use return statements in functions. Because
in this get random card, we had to return
253:58 - values. And that's something you didn't know
before this section, there's still more things
254:02 - to learn about functions. So we'll definitely
continue on with functions in the Chrome extension,
254:06 - we're going to build a bit later. But for
now, just be proud about the fact that you've
254:09 - at least come to the point where you can return
values in function, that's a big, important
254:14 - step. So with all of these things learned,
I completely understand if you feel that you're
254:19 - a little bit on shaky ground here, and that
all of these names basically just confuse
254:23 - you even more, I don't think you should worry
about that, I would have never remembered
254:27 - the difference between comparison operators
and logical operators. When I learned JavaScript,
254:31 - what they are called, doesn't really matter.
The important thing is that you know how to
254:35 - compare two variables, for example, or that
you know how to create a true or false variable,
254:41 - whether that you call them Boolean or true,
false isn't something you should be too worried
254:45 - about right now. So even though this might
look scary, try to not let it scare you just
254:50 - focus on coding as much as you can. Because
over time, these concepts will mature in your
254:54 - mind and become second nature. And actually,
on that note, you are going to get some practice
255:00 - right away. Because before we jump on to the
final project and the Chrome extension, I'm
255:05 - going to throw a few challenges on you, just
so that we're sure that you really understand
255:09 - these concepts, and that you build out that
ever so important muscle memory. So let's
255:14 - go ahead
255:15 - and do that right now. Okay, in this challenge,
you're going to practice objects and functions.
255:24 - So first, you are going to create a person
object that contains three keys, name, age,
255:29 - and country. And the values of those keys
should be set by using yourself as an example.
255:35 - So your name, your age and your country. And
then you're to create a function called log
255:40 - data that uses this person object, it just
grabs it from the global scope to then create
255:46 - a string in the following format pair is 35
years old lives in Norway, obviously, Pear
255:52 - 35, Norway, are pulled from the person object
directly. Whereas the rest as a string that
255:58 - is hard coded inside of the function. Finally,
call log data in order to verify that it works.
256:05 - So go ahead and do this right now. And then
I will show you the solution as well when
256:08 - you return back.
256:12 - Okay, let's do this. We'll do let person equals
open and closed curly brackets. Name, should
256:23 - we pair age 35 and nor right like that, and
then the function log data like that. Here,
256:37 - we will console that log. This string and
you can see the first value is actually pulled
256:43 - directly from person dot name. So we'll do
person dot name, plus, and then S, then plus
256:53 - person dot age. That's less again, years old,
and latest n plus person dot. Like that. Now
257:08 - the final step is to call the function log
beta. run the code. And yes, we can see here
257:15 - is 35 years old and lives in Norway. Great
job. Okay, now you are going to practice conditional
257:25 - statements. So that is the if elsif and Elsa
statements. And the problem you're going to
257:31 - solve is a very common one for train companies
or a bus service, which is that the price
257:36 - of the ticket is based upon the passengers
age. For example, if the passenger is less
257:42 - than six years old, there's a free pass six
to 17 gives a child discount 18 to 26 gives
257:49 - a student discount 27 and up to 66. That's
the age range that pays the full price. And
257:55 - the people over 66 get get the senior citizen
discount. So your job is then to create a
258:01 - conditional statement that accounts for all
of these scenarios. And based upon the age
258:06 - variable up here logs out which discount the
passenger will get. So go ahead and give this
258:12 - a shot and return back to me when you want
to see my solution.
258:18 - Okay, let's do this. I'll start with the F.
And if age is less than six, while then console
258:30 - log free. Else if the next condition is that
age is less than 18. Because novolin practice
258:42 - mean from six to 17. here because it less
than 18. Yeah, that's 17 and below, wherever
258:48 - we've already accounted for up until five.
So the code here will be triggered from six
258:56 - to 17 console dot log. Oh, discount. Okay,
next one elsif. Here we'll do age is less
259:06 - than 27. tall, large student discount, because
this one kind of starts at 18, since this
259:15 - one stopped right before 18. And it should
be up until including 26. That is in other
259:20 - words less than 27. Then we have the full
price orders for people now left in the group
259:29 - who are less than 67. Or in other words, 266
console log full price. And finally, then
259:41 - we have the else we don't need to specify
an IF because In all other cases, the passenger
259:46 - should get the senior citizen discounts like
that. Let's run the code at 15. Yes, we're
259:55 - getting the child discount correct. At 55.
We're getting the full price very good 75,
260:03 - we are getting the senior citizen discount.
So it seems to be working for at least these
260:07 - three things scenarios. And I hope it works
for the rest. So let's move on. Okay, it's
260:15 - time to practice your for loop skills and
your geography skills. Because I've created
260:21 - this large countries array here, which contains
the five largest countries in the world by
260:25 - population size. So it's China, India, USA,
Indonesia and Pakistan. And what you're to
260:31 - do is to use a for loop to log out the following
to the world. First a sentence the five largest
260:37 - countries in the world, and then each of the
countries on a new line with a dash and a
260:42 - space in front of the country name. So you
are to use a for loop and loop through this
260:47 - array here, you can simply hard code out all
of the console logs that wouldn't serve any
260:52 - purpose. So try to remember how to use a for
loop. If you can't remember it, you can look
260:56 - back at previous casts, as we certainly have
gone through it. Or of course, I will also
261:01 - show you the solution afterwards as well.
Okay, let's do this. I'll start with the for
261:11 - loop, because that's the meat of this challenge.
For let i equals zero, we'll start at zero
261:17 - because as you remember, arrays are zero indexed,
and we want to use the index in order to fetch
261:23 - out each of the items. So starting there and
stopping before I reaches large countries
261:32 - dot length, length of list is five. So before
it reaches five, that is four and indeed Pakistan
261:40 - is the fourth index. So that should be right.
And we want to increment upwards. Like that.
261:46 - Here, we'll do console log, and in first the
batch and the space like that concatenating
261:54 - this with large countries, passing in in the
square brackets, the greater variable i and
262:02 - now let's run this code and bring up the console
and indeed, it looks to be working. Now we
262:08 - only need to console log out the five largest
countries in the world Like this, running
262:15 - the code, and yes, it works. Great job.
262:20 - Okay, now I need your help because I have
messed up our large countries array. As you
262:28 - can see, in first place, I have Tuvalu and
in fifth place I have Monaco. However, neither
262:34 - of those countries are large enough to deserve
a spot in this large countries array. Actually,
262:39 - Tuvalu is a tiny island state far out in the
Pacific Ocean with just over 10,000 inhabitants.
262:46 - And Monaco is a tiny state in Europe, that's
smaller than Central Park in New York. So
262:51 - surely, it does not belong in this array.
The first and fifth place belongs to China
262:58 - and Pakistan. So I need you to help me fix
up this large country's rate so that China
263:03 - and Pakistan are added back into their respective
places. And to solve this, you are going to
263:09 - use the fort following tools, first push and
pop, which you've learned earlier in this
263:14 - course. And then their counterparts on shift
and shift, which I haven't taught you about.
263:20 - But that is intentional, because I want you
to Google how to use on shift and shift. And
263:26 - what I will disclose to you is that they are
kind of a mirror image of push and pop, because
263:33 - whereas push and pop will work with the end
of the array on shift and shift works with
263:39 - the beginning of the array. So pop will remove
an item at the end, like this was push will
263:47 - push an item into the end like that. And likewise,
shift will remove an item from the beginning
263:54 - of the array like this, and on shift will
shove an item into the array at the start
264:01 - like that. So with that short explanation,
and Google, you should be able to, I want
264:07 - you to try to solve this challenge. And of
course, I will show you the solution when
264:10 - you return back to the screencast. Good luck.
264:15 - Okay, hopefully that went well. Let's do this.
I'll start at the end. So I want to replace
264:24 - Monaco with Pakistan, then I'll do large countries.com
in order to pop away Monaco, and then large
264:35 - countries push asking in Pakistan. Let's now
console log large countries to see if this
264:46 - works. running the code, and yes, there we
go. Now, to remove this first item here to
264:54 - follow, I'm going to have to use shift. And
here I completely understand if you're confused
264:59 - as to why shift is the name shift. And ns
shift is named on shift. It's about the two
265:03 - most intuitive method names in JavaScript
in my opinion. And one way to think of this
265:08 - is that on shift is a longer word than shift.
So on shift makes the array longer. Let's
265:14 - just us push is a longer word than pop. So
push makes the array longer. Anyway, let's
265:23 - just do this large countries dot shift. Let's
see if we've removed two volumes by running
265:30 - the code now. Yes, Tuvalu is gone. That means
I need to do large countries.on shift and
265:38 - pass in China like that. running the code.
Yes, we have fixed up the large countries
265:46 - array. Great job. Now it's time for a scary
challenge because you are going to check every
265:55 - Friday the 13th. And if so you're going to
log out this spooky face because as you might
266:01 - know, Friday the 13th is kind of a scary date
if you've seen the Friday the 13th horror
266:08 - movies. So you have two variables date of
month, which is meant to be from either one
266:13 - to 31 depending on which day of the month
it is and then a weekday variable which is
266:18 - meant to be Friday or Tuesday or Wednesday
or any of the days in the week. And if it
266:23 - is both Friday and the 13th and only if both
of those conditions are satisfied you are
266:29 - to log out the spooky face. So just remind
you, you have to use the logical AND operator
266:35 - which we learned is symbolized with these
two ampersands. So go ahead and give this
266:41 - a shot right now.
266:45 - Okay, let's do this. We'll do if opening close
parentheses and heroes day of MONTH critical
266:55 - equals 13 if it's the 13th day, and if it
is the week they have triple equals Friday.
267:06 - Then we are going to log out the spooky emoji
like that running the code Nothing happens
267:13 - because it's Friday the 31st. Flipping this
around Friday the 13th. Yes, we are logging
267:20 - out the spooky face. And if we change this
to Tuesday, nothing works out because this
267:26 - time, the first condition was satisfied it
evaluated to true, but the second one was
267:31 - not satisfied. So it evaluated to false. And
the AND operator requires that both the first
267:39 - and the second evaluates to true in order
to execute the code in the body of the if
267:45 - statement. So, great job. Okay, now you're
going to practice returning random numbers.
267:53 - And the problem you're to solve is the rock
paper scissor game, if you try that, it's
267:59 - a game where two people truce with their hands,
either a rock paper or a scissor. And the
268:04 - way it works is that the rock will beat the
scissor, but the paper will wrap itself around
268:10 - the rock so that the rock loses. And if the
matches between the scissor and the paper,
268:15 - the scissor will cut the paper into pieces.
So if those rules were a bit confusing, don't
268:20 - worry about it. That's not the point here,
your only job is actually to create a function
268:25 - that returns one of the random items in this
array when it's called. So you need to work
268:30 - with math dot random in order to achieve this,
go back and watch previous cast. If you've
268:35 - forgotten about that, or search for it on
Google, that's even better. And finally, when
268:39 - you have coded up your solution and want to
see mine, just revert back to this screencast.
268:43 - And I will, of course, show you how to do
it as well.
268:48 - Okay, let's do this. We'll call the function
get ham. And inside of it, first need to generate
268:58 - a random index that we're going to use in
order to fetch out Rock paper or scissors.
269:04 - So we'll let random next like that, equals,
first I'll just do math dot random like that.
269:12 - And then actually, I'm going to return a random
269:15 - index,
269:17 - and then debug along the way, just to be sure
that I understand each step I'm taking. So
269:22 - here, I'll console log, the result of running
the get hand function like that. So now if
269:28 - we run this, we're logging out 0.05, or 0.1,
or 0.07, or 0.927. So a value between zero
269:38 - and one, not including one. So 0.99999 is
the top value, okay? First, then what we need
269:45 - to do is multiply this with three. Now if
we run it, you see that I'm getting a value
269:52 - between
269:54 - zero and 2.999990 2.999, is my current range.
Now, the value I want is either 01 or a two.
270:07 - So I'm not too far from this. And the way
I can get that is by stripping away the decimals
270:13 - by flooring it in other words, math dot floor,
like that. You can do to zero to one, yes,
270:24 - now we are generating random numbers between
zero and two. How can we use that to get back
270:31 - a random hand either rock paper scissor ladder,
simply by doing hands, and then using the
270:39 - random index as the index. Now let's run this.
We're getting scissor. We're getting paper,
270:46 - and we're getting rock. Brilliant, great job.
Now I have a fun little challenge for you.
270:55 - Because you can see this fruits array here,
which contains emoji fruits, basically, three
271:00 - apples and two oranges mixed together, you
are going to take these fruits and sort them
271:05 - onto the apple shelf, or the orange shelf,
the apple shelf is the one at the top here
271:10 - and the orange shelf is the one at the bottom.
They are just simply divs, I've given a little
271:15 - bit of styling. So you are to create a function
that when called puts the apples onto the
271:21 - apple shelf and the oranges onto the orange
shelf. And you should use a for loop, a conditional
271:28 - statement and the text content property to
achieve this. Now, one thing you might be
271:34 - wondering is how do you work with emojis in
JavaScript, and actually, you can treat these
271:39 - as normal strings. It's just as if it said
orange here instead of having the mot. So
271:45 - with that, I wish you good luck, and I'll
see you later when I'll show you my solution.
271:50 - Okay, hopefully that went well. Let's do this
function. I'm gonna call it short fruit like
272:01 - that. And then inside of the function, we
first need to loop through all of the fruits
272:07 - for let i equals zero. I equals less than
fruit, da Thanks. And I should be incremented
272:16 - upwards. Now inside of this, we need to check
at every step in the iteration. are we dealing
272:22 - with an apple? Or are we dealing with an orange
shell do if fruit I, that's the current fruit,
272:30 - triple equals, then I can just copy this apple
here. If it's an apple, well, then we are
272:37 - going to do Apple shelf dot txt content. In
here, we're not going to do just equal the
272:47 - apple, we're going to plus equal because we
want to gather all of our apples here and
272:52 - not wipe them out every time we run this code,
then, I'm going to do an else if fruit I triple
273:00 - equals this time an orange, well, then we
are going to head over to the orange shelf
273:08 - and do text content plus equals the orange.
Now, it would have worked perfectly fine if
273:16 - we just admitted this as well like that, because
in our array, if it isn't an apple, we know
273:22 - that it's an orange. But we might be getting
other erase which some of bananas in them
273:26 - as well. And if so we don't want to put any
bananas in the orange shelf, we want to check
273:31 - explicitly that we are dealing with an orange
before we put the fruit up on the shelf. So
273:36 - finally, we just need to sort fruit to run
the code. Let's do that. And there we go.
273:43 - We got three apples and two oranges neatly
sorted on both of the shelves.
273:49 - So great job. Hey, and welcome to this excellent
where we are going to build the Chrome extension,
273:57 - which is just so freakin cool. Because Chrome
extensions, if you haven't seen them are programs
274:03 - that can
274:04 - enhance your browser experience in Chrome.
This is an example called honey. It's really
274:10 - brilliant. Because what it does is gather
coupons from all over the web. And when you
274:15 - visit a page where you want to buy something,
it gives you whatever coupons it can find
274:19 - online, so that you can save money and it
was acquired by PayPal for $4 billion. So
274:25 - pulling Chrome extensions is huge, because
I mean, everyone uses browsers and and surely
274:31 - what comes out of the box when you use Chrome
surely hasn't thought of every single problem
274:36 - people might encounter when they are using
browsers and browser extensions is our way
274:41 - as developers to build solutions around these
problems. Here's another one, Grammarly. I
274:45 - use it all the time here. So when I write
for so for so for example, when I write tweets,
274:51 - it sits on top of Chrome and checks my spelling
because it has access to what I do on the
274:55 - page, and then suggests how I should improve
my spelling and my writing in general. And
275:00 - this one right here is a lifesaver. It's motion.
And it saves me hours every single day by
275:06 - stopping me right before I tried to enter
for example, Facebook, and it does this with
275:10 - a ton of other distracting sites as well so
that I can focus on what matters, like for
275:14 - example, creating courses on scrambler writing
code or doing productive stuff. So, so cool.
275:19 - If you want to check out more extensions,
you can head over to Chrome dot.google.com
275:23 - slash webstore. There, you can search through
all of them. And also, if you want to open
275:28 - your extensions in Chrome, just click this
puzzle icon in the top right corner and you
275:32 - will see all of your extensions. And here
is the lead tracker. What's that? Well, that
275:37 - is the one we are going to build in this section.
It is based on an insight I had when I worked
275:42 - as a developer in a company called Sen, which
is a provider of price information for people
275:47 - who are shipping containers. Because what
I saw there was that the sales team at that
275:52 - company spent countless hours tracking down
leads or sourcing leads, as they also call
275:57 - it. And that is looking for people online
who might be interested in your product. So
276:01 - what they do is like, browse through a bunch
of pages and look at people and like no, this
276:05 - guy is probably not interested in our product.
This will neither are Yes, here we have a
276:09 - potential customer, let's save this one to
our system. Moving on, this person does not
276:13 - look like a potential customer. But this all
of us. Yeah, and this one does as well. But
276:17 - this one does not look like a potential customer.
So what they then had to do is take these
276:21 - three potential customers and store them somewhere
so that they could reach out to them in the
276:25 - next face. And this is something that and
this is something that basically every single
276:29 - sales representative does, because I mean,
you need people to sell to, so you need to
276:34 - find them somewhere. So early Stryker will
be a tool for these kinds of people. The way
276:39 - it works is that you visit a website, for
example, a profile on LinkedIn, and then you
276:43 - open up the extensions, click on the lead
striker. And there you can see, you get the
276:48 - ability to save input, that is any URL that
you pass into this input field, or hit Save
276:54 - tab. If you hit Save tab or extension heads
over to this tab grabs the URL and saves it
277:00 - in a list and then you can move on to another
page for example, my LinkedIn page and then
277:05 - hit Save time again and boom there we have
the URL to my profile. And then moving on.
277:09 - This is Syndra our CTO in screamer yet again,
we Click Save tab, and his profile URL is
277:15 - saved. And this data is persistent. So I can
close down the app or chrome, turn off your
277:20 - computer on when you come back, it's still
there let you as a sales representative, and
277:24 - then grab these leads and do something else
with it. So this is actually a pretty useful
277:28 - tool for sales representatives. And it's actually
deployed in the browser so that you can use
277:34 - it in the real world. And the point with this
is to give you the powers to do this to actually
277:39 - create Chrome extension that has value and
also give you the skills you need to deploy
277:45 - it to someone's browser. So once you've learned
this, I would really recommend you to look
277:49 - for opportunities. Look for problems you see
out in the world, maybe there's a problem
277:54 - you have or, or someone you study with, or
someone you work with, or just a problem someone
277:58 - tells you about when you come across problems
people have, I want you to think, can I build
278:03 - a Chrome extension to help solve this problem,
because if you can do that, you truly have
278:08 - a superpower. And that will manifest itself
in opportunities that you will get throughout
278:14 - your career, if you're just willing to use
that superpower, which JavaScript and web
278:18 - development is. So this was a long introduction,
I hope you are as excited as me, let's just
278:24 - move on and build your very first Chrome extension.
Okay, in this challenge, you are going to
278:33 - create the basic markup we need in order to
start building our app. So you're to create
278:38 - an input element, which is of type text and
has the ID of input to dash L. And then you're
278:45 - going to create a save input button. That
is when the user will click in order to save
278:49 - the input, make sure to have the ID of input
dash btn. And here, save input should be the
278:55 - text inside the button.
278:57 - So go ahead and do this right now. Okay, let's
do this. I'll start with the inputs, and give
279:08 - the type of text and ID of input L. And the
input element is a so called void or empty
279:18 - tag, it only has an opening tag. So you're
not supposed to create closing tags, because
279:23 - you're not meant to write anything in between
input tags. This user LED is meant to add
279:29 - the input. So this is how you create an input
tag just mentioned, often called void or empty
279:35 - tags, or you'll also hear them referred to
as self closing tax. Anyway, let's move on
279:41 - to the button. button. And it's not a void
tag, it should have a closing tag and an opening
279:48 - tag. And in between, we are going to write
save input and the ID and set here as input
279:56 - dot btn. We now run this code you can see
yes, indeed, we have an input field and a
280:03 - button. Great job. Okay, now you're going
to style our app according to this design.
280:13 - So in the CSS file, which is where you're
going to work, you'll see that I've already
280:17 - styled the body tag a little bit. Specifically,
I've cleared out the the margin, since browsers
280:23 - often add a default margin to the body tag,
I had to set that to zero to neutralize that,
280:29 - because I don't want any margin on the body.
However, I've set the padding to 10. Because
280:33 - I do want a little bit of padding. You can
see here on the body element that there's
280:37 - some space between the edges and where our
elements start. That is the padding that is
280:42 - provided. In here, I've also set a font of
Arial, not as a web safe font, so that one
280:49 - should work without, for example, using Google
fonts in our project as well. So just click
280:55 - on the slide here when you want to see the
sign and click outside of the slide when you
280:59 - want to go back to the code. And I've also
added a little helper text here, which is
281:04 - the hexadecimal code of the green color, which
you can see on the button and on the borders
281:09 - of the input field. Now you can see on the
bottom image here that I've added some text
281:15 - to the input field, the slightly bluish color
in the background here, it's not something
281:19 - you are to configure, that's just default
styling that is added by the browser. So you
281:24 - don't have to think about that. As far as
you know, the background of the input element
281:28 - will be white. Now I'm going to get you started
here with making the input element full width,
281:34 - because that's a little bit unintuitive. And
I want to show it to you. Because as you can
281:39 - see here on the input element, when we enter
text into it, we have a little gap between
281:44 - the text and the edge of it. However, in our
app now that you will see that there is basically
281:51 - no gap. So we have to add a little bit of
padding on the left side, let's say 10 pixels.
281:58 - And there you can see we got the gap. We want
the same gap on the right hand side as well.
282:02 - So I'll do padding right of 10 pixels as well.
Now we have that and you might wonder why
282:08 - I started there. It's a little bit weird,
but let's say that we now want to provide
282:11 - the styling for me This input field to be
full with, well, then I'll do with and then
282:18 - set it to 100%. That means take up all the
available space I have inside of my container.
282:26 - And for the input field, the kind of container
it lives inside of is the body type.
282:32 - So
282:33 - that means that 100% should make the input
field take up the entire body, and the body
282:38 - has a little bit of padding as you know. So
I would expect this to actually stop at the
282:44 - right 10 pixels before the end of our browser.
But actually, it doesn't do that it continues
282:48 - on an actually goes past our browser, which
is a little bit weird. The reason is that
282:55 - the true with this element now is 100% plus
10 pixels plus some pixels, because it includes
283:05 - the padding left and the padding write an
ad stat on top of this width. So that's a
283:11 - problem. And it results in our input field
being wider than our body tag. And we don't
283:15 - want that. So the trick I'll use to avoid
that is something called box sizing. And here,
283:23 - I say they want you to size the box long its
borders, the right border, box, and there
283:30 - you can see now, full width, includes the
padding, as well as the 100% now takes into
283:39 - account the padding. And just make sure that
the entire thing spans across the entire body
283:45 - tag, but not overflowing it. I wanted to show
you that because it's not entirely intuitive.
283:53 - Now you have what you need. Your job is to
use only these two selectors, the input and
283:59 - the button selector and make it look like
the design you can see here on the slide.
284:03 - So go ahead and give that a shot right now.
Okay, hopefully that went well. Now, let's
284:13 - do this together. I'm going to continue with
our input elements, that's here, we'll see
284:20 - that it's very cramped above and below the
text were written in the input field. So what
284:25 - I can do as padding, bottom of 10 pixels,
and padding top, also of 10 pixels. Now we
284:36 - have something that looks much more like what
we have here. Next up, we also need the color
284:43 - on the border. So we'll do border, one pixel
solid, and then use its green color here,
284:54 - like that look good.
284:56 - Now, we can actually continue with the button.
The first thing is the background color, which
285:02 - is green color background and use this green
color again, like that. Okay, so the text
285:12 - is white color, right like that. There's also
padding here as well, which we need to add,
285:19 - there's a little bit more padding on the left
and right hand side, try padding top 10 pixels
285:26 - and padding, bottom of 10 pixels. And then
padding left of 20 pixels. So yeah, starting
285:34 - to look good padding, right 20 pixels. Now,
I actually want to clean up our code a little
285:42 - bit, because you can see we're using this
very verbose way of writing padding spots
285:46 - here. And here. In the body, as you have learned
previously, in this career path, you can use
285:51 - the shorthand. And if all of the top bottom
left right are of the same value, we can just
285:57 - use padding, I can remove all of these and
padding 10 pixels. Here, it's a little bit
286:04 - more complex, but the top and bottom are identical.
And the left and right are identical, what
286:09 - we then can use as padding, and then 10 pixels
for the top and bottom, and then 20 pixels
286:15 - for the left and right. So the first value
kind of becomes to the y axis above and below
286:21 - and the second value becomes the x axis to
the left and to the right. Move this. Now
286:27 - see, it looks identical as how we had it previously,
but we've removed a ton of lines, which is
286:33 - good. Now, another thing on the button is
that has these default borders. We don't want
286:40 - that according to our design. So we'll do
border numb like that. Now it's really starting
286:47 - to look similar, but there's two things we
want to both the text and we need a little
286:52 - gap between the input field and the button.
So font weight to bold, yes. And the gap between
287:03 - the button and the input can be added to either
of the elements. I'm going to add it to the
287:07 - input field, use a margin, bottom and set
it For example, for pixels, there we go. Now
287:17 - we have something that looks pretty much like
what we have. And it's also responsive. So
287:23 - we are ready to move on. Okay, now we are
going to move from the CSS over to the JavaScript,
287:34 - because we have to make our input button work.
And while you won't make it useful in this
287:40 - cast, you will at least have it log out button
clicked when the user clicks it. So you know
287:46 - how to do this, you're going to have to modify
both some HTML and write a function in the
287:52 - JavaScript file, to go ahead and do it so
that when I click the Save button, the console
287:58 - will log out button clicked. And once you
are done, return back to the screencast. And
288:03 - I will show you the solution as well. Good
luck. Okay, hopefully, you remembered that.
288:12 - The way to do this is to create an on click
handler on the button, there, you want to
288:19 - type in the name of the function that you
want to trigger. Let's call this function,
288:22 - save lead, for example, open and close parentheses,
then we'll head over to the index.js file
288:29 - and create that function, function, save lead,
like that. And inside of it, we'll do console
288:36 - log. Like that, we'll run the code, click
the button. And indeed, we are logging out
288:44 - button clicked. Great job.
288:52 - So while this way of writing event listeners,
where we define a function and trigger it
288:57 - via the onClick attribute in the HTML works
perfectly fine out in the wild will most likely
289:02 - see professional developers use a slightly
different technique. So it's important that
289:07 - you learn that one as well. And the way we
do that is by first grabbing a hold of the
289:13 - ID of the element, we want to hook an event
listener onto. So I'll do let input btn equals
289:21 - document dot get element by ID, passing in
the input batch btn. And then what I'll do
289:29 - is input btn dot add event listener like that,
inside of the Add event listener function
289:39 - or method, which is also called, I'll first
specify what kind of event I want to listen
289:44 - for. And here it is the click events, then
I'll write a comma and do something which
289:51 - might look a little bit weird, because now
we are going to define what are we going to
289:54 - do when someone clicks on this input button?
Well, we are going to invoke a function. And
290:00 - in order to invoke that function, we first
have to write it to the function, open and
290:04 - close parentheses and then the curly brackets
and break it onto a new line. And inside of
290:08 - this function, we can write whatever code
we want to be executed when the user clicks
290:14 - on this input button. So here, we'll do console
dot log button clicked from an event listener,
290:22 - like that. And let's change this to button
click from onClick attribute. Now, if we run
290:29 - this code, hit the button, you can see both
this line and this line is executed. However,
290:35 - now we can actually remove this onclick event
listener from our HTML. And some would say
290:41 - that this results in a cleaner separation
of concerns where the HTML doesn't worry about
290:46 - any event listeners, that's all gathered in
the JavaScript. So of course, then we should
290:52 - also remove the Save lead function. And we're
left with this running the code, clicking
290:58 - the button and only this line triggers. So
in the next cast, you are going to get some
291:03 - practice writing this type of event listeners.
So let's dive into it.
291:13 - So in this challenge, you are going to practice
writing event listeners using the technique
291:17 - you just learned. So it's a three part challenge,
where you first are to grab the box from the
291:22 - DOM and store it in a variable. Here you can
see the box, it's just a rectangle that says
291:27 - open the box, you can imagine that this is
some kind of Easter egg on a ecommerce website,
291:31 - where if you open the box, you get a coupon
or something like that. And as for HTML, it's
291:36 - just a very simple div with an ID of box.
And of course, I've styled it a little bit
291:41 - in the CSS file, but we're not going to worry
about that. So when you have grabbed the box
291:46 - from the DOM and stored it in a variable,
you are to add a click event listener to it.
291:50 - And then finally, log out. I want to open
the box when the box is clicked. So if you
291:55 - struggle to remember how to add an event listener,
using JavaScript, you can go back and rewatch
292:00 - how I explained that Or even better, google
it out, and you should find the solution as
292:04 - well. With that, go ahead and solve this challenge
right now.
292:09 - Okay, hopefully that went well. Let's do this
through let box equals document, get element
292:21 - by ID passing in box, and then add eventlistener.
It's box dot add event listener, passing in
292:31 - first event we want to listen for that is
the clinch. And then what do we want to trigger?
292:38 - when the user clicks? Well, it's this function
right here. inside of it, we're going to console
292:43 - dot log, I want to open the box like that.
Let's run the code. Click the box. And yes,
292:52 - it works. Great job. Okay, we are back at
our lead tracking app. Now, of course, you
293:03 - are going to do what I showed you before you
learned about addEventListener, which is to
293:08 - refactor our app, so that it uses the dot
addEventListener. When you click on the Save
293:13 - input button, because this is crimbo, I am
not supposed to write the code. So even though
293:18 - I've already done it, Now, it's your turn
to go ahead and do this right now. Okay, hopefully,
293:28 - that went well. Now, I will quickly do it
as well, we need to grab a hold of the button.
293:34 - I'm going to grab the ID here. And do let
input btn equals document dot get element
293:43 - by ID passing in the ID. Now that we have
that we can do input btn dot add event listener,
293:52 - we're going to listen for clicks. And the
code we want to run. When users click the
293:57 - button is inside of the body of this function
right here. So I'm going to copy this console
294:04 - log, paste it in there. x Now I can remove
the Save lead function. And I can also remove
294:11 - the onClick attribute in the HTML. Like that,
I'll rerun the code and click Save input.
294:18 - And indeed, it works. Great job. Let's move
on. Now, we need to set up the infrastructure
294:27 - for being able to actually save the leads
that we enter into our input field. And for
294:33 - that, we need two variables. First a my leads
variable which should be assigned to an empty
294:40 - array. Secondly, the input l variable, which
should be assigned to the text input field.
294:46 - With that I mean, the input field right here.
So go ahead and create these two variables
294:52 - right now. Okay, the way to do this is let
my leads equals an empty array like that.
295:06 - And for the infidel, you probably did let
input L equals document, get element by ID
295:15 - passing in the input L. However, what I'm
going to do is swap out this let with const.
295:23 - That's weird. Why am I doing that? You might
wonder that is because modern JavaScript developers
295:31 - use both let and const to declare variables.
And now I think it's about time that you learn
295:37 - both of these methods. So we're going to set
the input data const and also
295:43 - the input btn.
295:45 - Now, the main difference between const and
let is that cost cannot be reassigned. And
295:53 - the name kind of hints to that. It says const,
which is short for constant. So whatever you
295:59 - assign it to, should be constant, meaning
you can't reassign it. And if you don't remember
296:05 - what reassignment is, it's when you do input,
for example, equals
296:10 - Hello.
296:13 - This won't work. If I run this code can actually
see assignment to constant variable. I tried
296:19 - to assign the input L, whether it's a constant.
So JavaScript is saying, Ah, not allowed.
296:27 - Now, you might ask, why do we need this? This
seems to be something that just makes it more
296:31 - difficult for us to code because it gives
us less freedom? Well, that is a very good
296:36 - question. So in the next cast, we'll dig into
exactly that so that you properly understand
296:41 - why you want to use both let them const and
actually get some practice using both of these
296:46 - variable types. Okay, let's say that we are
back at our blackjack game, and we have two
296:55 - variables player name and credits. The first
one is a const verse The second one is a let.
297:00 - Now, immediately upon seeing these two variables,
a developer will understand that player name
297:06 - is not to be reassigned. However, this developer
wouldn't only think that credits can be reassigned.
297:13 - Let's actually assume that credits are to
be reassigned further down in the code. So
297:18 - the developer would expect something like
credits equals credits minus 10, for example,
297:24 - and the reason for that is that developers
often use the following to decide whether
297:29 - or not they should use const. Or let. So if
possible, default to using const. If not,
297:35 - use let, if these two lines follow this methodology,
it would mean that it simply wasn't possible
297:42 - to write credits as a const. Because there
is going to be reassigned later down in the
297:47 - code. And thus, we skipped the default of
const, and use left instead. And this is actually
297:52 - the biggest benefit with const. It gives us
a way to quickly signalize to anyone who are
297:57 - reading the code, what we want to do with
the variables. So in addition to expecting
298:01 - that something like this here would happen.
The developer would also be very suspicious,
298:06 - if we saw something like that your name equals
something else down here, because that would
298:11 - mean that the person writing this code mixed
up their let and const, or perhaps didn't
298:16 - even understand it, as we know, this will
give us an error. So with all of this knowledge,
298:22 - and following this methodology, I want you
to do a challenge, which of the variables
298:28 - below should be changed from left to const?
Here, the situation is an ecommerce shop,
298:35 - we have a base price, a discount, shipping
cost and shipping time. At some point though,
298:40 - the details of the shipping changes, and then
you calculate the full price. And finally
298:44 - notify the customer. So go ahead and change
some of these variables to cost. And then
298:50 - I'll show you the solution afterwards as well.
Okay, let's do this. I'm going to start down
298:58 - here on where things are reassigned, it's
easy to see that these are reassignment, since
299:03 - we're starting a new line with just the variable
name, not let in front of it. So here we are
299:09 - reassigning shipping cost and shipping time,
meaning these two can be left. And this is
299:14 - a new variable. So actually, here's the end
of our code and base price and discount, they
299:21 - haven't changed. So they could be const. And
it says here, if possible, use const. So default
299:26 - to const. So then I'll do const and const.
Like that. And the code works perfectly fine.
299:32 - I haven't broken anything. Is there anything
else we can do? Yep, actually, it is. Here
299:37 - at full price, we see that this variable is
only assigned once it's not reassigned further
299:43 - down, just used here in the console log, meaning
that this one also should be a constant. So
299:49 - hopefully, you now understand why we want
to use const. And let, and if it's still a
299:53 - bit confusing, don't worry about it, we're
going to continue using these variables throughout
299:57 - this course. So eventually, it'll be completely
natural for you to switch between these two
300:03 - variable types. With that, let's return back
to our lead tracker app. Okay, we are back
300:13 - in our lead tracker app. And now we need to
make sure that when the user hits the Save
300:17 - input button, a lead is pushed to the My leads
array. For now, we're just going to use a
300:23 - hard coded lead. So www dot awesome lead.com,
for example, and that value should be pushed
300:30 - to my array when the input button is clicked,
go ahead and give this a shot right now. Okay,
300:41 - hopefully, what you did was to here inside
of the body of this function, right, my leads
300:48 - dot push, and then pass in www dot awesome
lead.com. Like that, if we now also console,
300:59 - log out the my leads array like that, we will
actually verify that it works. I'll hit the
301:05 - Save input button. And there you can see,
we now have one lead in the my leads array.
301:10 - If I hit it again, we have two and three and
four. However, it's pretty useless, because
301:16 - we're just pushing the exact same thing to
the array. So let's fix up that in the next
301:21 - cast. Okay, so now we are going to take whatever
the user enters into the input field right
301:30 - here
301:31 - and push that value into the my leads array
when the Save input button is clicked. So
301:39 - push the value from the input cell into the
my leads array, instead of the hardcoded www
301:45 - dot awesome leads.com value right here. However,
I haven't taught you how to actually get the
301:52 - value from the input URL. That is, for example,
this www dot example value right here. So
302:00 - you need to Google that. And that's great
practice because googling is, as you know,
302:04 - something professional developers do every
single day. So here is what I recommend you
302:10 - to Google Play to find. For example, a stack
overflow question and see if you can figure
302:15 - it out on your own. If you don't, no worries,
I will solve this for you when you return
302:19 - back to this cast. So go ahead and do this
right now. Okay, hopefully this went well,
302:30 - let's take a look at how we can find the answer
to this by googling. So we'll take the get
302:35 - value from inputfield JavaScript, which is
my suggested string and just paste it into
302:39 - Google. There, you can see we are getting
a ton of results. The first one is the W three
302:44 - scrolls, I want to go to stack overflow.com.
So I'll click here, we go into Stack Overflow.
302:50 - And in here, we can see the question being
asked, it seems super relevant for us. And
302:54 - it's been viewed two and a half million times.
So it's super relevant for a lot of other
302:58 - people as well. Let's scroll down a little
bit to the answers because that's where the
303:02 - juice is. Here, we can see there are various
methods to get an input textbox value directly.
303:06 - And here, method one, that's probably what
you want. You can see document dot get element
303:11 - by ID passing in an ID and doing dot value.
Oh, that's pretty handy. So how would we go
303:18 - about doing that? Well, we already have the
document get element by ID. And we have stored
303:23 - that in the input l variable. So perhaps we
simply can do input l dot value, then let's
303:32 - now refresh this and do www dot board lead.com.
Save input. And yes, we can see in our console
303:42 - that we have pushed the value we entered into
the input field leads through.com input, and
303:50 - that works as well. Great job, let's move
on. Okay, now that we're able to take the
304:00 - input value, and push it into the Miley's
array, so that we store our data, it's time
304:06 - to set the stage for going the other way around
as well meaning rendering out deletes. And
304:12 - as you might remember, when you want to render
all of the items of an array out, you first
304:17 - need to loop through that array and grab each
of the items. And that's exactly what you're
304:22 - going to do in this challenge. Whoever to
begin with, you are going to work with some
304:26 - dummy data just to make it a little bit easier
for you. So I've pasted in three dummy leads
304:31 - in the my leads array here. So the down here
starting on line 12, you can simply write
304:37 - out a for loop that logs out the items in
the my leads array. Hopefully you remember
304:44 - how to do this. And if not, no worries, I
will of course show you the solution afterwards
304:48 - as well. Go ahead and give this your best
shot right now. Okay, hopefully this went
304:58 - well, let's do this, we'll do for let i equals
zero, because we want to start at the zero
305:05 - index of the my leads array, I should be less
than the length of the array. That's my lead
305:12 - start length, and we want to increment i upwards
with one for each step. Then the inside of
305:19 - the body of the for loop, we'll simply console
log out my leads using the i r iterator as
305:27 - the index. And I run this code you can see
in the console, yes, we are indeed logging
305:33 - out all three of our dummy leads. Great job.
305:41 - Next up, we are going to transform this for
loop from simply logging out the leads to
305:45 - actually rendering them out on the page. However,
in order to do that, we have to actually create
305:51 - that unordered list where we are to render
the leads out. So you are going to do that
305:56 - through a two parts challenge. The first part
is to create the unordered list element, the
306:02 - UL with an ID of ul dash l that's for unordered
list element. And then after you've done that,
306:10 - return back to the JavaScript, grab this unordered
list and store it in a const variable that's
306:16 - called bolwell. Little bit of a weird name
there. But of course, also short for unordered
306:22 - list element with the camelcase convention
we're using in JavaScript. So once we've done
306:29 - that, we have set the stage for actually rendering
the data out instead of just logging it so
306:35 - that we can do that in the following lessons.
So go ahead and solve this two part challenge
306:40 - right now. Okay, hopefully, that went well.
Let's do this together. Starting in the HTML,
306:51 - we need to create the unordered list ul and
closing the tag, giving it an ID of ul dash
306:58 - l that if we run the cold, nothing happens
in the browser because for the element is
307:04 - empty. So let's just move on to the next part.
Here we are to create a const bullet ul l
307:12 - Send it to document dot get element by ID,
passing in URL dash, e l like that.
307:21 - Now, just to make sure that we've done everything
correctly, let's console log out this element
307:27 - from the code, and there we can see it is
being logged to the console. Good job solving
307:34 - this one,
307:35 - let's move on. Now, you are going to render
the leads out in the unordered list we just
307:43 - created using the dot text content property,
which I've used in previous sections. So you
307:49 - are to replace the console log here with the
rendering of each item into the unordered
307:55 - list. Now, what will happen here is that you'll
simply render out plain text inside of an
308:01 - unordered list, for example, www.read.com.
If we run this, this is how it will look.
308:09 - And as you hopefully know, this is not how
we write list items inside of an unordered
308:15 - list. The way to do it originally is to use
Li elements like that, run the code so that
308:22 - we get this dot thing link that it's a list
item. However, for now, you are simply going
308:30 - to render out plain text inside of the unordered
list. So we're kind of doing it wrong first,
308:36 - and then we'll fix it up later. So just go
ahead and render all the leads as plain text
308:43 - inside of the unordered list using dot text
content, even though that's not the correct
308:48 - way to do it. But I wanted to do that first
because the most important thing is to make
308:52 - it work. And then we make it better. That's
the philosophy here. So I'm going to rerun
308:58 - this page so that we don't have any leftovers
from when we looked at the HTML. Now we just
309:04 - have an empty unordered list. Go ahead and
do this right now. Okay, hopefully this went
309:14 - well. To do it, you do, you ll you'd grab
ahold of the unordered list dot txt content.
309:22 - And here you might have been tempted to say
equal my leads, and then the index. Let's
309:28 - see what happens if you try that it only renders
out great lead, which is the final one. The
309:35 - reason for that is that at each step in the
iteration of the for loop, cleared out the
309:40 - entire text and assigned to whatever lead
you're looking at at that step in the iteration.
309:45 - So for a split second, the value of the text
content was awesome lead for another split
309:52 - second, it was epic lead, and then finally,
just cleared out yet again and sub two great
309:56 - lead. And that is what we are seeing in the
browser. Now since the for loop then stopped,
310:01 - it had looped through the entire loop and
then broke out of the loop. So what we rather
310:07 - need to do is plus equals something we also
did in our poker game, if you remember that
310:13 - I don't take the previous value, and then
concatenate it with the current lead we're
310:19 - looking at. So if we run this, you can see
now we have all three leads render out, but
310:26 - it looks horrible, we want to add at least
a space in between them. So if you remember
310:32 - that can do that with plus, and then a space.
Now, it looks slightly better if we shrink
310:39 - in the screen actually break out on separate
lines. But if we enlarge the screen, they
310:44 - are just render out in one line. So this is
still the wrong way of doing it. Since we've
310:49 - just added plain text inside of the unordered
list, we want to add list items. Now we at
310:56 - least know how to take the data in my leads
and render it out on the page. And we also
311:02 - know how to take whatever the user inputs
into the input field and push that value into
311:09 - the lead. So we kind of have a very simple
implementation of each part of the app that
311:14 - we simply need to put together so that we
at least have a working first version. So
311:19 - let's continue on. Okay, now we need to fix
the fact that we are simply rendering out
311:28 - plain text strings like this, inside of the
unordered list. That's that's not what we
311:34 - want, we want to wrap them in a list page,
of course, like this. So in order to do that,
311:43 - let's first try to add, for example, an Li
opening tag before the lead and an Li closing
311:52 - tag after the lead. Run this you can see Oh,
we simply rendered out the HTML tags as plain
311:59 - strings. That's not what we want. We want
our browser to parse this as HTML, so that
312:04 - it can really turn them into list items. And
the way to do that actually, is simply replacing
312:10 - this text content property. with something
called inner HTML, we do that and run the
312:18 - code in there. Now we have them as proper
list items with these bullets that are included
312:24 - on the default styling of list items. So this
means that the browser actually looked at
312:31 - this string right here and understood, okay,
this is actually the starting of a list element,
312:36 - I'm going to avoid rendering that out as a
plain string, and instead convert this entire
312:40 - thing to
312:42 - a list item. So this opens up a whole new
world of manipulating the DOM, suddenly, you
312:48 - can create HTML elements with JavaScript.
So let's take a closer look at inner HTML
312:54 - and give you some practice on how to use it.
So to help you learn inner HTML, I have a
313:03 - really silly example for you here. Because
let's say that you're working on an e commerce
313:08 - website, somehow, your colleague, the HTML
developer, has forgotten to add the buy button
313:14 - inside of the div container, that is a crisis
because your customers out can't buy your
313:19 - product. So you ask the JavaScript developer
to have to do that instead. So you're going
313:25 - to use the dot inner HTML property, to render
out a Buy button inside of the div container,
313:32 - you have to grab ahold of the div container
first, and then use the innerHTML. And the
313:38 - text inside of the button should be by with
an exclamation mark. So go ahead and give
313:42 - this your best shot right now. Okay, let's
do this. So first, I'll look at the HTML,
313:53 - the ID of the container is indeed container.
So I'll you start with const container equals
314:00 - document dot get element by ID passing in
container. Notice we have that we can do container
314:07 - dot inner HTML equals, here, we'll create
the button button by inside of the button,
314:16 - and then the button closing tag. If we run
this, yes, we can see that we have a really
314:22 - neat button already styled because our CSS
developer had indeed did their job. And so
314:28 - have you to give yourself a pat on the back
for doing this. And let's move on. Okay, let's
314:37 - continue on with our e commerce website.
314:40 - Because let's say
314:41 - that you want to thank the user after he's
made a purchase. That's that's a nice thing
314:45 - to do. So what we want to do is that when
the user has clicked the button, we are to
314:50 - render a paragraph under the button, but still
inside of the same container. So this container
314:56 - right here in which the button is rendered
inside of and the paragraph should say thank
315:01 - you for buying. So I'm going to help you a
little bit on the way here by creating an
315:07 - on click event listener inside of the button
that will try to invoke a function called
315:12 - by when the button is clicked. So your job
then is of course to create that by function
315:18 - and have it render a paragraph inside of this
container using dot inner HTML so that the
315:24 - user is thanked. And one thing we don't want
to remove the button, when you render this
315:30 - paragraph, it should be under the button.
Go ahead and give this your best shot right
315:35 - now. Okay, let's do this. We'll do function
by and then inside of the body of the function,
315:46 - we need to target the container yet again,
container an inner HTML. However, if we try
315:53 - now to just render out a paragraph like this,
and run the code, click the buy button, then
316:00 - we lost our button. Because here we just cleared
out the inner HTML, and say we want whatever's
316:06 - inside of the container. Right now, we don't
care about it, we want to set it equal to
316:10 - this paragraph in this paragraph only. What
we instead have to do is use our good old
316:15 - friend plus equals for now, if we run this
call, again, hit buy. And there we go. Thank
316:20 - you for buying neatly placed underneath the
button. Great job. Okay, we are back at our
316:29 - Chrome extension app. And now your job is
to do exactly what I did if you castable.
316:33 - And I replaced the text content with the inner
HTML so that we could render the proper Li
316:39 - tags instead of just plain text inside of
our unordered list. That is this element right
316:45 - here. So go ahead and use your freshly acquired
knowledge about inner HTML to solve this challenge.
316:53 - Okay, hopefully that went well. The way to
do it would be to first add a opening tag
317:02 - before our leads is rendered out with that
with a double quote, and Li and then of course,
317:08 - eight plus out we already have this empty
space previously. We don't need that anymore.
317:13 - But we do need a closing Li tag, if we now
run this, because he Oh, it doesn't work?
317:20 - Well, that is because we're still using dot
text content, we have to change it to inner
317:25 - HTML like that. running the code. There we
go. Three list tags rendered out exactly how
317:32 - we want them.
317:34 - Let's move on.
317:38 - Now that you've finally managed to work with
inner HTML, I'm going to be a little bit annoying
317:44 - and teach you an alternative way of solving
this that doesn't use inner HTML. Because
317:50 - while I prefer to make a lot of the choices
for you as to which technologies you should
317:55 - use to build apps, especially as a beginner,
in this case, it makes sense that you learn
318:01 - it in two different ways, even though we're
only going to proceed with one way in this
318:06 - app. And that is the dot innerHTML. But you
will see this other method being used both
318:12 - in scribus, front end developer career path
and out in the world. So I'm going to teach
318:17 - it to you. And the way to understand it is
to break this line of code into three steps.
318:23 - Because let's have a look at what's actually
happening here. So first, we are kind of creating
318:28 - the Li element. So create element, then we
are setting the text content of that element.
318:36 - Finally, we are taking that expression, and
kind of appending it to the unordered list.
318:44 - Because appending means to add something at
the end of a document. So append to unordered
318:52 - list. So with this, we have the pseudocode
for our solution. Let's now comment out the
318:58 - the original way of doing it, and then write
out in YUI. So the first thing we need to
319:03 - do is create the element that is done by document
dot create element. It looks almost like this
319:14 - document dot get element by ID here. However,
now we are creating something not fetching.
319:20 - And what are we creating? Well, whatever we
place inside of the parentheses, naturally,
319:25 - in our case, this would be an L II element.
And this is how we specified we don't need
319:31 - to wrap it in these HTML tags symbols. Now
we have created the list element. So we need
319:38 - to store it in a variable, I'm going to use
const Li. And next up, we got to set the text
319:44 - content. So we'll do Li dot text content equals
my leads I okay, final step appending it to
319:56 - the UL element? Well, then we'll do ul, oh,
Alt, append, and what do you think will append?
320:04 - Well, Li Li, of course, we'll take this and
pass them in there. Now, if I run this code,
320:12 - you can see it works. However, in my opinion,
this is easier to understand intuitively than
320:20 - these three lines. Because here we get to
see at least the HTML element in a more humanly
320:26 - readable way. But you will come across this
method as well. So now what I want you to
320:33 - do is basically do the same thing as I did
try to make this work with the new method.
320:40 - And with this line of code commented out.
And if you need help, you can use this pseudocode
320:44 - to Google your way to the solution. Or you
can of course, go back and watch how I did
320:49 - it. But after you've done it, I'm not going
to go through it again. Because I've already
320:52 - done exactly that. This is just a little digression
for you to get this practice of doing it another
320:58 - way. And then when you're done, we are going
to return back to this dot innerHTML method
321:03 - here from the next cast, and work a little
bit on the performance of our solution. So
321:09 - give this a shot right now. And then I'll
see you in the next cast. Now it's time to
321:18 - improve the performance of our rendering by
first creating a variable list items to hold
321:24 - all of the HTML, then concatenating, the HTML
element onto that variable so that you after
321:30 - the loop has finished can render all of them
in one go. So just to go through this, this
321:35 - is a three part challenge where you first
create the empty variable, which we should
321:39 - call list items. And that should eventually
hold all of the HTML for the list items. But
321:45 - to begin with, you're going to assign it to
an empty string. And then inside of the for
321:48 - loop. Instead of manipulating the DOM every
single time the loop runs in every iteration
321:54 - of the loop. We're going to rather add the
item this one right here to the list items
321:58 - variable instead of using the innerHTML on
the unordered list itself. And then finally,
322:05 - after the for loop has completed, then you
can take the list items which not contain
322:09 - all of the HTML you need, then render it inside
of the unordered list using inner HTML this
322:14 - way will make our code more performant. And
faster. So go ahead and give this a shot right
322:19 - now.
322:22 - Okay, hopefully this went well. Now let's
do this. First I'll start with the list items,
322:30 - I'm going to have to use a link for that one.
But it's going to be reassigned as you know,
322:36 - for that we cannot use const. So to begin
with, it should be an empty string like that.
322:42 - And here, we are going to add the items, these
guys to the list items variable, instead of
322:48 - setting the innerHTML directly. So this is
simply replacing this here with list items.
322:55 - Now after this code has been running three
times one for each lead in our array, this
323:01 - list items variable should contain all of
the HTML we need. So then we can render it
323:05 - out or doing well l dot enter HTML equals
list items like that. Let's try this run the
323:14 - code. And as you can see, we get the exact
same result, meaning that it works. If you're
323:19 - still a little bit confused of what's going
on here, I would recommend you to for example,
323:22 - console, log out the value of list items so
that you get to see what the value of that
323:27 - string is in every iteration throughout the
loop. And once you feel you have a good grasp
323:31 - of this, we'll move on to the next lesson.
If you find yourself struggling to remember
323:37 - as to whether or not the performance way was
to do dot inner HTML inside of the loop or
323:42 - outside of the loop, you can remember this
sentence DOM manipulation comes with a cost.
323:48 - And with that, you can ask well, if it comes
with a cost is it best to manipulate the DOM,
323:53 - namely, using inner HTML three times inside
of the for loop? Or is it best to just do
323:58 - it one time outside of the for loop? Well,
if it has a cost, you'd prefer to do it one
324:03 - time than three times. So just remember that
DOM manipulation has a cost and look at your
324:08 - code in the light of that. Finally, if you
are a bit confused of what's really going
324:13 - on under the hood with this string that we
are constructing by running through our loop,
324:18 - what you can do is log out list items down
here, underlined 16, just to inspect how it
324:23 - looks in every iteration of the loop. So feel
free to jump in and do that right now. And
324:29 - when you are ready, I will see you in the
next lesson.
324:34 - Okay, now that we have many of the pieces
of our app working, let's stitch them together
324:42 - so that when a user enters a lead and hits
the Save input button, it'll actually be rendered
324:47 - out opposed to us having to actually add the
dummy data from the get go hard coding it
324:51 - here on line one, so I'm going to remove these
lines and your job is split into two. First
324:58 - you are to wrap the code below that is from
line 13 to 17. And a render leads function
325:03 - and then you are to call the render leads
function inside of the event handler for the
325:08 - button clicks. And I'm going to remove this
console right here to make it a bit cleaner.
325:12 - We're just to talk through the logic here.
And what will happen is that when the user
325:16 - adds something into the input field, and hits
the same input, this epic lead, as you know,
325:22 - will be pushed to the My leads array. And
then if we call the render leads, and have
325:27 - this wrapped inside of that render leads function,
it should according to our plan, render out
325:33 - whatever items there are inside of the my
leads rate, which would be much better than
325:37 - what we have now where simply I can hit the
Save input as much as I want, but nothing
325:41 - happens, my lead just stays in the input field.
Not good. So go ahead and try to knock this
325:47 - one out. Okay, hopefully that went well. Now,
let's do this. All right function, render
325:57 - leads, and then the body of the function inside
of that, I will copy this code and also tab
326:05 - it out so that it's easier to read like this
looking good. And then we have to call the
326:10 - render leads function. We do that by doing
render leads and adding the hope and close
326:14 - parentheses. Now if we run the code, www dot
epic lead.com. Save it. Yes, it works. www
326:22 - dot awesome. leads.com, who actually works
really good job. Now we have stitched together
326:28 - the various pieces of our app, we have what
looks like a functional prototype, you should
326:32 - be really proud of yourself reaching this
far to give yourself a pat on the back. And
326:37 - when you are ready. Let's move on. So while
our app now works, it has a little bit of
326:45 - a usability issue, because if I now try to
add a lead here, and hit save, you can see
326:51 - it is indeed saved, the buck still persists
in the input field as well, most likely, we'd
326:56 - want to clear out this input field. So that
is what I now want you to do here on line
327:00 - eight, clear out the input field, though I
haven't told you how to do that. And that
327:04 - is intentional, because now I want you to
Google it. And even better I want you to try
327:08 - to figure out on your own what you want to
write into Google to try to solve this issue.
327:13 - I'm not going to give you the text you are
to paste into Google this time, you just have
327:17 - to try and figure that out on your own and
see if you can find the answer. Because that's
327:20 - a critical skill. As a developer, you will
come across problems out in the wild every
327:25 - single day, and you won't have me there to
tell you what to Google for you obviously
327:28 - have to learn how to think of a phrase to
Google yourself. So go ahead and do that.
327:32 - Try to figure out how you can clear the input
field, write the code, you think works, test
327:36 - it out. And then of course, return back to
the screencast when you want to see my solution.
327:43 - Okay, hopefully that went well. If not, no
worries, let's do this together. So I would,
327:51 - for example, Google clear input value with
the JavaScript here, you can see we get a
327:55 - ton of results, I normally jump to the Stack
Overflow question for let's click into that
327:59 - one can see HTML, how to clear input using
JavaScript. So this user is using a slightly
328:04 - different technique than us with a function
and something called a target. However, most
328:08 - of the time, I hardly even read this, I just
quickly scroll down to the first answer to
328:13 - see if there's some kind of hint there as
to what we are to do. And in here, you can
328:17 - almost ignore all of it, except for the line
in the middle here that says target dot value
328:22 - equals an empty string. That's interesting,
that looks like something we can use. So here,
328:27 - perhaps we can do input l dot value, and set
that to an empty string input l value equals
328:35 - like that, from the code, we'll do the three.com.
Save input. And indeed, it worked. So great
328:43 - job.
328:44 - Let's move on. Okay, now our job is to make
our leads list clickable. Because as you can
328:52 - see here, on the Li item, or in the browser,
this is just plain text, where we want it
328:57 - to be a link so that after a sales representative
has gathered all of the leads, she can click
329:03 - and check them out again at a later stage
if she wants to. So in order to do that, we
329:08 - need to map the lead in an anchor tag, that's
the a tag inside of the list item. So you
329:13 - need to change this expression here so that
my leads is also wrapped in an anchor tag.
329:18 - And then you need to use the href attribute
to point to the specific URL, which is the
329:23 - same as the text you are rendering out. And
I also wanted to make the link open in a new
329:28 - tab. And if you don't remember how to do that,
it's super easy to forget, you'll just have
329:32 - to google it out and figure it out on your
own. So go ahead and knock this one out, and
329:37 - then return back when you want to see my solution.
Okay, hopefully that went well. If not, no
329:46 - worries, let's do this together. So we want
the anchor tag on the inside of the Li tag.
329:52 - So I'm going to add in the same strings as
we are creating the Li elements, an anchor
329:56 - element as well. So like that, and we'll set
the href. Now, just to bits hashtag symbol
330:05 - right here, that I'm going to close the anchor
tag on this side.
330:09 - If we run the code,
330:11 - or add some lead into the input and save it
there, we indeed can see that we get the default
330:15 - link styling. So our link works. Now at this
point, you might wonder well, why am I using
330:19 - single quotes for the value of the href? Why
isn't it wrapped in double quotes, as you
330:24 - might have seen people do other places when
writing HTML? Well, that is because here we're
330:28 - using the double quotes to tell a JavaScript
that we're working with a string. And if we
330:33 - then use a double quotes here as well, then
we're actually ending the string here, as
330:37 - opposed to ending it here. So this is a little
bit complicated when you start having strings
330:41 - that need quotes inside them, then you have
to use either single quotes on the inside
330:45 - and double quotes on the outside or the opposite.
And now this actually becomes even more complex,
330:50 - because what we need to do is inside of here,
replace this hashtag with the my leads, because
330:55 - it's going to point to that URL as well. How
do we do that? Well, now we actually need
331:00 - to close off the string before the hashtag,
because we're going to add a JavaScript variable.
331:05 - So then we will add the double quote, a plus
sign, and then a plus again, and then a double
331:11 - quote, yet again, start this string right
here, of course, then this hashtag now serves
331:16 - no purpose, it's just an invalid character
in JavaScript, we need to replace that with
331:20 - the my leads. So you can remove this space
right here. Now, if we actually console log
331:27 - out, list items, you run the code, and try
to save an input as well again, then you can
331:34 - see we are getting an expression, which looks
like valid HTML, one more thing we need to
331:39 - do is to make the link open in a new tab.
And I told you to Google that, so let's just
331:44 - do that as well. And here, I will just google
href, open in New Tab. And actually, Google
331:48 - is smart enough to just give us the answer
at the top here. You can see it's pulled up
331:53 - from this rapid tables.com article. And here
you can see in order to open a link in a new
331:57 - window or tab at Target equals underscore
blank inside of the age doc. All right, well,
332:03 - I'll do target equals and kind of quotes Do
we need to use now on the inside of the string?
332:09 - Well, we need to use single quotes, underscore
blank Otherwise, we would have escaped out
332:14 - of the string again and into JavaScript land.
And we don't want to do that this is just
332:18 - a string. And we don't need any JavaScript
variables to express it. Now, one thing is
332:22 - that when you try to click these links in
this grammar browser, even though you're using
332:26 - target blank, it won't work properly will
open up a new tab, which just has a super
332:30 - weird URL, that's just a scrim Quirk. So don't
worry about that, if you run this code from
332:34 - your local computer, this anchor tag will
indeed work. And we now we have all of this.
332:40 - And it works for this string is really long.
And great, in my opinion, it's a complicated
332:48 - expression. And I would like us to simplify
it and avoid using these mix of single and
332:53 - double quotes and all of this plus signs.
And maybe we also want to write this expression
332:58 - on multiple lines as you normally do in HTML.
However, that won't work. As you can see,
333:03 - it breaks our entire code and syntax highlighting
seen by the fact that the syntax highlighting
333:08 - is completely off at this point. So in the
next cast, I'm going to teach you about template
333:12 - strings, which will solve exactly that. So
just stay tuned, and I'll see you there. So
333:20 - in order to make this expression a lot simpler,
we'll use what's called template strings.
333:25 - And to make it super clear for you the benefits
of template strings, I'm actually going to
333:30 - comment out this current string, and then
on a new line, create the template string
333:35 - so that you can compare the two. And the way
you turn a normal string into template strings
333:39 - by replacing the quotes that wrap the string
with backticks instead. So let's do that.
333:45 - And pay attention to what happens with the
syntax highlighting of my leads and the plus
333:50 - operators. When we do that, I'm gonna do that.
And that, as you can see, it all just became
333:57 - blue. So now, this is no longer a JavaScript
expression. It's just a string. But we are
334:02 - of course going to fix that after we've looked
at the first huge benefit with template strings,
334:07 - which is you can break it into multiple lines,
something we couldn't do with a normal double
334:12 - quote string up here. So this gives us the
opportunity to write our HTML looks like our
334:17 - HTML looks like in an HTML file like this.
This is a much easier expression for us humans
334:24 - to parse than this one up here. So now we
have that it's time to take these sections
334:30 - here, which previously rendered out the leads,
but now just our plain strings, and simply
334:34 - delete them and replace them with $1, sign
open or close curly brackets, then passing
334:40 - in whatever JavaScript expression we want
inside there. This is how you kind of escape
334:44 - out of the string, and shove a JavaScript
expression into the string my opinion, much
334:49 - easier than what we had here with the quote,
the plus and the expression that another plus
334:55 - then a quote, simply replace all that
334:58 - with
334:59 - this.
335:00 - And now if you want to go even further, we
can add the appearance of the anchor tag in
335:05 - a new line. So that we get this really nicely
formatted expression looks just like it would
335:11 - write it in the HTML file. We now run this
code. Save the input, it works just as it
335:19 - did previously. But now we have removed all
of the ugly pluses. All of this wrestling,
335:24 - we had to do between single quotes and double
quotes and make sure that we used each of
335:28 - them in proper order. Here, we can do whatever
we want, we can even replace this here with
335:33 - a double quote and use single quotes. They're
all that's not a good practice. This just
335:38 - shows the power of the template string. But
now I've been writing code for far too long.
335:43 - The point here is that you should write the
code. That's what scrim is all about. Go over
335:47 - the next few lessons, you are going to get
your hands dirty with template strings. Now,
335:55 - you are going to practice template strings,
or template literals. As people also call
336:00 - it, I prefer template strings though, as that's
just an easier expression. Your job is to
336:05 - take this string, which is a concatenation
of two hard coded strings and a variable and
336:11 - turn it into a template string. I'm console
logging it down here on line eight so that
336:17 - you can see results. If we run it, you can
see that it says hey James, how's it going?
336:21 - chairs pair? So go ahead and change this from
a standard double quote string into a template
336:26 - string. And then of course, I will show you
the solution when you are done. Okay, hopefully
336:35 - this went well. Let's do this. I'll start
by simply replacing the first double quote
336:41 - with a backtick and the last double coat with
a backticks then the entire thing is a string.
336:46 - So now if we run this, it'll say hey, plus
recipient, how's it going? Obviously, not
336:52 - what we want. We want James to be logged out
as well. So we can remove all of this clutter
336:57 - all of these plus in quotes and do dollar
sign open close curly brackets, and then type
337:04 - in recipients run this. Yes, it's now a template
string.
337:09 - Great job.
337:11 - Let's make our email variable even more dynamic,
so that it also can take a sender value, which
337:18 - is the person sending the email. So you want
to create a new variable and call it sender
337:23 - and set its value to your name, then in the
email template string, you are to use your
337:28 - center variable instead of pair, you are going
to replace this text with your variable, then
337:34 - just run the code and you will verify that
it works through the console log. Good luck.
337:43 - Okay, let's do this, we'll create a const,
call it sender. And I'll actually set it to
337:49 - my entire name here, Harold, we're getting
so that we can see that it actually works.
337:54 - When we log it out scaping out of the string
and do center like that, run this, yes, now
338:00 - we are logging out my entire name at the end
of the string, great job. big benefit with
338:09 - template strings is that you can break them
into multiple lines, which is really handy.
338:13 - For example, in our email case, here, you'd
most likely want to write this on multiple
338:17 - lines, like have the hay in one line and have
the text in one line and then the tears and
338:23 - the final line. And this is possible, unlike
with regular strings, like we're using here
338:28 - for my name, prove that let's actually try
to break this into another line. What you
338:32 - see here is that we get this red underlines,
and the syntax highlighting has been completely
338:38 - broken. And if we try to run this, I'll see
that we get a syntax error. So obviously,
338:43 - not something we can do, you have to get it
back on one line. But for our template strings,
338:47 - it will work. And that is the challenge as
well, I want you to break the email string
338:51 - into multiple lines, however you think it
makes sense to do that. And then you are to
338:55 - run the code to see that it works. However,
there's a gotcha here, which is that in the
339:01 - scramble console, you will only see one line,
regardless of how many lines the string actually
339:06 - consists of. Here is an example where I've
created this random string, which is on three
339:10 - different lines, you can see that in the grammar
console, we're logging it out on a single
339:14 - line. Whereas in the dev tools, which I've
opened here in the console that lives in the
339:19 - dev tools, yes, indeed logged out over three
lines. So this is a quirk with the script
339:25 - console is not as robust as the chrome console,
basically. So for this challenge, you will
339:30 - have to open up the original browser console
in order to verify that you've done it correctly.
339:35 - And if you don't know how to open the developer
tools, I will show you now when you're in
339:39 - the scrim, move your cursor up to the header
area of the screen, then right click so that
339:45 - you open this menu, click on Inspect, that'll
open up the developer tools, make sure you
339:50 - are on the console tab. Now, of course, this
is how it works in Chrome, and I'm on a Mac
339:56 - computer myself. So if you are on a different
operating system, and using a different browser,
340:01 - it might be slightly different ways of opening
up the console. But it shouldn't be a problem.
340:05 - If so you just need to google it out how to
open the console on Windows using Firefox,
340:11 - for example. So go ahead now break the email
string into multiple lines logging out and
340:17 - then open the console and verify that you've
done it correctly.
340:22 - Okay, hopefully that went well. The way to
do this is super simple, you can just make
340:29 - this into a new line, let's enter a new line
and can even do this. And sometimes I even
340:34 - like to format this as we're writing a function
body or HTML so that I tab it out. So we see
340:39 - it like this. But you could do like this,
if you wanted or you could do like this. I
340:43 - mean, the point here wasn't exactly formatted
the way I would do it. The point was just
340:48 - to break it into new lines, run the code,
see that in the programmer console is still
340:53 - just one line. Hopefully you saw that, when
you log in and out the original console, it
340:58 - became multiple lines.
341:00 - Great job.
341:02 - Okay, we are back at our Chrome extension
app. And now you are going to do the same
341:08 - thing I did before we went on our little tangent
about template strings, which is to take this
341:13 - list items and turn the string here into a
template string so that you can get rid of
341:17 - all of these pluses all of these double quotes
and auto break it into multiple lines if you
341:22 - want to go ahead and do that right now. Okay,
hopefully this one's well. Let's do it together
341:31 - by replacing the outer quotes with backticks.
And then I'll just go ahead and break it into
341:38 - multiple lines to get better readability.
Like that. Now I can easily see that it's
341:43 - a list item, which wraps an anchor tag on
a new line. And here we still have these clunky
341:51 - plus signs. I'll remove all of those, wrap
the JavaScript expression here, and the dollar
341:58 - sign and the brackets like that. Then really
exact same thing here. Oh, like that. Even
342:07 - break this into yet another line. So now it
looks much better. And if we run this It still
342:13 - works exactly how we want it to. So let's
move on. Now let's take a little break from
342:21 - JavaScript and head over to our index dot
CSS file, because I want you to style our
342:27 - list according to the provider design. And
here is the provider design, you can see the
342:32 - links have the same color as the rest of our
app, we don't have the bullet points, which
342:36 - you can see are here in the current example.
So I want you to fix that. And the three selectors
342:43 - you are to use are the UL Li, and the anchor
tag, and I've set them up for you. So you
342:49 - just have to write a few CSS properties and
values inside of these. And then once you're
342:54 - done, return back to the screencast. Because
then I also will show you my solution.
343:01 - Okay, let's do this. The first obvious thing
is that our list in the design doesn't have
343:09 - these bullets. And the way to remove those
are to do list style. And then none, as you
343:16 - can see, they are gone. Now is the space on
the left hand side, namely the padding, which
343:22 - we have here, which you also want to eradicate
through the padding left and set back to zero.
343:28 - All right, next up, the most obvious thing
is the color of the anchor tags, it should
343:34 - be the green one we have already in our app.
So let's fix that. We'll do this one right
343:42 - here and select the anchor tag color should
be not Yes, pretty good. Let's compare the
343:49 - two Now, what I think is that we have some
more spacing here, there's more spacing between
343:55 - the list items and also a little bit more
spacing above the unordered list. So starting
344:01 - with the unordered list, I think we can give
him margin top like 20 pixels slightly down.
344:07 - And for the Li elements, I think we can give
them also a margin top, maybe then five pixels.
344:13 - Yeah, now they have a little bit more space
in between them. So I think this looks pretty
344:19 - good. So this challenge is done. But before
we move on, there's one thing I want to point
344:24 - out. And that is that we are using very broad
selectors for our CSS, we're basically selecting
344:30 - any unordered list or any list item or any
anchor tag on the page. And this comes with
344:36 - the consequence that if we, for example, want
to add other anchor tags in our app that are
344:41 - outside of this list of leads, for example,
let's say we added an anchor tag in the very
344:47 - top of our app, kind of like a navigation,
if we run this and see says home and we add
344:54 - ultimately, it's in the same styling as ultimately,
this might not be what we want. Oftentimes,
345:01 - anchor tags and links will look slightly different
depending on the context they were shown in
345:07 - what we could do to solve this problem would
be to down here, when we are flipping the
345:12 - color specify that we only want to do that
if the anchor tag lives inside of a list item.
345:19 - And we'll solve that by doing l i and then
a space and then the A. Now you can see the
345:25 - home link has the standard styling was the
anchor tag in our list as our green styling.
345:33 - So this is a way of saying only target anchor
tags that lives inside of list items. However,
345:39 - in this case, we can get away by just targeting
our anchor tags. That's we're not planning
345:45 - to add any other anchor tags across the page.
So we can remove our home tag. And then just
345:54 - target this list item in the easiest possible
way, which is what we have here. So that's
346:00 - perfectly fine to do, as long as we're understanding
the future possible consequences of doing
346:06 - that. And now I think we do that. So let's
just move on. So even though we haven't completed
346:16 - our app, yet, there's still many features
left to build, I want to go ahead and deploy
346:20 - it right away, because I just think it's so
much fun to actually see your app out in the
346:25 - wild. And that gives me a ton of motivation
to continue on, which is why I often like
346:30 - to deploy my projects early as possible. So
in this cast, we're going to prepare our first
346:35 - deployment so that we in the next cast actually
can do the deployment and try our app out
346:41 - in the Chrome browser. As you can see, on
the left hand side here, I've added a couple
346:45 - of new files, namely the icon dot png, that's
just a PNG image, which looks like this little
346:52 - icon right here really suitable for our app
with this dollar sign as our sales representatives
346:57 - are to be reminded that this app will bring
in more dollars for their Commission's so
347:03 - you'll see a manifest dot JSON file at the
bottom here. And you might wonder, Well, what
347:08 - is JSON? I've never seen that before. And
you're right. We haven't talked about that
347:11 - earlier. But don't worry, it's nothing dangerous.
json is short for JavaScript Object Notation.
347:18 - And it's a way for us developers to store
and send data. And it's often used when you,
347:23 - for example, want to send a piece of data
from a server to a client that is to a browser.
347:28 - And in our case, we are using this manifest
dot JSON file to configure our app and to
347:34 - provide metadata about it. So Google Chrome
will read through this and look at the name.
347:39 - Oh, it's called leads tracker will then Google
Chrome will give our app the name leads tracker,
347:44 - it will also see that the version is 1.0.
So that the next time we deploy, and we change
347:49 - this to, for example, 1.10, no, that oh, we
have updated our version. And that's information.
347:55 - That's definitely useful to note for Google
Chrome. One thing you might wonder here is
347:59 - why these key value pairs as you can see,
which you hopefully recognize from JavaScript
348:05 - objects,
348:06 - have keys that are wrapped in quotes, because
if you remember from when we worked with JavaScript
348:11 - objects, previously, we didn't use quotes
around our keys. That's something you have
348:16 - to do when writing JSON. So don't be tempted
to think that this actually is a JavaScript
348:21 - object. Right now, it's not it's just plain
text, but it's using the JavaScript Object
348:27 - Notation for it's mimicking JavaScript object.
And you later learn how to turn a JSON object
348:33 - into a JavaScript object. If this is a little
bit confusing, don't worry about it, it'll
348:37 - sort itself out. As we look more into this.
Let's just move on and look at the two final
348:43 - key value pairs here, we have Manifest Version
that's just telling Chrome, which version
348:48 - of this JSON file we are using, there used
to be a version number one that people used,
348:53 - and then there was a version number two, but
now we have a version number three. So that's
348:57 - version number three. And finally, there's
the action. And that's kind of the meat of
349:01 - our application. It configures. What happens
when the user clicks on our application from
349:07 - the Google Chrome extensions toolbar, let
me show you that. Here, we have Twitter. And
349:13 - if I click on the extensions button up here,
in the top right corner, this little puzzle
349:18 - piece, you can see it opens up all of my extensions.
And when I click out, for example, Grammarly
349:24 - for Chrome, it opens up the grammerly extension.
As you can see, it uses a little icon here
349:29 - as well. So in the action, the default icon
that you provide, this icon, PNG here, which
349:37 - points to this image file we've provided,
will pop up here besides this puzzle piece
349:42 - button, and also the default pop up the index
dot HTML that we provide inside of our action.
349:50 - Well, it's our pop up. And in our case, it'll
simply be the HTML we've been building all
349:56 - along. Now there's one thing we need to fix
just that a Chrome extension will only be
350:00 - as wide as it needs to be. And Strictly speaking,
our app doesn't need to be any wider than
350:05 - this, because that's the way our button needs.
So we need to set a min width on the index
350:10 - dot CSS. And I'm just going to go ahead and
do that min width of 400 pixels, for example.
350:17 - Now you can see, if we go below 400 pixels,
our input field is now outside of the app.
350:24 - So Google, Chrome will understand that we
don't want that we want our app to be like
350:28 - this, this is the minimum size. So now we
finally have everything in place, your next
350:34 - step is to download this code. You do that
by clicking on the Settings icon in the bottom
350:40 - right corner and download as a zip file, download
the zipped folder, you can then open that
350:46 - zipped folder, for example, in your dev directory,
call it whatever you want. Here, you can see
350:52 - all of the files that you recognize along
with a readme file, which you can safely ignore
350:56 - or delete. That's up to you. And when you
have that, we are ready to deploy our Chrome
351:01 - extension. So let's just move on to the next
cast do exactly that.
351:07 - Okay, it is time to deploy our application.
And I'm so excited about this, because I just
351:15 - love seeing products move out into the world
and start solving problems for people. So
351:20 - let's just jump into this. The first thing
you need to do is to head over to Chrome dash
351:26 - slash lash extensions, that'll bring up this
UI you can see right here, which lists out
351:32 - all of your extensions. Now this address here
is a little bit funky, so you can just copy
351:37 - it from the file right here and paste it into
your address bar if you want to do that. And
351:42 - once you're there, I want you to trigger the
developer mode on so just click up here in
351:46 - the top right corner. Then you'll see these
three buttons appear load unpacked pack extension
351:51 - and update and you are going to load an unpacked
extension. So click that button. That'll bring
351:58 - up the file chooser menu. There you are to
navigate to the leads tracker folder that
352:03 - we downloaded from scrim button, the previous
cast, choose that folder and hit select and
352:08 - once you've done that, boom, your lead tracker
is now in the extensions interface and Actually,
352:13 - that's it. Now if we open up another tab,
for example, I'll open up the LinkedIn profile
352:18 - of Frodo, one of the cofounders of scramble,
and then I can click on the puzzle icon here
352:23 - in the top right corner, that will bring up
all my extensions. And there we can see our
352:27 - lead tracker. That is just so cool to see
the little icon here. And if we click, it
352:32 - brings up the user interface for our app.
So that is amazing. Now I can, for example,
352:38 - right in the URL we're at at the moment and
hit save input. And there it is saved to actually
352:43 - now we have something that you can take with
you on every website you visit and save information.
352:48 - But Rob has a critical flaw. Because if I
now close this app, if I click outside of
352:55 - our HTML file, and it closes automatically,
and then want to open it up again, hmm, actually,
353:00 - our leads have been deleted, because that's
just as if we were saving something to the
353:06 - input here. And then seeing it in the list,
and then refreshing the page, and boom, it's
353:11 - gone again. So every time we open up our Chrome
extension, it's a full refresh. So we need
353:17 - to learn how we can store data across each
refresh. How do we do that? That's not something
353:23 - you've learned yet. But it's not that hard.
So over the next few casts, I'm going to teach
353:28 - you exactly that. So that our app becomes
truly useful for sales people who need to
353:33 - traverse the web and gather leads. So let's
just move on and get that sorted out. So in
353:42 - order to fix our problem of storing leads
across page refresh, let's actually open up
353:48 - a browser window and see if we can find a
way to do this, by playing around with the
353:53 - developer tools to here I have wikipedia.org,
we're going to right click, and then hit the
353:58 - inspect so that we open the developer tools.
Here, we're starting out at the elements,
354:03 - so we see the HTML elements of the page. But
where our action happens is over in the application
354:09 - tab, so I'm going to click that. And there
you can see, we get a new list of fancy words
354:14 - here on the left hand side serviceworkers,
storage, local storage cookies, some of these
354:20 - names you might have already heard before,
and they're probably a bit scary. And to be
354:23 - honest, you don't need to know about any of
them. At this point, what we want to look
354:26 - at is this one right here called local storage
354:29 - costs. When we click that, we can see it says
wikipedia.org here, and if we click into that
354:36 - item as well, it opens up this table here
on the right hand side where we have keys
354:41 - and values. And that's something you probably
recognize from JavaScript objects, for example,
354:46 - or even the JSON notation. Here, you can see
that Wikipedia has created three were looking
354:51 - keys and given them some values. So it seems
as if Wikipedia is trying to store some value
354:56 - about me, because these values here in local
storage will only be available for me, they
355:01 - are local to me, when I visit this domain,
this data isn't shared by default with all
355:07 - other users to visit Wikipedia at this point.
For example, you can see portal session ID
355:12 - somewhere long string, that's probably totally
unique to me. But without getting into too
355:16 - many details here. What's important is that
this is kind of like a local database that
355:21 - we can use. So let's try to do that. If we
hit on the console tab, and open up the console,
355:26 - which you've previously seen, and then type
in, for example, local storage dot clear and
355:32 - open and close parentheses to call that function,
and then navigate back to the application
355:37 - tab, you can see that we have cleared out
all of the key value pairs in our local storage.
355:42 - So we were able to interact with these values
using JavaScript. Going back to the console,
355:47 - we can get again, for example, do local storage
dot set item, and then pass in first my leads
355:54 - as a string, and then comma, and then I'm
going to pass in the string of the URL that
355:59 - we visited previously, that is FLOTUS LinkedIn
profile, and then hit enter. If we now go
356:04 - back to application, again, you can see that
we have a key value pair in our local storage.
356:09 - The key is my leads. and the value is the
URL to photos LinkedIn profiles. And what's
356:15 - so cool about this, if I now try to hit the
refresh button, what you'll see is that yet
356:20 - again, Wikipedia adds back these three key
value pairs, but the my leads key and its
356:26 - value persists. And that is exactly the feature,
we're looking for persisting data cross age
356:33 - refresh. So with this in mind, let's move
on and try to interact with the local storage
356:38 - from our index.js file in the next cast. So
I'll see you there. So now we are going to
356:48 - use local storage in our app. And we do that
the exact same way as we did it using the
356:54 - console on wikipedia.org. Whenever we're writing
it in our JavaScript file, it means that we
357:00 - can simply use the local storage variable
that's accessible in the so called global
357:07 - scope. So when you're running JavaScript in
the browser, you have access to this variable
357:12 - wherever you are. We'll then do set item,
open and close parentheses, and then we'll
357:17 - first write the name of our item, we'll call
it my leads, then we'll specify the value,
357:24 - I'll just do, example lead.com. This is the
key. And this is the value. If I now run this
357:34 - code, nothing seems to have happened. But
if we actually delete this entire line, and
357:39 - even rerun the browser, again, so that we
know that the only way to get ahold of that
357:43 - data would be if it has persisted in local
storage. And then try to do exactly that by
357:48 - doing local storage dot
357:50 - get
357:51 - item passing in the name of our item, the
key, and that was my leaks. And then we console
357:58 - log that out, running the code. Ah, there
we go. Example e.com is logged to the console,
358:05 - because our browser remembers that we previously
saved a lead under this name. And now we can
358:10 - get it by is pretty cool, it opens up so many
possibilities. Now I want you to try this,
358:17 - you're going to solve a three part challenge.
First, you are to save a key value pair in
358:21 - local storage in the exact same way as I did,
and then you are to refresh the page and then
358:26 - get the value and log it out to the console.
Finally, I want you to clear out the local
358:31 - storage as well. And as a little hint, I have
added the three methods here to use down here,
358:36 - local storage dot set item, passing in key
and value, get item passing in key and clear,
358:43 - which clears out the entire local storage.
So you need to use all of these three. And
358:48 - one little gotcha before you take a stab at
this, both the key and the value that you
358:53 - pass in here and here need to be strings.
That's a limitation with local storage, meaning
358:58 - you can only store strings. So it is a very
primitive database, but it's what we got.
359:04 - So give this your best shot, and then return
back to the screencast if you want to see
359:08 - me do it
359:09 - yet again.
359:10 - Okay, let's do this. First, we do local storage
dot set item, I'm gonna call this one mine
359:21 - name and set it to compare Harold, Oregon
like that. I'm gonna run the code so that
359:27 - now hopefully this has been saved. Meaning
I can actually comment that out because we
359:32 - don't need it anymore. Now I can do local
storage dot get item, and then pass in my
359:38 - name like that. Actually, I'm going to score
this and a variable called name, just a little
359:45 - bonus here, and then console log out the name,
instead of just console logging out this expression.
359:51 - And we run this you see, yes, we are logging
out my name. Good stuff. Let's move on to
359:56 - the final part of the challenge. I'm going
to comment this out. And then I'm going to
360:00 - do local storage dot clear. Now if I run the
code, apparently nothing has happened. But
360:08 - if we now comment these two lines again, and
run it
360:12 - Oh, no.
360:14 - So my name no longer exists? Well, that's
great, because that's exactly what we tried
360:19 - to do by clearing out local storage here on
line 11. So as far as I can see, local storage
360:24 - really seems to do the job. Let's move on
and learn how to use this properly with our
360:29 - my leads array through that it's implemented
into our app gives us that ever so important
360:34 - persistence feature for our leads. Now there
is one issue with storing our leads in local
360:44 - storage as an array. And that's something
we'd be aware about. If we for example, were
360:48 - to head over to Mozilla developer docs to
read a little bit about local storage. Here
360:53 - you can see the window dot local storage page.
The reason it says window here is because
360:58 - local storage actually exists on this window
object. But you can also use the local storage
361:05 - variable directly. And when writing code in
general, I would say that less is more so
361:10 - that if I can write less code, I will do that.
So that's why I'm omitting the window dot
361:15 - syntax. Anyway, here we can read that the
local storage read only property of the window
361:19 - interface allows you to access a storage object
for the documents origin Oh my God, that's
361:25 - just really complicated, in my view, especially
for a beginner. So let's scroll a bit down
361:29 - and read about what it actually does down
in the description. The keys in the value
361:33 - stored with local stores are always in the
UTF 16. The Home Screen format, what the hell
361:39 - does that mean? I think UTF 16 domstring.
That is some hardcore stuff. But we are not
361:45 - going to worry about all that the only thing
that matters is string, we at least know what
361:50 - that is. And as you can see here, as with
objects, integer keys are automatically converted
361:55 - to strings. Okay, so it seems like like actually,
everything that is stored inside of local
362:00 - storage has to be strings. Well, that's a
problem because we were expecting to store
362:04 - this array here. So how do we do this? Well,
to get someone to explain this was in an easier
362:09 - way, I would just google out our problem store
array. In local storage, and look for the
362:15 - first StackOverflow question, how do I store
an array in local storage? Okay, that's our
362:19 - problem as well. And instead of fine reading
the question, I just jumped to the answer
362:24 - immediately because I'm impatient. And there
you can see a very straightforward explanation,
362:28 - local storage, only support strings, use JSON
dot stringify and JSON dot parse. Okay, here
362:35 - we can see some code. And we recognize this
local storage dot set item, and then passing
362:40 - in the key. And then instead of just passing
in the value, which here should be the names
362:45 - array, they are doing JSON dot stringify.
And passing in the names array in that, it
362:51 - seems as if this JSON dot stringify takes
the array and turns it into a string. And
362:56 - likewise, on the other side, when they are
to fetch data from local storage, they use
363:01 - local storage dot get item names, but then
wrapping that entire expression into JSON
363:06 - dot parse. So that seems to go the other way
around from string to array. Okay, so actually,
363:13 - let's just try this. Let's pretend that this
is our array in local storage, we have one
363:20 - lead here. And as we read in local source,
everything is strings. So we have to turn
363:26 - this into a string, and we can use that with
the backticks. Like that. Now, this is a string.
363:31 - And the problem here would be that, let's
say that we fetch this from local storage,
363:36 - and we want to push another leads to the array.
And we try to do that with my leads dot push
363:42 - epically lead.com. From this, if we get an
error, my leads dot push is not a function.
363:51 - That is because the push method doesn't exist
on strings, it only exists as a method you
363:57 - can use on arrays. So what we then have to
do first, here, we've gotten the data from
364:01 - local storage. Now we need to do what our
friend over at StackOverflow did, which was
364:07 - to parse the entire thing. So we can do my
leads, equals JSON dot parse, and then pass
364:17 - in my leads here. Now, after he push, log
out my leads, I guess now we can see now what
364:28 - worked, how about if we want it to go the
other way round, this here, where we're actually
364:32 - stratifying the array so that we can save
it in local storage?
364:38 - Well, this will be this situation here. We
do my leads equals JSON dot stringify. And
364:46 - then passing in my leads, we now run this
code in the console, it kind of looks like
364:52 - every so maybe not the best example. But what
we can do here is we can type of before my
364:58 - leads, then we'll ask JavaScript to tell us
which type is this variable here. If we run
365:04 - this easy, we get string. So by using the
so called JSON methods, mostly stringify.
365:10 - And the parse and passing in our data, we
can flip back and forth between strings and
365:16 - arrays. And also obviously, if we used a JSON
object like this with the curly brackets,
365:22 - it would turn it into a JavaScript object
and the other way around, and that's actually
365:26 - a more common use case. But in our case, we
have an array to work with, and it does the
365:32 - job perfectly well for a race as well. Okay,
now it's your turn to practice. I'm going
365:37 - to turn this back into a string and give you
a set of instructions. Okay, you are going
365:46 - to do these four steps. First, turn the my
leads string into an array, then push a new
365:53 - value to that array. Then turn the array into
a string again. And finally console, log the
365:59 - string using the type of that you just learned
to verify that it's actually a string. So
366:04 - go ahead and give this a shot right now.
366:08 - Okay, hopefully this one's well let's do this.
First, we'll do my leads equals a song based
366:20 - on parse passing in my leads not to turn it
into a proper array again. Now that we have
366:28 - it as an array, we can do my lead stop, push
it to calm Okay, we have to turn it into a
366:37 - string again, we do my leads, reassigning
it to JSON string if I my leads. And finally,
366:47 - console, log out type of my leads from the
code and we get string in our console, just
366:56 - as we wanted. We have gone from string to
array back to string again. Great job. Now
367:06 - you are going to implement the first part
of our local storage feature and that consists
367:11 - of saving The Maya leads array through local
storage. So that should happen here on line
367:17 - 11. Right after you've pushed the new lead
to the My leads array and cleared out the
367:24 - input field, then then we are ready to actually
save it to local storage. And you have to
367:29 - remember to use the JSON dot stringify when
saving it, even though the browser we're using
367:34 - might be kind to us and actually do this for
us. If it notices that we haven't done it.
367:39 - We want to be explicit about this so that
we remind ourselves that we know the difference
367:43 - between working with just plain text or a
proper JavaScript array. So remember to do
367:49 - that. And once you've written your solution,
you should run the code by filling out the
367:54 - input field and hitting the Save input button
because this line at the bottom of the function
367:59 - will also be run, and that heads into local
storage and get the item that is called my
368:05 - leads. So if your implementation has worked,
this console log should log out whatever you've
368:10 - saved to local storage as well, because my
leads is actually the key we want to use in
368:16 - order to save our array. So use this as the
key. So go ahead and do this. And I will,
368:22 - of course, show you the solution when you
return back to this cast.
368:29 - Okay, let's do this. First, we'll do local
storage dot set item. And here, we first need
368:39 - to specify what key we want to save our item
under. And that is, as I said, here, my leads.
368:45 - So we'll do my leads, and then a comma. And
then what we actually want to save. Now you
368:51 - might have been tempted to simply do my leads
like that grabbing the variable called my
368:56 - leads. But as I said, we need to use JSON
stringify to turn this into a text string.
369:02 - So we'll do JSON dot stringify and wrap the
array inside of the parentheses of the stringify
369:13 - method. There we have it, let's run the code.
Try to add a lead, hit Save input. And there
369:21 - we go. As you can see, in the console, we
are indeed logging out something that looks
369:26 - very much like an array with one item of awesome
lead, which is exactly what we wanted. Great
369:33 - job. Let's move on. So now we are able to
set items in local storage, aka we are saving
369:42 - leads to local storage. So that we can, for
example, do awesome leave and epic leave and
369:49 - then see that yes, they are indeed logged
out. Because we have fetched the item from
369:55 - local storage here. And actually, you can
even open up the developer tools here on screen
369:59 - bar, and click down to see w zero.script.com.
And there you will see my leads as the key
370:07 - and the values as well. And the reason it's
c w zero.scrambler.com is because that's actually
370:14 - the domain for this mini browser under the
hood, whatever that screen by magic, don't
370:18 - worry about that right now, just know that
you can access it by choosing that domain.
370:23 - Now, there's one big problem here though,
which is that if we now refresh this page,
370:27 - again, boom, our leads are gone. Or actually,
they're not gone, they still exist down in
370:32 - local storage. However, we haven't written
the code for heading into local storage, fetching
370:37 - out the leads, and then displaying them. When
we are refreshing the entire page, we're actually
370:42 - not doing anything, we're just setting the
my leads array to an empty array. And we're
370:46 - not even triggering the render leads. So there's
multiple things we need to fix up here. But
370:51 - we're going to start small as usual, you are
going to basically just try to get the leads
370:56 - from local storage, and then store that in
a variable, which I would call leads from
371:01 - local storage, and then log out this variable.
So now I'm going to close the console. And
371:07 - before you go, I want to remind you about
the JSON dot parse method that you learned
371:12 - earlier, because you want to use that to parse
the string you get from local storage so that
371:17 - you turn it back into an array, this might
be a little bit difficult, but just give it
371:21 - your best shot and then I will show you how
to do it as well. Okay, hopefully that went
371:32 - well. Let's do this. We're going to do more
or less the exact same thing we're doing here
371:35 - to begin with, which is basically local storage
dot get item passing in my leads, whether
371:44 - we need to parse this, so I'll do JSON dot
parse, and then parentheses around this inner
371:53 - expression right here and then store this
in a variable called leads from local storage
372:01 - like that. Now we can console log out leads
from local storage. We run the code and you
372:10 - can see there we are logging out the array
With the leads that we know that we had here
372:16 - in our local storage, if I now do local storage
doc clear right above this line and run it,
372:24 - we get no. And now you're probably wondering,
Well, what the hell does no mean. And as you
372:29 - learn in the next lesson, no is a so called
falsie value that we developers use to signalize.
372:36 - emptiness. And here, the developers behind
local storage. That is, the people over at
372:41 - Google who have implemented local storage
into Chrome have made it so that it returns
372:47 - null. When we ask for a key that doesn't exist.
And actually, this is the case for all browsers
372:52 - because they have followed the same specification.
However, this means that we'll end up in a
372:57 - situation where this variable leads from local
storage is either No, which as I said is a
373:03 - falsie value, or it is an array, which is
a so called truthy value. So we're in a situation
373:09 - where we have to act upon a variable that
is either truthy or falsy, just not the same
373:15 - as true and false. Meaning we have to dig
deeper into what exactly truthy and falsy
373:21 - means. And we'll do that in the next lesson.
373:28 - Okay, so let's learn about truthy and falsy
values. So let's say that we, for example,
373:36 - have a slot machine up. So we have a constant
credit, that's how many credits you as a player
373:43 - have. And then we need to check if credit
is more than zero, well, then you're allowed
373:49 - to play the slot machine. So we'll log out
let's play with a slot machine emoji. And
373:55 - then else, this means that your credit isn't
over zero. So that means that you have to
374:00 - be at zero, then we'll console log out. Sorry,
you have no credits, like that. Now, if we
374:11 - run this one time, could see sorry, you have
no credits, it's logged out. Because credits
374:16 - was zero, this would evaluate to false credits
is not more than zero, meaning JavaScript
374:23 - would jump to the else clause. Wherever if
we change this to 12, then this expression
374:31 - 12 greater than zero would evaluate to true
and this block of code would be run. Now,
374:40 - JavaScript isn't really that strict about
what you shove into the condition here. Actually,
374:45 - if we only shove them credit like that, and
try to run this again, you can see that we
374:51 - are still logging out let's play. So even
though this would be evaluated to 12, when
374:55 - it's shoved into a conditional statement,
as this JavaScript will then again, translate
375:01 - 12 to true.
375:04 - Likewise, if
375:06 - credits zero, and we run the code, you can
see, sorry, you have no credits is logged
375:11 - out, because this would be translated to zero
first, and then JavaScript will say, Oh, no,
375:17 - that's a falsie value. So I'm going to translate
that out to false. So where you before learned
375:23 - about true and false values, you now have
to understand
375:27 - truthy
375:29 - and falsy values. Let's try another one. For
example, YOLO, just a screen. What do you
375:36 - think that will be? When I run this code?
What will be logged out? Just take a guess.
375:41 - Okay, let's run it, we can see let's play
is log that. In other words, YOLO, or this
375:48 - string, right here is a truthy value, because
JavaScript turns this into true in the condition.
375:54 - And as well if we pass in an array of random
items from the code, that is also a truthy
376:03 - value. Okay, let's try another one. Let's
do an empty string from the code. That's a
376:11 - falsie value, because it got translated into
false, meaning this block of code didn't run
376:18 - JavaScript, jump to the next block the else
clause and blocked out sorry, you have no
376:23 - credits. So let's go back to just adding credits
here so that our a fellow makes sense. And
376:29 - then at this point, you might feel that truthy
and falsy values is really complex, because
376:35 - how will you keep track of all of these truthy
and falsy values? It seems like, there's a
376:39 - ton of things to remember. Luckily, though,
it's not that hard. You essentially have to
376:45 - remember, these six values, they are the full
c values in JavaScript,
376:51 - false,
376:52 - zero, an empty string, no undefined. And this
weird thing right here non short for not a
377:01 - number, and out in the real world inside of
conditionals. In most cases, you'll work with
377:07 - either false null or undefined. So actually,
this non here is rarely ever Use, which is
377:13 - why I'm not going to talk anymore about it.
Null and undefined though, deserves a little
377:18 - bit of time, because a lot of developers are
confused about these two, and they mix them
377:22 - together. Now let's look at the similarities.
First. They're both primitive data types than
377:26 - just like strings, numbers and Boolean. And
they're also both ways to signalize emptiness.
377:32 - However, on high level, the core difference
is that no, is how you as a developer signalize,
377:41 - emptiness, or it's undefined is how JavaScript
signalizes emptiness. So you will use no as
377:49 - a developer, it's useful tool where it's undefined
is something you'll be exposed to, because
377:54 - JavaScript will tell you from time to time
that what you're looking for is undefined.
377:58 - Now let's see this through the lens of an
example. That'll help us see the difference
378:02 - between the two. Like, you'll sometimes see
developers and declare variables and assign
378:07 - them a small, let's say you are creating a
live streaming app, and you have current viewers.
378:13 - And that's set to null meaning that no people
are watching the live streams at the moment.
378:17 - However, a bit later, a few viewers might
pop up when you might want to do viewers equals
378:22 - and then an array of Jane and next, like that,
the reason this can be useful way of describing
378:30 - the situation in terms of how many people
who are watching the stream is because you
378:34 - might want to act upon whether or not there
are people in the stream. So if current viewers
378:41 - and you might want to do something, for example,
notify the live streamers that people are
378:45 - watching. So go ahead and turn on your live
stream. Let's all log we have viewers like
378:52 - that. Now this block of code will only fire
if current viewers has been set to an array.
378:59 - So now can see it'll be logged out. And let's
say you a bit later lose all of yours you
379:05 - set at the mall, run the code, nothing happens,
because no is a falsie value, meaning that
379:12 - this will be false. worse. The array here
is a truthy value. So when current viewers
379:20 - equals that array, except to drew this block
of code is run. Now here you can see that
379:27 - null is a useful way of signalizing emptiness
because an empty array wouldn't do the trick.
379:33 - If we run this code, you can see we are indeed
logging this code because current viewers
379:38 - is an empty array, which then again evaluates
to true. So it's better to use
379:45 - null here is how you as a developer can symbolize
emptiness, and act upon whether or not a variable
379:52 - is empty. Let's now look at undefined and
see how JavaScript uses that to signalize
379:57 - emptiness as well. And we can do that by simply
removing everything except let current viewers,
380:05 - we now create a console log current viewers,
which has been declared but not assigned to
380:12 - a value. When we run this, we'll get undefined
for JavaScript tells us that this variable
380:18 - is undefined or kind of like empty. Likewise,
if this, for example, was an object, and you
380:25 - tried to log out the key that doesn't exist
random key using the dot syntax, you'd also
380:32 - get undefined. JavaScript tried to look for
this, but it was completely empty. Here, if
380:38 - it is an array with one item, and you try
to look for the item at index five, run this
380:47 - again, JavaScript says undefined. So this
way, when you see either null or undefined
380:52 - in your code base, it should provide you with
a hint as to whether this is JavaScript trying
380:57 - to symbolize emptiness, or if there's a developer
who's written that code, and has tried to
381:02 - signalize emptiness. So that was a long walkthrough
of the differences between null and undefined.
381:07 - There's more to it also, but I don't think
we need to dig deeper than this. Let's wrap
381:11 - up this cast. And in the next one, I'm going
to teach you a neat little trick to check
381:16 - if a value is truthy, or falsy, which you
can use whenever you are in doubt. And then
381:20 - I'm going to stress test your truthy and falsy
skills. So let's move on. If you ever wonder
381:29 - whether a value is truthy, or falsy, you can
check it through writing Boolean, open and
381:35 - close parentheses and then pass in whatever
value you want to check inside of those parentheses.
381:41 - Here we'll do Hello,
381:44 - that's a
381:46 - store this in a variable called True or false.
Now console log, true or false. On the code,
381:54 - you can see that we get true meaning that
Hello evaluates to true removing the content
382:00 - of the string running it again, we get false
because as you hopefully remember, an empty
382:04 - string is a falsie value. Now with this in
mind, you are going to do a set of challenges
382:11 - which I said in the previous casts So, here
they are, it's six console logs. And inside
382:17 - of them, we are checking a bunch of values
for their boolean value. So each of these
382:22 - lines will log out either true or false. And
your job is to hear after these two flashes,
382:29 - right, either true or false, depending on
what you think will be logged out. So go ahead
382:34 - and give this a shot right now.
382:36 - Okay, let's do this. So an empty string, as
we remember, that is a falsie value. So this
382:47 - will log false. Here, I'm trying to trick
you because zero is indeed a falsie value.
382:54 - But this is a string, which contains one character,
it's not zero. so this will be true. Here.
383:00 - 100. That's a truthy number.
383:04 - No,
383:05 - hopefully, you remember it, the bad is a faulty
value. So this will be false. And here, I'm
383:09 - also Frank, trickier, zero wrapped inside
of an array, whilst zero is a falsie value.
383:16 - An array is a truthy value. So this will be
true, here, minus 00 is a falsie value. And
383:25 - whether it's minus or plus zero, doesn't change
that. So this should be false. Let's run the
383:31 - code. And we get false, true, true, false,
true, false, correct. Now we'll return back
383:38 - to the Chrome extension. And you'll use these
truthy and falsy skills in order to build
383:43 - a conditional for the leads we have stored
or not stored in local storage. So let's move
383:49 - on. So now that we're able to check if we
have any leads in our local storage, and if
383:58 - so, we parsed those leads so that we get him
as a JavaScript array, we are ready to act
384:04 - upon whatever data we get here. And first
lesson, look at what kind of data we can get.
384:10 - Because there's essentially two situations
we need to account for. One is this one right
384:15 - here, where the my array and local stores
gives us back some data, for example, this
384:21 - array right here, if so, we have something
to work with, and we can render it out instantly.
384:26 - But then there's the other situation, which
is the one right here where actually there's
384:32 - no data in the my leads key in local storage,
and actually the key doesn't even exist. If
384:37 - so, we know that we get back Nall for that
as a falsie value. And this is a truthy value.
384:44 - So then the question is, what are we going
to do in these two cases? Well, if the value
384:48 - is no meaning that there's no leads stored
in local storage, well, we're not going to
384:52 - do anything, because there's no point trying
to render out any leads. If there's no leads
384:56 - that are saved there initially. So then we're
just going to ignore it not do anything. But
385:01 - if we find a couple of leads, if we get an
array back from this expression right here,
385:06 - then we need to first set my leads to whatever
leads, we are returning back, and then call
385:14 - the render leads function, because the render
leads function takes the leads in the my leads
385:20 - array, and renders them up. Because of course,
that's what we want to do, we want to show
385:24 - the user whatever we found in local storage.
So here is the challenge formulated, first
385:31 - check if leads from local storage is truthy,
that's this variable right here. If so, set
385:38 - the mile leads variable, this one up here
to its value. And by that I mean the value
385:44 - of this variable right here, the leads we
have fetched out from local storage, and then
385:49 - call render leads. So this might be a little
bit of a difficult challenge, but give it
385:53 - your best shot. And then I will show you the
solution as well when you return back to the
385:57 - screencast.
386:00 - Okay, hopefully this one's Well, let's do
this, we'll do if leads from local storage,
386:11 - that's actually everything we need to do.
Because this evaluates to either true or false
386:16 - the expression. And if it's a true thing,
this code will be run. If it's a falsie, then
386:22 - JavaScript will just jump over all of these
lines and continue down here on line 16. So
386:27 - inside of here, we are first going to set
my leads to this newly value we've just fetched
386:32 - out my leads equals leads from local storage.
And then we're going to render leads like
386:42 - that. If we run this now, you can see nothing
happens. That's because at this point, local
386:50 - storage is most likely No. Let's just log
it out to verify that. Yes, we're indeed logging
386:55 - out No. What we then can do instead is actually
add awesome lead and epic lead to our list.
387:05 - Now both of these should be saved in local
storage. We should be in this situation right
387:10 - now. So if I refresh Yes, now we have persistent
our leads across refresh, that is so cool.
387:19 - So give yourself a pat on the back, you should
be so proud of yourself reaching this far,
387:23 - you're now working with a small database,
basically. And that's a huge step towards
387:27 - becoming a professional developer. Now, we
need to fix the fact that we can't delete
387:36 - our leads. Because obviously, that's a feature
we need. Let's say that I'm a sales development
387:41 - representative. And I'm gathering leads like
this, I have four leads at this point. And
387:46 - I want to go ahead and contact these people
or maybe move this data over into a spreadsheet,
387:50 - for example, so that I again, can go out to
the world wide web and churn through leads
387:54 - on LinkedIn and save them to my Chrome extension,
well, then I obviously need to get rid of
388:00 - these existing leads, so that I get a clean
slate to start with. But now that's not possible,
388:05 - I can refresh this as many times as I won't,
it'll just continue to store my leads. So
388:10 - we need a delete button, I need something
that looks like this. And that is what you
388:15 - are going to do in this challenge, you are
going to style this delete button. And then
388:19 - later on, we're going to write the code for
its functionality as well. But first, we have
388:25 - to create the button in the HTML. And I'm
just going to do that for you. So like that,
388:31 - delete all. And as you can see, if we render
this out, you can see that it's actually looking
388:36 - pretty good already. It has the default button
styling that we have added in our CSS here.
388:43 - But we want it to be kind of the inverse of
the Save input button, so that you properly
388:48 - see that it's something different. And in
order to target that button, we need to give
388:53 - it an ID of delete dash btn like that. Now,
before you start writing your code inside
389:02 - of the Delete btn selector right here, I am
going to do one change on the button as a
389:09 - whole. Because actually, this button, which
you can see in the slide has a slightly different
389:15 - styling than this one here. And that is that
the border is actually not Mum, it's actually
389:21 - one pixel solid. And then the screen color.
Like here, I can see both buttons got one
389:30 - pixel added to its border. If I remove this,
you'll see that the buttons become slightly
389:35 - smaller, they shrink and slightly like that
with zero. And they come a bit larger if I
389:40 - do one. And let's just try a different color
here, red there, you'll clearly see it with
389:47 - one pixel. And with zero pixels, we want one
pixels of the green color, because that's
389:54 - needed to get this green border around this
delete all button. So now we are ready you
390:02 - are to style a button according to the provided
design. And you're only going to apply the
390:06 - styles inside of this delete btn id selector.
So go ahead and do this. And then of course,
390:12 - I will show you the solution as well, when
you return back to the screencast. Okay, hopefully
390:18 - that went well. Let's start. The first obvious
obvious thing is the background. It should
390:26 - be white, not green. So I'll do background.
White, right. Okay. Now, we also seemingly
390:33 - lost the text. But that's not the case, it's
just white, so it blends in with the background.
390:39 - So we need to change the color as well. And
for that, we're going to use this green color
390:44 - up here and paste it in. And there we go.
As easy as that. With that. Let's move on.
390:54 - Now we are going to make our delete all button
actually work. So you'll do that through a
390:59 - three part challenge. Pretty big one, actually.
But first, I'm going to give you a little
391:04 - mini challenge. And that is this leads from
local storage here. Should that be defined
391:09 - as a lead? Or do you think we should change
it to a const? Just look at what we're doing
391:13 - with it down here on line eight and line nine
where we are using it and take your best guess
391:17 - as to whether we should change it or not.
And the answer is that Yeah, actually, we
391:24 - do want to change this to a const because
we're not reassigning it here. And if you
391:29 - remember from previously, it's a good practice
to if you can use const then use cost because
391:34 - it enforces strictness throughout your code
base when when another developer comes in
391:38 - here or you in two months and looks at this
leads from local storage and see Oh, it's
391:43 - a constant, then I know that this will not
be reassigned further down in the code. So
391:47 - that was just a little digression so that
we got to clean up this little variable inconsistency
391:53 - here. Now let's move on to the major challenge.
As I said, it's three part. First, you're
391:59 - going to grab a hold of the delete button
and stored in a delete btn variable. Then
392:04 - you're going to listen for double clicks on
the delete button. And if you don't know how
392:08 - to listen for double clicks, you should just
Google it. Finally, when The button has been
392:13 - clicked that is double clicked, you should
clear the local storage, you should clear
392:18 - out the Miley's variable, that is this one
up here. And you should also clear out the
392:24 - DOM so that the user doesn't see any more
leads on this unordered list. So a pretty
392:31 - big one, but give this one a shot. And return
back to me when you want to see my solution.
392:39 - Okay, let's do this. I'll start up here, we'll
define a const. With medium like that. You
392:48 - document dot get element by ID passing in
delete btn. status, indeed, we had right here.
393:00 - Then, let's move on, we are going to listen
for double clicks on the delete button. And
393:06 - how do we do that?
393:07 - Well,
393:08 - let's Google it. I think it's a good idea
to Google add event listener and then just
393:12 - double click, because as you know, it's the
Add event listener we are using. By doing
393:18 - this, we get the Mozilla developer docs as
the first result, clicking into that, and
393:23 - I always scroll as fast as I can to the example
I think it's a lot easier to learn from math
393:28 - rather from textual explanations. Here we
can see card dot addEventListener DB l click
393:34 - Hmm, pretty nice. So simply leaks ETL the
event listener, and V bl, click like that.
393:46 - Let's then also do the function. Now, let's
just console log, double click like that.
393:55 - Well run the code. Double click on delete
all
393:58 - and yes,
393:59 - it's worked. If I try a single click, nothing
happens. But double click? Yes. Okay, good.
394:06 - Three, when clicked, clear, local storage,
the my leads variable and the DOM. Okay, let's
394:13 - do this one by one. local storage, if you
remember the way declare that was local storage
394:19 - dot clear. My leads? How do we clear that
one? Well, we actually reassign it by doing
394:27 - my leads, and just setting it to an empty
array, and then finally clearing out the DOM.
394:33 - How do we do that? Well, actually, the trick
is to simply render out leads, which now are
394:40 - just an empty array. So we just trigger the
render leads function, render leads like that.
394:49 - let's rerun this. And now try to double click
on the delete all.
394:54 - Yes.
394:55 - Now we've removed everything in the DOM. And
we have cleared the local storage, our array
395:02 - is empty, we have a working delete button,
we can delete this console log here, great
395:08 - job during this challenge. Let's move on.
Now that we have an app that actually works
395:16 - pretty well, we're going to do something we
haven't done a lot throughout this course,
395:20 - which is to refactor our code, and not only
refactor it based upon a current need, we're
395:25 - going to refactor it based upon a hypothetical
future use case. So for this, we're not going
395:32 - to use the mini browser. So I'm just going
to minimize that one. And actually, I'm also
395:36 - going to take this function render leads,
and move it up here, right below this conditional,
395:45 - because it is the render leads function, we're
mainly going to refactor. And the reason for
395:49 - that is the following. This function now currently
has a very low degree of what we will call
395:55 - reusability. Because here, it is hard coded
that whenever it's called, it's always going
396:04 - to look at the my leads variable, the one
we've created up here, or global variable,
396:10 - and render out whatever exists in that array
at that point in time. Now, let's say that
396:16 - we one time in the future, also have another
array, for example, let all the leads, perhaps
396:23 - just a bunch of slightly unimportant leads
that you've shoved into this array that you
396:27 - don't want to render out at any given time.
But you want to perhaps have the opportunity
396:31 - to bring them up from time to time, if so,
we would struggle to render them out. Because
396:37 - as I said, in our render leads function, we
only care about to the My leads array. So
396:43 - what we can do instead is to make this function
a bit more dynamic, and have it render out
396:48 - whatever array we tell it to render out. And
the way we do that is to pass in a variable
396:55 - as a so called argument, when we call it we
could take my leads here, and then pass it
397:02 - in like this in between the parentheses so
that it would be possible for us to use it
397:08 - inside of the body of our function, but without
referring to my leads. Directly like this.
397:14 - Now, let's just pause here for a minute before
we rewrite the body of the function, just
397:18 - in case, this seems weird, because you might
feel you're walking on thin ice here, but
397:23 - actually, you've been passing in arguments
into functions, when you have called them
397:28 - for quite a while now. Because that is exactly
what you're doing a pair, for example, the
397:33 - get element by ID function, which you are
calling and giving it to the string of infidel,
397:38 - so that this function, when it does its magic,
and walks through the HTML file, in the search
397:45 - of its of its element, knows, when it hits
this point up, here it is, this is the element
397:50 - I'm looking for. Because pear told me, so
when he wrote this cold told me that this
397:55 - is indeed the ID he wants. Haven't we done
that? Well, the function would have been like
398:00 - blind to whatever it was looking for, wouldn't
be able to recognize this element. But we
398:06 - did, of course, give it that value. And that
is also what we're doing here. Now, we're
398:13 - telling render leads that we want you to render
out this data right here, and then make this
398:18 - work, we also have to hear right, something
like, leads inside of the parentheses here
398:25 - as well, the way this works is that when this
function is called, with this data passed
398:31 - in this data, this array will become this
variable here, which is accessible inside
398:36 - of the body of the function. So now, we can
replace my leads
398:41 - with leads here, and we can replace it here.
And here, at this point, the body of this
398:49 - function has no idea and no relation to this
my leads global variable up here, it only
398:56 - cares about what you entered into the function,
when you call it. And now what actually makes
399:01 - sense is to skip the usage of the word leads
in the name of the function, because actually,
399:08 - the function at this point doesn't even know
that it's rendering out leads, it could be
399:11 - rendering out a bunch of names of soccer teams,
or a list of fruits, or whatever it is, it
399:17 - renders out whatever you pass into it. So
actually, what we want to do is remove this
399:22 - leads here and simply call it render. Now,
this, of course, requires us to do the same
399:28 - thing on the delete button. Here, we'll use
the new name, render, and we have just cleared
399:36 - out the my leads array. So it's an empty array.
So what we'll do is simply pass in my leads
399:41 - here as well. And finally, on the input button,
when we add new leads, we have also modified
399:47 - my leads array. So we'll take that and paste
it into the parentheses of the function invocation.
399:53 - And then, of course, use the updated name
as well. So now, we have a function called
399:59 - render, which can take any array you give
it and then render it out. So potentially,
400:06 - you could give it the old leads array as well.
And it's a much more dynamic and reusable
400:11 - function. Let's try this. rerun the code,
save awesome leads, epic lead, it works. And,
400:22 - yes, the delete button also works. And just
as a final notice, it doesn't matter what
400:28 - we call this parameter here could have called
it YOLO. If we wanted, however, that would
400:34 - require us to also change this to YOLO. This
to YOLO and this to YOLO. We run the code
400:42 - lead, it works. And we can delete it, it works
in the exact same way. However, we actually
400:51 - want to use semantically meaningful names.
So let's use leads instead like that. You're
400:59 - probably a little bit confused right now.
That's totally okay. Let's take a closer look
401:03 - at how to use arguments in functions over
the next few casts. Okay, let's return back
401:12 - to the example of greeting our users, which
we've looked at earlier in the course. So
401:17 - scrambled we have this welcome back pair Harold
borgan text which is visible on the dashboard.
401:22 - And here I have the basic setup for such a
feature using a function. Starting from the
401:26 - top of the file, you can see that we are heading
into the DOM and fetching a welcome element.
401:31 - That is the HTML you can see right here, this
paragraph, which is completely empty at the
401:36 - moment. And here in the greet user function,
we take that welcome element, and we set its
401:42 - text content to welcome back pear, Harold
borgan with an emoji at the end. If we run
401:48 - this, nothing happens, of course, because
we also have to call the function greet user
401:53 - like that. Now if we run it, we can see that
it is rendered out on the page. And this is
401:58 - a very typical use case for a function rendering
out a specific thing. However, it's a really
402:05 - bad function because it can only render out
this string right here. It can only run rob
402:09 - my name, which is pretty silly and it should
actually Rather be called something like Greek
402:14 - pear. But that would just be stupid, we're
going to use the Greek user name and rather
402:19 - modify the functions so that it can greet
whoever enters the app. And the way to do
402:24 - that is to add a so called parameter to a
function. And I can do that by writing a variable
402:30 - inside of the parentheses, of the function
declaration. So here, for example, write name
402:36 - like that. Now, it is expected that we are
to use this name variable inside of the body
402:42 - of the function. And indeed, we are going
to do that we are going to replace this with
402:48 - a name like that. So now we are constructing
this string using the first string, then the
402:57 - name variable, and then the final string.
Now, if we run this code, you'll see welcome
403:02 - pack undefined. That is because name is now
undefined. And can you take a guess at Why?
403:08 - Well, it is, because when we call the function,
we haven't passed in any names. And our function
403:15 - expected us to do that. So here in between
the parentheses, we'll simply type a name.
403:20 - Let's type here, for example, run the code.
And now you can see welcome back up here.
403:25 - So here we are passing in a value into the
function when we are invoking it, that value
403:31 - becomes the name variable inside of the body
of the function. And this is then changed
403:37 - to pair on the flight when that is called.
403:41 - So now I have a challenge for you. You are
to give the function a parameter, which you
403:49 - are to call greeting, that replaces the Welcome
back. So it will always greet me, but the
403:55 - greeting itself can be Howdy, or Hello, or
Nice to see you, or basically whatever, because
404:01 - you will define it as a parameter in the function.
And then you of course, will call it with
404:05 - a value so that you verify for yourself that
it actually works. Go ahead and give this
404:10 - a shot. Okay, hopefully, that went well, the
way to do this is by doing a greeting here,
404:21 - and then removing this rather writing, rethink
here and then a plus. Here, when we call it,
404:29 - we can do it and run the code. And then we
can see how the pair Harold borgen. Great
404:36 - job. Let's move on. Okay, so our function
is now pretty dynamic, since it can use whatever
404:45 - greeting value you want, you can kind of set
the tone, however you want when calling the
404:51 - function, but we need to get back the same
type of feature for the name as well. So the
404:56 - way we can do that is by adding a second parameter,
because you can have as many parameters as
405:02 - you want. So actually, here, I can do name,
and then replace this with a name like that.
405:12 - Now if we run this, you will see how the undefined
again, because we have only given this function
405:18 - one argument when we call it, but actually
it expects to both the greeting and the name.
405:25 - So here we have to do comma, and then famous,
for example, we run the code now, you see
405:31 - how many dreams, now we have a really dynamic
function here. So it's a pretty good function
405:36 - in my opinion. But there's one issue which
is not related to parameters, but related
405:42 - to the code quality of the function body.
Because as you can see, while it made sense
405:47 - to use double quotes for strings, when we
started out, at this point, the expression
405:52 - has become a little bit clunky, we have three
plus signs here. And we might even get more
405:57 - of them as we continue on improving this function.
So at this point, it's time to refactor this
406:02 - expression into using template literals. So
I want you to do that now. And then we are
406:08 - ready to add a third parameter to our function.
So go ahead and change this into template
406:13 - literals right now. Okay, hopefully, that
went well, the way to do it would be to add
406:23 - a template literal to begin with. And then
once you end the string, then now we can remove
406:28 - all these clunky plus signs and boats. And
here we have two variables, greeting and name,
406:36 - which we need to escape out from the string.
So we'll do dollar sign, open curly bracket,
406:42 - closing curly bracket, dollar sign open, and
close. Yes, this looks better, much more readable.
406:50 - If we run it again, you see, we get the exact
same result. Great job. And your job now is
406:56 - to add the ability to choose the emoji as
well, meaning you should be able to run the
407:01 - function and pass in a third parameter, which
decides what kind of a Moji that will be rendered
407:07 - to the page. So go ahead and try that right
now.
407:12 - Okay, the way to do it would be the same as
we've done up until now, by adding a third
407:21 - parameter here. And then replacing this hardcode
remotely with lots variable escaped out from
407:30 - the string, of course, Modi like that. And
here, we'll need to also now add an emoji
407:36 - when we are calling the function. Let's try
the fire one, run the code and nice, we now
407:43 - have a super dynamic function that we can
use to create greetings of all sorts. And
407:50 - it's so much better than what we started out
with. Let's move on. Okay, up until now, we've
407:58 - only passed in strings as arguments in our
functions, whoever you can force pass in whatever
408:04 - data type you want, for example, numbers.
And I want you to practice that now. So I'm
408:08 - going to give you a challenge where you are
to use numbers and a function that you have
408:13 - written from scratch. So here, you have to
combine what you've previously learned about
408:17 - functions and arguments. And see if you can
connect the dots together. So you are going
408:22 - to create a function called add, that simply
adds two numbers together and returns the
408:28 - sum. So down here, on line five, and six,
I'm calling this function, and then and then
408:33 - logging it out. I'm doing that two times.
And the first time, the number seven should
408:38 - be logged out. And the second time the number
111 should be logged out, because I've passed
408:44 - in three and four, the first time around,
and nine and 102, the second time around.
408:49 - So these are basically your test cases. So
go ahead and write this function here on line
408:53 - three, it should have two parameters, and
should return the sum of those two parameters.
408:59 - And then afterwards, I will of course, show
you the solution as well. Okay, hopefully,
409:08 - that went well. Let's do this function,
409:12 - ad,
409:13 - open, close parentheses, and then the square
brackets, and inside of the parentheses, we
409:18 - need to define our two parameters. We'll call
the first one, number one. And the second
409:22 - one, number two, I'm here, I'm just going
to return num one plus num two like that.
409:30 - If we now run this, we can see in our console,
we are logging out seven, and 11. Great job.
409:37 - Let's move on. Okay, up until now, you've
heard me say the words parameter when I've
409:45 - talked about defining variables in between
the parentheses when we declare a function.
409:51 - And I've also said arguments when we pass
in values into the function when we invoke
409:56 - the function. And this is probably a little
bit confusing, like, why am I using two different
410:00 - words, they're basically the same thing. And
actually, to be honest, in my experience,
410:05 - most developers mix up the words parameter
and arguments all the time. And that's totally
410:10 - okay. Even I actually, up until this point,
I decided to actually explain the difference
410:15 - in this course, would mix the two up all the
time, meaning mixing up these hair values
410:20 - that you pass in when you call the function
and these variables that you define when you
410:26 - write the original function. So weight works
is that these are parameters. And these are
410:35 - arguments. And in order to remember the difference
between these two, I found a really cool comic
410:40 - on the web, which pictures two people arguing
in a bar, and then a bouncer coming to say,
410:46 - Hey, take your argument outside. And that
gives us the hint, arguments are created on
410:53 - the outside of the function, whereas parameters
then naturally have to be on the inside of
410:58 - the function. So greeting a name, as you know,
are only defined here on the inside of the
411:04 - function battalion. Jas, they come from kind
of the outside of the function, the outer
411:09 - scope, this is perhaps even more clear, if
we had a variable here, which was called pi,
411:15 - and we set it to it like that, and then we
pass in PI here, surely this high variable
411:24 - is on the outside of the function, because
in this case, that is this function lines
411:31 - two to four, this is on line seven, and line
eight, so they are on the outside. Likewise,
411:35 - here num, one, num, two are the parameters,
whereas three and four are the arguments.
411:44 - So with this, I want you to answer these four
questions with either arguments or parameters.
411:50 - So the answer is one or the other. And you
are to write that here after the question
411:55 - mark. So go ahead and do this right now.
411:58 - Okay, hopefully that went well. What are greeting
and name, greeting and name well that is on
412:10 - the inside of the function, that means that
they are per amateurs about how to you and
412:15 - James well, as we've talked about these live
on the outside, when you're outside of the
412:19 - function, you are an argument. So they are
arguments about number one and number two,
412:26 - okay, these are defined in the function declaration
and live in the inside of the function, meaning
412:32 - the parameters three and four, are on the
outside of this function here. So they are
412:40 - arguments like that. So from now on, whenever
you wonder whether you should say, parameter
412:46 - or argument, just think about this epic cartoon
created by type alias, and actually considered
412:52 - clicking on this link, so that you get to
check out the blog post, which is really good.
412:56 - And then to be honest, you will probably meet
a lot of professional developers who can't
413:00 - even remember this difference, but you will.
So far, we've only passed in numbers and strings
413:10 - into functions that we've practiced with in
this little mini section on function parameters.
413:15 - However, you can pass whatever variable you
want, actually, into a function as its parameter.
413:21 - So now I want you to create a function, which
is called get first, and it takes an array
413:26 - as its only parameter. That's why I'm writing
it as arr. And this function, one called,
413:32 - should return the first item in the array.
So I want you to create this function and
413:37 - make it return the first item. And then I
want you to call it passing in an array as
413:44 - an argument so that you verify that it works.
And you can do that by using for example,
413:49 - console log to verify it, I'm not going to
give you any starter code here, you got to
413:53 - write the entire thing, because that helps
you get the muscle memory. So go ahead and
413:57 - give this a shot right now.
413:59 - Okay, hopefully that went well. If not, no
worries, let's do this. We'll do get first
414:11 - like that are and then the body of the function,
then we need to take this our variable and
414:17 - return the first item, we do return our open
and close square brackets and zero inside
414:25 - of it. Now we can do get first open parentheses
and pass in an array. Let's say this was a
414:31 - blackjack games, we're passing in the values
of my cards like that. If we run this, nothing
414:39 - seemingly will happen. Since we've only returned
to this value, we haven't logged it out. Let's
414:44 - actually return it and store that value in
a first card variable and then console log
414:53 - out first card, we run this first card is
console log as 10. And that is indeed correct.
415:00 - Great job. We are back at our lead striker
app. And now you are going to do what I did
415:08 - previously, which was to refactor the render
leads function. So that it takes a parameter
415:15 - which I suggest uses call leads that it uses
instead of the global my leads variable, this
415:21 - one right here. So hopefully you remember
how I did this, or were able to wing it on
415:25 - your own. Anyway, please also remember to
update all of the function invocations across
415:30 - the file as well, it is a good idea to update
the name as well, but it's not strictly needed.
415:35 - So I'll leave it up to you to decide whether
or not you want to do that. Just go ahead
415:38 - and give this a shot right now.
415:44 - Okay, hopefully this went well. Let's do this.
So we are going to create this function so
415:54 - that it rather takes in a parameter here,
which we're calling leads, instead referring
416:00 - to the global my leads variable, so then we
simply need to replace my leads with what
416:06 - we've called our parameter like this in these
three places. And that's it. I also want to
416:12 - remove leads from the name and then go up
here, change the name and also pass in the
416:19 - my leads variable. Do the same thing here.
And we've cleared out the my leads variable
416:26 - as in my leads, which now is just an empty
array. And finally down here, pass in my leads
416:34 - like that. Let's run this to verify that it
works. Save input, delete all Yes. Great job.
416:43 - Let's move on. In this challenge, we are going
to set the stage for the Save tab button.
416:51 - I'm going to write the HTML for you first
and then you are going to take over and do
416:55 - the JavaScript part of it. So a button like
that it should be called save tab. run this.
417:04 - We can see that we get to the Save tab button
and let's give it an ID of bash medium. Like
417:12 - that, now, you are first going to grab the
Save tab button and then store it in a top
417:19 - btn variable. And then you are going to hook
up an event listener with this button so that
417:23 - you listen for clicks. And when it's clicked,
you are to log out my LinkedIn URL to the
417:29 - console. And the way you grab ahold of that
LinkedIn URL is through navigating into this
417:35 - times array, it actually has an object as
its only item. And that object has a key value
417:42 - pair of URL and the actual string value of
the URL to my LinkedIn profile. So this might
417:49 - sound a little bit weird, but like, why am
I forcing you to do all this complex stuff
417:53 - of navigating into this array and into this
object and fetching out this value right here?
417:57 - Well, you'll understand this, when we implement
this with the chrome API that actually gives
418:02 - us access to the current tab or on at any
given point, because then we actually have
418:07 - to do such a navigation. So I'm just prepping
you for that. So you have to remember how
418:13 - to work with arrays and objects, that's great
to get some practice on. If you struggle,
418:17 - I will, of course, show you the solution as
well afterwards. So go ahead now and just
418:21 - give this your best shot. Okay, hopefully
this went well, let's do this, we'll create
418:31 - a const tombigbee sub btn and use document
dot get element by ID, passing in tab dash
418:39 - btn. As that is the ID, we gave it over in
the HTML Yes. Down here, we need to listen
418:48 - for button clicks on the car btn will do add
event listener, first argument is clicked.
418:56 - Second is a function that will be run when
the button is clicked. And here, let's console
419:02 - log out just this entire expression, when
you are to navigate into complex expressions
419:07 - like this, so often a good idea to just take
one step at a time and log out the results.
419:13 - Let's run this, hit the Save top and bring
up the console. Okay, we can see now that
419:18 - we have our URL wrapped inside of both square
brackets and curly brackets. One thing we
419:24 - at least need to do is navigate into the first
item of this array right here. And how do
419:30 - we navigate into the first item, which also
happens to be the only item? Well, we simply
419:35 - do square brackets zero for the zeroeth index.
Let's run this it save time. And there we
419:43 - can see in our console, we're now just logging
out an object. So this is an object with a
419:47 - key URL and the value which points to my LinkedIn
profile. How do we get ahold of that value?
419:53 - Well, we use the dot notation dot URL like
that. From the code again, it saved up and
419:59 - there we go, we have logged out my LinkedIn
URL. Great job, let's move on. Next step is
420:10 - to actually save the URL instead of just logging
it out. Because obviously, this doesn't do
420:15 - the trick for our app, we need to save it
to local storage, we need to add it to the
420:20 - My leads array. And we also need to trigger
a render so that the fictional leads here
420:26 - actually will be rendered on the page when
the user hits the tab button. So to achieve
420:32 - this, you basically need to do more or less
the same thing that you're doing inside of
420:35 - the input button. So hopefully, you've got
this. If not, no worries, I will of course,
420:40 - show you the solution when you return back
to this screencast.
420:47 - Okay, let's do this. So the first thing I
want to do is push it to the My leads array.
420:55 - So we'll do my leads dot push, and then pass
in this expression right here, like that.
421:03 - Let's comment out this one for now. Next up,
we need to save the Maya leads array to local
421:09 - storage. Luckily, though, we know how to do
this, that's the exact same line as we have
421:14 - down here. local storage dot set item, the
my leads, which is the key should be set to
421:21 - stringified version of the my leads array.
So let's just remember how this looks and
421:27 - rewrite it up here. Want to rewrite it because
it's a little bit of a complex expression.
421:31 - So it's good to get that practice, local storage
set item, which item Well, it's the my leads
421:40 - key, which is what it's called here, we are
going to set it to the My leads value. However,
421:47 - we need to stringify this value first. So
we'll do JSON dot string if I open parentheses,
421:56 - close parentheses, and a lot of spaces here
so that you understand what happens. This
422:01 - is the array and this is the stringified version
of that array. So the array turned into a
422:07 - string like this, I think okay, looking pretty
good. Now First thing we need to do is actually
422:14 - trigger a rerender. Because we have pushed
something to the My leads rate. Now we want
422:19 - to render it out with the render function
and pass in my leads as the argument so that
422:24 - we actually get to see it on our page. I'll
run this code, bring up the mini browser and
422:30 - hit the Save tab. And there you go, we got
our URL render to the page, let's combine
422:36 - it with a lead as well, awesome lead. Yeah,
there we go and delete all Oh, nice, it works.
422:43 - Really good job. So we now have a working
dummy version of our tab button. However,
422:52 - it's kind of useless. Because if I hit the
Save tab here, once, twice, three times, you
422:57 - can see we're just rendering out our hard
coded tab URL, which we have here. What we
423:03 - of course, rather want to do as the following,
we want to be able to open up our Chrome extension
423:08 - on any URL. And then when we hit the Save
tab button, the extension should head over
423:14 - to the address bar here, grab a hold of this
URL, and then boom, save it in our list of
423:22 - leads. So my question for you here is where
in our code that is on which line, should
423:28 - we go ahead and try to talk with the chrome
API to ask it for the current tab URL, just
423:36 - take a guess at where in this file, we need
to do that? Well, the place we want to do
423:42 - it is right here, when the user has clicked
on the tab button, and this function has been
423:48 - triggered. Here on line 20, we want to grab
the URL of the current tab, basically what
423:55 - we are doing here, but we want to do it in
the real world, not just using the made up
424:00 - hard coded array I've written up here on line
14. So then the question is all how do we
424:05 - ask the Chrome browser for this URL. And yet
again, we will resort to Google
424:11 - will simply write
424:13 - Chrome extension get current tab, that gives
us a bunch of results. And on first place,
424:19 - you can see the developer chrome.com. So the
documentation, if we head into that, you will
424:25 - see Chrome, dots, tabs, okay, description,
use the chrome dots tabs API to interact with
424:31 - the browser's tab system. Hmm. Sounds about
right. If we scroll a bit down, we'll see
424:36 - manifest. So it turns out that we have to
do some changes on our manifest file. Namely,
424:41 - we have to add this permissions and then fill
in taps. Okay, that's fine, but not really
424:46 - what we're looking for, we're looking for
the JavaScript code, in order to actually
424:50 - grab ahold of the tap URL itself. If we continue
scrolling down, we get to this really discouraging
424:56 - list of a bunch of methods of this API. And
this is so typical, when you're searching
425:01 - through documentation, it's very often difficult
to find the answer as a beginner. So actually,
425:07 - what I would do is go back to the results
we got on google.com. Because there we can
425:13 - find a Stack Overflow question that looks
much more humanly understandable. How can
425:18 - I get the current tab URL for a Chrome extension?
Okay, let's click into that one, we can see
425:23 - there's a person that has a problem that looks
like ours. And that person is even provided
425:27 - some code of how they're trying to solve this
today, Chrome dot tabs dot get selected. Let's
425:32 - scroll a bit down and find an answer because
that's normally where we find a piece of code
425:36 - we can use. so here we can see just an FYI,
for your info for people from Google. The
425:42 - method the original poster uses is deprecated.
Okay, to get the tab, the user is viewing
425:48 - and only in the window, they are viewing us
this chrome dot tabs that query, okay, and
425:53 - then we pass it in an object with some data.
And we get this function with tabs and a lot
426:00 - of code. But actually, it looks very promising.
So what I'll do then, is what all developers
426:06 - do almost every single day, which is to copy
code directly from Stack Overflow, so I'll
426:12 - copy this and just paste it in here. Because
this is where we want to talk with the chrome
426:20 - API. I'm gonna remove this comment. Now we
suddenly have this hairy, strange looking
426:27 - code, which we haven't written, it's not comfortable.
And we can also see that it's not following
426:31 - our conventions for writing code. For example,
it uses semi colons, which we don't like.
426:35 - Like that. And it also uses the var keyword,
which we don't use either. It's the old way
426:42 - of writing variables in JavaScript, we want
to replace that with let or const. Now I'm
426:47 - just going to use let, as I'm not really sure
what the point with these variables is, at
426:51 - this point, I just want to clean that up and
storing them as select variables will definitely
426:55 - work. So let's just do that. However, now
that we at least have the code according to
427:00 - our conventions, it's time to break this down
and really understand it, and we'll do that
427:05 - in the next cast.
427:08 - Okay, now that we have this little snippet
of code copied from Stack Overflow, it would
427:15 - be really tempting to actually try to run
it and just console log out tabs at this point,
427:21 - for example, just to figure out what's going
on here after this function is being triggered,
427:26 - it actually, if we try to do that, from this
cold hit the Save tab, hmm, we'll see that
427:32 - we get an error cannot read property query
of undefined. That's because chrome dot tabs,
427:37 - that's a so called API Application Programming
Interface. Sounds really scary. I know. Don't
427:43 - worry about that. Now. Well, I wanted to say
that is that this is an API that is only available
427:48 - to us, when we're running the code in the
context of a Chrome extension like this, you
427:53 - can see here, now, we are running the code
in the context of this scrim bar mini browser
427:59 - here, and we don't have access to the chrome
dot tabs, meaning it's undefined as our error
428:06 - message is saying, because it's trying to
read the property query of something that
428:10 - is undefined. So we actually just have to
try to make sense of this code and try to
428:16 - configure it how we think it should be, and
then deploy it to see if it works out in the
428:21 - wild. So what I'm going to do, I'll delete
this console log tabs. And actually, I want
428:27 - to delete everything inside of this function,
because we are going to figure out what we
428:32 - will do inside of this function on our own
by looking back at Stack Overflow. And also,
428:37 - I actually want to comment out these lines
of code, because while it's okay to copy it,
428:44 - to get it into the code base, I want to write
it with you to break it down step by step
428:47 - so that you understand it properly. So with
this in the background, let's rewrite it and
428:53 - see if we can make sense of it. So the first
thing we write is Chrome, which is a variable
428:58 - that we will have access to when we are running
the Chrome extension. And that is an object
429:02 - and that has eight tabs key and the tabs that
is an object as well. And that object has
429:08 - a query method like that. So here, we're kind
of saying, hey, Chrome, I want to grab ahold
429:14 - of your tabs, or more specifically, I want
to query you for some of the tabs. Well, then
429:19 - which tabs is the next question? And we'll
specify that inside of the query using an
429:24 - object begin with? I'm going to say, Well,
I want the
429:28 - active
429:29 - tab I'm specifying active has to be true.
And which tab is that? Well, if we look back
429:36 - at our slide here, you can see that in this
situation, we have one browser window that
429:41 - has three tabs, but it's the LinkedIn tab
that is the active one. So it will give us
429:48 - this tab. However, here, we can also say that
we ought to specify current window to be true
429:54 - as well, which is a little bit weird. What
does that mean? Well, imagine this case, if
429:58 - you actually had another browser window in
the background. Well, the chrome API would
430:03 - know about this. So naturally, you'd have
to specify Well, which one of the two windows
430:08 - are you looking for. And in this case, the
active window is the one in the front right
430:13 - here. And that is where the LinkedIn tab is
located, where we have our Chrome extension
430:17 - open. Also, we have to specify well, current
window, so we need that to be true as well.
430:25 - So here we are calling the query method and
passing in an object that describes which
430:31 - of the tabs we want. And then as we did up
here, where we start with a specification,
430:37 - and then write a function, as the second argument,
will do the exact same thing in the query
430:44 - function as well. We'll write function like
that. And this function will be triggered
430:52 - when Chrome has found the tab we've told chrome
to look for. And when chrome triggers this
430:59 - function, it'll give us a tabs variable like
this. It's a parameter in this function. So
431:05 - now, we would get access to the tabs. And
this console log would work if we were running
431:10 - this in the context of a Chrome extension.
Let's now bring down the console. break this
431:15 - up a little bit? Because the question is here,
what do we want to do inside of this function?
431:20 - Well, it's through this tabs keyword here
that we will actually get a hold of the URL,
431:26 - the string in the address bar. So it's inside
of here that we actually have to push to our
431:31 - my leads array, save to local storage and
call the render function. So I'm actually
431:37 - going to copy this code and paste it in here,
like that. And now the question is, well,
431:46 - what does this tabs variable include, how
do we navigate to the URL value inside of
431:52 - this variable? Well, it just so happens to
be that it's constructed in this exact way.
431:58 - And how did I know that? Well, because here
on StackOverflow on our question, we could
432:05 - see that on the question below that a person
got it to work by doing var tab equals tabs,
432:12 - zero Which is exactly what we're doing here.
And then, on the next line, it did tab dot
432:20 - URL, which essentially is our dot URL here.
So it turns out that this is the way to get
432:28 - ahold of the URL. But at this point, there's
a little problem. Since we have defined tabs
432:33 - here, and also up here, these two variables
will be in conflict with each other. And obviously,
432:40 - we don't need this hard coded variable anymore.
We want to use whatever value we get directly
432:46 - from Chrome. So we can keep this and just
leave this how it is. Now, let's clean up
432:52 - this a little bit. And then finally, head
over to manifest dot Jason because we saw
432:58 - in the Chrome extensions documentation that
we had to add the following to our manifest
433:04 - file. So permissions, and then that is an
array. And here we specify tabs. So now we
433:11 - are telling chrome that we want to be able
to work with the tabs in the Chrome extension,
433:17 - otherwise, this chrome tabs simply wouldn't
work. So in the next class, we'll go ahead
433:23 - and deploy this so that we finally get to
try our entire application out in the wild.
433:33 - So let's deploy the final version of our app.
First, you of course, have to download the
433:38 - zip from this scrim. And you can do that by
clicking on the Settings icon in the bottom
433:42 - right corner, and then download as a zip,
which we did the last time around as well.
433:47 - And then make sure that you take these files
and update the lead tracker folder that we
433:53 - also created in a previous cast. Or if you
have been working locally alongside me, you
433:58 - of course, can skip this step. But
434:01 - what's important is that the same folder gets
the new updated files, because then we head
434:06 - over to the chrome slash extensions page.
There, we can see our lead tracker from previously,
434:12 - I'm going to hit detail so that we open up
the page for our extension, and then you can
434:16 - hit update. By doing that, Chrome will grab
ahold of the new files and update your extension.
434:22 - Once that's done, we can open up a new tab,
for example, and head over to a lead we want
434:28 - to track here I've opened up scribus CTOs
get a profile that's sindri. Let's say we
434:33 - want to track this URL as a lead. And then
I'll hit the Chrome extension button. I'll
434:38 - choose my lead tracker. And here, I can try
save tab and boom, our Chrome extension, headed
434:45 - over to a tab, grab the URL and displayed
it for us. That's awesome. We can also try
434:50 - our input field by just passing in a random
lead, hit the Save input. And there we go.
434:56 - It was placed here below the URL to Syndra
skitter profile. So so far, so good. Let's
435:01 - open up a whole new tab now. For example,
the answer LinkedIn profile, you probably
435:06 - recognize Leanne, from the scrim community
as she's our community manager, let's open
435:10 - up the Chrome extension again, and try the
Save tab button. Yes, it worked really good.
435:16 - Now, the final button to try is the delete
all. And I'll hit that. And there you go,
435:21 - we have deleted all of our leads, this is
so cool, we've now created a real world product
435:28 - that can give value to sales development representatives,
or basically any person collecting leads online,
435:35 - which is an activity that people in almost
all companies do. So we have really created
435:40 - something of value that you can share with
the world. So your JavaScript skills are starting
435:45 - to become dangerous. congratula, congratulations,
you have reached the end of the section and
435:53 - actually built your own browser extension.
How cool is that you should be gutted and
435:59 - proud of yourself for achieving that. And
just enjoy the fact that you've learned all
436:03 - of these awesome concepts that we now are
going to recap. So what did we learn? Well,
436:08 - we started out with a const variable that
is a critical part of JavaScript. And as you
436:13 - can see, once we learned it, we started using
it much more than we used let for all of these
436:18 - DOM elements that we stored in variables,
we use const, as we will not going to reassign
436:23 - these. And speaking of DOM, we learned a lot
of new things about the document object model.
436:29 - First of all, mostly add event listener down
here at line 14, we hooked up an event listener
436:34 - with the time button, for example, this gave
us the benefit of not having to write the
436:39 - event listeners in our HTML, we controlled
everything in the JavaScript file. And that
436:44 - also we learned about inner HTML, down here
at line 33. We had to use this because the
436:50 - dot text content property didn't do the trick
when we want to render out list items like
436:57 - this. And finally, we also learned input value,
which is another part of working with a DOM.
437:02 - And that was down here when we fetched out
the value which the user had entered into
437:08 - the input field. Another thing we did is take
one more step into the world. Have a function.
437:13 - Namely, we learned about parameters, which
is what we defined here, we defined a leads
437:17 - parameter in the render function. And that
gave us the ability to use this variable inside
437:23 - the body of the function. And also, it required
us to pass in the argument of my leads when
437:28 - we invoked this function. This is a crucial
concept to understand if you are to make functions
437:33 - really reusable. So I'm really happy that
we went through this.
437:37 - Next up, a super cool thing we also learned
was template strings. Because that gave us
437:43 - the ability to write strings on multiple lines,
which looks much better, it's easier for humans
437:49 - to parse. And also, we could use this dollar
sign and square brackets in order to escape
437:54 - out of the string, instead of having to use
these plus signs, which quickly became unmaintainable
437:59 - and confusing to work with. And then a super
cool thing we learned was local storage here,
438:05 - we saved things in local storage, so that
we could work across page refresh. This is
438:10 - kind of your first exposure to a database,
a very simple database, of course, but still
438:16 - very much the same concept. That forced us
also to learn about JSON, which is a very
438:21 - common way of storing data in web development,
you will forced to deal with this, since you
438:26 - had to turn our array into a JSON array using
JSON dot stringify. And also, we had to use
438:32 - JSON dot parse to go the other way around
when we fetched a string from local storage.
438:38 - And that string just happened to be a JSON
array. And we could parse it and turn it into
438:42 - a JavaScript array using the JSON dot parse,
don't worry, if you are confused about JSON,
438:48 - parse and JSON stringify. It's totally okay
to search for which one does what every single
438:52 - time you do it, I've done it again and again
and again. But JSON is core. And one testament
438:58 - of that is the fact that you were exposed
to JSON also in another way, namely, with
439:02 - the manifest dot JSON file, here, we have
to configure our app. And I'm actually glad
439:06 - that the Chrome extension required this because
you will see JSON in many different scenarios
439:11 - as you work as a web developer. Finally, one
of the last things we looked into was objects
439:16 - in a race, namely, this tabs array here, where
you actually had an array where it's first
439:22 - an only item was an object. So you had to
first fetch out the zeroeth index, and then
439:28 - do dot URL to fetch out the URL value of that
object. And this is very common objects shoved
439:35 - inside of a race. So it hopefully shouldn't
scare you that much the next time you come
439:39 - across that. So look at this list, it is really
comprehensive. Now let's do a little thought
439:45 - experiment, which might help you feel less
overwhelmed of all the things you don't know
439:50 - anything about in web development and all
these fancy words. Because let's say that
439:54 - you for two weeks ago, I asked a developer,
like how do you create a Chrome extension,
439:59 - and then the developer arrogantly replied
to you, well, it's not hard, you just add
440:04 - an event listener to a button, then fetch
out the input dot value, take that value stored
440:09 - in an object and convert it to a JSON using
JSON dot stringify, shoving it into local
440:14 - storage, no big deal, you can just fetch it
out later and use JSON dot parse in order
440:18 - to get it back into a JavaScript array and
then render it out in the function, shove
440:21 - it in as a parameter and just use a template
string and innerHTML to displayed on the screen.
440:26 - I mean, both be yield, right? I mean, imagine
getting such a reply, you'd probably feel
440:32 - that you would never ever learn all of this,
because there's so many concepts you didn't
440:37 - understand. But actually, that reply from
the developer is actually the exact thing
440:43 - we have done, and you have gone through it.
So even though in and of themselves, these
440:47 - names sound scary, you know that if you follow
the right course, you can learn them. And
440:52 - you don't have to be afraid of any of the
concepts you have yet to learn. Because whilst
440:56 - they sound super fancy from the outside, like
JSON, actually, they're not that complicated
441:01 - when you look into them. So try to just have
that confidence in yourself that you know,
441:06 - you can learn complicated three letter acronyms
that there are nothing to be afraid of, because
441:11 - that'll calm you down and serve you well as
you progress on this journey into web development.
441:17 - With that, let's actually put your skills
to the test. Now, because we need some more
441:21 - repetition on these things, you need tons
of repetition, these things take a lot of
441:24 - time to really get into your muscle memory.
And we'll start with that in the next section
441:29 - where you will do some quick challenges back
to back. Let's move on. In this challenge,
441:37 - we are going to do some let and const repetitions
because I've created this fictional game here,
441:43 - which has a player and opponent the name of
the game, the points variable and the has
441:49 - one variable after it's been set up, the game
is played down here at line nine and 10, the
441:54 - player gets some point and the has one variable
is flipped. And then based upon this, we log
442:00 - out who the winner is in this conditional
statement down here. Now if you try to run
442:04 - this code, you'll see that it actually doesn't
work because I've mixed up a little bit in
442:08 - terms of using let and const. So you need
to fix that. You need to go Through all variables
442:13 - and decide if they should be let or const.
And then finally, I want you to change the
442:18 - console logs here from using double quotes
to using template strings. So go ahead and
442:24 - do this right now.
442:29 - Okay, hopefully this went well, let's go through
this. Now what I want to start with is actually
442:37 - by looking at which variables that are reassigned,
and that is actually just the two ones down
442:42 - here points and has one, there's no reassignment
below, and neither above, that's just the
442:47 - initial assignments. So that means that the
points and has one are the ones that must
442:53 - be let variables because remember, let variables
can be reassigned. const cannot. So we'll
443:00 - let and let these two need to be. So that
means that these three variables pointing
443:07 - to the same value throughout our entire program,
it will work perfectly fine with using let
443:12 - and if you prefer to that that's also okay.
But it is a good practice to use const when
443:18 - you can to enforce a bit more strictness in
the code and to hint to people who are potentially
443:23 - reading your code down the line that these
variables won't be reassigned. So actually,
443:28 - I'm going to do that and use const for these
three variables, now we can run the code.
443:36 - And yeah, we can see that it actually works.
Paragraph 200 points and one the amazing fighter
443:41 - again, that comes from this string right here,
which we want to turn into a template string.
443:46 - And the way we've got to do that is now wrap
the entire tire expression in backticks. And
443:52 - here, we're starting off with a JavaScript
variable. So we'll escape out of the string
443:57 - like
443:59 - that. Remove all of these plus and quotes,
get again, dollar sign curly brackets. And
444:09 - then we also need the scaping here as well.
444:17 - Let's run the code works just as it did previously.
But now we have this much more neatly packed
444:23 - expression, doing the same here that that,
like that. And that's it great job doing this
444:46 - challenge. Let's move on. In this challenge,
you are going to create a function that takes
444:55 - a single parameter, that should be an array,
and then it logs out all the items of the
445:01 - array to the console. And I've created this
My Courses array here so that you can test
445:06 - your function, go ahead and write this function
starting here on line seven, and then return
445:10 - back to me when you want to see my solution.
445:14 - Okay, let's do this. We'll do a function,
I'll call it log items like that. I'll name
445:23 - the parameter R. And then inside of the function,
I need to write my for loop for i equals zero,
445:29 - i is less than r dot length, and i plus plus.
And in the body of the for loop, we'll simply
445:37 - do console dot log R, I like that. Let's try
to run the code, log items passing in my courses.
445:47 - And we get to learn CSS animations, UI design
fundamentals and intro to clean code logged
445:55 - to the console. And these are all courses
that you can take in the future when your
445:59 - web development skills are a little bit further
down the line and you're ready to truly level
446:03 - up your design skills and your software craftsmanship.
But enough of that for now, let's just move
446:08 - on. Okay, now we are going to verify that
you actually know how to use local storage.
446:17 - So you're going to do three things. First,
save a value to local storage. It could be
446:22 - any value, simple string and array that doesn't
matter. Just choose whatever you want, and
446:27 - give it whatever key you want as well. Then
I want you to delete that code and refresh
446:33 - the page. So you start with a clean slate
again, because this highlights the power of
446:38 - local storage, the fact that you can come
back fetch values from local storage and a
446:42 - context which is completely unrelated to the
time when you saved to local storage. So your
446:49 - third step is to fetch the value from local
storage and log it out. So go ahead and give
446:55 - this a shot right now.
446:59 - Okay, let's do this. First, we're going to
do local storage dot set item. Open and close
447:12 - parentheses. And let's do my credit. This
could, for example, be in an e commerce shop
447:17 - where you gifted credits to people who came
to your website on a certain day and save
447:22 - that in their local storage. And maybe you
got 100 credits. This time, I'll run the code
447:29 - seemingly and nothing happens. But let's hope
it works. Because now I'm going to delete
447:33 - this. And also rerun the code. Again, I'm
coming back on a later day. And now I want
447:39 - to do local storage dot get item, my credits
like that. Let's store that in a variable.
447:49 - Mike credits, local search and then console,
log out my credits as well. running the code.
447:58 - And yes, we are logging out 100, meaning that
our local storage implementation works. So
448:03 - give yourself a pat on the back end, let's
move on. In this challenge, we are going to
448:11 - repeat add eventlistener and how to fetch
out values from objects that live inside of
448:17 - a race. So to three part challenge, first,
you're to fetch the button from the DOM and
448:23 - store it in a variable. The button I'm talking
about is this one right here, you can see
448:27 - it says log Jane's score, it's defined here
in the HTML. So maybe you have to modify that
448:34 - as well to give it an ID, I don't know. And
then once you have that button stored in a
448:39 - variable you are to use add event listener
to listen for button clicks. And when the
448:44 - button is clicked, you are to log out Jane's
score, and you got to do it via the data array.
448:51 - So you got to head into data, find Jane's
object and log out to the value of her score.
448:59 - So go ahead and give this your best shot right
now.
449:04 - Okay, let's do this. So first, we are to fetch
the button. And as we saw, the button didn't
449:13 - have any IDs. So it will be hard to grab it
out. give it an ID call it drain dash btn.
449:20 - Like that. And then I'll do const Jane btn
equals document dot get element by ID passing
449:30 - in Jane dash btn. Okay, so far, so good. Now
we need to use the Jane button to add an event
449:37 - listener onto it. What kind of events are
we listening for? Well, it's click event.
449:42 - So that's the first argument and the second
one is the function we want to trigger when
449:48 - the button is clicked. Let's verify that this
works. clicked. I'll run the code. Click the
449:57 - button. And yes, indeed it works. Now we have
to head into data and data is an array. So
450:04 - let's actually log it out first. Okay, so
we got an array with two objects. How do we
450:15 - get the first object of those two? Well, we
know that we can use the square bracket syntax
450:20 - and put in the index of the item we're looking
for. So I'll put in zero, run the code, click
450:26 - the button. Yes, we're only logging out James
objects, how do we get the value of 52. But
450:32 - we need to use the dot notation and use dot
key or dot score. In our case, we run the
450:40 - code, log and boom, we are logging out Jane's
score. So great job getting this far. Let's
450:47 - move on. Okay, now I have a really cool challenge
for you because you are going to create a
450:56 - sentence generator. So it's this function
right here. It's called a generate sentence.
451:00 - And it takes two parameters desc and R. What's
that? Well, it is a description and an array,
451:08 - and it should return a string. Actually, it's
a full sentence based upon the description
451:13 - you pass in and the array you pass in. And
it's best understood through the lens of a
451:18 - couple of examples. If you pass in largest
countries, as the description and the array
451:25 - China, India, USA as the array that is the
second parameter, then function should return.
451:31 - The three largest countries are China, India,
USA. Another example if you pass in best fruits
451:38 - as the description and apples bananas as the
array, it should return. The two best fruits
451:44 - are apples bananas, so we actually have to
construct the string, fetch out each of the
451:50 - items and also the length of the array. So
a little bit tricky, but give it your best
451:55 - shot, use a for loop and also a template string
to solve this, and if you're stuck or want
452:00 - to see my solution just returned back to the
screencast and I will of course, show you
452:04 - how to do it.
452:08 - Okay, then let's do this. I'm going to first
Start by creating this string right here.
452:15 - So let base string and I'm going to call it,
we use a template string and the. And then
452:24 - here, we can't hard code the number as its
dynamic based upon how big the array is. Because
452:29 - we're going to do our dot length. And then
there's a space and then you other sign and
452:36 - curly brackets. And here we are to fill in
the description, and then our, and the space.
452:44 - Now we have the bass string, what remains
is simply adding each of the items to the
452:49 - end of this soldier for let i equals zero,
i is less than our dot length incrementing
452:58 - upwards. And that will be base screen plus
equals our men using our iterator value, saddle,
453:08 - fetch out the specific item. Also remembering
to add a comma after each of the items. Now
453:17 - let's try this right sentence. Let's do highest
mountains, do Mount Everest, and kaitou will
453:31 - store the result of this in a sentence. And
of course, then hills will need to return
453:36 - the bass string, like that. And then finally,
console, log out the sentence.
453:45 - Okay,
453:48 - not bad, we got the two highest mountains
aren't Mount Everest, comma k two, comma.
453:52 - Okay, two things to fix here. First, we need
a space after the comma like that. Good. Secondly,
454:00 - we don't want a comma after the final item
in the array. How do we fix that? What we
454:07 - need to do is inside of the for loop, check
if we are at the last item in the array. And
454:14 - what is the index of the last item in the
array? Well, it is one less than r dot length.
454:20 - Let's do outside of the for loop promised
last index equals r dot length minus one here,
454:31 - we'll do if i equals last index, then we are
going to do like that, if else we are going
454:51 - to do like that. So what are we doing here,
in this situation where I am passing in highest
454:55 - mountains and these two mountains, the first
time of the iteration i equals zero, and last
455:02 - index equals one. So going through this for
loop checks, S II equaled last index is zero
455:10 - equals one No, so we're not doing this, we're
instead jumping to this point where we are
455:16 - adding the comma, but then the next time around
both last index, and i equals to one. So JavaScript
455:23 - will run this piece of code instead. Let's
try it to verify that it works. Yes, we've
455:29 - got it. So this was a challenging one, and
required you to think a little bit out of
455:33 - the box. But that's how it is as a developer,
so I hope it didn't scare you too much. If
455:38 - it did, just watch it over again. Try it again.
Now that you've seen the solution, and that
455:42 - I will see you in the next cast. In this challenge,
you are going to imagine that you are working
455:50 - for about the hippest company I've ever seen
this one right here, the Brooklyn agency who
455:56 - currently consists of these super hip people
right here, your job for this agency is to
456:02 - make their code a little bit more dynamic,
because now you can see that they have simply
456:06 - hard coded out the three team images inside
of this container. But that isn't a particularly
456:12 - good solution cost when they get a new employee,
they would have to update the HTML. So it's
456:17 - actually much better to do this using JavaScript
and create a function that renders out the
456:23 - three team images because that sets the stage
for easily connecting this data with a database
456:29 - so that you can just update the database in
order to change team if new people join or
456:34 - someone quits. So that is your challenge,
creating a function that renders the three
456:39 - team images. And this function should be using
a for loop, template strings plus equals and
456:46 - dot inner HTML. In order to solve the problem.
Here I have provided you with an array that
456:53 - contains the paths to all of the images, you
can see images slash hip one dot jpg, and
457:00 - hip two and hip three. And they are located
over here in the images folder. And this is
457:04 - actually a very common situation where you
get an array of paths which point to the data
457:10 - you need. So we could imagine that this for
example, had come from the database when you
457:14 - render the page or something like that, right
now, though, it's just hard coded into our
457:18 - JavaScript file. There is a little bit of
CSS here as well. But But this challenge is
457:22 - not about CSS, it's about JavaScript. So we're
just going to ignore that. Just make sure
457:27 - that the images use this class of team IMG,
and you'll be just fine. So I'm going to comment
457:35 - out all of these images. Now we can see we
cleared out to the container. And I'll leave
457:41 - the table to you go ahead and solve this challenge.
Okay, hopefully this went well. Now, let's
457:52 - do it together, I'll start by grabbing the
div with the ID of container because we know
457:57 - we need that one. Container equals document,
get element by ID container like that. And
458:07 - then the function. I'll call it render images
like that. And here, we need a for loop, since
458:16 - we are going to loop through this array. So
I'll do for let i equals zero, I should be
458:23 - less than the length of the images array,
458:26 - like that. And we'll increment upwards. In
here, we can use dot innerHTML directly, let's
458:33 - do that first and then refactor it a little
bit after we've gotten it to work. So I'll
458:38 - do container dot inner HTML plus equals, at
each step in the iteration, we need to add
458:45 - to the current inner HTML knobs just to clear
it out using equals arrow
458:52 - mg. Class of table the class was team dash
IMG. Okay, we'll do team last IMD. And the
459:04 - source should be
459:06 - each of these items right here, we'll use
dollar sign curly brackets to escape out of
459:14 - the string and use imds passing in the current
index, which starts at zero and add to meaning
459:22 - 012 perfectly suitable to use in order to
fetch up items from this array, tossing the
459:29 - tag. Now the final step is to make sure that
we run the function, which will do my render
459:35 - in progress like that will run the code and
boom, there we go, we have rendered the images
459:42 - out. Brilliant. Now, let's refactor this code
a little bit. Because Because there are two
459:47 - things I would fix up here, the first thing
we're going to fix is the dot inner HTML in
459:53 - the inside of the for loop, because here we
are interacting with the DOM three times one
459:58 - for each iteration of the loop. And that has
a cost manipulating the DOM has a performance
460:04 - cost, it takes a little bit of time that we'd
like to avoid if possible. Now, it doesn't
460:08 - really matter when we're only rendering out
three items. So we as humans won't be able
460:13 - to notice the difference anyway. However,
it's a good practice to do it the most performant
460:18 - way just to know how it's done, because it
comes today, when you need to render out tons
460:21 - of things and manipulate the DOM quite a lot.
So and then it actually might matter. So let's
460:26 - fix this, what we'll do is we'll simply create
a variable up here, for example, images on
460:34 - set back to an empty string, then instead
of manipulating the DOM three times down here,
460:40 - we'll simply concatenate this string onto
this string. So we'll replace this entire
460:46 - thing with imgs. Dom loss equals this expression
right here. And now after this for loop has
460:55 - completed, this variable contains all the
three images. And it's time to do container
461:01 - dot inner HTML and set that equal to imds
bomb like that. If we'll run the code and
461:09 - see that it works in the exact same way, just
as we expected. So no visible change for us
461:16 - as humans, but we know that the performance
under the hood is better, since we're not
461:20 - doing Dom manipulations again, and again,
we're only doing it once. Okay, the final
461:25 - thing which is an auth attribute, because
that is for accessibility purposes, so that
461:31 - people with for example, screen readers can
understand what the images contain. and here
461:36 - we can do employee and the company like that.
Now, we have solved this challenge, and we've
461:45 - made it even better than the previous solution,
since we now also use an alt tag for accessibility
461:51 - purposes. So great job. So you have reached
the end of this course. It's very well done.
462:02 - You should truly be proud of yourself. Now.
Give yourself a pat on the back and just feel
462:06 - great about yourself because not many people
get to the finish line they give up, but you're
462:11 - not a quitter. Even though this course is
finished, you should by no means stop learning.
462:17 - So the real question is What now? What should
you learn next. And the most important thing
462:23 - is that you continue building more stuff.
That's how you learn. If you just build enough
462:28 - stuff, everything else will fall in place.
But of course, let's be a bit more specific,
462:33 - there are still a lot of basic JavaScript
concepts that we haven't gone through. And
462:37 - it's a great idea to continue expanding upon
your basic JavaScript skills. And then when
462:42 - you've done that, you can move more into iOS
six and beyond aka modern JavaScript. iOS
462:47 - six is short. For ACMA script, six, that was
a legendary update to the JavaScript language
462:52 - in 2015. It's actually already five years
old. But many of the modern patterns in JavaScript
462:58 - come from this update. And actually, you've
learned several of them already, I just didn't
463:03 - bother telling you that they were part of
the ESX specification. So you are totally
463:07 - ready to continue learning more about modern
JavaScript. Another thing you definitely should
463:12 - learn is API's and Asynchronous JavaScript,
because that opens up the world to you, you'll
463:17 - be able to have your applications talk with
external services, third party API's, bring
463:23 - in data from wherever you want. And then of
course, there is server side JavaScript, so
463:28 - that you can build full blown apps from start
to finish. But this probably looks a little
463:34 - bit overwhelming. But don't worry, I have
the solution for you, here at screen. But
463:38 - we have something called the front end developer
career path. It's our flagship, it's the course
463:43 - we put the most effort into by far. And it'll
take you to a higher level as a front end
463:49 - developer. So looking at the contents here,
it goes all the way from learning basic HTML
463:54 - and CSS to getting hired.
463:56 - And actually, you can jump in here in Module
Three, because the course you just took is
464:00 - a part of the career path as well. So if you
like our style of teaching, with a lot of
464:05 - projects and challenges back to back, you
can just jump into module three and continue
464:10 - on in the same pace. So I hope I will see
you there and if not, best of luck with your
464:15 - continued JavaScript journey.