00:00 - what is going on guys welcome to this
00:01 - python course for network programming in
00:03 - today's video you're going to learn
00:05 - network programming principles in python
00:07 - taught on four different projects so
00:08 - we're going to do a mailing client we're
00:10 - going to learn how to automate mails
00:12 - we're going to learn how to do a ddos
00:14 - script so a little bit of penetration
00:15 - testing there we're also going to build
00:17 - a threaded port scanner which is
00:19 - essentially just a
00:21 - port scanner on steroids so it's going
00:23 - to scan multiple ports at a second at
00:25 - the same second and we're also going to
00:27 - build a tcp chat that allows you to chat
00:29 - with the server and multiple clients
00:31 - connected to the server at once so i
00:33 - hope you enjoy this video and let's get
00:35 - right into it
00:40 - now let's get started with the code the
00:41 - first thing we need to do is we need to
00:42 - import the smtp library of python smtp
00:46 - is the protocol that we're going to use
00:47 - to send mails because what we need to do
00:49 - here is we need to take our script and
00:51 - log into an existing mailing account so
00:53 - make sure you have one
00:55 - you log into an existing mailing account
00:57 - and then use the smtp protocol with your
00:59 - python script
01:01 - in order to send mails from that account
01:03 - to other accounts so you cannot just
01:04 - send mails directly from the python
01:06 - script you use the python script to log
01:08 - into your existing mail account and then
01:10 - use the smtp protocol to send mails from
01:13 - there
01:14 - um so this is what we're going to do and
01:16 - for this we need to define a server the
01:18 - server is defined by smtplib.smtp
01:21 - and here you have to specify the smtp
01:24 - server and a port and the port we're
01:26 - going to use is 25 for smtp
01:28 - and the smtp server address is usually
01:31 - something that you can find out by
01:33 - googling so you just type in smtp server
01:36 - gmail smtp server yahoo whatever
01:38 - provider you're using so
01:41 - smtp.gmail.com for example is the one
01:43 - for google it's a very uh
01:45 - basic format actually you always write
01:47 - smtp dot most of the time it's just
01:49 - going to be dot whatever your provider's
01:51 - domain is
01:53 - in my case i'm using a an austrian uh
01:56 - provider here where i'm hosting my
01:58 - website which is world4you.com so
02:00 - smtp.world4you.com
02:02 - is the
02:04 - address of my smtp server here
02:07 - we're off the smtp server of my provider
02:09 - and once we have that we're just going
02:11 - to start it to start the whole service
02:14 - here
02:15 - by calling the ehlo command so this is
02:18 - the function need to call to start the
02:20 - whole process and now the next thing
02:22 - that we need to do is we need to log
02:23 - into the account so you have your smtp
02:25 - server a gmail or whatever it is and
02:27 - then you just log into your account and
02:29 - to do that of course you need the
02:30 - information first you need the email and
02:32 - the password and i would never recommend
02:35 - saving the password clear text in your
02:37 - um script because what you essentially
02:39 - need to do is you need to say
02:40 - server.login and then you know you have
02:43 - your mail here mail at mail.com whatever
02:46 - and then your password here password123
02:48 - whatever it is uh you can do it like
02:50 - that if you want if you're just using
02:52 - the script with a crappy mail account
02:54 - that you don't need just for
02:55 - experimentation you can do it like that
02:57 - but i would not recommend it what you
02:58 - should usually do is you should save
03:00 - your your password encrypt it in a text
03:02 - file then load that text file decrypt it
03:05 - and then use that password
03:07 - for this tutorial i'm just going to save
03:09 - the clear text password or actually save
03:11 - the clear text password already in a
03:14 - text file and i'm going to read it here
03:16 - so that you as a
03:18 - viewer are not able to see it so what
03:20 - i'm going to do is i'm going to say with
03:22 - open i'm going to open a text file
03:23 - stream
03:24 - uh with open password dot txt
03:28 - in reading mode
03:30 - sf and we're going to say password
03:33 - equals f.read
03:35 - so now i have the password that i saved
03:38 - in this password txt file i now have it
03:40 - in the script and i'm going to say
03:42 - server
03:43 - dot login and now you have to specify
03:45 - your mail so whatever
03:47 - maybe yours is alex gmail.com whatever
03:49 - it is in my case i created a separate
03:52 - email for this tutorial so mail testing
03:55 - at
03:56 - neural9.com
03:59 - and the password is the one we just
04:01 - loaded so this is how you log into your
04:02 - server into the smtp server into your
04:05 - mail account and now we can start
04:06 - creating the message
04:09 - now before we can start creating the
04:10 - mail message what we need to do is we
04:12 - need to import some additional libraries
04:13 - because what we're going to do is we're
04:15 - going to create a message a mail
04:17 - consisting of multiple parts of
04:19 - attachments of messages of headers uh
04:21 - and for this we need to import some
04:23 - additional libraries so let's start with
04:25 - from email
04:27 - import encoders which is something we're
04:29 - going to need later on this video not
04:31 - not yet
04:32 - and also let's say import
04:35 - not frozen set from email import
04:38 - um mime text
04:40 - which is the ordinary text that we're
04:42 - going to use
04:43 - um actually from email dot
04:46 - mime dot text import mime text
04:50 - then from email dot mime dot base
04:54 - we're going to import minebase
04:56 - which is what we're going to use for the
04:57 - attachment and then for the whole thing
05:00 - we're going to use mime dot multi-part
05:03 - import
05:04 - multi-part
05:05 - um that's it and now we can start
05:07 - creating the message using these
05:09 - libraries here so the first thing that
05:10 - we're going to do is we're going to
05:11 - define the message as a my multi-part
05:15 - and we're going to define the header and
05:17 - the header is essentially consisting of
05:20 - a from 2 and a subject so we're going to
05:22 - say message equals or actually message
05:25 - from equals because message can be
05:27 - treated like a dictionary we can just
05:29 - say okay message from equals and here
05:31 - we're going to say neural nine or your
05:33 - name whatever you want you can put here
05:36 - all kind of creative stuff
05:38 - and then we can say
05:40 - two and here you usually just specify
05:43 - the target email in my case i'm going to
05:45 - use a 10 minute mail but i'm not going
05:46 - to use the 10 minute mail domain because
05:49 - the 10 minute mail domain
05:51 - for some reason is not able to receive
05:53 - attachments i tried at least when i was
05:55 - experimenting with my script i couldn't
05:57 - receive attachments there so i'm going
05:59 - to use a german spam mail provider which
06:01 - is providing 10 minute mails
06:04 - and the domain is called
06:06 - spammel.de so i'm going to just say mail
06:09 - testing at spamo or actually this is
06:12 - probably not that that intelligent
06:14 - because my mail is already mail testing
06:16 - let's say
06:17 - uh test mails at spammel.de
06:22 - you can use a different one you can also
06:23 - use your existing email a real email i'm
06:25 - just going to use a spam mail for this
06:28 - video
06:29 - then we're also going to say subject
06:31 - equals
06:34 - um
06:35 - whatever you want it to be
06:37 - just a test
06:39 - is essentially what you're going to see
06:41 - once you receive the mail in the subject
06:43 - and uh that's essentially it now you can
06:46 - specify a text for your message and i
06:48 - usually do this in a file so we're going
06:50 - to create a new text file here we're
06:52 - going to say message.txt
06:55 - and here we're going to just write our
06:57 - mail message hello world
07:01 - this is a mail sent with python
07:07 - uh subscribe
07:09 - to neural nine
07:11 - always gotta do this
07:13 - as we're used to it to it already from
07:15 - the other videos kind regards
07:20 - uh neural nine
07:22 - there you go
07:24 - then you have the message here and what
07:26 - you do then is you just load the message
07:28 - the same way you loaded the password if
07:30 - you loaded it so with open
07:33 - message
07:35 - dot txt
07:36 - in reading mode s f
07:40 - we're going to say message
07:43 - equals f.read
07:46 - that's essentially it and
07:48 - this is something that you just need to
07:50 - attach to the message
07:52 - object here so message.attach
07:56 - which is not the attachment we're going
07:57 - to add the attachment later on so we are
07:59 - not adding oh sorry not text.txt you're
08:02 - not adding the um txt file to the mail
08:06 - you're adding it as a text and we're
08:08 - later on also going to add an image as
08:10 - an attachment so what you need to do now
08:12 - is you need to attach mime text
08:17 - and you're just going to pass the
08:19 - message here
08:20 - and you're going to attach it as plain
08:23 - text so this is how you add a header and
08:26 - a text to your message object
08:29 - now one more thing that we want to do
08:30 - before we send the actual message is you
08:32 - want to attach an image to it so in this
08:34 - case i downloaded the royalty free image
08:36 - from pixabay uh you can also use google
08:38 - images if you're just using it for your
08:42 - personal experimentation you're not
08:44 - going to get sued for that
08:45 - so i just picked this coding.jpg file
08:48 - from pixabay because i'm doing a video
08:50 - and i shouldn't be using copyrighted
08:52 - images here um however you get this
08:54 - image put it into the same directory and
08:56 - then you specify the file name
08:58 - file name in this case coding.jpg or
09:01 - essentially the file path if it's
09:03 - somewhere else you can also specify the
09:04 - whole path and then we're going to open
09:06 - up attachment equals open we're just
09:09 - going to open a file stream of this file
09:11 - name
09:12 - and now we're going to open it in
09:14 - reading binary so we're not going or
09:17 - reading bytes we're not going to open it
09:19 - up in reading text mode but in reading
09:21 - byte mode because we're using um
09:25 - we're working with image data here not
09:27 - with text data anymore
09:28 - uh so the next thing is we're going to
09:30 - create a payload object so we're going
09:32 - to say p equals and now we're going to
09:35 - use this mime bass object so we're going
09:37 - to say mime bass
09:40 - and
09:40 - here we're just going to start a
09:42 - so-called don't ask me what it stands
09:45 - for it's a application and then it's
09:47 - called an
09:48 - oc
09:50 - stream
09:52 - which is essentially the scene uh the
09:53 - stream that we're going to use to
09:56 - uh process this image data here and then
09:58 - we're going to set the payload of this
10:01 - payload to attachment to the file stream
10:04 - dot
10:05 - read
10:07 - or actually
10:09 - like that
10:11 - attachment.read
10:12 - i'm not sure if we even need those
10:14 - parentheses here
10:16 - i don't think so so attachment.read and
10:19 - this is what you set as the payload you
10:22 - just read the content of this attachment
10:24 - with reading byte modes
10:26 - uh and
10:28 - you set the payload now the next thing
10:29 - you want to do is you're now gonna use
10:31 - the encoders so we're going to say
10:32 - encoders and code base64 so we're going
10:35 - to encode the image data that we just
10:37 - read and that we set as a payload uh
10:40 - we're going to encode p
10:42 - and then we're going to add a header to
10:44 - p so we're going to say p dot add header
10:47 - content
10:49 - disposition
10:51 - and we're going to use an f string here
10:53 - to say application or attachment sorry
10:56 - attachment
10:58 - semicolon and then file name
11:01 - and now of course we add the file name
11:02 - here
11:04 - which is just file name
11:06 - and this is how you add the attachment
11:08 - of course now the payload the attachment
11:10 - itself has to be attached to the message
11:13 - so we're going to say
11:14 - message dot attach
11:16 - yeah message.attach
11:18 - p and that's how you add the actual
11:21 - payload to the message
11:23 - now the last thing we need to do is we
11:24 - need to say text equals
11:26 - message dot
11:28 - um
11:29 - as string
11:31 - so we finally get the whole thing as a
11:32 - string and this string can then be sent
11:35 - by the server so we're going to say
11:37 - server dot send mail
11:39 - and we're going to send it from
11:41 - mail testing
11:44 - at neural
11:46 - nine dot com
11:49 - to our target what was it test mails
11:53 - test mail start at spamal.de
11:58 - and we're going to send the message
12:00 - which is the text
12:01 - now this is the whole script and we're
12:03 - now going to test it
12:05 - so now what i did is i created a spam
12:07 - mail on spammel.de it's german don't get
12:10 - confused by that but you can also use
12:12 - any other spam mail provider or you can
12:14 - just use a real mail as a target um in
12:17 - this case i just didn't want to use or
12:19 - show any of my personal emails so i used
12:21 - this spam test mails at spammel.de and
12:24 - now what we're going to do is we're
12:25 - going to run our script so we're going
12:27 - to say run
12:29 - and if we didn't make any mistakes this
12:31 - should now send the email without any
12:34 - errors wow we didn't get an exception
12:36 - i'm surprised to be honest and now let's
12:38 - wait for it and see if we get something
12:40 - here and you get it here just a test
12:43 - hello world this is a male scent with
12:45 - python subscribe to neural nine kind
12:48 - regards neural nine you can also see
12:49 - that uh avas or avest was checking this
12:53 - mail so if you don't want this message
12:55 - to appear just if you're using the same
12:57 - anti-virus software just turn it off and
12:59 - you can also see that there is an
13:01 - attachment in here coding.jpg
13:03 - and if i download it you can see that
13:06 - it's the exact image that we wanted to
13:07 - send so it worked the script worked you
13:10 - have neural nine at an unknown i don't
13:12 - know if we have the
13:14 - uh male header here somewhere as well
13:18 - uh but if you're using a normal mail
13:19 - account this should appear as neural
13:21 - nine as uh or your mail not neural nine
13:24 - as in this case mail testing at neural
13:27 - nine dot com uh in this case it says
13:29 - neural nine at unknown i don't know why
13:31 - it does that but essentially it works
13:33 - the subject is here the text is here as
13:35 - a normal text and then we also have the
13:37 - attachment so it worked perfectly fine
13:39 - and that's basically it
13:44 - we're going to code a distributed denial
13:46 - of service script which is basically a
13:48 - script that overloads a website with
13:51 - requests so that this website is not
13:54 - able to
13:55 - offer its service anymore because you're
13:57 - overloading its
13:59 - capacities
14:00 - basically so before we get into the code
14:03 - let's talk a little bit about how ddos
14:05 - basically works um you have one attacker
14:07 - and this attacker chooses a target for
14:09 - example the server of a shop or off a
14:11 - newspaper or something and says okay i
14:14 - want to take this side down so what do i
14:16 - do i send 5000 or 10 000 or 50 000
14:20 - requests per second so that the server
14:23 - will be overloaded the capacities are
14:25 - not enough to handle all these requests
14:28 - and as an effect of that if a normal
14:30 - user wants to connect to that website
14:32 - it's also not possible because you're
14:33 - getting 50 000 uh requests per second so
14:36 - if i as a normal user as a customer want
14:39 - to visit that website i'm not going to
14:42 - be able to do that because the hacker is
14:44 - already or actually ddos is not hacking
14:45 - but the attacker is actually flooding
14:48 - the server with a request so i cannot
14:50 - visit the site as well now of course you
14:52 - can counteract this by blocking the ip
14:54 - address of the one who's sending all
14:56 - these requests or actually blocking all
14:58 - the ap address
15:00 - addresses except for your own and then
15:02 - you know do some stuff in the back end
15:04 - or something
15:06 - but usually that is how it works you
15:07 - have an attacker and this attacker
15:08 - chooses to take down a website by
15:10 - flooding it with requests now first of
15:13 - all before we get further into this
15:14 - video i want to mention that ddos is
15:16 - highly illegal so if you do it do it on
15:18 - your own server do it off the server
15:20 - onto the server of someone you know that
15:22 - gives you permission to do it uh don't
15:25 - just go ahead and ddos amazon or any
15:27 - other web page because you can get sued
15:30 - and you can't get in prison for that so
15:32 - i am not responsible for what you do
15:33 - with this knowledge here it's purely
15:35 - educational
15:36 - i'm not encouraging you to attack
15:38 - certain websites or something so this is
15:40 - just so that you understand how it works
15:42 - how to implement it with python and then
15:44 - you can penetration test your own
15:46 - systems with it but don't go ahead and
15:48 - you know
15:49 - attack some strangers or some websites
15:52 - of other people
15:54 - having said that let's talk about how
15:57 - this is done when you're attacking
15:58 - bigger targets because in year 2010 i
16:01 - think
16:02 - anonymous took down paypal because of
16:04 - the whole julian assange affair
16:06 - but of course the problem is that paypal
16:08 - is quite a big service and if you want
16:10 - to take down paypal and of course you
16:12 - shouldn't do it but i'm just saying if
16:14 - you want to take down a big target like
16:16 - paypal you cannot just go ahead on your
16:18 - own and run a script what you do is you
16:20 - use a so-called botnet so you in fact
16:22 - other computers these people don't know
16:25 - anything about it but you just go ahead
16:27 - and you uh in fact your computer for
16:29 - example my computer just people that
16:31 - don't know what's happening and you're
16:33 - basically having them as your zombie
16:35 - army it's not about harming these people
16:37 - so you're not infecting their computers
16:39 - with a virus deleting their file
16:41 - encrypting their files uh or you know
16:44 - getting information from them like
16:45 - passwords or something you're just using
16:47 - them as your army so you're using them
16:49 - as your soldiers
16:51 - so uh they will probably not recognize
16:54 - that you're even
16:55 - taking control of them because you know
16:57 - you're not doing anything with them
16:59 - unless you want to attack a target so if
17:01 - you have let's say 50 000 computers in
17:03 - your botnet you have 50 000 people
17:07 - for example grandmas or people that
17:09 - don't know anything about coding
17:11 - anything about networking about hacking
17:13 - they're just using their computers but
17:15 - when you say start they start executing
17:17 - the same script as you are so you're
17:19 - basically saying okay i want to hack
17:21 - paypal uh i use my botnet all these 50
17:24 - 000 computers are going to run this
17:26 - script right now and everyone is
17:27 - flooding paypal with 50 000 uh
17:30 - requests per second
17:32 - and 50 000 times 50 000 is a pretty big
17:36 - number
17:37 - and of course what happens in addition
17:39 - to that is this is just one attacker
17:41 - with one botnet and uh in the attack on
17:44 - paypal you had multiple attackers with
17:48 - their own botnets uh ddosing people so
17:51 - this is how
17:52 - they took down people and again i'm not
17:54 - recommending you to do that i just want
17:56 - you to know how this happens
17:58 - and i want you to understand how this
18:00 - works so that you can maybe penetration
18:02 - test your own systems with it or even uh
18:05 - take some counteractions security
18:07 - measures based on that knowledge but
18:09 - that is basically how ddosing works
18:13 - so now let us get started with the
18:15 - coding and the first thing that we're
18:16 - going to do is we're going to import
18:17 - threading and we're going to import
18:20 - socket
18:21 - uh socket because we're going to use it
18:23 - to connect and threading because we're
18:24 - going to run multiple threads now one
18:26 - more thing that i need to mention here
18:27 - is python is maybe not the best language
18:30 - to do this because python doesn't
18:32 - support real multi-threading so uh if
18:35 - you're doing multi-threading in python
18:37 - it's not actual multi-threading it's
18:39 - simulated multi-threading so you're
18:40 - basically switching between the tasks
18:43 - as fast as possible but it's not actual
18:46 - multi-threading so you might want to use
18:47 - a different language for that but it
18:48 - still works uh since it's sending a lot
18:51 - of requests at the same time just so
18:53 - that you know what's happening in the
18:55 - behind behind the scenes basically
18:57 - so what we need here first is we need a
18:59 - target and this target is usually an ip
19:01 - address but it can also be a
19:04 - um
19:05 - a domain name because the domain name
19:07 - can be resolved into an ip address but
19:10 - what i'm going to do here i'm going to
19:11 - just ddos my own router and i recommend
19:14 - you to do the same unless you have a
19:16 - website on your own so if you have i
19:17 - don't know
19:18 - if your name is john stevenson or
19:21 - something and you have johnstevenson.com
19:23 - please don't ddos johnstevenson.com if
19:25 - it exists but if this is your webpage go
19:27 - ahead and ddos that web page
19:30 - but um other than that just
19:33 - keep it in your own network so ddos your
19:35 - router ddos your own laptop run a run an
19:38 - apache server onto your own system and
19:40 - then ddos that if you want but don't go
19:42 - ahead and ddos some other websites it's
19:44 - highly legal again
19:46 - so the ip of my router my
19:50 - inside ip
19:51 - is 10.0.0.138
19:56 - and if you want to know what your ip is
19:58 - you can just go ahead and say cmd okay
20:00 - and then you say ipconfig
20:03 - and you're going to see
20:05 - a
20:06 - wireless lan adapter since i'm using
20:08 - wireless lan here um
20:11 - you can see your own ip this is the ipv4
20:14 - address which is the one that you're
20:15 - using in your own network so this is not
20:17 - a public ip address otherwise i wouldn't
20:19 - be showing you that this is just in my
20:21 - network at home this is my ip address
20:24 - and the default gateway is my router so
20:26 - this is the ip of it
20:28 - um so if you want to ddos your own
20:29 - router you can just go ahead and say
20:33 - ddos this ip address here uh it will be
20:35 - probably different in your system or in
20:38 - your network uh however depending on the
20:41 - port that we're ddosing different things
20:43 - can happen so if i ddos on port 22 i'm
20:46 - ddosing the ssh service so the command
20:48 - line service the secure shell service um
20:52 - and the website will still work if i
20:54 - ddos port 80 i will lead off the http
20:57 - port so the web interface might be down
21:00 - so depending on which service i'm going
21:02 - to take down or i want to take down i'm
21:04 - going to attack a different port in this
21:06 - video we're going to attack http so i'm
21:08 - going to say port equals
21:10 - 80 and what we can also do here is we
21:12 - can specify a fake ip for the header
21:16 - however please don't think that you're
21:17 - anonymous just because you specify a
21:20 - fake ip in the header you of course need
21:22 - to use um
21:23 - anonymization tools so you cannot just
21:25 - go ahead and change the http header and
21:27 - then think that you cannot be recognized
21:30 - as a hacker
21:31 - but still it's a nice extra that you can
21:33 - add to your script so you can say fake
21:35 - ip
21:37 - equals and then you just choose an ip
21:39 - whatever it is
21:40 - uh let's just choose 182.
21:45 - 2032
21:47 - and that's just one sample ip that you
21:50 - can have and these are the the things
21:52 - that you need in order to
21:54 - specify the target and also add your own
21:57 - fake information into the header
21:59 - so now we're going to define the actual
22:01 - attack method and this method doesn't
22:02 - look like an attack method because it's
22:04 - basically just an endless loop running
22:06 - uh
22:08 - a socket connection so what we do is we
22:10 - say def
22:11 - attack we need to define a method here
22:13 - so that we can later on refer to that
22:15 - method in the threads
22:17 - um and what we do is we say while true
22:19 - basically an endless loop and then we
22:20 - say s equals socket
22:22 - dot socket
22:24 - socket dot af inet
22:28 - uh which is basically just uh creating a
22:30 - new socket an internet socket and then
22:32 - specifying the protocol which is tcp so
22:35 - sock stream
22:36 - and when we've done that we just say s
22:39 - dot connect to the target on the port we
22:42 - need to pass a tuple here
22:44 - um
22:45 - and that's basically it now we have to
22:47 - send the header and for this i'm going
22:49 - to copy the two lines from the website
22:52 - just because i don't want to remember
22:54 - the whole format here
22:56 - as i said you can find the text based
22:58 - version on neural nine dot com so if you
23:00 - want you can just you know copy it from
23:02 - the website or type it in manually we
23:05 - just say get slashed and we enter the
23:07 - target then we say specify the http
23:11 - version encode the whole thing and send
23:13 - it to the target on the specific port
23:15 - then we also say host enter the fake ip
23:18 - address encode it and send it to target
23:21 - and port and after that we just close
23:23 - the connection that's basically the
23:24 - whole attack method it's just uh
23:27 - constantly connecting sending closing
23:30 - connecting sending closing over and over
23:32 - again
23:33 - but of course this would not be enough
23:34 - we need to run this in multiple threads
23:36 - so what we do is we basically say uh for
23:40 - i in range
23:42 - how many threads do you want to run you
23:43 - can say 500 for example or 50 or 5 000.
23:48 - what we do is we say threat
23:50 - equals threading dot threat
23:53 - and we basically specify target but this
23:56 - time this is not the ip target but the
23:58 - target function and this is attack and
24:01 - then we say threat
24:03 - dot start
24:05 - and that's actually it that's actually
24:07 - the whole script we just have an attack
24:09 - method we have the
24:10 - 500 threads that run this attack method
24:13 - uh when we run this the connections will
24:16 - be made but of course we won't see
24:17 - anything if you want to see how many
24:19 - connections have been made all uh
24:21 - all the time of course this will slow
24:23 - down the script so printing the
24:24 - connections uh printing the amount of
24:27 - connections already uh
24:29 - done will slow down the script so what
24:31 - we can do
24:32 - uh is we could say
24:34 - already
24:37 - uh
24:38 - i don't know attacked or okay not
24:40 - attacked
24:41 - already connected
24:43 - stupid name i know let's say zero what
24:46 - we do then is
24:47 - when we close the connection we just say
24:49 - okay global
24:50 - so that we can
24:52 - access this already connected variable
24:54 - global already connected and then we say
24:56 - already connected plus equals one and i
25:01 - think that's actually it let me take a
25:03 - look oh of course we need to print it
25:05 - sorry
25:06 - and then we can just print already
25:07 - connected
25:10 - um
25:11 - yeah then we can run it
25:13 - and see what happens you can see
25:15 - immediately
25:16 - we have around
25:18 - 500 of course it's way faster if we
25:21 - don't print all the numbers so what we
25:23 - can do is we can say
25:25 - if already
25:26 - connected modulus 500
25:30 - equals zero which basically means every
25:32 - 500
25:34 - uh
25:35 - connections you can print it what we do
25:37 - is we just say print already connected
25:40 - so it will only print
25:42 - every 500 connections
25:45 - still
25:46 - or
25:47 - did i make a mistake here oh no actually
25:49 - it's that slow
25:51 - so it's probably not a good script at
25:52 - all
25:53 - but
25:54 - still it works um
25:57 - or maybe it's that slow because i'm
25:59 - asking all the time
26:01 - i don't know
26:03 - however basically this is how you do it
26:05 - you define a method that sends a
26:07 - connection in an endless loop and then
26:09 - what you do is you basically
26:11 - uh run multiple threads at the same time
26:13 - attacking then you have bots or a botnet
26:16 - with computers that all run the script
26:18 - at the same time and then maybe you also
26:20 - have multiple attackers and in the end
26:22 - you take down a service like that
26:25 - of course you can again specify
26:27 - different ports then this part here
26:29 - doesn't make a lot of sense but you can
26:30 - also
26:31 - try to take down the ssh server or
26:35 - other services whatever
26:37 - but this is how you basically do it you
26:38 - define a method run multiple threads and
26:41 - then you take down a system
26:43 - so that's it for today's video again
26:45 - this episode was purely educational so
26:47 - first of all the script is not optimal
26:49 - you would not use it for an actual ddos
26:51 - attack it's not a good script you
26:53 - wouldn't use it
26:54 - it's just so that you can get an
26:56 - understanding of how something like this
26:58 - could be done
27:00 - but no one would ever use this python
27:02 - script for a ddos attack
27:04 - first of all because it's slow second of
27:06 - all because it's not really heavy you're
27:08 - not sending a lot of data
27:10 - um
27:11 - but it's just to see how you could do
27:13 - this in python uh second of all if
27:16 - you're using ddos this script or any
27:18 - other script keep in mind it's illegal
27:20 - use it on your own systems i mentioned
27:21 - it two times before
27:23 - but it's very important and you
27:25 - shouldn't you know do any harm with
27:27 - these scripts
27:31 - we're going to create a port scanner in
27:33 - python which is going to allow us to
27:36 - find open ports in servers computers
27:38 - printers basically any kind of host
27:42 - and
27:43 - we're going to use multi-threading to
27:44 - make this port scanner as fast as
27:46 - possible so we're going to run multiple
27:48 - threads so that we can scan hundreds of
27:51 - ports per second now before we start
27:54 - with the video let me tell you that you
27:55 - can find a text based version of this
27:57 - tutorial at neural nine dot com which is
28:00 - a blog post and there you'll also be
28:02 - able to
28:03 - copy the code if you want so
28:06 - if you're interested in that check that
28:07 - out you'll find a link into description
28:09 - and you can also check out the other
28:11 - blog posts about machine learning
28:13 - programming and so on this page if
28:15 - you're interested in them so let's get
28:17 - to port scanning now first of all why
28:21 - scan ports why are we interested in open
28:24 - ports we are interested in open ports
28:26 - because an open port especially an
28:28 - unnecessarily open port
28:30 - might be a security gap and we always
28:33 - want to find security gaps either in our
28:35 - own networks to make sure that our
28:37 - network is secure enough or if we have
28:40 - bad intentions and we are hacking we
28:43 - want to find open ports in networks of
28:46 - other people now notice that port
28:49 - scanning is illegal even though it's not
28:52 - a hacking attack in and of itself it's
28:54 - an illegal act so don't scan networks
28:56 - that you don't have any permission for
28:58 - only scan your own network your own
29:00 - computers your own servers
29:03 - don't do this for
29:05 - exploitation purposes
29:07 - so i've warned you i don't take any
29:09 - responsibility for what you're doing
29:11 - this content here is purely educational
29:13 - so if you use it for something bad it's
29:15 - your fault and i do not advise it now
29:18 - let's get into port scanning itself how
29:20 - does port scanning work or how are we
29:22 - going to scan ports now what we're going
29:24 - to do is we're going to use sockets
29:27 - to connect to a certain target to to
29:29 - connect to a certain server or ip
29:32 - address at a specific port if the
29:34 - connection succeeds we're going to say
29:36 - this port is open if it does not succeed
29:38 - we're going to say this board is closed
29:42 - and to do that we're going to implement
29:44 - a portscan method so let's start with
29:46 - that we're going to import the socket
29:48 - module
29:49 - and we're going to say uh def port scan
29:54 - and we're going to pass a port here
29:56 - now
29:58 - to scan a port as we said we have to try
30:01 - to connect so what we're going to do is
30:03 - we're going to create a socket first
30:06 - uh socket dot socket
30:09 - um
30:11 - socket again
30:13 - dot af
30:15 - e-net or inet which stands for internet
30:18 - basically we're just saying okay this
30:20 - socket is an internet socket and not a
30:22 - unix socket
30:23 - and the second parameter is socket
30:27 - dot sock stream
30:29 - sorry
30:31 - sock stream which basically just says
30:34 - that we are using tcp instead of udp now
30:37 - that we have created a socket what we're
30:38 - going to do is we're going to connect um
30:41 - and before we can connect we have to
30:43 - define where we're going to connect to
30:45 - because when we use the connect
30:47 - method we have to pass a tuple and the
30:50 - first part of the tuple is
30:52 - the ip address which would be our target
30:56 - and the second one the second parameter
30:58 - here is the port so the port is actually
31:01 - the parameter of this function so we can
31:03 - just pass it but the target we have to
31:06 - define a target and as i said
31:08 - use your own computers use your own
31:10 - servers or servers that you are
31:12 - permitted to use so
31:14 - uh do whatever you want but don't scan
31:18 - the network or someone else that you
31:19 - don't have permission to
31:22 - so basically just pick a device from
31:24 - your home
31:25 - now in my case i'm going to pick
31:27 - my router which has the ip address
31:31 - 10.0.0.138
31:34 - and it's my default gateway if you don't
31:36 - know
31:37 - what ip address to choose you can always
31:39 - pick localhost localhost would be
31:42 - 127.0.0.1
31:45 - this would be your own machine that
31:46 - you're operating on right now so if you
31:48 - don't know what to scan just scan your
31:51 - own computer that you're working on
31:52 - right now now what we're doing here is
31:55 - we're saying connect to the target which
31:58 - is our ip address here and we're saying
32:00 - connect on this particular port now
32:03 - if we don't get any errors or any
32:06 - exceptions up until now the connection
32:08 - succeeded and we can return
32:10 - true this means our port scan was
32:13 - successful or basically the port scan
32:15 - was always successful but our port is
32:18 - open so we found an open port the
32:20 - connection was successful
32:21 - um if this is not the case so if we get
32:24 - some exception some error
32:26 - we're going to just return false
32:29 - now with this method here already we can
32:32 - scan ports so
32:34 - i can just say print
32:37 - port scan
32:39 - 80 should be open because it's
32:42 - http
32:45 - and as you can see i get true now if i
32:47 - check for another port maybe 98
32:50 - hopefully it's closed
32:58 - yeah it's closed so i get false um so
33:01 - whenever i get i cannot connect to a
33:04 - port i return false and every time i can
33:07 - connect to a port i return true so this
33:10 - is how this method works and we could go
33:12 - ahead now and just write a for loop for
33:15 - port in range and then just define a
33:18 - range of ports for example from
33:20 - 1 to
33:22 - 124 which would actually just scan up
33:25 - until 123. these are the so-called
33:27 - standardized ports that are reserved for
33:31 - http ftp
33:33 - uh and
33:34 - ssh telnet and so on
33:37 - so we're going to say
33:39 - scan all of these ports and every time i
33:42 - get a result which is either true and
33:44 - false so
33:45 - board scan
33:48 - port so we're scanning the port that we
33:50 - have right now in the loop and then we
33:52 - say if the result
33:55 - we can just say if result since it's a
33:57 - boolean so if true if false you know
34:00 - if the result is true we say print
34:03 - port whatever
34:06 - is open
34:07 - and we can format
34:09 - in the port number
34:12 - and otherwise we just print
34:15 - port whatever
34:17 - is closed
34:20 - format port
34:22 - so when we run this you will see that it
34:25 - starts checking for all the ports like
34:27 - port one is closed port two is closed
34:30 - and so on and it continues to do that in
34:32 - a very very slow pace as you can see we
34:35 - barely make any progress it's very very
34:38 - slow
34:41 - now to change that what we can do is we
34:44 - can introduce multi-threading as i said
34:46 - and to do this we cannot just start 30
34:49 - threads because it would be very
34:51 - inefficient to just run multiple threads
34:53 - because if we just run multiple threads
34:55 - what happens is we can or the
34:57 - possibility is there that we check the
34:59 - same port number twice
35:01 - so to make this as efficient as possible
35:03 - we're going to use so-called cues so
35:06 - we're going to import two more libraries
35:08 - here first of all import threading
35:10 - because we need we need the threads and
35:13 - also from q
35:16 - import q
35:18 - with a capital q
35:19 - so a cube basically is like a connect a
35:23 - collection or like a sequence like a
35:24 - list maybe where we have all kinds of
35:27 - elements and every time that we get an
35:29 - element from this list it's no longer in
35:31 - the list so uh we're basically cueing
35:34 - the elements
35:35 - in this case we're queuing the port
35:36 - numbers and i can say i have all the
35:39 - ports numbers port numbers from one to
35:42 - one thousand and every time i get one
35:45 - uh the whole list the whole sequence
35:47 - shifts and i can get a new one well
35:49 - we'll see how this works in a second
35:52 - but first of all let's remove this loop
35:55 - and start by defining an empty queue
35:58 - here that we're going to fill up later
36:00 - on so q equals q
36:03 - and i'm also going to create an empty
36:05 - list with the op 40 open ports actually
36:09 - this is the list where at the end we'll
36:11 - add all the open ports so that we can
36:13 - see which ports are open in an
36:16 - uh final report
36:19 - now what we're going to do now is we're
36:20 - going to fill up this queue and to do
36:22 - this you can choose whatever method you
36:24 - want you can just fill
36:26 - uh
36:27 - i don't know 10 000 porch numbers into
36:29 - it you can uh fill
36:31 - just a list of numbers into it you can
36:33 - write your own method if you want what
36:35 - what we're going to do right now is
36:36 - we're going to define a method fill
36:40 - fill queue
36:42 - and we're going to
36:45 - say from
36:46 - port
36:48 - and to port so we're going to define a
36:50 - range you can also pass a list it
36:53 - doesn't matter
36:54 - basically you're just saying
36:56 - or let's let's do a list actually it's i
36:58 - think it's more it's better let's say
37:02 - port list
37:04 - we're going to pass a port list and what
37:07 - we're going to do is very simple we're
37:09 - just saying
37:11 - for port in port list
37:17 - we are going to
37:20 - put in every port into the queue
37:24 - now the queue operates by the first in
37:26 - first out system so the port that enters
37:29 - the list first is the first to get
37:31 - scanned so i'll start putting in one two
37:34 - three and these are the ports that will
37:36 - be scanned first so
37:38 - i'm basically just taking the list that
37:40 - we can pass later on and i'm
37:43 - filling this list into the queue
37:47 - now the next step is to define a
37:50 - so-called worker method because the
37:52 - worker method is the actual
37:54 - function or method which our threats are
37:57 - going to be using so
37:59 - when we run a threat we want it to
38:01 - execute this function and this will be
38:04 - the port scan actually so we're going to
38:06 - say for every thread every thread is
38:08 - going to execute this
38:09 - while not
38:11 - q dot empty so basically as long as
38:14 - there are elements that are not scanned
38:16 - in the queue as long as the queue is not
38:18 - empty
38:19 - what i'm going to do is i'm going to say
38:22 - port equals q dot get so i'm going to
38:25 - get the next port in the list since it's
38:27 - not empty i'm going to get one
38:30 - and then i'm going to say if port scan
38:33 - of this port
38:35 - returns true
38:36 - i'm going to print
38:38 - port
38:40 - whatever is open
38:44 - and we're going to say format port
38:48 - and additionally we're going to add the
38:50 - port to the open ports list so we're
38:52 - going to say open ports dot append
38:54 - port so we're adding our port to the
38:57 - open ports list so that we can have a
39:00 - good final report in the end
39:02 - now
39:03 - otherwise if you want you can also print
39:07 - port whatever is closed but when we run
39:10 - that many threads it will be very very
39:12 - hard to find the open ports because
39:14 - we'll have a lot of statements at the
39:16 - same time so i think it's more
39:18 - beneficial to just print the open port
39:21 - just so we get a better overview of this
39:25 - so we're going to delete this and we're
39:27 - only going to print something if the
39:30 - port scan returns true otherwise we're
39:32 - not going to do anything
39:35 - so these are the functions that we're
39:37 - going to use now what we need to do is
39:38 - first of all we need to fill our queue
39:41 - and we can do whatever we want you can
39:43 - say i want all the ports from zero to
39:46 - five thousand or i want only twenty two
39:49 - eighty four four three and so on only
39:52 - the important ports that i'm interested
39:54 - in just to find your own list if you
39:56 - want i'm going to say a port list equals
39:59 - range
40:00 - 1
40:02 - up until 124
40:06 - and
40:07 - now i'm going to say
40:08 - fill queue
40:10 - port list
40:14 - so the next step is to define a an empty
40:18 - thread list
40:20 - and i'm going to explain in a second why
40:22 - we need a list for our threads because
40:24 - actually to run the threads we don't
40:25 - need this list but
40:28 - we're going to need this list later on
40:29 - because otherwise the last part of this
40:32 - script is not going to work so
40:34 - first of all
40:36 - we're going to say 40 in
40:38 - range
40:39 - and now we're going to specify the
40:41 - number of threads that we go uh we want
40:43 - to run so
40:45 - do you want to run 10 threads do you
40:46 - want to run 20 threads 100 threads
40:48 - whatever so let's start with 10 threads
40:51 - so
40:52 - range 10 and now we're going to say
40:55 - threat
40:57 - equals threading
40:59 - dot thread with a capital t
41:01 - and we're going to say target
41:04 - equals
41:07 - target equals worker
41:10 - notice that we're not calling the worker
41:12 - function here so we're not saying worker
41:13 - in parentheses we're just saying worker
41:15 - so we're referring to the worker
41:17 - function without actually calling it now
41:20 - what we're doing here is we're creating
41:22 - 10 so range 10. so 10 times we're
41:24 - creating a new thread with the worker as
41:28 - the target function and then what i'm
41:30 - going to do is i'm going to say thread
41:33 - threadless dot append thread
41:37 - and
41:38 - then we have all these threads that we
41:40 - created right now in our list now the
41:42 - next step is to run all of these
41:45 - so we can see for thread in thread list
41:50 - thread dot start
41:53 - and last but not least this is the
41:55 - important part why we need the list
41:57 - we're going to wait for all threads to
42:00 - finish so we're going to say for thread
42:02 - in
42:03 - thread list
42:05 - thread
42:06 - dot join the join method waits until the
42:10 - thread is done until it continues with
42:12 - the code so after this statement here
42:14 - we're going to print
42:17 - the open ports
42:19 - open ports are
42:21 - and open ports
42:23 - and the reason we have to join here is
42:24 - because we don't want this to get
42:26 - printed
42:27 - until all the threads are done so we
42:31 - only want to print all the ports that
42:32 - are open in the end when every thread is
42:35 - finished
42:37 - so basically that's it now let's run
42:38 - this
42:39 - when we run this
42:41 - you will see that
42:46 - we're going to make progress quite fast
42:48 - so we already reached 22 25
42:52 - and it scan basically scans 10 ports per
42:55 - second more or less we have 10 times the
42:57 - speed that we had in the beginning so as
42:59 - you can see we already reach port 80
43:02 - but it's still not the fastest so if we
43:04 - want to have this even faster we just
43:07 - don't say 10 but we can say 100 and then
43:10 - it will already scan 100 ports so we
43:12 - already scan for 80
43:14 - 143 and so on and it's way faster and we
43:18 - can keep increasing the number as long
43:20 - as
43:21 - it seems to be faster because you know
43:23 - sometimes or at some point you
43:26 - you will reach a limit and your computer
43:28 - is not going to execute faster
43:31 - but
43:32 - you can try with 500 for example and you
43:34 - will immediately reach
43:36 - 500
43:38 - as you can see so it's quite fast
43:42 - i think when you say a million it's not
43:44 - uh it will not be faster but
43:48 - as you can see with 500 it works quite
43:50 - well
43:52 - these are the open ports actually quite
43:54 - a few
43:55 - and
43:56 - i'm going to have to take care of that
43:58 - because
43:59 - obviously a lot of ports are open
44:02 - in my router
44:08 - we're going to develop a tcp chat and
44:10 - python so we're going to set up a server
44:13 - and we're going to set up multiple
44:14 - clients and these clients can then
44:15 - connect to the server which works as a
44:18 - chat room you could say and each client
44:20 - can then send messages to the server
44:22 - with his or her nickname and all the
44:24 - other clients can see these messages and
44:26 - respond so let us get into the code
44:29 - now the first thing we're going to do is
44:31 - we're going to create a server file so
44:32 - we're going to right click onto the
44:34 - directory and create a server.py
44:37 - file and in here we're going to import
44:39 - threading
44:41 - import threading and import sockets
44:43 - these are the two modules that we're
44:45 - going to
44:46 - need in this video and if you don't know
44:48 - how to work with sockets or you don't
44:49 - know what sockets are you don't know
44:50 - what multi-threading is i highly
44:52 - recommend that you check out the python
44:54 - intermediate tutorial series on this
44:56 - channel because there i talk about
44:58 - network programming about
44:59 - multi-threading what
45:01 - these things are i also have a tutorial
45:03 - on how to make a port scanner a
45:05 - multi-threaded port scanner where i use
45:07 - both concepts so check out these videos
45:10 - uh because i'm not going to go too much
45:11 - into the details of threading or sockets
45:13 - in this video now the first thing we
45:15 - need to do here is we need to define a
45:17 - host address and a port for our server
45:19 - so
45:20 - the host in this case will be just
45:22 - uh
45:25 - 127.0.0.1 because we're using localhost
45:27 - so let's add a comment here localhost
45:31 - this is just because we are running this
45:33 - on our machine if you run the server on
45:35 - a web server you should always uh
45:38 - pick the host address of the server so
45:40 - always the ip address of the server uh
45:43 - this is just the basic localhost since
45:45 - we're running it on this computer it uh
45:48 - will be localhost
45:49 - then we need a port and as a port you
45:51 - can choose whatever you want you could
45:52 - just go with
45:55 - 99872 or something like that
45:58 - what you shouldn't do is you shouldn't
46:00 - take ports like 80 because this is uh
46:02 - http you should just not pick any
46:04 - reserve ports or well-known ports at all
46:07 - so uh just don't choose any ports from
46:10 - one to i don't know i think 10 000 or
46:13 - something but we're just going to go
46:15 - with 55 5555
46:19 - this is a solid port um
46:21 - [Music]
46:22 - and then what we need to do is we need
46:23 - to start service so we're going to say
46:24 - server equals
46:27 - socket and in here we're going to say
46:29 - it's an internet socket so socket dot af
46:32 - inet
46:35 - and then we're going to say it's uh
46:39 - socket dot suck stream so again if you
46:42 - don't know what that means
46:44 - uh oh sorry socket dot
46:47 - sock stream
46:49 - if you don't know what that is and if
46:50 - you don't know uh why we're creating a
46:52 - socket in that way check out the
46:54 - intermediate tutorial series today we
46:55 - talk about these concepts so next thing
46:58 - is we need to bind the server to the
47:00 - host and the ip address so we say
47:01 - server.bind and we pass a tuple of host
47:04 - and port
47:05 - so we're saying okay the server is bound
47:07 - to the localhost on port five five five
47:10 - five five five i think this was five
47:13 - times fives hopefully uh then we say
47:15 - server.listen which basically puts our
47:18 - server into listening mode for a new
47:20 - connection so as soon as we say
47:21 - server.listen the server starts
47:23 - listening for incoming connections
47:26 - now what we're going to do next is we're
47:27 - going to define a couple of methods
47:29 - we're going to define three methods the
47:30 - first one being a broadcast method the
47:32 - second one being a handle method for
47:35 - client connections and the last one
47:37 - being a receive method which basically
47:39 - combines all the methods into a main
47:41 - method you could say but before we do
47:43 - that we're going to define two empty
47:44 - lists here and these two empty lists are
47:47 - the clients list and the nicknames
47:50 - list so these two lists will be the list
47:54 - uh where we put all of our clients in so
47:56 - if we have a new client connecting to
47:58 - the server we're going to put it into
47:59 - the clients list and also we're going to
48:02 - get the nickname of this client which
48:04 - the client can then later on choose and
48:06 - we're going to say okay the client x has
48:08 - the nickname uh i don't know bob or
48:11 - something like that
48:12 - uh and then we can just use clients and
48:14 - nicknames to
48:16 - do certain things later on now the first
48:18 - function we're going to define here is
48:19 - the broadcast function's a very simple
48:21 - function it's just a function that sends
48:23 - a message to all the clients that are
48:25 - currently connected to this server so
48:28 - i'm going to say def broadcast
48:31 - and we're going to pass a message here
48:33 - so we're going to say broadcast message
48:35 - and then we're just going to save for
48:37 - every client in the clients list which
48:40 - now is empty but later on we're going to
48:42 - fill it up for every client that is now
48:44 - connected to the server we're just going
48:46 - to say
48:47 - dot sent
48:48 - this message very simple we're just
48:51 - getting all the clients and sending a
48:53 - particular message and this is how you
48:55 - broadcast messages from a server to all
48:57 - the clients
48:59 - so the next thing that we want to do is
49:00 - we want to handle the client connection
49:01 - so when a client connects to the server
49:03 - we want to receive messages from the
49:05 - client if the client is sending any and
49:07 - then we also want to uh send back
49:09 - messages to all the other clients
49:11 - depending on what the client sends so if
49:13 - client a says hi
49:15 - we want to get this message process it
49:17 - and then broadcast it to all the other
49:19 - clients including uh also client a
49:22 - itself because every client needs to see
49:24 - what's happening in the server so what
49:26 - we want to do is we want to find a
49:27 - handle function and we want to handle
49:29 - one particular client so we're we're
49:30 - going to later on run this function on
49:33 - all of the individual clients but for
49:35 - now we're just handling one uh single
49:37 - client so we're getting the client and
49:39 - what we do is we say while true
49:41 - basically we're starting an endless loop
49:43 - here we're saying try a certain thing so
49:46 - as long as it works without giving you
49:47 - an exception or an error we're going to
49:50 - just say message
49:52 - equals
49:53 - client dot receive i think it's like
49:56 - that our ecv
49:58 - uh
49:59 - 1024 bytes
50:02 - just
50:02 - the basic method uh message so what we
50:04 - do here is we say okay as long as it
50:07 - works that we receive a message from the
50:09 - client we're just going to broadcast it
50:12 - to all the other
50:14 - um
50:15 - clients
50:17 - or oh sorry no uh broadcast a message to
50:19 - all the other clients so what we're
50:21 - doing here is we say try to receive a
50:23 - message from the client and if that
50:25 - succeeds broadcast this message to all
50:27 - the other clients including this client
50:29 - as well
50:30 - uh if that doesn't work so if we get
50:32 - some exception some error while
50:34 - receiving the message or while
50:36 - broadcasting what we're going to do is
50:38 - we're going to just cut the connection
50:40 - to this particular client remove it from
50:42 - the list and then uh basically terminate
50:45 - this function so we're going to say or
50:46 - terminate this loop so we're going to
50:48 - say the index of this particular client
50:51 - is the clients.index
50:54 - of this client and we need this index in
50:55 - order to remove the nickname and the
50:57 - client from the list
50:58 - so we're just getting the index okay
51:00 - where is this particular client that
51:01 - failed right now in the list which index
51:04 - does it have and then we're going to say
51:06 - clients.remove
51:08 - client so we're going to just remove the
51:10 - client we're going to close the
51:12 - connection to the client and then we're
51:14 - also going to say okay the nickname of
51:16 - this client
51:17 - is the nicknames
51:20 - index of the client so basically
51:23 - whenever we're adding a client we're
51:25 - also adding the nickname so they will
51:26 - always have the same index and when we
51:29 - remove a client we also remove the
51:31 - nickname on this particular index so
51:33 - that we don't get any inconsistencies
51:35 - here so what we do then is we say
51:38 - nicknames dot
51:41 - remove
51:42 - our nickname
51:46 - and you could either print it before
51:47 - that i'm going to print it before that
51:49 - or you can print it afterwards we're
51:51 - just going to broadcast to all the
51:52 - clients that this client has now left so
51:54 - we're going to say broadcast and we're
51:56 - going to use an f string here and we're
51:59 - going to say nick name
52:04 - left the chat
52:06 - for example
52:07 - um and then we're going to encode this
52:10 - message
52:11 - in
52:12 - ascii code
52:14 - so that
52:16 - we get the right message so after that
52:19 - of course we're breaking out of the loop
52:20 - and that's it so we're handling a client
52:23 - one client connects and what we're doing
52:25 - is we're constantly trying to get
52:27 - messages from this client uh this will
52:30 - not give you an error if the client is
52:31 - not sending anything but it will give
52:33 - you an error if this client is not there
52:35 - anymore so as soon as a client produces
52:38 - some kind of error what we do is we just
52:40 - remove it from the list remove the
52:41 - nickname and broadcast to all the
52:44 - different uh clients connected to the
52:46 - server that this client is now left and
52:49 - then we just terminate this function so
52:51 - this function will later on run in a
52:53 - threat for each client we'll have a
52:55 - single thread running and processing
52:57 - this particular function or actually
52:59 - executing the handle function and as
53:01 - soon as a client disconnects what we do
53:04 - is we just break this um
53:06 - loop and therefore terminate the
53:08 - function therefore terminate or end the
53:10 - threat
53:11 - so this is how we're going to handle the
53:13 - client
53:14 - connection
53:16 - so now last but not least in the server
53:17 - what we're going to do is we're going to
53:18 - define the main method the receive
53:20 - method which combines all these things
53:23 - that we've written up until now into one
53:25 - function so we're going to say def
53:27 - receive and we're going to just receive
53:30 - client connection so we're saying while
53:32 - true
53:34 - what the server is doing it is basically
53:36 - accepting all the connections so
53:39 - we're going to say client and address
53:42 - equals server.accept so what's happening
53:45 - is we're running the accept method all
53:46 - the time and if this method gets a
53:49 - connection what we get what it returns
53:52 - is a client and the address of the
53:54 - client so in this case we're always
53:56 - going to have the same address since
53:58 - we're on one computer but if you have
53:59 - this running on a server you'll see the
54:01 - address the ip address of this client
54:03 - connecting to your server
54:05 - so
54:06 - basically we're connecting to clients or
54:08 - allowing the clients to connect and if
54:10 - this is done if this happens if a client
54:12 - connects we're just going to say print
54:15 - on the server itself this is not a
54:16 - broadcast this is just on the server
54:18 - console so that we see what's happening
54:20 - um
54:21 - connected
54:24 - with and let's make an f string out of
54:27 - this connected with
54:29 - address
54:31 - so that we know
54:33 - actually we should say str address
54:39 - double d
54:40 - there you go so we're waiting for a
54:42 - connection we're accepting all the
54:43 - connections coming and if a connection
54:46 - happens to come
54:47 - in fact come in this moment what we do
54:49 - is we just print that we now connect it
54:52 - to this client on this particular
54:54 - address and then of course what we want
54:56 - to do is we want to get the nickname of
54:57 - the client so the client will be able
54:59 - before it connects to our server to
55:01 - choose a nickname and it will then it
55:03 - will then be the nickname that is
55:04 - displayed on the server uh so what we
55:07 - need to do first is we need to ask the
55:09 - client for the nickname because of
55:11 - course if it just sends us a message
55:12 - we're going to process it but the first
55:14 - message that the client sends to us
55:16 - should be the nickname so what we're
55:18 - going to say is we're going to send a
55:19 - message
55:20 - to this client and this message will be
55:22 - a code word which is not visible to the
55:24 - user of the client it's just visible to
55:26 - the client itself later on in the code
55:29 - we're going to send the keyword nick and
55:32 - if the client receives this keyword nick
55:35 - it should be um
55:36 - it should be informed that it should
55:38 - send the nickname to the server so that
55:40 - the server knows who are you we're going
55:42 - to say encode
55:44 - ascii again
55:45 - and we're basically just sending this
55:47 - keyword and in the next step what we
55:49 - hope to receive from the client is
55:52 - the nickname itself so we're going to
55:53 - say client dot
55:55 - receive
55:57 - and we're going to receive 1024
56:00 - bytes and decode them from ascii
56:06 - so
56:07 - then of course what we're going to do is
56:09 - we're going to say nicknames
56:11 - dot append
56:13 - nickname
56:15 - and clients
56:17 - dot append
56:19 - client
56:21 - and then what we need to do is we just
56:23 - need to send a couple of messages here
56:25 - so we're going to say okay
56:26 - print
56:28 - nickname of the client is okay so there
56:30 - you go nickname of the client
56:35 - is and then nickname
56:37 - of the knight of the client just
56:39 - connected is whatever
56:41 - and then we're just going to broadcast
56:44 - that so that everyone every client is
56:46 - currently connected to the server
56:48 - knows that this client is now connected
56:50 - and that's the nickname of this client
56:51 - so we're just going to say
56:53 - f string
56:56 - nickname
56:59 - joined the chat
57:02 - and we're going to encode this message
57:05 - again
57:07 - and then every server uh sorry every
57:09 - client knows that there is a new client
57:11 - in this chat
57:12 - and they get a message that this client
57:14 - just joined the chat with the respective
57:17 - nickname
57:18 - and then we're going to send the
57:19 - particular client that just connected
57:21 - we're going to send to the one client
57:23 - that uh this client connected to the
57:25 - server so we're going to say sent
57:28 - uh
57:29 - connect it to the server so that the
57:32 - client knows that it's now connected and
57:34 - it can start chatting and of course
57:36 - we're going to encode this message as
57:38 - well
57:41 - now we're almost done the last two
57:42 - things that we're going to do is we're
57:43 - going to define a thread and run a
57:45 - thread so we're going to say threat
57:47 - as we said we're going to run one thread
57:49 - for each client connected because we
57:51 - need to handle them
57:52 - at the same time we cannot just handle
57:54 - them serially because uh one client
57:56 - might send something and another client
57:58 - might send something and we need to
57:59 - process it at the same time or at least
58:02 - uh roughly at the same time and not just
58:04 - you know process one client interaction
58:07 - then start with the next one
58:09 - so what we're going to do is we're going
58:10 - to say threading dot threat
58:14 - capital t
58:16 - and the target of this thread will be
58:18 - the handle function
58:19 - and the arguments
58:21 - will be just client
58:24 - and then we're going to say threat
58:27 - dot
58:28 - start and if you know about if you know
58:31 - how to deal with python frets you know
58:33 - that you need to use the start method
58:34 - and not to run method because otherwise
58:36 - this doesn't work
58:37 - so let's uh look one more time at this
58:41 - code what we're doing is we're just
58:42 - saying accept clients all the time when
58:45 - a client actually connects we're going
58:47 - to just say okay connected with this
58:48 - client so that the server admin knows
58:50 - what's happening
58:51 - then we're going to send to the client
58:53 - the keyword nick or the code word nick
58:55 - so that the client knows okay i need to
58:57 - send my nickname we're then going to
58:59 - receive the nickname from the client
59:00 - append this nickname and this client to
59:03 - our lists and then we're going to print
59:05 - on the server again for the server admin
59:07 - that the nickname of this client is
59:08 - whatever then we're going to broadcast
59:10 - to all the clients connected to the
59:12 - server that this client with this
59:13 - nickname now join the chat we're going
59:16 - to send a message to the particular
59:17 - client that the connection was
59:19 - successful and then we're going to start
59:21 - a thread handling the connection to this
59:23 - particular client
59:26 - so now we can actually start coding the
59:28 - client but before we do that i need to
59:29 - add one more line here the receive
59:31 - method also needs to be called because
59:32 - we defined all this but we didn't run it
59:34 - so the received method is our main
59:37 - method and it runs down here uh we could
59:39 - actually also go ahead and run the
59:40 - server but you're not going to see
59:42 - anything but a good sign is that it's
59:45 - running and not crashing so it probably
59:47 - works but for the server to do something
59:49 - of course we need a client to connect to
59:51 - it because otherwise it's not going to
59:52 - do anything
59:54 - what we could do is we could just print
59:56 - out the message
59:58 - server is listening
60:00 - listen
60:03 - dot dot dot and then it
60:07 - yeah you can see the server is listening
60:09 - and that's how you run the server now
60:11 - the next thing is we need to define the
60:12 - client so we're going to say client dot
60:15 - py and here also we're going to import
60:17 - socket and import threading
60:22 - and we're also going to define a socket
60:24 - so we're going to say client
60:26 - equals socket dot
60:30 - socket
60:31 - af oh sorry socket dot af
60:35 - finite
60:37 - and socket dot
60:39 - suck stream
60:43 - there you go and now instead of binding
60:45 - the client to our a port and a host
60:48 - we're going to connect it to a
60:50 - host on the port so we're going to say
60:52 - client.connect
60:55 - and we're going to connect it to
60:57 - localhost so 127.0.0.1
61:01 - and we're going to connect it on port
61:03 - 55555
61:06 - and now we're connecting it to the
61:08 - server so in this line when this line
61:09 - gets executed the server will receive uh
61:12 - will trigger the accept method and the
61:14 - client is now connected to the server
61:16 - so what we're going to do in this client
61:18 - is we're going to define two methods and
61:20 - run two threads simultaneously so we're
61:22 - going to receive all the time data from
61:25 - the server so we're going to have a
61:26 - receive function that's running
61:27 - constantly and at the same time we're
61:29 - going to
61:31 - um
61:32 - to send messages or we need a thread
61:35 - running for all the messages that we're
61:36 - going to send so let's start with the
61:39 - receiving part define a function receive
61:42 - and this function is just running again
61:44 - in a while true loop
61:47 - and we're going to try something all the
61:49 - time what we're going to try is we're
61:51 - going to receive messages from the
61:54 - server so in this case uh we'll say
61:57 - client.receive but the client is
61:59 - actually receiving from the server so
62:00 - what we're going to do is we're going to
62:01 - say message equals
62:03 - client.receive just don't get confused
62:06 - we're still receiving from the server
62:07 - not from the client but
62:09 - uh for the server to send messages it
62:11 - uses a client so it could be considered
62:14 - a client so
62:15 - we're receiving
62:17 - 1024 bytes and we're decoding what we
62:20 - receive
62:22 - and that's basically it now what we need
62:24 - to do is we need to check if the message
62:26 - that we just received
62:28 - is nick or something else so we're going
62:30 - to say okay if message
62:33 - equals nick which is the keyword for
62:35 - sending the nickname
62:37 - we're going to send the nickname i'm
62:39 - just going to pass here because we need
62:41 - to get the nickname first in the
62:42 - beginning of the script
62:44 - and if it's not nickname what we're
62:46 - going to do is we're just going to print
62:47 - the message so whenever we get a message
62:49 - from the server that's not nik or any
62:52 - other keyword that we define we're just
62:53 - going to print the message because we're
62:55 - not going to do anything about it we
62:57 - just want to see what the server has to
62:59 - tell us so we're going to say message
63:02 - print or print message
63:04 - if that doesn't work what we're going to
63:06 - do is we're just going to close the
63:08 - connection so we're going to say
63:09 - uh
63:10 - an error occurred
63:14 - and
63:15 - i think double r
63:17 - i'm not sure
63:19 - oh man i think it's
63:20 - misspelt yeah double r
63:22 - uh an error occurred and uh then we're
63:25 - just going to close the connection so
63:27 - we're going to say client close
63:29 - and we're going to break this endless
63:32 - loop
63:34 - now how are we going to send the
63:35 - nickname first of all we need the
63:37 - nickname so we're going to say nickname
63:40 - equals
63:41 - input
63:43 - choose a nickname so whenever we run a
63:45 - client the first thing that we want to
63:47 - do is we want to choose a nickname
63:49 - and if the message equals nick what
63:52 - we're going to do is we're going to say
63:54 - client dot
63:56 - sent and we're going to send the
63:59 - nickname the encoded version
64:02 - to the server so what's happening here
64:03 - is the server is listening all the time
64:06 - the client is choosing a nickname
64:08 - connects to the server and the moment
64:10 - this happens this gets triggered we say
64:13 - connected with whomever and the first
64:15 - thing that the server then does is it
64:17 - sends the keyword nick so we're going to
64:19 - get the keyword nick we're going to send
64:21 - the client name or the nickname
64:24 - then we're going to receive it here
64:25 - append it and whatever and then we're
64:27 - having a connection and as soon as the
64:30 - server sends something to us we're going
64:31 - to receive it and print it onto our
64:34 - screen
64:36 - now let's finish off the client by
64:37 - defining the second function which is
64:39 - the write function and what this
64:41 - function does is it runs a while loop as
64:44 - well
64:45 - in endless loop and here what we do is
64:47 - we always define a new message so we're
64:49 - going to say message equals
64:51 - um
64:52 - f string and here we're going to say
64:55 - nickname
64:57 - colon and then the actual message the
64:59 - actual message is always what the user
65:02 - puts into the script so
65:03 - oh i need to use double quotation marks
65:05 - here um what we're doing here is we're
65:08 - constantly running new input functions
65:10 - so as soon as the user clicks enter and
65:12 - sends one input we ask for the next one
65:15 - so the user the only option that the
65:17 - user has is to either close the client
65:19 - or write new messages so are always
65:22 - waiting for new messages this is a
65:23 - threat
65:24 - receive and write will run
65:26 - simultaneously and the right function is
65:28 - always waiting for a new message and you
65:30 - send a message by clicking the enter key
65:32 - and once you get a message so once you
65:34 - click enter or press enter what happens
65:36 - is you say client dot sent
65:39 - and we're sending the message of course
65:41 - encoded
65:43 - and that's basically it that's the whole
65:46 - function
65:47 - and now what we need to do is we need to
65:48 - run two threads we need to run a receipt
65:50 - thread and a right thread so we're going
65:52 - to say receive
65:54 - thread equals
65:56 - uh threading
65:58 - dot thread
66:00 - with the target function of receive we
66:03 - don't need any arguments here
66:05 - and then we're going to say receive
66:06 - thread
66:07 - dot start
66:10 - and then we're going to do the same
66:11 - thing for the writing thread so right
66:13 - thread
66:14 - equals threading dot threat
66:17 - and a target here is the right function
66:20 - and we're going to start this thread as
66:22 - well
66:23 - and now we're done with that
66:26 - but
66:27 - uh the problem here is that in pycharm
66:29 - we can only run
66:31 - one client at a time and to see how this
66:33 - works we need to run one server and two
66:35 - clients so i'm going to run this in a
66:37 - command line right now
66:39 - so right here i navigated three
66:40 - terminals into the direction of the tcp
66:43 - chat and what i'm going to do on the
66:44 - left side here this will be a server and
66:46 - these two right terminals here are going
66:48 - to be
66:50 - the clients so i'm going to just say
66:53 - python server
66:55 - dot py and as you can see server is
66:56 - listening and here we're just going to
66:58 - say python client
67:03 - and we can choose a nickname so for
67:04 - example let's say neural nine
67:07 - is a nickname and as you can see we get
67:09 - connected with the ip address and the
67:11 - port nickname of the client is neural
67:13 - nine i can see here on the right neural
67:16 - nine join the chat because this is a
67:17 - broadcast message that gets sent to all
67:20 - the clients including myself
67:22 - uh and also connected to the server and
67:25 - now we can run a second client so we say
67:27 - python
67:30 - client.py
67:33 - and i can choose a nickname here let's
67:35 - say youtube
67:37 - audience so you guys
67:39 - and you can see i get here again
67:40 - connected nickname is youtube audience
67:42 - here i see youtube audience joined to
67:44 - chat connected to server and here on
67:46 - neural nine i can see
67:48 - uh youtube audience joined the chat so i
67:50 - can say hi or hey
67:53 - youtube
67:55 - then what happens here in the server i
67:56 - don't see anything because the server is
67:58 - just monitoring the connections and here
68:00 - on the client side i see hey youtube
68:02 - from myself but also the youtube
68:04 - audience here sees hey youtube from
68:07 - neural nine so it can answer
68:09 - hey
68:10 - what's up
68:12 - and i can also see it up here and i can
68:14 - also start spamming here if i want and
68:17 - you'll see it in both uh
68:20 - clients so this is how you do a
68:21 - professional advanced chat of course you
68:24 - could also add some special commands
68:26 - like kik or ban or i don't know emojis
68:29 - or something but this is a basic version
68:32 - of a chat room