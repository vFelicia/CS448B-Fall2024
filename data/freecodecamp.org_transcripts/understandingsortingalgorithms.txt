00:00 - sorting algorithms are used regularly in 
computer science and programming. In this course,  
00:04 - you will learn how the most popular sorting 
algorithms work using diagrams and code.
00:17 - Coding time with coding cleverly, but this time, 
we're on a different channel. That's right, coding  
00:23 - cleverly is being featured by Free Code Camp. 
This video will be about some of the different  
00:29 - sorting algorithms that you can apply to almost 
any programming language. The language focused in  
00:34 - this video will be c++, however, like I said, you 
can apply the concepts to any other languages of  
00:40 - your choice like Java, Python, C, and so on, you 
would at least need to know the fundamental core  
00:46 - concepts of programming, especially the basic 
programming constructs, like sequence selection  
00:51 - and iteration. To understand this video, Also, 
make sure to check out my channel coding cleverly,  
00:57 - where I've covered almost every concept from 
programming fundamentals, to object oriented  
01:02 - programming all the way to data structures and 
algorithms and beyond. Okay, so let's start by  
01:07 - writing a simple algorithm for sorting an array. 
So first of all, let's include our iostream and  
01:12 - encourage you to type along with me to get the 
maximum practice. So ash include iostream. And  
01:18 - then we have our namespace standard. And then we 
have our integer main. And we also have our return  
01:27 - zero right here. So we're going to start off with 
a very simple algorithm. And we're going to look  
01:31 - at its visual implementation. So suppose we have 
an array of four elements. And that's the four  
01:37 - sides we have 231, and five. And basically, this 
is an array, which is basically indexed having  
01:44 - values from zero all the way to three. So our job 
is to sort this in ascending order, we know that  
01:50 - this is not in ascending order. So we're going 
to use a very simple algorithm. And I'm going  
01:55 - to create, actually the implementation here. So 
then after that, we go back to our code editor,  
02:00 - and we're going to type along, and it's just going 
to make much more sense. So suppose we have two  
02:05 - variables, and we're going to have one variable, 
which is going to be enlisted on the top, so we're  
02:10 - going to have that as AI. So that is going to be 
the first one, which is zero location. And then  
02:15 - we have j, which is going to be the second one, 
which is going to be i plus one. So right after  
02:19 - the AI is going to be the J and we're going to 
play apply actually a nested for loop. So first  
02:25 - for loop is going to have some condition, though 
after inside, there's going to be a premonition  
02:29 - that says j is less than I. So over here, what it 
means is that the array of that j m, the value of  
02:36 - that j is less than the value of that I now that's 
what I meant by array sub j and less than arrays  
02:44 - of absolute value of j less than the I value, this 
is our condition that's going to be inside of our  
02:49 - nested for loop the internal one. And this is the 
condition if it's true, we're going to create a  
02:54 - temporary variable, and we're going to store the 
value of i so whatever's in it, so in this case,  
02:59 - it would two is in it. So two is going to be 
stored in temp, so then we're going to swap it  
03:04 - using a swift same swapping methodology is equal 
j and j is equal to temp variable. So whatever the  
03:09 - temp value was actually was if value is value 
was two, that's going to be in J. So actually,  
03:14 - we just implemented a swap methodology here. So 
right after that, we're going to check in this  
03:20 - condition. So in this case, we have two and three, 
so a value of three is actually greater than the  
03:24 - value of two. So in this case, the condition 
won't be true, and it won't execute. So this is  
03:29 - just going to skip the value. And we're just going 
to make our j now increment to the next portion.  
03:35 - So we're going to skip this. So I just crossed 
this out. And now I go and put this next pointer  
03:40 - over here and J. So now I n j, now you can 
see that j is value is less, now we have one  
03:45 - and we have a comparing with two. So g one is 
less than two. So this condition is now true,  
03:50 - you could see that one and two are going to be 
located talking about the values. And now that the  
03:58 - condition is going to be satisfying here. So we're 
going to look over here that temp is equal to i,  
04:04 - and then we have the value which is I so what is 
I to so that's going to be in that temp variable  
04:11 - is equal to j now j is actually one, so i is equal 
to one, so we're going to have here i is equal to  
04:18 - the value one. Now after this we have j so j is 
equal to Now the value of temp. Now temp value was  
04:27 - actually two. So now you can see that this 
swapped value. So we have I, which is now one  
04:32 - except for two now two, and now over here in the 
J position instead of one. Now we have the value  
04:38 - of two. Now you can see that swapped out and now 
Jays value going to be incremented. So you can  
04:42 - see that the index is now no longer going to be 
here. And now it's going to be in the fifth Bay  
04:47 - actually the last one, which is where the fifth 
value is. And we're going to be checking again  
04:52 - we're gonna say i and j will say j is less than 
I, well, no, it's not j is greater than I. So  
04:58 - now this portion of that nested for loop will 
be terminated. And what what's gonna happen  
05:03 - now is our eyes are going to be incremented. 
So I plus plus, and we're gonna have I know,  
05:08 - plus one. So originally where j was right, so 
now there, that's where i is going to be. And
05:15 - actually, what we see here is that j is always 
going to be i plus one, like we mentioned before,  
05:21 - this is our sorting algorithm process that we 
need. So it's just going to be side by side,  
05:26 - or they're going to be a jacent to each 
other in initially, and then after that,  
05:29 - they're just going to be incrementing. So like, 
just like Jays position, so we have j over here,  
05:33 - and we have i and j. So if I look over here, 
we have I, which is three and J, which is to  
05:39 - check the condition. Now that's true 
again. So what's going to happen  
05:43 - is that j is less than i that is true. And we're 
going to process this temp is it, temp is equal to  
05:50 - Now you could guess what's happening 
here. Now temp is equal to the value of i,  
05:53 - which is three now, so three is going to be placed 
here. So there you go, three. And then after that,  
05:59 - we have i is equal to Now the value of j, j is 
actually two, so we just gonna have two over here,  
06:05 - i is equal to two. And then last one, which is j 
is equal to the value of 10 plus 10, plus three,  
06:11 - so that places over here, so now we just basically 
swapped it again. So we have instead of three,  
06:15 - we have two over here, and instead of two, we 
have three over here. So you can see now that j  
06:21 - is now going to be incremented, again to the last 
one, and we can see i is just in the same exact  
06:26 - position, and zero is going to compare two and 
five. Well, that condition is not satisfied for  
06:29 - this condition, so is just going to increment that 
process again, i and j now is going to compare  
06:35 - and say three and five, while that condition is 
also not true for that while loop to be executed.  
06:40 - So now we have this i and j in red. So you'll 
see that there's nothing to be changed.  
06:47 - So we have actually, our algorithm is working. 
And we see that 123 and five, see 123 and five,  
06:56 - there are in ascending order. And that's how our 
algorithm was supposed to work. So this visual  
07:02 - implementation of this algorithm helped us and now 
we could map this into our code. So we're going to  
07:08 - be right now typing, so I would encourage you 
to type along with me. So let's just get things  
07:14 - started. Okay, so the thing here is that we're 
going to have to create an array, and I call it  
07:18 - an array, and I suppose one is have a size. So I 
could define something over here on the top. So I  
07:24 - say hash define, and I say Max, and I say that's 
the 100. Alright, so this is the maximum value,  
07:30 - so it just put max here. And what I could say here 
is that, I could ask the user to enter a number  
07:39 - and, and that will be the size and it 
should be in between zero to 100. So  
07:46 - it's going to be input, and then it's going 
to be n now I need to define an N here,  
07:50 - so I'm just gonna say integer. And so this is 
the integer and now inputting values in an array.  
08:00 - So in putting values in array with a new for, 
don't say int i is equal to zero is less than n,  
08:07 - I would say i plus plus really simple. And then 
we have the RAND function that's going to put  
08:13 - values randomly inside of the each indices, so we 
could say array sub, I would say, just the RAND  
08:21 - function. And that's it. So this is going to give 
a number between zero to the RAND Max, whatever  
08:27 - the integer Max is. So what we could put here is 
now we just have to include one more header file  
08:34 - for the RAND function. So it's called C standard 
library. And there you go. So C standard libraries  
08:41 - don't know we have values inside of this, 
let's output our array. So outputting  
08:48 - the unsorted array, so unsorted array, we would 
just basically say for int, i is equal to zero,  
08:58 - i is less than n, and then we have i plus plus, 
and then we say console, output array sub sub i,  
09:08 - and we put this space. And hopefully, we'll get an 
array just put an end line right here at the end.  
09:14 - And now I save my code. So I'm going to run it 
using my G plus plus compiler. So over here,  
09:18 - I'm going to be writing g plus plus my name, which 
is part one, and we have CPP, and hopefully, it's  
09:27 - going to be compiled. Now we just say a to run it, 
and through a number n. So basically, I could say  
09:35 - 10. Now it's going to give me 10 random 
numbers for my eight array. So it has 41,
09:41 - this, this and this and all the way to 10. So 
you can see that these are 10. Let's run this  
09:45 - one more time. And now I'm going to input 20. 
Now it's supposed to give me 20 random integers.  
09:51 - So now though, there you go. How about having 
50 no 50 random integers. Now you got my point  
09:57 - over here. It's creating a randomized array. And 
putting some random values. But you could see over  
10:02 - here that these are not sorted in any kind of 
order. They're not in ascending node or are in  
10:08 - descending. And our that's our job to put that. So 
it's a 41. And you can see that this is a number  
10:13 - that's greater, but then after that you can see a 
smaller number. And what does this even meaning.  
10:18 - So we need a properly managed array. So let's 
create a properly managed array. So what we  
10:23 - can do here is right after this, let's create 
a sorting algorithm. So sorting, and array. So  
10:30 - how are we going to sort this array? First of all, 
let's go and open a for loop. So let's say for  
10:35 - int i is equal to zero, i is less than n, and then 
we say i plus plus. And then right after this,  
10:41 - we can put on another input array. So we could 
say, this another loop, that's going to be  
10:46 - nested inside of the beginning one, so it's 
going to be J. But this is careful. This is  
10:51 - the next value after the array. And I'll tell you, 
what's the reason behind this, say j less than n,  
10:56 - and we say j plus plus. And now inside of this is 
basically our concept that's going to be applying  
11:03 - with array sub j is less than array sub i. Now 
what does this mean? I'll tell you all of this.  
11:11 - So suppose we have an array. And that says that 
if array sub j is less than arrays, because  
11:16 - look at this, so this is an array, 
and you will see that it's an order.  
11:19 - So you can see that this is this I value which 
is starting from zero, and this is a j which is  
11:25 - starting, which is greater than I want one times, 
so you'd see that j is this. And this is now  
11:32 - if I had a randomized or raise, oh, let's say five 
over here. So you could see that this is not in  
11:38 - ascending, it's basically 10. And then it's five, 
why is five over here, something bigger should be  
11:44 - appearing. So the condition here is that erase 
sub j is less than array sub i. So meaning if  
11:50 - array sub j, which is this is less than array sub 
i. And that is the case. Now what we want to do,  
11:57 - we want to swap the values. So what we could 
do by swapping the values, so var five could  
12:03 - be over here, and the original value 10 should 
be placed over here. How do we do this, because  
12:08 - 510 30 and 40 will be then sorted. And the thing 
is that we're going to have to create an input  
12:15 - integer, temporary, something. So we're going to 
put that in assign that with I. Now once we have  
12:20 - that assigned with I now what we could do here is 
that we could change a race of AI. And we could  
12:26 - say to that to a race of J. So we're assigning a 
race of eyes value with array sub J's value. And  
12:32 - now we can have a race of J's value. And we'd like 
to put that as a temp value. So this is going to  
12:38 - improvise our array in a sorted fashion. And it's 
going to be in ascending order a sc n di, N D, or  
12:46 - D er. So this is going to be in ascending order. 
So it's going to check and then after that, it's  
12:53 - going to do this, it's going to go into our next 
iteration, which is going to be is equal to one.
12:57 - So plus plus increments to this, 
so it's going to be this value,  
13:01 - and then it's going to be checking with this
13:03 - value. And it's going to see if it's the case 
that it's not right, it's going to swap it  
13:08 - out, it's just going to next, do this 
next iteration until the array is done  
13:14 - examining. So once it's done, you can just break 
out the loop. And once your break, like your free,  
13:20 - so what's once you're free, you return to 
zero. So this is going to give me my array in  
13:25 - ascending order. But now we don't have anything 
displaying it. So let's display this array. So  
13:31 - I'm just going to write comments shorting 
the array, now we're going to display  
13:37 - the, so let's just say the sorted array. 
So displaying the sorted array, we just  
13:45 - do a basic for loop, i is equal to zero, I'm 
gonna say i less than n, and we say i plus plus.  
13:53 - And then over here, which we could add is 
basically console output, and we say array sub  
14:00 - i. And then we say this. And now let's just put 
an end line right here. Now let's run the code. So  
14:08 - basically go back to our G plus plus compiler. And 
we're going to be running our code. But first of  
14:14 - all, let's compile it. And I'm just going to give 
a hyphen o flag to indicate that this is a new  
14:20 - executable, and I'm just going to call it run. So 
I'm going to hit the compiling button compiling is  
14:26 - successful. Now we're just going to run. So now 
you'll see enter a number and so enter a number  
14:32 - and meaning that let's just enter some random 
number and it's going to create an array with  
14:38 - some randomized values in each indices, so 
let's have 20. Now these are 20 random numbers.  
14:45 - You will see over here for 2041 and all of this 
which is unsorted. It goes in random order. And  
14:51 - then after that, it sorts it. And you can see my 
sorting algorithm does the trick and sorts them in  
14:57 - ascending order. That's pretty amazing. Okay, 
now let's do one other thing for us to have a  
15:04 - descending order fashion. One other thing I want 
to do here is that, I want to tell that this is  
15:09 - going to be the sort of, so I could just write a 
console output, and I'd say sorted. So sorted. And  
15:16 - right here displaying the sorted array. And the 
other thing that I want to do is I just want to  
15:20 - show you how descending works. So this less than 
sign, which is arrays of J, less than arrays of  
15:26 - I will just be turned into arrays of j greater 
than arrays of I. So if it's greater than swap it,  
15:33 - so that's basically descending order, so I'm 
just gonna change this ascending to d, e, s, e,  
15:41 - n, di, N, G. So this is now going to be 
in descending order. So it's going to run  
15:46 - again. So I'm just going to compile this 
basically. And then we're going to run it.  
15:52 - And now let's have a value like 22. Now 
you have these values, which are 41.  
15:57 - And all of this in random order. And then 
after that you call the sorted basically  
16:04 - prompted out on the terminal screen. And then 
after that, you sort them in descending order  
16:08 - fashion, and look how awesome that took. So that's 
it with this one. And now let's continue with  
16:14 - the other sorting algorithms. So the next sorting 
algorithm is called the selection sort one of the  
16:19 - most common and most famous, well known sorting 
algorithms in the world. So how we're going to  
16:25 - implement this is basically first type along, 
and we're going to be explaining side by side,  
16:30 - as well as gonna give a brief explanation at 
the end. So just keep on typing along with me.  
16:36 - So hash include, we're gonna have input output 
stream, and then we're gonna have using namespace  
16:45 - standard. And then we also have integer 
main. And we also have the return zero.  
16:52 - Now, what we're going to do here is basically, 
first we're going to create a swap function.  
16:56 - So what I'm going to be implementing is basically 
a swap function, so void, and then we have swap.  
17:02 - And then we have basically an array we're going 
to have, and it's going to be swapping. So  
17:08 - I'm going to show you that it's going to have an 
x value, and it's gonna have a y value. So it's  
17:11 - going to be implementing that famous swap function 
process that we've been doing. So what's going to  
17:18 - be doing is basically, integer temp is going 
to be having a sub x as the first value, so a
17:25 - sub x, so a sub x is going to be equal to a 
sub y, and then we're gonna have is a sub y  
17:32 - equals to the 10th. variable. So and that's how we 
swap something. So suppose we have an array inside  
17:40 - of it, and we just call it an array. And we're 
going to have some values to it. So let's say  
17:44 - some random values. And what we want to do is 
basically, we want to swap the process over here,  
17:50 - if we have some random values that are 
not matching, and we want to swap them,  
17:54 - we could use a swap function like just we did in 
the basic algorithm in the beginning where we did  
17:59 - ascending order. So basically, we're implementing 
selection sort. So we created our first function,  
18:04 - which is swap, the second function that we're 
going to be doing is basically the selection  
18:09 - sword. So how this is going to go is 
basically we're gonna have a void.  
18:14 - And we're going to call this as a selection sort. 
And it's going to have two input parameters. First  
18:19 - one is going to be the array, and the second one 
is basically going to be the size of the array.  
18:24 - Now inside of this is going to have the location 
index, which is zero, it's going to always start  
18:29 - from zero array start from zero, just that and 
now after that, it's going to loop through this,  
18:34 - so it's going to be i less than n minus one, 
we're going to loop to the last the last element,  
18:38 - so n minus one is the last element, and then 
we're going to have to find the value that  
18:44 - should be smaller than the value that we're 
specifying as is zero, and it should be like  
18:50 - swapping the function, so we're going to have 
to indicate one j over here. So it's going to be  
18:54 - called, and we're going to use another function, 
which is going to be called location of smallest.  
18:58 - And don't worry, I'm going to be teaching what 
this is. So basically, we're gonna have a sub i,  
19:04 - and we're gonna have n minus one. So we're 
just gonna have three input parameters, here,  
19:08 - we're gonna have the array passed in, and you 
know, this is passed by reference. So it's always  
19:12 - going to be the same array no matter where you're 
going. And then we have iron, which is going to  
19:16 - be the current location, it's always going to be 
incrementing. And it's going to be zero over here,  
19:20 - it's going to be changing. And over here is the 
ending point. So that's the last one ending last  
19:25 - element. So swap is going to be implemented here. 
And it's going to have three input parameters just  
19:29 - like we did before. So it's going to have the 
array, which is small a, and then it's gonna  
19:33 - have the size of the eye and it's going to have 
this J. So basically, I which is going to be  
19:38 - the index, so it's going to be the first element 
and second element and wants to swap them. So it's  
19:44 - going to be implementing the swap function and 
it's going to be incrementing i plus plus here.  
19:48 - So this is how it's going to be doing now we need 
here is the location of smallest function. So that  
19:54 - doesn't make it oh right here. So what we're 
going to do here in the location of smallest  
19:58 - is basically have a return type. Hello, okay, 
because it's going to be returning a value of  
20:03 - J. So you can see that j is integer, so it needs 
a return type at the end. So over here location  
20:09 - of smallest, let's have some input parameters, the 
first input parameter is the array. And the second  
20:14 - parameter is the s. And the third input parameter 
is the ending point. And you might be asking why  
20:19 - I did this. And you can see over here that the 
starting point is going to be I, the ending  
20:24 - point is going to be n minus one. So it's always 
going to be checking at the end. So it's going to  
20:27 - be looping through this whole array and trying to 
find the smallest. And when it finds the smallest  
20:33 - from I, then it's gonna swap the values in the 
swap function. And that's how we're going to be  
20:37 - implementing this selection sort algorithm. 
So if I'm going to create an AI over here,  
20:42 - I'm just going to create intermediate intermediary 
variables. One is going to be Isaac s, so I S. So  
20:48 - AI is going to be as the starting point, and then 
we're going to have j, which is going to equal to  
20:53 - basically I not s, so we're going to implement 
it, and we're going to say whatever it is,  
20:59 - that's going to be in j and I over here is the 
starting point. And then what we're doing here is  
21:04 - that basically, we're gonna have a loop again. So 
while we're gonna have i less than or equal to E,  
21:12 - which is the ending point, now, if A and then 
we have a sub i, which is the first element,  
21:21 - if that is less than a sub j, if we find some kind 
of thing that is greater, so a sub j is greater.  
21:27 - So we would say is j is equal to, I just 
want to swap right, we want to locate it.  
21:32 - And then after that, what we want to do is 
basically increment it using i plus one,  
21:38 - right, so that's going to be incremented. And 
then we're going to return the value object.  
21:43 - And don't worry, I'm going to be explaining 
this through a graphical representation.  
21:47 - So you're This is how it's done. So we have 
our three functions, we have a swap function,  
21:52 - and we have a location of smallest function. And 
we also have a selection sort function, let's  
21:56 - create a display function to display the contents 
of the array. So it's going to be called display,  
22:00 - it's going to have an integer array, and it's 
going to have a size of the array, which is n.
22:06 - And what you're going to do here is 
basically it's going to start from  
22:08 - zero. And what how it's going to be implementing 
is basically while the i is less than n,  
22:15 - and then we're going to be displaying 
the contents of the array by using a  
22:18 - sub i. And we're going to have the double quotes 
over here, which is space and just going to,  
22:24 - it's going to keep on listing them out. And then 
it's going to print an endline over here just to  
22:28 - make the format a little more prettier. So right 
after that, what we'll do is basically have the  
22:35 - array over here specified, let's just create an 
array, which is going to be called arr. And it's  
22:40 - going to have some random values. So it's going 
to have 100 to 12, I'm just giving random values  
22:44 - over here, it's just in random format needs to be 
sorted using my selection sort function. So I'm  
22:51 - just gonna pass this in. So you can see that this 
is random. And now what I'm doing is basically  
22:55 - calculate the size, how to calculate the size, 
one of the process I want to use is basically  
23:00 - the size of operator size of operators is going to 
pass in, and it's going to have an array, and then  
23:05 - it's gonna have the size of basically the integer 
variable. So basically, you will see that this is  
23:11 - the data type, and it's going to be for the array 
is basically the whole thing. So we'll see 1234567  
23:21 - and eight and nine, nine, multiplied by 
four, which is basically 36. And now 36  
23:27 - will be basically divided by the integer, which 
is going to be four. So 36 divided by four  
23:33 - is going to give you the value, which is nine. 
So nine is going to be the answer right here.  
23:38 - So once this is the size, I'll just comment over 
here and say size equal to nine. Why don't we want  
23:44 - to do here is basically we want to implement our 
selection. So first of all, let's just display  
23:50 - it. So let's just display and we're just 
going to pass in the variable and the size.  
23:55 - So it's just going to automatically display 
because it's a void function, and its purpose  
23:59 - is to display it. And then right after that, this 
is called our selection sort of function. And it's  
24:05 - going to ask for array and also a size. And then 
after that, we'll just display our selection,  
24:10 - sorted array using array, and then when you have 
size. So once I do this, I'll just execute and  
24:16 - running. So basically, I'm going my terminal 
screen over here, I'm going to write g plus plus,  
24:20 - I'm going to use the selection sort dot cpp. And 
all we know that by default, it's going to be a,  
24:26 - so I'm just going to run it and I'm going 
to say Oh, and I'm going to say selection  
24:30 - sort. So now it's compiled, and I was running 
through a selection sort. Now you'll see over  
24:35 - here, we have some random stuff what's 
going on. Okay, so something went wrong  
24:41 - Ctrl T, to break the code, something went wrong in 
this code, and let's just check what it's wrong.  
24:48 - What's wrong in this. So we have iOS and then we 
have it's incrementing. So this is processes okay.  
24:54 - And minus one is okay, there's some infinite 
loop that's been created using selections  
25:00 - or array and then size. And so let's just look 
over here. Okay, so I forgot to increment this i  
25:08 - plus plus. So just right here, I didn't 
commit. And now it's going to be working. So  
25:12 - basically, we were done that, and 
let's just run this code once again,  
25:16 - selection sort. And now let's call us and look 
at that, we had this array, which was unsorted,  
25:21 - which is 102 12 193 90, whatever 32. And now, 
what we did is passed in the selection sort,  
25:28 - and it's sorted the array for us, I mean, 11 1239, 
in ascending order, now ascending, what is that,  
25:33 - like, if you have the same value, it could be 
equal, or asked to be greater. So just in case,  
25:37 - if I have a value, like 11, and 11, they're gonna 
be in the same adjacent locations. And then after  
25:43 - that, it could be a bigger value. So that's 
sorted. In selection sword, I really hope you  
25:48 - enjoyed and you understood, so what I want to 
do is, one other thing is basically show you  
25:53 - how the implementation is done. So suppose that 
there are arrays sorted like this in the memory.  
25:59 - So we have some kind of indices. So we have 
like five, and we have four, and we have three,  
26:08 - we have seven, we have nine. So we want to sort 
this in ascending order. So what we're gonna do  
26:13 - by default, with selection, sorting does is that 
it sort makes this eye as the index of zero,  
26:18 - and it will check for J. So what my process here 
is like that location of smallest will be called.  
26:26 - And you will see in my code, which is basically 
in here, so I'm just going to show you over here,  
26:31 - what I see here is that the location is 
zero, and the Y is not less than n minus one,  
26:39 - the last element, what we do is we get the J 
and we put that in the location of smallest  
26:43 - passing a, we have the I variable, which is 
basically going to be zero and n minus one,  
26:49 - which is the last element, and it's going to 
be the location of smallest. So location of  
26:52 - smallest is going to locate for the variable, 
which is going to be this smallest one,
26:58 - even i less than equal to E if it's less 
than or equal to. So if it finds it,  
27:02 - it's going to sort that as j and it's 
going to return that value. So you can see  
27:06 - what's happening is that it find the smallest. 
So you see that the smallest here is three,  
27:10 - so j is going to be pointing here. And then it's 
going to be applying that sorting algorithm, which  
27:15 - is going to cut swap this. So you can see over 
here that it's going to be swapping, so we have  
27:20 - three over here. And then initially five is 
going to be over here. But what we want to  
27:24 - see here is that in this text editor is that 
this is basically displaying so we have a  
27:31 - selection sort. And then once we go back into our 
selection sort algorithm, we have a swap function  
27:36 - swap is going to get this value by energy that's 
returned from here, and it's going to swap it. So  
27:41 - basically the simple swap algorithm, it's going 
to swap the both values. And then after that,  
27:46 - it's going to increment and it's going to go to 
our next location. So you can see the place over  
27:50 - here is going to No, not, it's not going to be 
pointing over here anymore. And it's going to be  
27:54 - pointing over here. And now this j is not going 
to be over here. So just want to indicate that  
27:59 - this j will now going to be pointing somewhere 
else. So we have this is now implemented over  
28:04 - here. So I'm going to be incremented over here. 
Now this is going to be its base. And what we're  
28:09 - going to be checking now because this is not 
going to be sorted with three. So now we're always  
28:14 - basically over here. So now we're going to look 
for a value that is going to be smaller than  
28:18 - four. So basically, is there something for smaller 
than four, it's not so that we just increment,  
28:23 - and we say I is going to be over here. Now 
it's five, if there's something foreign,  
28:27 - it's okay, so it's going to be checking 
all and is going to go throughout the loop  
28:30 - until the whole array is sorted. So I hope you 
understood this concept of selection sort through  
28:33 - this graphical implementation. Now we're going 
to go to our next sorting algorithm. And let's go  
28:39 - towards it. Alright, so now let's look at another 
sorting algorithm. This is called the bubble sort  
28:43 - algorithm. And it's going to go as follows. 
So basically, you have to include your input  
28:46 - output stream, and you're gonna have to do your 
namespace standard. And let's just go simply  
28:55 - write our boilerplate code. Okay, so, boy, 
this bubblesort is going to also deal with  
29:04 - swapping. So we're gonna have to include this 
swapping methodology, which is basically swap,  
29:09 - and then we have an integer array, we have an 
x value, we have an a y value. And basically,  
29:17 - when we go over here, we have actually a 
temporary, which is going to be assigned to  
29:23 - the first value, and then we have the first value, 
which is a sub x is going to be assigned to the a  
29:28 - sub y value, and then the a sub y value will be 
equaling to the 10th value. So this is how the  
29:34 - swap works. And now let's have a bubble process. 
So the bubble process is a little bit different.  
29:40 - How it's different, is that from selection sort 
that we already covered, we actually went from  
29:46 - the top right, so we went from the top and then 
went went our way to the bottom. So in bubblesort,  
29:52 - we're going to go bottom to the top, so I'll 
just explain it. So first, just type along. So  
29:57 - it's going to be bu BB le Baba. And then what what 
this process is going to do is it's going to do  
30:04 - some specific process, it's going to get an array. 
And it's also going to get the size of the array.  
30:09 - And we're going to go back to this a little 
later. So let me just, I just wrote a signature  
30:13 - right now. And I'm going to go and talk about 
the void bubble process. So the bubble sort  
30:18 - actual functions, this is the actual bubblesort 
function. And what we're gonna do is basically,  
30:23 - it's going to have that same integer array, which 
is right here, and then we have the size. And  
30:29 - so now over here, what we want to do is basically 
start from the portion what I was saying that  
30:37 - bubblesort is going to be adopting. So 
the bubblesort is going to say, integer I  
30:43 - integer i is equal to zero. And what we need 
is while we have i is less than n minus one,  
30:52 - the last element, we're going to have bubble 
process. So BB, BB le bubble, and it's going  
30:59 - to have the rate and the end value, which is n is 
going to be the size is going to be the rate and  
31:05 - it's going to increment it to the weight. So it's 
just going to go and increment. So in the bubble,  
31:11 - what we're going to have is in here, now we're 
going to open it, and we want to start so the  
31:17 - bubble process is going to be from the I. So it's 
going to start from the last element. So that's  
31:23 - what I was talking about n minus one is the last 
element. And it's going to go like while and we  
31:28 - have basically i greater than zero, so i greater 
than zero. And now inside of this is if we have  
31:38 - a condition that if a sub is now a sub 
i should be less than a sub i minus one.
31:46 - Now, this means that there's an A sub 
II, if it's the top portion is greater.  
31:54 - So what you want to do is that if a 
sub i is less than the ACI minus one,  
32:01 - what you want to do is swap it, so we're going to 
swap it using this swap function that we already  
32:05 - have, it's going to take a it's going to take the 
AI element, and it's going to take i minus one. So  
32:11 - that's how it's going to swap it. And we're going 
to have a generically having going minus minus  
32:17 - because we're starting from n minus one, it's 
going to go all the way to zero. So this process  
32:24 - should work. So now after that, we should 
have our display function. And we're ready  
32:29 - to go. So basically display over here have an 
array. And we also have the size of the array,  
32:35 - which is some kind of size, I will just call 
it as that. And now inside of it, we need an  
32:42 - input. So I will just say some kind of is equal to 
zero integer. And then we have the loop process,  
32:47 - which is going to start from i less than n. And 
then soon as go, so basically is less than n and  
32:53 - you want to process it. So array. And then we have 
the ISO value. And we're just going to keep on  
32:59 - going like that, until we reach our ending 
point. So which is console output over here.  
33:04 - Yeah, just to make it a little more similar to the 
previous one, I'll just change this to just and  
33:11 - because this one's matching here. So now let's 
create an array over here. And I'm just going to  
33:15 - call it as integer array. And I'm just gonna 
give some random elements to it. So let's  
33:20 - just say this. And then it is and then something 
like that, this, this and 33. Okay, this is just  
33:28 - random stuff. Now I want to sort this, so I'm just 
going to first display. So I'm going to display,  
33:33 - I'm going to say array and alternate my size 
data type. So actually my size variable.  
33:40 - So I'm going to have size n over here, I'm going 
to say size of n, I'm going to have the array and  
33:46 - I'm going to say size of and I'm going to have 
the INT it's going to give me the size. Now what  
33:50 - I can do here is basically have the display 
function call and then the sorted function,  
33:55 - so it's called bubblesort. So I'm just going to 
name it bubblesort. I'm going to pass in my array,  
34:00 - I'm going to pass in my size. I'm going to 
display once again. So I'm going to display array,  
34:04 - and then I'm going to pass in the size. Now, 
I suppose to work. So let's just go to our  
34:09 - c++ compiler over here, just type bubblesort bbls 
o r t, and we say dot cpp. And let's just name it  
34:18 - something like hyphen o bl s o r t. And there we 
go write, compile. And there you go. It ran Whoa,  
34:27 - what happened over here, I think we did the same 
exact mistake. So let's just go back over here  
34:32 - and see where we went wrong. Okay, so we just 
forgot to increment on wild loops to remember  
34:36 - to do this. This is really important. Okay, so i 
plus plus over here. So that is just loops out and  
34:41 - it doesn't cause an infinite loop. So over here, 
and let's just go back over here to compile it,  
34:48 - recompile it and running it again. You can see 
that my original array was 102 and then 293, and  
34:54 - then 1939, and all of that and then once we passed 
in our bubblesort Actually sorted out sum from  
35:01 - 1138 102. And all the way to the last element. 
So that was pretty cool. Uh, sorting an array  
35:08 - in ascending order using bubble sort selection 
sort, because the, the methodology was basically  
35:14 - a little bit different. So I just want to show you 
how this is implemented in a graphical wait. So  
35:19 - so the implementation of the bubble process is 
basically similar to what we did with selection  
35:23 - sort. But in actually reverse order, we have this 
swap function that's going on, but we have this  
35:28 - visualization that could help us understand how 
this process is working. So suppose we have some  
35:33 - random values, here, we have three, we have 
five, we have one, we have four, and we have,  
35:38 - let's say three. Now, the bubble process 
is going to work like this. So let me just  
35:43 - go over here. And now let's see. So 
it's going to start from the bottom,  
35:46 - and it's going to compare these two values. Now it 
sees that three and four now would you mean that  
35:51 - is basically bubbling, meaning it's liquid 
portion is on the bottom and liquid portion is  
35:56 - basically heavier than the Bubble bubble is 
lighter bubble makes it flow on the top. So  
36:02 - when you compare a liquid and a bubble, bubble 
is lighter, so bubbles should be on the top. So  
36:05 - this isn't exactly the same thing. They're talking 
about the weights. So for weight is heavier than  
36:10 - three weight, so four should be on the bottom, 
and three should be on the top. So this is  
36:14 - one actual process, what's happening here is 
that the swap function will be called, and this  
36:19 - is going to be changed to three. And this is going 
to be changed to four. And then after that bubble  
36:23 - will go up over here one step level, so it's going 
to go from here. And now it's going to go over  
36:27 - here. So now it's going to compare three and one. 
So three, and one, actually, what's different now.
36:32 - So you have over here is basically you 
say one and three, so actually, it's okay,  
36:38 - so three is heavier than one. So when it's 
okay, so go again, we're one in five. So five is  
36:44 - heavier. So basically five will go on the bottom, 
and one will go on the top. Now. Now over here,  
36:49 - now one in three. So basically three is 
heavier. So three will go on the bottom  
36:54 - right here. So just three is on the bottom right 
here, and then the one is will be on the top.  
36:57 - So this is one actual bubble process. 
And you'll see 1353 and four, right now,  
37:02 - we basically did our one process here and we 
sorted till this portion, there is more processes.  
37:09 - And you'll need to do one more bubble process. So 
again, you're going to have to go from the bottom.  
37:14 - So you're going to check like this. So 
basically, we're going to start again,  
37:19 - and we're going to see the values once more. So 
forgive my writing, so four, and then we have  
37:28 - three, and we have five, then we have three again 
over here, and we have one, so now four and three,  
37:36 - which is heavier, it's okay, go up here, compare 
these two values. Now three and five. So three and  
37:41 - five, actually, five is heavier. So five will go 
on the bottom. So five is over here, just cross  
37:45 - this one out, and this portion will be having 
three now. Now three and three, well, actually,  
37:50 - it's the same equal, so it's going to be okay, so 
one, okay, so it's okay, so 13354. Now, one more  
37:56 - process. So after one more process, so we're gonna 
have one more process. So let me just erase all  
38:02 - of this, how we're going to have an even one more 
process. And now, this should be our final bubble  
38:07 - process. So there's just look at the values again, 
over here, and then over here, and then over here,  
38:11 - and then over here. So this is one, and then 
this is three, and now this is three as well.  
38:17 - And now this is five, this is four, so it's going 
to start from the bottom, and you see that five  
38:22 - and four, well, five, and four, this is different, 
this is heavier, so the heavier portion should be  
38:28 - on the bottom and the lighter portion should be 
on the top. So four is going to be over here,  
38:31 - and then five should be over here. So five, four, 
and then 3311 inch. Okay, so this is our exact  
38:38 - sorted array. And this is how we're going to be 
sorting our array in bubblesort, a slower and it  
38:43 - depends on the number of inputs. So it could vary 
and exponentially grow as the inputs increase. So  
38:49 - that was bubble process. Alright, so now let's 
jump into Insertion Sort. So this is pretty much  
38:54 - different from the other two that we've included 
right now, which one was selection sorting,  
38:59 - the other was bubblesort. So I would just 
encourage you to type along with me. And  
39:03 - explanation we'll be doing side by side. So let's 
just go and include this main and then let's just  
39:09 - go over here and then return the zero. Okay, okay. 
Now, what's gonna happen here is that we're not  
39:13 - going to have a swap function like we did with the 
other ones, what we're going to have is basically  
39:17 - some differences. Now, the differences is that 
we're going to have an insertion sort function,  
39:22 - and the insertion sort is going to basically have 
an array, it's going to have one more thing that  
39:27 - is going to be inside of it. So the first thing 
that's going to have is going to be the size.  
39:32 - This is pretty much the similar. And one thing 
here is that it's going to start from one  
39:36 - not from zero, like others that do because 
we're assuming something and assuming is  
39:41 - that the assumption is basically that some 
portion of the rate is already sorted beforehand.  
39:46 - And we just have to like insert elements B into 
that sorted array, and that's how our process  
39:50 - is going to be done. So we're going to go and 
we're going to have a while loop so that I could  
39:55 - tell you that it's going to go in a while loop, 
it's going to go to end and it's gonna say insert  
40:00 - Insert ight. Now this is going to be the function 
that's going to be called. And this function is  
40:04 - going to take in an array, it's going to take 
in the size, it's going to take in the element,  
40:07 - which is going to be the portion that I'm going 
to be talking about. And then this is going to  
40:11 - keep on incrementing i plus plus, right? 
Like in other languages, like I is equal,  
40:16 - i plus one, whatever it is, man, I can't get 
the plus. Right. Okay, so just like that.  
40:22 - So I plus plus whatever it is like that. So now 
let's have the insert ICT element, how do we do  
40:28 - this insert, I think so let's go over here. And 
after this, let's just talk about the insert it.  
40:34 - So this is actually something that's also void, 
and it's going to have the insert element, so just  
40:40 - right over here, and now inside of it, we're gonna 
have the array, we're gonna have, basically we're  
40:46 - gonna have the integer n size, we're gonna have 
the integer size, which is specified over here,  
40:51 - we're gonna have this key variable media 
intermediary variable that's going to store our  
40:56 - location, or basically the value of our eye. And 
now it's gonna say int j, and this j is going to  
41:02 - be the last element of that sorted array. So the 
last element of that sorted way is going to be i  
41:07 - minus one, because I actually after the sorted 
array, and i minus one, it will be the one last  
41:12 - element, so we're gonna have a loop again, and 
we're gonna have two conditions. For this case,  
41:16 - we have j is greater than equal to, we have j is 
greater than equal to zero. And we also have one  
41:21 - more condition that j should be actually greater 
than the key. So if j is greater than the key,
41:29 - we're just going to keep on looping this, 
so not a G j, or whatever it is a key.  
41:34 - So a sub j, so let me just have this eight, and 
then a j over here, not just playing j, okay,  
41:40 - so a sub j should be greater, and then 
the J should be greater than equal to,  
41:45 - so what's going to happen here is that eight sub 
j plus one, this is going to be implementing,  
41:51 - and it's going to equal to j, and I hold on, I'm 
just gonna teach you this, don't worry. So now  
41:56 - we're gonna have j is equal to j minus one, now 
it's just gonna keep on decrementing, going to  
42:01 - the top, like a bubble sort is gonna go up and up 
and up until you reach that less than equals zero,  
42:06 - or if a sub j is gate, basically, greater if 
it's less than something like, if it's less than,  
42:12 - then it's gonna just break out less than the key. 
And naturally, what's gonna happen here is if this  
42:18 - condition is false, we're gonna have a sub j plus 
one or two we're trying to implement, and we're  
42:23 - gonna put that key thing inside of it that lost 
value. And now we just have this display function,  
42:29 - which is going to be over here, let's just have 
it over here. So void, let's have a display.  
42:35 - And let's have an integer array. And then let's 
have the size of it. And then let's have something  
42:41 - which is going to be the AI, it's going to start 
from zero, it's going to go basically from while  
42:47 - and it's going to just check that is less than 
n. And then it's going to go and say our console  
42:52 - output is going to say AR AR, actually, 
it's not AR AR, it's going to be a sub i,  
42:58 - and it's going to be AI. And then it's going to be 
that over here, there's going to be a comma right  
43:03 - there. And then there's going to be an N line, 
semi colon right here. And actually not this,  
43:11 - I don't want that I just want a semi colon. And 
this is going to be incrementing. So I plus plus.  
43:16 - And then we're going to have a comp end line over 
here. There you go. And let's just get some data  
43:22 - from our previous sorting algorithm. So like a 
bubblesort, let's just get some of the data, just  
43:28 - the array portion, not anything else. So just get 
this portion over here. Let's just copy this, and  
43:33 - it's coming here and just paste it. So I'm just 
going to go here, and we're just going to paste  
43:37 - it right here. So the only thing I'm going to be 
changing here everything is okay. I just want to  
43:41 - sort out using my function. So I'm just going to 
call it with my Insertion Sort, actually. Yeah,  
43:46 - so insertion sort is going to be called. Okay, so 
the insertion sort should be over here. Let's see.  
43:52 - Yeah, the insertion sort is right here, it's 
going to go and it's gonna call this one  
43:56 - insert, right? It's gonna, it's gonna perform some 
operation, and then it's gonna go back plus plus,  
44:01 - it's going to keep on doing and it's gonna keep 
on calling this insert it so many times until  
44:05 - the thing is sorted. And then after that, we 
just display it. So let's just run this code.  
44:09 - I'm going to go over here my ci 
plus plus, and let's just clear this  
44:13 - screen. And let's just compile So basically, 
g plus plus is short Insertion Sort dot cpp.  
44:20 - And then we can say, hyphen Oflag, and then say 
is short. Okay, it should be working, compiling.  
44:27 - Okay, so there's a warning over here and 25 no 
return statement and function returning non void.  
44:33 - 25. Let's see. 25. Where are you? 25 is over 
here. And there is should be something over here  
44:38 - insertion sort and doesn't have a return type. 
Wow, should we have a void so let's just have a  
44:42 - void over here. And let's just go back here. 
And now let's just compile it recompile it.  
44:49 - And there you go. Now we have an ins short, 
so Insertion Sort, and if I run this,  
44:55 - you're going to have this sorted. So 192 
290-319-3918 32 Yo, yo, yo 1138 102 293 311.  
45:04 - And this is also sorted in ascending order. 
Now let's have the implementation. So this  
45:08 - is basically an array, just a random sample, and 
we have 379. And somehow this is basically sorted  
45:15 - from here how that happened, just randomly, it 
just sorted beforehand. And now our is going  
45:19 - to be over here. So it's going to be after that 
sorted, and then j is going to actually be going  
45:23 - to be over here, remember, I said that it's 
going to be i minus one, so this is J, and the  
45:28 - first process is going to happen. So if I go over 
here back in my code, so my code is over here,  
45:34 - and if I see over here that this is going to 
be the process insert, if it has an array,  
45:37 - it has the inside, it has an element I, 
and it says a key is equal to a sub i,  
45:42 - so there's gonna be a variable that's gonna be 
stored, and j is equal to i minus one, and it's  
45:46 - gonna say that j is greater than equal to zero, 
and a sub j is greater than the key. So it should  
45:51 - be working like that. And let's see if I could 
implement here, here. So we have a key variable.  
45:55 - So this will have a key over here. So key k, e, 
y, store that value inside of it, which is going  
46:02 - to be something inside. So what's it going to be, 
it's going to be the value of, it's going to be a  
46:06 - sub i. So that's four. So four is here. Now ignore 
that. Now, what you're going to do is basically,  
46:11 - you're going to check the condition and the 
condition is true, why? Because a sub j is
46:15 - greater than equal to zero. Actually, if I, 
if I go back over here, where am I? Okay,  
46:22 - so you can see that it's j is greater than or 
equal to zero, it's perfect. And then a sub j  
46:28 - is greater than key. Now, if I talk about a sub j, 
now if I talk about that, let me just see, a sub j  
46:34 - is basically this nine right now. And we have a 
key, which is four so that j sub j is greater.  
46:40 - So no, no fans where we're still working. 
Okay, so the work, the thing is going to still  
46:45 - work. If I go back over here, we're going to 
have a sub j plus one is equal to a sub j.  
46:50 - So that means that we're going to have something 
that we're going to be implementing, so a sub j  
46:58 - is going to be over here. So we're going to go 
over here. So this is going to mean that j plus  
47:03 - one is this portion, and it's going to equal it, 
it's going to sign this line over here. And what's  
47:08 - going to happen is that it's going to go minus 
one, so j is not going to be here anymore. No,  
47:11 - it's going to go over here. Okay, so that was 
now that's one process of that loop. So that's  
47:17 - one process of it. And let's go again. So a sub 
j greater than this is greater j is greater than  
47:22 - equal to zero, and a sub j is greater than the 
key, because the key is for nj seven. So that's  
47:27 - perfect. Now let's go back over here. And we see 
that a sub j plus one is equal to a sub j, and we  
47:32 - have j minus one a process again, so whatever that 
value was, so we have seven over here, that seven  
47:36 - is going to be now over here. Okay, so the J is 
going to go up here now, and it's going to remove  
47:41 - it. So you can see that there is still over here 
in this location. And you can see that the four  
47:45 - was removed, so we don't have that value anymore. 
That it just changed to nine. see over here,  
47:50 - this is nine. And where does nine come from? It 
came from here. So within seven campervan came  
47:54 - from here, so this is happening, so we have this 
last value over here stored in our key. So that  
47:59 - was the purpose of the key Well, not nice key. So 
now we're going to do is basically go over here.  
48:05 - And we're going to see a sub j plus one, and it's 
going to, it's going to see this condition, is j  
48:10 - greater than equal to zero. Well, that's true. If 
I look at that position of here, it's over here,  
48:14 - it's greater than or equal to zero, but it is 
equal zero. So it's true. But the second condition  
48:18 - is not true, why a sub j is greater than key. And 
actually, it's not greater. How is it not greater,  
48:24 - it's less than because it's true on this key 
is greater. So this just terminates that loop.  
48:30 - And what's going to happen now is that the key is 
going to be sorted inside of this, this portion  
48:35 - over here, which is j plus one. So that key value, 
which is four is going to be over here. Now,  
48:40 - this four is going to be here, 3479. Well, this is 
sorted. And now it's going to, it's going to move  
48:45 - on and this is I know a new position of i and 
this is going to be a new process. So that's
48:50 - how it's going to be starting, 
if I look back over here.  
48:54 - So you can see a sub j plus one is going to key
48:56 - and then the process starts again, if you want to 
do it. And that's how it basically we're going to  
49:00 - sort it insert sort, it's going to increment its 
I value again, it's gonna be a new PlayStation,  
49:05 - and then after that position, and then after 
that we have inserted it and then the process  
49:09 - starts again and again and again until the 
whole damn array is sorted. And then we get  
49:14 - this ascending order of it. So I hope you 
understood this concept of Insertion Sort.  
49:19 - Really, if you took this concept and 
overall, like, take a practice of it,  
49:23 - I definitely know that you can do it. So next up, 
we're going to be diving into another algorithm.  
49:29 - Let's dive into the merge sort algorithm. So let's 
just type along with iostream namespace standard  
49:42 - main. And the return zero semicolon. Okay, so 
let's create some functions here. And let's  
49:50 - just explain it the way we do it. So first of 
all, let's just find our way for the merge sort.  
49:57 - So we're going to initially have a merge sort 
function. So how this is gonna work is basically  
50:02 - we're gonna say void, Mr g s o r t, and we're 
gonna say we're gonna have an array inside of it,  
50:10 - and we're gonna have the size of that. Alright, so 
this is gonna have another function inside of it,  
50:17 - it's going to call another function. And what 
this process is called, is called, actually,  
50:23 - this is called a wrapper function, and it's going 
to pass into an auxiliary function. So this is a  
50:28 - wrapper function. Alright, so what we'll say is, 
this is merge sort, and it's going to have the  
50:35 - array inside of it, it's going to have the size 
of that array. And it's also going to have one  
50:39 - other additional parameter. So additional thing is 
that it's going to have the size but before that,  
50:45 - it's going to have one other thing, it should have 
the index of the first element, so it's going to  
50:50 - be the array, the index of the first element, and 
then the size of that, basically, size minus one.  
50:58 - And this is how the merge sort is going 
to be over here, we're going to have that  
51:02 - auxiliary function called. So on the top, we can 
just specify our auxiliary function, so a UXILY  
51:11 - function. And what we're gonna say over here 
is, we just have the same void, Mr g, s, o,  
51:19 - r t, and now the same input parameters, where 
we have an array. So we have this input array,  
51:26 - we have basically the start value, and we have 
the end value. Okay, these are the basically  
51:31 - the indexes. And we call this as the 
auxiliary function, or we also known as,  
51:38 - say, helper function. These are some of the 
names we're going to use. So let's have a  
51:44 - base case to this. Now. Yeah, I don't 
know what a merge sort is, right? Now,  
51:48 - we just basically drew out the thing over here. 
So we have this function calls another function.
51:54 - Another scenario here we have is basically 
a same array. And somehow, it's sorted in  
52:00 - section. So you have a first part, which is 
sorted, and the second part is sorted. And
52:06 - what we our job here is, don't think of this as 
just two arrays, this is one single array. And  
52:11 - somehow, we have this first part sorted, and 
we have the second part sorted. And our job  
52:16 - is to make this sorted in one hole. And how 
we could do this is the process of merge.  
52:22 - So we're going to use merge sort algorithm to 
do this. So what we can do is, we have to know  
52:27 - in advance how the first part is sorted, or the 
second part sorted, and we have to put a trust,  
52:33 - we have to put faith in one process. And 
that themes process is called recursion.  
52:38 - And now that's what we're going to be 
applying. So you're going to check,  
52:41 - and the process is going to go like this. 
So we're gonna have this first element two,  
52:46 - and we're gonna check this third out this 
part over here. So first, first of these two  
52:50 - sub arrays, and I'm gonna say two and three, which 
one is greater, I mean, which one is smaller,  
52:54 - so basically two is smaller, so two is going 
to be planted here. And then this is going to  
52:59 - be incremented. So this sub array index is going 
to be incremented. So it's going to be plus one,  
53:04 - which is going to be seven now, and this part is 
going to remain the same, now three and seven will  
53:08 - be compared. And we could see that three is lower, 
so three is going to be placed in here. And now  
53:13 - this is going to be incremented to four. So you 
could see that four and seven will be compared,  
53:18 - and we have four over here. So four is going to 
be and this is going to be incremented to five,  
53:23 - so five, and seven, and five is now going 
to be added. So five is going to be here.  
53:27 - Now, it's going to be 15, and seven, so seven is 
going to be here, so seven is going to be here  
53:32 - now 11 and 15, you'll see 11 is smaller, so 11 is 
going to be in here. So is going to be incremented  
53:38 - to 19. So we have 15 and 19. So now we have 15 
over here. So 15 is going to be over here. And  
53:43 - then we have this comparative 15 is going to be in 
committed to plus plus. So we have 18 and 19. So  
53:49 - what what is it 18. So now you can see over here, 
we assumed that this part is already full now. Now  
53:55 - what do we do? Well, now what we're going to do is 
basically, this, this last part, we're just gonna  
53:59 - append to the end. So that's our process here, 
what we're going to do is append these 19 and  
54:04 - 21 to the end how we're going to do this. And you 
could see by this is just sorted in our ascending  
54:10 - order fashion. And that's what we required. And 
how do we do this? And you would ask me, now,  
54:15 - if it was worded like this, why not just put like 
a pre existing sorting algorithm like a merge,  
54:20 - like something like Insertion Sort selection sort? 
Well, that process is going to take longer, and  
54:25 - this process is fairly shorter. That's the crux 
of merge sort. And that's why it makes it faster.  
54:30 - It's much more faster as compared to any of the 
sorting algorithms we've discussed so far. So now  
54:36 - let's go back into our code. And now start typing 
along. So first of all, let's have this merge  
54:42 - sort and inside of this we have an array we have 
this int s, we have this int E, we have a helper  
54:47 - function out in the condition we have a base case, 
now we have this s greater than equal to E. This  
54:52 - is some case that's not true. It can never be 
true. In this case, it will just return. So this  
54:57 - is our base case. And that F That you could say 
that this is just not going to be true because  
55:03 - start is never going to be greater than or equal 
to eat. That means that it's just a logical always  
55:09 - you have a start, which is less than equal to 
E, and I'm talking about the indices over here,  
55:13 - and not the value. So you have a start, like for 
instance, we have a start here, and we have an end  
55:17 - over here, obviously, these are indexes, indices 
are start from zero all the way to n, right,  
55:22 - and the C, start from n minus one, it never does 
the other way around. So that's just illogical.  
55:27 - And now we're going to have the implementation 
Harry, we're going to find the midpoint value  
55:31 - of that array. So this is our function here. So 
what we have to do here is basically means is, let  
55:37 - me just put these plots back, okay, so our process 
here is, we have to find the midpoint value,  
55:43 - which is right here. So you can see over here, 
if I observe here, that I have 1-234-567-8910 10  
55:53 - elements, and if I, if I go from here, like 
the start value would zero index, and the  
55:58 - last value, which is nine, and if I divide 
this way, two, I'm going to get a 4.5, right,  
56:03 - and I'm gonna get the integer division of it. 
So I'm just gonna get a four part, the decimal  
56:07 - part is just going to be excluded. So we're gonna 
have 401234, this is our fourth index. So this is  
56:14 - our fourth index right here. And what I'm going 
to do here is I'm going to place that value. So  
56:19 - basically, this is our four index. And we're going 
to, we're going to split this here. And this is  
56:24 - now you could see that this is our mid m, outside, 
this is our m, and, and the stuff that is before  
56:32 - is going to be the things. So 0123 is going to 
be four and then after this is 01234. So this is  
56:39 - five over here, and this is four, and this is our 
midpoint. Now, suppose if we added something like,  
56:45 - had an odd number, then we'd have even cases here, 
but in this case, we don't have but this still
56:50 - is our process. This is how it's going to be 
implemented. Go back here, and we have this mid.  
56:54 - And this is going to be a simple function where 
we're going to do it's going to be s plus E. Now,  
56:59 - this is going to be the the start index 
and the last index and we divided by two,  
57:04 - just like we discussed. And I know that's pretty, 
really simple, because this is n minus one I told  
57:10 - you over here, and that's the last element is 
indicating the last element, and it's just going  
57:14 - to divide it by two, which is give a 4.5 it's 
going to be four because of its it because it's  
57:18 - an integer division. Okay, so now let's have 
that Merge Sort calling you using recursion,  
57:24 - that what I was talking about. So it's going 
to start from a, this is our starting point.  
57:28 - Now, careful here that it's gonna, it's this is 
the array, the starting point is S, but the Met  
57:35 - endpoint is now M. Why because now we're going 
to try to split into two sub arrays with sorted  
57:41 - processes. So we're going to call again. And 
the second time we're going to have a array,  
57:46 - it's going to start from m n is going to go 
all the way to the end. So it's going to be  
57:52 - not m but n plus one, because now we're going 
to have this process additional. This over here,  
57:58 - we have this portion we want sorted, and we want 
this portion sorted. So we're just casing we're  
58:03 - just discussing right now, this portion, not this, 
not this thing over here, not this right now,  
58:08 - we're just looking at the top. So so I hope you 
got the point over here that we wanted to sorted  
58:14 - in ascending wise over here and the sending wise 
here. Okay, so back over here, we have this m  
58:20 - plus one. And now we call one more function. And 
that function is basically the combined function.  
58:27 - And the combined function is going to be pretty 
much something like this, we have an A array, we  
58:32 - have the S which is the start, we have the middle 
value, which is m which is the last value, which  
58:37 - is e and this combined will be defined over here 
somewhere. So let's have this combined defined.  
58:45 - So now we're going to do is basically 
we're going to say void combine.  
58:50 - And if I have that specified here, I would 
say int a, and we have this array right here,  
58:57 - we have an int s starting value, we have 
an int and which is the middle value.
59:04 - Forget that right. And then I 
got the last element, which is  
59:06 - end. And what we could do here is that we want
59:10 - a temporary buffer. And I'll tell you why just 
hold on a moment. So let's just create a buffer  
59:16 - over here. And what it's going to do is basically 
going to get some value from the heap or is going  
59:20 - to get some. So it's going to be able, it's 
going to be a array from the heap that we're  
59:27 - going to get. And basically this is going to be 
representing the for the total size of the merged  
59:40 - array, what we're talking about. And  
59:43 - what we're gonna do here is that 
we're gonna have a kz go to S
59:47 - and we're going to say while so while is over 
here, and because i k less than or equal to E
59:57 - and what we do here is buffer And we say buffer 
sub k is equal to a sub k. And we could say k  
60:08 - is equal to k plus one. Now, what do you 
mean by this? Now, I'll tell you what,  
60:15 - what this means. The thing is that we're creating 
a temporary buffer that we're allocating from the  
60:21 - heap. And then we're going to deallocate it using 
the Delete keyword. But before that we're using  
60:25 - it because we don't want to reassign it in that 
existing array. So we want it basically stored.  
60:32 - And then we want something over here. So I'll 
just say this portion here, b, u, s, s, e r,  
60:39 - this is the buffer, this portion, and this whole 
thing, I'm talking about the whole thing. So this  
60:43 - is buffer, and this is going to be our output 
array. So this is going to be the sorted array,  
60:48 - we're doing in two separate things. Because if we 
swing just one single array, it's going to cause  
60:54 - complexities, much more complexities as just 
copying the elements. So suppose we have this  
61:00 - array. So just ignore this part, because it's not 
sorted right now. And we just created a duplicate  
61:06 - array that had all the values. So it started from 
K, and it went, so it said, zero all the way to  
61:11 - the value. Last one. So if I go back here, you 
could see that case started with a starting value,  
61:16 - and it was less than equal to n value. And it just 
said buffer sub k is equal buffer sub k. So a sub  
61:21 - k, whatever the value is, where it's going to 
store it in the buffer, so it just initialized  
61:24 - all of them, and just k plus one all the way to 
the end. So just copied, made a duplicate, right.  
61:30 - So now after that we could do is we're gonna 
have something specified here, right after this.  
61:35 - So once it's copied, bam, i is equal to s. Now 
we're gonna have one thing over here, which is J,  
61:41 - and we're gonna say m plus one. Now, I'll 
tell you why we did this. And we also have,  
61:48 - which is K. And we said that as S,  
61:55 - i is equal to s, come back here, and we have 
this IO. And it's going to be over here,  
62:04 - which is the starting value, just give me another 
color over here, I'll just get a little darker.  
62:10 - Okay, so I have over here, which is right here. 
And the second one, what we have is this mid,  
62:16 - we know that, okay, so other one we have is j 
is equal to n plus one. So if I go back here,  
62:22 - we have this j is this over here. And we 
know that this is endpoint right here,  
62:27 - he so you can see that this AI has to go in commit 
all the way to the M, this is its last element.  
62:34 - And this j has to increment all the way to the end 
portion here. So that's how we're going to compare  
62:40 - the values like two and three, which one is 
similar to planted here, go and commit to two plus  
62:46 - seven. And then we're gonna say seven and three, 
what is smaller, three smaller planted here, and  
62:50 - then put the rest. So that's the process what I'm 
trying to implement to code, I have to map this  
62:56 - out. So that's why I'm using this diagram. That's 
what we're doing. So we're going to have indicated  
63:01 - s, while let's have a while loop. And this is 
how this process is going to go I which is that
63:07 - value, what I told you, This over here is less 
than or equal to m, and j is less than equal to E,
63:13 - this process is going to go on. So if i less than 
equal to m, and we have j less than equal to E,  
63:22 - we want some process going on. So if that buffer, 
be you FF, er, FF er is E I, and then we have less  
63:34 - than equal to bu FF er sub j, if this process is 
done, so if a buffer sub i is less than equal to  
63:44 - buffer sub k, then what we're going to do is a 
sub k, that process what I was talking about,  
63:50 - that if it's less or equal than just copy it 
inside of that, Kate, then the array which is over  
63:58 - here, we want to sort it out, so we're just gonna 
copy here through buffer. So it's a bu FF, er sub
64:04 - i.
64:05 - So in the case, if it's less, 
right, if it's less or equal,  
64:08 - and then we just increment is equal i 
plus one, just what we did over there,  
64:11 - just what we did over there. So if that's 
not the case, we'll just have an else.  
64:16 - And when I put something in here, so let me just 
put over here, the case here is that a sub k,  
64:24 - a sub k is going to be over here, and it's going 
to equal to buffer. So it's going to be buffer,  
64:29 - and then we're going to have sub j over here. So 
we're gonna have this j in here, which is a sub k,  
64:36 - because if it's not the case, it's going to 
be less, right. So it meaning if it's less,  
64:40 - but if it's greater than the J is gonna be there. 
And then obviously, we're gonna have j being  
64:45 - incremented, instead of it being intermitted. 
So we have that and we have k is equal to k  
64:52 - plus one. Let me just have that. There you go. And 
now we have the condition here. So this is this  
64:59 - case over here. This is a while loop. And we 
have another while after this condition. Now,  
65:05 - I'll tell you the reason why behind this. 
So we have this while loop and after this,  
65:10 - we have two wild loops. Additionally, I'll tell 
you the reason why we need those two. The thing is  
65:15 - that if we compare these two, like, suppose we had 
this tool, and we had this three, we compare that  
65:20 - to was less. And then we incremented. It, we're 
just doing plus plus don't we did, but the case  
65:25 - one that we came here at this 19 and 21, how these 
come, this array just got full, all this was fully  
65:30 - remember this portion, but then we just appended 
these last two inside of this, how do we do that  
65:35 - automatic process that automatic process was going 
to be is going to be done through two wild loops,  
65:39 - we're going to be including, and that condition 
is like if is less than good, or if j is less than  
65:43 - equal to eat. Now this is the two conditions and 
look at this carefully. So while we say i is less  
65:51 - than or equal to m, so if this condition is like, 
still there, like it's true, like it broke out. So  
65:58 - the process here is that these two will never 
become false together, it's always going to be one  
66:03 - one of them and not the other. Right. So 
if that case like Jays listening, he that  
66:07 - came and then after we still have is less than 
equal m, what we could do here is that a sub k,  
66:13 - and this is the same scenario, what we did with 
the example, a sub k is equal to we're gonna say,  
66:18 - buffer so that we got the thing from buffer, and 
we said that as J. And what we do is basically,  
66:27 - actually, we're gonna have that set with I because 
it's eye over here. And we're going to set that  
66:32 - with eye, and then we're going to do is, we're 
going to increment i plus one, and we're going  
66:37 - to increment the K is equal to k plus one. And 
if the other cases, they're like, while j less  
66:44 - than equal to E, we're going to have a sub k is 
equal to buffer. And we're gonna have that as J.  
66:55 - Sub, there you go. And we have Jay Z going to j 
plus one. And we have k is equal to k plus one,  
67:05 - it's just going to increment the K value. 
And you already know where k is starting.  
67:10 - This is k right here. So this portion is K. And 
j is going to go 1-234-567-8910. All the way  
67:17 - when it's done. So it just keep on incrementing, 
you can see that j is over here is over there.  
67:21 - And that's the process going behind it. And then 
once we're done with it, we don't want this extra  
67:26 - memory, we just delete it. So we just delete 
our buffer and using this delete syntax, it's  
67:32 - basically we're going to deallocate it from the 
memory. And that's it. Now let's just have this  
67:38 - additional function that we need is basically, I 
think, so it's a printed, so Oh, I forgot my main  
67:44 - logic here. I mean, so this is mean, maybe I left 
it up on the top, yep, that's a common mistake.  
67:53 - Okay, so just delete that portion here. And let's 
just have a display function at the bottom here.  
67:59 - So at the bottom value, right here, let's have a 
display function. So it's going to be called void,  
68:04 - we're gonna have a display, and we're doing is 
basically having an array, just like the small  
68:11 - other ones, so have the size n. And we're gonna 
have something which is going to be implementing,  
68:16 - like we have temporary, and we're going to have 
that associated with a sub. What am I doing  
68:21 - x not actually that i is equal to zero, my dad. 
So we're gonna have while i is less than n,  
68:30 - and then we're gonna say, console, output the 
array value, array sub i, and put that comma here.  
68:38 - And then we have it just keep on incrementing 
plus plus. And yeah, constant output here.
68:45 - There you go. And now what we'll do is basically 
run the code here. So get a random array again.  
68:53 - So let me just get this array, which is right 
here, copy here, copy and paste it here.  
69:00 - And let's just change up the thing over here, 
which is insertion or sword, we're going to have  
69:05 - Mr. G, Mr. G, Mr. g sort, merge sort. So let's 
go back to our c++ compiler, c++, Mr. g, s,  
69:15 - o r t dot cpp, Ivan Oh, Mr. G, Mr. g, s, o r t, 
and a compiled Mr. g s. o RT. There you go, viola,  
69:30 - 110 and then 100 to whatever 293 and then 
all of that, and sorted in ascending order.  
69:37 - So that was it with merge sort. And this is much, 
much more faster as compared to any of the sorting  
69:42 - algorithms we've done so far. So even selection 
sort bubble sort, Insertion Sort, even the  
69:47 - problem that we did in the beginning, because 
those were of time complexity, old n squared  
69:53 - over n squared over n squared over n squared. 
But this merge sort is somehow faster, because  
69:58 - it's doing the time complexity. In all n log of n, 
so Oh, and then we have n, and then we have log,  
70:06 - and then we have that n inside of it. And this 
is much, much more faster as compared to any of  
70:11 - the other sorting algorithms. Now, if you get like 
a set of arrays from a text file that I could be  
70:16 - doing in my other videos, so stay tuned. For my 
next upcoming videos in my channel, you're going  
70:21 - to be seeing that we're going to have a text file, 
and we're going to be looking at comparing how  
70:25 - fast is this compared to other sorting algorithms. 
Because if we have these O of n squared,  
70:30 - sorting algorithms, these are going to take much, 
much more time as the input value increases, it's  
70:35 - going to exponentially exponentially grow. But as 
compared to merge sort is just going to be fast as  
70:41 - lightning because it's in all and all n log of 
n whatever complexity. So hope you enjoyed this  
70:48 - video, hope you liked it. And please make sure to 
visit my channel which is called coding cleverly,  
70:54 - where I have so much content of c++, and I've done 
data structures and algorithms. I have done object  
71:00 - oriented programming, done the basics, beginner 
level, procedural programming, and I my my goal  
71:06 - is to complete data structures. And then after 
that, I advanced to other project based videos  
71:11 - as well as new languages and technologies. 
So make sure to subscribe to that channel.  
71:16 - And yes, thank you so much for watching. I really 
appreciate the support. So thank you so much,  
71:22 - and thank you Free Code Camp for putting my 
video on their channel. Really appreciate it.