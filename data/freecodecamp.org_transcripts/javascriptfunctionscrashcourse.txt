00:00 - In this course, you will learn all about JavaScript functions. As one of the foundational pillars
00:06 - of programming, understanding functions is crucial for every aspiring developer. This
00:12 - course will provide you a comprehensive overview of functions and JavaScript, breaking down
00:18 - complex concepts into digestible modules, from the essentials of what functions are
00:24 - and why they're indispensable to diving deep into terminologies, scopes, closures, and
00:31 - advanced patterns like higher order functions and recursion. This video will help you become
00:37 - an expert at functions. Tapas has over 18 years of coding experience and has a passion
00:44 - for teaching and creating open source communities. He's the teacher of this course. So let's
00:49 - get started. Hello, friends. How are you doing? What is this crash course about? The crash
00:54 - course is about JavaScript functions. So we'll be going through a bunch of details about
00:59 - JavaScript functions in and out and try to understand with lots of code, like how it
01:04 - works fundamentally. One thing I keep saying, folks, is that the concept is much, much bigger
01:10 - than the syntaxes while we'll be writing code, but we want to deep down in the concept first
01:15 - and then complete that with the syntaxes. I hope you enjoy this entire course. And if
01:22 - you so, please like and share this video. If you have any doubts, comment below. I'm
01:27 - going to respond to you with all the doubts, clarifications, be assured about that. Okay,
01:32 - so a few things before we get started, how to take this course. This is a longer video
01:37 - because of course, it's a crash course, we have to fit in a lot of stuff within one video.
01:42 - But if you follow certain patterns, you will be enjoying the entire journey of going through
01:47 - each and every topic that we're discussing in this video. Okay, so first thing, take
01:52 - breaks, don't try to consume all the content at once, take adequate breaks, and then try
01:58 - to feel like what you have learned are just few seconds back. Second thing, after every
02:04 - logical chapter within this course, try to understand whether you have completely got
02:10 - the concept or not. If not, go back and try to relearn. No problem, any time go and try
02:15 - to relearn. I will be teaching a lot of exercises. So you have to do this exercise with me, but
02:21 - don't type them as I am teaching. Okay, first, try to understand what I am teaching, try
02:27 - to completely get it in into yourself. And after that, pause the video, try to do this,
02:33 - you know, those those quote, quote part by yourself. All the code examples are already
02:38 - there on GitHub. And the link to that is there in the comment section for the description
02:43 - section of this video, you can anytime pull it up and try to see like, you know, what
02:47 - is the code look like? So no worries about that. But don't type the code as I am teaching,
02:53 - because then you won't be focusing on what I'm teaching, rather focus on learning, and
02:58 - then try the code out. So go repeat, come back, learn and everything. And in case there
03:02 - is nothing clear, feel free to comment. I'm going to respond to you. So without any further
03:08 - delay, let us get started.
03:14 - Let's quickly talk about the concepts we'll be covering in this crash course. So first
03:19 - thing we'll be talking about JavaScript functions fundamentals, what is function what is it used
03:23 - about a very, very basic level, right? I'm considering a beginner when they watch this
03:28 - crash course, they will be able to understand what functions are and why they are used.
03:34 - Then we'll be clarifying few terminologies, there are a few terminologies, which are a
03:38 - bit confusing when you learn functions, for example, functions versus methods, parameters
03:43 - versus arguments, and there are many more such terminologies that we want to clarify.
03:48 - Next we want to talk about function declarations, we'll be talking about function executions,
03:53 - then we'll get into call stack, we'll talk about arrow function nested function function
03:58 - scope, we'll talk about closure, we'll talk about callback functions, higher order functions,
04:04 - pure functions, we'll talk about IIFE, we'll talk about recursion. So there are lots, lots,
04:11 - lots to learn, there are lots to talk about. That's why I told you like when we go to each
04:17 - of this chapter in this course, try to understand one chapter before you go to the next one,
04:23 - and please practice the chapter before you go to the next one. Alright, so take your
04:26 - time and let's get started with the learning. The first one about JavaScript functions and
04:31 - its fundamentals. So what is JavaScript function? Before I get there, let me tell you a story.
04:37 - It's the story of two friends. One of the frame actually trying to cook a dish, but
04:44 - she doesn't know the recipe of how to cook it. So she called her friend who is sitting
04:48 - abroad over phone, try to ask for the recipe. The friend at the other end, she received
04:54 - a call and told the recipe line by line saying that, Hey, if you want to cook this dish,
05:00 - you have to follow this recipe like you have to put this first, then you have to put this
05:03 - one, then you have to cook it for so long. And then finally, your dish is ready. Great.
05:08 - The friend cooked the dish following the recipe that she got. But after a week, when she tried
05:14 - to cook it again, she felt like, okay, let me ring up my friend again and try to ask
05:19 - the recipe. And the same thing happened. The friend gave the recipe over phone. She followed
05:23 - the instruction, cooked the favorite dish. Next month, the story remains same. She calls
05:29 - her the friend again, again got the recipe, cooked the dish for a few months. It went
05:33 - on like that. But after that, even though they are very best friend, the friend who
05:38 - is sitting abroad really got frustrated of it and just told, Hey, I have been telling
05:42 - you this recipe for like four or five months now. Why don't you write it down somewhere
05:46 - so that you don't have to ask me again and again. And I don't have to perform this task
05:51 - of telling you again and again. Rather, wherever you're writing it, you probably can fetch
05:56 - it from there. Then what the friend did, she wrote every instruction in a diary. And next
06:02 - time onwards, she never rang up the friend abroad, rather followed it from the diary.
06:07 - JavaScript functions a little bit like that. So it saves you from repeating the same task
06:13 - again and again. Rather, you put the task somewhere, and then reuse that every time
06:19 - you have to perform the same. Similarly, to that friend's story, who wanted to cook the
06:24 - dish, but finally, actually, instead of giving the task of her friend to tell it again and
06:30 - again repeatedly, she fetched it from the diary, the friend never had to perform the
06:34 - task again. Okay, so with this analogy in mind, like reducing the task, performing the
06:41 - task again and again, rather, we will create something so that we can actually reuse it
06:46 - whenever required in our programming. That's the very, very fundamental aspect of functions.
06:53 - Now you'll be getting into a graphics through which the similar kind of story will be putting
06:58 - into the code in a visual way and try to understand what exactly function does programming. The
07:04 - yellow box you see on the screen, consider that is a program. And in that you have a
07:09 - bunch of lines of code. Now, just look at it a little bit closely, there is a color
07:15 - coding, there are a bunch of black lines, then there is a green line, again, bunch of
07:19 - black lines, then is a red, orange, blue, again, bunch of black lines, and then there
07:25 - is a white line, right? So what I try to mean here, those black lines are the kind of code
07:32 - the same code has been repeated multiple times. So three black lines, then some other code,
07:36 - then again, same three black lines have been repeated, then some other code, then again,
07:40 - same three black lines got repeated like that, right? So there is a repetition exist. Now,
07:45 - we want to bring in the concept of JavaScript functions here, so that we can reduce this
07:49 - repetition. So what we do basically in this case, you know, going forward, is we first
07:56 - mark what are those lines that are getting repeated. So you see here, we have marked
08:02 - those lines that are getting repeated. And the next thing that we do is like, how can
08:07 - we make this code better, so that we don't repeat the same task, right, the same lines,
08:13 - rather than that, we kind of take those lines somewhere, give it a name, in this case, a
08:19 - name is like if you and fun. And then what we do is like the same code that we got, change
08:25 - it in such a way that instead of those line, we are going to use the same entity, the one
08:31 - we had created before. So do you see this one, the number of lines of code has reduced
08:36 - drastically. So what we did, instead of repeating the same task in your code, the first one,
08:43 - we have now put the code in something which we call as function, given it a name call
08:48 - if you and fun, and then use that if you and fun in our code, instead of repeating those
08:54 - lines every time. So we are not only reducing the number of lines of code in, you know,
09:00 - in our total source code, but what we are also doing is basically we are reusing something
09:05 - again and again. Now think about the case, like why, why do we need it, the best case
09:10 - probably is, let's say there is a problem in these three lines, there is a bug in these
09:14 - three lines. So in the previous case, if there is a bug, and you have to fix that bug, or
09:20 - you have to fix that issue, you have to fix this issue at least three times. So you have
09:23 - to fix it in the first bunch of line, then again, the second bunch of lines, then again,
09:28 - the third bunch of lines. But as we have put this thing into a function in a single place,
09:33 - and then reusing the same with its name in the multiple different places, if you have
09:37 - to fix the bug now, you have to fix it in one place, just inside that function's body
09:42 - just inside that function, and then rest of it will work. So functions are a bunch of
09:48 - blocks that you keep together to perform something which otherwise will be very, very repeated
09:56 - in your code function should ideally have a name, but it can be without a name also,
10:02 - in most of the cases, you will have function with a name, so that you can call the function
10:08 - with that name. So you me, every human being has a name. And the purpose of the name is
10:13 - like, we will be called by that name. And when someone will call us by that name will
10:18 - respond and say, Hey, I am here. I am is the I am the person. Similarly, for the function,
10:23 - when we call the function by the name, function will say like, Hey, I am here. And inside
10:29 - this, I have this bunch of code, go ahead and execute this code. Okay, so that's the
10:34 - beauty of JavaScript function. I hope you understood it. I know this graphics and please
10:38 - keep it in your brain. Because, you know, the rest of the crash course, we are going
10:44 - to use this terminology again and again, you know, for better understanding in programming,
10:50 - at times, terminologies are much more harder than the programming itself. And when a developer
10:55 - gets stuck on those terminologies, they feel so discouraged of learning that particular
11:01 - programming language, it happens. So that's where we are learning any programming language
11:06 - or an aspect of an programming language, we have to make sure that we understand certain
11:11 - terminologies very well. When you are learning JavaScript functions, there are a few terminologies
11:15 - that you also need to know, and you have to differentiate between them very well. So some
11:20 - of the terminologies are functions and methods, what are the differences, we're going to talk
11:24 - about that, then declaration and definitions, what is the difference, is there a difference
11:29 - between them, arguments and parameters, we'll be talking about that as well. And then callback
11:34 - and higher order functions, you will get confused often with these two, we'll be talking that
11:39 - also deep down when you go in the course itself. So these terminologies, keep in your mind,
11:45 - like when we are talking about it, make sure that in your head, these terminologies and
11:49 - the differences or the similarities is completely chalked out, completely cleared. If not, go
11:55 - back and try to see like where I have explained this one. If you still have further questions,
11:59 - ask them in your comment section, I'll get back to you.
12:06 - Let us now start creating functions and try to learn like how do we create functions.
12:11 - Okay, I think before that, so you can use any editor like you can use Visual Studio
12:16 - Code or any other editor of your choice while coding. What I'm using right now, I'm using
12:22 - browser's dev tools and the console tab, so that I can write the program here and execute
12:26 - them there and there. If you want any other mechanism like you will be writing on Visual
12:31 - Studio Code and use the live server to run your program, most welcome, or you can actually
12:36 - practice them on the browser's dev tool. Just go press F12, open the dev tools, go to console
12:42 - tab and start writing your program and execute it because you're just practicing at this
12:47 - point of time. So first, first thing first, what we'll be doing now is we'll be creating
12:52 - function. So we told that function is something which is going to help you to keep a bunch
12:59 - of instruction and code in a place so that you can reuse it again and again when you
13:05 - need it. Now to declare or to define a function. So our first terminology, bang, declaration
13:12 - versus definition. So these two things are exactly same when it comes to function. Function
13:19 - declaration, function definitions, defining a function is kind of same. If somebody's
13:24 - saying I'm declaring a function or another person saying I'm defining a function, they
13:28 - are actually talking about the same thing, which is nothing but creating a function with
13:32 - bunch of logic. So what we're going to do now, we're first going to create a function.
13:37 - So to do that, I have to use a keyword call function. This is the keyword, and then I
13:43 - have to give the function a name. I told just now the function may or may not have a name,
13:49 - but most of the time the function will have a name so that we can call the function by
13:53 - its name, just like the human being has name. There are situations where the function may
13:58 - not have a name and we'll talk about the situations in the in some time in this course. OK, so
14:05 - let's first give a name. Let's give a name called print me and then give a, you know,
14:12 - curly braces and then close that curly braces. So this is what you have declared or you have
14:19 - defined a function. OK, so right now the function has a keyword, a name, a bunch of parentheses,
14:26 - and then curly braces open a curly braces end. Inside this curly braces, you are going to
14:32 - write every logic that you want this function to have so that you can reuse this logic anywhere
14:39 - you want. For example, this particular function may just log certain thing into this console.
14:46 - So you do console dot log console dot log console is like an, you know, something that
14:53 - you already have with JavaScript on this particular debugger so that you can use it for your coding
15:01 - purpose for your debugging purpose. And on console, you have varieties of methods. One
15:06 - of the method is log through which you can log something in the console so that you know
15:11 - you can actually read them or it's more for the debugging purpose that you can use. OK,
15:15 - so let us do something like printing something like this. OK, so I have created a function
15:22 - with a function keyword and the name called print me and the instruction the function
15:27 - has is is a log that I want to print in the console and that log says printing. That's
15:33 - it. So this is my function definition or function declaration. Now, as I have declared this
15:39 - function with a name, the next thing that I can do beautifully is by calling this function.
15:44 - So to call this function, just type the name of the function, you know, print me over here,
15:49 - there is autocomplete already. And then to call it, you have to give this parenthesis.
15:54 - Otherwise, you are just printing this particular function's name. And if you just do this,
16:00 - the function is going to print its complete body itself. So if you just do print me the
16:04 - name itself, it is going to give you a string version of the entire function's definition
16:10 - or declaration that you have done just now. But to execute to call it specifically, you
16:16 - have to give this parenthesis, you must give this parenthesis, and then you press enter,
16:22 - it will give its output. It's just log printing, because that's exactly what we asked this
16:27 - particular function to do. So our function has worked. That's great. Now, as the function
16:33 - has worked, I want to just do something more with this. OK, so this is where what I'm going
16:40 - to introduce something called parameter. Okay, so let's write the same function function.
16:47 - And we will say the name is print this. And we will pass something over here, which we
16:54 - call as parameter, I'll get into it in a minute. And then I'll close this function's body.
17:00 - And inside this, what I'm going to do, I am going to write like console dot log, param.
17:08 - So what is it? What does it mean? What what I have done here? Okay, so I have first, similarly
17:14 - created a function with the function keyword and the function name. Here, I have not done
17:19 - anything between these two parentheses. But in this case, I have done something in the
17:23 - parenthesis. So whatever you put inside this parenthesis of a function, it's called parameters.
17:31 - Okay, whatever you put inside this parenthesis is called parameters, you can put as many
17:38 - parameters that you wish to, as long as you need in your programming logic. So if I am
17:44 - passing param is going to just, you know, I can use this param anywhere inside this
17:49 - function, so that I can do something with it. So for example, I can just now do print
17:56 - this and pass this is going to print the thing that I have just given over here. So it means
18:07 - I can pass a value to a function, and that value actually get mapped to the parameter.
18:15 - And that's something that I can use, you know, inside the function to do anything that we
18:20 - want. So again, there is a thing that I want to call out over here, there is a terminal
18:25 - logic thing, a parameter versus argument, anything in the function definition you pass
18:31 - inside this parenthesis is a parameter. But when you call this function invoke this function,
18:37 - the actual value that you're passing to this function is called argument. Okay, so that's
18:42 - the difference. Sometime what happened that we call this also as parameter that I'm passing
18:47 - the parameter, we call this as an argument that I'm passing the argument, that's not
18:51 - the case. So parameter is something that you pass to a function while declaring or defining
18:57 - the function, which is like this. But when you call or invoke this function, the actual
19:02 - value you pass to it, it's called the arguments. So I hope this is clear to you the parameter
19:07 - versus argument. Okay, great. So we have defined the function. And we have now know what is
19:13 - parameter we have now know what exactly is, you know, argument and things like that. Okay,
19:20 - so the next thing, we have defined the function, but there is one more way we can actually
19:24 - declare or define the function. That's called using the function expressions. Okay, so what
19:30 - is expression, let's learn. But before that, let me just clear it off all this thing that
19:34 - I have done, because I don't need it. So if I say const count equals 200, this is an expression,
19:43 - what this expression has, it has a variable name called count. It has like, you know,
19:49 - how we have defined this variable, we are saying this variable is a constant, and then
19:53 - is a value of this particular variable. Okay, so const count equals 200 is an expression.
19:59 - Exactly. Similarly, we can actually define a function. So let's take the print me function
20:05 - itself. So in the print me function, the print me is nothing but the function name, which
20:10 - we can actually put as a variable over here. And then what we can do here, instead of that
20:17 - 100 value, we can give function itself is a value. And then we give the functions body.
20:24 - And inside this function body, we can give whatever we need. Sorry, it's got executed
20:29 - my bad, I'll just put it over here. You can give console dot log, they print, right. So
20:41 - this is what I am done. So I have const print me equals to function and then this this thing.
20:48 - So previously, what I have done previously, I have done this function, print me. Okay,
20:56 - and then I have done here console dot log, say, printing. So now, I have just defined
21:06 - the function, but I have defined the function in the function expression way. So it means
21:11 - that the name that I have used for function before, now it's a variable basically. And
21:16 - then the variable what I have assigned is nothing but a function, I have assigned that
21:20 - a function. So it means print me is nothing but a function. Now, when if I did const print
21:25 - me equals to 100, print me is nothing but a number, which value is 100. Now I have done
21:31 - const print me equals to function, that means print me is a function. And then I should
21:35 - be able to execute this function. So first, I'll define this, okay, print me as already
21:40 - declared, because I have used this, let's use some other name for now, say print me
21:46 - again. Okay, so this is the name, and then I do print me again. And I have to execute
21:54 - me, so I have to do this parenthesis, and I got the print. So this is another way I
21:59 - can actually define and declare a function, right. Now, in the same thing in the print
22:04 - me again, let's say print me again, and let's say with param, what I can do now I can actually
22:13 - put any parameter here, right, or this time I'll put two parameters a and b. And here
22:20 - after coming, I'll be actually doing a and b. I have done now declared it. Now let's
22:27 - say print me again with param, if I do 10 and 20 as an argument is going to print 10
22:35 - 10 10 and 20. So I hope this is clear. And now you know like how we can actually define
22:41 - a function or declare a function. There are two ways we have done. Okay, so one is with
22:47 - expression and that is without expression. Let's learn how to return from a function.
22:52 - So return is something you will be using very often when you work with functions. So far
22:58 - what we have done, we have created a function, but inside that we have just done a console
23:02 - dot lock statement, which is not enough. Usually what happened is like when you create a function,
23:07 - let's say function x, and you have something over here, right. And then you will have say
23:14 - another function, y. Okay, and you have something over here. And then each of these functions
23:22 - are supposed to do their own task, right. And in the entire program, our entire application
23:27 - is not like that you will have only one function, you will have multiple functions. And what
23:31 - we'll be doing is like, if function x whatever is supposed to do, what you can use is basically
23:36 - you can use it like the output value of function x, and take this into a variable like say
23:43 - let p equals to this, and basically can use this p somewhere inside another function or
23:51 - anywhere else that in that matter. So basically, whatever the value of that x function that
23:58 - returns, you can utilize that value anywhere else maybe in another function or anywhere
24:03 - in your programming, right. So that is that is that is very much feasible thing in and
24:08 - the thing that you will be definitely doing. Now this thing to happen, if you see this
24:12 - expression, let me remove everything over here. And just to put this for your consumption,
24:17 - this particular expression, what we are doing, we are having a variable called p. And the
24:22 - piece value is what is not the function, but the value we get from executing a function,
24:30 - because we told a function name along with a parenthesis means executing calling invoking
24:36 - a function of function name without a parenthesis means it just the string representation of
24:43 - the function definition itself. This is a this is a difference that you have to keep
24:47 - in mind. So in this case, we have parenthesis means the function will execute function will
24:52 - be called or function will be invoked. And within that if the function is returning any
24:57 - value, if the function is returning any value, that value will be assigned to this variable.
25:03 - What if the function doesn't return any value? What if it just has a console.log like we
25:08 - have seen the function so far, in that case, simply the function execution will return
25:13 - something very special, which is called undefined. Okay, it means that something that is not
25:20 - defined yet is something called undefined. Okay, so now let us create a function that
25:25 - returns something. So for that, we'll create a function, say sum, and we'll do a summation
25:32 - addition of two things. So we'll take a and b as two parameters, terminology matters.
25:39 - And what we'll do is like we'll do return of a plus b, simple, which means that this
25:45 - is a function whose name is sum takes two parameters a and b, it sum up those two parameter
25:50 - with this arithmetic operation, and the result it returns, you know, back. So let's execute
25:57 - sum, it takes two arguments. Now, let's put two and three. It means we are expecting a
26:04 - five is returning a five. The same method, we can actually write a little bit differently
26:09 - how let's write the same method function, sum, we will do again a comma b. And in this
26:17 - case, we just did return of a plus b, instead of that, sometime, you might want to do this
26:26 - also, like let return a variable a plus b, and then return that particular variable itself.
26:37 - That is also same thing, same as you know, we have done whatever we have done before
26:41 - like returning a plus b directly, right. So if it is just a simple calculation, returning
26:47 - it directly itself will be a shorter amount of code that people does. So please follow
26:51 - that. This is about returning returning from a function, it means everything that you do
26:57 - inside a function, all the tasks, all the logic, all the operations, and at the end
27:01 - of it, if you want the function to return a value, so that that value can be utilized
27:07 - elsewhere, you have to use a return statement, followed by what you want to return. I hope
27:13 - this is clear.
27:18 - What is default parameter? When you define a function, we know how to define a function.
27:23 - So let's define a function function will take the same. Okay, little bit different function,
27:30 - let's say calc is a function, and it takes a two parameters a and b. And what we do,
27:37 - we will return some value and the value that we want to return is something like two into
27:43 - a plus b. Okay, this is the value we are planning to return. So what does this function do a
27:49 - simple function, a function whose name is calc, takes two parameters a and b, what it
27:55 - returns is for sum up these two parameters value, then multiply it with two, and then
28:01 - return something back a value back. So let's execute this, let's call this function with
28:07 - two comma three. Alright, so what it gives you, it gives you 10. Yeah, of course, because
28:13 - two plus three is five, five into two is 10. Similarly, you can do three into three, what
28:18 - is going to give you 12, three plus three is six into two is 12. Now let's say someone
28:23 - in the team forgot to pass this second argument, what you get, you get not a number. Why do
28:31 - you get an order number? Because when you don't pass an argument for a parameter for
28:37 - the function, the parameter value will be undefined. We told about that. So it means
28:43 - that in this case, you are not passing the second argument. So value basically, so then
28:49 - b will be undefined. Now a plus undefined on a will be three b is undefined, three plus
28:55 - undefined is not a number, of course, it returns not a number. Now on a situation like this,
29:00 - instead of getting not a number, you might want to safeguard it with some kind of default
29:05 - value, right, some kind of default value of these parameters, so that at least this one
29:11 - fail like this, rather, you can safeguard them with some values of, you know, something
29:17 - that you are liking. Okay, so what we're going to do the same function, I'm going to bring
29:21 - in again. And now I can actually default it to zero. Okay, it's a default value or default
29:27 - value for this parameter that I'm putting. So it means if someone is not passing a value
29:34 - for this parameter using the argument, the value zero will be used instead. Okay, so
29:40 - let's do this. Now I'm going to do Calc three again, if you see this now instead of no n
29:45 - n, not a number, it is actually returning a value which is six, which is let's do the
29:49 - computation a is three b is zero three plus zero is three three into two is six. Okay,
29:57 - so you can do a default parameter value for your function if it's required to. And in
30:05 - that case, you can safeguard it from an unnatural value return value from the function like
30:10 - not a number. And you can actually override the undefined value instead of having undefined,
30:16 - you can now set certain value with the default parameter. Rest parameters. What is rest parameter?
30:27 - The rest parameter is something that allows a function to accept any number of arguments
30:35 - as an array, any number of arguments. Okay, now theory is one side, let's do it with example,
30:41 - let's create a function, let's say give a function name, we'll give a name call say
30:47 - collect things. Okay. And we'll have two parameters of it first is x and then is y. Now we are
30:57 - talking about rest parameters are different kind of special parameters, right, we know
31:01 - about default parameters. Now, now we are learning about the rest parameters. And I
31:05 - just now say the rest parameter allows a function to accept any number and infinite number of
31:11 - arguments as an array. Now to make sure the rest parameter accept an infinite number of
31:17 - arguments, what we have to do, you have to give a special syntax to it, the syntax is
31:22 - with three dots. So when we give three dots, what happened is like this, this, this particular
31:28 - parameter become rest parameter. Now here are two things I want to call out a function
31:33 - definition can have only one rest parameter. So it means that you cannot do x comma rest
31:39 - parameter y comma rest parameter z, you cannot do that. So it can have only one rest parameter.
31:46 - And the rest parameter must be the last parameter that you define for the function. These two
31:50 - rules, please keep in mind, I'll repeat again, a function definition can only have one rest
31:57 - parameter as we have over here with y. The rest parameter must be the last parameter
32:03 - like how we have here. So you cannot have like you know, making this x as a rest parameter
32:08 - and then y as a normal parameter, you cannot have that rather you have to have like this,
32:13 - of course, the name suggests it means rest, rest means rest of it, rest of it means whatever
32:19 - is leftover. So that is where it goes at the end. Okay, now what I'm going to do, I'm going
32:25 - to do a console dot log of x. And then I'll go do console dot log of y, so that I can
32:35 - actually print and see like what exactly it prints. Now I have defined, let's just do
32:41 - collect things, sorry, let's just do collect things, and then pass some arguments, any
32:49 - number 5, 6, 7, 8, 9, okay, 9 enough. Now what I'm going to do, I'm going to call collect
32:55 - things with nine arguments, I can pass 100, 1000s, millions if I have time. Okay, so let's
33:01 - test it with 9. So what will happen, the first argument that gets mapped to the first parameter,
33:07 - so x value will be 1, and the rest of it 2 to 9 goes to the rest parameter. So it means
33:14 - y will now accept from 2 to 9, but within an array. Okay, so if I just printing it,
33:22 - so if you see, the first sprints x is 1, and then rest of the 8 goes inside an array 2
33:29 - to 9, this subscript is an array notation 2 to 9, and then that get assigned, this entire
33:35 - array get assigned to this y parameter, that's why it's called rest parameter. Hope it was
33:41 - again easy for you to understand, and you will try to practice a lot about the rest
33:46 - parameter.
33:52 - Let's learn about arrow function or fat arrow syntax. Alright, so we know how to define
33:59 - a function, right? Let's do it again. But this time, let's repeat the one we did with
34:04 - function expression, const add equals to a function. And then we have two parameters
34:11 - over here. And then we have return of x plus y. And finally, we close this particular breast.
34:24 - So that works, that's great, right? Now, what we can do over here to convert this one to
34:31 - a arrow function or fat arrow syntax that a few adjustment that you have to do. So initially
34:37 - the arrow function or the fat arrow syntax looks little weird. But how I tried to kind
34:43 - of remember writing it. And right now, what happened is like, I hardly write a function
34:48 - in the regular definition or declaration way, it's always about writing the function with
34:52 - the fat arrow syntax or the arrow syntax. Okay, so let's convert it, if you're new to
34:56 - it, you will take some time to get a grip on it. But once you get a grip on it, I'm
35:01 - sure that you're going to write the arrow function again and again. Because now I'm
35:05 - coming to the usage of it, because the best uses, you will write less number of code,
35:11 - you will write lesser amount of code. And be it any framework or any library today in
35:18 - the modern web development, I think the de facto, the very normal coding syntax for
35:24 - function is using arrow function. It doesn't mean that you cannot go with the traditional
35:30 - way of declaring and defining function or declare a different functions using expressions
35:34 - like the one we see on the screen, you can always go with that. But if you use arrow
35:40 - function, or you use fat arrow syntax, it's like, you know, much more modern, is much
35:45 - more less code. And of course, there is one more thing that is there which I won't be
35:49 - covering in this crash course in the but the but in the following one, the relationship
35:53 - with this keyword and arrow function, arrow functions, no binding to this keyword, that
36:02 - is what is another special case that comes but that will be covering into the this video
36:06 - that this keyword video that I'll be making next. Okay, but let's now focus on how to
36:11 - convert this one to arrow function. Okay, so to convert this one, what I have to do,
36:16 - simple thing, one is I'm going to remove this function keyword. So you don't need function
36:20 - keyword at all to make an arrow function. Next, we are talking about his arrow function.
36:25 - So you need an arrow. So arrow is a combination of this equals key, and this get it done.
36:30 - So if you have a greater than and the equals and the greater than key without any space
36:35 - side by side, you actually have an arrow like syntax. And this is what is making is an arrow
36:42 - function. So this is an arrow function, okay, const add, this is the parameter that we are
36:47 - taking. And then what is happening, basically, I am having an arrow and then the definition
36:52 - of the function. That's all about the arrow function. So I'm not using the function keyword
36:57 - at all. So let's just make sure that it runs to comma three, it runs five. Okay, very good.
37:05 - But one more thing that I can do, if the arrow function body the arrow functions declaration,
37:13 - having only one statement, just one line and one and returning something, you don't have
37:18 - to even give this, you know, curly braces. So this one you can very well define, like,
37:23 - you don't need this, just get rid of it. And then you get rid of it, that's it. So this
37:31 - syntax compared to this one, you know, the with the function keyword, this is much, much
37:35 - simpler, isn't it? So if you have a syntax like this, it is it is way, way easy for you.
37:42 - And if it is something like, you know, you have dependency with just one parameter over
37:47 - here, you don't have to give this parenthesis, you can actually do things like this. So if
37:51 - you have, you know, just one line stuff over here, so it's much, much simpler. So this
37:57 - is the reason why arrow function is very well depreciated, very well appreciated by the
38:05 - developer community, it is very well received by developer community, because you will be
38:09 - writing very less syntax is very less code. And in all the modern web development, you
38:17 - know, area that a function is used very heavily. So please practice writing arrow function.
38:23 - And I hope that you keep writing more and more arrow function in your code, then writing
38:27 - the function more traditional way.
38:30 - All right, so nested function, what does nesting means? We know how to create a function, let's
38:40 - say we create a function called outer. And that function has a body. And it can have
38:47 - certain instruction, like what is this function supposed to do? Maybe in this case, a function
38:51 - is supposed to print something called outer into the log. Now, JavaScript allows you to
38:58 - create a function to define a function within within another function. Okay, it might sound
39:04 - a little bit strange if you're new to it. But this is a very, very powerful feature.
39:09 - And this is the first basic thing towards understanding the concept of closure, the
39:17 - concept of closure in functions in JavaScript function equals to the understanding of nested
39:25 - function, plus function scope. So if you want to understand closure deeply, I want your
39:30 - attention over here first understand what nested function is, how does it work? Up next
39:36 - we'll be talking about function scope. And then we'll be talking about closure so that
39:39 - everything is very, very clear to you and is very straightforward to you. All right,
39:43 - so nested function. So function within a function, this means I can create another function over
39:49 - here, give it a name, maybe for simplicity, I'm giving it an inner. And I can give a console.log.
39:58 - As I've defined this function using the outer function, this function is called a nested
40:02 - function. And this nested function as I've defined outside, you know, inside this outer
40:08 - function, I have to call this one inside the outer function itself. Okay, so like this.
40:16 - So right now, if I have defined it this way, and if I call the outer function, what will
40:21 - happen? The outer function will be invoked, it will print this console.log, then it will
40:27 - see this inner function has been defined, the definition happened. And after that it
40:31 - will invoke the inner function also. So what will be the output if I do this outer over
40:36 - here? Okay, so the output is outer and then the inner. So it first print the log outer,
40:42 - and then the definition happened, the inner get executed, and this this inner actually
40:49 - gets printed out. So you can have nesting to any level in JavaScript functions. However,
40:55 - you won't see in practice, you know, too much level of nesting, but you definitely will
41:02 - see now if you go back and see the code, the various JavaScript code, you'll definitely
41:06 - will see some level of nesting, some level of defining one function, another inside another
41:12 - function happening. And it's a very powerful feature, we'll be able to see this in a moment.
41:19 - Just now we have seen what nested function is. And now we are stepping into understanding
41:29 - function scope. Okay, these two are a bit interrelated, because you have to understand
41:33 - the concept of nested function, you can define a function within another function. And then
41:38 - the function scope is important to understand who can access what? Okay. Now, there are
41:43 - certain generic rules. But to understand those rules, I thought a graphical picture will
41:48 - be much more important. So please pay attention to this graphic over here. So let's say there
41:52 - is a JavaScript file, you know, and a function is defined inside that. So the function is
41:59 - running globally, it means that the function is not inside any other function. So this
42:05 - blue one is a function, this particular function is not inside any other function, okay, the
42:11 - function is just defined globally. Now what happened, there are there are actually two
42:16 - rules, two primary rules that you have to keep in mind. And these two rules are very
42:21 - important if you understand, I want to understand closure. Okay. So the first rule over here
42:27 - is variable that are defined inside a function, the variable that are defined inside a function
42:34 - that cannot be accessed anywhere outside of the function. Okay, so the variable that this
42:43 - one is defined inside this function cannot be accessed from anywhere outside of the function.
42:50 - Okay, so anything defined in this blue box cannot be accessed outside of the blue box.
42:57 - Understood first principle, okay, of variable defined inside a function cannot be accessed
43:02 - anywhere outside of the function. Second principle, the opposite of it, a function can access
43:10 - all the variables inside the scope it is defined. A function can access all the variable inside
43:19 - the scope it is defined. So it means this blue function can access all the variables
43:26 - that is defined, you know, in the scope, the function is defined in the global scope. So
43:30 - inside the global scope, if I am defining, I'm having any variable, I will be able to
43:36 - access that from this function, but the reverse is not true. From the outside, you cannot
43:40 - access the thing which is inside. Understood this rule, let's repeat this rule again because
43:46 - it's very important for us to understand closure. Variables defined inside a function cannot
43:52 - be accessed anywhere outside of the function. First rule. Second, a function can access all
43:59 - the variables inside the scope that it is defined. So this blue box is defined in the
44:05 - global scope. In the global scope, if there are any variables from this blue box, from
44:09 - the blue function, I should be able to access it. Great. Now we have learned about nested
44:15 - function, no? So just replace this global with a function and this function one with
44:20 - a nested function, okay, inner function. So the global is outer function and this function
44:25 - is an inner function. In this case also, then the formula remains same. The rule applicable
44:31 - over here also. So it means your outer function cannot access anything from the inner function
44:38 - as the inner function is defined in this outer function. So it means the inner function will
44:43 - be able to access anything that is defined in this outer function because inner function
44:48 - is defined in the outer function scope. Very simple, right? So now if it goes keep going
44:54 - nesting, like if there is another function inside, there is another function inside.
44:59 - Same rule applicable. We have the same rule applied over there. So this is how it works.
45:05 - So you have to keep this thing in your mind. Now we are going to see with some code example
45:09 - here, okay. We'll be seeing some code example over here. But you have to really remember
45:14 - this rule that a variable defined inside a function cannot access anywhere outside of
45:19 - the function, you know, from outside of the function. A function can access all the variables
45:24 - inside the scope that it is defined. So these arrows and these things, if you keep it in
45:29 - your mind, I think things will be very clear. Okay, so let's move on and try to see like
45:34 - how the things works code wise, we'll be doing some coding now. So based on the rules that
45:38 - we have learned so far, we are going to write the code so that we understand this thing
45:42 - clearly, right? Let's create a function, let's create a function called a do something. Okay.
45:51 - And what is this function doing? It's basically, let's create a few variables inside that.
45:58 - So let's do let x equals to 10, const y equals to 20. And then let const, okay, let's get
46:09 - var z equals to 30. Okay. And then simply we'll do a console dot log of x comma y comma
46:18 - z. Okay. So we know if I now do do something, I just call this function, I know what will
46:26 - be the output is 10 2030 very, very straightforward things that we have created over here. Okay.
46:33 - So but this is where our rule number one comes into the picture, what was the rule number
46:39 - one variable defined inside a function cannot be accessed from outside. Right. So it means
46:47 - I have defined let x const y var z inside the do something function and I've executed
46:53 - do something it executed this console dot log x y z. Now if I try to take this console
46:58 - dot log and try to execute outside, what is going to happen? Do you see that? He says
47:07 - x is not defined. Okay, x is not defined, maybe x is late, so it's not able to define.
47:12 - Why also is cause not able how about a var? No, even if it is var, and it is defined within
47:18 - a function, you cannot access this variable outside a scope outside of this function,
47:26 - you cannot access that is the first principle that we have learned just now. Right. Now,
47:33 - second principle, what was the second principle? Do you remember? The second principle was
47:37 - about if the function basically now can access anything and everything from its scope, basically
47:46 - the scope where it is defined. Okay, so let's see the second rule. Now what will be doing?
47:52 - We'll be defining var x equals to 10, const y equals to 20, let z equals to 30. Okay.
48:06 - Now if I do function, do something and do a console dot log of x comma y comma z, what
48:25 - do you think will happen? If I just execute do something, what will happen? Do you think
48:31 - it is going to give an error or is going to print is going to print successfully? Why?
48:36 - Because our second rule say, wherever the function, whatever the scope the function
48:40 - is defined in that scope, if there are variables declared, the function can access this variable,
48:46 - this function is declared in the global scope, it means that function is not inside another
48:50 - function. So it means if the global scope is having any variables, so the function will
48:56 - be able to access those variables inside the function itself. But when we did the thing
49:02 - other way around, we have declared all this thing inside the function and tried to access
49:06 - them from outside, it doesn't work. So these two rules define the functional scope, the
49:11 - scope that we are talking about is the functional scope, you have to remember what is accessible
49:16 - where simple thing if it is in the outer scope, if it is if it is defined in the same scope
49:21 - where the function is defined, it is accessible within the function. But if it is defined
49:26 - within the function, it is not accessible from outside, even if it is a var that is
49:30 - declared and defined inside the function. Clear about it. Great. So ask a developer
49:41 - about a complex JavaScript topic. There are higher chances that we'll hear back closures.
49:49 - This is because the closures are not understood fundamentally by connecting the dots. Okay,
49:56 - from connecting the dots point of view. If you don't know about connecting the dots and
50:01 - creating a mind map to learn a complex topic, I have created a video on how to learn JavaScript
50:07 - by connecting the dots, please go ahead and take a look. Now, coming back to closures,
50:12 - if you learn closures by connecting the dots, you will find closures understanding much
50:16 - easy, if you just jump into closure and trying to understand you may not understand it well.
50:21 - But if you come from the background of nested function, then function scope, you will be
50:26 - able to understand closure very easily. Okay, so let's get into understanding closures,
50:32 - so that we can actually feel it, it's easy. Take a look into this picture on your screen.
50:39 - So there is a box inside that there is another box, consider this one as an outer function,
50:45 - and this one as an inner function, we have learned about the nested function already,
50:49 - right? So let's give them a name. For example, I'll give them give the for this one as f
50:54 - one as a function one, or we'll I'll give it as a name, the outer, to be very sure that
51:00 - they're out, this is outer, and this one, of course, inner. Now, you know, if I define
51:06 - a variable over here, say a, this variable is not accessible from outside. But if I define
51:15 - a variable over here, say b, this variable is accessible from inside the inner function.
51:21 - So we have learned this in the nested function and the function scope very clearly. Okay.
51:28 - Now, what is closure? The nested function is a closure, this inner function is nothing
51:35 - but a closure, okay, as simple as that. So if anybody asked you a definition of closure,
51:42 - you can tell this nested function is a closure. Now, if you go for a bookish, you know, closure
51:49 - and for example, if you go to MDN, and try to look for what is closure, you will get
51:55 - a definition like a closure is a function that can have free variables together with
52:01 - an environment that can run that variable, okay, which means it the environment is nothing
52:09 - but this inner function. And the variable means every variable that is defined inside
52:13 - that inner function. And there is an ability through which you will be able to run things
52:18 - which is in this inner function. So this inner function is basically is a closure. Okay,
52:25 - this is how we should be understanding closure. Now, let me summarize. The inner function
52:30 - can be accessed only from the statements in the outer function, correct, we'll see it
52:38 - in code also. And the inner function from a closure, it means the inner function can
52:43 - use the variables, the arguments, everything from the outer function, while the outer function
52:50 - cannot use the arguments and the variable from the inner function here. With this one,
52:56 - if we understand like what is closure, the closure is nothing but the nested function,
53:02 - because it provides an environment, you know, to the outer world. So this nested function
53:08 - can leave in a longer, the nested function can leave longer for execution. And it can
53:15 - actually perform the all the required operation. Right, so let's write a function will give
53:24 - the team as outer. And let's take a parameter of this one outer function. And then let's
53:33 - take another function nested function, which is like inner, we will also take a parameter
53:38 - over here. And what we can do here, this is the beauty of it, the inner function can access
53:46 - the outer functions variable and argument. So I can do return x plus y, correct, inner
53:53 - function can access the outer functions argument or any variable that is declared inside outer
53:58 - function. So I can do return x plus y pretty well over here. Okay. And then finally, what
54:05 - I can do, I can do return inner. Okay, I am returning this inner function as well. Okay.
54:15 - Now since the inner function, the inner function is which one this one forms the closure, this
54:20 - is what is closure. Okay. Now, what I can do basically, I can call this outer function.
54:27 - Okay, and specify the argument, and then leverage both outer and inner together. That's the
54:34 - advantage. Okay. So let me see, how can I do this? I'll just press enter. Now first,
54:41 - what I can do const outer return equals to outer, let's give 10. What do you think will
54:51 - be returned over here? This is this is this is the most interesting part, what will return.
54:56 - So once we call this outer function, outer function, return nothing but a function, which
55:01 - is like an inner function. Now when the function execution is over, the call is over, that
55:05 - function is over, right? That function is nowhere in the picture. So if I press and
55:09 - enter over here, outer is just over, it is nowhere in the picture. But the beauty of
55:14 - it, the beauty of it is the argument I have passed to outer is still leaves, where is
55:21 - still leaves inside inner because this 10 was passed over here, this 10 is still used
55:27 - over here and this still leaves, even after the outer execution because outer returns
55:32 - the inner, the inner is actually over here outer return. So let me just if I just do
55:38 - outer return for you, if I just do this one and print this for you, what it returns is
55:43 - returns inner y return x plus y, which is written this function, where x is nothing
55:49 - but this 10 that I have passed. So though the execution of outer is over, but the value
55:54 - that we have passed through outer still leaves within inner. So it means, it means if I just
56:00 - execute outer outer return now, oh, you to your outer return now, with a parameter set
56:09 - two is going to give me the output of 12. Why? Because outer return is nothing but this
56:17 - inner function, inner function expects a parameter over here, the parameter that I have passed
56:23 - as the no pass the argument over here. But what it did it actually use this two with
56:29 - a variable that I have passed long back and the execution is over. That's why this is
56:34 - called closure. This is created a closure closure is nothing but the variables and an
56:41 - environment that you can actually execute freely. What do you mean by freely? It means
56:47 - usually in functions whenever the function execution is completely over, this is done
56:52 - any variable that is that is actually created inside that that's all gone is basically you
56:58 - are not going to get it anymore. But in this case, though outer is executed long back,
57:04 - but the argument of the parameter we have passed through outer is still leaves within
57:09 - inner because inner is a closure, and I can actually utilize it, you know, at a later
57:13 - point of time. So this is what the concept of closure that you need to understand. This
57:18 - is what you need to understand is like, why closure is really handy method, why closure
57:25 - is really useful. So you can use closure for various use cases. One of the use cases that
57:32 - I have seen over here is like preserving the variable. So I have passed 10 though the function
57:37 - execution is over, but still 10 is preserved over here. And as it is preserved over here,
57:42 - it can be utilized with another value to compute something and return, right? That's why the
57:47 - closure is useful. In the video that I'll be creating focusing on closure, only there
57:53 - I'll be talking about much more real life examples and the use case that you can actually
57:58 - build with closure. So as you understand closure fundamentally right now, start practicing,
58:04 - start creating this kind of a small example where you have a outer function inner function,
58:10 - outer inner both takes some argument, you return the inner function from the outer function
58:14 - and see after outer execution gets over how the value that you pass through outer you
58:19 - can still used inside inner at a later point of time. So this kind of thing, the example
58:23 - that you're seeing over here, try to find out this example over internet or try to cook
58:27 - something by yourself and try to practice it more use case oriented example like real
58:32 - life use case oriented example of closure that will come in a dedicated video. I hope
58:37 - this clarify your concept. Now just to recap it once the closure understanding is depending
58:43 - on your understanding of nested function plus function scope. We know by nested function
58:47 - that a function can define one more function within it. We know why the function scope
58:52 - is like the outer function cannot access any variable inside the inner function. However,
58:59 - inner function can access any variable and the argument of the outer function. This ability
59:04 - gives us a very powerful feature called closure through which even if the outer function execution
59:10 - is over, but we can persist certain values which was passed to the outer function within
59:16 - inner function and compute it at a later point of time. That becomes a powerful feature itself
59:21 - a powerful design pattern itself in JavaScript, which is called closure. I hope this is clear
59:26 - to you.
59:31 - Now we learn about callback functions. What is callback? Okay, so everything is in the
59:36 - name itself callback. It means call it back some point of time. But let's understand with
59:43 - some example. Now in JavaScript function is a first class citizen. What do you what do
59:50 - you mean by that? It means that we can create a function we have seen function definition
59:55 - we can assign a function we have seen like when you do const x equals to function and
60:01 - then basically we can assign this function to a variable. We can assign a function we
60:07 - can return we can define a function within another function. We have seen this from the
60:11 - nested function. Now the next thing that we are going to see is like we can pass function
60:18 - as a parameter to another function. Okay, that is where the callback function comes
60:24 - into picture and we'll see what is use cases are. Okay, first, let's define a function
60:30 - called foo. Okay, and this is the foo function. What is this foo function doing over here?
60:38 - Let's assume that foo function can take another function as a parameter. Let's pass another
60:45 - function function as a parameter called foo or let's call bar because that's foo bar
60:51 - bus are the things that we usually use these names for example. Now as this function takes
60:59 - an argument which is nothing but another function. So it means I can capture it as a bar parameter
61:08 - and assume that this bar is nothing but another function. So it means that inside this I should
61:14 - be able to execute this function. Very simple. If it was a string I could have printed the
61:20 - string or concatenated with something else or done something with the screen. If it is
61:23 - a number I would have done something with a number. If it is a function I'll simply
61:27 - execute this function. Now to execute this function we know that we have to give this
61:30 - parenthesis to call this function or execute this function. This particular function is
61:37 - called a callback. This particular function is called a callback. But why? We'll come
61:44 - to that. But first I want to execute this. How do we execute this one? I have defined
61:50 - it. Now if I have to execute this I know that foo takes a function. So I can actually pass
61:56 - a function to it. Ok. And let's do something like this. So what I did? foo takes a function.
62:09 - Of course we told foo takes a function. The bar is a function. And we execute it inside.
62:14 - This means that I can pass a function as an argument to foo. So I have passed a function.
62:20 - Do you guys realize one thing over here? I have created a function which doesn't have
62:24 - a name. So this function is called anonymous function. The function that doesn't have a
62:29 - name is called anonymous function because it doesn't have a name. And as I will be using
62:34 - this function instantly over here I didn't bother about creating it again. Ok. So if
62:40 - I just execute this one. This function get passed over here and then it gets executed
62:46 - in this line. Once it get executed in this line this console.log get executed and it
62:51 - prints bar. Same thing what I can do instead of doing this line for you to understand this
62:57 - better I can create a function with a name. For example function named and instead of
63:04 - that I can actually say console.log of bar again. Same thing like the previous function
63:12 - instead of passing it directly. Now I can do foo of named. Right. It's exactly the same
63:20 - thing that whatever instead of again declaring the function with a name function and then
63:25 - passing the function over here I just pass the function directly over there. That's the
63:29 - only difference but output is same. Ok. So now you know a function can take a function
63:35 - as an argument and I can actually do that. And the function which is passed as a parameter
63:41 - and I am using it you know inside it at a later point of time is called callback function.
63:46 - But why it's called callback function. That's the thing. Let's go from the beginning again
63:51 - to understand why it's called a callback function. So again we'll be defining function foo take
63:58 - another function bar and let's say I have some condition. Condition is if it's night
64:05 - consider that it's night is a boolean variable it can be true or false. In that case you
64:13 - call bar. Ok. Usually at the night only like you know bars will be like flourishing everywhere
64:20 - or let's say another condition is there if is drinks over check online in this case only
64:35 - ok. Pelling mistake check online in this case itself you call bar. So we have two conditions
64:44 - where we want to call this particular function call bar. The one condition is if it is night
64:51 - then call bar function or maybe do an online call or network call to check whether the
64:56 - drinks is over then only you call bar. So it means that calling back bar is based on
65:03 - certain kind of conditions that is happening within this function. This is a case where
65:08 - you actually want to call this function as a callback function. You are calling it back
65:15 - based on certain conditions based on certain things. It is so so amazingly powerful because
65:21 - you can pass any function to another function and call this passed function based on any
65:28 - condition at a later point of time. That's why it is called call back. Now if you want
65:33 - to understand this concept with much deeper example. I have created an example with the
65:38 - pizza hub or the pizza hub and a little boy story. It's like a storytelling so that anybody
65:43 - can understand. That video is already out there. Go ahead and check out that video.
65:48 - The link of that video is in the description of this video. You can check out and find
65:53 - out like you know how in a real life application you can use call back you know effortlessly.
65:58 - So I hope the callback functions is clear to you now.
66:07 - Now we learn about higher order function higher order function or HOF. OK. What is higher
66:12 - order function. A higher order function by definition is a regular function is a normal
66:17 - function that takes one or more function as an argument and or returns of function as
66:27 - a value of it. OK. Let's write it down. It's a bit complex in that way. So one condition
66:33 - is like it takes one or more functions as argument. OK. This is the first thing. And
66:46 - then the second thing. It may return a function. OK. So not necessarily both the conditions
66:57 - has to be made for a higher order function. If any of the condition meets it's actually
67:03 - a higher order function. Now we just now spoke about a callback function right. What is told
67:09 - about callback function. A callback function is a function which takes a function as an
67:14 - argument based on certain conditions or something. Whatever the function we are passing as an
67:20 - argument it is going to invoke that function inside. Now in the first case of the HOF higher
67:27 - order function is about taking one or more function as an argument. So it means there
67:32 - is a relationship between a higher order function and a callback function. And that is where
67:37 - sometime in interviews interviewers put some tricky question is HOF and callback are same.
67:45 - No HOF and callback are not exactly same because for callback functions it is not mandatory
67:51 - for the main function to return any function. It can accept the function as a argument.
68:01 - Do something with it. But it is not necessary that it has to return a function. Whereas
68:06 - in higher order function if the function return another function it calls a higher order function.
68:13 - In that case also it calls higher order function. OK. So it means that if I am just taking like
68:21 - a function. OK. Let's take a function. Let's give it the name call gate capture and let's
68:28 - take a parameter called camera. OK. Now if I am doing like this. This is a higher order
68:39 - function. Why because camera is a function and I'm executing this one over here. So I
68:45 - can actually call get capture over here. I can call. Sorry about that. I can call get
68:56 - capture over here. And pass a function to it. I can say function. OK. Do a console console
69:09 - dot log. Say can on. OK. So it execute. This is what we have seen when we understood a
69:23 - callback function. Now we can do the other part also like a function returning another
69:28 - function which is also called a higher order function. So how it will be. We can actually
69:33 - do like function return the f n and it can return a function with say a console dot log
69:55 - of returning something we are printing over here to prove that it works. Now how am I
70:03 - going to execute this multiple ways to execute it. For example. Const. Say f n equals to
70:13 - I can do return f n. To return f n. When I return f n what it does it return a function
70:21 - right now. So if I do this. So f n is now nothing but a function. If you see that the
70:27 - moment I'm typing f n it is giving f. If I just do a printout over here. It is running
70:31 - a function to execute this one. It means I need the parenthesis. OK. So it will execute
70:36 - this one. So this is one way that I actually can execute this thing. So I hope this is
70:44 - quite clear. Now do you. If you are working on JavaScript for some time you are already
70:49 - using some of the higher order function. You know already. And the higher order function
70:54 - is extremely extremely useful for you know your core reliability predictability aspects
71:03 - of it. You are already using some of those things called array functions like map filter
71:09 - reduce find all this method that you have right on the arrays are all higher order functions
71:18 - because they are also you write a code like you know one if I take like one comma two
71:24 - comma three and on this array you do something like filter and in here you pass a function
71:31 - right your filter condition you pass over here if you are using array already you will
71:36 - know that and this is where you actually put your condition like based on which condition
71:41 - you want to filter this one out right you get this like element and if the element greater
71:49 - than two greater than three you know you actually write conditions like that and based on that
71:55 - you filter the things out. So this is an example of a higher order function like how why exactly
72:02 - for higher order function and where you use the higher. Now again if you want to get a
72:07 - very very deep look of higher order function as it is crash course we are not getting into
72:12 - too much deep but you want to get a very good deep of a higher order function. I have already
72:16 - created a video for it. Please take a look at it. I'm sure that you will enjoy learning
72:20 - higher order function and try to understand what are the different use cases apart from
72:25 - built in JavaScript functions whenever you are coding in what cases you will be using
72:29 - higher order functions. Please take a look. Let's see what a pure function is. In JavaScript
72:40 - when you are dealing with function you deal with lot of pure functions you also deal with
72:44 - lot of impure functions. By definition a pure function is a function that produces the same
72:50 - output for the same input. So function say greeting input is name and what is going to
73:03 - do is going to return a greeting message. So return hello and this kind of greeting
73:14 - message is going to return. Fair enough. So if I call say greeting and pass my name is
73:23 - going to return hello tapas. So for same input is going to return same output. If I as many
73:32 - times I am going to input tapas that many times it is going to return hello tapas. If
73:37 - I do hello YouTube it is going to return hello YouTube. As many times I am going to input
73:43 - YouTube that many times it is going to output hello YouTube. Pure function. This is pure
73:48 - function. Pure function helps in predictability. It means that if the input is same output
73:54 - will be always same. So this is very very predictable. What is impure function? Just
73:59 - the opposite of that. It means that for the same input it is not going to create the same
74:04 - output. So same function if I just do a little bit different way. So for example let me create
74:11 - a variable called greeting and what I did now initialized with hello. Now I have a function
74:20 - like function you know this guy. I will just copy this so that I can utilize it. But I
74:26 - will change a little bit. What I will be changing instead of this hello. Heartcoding hello.
74:31 - Now I am taking this greeting from here. Alright so if I now say greeting tapas it will give
74:43 - hello tapas. Fair enough. If I give tapas again it will give hello tapas. Fair enough.
74:48 - But if I change this greeting variable value to from hello to hola. Hello to hola. And
74:58 - then I do it again for the same input tapas the output become hola tapas. So from hello
75:06 - tapas it become hola tapas. It means say greeting is not producing the same output for the same
75:14 - input. Right. No. Because it is depending on something and that something is called
75:21 - side effect. What is a side effect? The side effect is nothing but a variable which is
75:25 - outside of the scope of say greeting function and say greeting cannot control this particular
75:32 - variable. Any anyone can change which can create a side effect such that this particular
75:38 - function is no more appear function. It is no more returning the same output for the
75:44 - same input. So this is the difference between pure versus impure function. Can you write
75:49 - all the functions as pure function in your application may not be you may not be able
75:53 - to write you know all the functions as a pure functions because there will be side effects
75:57 - you need things like that you have to make network call you have to probably write something
76:01 - on the console log everything is side effect. But as much as possible if you can make certain
76:06 - things as pure you have more more predictability for those cases. So look out for this thing.
76:12 - Again if you want to get deeper to pure function you want to learn like the real life use case
76:17 - of pure function where exactly we use where can we make use of it. I have created an extensive
76:22 - video for pure function. Take a look at it so that you can learn and practice it much
76:27 - more. All right. So I hope now you got the basic fundamental understanding of a pure
76:32 - and impure function. All right friends. So let's learn IFE. What is IFE. It's an abbreviation
76:44 - of the term immediately invoked function expressions I for immediately then I for invoked then
76:52 - if for function if or expression immediately invoked function expression what does it mean.
76:58 - It means it's a function expression that's where the code inside the function gets executed
77:04 - immediately after it's been defined. Now let's take a function for example function X is
77:11 - the function right which is having a name X. Now if I have to execute this function
77:16 - at a later point of time whenever I want in my code what I'll do I'll just use this name
77:21 - with the parenthesis and execute this function. OK that's great. Now the only reason why this
77:26 - name exists the X for this function is because I can use this name to execute this function
77:32 - at a later point of time. Maybe wherever I have defined this function after two hundred
77:36 - lines after that based on certain logic I am executing I'm calling I'm invoking this
77:41 - function. All right. But IFE says the use of IFE is to execute the function immediately
77:50 - after it's been defined. So if I have to do that I don't need the name of the function
77:55 - because the moment I define right after defining the function I want to execute it. So I don't
78:00 - need a name. So let's start with something which doesn't have a name. I did function
78:05 - X before I don't give any X now rather I have created something like this. But if I try
78:11 - to run this it's going to give me a problem saying that function statement require a function
78:16 - name. OK. So now I cannot create an anonymous function like this and let's just keep it
78:22 - as it is because it's require a function name. OK. Now let me introduce an operator called
78:27 - group operator which is nothing but a bunch of parenthesis. Now if I put this anonymous
78:33 - function the function without a name inside this group you know operator what happened
78:41 - if I just give an enter it actually gives me the string representation of this particular
78:47 - function itself. The string representation of this function itself. Correct. Without any
78:52 - name but string representation. In previous chapters we have seen whenever we get a string
78:58 - representation of this function itself it means it's a function. So it means I can actually
79:03 - give the parenthesis after that to execute it. So it means if I take this guy and just
79:09 - put a parenthesis around this it means it will be executed. Yeah. So I have got a proper
79:15 - function that's got executed. So this is what is IIFE. So now let me write a few code inside
79:22 - this so that you know that it gets executed. So console dot log IIFP. If I just try to
79:28 - execute this you see that IIFE got printed. So the function when I am defining at the
79:33 - same time I am also executing this function that is what is IIFE that is what is immediately
79:40 - invoke function expressions. Now if you ask why does it exist there are a few reason why
79:46 - it exists. Before ES6 I mean before we had like late const all this better way of managing
79:54 - accessibility of a variable like where it where what can be accessed where where things
80:00 - cannot get polluted where you have you know before ES6 where you had only var like the
80:07 - chance of your global variable gets polluted you had no other option that using IIFE to
80:14 - protect them. OK. Also another reason is like a very normal reason is like when you create
80:20 - a function with a function name it means the function name unless it is a like nested function
80:26 - or inner function the function name basically exists in the global context and the globally
80:31 - it is not inside any other function. So it means there are chances that somebody else
80:35 - might be using the similar function name somewhere else might there is a chance of kind or a
80:42 - variable name with the same name as the function name and the chance of getting it polluted.
80:46 - So for that not to happen the IIFE can be used. So IIFE can be used for various different
80:52 - use cases but the concept of IIFE is this that whenever you actually define the function
80:58 - immediately after that you want to execute it. Only in this case you use the syntax and
81:04 - use that IIFE. I hope the syntax breakdown also makes sense to you because it doesn't
81:08 - need a name. So we started with an anonymous function then we actually used a group operator
81:14 - around that so that we get a function definition and then the last parenthesis basically a
81:19 - pair of parenthesis used always to call or the invoke the function we use it along with
81:24 - it and we got an IIFE result then and there. I hope it was useful. Thanks for watching.
81:34 - So we are going to understand call stack but before understanding call stack we have to
81:38 - understand function executions very well. OK. So first we'll understand what call stack
81:44 - is and also we'll understand what is function execution so that you get a complete clear
81:49 - picture about it. The element that gets inside the stack first it comes out last. Right.
81:56 - So here consider there are three elements like F1 F2 F3. They went in like first F1
82:02 - then F2 then F3 but when it had to come out the F3 come out first then F2 and then F1.
82:09 - That's how the stack stack works. Now instead of normal variable if a function gets inside
82:15 - a stack then it will be like similar way like first F1 F2 F3 gets in and then F3 F2 F1 it
82:23 - comes out in this sequence. So when a function gets executed there is a stack that JavaScript
82:29 - engine maintains. OK. And in that stack it defines like how the execution of this particular
82:36 - function takes place. Whenever JavaScript interpreter go line by line and encounter
82:42 - a function call or a function invocation it puts that function inside a stack executed
82:49 - and once the execution is over it takes it out from the stack. The reason for doing this
82:54 - there is a proper sequence of how the functions are getting executed can be maintained through
82:59 - the stack data structure. We are going to see that with example. All right. So the first
83:04 - example that we are going to take there are three functions F1 F2 F3 you are able to see
83:10 - on the screen. Each of this function have bunch of code that can be executed whenever
83:14 - we are invoking or calling this function. We are calling these functions first F1 first
83:18 - then F2 then F3. Right side we have a function execution stack or call stack. So call stack
83:24 - and function execution stack are the same. What we're going to see like when these functions
83:30 - are getting executed like first F1 gets called what happened to call stack then F2 what happened
83:36 - to call stack then F3 what happens to call stack. That's what we want to learn. OK. So
83:41 - please pay an attention to this call stack and also how the code is getting executed.
83:46 - The first thing first F1 F1 gets executed F1 gets inside the call stack or the function
83:51 - execution stack inside F1 bunch of code. OK all done done done getting executed. There
83:57 - is no function inside it. So nothing else to put at this point of time inside the stack.
84:02 - Then F1 execution is over. Take out F1 from it. Next F2 gets executed. Put F2 similarly
84:08 - over there. There is no function inside it but execute all the code. Execute F2 take
84:14 - it out. Then goes to F3. Again put F3 inside the stack. Execution is done. There is no
84:20 - function bunch of code. Get it get it executed. It's out. It's very simple F1 F2 F3 has got
84:26 - executed. Now let's take a little bit complex scenario with this code. So what is happening
84:31 - here you have F1 your bunch of code. There is no function in it. Then you have F2 a bunch
84:37 - of code but there is a function F1 which you have defined before we are invoking over here.
84:42 - You remember a function can have another function inside it. A function can invoke another function
84:47 - inside it. Yes. This is an example. So F2 basically invoke F1 or call F1 inside it along
84:54 - with a bunch of code. F3 there is no other code other than it is executing F2. It's like
84:59 - a chain. Right. So any invoke F3 it is actually invoking F2. F2 executing a bunch of code
85:06 - and invoking F1. F1 executing a bunch of code but no function invocation inside F1. Now
85:13 - how this can be depicted into call stack or the function execution stack. That's what
85:18 - you're going to see. So again pay attention to the right side. First what happened when
85:22 - F3 executes. When F3 executes it finds F2. But before that F3 has to go inside the call
85:29 - stack because of function has to go inside call stack to get executed. So now F3 get
85:34 - executed it finds F2. Oh yeah. F2 another function. So before I take out F3 out of it
85:41 - because F3 will be taken out only when F3 is complete execution is over. But it's not
85:46 - over now the cursor is at F2. So it has to put F2 inside. F2 came inside. The F2's execution
85:53 - gets started but F3 is still in the call stack. So F2's execution a bunch of code is executed
85:58 - this line get executed this line get executed. Oh now it encountered F1 which is also a function.
86:04 - It's time to put it in the call stack. The F1 got into the call stack. Now if you see
86:08 - in the call stack or the function execution stack you have F1 F2 F3. But in the reverse
86:14 - order of how they have got entered right. Now we are the F1. F1 a bunch of line of code
86:20 - are there. Let's execute them one by one. But there is no function. So nothing else
86:25 - to put into the call stack. But execution when it is over for F1 we have to take it
86:30 - out from the call stack F1 is over. Now our cursor is over here. So F1's execution is
86:36 - over. That means F2's execution is also now over take out F2. So cursor is over here.
86:42 - F2's execution is over. The next line there is no more code. That means F3 time to take
86:46 - it out. Isn't that awesome. So this is exactly what function execution stack or call stack.
86:54 - That's how it works. That's how JavaScript engine maintains at what sequence your function
86:59 - should be executed. I hope it is very clear to you right now. Now this particular concept
87:04 - is very very important if you want to learn JavaScript asynchronous programming deeply.
87:10 - I have a complete series created for JavaScript asynchronous programming. If you were interested
87:16 - go ahead and take that series. I'm sure that you will be able to master that concept very
87:21 - very quickly. All right. Thank you for watching. Hello friends. Let's talk about recursion.
87:31 - What is recursion. Recursion means a function that refer or call itself. OK. What does it
87:38 - mean. Let's create a function. Let's say function foo. And inside that we create we do we OK
87:46 - function foo. Inside that we do a console dot log. Let's say foo. And then we say that
87:52 - a recursion is something where the function can refer or call itself. In this case we'll
87:58 - call itself. What happened when we invoke this. So we invoke foo. OK. Are you with me.
88:05 - What is going to happen. Do you see what happened. The function is keep calling keep calling keep
88:09 - calling keep calling and after some point of time is going to say maximum call stack
88:14 - size exceeds. So if you know about function call stack now it means that foo is going
88:20 - to put itself multiple times into the call stack call stack call stack multiple times
88:26 - and once will happen the call stack has a max size defined when the max size limit the
88:32 - threshold limit reached is going to give the error call maximum call stack call stack exceeds.
88:39 - That's the error that we are getting. OK. But if you're getting an error what is the
88:43 - use of recursion. OK. We'll come to that. Just a second. But before that this is one
88:47 - way that we can actually define recursion like a function is actually invoking itself.
88:53 - Let's do another way. That's how the recursion can be done. For example const foo equals
89:01 - to function bus and then inside this what I'm going to do I can call foo like this.
89:16 - What will happen. So in this case I have created a function and the function is assigned to
89:22 - a variable call foo. So that means foo itself is a function. So in this case foo and bus
89:27 - are almost same. So whether you call foo here or you call bus here whatever it is you are
89:34 - actually creating a recursion here because now you are referring to this particular function
89:41 - either with foo or with bus whatever name it is it's the same function. So that's the
89:45 - another way you create the recursion. So in this case also it will just OK who is already
89:51 - exists because I use this name before. So if you actually use it it is going to actually
89:57 - create the recursion for you. OK. Both the cases are same. Now we saw like with recursion
90:03 - what was happening. It was just creating it was calling itself calling itself calling
90:08 - itself and then it hits the maximum heap size and the error out. Then why should we use
90:14 - recursion. OK so one thing is like whenever you are using recursion you have to make sure
90:24 - that you have something called base condition. OK. This is very important. So recursion without
90:30 - a base condition is not of much use base condition means under which condition you have to stop
90:38 - the recursion. You have to stop the recursion at some point of time because you want to
90:43 - stop the execution of that function to execute itself at some point of time so that you can
90:50 - exit it out or do something else. So that condition is called base condition. OK. So
90:55 - usually how you will be writing things in recursion in a recursion program. So you'll
91:00 - write writing something like function recurse function recurse if it is a base condition
91:11 - if base condition in that case you probably do something and after that you return otherwise
91:24 - continue to recurse. So this is how you actually do recursion. You should have a base condition
91:32 - and if there is a base condition you do something and then return from it. Otherwise you continue
91:37 - to recurse. OK. Let's write a program so that we can actually understand in a much better
91:41 - way. OK. So the program that we'll be writing is about let's say we'll be fetching water
91:46 - multiple times. So let's call a function. Create a function called fetch water and let's
91:56 - take a parameter called count like how many times you want to fetch the water and we say
92:02 - if the count is zero this is our base condition. OK. We have written the base condition. In
92:11 - that case you do something. Maybe I'll do like console dot log and say like no more
92:18 - water left. So sad. OK. Done. And then I will return. Otherwise keep fetching the water
92:29 - and I will do like count minus one and we can do a console dot log here also saying
92:42 - console dot log fetching water. OK. We'll see the enter code and then after fetching
92:50 - water we'll do that line got deleted somehow. Fetch water count minus one. All right. So
92:59 - let's read this code once more. What we are doing. We have a fetch water. We are calling
93:03 - fetch water again. Here is a recursion of course but we have a base condition also.
93:08 - The base condition is when we'll be exiting from the recursion. Our base condition says
93:13 - when the count is zero then I'm saying no more water left and break this recursion but
93:19 - until count is zero I'm just recursing it just fetching the water. Correct. So now if
93:25 - I say fetch water five times what will happen. It will go count is five is equals to zero
93:35 - no it won't go inside that base condition doesn't meet. Fetch the water become count
93:39 - four. So count four means again call the same function with count four. So count four comes
93:44 - here is four is equals to zero no again base condition doesn't meet. Again fetch the water.
93:50 - Now call the same fetch water with four minus one that is three. Keep doing this until count
93:55 - is zero. Once the count is zero no more water left and you exit from the recursion. Right.
94:02 - We'll do. So fetching water fetching water fetching water fetching water fetching water
94:06 - and then no water left. So we have written a program using recursion and we also have
94:12 - the base condition through which we exit this recursion. Right. Now the same thing you could
94:18 - have done with for loop isn't it. The same function same functionality would you could
94:23 - have done with for loop. So there is always some debate like whether you should be using
94:28 - recursion versus using for loop. Wherever the for loop applicable maybe you should be
94:33 - using for loop. But in some cases for example you want to create the factorial of a number
94:38 - factorial means factorial of n or factorial of five means five into four into two three
94:43 - into two into one. Right. So the if you want to do a factorial maybe the recursion is the
94:48 - right way to go because it makes the code much more readable than doing a factorial
94:54 - using for loop. Right. So readability is one of the factor that you want to probably take
94:58 - it into account when you use recursion over for loop wherever recursion is applicable.
95:03 - So that's all about recursion. Whenever somebody is asking about your recursion please also
95:09 - mention that you have a best condition where you can exit out from recursion. I hope it
95:14 - was useful. It's all right friends. Everything has to come to an end. So our this crash course
95:20 - also has to come to an end. I hope you enjoyed learning all about the functions all the things
95:27 - about functions. Some of them at a very high level. Some of them in depth. But the purpose
95:33 - of this course was to do a crash course where we can run through all the aspects of JavaScript
95:38 - functions and give you an idea give you the confidence that you can learn some of these
95:43 - concepts if you learn incrementally if you learn by connecting the dots. So we started
95:48 - with very basic things like how to create a function and ended with recursion in between
95:53 - we touch nested function function scope closure pure function call back all these various
95:59 - aspects. But your learning should not stop here. You need to keep practicing each of
96:04 - this concept much deep by with your hands on. And I have videos for some of this concept
96:11 - to teach much more deeper way. For example call back pure function HOF you know a lot
96:16 - of these things are having in-depth real life use case scenario videos. Please go and watch
96:21 - them if you're interested or if you want to read it from somewhere or from some other
96:26 - YouTube channel. Please feel free to do that. But the learning should not stop here. This
96:30 - crash course purpose was to give you a start give you the required confidence so that you
96:35 - can now keep learning. All right. All the best. And again a simple and small request
96:41 - please subscribe to the channel if you have not done already and hit the bell button so
96:45 - that whenever I publish a new video you get a notification of. All right. Take care of
96:50 - yourself. I'll come back. Another video. Thank you.