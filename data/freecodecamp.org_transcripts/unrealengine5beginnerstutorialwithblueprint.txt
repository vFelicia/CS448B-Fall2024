00:00 - In this game dev course varnas games will teach 
you how to build games with Unreal Engine five,  
00:05 - you will also learn how to use the blueprint 
visual scripting system that makes it simpler  
00:10 - to create gameplay elements. Hey, guys, thank 
you so much for checking this course out.  
00:16 - This is going to be a very, very beginner level, 
Unreal Engine five blueprints only course,  
00:23 - we're going to make a simple game called 
the battery man. So if I play this game,  
00:27 - what's going to happen is I have a few batteries 
present all around the scene, I have to collect  
00:33 - these batteries over here. And once that's done, I 
either go to the new level, or I win the game. So  
00:41 - here, this is my second level. And if I collect 
these batteries, I have my event condition. And  
00:47 - I always have a loose condition too. So if I wait 
it out, if I don't collect any of these batteries  
00:53 - over here, and wait for five seconds, I lose the 
game, I can quit if I want. And if I can retry,  
01:02 - we obviously still we have made many too. So we're 
going over everything in this game, including  
01:09 - UI validate taking a look at when conditions and 
emissions. We're coding everything from scratch,  
01:15 - we're using the Third Person template, but 
we're not using any of their built in movement,  
01:20 - we're going to create our own character 
add our own functionality to these  
01:24 - to this character. So it's going 
to be a game that you have.  
01:30 - Hey, guys, and welcome back. Now we 
will take a look at Unreal Engine five  
01:35 - and try to create our own project. So what you 
have to do is open up your Epic Games launcher.  
01:44 - And Epic Games launcher is essentially a poster to 
Unreal Engine and its marketplace. So if I'm if I  
01:51 - let's take a look at the marketplace over 
here. So the marketplace essentially has  
01:56 - all these different high quality assets 
that I can use. And one thing I love about  
02:00 - the marketplace is that has something called 
the free for the month five, where it chooses  
02:07 - five paid assets from the asset store from the 
marketplace. And it provides the users of Unreal  
02:14 - Engine these assets for absolutely free. So that 
is an amazing feature. And that's why I love  
02:20 - the Unreal Engine marketplace. It has 
a lot of different high quality assets,  
02:24 - and even Epic Games, most of it, most of the 
content Epic Games provides is completely free  
02:29 - and you can use it in your game. So try check 
out the marketplace and use this in your game.  
02:35 - It's not cheating, it's actually an amazing thing 
that you do know how to use other people's assets  
02:40 - on your game, because that's how game development 
actually works. Let's try and see how to install  
02:45 - Unreal Engine five. Now, if I open up the games 
launcher and open this up five part over here,  
02:52 - it has my early it says Unreal Engine five early 
access. Now Unreal Engine five is not complete,  
02:58 - which is why it still says it's an early access. 
But I can download my early access from here. And  
03:07 - I can also get the sample project that that they 
showed in the Unreal Engine five showcase video,  
03:14 - which is amazing. But once you're once you're 
done installing Unreal Engine file, if you go to  
03:19 - your library, you will see your Unreal Engine 
five editor over here and I can open it up.  
03:26 - And over here. If you scroll all the way down, if 
you go to Wall, you have all of the assets that  
03:30 - you bought or claim I have all of these assets, 
all of these are free assets and they're amazing.  
03:36 - So try to check the assets out 
maybe you might like something and  
03:41 - make them outfit. Anyways, I can go here and 
hit launch. And if it takes a while Don't worry,  
03:48 - I have my Android version five installed on my 
HDD just because of how big it is. Usually I  
03:54 - have the engine on my HDD and then on my SSD is 
where I have all of my project saved. So you can  
04:03 - do that you can have the same approach or you can 
do something different it's completely up to you.  
04:07 - But that's usually what I do. It takes a it takes 
a long time to open up Unreal Engine for me,  
04:14 - essentially because of because I mean one 
I'm recording and two because of the fact  
04:19 - that for Unreal Engine you need pretty decent 
specs I have like average specs for example you  
04:26 - can see I have a six core CPU and memory when 
it comes to memory. If you're trying to make  
04:31 - a game using Unreal Engine make sure you have at 
least 16 GB RAM. Don't try to create a game with  
04:36 - eight GB it is not going to work out well for you 
especially if it's going to be a high scale game.  
04:41 - And make sure you have a good graphics card. I 
have two GB RAM so I can barely get through this.  
04:48 - But if you if you're trying to if you're 
purchasing a new laptop or a new computer just  
04:53 - for game development, make sure you have a good 
CPU which is six cores at least or more than six  
04:58 - cores. It uses a lot of CPU power. So if I go to 
processes over here you can see Unreal Engine is  
05:04 - hogging up my CPU like crazy. And if I go to my 
performance again, memory, make sure you have like  
05:10 - at least 16 GB RAM, especially on the engine five, 
you will not be able to get when I swear to God.  
05:15 - But anyways, let's go to games. And but we 
have a lot of these templates over here.  
05:21 - So if you want to create a really quick prototype, 
the best part about Unreal Engine is that you can  
05:25 - create prototypes really easily. So if I 
want to create a first person prototype,  
05:30 - I can, instead of creating the movement, the 
projectile movement, everything from scratch,  
05:35 - I can just I can just use the template over 
here, and it will create it automatically for me.  
05:42 - So I have my shooting part, my keyboard, my, my 
joystick all of them built in, so I don't have  
05:49 - to create it from scratch. Now this this is 
very, very useful when it comes to game jams,  
05:57 - necessarily you game jams or competitions, where 
you are given like a day or two days to create  
06:02 - a game. And for those, it's very, very useful. 
So you can see I have a lot of these different  
06:08 - projects, I'm going to be using third person, 
except we're going to create the animations,  
06:14 - the game, whether the movement logic, everything 
from scratch. So that's what I'm going to use the  
06:19 - third person and the reason why I'm using third 
person. Third Person project and not a blank  
06:24 - project is because I have a lot of Unreal Engine 
provides a lot of animations. And I need these  
06:30 - animations in my game, I don't want to make my 
animations from scratch, which is fine, I'm going  
06:34 - to use the third person project. Now under quality 
patient, I'm going to use change mine to scalable,  
06:41 - I'm going to enable static content static 
content essentially like a bunch of assets  
06:45 - Unreal Engine gives for free like textures, 
materials, particles, etc. Under project name,  
06:53 - make sure there's no blueprint, not C++, there 
is not a C++ close, there is not a C++ course,  
06:59 - the next the next course that I'll be releasing, 
that's going to be a C++ course of the same game.  
07:05 - Anyway, so I'm going to name this Batman 
and create project, this might take a while,  
07:11 - especially if it's your first time, this 
might take a while for me not much. But  
07:17 - when it's compiling shaders, that's when 
it takes a very long time. So if you have,  
07:21 - if you have a project that has a lot of different 
gameplay logic and assets built into it,  
07:26 - then it is going to take a very, very long time, 
especially because it has to compile the shaders.  
07:37 - Okay, now now that it's open up, you can see 
that we have this scene and all everyone opens  
07:45 - up the third person scene. This is the default 
scene over here, I have the the floors, there's  
07:52 - a lot of cubes, the character, blah, blah, blah. 
Let's start to go over all of these one by one.  
07:59 - Now I have to place actors tab where I 
have different confidence or actors that  
08:04 - I can add on to my scene, what is an actor, 
an actor is an object that can be placed  
08:10 - on the world. This is an empty act. And I 
can then add logic to this act over here.  
08:16 - Now how this works is that everything that can 
be placed onto the scene is an actor. So the  
08:21 - box trigger is essentially an actor. Look at it 
this way. A Tesla Model S for example, is a car.  
08:28 - It is an electric car, but still a car It derives 
from a car. That's how this works over here. The  
08:35 - Empty Actor is universal everything that can be 
placed over here as an actor. So this is an actor,  
08:40 - this is an actor, but we have different types 
of actors. So from an actor, something called  
08:45 - upon is created upon as an actor that can be 
processed, processed, meaning it can you can  
08:51 - add input actor to this to this point over here, 
for example, you can move the point like a vehicle  
08:55 - etc. Or character is basically attack upon that 
move around. So this is how the hierarchy works.  
09:03 - You have an active force, under this actor, we 
have a point so the point inherits from an actor,  
09:09 - and the character inherits from a point and 
basically has like mesh collision, etc. Let's  
09:14 - talk about collision Shelby, select this third 
person character and in the World Outliner, you  
09:19 - can see that this third person character has been 
selected. And under world settings, I have my game  
09:25 - mode override. We'll take a look at all of this 
later. But let's go to a Details panel. Underneath  
09:31 - this panel, I have my capsule component, which 
is basically collision. The way collision  
09:36 - works in games is that you have a capsule you 
don't have all these complex collisions, like  
09:42 - you know the exact shape of the character 
that is not going to happen. It's very,  
09:46 - very resource hungry. We use simple collisions 
in our games. And what permissions do is it  
09:51 - makes sure it doesn't walk through the stairs 
over here unless you want to create a ghost.  
09:57 - I can move up the stairs I can Jump um 
solid the collision basically says okay this  
10:03 - object is solid, but that does not make collision 
cannot be you know collision cannot be cannot  
10:11 - walk through the wall it definitely can you have 
different presets. For example, I can save my I  
10:16 - can set my collision in such a way that I can move 
through stairs, but I cannot move through a floor,  
10:22 - I can do that, I can definitely do that, all 
you have to do is select the capsule component.  
10:28 - And once you select the capsule component, 
and in this part over here we have different  
10:33 - other we have different attributes essentially 
like the transform the shape, the navigation,  
10:38 - all of that. Now, the transform is universal for 
every single game engine, we have the location,  
10:45 - the rotation and the scale. The red is for the x 
axis, y is for them in the green is for Y axis and  
10:54 - the blue for the Zed axis. You can also see these 
arrows over here. If I change this red arrow,  
11:00 - if I hold this red arrow and like my mouse, 
you can see that my x axis is getting changed  
11:05 - the same for my Y and my said, I can also move 
two axes at the same time. For example, my Zed  
11:12 - oops, okay, that's pretty good. I can move my 
Zed and my bi axes at the same time. Really,  
11:18 - okay, I know what I'm going to move my x and my 
y, just because it's simple, you can see that  
11:23 - my values, the corresponding values also change. 
So I'm that then when you're trying to place  
11:31 - objects, that is you'll sort of have to 
understand how to change all of these  
11:36 - values. Now I can also change the rotation, if I 
press E, I can change my rotation. So you can see  
11:42 - I can go up and down, I can change, for example. 
Okay, let's let's actually go back. If I, if I  
11:48 - change the green part over here, you can see them 
changing by rotation with respect to my y axis,  
11:55 - same goes to the blue and the red does 
not waste time. And the scale is obviously  
11:59 - the size of the character, I'm going to 
change this back to zero, I don't want  
12:03 - a humongous character. Okay, now mine is 
supposed to be one non zero, if it's zero,  
12:10 - it's going to be it's not going to have the x 
dimension at all, it's going to be a two that it's  
12:14 - going to be a two dimensional object, capsule 
component if I have something called mobility,  
12:20 - and this is present for every single object. 
So for example, if I select my network,  
12:26 - the Mac, the star, play Star, essentially, it 
defines where my player should start, this is  
12:30 - for the SS network player starts. So that's for 
multiplayer. So this capsule, probably under  
12:36 - capsule company, if I have if I have something on 
mobility, it I can basically say if my character  
12:41 - should be static, mobile or stationary. If I'm 
if my character person gets some input and has  
12:48 - to move in one of these accesses, or even rotate, 
I need to make sure that is movable. Over here,  
12:55 - I have my animations, we'll be going over all of 
this later on be recreating this from scratch,  
13:01 - I have my mesh, I can select if I want to simulate 
physics or not. And that gives realistic physics,  
13:07 - I can enable gravity or disable 
gravity. Actually, you know what,  
13:10 - try to change all these values and try to see 
what it does. That's the best way to learn to just  
13:14 - explore the explore and try to change all these 
values. Hopefully you don't break the engine.  
13:21 - I have my capsule competence. So I basically have 
different competence attached to my character. And  
13:26 - these confidence have different attributes like 
my for example, my hair has different attributes  
13:32 - by my legs have different attributes, but as 
a whole person. So that is basically how this  
13:38 - works. It as a whole is a third person character 
and has different components attached to it,  
13:44 - a hammer camera, etc. Now, you can see that 
it says it's inherited over here, it means  
13:50 - my if I hover over this, it says my parent classes 
character, What in hell would I mean by inheriting  
13:58 - means this actually a programming concept. And 
what this means is that the parent class has a  
14:04 - set of attributes that I inherit on my child, this 
is this third person character, this is not this,  
14:10 - this inherits from the character class. So you 
can see the pen class it says the character class  
14:17 - and the character class has the capsule component, 
the mesh, etc. So I don't have to if I create a  
14:23 - child of this third person, character, I mean the 
child of this character class and have all of the  
14:28 - all of this melted. Think of this as you think 
of your parents. If you're if your parents have,  
14:34 - let's say, brown eyes, the chances of you 
having blue eyes is pretty pretty low. So  
14:38 - you kind of inherit the genes from your parents, 
and it's getting passed on to the child. That's  
14:43 - how programming works too. And that's why it's so 
beautiful. Now when it comes to content browser,  
14:49 - I have my blueprints and with the content 
boxes used to navigate through your game files  
15:00 - And that's pretty much what it's used for. And I 
have different folders. This has been created by  
15:06 - Unreal Engine automatically because of what 
template I've chosen. So if I go to blueprints,  
15:11 - I have a third person character. Before that, 
let's first familiarize ourselves with the place  
15:17 - actors Part Two, if I go to, I have different 
tabs over here under place actors, I have my  
15:23 - directional light, my point light over here, sport 
light, all of that just like real life, I can,  
15:30 - I can drag drag this value into the scene, and it 
has automatically selected whatever object I've  
15:35 - added, I can change all of these values, for 
example, I can change the light color to like,  
15:41 - an a blue, red, etc, I can change my intensity, 
I can either make an absolutely bright or very,  
15:48 - very dark. So the C D stands for CAD, 
CAD, do whatever, okay, I don't know,  
15:54 - I started physics. But anyways, that's what 
intensity is for my attenuation radius, that's  
16:01 - all of these are physics light concepts. So if you 
really liked physics, you'd probably be able to  
16:11 - recognize all of these different variables 
over here. Unfortunately, if you want to get  
16:17 - really good game development, a little bit of 
physics, a little bit of math, it is important,  
16:22 - because, you know, programming is essentially just 
math, and physics, but in a very, very practical  
16:30 - bill. So did you don't need to know math, 
physics and all of that. But it does help a lot.  
16:38 - You can understand the concepts a lot better, 
especially when you have to debug something or  
16:42 - add a completely new feature. Anyways, let's 
not waste any more time. And that's create a  
16:48 - new level so that we can add our own characters, 
I mean, our own objects to the scene. The fact  
16:55 - if I click on my file, I can go to new level, 
I'm going to create a default level over here,  
17:00 - and it'll automatically ask me to save this model 
over here. Now, if I press Ctrl S, I can save this  
17:08 - on my folder, I'm going to create like click 
over here create a new folder called scenes.  
17:14 - And I'm going to call this level one. 
Actually, this should be called levels,  
17:21 - I used to do this in Unity a lot. It's supposed 
to be levels in Unity two, three policies.  
17:26 - There we go. Okay, I'm going to remove the 
floor and the Player Start that they actually  
17:32 - Yeah, put it over the place, we will add all 
of this. I have, obviously I have something  
17:37 - called atmospheric fog, which variable has a 
lot of influence on light. But I can also add  
17:43 - something called the exponential height fog 
with, which adds a lot of depth to the map.  
17:49 - Actually try to try to explore over here try to 
add different objects onto your scene, as I said,  
17:55 - but we'll be creating something called a landscape 
over here. So I have something called landscape  
18:00 - tab. If I click on this, you have something, okay. 
All of these clients that you see over here, this  
18:07 - is usually called gizmos in game development. This 
applies for all all game engines, these lines,  
18:14 - the basic call gizmos, and they're basically 
outlines of whatever object you have selected.  
18:19 - The reason why I'm painting the landscape and 
just not adding a cube over here and scaling it  
18:23 - is because it is very, very well optimized 
landscapes are optimized for huge, huge levels.  
18:29 - And I'll actually show you why. Over here, if 
I go to my landscape tab, I can change a lot  
18:34 - of different values. But all I'm going to worry 
about as my section size, I'm going to make the  
18:39 - seven to seven chords. So you can see it's seven 
over here and seven over here, I guess 1234 Yep,  
18:45 - there we go. And I am going to create this. Now 
the reason why I say this is very well optimized  
18:52 - is first off, I can change the depth of this 
landscape and you will see in just a second.  
19:00 - Oh, I forgot to add the material, but 
no probably we can add that later on.  
19:05 - It might take a while if 
especially if it's the first time  
19:08 - for to set everything up. But once you've 
had created this, this wait for a bit  
19:20 - okay, you can now see this huge white cursor over 
here. Let's change the brush size to something  
19:26 - small. You can see that I've selected it has 
automatically selected the sculpt part and I can  
19:32 - basically add some depth to this map. For example, 
I can create mountains over here and if I want to  
19:39 - flatten it, I can select the flattened part 
and then completely flat smoothen this out  
19:46 - and flatten this to do the reverse of Actually 
no. Now this automatically selects the sculpt  
19:55 - part here. I can basically create mountains 
etc. Smoother where it is pretty surface  
20:02 - mount is more than sit out. And you can see that 
the shadows start disappearing. And it's kind  
20:08 - of the opposite of sculpt mode. Flatten makes 
the land as flat as possible. So if I want to,  
20:17 - like, add a river over here, I don't know 
if you guys are aware, but Unreal Engine has  
20:22 - this amazing water system. So if I want to add a 
component, not a river, that doesn't make sense,  
20:27 - if I want to add a point over here, I can easily 
do that. But the reason why I'm using landscape  
20:33 - is because let me show you something. Let's 
actually go all the way. Let's cut this part  
20:39 - over here. And let me change the tool strength 
to like point four. So it's faster, you can  
20:46 - see that it does not render the graphics over 
here, because it does not have to like, I mean,  
20:52 - why would I want to render all of my graphics is 
the depth, the complete height of this graphics  
20:59 - over here, when the player is not going to see 
it? Right? It's all about optimization. Now,  
21:04 - this is also one of the reasons why you've seen 
in many games, if you have some collision issues,  
21:09 - for example, if I don't have collision over here, 
and the player just sort of falls through the map,  
21:13 - if you keep falling, you can actually notice that 
you won't be able to see the top of the level.  
21:17 - That is because of the optimization part of this 
landscape or whatever they using. It applies  
21:23 - to a lot different game engines. It was very, 
very common in Grand Theft Auto, San Andreas,  
21:29 - and also cyberpunk. But anyways, that's pretty 
much why I'm using landscape. So here and also  
21:35 - because I can use the the sculpt feature here, let 
me just, I'm going to add some depth, I'm going to  
21:43 - make this look like an actual ground so that it's 
not completely flat, I find that really boring  
21:47 - I hate I hate when objects are completely flat. 
So I'm just sort of going to do that. And let's,  
21:56 - so you can see that it's it's editing something 
called the height map, the height map essentially  
22:01 - adds depth tells the map where how high. The level 
is, for example, this coordinate my, I have like  
22:10 - mountain of some sort. And we here I don't. So 
that's pretty much what it's doing, we're here.  
22:18 - Now if I want to go back to my SELECT mode, I 
can just simply click on my select modal here.  
22:24 - And that is pretty much it. So if I select my 
landscape, I can change a lot of these values,  
22:32 - what I'm gonna do is I'm actually going to create 
this again, because I didn't show you how to add  
22:37 - a material. So when you go to your landscape 
mode, you can see this material part over here,  
22:42 - try to select the ground material. And let's 
create it again. And it's going to be 77.  
22:48 - So that's how you add material. And again, 
I'm going to add some depth over here, just  
22:53 - rub sound and make sure you have you click your 
mouse and just to wrap this around. Okay, that  
23:02 - is awesome. Now they've created the landscape. And 
also another good part about this landscape mode  
23:08 - is that it scales the texture automatically 
for you so that it's not just, you know,  
23:14 - one part of the texture, it sort of scales a lot. 
So I really, really love that about the landscape.  
23:23 - So try to add some lights onto your landscape, 
try to experiment on your own to change the light,  
23:30 - the color of the light or the intensity, whatever 
you want. And that less and less, I think around  
23:36 - the exponential height fog. If I go all 
the way to the top, I could change the  
23:41 - fog density to make this really foggy. I 
want to give this a sort of Martian like,  
23:47 - looks, I'm sort of gonna make that red in 
color. And yeah, that looks really good.  
23:55 - Okay, now, let's get into the coding part. But 
it's not exactly coding. It's called something  
24:03 - called blueprinting. And that's the visual 
scripting language of Unreal Engine and I  
24:09 - absolutely love it. If you go to the Blueprints 
folder, you can see the third person character  
24:14 - that says W tech. Now remember, this does not mean 
you can completely get away with just blueprints.  
24:21 - You will need C++ if you're making a full fledged 
game and releasing it. Why because blueprints are  
24:27 - mostly meant for prototyping and small features. 
If you if you have if you're trying to make a  
24:32 - multiplayer game, for example, you can't get 
away with blueprints because blueprints is not  
24:37 - exactly the fastest programming language. It is 
also a programming language, but it's not fast.  
24:42 - C++ is a lot faster, which is why we're going to 
create the exact same game game in C++ later on.  
24:49 - But that is a different course. This is only 
going to be blueprints as I explained before.  
24:55 - This might seem a little confusing for you, but 
actually these are two different windows And  
25:00 - if I go to my viewport over here, I can see 
my third person character in action. And I  
25:07 - can see my collide, I can see all of my confidence 
altogether, like the camera, the error component,  
25:12 - all of that, let's try to take a look at all of 
these one by one, they've always taken a look at  
25:17 - the capsule component, let's take a look at the 
arrow confident this basically points towards the  
25:22 - points to the front of me to the forward 
vector, or it points forward all the time. They  
25:29 - say look at the mesh, the mesh. Okay, so now we 
have two different types of mesh in Unreal Engine,  
25:34 - whereas the static mesh, and one is in skeletal 
mesh, the Static Mesh is used for stuff like,  
25:42 - let's say, a cube, for example, if I drag this 
cube over here, you can see I have a static mesh.  
25:47 - That's mostly because this cube is probably 
not going to move and it does not have any  
25:51 - extra animations. Like, I mean, what am I going to 
animate out of cute, maybe I can make this fall,  
25:56 - it's a champion, I don't need a skeleton, I don't 
need something called a skeleton for it. But I  
26:01 - have something called the Skeletal Mesh. And this 
is the complex counterpart for the Static Mesh. A  
26:08 - Skeletal Mesh is essentially a mesh with something 
called a skeleton, the how animations are created  
26:16 - is you have something called a skeleton and it's 
assigned to a particular mesh. And you have the  
26:22 - skeleton is of a bone and riddlin. It's almost 
just like the human, the human skeleton over here.  
26:29 - Now, what how animations are created is i You 
take specific bone, and you sort of change  
26:36 - the values. For example, if I rotate this bone 
over here, activate an animation, I mean this  
26:41 - for a second slapping someone, but that's pretty 
much how animations are created. I manipulate the  
26:46 - transform values of this of these points over 
here, like, okay, not the middle finger, maybe  
26:52 - the index finger. And yeah, there we go, I can 
do that. So that's pretty much what animations,  
26:59 - how animations are created. Now you can create 
animations in Unreal Engine, but I'd suggest you  
27:05 - to if you want to learn how to make animations, 
there are a lot of Blender courses online,  
27:09 - by Game Dev TV, or anyways, there are a lot of 
different there's a lot of Blender courses online,  
27:15 - please take a look at it. It's amazing. But this 
is the skeleton that unreal provides us with,  
27:23 - I have something for the camera, boom. Now, if I 
hover over it, this is the spring arm component.  
27:27 - And the spring arm component. Essentially, the 
reason why we're not adding the camera directly  
27:32 - is because if I have a wall behind, and if 
my if my character is moving behind him, if  
27:37 - characters moving back like that, okay hadn't 
moved the capsule, I've actually moved the mesh,  
27:44 - if I keep moving back and the camera moves with 
it, the camera might flip through the wall,  
27:50 - I don't want that I want my camera to sort of move 
up as the wall as I'm getting closer to the wall,  
27:58 - which is what Sprayground is used for it makes 
sure that you the camera doesn't move through  
28:03 - the void. Now the follow camera is that the camera 
itself and if you want to change the position add  
28:10 - rather change the values of the target offset over 
here. So five, Jesus like maybe 30, I mean 300,  
28:17 - you can see moves with respect to the y axis. So 
I do it that way, anytime. So I'm going to if I  
28:24 - want this hire, I can change the socket offset, 
and then press E change the rotation like that.  
28:31 - So that's the way to go when it comes to making 
a camera system. And they have the character  
28:36 - movement. This is a built in component created by 
and created by Epic Games. And this basically has  
28:44 - different menus that you can manipulate, for 
example, the movement values, let's actually  
28:48 - try to change these if I search for my walk speed 
over here, that's actually search for the maximum  
28:55 - walk speed. If I change this to like, let's say 
350 over here. And if you want your changes to  
29:02 - get saved, you have to make sure you hit on the 
compile button. And if I press Alt P, you can  
29:09 - see that I am walking slower than usual. So I can 
basically manipulate all of these values. And this  
29:16 - is again, you can see that is inherited. 
So this belongs to the character class.  
29:20 - And this character class has all of these 
inherited so I can read any of these. Let's,  
29:27 - let's respect the 600. But anyways, it doesn't 
matter because we're creating our own character.  
29:33 - The Event Graph is where you create your 
logic. So these are all called nodes. And  
29:39 - you can basically drag and drop these nodes 
over here to create your flow of the code.  
29:47 - Don't worry, this is very confusing. We'll be 
creating all of this from scratch. Okay, and yeah,  
29:55 - that's pretty much it for the Event Graph. And if 
I go to my Construction Script This occurs even  
30:01 - before the even before the game starts. So if I 
want to add some functionality to my game engine,  
30:07 - I can do that in the Construction Script. In 
my event graph, I have my variables button.  
30:13 - Let's take a look at the graphs, I can get 
different graphs. For example, I can create a new  
30:17 - graph just a moment, if I want to keep this very, 
very tidy. But we're not going to do that we have  
30:23 - a very simple script, so that's fine. And we have 
something called variables a variable is okay,  
30:29 - I'm going to make a variable that a variable is 
basically something that can contain a value.  
30:35 - Variables can be of different types, 
floats, integers, integer 64, by double,  
30:42 - let's take a look at all of these. A boolean holds 
a true or false value by the snake bit number,  
30:47 - integer is a number bigger than the byte integer 
6464. bit number float is a decimal number. So  
30:54 - that's like 3.14 10.6 6.9. And double is a 
big 64 bit floating floating point numbers  
31:01 - as far as like 6.999. And and then try and 
keep going on until six bits of memory.  
31:06 - A name is a piece of text, or string is basically 
any single value that's in quotes. For example,  
31:17 - it could be my name, or the the word, the 
word hello, or the sentence Hello world,  
31:23 - that could be a string. A text as well, this is 
a different type of string used for UI, etc. Name  
31:32 - is mostly used for scene names, level names, all 
of that vector, a vector in physics is basically  
31:40 - a value that has a magnitude and direction. So 
I can say, x is moving at 10 to 10 meters square  
31:50 - per second in my in the x direction. So that's a 
vector. And a vector consists of the X, Y and Zed  
31:59 - values to theta is for rotation, and 
it also has the X, Y and Zed values  
32:05 - that are transformed. We've already seen it, it's 
the rotation, the rotation location and the scale.  
32:12 - It is universal for every single game engine. So 
yeah, that is the basics for the blueprints. Now  
32:21 - let's go ahead and create our own character. 
So I'm going to create a new folder first. And  
32:26 - I'm going to call this custom blueprints, 
because I will differentiate between the  
32:30 - ones that Epic Games has created and the ones 
that I've created. And it's very important to  
32:35 - be organized. Now. Okay, trust me on this, every 
single game developer will ask you to be organized  
32:41 - and they themselves will not be organized. This 
happens all the time. But it is best practices,  
32:46 - you're just starting to learn. Try, keep your 
project as organized as possible. Now, over here,  
32:52 - I have my desktop icons, hidden but if I showed 
you your policy, how old next time, make sure  
32:59 - you don't make that mistake, try to organize 
your folders as much as possible. And custom  
33:05 - blueprints, I'm going to create a Blueprint Class, 
and this is going to inherit from my character. So  
33:12 - I'm going to have every single functionality 
that this character provides. For example, I can  
33:16 - walk around, I can add input the code, I have the 
ability to do that. But I need to make sure I tell  
33:23 - my character to move that's like you, you have the 
intelligence to make game. But you need to learn  
33:29 - how to make a game that's pretty much what we're 
doing over here. So have a character, I can select  
33:34 - that. And the naming convention is usually DT 
underscore the name someone call this battery man.  
33:42 - And if I open it up, I don't have the mesh 
anything. So if I go to my third person character  
33:46 - and try to compare it all of these inherited 
parts, I have them on my VPN disco Batchi. Man,  
33:53 - I don't have the mesh because the mesh isn't I 
mean, I don't have the camera and the spring on  
33:57 - component because that is not inherited. So let's 
actually copy this and add them to our character  
34:07 - over here. Oh, actually seems like yeah, we can 
probably them coffee and paste them over here.  
34:15 - So I already have my camera added or you can just 
say Add Camera and add spring on component etc.  
34:24 - Okay, I have my camera, Compile and Save and let's 
assign our mesh. So if I go to my mesh, I can go  
34:31 - to my skeletal mesh. I have only two of these. 
I have the female and the male. I'm going to use  
34:35 - the male mannequin. They're going to bring this 
all the way to the bottom by 80 units. Actually,  
34:42 - let's do 90 Actually, no, I think I think it 
would be fine over here and press E and let's  
34:53 - move that by 90 degrees. And again, that's the Zed 
axis companion save that style. To run the game,  
35:02 - you will notice that I still have my third person 
character. And if you're still confused as to  
35:07 - what character I'm using, you can inject 
from this character. What does that mean?  
35:13 - function, just press f8 in your keyboard. 
And then you can the game is still running,  
35:20 - but I can basically debug the scene over here. 
Now if you select your third person character,  
35:26 - you can see that I'm still using metal first 
character, my player since pawn. And that sparks  
35:32 - a question. How does the game engine know without 
adding any functionality? How does this know that  
35:39 - I am adding I want my third person character 
to spawn? That doesn't even make sense, right?  
35:45 - The reason is because I have something called 
game modes. If you go to Edit Project Settings,  
35:51 - let's take a look at the maps and modes part. 
Over here, I have something called Game Mode, the  
35:57 - game would basically set default values for every 
single scene. So I can say, no matter what scene I  
36:04 - create, I always want my third person character to 
spawn. And in that scene, I can say for example,  
36:09 - if it's the main menu, I can have an override 
game mode, which says, Okay, for the main menu,  
36:14 - don't spawn the character, because that's 
weird. So I'm going to just have my UI, etc,  
36:20 - I don't want my character to respond. So that's 
how Unreal engine works. So over here, on my  
36:26 - default game mode, I'm going to change this value 
to BP underscore Batman. And now if I press Alt P,  
36:32 - I can see over here, but obviously, I don't 
have any functionality. The reason is,  
36:38 - because I have the ability to take input, but 
I haven't done anything with that input yet.  
36:43 - So that's what we're going to add over here. If I 
go to my event graph, let's actually take a look  
36:48 - at all of these events over here, which we haven't 
seen before. I'm going to remove these. Okay, now,  
36:56 - the event claim, let's actually see what this 
does the event play event, it executes whatever  
37:02 - code that's attached to it in the beginning of 
the game, so only one is going to get executed  
37:08 - once and that's when you begin playing the game. 
Even take it gets executed every single second.  
37:14 - And let's actually take a look at an example. If 
I drag this over here is called the exec node.  
37:20 - And I can release it to play to place a new 
node. And I can just save print string over here.  
37:27 - The way this works is, when I call begin play when 
they implement is called automatically and that  
37:32 - time is going to print out the string over here. 
And I'm just going to say this is they can play  
37:40 - compile, and let's play the game, Alt P. And you 
can see that says this, this is being played. Now,  
37:50 - I'm going to add Player Start at the play style 
essentially defines where my player stood bed, my  
37:56 - ventilation stopped the game. So now I don't fall 
off the map. So notice this is big and played.  
38:03 - I'm going to now press Alt and 
click this button over here.  
38:08 - And then move on move this to the bottom, and 
then drag the event take note over here. Now this  
38:14 - can be anywhere. But I'm just I just asked you to 
get it bring it to the bottom because I want this  
38:20 - to be neat. So Compile and Save on dpi. And now 
you can see that printed every single frame. Now  
38:27 - remember, this might be different for every single 
computer. If my game runs at 60 frames per second,  
38:34 - this function will be called 60 frames per second. 
But in a different person's computer, let's say  
38:39 - you have an RTX 13 3080. And your game runs at 
like 160 frames per second 120 frames per second,  
38:48 - then this function will be called at 100 120 
frames per second. That is how the tick function  
38:55 - works. For unity users. This is like the start 
and the update functions. Very, very similar.  
39:03 - So we're not actually not going to use any of 
these because what we're going to do is we're  
39:08 - going to say if I press my W key or my s or my 
A or my D, do me move the character and if I  
39:15 - press let's say my mouse button, print something 
out, that's what we're going to say over here. So  
39:22 - if I minimize this window, go to 
Edit Project Settings. I have my  
39:28 - input part over here. I have two types of 
bindings over here. One is the action binding  
39:35 - action mapping and once the Axis Mapping action 
mappings are pretty self explanatory, I just have  
39:40 - my spacebar over here. I'm actually not going 
to bother adding bank our game does not have  
39:45 - any jumping mechanics over here so we're not going 
to add any jump but I'll actually show you how to  
39:52 - make your player jump. So this basically says if 
I if I'm basically if I go back to my blueprint,  
39:58 - right like and Jump event. You can see under input 
action events, I have this jump, and this button,  
40:06 - my press my button, press my jump button, do 
something, press. If I release my jumper do  
40:11 - something, I was the jump button. The jump button 
is my spacebar. And for my gamepad, it's my face,  
40:18 - pop, pop bottom. But anyways, I'm going to 
name all of these Unreal Engine, obviously,  
40:26 - it seems like it supports a lot of different 
consoles, which is awesome. And my access  
40:30 - mappings, this gets a little confusing, I'm going 
to remove everything I'm not going to use again,  
40:35 - because it gets very confusing for new developers. 
So I'm going to do more of these. Now, if I press  
40:43 - W, I want to return a value of one, which is 
basically going forward. If I press S, I want  
40:49 - to return a value of minus one. And if I press A, 
I want to return a value of minus one, if I press  
40:56 - do moderate on the value plus one, why? Because 
take a look at the axis. If you go forward,  
41:01 - it's usually positive. If I go backward, it's 
negative. So to my movement input, I'm basically  
41:08 - going to say add one, two, as long as I'm pressing 
my W button, add one to my movement input.  
41:16 - And if I press a it's going to add a value of 
let's say minus one at that particular direction.  
41:23 - So why is it Why is a minus one, well take a look 
at the x axis. If you look at the x axis, the left  
41:28 - part is minus one, the right part is supposed to 
one. So that's basically how the coordinate system  
41:34 - works over here. Turn rate, what we're going to 
do over here is I'm actually going to delete our  
41:39 - turn, rate and turn and our lookup rate over here. 
And what we're going to do is, instead of this,  
41:48 - we're going to call this look tight, and then 
we'll call this look up, look up is your mouse by  
41:56 - direction, it returns a value ranging 
from minus one and four look right,  
42:02 - if I move my mouse in my x direction, it returns 
a value ranging from bots to one, let's actually  
42:08 - see what that does. Now, in my input action, 
if I press this, I want to print I am jumping.  
42:18 - So I can just say control me Compile, Save that 
go back, I can remove this now, and all failed.  
42:25 - If I press space, it says I have 
sheltered and if I release this,  
42:32 - if I go to my release part over here, I it's 
only going to print this out when I release  
42:38 - my important. Okay, now, let's try to bind all 
of Les I ran in said add some functionality.  
42:47 - If I right click and then search for mouse X, 
make sure you get the event the the events and  
42:53 - not the mouse values. So I'm going to get mouse 
X and mouse vi the events. So let's actually  
43:01 - see what I mean by when I say it returns a value 
ranging from minus one. So what I'm what I can do  
43:06 - is from this node, I can print a string. And this 
is a float, the green part is for float, what this  
43:12 - is doing is it's giving an output of or returning 
a value of a float, which is the axis value. And  
43:19 - if I drag this end, it's going to convert a float 
to a string. If I compile and save, go back,  
43:28 - Alt P, if I move my mouse, left and 
right, actually, that was more sex,  
43:35 - yes, so that's going to be left and right, you can 
see my values are ranging from one to minus one.  
43:40 - I mean, that starts from one, if I go right, 
it's going to be positive, it's going to go if I  
43:46 - go left, it's going to be negative, it just keeps 
adding that value over here. And the same goes you  
43:52 - can try this out for more spy, I'm not gonna waste 
everybody's time trying to do the same thing for  
43:57 - most pilots will do the same thing. Okay, so let's 
actually try to add our mouse movement over here.  
44:04 - If I go to my spring arm, I have to make sure 
it always has used pawn control rotation. why?  
44:10 - It's because when I change when I what I'm going 
to do is I'm going to change the control rotation  
44:15 - of the phone. And that's how I'm going to change 
the rotation of the spring arm which changes the  
44:20 - rotation of the camera. Why? Because the camera 
is the child of a spring arm. What that means is  
44:26 - that if I move my spring on the camera is going 
to change with it just like how a kid follows  
44:34 - his or her mom all the time. That's basically how 
the spring in the painting part works over here.  
44:40 - Same way the arrow is a child of the capsule 
component the mesh is the child of capsule,  
44:45 - etc. which means as a moment capsule 
permanent the mesh moves with it. Okay, so  
44:51 - we're going to change something called the yaw 
and pitch, the pitch is the y axis the yaw is the  
44:57 - Zed axis. So with this axis value basically add 
that value to the Y or the Zed axis. Let's see  
45:04 - how to do that. That's dragonoid. And we're 
going to search for it. If it's the x axis,  
45:09 - we're going to add the your to it. Why? Because 
the x axis, if I'm going to rotate with respect to  
45:16 - my x axis over here, that means I'll be rotating 
it, you know, sideways, I don't want that, right.  
45:25 - So I'm basically rotated with respect 
to the set axes, which is basically  
45:32 - left and right. So I can plug in this value over 
here, copy, I mean, I'm not gonna copy that,  
45:39 - I'm just going to do the same thing, but for the 
pitch over here, so add controller pitch input.  
45:47 - Now, keep in mind, if I have this disabled, so 
all 10 like that, if I don't have an exit node  
45:54 - connected, it means this, this function will not 
get executed, what is the function of function  
46:00 - is a chunk of code, which may or may not take an 
input, and it provides an output based on that by  
46:06 - processing it. So you have an input, it processes 
that input, calculates that does something and  
46:11 - then provides an output the output here being the 
camera, getting the camera rotating on the scene.  
46:19 - So if I go back, Alt P, you can now see that 
I have proper camera movement over here.  
46:26 - Now, if your axis is inverted, like for example, 
if I go up, I want to go down. And if I move down,  
46:32 - I want to go up, if I want to do that, all I 
have to do is go to my project settings again,  
46:37 - go to my input part, and I can just change 
my mouse vide positive one. And if I alt v,  
46:46 - now, if I move, if I move up, I mean, 
it just does the opposite, essentially.  
46:53 - Okay. Let's open up the blueprints, again, where 
we we did this for our mouse, but we need to add  
47:01 - movement, obviously, to it. So let's do that. Now 
let's get on events. So our move forward event was  
47:09 - basically binded to the keys W and a I mean, 
W and S. So let's search for the access event  
47:17 - over here. And let's do the same for move right, 
the X event. So I have the x value over here,  
47:24 - for move forward, I'm going to add this axis 
value to something called the forward vector  
47:29 - of the character, the forward vector is basically 
a vector that defines the forward direction. And  
47:35 - here we're going to add this to the right vector. 
The right vector is essentially the the vector  
47:40 - that defines the right direction. So if I right 
click and add movement, or if I search for this,  
47:49 - I need the world direction over here. The 
whole direction is that basically we get actor.  
47:59 - Let's actually get the rotation over 
here. So if I drag this over here,  
48:05 - get rotation, okay, get location, get 
forward vector. So this is going to get  
48:12 - this direction is going to be the forward vector, 
because we're going to, we're either going to move  
48:16 - forward or back. And this takes an input 
asset rotation. Now, this is a variable,  
48:22 - the forward vector is a variable. And it's if 
I mean, there's a function, the forward vector  
48:29 - itself is available, this get forward vector is 
a function. And this does not have an exec mode,  
48:35 - which means it's a pure function, it returns a 
vector, and I can add that to the world direction,  
48:41 - the scalar value is going to be the intensity, 
which basically whether if I press W, it's going  
48:45 - to return a positive value, the press S, it's 
going to return a negative value. And N rot  
48:51 - is basically the rotation, I'm going to get actor 
rotation here. And so basically, what it's doing  
48:57 - is basically doing some complex math, and then 
saying, Okay, I know what the forward vector is.  
49:03 - So move, depending on that direction. Now, the 
same thing over here, and movement and foot,  
49:10 - but there's going to be for the right vector. So 
get right vector. And we're again going to use the  
49:19 - actor's rotation over here. So that's that for our 
movement. And that's pretty much it. We're done  
49:28 - with movement. So if at all fee now, I can move 
left, right, forward, back, etc. And it works  
49:35 - perfectly fine. But my character is still in this 
V pose, or this T pose. The reason this because  
49:42 - I don't have any animations assigned. Before 
that, let's actually see how to make this neat.  
49:49 - Now, okay, the length of this node or this length, 
the length of this line does not matter. It's not  
49:57 - it's not going to affect the speed at all. Just 
just adding that I was dumb enough to believe  
50:02 - the speed was affected. Because of it. Don't be 
like me, it's not. But always make sure it's neat.  
50:11 - Make sure you can see which line which axis, I 
mean, which way was getting connected to what etc.  
50:17 - That is very important. So Compile and Save. Now 
let's start, let's send a document our code over  
50:23 - here. If I select all of this, and press C, I can 
add something called a comment. This does nothing  
50:29 - but it's just for us for our understanding. So I'm 
just going to say add Movement Input over here,  
50:35 - and over here on the screen to see add mouse 
input here. Now, we're not going to have,  
50:42 - we're not going to make a character jump, but 
in case you want to add the functionality,  
50:46 - I'll show you how to do that. If I right click 
and search for the jump event. So remember,  
50:53 - we have an action action event called 
Jump. Very impressed this I want to start,  
50:59 - I want to just jump and jump is a built 
in function of this character class.  
51:05 - So the character automatically starts jumping. 
And over here, I can say Stop jumping, because  
51:11 - I don't want to keep going higher and higher and 
higher. So all three, I have my jumping over here  
51:18 - to person. But I'm not going to bother adding this 
because I don't want this in my game. But yes,  
51:26 - that is that for movement. Now that they've added 
movement, the next part is to add animations. A  
51:34 - lot of people don't like animations. I personally 
don't like adding animations. But unfortunately,  
51:40 - it is a part of game development. So let's 
dive in on how to do that. For animations,  
51:45 - I have a different blueprint that I can add. So 
I'm going to make content part and new folder.  
51:54 - I'm going to call this animations. And let's 
create something called an animation blueprint.  
51:59 - Now the reason why we using an anime Animation 
Blueprint, not the normal blueprint is because  
52:03 - the Animation Blueprint is optimized specially for 
for blueprints and before animations, and it has  
52:10 - a lot of different functions built in. Now, 
to create an animation blueprint, I have to  
52:14 - attach this or assign a skeleton to what we've 
already seen what a skeleton is. So different  
52:20 - animations are made for different skeletons. 
So make sure we select the YUI for manikin,  
52:26 - which is the built in skeleton, press OK, 
the naming convention is AVP. Oops, again,  
52:33 - right click Rename a BP underscore, I'm just going 
to name this battery man over here. Double click.  
52:43 - And now I have my output pose, I have two 
different graphs. So here I have something  
52:48 - called the Adam graph, which basically decides 
the output post and in the event graph, I can,  
52:54 - let's say get the speed of the character and then 
change the animations based on that. That's what  
53:00 - these two graphs to the Event Graph is for 
all the functionality like um, getting the  
53:04 - variables adding values to the variables, 
etc. The enum graph is to decide the output  
53:11 - pose. If I drag a node from here, and search for 
the run animation plate or person run and compile.  
53:20 - Now, this over here takes an input if your if your 
variable is on the left side, it means it's taking  
53:26 - an input. If it on the right side, it means the 
node is giving an output. So the third person  
53:32 - is going to get the animation, use the animation 
pose as an output. And that output is sent as an  
53:39 - input to this output. So here, component save, 
I had to go to Batman and assign my animation  
53:46 - blueprint. So I can either select my animation 
blueprint and then hit this arrow over here.  
53:53 - Or I can just search by a BP underscore 
batch command. Now Compile and Save.  
53:58 - If I run this now, you can see that my animation 
is getting played continuously. I don't want that  
54:04 - I want that idle animations, all of that. 
I want a different animation for strafing,  
54:09 - it just looks really weird. So we're going to 
create something called a blend space for that.  
54:14 - Let's take a look at what blend spaces. So good 
animation. And so it's for blend space. And again,  
54:21 - you have to assign the skeleton. So 
this will be BS underscore battery man.  
54:35 - Okay, now, let's open this up. And this might 
look a little confusing, but essentially,  
54:42 - the Blendspace has the x axis and the Y axis. 
And depending on the values of this, also a  
54:49 - certain animation will be played. For example, 
let's take a look at the vertical and the  
54:53 - horizontal the vertical. I think 
the vertical is this one over here.  
54:58 - Yeah, that's the speed. So that's vertical 
axis, we're going to name this the speed  
55:02 - and in the bottom on the horizontal axis the 
direction. So based on my direction and my speed,  
55:09 - I can play a particular animation. So my 
minimum speed over here is going to be zero,  
55:14 - my maximum axis value over here, my maximum three, 
the 600. As we set in our movement component,  
55:21 - a minimum axis value here is going to be 180. 
by Paul maximum is going to be first a 180. So  
55:28 - Y, first 180. And next 181 80 is usually forward, 
negative 180 is the complete opposite direction.  
55:36 - So that's what we're doing over here. 
Okay, so basically, what I'm saying is,  
55:42 - actually, let's do this with an example search 
under this Asset Browser source for your idle  
55:47 - animation, and drag and drop this at the bottom. 
What I'm saying here is, if my speed is zero,  
55:54 - regardless of my direction, make sure you 
play the idle animation, I'm pretty sure  
55:59 - you can now understand what this is doing. So 
if my speed is zero, then I'm going to play  
56:04 - my idle animation. Now you may understand where 
to put your run animation, it's going to be all  
56:10 - the way at the top. Now, if you hold Shift, and 
actually sort of move around, you can actually  
56:18 - you can preview the animation. So if my speed is 
set, if my direction is at zero, which is forward,  
56:25 - and my speed is at 600, then I'm going to 
play that animation. And it's slowly trances  
56:32 - rate slowly adds the value. So my animation 
slows down as I go down. And my preview value,  
56:38 - if my speed is at zero, regardless of my 
direction, I'm still going to stay idle.  
56:42 - So that's what it does. If my direction is at 
90, I want I want to make sure I move left. So  
56:54 - let's search for that search going on, experts 
take a look at all families over here. Okay, so  
57:07 - they would usually happens is we have different 
animations for when the character turns left, and  
57:12 - when the character on site. But the animation, the 
animations that come built in, we unfortunately  
57:18 - don't have those animations. So what we're going 
to do is we're just going to add run over here.  
57:23 - And remember, when my direction is at, usually, 
you'll have also a backward run animation.  
57:33 - So when the direction is at minus money at MIT, 
you usually want your the want to move backwards,  
57:39 - so you have different animation for that, 
and you will add that, respectively.  
57:45 - So that's just add this animation, 
I really don't want to do this. But  
57:50 - in our C++ course, I'll make sure we get 
animations for moving right moving left,  
57:56 - actually, let's try deleting the all the other 
values, let's just have one for moving forward.  
58:02 - If I save this, and all be okay, obviously, I need 
to assign this Blendspace in the animation token,  
58:10 - because we still haven't assigned it yet. So if 
I go to my animation blueprint, I can drag a node  
58:17 - and search for Blendspace. So now I can see my 
Blendspace vs underscore Batman. And this takes  
58:23 - in two inputs, one is going to be the direction 
one is going to be the speed and based on that it  
58:27 - will choose an animation, which is what we set. So 
from here, I'm going to drag and load and promote  
58:34 - this to a variable. So it automatically creates 
a variable called direction and it's a float. And  
58:39 - I'm going to promote this to a variable and it's 
going to be speed, compile, go to my event graph.  
58:45 - Now in my event graph, I can get the speed and the 
direction. So let's see how to do that. Now from  
58:52 - tie get pawn owner, what this does is it tries 
to get the owner of this animation blueprint.  
58:59 - So I can now cast this to my BP battery man, why 
am I doing this, but that's actually that's mainly  
59:09 - because I have my point upon is the class but 
I have to convert my class to my battery man.  
59:15 - The way this works is if I go to my BP underscore 
battery man and add a variable, I'm just going to  
59:20 - call this test variable. And I want to get hold 
of this variable. I can't get this from porn,  
59:26 - I can just say get test variable, it does 
not exist. But if I convert this to a Batman,  
59:34 - and then as Batman, if I try get test variable, 
now I can get hold of the very variable. So we're  
59:40 - trying to just localize our localized this pawn 
to my VPN scope actually, man. So from here, we're  
59:49 - going to actually first what we're gonna do is 
we're going to check to see if we got our foreign  
59:53 - owner or not, and that is done using the S valid 
node. So if I Get my point honor, if if I'm not  
60:02 - able to get my point or I can just say, I can just 
print a string saying I porn on are not valid.  
60:14 - Now the reason why we're doing this is because of 
attorney get a few variables from the point honor  
60:18 - the to make sure we have that pawn owner, if not 
your game is and up your game is going to crash  
60:23 - to this the safer way of doing it. If it is valid, 
what we're going to do is we're going to cast to  
60:29 - third cast to PP underscore Batman. And this has 
an exec node. So obviously this goes to as valid.  
60:39 - As Batman, what I'm going to do is we're going 
to get a variable called get velocity. So  
60:46 - the velocity is obviously the speed. But remember, 
velocity has direction, and magnitude. So from get  
60:54 - velocity, we're going to get, we're going to 
calculate that you're going to get the that  
61:03 - we're going to get the vector length,  
61:07 - the return value is going to be your speed. So we 
already we already promoted this to a variable.  
61:14 - So we're going to set this variable here. So drag 
this variable onto your event graph and press Alt,  
61:22 - and then you can just drag the return value 
on to speed which means now the value of the  
61:28 - speed is going to be the velocity, the vector 
of velocity from battery man, we'd obviously  
61:35 - set the direction to we're not done yet. So 
from here, we're going to get actor rotation.  
61:43 - And from the rotation, we are going to calculate 
direction. So obvious for the direction you need  
61:51 - to calculate what you need calculate the velocity. 
So from the velocity, you get something called the  
61:56 - direction to that's how vectors work. And again, 
I'm going to the same direction. And I can set  
62:04 - the value. After setting speed, I'm going to set 
the direction. So the control flow is basically  
62:11 - update animation. This is basically going 
to happen every single frame. From here,  
62:17 - it's going to go to S valid, it's going to check 
if the pawn owners valid, if it is cost to pvns,  
62:23 - go battery man. So convert porn to Batman, 
from here, get the velocity Get Actor rotation,  
62:30 - calculate the vector length, 
calculate the direction, set the speed  
62:34 - and then set the direction, we can 
actually then keep this over here.  
62:40 - Now we have the values for speed and direction, 
all you have to do is go to Anam graph,  
62:44 - and you can see that it has already set the 
direction and the speed. So now Compile and Save,  
62:50 - go back. And if you press ALT T, I now have my 
animations. Obviously, it does look a little  
62:57 - weird that if I go left and right, I don't have 
proper animations. But that's actually going to be  
63:05 - actually try to do this on your own search 
for your left and right animations. Go to your  
63:12 - go to this namespace. When your direction is at 
minus Canadian 180, you want to make sure the  
63:17 - character goes backwards. And for left and right 
animations here, you're going to place your right  
63:23 - animation here, you're going to press your left 
animation and check if it works. And if it does,  
63:28 - then you understood how blend spaces work. But 
we're gonna move on the game. As you've seen at  
63:35 - the beginning, the way the game works is you have 
a lot of different batteries all around the map.  
63:40 - And the health of the player keeps decreasing. 
And you have to make sure you collect all of  
63:46 - these batteries. And if you do, then you 
go to the next level or you win the game.  
63:51 - So let's see how to do that. This is where 
we'll be learning about UI, etc. So that's  
63:57 - going to be there's going to be the second part 
of the course. If I go to my blueprints, method  
64:01 - person actually not method freschetta. Obviously, 
it has to be my AVP underscore Batman, I mean, my  
64:08 - btn school Batman over here, we're going to create 
a new variable called Health. Let's remove this.  
64:18 - And let's create a health variable. Over 
here, I'm going to search for now I'm  
64:24 - going to make this a float and compile 
the default value as the default value.  
64:30 - And what's going on with me the default value 
is going to be 100. Compile and Save. Now,  
64:37 - what we're going to do is we're going to get 
our event tech and every five seconds we are  
64:43 - going to reduce the health. How do I do that 
dragon node and then add a delay over here.  
64:49 - What this does is it's basically going to wait for 
X amount, they're going to wait every five seconds  
64:57 - and get this value. So if you Jacqueline's 
funny on the screen and then hit Ctrl,  
65:03 - and then place it you will get, you'll be 
able to get whatever value your health is.  
65:09 - And we're going to subtract. So if I just be, as 
you can see, if I search for minus, I can subtract  
65:16 - a value, and I'm going to subtract a value of mine 
of five maybe. So once I've subtracted the value,  
65:25 - so let's say my health is 100. If I subtract it, 
the output is going to be 95. And I have set over  
65:32 - here, again, set whatever value I've returned. 
And then once I'm done, I can just do that.  
65:39 - Now, basically, every five seconds, I'm going 
to reduce my health, let's print my health out.  
65:47 - Actually, for simplicity, I mean, just make 
sure it's faster, I'm going to make it every  
65:51 - two seconds, and drag and drop health, again, 
converted into a string and plugged into my friend  
65:57 - strength file and save it. Now you can see it's 
100, after two seconds, 95. And then it's 9085,  
66:09 - etc. So it keeps going down. What I'm 
going to do is, I am going to add some UI,  
66:15 - I'm going to add a health bar so that this 
is connected to that, I'm going to reduce  
66:20 - my health every two seconds, but I'm going 
to reduce my health by 10, Compile and Save.  
66:28 - Now, I have to do something called binding, I'm 
going to bind this house to my UI. So let's take  
66:35 - a look at how to create UI. Under blueprints, I'm 
going to create a new folder and call this UI.  
66:49 - And under UI, you can go to FX, I actually 
not effects. This is not a user interface.  
66:57 - And I'm going to create a Widget Blueprint, 
the naming conventions W BP underscore whatever  
67:02 - name I'm going to call this player UI. So in 
this, we have something called the designer  
67:12 - and the designer, this what the UI is 
going to look like you can design me,  
67:16 - you can basically place all of these objects, and 
you can make it look like a proper UI, we're going  
67:22 - to add something called a progress bar over here. 
Let's actually scale this about let me make this  
67:31 - 500. And I'm going to do something called 
anchoring. What this means is as I resize my  
67:37 - screen, so for example, if I minimize my screen, 
I want my, I want this to still stay at the top  
67:42 - left corner. And if I make it fullscreen, it 
should move along with the screen. That's what  
67:48 - anchoring means. So I'm going to 
make sure that it's over there.  
67:52 - And if I scroll all the way down, under style, 
I have something called the Fill image. If I,  
68:02 - if I'm, if I drop this down, I have something 
called the 10th. The first image is going to be  
68:09 - the actual health over here. So I'm 
going to make sure my I mean my battery,  
68:13 - my battery is going to be green, that actually 
reminds me how to change this to battery not here.  
68:23 - Okay, and make sure you save that here and 
compile. And over here, our background image,  
68:30 - let's just make this actually let's make 
that black, that's fine. And we have to we  
68:38 - have something called the percent. Now the person 
ranges from zero to one, if it's one is going to  
68:43 - be completely filled. If it's zero, it's going to 
be empty. Let's make the default full. And we're  
68:51 - going to do something called binding it. So you 
see this bind button, and you can select Create  
68:57 - Binding. And what we're what we're going to do 
is we're going to get the health and we're going  
69:01 - to set that health to this percentage, we're 
going to convert the health into percentage,  
69:05 - and then we're going to set it over here. So 
the return value is going to be the percentage  
69:09 - that's displayed. So now we can say Get Player 
Character. And that's going to return whatever  
69:17 - character I've possessed the good RBC convert 
this to my Batman. So once we've done that,  
69:27 - as Batman, we can just get our health and get 
battery. And then we can set that over here.  
69:40 - But remember, we have to convert this into 
percentage because this person is going to be  
69:45 - between zero and one. So what we're gonna do is 
we're going to divide this by 100. Remember by  
69:51 - by definition percent means per cent cent is 100. 
So, we're going to divide this by 100. And then  
69:59 - Return it over here, Compile and Save. Now, we 
have to add this UI on to the screen. To do that,  
70:10 - let's go to bed, let's have our begin play, all 
the UI will be instantiated in being in play.  
70:17 - Over here, we're going to create a widget. So 
we're going to create an object of this player  
70:23 - UI. So I need to select which class, that's 
going to be my WP player UI. And return value,  
70:31 - I'm going to add this to Viewport. So 
it's basically to add this player UI on  
70:37 - the viewport and whatever function binding, it's 
going to make sure it executes all of that code.  
70:43 - So now if I play, you can see that my percent 
bar is slowly decreasing, which is amazing.  
70:51 - And it has some amazing decal, too. So it has 
some animated graphics. So that's very cool.  
70:57 - As well, um, Unreal Engine, it does everything 
for you. And we can now remove this frame string.  
71:04 - Now, again, we have to make sure it only reduces 
the value until it costs zero. And once it goes to  
71:11 - zero, I want to kill my player. So to do that, 
first off, we're going to decrease the value  
71:16 - only if my battery is more than zero. So if 
I drag control, we now can search for the  
71:25 - greater than symbol. And if it's greater than 
zero, only then execute this. But how do we do  
71:31 - that? How do we add conditions, we do that by 
something called a branch. So you can see that  
71:38 - red color over here. So if it's more than zero, 
it's going to return true. If it's less than zero,  
71:43 - it's going to return false. So from here, I can 
create something called a branch. And I can now  
71:50 - add this to this branch. Now, if my health is 
more than zero, then I'm going to execute this.  
71:59 - So I'm going to move that to the top. If my 
health is less than zero, then I'm going to say  
72:04 - my player is dead. So that time I'm going to add 
a retry screen etc. And I'm going to make sure I  
72:15 - do not possess this character anymore. But we will 
see that later on. But let's create a variable.  
72:22 - Now. Let's say B is player that's a naming 
convention for bool boolean values, you make sure  
72:29 - it's B is clear that or whatever. And we're going 
to make sure this Boolean compile, and the default  
72:38 - value is going to be false. And if I hold Alt and 
drag this onto the scene, we can set this to be  
72:46 - true over here. Awesome. Now, if player is dead, 
then obviously, I've lost so I'll use a pull out  
72:55 - menu screen menu. And I can either retry the game, 
or I can play the game again. So that is the basic  
73:04 - functionality that we're going to use over here. 
Once the player is said, what we're going to do is  
73:10 - we are going to we have this function called 
detach from controller pending destroy. What this  
73:16 - does is it makes sure your controls don't affect 
the player once you have detached from once you're  
73:24 - dead. So if I wait and wait for it's actually 
let's let's make that faster, have no patience,  
73:32 - I'm going to make that 20 so that as soon as I 
spawn in like four seconds, I end up dying. So  
73:40 - that's there. And now you can see that you can 
try controlling, but you will notice that your  
73:47 - controls don't work. And that's because we have 
detached from this controller. And we need the  
73:54 - animation to stop playing. So we can we can 
also have another so we can we can either  
74:01 - stop our animation like this, but this might not 
work. Let's try that out. Let me make that funny  
74:09 - because I don't want to wait four seconds, Compile 
and Save. All pay. Now the animations are still  
74:18 - playing. So we have to take care of this through 
the Adam montage. I mean the animation blueprint,  
74:25 - we have this variable here is player dead. 
So we're going to get this variable from our  
74:29 - BP battery man. And if it's true, they're going 
to stop animation. So let's see how to do that.  
74:35 - We'll be learning about a new thing called the 
blend by blue. Yeah, the Blendspace by blue.  
74:43 - Okay. Over here in this enum enum graph we've seen 
before that we have something called a branch. So  
74:49 - if the condition is true, do this condition is 
false to that. Instead, what we'll do is we'll  
74:54 - say, just search for both answers blends poses by 
bool. then post this by blue. Okay, anyways, if  
75:04 - so we can pass in a bool value over here. And 
if it's true, it will do this. If it's false,  
75:09 - we'll do something else. Now, if a player is not 
dead, we want this Blendspace. If the player is  
75:16 - there, then we can just, maybe I know, we can 
play the idle animation over here. And how do  
75:24 - we get this value? Same way, we have BP battery 
man, they can also say get the S is player that  
75:36 - and we can promote this to a variable. So promote 
the variable and bring this all the way to the top  
75:44 - and compile. Now I think 
you can understand the rest,  
75:48 - we can just drag and drop this over here. And 
now it's going to make sure if there's dead  
75:54 - then just want to play the idle animation and not 
do anything because we don't have fuel to run.  
76:00 - There we go. That works perfectly fine. And 
after this, we have to make sure we display  
76:05 - our player Lua screen. Now try to do this on 
your own, it might be a little difficult, but  
76:11 - just give it a shot. If you can't, no 
problems we're going to do anyways,  
76:16 - we're going to create a new user interface, we're 
actually going to create two of them. One is for  
76:19 - player when one is for player two is. So we WP 
underscore. Actually, we don't need a blueprint  
76:29 - of Widget Blueprint for when because we're 
automatically just going to go to the next level.  
76:35 - Or we're just going to have it is going to 
go to the next level. And here we can just  
76:39 - name this the BV WPP Lu screen and the designer 
part. I'm going to add an image first, let's scale  
76:48 - this completely, so it fits this handle. And make 
sure we have this properly aligned. Okay anyways,  
76:58 - even if it's oversized no problems, we're going 
to anchor this to be full screen. There we go.  
77:07 - So it's going to be it's going to make sure it's 
always full screen. And I'm going to change the  
77:13 - opacity to I'm gonna change the color to black 
and the F two like that. That looks fine. We're  
77:21 - going to have two buttons now. The first button 
is basically going to be one sec. Give me a second  
77:37 - Okay, the first button what it's going to 
do is when there's when the the retry part,  
77:45 - so retry game, and need to add some text 
to it. The same button, I can do the cater.  
77:54 - And they're going to add this over 
here. I know it's not exactly aligned,  
77:58 - but that's fine. This is going to be quit aim want 
to quit color and opacity seems just fine for me.  
78:08 - Yeah, that's that seems just fine. No problems. 
Okay, now let's see how to add text to this,  
78:15 - all you have to do is search for text and drag 
and drop it, it's going to automatically pair it  
78:20 - make this a child. And either the text block over 
here are going to save the try game. Or actually  
78:30 - usually just as we try. And on the phone, 
I'm going to change the size to maybe 34.  
78:41 - That seems fine. And for quick game again, 
another text block, they're going to make it 3042.  
78:49 - And we can just say quit. Game nation, I'm 
gonna name this text block to quit text.  
78:58 - And this one is going to be retry. And we're 
going to have a huge block of text over here.  
79:07 - And this one, we're going to name it. We're 
just going to say you do is that's that's pretty  
79:12 - much it. Let me make that 80 actually living and 
textbook I'm just saying I'm just going to say you  
79:20 - Louis. Okay, awesome. In my graph, I have to make 
sure I add functionality to this to these buttons.  
79:29 - So if you scroll all the way to the bottom after 
you've selected the button we have on click and on  
79:34 - press, we're going to use the on pressed because 
it works better for example, if you press enter  
79:40 - by mistake it might just end up retrying again, 
we don't want that we have to make sure we click  
79:45 - on the button. So that's why we use on pressed do 
the same for retry game to I mean for quit game.  
79:54 - Not on flick on pressed over here. And for retry, 
they're going to open We're going to load the  
80:00 - level, we're going to load the exact same level. 
So that level is going to be get level get current  
80:08 - level name. Because if it's a different level, if 
it's level two, then it has to make sure it has,  
80:13 - it opens up that level. So get current name 
ensures it gets the proper level, the level  
80:19 - that you're running right now. And we're going 
to open that level. So it's basically to open  
80:24 - the same level, again, all the default settings 
for quit game, it's literally just one node,  
80:31 - quit game. That is it, Compile and Save. 
Now if I minimize my screen called P, again,  
80:38 - we have to make sure we add it to Viewport. 
So if I go to my blueprints, if my player is  
80:44 - that detached from controller pending, destroyed, 
that's fine. And whatever we did here, we're doing  
80:50 - the exact same thing over here. But the problem 
is, remember, this is on tick. And when we create,  
80:59 - when we put this on tick, it means it's going 
to create the player widget every single frame  
81:04 - and add it to Viewport every single frame, which 
means your game might end up crashing. So we're  
81:09 - going to add a note that says do once. This means 
that it's going to whatever that comes after it's  
81:15 - going to do this only once. They're going to burn 
to make sure we recreate the loo screen widget,  
81:24 - and then we're going to Add to Viewport. Now 
if we compile and save it, let's run the game.  
81:31 - And now it says he lose. But the 
problem is we cannot use our mouse,  
81:36 - we can only you know we have to press windows 
etc. So if you want to show the mouse cursor,  
81:42 - get your Player Controller anything related to 
controls that's present in the Player Controller,  
81:47 - and over here, search for cursor. 
Let's see what we have over here.  
81:55 - We have get Show Mouse Cursor Set Show Mouse 
Cursor. So we can set this by this value is  
82:02 - present in the Player Controller, we can set this 
to true after Compile and Save this and minimize.  
82:10 - And we're running around. And now I can see my 
cursor. If I press retry. It loads the same level  
82:18 - again, and I'm losing and blah, blah, 
blah. So it basically restarts the level.  
82:24 - Okay, awesome. We've done all of that. Now 
let's see how to convert these into functions.  
82:31 - Functions are basically blocks of 
code made into one chunk of an object,  
82:38 - which you can call later on. For example, if I 
right click on all of this collapse to function,  
82:44 - collapsing the function fail, let's see why 
is that okay? Delay cannot be okay, some.  
82:50 - Okay, let's just create a test function over 
here, test function. So this function can have  
82:56 - a lot of different functionality. For example, 
imagine I have 1000 nodes in this graph over here,  
83:01 - forgot to even graph if I'm, if I 
want to call this function again,  
83:05 - like in 10 different positions. What if it makes 
better sense for me to call this function rather  
83:12 - than creating those 1000 nodes again, and again, 
and again, that's going to look very, very dirty,  
83:17 - which is why I'd rather put those 1000 function 
those 1000 nodes in one function, and then I can  
83:25 - call this function, and delays cannot be added 
in a function. So if I right click over here,  
83:30 - I can just collapse this to a function. And I 
can say that use health. And this function we  
83:37 - know that reduces health. If I double click on 
this, it does the exact same thing over here.  
83:45 - Now, if you want you can convert this 
to a function to I'm going to leave it  
83:49 - they've done that for now they've made functions 
for me, we've made a function for it yourself,  
83:54 - but I'm going to leave the player death part as it 
is. But I can maybe add this part to a function.  
84:03 - But that depends on you. Or I can just collapse 
this to a node to collapse to node player deck.  
84:12 - So this basically just instill in an 11th 
graph. It's not it's not a function or anything,  
84:17 - but we're just making this part of the 
code faster. I mean, shorter so that we can  
84:23 - find out what's going on. Okay, so now let's 
create a variable called battery's collected,  
84:31 - there should be an integer by, what we're going 
to do is we're going to have a maximum number of  
84:36 - batteries per level. For example, this level will 
probably have eight different band aid batteries.  
84:41 - And once we've collected all batteries, we're 
going to check if the number of batteries  
84:45 - we've collected is equal to the number of 
patties that are supposed to be collected.  
84:51 - And if it is equal, then we can say the player 
has won the game and move to the next level.  
84:57 - Or they can just display when screen but in this 
case We're going to just move to a new level,  
85:01 - and you can add all the other functionalities. 
So once we've reduced health, this part means the  
85:06 - player has not died yet, as you can see over here. 
So what we'll do is, after releasing the head,  
85:14 - we're gonna check to see if the number of 
batteries we've collected is equal. But actually,  
85:20 - we're not going to do this in the player, we're 
going to do this in something called the Level  
85:23 - Blueprint. So if I go to my level effects here on 
blueprint, and if I hit on Open Level Blueprint,  
85:33 - this is a different type of blueprint, it is for 
the level itself, and it can get access to every  
85:40 - single object that's present in the level. And I 
can add functionality based on that, for example I  
85:45 - can get, I can get the character that's present 
in this level, and then check to see how many  
85:50 - back he has collected. And and check to see if the 
number of batteries I've collected is, you know,  
85:56 - equal to the number of get batteries 
they're supposed to be collected,  
86:00 - and then change to the next level. So that started 
with that. First off, in begin play, we're going  
86:06 - to get hold of our BP underscore Batman. So 
Get Player Character, we're gonna cost it  
86:15 - to be fi underscore Batman. So we're gonna, we're 
going to convert our character to the Batman.  
86:20 - And then as Batman, we're going to promote this 
to a variable, so that we have a reference to our  
86:28 - player at all times. And in tech. So now we'll 
be introducing something else. But before we  
86:37 - we start making our Venn conditions, let's 
actually implement our batteries themselves.  
86:43 - So right click, create a new blueprint. And this 
is going to be an actor, TV underscore battery.  
86:51 - If I open this up, I'm going to add something 
called box. And I'm just going to add, actually,  
87:01 - let me just add a cube over here. If I scroll all 
the way to the bottom, okay, I'm adding a cube,  
87:07 - this is going to be my battery, your title, try to 
try to change the Static Mesh to something else,  
87:15 - maybe try to find a battery acid 
and change the mesh to a battery.  
87:19 - But I'm going to leave this as it is, we're going 
to scale it. So if you want to scale and press our  
87:26 - I'm going to make this flat. Something like that. 
Okay, awesome. Now, what we'll have to do is,  
87:34 - let me change the material to maybe I've seen this 
really cool material that Unreal Engine has, it  
87:42 - has this very cyberpunk like texture, there we go. 
I love this texture. I'm going to make it this.  
87:50 - Okay. Now, if we scroll all the way to the bottom, 
we have a lot of different events. What these  
87:55 - events are, is that when the component is hit, 
do something, when that when someone overlaps  
88:02 - the component, do something when an object has 
ended overlapping, do something. That's basically  
88:07 - all these events are. That's what these events 
do, let's try to take a look at the on component  
88:13 - head event called when a component hits something 
solid. So if this component hits, maybe something  
88:20 - solid, like another cube or a player, what is it 
supposed to do, that's how projectile bullets work  
88:25 - in game development to let's try to take a look 
at on competent head, press on if I click on the  
88:31 - plus symbol, I have something called the head 
component. And the other actor, the other actor  
88:38 - is going to be whatever actor that has collided or 
hit this cube over here. And we're going to cost  
88:45 - this to our battery man. No, not the battery, 
the battery man. So search for battery man.  
88:53 - Now if this is true, so if I have 
cost, if I have hit the battery man,  
88:58 - then we're going to get the health. Get 
the battery. And then we're going to add,  
89:07 - maybe let's see, we're going to add an amount 
that actually let's make this a random value,  
89:14 - subtract a node from this and then there 
should be there should be a node that says  
89:20 - random float in range, we're going to we're 
going to add a value between five and 10. So  
89:26 - there's going to return a value of five and have 
a number, a random number between five and 10.  
89:33 - And from battery we're going to set 
battery again. And then we can drag this in  
89:41 - for Compile and Save. Let's see if this works. And 
I have to obviously destroy this object because  
89:47 - I don't want to cheat so I can destroy the actor 
which means it's going to get deleted from the  
89:53 - scene. If I placed this object over here, and 
move this to the top, maybe we can add some lines  
90:00 - This what? Oops, okay, I have to make sure 
I, the game isn't that difficult for me.  
90:07 - So I'm going to change my battery value 
back to 100, Compile and Save old faith,  
90:15 - fam move towards this battery, you can 
see that my head has increased over here,  
90:20 - let me show you again my battery. So you can see 
it's slowly increased, which is what we're going  
90:25 - to do over here. Now, we're going to make sure we 
keep increasing our battery for our player over  
90:31 - here. Let me go back to my BP underscore battery, 
let me add a light over here, point light. And  
90:39 - make sure you raise it to the top because if it's 
inside the object, you won't be able to see it.  
90:44 - And we can make it red in color. Okay, Compile 
and Save. Now, here comes the interesting part.  
90:55 - This is where we make our wind conditions. So 
over here, once we've added health added, okay,  
91:03 - my opponent has been added battery to our battery 
man, we can add a variable to the batteries  
91:10 - the player has collected. So again, 
get the batteries collected over here.  
91:18 - And we obviously have the set of doses set that is 
collected, I hope this doesn't get too confusing.  
91:25 - If you do, then try to make try to do a little bit 
of math in a in a different project on your own by  
91:31 - getting values from a player and casting them. And 
you will be able to understand them in no time,  
91:37 - I'm going to add one to the number of 
batteries collected. So if I let's say I  
91:42 - have three batteries already collected, I'm going 
to add one to it. So that's going to become four,  
91:47 - I'm going to set the batteries collected. 
And then I'm going to destroy the cube,  
91:54 - Compile and Save. Now in my Level Blueprint, I 
have to make sure I define what is the maximum  
92:01 - number of batteries, right. So let's try to do 
that. Now, right like, we're going to take a  
92:07 - look at something called the Game Instance. So 
let's take a look at Game Instance over here.  
92:15 - Now gi underscore battery, man 
instance citizen all of that.  
92:22 - So in this instance, what a Game Instance is that 
it is an object that persists persists through  
92:28 - every single level. So this object will be there 
in the main level. And then level one, level two,  
92:34 - level three, this this is going to persist in 
every single level. So we can add a few variables  
92:39 - that says okay, if it is level one, then make sure 
the number of batteries is let's say eight. And  
92:46 - that will do it has to be 10 etc. Now, this is 
not the best way to do it. But since this is a  
92:52 - very beginner level tutorial, we're not going to 
go over gameplay, like proper gameplay mechanics.  
92:58 - So I'm just going to add a variable here. So level 
one, then batteries, actually no Max batteries.  
93:08 - One. So this indicates for level one, this is 
the maximum number of batteries are going to  
93:13 - make it a float. And let's this let's set this 
value to eight. Now, if you want another level,  
93:18 - let's say level two, you can say Max batteries, 
two, etc. Now go to the Level Blueprint. And you  
93:25 - will have to do this for every single level. But 
in tech, what we can do is we can right click  
93:32 - Get Game Instance, we have to cast this to our 
battery man instance cost vi battery man instance.  
93:42 - And again, we can do this in big and 
play because we don't want to talk we  
93:47 - don't want to cost this every single frame. 
And then we can promote this to a variable  
93:55 - gi battery math. Okay, now from the battery 
man instance, what we can do is we can get  
94:06 - max batteries for one. And then from our battery 
man, the player itself, we can get get batteries  
94:15 - connected. We're going to check if these are 
equal. Now I forgot to make this an integer.  
94:21 - So let's make sure this is an integer to Compile 
and Save level one that's checked to see if these  
94:31 - are equal. So I can if these are equal, then I can 
basically say so again, we have to create a branch  
94:39 - so we're creating a condition over here. So if 
we create a branch Event Tick, if these two are  
94:48 - equal, then I've won the game. So I can just 
end up opening the next level or again I can  
94:56 - I can have a windscreen or whatever match has been 
opened another scene for this one. And let's call  
95:04 - this level, the next level, whatever. For example, 
this one's going to be level two, you will have to  
95:10 - do this for every single game level. But remember 
in the C++ course, since that's going to be a more  
95:17 - advanced course, we will take a look at how to 
make this a lot more scalable in the sense how  
95:22 - to make sure we just add the logic once and 
we don't have to keep copy pasting our code  
95:26 - on and on and on. Now that they've created the 
Game Instance, we have to make sure we set it in  
95:32 - our project settings. So go to maps and modes. And 
if you scroll all the way down, our default Game  
95:38 - Instance has to be gi underscore battery instance, 
let us create another level over here. So again,  
95:48 - new level, there's going to be a default level 
and save it. We're going to call this level two.  
96:00 - And that's pretty much it. I bet we're done 
with all of our code mechanics. Now, if I play  
96:06 - the game, and let's say our maximum is going to be 
one. So if I open up my Game Instance, over here,  
96:15 - my maximum number of entries is going to be one, 
for example, save the game. And if I play now,  
96:24 - we now move to the next level. So that's how we 
make our vent conditions. Now all you have to do  
96:30 - is decorate your level, maybe add a few obstacles, 
and maybe like a few cubes that distracts the  
96:36 - player, maybe trying to make this into a maze, 
get a few assets from the marketplace and try  
96:41 - to make it in such a way that maybe it's like in 
a spaceship, and the player has to find all the  
96:48 - batteries from the spaceship, which would probably 
look really cool. But now I have five different  
96:56 - batteries here. So I'm going to go to my Game 
Instance, maximum batteries is going to be five  
97:02 - over here. Compile and Save, and save it. Okay. 
Now let's see if this still works. So all fie  
97:12 - I'm going to collect, oops, it seems like I have 
to make sure this is all the way to the bottom.  
97:21 - So all the way to the bottom, all the way 
to the bottom. Okay, all fee. Now let's see.  
97:28 - So first, my battery does keep 
increasing. So that's pretty cool. But  
97:33 - okay, I might, I might actually lose this. I'm not 
really good at games. Okay. Okay, we seem to be we  
97:40 - seem to win the game. That's awesome. And yeah, 
that's pretty much it for our vendor events. Now,  
97:47 - let's say your level two is your last event, 
what you do is in your level two Level Blueprint.  
97:53 - So if you open up the blueprint, just have the 
same condition that as you had in level one,  
97:59 - except if it's equal, you create a new 
widget, your your windscreen, for example.  
98:04 - And then you display that windscreen on to the 
scene. For example, if I go to level two, now,  
98:09 - let me actually show you how to do it real quick. 
So if I go to level two, open my Level Blueprint,  
98:14 - now I can try to do this on your own, please 
don't try to copy what I'm doing. That's fine,  
98:19 - I want to show everything because I want to 
sort of make sure you guys get it on your own.  
98:25 - What you do is you will get your Game Instance 
again, you will cost this two battery instance.  
98:32 - And we're pretty much doing the same thing we 
did before. And remember, if you have level two,  
98:38 - your level two Level Blueprint open, you 
can open your level one level blueprint,  
98:44 - it's going to get closed automatically. So 
we're going to promote this to a variable.  
98:49 - And same thing. The same thing happens except 
it's going to be for our Player Character. So Get  
99:00 - Player Character cost to battery man. So 
basically converting it to battery man  
99:08 - and then promote the variable. And then we 
can get max, I mean get batteries collected.  
99:21 - And we can use this to compare. So in our Event 
deck, what we'll do is we can get these to  
99:29 - get batteries man so there's going to be so we 
have to create a new condition for level two.  
99:35 - So all you have to do is Ctrl C Ctrl V, rename 
this to max batteries to I'm just going to make  
99:42 - sure the max battery is just 
something like one for my level two.  
99:47 - So this is equal to the number of batteries are 
collected, not battery number of patties collected  
99:57 - batteries collected If this is true, what's 
going to happen is I can just print out,  
100:13 - I can create a new widget, there's going 
to be my winning windscreen over here,  
100:18 - which is going to basically have a text 
that says you win the game, and then  
100:23 - it can have a quick game. And then over here, 
we can say cost to, I mean, and to Viewport  
100:32 - for time to compile, that it has an arrow 
here, because the Create Widget class has  
100:38 - to be specified. So let's create 
a new UI element over here. So UI.  
100:47 - Actually, let me just let me let me do 
skaters W, BP underscore wind screen.  
100:55 - Now in stuff lose, they can just say, you when.  
101:03 - And we're going to load out for 
retry, we'll load the first level.  
101:07 - And actually, let's have the return to 
main menu part in this vein main menu,  
101:15 - and quit game. Yeah, fifth game is going to be 
the same. Now in the graph, open level four,  
101:22 - because we have to make sure we rename everything 
because we just duplicated it. So for retry Game  
101:29 - Over here, we have to make sure this says main 
menu now. It's just for simplicity's sake. Now  
101:36 - when you press the main menu, we want to open 
up the main menu. So we're going to create a  
101:41 - new level called Main Menu, obviously, Compile 
and Save. Because if I go to level two, I can  
101:47 - just create the main screen and make sure you get 
the Player Controller. So Get Player Controller.  
101:59 - Show Mouse Cursor, we're going to set it 
not get it. So Show Mouse Cursor set it  
102:08 - we are going to set this to true, Compile 
and Save. Now we have the main menu  
102:18 - we have the main menu part. And that's 
pretty much it. So my condition for  
102:25 - my second level is going to be two sets need 
to collect two batteries and I've in the game.  
102:32 - So over here, we're going to end up adding 
batteries again, we'll add two batteries.  
102:41 - If I played the game now collected one 
collected two, and doesn't seem to be working,  
102:49 - let's take a look at what's going on. Okay, 
the reason why I wasn't working was because  
102:56 - I got the variable for the first 
level. So we're going to get batteries  
103:02 - over here and make sure we set that now it's 
going to work. So if I Compile and Save,  
103:08 - and again, remember we have to make sure we detach 
from so okay, if I go back to my battery man,  
103:15 - you see we have detached from pending destroy over 
here, we're going to do the same thing over here.  
103:20 - That's because as I move my mouse, I don't want my 
camera to move to in my windscreen. So let's see,  
103:27 - let's actually see if we can get this on our own. 
So detach from nope, I'm not able to get that  
103:35 - get that particular node. So let's see if that's 
present in our Player Controller. No, it's not  
103:39 - present in our Player Controller, which means 
it should be present in our character itself.  
103:46 - detach from controller pending destroyed, 
there we go. We can do that Compile and Save.  
103:52 - So this means we cannot control our player 
anymore. So once I collect these two batteries,  
104:00 - it says you went and again one more problem. 
This is going on in tech. So we have to make  
104:07 - sure we do this only once. We don't want this 
every frame it's going to crash your game which  
104:13 - was about to crash my game. So we have to 
make sure that only that's done only once.  
104:19 - If you want you can make put all of this in a 
function. And yet we're gonna save this go back  
104:27 - OLOFI collect the first one second one, we went 
quit game and we're done with the game. Awesome.  
104:37 - Now, obviously this is not the best way to make 
a winning condition but if you want to do it,  
104:44 - don't worry about making it the best way possible 
the first time you're trying it. The main the  
104:51 - main point is to understand how blueprints work 
first, and then in the next course that is fine.  
104:56 - The next course is going to be a more advanced 
course where we learn Proper winning conditions,  
105:01 - all gameplay principles, etc. Now, we have one 
more thing remaining. And then we're finally  
105:08 - done with this course, which is going to be our 
main menu. So, in fact, I had to create another  
105:14 - Widget Blueprint, W BP underscore main menu 
over here. And I'm going to add an image again.  
105:25 - Let's make this fullscreen and anchored, 
make sure that's fullscreen. And now,  
105:32 - what we're going to do is, well, let me change 
this to black first, this is going to have two  
105:37 - buttons, one is going to be play game one is 
going to be quit game. That's pretty much it.  
105:44 - And I'm pretty sure this is self explanatory. 
I'm pretty sure most of you guys will be able  
105:48 - to do this on your own by now. But if 
not, no problems, don't feel demotivated,  
105:53 - it's completely fine. It's normal. So 
we're gonna save play game over here.  
106:00 - Duplicate this control, actually, yeah, 
Ctrl W, that's duplicate. And they go,  
106:09 - they're going to make this, I'm going to call this 
quit game. And obviously, you can have another,  
106:14 - you can have another button that shows the 
controls, etc. Over here, that's add some text,  
106:24 - text to both play game and do it again, I 
added it to the image by mistake. So I'm  
106:30 - going to remove that there's going to be called 
play game. This is going to be called load game.  
106:41 - And obviously, we want to change 
the size to like maybe 34.  
106:49 - That's not gonna be faking. I'm just gonna quickly 
over here. And over here, again, go back to the  
106:54 - font, make this 34 Compile and Save. How do we 
tell the editor that whenever we open up a project  
107:04 - or the game, we need to make sure it opens this 
main menu level. To do that go to maps and modes.  
107:14 - And you can see your editor startup map and 
your game default map, what I'm going to do  
107:18 - is I'm going to create a new level and 
make sure it opens up the main menu over  
107:22 - there. Now open up a new level. Actually, 
we don't need to make it a default level,  
107:28 - we can just create an empty level over here. And 
Ctrl S, you can see that it's completely dark  
107:34 - because there's nothing in this level, we're 
going to call this the Main Menu. Over here,  
107:42 - what we're going to do is open up your Level 
Blueprint. Before that we had to add a game  
107:49 - mode override because as I said, it doesn't have 
to add. So if I run this game now, it's going to  
107:56 - Okay, all up. If you see it spawns up, it spawns 
the BP underscore Batchi. Man, we don't want that,  
108:03 - obviously. So what we're going to do is we're 
going to add a game mode override over here,  
108:09 - which means for this level alone, it's going 
to create a different game mode and it's going  
108:14 - to use that so under Custom custom blueprints, 
I'm going to create GM underscore main menu.  
108:24 - And over here, under default 
point, it's going to be none  
108:29 - under hard, I'm just going to have all 
of this normal. Now. Under blueprints  
108:34 - Open Level Blueprint, again, we're going to do 
the same except this might be in vegan play.  
108:39 - So Create Widget. And what we're going to 
create is the main menu and Add to Viewport  
108:51 - Compile and Save. Now if I go back to my project 
settings, scroll over scroll down here I have my  
109:00 - editor start up map. I'm going to keep my level 
selected over here so content levels main menu,  
109:10 - I am going to hit this arrow and it's going to 
automatically assign my main menu now let's play  
109:16 - the game. So press Play Game nothing happens 
that is because we haven't added functionality  
109:24 - yet. So if I go to main menu, select 
this button again scroll all the way to  
109:29 - the bottom on pressed you know what to do 
open level this is going to be level one.  
109:38 - And if if I go to quit game on pressed again, 
you can just quit the game. Now make sure  
109:48 - in level two level blue in our windscreen Level 
Blueprint. It the level is named properly. So  
109:55 - that's main menu without a space, Compile and 
Save. And this is to have a sense playthrough now.  
110:01 - So if I alt V three game, I have my HUD, and you 
may have VLC because of that, okay, there we go.  
110:09 - We're going to try to 
collect all of these on time.  
110:15 - And that's level two. And level two, we're going 
to, we're going to get these two. And now we win  
110:20 - the game. And we can quit the game. That is pretty 
much it. Now we have a tiny little part over here,  
110:29 - the animation keeps playing for 
the animation keeps playing for our  
110:39 - well in our level two after we win the game, 
because we haven't added a win condition  
110:44 - in our Animation Blueprint. So what we're going 
to do is we're also going to add another variable,  
110:49 - and this variable is going to be called B has 
layer one. Now in begin play, I'm going to make  
111:00 - sure I set this value to false and make sure this 
is a bool. So we're gonna change variable type.  
111:11 - Close Compile and Save, and 
make sure we set this to false  
111:15 - every single time we start playing the game.  
111:19 - Over here, in my Level Blueprint, again, what 
I'm going to do is in level one, at Save Selected  
111:28 - blueprints, Open Level Blueprint. And we 
have to make sure we get this character  
111:36 - from the from the character over here, set. 
Clear one has player one over here. If it's true,  
111:47 - then we can set we can actually we have to set 
this only in level two, not our level one, because  
111:54 - our player hasn't technically won the entire 
game completely yet. So if I go to level two,  
112:01 - open up my Level Blueprint, I have the same 
thing over here too. Now if I, if I from the  
112:09 - battery man, I have to set one just search for has 
player one, I'm going to double click on this node  
112:17 - so that I can redirect this node over here 
like that. Move it all the way to the end.  
112:29 - And then connect this, we're going to set 
this to true, I'm going to again add another  
112:36 - node over here so we can detect it 
properly said looks a little neat.  
112:40 - Compile and Save. Now let's open up our our 
Animation Blueprint. And open that up. Okay,  
112:52 - over here now we're blending spaces wherever 
blending poses by bool over here. Now, if player  
112:58 - is dead, they're going to play the idle animation. 
But if the player is dead, or if the player  
113:07 - has won the game, we're still 
going to play the idle animation.  
113:10 - So over here, we're going to have an all Boolean, 
what this does is it checks if one of these will  
113:17 - so takes into bool values. And if it cannot 
be stick a lot more can take five, six, etc.  
113:23 - But we just need to have these. So 
we're going to remove, then remove pan  
113:28 - over here if the player is dead, or if the 
player has one, plate, the player dead animation.  
113:35 - So to get that cost to Batman, we've already done 
that. From here, we will get one has clear one.  
113:44 - Move this all the way to the bottom. And 
again, we're going to promote this to  
113:48 - available the name is fine. And all the way to 
the end. There we go. That looks a little neat.  
113:58 - AnimGraph place this over here. So if any one of 
these conditions are true, we're going to play  
114:05 - the idle animation. So if I now play the 
second level one to see now my animations  
114:15 - don't play continuously. So I can now quit 
the game. And that works perfectly fine.  
114:21 - Awesome. Now that is pretty much it for this 
game. Your challenge is to add your own map  
114:28 - try to add your own level, go to the marketplace 
get there a lot of free assets that you can use.  
114:35 - Maybe make this into a spaceship and try this 
out. The only problem now is that unfortunately  
114:41 - since Unreal Engine five is still under 
development, most of the assets are not compatible  
114:48 - with the engine. So if I go back to my Epic Games 
launcher and if I try to add this free asset that  
114:53 - I got from the free for the month thingie if 
I click on show all projects and try to select  
114:59 - Unreal Engine five You can see it says asset 
is not compatible. So what you'd have to do is  
115:04 - you'd have to downgrade this project to Unreal 
Engine five. And then you will have Unreal Engine  
115:10 - four and then add the assets. But the problem is 
you might have a lot of issues after upgrading it  
115:16 - back to Unreal Engine five, which is why it is 
still in early access. Not a lot of assets are  
115:20 - still away are available for Unreal Engine five 
witches. Yes, it is a little disappointing, but  
115:27 - at the same time, they've specifically mentioned 
this engine is an early access. So don't be too  
115:34 - worried, you can follow the exact same tutorial 
that I've showed over here in Unreal Engine four,  
115:39 - it's the same functionality, same blueprints, all 
of them work perfectly fine, it's just that the UI  
115:44 - might look a little different. This looks a lot 
more modern than Unreal Engine four. That's the  
115:51 - only difference accurate pretty much fine for 
now when it comes to at least the basic parts.  
115:56 - So this tutorial can be followed in Unreal 
Engine four, two, so don't worry about that.  
116:02 - But thank you so much for watching. I 
really hope you learned something and I hope  
116:06 - you were able to familiarize yourself with 
Unreal Engine five and game development.  
116:12 - If you've completed this course that is amazing 
tied to add your own functionality to it.  
116:16 - If you want to learn C++ stay tuned because 
I have a C++ course coming very, very soon  
116:23 - we're going to create the exact same game 
but in C++ so that is going to be very,  
116:28 - very fun. But thank you so much for watching 
and I will see you very soon. Bye and good luck.