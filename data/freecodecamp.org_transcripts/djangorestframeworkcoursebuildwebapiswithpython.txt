00:00 - The Django REST framework is a flexible toolkit for building web APIs using Python.
00:04 - Bobby Stearman teaches this course about how to use the Django REST framework.
00:08 - Bobby is a senior software engineer and has created many popular tutorials.
00:13 - Hi everyone and welcome to this course that I'm putting together for free CodeCamp over the next
00:16 - hour or so. I'll be showing you everything you need to know to build your own web API
00:21 - using Django REST framework. I'm Bobby Stearman from DigCoding and welcome to this course.
00:27 - Let's begin. Hi and welcome to the start of this course. So let's cover this off straight away.
00:33 - What is Django REST framework? Well, it's a toolkit that allows you to build
00:39 - web APIs. Okay, so think of it as a standalone API where your clients can make requests such as get,
00:46 - post, put, delete requests to you. Your API receives this information, it validates the
00:52 - information and it responds to the user. That's essentially what we're trying to do here. It's
00:57 - very powerful. It's very popular. A lot of projects that I work on these days are using Django REST
01:03 - framework. Some of the projects that I use or I work on at the minute just use Django REST
01:09 - framework as a backend and then they use a react or review front end. So a single page application.
01:15 - Like I said, it's very popular, very powerful. That's why I decided to put this course together.
01:19 - It'll take me about an hour to an hour and a half to finish the course. It's made up of eight
01:24 - modules. The first two modules are cloning down a repository that we've got on GitHub.
01:30 - And then module three onwards will be looking at building models, serializers, routers and views.
01:39 - Okay. By the end of this course, we will have a fully functional web API where we can make
01:44 - requests to, and we will get responses. And in the background, it'll be saving information to a
01:50 - database. Okay. Each module comes with a set of instructions, so step by step guides, and this can
01:58 - all be found on GitHub, which I'll show you in a moment or two. I will be here following along
02:02 - every single step of the way. Like I said, at the end of this course, we'll have an app that
02:08 - hopefully you can then refactor and add it to your own project. Okay. So let's begin.
02:17 - What you can see on screen is Django REST Framework's homepage. Now this is a great
02:22 - reference point for their documentation. It's got examples. It shows you how to install stuff.
02:28 - It's fantastic. If ever you hit a brick wall or a dead end, this is always a good place to start.
02:33 - Always read the docs. So I'll be referencing this a few times throughout the course.
02:39 - Another thing, Docker. This project is a Django project that's entirely Dockerized.
02:48 - So it stands to reason that it's a good idea if you have Docker and Docker Compose installed on
02:53 - your local machine. That way, when you clone everything down, you can follow along with me
02:57 - every single step of the way. It just makes it a lot easier when putting a course like this together
03:02 - and it negates the need for prerequisites like Python and curl or HTTP on your machine.
03:10 - So by installing Docker, it allows you just to keep up and be a lot. It's a lot more fluid.
03:17 - Okay. So pause the video, install Docker and come back.
03:23 - Last link that I want to show you is GitHub. You do not need a GitHub account to get your
03:29 - hands on this code. It's a public repository. If you don't have a GitHub account, click the
03:34 - green button here, download zip, extract the files on your local machine and you've got the code.
03:40 - Okay. So you don't need an account. However, if you do have an account,
03:44 - you have some options of cloning this repository and I'll show you those in a second.
03:48 - So the project is called drf underscore course. It has numerous different branches. Main is default.
03:56 - That's just kind of the empty box. If you like hasn't got much is the very, very bare bones
04:01 - of the project. You have a complete branch. That's the complete project. And if you clone that down,
04:08 - you skip forward to the end of the course and you've got all of the code.
04:11 - I would advise you to watch the video as it's a much better way of doing a deeper dive on drf.
04:18 - Okay. And then you've got one module or one branch for each module. So there's eight modules in the
04:23 - course module one and module two are set up configurations and module three onwards is building
04:28 - out of the app. Okay. So these are the directories and the files, and then you've got a read me file.
04:35 - Okay. So bit of an intro. So welcome to the course is great if you're looking to learn drf.
04:41 - And it's also great if you're looking to build an API. Like I said, it's popular, it's powerful,
04:44 - and it really will be a good string to your bow. It does say prerequisites of Python 3.10.
04:51 - I do use matching case statements in this course, and only got released in Python 3.10. If you've
04:58 - got it on your local machine, great. However, the containers in Docker already have Python 3.10 in
05:03 - there, so you shouldn't really need them. Also, I go on to say that you it's handy to make calls to
05:10 - the API to have curl or HTTP installed on your machines that you can make calls. But again,
05:17 - I've got containers built in this project with it all loaded up. So you don't need to install
05:22 - anything. So that's why I say install Docker. Okay, let's get started. When we clone this down,
05:29 - we want to clone it down into a directory and you want the local machine called drf underscore
05:35 - course. That is our root directory. I reference it a lot throughout the course. So please call it by
05:40 - that name. Don't call it Bobby's course, Billy's course, call it drf underscore course. It just
05:47 - makes our life a lot easier. I've already got one on my machine and my text editor, which in this
05:51 - case is BS code is already open in that directory. Okay, so I've skipped that part. But if you can
05:58 - open up this directory, and then take the clone code from here, I have an SSH key, you can use
06:08 - this GitHub CLI if you have it or the HTTPS option. I have an SSH key. So I'll be using that.
06:16 - And lastly, before I open up VS code. Each of these modules are recorded individually as well
06:23 - on my own YouTube channel. So if you like this course, and you like this content, then I advise
06:30 - having a look at the decoding channel and the playlist on there. Because like I say,
06:35 - if you like this content, you probably like the other content that I put out there. So that's
06:39 - that. I've copied over my git clone command, let's open up VS code. As you can see here,
06:45 - let's make it a bit bigger. I've got drf course here. And it's a instance of my VS code. So new
06:53 - terminal. Right click that in there, the little full stop at the end here will clone it down
07:00 - into drf. I have a passphrase. So I'll pop that in there. And there we have it. Great. So what
07:12 - I like about VS code is especially when you're coding in Python, and do Django apps, VS code
07:20 - has a whole bunch of extensions that make it act like an ID. And it's very, very good when you're
07:26 - using Python. So I would strongly advise that you get it installed in your machine if you're
07:31 - following along. And also, the reason I'm using markdown language for the steps is in VS code,
07:40 - it has a preview option. So you can actually preview that markdown. And it renders it like
07:44 - it would in a web page. So this is what we get, we get a directory called backend, we get a directory
07:52 - called steps. And then we have a get ignore, we have a Docker compose file, which we need with
07:56 - the firing up the project. We have a template ENV, readme file and the server PY. Don't worry
08:02 - about server PY file. One of the containers that we're building in Docker is actually a Flask app.
08:09 - And it allows us to just to fire up another application and make requests to the API.
08:15 - The reason I'm using Flask is because it's, it's a lot easier to set up a Docker container using
08:20 - Flask than it is Django. In this instance. So let's not worry about that too much. Let's go ahead
08:28 - and open up module one steps and open up as a preview. I'm hoping that's going to look okay
08:35 - on the screen. I'm going to close my terminal for now. There we go. So I'll say this now and not
08:43 - throughout the course, each module has a start, a middle and an end, the start will show you what
08:48 - your config, your directory configuration should look like, where your files are, how they're
08:54 - configured. When I watched previous courses to this years and years and years ago, I found that
09:00 - I'll be following along and I'll be saving files in the wrong directories and wrong, the directory
09:04 - to be called something slightly different. I've tried to be as thorough as possible. This is what
09:09 - your directory should look like at this present moment in time. And at the end of the file, right
09:13 - at the bottom here, this is what it should look like at the end of the module. Hopefully that's
09:19 - going to be helpful for you. And the middle part of the module is the instructions and the walk,
09:25 - the step by steps that I'll be walking along with you. So look, we've got a backend directory,
09:30 - a steps directory and a few files. So we're good to go. If you're ever in doubt and you've
09:37 - cloned this down from Git and you can change and pull down the code from the module branch as it
09:44 - went, and that should reconfigure things for you. Okay, steps, commands. You should now have a
09:50 - directorial DRF course in your development directory. This will be known as your root
09:54 - directory. In this module, we will be starting our project. To do this, we need to create a virtual
10:00 - environment. Now, this is Dockerized. We don't necessarily need the virtual environment when
10:06 - we've got the Dockerized project. However, I do reference some bits and pieces in the rest
10:13 - framework directory that we're installing. Now that's all installed in Docker, but it's handy
10:18 - to have the virtual environment in the project also so I can open up those files. So just bear
10:23 - with me. So first thing you want to do, you want to invoke this command, this Python command,
10:28 - and we'll open up our terminal. Make sure you're in the root directory and we're creating a virtual
10:36 - environment and we're calling it venv. I'm on a Windows machine, so to fire up that virtual
10:42 - environment, I use this command here. Okay, and how do I know it's running? I've got venv
10:50 - in brackets there. Can you see that? Now we can go ahead and we can install all the dependencies
10:56 - of the project. I want this to be more about Django rest framework, rather than Python and
11:02 - pip and Django. So I've already created a requirements file, which is in backend, which
11:08 - is here. It looks like this. Now when we run the following command, it will cycle through
11:12 - these and install them into our virtual environment. Okay. So go back to the module,
11:18 - back to the module, and we will take this command, pip install, and we'll point it
11:26 - towards the requirements file in backend and it cycles through and it'll install everything.
11:31 - You can see one of the things we're installing is Django rest framework,
11:33 - Django rest framework, JSON API, and Django filters. They're all working together in this project.
11:40 - We also got Python dot env. This allows us to identify environment variables in a file
11:47 - in the project. And that way we can have secrets and API keys and things like that in here.
11:54 - Okay. And this is the, this is the file that we'll be using for that. Okay.
12:00 - This that will command at the bottom here, the bit in yellow is saying, uh-oh, you need to
12:04 - upgrade pip. You can do that. It's not necessary really, but let's go ahead and do that.
12:10 - Place that and that should go ahead and then that'll update pip and you won't see that
12:15 - problem anymore. Good. Right. Go back to module one. It's a lot easier when I'm, um, not mirroring
12:25 - my screen because my text is far bigger. So I don't get to see as much. So, uh, we've installed
12:30 - everything right now. We've installed Django. That's the most important one actually in this
12:36 - instance. Um, Django 4.1.3. Okay. So that's the version of Django that we've got installed by
12:44 - installing it. We now have access to the Django commands and Django admin commands. One of those
12:48 - commands we're going to use is start project. Okay. So we use Django admin, start project.
12:55 - I don't want to dwell too much on this because it's not a Django course. It's a Django REST
12:59 - framework course. Um, there we go. What we're doing, we're starting a project and we're dumping
13:08 - it in backend. We should now see this DRF course on the left hand side here. Good secrets. We want
13:15 - to copy the template that comes with the course and we want to call it dot ENV. So we now have
13:21 - this file here and this will be picked up in the Django project. So it's looking for a secret key.
13:28 - It's looking for allowed hosts. Okay. But it's already pre-configured. You don't want to worry
13:31 - too much about that. And that, when I say module one and two is all about setup, that really is.
13:38 - Okay. So our configuration in module one, let's close this, should now look like this. We've got
13:43 - backend. We've got a new DRF course, which is here. See that we've got an init file. We've got ASCII,
13:50 - WSGI URLs and settings. Okay. That comes straight out of the box when you set up a Django project.
13:55 - We've got a new directory called virtual ENV or VENV. If I open that up, it's got include,
14:00 - lib and scripts. In lib, we'll have site packages. And if you look in here, this is everything that
14:04 - we just installed. We've installed Django REST framework, loads of other stuff, but Django REST
14:10 - framework is really the heart of this course. Okay. If you go in here, we've got files such as
14:15 - serializers. So we'll be importing this in some of the projects. Some of these classes and methods
14:22 - will be calling quite a lot in this course. So we'll become familiar with this setup
14:26 - up soon enough. Okay. But that is the end of module one. What we'll do is we will have a
14:33 - quick sneak peek here of module two. So we'll close this. We're going to steps module two.
14:39 - And the next module we will be, we'll be setting up a new app called core and we'll be added some
14:47 - bits and pieces to the settings file. Okay. So that's module one. See you in the next module.
15:00 - Okay. This is module two. What we're going to be doing is having a look at this module two,
15:07 - which is in the steps directory. We'll open it up and we'll open it as a preview. And as I said,
15:13 - in the last module, these files are broken down as a top middle and the bottom, the top, the bottom,
15:20 - show you the configuration, start and finish. And a bit in the middle is all about following steps
15:24 - that we can follow along together. I know that this is correct because I just completed it in
15:30 - module one. Just make, make sure that your configuration is where it looks or what it looks
15:35 - like on the screen before moving on. And if not, just pull down from get. Okay. So Django makes
15:42 - easier to build better web apps more quickly with this code. That's why I love Django so much. Right.
15:47 - So in this module, we'll be creating a Django app. A Django app is a Python package that is
15:54 - specifically intended for use in Django projects. An application may use common
15:59 - Django conventions and it's normally all bundled up. Right. So we're going to create two apps in
16:03 - this project. One of them is going to be called core. The other one will be called e-commerce.
16:08 - We won't bother ourselves with e-commerce just yet. Let's focus on core. So this app will hold
16:12 - logic around core functions of the app. In this case, it's going to be a contact us model,
16:18 - serializer and view. So a user can buy some information at us at an end point. We'll take
16:23 - the information, we'll save it into the database. In this instance, it will be a username, an email,
16:30 - so a username, a first and the last name, an email and a message. And we'll store that in
16:34 - the database, which is quite helpful stuff. Okay. What we want is python manage.py start app core.
16:41 - That is the command we're going to be using, but you need to be in the backend directory. It won't
16:47 - work in DRF course because we're calling the manage.py file, which is in here. Okay. So CD
16:55 - backend, and then we'll add that command here. And it should start a new app called core. You see
17:01 - that we now have access to it. However, we do need to tell Django that that core is active. So we need
17:07 - to change some bits in the settings file. So let's take this code. I don't want to glance too much
17:15 - over the steps, but I don't also don't want to read it straight from the screen. So we need to
17:22 - change some settings. Okay. So there's kind of three or four parts. We need to change. First
17:26 - thing we need to do is change the imports at the top of the screen so that we can actually access
17:31 - ENV environment variables. We're using python.env for that. And we just need to invoke instantiate
17:39 - it. So we have access to it. So if we open up Django, so DRF course, and then go to settings.py.
17:47 - This settings file has been constructed straight from Django. Okay. So it's got no changes in there
17:51 - at all. You want to change this first line or line 13 and everything about it and just paste in what
17:57 - I've just copied from the module. We've still got the path except now we're importing.env.
18:02 - We're importing operating system, which is a Python package. And now we're instantiating.env
18:07 - with load.env. Okay. It's not DRF stuff, but it just is really helpful so that we can store
18:13 - information outside of the settings. Next thing we want to do, we want to change secret key,
18:18 - debugging allowed hosts. So go back in steps, pick this up and drop it over this here. And what
18:27 - that's now doing is rather than looking at the secret key that comes straight out of the box,
18:31 - it's looking at the secret key in the ENV file, debug out of the ENV file and the allowed hosts
18:36 - out of ENV, which are these here. Okay. Great stuff. You're all with me. Next, we need to tell
18:44 - Django that we want to use the core app that we've just created, but also we want to use
18:50 - Django extensions, which is a great package that you can install into a project. We're going to be
18:58 - using Django filters and REST framework. REST framework and Django filters work together.
19:04 - REST framework gives us access to all of the view sets, the serializers, the routers and things
19:08 - like that. So essentially you add an installed app so we can actually use Django REST framework in
19:12 - the project. So we want to copy this and we'll drop that directly in installed apps. Okay.
19:20 - Django extensions, again, it's not DRF, but you have a load of module abstracts
19:28 - and that we can just use in our models in the project to allow us to have loads of
19:32 - fields without having to code it up and it just speeds things up. Good. Next, we need to add some
19:38 - specific Django REST framework variables. Go to the bottom of the settings file. So pick it up
19:47 - from the steps file and drop it in here. Okay. So what are we creating here? We're creating a
19:53 - variable called REST framework. So Django REST framework is looking for this variable in the
19:57 - settings file. Okay. This is taken straight from Django REST framework.org and it's kind of a basic
20:06 - setup. It's a load of key value pairs in a dictionary and it just adds some bespoke settings
20:15 - to the instance of Django REST framework that we're playing with. One project might want token
20:20 - authentication, another one might want pagination, things like that. Okay. So you can see we've got
20:27 - exception handlers, we've got default pass classes, renderer classes. What else have we got? We've
20:33 - got test request default format. So when we write some tests later, this is the default format of
20:38 - the data that is being sent. Okay. And we'll add to this throughout the course. So we will be doing
20:43 - some token authentication in this course. You'd be pleased to know. I think that's in module five.
20:49 - And yeah. Okay. They are the settings. URLs. Okay. So normally when you're working with a
20:56 - Django project, you do things in a certain order. So you install the packages, change your settings,
21:01 - add the URLs to the URL conf because some of the packages require that. And then you go about and
21:07 - you create apps, models, forms, views, URLs. Okay. In that kind of order. So we'll go through that,
21:14 - but this is the URL conf. What I'm going to do here, so we're going to add this to URLs
21:21 - straight out of the box. It wires up admin. We're not going to change that because it's handy to
21:25 - have access to the built-in admin page in this course. So we'll keep it as it is, but instead
21:29 - what we're now brought in is two things. So we've got REST framework, import routers.
21:34 - Think of a router in Django REST framework as a way of directing routing traffic to your API,
21:43 - to the correct view. Okay. That's what we're doing there. So when a request comes into an endpoint
21:49 - that we specify, the router will help to direct that towards the view. It works well with the
21:56 - URL patterns that Django uses. Okay. So that's why we're bringing this in here. You can write
22:02 - a bespoke router, but the default route will, for instance, if we're doing a retrieve call in a
22:12 - view set, it will already know to look for the primary key. Okay. So you can have a bespoke
22:18 - router that will look for type and key, but you need to write that. We're not doing that in this
22:24 - course, but that is where you would handle that kind of logic. Okay. Migrations. Lastly, we now
22:31 - need to migrate everything to a database. Now we are using the straight out of the box database.
22:38 - We haven't got a post-rescue database or anything in this course. So by running migrate,
22:43 - make migrations and migrate, we'll be creating a database file essentially, and that will appear
22:48 - in the project. So let's go ahead and use these two commands. Look at my terminal. You see that?
22:56 - We're in the correct directory backend, and we click migrate. That's exactly what we're expecting
23:03 - to see. In Django, in the installed apps, there's certain things here like auth and content types
23:13 - and sessions that have database tables. Now we will be using auth especially. We need those tables
23:21 - in our database. So we run those migrations and migrate those tables into this. This is our
23:27 - temporary database. This is not a production ready database or anything like that, but this is what
23:31 - we'll be using. So we've just done that and we can now run a local server. So we'll do that quickly.
23:42 - We are going to use Docker in another module, but right now let's just fire up the server. Can you
23:46 - see that? And that will say everything's looking good. And if we open up my browser and go to 127,
23:58 - and we'll just paste it in there. Oh, that's not what I wanted to apologize. One second.
24:06 - I think localhost should work. Yeah, there we go. It does work. So this is exactly what we want to
24:15 - see at this point. It means we have configured things exactly where we need them to be to see
24:22 - the web API in our browser. You can see that we've got no endpoints at all, but the built-in
24:29 - homepage, if you like, is just a basic get request. And that's why you're looking at this page.
24:34 - Okay. So in the next module, we will start building out our core app. So we'll build some models,
24:42 - serializer, some views and routers so that we can actually make a call to an endpoint and
24:48 - make it all work. Good. Where are we? So that is module two. Thank you very much. I'll see you in
24:57 - module three. Okay. Module three. Let's begin. I will just close down some of the bits from the
25:06 - last module. Let's go to steps, module three, and we're going to preview. Good. So module one and
25:13 - two was all about setup and config. Okay. Arguably you could skip to this point if you're really good
25:17 - at Django and you know what you're doing, you can start here. It's a basic setup. So start and end.
25:24 - So the start configuration should look something like this, the directory configuration. We've got
25:30 - a core app in backend, which is good. We've got that straight out of the box stuff. Nothing fancy
25:36 - pants in there. Got a Docker file. Don't worry about that. Got DRF, got a DBSQL Lite file,
25:45 - which we have. We've got it here. That's a new file. And then we've got everything else that we
25:50 - had. So we're all good to go. We don't need to change anything, but if you've lost track a little
25:55 - bit, you can pull down from module three from GitHub. Good to go. Right. In the last module,
26:00 - we wired up to one new app, should I say as a typo. What we now need to do is we need to create
26:11 - a contact us endpoint so a user can send their name, email, a message to our backend. What we
26:17 - need is a module. This is a Django convention. So we create a module which translates to an SQL
26:24 - table with fields. Okay. Okay. We need a router to direct traffic to the endpoint, to a view,
26:35 - and then we need a serializer to serialize data. So a serializer is similar to a Django form.
26:42 - So it does a lot of the heavy lifting. So a serializer is kind of a piece of code that
26:46 - sits between a request coming in and the backend. Now it serializes the say JSON data into Python
26:55 - data types and then back again. So it receives information, alters that information into
27:01 - something that Python can read, validates it, does stuff in the background, and then it spits
27:05 - it back to the user. That's what a serializer is doing. Very similar to a form, right? So
27:10 - that's what we need to write. And then we have a view. The view handles all of the logic. This
27:14 - will be a view set or a API view. An API view is very similar to a normal Django class-based view.
27:22 - But with Django RIS framework, they have some other views that we can use as well, like API
27:27 - view, view sets, and some built-in mixings that we can use as well. Okay. So let's start with
27:36 - models. Remember we do models first. So pick up the code that you can see on the screen here.
27:40 - Copy it, go into core, go into models, Ctrl A, Ctrl V. Okay. And then save. It will have a dodgy
27:48 - import. Don't worry about that. We'll cover that off in a second. But essentially we're importing
27:52 - models from Django. And we've got some extensions. So remember Django extensions give us some
27:56 - abstract models that we can use. A timestamp model gives us a couple of fields like created.
28:02 - An activator model will give us a status field and an activated date and a deactivated date.
28:09 - And a deactivated date. And also we'll have a title description model. That gives us a character
28:15 - field or two character fields, text field. And the reason I'm adding those is because
28:22 - the first name and the message will be a character field and a text field.
28:26 - All we need to do is just direct the serializer to the correct field. And that's why I wanted
28:32 - to add it into the course. And then we've got a model called contact. We're inheriting some
28:37 - bits and pieces here, including an abstract called model. Each of the tables in this course will have
28:42 - a UUID as an ID field. We'll create that in a second. Got meta class, and then we're adding
28:49 - an email field. So this is just the models.email field. All right. So this is, this is what we'll
28:54 - be adding to the serializer also. And then we've got to done the string method here, which is a
29:00 - string representation of the model. Again, don't need to do a deep dive on this. This is a Django
29:04 - Django model. And this is what the database will have in it. Let's construct that abstract.
29:13 - So abstract models, you will notice that we're importing an abstract model. I've already spoken
29:18 - about that. We're going to have a ID field in each of our models with a UUID field. So copy this here
29:25 - in backend, we want a new directory. So we'll call this utils. Within that, we want a new file
29:35 - called thunderinit.py. And then another file in there called model abstracts.py and dump all of
29:51 - that code in there. Paste. Okay. Bringing in UUID from a Python, that's a built-in Python package,
29:58 - and then models. And all we're doing here is we're creating this class called model. It has an ID
30:02 - field, which is a primary key. Okay. So we, we're using that primary key when we're making calls to
30:09 - the API. And then in the class meta, we call it, we're saying abstract equals true, which means
30:15 - we can then inherit that in our, in our contact. Again, let's not dwell on that too much. Okay.
30:22 - Good. Serialize this. Remember serializer is some code that sits between the user request
30:27 - and the backend and back again. So it handles the serialization of information data. Okay.
30:33 - So we need to create a file in our project called serializers.py in core new file.
30:40 - Okay. And then in there paste in this code, what are we doing? We are importing our model that we
30:49 - just created for it's relative. That's what is this dot is here. And we're bringing in serializers.
30:55 - So let me touch on this quickly. So when from rest framework, import serializers, what are we doing?
31:02 - We are importing from our virtual environment. In this case, we're looking at a virtual environment
31:08 - here. We're looking for rest framework and then we're looking for filing here called serializers.
31:15 - Now by importing that we now have access to all of this. Okay. So in here we have the base
31:20 - serializer, which will be abstract. Let's minimize some of this. So when we, when we create serializer
31:29 - and we inherit serializers dot serializer, it's this class that we'll be using. Okay.
31:35 - So you can see here we've got a default error message, we've got fields. So it's doing a lot
31:39 - of hard work there. Another thing we've got is a model serializer. So a model serializer is just
31:46 - a regular serializer, except that a set of default fields are automatically populated. So it links to
31:53 - a model. It's model serializer. Okay. So serializer field mapping. So this is the logic where if you've
32:01 - got a serializer field, it maps it to a model field. But this is the reason I'm showing you this is
32:07 - this is what we're, we're importing. So a lot of courses you see online, it won't really do a deep
32:12 - dive on this sort of thing. You know, this import serializers from serializers. What does that mean?
32:18 - What are we actually using? So I'm just showing you that this is what we're doing. Okay. So when
32:22 - we create a serializer, we're inheriting from these classes. So we have access to all of the
32:26 - methods and functionality within good. And then yeah, from framework dot fields, we're accessing
32:33 - child film and email field. Okay. They're the two fields that we're playing around with. Okay. So
32:39 - let's create a contact serializer. We're inheriting model serializer. Remember this does the mapping
32:45 - to the fields. We have a name message and email field, very similar to Django forms. Okay. So you
32:53 - add a variable and then you say what field type is what widget you're going to use. This is very,
33:00 - very similar except in this name. If you remember, we're using a Django extensions field called
33:08 - title description. Now that gives us a field called title, but in the serializer, we want to call it
33:16 - name. So what we do is we point this towards the title field. Okay. That's why we've got source
33:23 - equals. That's what that keyword is doing. And we're saying required through. So we're expecting
33:27 - that information to come through from the client. If we don't, it will get a 404 response. Same
33:33 - again for message. We're pointing it to description and email where we know there's an email field,
33:37 - right? So we've got an email field called email in the model. We have a class meta and in a
33:43 - direct it to the model that we're looking for. And then the fields that we want. That's it. That's
33:48 - all we need for the serializer. Okay. We're linking the serializer to a model that we have.
33:53 - All we now need to do is wire up some views, save, but talking of views, let's take this code,
34:01 - copy, go into views in core, paste that in and we'll save that. Okay. So, um, from Jason,
34:13 - which is a Python package, bring in a Jason decoder error. Um, we're bringing in a Jason
34:19 - response from a Django package. Then from dot serializers, which we just created,
34:23 - we're bringing in a serializer and a few bits and pieces from rest frameworks. We've got parsers.
34:28 - This allows us to handle the parsing of the Jason that we're going to be receiving from the
34:32 - client. And we've got views. So there's a whole bunch of different views that we can handle.
34:37 - Let's have a look. You know, the views here, we're using an API view in this instance. Now,
34:42 - an API view is very similar to a Django class based view. And in a way you can have a get
34:49 - method, a post method, so on and so forth. So it'd really, really helpful if you've been working
34:54 - with Django for a long time. It's a good, nice, easy transition to use API views, but you have
34:58 - other bits and pieces in here as well that you can also use. Good. And then you've got status.
35:04 - So status gives us access to a whole bunch of predefined statuses that are in, um, rest framework.
35:12 - So HTTP, uh, 200 equals 200. And we use that in the responses. We feed back to the client.
35:20 - Okay. So contact API view, parsing through views, the API view, which is
35:28 - Was it this? No, sorry, got too much open. Is this it? This is what we're parsing through.
35:35 - Okay. So we've got a deep, uh, we've got schema, got as view. Okay. So
35:43 - remember it's like a class based view. And if you're going to render that to a webpage in
35:47 - Django, you would use a dot as view at the end of it. If we have a function based view, you don't
35:51 - need to do that. Um, we've got some other methods here that we've got. We won't go in, it's not a
35:55 - deep, deep dive. This is a very sort of top level. Um, so we've got a get serializer context method.
36:02 - And we've got a get serializer method. Um, and at the top here in an API view, you need to put the
36:09 - serializer class. So the serializer class in this instance is a contact serializer. So we'll be using
36:14 - these two methods here to handle the getting off that serializer in an API view. So we now have
36:19 - access to that serializer. And anyway, we've then got, what's the most important part of this view
36:25 - is the post request. So what we're doing here is we are expecting some Jason to be sent in from a
36:34 - client. First thing we want to do is to pass that Jason using a, the parser that's built into the
36:39 - Django REST framework. Um, we then use this, we send that data through to the serializer to handle
36:47 - the, um, serialization of information. Remember pointing it to the right fields.
36:51 - And if the information that's coming in is valid, i.e. there was a name, a message and an email,
36:59 - and the email is an email type, um, data type, and it'll be valid, same as a form, no different.
37:05 - Then what you do is you save the serializer like you would a Django form, and it saves that
37:10 - information to the database. What you then do is you send a response back to the front end,
37:15 - which is the data from the serializer. Send information in, serializer takes the information,
37:21 - checks it, validates it, saves it to the database, sends the information back.
37:26 - Okay. That's what we're doing in this post method. If it's not, if there's an error,
37:33 - then we spit back a 400 bad request. We know in, it's not in views, we know in status,
37:42 - where is it there, that 400 is bad request and it will spit back a 400. Okay.
37:49 - And then if the encoding of the, if it doesn't come in as a proper JSON, then the decoding will
37:55 - fail and we'll send back a status 400 with an error message as well. Okay. So we're handling
38:00 - the information coming in, in this post request via review, same as you would in a view in Django.
38:06 - Okay. But now what we need is a router to route the traffic from the endpoint to the view.
38:16 - So what we need is
38:22 - in previous courses, I would have put a URLs or router file in here, but we're just using it from
38:26 - the DRF course, so the URL conf file. So, okay. We've just added that. So we've imported what's
38:37 - different. We've imported the cause views that we just created and we've added a new path to
38:42 - URL patterns. Now this is a, this is a API view. Again, like a class-based view, that's why we've
38:47 - got the as view at the end. Endpoint is contact and it's core views, contact view. So it's very
38:54 - similar to a URL pattern that we'd normally use in Django anyway. So this is why it's so easy to
38:58 - kind of get your head around if you're good at Django. And that's the, that's the, that's the
39:02 - router. I think, no. What do we do? When we create models in Django, we register them so we can access
39:12 - them in a built-in admin page. So if you go into admin.py and save this code, it'll give us, it
39:19 - will register contact to the admin page and give us access to any instance that is saved to the
39:24 - database. Last thing we want to do is migrate the changes that we've got it in the database.
39:35 - Don't want that. Don't want that one. Let's go to CD backend. Remember you need to be in backend to
39:43 - invoke the manage.py file. No more Django filters. Okay. No more. You know, the reason that's done
39:52 - that is because we have not got a virtual environment. You see that in the bottom left,
39:57 - there's no open bracket ENV. So what I need to do is the ENV backslash scripts, backslash activate
40:09 - .bat because I'm on a Windows machine, CD back in the backend and then use those same pieces of
40:16 - code again. There we go. Good. We now have, you see we've migrated contact and we might, so we
40:26 - create a migration file and we've migrated it to the database. So by running those commands,
40:30 - we've created this file here and you can see we're creating a model called contact with all of these
40:36 - fields. So we've got ID, which is a UUID field, created modified title description. So with one
40:43 - line of coding models here, because we're inheriting all of this, it actually creates a whole bunch of
40:52 - other fields, which is it. And then we've migrated it to the database. Good. Now we are in a position
41:00 - to make a call to the data and make a call to the API. So what we'll do is we will deactivate,
41:13 - just deactivate your virtual environment when you're doing this. We will CD that one. So we're
41:20 - going to DRF course. And now what we want to do is we want to fire up Docker. So you go Docker
41:26 - compose up dash D dash dash build. What that would do, that will call this file here. And whilst
41:42 - that's just doing what it needs to do, I'll just show you what's in there. We're creating two
41:45 - containers. Okay. So the API, this is the Django app and another app, which is a Flask app, which
41:53 - is a really, really small lightweight container that has Curl HTTPI installed, which will allow
41:59 - us to make a HTTPI request to the API. HTTPI, sorry, HTTPI is very similar to Curl, except
42:07 - the response you get is really, really easy on the eye. And it's much, it's just better. I find it
42:14 - better than just a normal co-request. Now Docker should be running. Happy days. Look at the app.
42:25 - Sorry, that's a bit small. There we go. This is the app. So this is Flask. And then I'll be doing
42:33 - a lot of zooming. And then we've got the API. There we go, which is very similar to what you'd
42:38 - be seeing if this was running is in your local terminal. Okay. So that's working perfectly well.
42:43 - I'm really happy with that. So we're going to app and open up the CLI, which is the equivalent is
42:51 - a command line interface. It's the same as your terminal. It's just, we have access to HTTPI.
42:58 - So what I'll do, I'll go back into module three and I will, where is it? Where is it? Where is it?
43:07 - Where is it? We will make this call. So what is this? HTTPI, that is the, I say you invoke a call
43:17 - using HTTPI, similar to curl. We give it the endpoint. In this case, API is the name of the
43:23 - host for the Django project. Before it had been local host or 127.0.0. The 8,000 is the port.
43:35 - No different if it was local host 8,000. It's just when you're in Docker in this course,
43:39 - you'll be using API. We pass through name, message, and email. They're the three fields.
43:47 - Copy this back in Docker, paste it there, and then press enter. And you can see that it's,
43:57 - I can't, I'm zoomed in, so I haven't got access. But you can see the JSON at the bottom there.
44:01 - That is the response we're getting from the API. So it's saying that it's actually created
44:08 - an entry in our database with an ID of 881896. So that tells me it's worked. Now I can
44:18 - demonstrate that it's worked by logging into the admin page, but I won't in this module.
44:23 - Perfect. That is exactly where I want it to be at the end of this module.
44:26 - So we've got a new configuration of what a directory should look like on the left hand
44:31 - side here, but we're not going to look at that. So don't worry, but please double check before
44:36 - you move on to the next module. So thank you very much. And I'll see you in module four.
44:46 - Okay. Module four. Let's, sorry, I'm recording this as one here. I'm not editing at all. So
44:52 - all of these screens are open because they were open a second ago. So module four, let me just
44:59 - tidy things up in my screen. Right. There we go. Module four, go into preview.
45:06 - This is what it should look like. Pause, have a check. I'm not going to spend too long on that,
45:10 - on that. Clone down if you need to make sure your directory setup is the same as what it is on my
45:14 - screen. So in the last module, we built a contact endpoint. Now we want to do some tests. Okay.
45:20 - A, an app without tests is broken by design. Okay. So that's on the Django website, but it's very
45:29 - much true. If you don't have tests in your app, then you know, you're not going anywhere with it.
45:33 - So what we'll do, we'll pick up all of these test cases that are pre-written
45:38 - and I'll copy them and I'll go into backend core, open up the test.py file and drop them in.
45:45 - So if you're used to writing Django tests, what you'd normally do is you'd use,
45:50 - you'd write some unit tests and you'd test different methods and views and things like that.
45:56 - Well, in REST framework, you have something called an API client. Well, that constructs a client
46:02 - similar to HTTP or the container in Docker to make a call to the backend. This is just a built-in
46:08 - REST framework API client allows us to make post, put, get, delete requests.
46:13 - So that's what we're bringing in there. We've also got API test case. Okay. So we're bringing in those,
46:20 - the contact test case inherits from API test case. And it's very similar to the Django test cases.
46:25 - You need a setup method, which constructs things in the test database, and then you can make calls
46:30 - against them. Okay. And then again, we're bringing in status like we did in the view. So we're going
46:35 - to do assert equals against some of these tests that we're constructing. And we're expecting
46:41 - 200s, 400s, 404s, and things like that. So if you use the Django, these are just pretty normal
46:48 - Django tests, but because we're using REST API or Django REST framework API test cases, it will
46:54 - spend a little bit of time going through this, no more than a few minutes. So there's a setup method.
47:00 - We're calling self.client, the API client. Okay. So we can access the API client by self.client
47:06 - in the methods themselves or in the test cases. We create a dictionary here, Python dictionary
47:11 - called self.data, and we add a name, message, and an email field. This is what we're expecting
47:16 - from the contact endpoint. And then a URL, which is self.url equals contact. Okay. So let me
47:23 - minimize some of these. Now it's important to note that we can call these when we run
47:33 - a Python manage.py test, or that's already built into the Docker instance. So when we fire up
47:39 - Docker, it automatically finds these tests and it runs them. So we've got what? Eight test cases
47:45 - here. So we test the endpoint. We test the contact endpoint without a name. We test the contact where
47:53 - name equals blank. And then we do similar to the message. And we do similar to email, except with
47:59 - the email, what we also then do is we do send an email, but we send a data type that isn't an email.
48:05 - So it'd be like a string without an at symbol in it. So that's quite thorough test cases for just
48:10 - single endpoints. We've got eight tests. The first one is we, sorry, that's not the first one.
48:18 - The first one is we get the data from self.data. The response is self.client. So this is the same
48:26 - as requests actually, say response equal requests.post, very similar to that. In this case,
48:33 - it's request.client.post. You pass through the URL and then you pass through the data, which is in
48:39 - this case, what we're expecting. I would expect HTTP 200 OK, which is a 200 response. I would
48:48 - also expect that the database has one entry in it. And I'd also expect that that database
48:56 - entry title is Billy Smith, because that is what's in here. OK, next, I won't go for each of these
49:04 - because I'm sure you understand testing. What I do, I take the data and I use the dictionary
49:11 - method pop to remove name. So now we've got a dictionary without a key value name. Post it,
49:18 - I expect it to say 400 because we're expecting name and hasn't got one. Again, rather than popping
49:24 - it completely, I remove name and just add a blank string instead and expecting 400. So these last
49:31 - seven test cases, I'm expecting 400s. OK, so that's testing. Go back in a module. What we
49:39 - can then do is we can use this command, Python manage.py in Docker. But this time we want to go
49:46 - into the API container. That's the app container. I apologize. Go back in here, go into CLI. Changes
49:55 - I make locally will work in Docker because I'm using something called volumes. So persists data.
50:01 - So essentially what happens outside of Docker in my project will also be in the Docker container.
50:08 - So those test cases will now be there. Should be.
50:11 - There we go. So it's run eight tests. We've created eight tests. They're all OK. So every time we're
50:16 - looking for 200 bang on every time a 400. Perfect. So now what we can do is we've already done this.
50:25 - We've already done this. As in we've sent the test case. We sent it, did this in the last module.
50:32 - We don't need to do it again. OK, but we can check the database. So if we use Python manage.py shell,
50:38 - in here, and just zoom, it just invokes a Django shell or Python interpreter, the Django. Same as
50:49 - what you'd see locally. Now, what we can do here is we can say from core dot models. Import. Import
51:11 - contacts. So we can say C equals contact dot objects dot last and then C. OK, and Bobby
51:26 - Stearman. OK, that was the call we made in module two. Module three, sorry. OK, can you see that?
51:32 - It's probably quite small. I do apologize. It's just you can't change the font size in Docker yet.
51:37 - OK, so there we have it. That worked. And that's it. That's module four. Your directory
51:44 - configuration should look like this on the screen. If it's not, pause, check, go back, make sure it
51:48 - does before we move on to the next module. I'll see you in module five. OK, module five.
51:59 - What have we got here? We've got back end. We've got steps. That's everything closed down. So we're
52:02 - picking up exactly where we left off in module four. So we're going to steps and module five.
52:07 - We'll open up as preview. We're halfway through the course now. So it's probably a good time for me
52:14 - to say, look, if you like this content, please visit DidCoding's YouTube channel and subscribe
52:21 - and click the bell because you like other content that I add. And also drop a like on this actual
52:26 - video on FreeCodeCamp and comment as well, because I do get to see them. It's always good to have
52:31 - feedback. So start and end of these step by steps. Just make sure the configuration on your local
52:36 - machine matches what's on here. If not, clone it down. We've built our core app. We now need to
52:43 - build an e-commerce app. The e-commerce app will be used to, it'll have two endpoints. It'll have an
52:51 - items endpoint and an order endpoint. So we want users to be able to call an endpoint and retrieve
53:00 - all the items that we've got in our shop. Okay. And also call it same endpoint and pass through
53:04 - a primary key to identify a single item. And then if they want to purchase it, they place an order.
53:11 - So there'll be an order endpoint for that particular item. So on top of that, we want to
53:16 - do some validation. So we want to make sure that the item has stock. We want to also make sure
53:21 - that only users that are authenticated can access these endpoints. So there's a few little bits
53:27 - we're going to be looking at over the next four modules. We're going to add token authentication
53:31 - to our app. We're going to build out some models, some new serializers. We're going to add some
53:35 - validation to the serializers and see where it leads us. Great stuff. Right. So let's use this
53:42 - command here in backend. If I close them down again, I will close the terminal down completely
53:49 - because I'm using Docker now. Remember you can fire up Docker with Docker dash compose up dash D
53:57 - dash dash build. No, yeah, that's right. And now fire up this app in Docker. And when you're in
54:03 - there, you can then use these Python commands in the API. So we'll quit the shell and we're done
54:11 - for that in here. Yes, we will in the API. And this is me making these calls in Docker. However,
54:19 - you will see them appear in my local machine. And the reason you'll see them on my local machine
54:24 - is because the data persists and we're using volumes. So e-commerce is now here. We need to
54:30 - change the rest framework variable in settings. The reason being is because we are adding token
54:39 - authentication. What we've done here is we've had, we've added a default, default authentication
54:48 - class called authentication dot token authentication. So anywhere where we add a permissions class
54:55 - in a view will enforce authentication. So you won't be able to access that view unless you
55:02 - pass through a valid token. Okay, so that's the first step. In fact, if we do DRF token authentication,
55:17 - this page here will walk you through all of the steps, but I'm doing that
55:23 - for you. So just follow the modules. So I've added that we now need to add a new app into our
55:29 - installed apps. So back in the settings, go into our installed apps, save over. You can see now
55:35 - that we've got authentication added there. Okay. That stands to reason that we'll probably be adding
55:43 - some URLs and making migrations because we're getting new tables in the database. Okay.
55:48 - So let's go back to our URL conf. And you can see now we've got a new endpoint and we've got a new,
55:56 - oh, we do apologize. So we're importing from Django REST framework and we've got a new endpoint.
55:59 - Save that. So this means now we've got an endpoint in our project where when a user visits that
56:03 - endpoint and passes through a username and a password, they will then receive back a token.
56:08 - That token acts as an authentication token. So if we receive that then in the backend, we know
56:14 - that that token links to a certain user. Okay. Keep tokens safe. So we've got a new endpoint,
56:24 - keep tokens safe. Now we need to migrate those new tables that we've added in installed apps
56:31 - to our database. So we go back in the Docker, paste those pieces of code in there
56:39 - and zoom in. You can see now, can you see that? We've got auth token. We've got initial auto and
56:44 - token proxy, which are the migration files for the tables that we're now having on the database.
56:49 - Don't worry. We'll see them in the built-in admin table very, very soon.
56:52 - What we also need is something called a signal. Now, if you're familiar with
56:57 - Django, you'll know what these are. We want a way of creating a token every time a user is
57:05 - created in the database. The way we do that is we use a signal. Now a single, a piece of code, which
57:13 - in Django, we call a signal, something that receives a signal from a certain table
57:18 - based on an action. Now that could be a pre-save or a post-save. So when a database has a new
57:25 - instance saved in it, a signal is sent from the database and this receiver has an antenna and it
57:30 - picks up that signal and says, ah, okay, I need to do something. And in this case, it will be create
57:35 - a new token. That's what we're trying to do here. So we go into e-commerce. We have a new file called
57:44 - signals.py. Sorry, I'm not following the modules. Sorry, the module five steps, step by step. I am
57:53 - going step by step. I'm not reading straight from the screen. So you can see we've got a post-save
57:56 - signal. So after something's saved, we get a signal. We have a receiver to receive said signal.
58:03 - What table? The core user table. So when a user is added to the database, that's who sends the signal.
58:08 - And what do we want to create? We want to create a new token, which is the new table we've created
58:13 - in a database. And this is what the code all looks like. We now need to wire that into the app. So
58:18 - when the app starts, the signal is active. It's looking for signals. And what we do in here is we
58:25 - say def ready. So it's a ready method. Pass through self. What do we do? We want to import from
58:34 - ecommerce.signals. Perfect. Now when ecommerce starts, signals will be active. That's what this
58:48 - bit here is. What do we want to do now? We want to create our first user. We'll make it a super
58:53 - user. So I want the super user, which is twofold. That will trigger that token. So we'll have a token
59:00 - and it'll also give me access to the built-in admin page, which I'll show you in a second.
59:03 - So I'll copy, paste that in there. Can you see? Don't necessarily need to see it, but there you go.
59:12 - Enter and that will ask me for a username. Just Bobby. Don't worry about an email address.
59:22 - Just a random password. There we go. User is created. I'd expect to see a token in the database.
59:27 - So go in your browser. We will go to localhost forward slash admin, because that's the URL. Bobby
59:41 - password. Perfect. I expect to see Bobby in the user table, because that's my super user.
59:47 - If I look in tokens, there we go. It's created a token and this is the key. So this is my
59:52 - authentication token. Perfect. You go back into modules. What we now need to do is we need to test
60:02 - the end point. So I expect to, when I test this end point, I make this call using HTTP, HTTP in
60:09 - the Docker, I would expect to receive something like this, which would be an endpoint response.
60:18 - And it will say token. It will give me my new token. So what I'm going to do is take most of
60:25 - this, but you need obviously use your own username and password. So I'll copy this
60:33 - and I will go to the app container. Remember we're making a call from app to API,
60:38 - go in a CLI, drop that in there. And I will say, well, username is Bobby password equals
60:51 - presenter. Perfect. See that? So it starts in eight B eight eight.
60:58 - We go back into the database, eight FB eight eight. Perfect. That's exactly what I wanted to see.
61:07 - That's it. We've just added what we are module five, which is added token authentication to a
61:11 - project. This is really good stuff. So now we can add that to our views. So if somebody's trying to
61:17 - access information, they will only access information relative to that user. That's what
61:22 - we're able to do. Not always the case. You might just want to have authentication on
61:26 - certain views so that only authenticated or signed in users can access it. It's good if you imagine
61:33 - you've got a mobile app, which, you know, is completely disconnected from the back end.
61:37 - Okay. Same as a react or a view app. So where are we? That's it. That's module five. Thank you
61:44 - very much for watching. I'll see you in module six. Okay, module six. Let's go ahead and begin.
61:53 - Um, let's go ahead and begin. Like I said, I'm recording this in one fell swoop, so
61:59 - please excuse the cluttered, uh, left hand side. So steps module six in preview.
62:07 - We've built our core app, configured everything. We've got a generous framework working. We've
62:11 - now got an e-commerce app with token authentication in this module. Just make sure your configuration,
62:18 - by the way, is exactly where it needs to be on the left hand side. It should look like this.
62:22 - It's not cloned down. What we're going to do now is we're going to go through the same process.
62:27 - We went in the core app, build our models, build our serializers, build our views,
62:31 - build our URLs in that order. Okay. So remember models relate to databases. So we need an item
62:38 - and an order model. So a model to catch all the items in the database.
62:46 - So go into backend e-commerce models, drop them in there. And I'm not going to spend too much time
62:54 - going through this, but it's important you understand some of the methods. So we've got
62:57 - an item model with some fields, right? We've got a stock and a price. So what stock we have in the
63:02 - database and what the price is now prices in pence and pounds or cents and dollars, whatever the case
63:07 - may be. It doesn't really matter. We've got a method to convert it into, remember if you're in
63:12 - pounds and pence, if you divide pence by a hundred, you've got your pounds. You've got managed
63:18 - stocks. We've got a method to decrease stock by a factor of whatever the order is. Okay. And we've
63:26 - got another couple of methods here to place an order to check stocks. So when you place an order,
63:31 - it checks the stock. If there's enough stock or the stock equals the order or is above the order,
63:37 - then it calls managed stock. So that's one of the validation methods we'll be using in the serializer.
63:44 - And then we've got an order model, which will relate to the user. So foreign key to the user
63:49 - will be the item that's been ordered and the quantity. Okay. So then we'll have an endpoint
63:54 - to view all of the user's orders. Okay. All of the items, retrieve a single item, retrieve a single
64:01 - order, retrieve all of the orders. So, okay, that's all we're doing in the models. We now need a new
64:07 - file called serializers.py. So I'm jumping forward. There we go. E-commerce serializer.py.
64:16 - You now need to pick up all of this code, copy, go into e-commerce, drop it in there and save.
64:26 - So bringing in the two models we've just created. And then for very similar to the core app,
64:32 - we're bringing in serializers, bringing in status and exception. The reason I'm bringing in exceptions
64:37 - is because I've got this class here, which is called a not enough stock exception. In a normal
64:42 - app, you'd probably have a number file here called exceptions and you'd have a whole bunch of them.
64:45 - So when you're validating, you can call, invoke, raise certain exceptions based on validation.
64:50 - We're only doing one piece of validation. We're checking that the stock is high enough
64:54 - or we've got adequate stock to cover the order that's coming in. So if when calling the method,
65:03 - check stock, stock is too low, we will raise not enough stock, which is a 400 bad request.
65:11 - The details say there is not enough stock and it'll be an invalid code. Okay. Model serializer,
65:18 - item serializer, order serializer is another model serializer. So these serializers, again,
65:23 - I spoke about this in module two, I believe there's a whole bunch of different serializers.
65:27 - You don't need to use model serializers. Like I said, that points it to model fields
65:32 - and it kind of does this, this clever model matching, sorry, field matching. You can use
65:38 - other sorts of serializer. There's one called just serializer, in which case you need to specify
65:43 - what those fields look like. Outside of this course, you might want to do a deeper dive on that,
65:50 - but we're using models. It stands to reason that we can use a model serializer. So this item
65:55 - serializer has got no fields. We're not adding any fields, class meta, model item, and we've got
66:01 - title, stock and price. Okay. There are three fields that we have in the database. Order
66:08 - serializer, however, we're using an item primary key related field. What we're doing there is
66:14 - we are saying that the item field in order serializer, remember we're cleverly pointing
66:21 - fields towards model fields. We're saying that that particular field, identify it by its primary key
66:27 - is a foreign key link between the two tables. So we're identifying that link via a primary key.
66:33 - I hope that makes sense. Same meta as above, but this time we've got a validate method.
66:40 - That validate method will be called when we call, when we save the, sorry, when we call it is valid.
66:47 - So the is valid method will call validate and it will check to make sure that all the information
66:51 - is as expected. Now, in this case, what we're trying to do is yeah, check the fields, other
66:55 - fields. Okay. Bang on. Perfect. After that, we then want to check the stock. Now, if the stock
67:01 - is too low, it will be, we will raise this, not enough stock exception. So it will be not valid.
67:09 - Does that make sense? That's why we've got this method in there. It's being called when we call
67:13 - the is valid method in the serializer. Okay. Then create a few models, pop them in the admin file
67:24 - here so we can access them in the built-in admin page. Don't need to go too further on that. And
67:30 - we need to migrate those new tables to the database. So if we open up Docker again, open up the API
67:37 - container, sorry, not the app one, API container, open up CLI, pop them in there, press enter.
67:45 - There we go. We created an item table and an order table. We should be able to see those in here.
67:52 - We update, happy days. We've got an items, we've got an order. Actually, let's go ahead and create
67:58 - some items, shall we? Add an item. That's one. That's one. We'll have a stock of 10, price 300.
68:11 - Save and add another. That's two. That's two. Stock of 20, price 500. That'll be five pounds,
68:22 - right? Okay. We've now got items in the database. So when we do call the endpoint,
68:26 - we should see something. That is it. That is the end of module six. So the next module we'll start
68:35 - adding the views and the routers. The module after that will add some tests and we should have a
68:40 - fully functioning app at the end of that. So thank you very much for watching. Make sure your
68:45 - route directory is what it needs to look like before you move on to the next module. I'll see
68:49 - you in module seven. Okay. Module seven. Here we are. So two more modules, including this one.
68:58 - There we go. Module seven. Look at this in preview. Make sure your configuration on the
69:04 - left-hand side matches this. If you don't, clone down. Okay. Our e-commerce app is picking up
69:11 - speed. We've got our models. We've got a serializer. We now need to wire it into some views.
69:15 - So we need to pick up all of this code and drop this into backend e-commerce views, paste.
69:27 - What we're doing different to what we did in core, this we're bringing in is authenticated.
69:33 - Remember we're wired in token authentication. So by bringing this in and adding this to our views,
69:38 - that will invoke the authentication class that we have in our settings, which is token
69:43 - authentication. We're expecting a token to be sent via the request in the header as
69:50 - authorization or authentication. So we've got an items view. We've got some mix-ins here as well,
69:59 - actually. So a good thing about this is a generic view set. Okay. So we've had an API view. We're
70:04 - now using a generic view set. Generic view set has built-in methods such as retrieve.
70:09 - What are they? Retrieve, list, create, update. I forget what they all are now. But by using the
70:18 - generic view set and some mix-ins, you get very, very similar to the generic views in Django,
70:24 - actually. A lot of the methods are all built-in. You don't need to do a lot of heavy lifting,
70:28 - especially when we're working with model serializers. Okay. You can see a good example
70:34 - of this. This is the item view. Okay. We've got no methods. We're just passing through permissions.
70:37 - Telling it what a query set is. We're telling it what serialize to use. By using those mix-ins,
70:46 - I've got a list endpoint, as in show all. And I've got a show and retrieve. So it's a get request
70:54 - for a single item. Okay. So we pass through the UUID or the ID of an item. You're retrieving one.
71:00 - Very powerful. Next, we've got an orders view set here. Similar, passing through everything. I can't
71:07 - remember if, actually, that's probably a hangover. So we're using the list and retrieve to get single
71:12 - orders. Okay. We're using this update one, which I don't think I'm actually using. We've probably
71:17 - got access to that URL, because that's what we're doing here. The view set, the generic view set,
71:22 - will give you access to methods, but it'll also construct those endpoints for you as well.
71:26 - On a API view, you need to add the as view method when you're wiring up the URL router. But with a
71:33 - generic view set, you do it slightly different. I'll show you in a second. Difference here is,
71:38 - again, permissions class. We've got a create method here. So this is what we're going to be calling
71:43 - when we create an order. Different to core is we're passing through to the serializer, the data.
71:52 - To the serializer, the data. Okay. If the serializer is valid, so we're going to call that,
71:58 - is there enough stock? If there is enough stock, we're not saving the serializer, because this is
72:03 - a model serializer linked to an order. We're not creating... We have to place an order. We're
72:10 - calling a place order method. So we're not necessarily just saving a serializer. We're
72:14 - doing it slightly different. We're calling a method in a model. So we're getting the item,
72:18 - specific item based on a PK, the primary key. And then we're calling the order place order method,
72:24 - which will create that order in the database. And then we respond with the... We pass through
72:29 - the new order that we've created to the order serializer and the data. So that's how we're
72:33 - sending the data back to the user. Okay. That's the view. Very simple, right? We now need a router.
72:41 - Go back in the models, doing all of this in URLConf. So we copy this, go into DRF course,
72:50 - go into URLConf, and we're going to add some bits. Okay. What are we doing? We're bringing
72:54 - in the views from e-commerce, and then we're wiring up these generic view sets different
73:01 - to the API view. Okay. We're putting as view here, same as a class space view in Django,
73:07 - very similar API view. These are different. These are generic view sets. So we're using RegEx.
73:14 - So it's a regular expression URL. E-commerce view. So this is the view set itself. Next,
73:20 - we haven't got as view at the end there. Base name is item and order. And then what we do,
73:25 - we're registering those to the router. The URL patterns become the URLs from the router.
73:31 - Remember, so although we're registering things to router, because we're using generic view sets
73:39 - and a whole bunch of other stuff, that router has a whole bunch of URLs. So we'll have a retrieve
73:47 - and a list and a get with a PK that are already built in just by registering this. So the URL
73:53 - patterns becomes vast. And then what we do is we append these three URLs to the URL patterns,
73:58 - and that becomes a whole bunch of URL patterns for the project. Okay.
74:05 - That's that. That's module seven. We are good to go. The reason I've stopped there is because
74:10 - we're going to be doing testing in module eight. It's the last piece. We'll be doing some unit
74:13 - testing and then we'll be testing those endpoints. Okay. So that, just make sure that your configuration
74:20 - is looking how mine does or looking at does in the modules and you'd be good to go.
74:23 - Right. Thank you very much for watching module eight next. Perfect. Right. Module eight,
74:33 - module eight and close some stuff. Open up module eight. Good. Before we start,
74:39 - make sure your configuration is exactly the same. If not, cloned down from GitHub,
74:43 - let's move on to the steps. So like in module four, when we done the testing for our core app,
74:50 - let's do it again for e-commerce, except this is a little bit more complicated.
74:57 - Doesn't need to be any more complicated. I won't go into a big deep dive because I've already
75:02 - spoken about the API client and test cases. So we're creating a client is a callable very
75:08 - much like the request package. So we're calling the API testing and adding it to a test database.
75:16 - Inheriting the API test case here. So we have a setup method. We're creating some dummy information
75:21 - similar to what I did in the admin page earlier, adding five items. We're creating a self items
75:28 - variable here, which is all of the items in the database. We're creating a user. Well, we know
75:35 - when we create a user, we're also creating a token. We're creating a couple of orders. Okay.
75:40 - Against the first item. That way we can call the order at any point. Token. So creating a token,
75:46 - we know that we've just created it. Yeah. So it's self token is for this user here.
75:50 - And then the client is API client. And then difference here is that on self client,
75:57 - we can call the credentials method and pass through the token. So we'll add a header to each and every
76:03 - call. Remember we've got permissions class in these views. So if we don't have that, we can call
76:08 - class in these views. So if we don't have this, we're going to hit a failure each time. So we're
76:12 - passing through the token. So now it will be written. It will be token space. So it'll be,
76:18 - it'll say authorization, and it will say a token space, and it will be the token key. Okay. And
76:24 - that'd be in the head of every call. And then we have how many? What have we got here?
76:28 - We've got a few, one, two, four, six, eight, 10, 10 ish, 10 test cases. So what we're doing,
76:41 - we are checking out what's in the database. We're expecting five, if there is happy days,
76:48 - we've got, we make a call to the item endpoint. Remember we've got a retrieve list or a list
76:55 - method. I'll bring back every item. So I'm making a call to it. We're expecting status 200. That's
77:02 - the first endpoint. Now we want to get each item. So what we're doing, we're going to cycle through
77:09 - all of the items. Now we're going to make five calls to the endpoint. You can do this differently,
77:13 - but this is just one way of doing it. So I'm calling the endpoint five times and I'm saying,
77:17 - right, get the item with PK from the item from the database. So item.id. We're expecting a 200
77:25 - because we know that they're there, right? So we're getting a response 200. Then we get,
77:31 - then we get a little bit complicated. So test order is more than stock. So we're now calling
77:35 - methods, right? So for items, so these are methods in the item database. So current stock
77:44 - is, so we're getting the current stock and then we're saying I check stock. So we're passing
77:50 - through. So make check that the order is more than stock. So we'd expect that to be false.
77:56 - We go through, I'm not going to go through each of these, but I'm basically testing every outcome
78:00 - for the endpoint. So have we got too much stock? We've not got enough stock. Does the stock equal
78:04 - the order? What happens if we don't send an item ID, something along those lines? Okay. So just
78:14 - going through, I mean, you can probably be a lot more thorough than this, but these are the tests
78:20 - that we've got. Modulate. Okay. So we can now go in here, go into Docker. I'm in API, which is
78:29 - correct. We've got that drop to manage.py testing that we're now 18 to 18 core 10 in e-commerce
78:38 - and expecting. There we go. Okay. All the tests work. This is where you want to be.
78:45 - Now let's go ahead and test some endpoints. I need module eight opened and this is how you'll
78:52 - probably need to do it as well. So I'll open up modulate without it being in preview mode.
79:00 - The reason being is because every place it says your name, I'm going to control H and change it to
79:10 - the username of the person in the database. I know it's Bobby. Can you change it? Can you change
79:16 - your password? Whenever you see your password, I'm going to change that to my password. So what
79:25 - we're doing here, I'm just creating the HTTP endpoints, your token. Every time I see your
79:31 - token, I'm going to change that to the token in the database, which is this one here, copy
79:39 - and change all the lows. And then you've got UUID for item. So you can see here,
79:52 - we're calling the item endpoint. So your UUID will be an ID that appears in the database.
79:59 - So we go into items, change this one, copy, not change that one. Oh, sorry.
80:16 - It's like, it's a little bit difficult when you're just doing a right. And then we get onto,
80:24 - after that we get onto orders. So we won't look at those yet. Okay, cool. So we go back and preview.
80:29 - I should now have those. Yeah, we do. Right. So spend some time going through these. So let's
80:35 - test all the endpoints there. So call our endpoints. Here are the requests we can make
80:39 - to our new endpoint. So we've got first, what I'll do, I'm going to keep going backwards and
80:48 - forwards, but we go to the app container, going to CLI. What we'll do, we will drop this in there.
80:56 - So we're calling the API auth to get a token. There we go. Token, it works. I'm going to zoom
81:06 - in each time. I know it's small. I do apologize, but at least you've got instructions. You've got
81:11 - the code. Next, we want to check and get all of the items. Remember, this is the domain. The
81:23 - endpoint is item. That is a retrieve all. We're getting all items in the database, providing we
81:28 - send through the token back into Docker, drop it in there. And I expect to see two items. We've
81:38 - got two in the database. Now what happens if I remove the header with the authentication token?
81:50 - There you go. Not authenticated. Perfect. That's exactly what we want to see. Next,
81:58 - we want to retrieve one item that we have in the database.
82:02 - There we go. Pass through the UID, and it gets a single retrieved one item. Well, so we got this,
82:13 - got retrieve all orders. Yeah, we can look at that one. Back to Docker, retrieve all orders.
82:25 - We've got two. We haven't got any orders in the database. Let's make an order, shall we? Your UID
82:34 - authentication. This will place an order for item ID. Sorry, I'm moving around on this. I probably
82:48 - should have looked right. If I change that, this will retrieve all orders. This will retrieve a
82:56 - single item. This will place an order for an item. Let's place an order for an item, shall we?
83:10 - Sorry, not handy when you're making a video. What is this doing? We're calling HTTP. We're
83:17 - calling the order endpoint. We're passing through an authentication token. Then we create an adjacent
83:23 - data type, and we send it through the ID of the item and a quantity. I know that we've got the
83:29 - stock of one. Let's copy that. We'll drop that in here. That will create an order. If I do that
83:38 - again and change the quantity to 1,000, I know we don't have a stock of 1,000. That should say
83:46 - there is not enough stock. Remember, we're validating that. If there's not enough stock,
83:51 - we're raising an exception. Brilliant. Now we can call the... I'm seeing the trouble with Docker.
83:58 - You can't press up and get your previous. Let's check all orders, and then I won't keep you on
84:05 - here any longer because you can do this in your own time. We should now see one order, right?
84:11 - There we go. Brilliant. That is exactly what I wanted to see. Just zoom in.
84:15 - Again, we added an order of one, remember, and retrieved it.
84:24 - I also showed you... Where is it? Where is it? Where is it? There we go.
84:32 - What I'll do, I'll create another order just quickly, and I'll create that with five.
84:38 - I believe we've got enough stock. There is. We will then get all of our orders with this one here.
84:47 - Copy, back in the Docker. Drop it in there. It should now have two. Perfect. That's exactly
84:53 - what I wanted to see. That is it. That is the end of the course. Let's just recap quickly. What have
85:02 - we done? We've gone through eight modules. The first two modules were all about getting the code,
85:08 - configuring a Django project, essentially. Nice and easy stuff. We have then created a core app
85:15 - with a contact endpoint, a normal model serializer, and we've just got a post request. We're using an
85:22 - API view, which is similar to a Django class view. Brilliant. We've then invoked or added
85:28 - token authentication to the project, created an e-commerce app with an item and an order endpoint
85:34 - with permission classes. Only those that have got an authentication approval can view, retrieve,
85:42 - create information. We have now created a very, very good, not production ready,
85:50 - API, but it's a good API that you can use and hopefully refactor and use it in your own project.
85:57 - Now, I'd just like to thank everyone for watching. If you like this content, then please visit Did
86:04 - Coding and you'll see many more videos like this on my channel. Like this video on FreeCodeCamp
86:10 - and add a comment because I do get to see those comments. Comments from previous courses on
86:14 - FreeCodeCamp really has led to me building some other courses and tutorials. Just before I do
86:21 - close the video out, I just would like to thank FreeCodeCamp one more time just for allowing me
86:26 - to create this course and for them to post it on their channel. Keep up the good work,
86:32 - keep that free content coming. Again, thank you very much and hopefully I'll be seeing you very,
86:38 - very soon. Bye-bye.