00:00 - hello free code cam friends my name is
00:03 - tobias and today i will guide you
00:05 - through a very important topic how to
00:07 - undo mistakes with git
00:10 - because i think this is really one of
00:12 - the core skills to master as a software
00:15 - developer how to undo mistakes how to
00:17 - deal with them and how to undo them
00:19 - because
00:20 - the beginner and the professional alike
00:22 - we all make mistakes but the
00:25 - professional knows how to deal with them
00:27 - and how to undo them
00:29 - so let's see how we can do that and how
00:31 - we can learn to better deal with
00:33 - mistakes
00:34 - but first a huge shout out to the people
00:37 - at free code camp for doing an awesome
00:40 - job of teaching people how to code for
00:42 - free and thanks for letting me help you
00:45 - with that mission
00:47 - a couple of words about me and about
00:50 - why i chose this
00:52 - very specific topic
00:54 - so
00:55 - one of the reasons is i am part of the
00:56 - team behind tower tower is a git desktop
01:01 - gui for mac and for windows and we've
01:04 - been around since
01:06 - 2011 and helped over
01:07 - 100 000 software developers all over the
01:10 - world in companies big and small
01:12 - let's say
01:13 - work more easily with the git version
01:15 - control system work more productively
01:17 - with git
01:18 - and today's workshop will mostly be on
01:22 - the command line get on the command line
01:23 - so you don't have to
01:25 - have tower installed don't worry
01:28 - and the reason why i chose this topic
01:31 - undoing mistakes
01:33 - is that sometimes i feel like that
01:35 - little man here in the middle of the
01:36 - lion cage
01:38 - there's so many things to do wrong
01:40 - there's so many things that can break in
01:42 - a complex software project today and
01:44 - things will break let's let's be honest
01:47 - they will break
01:48 - and this is what git is actually for git
01:51 - is our safety net git is therefore
01:54 - helping us undo things and
01:57 - recover from mistakes
01:59 - and the the thing that i noticed in
02:01 - talking to to other developers is that
02:04 - many of them don't know that git has
02:06 - these amazing capabilities to help you
02:10 - undo mistakes so i think that it's
02:13 - really really crucial to learn what git
02:15 - can do and how you can do that and
02:18 - that's what we
02:19 - will talk about today in this workshop
02:22 - i have 17 cases of how to mess up and to
02:26 - correct with me today
02:29 - and they'll get a little bit more
02:30 - complex towards the end so depending on
02:32 - your own level of gift knowledge you
02:35 - might want to concentrate on the first
02:37 - half little easier cases and and then
02:40 - the second half is more complicated so
02:42 - depending on your own level of of skills
02:46 - all right i would say let's dive in and
02:48 - start with the first very simple case
02:51 - so let's talk about how to discard local
02:54 - changes in a file so you made some
02:57 - changes in in a local file and haven't
03:00 - committed those changes yet and you
03:02 - notice well not the best work i want to
03:05 - undo those changes and get back the last
03:07 - committed version of that file let's see
03:10 - how we can do that
03:12 - so we have a couple of changes here
03:16 - so let's take a closer look at what we
03:18 - did with
03:20 - imprint html with git diff and the file
03:24 - name i can take a closer look at the
03:26 - changes that happened there and let's do
03:28 - that for imprint html
03:30 - okay so i changed the the title tag here
03:33 - and let's say this isn't what i really
03:35 - wanted and i want to undo that and get
03:37 - back to what i last committed
03:40 - and the command to use here is
03:43 - git
03:44 - restore and then the name of the file in
03:48 - print html
03:49 - in in the past you might have used git
03:52 - checkout to do that that's also possible
03:54 - of course but the git restore command a
03:57 - little bit newer you could say is a
03:59 - little bit clearer that the purpose is
04:02 - very limited of git restore so there's
04:05 - less ambiguity
04:07 - around that so git restore and the name
04:10 - of the file
04:11 - and let's see what that
04:13 - what that did get status voila imprint
04:16 - html is not amongst the changed files
04:19 - anymore so we undid that
04:23 - all right
04:25 - git restore and the file name
04:28 - along the the course of this little
04:30 - workshop you will see those yellow
04:32 - warning boxes on my slides and first
04:35 - case first warning box i'm very sorry
04:37 - but that's life
04:40 - in these first couple of cases we're
04:41 - talking about uncommitted local changes
04:44 - changes you have not committed to the
04:46 - git repository yet and the thing to keep
04:49 - in mind here is
04:51 - if you undo those if you discard those
04:54 - they're gone right you can't get those
04:56 - back so be a little bit careful with
04:58 - those and
05:00 - don't rush things
05:02 - all right number two
05:04 - similar but a little bit different
05:06 - here we didn't only make changes we also
05:09 - deleted a whole file and let's say we
05:12 - desperately want that file back and see
05:14 - how we can do that
05:16 - all right this is case number two sorry
05:22 - and again get status to see what we have
05:26 - okay so let's see that let's say that
05:28 - arrow html the deletion of that file
05:31 - wasn't our best move so to get that back
05:34 - the good news is it's the exact same
05:38 - command as before git restore and the
05:41 - name of the file and if i do that
05:44 - get status so it's not listed as a
05:46 - changed file anymore wonderful and let's
05:49 - really make sure
05:52 - voila here it is back again as a
05:54 - physical file in my working copy on my
05:57 - disk so we brought that back from the
06:00 - dead
06:03 - all right again git restore and the file
06:06 - name of the file you have deleted and
06:08 - went back
06:10 - number three let's get a little bit more
06:12 - granular and maybe more interesting
06:15 - sometimes not all of the changes that we
06:17 - made in a file are bad right sometimes
06:19 - we have good days or mixed days and not
06:22 - everything
06:24 - is bad and we don't want to throw away
06:26 - we don't want to discard everything just
06:29 - parts of our changes and we want to keep
06:31 - other parts of the changes and this is
06:33 - possible with git so let's look at let's
06:35 - look at how to do that in practice
06:39 - number three
06:41 - and
06:42 - let's take a look at what we did with
06:45 - index.html
06:47 - and you'll see we have two chunks of
06:49 - changes here so in the first chunk i
06:51 - manipulated a list i added some list
06:54 - items to to an unordered list and in the
06:58 - second
06:58 - chunk here i manipulated
07:01 - a link
07:02 - so let's say the first one is genius
07:05 - work and the second one is bad we want
07:08 - to keep the first one and get rid of the
07:11 - second part of the changes right
07:13 - so bonus points if you can guess the
07:16 - command yes it's git restore again but
07:20 - this time the secret sauce is dash p
07:24 - to go down to the patch level and talk
07:27 - about individual patches or chunks hunks
07:30 - of changes and i think we wanted to do
07:33 - that with index html
07:35 - and let's do that
07:37 - so git now steps through every chunk or
07:41 - hunk of changes together with us and
07:44 - asks us a simple question down at the
07:47 - bottom do you want to discard this hunk
07:49 - from the work tree don't ask me what all
07:52 - of the letters and options mean i do not
07:54 - know i want to sleep at night but it's a
07:56 - simple question do we want to discard it
07:58 - yes or no that's the most simple
08:01 - possibilities and i think we said we
08:03 - want to keep the first one so i don't
08:05 - want to discard this no
08:08 - but the second one i want to get rid of
08:10 - so yes discard this
08:13 - all right let's see what we have
08:17 - so this is tower this is the graphical
08:20 - user interface for git that we
08:22 - make and we work on index html wonderful
08:25 - so that the second part of the changes
08:27 - the second chunk is gone we discarded
08:30 - that but we kept the first chunk alive
08:35 - you can also go
08:37 - one level more granular you can also do
08:40 - the thing that i just did on the command
08:42 - line here in a graphical user interface
08:44 - you can just discard individual chunks
08:47 - but you can go one level deeper you can
08:49 - say okay
08:52 - these two lines here i want to discard
08:54 - these two lines in the chunk but the
08:56 - rest of the chunk should remain intact
08:59 - so you can really be very granular when
09:02 - discarding changes
09:04 - voila or even
09:06 - when you want to stage things for the
09:08 - next commit when you want to add changes
09:11 - for the next commit that's staging and i
09:14 - can say this line here number 17 is
09:18 - part of the next commit but the other
09:20 - line is not
09:22 - so this helps you produce very very
09:25 - granular commits and
09:27 - when you begin working or thinking about
09:29 - that you might say well this is over the
09:31 - top
09:32 - i think it is not i think it really is
09:34 - very helpful because there's a one big
09:38 - general golden rule in version control
09:41 - and that is
09:42 - to commit semantically to commit only
09:45 - topics in one commit that belong to the
09:49 - same overall topic right not to mix
09:52 - different topics in the same commit this
09:55 - is very important and when you want to
09:57 - work in that way
10:00 - working with changes in such a granular
10:02 - way discarding chunks or even lines and
10:05 - staging lines and chunks becomes very
10:07 - very useful and and helpful
10:11 - all right
10:13 - git restore again but this time with the
10:16 - dash p flag
10:20 - so
10:22 - enough sweet talk let's put out the big
10:25 - guns
10:26 - and we want to do undo everything we did
10:29 - since we last committed right this is
10:31 - for the the bad days or for the bad
10:34 - weeks maybe
10:35 - when you when you notice you've
10:37 - programmed yourself into a dead end
10:39 - and you really want to start over you
10:41 - want to get back to the last committed
10:43 - state and start over undo everything and
10:46 - let's see how we can do that in git
10:50 - all right this is case number four
10:54 - and let's see what we have
10:56 - so again a couple of changes in our
10:59 - local working copy here and let's say we
11:02 - really want to undo all of them and get
11:04 - a clean working copy
11:07 - this is again git restore but this time
11:09 - with the dot operator to say well
11:13 - everything in this
11:14 - location should be undone right if i do
11:18 - that
11:19 - and type git status once more
11:22 - voila nothing to commit working tree
11:23 - clean that's what we wanted to have
11:26 - um again please be careful with this
11:29 - command
11:30 - you are still working on
11:32 - uncommitted local changes and if you
11:34 - undo them
11:36 - they're really gone so be a little bit
11:38 - careful with those okay
11:41 - good number
11:43 - five
11:45 - so far from number one to number four we
11:48 - worked on those local changes
11:49 - uncommitted local changes and for the
11:51 - remainder of the workshop we're going to
11:53 - work with committed data right we are
11:56 - going to manipulate
11:58 - committed history
12:01 - so
12:01 - this is a totally different area of the
12:04 - workshop and a total different area of
12:06 - use cases and let's start with something
12:08 - very simple again
12:10 - fixing the very last commit because it's
12:13 - very very common to mistype your commit
12:15 - message or to simply forget
12:18 - to add a certain change
12:20 - this is something that can be done very
12:22 - easily fixing the last commit in git
12:26 - all right
12:27 - number five
12:30 - and let's see what we have
12:32 - okay
12:33 - so
12:34 - this is the very last commit here and
12:37 - you can see well a couple of typos in
12:39 - the commit message we should really fix
12:42 - that
12:43 - and let's do that quickly
12:46 - so on the command line you can use git
12:49 - commit dash dash amend that's the the
12:52 - crucial part and
12:54 - with dash m i can provide a new commit
12:57 - message and hopefully this time a better
13:00 - one typos are indeed
13:03 - embarrassing don't mistype embarrassing
13:06 - that's embarrassing no looks good okay
13:11 - and let's see what happened
13:13 - and voila you might have seen it flicker
13:16 - this very last commit has now been
13:18 - corrected with the commit message that
13:21 - we provided with a new commit message so
13:23 - we fixed that
13:25 - the other
13:27 - type of problem let's say that you can
13:29 - have with the very
13:31 - last commit is that you forgot to add a
13:33 - change that should actually be part of
13:35 - that commit
13:36 - and changing that is actually pretty
13:38 - easy
13:39 - you can simply add that to the staging
13:42 - area that forgotten change and then
13:44 - simply say amend again it's the same
13:47 - thing on the command line and then click
13:50 - amend here and you'll see voila index
13:54 - html is now part of that change set two
13:57 - right
13:58 - um
13:59 - little yellow warning box again
14:03 - so
14:03 - amend is one of those commands that
14:05 - rewrites history as i said many of the
14:08 - the things that we're going to talk
14:10 - about we'll do that we'll rewrite
14:12 - history and this is a prime example
14:15 - and you should keep one rule in mind
14:18 - that will keep you happy and maintain
14:21 - your friendships amongst your colleagues
14:22 - and guarantee a long developer life
14:25 - do not change
14:27 - commit history of things that you have
14:29 - already pushed that you have already
14:31 - shared
14:32 - on a remote branch this is very
14:34 - important because if you do so then
14:38 - the same history the re-written history
14:41 - will be pushed again and that's gonna
14:43 - cause trouble for your colleagues who
14:45 - may have based their work on those old
14:47 - commits so never
14:50 - change history for commits that have
14:51 - already been pushed
14:53 - i'll show you what i mean by rewrite
14:56 - history to make that a little bit
14:57 - clearer i think that's that's helpful to
14:59 - understand
15:00 - so at the moment this very last commit
15:02 - has a
15:04 - commit hash of one two three five f d
15:07 - nine a something like that
15:09 - if i do another amend i can do that as
15:11 - long as i want to
15:12 - are indeed very embarrassing
15:15 - amend
15:17 - let's take another look
15:19 - and voila you saw that the the commit
15:21 - hash changed
15:23 - so git is not able to somehow magically
15:26 - open that commit in the background and
15:28 - then exchange something and then close
15:30 - it again what happens in the background
15:33 - is that a completely new commit object
15:36 - is created and swapped swaps out the the
15:40 - old one right so the the old one is
15:42 - replaced with a new one and this is what
15:45 - rewriting history means there there are
15:47 - really new commits that are exchanged in
15:49 - the background
15:52 - okay
15:54 - number six
15:56 - reverting a commit in the middle so
15:58 - let's start with the good news here
16:01 - c2 here is the bad guy but everything
16:04 - that came before that or after that is
16:06 - absolutely fine we don't want to throw
16:09 - away everything we just want to undo
16:11 - c2 that commit here in the middle
16:14 - and revert has uh quite an a
16:18 - non-destructive way let's say like that
16:19 - a non-destructive way of of doing that
16:22 - revert does not go ahead and rip out c2
16:26 - and throw it away
16:27 - instead it creates a new commit c4 here
16:30 - in this little example here it creates a
16:33 - new commit that contains the opposite
16:36 - changes and that's how it undoes
16:39 - the problem you had in that original
16:41 - commit so if you look at that
16:43 - silly example here
16:45 - in the old commit i changed about this
16:47 - project into about and git is clever
16:49 - enough to understand okay if i uh
16:52 - introduce opposite changes i will undo
16:55 - the effects of that old commit
16:57 - pretty clever and very um
17:00 - very safe let's say like that
17:03 - okay so
17:05 - let's do this
17:07 - on the command line
17:11 - and first of all let's have a look at
17:14 - what we could undo
17:16 - or revert in that case let's say we want
17:19 - to revert this one here right so if i
17:22 - take a look at the change set here
17:25 - i can see that i changed about into
17:28 - about this project so i'm going to
17:30 - expect
17:31 - the opposite changes when i do a revert
17:33 - on that commit right
17:35 - okay so to revert this one i have to
17:38 - remember the commit hash up here i'll
17:40 - copy that to the clipboard
17:42 - and then on the
17:45 - command line i can just type git revert
17:47 - and the hash of the commit that i want
17:49 - to undo
17:51 - that's actually it
17:54 - and i'm getting an editor window here
17:57 - why is that
17:58 - because as i said we are creating a new
18:01 - commit that reverts the old changes and
18:04 - creating a new commit means there's a
18:06 - new commit message that i could provide
18:08 - and this is the commit message that i
18:10 - could add i'll go with what git support
18:13 - suggests here in this case that's
18:15 - wonderful because it's very very clear
18:18 - we revert this commit here with
18:21 - this commit hash that's that's wonderful
18:24 - i'll take that save and close
18:26 - and take another look at tower and see
18:29 - voila we have a new commit
18:32 - that undoes this one here
18:35 - by introducing the opposite changes
18:39 - very practical
18:41 - all right
18:43 - number
18:45 - seven get revert and the commit hash
18:48 - number seven is a little bit different
18:50 - because here everything that came after
18:52 - c2 is actually bad so we really want to
18:55 - turn back time and go back to c2 and
18:58 - forget everything that came afterwards
19:01 - delete in air quotes delete everything
19:03 - that came afterwards and this is a case
19:05 - for the reset command
19:09 - so let's see how we can do that
19:14 - and again let's see what we want to do
19:19 - and let's say we want to return to this
19:21 - point in time here to this commit here
19:23 - and forget everything that came
19:25 - afterwards so we want to undo
19:27 - delete remove however you want to put it
19:30 - these commits that came later
19:32 - again i need to remember the the commit
19:34 - hash
19:36 - to which i want to return this one here
19:40 - and on the command line i can write git
19:42 - reset dash dash hard i'll explain the
19:45 - the um the option in a second and then
19:48 - the hash of the commit that we want to
19:51 - return to
19:53 - hola
19:54 - let's see
19:56 - okay you just saw it flicker maybe
19:58 - the newer commits disappeared and we're
20:01 - now back at this commit
20:04 - at a previous state in time
20:07 - um you saw me use dash dash hard on the
20:09 - command line so if there's desktop hard
20:12 - there might be other options that's true
20:14 - there's hard there's keep there's mix
20:16 - there is
20:18 - soft i think i i can never remember all
20:21 - of the the options you live a happy life
20:24 - with hard and mixed so you've seen hard
20:27 - hard means no local changes should
20:30 - survive you really want to have a clean
20:33 - working copy mixed is a little bit
20:35 - different let's let's see mixed
20:38 - so the scenario here is the same i
20:40 - prepared the same scenario twice so we
20:42 - will go to this revision here
20:45 - but this time using mixed and the
20:47 - difference is
20:49 - mixed keeps
20:51 - the local changes or the changes
20:53 - contained in the commits that we're
20:55 - going to undo as local changes so these
20:58 - two commits here will be undone but they
21:00 - have a change set of course they have
21:03 - changes that are contained in in those
21:05 - commits and with
21:08 - using mixed we'll do that here
21:11 - reset
21:12 - in tower we call it keep changes on the
21:14 - command line it would be mixed that's
21:17 - the same thing
21:18 - if we do that
21:20 - voila we return to that revision but
21:23 - we also keep the changes that are
21:26 - contained in those removed revisions as
21:29 - local changes and you can hop into your
21:31 - editor make some changes discard things
21:34 - add things you're a little bit more
21:35 - flexible with mixed i would say
21:40 - okay
21:42 - number seven git reset dash hard and
21:45 - dash mixed
21:48 - number eight so far we've mostly worked
21:50 - on the complete project or incomplete
21:52 - revisions and this time i want to work
21:55 - on just a single file sometimes you have
21:58 - the situation that you know a certain
22:00 - file was good at some point but it's not
22:04 - in in the current version and you want
22:06 - to return time or turn back time for
22:09 - just a single file not for the whole
22:10 - project not for the whole
22:13 - history just for a specific file and you
22:16 - can do that with kit and let's see how
22:18 - we can do that
22:20 - and this is number
22:24 - eight
22:27 - and let's take a look at the scenario
22:29 - okay
22:30 - so in tower we have a quite a practical
22:32 - um
22:34 - feature called the
22:35 - file history so i can just right click
22:38 - any file and say show me the files
22:40 - history this shows you
22:42 - only the changes for that particular
22:46 - file so you can very easily see how a
22:48 - specific file evolved over time and so
22:51 - we're doing that for index html let's
22:53 - say we only want to
22:56 - return to this revision for index.html
22:59 - right this is the state of index html
23:02 - that we want to have in our project
23:04 - again
23:05 - so i'm going to copy the
23:07 - hash here again
23:10 - and on the command line
23:12 - you could guess it's restore yeah git
23:16 - git restore
23:17 - the source parameter the source is the
23:20 - revision hash that i just copied and we
23:22 - want to do that with index.html
23:26 - voila and if i do that let's see what
23:28 - happened
23:30 - in the working copy i now have changes
23:33 - that bring back
23:35 - that version of index.html this is these
23:40 - are the changes that bring back that old
23:42 - version of the file again
23:46 - all right
23:48 - git restore
23:50 - source and you tell get from what source
23:54 - revision you want to restore which file
24:00 - all right for the next two cases i think
24:02 - we're going to use a very specific
24:04 - git tool
24:05 - called the ref log the reflog you can
24:08 - think of uh somehow like like git's
24:10 - diary i would say a journal where we get
24:13 - protocols every movement of the head
24:16 - pointer so what's a movement of the head
24:18 - pointer you might ask so this is when
24:20 - you commit when you check out when you
24:22 - reset when you cherry pick when you
24:24 - rebase
24:26 - actually all of the more important
24:29 - actions are protocoled in this journal
24:32 - and this of course makes it perfect for
24:34 - undoing mistakes
24:36 - and let's see what we can do with the
24:38 - refloc for example this here
24:40 - think back two cases i think number
24:42 - seven
24:43 - we did a reset right we rolled back to a
24:46 - specific
24:47 - older revision
24:49 - and
24:50 - did that with the reset command and then
24:52 - sometimes numbers three and four follow
24:55 - you sometimes notice oh damn i shouldn't
24:57 - have done that that was the wrong move
25:00 - and then the panic emoji con often
25:02 - follows and let's see if we can use
25:04 - reflog to undo that and to get back
25:07 - those seemingly lost commits right
25:10 - that's the thing we want to do
25:13 - okay
25:16 - number nine
25:22 - okay so let's say again we want to
25:25 - return to this revision here and by
25:28 - doing that
25:29 - these newer commits here will disappear
25:31 - will get deleted in air quotes
25:34 - so again a reset
25:38 - we don't need to keep changes
25:41 - and boom
25:42 - everything newer is now gone and i'll
25:46 - give you a second or two to notice oh
25:48 - damn
25:49 - we shouldn't have done that and we we
25:51 - dearly miss our commits already and
25:53 - let's see if we can use the reflux to
25:54 - get them back
25:57 - so get refloc to open up the the journal
26:00 - that i just talked about and it's it's
26:03 - ordered chronologically so the most
26:06 - recent
26:07 - actions are at the top and if you look
26:09 - at the topmost item you see okay there's
26:11 - a reset and we just did that 20 seconds
26:14 - ago or 10 seconds ago so the journal
26:17 - works
26:18 - and if we want to undo that the good
26:20 - news is we can just use the state before
26:23 - and restore that one so i'll just copy
26:25 - this here to the clipboard
26:28 - and then i could totally use git reset
26:32 - once more that's possible but i prefer
26:36 - to
26:36 - create a new branch
26:38 - let's call that happy ending and let's
26:41 - start that branch at that revision
26:44 - before we
26:46 - did that mistake
26:48 - and let's see what happened
26:50 - okay happy ending voila here are the
26:53 - commits that we thought we had just lost
26:56 - wonderful we saved the day i think
26:59 - um the refloc if any tower users are
27:02 - amongst you
27:03 - the reflux is also part of the newer
27:05 - versions of tower if you don't see it in
27:07 - your version
27:08 - probably you don't you haven't activated
27:10 - it yet
27:11 - you can activate that in the preferences
27:15 - here
27:16 - show reflog in the sidebar because it's
27:20 - some kind of a an advanced feature not
27:22 - everybody needs it but if you want to
27:24 - have it you can activate it and you can
27:27 - have the different branches sorted and
27:31 - a great tool so you can see what
27:33 - happened in your git repository
27:38 - all right that was
27:40 - recovering deleted commits with the ref
27:43 - log
27:43 - and you can also do other things with
27:46 - the ref log for example this here
27:48 - recovering a deleted branch for example
27:52 - so
27:53 - let's say you have worked on a feature
27:55 - branch for some time and
27:57 - your team
27:59 - lead or your boss or customer says you
28:02 - don't need that feature anymore so to
28:04 - tidy up you delete that
28:06 - and again numbers three and four
28:09 - sometimes follow
28:10 - the feature is not out of the picture
28:13 - just yet and it returns and you notice
28:16 - it was a bad idea deleting that and the
28:18 - panic emoji follows let's see how we can
28:22 - undo that with git
28:26 - and this is case number
28:29 - 10
28:34 - all right
28:36 - so at the moment we have a beautiful
28:38 - feature login branch that also contains
28:41 - a commit that is present nowhere else so
28:44 - we are going to delete this branch in a
28:46 - second and we're really going to
28:48 - delete data right this commit is present
28:51 - nowhere else so we're losing data right
28:53 - now
28:54 - we'll go on
28:56 - the first thing i have to do is step
28:58 - away from this branch because currently
29:00 - this is the head branch and i can't
29:02 - delete the current branch so i'll double
29:04 - click master to check it out
29:06 - and then right click feature login and
29:09 - say delete
29:11 - i have to force deletion because it
29:13 - contains data that is present nowhere
29:15 - else
29:16 - and
29:17 - voila
29:18 - okay so
29:20 - boom panic
29:22 - we noticed that this actually wasn't a
29:24 - good idea and we need that branch back
29:26 - and let's see how we can do that with
29:28 - the refloc
29:30 - again git reflog
29:32 - and you notice the most recent item here
29:35 - is the checkout that we just did before
29:38 - deleting that branch and that's of
29:40 - course our lucky day because we can just
29:43 - return to the state before again
29:46 - and restore this one to undo what we
29:49 - just did
29:51 - and in this case of course get branch
29:54 - for creating a new branch makes a lot of
29:56 - sense and i think it was called feature
29:59 - login if i'm right and again it should
30:02 - start at the
30:03 - state before
30:04 - the state we just
30:06 - thought we had lost
30:08 - okay
30:11 - feature login seems to be back
30:13 - and including that seemingly lost commit
30:17 - so we just undid that and saved that
30:20 - valuable part of our work
30:23 - one thing i want to show you in tower um
30:27 - since i don't know
30:28 - a couple of versions ago we introduced a
30:30 - very very helpful feature um
30:33 - connected to undoing things when you
30:36 - want to undo something in your text
30:37 - editor you can just
30:39 - hit command z right it's as easy as that
30:42 - and we implemented that for git
30:45 - so if i just delete that once more
30:48 - delete feature login
30:50 - force delete
30:52 - and then hit command z
30:54 - voila the branch is back and this works
30:56 - for deleting branches for deleting
30:58 - commits
30:59 - for
31:00 - staging unstaging discarding changes
31:03 - from making resets for almost anything
31:05 - so you don't have to actually know the
31:08 - different commands that you need to undo
31:10 - things you just need to type command z
31:13 - and that's it very very powerful very
31:16 - practical
31:19 - all right
31:20 - git reflux again
31:22 - and let's move on to number 11
31:24 - moving a commit to a new branch
31:27 - so the problem here is that we have
31:29 - committed to the wrong branch and many
31:32 - teams have a convention that says you
31:34 - shouldn't commit to a long-running
31:37 - branch like master or develop
31:40 - those branches should only receive
31:42 - commits by integration right by merging
31:44 - or rebasing not directly committing to
31:47 - them
31:48 - but still we do because well
31:50 - we mess up we're on that branch and we
31:53 - type git commit and then it has happened
31:55 - actually in this case we should have
31:58 - created a separate feature branch a new
32:00 - feature branch and committed there and
32:02 - let's see if we can clean up the
32:04 - scenario so that it looks like that like
32:07 - it should look
32:09 - okay
32:13 - and let's see what we have
32:16 - okay
32:17 - so
32:18 - the very last commit on master is
32:21 - start new login feature and of course
32:24 - that smells that should have been the
32:26 - new feature branch that i just talked
32:28 - about
32:29 - and the good news is
32:31 - master already has the state that our
32:34 - new feature brand should have so we can
32:36 - just use that as a basis
32:39 - to create a new branch feature
32:43 - login
32:43 - [Music]
32:45 - and voila so now we have that feature
32:48 - branch feature login that contains that
32:50 - commit everything is okay on on that
32:53 - branch but the second part of that
32:55 - solution is of course
32:56 - to clean up master because master is
32:58 - currently in a dirty state it shouldn't
33:00 - contain that commit
33:02 - this last one here so let's move back to
33:05 - master check it out double click
33:08 - and then simply make a reset
33:12 - don't need to keep changes
33:14 - and voila
33:17 - master is now clean
33:18 - that commit that shouldn't have been
33:20 - there here is not here anymore and
33:23 - feature login has the correct state so
33:27 - nobody will ever find out you keep a
33:29 - wonderful reputation amongst your
33:31 - colleagues
33:34 - on the command line
33:36 - you create that feature branch get
33:38 - branch feature login and then you clean
33:41 - up master by using git reset
33:44 - head tilde one means one behind the head
33:47 - so you don't have to copy the the commit
33:49 - hashes all the time
33:51 - and we're doing that with the
33:52 - heart option
33:55 - all right number 12
33:56 - looks similar but it's a little bit
33:58 - different the problem is the same we
34:00 - committed on the wrong branch but this
34:03 - time the feature branch is already
34:06 - present right we don't have to create
34:09 - that feature branch it's already there
34:11 - we just
34:12 - just in our quotes have to move over
34:15 - that commit to its correct branch and
34:17 - then clean up let's see how we can do
34:19 - that
34:22 - all right this is number 12.
34:29 - and let's take a look at the scenario
34:31 - okay
34:32 - so on master the latest commit reads
34:35 - newsletter sign up page okay while we
34:38 - are having a feature newsletter branch
34:41 - so my suggestion is this commit should
34:45 - have been here and not on master right
34:48 - so to do that let's move over to feature
34:51 - newsletter
34:53 - and then
34:54 - cherry pick that's a new tool we haven't
34:56 - used yet use cherry pick to move over
34:59 - that commit
35:01 - right cherry pick
35:04 - and voila feature newsletter now
35:06 - contains that commit like it should have
35:08 - been in the first place
35:10 - and master still has that so again like
35:14 - in the case before we have to clean up
35:16 - we just reset to that state before well
35:18 - we have to check that out
35:22 - we reset to the state before
35:26 - voila master is clean
35:29 - the the commit that should have never
35:31 - been there is not there anymore and
35:34 - feature newsletter contains the commit
35:36 - that we moved over using cherry pick
35:40 - on the command line a little bit more to
35:42 - do
35:43 - get checkout to move to that feature
35:45 - branch then get cherry pick to move that
35:47 - commit over
35:48 - go back to master and then again cleanup
35:51 - master using git reset
35:54 - hard
35:57 - all right for the last
35:59 - i think five cases we're going to use
36:02 - interactive rebase
36:04 - by some called the swiss army knife of
36:07 - git tools which i find quite fitting
36:09 - because a swiss army knife has lots of
36:11 - different tools but it's still a knife
36:13 - so you could theoretically cut yourself
36:16 - a little bit
36:17 - if you keep that golden rule
36:20 - in mind to not change commit history
36:24 - that has already been pushed then you're
36:26 - fine so many of the the the tools that
36:29 - we have talked about and that we will
36:31 - talk about are there for a very specific
36:34 - use case that will help you clean up
36:37 - your local commit history before you
36:40 - merge that back into a team branch right
36:42 - so you've worked on a feature branch for
36:44 - some time and you could do some cleanup
36:47 - let's say and you can use all of the
36:49 - tools that i just showed you and that
36:50 - i'm going to show you to do that cleanup
36:53 - and then move it back integrate it merge
36:56 - it into a master or develop or a shared
36:59 - branch and push it
37:01 - so interactive rebase what can you do
37:03 - with that you can
37:05 - edit old commit messages delete commits
37:08 - uh combine multiple commits to into one
37:12 - split commits a lot of different things
37:14 - and
37:15 - let's start with very simple case let's
37:17 - edit an old commit message to to show
37:20 - you how interactive rebase works
37:23 - so you might say well we've done that
37:25 - tobias in case number five if i'm right
37:28 - we've edited an old commit message then
37:30 - back then it was
37:32 - the very last commit and that's pretty
37:34 - easy you can use git commit amend for
37:36 - that case
37:38 - but if we're talking about something
37:39 - further back in the commit history amend
37:42 - is not available anymore you have to use
37:45 - interactive rebase to do that
37:47 - and since this this is quite an easy
37:49 - case it's perfect to illustrate how
37:52 - interactive rebase works in general
37:55 - so
37:56 - very generally speaking you have three
37:58 - big steps with every interactive rebase
38:01 - session the first is you have to ask
38:04 - yourself how far back in time in history
38:08 - do i want to go what should be the new
38:10 - base commit what part of commit history
38:13 - do i want to manipulate
38:16 - and then you actually start the
38:17 - interactive rebase session that's step
38:19 - number two
38:21 - and then you will see an editor window
38:23 - where you can determine which actions
38:25 - you want to perform and i'll have some
38:27 - comments on that uh when we see that in
38:30 - practice and let's i'd say we check that
38:33 - out in practice and then discuss things
38:35 - a little bit more
38:37 - okay
38:39 - number 13
38:44 - and let's see what commit we could
38:47 - change
38:49 - so let's say we want to change the
38:50 - commit message of this old commit here
38:53 - again remember if it had been this one
38:56 - no problem git commit amend wonderful
38:59 - but anything older than that we need
39:01 - interactive rebase for so
39:03 - first step in interactive rebase how far
39:06 - back in history in time do i want to go
39:09 - i could either
39:11 - copy the the commit hash or do a little
39:13 - bit of counting
39:14 - the answer is at least to the parent
39:18 - commit of the one that i want to change
39:20 - right at least to the parent commit so
39:22 - either i copy this commit hash or say
39:25 - head minus one minus two minus 3
39:29 - and let's start
39:31 - git rebase interactive head tilde 3 we
39:36 - said n minus 3
39:37 - and let's
39:39 - start
39:40 - voila this is the editor window that i
39:43 - mentioned
39:44 - two
39:46 - notes about this editor window first
39:49 - the order of commits seems reversed
39:52 - right so if you take a look at the the
39:55 - bottom most improved headline for
39:57 - imprint that's actually the top most
40:00 - here in the real history don't be
40:02 - confused by that that's okay
40:04 - from git's perspective we're doing an
40:07 - interactive rebase and git has to
40:09 - reapply the old commits step by step so
40:13 - the reversed order is okay
40:15 - the second note here is
40:17 - we do not go ahead and make our changes
40:21 - we do not
40:22 - change the commit history the commit
40:24 - message right here but we only
40:28 - mark up what we want to do with that
40:30 - commit and in in this case we want to
40:33 - reword reword is documented here use the
40:36 - commit but edit the commit message we
40:38 - want to edit the commit message
40:40 - so save and close after marking that
40:44 - line with reword save close
40:47 - and now finally
40:50 - i can really edit the commit message now
40:53 - is the time to make my changes optimize
40:57 - the general markup structure in index
41:01 - page
41:02 - close save and close
41:05 - and if we take a look at
41:07 - tower we will see wow here it is now it
41:10 - says optimize the general markup
41:13 - structure in index page
41:15 - so we just manipulated history although
41:17 - just git history but
41:19 - a very special
41:21 - case here
41:24 - all right
41:26 - get rebased to edit an old commit
41:29 - message you can also use git rebase to
41:32 - delete an old commit
41:34 - so
41:37 - sometimes not often probably but
41:39 - sometimes you really have a commit that
41:40 - shouldn't have been there at all
41:43 - and interactive rebase allows you to
41:45 - really delete that from the history
41:48 - let's see how we can do that in practice
41:52 - that's number 14.
41:58 - and let's see what we can delete um
42:02 - well let's say we want to delete this
42:04 - one right
42:05 - so again it's still an interactive
42:07 - rebase session so first step how far
42:10 - back in history do i do i need to go at
42:12 - least the parent commit so either copy
42:15 - this one here or
42:16 - head minus one minus two
42:20 - git rebase dash interactive head
42:24 - tilt d2
42:26 - and
42:28 - voila the editor is back and we said we
42:31 - wanted to delete this one here and i can
42:34 - mark this with drop drop is the action
42:38 - keyword for deleting a commit
42:40 - you could also that's the exception from
42:42 - the rule you could really just delete
42:44 - that line it's an editor right you can
42:46 - manipulate the text here you can delete
42:48 - that line and save and close that will
42:50 - also remove the commit that's also okay
42:53 - but i think it's it's better to stick to
42:55 - the official way of doing things and to
42:59 - properly mark up the line with what you
43:02 - want to do to it
43:03 - so drop save and close
43:07 - and if we take a look at the history
43:08 - voila you just saw it flicker
43:11 - the commit was removed was deleted from
43:13 - the history that's possible with
43:15 - interactive rebase
43:20 - number 15 you can also squash multiple
43:23 - odes commit into old commits into one so
43:28 - in general the the rule in in version
43:30 - control is to commit granularly and
43:33 - rather smaller than bigger but sometimes
43:35 - you might have overdone that let's say
43:38 - and you want to combine multiple commits
43:40 - into one and that's also possible with
43:42 - interactive rebase and git
43:46 - all right number 15
43:52 - and let's see what we can combine
43:55 - and i would say let's combine these
43:58 - fellas here right these two should be
44:00 - one
44:01 - melted into one and again it's
44:03 - interactive rebase so we have to do the
44:06 - little counting game so at least the
44:08 - parent commit
44:10 - so this is ahead minus one two three
44:14 - and
44:15 - let's start that git rebase
44:18 - dash interactive head
44:21 - till d3
44:24 - and voila
44:26 - so we said we want to combine these two
44:29 - commits right
44:30 - and the the tool we're going to use here
44:33 - is squash squash is there to
44:36 - meld
44:37 - combine multiple commits into one and
44:40 - the one thing you have to know about
44:42 - squash to use it is
44:43 - the line i am
44:46 - marking up
44:47 - will be combined with the line before
44:50 - the line above so by marking up line
44:52 - number two i will combine it with line
44:55 - number one and that's what we want so
44:57 - let's
44:58 - save and close
45:01 - and again i do get an editor window why
45:03 - is that
45:04 - that
45:05 - by melting those two commits into one a
45:09 - new commit is going to be created and a
45:11 - new commit means i can provide a new
45:13 - commit message so combine two into one
45:17 - i'll leave the the old commit messages
45:19 - here just just in there for us as an
45:22 - overview
45:24 - i could of cour of course change that
45:26 - too
45:27 - and
45:30 - voila here we go we have combined the
45:33 - change sets of course and provided a new
45:35 - commit message here so we combine two
45:38 - old commits into one new one
45:41 - pretty awesome
45:43 - again a note about how to do that in
45:45 - tower it's pretty easy to do things like
45:47 - these in tower you can just
45:49 - drag and drop and this will be a squash
45:53 - right you will combine that
45:55 - very easy
45:58 - so
46:00 - number 16 second to last and actually my
46:03 - my favorite case
46:05 - because it's very very very practical so
46:08 - the scenario is number one
46:11 - we made a mistake it doesn't matter what
46:14 - it is we could have forgotten to add
46:17 - something we should have deleted
46:18 - something we mistyped something it
46:21 - doesn't matter a mistake right
46:23 - and the the normal reaction number two
46:26 - is to add our corrections in a new
46:29 - commit right
46:30 - that's that's just normal that's that's
46:33 - okay the problem with this approach is
46:36 - we have that original commit c2 and we
46:38 - have a correcting commit a band-aid
46:41 - commit c4 right and if you do that a
46:44 - couple of times
46:45 - original band-aid original band-aid your
46:49 - commit history becomes unreadable
46:51 - because nobody understands okay why is
46:54 - that commit here shouldn't have that
46:56 - been here and you have lots of commits
46:59 - and and no semantics actually that
47:02 - band-aid commit doesn't have any
47:04 - semantic meaning it's just there to fix
47:07 - an earlier mistake right and the beauty
47:09 - of the tool we're going to use here
47:12 - which is called fix up the beauty is
47:14 - that we're going to use that band-aid
47:17 - commit apply it to the original one
47:21 - and the band-aid gets thrown away right
47:23 - that mt commit that non-semantical
47:26 - commit that newer one that fix up commit
47:29 - is
47:29 - disposed and the original commit appears
47:33 - to be perfect from the start
47:36 - very beautiful all right
47:39 - enough talk let's do this um
47:44 - and let's see what we have
47:47 - okay so
47:49 - let's say that
47:51 - this commit here is not complete right
47:53 - we made a mistake here and let's also
47:56 - see say that what i prepared here
47:58 - changes in error html would fix that
48:01 - mistake right at the moment error html
48:04 - is not part of the change set here
48:07 - but adding it to the change set would
48:09 - make it complete
48:11 - so
48:12 - first step is
48:14 - to simply add that change to the staging
48:17 - area
48:18 - and to commit it but not a normal commit
48:21 - we are going to use fix up as a as an
48:25 - option and we go we want to fix up this
48:29 - old commit here right that new commit
48:31 - that we are producing should fix this
48:34 - old one and we're going to
48:36 - copy that to the
48:38 - clipboard the commit hash of that one
48:43 - fix up whoa with an x
48:47 - right so if you read that it says this
48:49 - new commit here
48:51 - fixes this old commit here okay let's do
48:55 - that and you probably expected fireworks
48:58 - or something spectacular but i'm very
49:00 - sorry we just produced a new commit with
49:03 - that command but
49:05 - something is cooking here right fix up
49:08 - exclamation mark is prefixed so
49:11 - something is happening here okay
49:14 - the second part of that solution is to
49:16 - use interactive rebase of course we're
49:18 - still in that department of the workshop
49:20 - so we're going to use interactive rebase
49:22 - to fix this one
49:25 - first step in interactive rebase how far
49:27 - back do i need to go at least the parent
49:30 - so
49:31 - hit minus one two three
49:33 - four that's the one we want to correct
49:35 - so at least here
49:38 - all right git
49:40 - rebase interactive head tilt d4 and
49:45 - the second part of that secret sauce
49:47 - here is to use dash dash
49:49 - auto squash right first part is fix up
49:53 - when you commit second part is auto
49:55 - squash when you start the interactive
49:57 - rebase that's a two-part solution
50:00 - and the good news is
50:02 - in this editor window i don't have to do
50:05 - anything git already did all of the hard
50:08 - work for us and i'll explain that to you
50:10 - but just keep in mind nothing to do for
50:12 - us
50:13 - i'll explain
50:14 - what happened and why
50:16 - so the first thing that git does did for
50:19 - us is to mark up that band aid commit
50:22 - here as fix up right this is the fix up
50:25 - commit that's the first thing i didn't
50:27 - do that it's automatically here and the
50:30 - second thing that git did is it
50:32 - automatically sorted this line to the
50:36 - right position right because actually
50:38 - change headlines for about an imprint
50:40 - the fix up commit should be the bottom
50:42 - most right reverse order so it should be
50:46 - down here but git already understood
50:49 - okay we want to use this to fix up that
50:52 - other old commit so i'll position it
50:55 - here because it works just like squash
50:58 - squash you remember the rule squash
51:00 - combines with the line above fix up also
51:04 - combines with the line above
51:07 - so nothing to do for us just save and
51:09 - close
51:11 - and if you take a look at
51:13 - that
51:15 - this is the one we fixed up and now it
51:17 - contains error html it is correct and
51:21 - the ugly band-aid commit has been thrown
51:24 - away wonderful beautiful commit history
51:27 - nothing is dirty nothing seems to have
51:30 - been broken everything's fine
51:33 - again if you want to do that in tower
51:35 - very very simple just drag and drop and
51:38 - keep the option key pressed
51:41 - and voila this is a fix up
51:44 - very very easy
51:47 - okay
51:48 - um
51:49 - git commit fix up and get rebus
51:51 - interactive auto squash a two-part
51:53 - solution
51:54 - and here we are at the last case of this
51:57 - workshop and this is actually just to
52:00 - to show off a little bit about what
52:02 - interactive rebase can do because the
52:04 - answer is anything actually anything
52:07 - so split or edit
52:09 - really opens up an old commit for
52:12 - editing it again
52:14 - very very beautiful so um we can edit
52:18 - that old commit add new changes delete
52:21 - something add files and then make
52:24 - multiple new commits out of that change
52:27 - set very very flexible
52:29 - and let's see how we can do that
52:35 - this one is quite a lot of work to do on
52:38 - the command line so i'll show you how to
52:40 - do this in tower and you know that it's
52:42 - possible if you ever want to do that
52:46 - we need something that has a couple of
52:47 - changes so
52:50 - let's take this one so in tower i can
52:52 - just right click and say
52:54 - edit
52:56 - and this brings me right into the middle
52:58 - of an interactive rebase session where
53:00 - the whole contents of that old commits
53:03 - are here in my local working copy so i
53:07 - could just as i said hop into an editor
53:09 - make some changes or say well
53:12 - this here really doesn't make sense i'll
53:14 - throw that away
53:16 - and
53:17 - this and
53:19 - this is actually one topic so
53:22 - commit number one we wanna uh as i said
53:25 - the the general rule is to commit only
53:28 - things that belong to the same topic so
53:30 - this is one topic and this is actually a
53:32 - second topic so let's make that commit
53:35 - to
53:37 - and then i can hit continue continue
53:40 - closes the interactive rebase session
53:42 - and voila i just
53:45 - split
53:46 - edited an old commit and created two new
53:50 - ones out of that
53:51 - very very flexible
53:54 - and allows you to
53:55 - clean up your history in a very elegant
53:58 - way
54:01 - all right i think i've said it a
54:03 - bazillion times but let's say it one
54:05 - more time
54:06 - many of the tools today that i showed
54:08 - you
54:09 - do rewrite history and the rule to live
54:12 - by is don't use these tools for read
54:15 - writing commit history that has already
54:17 - been pushed to a shared repository right
54:20 - use those things to clean up your local
54:23 - history before you merge that back into
54:26 - a team branch and this is true for
54:28 - amending commits rebase interactive
54:30 - rebates definitely sometimes reset so be
54:33 - a little bit careful and use those only
54:35 - in the right situations
54:39 - all right
54:40 - what we have done is
54:42 - we've created little videos of those 17
54:45 - cases and a very handy cheat sheet
54:48 - with some
54:49 - problem
54:50 - situations and the solution for that if
54:53 - you want to get that that's free to go
54:55 - so go at bitly
54:57 - and get first aid kit if you want to
54:59 - download that
55:02 - that's it from me
55:03 - thank you very much for your attention
55:06 - and i would say have fun
55:08 - breaking things and of course
55:11 - repairing
55:12 - goodbye
55:20 - you