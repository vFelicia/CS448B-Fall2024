00:00 - Nuxt JS is a progressive JavaScript framework for building user interfaces on the web. It makes it
00:05 - very easy to create server rendered applications, static websites and single page applications.
00:11 - And it's a popular choice for developers looking to build fast and scalable web applications.
00:16 - Guillaume created this course about Nuxt 3. He has 10 years experience as a developer and is a popular
00:22 - instructor on Udemy. Let's start learning. Hello, everybody, and welcome to this course about
00:28 - Nuxt 3. My name is Guillaume and today I'm really excited to introduce you to my favorite framework.
00:34 - Nuxt is a framework made on Vue.js and you might know that last year Vue.js upgraded to the version
00:41 - 3. So Nuxt did the same and now we have all the features of Nuxt 3. With Nuxt.js you can create
00:49 - full stack application and it's a very interesting framework because there are several rendering
00:54 - modes. During this course we are going to learn everything you need to know to create a full stack
00:59 - application with Nuxed. Here is the program of our course. We are going to learn first how to create
01:06 - an application. Then we are going to look at pages and routing the file system that help us to create
01:13 - routes automatically. We will look at components and the main feature of Nux is to auto import the
01:21 - components. How to create layouts. How to deal with images and assets. We are going to look also
01:29 - at composable, the new feature of Vue 3. How to create plugins and why. How to deal with middlewares
01:37 - to prevent authentication, for instance. We are going to learn what are modules, a specification
01:43 - of Nux.js that help us to supercharge our application. We are going to talk also about
01:50 - state management and especially about Pinar. One of the most interesting part of this course
01:56 - is talking about the rendering mode with SSR, SWR and eBread mode, the new mode.
02:03 - Finally we are going to look at servers with Nitro, how to create a server on our app.
02:09 - We will need also to know what are use fetch, use lazy fetch, use async data, those methods provided
02:15 - by Nux 3 to fetch data. Also if you are interested to work with Nux, you might be interested also in
02:24 - SEO and methods for the rendering modes. We will look at lifecycle hooks, how to configure our
02:31 - project. Then finally we will finish our course on Nux content, a package or module that help us
02:38 - to create static website with Nux. And finally we will create a full stack application which will
02:45 - be a documentation and an API. So if you are ready to follow this course, let's go!
02:56 - Nux.js is a JavaScript framework made to create front-end application. Nux.js has been built on
03:03 - top of Vue.js, a bit like Nuxt.js for React. And there's a lot of features that help us to develop
03:10 - faster and that improve our developer experience. So when you go on nux.com, the official
03:16 - documentation, we see now that we are on the version 3 of Nux. Because yes, Vue switched
03:23 - recently to the version 3. So Nux had to update its latest version. So when we click on get
03:30 - started, we arrive on an introduction page. But for us we are going to go directly on installation
03:35 - and we are going to go down and here we see that we have a command npx nuxi init project name. So
03:42 - I'm going to copy paste that, go into my terminal, I'm going to give a name so it's going to be my
03:48 - Nuxt project. And there we go, my project has been installed. The first thing we can notice when we
03:55 - arrive in this Nuxt project, and if you already did some Vue.js before, is that it's really light.
04:00 - There's only six files at first. So when we are going to type npm install, we're going to have our
04:06 - node modules. However, we don't have the folders that we have on Vue 3. For instance, on Vue 3,
04:12 - we get the source folder, we can have the public and assets. With Nux, it works a bit the same.
04:18 - However, the difference is that we will not have any source folder at first. We will have to create
04:24 - our own folders, page components, et cetera, et cetera. And it's going to work like this because
04:30 - Nux is providing to us a file routing system that works on the organization of our folders.
04:37 - It will automatically create our routes. And another thing that is really cool is that with Nuxt.js,
04:42 - it's going to auto import our components. So we will not have to import all of this.
04:48 - But we are going to see that in the next lesson. Type npm install to npm install our project.
04:56 - Then we are going to type npm run dev to just launch it in our browser and to look at it at first.
05:03 - Okay, this is done. And the first thing we can notice is that we have a node module folder.
05:07 - And we also have this point Nux folder. Yarn dev or npm run dev, it depends. And here I'm
05:13 - going to open my localhost 3000. And there we go. We've got our application running,
05:20 - which is actually this Nux welcome only. So our application is now set up. We can use it
05:26 - directly like this. If you want it, you can deploy it from now. It will work as it's supposed to work.
05:33 - And what we're going to do at first is just to remove this and put hello Nuxt 3 because we don't
05:38 - need that component. All right. Our app has been created, but it's totally empty. The first thing
05:45 - I'm going to do is to add a bit of configuration. Because, yes, with Nuxt, yes, we have a Nuxt.config.
05:51 - TypeScript or JavaScript file that can help us to provide some configuration. So we have a method
05:59 - called define Nux config that receive an object. And in this object, we can pass several elements.
06:06 - The topic of this course is not to talk about the configuration. The topic of this course is just to
06:11 - create an app. However, I'm going to do a bit of configuration at first before we start the course
06:18 - in order to follow every step. So the first thing I'm going to add, it's an alias. This alias will
06:24 - help me actually to catch some elements directly from the source. But you are going to say to me,
06:30 - Guillerme, you talked before about the auto import feature. Auto import is working for pages and
06:37 - components and some other folders, but not necessarily for everything. So we will necessarily
06:42 - need an alias. So this alias will be an at. Okay. And here I'm going to say, hey, I need the paths
06:50 - of my current project. And I want to be at the root. So I'm going to import resolve from pass
06:59 - up there. All right. And here I'm going to resolve a pass. So I'm going to start with dear name.
07:08 - And here it's going to be just the source, the root, actually, of my source. Okay. So now when
07:16 - I'm going to type at everywhere in my app, it will resolve directly the dear name. So the dear name,
07:22 - which is actually the root of my folder. And I will be able to catch anything and to import
07:28 - dynamically every element of my project. Another thing is that I want to add a CSS file because
07:34 - we don't have any style in there. So what I'm going to do, I'm going to create a folder directly,
07:40 - which will be assets. And in this assets, I will add a main.css. If you want to add a CSS,
07:47 - it's okay. Me personally, I'm going to add a CSS. What I need to do now, it's to install
07:52 - SAS because SAS is not installed. So I'm going to type npm install SAS, and I'm going to launch
07:58 - again the project. And what I want to do, I want that this main.css file would be actually
08:03 - root style sheet of my project. So what I can do is to type CSS. And CSS, actually, it's an array.
08:11 - So I'm going to specify on this next.config.ts that I want to have one file as a CSS root file.
08:19 - You can have many other because it's an array. So here I'm going to add assets main.scss. To
08:26 - check if it's working, I'm going to add a body and here it's going to be color red. And when I get
08:32 - back, there we go, we see that I have the color red apply. So it is working, it is applying my
08:38 - SCSS. Finally, for the need of discourse, I'm going to install Tailwind CSS. So I go on Tailwind CSS
08:45 - on Get Started. Then I click on Framework Guides. There I click on Next.js. And I go on the version
08:52 - three because here we are on the version two. So here we arrive there and we see that we have to
08:58 - install Tailwind CSS in our terminal. So I'm going to copy paste this going back there. I'm going to
09:05 - stop npm install Tailwind CSS. There we go. Then I need to init my file. So I'm going to type npx
09:13 - tailwind css init. Then we need to specify to nux.config.js to use post css and tailwind.
09:22 - So I'm going to copy paste this and I get back there. And just after my configuration,
09:27 - I'm going to add post css plugins, et cetera, et cetera. All right. Then finally, what I need to do
09:33 - also, it's to add actually to the tailwind.config.js right now, which is almost empty. It's to add
09:41 - here the content file that I need to watch. So let's have a look on this. I'm just going to copy
09:48 - paste and we're going to look at it. We will watch for components. So there will be a components
09:53 - folder. We will watch for layouts because they can be a layout folder also. Pages, which will be the
10:00 - pages of our project. Plugins, but also for the nux.config.js and of course the app.view.
10:08 - So now it's done. What we need to do is to add those elements, tailwind base, component and
10:14 - utilities to our main.scss. And we already imported it to our project. Remember just up
10:22 - there on the CSS line there. So when I get down, it's telling us to do it, but we already did it.
10:29 - And now let's run again our project and let's see if it's going to work. And when I get back to
10:37 - localhost 3000, there we go. I think it's working because the font has changed. And if I go to the
10:42 - network on main.scss, we see that tailwind is clearly imported. If you want to get this starter
10:49 - project, you can go on my GitHub and down there you got the nux3 tailwind starter. And when you
10:54 - click on it, you have the full repository available that you can clone directly. Finally, we are ready
11:00 - to follow this course and to learn how to create a front-end application with nux3.
11:12 - One of the main features of nux3 is its file system routing. What does it mean? Basically,
11:19 - in view3, you are supposed to install viewrouter to deal with routing. Then you will have to create
11:26 - a root.js file, declare your routes, import your component or pages, and then organize all the
11:33 - nested routes, the navigation guard, et cetera, et cetera. With nux3, you don't need to do that
11:39 - because there's a system inside nux3 that helps you to deal with the routing automatically.
11:45 - And it's working with the pages directory. So we see here on the official documentation that
11:50 - every view file inside the pages directory creates a corresponding URL. So let's get back to our app
11:59 - and let's try to create a route. So I'm going to create a new folder called pages. And inside these
12:05 - pages, I'm going to create, for instance, an events.view page. So here it's supposed to be
12:14 - slash events as a corresponding URL. So I'm going to create a quick template. And in this
12:20 - template, I'm going to type div events page. All right. It's good. But remember, in my app.view,
12:28 - I have this. And normally, with viewrouter, if you're already coded with view, you're supposed
12:34 - to use the router view built-in component that is provided by viewrouter. How does it work with
12:42 - nux3? Well, if we go back to our app, we already got an error. And if we try to access the page
12:48 - events, we have actually the page of app.view. And this is a bit confusing because we're supposed
12:57 - to have events page and we finally have a app.view. It's really easy to understand. We have to say to
13:04 - nux3 to use the router. So first, we are going to use a first built-in component, which is nux3
13:11 - layout. Because later, we are going to use the layout of nux3. And inside this nux3 layout,
13:18 - we are going to use the router view built-in component. But actually, it's not router view.
13:23 - It's nux3 page. nux3 page here is working exactly like router view component with viewrouter.
13:32 - Now I've did that. I can get back. And on my slash events root, I got the events page
13:39 - here display. However, if I get back to the root of my app, I got a 404. And it's totally simple
13:47 - to understand. I don't get any index at the root of pages. However, app.view is supposed to be the
13:54 - root of our single page application. And it needs the first page to start. And this first page has
13:59 - to be index.view inside my pages folder. So I'm going to type template div. And I'm going to say
14:08 - here index page simply. So I got an index.view, which is the first page. So the root URL of my
14:16 - application. Then I got slash events that is displayed there. So when I get back and I update,
14:23 - so maybe I got to start again my server for him to understand that I have an index page right now.
14:30 - And there we go. I got my index page display. And if I get to slash events, I got my events page.
14:37 - All right. So it's really cool. Let's try to create a new page. And let's say that is going to be
14:44 - my and dash profile.view. Okay. And here I'm going just to copy paste the code that I have
14:53 - there. I'm going to close all of this. And I'm going to type my profile. See that it's also
14:59 - working. How cool is that? Okay. Let's remove this my profile.view. And let's create instead of
15:06 - events.view a folder called events. And now we've got a problem because we've got this event.view
15:14 - and events folder there. So what we can do is to move this event.view here. And I can rename this
15:21 - as index.view. So now what is it happening? It's that here when I go to events, it's taking my
15:29 - index.view. And let's say that I want to create a file inside my events folder which relates to
15:38 - another route. Is that possible? Yes, it's possible. And it's going to create the full URL for us.
15:45 - So let's say that we've got an event. And here I'm going to have a profile.view, the profile of the
15:51 - event, let's say. So I'm going to have a template tag, div, profile event there. I'm going to save.
15:58 - And when I get back and I type slash profile, okay, because I'm in the events folder and there
16:04 - we go, we access to the profile event page. How cool is that? It's amazing because we can create
16:11 - a lot of routes like this. And of course, if I wanted to create a new folder called profile and
16:17 - inside I would like to add a new view and which will be indexed inside, it could work. So you see,
16:24 - you can create really nested routes and with this file routing system inside pages, next,
16:30 - we'll totally understand what you are trying to do and we'll build for you all the paths that you
16:35 - need. Let's say now that in event, I would like to have an ID actually that I would catch through
16:42 - my route. You can do that with brackets. So here I'm going to type ID between brackets.view exactly
16:51 - like we would do in Vue.js. So I'm going to type template there and I'm going to type div and
16:58 - actually I'm going to have event ID and here, of course, I would open my double curly brackets
17:06 - and inside I would try to access to my route, params.id exactly like I would do in Vue.js.
17:13 - Okay. This dollar route is the object related to the current route. And here we're going to catch
17:20 - the ID between the curly bracket, between the brackets, sorry, that we got in our Vue file.
17:26 - When I go to the page, event ID 12, for instance, there we go. We catch 12 as an element provided
17:35 - into the params. Okay. It could be anything. It could be a very long number. It could be Guillaume,
17:40 - for instance, whatever. There we go. We can catch it this way. So when you want to make dynamic routes,
17:47 - you can use those brackets and put inside the parameter that you want to catch.
17:52 - And it's going to pass immediately through the route this parameter for you.
17:56 - Oh, if you want to catch this parameter inside your script, so here I'm going to open a script.
18:02 - With Nux, we got auto import everywhere. So here we got available a method called use route.
18:08 - So I'm going to create a new variable and here I'm going to use route, the method that helped
18:14 - me to access to the route. So I'm going to console log this route. And I'm going to get back,
18:20 - open my console. And what we see is that we got the route as a proxy object. What I can do is
18:28 - to type route dot params, exactly what I would do inside my template. And here, there we go.
18:35 - We see that it catch actually the ID of my route. So I get route dot params dot ID.
18:40 - And this method use route is available everywhere in the Nux application. And you will see when
18:46 - we get more deep into the course, everywhere in the Nux application, you have a lot of methods
18:52 - like this that are auto imported everywhere you need them. You earn a lot of time by doing this.
18:58 - This is a good timing to show you another method that is very useful provided by Nux.
19:03 - Exactly like next.js, if you know next.js, you have the context available. Nux also got the context
19:11 - that is available. What you can use actually is the use Nux app function. Here I'm going to remove
19:18 - this. I'm going to type const Nux is equal to use Nux app. Use Nux app is actually a function that
19:26 - is available everywhere in the application to give us access to the current context. So here I'm
19:32 - going to console log Nux. I'm going to get back. I'm going to update. And look at that. We've got
19:38 - an object which is big and contains a lot of method and data. And if we look a bit closer to it,
19:47 - we see that we got access to what we call a context. This is actually the context of your
19:52 - current application. So here you got a function called use head. We're going to see that later.
19:57 - We got view app that gives us access to all our view application with the instance, et cetera,
20:03 - et cetera. And all of these will help us to deal with some operation everywhere in the application
20:11 - when we need to. And on the official documentation, we've got a good definition of what is use Nux app.
20:18 - Use Nux app is a built-in composable that provides a way to access shared runtime context
20:24 - of Nux, which is available on both client and server side. It helps you to access the view
20:31 - instance app, runtime hooks, runtime config variable, and internal state such as SSR context
20:38 - and payload. Use Nux app will be very useful when you will create your own Nux application.
20:44 - You may need this context very, very often. Don't forget about it. Let's finish now to talk about
20:51 - the navigation. If I get back to my app.view here, let's say that I want to create a header.
20:57 - And here it's going to be a header with a list of elements. So here I'm going to have a list.
21:04 - And inside this list, I would like to have a link that pushes to the homepage. What I can use
21:10 - is Nux link. And Nux link, actually, it's a built-in component that helps you to push to
21:19 - the route that you want. So here I want to push to home. So I'm going to type slash. And here
21:25 - it's going to be home. And then let's say that I want to push to events. So I'm going to type
21:31 - slash events. When I get back here up there, I got two buttons. So now it appears like a text.
21:37 - But when I click on home, I go on home. Then I click on the events. I go on the events.
21:41 - Okay. So use Nux link. When you want to create a link that push to a route. And when you want to
21:47 - create, actually, some programmatic navigation. As you see, Nux is providing to us a very easy
21:53 - system to deal with the routes. We don't need to create a route folder. We don't need to import
21:58 - another package or another plugin to our application to deal with routing.
22:02 - Nux itself is built around this file routing system. And later, you will need to deal with
22:10 - authentication and deal with what we call middleware. If you need to prevent the entry on a page,
22:17 - depending on the authentication, for instance, what you will need to do is to watch the course
22:22 - about middleware. Because within Nux context, actually, we can deal with middleware that
22:28 - prevent some actions depending on the user interface and depending on the user entry URL.
22:36 - It's time to talk about the components. With Nux 3, we got a feature called auto import.
22:48 - Which basically means that every component are available everywhere in the application
22:54 - because it's auto imported. So if we look at the documentation, it's written that most components
23:00 - are reusable piece of user interface. You can create these components in the components
23:07 - directory and they will be automatically available across your application without having to
23:13 - explicitly import them. So previously on Vue.js, what we were supposed to do is to every time we
23:22 - need the component to import it everywhere we need it. We can also go on the main.js file
23:29 - and say, actually, to the Vue application to use the component and we can import it everywhere also.
23:35 - It's a kind of auto import. However, with Nux, we don't need to do all of this.
23:41 - And that's really amazing because we save a lot of time. So we are going to create a folder and
23:47 - here I'm going to close all of this. We're going to create a folder called components.
23:53 - Okay. Components. And here inside this folder, I'm going to create a first component called
23:59 - alert.vue. Okay. And this component is basically taking a div. This is an alert component. Okay.
24:09 - I'm going to add some style to it. So I'm going to be a bg green 500. It's going to be rounded
24:16 - px2py1 and text y. There we go. And maybe a bit of margin button. All right. We've got this component
24:26 - and right now we've got our app running there, an index page. I put the background in black to have
24:33 - a bit of more effect. And now I want to use this component alert in my index page. So I go on my
24:40 - index page. And what we used to do before is to go to script. And then we would say basically
24:47 - import alert from blah, blah, blah. We don't need to do that anymore. We can directly say, hey,
24:56 - here I want my component alert. Let's get back to the app. And suddenly we've got our component
25:04 - available. And that's amazing. That's why I love Nuxt. With Nuxt, we save time. So how does it work?
25:14 - Basically, it works like exactly pages with the file routing system. It's based on the name of
25:20 - the file and it's based on the level of the current file. So if I create another component, let's say
25:28 - that it's going to be header.view. And here I'm going to type this setup and I'm going to put
25:34 - header here. If I go to my app.view and on top of that, I'm going to type header because it's the
25:41 - name of the file. What's going to happen is that it's going to look for header as a component,
25:48 - as the file coming from the folder component. So you have to create this folder component to tell
25:54 - Nuxt, hey, I'm looking for a component. And this component is supposed to be in the component
26:01 - folder. So the component directory is playing a very important role in the Nuxt application.
26:08 - It's just the place where you're going to put all your interface pieces. So if we want to create a
26:16 - deeper component tree, actually, what we could do here is to create, for instance,
26:21 - let's create a folder and profile. In there, what I can do is to type also index.view. I'm going to
26:28 - type profile component. I'm going to close all of this and get back into my index.view. And down
26:35 - there, I'm going to type profile. And when I'm going to type profile here, it will understand
26:40 - that he has to look for the profile. And here he found a folder and then index.view. So he
26:47 - understand that it is the profile component. Let's say that in my profile component, I have
26:53 - another folder. And this folder would be header again. So we'd have an index.view there. And again,
26:59 - it's going to be profile header. How can I import this header here inside my index? What you have
27:07 - got to do is to come from the parent to the children. So we've got profile at first. So I'm
27:14 - going to type profile. Then I'm going to type header because my component is supposed to be
27:19 - in the header folder. So from component, I want to look to profile. Then I want to look to header.
27:26 - And inside header, I got this index.view. So I'm going to type profile header. And if I get back
27:33 - to the app, there we go. It is working. I got my profile header. So to give a deeper understanding
27:41 - of it, I'm going to say that here it's going to be the main page. Now I'm going to open my console.
27:48 - And inside my console, I'm going to inspect. And look at this. I got a first div, which is
27:55 - ID next. And inside of it, I got the root of my application. And what do I get? I got a div
28:03 - called header. We already imported it, but we didn't put the class header. So if I go there
28:08 - and I put the class header, we will understand that this is the header we are talking about.
28:14 - Okay, header. And then we got the main page. Because remember, in app, we have got the
28:21 - header. Then we're supposed to have the current page display. So we've got actually main.
28:28 - And then we've got our alert. So we didn't put alert. But if I go there and I put alert,
28:35 - it will work this way. There we go. So we got the alert component. Then we got the profile.
28:40 - And then we got the profile header. So you can go really deep like this. You can go really deep by
28:47 - creating component this way. And let's say that in my header, I would have an avatar.view.
28:55 - Okay? Here, I'm going to put class. And again, here on VS Code, I get the pass profile header
29:05 - avatar. It really helped me to create my current component. So it's going to be profile header
29:11 - avatar. And actually, it's going to be avatar of profile header. I'm going to save. And now I want
29:20 - to import this avatar inside my profile. What can I do? Well, actually, it works exactly the same
29:29 - everywhere. Depending on where you are, you just need to always start by the component root.
29:37 - So here, what is the component I want to import? The component I want to import,
29:41 - it's avatar from header from profile. So I need to start by profile. Then I need to look to header.
29:51 - Then I need to look to avatar. And this is the component that has been created previously.
30:00 - I went to profile, then header, then avatar. And I've created this profile header avatar.
30:06 - And when I get back to the app, there we go. I got my profile avatar just after inside the profile
30:15 - header. It's a bit confusing when you get a lot of files like this. If I go to my index page,
30:22 - which is supposed to have profile, and I remove this, I get nothing. And if I want to use the
30:28 - avatar that is in the profile header avatar, what I can type, it's always the same. I can
30:35 - always import all those elements depending on their roots. In this example, I made in purpose
30:42 - something complicated. I created several folders with several files inside because I wanted to
30:50 - show you that you can go from a simple organization to a complicated organization and to retrieve
30:57 - actually the path of the component because you are not importing them anymore. And you are using the
31:03 - auto import feature of Nuxt. You will need to understand how to catch those levels. And the
31:10 - easiest way, as I said to you, is to come from the parent, then going to the children until the
31:15 - element you want to catch. What we notice with Nuxt3 and the components, it's that this system
31:22 - helps us to not importing everywhere our components. And it gives us also the ability
31:28 - to call components everywhere we want dynamically. However, be safe. When you are creating your
31:35 - components architecture, try to be simple. Try to be easy. Do not create really deep folder and deep
31:42 - files because otherwise you will have very long name at the end. If we get back there, for instance,
31:48 - we get a profile header avatar, it's a very long name, okay? You don't want at the end to have
31:54 - very, very long name because the readability and the developer experience will decrease.
31:59 - So this system is good. Nuxt made something great with this auto import. However, be careful on the
32:08 - usage. Sometimes in our application, we want to have separate design or we want to change the
32:19 - behavior of our app depending on the authentication, for instance, if we are logged in or logged out.
32:25 - For that, we can use what we call layouts. And, of course, Nuxt.js helps us to deal with layouts.
32:32 - So right now I got my main page and if I get back, I just got this page here, index.view,
32:37 - that is created and it's totally empty. And let's say that I want to create first a default layout
32:44 - for this page. What I'm going to do is first I'm going to create a layout folder. Inside this
32:51 - layout, I'm going to create by default default.view. Default.view is going to be the layout by default.
33:00 - And we will see later that in our page, we will be able to declare what layout we want to use
33:05 - depending on the situation, depending on what layout you want to display, actually. So here I'm
33:12 - going to create a template. And in this template, I'm just going to create a first div. And this
33:17 - div is going to be class and I'm going to call that default layout this way, okay? Just for the
33:23 - example. Then what I'm going to write is just a p and I'm going to type default layout. So we will
33:30 - see that we are in the default layout. What I need to do now is to specify that here I want to put
33:38 - the data. I want to put the pages. I want to just display the current vision on what I want to
33:45 - display. So I need to use the built-in component slot. Slot here will receive actually a page
33:52 - which is index.there. So once I have done this, let's get back to my app. Let's refresh. And there
33:59 - we go. We see that without writing anything on my index.view, I got this default layout that is
34:06 - display. And if I open here my elements there, my console, I got the default layout that is apply.
34:14 - And we see that the page is a child of the default layout, all right? So we created our first layout.
34:22 - And if I apply some class, like, for instance, text-wide bgslate900 and hscreen for this one,
34:31 - we will see that my style will be applied on the whole layout. So on all the children down there.
34:39 - So to create a layout, you use a slot. All right. Now let's try to create another layout which will
34:47 - be a custom one. So here in layout, I type custom.view. And actually what I can do is just copy
34:54 - pasting this custom layout. And instead I'm going to call it custom layout. And here is going to be
35:02 - custom layout. Again, we need the built-in component slot in order to display the content we want to
35:08 - display. So now I've got this. I want to create another page because default is for all the pages
35:16 - that are not asking for any other layout. But now I'm going to create another page. And let's say
35:23 - that this one will be, for instance, custom.view. Exactly the same name as the layout, but you're
35:28 - not obliged. It could be Evans or whatever. Okay? So now we set this. We have to create another page.
35:35 - So I'm just going to grab this one. It's going to be custom page. And here I'm going to type
35:41 - custom page. All right. The thing is now if I go on slash custom, so with my router, you know that
35:47 - it generated the root. If I go on slash custom, what is going to happen? On the custom page, I got
35:54 - my default layout. And this is normal because I didn't specify any layout to use. When you want
36:02 - to specify a layout to use, in your script here, you are going to say that you want to use this
36:09 - layout on this custom page. All right? So what you need to use as a method is the define page
36:17 - meta. Define page meta is a function available everywhere in your next application that you can
36:24 - call to specify some parameters because it's an object that is taken as a parameter. And here
36:32 - I'm going to use layout. And in there, I'm going to use the name of the layout that I'm going to use.
36:39 - So you understood now that I want to use custom. Okay. I specified here on the custom.view page
36:47 - that I want to use the custom layout. Now I'm going to close all of this and just open here
36:54 - my custom.view. Now let's get back to the page and let's see if we get our custom layout.
37:01 - So when I get back, I get finally my custom layout. So back in the layout, I'm going to
37:07 - change just the color. Let's say that we were going to have a background blue. There we go. I
37:12 - got a background blue. Now I'm going to get back on the main page. And we see now that I switch
37:18 - from a layout to another one. So if I get back to custom, there we go. We've got another layout.
37:25 - So you understand now that we can use this layouts folder and we can create new layout
37:32 - inside this folder, they will be automatically registered with the name. And after in the pages,
37:40 - you will be able to call this layout through the define page meta method.
37:51 - When you want to store style sheets, images, or font, you usually use the assets folder.
37:57 - But with next, we get two directories that can handle these assets. These two directories are
38:05 - public and of course assets. Previously, we created an assets directory to put our main.scss.
38:14 - But me, I added two images there to show you how we can use assets to fetch our images.
38:20 - But first, let's have a quick look on the documentation and let's have an explanation
38:25 - on difference between public and assets. The public directory content is served at the server
38:33 - root as is. The assets directory contains by convention every assets that you want the build
38:41 - tool to process. So what is the difference between public and assets? That's the main question here.
38:49 - Why do we get two different folders? And that's maybe why you are watching this video,
38:54 - because it's a bit confusing to have two different folders that we could use actually
39:01 - to store our images, font, or et cetera, et cetera. Let's start by explaining the assets directory.
39:07 - Let's have a look on the documentation. Next, use a webpack to build and bundle your application.
39:16 - This is the tool that basically bundles your app. The main function of these build tools is to
39:21 - process JavaScript file, but they can be extended through plugin for vits or loaders for webpack
39:28 - to process other kinds of assets like style sheet, font, or SVG. This step transformed the original
39:34 - file mainly for performance or caching purpose. So it is clear that the assets directory is
39:41 - processing an additional step to your style sheet or your image at the bundle actually.
39:48 - So here, this step is improving the performance of our files, and also it's working on caching.
39:57 - By convention, Nuxt uses the assets directory to store this file, but there is no auto scan
40:03 - functionality for this directory, and you can use any other name for it, which means that Nuxt is
40:12 - not watching at assets. It's just a fixed, a static repository there that is here just for the dev,
40:20 - and there is no auto scan functionality, so it means that Nuxt is not watching to it.
40:25 - So you can name it the name you want. Here, basically, it's assets. Let's take an example.
40:31 - Here, I got my app running, and in assets, I added two images. So what I can do is to go on my main
40:37 - page, which is index, all right? And here in index, what I could do is to import this image.
40:45 - So I can take this example down there, and I'm going to add it just after my LO Nuxt,
40:52 - which we can actually put there, LO Nuxt 3. There we go. And I'm going to catch my image called
40:59 - 1.gpg. I'm going to remove this alt, this useless alt, and there we go. And now I get back to my app.
41:08 - I got my image that is display. So this is the first way of displaying an image,
41:14 - and of course, after that, I could have had some CSS to change the size. Let's try to display the
41:21 - second image also. There we go. I got my second image that is displayed there. All right. This
41:28 - is the first way. Another way, instead of always using this pass, what we could do is to use an
41:36 - alias. So I'm going to get back on nux.config.js, and remember, I have created this alias previously.
41:45 - This was the whole way to resolve pass, because now we can use root dir and source dir with nux,
41:53 - so I can remove this one, and I could put, for instance, assets. Okay. And here I can type
42:01 - slash, and I can use root dir. There we go. Here, root dir, and I can close it. Here, there's a mistake.
42:09 - I can close it with assets. Now I did this. What I can do directly, instead of having the wave that
42:18 - I got here, I can use at, and at assets will play the exact same role as the wave and will retrieve
42:26 - for me directly in the assets folder the image. Of course, if I have a folder, I have to follow the
42:33 - pass to this folder, and when I get back, it's also working. This is the second way of using the pass,
42:41 - and, of course, it's very useful. Now let's talk about the public directory. We see that here I
42:50 - got a folder assets and one GPG file. If I want to access this image, what I could do is assets.GPG,
42:59 - but if I do that, of course, I got a 404, because here nux.js is not serving this folder. Remember,
43:10 - it says down there that nux doesn't auto scan and doesn't take in order this folder into its build.
43:21 - Basically, because it's processing, actually, basically, if we want to have a public image
43:27 - with no process at all, because assets is processing, but public here is not processing,
43:33 - we can use the public folder. Here, the public directory is used as a public server for static
43:41 - assets, all right? Public server for static assets. You're going to put the image into the public
43:48 - folder, and it will stay as it is. There will be no compression, there will be no processing,
43:55 - nothing else, no resizing, it will stay as it is. The same for style sheet, the same for any other
44:02 - file that you will put in there. You can get a file in the public directory from your application
44:07 - code or from a browser by the root URL slash. Let's try. Now, I'm going to create a new folder
44:14 - at the root, which will be public, and I'm going to move my two images there into the public folder,
44:21 - and I'm going to try to access it. Back in my app, I type the name of my image as a URL,
44:30 - and there we go. I got my image available exactly like if I would take it from a server,
44:38 - and as you look at it, as you look at it, it's directly available into my URL, but there is no
44:46 - preprocessing of the image. This image will be available directly like this, and there will be
44:53 - no caching. So if I want to access this image, basically, what I can do is to directly use the
45:01 - slash. So here, instead of having all of this, I can just put the slash and here the two, so I'm
45:09 - going to get back on the app, and there we go. Slash will look directly into the public folder,
45:18 - which is very useful if you want to fetch another file like this. You can use directly the public
45:24 - folder, but remember, public means that it's public, so it's available on the app all the time. So you
45:32 - got to be careful if you want to store files or elements that you don't want to share. Don't put
45:38 - it into the public folder. Put them into the assets folder. By using SVG as icons, you might ask
45:44 - yourself how to do it with assets and public folder. Well, actually, the thing is that with SVG,
45:51 - you would have to use a plugin for VIT to load them, and there is one called VIT SVG loader that
45:58 - helps you actually to import the SVG from, for instance, a public or assets folder and to render
46:06 - them directly like a component. So here you get this package that is available, and the only thing
46:14 - that you would need to do is to go on your VIT config.js, and if you don't have it, you have to
46:19 - create it, and then you give the plugin a VIT or SVG loader, all right? So you can use a third part
46:29 - plugin for next to load your SVG. However, you know that I like to give you the best tips
46:37 - to develop faster and efficiently in Vue.js, and if you want to, and especially next,
46:44 - and if you want to use SVG, my advice would be to go on icon.gs.org. And the thing is that
46:52 - everything is a component in Vue.js. So basically, icons can be also components.
46:59 - So let me give you an example. We are going to catch an icon. So here I'm going to look at it,
47:03 - and you will see that what we can do can be very cool. So here, if I type bell, and let's say that
47:09 - I'm looking for a bell icon in SVG, basically, let's say that I'm going to take this one,
47:16 - you see that on this website, on icon.gs.org, I can download SVG as components.
47:24 - And here we see that I get plenty of other options. I can also do it in React,
47:29 - Svelte. I can download them directly. What I can do if I click here on component view,
47:35 - I can just come back, go on my component, and here I'm going to create a folder called icons.
47:42 - And in icons, I'm going to create a bell.vue. And I'm going to copy paste, and directly,
47:50 - I got my SVG that is appearing here. So let's say that now I want to catch,
47:57 - so I'm going to remove this image. I want to use my SVG icon, which is in my.vue file.
48:04 - How can I do it? Exactly. Like I explained to you for the components. Listen, I can simply call
48:11 - icons bell. And here icons bell is going to call in the component folder icons and bell. Now it's
48:18 - done. Let's get back to our application. And there we go. We've got our SVG that appears this way.
48:25 - It's way faster than using plugins that we can add to our configuration. This was my tips.
48:32 - When you want to use icons, go on icon.gs.org and use them directly as components.
48:43 - View free introduced to us the new concept of composables. If you already coded React application
48:49 - or Next.js application, you might know what are hooks. Well, basically, it's exactly the same as
48:57 - composables. However, with the view composition API introduced by view free, the idea is to split
49:04 - the code logic into several files instead of having the same logic everywhere mixed.
49:11 - Why we do that? Because it makes the code lighter, but also because it helps us to debug faster and
49:18 - to have some code cleaner. So we created in view free the composables in order to separate some
49:28 - code logic. So let's have an example because we need something concrete. Here I got two views.
49:34 - I got index.view and I got profile.view. And let's say that in index.view, I would have a function
49:40 - called say hello with just console log hello. There we go. All right. And I want to trigger
49:47 - this function every time index.view will be built. So back in my app, I open and there we go. I got
49:54 - hello that is console log. Now, let's say that I want to have the same function triggered in my
50:02 - profile.view. Well, it's a big dump because I got the same piece of code written in two different
50:10 - place. And here the thing is that it's two different functions, even if they got the same name.
50:17 - They got the same name, so it means that they are supposed to do the same thing,
50:21 - okay? But they have two declarations in two places. And that could be a problem because
50:27 - one could console log hello and the other one could console log goodbye. And that's a problem
50:34 - here because we wish that say hello could do the same thing. To solve that problem, we could create
50:39 - a composeables that will contain our say hello function. So here I'm going to create a new folder
50:45 - and this folder is going to be called composeables. And now you understood Nux 3. Auto import is the
50:52 - main feature. Of course, Nux 3 will auto import all our composeables. So the convention says that
51:00 - with view 3, we should name the composeables with a use before. So let's say that here we are going
51:06 - to call that use utils.ts. Here what we're going to do, we are going to create a const, okay,
51:13 - called use utils that we are going to export. And this would be a function. Okay, so let's get back
51:21 - at our say hello. Let's say that in our function we would have this say hello there. And now what
51:28 - we want to do, we want to return say hello. Now I get this file called use utils that I could use
51:35 - everywhere in my app because I have the auto import feature made by Nux 3. So instead of
51:42 - having this declaration there, what I can do is just destructure, okay, my use utils. And use utils
51:51 - come from where? It comes from this file composeables. So Nux 3 understands that every file that is
51:59 - there as a function and is going to record this function. And here the function that we have is,
52:05 - of course, use utils. So I got use utils and what I need to import is say hello. And now I got my
52:14 - say hello there that I can trigger. Of course, I can do exactly the same there. And now I don't
52:20 - get the problem that I have two different declarations. So here I can put hello from
52:26 - use utils. Back in my update, we see that I got hello from use utils. So I really encourage you
52:35 - to work as much as possible with composeables. And now you understood that we can, you don't
52:42 - need to import, okay, with Vue 3 you would have to do this. You will have import from
52:48 - add composeables, et cetera, et cetera. You can have the big benefit of the auto import
52:54 - of the composeables for Nux 3. And I really encourage you to gather all the business logic
53:01 - into composeables because it's easier to read, easier to debug, and it doesn't make your code
53:08 - base heavier. It's a very good timing to talk about a very useful library that a lot of Vue
53:15 - and Nux developers are using. This library is called Vue use. Vue use has been created by
53:22 - Anthony Fu. He's really known in the Vue community. And there's a lot of other developers that help
53:28 - him. But basically this Vue use library is working a bit like composeables. When you install this
53:35 - library, you get tons of methods that helps you to develop faster and that improve your developer
53:40 - experience. Most of the time, if you would need to detect, if you click outside, you would go into
53:46 - your composeables and you would click a function called const on click outside. Okay? That's really
53:54 - basic. A lot of developers are doing this all the time. Well, the thing is that if you install Vue
53:59 - use, you don't need to do that. All you would need to do is to import click outside coming from the
54:05 - Vue use library. So as you see, you get some examples. And it shows that you will save a lot
54:12 - of time if you use this kind of library instead of creating your own function. And at the same time,
54:19 - think about something. The Vue use core team actually worked on many functions. Look at this.
54:27 - They thought about everything. So don't think that you could do better than an open source community
54:34 - that is working on that all the time. The code quality of this library is tremendous. It's
54:40 - amazing. So do not waste your time writing function. And here you get a lot of examples.
54:48 - You may have a trouble and this trouble could be certainly solved by a function there.
54:53 - So I really encourage you to go on Vue use and to install this library to use it.
55:03 - If you code it in Nux2, you might be familiar with the concept of plugins. Let me give you an
55:09 - example. Let's say that before you launch your application, you want to trigger some JavaScript.
55:16 - Well, actually, it's not really before you launch it. But it's at a certain time that you want to
55:21 - trigger some function. What you can do is to use plugins. Also, let's say that you would like to
55:28 - have a directive or some kind of function available everywhere in your app. And you don't want to use
55:34 - a composable to put this function and import it. You just would like to click. You would just like
55:41 - to have a Nux app dot something to trigger your function. Well, what you are looking for are
55:47 - plugins. On the official documentation, we can read that Nux automatically needs the files in
55:52 - your plugin directory and loads them at the creation of the Vue application. So basically,
55:58 - what you need to do is to create again, and it's always the same logic actually. And this is why
56:04 - I love Nux. I can create my plugins folder. And inside, I will create a my plugin dot ts.
56:12 - So let's create this first plugin, my plugin dot ts. And there we go. The main difference
56:18 - is that those plugins can be called at the initiation of your Nux application. So I get
56:23 - my plugin dot ts. And if I go down, I see that I need to type export default define Nux plugin.
56:31 - Let's go let's type export default, define Nux plugin. And here as an argument, I can
56:39 - type the Nux app. Because here at the beginning, I will have my context available. So let's console
56:47 - log this Nux app that we already saw before. And there we go. Now I did this, I can go back to my
56:53 - app and try to trigger again. And look at that. What I have is that before my composable function
57:02 - that says hello from UCTL, I have my Nux app context available. However, in Nux, if we are
57:10 - using plugin, it's because most of the time, we would like to have some directive or to have some
57:16 - function that we could trigger everywhere. Like I said, at the beginning of this course. In order
57:20 - to do that, we have an amazing example there. Really simple to understand. It's that we create
57:26 - our plugin and we return an object. And inside this object, we get a provide key. And this provide
57:33 - key will tell actually to Nux, hey, record this as a function or directive list because it's an
57:40 - object that will be available everywhere in my app. So let's create our own directive. And here
57:48 - is going to be exactly a bit like this example, I guess. So I'm going to get back there. And what
57:52 - I'm going to do, I'm going to return an object. And in this object, I'm going to return provide.
57:57 - And provide here will wait for something. Say hello. Okay. Say hello. I got say hello, which
58:04 - actually will take a message, which would be a type string. And it will console log. Okay. My
58:11 - message. So I got hello message. There we go. Now I've got this. Okay. Now I've got this. I can go
58:20 - to my index.view. And I can call my hello function. So how I can do it? Well, it's really easy to
58:29 - understand. We see down there that I can import hello from Nux app. I'm going to import my hello
58:36 - function, which is here, but actually it's not hello. It's say hello. So say hello actually will
58:42 - be available. And if you look at the object, what I got now is a dollar say hello. So what we're
58:49 - going to do first, it's a console log, this use Nux app, which will return to me the context. And
58:55 - if I click and I look down, I got down there, I got this say hello function. So now everywhere in
59:03 - my app, I got this say hello function that is available. What I can do now is to use this
59:08 - function, say hello, simply by typing dollar say hello. And here I'm going to put Guillaume for
59:14 - instance. And when I get back and I update, there we go. It's working. Often plugins are used to
59:21 - inject into the Nux context, all the logic of a certain library. Let me give you an example for
59:28 - Firebase. If you would like to have Firebase installed on your Nux application, you would use
59:34 - a plugin. Even if there is a module for Firebase that maybe we are going to see later. As I said to
59:38 - you, here we got a very good example on the Nux documentation. We can use plugins for third library.
59:44 - And here we got the module view gtag, actually, to add Google Analytics tags to your Nux application.
59:52 - A last example is to change the view directive. And here we've got another example. Here we are
59:59 - going to create a plugin. And we see that we inject again into our view app, inside the Nux app,
60:06 - the directive focus. And in this directive focus, we are specifying behavior. So this is something
60:13 - else that you can do inside your plugin folder. You could change your directive directly there
60:20 - and say from the start of the app, hey, I want to change a behavior and this is what I want to do.
60:26 - So in plugins, you can have custom plugins that you create for yourself and that create
60:32 - some triggers. You have plugins that are related to modules and you have plugins that are related
60:37 - also to directive. Actually, you can create the plugin you want. And that's the force of Nux.js.
60:43 - One of the main reasons I moved from View Free to Nux Free, it's because of the routing system,
60:55 - but also because of middlewares. Because with Nux Free, what we can use is middlewares,
61:02 - those files that will trigger some operation before we switch from root to another one.
61:07 - So you understood now that we can deal with authentication with middleware. And I can say
61:14 - that with Nux Free, it's so useful. Let's have a quick look on the documentation.
61:21 - Next, provide a customizable root middleware framework you can use throughout your application.
61:28 - The ideal for extracting code that you want to run before navigating to a particular root.
61:39 - That's amazing. I don't know if you realize, but that's amazing because we can deal with several
61:44 - cases we want to deal with thanks to authentication. There are three kinds of root middleware,
61:50 - anonymous or inline root middleware, which are defined directly in the page where they are used.
61:57 - So I get back to my app and I'm going to create a folder called middleware. And I'm going to
62:03 - create a new file. And let's say that this file is going to be called auth.ts. In this auth.ts,
62:11 - I'm going to export default a method called defineNuxed. And here be safe because what we want to
62:20 - have is define root middleware. So this method provided by Nuxed help us to catch several
62:29 - parameters to and from are from them. So here I'm going to use to, from. Now what I'm going to do
62:36 - is to console log this to and this from. All right. So now I got my middleware.
62:45 - And you probably understood that there's a mistake because I want this middleware to be
62:52 - triggered everywhere. So if I get back to my app and I update, I don't have anything that is console
63:01 - log. And here on the line two and three of my auth.ts, I'm supposed to have defined a next root
63:08 - middleware. So on every root, it's supposed to execute all the code there. It's because here
63:14 - the global root middleware is supposed to have a global suffix. So what I'm going to do is to
63:21 - rename and put here auth.global.ts. Now I get back to the app. I update. And there we go. We see that
63:33 - now on this root, I have my two elements that are triggered. The first, it's two. This is the
63:41 - root I'm going to and from. This is the root I'm going from. So I'm going to put slash and I think
63:47 - I already got a root profile there. And as you see, and I get data from where I come and where I go.
63:54 - So it's really useful to use this global actually middleware that can help us to trigger some
64:01 - operation. Let's take an example. And let's say that we want to check on every root of our
64:06 - application if we are logged in or not. And we would check that with a variable, okay, is logged
64:13 - in. Okay. Which will be on false. All right. Well, the thing is that later we will have a store.
64:21 - And in this store, we will have some kind of variable like this. So we will be able to check
64:26 - the store first to see if we are logged in or not. And then we could take some decision. But there,
64:32 - what we need to do is to check with if we are logged in or not. Otherwise, if we would not be
64:40 - logged in, we would redirect. We would redirect to a login page. And there what we want to do,
64:47 - we want to redirect actually to the page we want to go. And this page, we have it because we have
64:55 - two. Two is the destination. Two is the destination. So what I can do is console log my two. All right.
65:05 - So when I get back there, I update. And actually, I'm going to go exactly there. Okay. I see that
65:13 - where I want to go is to the full pass. So what I can do is to use a method that is written there
65:21 - called navigate two. Navigate two. And not from two.full pass. If we are logged in, we say, okay,
65:30 - you can go to the destination you want to go. Otherwise, if you don't want to, you have to
65:36 - navigate two and the page here could be logged in. So this is a quick example on how we could create
65:45 - an authentication system on every route. But what happened if I removed this global? Here,
65:51 - we already saw that when I removed this global, and I'm going to remove this example, I'm going
65:56 - to say just console log hello from middleware. There we go. We saw that nothing is happening
66:05 - there. So when I update, nothing is happening on my index page. What you can do also, you can
66:11 - specify to your page that you want to use this middleware. So here in my page that I want to
66:18 - add a middleware to, I can type define page meta. And in this function that we already saw to define
66:27 - the layouts, but we can also use to many other things like title, etc. We can say, hey, I want
66:35 - to use a middleware. And this middleware is going to be off. Let's check that. And when we get back,
66:43 - we see that hello from middleware off. If I go on profile, I don't get this hello from the middleware.
66:52 - And what I would need to do is to do exactly the same thing on profile.view. There is also a
66:58 - method that you could use, for instance, inside a plugin. And this method is simply add route
67:03 - middleware. Well, basically what we could do is to say to our plugin to add a root middleware,
67:11 - and we define this by the name of the plugin, then by the function and everything that you want to
67:16 - trigger inside of it. And you can specify at the end if you want it to be global or not. That's
67:22 - another way of adding a middleware, which is very convenient with Nux3. It's that you can set up
67:29 - authentication really fast, depending on your middleware. That's an amazing feature for me.
67:40 - With Nux3, we can use what we call modules. And actually, we had already this in Nux2.
67:46 - Modules are like libraries. You have to install them and add them to your nux.config.js. Also,
67:52 - modules are made to simplify your integration and simplify your developer experience.
67:58 - These Nux modules are actually running asynchronous when your Nux application is launched. And these
68:05 - modules can be created by anyone. They can be published on NPM in order to help other developers
68:13 - to save time to help you to develop faster. We've got Tailwind, for instance. And if we click on
68:19 - Tailwind, because we already installed Tailwind on our Nux.js application, we see that on the
68:27 - installation command, we've got a prefix called add Nux.js slash Tailwind CSS. It means that this
68:36 - module, this specific library, is made only for Nux.js. And with the add Nux.js, we understand
68:45 - that we call, actually, the Tailwind version for Nux.js. But what is the main difference with a
68:53 - current library? Well, if we get back, we see that here we have a definition called a supercharge.
69:02 - So, a module is here to supercharge your Nux project. So, we understand that this is a plus
69:13 - that goes directly inside the real lifecycle of Nux. So, let's get down and let's install,
69:21 - for instance, a package, a module called Nuxed Content. So, how do we install Nuxed Content?
69:30 - Well, and how do we install Nuxed Module most of the time? Well, which is cool is that we have,
69:37 - often, a documentation that comes with the module that has been created by the developer. And that
69:46 - is really useful because when you click on it, we arrive on a new website, on a new documentation
69:51 - that explains to us how to use this specific package. There, I'm going to click on get started
69:57 - for Nux content. And we see that I don't got a new project. I want to add my new project.
70:02 - So, what I would need to do is to add this, actually, this module by stopping my server
70:10 - and just typing yarn add dash dash dev at Nuxed slash content. I'm going to type enter. And after
70:20 - the installation, I am able to see that in my list, I got Nuxed Content as a dev dependency.
70:28 - So, it's not finished because with Nuxed, what we need to do when we want to use modules
70:34 - that are entering inside my Nuxed cycle, actually, my Nuxed context, I need to specify to my Nuxed
70:44 - application to use this module. So, what I'm going to do, I'm going to get back and go on
70:49 - nuxed.config.ts. And here, I'm going to type modules, which is an array. This array is waiting
70:56 - for different modules. And we see here that type 9 proposed me already Axios as a package or proxy.
71:03 - But me, I'm going to use Nuxed content. And when I get back, I'm going to type enter there. There
71:09 - we go. And now I got Nuxed content. So, I'm going to type yarn dev. And actually, you will see that
71:16 - here for this specific package, nothing will have changed. However, if I want to use Nuxed content,
71:23 - we see that I have to create a content folder. So, I'm going to type content. And inside,
71:28 - I'm going to create an index.md because Nuxed content is a package to render markdown files.
71:36 - And now, with Nuxed content, Nuxed understand that he has to look at content. So, I'm going to type
71:43 - lol. And if I want to render this content, I have to use a built-in component called content doc.
71:51 - So, I'm going to close this. I'm going to get back. And now, this built-in component, content
71:56 - doc, is available because I installed this module. And I specify Nuxed.config.ts to use it.
72:03 - So, I'm going to go on my main page. And inside, instead of having this lol, I'm going to put
72:10 - content doc. And when I get back, I get my content. So, as you see, there are many modules that you
72:16 - can use. For instance, E18n, which is actually for internationalization. And it's always working the
72:23 - same. What you need to do is to install the corresponding package and then to add it to your
72:30 - module array inside your Nuxed.config.ts in order to use it. Most of the time, you will look for a
72:37 - library to use in Nuxed. Well, before doing that, I highly recommend you to look at Nuxed modules
72:46 - because maybe there's already a developer that did work for you and created a package that will help
72:52 - you to go faster in your developer experience. When we create a front-end application, we often
73:03 - need a state management system. What is this exactly? Well, when you have a view and you declare
73:10 - some variables inside this view, you have what we call a scope. And these variables are available
73:16 - only in that scope. However, sometimes we need to have some kind of state management to just share,
73:24 - for instance, the data or variables between components, pages, and everywhere in your
73:29 - application. For that, we use a state management system. And of course, with Vue 3, if you already
73:35 - coded a Vue 3 application before, you might know Vue X or Pia. But with Nux 3, we have a new
73:44 - solution, which is user state. And we are going to look at it right now. Nux 3 provides user state
73:50 - composable to create a reactive and SSR-friendly shared state across components. SSR-friendly,
74:00 - what does it mean? Later in this course, we are going to look at rendering mode. And SSR
74:05 - mean server side rendering. Here, Nux is talking about user state. And user state is a ref
74:14 - replacement. So if you don't know ref, it's a new function provided by Vue 3 that actually will
74:22 - create for us a proxy variable that will be reactive. If you want to know more, I highly
74:29 - recommend you to look at Reactivity in Vue 3. Let's have an example. Here we have a basic usage
74:36 - that I'm going just to copy paste. So I get my app there. I'm going to remove all of this
74:41 - and use the official example. So when I get back, there we go. We see that when I click,
74:50 - I increase or decrease my counter. And my counter is up there and is using a user state counter,
74:58 - which is returning actually a value. All right. That's really interesting. But what we are looking
75:05 - for actually is to have some kind of store or state inside our app. So here it is working. All
75:13 - right. But here we see that we have shared state. And this might be what you are looking for.
75:18 - Go to our composable and let's create a new file called states.ts. By the way, in the previous course
75:26 - of composables, I told you that the convention is to use as a prefix for your composables. It seems
75:33 - that here in this example, it's not respecting the convention. Here I see export const there.
75:38 - I'm going to copy this. All right. And there we go. Now I get this state.ts through composable
75:46 - that is injected inside my whole application. And so I get two values available. Use counter
75:51 - and use color. And the thing is that here we would like it to work like a state in ViewX. Why do I
75:57 - take ViewX as an example? Because if you did next to before, you knew that a folder store would be
76:04 - already written by default. And in this store, every store that you would create would follow
76:11 - the path of ViewX. So basically, you would have ViewX store that will be auto imported,
76:16 - auto injected inside your next content application. Actually, every store that would be created inside
76:23 - this store folder would be injected directly into the next context of your application.
76:30 - Here we've got an example of a ViewX store. And basically, there's a state, there's mutation,
76:38 - there's actions, there's dispatch. All right. But this is for ViewX. In the example provided by
76:47 - next3, we see that this use state can work exactly like a store and can return actually
76:54 - just an object or a value that could change. So what we want to test? We want to test that
77:00 - is this counter will have actually the same value everywhere in my app.
77:06 - So here, instead of having counter there, I'm going to call use counter, which actually comes
77:13 - from my state. Here I get my use counter. And what I want to do, I want to create a component,
77:18 - and let's say that we're going to have counter component, counter.view, that would have exactly
77:25 - the same code as in my app. Now I've got this, I can create a new div. And next to it, I'm going
77:32 - to call my counter. So I will have a double counter. Here what I can do is to put an ID,
77:39 - and let's put the ID main. And here I'm going to put another ID, which will be counter.
77:44 - When I get back to my app, we see that I got these two different files. I got this file,
77:50 - which is the counter. And I got this one, this scope, which is main. I want to be sure that
77:55 - my state encounter will also change. So let's click, and we see that actually my state is changing in
78:04 - the two components. Here we've got what we call a shared state. We can define global type safe
78:12 - states and import them across the application. So the main question would be Guillaume. Why
78:19 - we will use a state.ts, that will be actually a composable, instead of using ViewX or pinya.
78:29 - That's the question I asked myself also. And I found this very good article on viewmastery.com,
78:35 - which is a reference about view, written by Michael Tissen. And this article is called
78:41 - Nux3 state management, pinya versus user state. And here Michael is asking the same question as me.
78:51 - Do I use Nux3 home state management solution user state? Or should I use Nux3 with pinya?
78:57 - Which is better? Well, here is the short answer provided by Michael Tissen.
79:04 - Pinya is what you get if you keep adding more and more features to user state.
79:09 - More complex app will benefit from the extra features in pinya. But user state is better for
79:19 - small and simple apps. This is the short answer and I think everything is said there. If you have
79:26 - a big application and once your user state is heavier, you should use a state manager like pinya.
79:34 - Otherwise, if you have a small application, you better use user state. And if you want to know
79:41 - more about why we use user state in state of ref, what is state hydrotation, and what are all the
79:49 - problems around it, and why to use either user state or ref, I recommend you to read this article.
79:58 - Otherwise, we will have to install pinya as a state manager. Because yes, even if I showed you
80:05 - this state management system by Nux3, I also want to show you a bit of pinya. Because yes, for me,
80:13 - I can't make a course about Nux3 without talking about pinya, which is an amazing state manager.
80:19 - So let's have a look. Let's install pinya. And so I'm going to stop my server. And I'm going to
80:26 - type yarn add pinya add pinya nux3. So you understood now that this pinya nux3 is a module
80:34 - that I'm going to add. And if you want to look at it, you can go on the module page of Nux3 to find
80:40 - it. Or otherwise, you go on pinya.vgs.org and you look for NuxGS. So I'm going to get back to my
80:47 - nux.config.gs and I'm going to add pinya nux3. There we go. Now what I got is that
80:56 - I can use the store outside of setup. So I'm going to type yarn dev again. And I'm going to
81:05 - create a new folder at the root of my application. And this new folder will be stores. Actually,
81:13 - in this folder, what I'm going to put is actually, yeah, my store. They call it my store. As an
81:19 - example, my store.gs. So now I need to create my store. So when I get back, I got an example there.
81:27 - I got several examples, actually. And what I'm going to do, I'm going to copy paste this use
81:32 - counter store. There we go. So how does a store is working? As I said to you, with pinya, we got
81:38 - state getters and actions only. All right? So now with the state, we are returning some value.
81:46 - And we got getters that are actually like computed function that will return to you the value when
81:52 - it's updated. And then we got action. Only the action are supposed to mutate our store. We've
81:58 - got another option. We can write our store with the view free way. So here, as you see, we've got
82:05 - ref, we've got computed, we've got increment. So when I get back there, I have the whole way
82:11 - of doing it. Now I'm going to copy paste and we are going to look quickly at the difference.
82:16 - Down there, we have the view free composition API that has been used. And up there, we have the view
82:23 - two, which is actually used with the option API. State are replaced by reference and getters are
82:30 - replaced by computed properties. I decided to keep it on the view free way. So with the composition
82:36 - API, I got my store. I'm going to import my store, which is use counter store. I'm going to create a
82:43 - variable called store, which we call actually the counter store. And I want to console log it. When
82:49 - I get back to my app, we see that I have the proxy that represent actually my store. And if you are
82:55 - using view dev tools, which is actually an extension for Chrome, you can see that there, we've got access
83:03 - to our pinna stores and we've got our counter just in here. We see that there are several ways
83:09 - of dealing with the state management inside Nuxt free. You can have the user state through
83:16 - composables, or you can use pinna, which is a more complete library or module to help you to deal with
83:23 - state management across pages and components. Which is brand new with Nuxt free. It's this
83:34 - server directory that can help us to create actually a backend and to deliver some
83:40 - functionalities that are related actually to API. So on the official documentation, we can read that
83:47 - Nuxt automatically scans files inside the server directory, API and server routes, and also server
83:56 - middleware directories to register API and server handlers with HMR support. So what we can see is
84:05 - that we can use the define event handler. And this handler can directly return JSON data, a promise,
84:14 - or use event node.res.n to send a response. All right, let's go directly into the subject and
84:21 - let's create a server API folder. So here I'm going to create a new folder at the root of my
84:29 - application. I'm going to type server and inside, because I want to follow the documentation,
84:36 - I'm going to create an API folder. So I'm going to click on there and here I got an API folder.
84:42 - So now, if I follow what is written on the documentation, I understand that now I can create
84:50 - an endpoint. And which is cool is that when we look there, we see that later we will be able to
84:57 - fetch, okay, we will be able to fetch a root slash API slash LO if we are creating a LO.ts file.
85:06 - So to start, we are going to copy paste this code and I'm going to create a simple LO.ts file.
85:15 - And there we go. So my server is running. And we see that in my console, there is this
85:23 - nitro build in 400 milliseconds. What is this nitro? We are going to see that just after.
85:30 - So I'm going to get back there and I'm going to open my application. So my application is there.
85:36 - And if I type slash API slash LO, I'm supposed, okay, I'm supposed to have an endpoint that
85:43 - responds to me, actually what we wrote before. And when I type this, there we go. So now we see that
85:51 - our NuxJS application, it's not only about frontend, it's also about backend. We have an endpoint that
85:58 - is available and here that is answering to us a JSON object. So Nux now has a role of a frontend
86:08 - framework but also of a backend framework. Actually, it was already the case before. But now we see
86:14 - that we can create our own endpoints and to do some backend. So let's just console log this
86:22 - event object that we've got there. So I'm going to open this. I'm going to get back and I'm going to
86:29 - type again on the endpoint. And we see here that we've got an h3 event object with a context nitro
86:40 - and a big node object. And we can see there that we've got everything that we need to handle this
86:47 - node call. So and we got also a res with a server response, et cetera, et cetera. So we can see that
86:54 - here we can catch events going to this API folder and to this API. Actually, hello.ts
87:03 - endpoint on our API. Okay. But what is the point to have a backend on my frontend application?
87:10 - Well, it can be for many reasons that you would need a backend for your application.
87:15 - For instance, if you want to provide some triggers or provide some action that you would do not on
87:22 - the frontend side but on the backend side, now NUGGS gives you the opportunity exactly like NUGGS
87:28 - because we can do the same with NUGGS. It gives you the opportunity to actually put some business
87:33 - logic on the backend side and not on the frontend side. So how does it work? Well, basically, on the
87:40 - server where you are going to host your NUGGS application, it will also run the backend,
87:46 - and it will provide the operation on the backend side and not on the client side.
87:52 - If you never did some backend before, I highly recommend you to dive deep into NUGGS or at least
87:58 - a little bit to understand how we create backends. It's not that you have to learn everything about
88:05 - the backend to handle this part of NUGGS. However, if you want to create some triggers and some
88:11 - endpoints, however, it's always good to have some knowledge to start creating endpoints on a backend
88:18 - such as this one. If we continue to read the documentation, we see that we can make some
88:23 - cull there, and we are using a method with a dollar fetch. However, what is this dollar fetch?
88:31 - Well, we are going to see this in the course, dollar fetching. But for now, I'm just going to
88:36 - copy this code there, and I'm going to get back to my application. So on the frontend side,
88:43 - and I'm going to open my console. And what I'm going to do, I'm going just to copy paste this
88:49 - code. So I'm going to get back there. I'm going to go on index. And up there, I still have my
88:55 - content dock, which is there. It's okay. What I'm going to do, I'm going to type await fetch
89:03 - API hello. So we have a top level await there. So what I'm going to do, I'm going to type
89:08 - const response. And I'm going to console log my response. And when I get back, there we go.
89:15 - We see that my frontend called my backend automatically. And it called the API folder
89:23 - with the endpoint I have created in there. See that in the same application, we can do
89:30 - full stack operation. Because we can have a frontend and a backend. So it can be very useful.
89:37 - If we continue, we see that down there, we've got a server root option. And it is written,
89:44 - file inside the server API are automatically prefixed with API in the root. Yes, that's what
89:50 - happened here when I type slash API slash hello, which is the name of my file. Hello is, of course,
89:56 - the name of the endpoint. I got an API there in my URL. Maybe I don't want it. So for having server
90:06 - roots without API prefix, you can instead put them into server roots directory. So let's get back.
90:13 - And at server here, I'm going to create a new folder called roots. And in there, I'm going
90:19 - to copy paste my hello.js that I got there. However, I need to change the code of this file.
90:25 - So I'm going to get back there. And I'm going to type hello world from roots folder. I'm going to
90:31 - save. And now I'm going to get back. And instead of having API hello up there, what I'm going to
90:39 - type is just slash hello. And it will work exactly the same. However, the difference here is that I
90:47 - didn't return a JSON. I just returned a simple string. If I would like to return a JSON, I could
90:53 - do exactly the same as I did in the API folder. So back in my roots folder now, I'm going to just
91:01 - open these brackets this way. Hello from roots folder. And I'm going to save. I'm going to get
91:10 - back. I'm going to type again. And there we go. I got my JSON there. We just saw two ways of creating
91:17 - server endpoint on Node.js. We saw the API folder, which will prefix all your endpoint with slash
91:25 - API slash. Otherwise, if you want to create root without the API slash, you can put your endpoint
91:33 - inside the roots folder. Your file, they look like they export a default define event handler method.
91:42 - And inside, every time you can provide operation, you can trigger actions, whatever. But every time
91:49 - you have to return at the end the result of your endpoint. You know me, I try to give you all the
91:55 - best practice all the time. When you are creating a file like this, it's creating actually an endpoint.
92:02 - And this endpoint will take the name of your file. Well, try to be concise every time you are going
92:08 - to create some endpoints. The name of the endpoint should be really logic and follow some pattern.
92:17 - Here, what we do, we are creating a hello root. And this root is supposed to have a method.
92:24 - The method can be post, get, patch, delete, whatever. So the best practice that I want to
92:30 - give you now is to actually always put a suffix at your root. Here we have a root hello. And the
92:40 - method is supposed to be get. So I'm going to type get. And now we understood that actually this
92:47 - root is supposed to be a get method. So if you are going to try to post to this root, it's not going
92:53 - to work because the suffix is now get. When you put just hello.ts, it's like you are doing anything
93:02 - you want. So remember, in Node.js, or if you don't know, in Node.js, when you are creating an app,
93:09 - you can specify the method by typing app.get, app.post, app.patch, and then you provide an action.
93:17 - Here, what it does actually, without putting a suffix, it does an app.all. It means that it's
93:26 - going to receive any request depending on the method. So the best way is always to specify.
93:33 - Of course, if you get a post, instead of get, you're going to put a post. If you get a delete,
93:38 - you're going to put a delete, et cetera, et cetera.
93:41 - Now,
93:46 - previously on the server part, we talked about nitro. Because when we launch our application
93:52 - on Next3, if we look at the terminal, we can read that Next is running on nitro. What is nitro?
94:00 - Well, actually, nitro, it's a server engine. And actually, on the official documentation,
94:06 - we've got some information about nitro. Next3 is powered by a new server engine, nitro.
94:15 - It is cross-platform support for Node.js, browser, service worker, and more. Because before Next was
94:22 - running on Node.js, now it took nitro, this new engine, that helped us to make Next3 running.
94:29 - Serverless support out of the box, API would support, that we saw already on the server part.
94:37 - Automatic code splitting, async loaded chunks, hybrid mode for static plus serverless site,
94:44 - and we will see that this hybrid mode is the brand new feature of Next3. Development server
94:50 - with hot module reloading. There's also a website for nitro on nitro.ngs.io. And if we click on
94:59 - get started, suddenly we see that on the documentation, we recognize what we've got on
95:06 - our server part on Next3. We see that we have this method called define event handler. And we see
95:15 - that we can create, actually, a backend, a server with nitro. So why Next3 decided to use nitro?
95:26 - Nitro. For many reasons, and one of these reasons, it's that we can use the cache API to cache
95:35 - elements. Okay? So the thing is that Node.js is really known for its SEO performance and its
95:43 - server side rendering mode. We are going to see later the mode. However, now let's talk a little
95:50 - bit about how we can cache elements with Next3. Basically, what's going to happen when we use
95:57 - SSR is that every time we are requesting a server, the server is going to build the application and
96:04 - deliver it to the client. The difference with the SPA mode is that on the SPA mode, everything is
96:12 - done on the client side. With the SSR mode and the hybrid mode that we are going to see later,
96:18 - we can cache elements, which means that instead of every time there is a request,
96:24 - our next application has to be built. We cache the element every five minutes, for instance,
96:31 - and every five minutes somebody is going to come. It's going to build a cache version,
96:36 - and during this five minutes, it's going to deliver the content to the next call.
96:42 - Also, Nitro provides to us a built-in storage layer that can abstract our file system or
96:50 - database to any data source, and that can be very useful, especially if you are doing some Redis.
96:57 - We can store some elements when we need them. Then, of course, it is backend, so we can use
97:05 - the router and link from Nitro that help us to create some routes and some endpoints to provide
97:13 - some operation, which is really funny, and at this point of the course, you already saw a lot of
97:19 - auto-import with Next.js. We have also auto-import with Nitro. What I like, especially about Nitro
97:27 - also, is that there is a deployment documentation that helps you to deploy, for instance, on Netlify,
97:33 - and that helps you to deploy Nitro if you want to use it also separately from Next.js.
97:39 - So, it was necessary for me to talk about Nitro to have a quick presentation of it,
97:45 - because this course is not about Nitro, it's about Next. But if you want to do some backend
97:51 - on the Next side, you might want to focus on Nitro, and especially to go, for instance,
97:58 - on the official repository, which is on NGS organization. NGS, it's actually basically
98:06 - what the organization that created Nitro, but not also Nitro, some other methods that are used
98:14 - inside Next.js 3. This is probably the most important lesson of this whole course about
98:27 - Next, and this is probably the one you were waiting for, because Next.js is really known
98:33 - for its options about rendering. So, previously in the lessons, I was talking about how you can
98:41 - render differently your applications, and it's not related to Next.js. However, Next.js is providing
98:48 - many options that are very useful when you want to take care about the SEO of your application,
98:54 - for instance. So, for this lesson, we are going to look at two documentation, the old one,
99:01 - the one about Next 2, and then we are going to switch to the Next 3 to see the difference.
99:08 - What is rendering? Well, we can look at a good definition about rendering on the new
99:16 - documentation, and we can see that here it's written, both the browser and server can interpret
99:24 - JavaScript code to render VGS component into HTML elements. So, we can see that we can render
99:33 - our application from VGS component into HTML element on the client side and on the server side.
99:40 - This step is called rendering. Next supports both client side and universal rendering.
99:50 - The two approaches have pros and cons that we will cover in this section. But before,
99:56 - let's get back to the old documentation, and let's look at how it was written before.
100:02 - We talk directly about server-side rendering, SSR, and static site. Server-side render sites
100:13 - are rendered on the server each time the user requests a page, therefore, a server is needed
100:19 - to be able to serve the page on each request. Static site, which is the opposite of SSL,
100:27 - are very similar to server-side rendered application with the main difference being
100:32 - that static site that renders that build time. Therefore, no server is needed.
100:40 - The static sites, they are not billed every time there's a request. They are billed
100:46 - are billed time when you type and PM run billed, for instance. So, it makes a big difference
100:52 - because on static site, it's difficult to fetch the data and build your HTML document to deliver
100:59 - it to the browser because when you are fetching the static website, it is already billed. So,
101:07 - the data is static there. So, for SEO reasons, what you want to have is that when the robot
101:14 - is arriving on your website, you may want to have all the data or the fresh data
101:19 - already fetched and completed, interpolated everywhere. For that, you will use SSR.
101:26 - And with Nux2, we had the option SSR true, which we could put on Nux.config.js or TS.
101:36 - So, when I go on Nux.config.ts, if I want to put the SSR mode, the only thing that I have to type
101:43 - is SSR then true. And from there, my application now will be billed on the server side. And it
101:55 - doesn't change something immediately on your application, but this new rendering mode actually
102:02 - change a lot of things in your data life cycle. If we look at the new documentation again,
102:08 - we have some explanation. Client-side only rendering, out of the box, a traditional VGS
102:14 - application is rendered in the browser in the client. So, the computer actually, not the server
102:20 - or the phone. Then, VGS generates HTML elements after the browser downloads and passes all the
102:26 - JavaScript code. And this schema is explaining it very well. The browser downloads an HTML document,
102:33 - then the browser downloads and runs the JavaScript. And the app is rendered and interactive. This is
102:43 - the client-side rendering. We see that the JavaScript is not executed. We got pros and cons
102:50 - about this technique. The development speed is a pro. When working entirely on the client side,
102:56 - we don't have to worry about the server compatibility of the code. For example,
103:00 - the using browser only API, like the window object. Because, yes, on the server side rendering,
103:05 - you don't get any window object. So, that's a problem. But, however, it's a development
103:11 - speed feature that is a pro of the client side rendering. It's cheaper. Running a server are
103:17 - the cost of infrastructure, and we've got also other problems related to this. And offline,
103:23 - because code entirely runs in the browser, it can nicely keep working while the internet
103:29 - is unavailable. Which means that with the client side only, when you fetch the application,
103:34 - you don't need any more to have actually internet running instead if you are fetching some data.
103:42 - But it can work offline, which is amazing. The cons of the client-side rendering is the
103:49 - performance. The user has to wait for the browser to download, pass, and run the JavaScript file.
103:55 - The server side rendering is faster. And the client side needs actually a good internet
104:01 - connection, and it needs also memory to make the work to render the application in the browser.
104:07 - With the server side rendering, it's faster. And finally, that's the main topic.
104:13 - With the client side rendering, we have very bad SEO performances.
104:19 - And that is maybe why you are watching this video. This is because you would like to have
104:25 - good SEO performance on your next application. And with the client side rendering, this is very bad
104:33 - to do SEO. Actually, it's useless to try to do SEO because your page is not rendered at the right
104:39 - time. And as written here, we can see that as search engine crawlers, so the robot of Google,
104:46 - for instance, won't wait for the interface to be fully rendered on their first try to index the
104:52 - page. So if you have a SEO problematic on your project, you should do server side rendering.
105:01 - Then you get what we call universal rendering. Client side plus server side. Well, it's actually
105:08 - the server side rendering. What happens is that when the browser requests a URL with universal
105:14 - rendering enabled, the server returns a fully rendered HTML page on the browser. So as I said
105:20 - to you, it's going to make the work for you and just send you the page. Whether the page has been
105:27 - generated in advance or cached and is rendered on the fly at some point next has run the JavaScript
105:34 - code in a server environment. Making a static page interactive in the browser is called
105:42 - hydration. That's what we saw before. That's a good definition of hydration. So basically,
105:50 - this universal rendering is working this way. The fully HTML is sent to the browser and rendered.
105:56 - So the work here has been done about all the data completed on the server side. Then the browser
106:04 - download and run the JavaScript in background. Then a new step is coming on our cycle. Because
106:13 - at that time, we need to get this hydration step complete. And hydration, again, it's making a
106:23 - static page interactive in the browser. So when you use SSR, you might have some errors related to
106:31 - hydration. It's maybe because you didn't make the static page interactive in the browser. It
106:39 - didn't took time to complete, actually, the interactivity of your page. It's a very common
106:46 - error that you get when you are doing some SSR. What are the pros and cons of SSR? Of course,
106:51 - it's the opposite of the client side. We got a search engine optimization pro, which is very big.
106:58 - Universal rendering delivers the entire HTML content to the browser as a classic server
107:04 - application. Web crawlers can directly index the page content, because at this step, we have the
107:10 - hydration, and then we get also the page content already rendered, which makes universal rendering
107:17 - a great choice for any content that you want to index quickly. Then, of course, you get the
107:23 - performance. User can get immediate access to the page content, because browser can display static
107:28 - content much faster than JavaScript generated one. However, with SSR and universal mode, we got some
107:36 - cons. And the first for me, it's the developer constraint that is written there. Server and browser
107:43 - environment don't provide the same APIs, and it can be tricky to write code that can run on both
107:50 - sides seamlessly. Of course, writing HTML, CSS, Vue.js, React, whatever, on the client side is
108:00 - a different behavior than writing it on the server side. When you choose to work on the server side,
108:07 - you will encounter maybe errors that you never encountered before, and you will have to deal
108:12 - with it. However, the next documentation is very well provided to deal with those problems.
108:18 - Also, it's a problem of cost. A server needs to be running in order to render pages on the fly.
108:25 - This adds a monthly cost like any traditional server. Of course, because you are not just
108:30 - delivering some pages, you are making your server running to make the work instead of the client's
108:36 - browser, so it has a cost, of course. However, the server calls are highly reduced thanks to the
108:43 - universal rendering with the browser taking over on client side navigation. Why do we use universal
108:51 - rendering? Well, for blogs, marketing website, portfolio, e-commerce website, and marketplace.
108:57 - Finally, by default, Nuxt uses SSL or universal rendering to provide better user experience and
109:04 - performance to optimize search engine indexing. What is new with Nuxt 3 and what was not in Nuxt 2,
109:15 - which means here, it's the eBread rendering. eBread rendering allows different caching rules
109:22 - per route using root rules and decides how the server should respond to a new request on a given
109:28 - URL. So now, basically, with this eBread thing, what we can do is that we can specify on each page
109:36 - what strategy we want to choose, either client side, either universal rendering or server side
109:42 - rendering. But also, what we can deal with is caching. And as I explained before, what we can
109:50 - do is to choose when we want to cache our page and to put an interval between the time we want to
109:57 - have fresh data. Caching helps us to deal with this server that will build, actually, every time
110:05 - there is a request, your application, and deliver it. Instead of dealing with every request and
110:12 - every time building the app, what we can do is to cache our application. And, of course, this
110:19 - eBread rendering is possible because of Nitro, the new server engine that powers Nuxt 3.
110:26 - So please refer to Nitro to know more about caching. And we can continue on the root rules.
110:34 - Because previously, every root page of Nuxt and server must use the same rendering mode,
110:40 - client side, and universal. Now, when eBread, we can specify on the root what we want to use.
110:47 - Using root rules, you can define rules for a group of Nuxt rules, change rendering mode,
110:53 - and assign a cache strategy based on root. So down there, we've got an example with define
111:00 - Nuxt config. So you understood that it happens there in our Nuxt.config.ts. So what I can do
111:07 - instead of having this SSR true is to have a root rule entry. And in this root rule entry,
111:13 - which is an object, I can specify the name of the root, the URL of the root, which is related there
111:21 - on a page. And I can specify if I want to use server side rendering or not, if I want to use
111:30 - some header, for instance, or if I want to have just static. And I can also work on headers with
111:36 - redirect and status code and et cetera, et cetera. So with this root rules, we can specify with these
111:44 - options, okay? We can specify which type of rendering we want to use. And that's the new
111:50 - thing with Nuxt free, this hybrid possibility that we didn't get before. We had to put on the
111:56 - entire application that we want to use SSR or just static. Now we can use both.
112:08 - When we go on the official documentation, we can see that Nuxt provide use fetch,
112:14 - use lazy fetch, use async data, and use lazy async data. So we are going to start by use fetch.
112:22 - And what we're going to do at first is to go on our project and on Nuxt.config.ts,
112:29 - I'm going to put my SSR model files. So like an SPA or a static website. All right. So now I'm
112:37 - back. And now my application is not declared as a server side rendering mode for now. So by default,
112:47 - Nuxt free is on SSR. But we just removed this SSR mode. So everything is happening client side for
112:54 - now. And we are going to start with use fetch. Within your page components and plugin can use
113:00 - use fetch to universally fetch from any URL. Universally it means on the server side or on
113:08 - the client side. This composable provides a convenient wrapper around user async data and
113:14 - fetch. So that's very nice to see. However, what is async data? We are going to see it after.
113:21 - And what is fetch? Well, it's actually dollar fetch. Because we know that we know JS, we have
113:26 - this method fetch that helps us to fetch some data. And actually it's also available in JavaScript
113:32 - regularly. So we have this dollar fetch. And if we go on the API side documentation of Nuxt,
113:42 - we can see that the definition of use fetch is these composables provide a convenient wrapper,
113:47 - exactly what we read, around async data and fetch dollar fetch. So it's a combination
113:55 - between use async data and fetch. And if I click on dollar fetch, we see that dollar fetch is
114:01 - actually a function that is globally exposed. And that function comes from a library called offetch.
114:11 - And when I click on offetch, I arrive on a repository. And it's called a better fetch API,
114:18 - works on node, browsers, and workers. So this fetch here is available on free side, node, browser,
114:25 - and workers. And it comes from, of course, NGS, the unified JavaScript tools that we talked about
114:33 - before. So use fetch automatically generate a key based on URL and fetch options, provide type
114:40 - hints for request URL based on server roots and infer API response type. And down there, we've got
114:47 - an example. So we see that at first, our use fetch method can be destructured. And it can be
114:56 - destructured in different types. And we can look at this type down there. We've got data, which
115:03 - maybe will be the response. And of course, it will be the response. But we got also pending. And
115:08 - pending can be a loading state that will be very useful. We got also refresh, which means that
115:15 - actually later we will get a function called refresh that when we click on it, we'll refresh
115:19 - the call and the data. We've got execute, and we got also error to actually display the error.
115:27 - And as options in our fetch, we've got a lot of other elements. But we are going to come back at
115:33 - it just after. What I need to do for myself is just to fetch from an API. And actually,
115:39 - which is cool with next, is that we can create a server side. So what we got here is a server
115:45 - folder. And inside, I got a product, a product root, which is available at localhost slash
115:53 - API slash product. And I got this Gson. And you understood now that this root products will
116:00 - distribute my Gson array. So back in my products.ts, what I can do is just to import my data. And
116:09 - when I call this endpoint, it will return to me the data from my Gson. So I'm going to get back,
116:16 - I'm going to update. And there what I'm going to do, I'm going to go on localhost slash API slash
116:22 - products. And there we go. We've got our data there. So the thing is that now on my index,
116:28 - what I want to do is to just fetch this endpoint. So what I'm going to do is simply to put
116:37 - const data and like it would be a response. Actually, I'm destructuring here, my response.
116:43 - I'm going to type use fetch. And here it's going to be API slash products. And what I want to do,
116:50 - I want to console log this data. There we go. Let's get back. Let's update. And we see suddenly that
117:00 - we have actually a reference. And which is cool is that immediately the data that is coming from
117:07 - my API has been turned into a reference value. So what we need to do is to type data.value,
117:17 - because there is some value there. And there we go. We see that we've got our data with our array.
117:22 - However, it's still a proxy. So that's a bit a problem. What I would need to do is first,
117:30 - I'm not going to call it data. However, I'm going to call it products. And what I would need to do
117:36 - is actually to transform to row if I want to access into my JavaScript to the data this
117:42 - products.value. There we go. I update. And suddenly, there we go. I got my 10 products
117:52 - available, which is amazing. That was for the JavaScript part. However, if I want to put it
117:59 - into my template, I will put products there. And what's going to happen there? Amazing.
118:09 - What's happening is that we've got our products displayed there. And here, the most interesting
118:15 - part of your search is that right now I got this data there. So I can put as an option here,
118:23 - I can put as an option a method called transform. With transform, I can say that I want to change
118:30 - the model that is returned to my view. What I'm going to do is to open an object just after my
118:37 - call here. And of course, later, you may need to put some kind of headers or anything else.
118:44 - You can do it there. All the keys that you need to find are in the API docs. And here we see that
118:51 - we got many keys such as key, method, query, params, header, lazy, immediate, watch. Anyway,
118:59 - what we want is to use transform. And with transform, what I'm going to do is to access
119:05 - to my products. And here, what I want to return is actually products.data, because I got this data,
119:13 - which gives me the array. And what I want to have immediately is just the array and not this data
119:21 - in front of it. So you see, you can use transform to get it. Now, if I go to my nugs.config.ts,
119:28 - and I remove this SSR false, and I pass to SSR true, so now I'm on server side rendering, what
119:35 - happens is that nothing is happening. Because remember, use fetch can be used on SSR true or
119:43 - SSR false. So if you are doing client side, it will work. If you are doing server side rendering,
119:50 - it will work also. And you won't see the difference at all. And what we want to do now, we want to use
119:56 - this loading pending, actually, that is available there, which is a Boolean. So if I get back to the
120:04 - use fetch documentation, we see that I get this pending, which is a Boolean. And what I would like
120:09 - to do is to display, actually, a loader while I'm waiting for an asynchronous call. So what we would
120:20 - like to use is another function, which is called use lazy fetch. Because use fetch is freezing your
120:29 - application until the moment it receives the data and then it renders the data. With use lazy fetch,
120:37 - we want to display a loader, so display the application immediately and display a loader
120:43 - instead. So it means that here in my data, what I need to do is actually to return a promise. So
120:51 - here it's going to be an asynchronous call. And what I want to do is to return a new promise,
120:58 - the old way. Okay. And then here I will have a resolve and reject. I'm just going to use
121:06 - resolve that I will not reject. And there I'm going to actually put a set timeout function.
121:14 - And this set timeout function will answer after 2,000 milliseconds. And what's going to happen
121:21 - is that I'm going to resolve. And what I'm going to resolve is my data. Okay. So I'm going to save
121:28 - this. And back in my application, what I'm going to do, I'm going to say, hey, if it is pending,
121:34 - I want to have loading. Otherwise, I want to have the products. All right. So we have a
121:41 - function which is called use lazy fetch, which is a use fetch, but that is not freezing our
121:48 - application. And on the product's end point, we have a promise. So we're going to wait for some
121:55 - time, actually 2,000 milliseconds or 2 seconds to render our app. So let's try. I'm going to update.
122:04 - And what's happening is that we have a loading during 2,000 milliseconds. And we have then the
122:13 - array that is displayed, which is very cool because most of the time with this use lazy fetch,
122:18 - we would like to have some kind of skeleton waiting for the app. And it's working very well.
122:31 - Let's talk now about use async data. Within our page, components and plugins can use
122:38 - use async data to get access to data that resolve asynchronously. And we have a definition about
122:44 - the difference between use fetch and use async data. Use fetch receives a URL and gets that data.
122:51 - Whereas a user sync data might have more complex logic. Use fetch URL is equivalent to user sync
123:00 - URL fetch URL. It's developer experience sugar for most common use case. And down there, we've
123:07 - got an example of actually this user sync data, which actually is fetching an endpoint with a
123:16 - counter there example and this user sync with this time a key and another URL and a function
123:24 - which calls actually dollar fetch. And it returns a promise. And it's using the callback that you
123:31 - will put in it. So there we've got this fetch which is there. And we've got this user sync data. So
123:37 - the best thing is to put an example. In my endpoint, I'm going to create a new function,
123:45 - which actually will wait for a promise on a project count. So we've got a product count
123:52 - value up there. And after two milliseconds or two seconds, we are going to actually increment
123:59 - this product count. And finally, we are going to return this product count. So when we are going
124:05 - to call this slash API slash product, we will wait for 2,000 milliseconds. So we will need on the
124:14 - index.view to wait for that call. So it would be asynchronous. And finally, we will return our
124:20 - product count. So back in my index.view, what I will need to do is to use async data on a key,
124:28 - which could be product. And there, what we will need to do is to open this function. And this is
124:35 - our callback. We will have the answer of this fetch. And this is this fetch that is going to
124:40 - make the call. And remember, this promise will be returned. And then we will get the data. And we
124:46 - will have our pending there. So I'm going to get back. I'm going to update. And what we see is that
124:52 - there we go. We've got our product count. But there was no pending. Now I know that my server
124:58 - is running and that there is this actually every time I fetch this incremental function, what I
125:06 - can do is here using a function to refresh my call. So what I'm going to do actually is to declare in
125:15 - my template a button. And this button will trigger a function that will be called refresh. And
125:22 - this refresh function will use another function provided by nux, which is refresh nux data. And
125:29 - here, this is where I'm going to use the key of my function. So I got products, which is there.
125:36 - So I get back. And when I click, we see that I got finally my loading because it's already rendered.
125:44 - And every time I refresh, it's incrementing my product count. Okay. So now I'm going to use
125:52 - actually use lazy async data. And it's the same thing as use lazy fetch. Sorry. If instead of
126:03 - having an incremental function, we would have a set interval that would be actually triggered every
126:12 - second. Now what I have is this use lazy async. However, I don't have any asynchronous actions
126:21 - there. So what I can be back is on user sync data. And when I get back and I click on refresh,
126:28 - we see that it's been 33. Actually I said product count, but it's actually seconds. I got 36 seconds,
126:36 - 42 seconds that my server has been running because it's already turning there. And we've
126:43 - got this product count incremental every second. We saw that nux 3 is providing to us several
126:50 - methods to fetch data. The first method is use fetch. And actually use fetch, which is a composable,
126:57 - help us to fetch data universally. So on front side and on the back end side. And we can fetch
127:05 - that from any URL. And actually use fetch is a combination between asynchronous call, which can
127:12 - be used with the composable user sync data, and dollar fetch, which is coming from the method
127:17 - or fetch from the library and the organization of NGS. We also saw that we got many other options
127:26 - that we can pass on our fetching composables provided by nux. And this function can help us
127:33 - to watch some elements to refresh or to put some others, some keys, method, queries, and params.
127:39 - Also nux 3 is working with cache. And we've got a function called clear nux data that help us to
127:47 - clear the cache data that we fetch. Because when we use with async data, the key, we get some cache
127:53 - that can implies some data that will be not fresh. To refresh the data, you can use the clear nux
128:00 - data function. The common problem is to pass the client headers to your API. And there is a method
128:07 - provided by nux, which is use request header. And we see here that we can pass directly the headers
128:13 - on use fetch. If you have a frontend application, you might want to work on the SEO. The search
128:23 - engine optimization is going to help you to be found on Google. And of course, with nux 3,
128:30 - we got everything we need to index every page with the right SEO methods that we can put
128:36 - inside a built-in composable that is available, which is use head. On the official documentation,
128:44 - we see that we got several options to set the SEO methods of our app. And the first one is to go on
128:52 - our nux.config.ts. So we can read providing an app.ed property in your nux.config.ts allows you to
129:02 - customize the ad for your entire app. This method does not allow you to provide reactive data. If
129:09 - you need global reactive data, you can use use head in app.view. So if we go here on the nux.config.gs,
129:18 - the first thing that we can do is to open an app object actually. And inside, we can put a head.
129:28 - Okay, so here, this head is going to be everywhere in every page of your app. So if you have several
129:36 - page later there, it will take the head from here and put it everywhere. So let's get an example.
129:41 - So I'm going to put title nux course on YouTube, whatever. I'm going to save this, look at my
129:49 - server. So it's running again. And then I come back. And what we see up there is that I got nux
129:57 - course on YouTube that is inserted here. If I inspect, and I open my head, we can see that
130:04 - suddenly I got my title. So let's continue. Let's say that there I'm going to have some kind of
130:10 - description. This is a repository for a course about nux3 for YouTube. So here we see that
130:22 - description is not available, of course, because you get a stick to the model of the head object.
130:28 - So when I go on here, what I can see is that on app, I can specify many things. And I can specify
130:37 - head. Later, we will see the whole configuration. But for now, let's just stick to this SEO thing.
130:45 - So I got my head. And we see that actually what I'm trying to put is a meta. So this description
130:51 - is supposed to be a meta. And what I can do is to open this meta. Meta is actually an array.
130:58 - And inside, we're going to put some objects. And these objects here will get name, content,
131:05 - a lot of stuff. So the meta that I want to put, actually, it's actually content. And here,
131:15 - this is where my description should be. So I'm going to put name. And then I'm going to put
131:21 - description. There we go. He understood. So I'm going to save. Now I'm going to get back.
131:28 - I'm going to update. And I'm going to open my head. And I will see if I will get my description.
131:35 - Okay, I got my description, which is available there. So when we look at actually the documentation,
131:42 - we can see that we can add also link, style, script, no script. And finally, we will find
131:48 - something like this. And we will get all the SEO provided by default on the nux.config.ts.
131:55 - If you got an app where you don't want to put some SEO on pages and just got a general SEO for
132:01 - the whole application, you should use this method, go on nux.config.ts. However, if you don't get
132:07 - this, let's remove it. And let's doing it page by page. So I'm going to get back to the first
132:13 - page, which is index there. And I'm going to get back also to the documentation there.
132:20 - So when I get down, and here I had an example that I could use,
132:25 - again, we already saw that we can put everything on head. I can also use page by page, this use
132:31 - add composable. The use add composable function allows you to manage your tags in a programmatic
132:37 - reactive way, powered by you view use add. You use again, we saw it before. It's a combination
132:45 - actually of many composable that we can use in the library, in the library views. So what I want
132:52 - to do, I'm going to do exactly the same. And if we look at this object inside use head, we can see
132:59 - that it looks exactly the same as in nux.config.ts. So I'm going to get up there, I'm going to open
133:06 - a script as setup. And the thing you should not miss there is that you want to say that you are
133:12 - going to use TS, okay, as a lang. So I'm going to use type script. So let's use this composable,
133:19 - I'm going to type use add. And inside there, I'm going to put everything that I need. So just going
133:26 - to copy paste actually this example. So here I'm going to have a title, and I'm going to put this
133:32 - is my homepage for nux course. And I'm going to put as a description page where you are going to
133:45 - find everything about this course of nux or okay, then I could put some body attributes,
133:53 - then I could put some scripts or links or whatever. Alright, this is done. I have complete
133:58 - my methods on my use head. And every time I'm going to go to index, I'm going to find in the
134:05 - end, actually, all the content that I have added. So this course is not really about SEO, but it's
134:12 - just a good way here that I'm showing you to add some SEO on a specific page, we would catch this
134:18 - ID with the use root composable available by view free. And we would catch actually the
134:25 - param of this product ID. And then we would inject this product ID directly inside our
134:30 - title, for example, right now, I'm on the index.view page. If I go on the profile.view page,
134:36 - actually, I want I would like to change the SEO. So again, I'm going to open a script setup
134:42 - length, yes, and I'm going to do exactly the same, I'm just going to use add there, and I'm going to
134:48 - write my SEO. And there I'm going to write my SEO concerning my page. So here I'm going to have a
134:55 - title, which will be profile page. Okay, now, here I'm on index. And if I go on slash profile,
135:04 - we see that my SEO methods have changed, of course. So you could work on every page,
135:12 - you would like to put SEO on. And of course, if you would not have some SEO, you could provide it
135:19 - here inside the use head object. And another thing is that I don't know if you noticed, but
135:24 - in the previous example, we had this script. So you could add as a script there, directly with
135:31 - the use head, thanks to the use head, the script you would like to launch. So right now, we've got
135:37 - a console log Hello World. So when I come back to this index page, we see that I got my Hello World
135:44 - that has been triggered here. This is a good way when you want to call a CDN on a specific page,
135:51 - instead of putting the CDN link here in nux.config.ts. There is another way to deal with
135:58 - SEO. It's by components. Nux provides title, base, no script, style, meta, links, body,
136:06 - all those built in components that we can interact directly with your metadata within your component
136:14 - template. So let's have a look there, we see that we got just a specific template there. And we've
136:21 - got a head component with title just down there. So I'm going to get back in my index, and I'm going
136:29 - to remove all of this. And what I'm going to do is inside my homepage, I'm going to use this head
136:37 - that I got there. And I'm going to use the title built in component. So this is my title. For any
136:44 - reason, you would like to have this component there. So when I get back, and just I update,
136:50 - there we go, we see that I have this is my title. And if we continue, we can see that I can have
136:55 - some description and some style also. So in my case, it's useless because I already got tailwind,
137:02 - but I could have a dynamic title. So I'm going to have my dynamic title. And here, this is my
137:10 - dynamic title. Of course, if it would be a dynamic title, it would be under a ref. So I'm going to
137:18 - get back. And look at that. I got this is my dynamic title. And we saw that the background was
137:24 - suddenly green. However, this body green here has been removed by my tailwind. So we could have
137:31 - some style. We could have some many other elements related to the built in components provided by
137:38 - Nux. As I said to you before, you could have some dynamic data. And here we've got an example with
137:44 - the reactivity. Reactivity is supported on whole properties as computed, computed getters,
137:50 - ref and reactive. There we've got the example, we could inject the title that we got there inside
137:56 - our user head. Of course, if you want to use third party scripts, you can also inject the scripts,
138:02 - as we saw in the user head before. And you can say with the body true that you want them to appear
138:09 - at the end of your body and not specifically into the template. Remember when we talked about the
138:15 - layout, we saw that by page, we could put the layout we would like. And we use define page
138:22 - meta, the built in composable, which is available everywhere in my next application. And here we see
138:29 - that we can also define the SEO through the define page meta. So what is the difference between
138:35 - use head and define page meta? Well, the documentation doesn't explain very well
138:40 - what's the difference between define page meta and use head. But I guess that if you really want
138:45 - to work on SEO, you would use use head and define page meta would be for more less specific data
138:52 - that you would put into your metas. The lifecycle hooks, what is it? Nux provides a powerful hooking
139:04 - system to expand almost every aspect using hooks. This feature is powered by NGS hookable. These
139:12 - hooks are available for Nux module and build context. Here we get the example with close.
139:18 - However, if you want to have the list of all the hooks, you can go there in the API documentation
139:23 - at advanced. And then you can click here on lifecycle hooks. And suddenly we've got the list
139:29 - of every hook that we can use with a description. And it's also telling us the environment we can
139:35 - use because sometimes it can be server, sometimes it can be client, etc, etc. The other way is to
139:42 - go here inside your nux.config.ts. And you can click on the hook. And suddenly we can look at
139:49 - the interface of the next hook. And down there we've got a list actually, which is exactly the same.
139:56 - And we see that we've got build before, pages, extend, imports, etc, etc. We've got a lot of
140:03 - hooks when we can trigger some operations. So I'm going to pick up a status ready because it's in
140:11 - the list. And instead of having this nux that I'm going to catch, I'm going to just console log the
140:19 - context because I guess that I got my context already available there. I'm going to stop and
140:26 - restart. And I'm supposed to have my context that is console log. And we can see it there.
140:32 - So sometimes you would like to create some hooks at certain moments. And you would like to trigger
140:39 - some operation for any reason. Well, you can use actually all those hooks that are available there.
140:46 - And be safe because some hooks, they are triggered in some environment. Some can be server and client.
140:54 - Some can be on the server. Some can be only clients. Another thing that we could do is to use
140:58 - those life cycles inside a plugin. So here we've got an example of a plugin that would be triggered
141:05 - every time there is a page start. So I'm going to copy paste this. I'm just going to remove this
141:10 - hook that I have there. And I'm going to go on my plugin and I got a plugin.ts that comes back from
141:17 - a preview score. And here to my context, I would add a new hook on the app created. And I would like
141:24 - to console log from plugin. And what we see that I already got hello from plugin. And here I got
141:30 - hello from plugin two. I could add some hooks from some plugins. When I would like to trigger some
141:36 - operation at certain step of the initialization of my... Another subject that we are not going to
141:41 - treat here, because it's related to Nux but not directly, is the usage of Nuxkit. Nuxkit is the
141:48 - library that helps you to create modules. And if you would like to create a module, also you could
141:55 - loop through the Nux context and add your own hook inside the module that you would like to create.
142:00 - In terms of configuration, Nux give us access to a config file at the root of our application.
142:13 - In this config file, we can configure the whole project, but we can also actually add some modules,
142:21 - we can add some CSS paths, or we can add some specific configuration related to the module we
142:28 - add. Previously, we looked at the Nux.config.ts, and we worked on the CSS paths on the modules,
142:37 - and we had it, for instance, post CSS with a config here a file. For instance, I can give you
142:44 - a first example. On our project right now, we've got Tailwind CSS. So basically, with the module
142:50 - of Tailwind that I didn't use, actually, what I could do is instead of having this Tailwind.config.js,
142:56 - I could grab actually this whole object there and add it here in Tailwind CSS directly here.
143:05 - That's the purpose of this Nux.config.ts. The idea is that when you are going to inject a module
143:12 - to your application, later you will have some configuration file from another library.
143:18 - The idea is to never have this config file except the Nux.config.ts, which here plays the role
143:28 - actually to the place of the whole configuration of your project. What I just said concerns only
143:34 - the modules. However, we have some other configuration that we can add to our project.
143:41 - So if we look at the documentation, we see that in this defined Nux config, which is a
143:47 - method provided by Nux natively, we can inject this big object. In this big object, there will
143:53 - be the whole configuration. When we look at it, we have a lot of options. Which is interesting is
144:00 - that we can access this config also, this runtime config. We can access it inside our DOM by just
144:08 - using this inside our view. Then later, we've got a lot of configuration. Again, this app config is
144:15 - available. If we want to look deeper at it, you can go on get started configuration. But for me,
144:24 - now what I want to do is to show you most of the options that are available actually in this
144:30 - configuration file. During this presentation, we are not going to pass on every configuration key
144:37 - that you can add. It will be useless. I'm just going to talk about those that are the most useful
144:43 - in my opinion. Previously, we already worked on some alias and especially on the assets folder.
144:52 - Instead of having a very long pass that you will write by yourself with points and slash,
144:58 - you can use those aliases. Here you get the options that says that actually you can access
145:06 - through the specific folder that you want with the related pass. Instead of having slash and root
145:14 - there, we would add an add, for instance, or we would add assets slash name of the image.png.
145:21 - That's a very useful config that you can have. Then we have the app object. You have the base
145:28 - URL if you want to change the base URL of your application. You have the build assets there.
145:34 - Basically, when you build your application, you have by default this underscore next.
145:42 - The folder name for the build assets relative to base URL. You can change it with build assets
145:47 - there. You get the CDN URL, an absolute URL to serve the public folder from production only.
145:55 - Basically here, if you would like to change, you would type directly CDN URL, blah, blah, blah,
146:01 - immediately. You get the head that we already saw in the course on SEO that helps you to define the
146:09 - SEO for the global application, which can be actually here a problem because sometimes you
146:14 - want to have different SEO data or metas inside every page. Keep alive. That can be disabled.
146:21 - Keep alive again. It's when you want to keep alive a component with its data instead of
146:26 - just destroying it inside your app. You get the layout transition. We didn't see the transition.
146:32 - However, you imagine that irritating from view with Nux, you can do some transition.
146:38 - You can turn on false or true your layout transition. Same for the page transition.
146:45 - You can change the root ID. Here we see that on my div. I got underscore underscore next.
146:51 - If I want to change this ID, I can do it with the root ID. So basically I would go there
146:57 - and say that for now, the root ID would be Guillaume in, for instance. There's also the build year
147:03 - option that helps you to change actually the name of the build directory that you will have.
147:09 - So here we got dot next there, and this is the build of your application. It's actually
147:14 - what is delivering your application there. If you want to change the name, you can type build year
147:19 - and it will create a folder with a new name instead of dot next. You got the debug option,
147:27 - which is clearly cool because it logs out when you get a problem or not.
147:32 - It prints out OX names, timing on the server, logs, everything that is related to the next app.
147:39 - If you want to turn it off, you can go on your app and just type here debug false,
147:44 - and then you will not have the console log in your console.
147:48 - Then you got the dev server option. If you want to improve your developer experience and change,
147:53 - for instance, the host, the HTTP, the port, the URL, you can do that in the dev server object.
148:02 - Inside, you just enter those key and you change them.
148:05 - If you want to customize all the architecture of your project and change the name of the folder
148:11 - for any reason, you can use also deer. Inside deer, you can specify where you want assets to be,
148:18 - so change the name of assets, the name of layout, middleware, pages, plugin, public, and static.
148:25 - It can happen to you that you have extensions that are not resolved by Nuxt and you have to
148:31 - specify them inside your nux.config.ts. For instance, there we've got this extension array
148:39 - and we've got some.gsfile,.gs6,.mgs,.ts,.ts6,.vue, or maybe we could have some GQL if you do
148:48 - some GraphQL. You would have to declare them inside your nux.config.ts. So especially there,
148:56 - what I would do is here, for instance, to say extensions, which would be an array and it says
149:03 - CSS, but actually it's not CSS, it would be GraphQL or it would be.gql, for instance.
149:11 - And then my Nuxt application would resolve these files with this extension. Previously,
149:18 - we already saw the modules, so you can add a module entrance and add your modules there.
149:23 - You can also use the root deer option that helps you to define where is your Nuxt application
149:30 - and where Nuxt has to look at when it's building your app. If you want to work on the configuration
149:35 - of VIT, you can also do it in nux.config.ts. There is a VIT entrance that gives you all the access
149:43 - that you need, for instance, to the ears build configuration, the public directory, the resolve,
149:49 - the root, the server, all the options related to Vue. And finally, there is a big set of options
149:56 - to configure Webpack, because if you are already a front-end developer, you know that with Webpack,
150:03 - you will have some configuration that you would do through a webpack.config.ts file.
150:09 - Here, of course, you can do it through nux.config.ts.
150:18 - One of the most interesting modules provided by the Nuxt community is Nuxt content. Why?
150:24 - Why? Let me give you an example. Sometimes you are creating websites,
150:29 - and on those websites, there's only static content. This static content is just written
150:35 - directly in raw on your HTML. Well, and you don't need necessarily to create some JavaScript
150:43 - interaction and stuff, you just want to put some static content, such as text, videos,
150:50 - photos, or images, whatever. For that, what you would do is just to create an app and write
150:57 - in HTML your title, your paragraph, and stuff. However, one of the most interesting things
151:03 - is that you could write this content in markdown. And writing it in markdown would be easier than
151:11 - writing a whole application in HTML, CSS, and to set it up, etc. Next content is providing
151:20 - an amazing solution for that kind of problem. Most of the websites that are written to be
151:26 - documentation are static content. Let's take an example. Here we've got this Nuxt content website
151:33 - on content.nuxjs.org. And this website is just static content. There's only text written down
151:42 - there. So what we would like to do is not to write HTML, but instead to write markdown.
151:48 - And maybe sometimes we would like just to write JSON to display some website. We can do that with
151:55 - Nuxt content. With the module Nuxt content, we just need to have a folder called content,
152:00 - and Nuxt is going to watch our folder and translate our markdown files into HTML pages.
152:08 - It will even do the routing between the pages, and you will be able to change from a page to another
152:14 - one just by creating the file. You will not need to register any route. You will not need to do
152:21 - anything. It will work really easy. So what I propose to you is to create a content,
152:27 - actually a content website, a static website with Nuxt content. So I'm going to click on
152:32 - get started. And down there here I got a command, npx nuxi init content app. So I'm going to copy
152:40 - paste this, get back, and I'm going to enter in my folder. There we go. And here it's going to create
152:49 - for me a content application. It's a Nuxt application. So everything that you've learned
152:55 - inside this course will be available inside this app. So I'm going to enter into it. Once I'm into
153:02 - my project, what I can see again is that it's a very, very light project. There's only an
153:07 - app.view with a Nuxt page at the root. I got a page component with a slug, and I got this content
153:14 - doc. Content doc is just the routing system of Nuxt content, a built-in component provided by
153:23 - Nuxt content that displays all the pages that will be in content. And if I look in my package.json,
153:29 - what I can see is that as dev dependencies I get Nuxt, I get Nuxt content, and I get this
153:35 - folder called content, and inside I have markdown files. I have about, I get index, and just let's
153:44 - run our project, and that's it. We have our website running Nuxt content, and it says this page
153:51 - corresponds to the slash root of your website, blah, blah, blah. And these two pages are rendered
153:56 - by the pages slug.view. So here we see that we've got a slug, and we've got our index. So I'm going
154:03 - to try to go on slash about to see, and there we go. I got this about page, and actually this about
154:09 - page is coming from here. So here I can write in markdown. So to write in markdown, the syntax is
154:16 - really simple. You can find a lot of websites that we teach you how to write in markdown. You may
154:22 - know already markdown because you already wrote some readme by the past, but here I can write
154:29 - content, okay? So I'm going to save this, and as you see, immediately, it's rendered. So why would
154:36 - we do that instead of creating HTML pages? Well, the thing is that if you are working on your SEO,
154:45 - it can be very useful to create a website this way, because the content here will be rendered
154:52 - immediately because it's just static content, and there will be no JavaScript that will run
154:58 - inside your website. So for SEO purpose, it's amazing to use next content. Also, if you want
155:05 - to write some kind of documentation or some kind of blog, you would use that because it's easier
155:11 - to write here some content and to use the syntax, for instance, title syntax of markdown. There we
155:21 - go. As you see, you could be way faster by writing here in MD file instead of working in an HTML
155:32 - file. Let's create a new page. Let's say that we're going to have some kind of new file called
155:37 - profile.md, and here I would like this is my profile. Hello, my name is Guillaume. Okay,
155:46 - I'm going to save this, and now I'm going to go to a slash profile, and I type enter,
155:53 - and immediately my root has been created. So of course, this markdown is really limited. You
156:00 - cannot do any JavaScript or very complicated stuff into it. It's not made to create web application,
156:07 - really. It's more to create some content. So another thing is that right now my website is
156:14 - totally empty. I would like to put some style. I would like to create, actually,
156:23 - just some design, you know. I would like to add some colors. I would like to add some style,
156:27 - et cetera, et cetera. Well, what we could do is going back to the Nux.com documentation and go
156:34 - to the modules, and what we could do, we could add Tailwind as a module. Instead of adding it
156:42 - directly from the Tailwind documentation, what I'm going to do is to install this Tailwind module.
156:47 - So I'm going to stop, and I'm going to install Tailwind as a module. Then I will need to add it
156:54 - to my modules there. So I'm going to go to my Nux config, and actually Nux content is working
157:00 - exactly like any other module. As you see here, we've got Nux content that has been added,
157:06 - and we've got Tailwind CSS. So you can either create a Nux content application
157:10 - through this Nux content NPX init, or you can still add Nux content to your existing project.
157:18 - Okay. So I've done this. So now I'm supposed to have Tailwind CSS installed. So now I'm going to
157:24 - type yarn dev. There we go. And if I get back to my app, I should have Tailwind CSS. That is apply.
157:32 - And there we go. So now I got Tailwind CSS. What I can do is actually to inspect my markdown file
157:42 - that has been transformed as an HTML. And we see that here I got an H1, I got a paragraph, et cetera,
157:49 - et cetera. So what I can do is to create my own design system. I can right click there,
157:54 - create a new folder. I'm going to create an assets. And in this, I'm going to create a man.scss.
158:01 - So what I would do is to stop my server and to type npm install sass. And what I would do
158:09 - actually is just to type yarn dev. And I will add my sass here, file to my CSS inside my
158:19 - nux.config.ts. So I'm going to type at assets main.scss. And I would save that.
158:28 - Here what I would do is to import from Tailwind my base. And I would target my layer base,
158:34 - which is actually the basic layer that I'm using with Tailwind on my application. And what I would
158:41 - do, I would say, hey, I want that my H1 would be apply text red 500. That's a color from Tailwind.
158:49 - So when I get back, we see suddenly that I got my title there. And exactly it would do the same on
158:57 - every page. Okay. So what I could do also is just to put all these contents so I can get back
159:03 - to my slug. And here on the main, I could say that I want to put a container emix auto there.
159:10 - So I would say, there we go. And what I could do also, I could add some margin on the top and on
159:17 - the bottom with MY4. And there we go. So as you see, now I can create my own style sheet, my own
159:26 - design system, and then apply it to my content everywhere in my application. Again, for the
159:33 - routing, what I can do is just to use the markdown. So here on About, we see that I get a link.
159:40 - Let's go on Index. And let's just remove this. Let's say Home. And let's say that I want to have
159:45 - a link that would say, go to profile in with time slash profile. There we go. And I want to style
159:55 - my links. So I'm going to go here and say that all links will have, for instance, a color. So text
160:04 - till, yes, let's say till 600 and underline, whatever. I'm going to save that. And there we go.
160:12 - And when I click, I can go to the page I want with the routing system. If you want to know
160:18 - more about Nux content, you can go on the documentation. You can do that with markdown,
160:24 - with MDC syntax. You can also work with JSON. As you see here, you can apply some JSON.
160:31 - What you would do is work on YAML also. And you can work also on the displaying, on the rendering.
160:38 - If you have some questions about some stuff that you would do, you can go here and look at rendering,
160:45 - querying, navigation, etc. Everything is provided. A last thing, if you want to add some SEO to your
160:52 - page, because now we are working with markdown, what you can do is at the top of your file,
160:58 - you can specify, for instance, the title of your page. So this is my Nux content main page,
161:07 - whatever. And when you get back here, we see on the top that I got, this is my Nux content main
161:12 - page. So if you want to work on some methods, you can add them here on the top. And which is cool
161:18 - also with Nux content, it's that it's really easy to deploy. It's really fast, because it's just
161:25 - static content that will be built and rendered. We saw that with Nux content, we can create static
161:36 - website, and we can, of course, if we want, create some documentation. For this practical exercise
161:42 - that I propose you to end my course on Nux, what I would like to do is to create some kind of
161:48 - fake API that we would request. And next to it, I would like to create a fake documentation.
161:55 - Okay? So to do that, I can do entirely all these steps inside Nux 3, because I can create my API
162:01 - with server. But of course, I can also create my documentation with Nux content. However,
162:08 - when we start a Nux content project, it's empty. There is no styling, there's nothing to do.
162:15 - You have to build your own style. And actually, with Nux, what we can do, we can add our own
162:20 - themes. And our themes can be used to give some style to a website. If you look online,
162:26 - you will find some themes. And actually, we have one. And this one is used to make the website of
162:32 - Nux content. This theme is creating all this styling there. And all this website, if we look
162:40 - at it quickly, we will find that this website is using the theme called Docuus. Docuus, that you
162:47 - can find at Docuus.dev. It's actually a theme for Nux that helps you to just install a documentation
162:57 - website, a simple one, this way. So it's really simple to use, actually. But the thing is that
163:04 - you will have a documentation with a sidebar and everything already set up. So you will
163:09 - win a lot of time. I'm going to start by installing this theme as a new application.
163:15 - At this point, you should use a specific version of Nod. And if possible, the version 16. So me,
163:22 - I'm going to look by typing NPM, NVMLS, sorry. And I'm going to use the 16.17.1. Because the 18,
163:32 - there might be some bugs. So here, I'm going to say NVM use 16.17.1. There we go. And now what
163:41 - I'm going to do, I'm just going to copy paste this to create my project. And there we go. We
163:46 - got our Docuus that has been initialized. And if we take a look at it a little bit, we can see that
163:53 - it's a bit different. We've got some TS file, renovate.json. There's a bit of different
164:00 - configuration here. But actually, it's still using Nux 3, which we can see on the dev dependencies,
164:07 - the Nux team Docuus. So here, we've got our content. What we're going to do, we are going to
164:13 - launch it right away. So I'm going to type yarn and yarn dev. I got an empty documentation that
164:20 - is available with some specification. I can turn it to light and dark. And I got this get started.
164:28 - And it's totally empty. And we can start writing a fake documentation there. So if I get back to
164:34 - the project, I got my Nux folder with this guide. I got YAML. I got an index, which is actually the
164:42 - basic of my page. And then I got a folder. And with the folder, numbers to specify for my sidebar
164:51 - on which side are going to be the documentation. Okay. So what we could do at first is just to
164:59 - start with our fake API. So here, I'm going to call it actually fake countries API. Okay.
165:08 - API. There we go. Documentation. So here on the title here, it's for the meta, actually,
165:15 - of your project. So I can go down and put fake countries there. So here, it's marked down again.
165:21 - But we see it's a bit different. It's that we got a CTA button where we can put the get started
165:28 - code there. And there's the link to go to the guide or the button, secondary button.
165:35 - Then also on our snippet, we can put actually some code if we would like to have some code.
165:42 - So here, I'm going to write API to fetch any country in the world with its name, its
165:53 - ID code, and more information. Okay. So I'm going to save this. And there we go. I got my title there.
166:03 - So now what is our API doing? Well, actually, what we would like to do is to have some endpoints.
166:11 - So what I'm going to start to do is to create a new folder called server. And in there,
166:17 - I'm going to create a subfolder called API because I want to put API as a prefix.
166:24 - And in there, let's say that I would like to have a first endpoint called random.
166:29 - And it will be a random endpoint, an endpoint for random countries. So I'm going to create
166:36 - my endpoint. So export default, which would be a function. And I'm going to return a success
166:42 - true to try this endpoint at first. So I'm going to get back, and then I'm going to type slash
166:49 - API slash random. And there we go. Okay. My endpoint is working. That's great.
166:55 - Now what I want to do, I want to have some data that I would use to actually to display my country
167:02 - or to answer by my country. And I found this amazing library by Dupco called countries.
167:09 - So I'm going to install it. So I'm going to stop actually my server. And I'm going to type
167:17 - yarn had at Dupco. That's the person who made it. Thank you very much. Slash countries. So I'm
167:23 - going to type enter. And it's going to install for me this library. There we go. So I'm going to
167:28 - start again. And there we go. And what I can do actually is to import the countries or the country
167:37 - list from the library. So I'm going to get at the top there. There we go. And I think country
167:44 - list should be an array. So for that, I'm going just to console our country list at first.
167:49 - And let's look at it. There we go. Yeah, there we go. That's what I thought. We've got an array
167:55 - with some countries there. I want that endpoint to be a get. So I'm going to type random dot get.
168:03 - Okay. And it's going to change. Okay, that's right. And what I want to answer is actually
168:09 - a random country. So I'm going to type random country as an answer. And it's going to be
168:15 - country list. And inside the country list is going to be a mat floor, mat random. Exactly.
168:21 - Country list dot length. And there we go. So let's get back and let's try actually our endpoint
168:30 - again. And when I type enter, there we go. I got jibalta. If I type again, island, island.
168:40 - Okay. That's cool. It's working. What I could do now is actually to just create the documentation
168:48 - about this endpoint. So I got API slash random. So what I can do is getting back on my fake
168:57 - countries API. I'm going to click on get started. And what I'm going to do at first is not to remove
169:04 - this get started because I want to keep it. But actually, I'm going to create a in the guide
169:10 - actually in the guide section. I'm going to oh, maybe what can I do is to create a second
169:16 - folder called endpoints. All right. And if we say nothing is happening here. Because what I need to
169:23 - do is to create a deer dot yaml. Deer dot yaml at the root. And I'm going to use this as an example.
169:34 - So I'm going to copy paste this title guide. And I need to put a title. So here API. Let's call it
169:42 - API. All right. So I'm going to save. Okay. Nothing happens because I need to put actually my zero
169:49 - dot index dot end. And this one, let's take the same example as we get there. I'm going to save.
169:58 - And there we go. As you see, I got my page that appears there. And that which is cool is that we
170:04 - can see that there is a navigation that is automated between the pages. So API. And this one
170:12 - is called get started. Let's try to change the title there. So I'm going to remove this.
170:16 - And let's say get a random country. And we see now that my title is now appearing on my sidebar.
170:26 - So I'm going to get back. And I'm going to type some documentation about it. So here it's
170:31 - again marked down. So you can write whatever you want. Endpoint to get a random country on our
170:39 - country's list. Okay. So what we could do also is to type some code that we could put. Here what I
170:47 - can put is method get. And down there I could put slash API slash random. And I'm going to save.
170:54 - And as we see, there we go. We've got our random that is here. Endpoint to get a random country
171:01 - on our country list. If you want to know more about creating endpoints with Nitro, you can go
171:06 - on the official documentation of Nitro.ngs.io. Nitro can exist by himself also. Right now we are
171:13 - using it in Nux3, but you can also create regular endpoints with Nitro. So what are we going to do
171:18 - now? We are going to create a new endpoint where we're going to post actually a request with a
171:24 - string. And we want to find in our area of countries the specific country. So what I'm
171:29 - going to do, I'm going to get back to my app. And in the API folder, I'm going to create a new
171:34 - folder called countries. And there I'm going to create a new endpoint called find.post.ts.
171:43 - Find would be just the endpoint. So it would be actually API slash countries slash find.
171:52 - And this endpoint will be a method post. All right? So what I'm going to do, I'm going to use
171:58 - the example of Nitro. And it's exactly the same as the random one. The difference is that I didn't
172:05 - use the event handler here function. It's exactly the same, but whatever. Okay. So now we return
172:12 - user profile. It's going to be an object that we will return at the end. And what we want to do
172:17 - actually is to use the country list that we had before. So I'm going to come back on this. I'm
172:23 - going to import. Actually, my country list. And there we go. So what I want to do is to post as a
172:33 - body. Actually, I'm going to post an object with inside. And there will be, we can call that
172:42 - country. Okay? And country will be a string. Okay. So I'm just making those notes for this course.
172:50 - And don't take them as a good practice. Most of the time, you have better way to write comments
172:56 - in API. This course is not about back end either on API. It's just to show you the example.
173:02 - So it will be a string. Country will be a string. And we will catch it through this event. So what
173:07 - we're going to do is to create a variable called body. And we want to await for a function,
173:15 - a native function of nitro. And this native function is read body. Read body, we pass the
173:22 - event to it. And it's going to return for us directly our body as an object. Which is very
173:28 - cool. So we will get our country up there. So once I got the country, I can destructure country
173:36 - from the body. And here what I can do is to return the countries that we will find with this string.
173:46 - So, for instance, here, if I'm going to type France, it's going to return to me here an array
173:52 - with countries that correspond to France. So there's two things that I need to do. I need to
173:58 - look at how country lists are looking at. And here I get to return countries. It's not specifically
174:05 - one country. It's not find one country. It may be several countries. Because we will see that
174:11 - our string will match the letters. And in there what I'm going to do, I think I already know,
174:17 - but I'm going just to put true for now. And I'm going to look at the list. And there we go. I
174:23 - want to match the label. I want to match the label with country. So if it's going to be Ghana
174:29 - in my country here, I want to match the label in my array. So I'm going to do country list, simple
174:35 - JavaScript. Then I'm going to filter. And what I want to do is that here I get an object. And in
174:43 - this object, I want to match my object.label that we just saw. And I just want to know if it's going
174:50 - to include actually country. All right. So we can save this. I'm going to remove that.
174:58 - And now I need to post to this endpoint to know if I get some response. To do that, me, I'm using
175:08 - actually rapid API. Rapid API helps you to create some actually postman inside your IDE. And here
175:18 - especially it's a visual studio code. So here I need to create a new call. And this new call
175:26 - actually will be my post. So I'm going to go there. I'm going to post to what? I'm going to post to
175:33 - actually HTTP two point slash local host 3000 slash API slash countries. And here it's
175:43 - find. Okay. So I'm going to click on Gson. And here I'm going to pass my country. Okay. And let's say
175:50 - that we are going to type France. Okay. And when I type send, there we go. We see that I have my
175:57 - country that have been found on my endpoint, which is API slash countries slash find. Okay.
176:04 - Now let's say that I want to remove some letters on my country down there. Let's say that I want
176:11 - just to type fra. It's still going to find France because on my endpoint, I'm just filtering on
176:21 - includes the strings. And I'm looking at labels. So I'm going to get back. And if I remove some
176:27 - letters, I got more countries that start actually with French, actually French, Vienna, France,
176:35 - French Polynesia, French, Southern, et cetera, et cetera. Now, if I type an A, I'm going to get
176:42 - back and I'm going to click on send here. I got several countries. So these several countries
176:48 - are Algeria, American Samoa, and or Angola, Angola, et cetera, et cetera. You're not obliged to use
176:56 - rapid API for this course. You can use, for instance, postman it's better. But for me,
177:01 - I got this in my VS code. It's faster. Now I have created my endpoint. What I want to do,
177:07 - I want to put the documentation to use it. So I'm going to get back there in my index.
177:12 - And what I can write here, it's find a country by label. And actually it's going to be exactly the
177:21 - same. Find a country by label on our list. It's going to be a post. And this time it's going to be
177:28 - countries slash find. And if I save and I get back, I update, we see that there's a problem.
177:35 - Because I got my index and it doesn't put here find a country by label. So what I need to do is
177:43 - actually to create another page. What I need to do if I want to separate the two files, I can create
177:49 - another markdown file, 1.find.md, for instance. And I arrive there with my explanation. And there
177:57 - we go. We see that I get a random country, find a country by label, and there we go.
178:03 - Of course, this presentation is not very well. I should work more on the design,
178:07 - on what I want to do. So here we see that we can copy paste the code, which is amazing.
178:12 - However, we've got this method get on the top. It should not be here. So I'm going to remove this
178:18 - and I get my endpoint. And I'm going to put just endpoint there. So it makes me think that I have
178:25 - to change my description up there. And what I could do is instead of putting this, what I could put
178:34 - is my method get there. So I would have method get as a reference up there. Of course, I'm not a big
178:42 - boss in markdown. I'm sure you get a lot of ways of doing nicer stuff, but that should be enough.
178:48 - So I got my endpoint here. And actually, I can remove endpoint. And what I would like to have
178:55 - is a response example. So I'm going to take this and remember on my API slash random,
179:03 - I have a response. So what I can do is just to type slash API slash random, looking at response.
179:12 - And I'm just going to copy paste this as an example. So I'm going to get back
179:16 - and I'm going to update. Okay. And here in my response, I'm going to put my fake response.
179:22 - And there we go. That's an example of a good documentation we could do. So what I'm going to
179:29 - do, I'm going to copy paste actually the same model. So I'm going to get back on find them.
179:36 - And instead of having this method on the top, I would put method post. Okay. And I would put,
179:45 - for instance, a response example down there. And actually I can take back this. I'm going to
179:53 - go there and the response that I got. So let's get back on my API call, which I got here.
180:01 - Here exactly. Here I got a response and I'm going to put friends. I'm going to type and there we go.
180:08 - Now I can copy paste this here and I got some kind of response there and look at this.
180:17 - So that's really cool. Really quickly. I succeed to create the base of an API and actually at the
180:25 - same time, the base of a documentation. However, if we look closely at what we do, we put the
180:34 - endpoint, we put the response, but we didn't put the body. So let's get back on find a country by
180:42 - label. And what I'm going to do is on the top of response, I'm going to put a body example.
180:50 - So I'm going just to copy paste this. And on the body, of course, I gather pass the country,
180:56 - which will be, of course, France. And here what I can specify is that it will be a string.
181:04 - Okay. So here I got a string with the body. And that's good. We are good. Another thing
181:12 - that we would like to do is to find countries by language. And that could be amazing. So we should
181:21 - look first at our endpoint. And we should look at actually we should look at the countries that
181:30 - we've got. Okay. So we've got our countries there. And these countries, they should have a language.
181:39 - So as we see on the model on TypeScript, we already saw that there's a language which
181:43 - would be an array containing strings. That's amazing. Later, we will be able to create
181:48 - a currency and also to work on the code, capital, or stuff that we want. All right.
181:54 - So we're going to work on these languages at first. And we want to create an endpoint
181:59 - with languages. And we suddenly realize that our countries.find, it's a bit weird, okay,
182:07 - as an endpoint. Because find would mean anything. And in our documentation, we can see that we can
182:14 - find a country by label. Okay. So and our titles are very long also. So if we would like to do
182:23 - something more clear, we would have to work on our API endpoint. And we will have to work on our
182:30 - names. All right. I improved a bit this documentation. And I created some endpoints. And let me present
182:37 - them to you now. So we still have this entry here with this stuff that is useless. Actually,
182:44 - I should change it. And it's called fake countries. So I don't know why it's called fake countries.
182:49 - I should have put countries because it's still real countries. So when we click on get started,
182:54 - we arrive on the guide that I worked on. So basically, I've had a welcome on fake countries
183:01 - API. I've had a version, the date, how to use it, and the options that we can have if we look
183:09 - at the documentation of docus, actually, we've got some options that we can add, such as check,
183:17 - danger, and stuff. That's really interesting. I've added some rules. This API is free to use.
183:22 - However, please do not spam or use it more than one hundred times per day.
183:26 - We'll banish your IP for 30 days if you spam it. Yeah, that's what I wrote. There's an about
183:33 - section. And we see here on the right, actually, that we've got a sub content panel that is really
183:40 - useful on the actual page. And on my API, I've worked on my endpoints. So I tried to be very,
183:50 - very concise and very clear about what the API is doing. So what I did actually, I've created
183:57 - an endpoint called get all. And here we've got this endpoint. This is API country whole. So we
184:04 - don't need anybody. So what I'm going to do, I'm going to test, actually, on my localhost decent
184:11 - point. And there we go. Let's look at this. We have the full file, actually, as a GS, a decent
184:18 - file, actually, sorry, about every country and everything we've got on it. That's really cool.
184:24 - Okay. That's the endpoint that I've created. And I've kept this model of putting the method
184:29 - and a short description and the endpoint and an example of what we can have. So it can be very
184:35 - useful if you want to use the flag, the name, the code of whatever. Then I've worked on the
184:43 - random one. So as you see now, we've got API slash countries slash the name of the
184:51 - endpoint that we're going to have. So for all, I get slash all. For random, I put slash random.
184:57 - So when we get back to the server, now we've got our server with the API because there is another
185:04 - route that I'm going to show you after. And on API, I got a folder countries with all dot get
185:11 - because it's a get. And random that it's a get also. And what I'm doing, actually, when I get
185:18 - an object, I'm transforming it to an array. And then I look at it. So basically, we've got all
185:23 - the endpoints there that will be with this API slash countries. So here I'm going to try my
185:31 - random endpoint. And there we go. I got a random country there. Then after on the other methods,
185:38 - by label, by capital, by currency, these are posts. And on those posts, actually,
185:45 - I'm returning not Gsons. I'm returning an array. So basically, here we've got labels. So we're
185:53 - going to try it. I'm going to try to catch a country by label. So I'm going to get back there
186:00 - on my previous post. And I'm going to type HTTP slash slash localhost 3000. Then with my slash,
186:11 - so I'm going just to push that this way, I'm going to get back there. And when I send it,
186:17 - there we go. I got France, if I try to find United something, for instance, United, there we go.
186:25 - I got Unitate Arab Emirates, United Kingdom, United States. So my endpoints, label.post.ts is working.
186:35 - And also what I did on my endpoints is that I put some guards. So here I got my guards on the label.
186:42 - All right. I did the same with currency. I did the same with capital. So let's try capital. So I'm
186:51 - going to go on the documentation, get by capital. What I can do is to find a country by its capital.
186:58 - So I'm going to type instead of countries here, capital. And here as capital, I'm going to pass,
187:07 - for instance, Washington. And when I'm going to send it, there we go. I got the countries by
187:14 - capital, which is amazing. What I can do also is to type by currency. And currency is interesting,
187:22 - because here with currency, I will have several other countries. So when I type for the euro,
187:29 - I get all the countries of Europe that have the euro as a currency. Let me try to find a doll for,
187:39 - ah, no, it's not, yeah, it's working well. It's not doll, it's USD. So there we go. We see all
187:45 - the countries that are using USD, for instance. So what I did, it's exactly the same. I just copied,
187:53 - paste some code, and it's working very good. If there is no currency, we can see that we get also
188:00 - an error, and it's working very well. So now you can go on the documentation and check all of this.
188:07 - It was a quick course to teach you how to use Nuxt content and how to use all the force of Nuxt to
188:15 - create an API and to create a documentation. Of course, we could have done it by creating a full
188:20 - stack application also. It would have worked. However, it would have taken a lot of time to
188:26 - create the whole design, actually, the whole template. Instead, using docus helped us a lot.
188:33 - So this is a good example on how you could create a business. For instance, if you would like to
188:39 - create an API where people could fetch some data, you would have to use a stripe layer to make people
188:48 - pay and to be able to use the API. Once they pay, they get a token, and they can use this token,
188:55 - and you could do a lot of stuff like this. So this is really not a real documentation, okay?
189:02 - This is a start. To end this lesson, I wanted to show you where I found docus. Actually,
189:08 - I went on Nuxt team. Here on Nuxt team, what you can see is that you have several different
189:14 - teams that you could apply to your Nuxt.js application. So we've got docus, which is here,
189:21 - and this is the one that I use that helps us to create a documentation on the fly. However,
189:27 - you got some other teams that you could use, and I think in the future, there will be more and more
189:34 - teams that will be available under Nuxt 3. Not pretending that I can build a whole documentation
189:41 - by myself, and I'm not pretending that I'm an awesome back-end developer, but this was a good
189:47 - example to show you how we can use Nuxt and how we can use its power to create a full documentation
189:54 - and a full stack application. So what I would do now, my documentation is online, I would deploy it
190:01 - on Netlify or Vercel, and right away, what would happen is that my endpoints would be available on
190:09 - the address provided by Netlify and Vercel. And congratulations, you succeed to create your first
190:16 - documentation and your first full stack application with Nuxt.js. Thank you very much for watching this
190:22 - entire video, I hope it helps you to create a full stack application. See you next time, bye!