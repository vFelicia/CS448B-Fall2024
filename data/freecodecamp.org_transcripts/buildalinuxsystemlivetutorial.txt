00:00 - hello world
00:05 - by all means
00:07 - uh this isn't so much a vm as a machine
00:10 - that is less
00:11 - underpowered than the netbook i normally
00:13 - care around with me
00:14 - this netbook has
00:16 - many hours of battery life it's
00:18 - extremely portable and it's powered up
00:21 - it's powered by a wind-up toy
00:23 - so if i actually do test builds for you
00:25 - we'd be here a while
00:29 - all right i pretty much am forced to
00:32 - start
00:34 - let me see did i decide to go with index
00:36 - or index two yeah i think index two
00:43 - six and one half dozen together
00:45 - um
00:46 - i'm pretty much forced to start with the
00:49 - concept of circular dependencies
00:52 - when you are building
00:53 - a linux system
00:55 - if you've ever installed things there
00:57 - are often other prerequisite packages
00:59 - well when you get down far enough the
01:00 - dependencies become circular you can't
01:04 - install a system without boot media a
01:06 - usb or cd to boot it from you can't
01:09 - create a boot media without having a
01:11 - running system you know way back in the
01:13 - dark ages we had punched cards and paper
01:15 - tape that you could physically write
01:17 - information to or the switches on the
01:20 - front of the altair that you know you
01:22 - could flip here's the address here's the
01:24 - here's the value the right button and
01:26 - you could literally toggle in a program
01:28 - if you had hours to do it
01:30 - that
01:31 - went away a long time ago we now have
01:33 - you know millions of bytes of stuff
01:36 - and when you're putting together a
01:38 - system
01:39 - something you're going to hit a lot
01:41 - especially if you ever deal with
01:42 - something like linux from scratch is you
01:44 - have to build packages before you can
01:47 - build other packages
01:49 - and in order to avoid bits of the host
01:52 - system leaking into the target you
01:54 - sometimes have to build something that
01:56 - you're not actually going to install but
01:58 - you're going to build against
02:00 - so
02:01 - we'll get to all that
02:03 - but the reason i introduce with the
02:04 - concept of circular dependencies is i
02:07 - have spent two weeks attempting to come
02:09 - up with a nice linear index of here's
02:11 - the topics i want to cover in this order
02:14 - and it's circular dependencies all the
02:16 - way down so we're going to be explaining
02:18 - some stuff and then coming back to
02:20 - explain why that was incomplete or wrong
02:24 - a little later
02:26 - all right
02:28 - so
02:29 - circular dependencies
02:32 - so
02:35 - there are four
02:38 - let me
02:41 - there are four
02:44 - basic
02:45 - components
02:46 - of a build environment of a linux system
02:49 - that's capable of rebuilding itself
02:50 - under itself from source code
02:52 - those four are a kernel a c library a
02:56 - set of command line utilities and a tool
02:59 - chain and a tool chain is what all the
03:01 - embedded geeks call a compiler and
03:04 - linker and the make program the set of
03:06 - build utilities that actually let you
03:08 - compile stuff
03:11 - when you are creating a system though
03:14 - it doesn't have to be able to rebuild
03:16 - itself under itself your your tiny
03:18 - little embedded ones generally don't
03:20 - so
03:21 - your build time
03:23 - packages and your runtime packages one
03:25 - of the ways that
03:27 - you break circular dependencies is by
03:29 - separating them
03:31 - okay
03:32 - one of the things i did as
03:36 - okay one of the things i did is back
03:38 - story to this a long time ago
03:44 - is starting like 15 years ago i created
03:47 - a project called aboriginal linux from
03:49 - the latin ab originate from the
03:51 - beginning
03:52 - where
03:53 - basically i started with linux from
03:55 - scratch and i went okay
03:59 - what is the smallest simplest
04:02 - build environment i can get capable of
04:03 - building itself from source code those
04:05 - four packages i talked about are
04:07 - conceptual packages i got it down to
04:09 - seven actual packages
04:13 - uh which were
04:14 - the linux kernel you see libsy at the
04:16 - time
04:17 - um make
04:19 - bash
04:20 - bin utils gcc
04:23 - and
04:25 - i list them here
04:28 - and busybox
04:30 - and in order to make that work i wound
04:32 - up actually maintaining busybox for a
04:35 - while because i did so much work with
04:37 - you know if i want to replace the new
04:38 - version of said with busybox said um
04:41 - it didn't work
04:43 - so i upgraded it to the point where you
04:44 - know
04:45 - i i upgraded their sort command i
04:47 - upgraded their mount command
04:49 - and it got to the point where the
04:50 - previous maintainer just handed it off
04:52 - to me for a couple of years and then i
04:53 - handed it off to dennis flozenko
04:56 - but
04:58 - busybox has had a lot of work over the
05:00 - years
05:01 - to make it
05:04 - provide the set of command line
05:05 - utilities
05:07 - all in one package
05:09 - and that was an explicit goal that took
05:11 - years of work the others you know the
05:13 - tool chain i used at the time was bin
05:15 - utils plus gcc plus make so three
05:18 - packages there
05:20 - and by the way uh even busybox at the
05:22 - time i was substituting in bash for its
05:25 - shell because i never got around to
05:26 - upgrading it shell that's why there's a
05:28 - seventh package there um busybox has had
05:30 - some work on its shell since then and
05:32 - it's possible that you could build linux
05:33 - from scratch with busybox ash these days
05:35 - i haven't tried it recently
05:39 - this was an old version of gcc that had
05:41 - been utils in gcc as two packages now
05:44 - they've metastasized to five packages
05:47 - you know so the simplest system with
05:49 - modern packages is less simple than
05:52 - previous systems were fun stuff linux is
05:55 - still linux for a while linux needed
05:59 - perl to build because peter and decided
06:01 - that was a thing in 2625
06:04 - and it took me several years of
06:05 - submitting patches to remove pearl as a
06:08 - build requirement before that finally
06:10 - went away in like 2013.
06:14 - um
06:15 - okay
06:16 - so
06:19 - let me start
06:22 - by the simplest thing you can do to boot
06:25 - a system
06:26 - is
06:35 - because i'm in the wrong
06:38 - uh let's see yeah i haven't the intro
06:41 - file
06:43 - no
06:45 - okay so how simple can we get
06:47 - here is a page where someone booted
06:50 - hello world on the bare metal
06:56 - okay
06:57 - and
06:58 - you can
06:59 - easily google for this or you can go to
07:00 - that url i'll post a list of the urls i
07:03 - went to after the talk
07:06 - but basically what what he did
07:08 - is he has a little function that just
07:10 - repeatedly writes to the
07:14 - uh
07:15 - the output register of the serial port
07:18 - and has that iterate through a string
07:23 - and then
07:25 - specially builds it with a little
07:27 - assembly header and with a linker script
07:29 - that puts stuff in the right place
07:33 - does this stuff
07:36 - which you know the assembler gcc for the
07:38 - c part linker running the special linker
07:41 - script and then a program called obj
07:43 - copy that takes it from the elf format
07:45 - and copies it to a binary it basically
07:48 - the l format is a bit like zip or like
07:51 - tar it's an archive format for storing
07:54 - executable data
07:56 - so there's a variant of elf that stores
07:58 - shared libraries there's a variant of
08:00 - elf that stores dynamically linked
08:02 - programs there's a variant of elf that
08:03 - stores dynam statically linked programs
08:06 - it's basically the same archive with
08:08 - different header information
08:12 - and what this does is this extracts just
08:14 - the raw binary blob output format binary
08:17 - and puts it to test.bin
08:20 - and one of the things i did is
08:24 - hello hardware
08:27 - make.sh
08:31 - the other thing i have to introduce is
08:32 - the concept of cross compilers we'll get
08:34 - to that i mentioned circular
08:35 - dependencies
08:37 - and
08:38 - so if i run make.sh which i ran on that
08:41 - machine and the paths are different of
08:43 - course
08:56 - just make
08:58 - mcm two
09:02 - ha there i have it
09:05 - so this is actually the machine i muscle
09:07 - cross make
09:10 - two
09:12 - output
09:14 - let's try that now
09:16 - hey
09:17 - so
09:18 - that just compiled the
09:21 - the programming created a test.bin
09:23 - and then run is copied from his thing
09:26 - where we call qemu's system arm tell it
09:29 - machine uh versatile pb is one of the
09:32 - arm systems qmu no simulator does
09:34 - anybody here not know what qamu is
09:38 - okay
09:39 - qemu is an emulator
09:42 - it's a program that creates a virtual
09:45 - machine
09:46 - and
09:48 - runs the code you feed into it
09:52 - it has a
09:53 - built-in
09:55 - bootloader where basically you can go
09:57 - this file copy it into the virtual
09:59 - memory and jump to the start of it
10:02 - you know if it's in a known format it
10:04 - can actually read the header on it and
10:06 - go oh this is an elf file i'll do
10:08 - basically what obj copy did
10:10 - copy into memory myself and jump to the
10:13 - start information out of the header uh
10:15 - here we already did the obj copy so you
10:17 - know the bare metal one
10:19 - the dash kernel test.bin argument is
10:22 - basically telling it use your built-in
10:24 - bootloader to load this into the virtual
10:27 - machine's memory
10:29 - dash no graphics says instead of popping
10:33 - up a window with
10:35 - the bitmap output of your emulated video
10:38 - card you know whatever
10:40 - the program that's running wrote into
10:42 - the
10:44 - m you know
10:45 - it tried to access the emulated hardware
10:47 - and its
10:48 - its driver intercepted that and wrote it
10:51 - into the window instead of doing that
10:54 - just have a serial port
10:56 - on
10:57 - uh
10:58 - on the standard in and standard out of
11:00 - the qemu program so that whatever you
11:02 - write to qemu's standard in goes to the
11:05 - serial port and whatever the serial port
11:08 - you know whatever the program writes
11:09 - back to the serial port goes to standard
11:11 - out of qemu so that you can actually you
11:13 - know interact with it on qemu's standard
11:16 - in and you can actually do things like
11:19 - use tickle to script
11:20 - emulator instances that way it's it's
11:23 - very useful
11:24 - uh the dash m128m
11:27 - says 128 megabytes of memory is how much
11:30 - should be installed into the virtual
11:31 - machine
11:32 - this says
11:34 - basically what motherboard to emulate um
11:38 - what board
11:41 - board is shorthand for um
11:43 - for motherboard it basically says
11:45 - put this processor input memory at this
11:48 - location
11:50 - all the information about
11:52 - you know all the information that would
11:53 - be in device tree when we get to that
11:55 - you know all the information that
11:57 - the colonel needs to know where to look
11:59 - for these devices well qemu similarly
12:01 - needs to know where to put the emulated
12:04 - versions of them so we told it this is a
12:07 - common type of very old armboard from i
12:09 - think the 90s
12:11 - the
12:12 - versa the arm versatile board
12:14 - and then this is just me telling it
12:15 - don't attempt to emulate an audio device
12:18 - because if you do it will spam standard
12:20 - out with a bunch of i failed to
12:23 - to connect to oss and it's like i just
12:25 - don't want that
12:26 - so when i do that i get
12:28 - hello world
12:30 - it booted a
12:32 - virtual system which wrote something to
12:34 - the serial port and then just spun
12:37 - okay so this is
12:39 - about the simplest thing you can get a
12:42 - machine to do
12:43 - and actually see the output
12:45 - and my fan is starting up because it is
12:47 - spinning you'll notice there's a cpu pin
12:51 - and the other
12:52 - fun thing about this is we're now going
12:54 - to tell you
12:57 - why it's wrong
13:00 - and the reason that it's wrong
13:03 - is
13:08 - oh come on i have it in here somewhere
13:10 - um
13:12 - the reason that it's wrong
13:14 - is that real serial hardware only works
13:16 - at a certain rate
13:18 - you know it has a uart buffer that can
13:19 - fill up
13:21 - if you just spin writing to its output
13:24 - register it's going to start discarding
13:26 - data fairly quickly what you need to do
13:29 - is you need to read a status register
13:33 - that will have a bit set that says i am
13:36 - ready for the next byte or not
13:39 - and you can actually fetch that out of
13:41 - the linux kernel source code in
13:43 - [Music]
13:46 - uh it's under drivers
13:51 - yeah
13:51 - tty
13:53 - serial
14:00 - amba pl
14:03 - 011.c
14:05 - and then uh
14:07 - put
14:14 - uh yeah console put character
14:17 - um
14:19 - it's doing a read from a register and
14:21 - ending it and while it's doing that you
14:23 - know cpu relax is basically a way of
14:25 - telling the processor not to overheat
14:26 - it's it's a no op that takes a little
14:28 - extra time and then write the character
14:31 - once it frees up so you know that a
14:33 - driver attempting to talk to real
14:35 - hardware is doing an extra step that the
14:38 - emulator is not doing
14:40 - and we're going to hit that a few times
14:42 - in here but the really fun thing about
14:43 - this
14:44 - this pl
14:46 - 011 console putcare
14:48 - is a linux driver that's designed to
14:51 - work
14:52 - before interrupts have been enabled
14:54 - early in the linux boot process early
14:56 - print k we'll get to configuring the
14:57 - kernel in a little bit
15:00 - and that means that
15:03 - before linux has really initialized most
15:05 - of the other hardware it may want to
15:07 - print stuff out very very early on
15:10 - which means if you know what your serial
15:12 - hardware is and where it's configured
15:14 - you can basically look up what these
15:15 - macros are and substitute in the
15:17 - constants and cut and paste a line or
15:20 - two
15:20 - that let you stick print statements into
15:24 - anywhere you can stick it into a
15:26 - bootloader you can stick it into early
15:28 - boot you can truly debug almost anything
15:31 - with print statements
15:33 - you know so that's actually a nice
15:35 - little technique to
15:37 - have in your back pocket
15:39 - and we will get back to that so
15:45 - the other thing that's wrong with that
15:46 - is we're doing the simplest possible
15:48 - linux system and clearly hello world is
15:49 - not linux so let's actually do
15:52 - what it says on the tin and i should
15:55 - have done that beforehand
15:58 - because i want to build uh 410
16:01 - and
16:03 - i don't know how slow the you know the
16:04 - net here is going to be too slow all
16:05 - right
16:09 - can you give me four nine
16:11 - i don't know when the next time last
16:12 - time i did a poll on this machine was
16:16 - all right
16:17 - so
16:20 - the other thing other than circular
16:21 - dependencies is we're going to have to
16:23 - define simplest
16:25 - what i'm going to show you right now is
16:26 - the simplest
16:28 - way to build a linux system
16:31 - hello
16:33 - what are you doing
16:37 - where are you at
16:40 - random thing in 2016 now
16:45 - right lovely
16:48 - do i have any others
16:52 - i have a bunch of others
16:54 - well here's three five
16:56 - right
16:59 - sure
17:00 - that's ancient
17:02 - still works the same way though did you
17:05 - finish
17:06 - yeah what
17:13 - the downside of switching to a much
17:15 - faster machine right before the thing is
17:18 - my careful setup i ran through is right
17:20 - there
17:24 - yes
17:28 - the
17:29 - 4.9
17:31 - 4.9 there we go
17:33 - all right so it's gonna boil down to
17:38 - we're going to do a
17:43 - yes
17:48 - which of these yes i know
17:51 - all right did i put it in here
17:55 - sure
17:56 - okay the theory behind building a kernel
17:59 - always boils down to you're going to do
18:01 - a make config
18:03 - you're going to do a
18:04 - make
18:06 - and then
18:07 - you you install and boot the result
18:11 - a lot of the times we're going to be
18:13 - cross compiling
18:15 - cross com the the difference between
18:17 - native compiling and and cross compiling
18:19 - is
18:21 - something that i'm going to explain
18:24 - on an x86 64 system we're going to start
18:27 - with the available def config so if you
18:30 - go make help
18:32 - grep underscore def config it should
18:35 - list
18:37 - for the architecture you've selected the
18:39 - available are you still checking out no
18:42 - no you're not
18:44 - come on there we go
18:45 - so it has i3 386 def config which is 32
18:49 - bit and x86 64 def config which is 64
18:51 - bit if i selected a different
18:53 - architecture
18:56 - a bunch of architectures in the arch
18:57 - directory if i selected
19:00 - you know
19:01 - make arch equals
19:04 - arm
19:05 - i'm going to get a whole bunch of def
19:06 - configs
19:08 - but
19:09 - for right now
19:11 - the simplest way of doing it is to build
19:13 - for the same architecture as this thing
19:15 - to not deal with cross compiling at all
19:17 - first and i'm going to go make x86 64
19:20 - def config
19:24 - that's an underscore there i don't think
19:25 - you can actually
19:27 - see it
19:32 - seriously
19:38 - there we go
19:39 - and then make dash j8
19:41 - as soon as we're done
19:47 - come on
19:48 - you can do it
19:52 - j8
19:55 - and this is going to build an awful lot
19:57 - of kernel
20:00 - and that's going to go for a while so
20:02 - meanwhile in another window the reason i
20:04 - opened the second window
20:07 - let's build a hello world binary
20:14 - so
20:40 - the reason for this instead of exiting
20:43 - is that i'm going to run this as pid 1.
20:47 - when a kernel boots it needs
20:50 - first it needs a bootloader to have run
20:52 - to load it
20:53 - to load it into memory and there's a
20:55 - couple of times that it can load run
20:57 - straight around but we'll get to that
20:59 - then the kernel needs to know the board
21:01 - layout
21:02 - you know where to find the physical
21:03 - memory where to find the serial port if
21:05 - you're using a serial console where to
21:07 - find the i o devices even if you have
21:09 - buses you can scan you need to know what
21:11 - buses there are and where to find them
21:13 - so it needs some starting data before it
21:15 - can even scan the rest of the system to
21:17 - see you know what's plugged into usb
21:18 - well where's the usb controller
21:22 - and then it needs a root file system
21:27 - in order to load its first program from
21:31 - and it needs the first program to run
21:35 - and we're going to provide all those
21:37 - things in the little system we put
21:38 - together here we are going to use a knit
21:41 - ram fs and we are going to use a
21:43 - statically linked hello world program as
21:45 - init and we're going to boot this under
21:47 - qemu so that you can see basically hello
21:50 - world run in a different context so this
21:52 - is a second layer of useless before we
21:55 - start getting to actually
21:56 - useful now you'll notice
22:00 - this is this is building it at a
22:02 - reasonable clip you know this is an
22:04 - eight-way smp machine
22:05 - and it's still building
22:07 - quite a lot the thing about def config
22:10 - is it's got how many symbols
22:26 - so that's 1164 that are just set to y
22:30 - uh actually
22:32 - okay there's the number that are that
22:34 - are set
22:35 - so 1252
22:38 - symbols
22:40 - which
22:42 - select a lot of stuff
22:44 - you know we're not going over all of
22:45 - these symbols we do not have time
22:48 - so what we're going to do instead
22:50 - you know
22:53 - so
22:54 - make dev config is simple to build it is
22:57 - not
22:58 - going to result in the simplest system
23:00 - i thought it would take less time than
23:01 - this
23:10 - and then to package this up
23:14 - we are going to
23:27 - we are going to do this little
23:29 - invocation
23:31 - find period to cpio
23:33 - dot o dash h new c pipe it did to gzip
23:38 - and we're going to do that in the
23:39 - directory
23:40 - that
23:43 - has our new root file system
23:46 - so
23:51 - gzip
23:52 - i don't need i don't actually need the
23:53 - parentheses and then redirect that to
23:57 - the directory above this
23:59 - root.cpio.gz
24:04 - so this has created uh
24:09 - yeah i did i didn't strip that that's
24:11 - statically linked against glibc which
24:13 - means it's flipping enormous
24:15 - and
24:16 - it even has the source code in there but
24:18 - that won't
24:19 - that won't bother us
24:21 - when the linux kernel
24:23 - boots
24:25 - it
24:28 - starts by
24:29 - mounting a root file system there are a
24:32 - couple of ways you can specify
24:35 - where the root file system lives you can
24:37 - statically link in a cpio archive into
24:41 - the kernel binary
24:43 - which will be extracted into memory in a
24:46 - file system called init ram fs and ram
24:49 - fs is an instance
24:51 - of either
24:53 - ram fs or temp fs in more recent ones
24:58 - here
25:00 - doc documentation file systems
25:05 - i uh years ago i wrote documentation on
25:08 - this so if you want to uh
25:11 - you know read through all that this is
25:13 - just the
25:14 - very quick summary
25:18 - cpio is an older archive format that
25:20 - predates tar but still works just fine
25:23 - they used it because it's simpler tar is
25:24 - actually a lot more complicated under
25:26 - the covers
25:27 - that gets extracted into ramfs ramfs is
25:31 - a
25:32 - ram-based file system there's four kinds
25:35 - of file systems there's block backed
25:36 - which is the conventional ones you're
25:37 - familiar with like ext2 there's a
25:40 - there's a block device which is a fixed
25:42 - amount of storage that gets formatted
25:44 - and interpreted through a second driver
25:46 - that tells us what kind of file system
25:48 - there is
25:49 - there's
25:50 - pipe backed which are called different
25:52 - things sometimes you hear them as
25:53 - network file systems fuse is another
25:55 - example of this where basically you're
25:57 - talking through a pipe to another
25:59 - program that speaks a protocol and that
26:02 - other program is providing your file
26:03 - system so that program may be samba that
26:05 - program may be you know
26:09 - there's a bunch of things it could be
26:10 - um
26:14 - pipe backed ones don't have to be
26:15 - network file systems but people usually
26:17 - think of that the point is that it's a
26:19 - serial protocol
26:20 - the third kind are the ram backed file
26:23 - systems where your your files are stored
26:26 - in memory where basically the linux disk
26:29 - cache the page cache and the de-entry
26:32 - cache
26:33 - that store copies of the file you know
26:35 - copies of file data on their way to
26:38 - whatever backing store there is because
26:39 - if you're writing faster or if you've
26:41 - read them in and it doesn't want to redo
26:42 - the transaction with either the block
26:44 - device or the server
26:46 - you know
26:47 - the cache storing the
26:49 - data in the case of rambac file systems
26:51 - has been plugged so that there's nowhere
26:53 - to flush the pages to when you write
26:55 - data into a ram-based file system
26:58 - there's two instances of them there's
26:59 - ramifest and temp-fs in the kernel
27:01 - when you write it in there it it has
27:03 - nowhere to go so it stays and when you
27:06 - delete the files out of them it frees up
27:09 - the memory so that they automatically
27:12 - resize themselves to how much is
27:14 - actually being used now note that the
27:16 - older ram disk that you've probably
27:19 - heard of isn't actually a ram bass file
27:22 - system it is a block backed file system
27:25 - where you have a device driver that
27:28 - turns a block of memory into a block
27:30 - device it exposes it in dev as slash dev
27:34 - ram zero or something like that and then
27:36 - you use a second driver as the you know
27:39 - ext2 or vfat or something like that as
27:42 - the lens you look at that
27:44 - block of memory through you run a
27:46 - formatting program on it to put it in
27:48 - you know the right format you copy files
27:50 - into it and then you look at it through
27:51 - a second driver
27:53 - that is a convention that is a block
27:55 - based file system not a
27:57 - a ram based file system
27:59 - so a lot of people to this day still
28:01 - confuse those ram-based file systems are
28:04 - actually a lot more memory efficient
28:06 - because the thing about a block-based
28:08 - file system is you've got the copy in
28:10 - the block device and then you've got
28:12 - another copy in the page cache
28:14 - so it actually you know
28:18 - it it's actually less memory efficient
28:21 - to use the older format and a lot of
28:24 - people still don't understand the
28:25 - difference between those uh the fourth
28:27 - kind is synthetic file systems where
28:29 - there is no backing store when you read
28:31 - files or you write files you're talking
28:33 - to a driver that can do arbitrary stuff
28:35 - with them proc is an example of this
28:36 - sysfs is an example of this the contents
28:39 - of proc
28:42 - are just hallucinated by the driver it
28:45 - makes it up
28:46 - and then when you write stuff into there
28:48 - it can call any arbitrary function in
28:49 - the driver to do anything it wants
28:52 - you know so those are actually four
28:54 - different categories of file system
28:56 - and generally when you are
28:58 - telling the kernel you know when the
29:00 - kernel is booting
29:02 - it can
29:03 - extract a cpio archive into
29:06 - the ram fs instance it already has and
29:08 - this is called an it ram fs
29:10 - the older way of doing it before linux
29:13 - implemented any ram based file systems
29:15 - it only had an it rd the initial ram
29:19 - disk the block backed version
29:21 - so
29:22 - it could allocate a ram block disk and
29:26 - take something like an ext2 image
29:29 - and copy it in there it could take a
29:30 - gzipped ext2 image the same way that
29:32 - you'd uh
29:33 - you know
29:35 - you take an iso image for example that
29:38 - you ripped from a cd and then you can
29:40 - gzip it well you could
29:41 - [Music]
29:42 - you could copy that into
29:44 - the uh
29:45 - the ram disk and
29:48 - mount it using the iso 9660 driver as
29:50 - the lens you look at it through
29:53 - um
29:54 - and then the third thing it can do is if
29:56 - you didn't provide either of these two
29:57 - or if you did provide them but it
29:59 - couldn't find an init program to run out
30:02 - of them
30:03 - in in it remfs it looks for file slash
30:06 - init it looks for file init in the top
30:08 - level directory that is execu that has
30:11 - the executable bit set if it can exect
30:13 - that it'll stop looking further and
30:15 - it'll just launch pid 1.
30:16 - in the uh
30:20 - in the older ram disk based one it
30:22 - looked for a different name linux rc
30:24 - which uh is just historical interest
30:27 - don't go there
30:28 - and in uh
30:33 - init main dot c
30:37 - the
30:41 - in the linux kernel source code in init
30:42 - main.c there's a
30:48 - there's a function
30:51 - start kernel
30:53 - so if you go into the linux kernel
30:55 - source code and look in init main.c
30:57 - function start kernel you can actually
30:59 - trace through how the linux kernel
31:01 - starts up because this is the one that
31:03 - actually does it it has a bunch of
31:07 - different places it looks as fallbacks
31:10 - it looks for s-bin in it it looks for
31:12 - etc in it it looks for bin in it and if
31:14 - it can't find any of those it'll launch
31:16 - been sh this is for the fourth sorry for
31:19 - the third place it looks
31:21 - if there is a
31:23 - root equals argument on the command line
31:26 - it goes ah this is a block device
31:30 - mount it
31:31 - and then
31:33 - try to find an init program in there
31:36 - that used to be you know
31:38 - that's that's the fallback root file
31:41 - system so those are the three different
31:42 - places that you can tell the linux
31:44 - kernel here's where to find your root
31:46 - file system and then within that file
31:47 - system you have an init program
31:50 - so the kernel has finished building
31:52 - and
31:53 - at the top level there's a file here
31:55 - called vm linux
31:57 - this is an elf
31:59 - program
32:01 - and i mentioned that
32:03 - elf is an archive format and you saw
32:05 - that obj dump trick will they do a
32:07 - variant of that object trick and then
32:09 - stick a little header on the front
32:11 - to create arch asterisk boot
32:17 - the the file arch x86 boot bz image and
32:20 - you'll notice i mentioned that this
32:21 - one's enormous we're going to go into
32:22 - kernel configuration stuff
32:24 - after this
32:26 - so what we do is we go qemu
32:31 - um
32:33 - let me see i
32:35 - did a
32:41 - uh
32:46 - i did a
32:52 - yeah
32:54 - yeah so
32:58 - oh this little trick here make dash j
33:00 - dollar sign parentheses n proc there's
33:02 - an nproc command that tells you how many
33:05 - processors this machine has
33:07 - so if you want to automatically do smp
33:09 - at the level that this machine does you
33:11 - can just you know
33:15 - that says run a command and turn its
33:17 - output into an argument
33:19 - so make dash j
33:22 - n proc
33:23 - will automatically do make dash j
33:25 - however many processors are in the
33:26 - machine that's what that little trick
33:27 - does it's fun thing so we did the make
33:29 - deck config we did the make and then
33:31 - this is kernel command line which is
33:33 - similar to the bare metal one qemu
33:36 - system i386 instead of arm this time
33:38 - because i'm running an x86 laptop
33:40 - dash no graphic is the same don't pop up
33:43 - a window instead give me a serial
33:44 - console on standard in and stand it out
33:46 - dash no reboot says when the system in
33:49 - here tries to reboot the hardware just
33:52 - exit qemu instead rather than restarting
33:54 - it
33:55 - here is where that kernel image we just
33:57 - built lives
33:59 - dash init rd
34:02 - of a file
34:06 - rd is as i mentioned there's the older
34:09 - uh boot mechanism that did initial ram
34:11 - disks i mentioned that you can
34:12 - statically link a cpio image into the
34:15 - kernel at build time
34:17 - well the method of pro of having the
34:20 - bootloader point it at an initial ram
34:23 - disk image that usually was a compressed
34:25 - block device boot loaders still know how
34:28 - to do that and the colonel still knows
34:29 - how to listen for that
34:31 - but what it does these days is first it
34:34 - checks the type to see is that a cpio
34:37 - signature at the start
34:39 - instead of ext2 or something like that
34:41 - if it identifies that you've fed it a
34:43 - compressed cpio image it goes oh
34:47 - i'll just extract this into a nitram fs
34:50 - and use initramfs instead of an
34:52 - it rd
34:54 - so it can auto detect the format so what
34:55 - we're doing is we're taking that archive
34:57 - and feeding it in through the external
35:00 - uh
35:01 - a nit rd loader and the reason we do
35:03 - that is every time we change the file
35:05 - system we don't have to rebuild the
35:06 - kernel
35:07 - because if it's statically linked in the
35:08 - kernel we'd have to rebuild the kernel
35:10 - and that's slow
35:12 - and then the last part which i screwed
35:14 - up
35:15 - there should not be a space there
35:17 - is append
35:19 - this is qemu ease for provide
35:23 - these extra arguments to the linux
35:25 - kernel command line what is the linux
35:28 - kernel command line there is a
35:32 - another one of these kernel.org docs
35:35 - capital d documentation
35:38 - is
35:38 - the online place for the documentation
35:43 - directory in the linux kernel source
35:44 - code
35:46 - under the linux kernel source there's a
35:47 - capital documentation directory with
35:50 - lots and lots of files in it i've
35:52 - already shown you
35:54 - documentation file systems
35:57 - fs root fs and
35:58 - ramfest.txt which is the documentation
36:01 - ramfest now let's look at
36:04 - they moved it recently it is now in
36:23 - oh
36:26 - oh okay they moved it between 4 9 and 4
36:28 - 10. it's in a different place now but
36:30 - it's the only old one here it moved into
36:31 - a sub directory but it's the same file
36:33 - name
36:34 - kernel parameters
36:36 - is a very nice file that just lists
36:41 - all the keyword equals value names that
36:44 - you can provide on the on the kernel
36:46 - command line to tell it to do stuff
36:48 - again as with the configuration symbols
36:50 - there's lots and lots and lots of them
36:52 - most of which aren't very interesting
36:54 - the ones that you are required to
36:56 - provide
36:59 - are
37:01 - well the the main one and that's wrong
37:03 - too
37:05 - if you're using a serial console you're
37:08 - going to want to say console equals
37:13 - the device
37:15 - the the name of the serial device that
37:17 - you're using you don't have to say slash
37:20 - dev if you do it'll recognize it and and
37:22 - chop it off but you have to identify
37:25 - which serial device should the should
37:27 - the serial console attach to
37:29 - because otherwise you won't get any
37:31 - console output and then panic equals one
37:34 - here says if the kernel panics reboot
37:37 - after this many seconds rather than
37:39 - hanging and remember that will make qemu
37:41 - exit so that's
37:43 - a lot more convenient here so we take
37:45 - this big invocation
37:49 - and
37:50 - we go
37:52 - and this will die because on this
37:54 - machine
37:55 - i have the
37:57 - root file system in another place
38:00 - but let's just use the one that i built
38:02 - a moment ago
38:05 - which is that root.cpio.gz
38:08 - that we just did so
38:13 - let's go back to here
38:17 - and go
38:24 - root.cpao.gz and now in a moment we
38:27 - should get
38:29 - come on
38:33 - hello
38:37 - do i have a broken qemu on this machine
38:42 - all right you're a much faster machine
38:44 - but i'm going to go back to the one that
38:46 - i actually
38:47 - did the initial setup on because this is
38:49 - silly
38:51 - oh
38:52 - that yes that would be wrong that would
38:54 - be why and it didn't make it far enough
38:56 - to panic so it never tried to exit
39:05 - qmu system x8664 yes
39:12 - that's much happier thank you
39:14 - so here are you know you'll notice
39:16 - there's lots and lots of boot messages
39:20 - what are you doing
39:22 - clock source switched to clock source
39:24 - tsc yes i saw that
39:26 - come on you should finish booting
39:29 - oh do i have a weird version of qemu on
39:31 - here
39:34 - oh yes i do blah
39:36 - it just it was booting asynchronously so
39:38 - it yeah
39:40 - so it continued to spit console messages
39:41 - after the thing so as i said this is
39:44 - very simple to build and pretty much
39:47 - useless we need to make the kernel
39:49 - smaller
39:50 - we need to make
39:51 - user space bigger well the next way to
39:54 - make user space bigger
39:57 - what have i got in here
40:03 - is i have a copy of busybox checked out
40:05 - here
40:06 - and what i'm going to do
40:11 - it is config prefix so i'm going to go
40:14 - make def config
40:17 - um
40:19 - who here has not configured a linux
40:21 - kernel
40:23 - okay
40:26 - we're going to get to configuring the
40:27 - linux kernel but busybox actually copied
40:31 - uh kernel configuration infrastructure
40:33 - so if i go make menu config
40:36 - i get an interactive configurator
40:38 - program where i can cursor up and cursor
40:40 - down and i can hit enter to go into a
40:43 - menu and i can hit space to select a
40:45 - symbol or deselect a symbol or sometimes
40:48 - it'll it'll cycle through asterisk m and
40:51 - space where the m means build this as a
40:53 - module rather than statically linking it
40:55 - into the kernel and
40:57 - if you don't understand what modules are
40:58 - just don't use them modules are a thing
41:01 - you level up to when when you need them
41:04 - it basically means that after the kernel
41:06 - has booted you can tell it here's an
41:07 - extra chunk of code using the ins mod or
41:09 - mod probe program say insert this module
41:13 - into the kernel
41:15 - and you can also tell it remove this
41:17 - module from the kernel at which point it
41:19 - will hide it from you but not free up
41:21 - the memory
41:22 - unless you've configured the kernel in a
41:25 - way people usually don't and provide an
41:28 - extra flag that will from that point on
41:31 - mark your kernel as tainted
41:33 - so that if you submit a bug report after
41:35 - doing it the kernel developers will
41:37 - explicitly ignore you
41:41 - yeah because
41:42 - removing bits from a running kernel is
41:44 - just
41:46 - not something that can ever quite be
41:48 - done safely or at least they haven't
41:51 - convinced themselves that it has and
41:52 - they just they don't want you to do that
41:54 - um but people like red hat with you know
41:56 - large amounts of money from corporations
41:58 - where the system should never be down
42:00 - even for maintenance they love you to do
42:01 - that so they'll argue with the kernel
42:03 - developers but anyway this menu config
42:05 - program is basically just a way of
42:07 - configuring stuff
42:08 - and then when i'm done do i want to save
42:10 - the new kernel configuration in this
42:12 - case no
42:13 - well now if i go to busybox and busybox
42:15 - make menu config there is a similar menu
42:17 - config
42:18 - here
42:20 - where you know
42:21 - here's stuff that would be in the new
42:23 - core utils package that was completely
42:25 - re-implemented you know here's you know
42:27 - do you want the dos to unix command do
42:29 - you want the df disk free command and
42:32 - they have a whole bunch of sub things of
42:34 - do you want it to have these features
42:37 - and back when i was maintaining this
42:38 - sucker i i did a policy that
42:41 - there is
42:44 - there are a bunch of
42:47 - yeah make help on a lot of packages will
42:49 - actually provide here's various make
42:50 - targets that's a good thing to know and
42:52 - you can then grep for
42:54 - the ones that have config in their names
42:57 - config is the
42:58 - default configuration
43:00 - you know you'll notice that we did the
43:02 - x86 64 def config over in the the kernel
43:07 - land well in busy box make def config
43:10 - basically says switch on everything that
43:13 - is sane
43:14 - don't switch on the weird debugging
43:16 - stuff don't switch on like the se linux
43:18 - stuff that won't build if you don't have
43:20 - the right headers installed
43:22 - but
43:22 - if it's a feature switch it on
43:25 - give me a configuration that includes
43:28 - pretty much everything we know how to do
43:31 - so this is the biggest busy box you know
43:33 - you can get and then you can go into
43:35 - make menu config and start switching
43:36 - stuff off to pare it down there's
43:38 - usually two starting points with any
43:41 - menu config based thing there's all no
43:43 - config
43:45 - and all yes config
43:46 - all no config is basically if you went
43:49 - into menu config and switched off
43:51 - everything that could be switched off
43:54 - this would be your config
43:55 - all yes config is the opposite switch on
43:57 - everything that you can switch on and
43:59 - the reason that busy box def config is
44:01 - different than busy bucks oh yes config
44:03 - is that in busybox all yes config is
44:06 - insane and switches on stuff that no
44:09 - sane human being would ever want and
44:12 - usually whatever your system is it won't
44:14 - work
44:15 - because i mentioned we're debugging
44:17 - stuff so make def config is a good
44:19 - starting point
44:20 - so what i did is i did make def config
44:23 - and then
44:25 - we compile it
44:27 - which shouldn't take as long as the
44:29 - kernel did
44:32 - and i don't know if this is a release
44:33 - version this is a random git snapshot
44:34 - but it should still work
44:36 - i've built it before
44:39 - if you're going to deploy it use a
44:40 - release version
44:42 - okay and then
44:46 - make help grip install
44:49 - which has config prefix so make
44:52 - config
44:55 - prefix equals
44:58 - i can just do pwd is an environment
45:01 - variable that is my current directory
45:02 - slash walrus just some name that i know
45:06 - isn't already there so i told it install
45:08 - into a directory that doesn't exist
45:10 - and so it populated this new directory
45:16 - oh yes
45:21 - you know
45:23 - my red-eye flight that i had to get up
45:24 - at 3 30 a.m for was yesterday you'd
45:26 - think i'd be recovered by now
45:28 - that's why i got this
45:34 - the drink that chases unicorns into the
45:35 - ocean
45:36 - ah nasty stuff okay
45:39 - so
45:43 - so this popular director remember i said
45:44 - the older linux rc name that nobody uses
45:48 - anymore well busybox has been around for
45:49 - a while and it hasn't necessarily
45:51 - cleaned out all of its old stuff
45:54 - so
45:55 - what i do now is i do the same trick of
45:58 - find period
46:00 - pipe it to cpio
46:04 - dash h new c dash oh i never remember
46:08 - that part
46:10 - i wrote the documentation on this so i
46:11 - wouldn't have to remember it
46:16 - yes yes yes
46:20 - okay
46:22 - dash o all right
46:24 - dash o
46:26 - pipe it to gzip and
46:30 - root2.cpio.gz
46:32 - and now what we do is we take our
46:34 - earlier
46:37 - uh
46:39 - qemu system x86 64.
46:45 - and
46:49 - we cursor up and we tell it instead go
46:52 - to
46:55 - busybox busybox
46:58 - root2.cpao.gz and now
47:00 - we add one extra little thing
47:03 - rd init equals
47:06 - bin sh
47:09 - what i'm saying is instead of looking
47:11 - for a file called init
47:15 - in
47:16 - initramfs
47:17 - look for this file instead as your init
47:20 - program the name rd init dates back to
47:23 - when we were using ram disks instead of
47:24 - ram fs but it it listens for both
47:28 - so what that should say is do the same
47:30 - big long overcomplicated boot and
47:33 - no it didn't
47:34 - okay
47:35 - and you know what i did wrong i didn't
47:36 - statically link it all right let me
47:38 - explain more
47:41 - need more exposition so what it did here
47:44 - is it failed
47:46 - to boot it it panicked at the end
47:49 - and the okay freeing unused kernel
47:52 - memory is the last thing it says before
47:55 - launching a nid in this case it's
47:56 - freeing three different chunks failed to
47:58 - execute slash bin slash sh error
48:01 - negative two uh error negative two in
48:04 - the case of
48:11 - the the file is user include assem
48:13 - generic airno base.h if you you know
48:16 - know that and eno int
48:19 - you know negative two in this case enond
48:21 - no such file or directory but bin sh is
48:23 - there yes but the dynamic linker wasn't
48:28 - because i forgot to statically link it
48:31 - wherever it is
48:34 - bin sh is assembling to busybox
48:38 - busybox is a
48:43 - file that is dynamically linked
48:46 - and it is looking for the first thing
48:48 - it's going to look for is this file
48:50 - which is the dynamic linker
48:52 - that is the program it will actually
48:54 - execute and then this program will be
48:56 - the first argument to that
48:58 - it's kind of like when i have a shell
49:01 - script it has pound sign exclamation
49:03 - point and a path to the thing to
49:05 - actually run and then the thing that you
49:07 - actually run gets this is an argument so
49:09 - that pearl or python or the shell can
49:13 - interpret this script well dynamically
49:15 - linked elf binaries work the same way
49:17 - they have a dynamic linker program that
49:19 - runs and then loads all these other
49:23 - libraries in you know from the library
49:25 - search path into memory links all the
49:28 - references out of this thing to them and
49:30 - then jumped to its start and what it was
49:33 - basically saying is this misleading
49:35 - error message the no such file directory
49:37 - was saying the dynamic linker in this
49:38 - thing wasn't there all it had was a
49:41 - number and the number did say what the
49:43 - problem was but it didn't say what file
49:45 - the problem was so if you encounter that
49:47 - kind of thing you know you you learn
49:51 - you learn to debug this kind of stuff
49:53 - okay so what we do is we build again
49:56 - and this time
49:59 - um
50:02 - make clean make i don't have to do a
50:05 - make clean but i don't remember
50:07 - the way to tell it to so ld flags
50:11 - static
50:14 - make j8
50:18 - right
50:22 - and we build again
50:26 - [Music]
50:29 - and then when that's done
50:30 - i can test that the busybox file is
50:33 - statically linked
50:37 - while it's doing that let me
50:39 - point you at a couple other interesting
50:40 - web pages
50:42 - so
50:43 - yeah what's the difference between rv
50:48 - um in current kernels not as much in
50:51 - current kernels i believe that a net
50:53 - ramifest will fall back to looking at
50:56 - init equals that went in like four six
50:59 - four seven or something it's fairly
51:01 - recent within the past year um init
51:03 - equals
51:04 - used to just tell the colonel what in it
51:07 - to look for when it was mounting a block
51:09 - device on you know stage three the root
51:12 - equals file back after it couldn't find
51:15 - a statically linked in it ram fs and
51:17 - then it couldn't find a
51:20 - an external rd image
51:23 - so it didn't have anything in it ram fs
51:25 - or an init rd then the third thing it
51:27 - would try to do was mount a block device
51:29 - and init equals used to only apply to
51:33 - that block device
51:34 - you needed the other argument to tell
51:36 - init ram fs what in it to look for
51:40 - okay i think that that has recently
51:42 - changed so i could say init equals and
51:45 - i'm using a four four nine kernel so we
51:46 - might as well try
51:48 - let's see so that will have okay so
51:52 - what i was pointing you to here let me
51:54 - finish the thought
51:55 - um
51:56 - i wrote a lot of documentation in that
51:59 - system that i have
52:01 - since
52:02 - stopped working on but you know i did
52:04 - this one for 15 years and i still answer
52:06 - questions about it
52:07 - but you know
52:09 - aboriginal linux our motto was we cross
52:10 - compiled so you don't have to
52:12 - where it booted these the
52:14 - smallest simplest development
52:16 - environment capable of rebuilding itself
52:18 - under from source under itself from
52:19 - source code and building linux from
52:21 - scratch under the result
52:23 - and that meant you could
52:25 - natively compile
52:27 - anything under qemu that you wanted to
52:30 - without ever having to cross compile
52:31 - again cross compiling
52:33 - is very hard i wrote documentation
52:40 - i meant to hand this out to the
52:43 - group i wrote an intro to cross
52:45 - compiling
52:47 - that
52:48 - explains you know basically what cross
52:50 - compiling is and why cross compiling is
52:52 - hard
52:54 - this is very polite because this was
52:55 - written not to scare people away from
52:58 - cross compiling this was sort of you
52:59 - know so you have to cross compile my
53:02 - sympathies here's how to do it um if you
53:05 - can avoid cross compiling
53:08 - try
53:09 - because cross compiling is really really
53:11 - nasty
53:13 - you have two contexts you have two sets
53:16 - of headers
53:17 - you know the one for the system that
53:18 - you're building on and the one that your
53:20 - system for the system you're building
53:21 - for you have two sets of of libraries
53:23 - you're linking against one for the
53:25 - system you're building on one for the
53:26 - system you're building for most systems
53:28 - go configure make make install
53:31 - and you know configure asks questions
53:34 - about the system you're building on
53:36 - and uses them
53:38 - to
53:39 - you know apply to the system you're
53:41 - building for and when they're two
53:42 - different systems
53:44 - the whole of configure is asking the
53:47 - wrong questions
53:48 - you know about half of cross compiling
53:51 - is figuring out how to lie to auto conf
53:54 - or to just get it to stop because it's
53:56 - like well let me build a little test
53:57 - binary and run it to see what the output
53:59 - output produces well you can't when
54:01 - you're cross compiling it won't run on
54:03 - this system that's sort of the point of
54:05 - cross compiling
54:06 - um
54:08 - and your build system if you are
54:11 - building something locally that like
54:12 - generates a header file you know a lot
54:15 - of times you will run a small c program
54:17 - to produce code that that or modify code
54:20 - that then gets compiled so you need a
54:22 - native compiler you need what's called a
54:25 - host compiler and you need a target
54:27 - compiler
54:29 - to build for the target and so you have
54:31 - two separate contexts and have to keep
54:33 - them separate you have to prevent bits
54:36 - of your host system from leaking into
54:39 - your target system
54:41 - and what you wind up doing is
54:43 - you know just natively compiling on a
54:45 - bunch of different targets it's like i
54:47 - tested it on an arm i tested it on spark
54:49 - i tested it on power pc i found slightly
54:51 - different bugs in each case
54:53 - but that's okay there's a linear number
54:55 - of them well when you're cross compiling
54:57 - i tested cross compiling from this
55:00 - system
55:01 - to that system and i got slightly
55:04 - different bugs
55:05 - every from system so it's
55:08 - hosts times targets
55:11 - so your testing
55:13 - you know attack surface
55:15 - is just exponentially larger and then
55:18 - there's the fact that only about two
55:19 - percent of the developers will ever care
55:21 - about cross compiling at all
55:23 - you know uh debian has over 40 000
55:26 - packages in its repository
55:29 - maybe a thousand of them have ever been
55:32 - cross-compiled on a good day with a
55:34 - tailwind
55:36 - and so it's just
55:38 - cross compiling is a thing that can be
55:40 - done
55:41 - but the point of this entire project was
55:43 - native compiling under emulation is so
55:46 - much easier and then the trick i did was
55:48 - i fired up uh disc cc
55:51 - and taught it to call out uh through
55:54 - through qemu's emulated network to the
55:56 - cross compiler running on the host
55:58 - so
55:59 - configure ran fine
56:01 - the you know there was one set of
56:02 - headers the header information was
56:04 - pre-processed before dc sends it out to
56:06 - the compile node um
56:08 - linking ran fine because that happened
56:10 - inside the emulator
56:12 - i could install the result into the
56:14 - system so that my dependency recognition
56:16 - you know worked fine but the heavy
56:18 - lifting of compilation was moved outside
56:20 - of the emulator to some place that cpu
56:22 - was cheap and i had access to smp
56:25 - you know so that was a that was a fun
56:27 - thing i i did it for a long time and
56:29 - it's sort of out of scope here but feel
56:31 - free to read about it what i'm actually
56:33 - working on now
56:37 - is a project called make root
56:40 - which
56:41 - basically
56:43 - one of the things aboriginal linux did
56:44 - is it built its own cross tool chain and
56:46 - its own native tool chain well there's a
56:48 - project out there now called
56:54 - muscle cross make
56:58 - by the guy who does muscle libsy rich
57:00 - felker
57:01 - which is a tool chain builder that not
57:04 - only creates cross compilers but creates
57:06 - native compilers which is the thing that
57:08 - i couldn't beat out of you know build
57:10 - root will create cross compilers it
57:12 - doesn't want to create native compilers
57:13 - cross tool ng look right cross compilers
57:15 - it doesn't want to create native
57:16 - compilers you know um
57:19 - code sorcery would give you cross
57:20 - compilers they wouldn't give you native
57:21 - clouds there's a bunch of places i get
57:23 - cross compilers from but if i then
57:24 - wanted to build stuff in the resulting
57:27 - system
57:29 - i didn't have a compiler i could install
57:30 - into the thing i could fish them out of
57:33 - debian
57:34 - debian has native compilers for all the
57:36 - targets it supports
57:37 - but they depend on debbie and they're
57:39 - dynamically linked not statically linked
57:41 - so i would need glibc installed for like
57:43 - super h
57:45 - and stuff like that and it's like
57:46 - well now i have i have a package that
57:48 - will actually give me the native
57:49 - compilers which is why i started over
57:50 - and i went i can be much much simpler
57:52 - about building a thing and what this is
57:53 - is this is a shell script
57:55 - that
57:56 - builds a root file system
57:59 - which
58:00 - i'll i'll go through this in a little
58:02 - bit after after i go through configuring
58:03 - a kernel i'll go through this as here's
58:05 - how you make a simpler route file system
58:08 - but it's it's a shell script that will
58:09 - basically populate one of these
58:11 - directories you then cpio up and then
58:13 - run it out of ram fs and that gives you
58:15 - a nice starting system once you have one
58:17 - of these things if you want to repackage
58:18 - it as ext2 or repackage it as squash fs
58:21 - there's a make squash fest utility you
58:23 - can read the man page of i can walk you
58:25 - through how to do that too
58:28 - basically creating a file system for one
58:32 - of the other file formats
58:34 - is either run a utility like make squash
58:37 - fs or gen ext2fs that works like tar
58:41 - does here's a directory here's the
58:42 - output file it just puts it into the
58:44 - thing or what you can do is you can use
58:47 - a loopback device anybody here not know
58:50 - about lootback devices
58:53 - okay
58:54 - loopback devices
58:55 - if you need to create a block device
58:57 - file system
58:59 - you have to do it as root
59:03 - uh you can
59:06 - uh let's see dd e i f equals dev
59:10 - zero
59:12 - o f equals blah dot img bs equal block
59:16 - size equals one meg count equals let's
59:19 - say
59:20 - 256 so let's create a 256 megabyte
59:24 - capital m
59:26 - shouldn't have to care so that created a
59:28 - 256 megabyte blah.img
59:33 - and then i can format it
59:35 - yes
59:38 - come on come on there we go
59:42 - and then i can go mount dash o loop
59:48 - blah.img
59:52 - i need to create a directory for it
59:56 - mount show loopblah.img
59:58 - subdir
60:01 - and then
60:08 - there we go and subdir
60:10 - is
60:13 - that file system
60:15 - a
60:16 - a loopback device is a special block
60:18 - device
60:20 - that
60:22 - creates
60:23 - um
60:24 - it it basically is it's another type of
60:26 - lens remember how i said ext2 is a lens
60:28 - you look at a block device through to
60:30 - make it look you know like a directory
60:32 - full of files well
60:34 - this driver lets you look at a file
60:37 - and make it look like a block device it
60:39 - shows up as dev loop zero
60:43 - or dev loop one there's a bunch of them
60:46 - you know um these days it it dynamically
60:49 - creates more there used to be a static
60:51 - number of them kind of like uh ptys you
60:53 - know they're dynamically allocated now
60:54 - they used to be statically allocated
60:57 - they split the difference by statically
60:58 - allocating the first view and then
60:59 - dynamically adding more is you asked for
61:02 - them
61:02 - um and what you can actually do is you
61:05 - can do ello setup
61:07 - dev loop zero which i believe by default
61:10 - will tell you what it's associated with
61:12 - you know so if i say devloop one it says
61:14 - it's not associated with anything but
61:16 - dev loop zero is associated with this
61:18 - thing if what the mount command is doing
61:20 - behind the scenes is calling ello setup
61:24 - to associate
61:25 - file name with loop device
61:27 - there's a man page on elo setup
61:30 - if you want to know
61:32 - and
61:33 - then when you unmount it the unmount
61:35 - command recognizes oh this is a look
61:37 - this is a loopback device and calls ello
61:39 - setup dash d to de-associate that
61:42 - loopback device with that file and the
61:44 - advantage of this is i can
61:53 - [Music]
61:56 - is i can copy
61:59 - a file into here
62:01 - that's two.txt into subdir and then i
62:04 - can unmount subdirer
62:07 - and then i can
62:09 - gzip blah.img
62:12 - and i i have just created a compressed
62:16 - ext2 image of 256 megabyte size that's
62:20 - the basic procedure
62:22 - for if i want to create block device
62:25 - images
62:26 - now
62:28 - this works for
62:30 - normal
62:31 - block devices it doesn't work for flash
62:34 - devices flash devices aren't exactly
62:37 - blocked devices
62:39 - because the way flash works normal block
62:41 - devices have a granularity of like 512
62:44 - bytes or these days 4k and the file
62:46 - systems have a block size of like 4k
62:48 - this is the the size that they upgrade
62:50 - with
62:51 - if your underlying device has a
62:54 - has an upgrade update granularity larger
62:58 - than the block size of a file system bad
63:00 - things happen
63:02 - because if your flash every time you
63:04 - write to the flash it's updating 128k
63:07 - chunk
63:08 - and you think you're writing 4k sectors
63:11 - so you have ext3 journaling and it's
63:13 - like right we write these things into
63:14 - the journal and then we update just this
63:16 - sector and we haven't written anything
63:18 - before it and we haven't written
63:20 - anything after it so we don't need to
63:22 - keep track of that and if we lose power
63:24 - in the middle of it all we have to do is
63:25 - replay the journal and that'll tell us
63:27 - you know
63:28 - what what changes we were in the middle
63:30 - of and then when we tried to remount it
63:32 - oh the entire directory is gone because
63:35 - that 4k was in the middle of 128k of
63:38 - directory and all of it got zeroed and
63:41 - then didn't get written back because the
63:43 - power was interrupted and oops my flash
63:45 - file system is corrupted because i'm
63:47 - using a file system type that isn't
63:49 - aware of flash's erase granularity
63:52 - this happens
63:54 - it's a bad thing so they have what's
63:56 - called log structured file systems that
63:58 - are designed for use on flash
64:01 - that the first thing they do is they do
64:04 - a special i o control against the block
64:05 - device that says what is your block what
64:08 - is your erase granularity
64:11 - what is the update size and alignment
64:13 - and stuff where are your erase blocks
64:16 - so that every time i update i am
64:18 - updating an entire erase block and they
64:20 - do things like they pack the data into
64:22 - the erase blocks so that they're not
64:25 - doing extra rights to you know we only
64:27 - updated a little of this thing so we
64:28 - don't want to erase and rewrite the
64:30 - whole thing we want to save our rights
64:32 - and and you know round robin around the
64:34 - disk because that's better for flash
64:35 - because flash wears out you know so they
64:37 - they work in a completely different way
64:39 - and if you try to mount one on a normal
64:42 - block device or on a loopback device it
64:44 - goes i can't figure out what the erase
64:46 - block size is that's part of the format
64:48 - of the file system
64:50 - i fail
64:51 - and it refuses to mount
64:53 - so
64:54 - if you mount one of those you have to
64:56 - provide if if you're faking it on
64:57 - something like a block device these days
64:59 - i believe
65:00 - you can provide an extra dash o option
65:04 - to to tell the driver
65:06 - and pretend your erase block size is
65:09 - this size
65:10 - so i can make a flash file system that i
65:13 - can then copy into flash
65:15 - but
65:16 - that's a whole area you now know you
65:18 - need to look it up but i can't cover it
65:20 - in any reasonable detail here
65:22 - okay so meanwhile going back to here we
65:25 - have
65:27 - built
65:28 - i opened a lot of windows didn't i
65:31 - i wonder which one is okay here we go
65:34 - so did i install no i didn't so make
65:38 - i should still have it up here make
65:42 - there we go
65:43 - oh
65:46 - did you have a question
65:49 - okay so we install into the thing now
65:56 - we and it's the same thing except
66:01 - walrus
66:06 - statically linked no dynamically linked
66:09 - darn it
66:12 - you didn't recursively remove the wall
66:17 - yeah it should have installed over it
66:18 - anyway
66:20 - you want to try that
66:22 - yeah yeah yeah yeah yeah yeah i didn't
66:25 - actually do a make clean this time
66:27 - did you detect that i changed the c
66:29 - flags and you're rebuilding everything
66:33 - okay
66:36 - statically linked
66:37 - all right let's do that install again
66:44 - what are you compiling
66:47 - i just built oh
66:49 - you're going to rebuild the thing and i
66:51 - didn't
66:52 - do the sea flags here
66:56 - [Music]
66:57 - i note that i haven't maintained this
66:59 - project since 2006.
67:01 - you can blame me for this but i will
67:05 - complain
67:07 - alright so file
67:09 - wara spin
67:12 - busybox static
67:17 - and let's do the cpio thing again which
67:19 - should still be in the
67:21 - command history
67:23 - and now let us go to
67:29 - wherever i had that
67:30 - kernel launch invocation
67:33 - too many open windows here we go and
67:36 - let's try it now
67:40 - hey
67:41 - all right
67:42 - i have a shell prompt
67:44 - so i have now made
67:47 - a
67:48 - simple to make
67:51 - kernel and root file system
67:55 - the kernel is still six and a half megs
67:57 - containing as you saw from the boot
67:59 - messages lots and lots of stuff we don't
68:01 - need
68:02 - and the root file system still has
68:04 - rather a lot of stuff we don't need it's
68:05 - the biggest busy box you can make
68:08 - and also
68:10 - you know i uh well it doesn't have a it
68:13 - doesn't have an init script
68:15 - so i have to mount t proc
68:18 - proc
68:19 - uh makeder proc i didn't make the
68:22 - directories
68:24 - and then i should be able to if config
68:27 - and you know nothing set up the network
68:30 - you know we need an init script that
68:31 - actually does some stuff
68:33 - so actually
68:35 - i'll get to the kernel let me go to the
68:36 - root file system stuff first this is
68:39 - that root file system builder i talked
68:41 - about
68:42 - so let me walk you through what it does
68:44 - you can you know github.com landley
68:47 - slash make root there's one script make
68:49 - root
68:50 - where you can basically just
68:56 - let me see if i
68:59 - let me check out a fresh copy of it i
69:02 - don't know just
69:05 - do i have no i do not have it
69:07 - extensively locally modified here woot
69:12 - january 31st is that current
69:14 - let me see
69:15 - yes okay
69:17 - so the first thing it's building is
69:19 - when i left busybox i started over from
69:21 - scratch in a project called toybox
69:24 - because
69:25 - i felt i could do a better job toybox is
69:27 - now the standard command line of android
69:30 - i am attempting to turn android into a
69:31 - self-hosting development environment i'm
69:33 - using what i learned on aboriginal linux
69:35 - to basically make it so that
69:38 - what's installed by default on android
69:41 - should be enough to build aosp
69:44 - let alone linux from scratch so that
69:46 - having an android phone is sufficient to
69:48 - develop for android
69:50 - um
69:51 - it's got usb on the end of it if you
69:53 - plug it into a usb hub you can add a usb
69:55 - keyboard usb mouse
69:57 - use chromecast to put it on a big screen
69:59 - and you know
70:01 - this is a gigahertz processor with at
70:03 - least half a gig of ram you know it it's
70:05 - a reasonably powerful system and if you
70:07 - plug it into usb it's going to be
70:08 - charging itself
70:09 - so
70:11 - i i gave a talk about that here at 2013
70:14 - the android guys went basically sure why
70:16 - not and started merging my stuff and
70:19 - that's taking up an awful lot of my time
70:21 - oh
70:23 - what i didn't do is i didn't tell it
70:27 - to use the current version of toybox but
70:29 - i'll just grab the
70:36 - one of the things i did is i made it so
70:37 - that if you uh
70:40 - if you have an extracted directory in
70:42 - the packages directory with the same
70:43 - name it'll use that instead of
70:44 - extracting the tarball
70:47 - um
70:48 - you know 300 something line script but
70:50 - it actually does a lot
70:51 - so let me walk you through it so it's
70:53 - building toybox instead of busybox
70:54 - because i am migrating all my own stuff
70:57 - from busybox to toybox
70:59 - um
71:01 - it it's a somewhat cleaner
71:02 - implementation if you saw uh the
71:05 - the talk a couple of sessions ago on uh
71:08 - on shrinking the linux kernel um
71:11 - he he was comparing toy box to busybox
71:13 - um the
71:15 - the really fundamental difference the
71:16 - reason that android can use it and
71:18 - couldn't use busybox even though busybox
71:20 - predates and you know busybox is older
71:22 - than android and you know you're not
71:23 - gonna wait for them to start shipping it
71:25 - it's they're they're not shipping it for
71:26 - a reason is that they have a no gpl in
71:29 - user space policy gpl v3 happened about
71:32 - the same time that android did and they
71:33 - responded by throwing out the gpl v2
71:35 - baby with the gpl v3 bathwater
71:37 - you know now that
71:39 - now that there's no such thing as the
71:41 - gpl anymore and you have warring camps
71:44 - that can you know the linux kernel and
71:45 - samba can't share code even though they
71:47 - implement two ends of the same protocol
71:48 - and each has to police their their
71:50 - submissions to make sure that they
71:51 - didn't get code from the other one
71:53 - because that would be incompatible and
71:55 - they'd get sued it's like android just
71:57 - went nope
71:58 - opting out and
72:00 - you know they rewrote
72:02 - they rewrote their bluetooth demon they
72:04 - threw away the one they had that was gpl
72:06 - and wrote one that's apache license
72:08 - they're they're slowly going through and
72:10 - removing that so toybox is under a
72:12 - public domain equivalent license that
72:14 - looks like a bsd license to make the
72:16 - lawyers happy and
72:18 - you know
72:19 - that's why they can merge it
72:21 - um
72:22 - okay
72:23 - so i did just build the thing and what
72:26 - that did is that created a
72:30 - directory called root that has a bunch
72:32 - of stuff
72:34 - and in the build directory it created a
72:36 - root.cpao.gz
72:38 - and this is a mix of toybox and busybox
72:42 - you could use just busybox
72:45 - but
72:46 - as i said my own personal development i
72:48 - am migrating from one to the other i'm
72:50 - only using busybox for the commands i
72:51 - haven't implemented a good enough
72:52 - version of in toybox yet
72:56 - so
72:56 - walking you through what this does
72:59 - this is the script on github
73:02 - uh it starts if you you know
73:04 - if you don't run it with any
73:06 - if you run it with unknown commands it
73:07 - prints out a help message
73:09 - it figures out if you've set the
73:11 - environment variable cross compile if so
73:14 - that is what cross compiler to use that
73:16 - says i'm not building it for
73:18 - uh the the host system i'm building it
73:20 - for arm or power pc or whatever the
73:22 - cross compiler is so it
73:24 - you know figures out a couple of things
73:26 - from that and it makes sure that it can
73:28 - actually run the cross compiler because
73:30 - if you point a cross compile you know
73:32 - compiler that isn't in your path it'll
73:33 - go uh no
73:36 - those directory names i mentioned above
73:38 - you can you can replace them if you want
73:40 - to
73:43 - it checks to make sure that you can
73:44 - build static binaries because it turns
73:46 - out on things like fedora unless you
73:49 - install the package that contains
73:51 - libsy.a it doesn't install the static
73:54 - libraries by default so you have to
73:55 - install an extra package in order to be
73:57 - able to link stuff statically it when
74:00 - you install a tool chain it can only do
74:02 - stuff dynamically
74:04 - because ulrich drepper hated static
74:06 - linking and even though he left to go
74:07 - work at the bank of evil goldman sachs
74:10 - um
74:12 - they haven't undone all of the damage
74:14 - uh static linking is very useful you'll
74:16 - you'll notice i i hadn't copied the
74:20 - shared libraries into the root file
74:22 - system i could run the ldd command to
74:25 - see what shared libraries do i need and
74:28 - copy them and then remember to run ldd
74:30 - against those libraries because
74:32 - libraries can link against other
74:34 - libraries
74:36 - but
74:37 - that's
74:38 - that's a lot of
74:40 - work up to that the simplest linux
74:43 - system as it says in the title of
74:45 - presentation is not going to be
74:46 - dynamically linked because dynamically
74:49 - dynamic linking adds
74:51 - complexity statically linking
74:53 - dynamic linking is worth it once you
74:55 - have reached enough different files
74:58 - sharing the same libraries
75:01 - that
75:03 - you're saving enough memory to care
75:05 - and it that won't be for a while
75:07 - okay so this is a thing that basically
75:11 - just extracts a tarball into a working
75:14 - directory and it checks to see if there
75:17 - is an extracted version and it will use
75:19 - that instead
75:20 - um
75:21 - it's only a few lines you can read that
75:23 - you know so and then cleanup is the one
75:25 - that uh
75:26 - deletes it afterwards this is basically
75:29 - tar extract
75:30 - and this is
75:32 - rm-rf
75:34 - only they're
75:35 - you know kind of fancy versions but
75:37 - every time you see that one of them is
75:38 - tar extract this does a w get of the
75:41 - source tar balls from this url and
75:42 - checks the sha1 sum
75:44 - so these are the toybox and busybox
75:46 - packages we will be building
75:48 - and then the first thing it does is it
75:50 - sees if there's an airlock directory
75:52 - that contains the toybox binary because
75:55 - i mentioned that when you are
75:57 - cross-compiling it's easy for bits of
75:59 - the host system to leak into the target
76:02 - system and you have that combinatorial
76:04 - problem where it built slightly
76:06 - different on ubuntu than it did on red
76:08 - hat that it did on this thing and
76:09 - instead of one set of things to test
76:12 - it's one for each target so it's
76:15 - number of hosts times number of targets
76:18 - and that is going to get out of hand and
76:19 - you will have stuff that you haven't
76:20 - tested
76:22 - well
76:23 - the way i solve that is
76:26 - i spent years making sure that busybox
76:29 - provided tools you could build a whole
76:31 - system with
76:32 - and these days i'm doing the same with
76:33 - toybox every
76:35 - tool that is in toybox dev config is
76:38 - good enough to build a system with not
76:40 - all the tools are there but
76:42 - you know the ones that are there
76:44 - my set can actually run autoconf that
76:46 - kind of thing so
76:48 - what i do is i build toybox
76:51 - install it into a directory and then i
76:54 - have a list of files i need to copy out
76:56 - of the host system because toybox
76:57 - doesn't implement a reasonable version
77:00 - and then
77:01 - and there will always be a few because i
77:03 - don't include a compiler so i'm copying
77:05 - gcc i'm sim linking to the host gcc i'm
77:08 - sim linking to the host bin utils in
77:09 - this directory of commands
77:12 - and then i set the path to just that
77:14 - directory and this is called the airlock
77:16 - step
77:17 - where once i've done this
77:19 - i'm using this
77:22 - little tiny system i built
77:24 - to provide a known build environment
77:27 - to isolate against variations in the
77:30 - host system
77:32 - now aboriginal linux was doing a whole
77:34 - lot more sanitization it had a white
77:36 - list of environment variables where if
77:38 - it wasn't one of these recognized
77:40 - environment variables it would unset it
77:42 - and it was doing a lot more cleansing
77:44 - and stuff and
77:47 - 95 of the time you don't need to worry
77:49 - about that so this is
77:51 - you know this is
77:52 - a little more than the 80 20 thing this
77:54 - is like the 90 that gets you 95
77:57 - of the thing
77:58 - so i this is creating an airlock step
78:01 - which is strictly speaking optional but
78:03 - it means that i'm building in a known
78:05 - environment
78:06 - i then
78:08 - um
78:10 - this is basically just dependency
78:12 - checking because
78:13 - you know in case i don't need to rebuild
78:15 - stuff that skip that step then what this
78:18 - does is this creates the directory
78:19 - layout
78:21 - this
78:22 - is doing a make deer
78:24 - of all the standard directories in one
78:27 - line
78:28 - this is pretty much the directories that
78:30 - packages expect to be in and with this
78:33 - set of directories i can install all the
78:35 - linux from scratch packages linux from
78:37 - scratch is an online book
78:39 - that tells you how to create a very
78:42 - large very complicated about 110
78:44 - megabyte system using conventional gnu
78:47 - packages
78:48 - but
78:49 - it's the base of
78:51 - most os versions it's nothing remotely
78:55 - like the embedded world uses and i as i
78:57 - said i spent
78:58 - many years making it so that
79:00 - a megabyte and change of busybox could
79:02 - replace 100 megabytes of gnu packages
79:06 - but that is the old reference
79:08 - build that i use because you know if you
79:11 - want to use the big version of said
79:13 - you can mine should be a drop in
79:15 - replacement for it but in order to
79:17 - ensure that it's a drop in replacement i
79:19 - need to test against the old one and i
79:21 - need to test that it can build the old
79:22 - one in case i am missing anything
79:24 - um
79:25 - so
79:26 - you know there's an exception directory
79:27 - a tmp proc sys dev home m t root and
79:32 - then under user there's bin s bin and
79:34 - lib and then there's a directory there
79:37 - and these are pretty much the
79:38 - directories that linux expects to be
79:40 - there there is a standard called the
79:42 - linux standard base lsb
79:44 - that
79:45 - unfortunately the linux foundation took
79:47 - it over
79:49 - the linux foundation was formed when the
79:52 - um
79:53 - when two black holes of bureaucracy
79:55 - combined
79:56 - to form voltron of bureaucracy and um
80:00 - one of those was the free standards
80:02 - group the other one was osdl
80:04 - and
80:07 - when they combined
80:09 - the
80:11 - the
80:12 - focus shifted from maintaining this
80:15 - standard to asking donors for money
80:19 - and
80:20 - unfortunately what this meant is that
80:22 - the linux standard base was so badly
80:24 - maintained that a year or so back debian
80:27 - when the 5.0 release came out threw up
80:29 - its hands and said we're done we're not
80:31 - paying any attention to the standard
80:32 - anymore which is kind of sad because
80:34 - there should be a standard for this
80:36 - stuff
80:38 - so
80:39 - there's still 4.1 lsb 4.1 and it does
80:43 - describe the layout of these things etc
80:45 - directory is where a bunch of config
80:46 - files traditionally live
80:48 - temp was the directory that unix used
80:51 - for temporary files
80:53 - proc is where you mount procfs sys is
80:56 - where you mount sysfs those are two
80:57 - synthetic file systems that let you give
81:00 - you an api to play with the kernel so
81:03 - that ps can see what processes are
81:04 - available and you know ins mod can see
81:07 - what hardware is available and stuff
81:08 - like that
81:09 - uh dev is the directory that the device
81:12 - nodes go in i mentioned that the the
81:14 - serial console device is one of the
81:15 - devices in dev
81:17 - dev lo setup
81:19 - sorry devloop0 when i was showing
81:21 - loopback devices
81:23 - home is the directory under which the
81:24 - user accounts live
81:26 - mnt is a directory for additional mounts
81:30 - that's the traditional name for it the
81:33 - modern systems added one called media
81:36 - that does the same thing but
81:39 - they liked it
81:40 - um root is the home directory of the
81:43 - root user this is
81:45 - fallout from the days when uh home used
81:47 - to be on its own partition a lot and in
81:50 - case you hadn't you know in ca if you
81:52 - ever trash that partition it would give
81:54 - the and had to log in as root to
81:55 - administer the system it would give the
81:57 - root user you know somewhere to have his
81:59 - files um
82:01 - user bin s bin and lib
82:03 - actually exist because um ken thompson
82:07 - and dennis ritchie on their original uh
82:09 - pdp 11 in 1971 filled up their first
82:14 - disc
82:15 - their their root disc was a half
82:17 - megabyte very fast disc and then they
82:20 - had what was called an rk05 disc pack
82:22 - which was two and a half megabytes of
82:23 - external space basically like a usb disk
82:26 - today
82:27 - um slower but much larger and when they
82:29 - filled up their their root partition
82:31 - they leaked it into the user directory
82:34 - where they had the user accounts and
82:35 - then when they got a second expansion
82:36 - disk they moved all the user accounts to
82:39 - the new disk and they called that one
82:40 - home and they left the user directory to
82:44 - be eaten by the operating system
82:46 - and then people retconned all sorts of
82:49 - rationales for this but
82:52 - no that's why it happened and these days
82:54 - when i'm making a system you'll notice i
82:56 - just sim link user bin to bin user s bin
83:00 - to s bin and user lib to lib so
83:04 - you know
83:05 - there's
83:06 - there's there's a bin an s-bin and a lib
83:09 - at the top directory that i just sim
83:11 - link to the second copy of them
83:12 - collapsing together because i don't care
83:14 - it doesn't matter
83:15 - you know but i researched why they did
83:18 - this in the first place and dennis
83:20 - ritchie wrote it up as a historical
83:22 - anecdote and i went oh that's why they
83:24 - did it now i know that we don't need to
83:26 - do it anymore
83:29 - a lot of this researching why we do
83:30 - things in the first place if you drill
83:32 - down into it a lot of times you can
83:34 - figure out it's okay to do it
83:36 - differently and it's okay not to do it
83:38 - at all once you understand why it was
83:42 - there
83:43 - so that's an example of that
83:45 - and then the var directory was
83:48 - um it was a place to put things that
83:51 - should persist across reboots but should
83:53 - be writable because etc could be in a
83:56 - read-only directory you know so config
83:58 - files versus dynamic config files so
84:00 - those are basically the the directories
84:02 - it expects to be there and you can just
84:04 - copy this snippet right out of my thing
84:06 - or just run this file
84:09 - then i create an init program
84:13 - now you'll notice i said
84:15 - you know init is pid one
84:17 - it is the program you run when the
84:19 - system first comes up
84:22 - and
84:24 - i actually wrote up a little
84:31 - things i probably won't have time to
84:32 - cover but should okay
84:35 - so
84:37 - um a knit is
84:40 - weird and i wrote down why and yeah
84:43 - these are a bunch of different examples
84:45 - of types of init you may encounter using
84:47 - bin sh's in it you've seen me do that um
84:49 - your app the hello world was an example
84:51 - of that but a lot of internet of things
84:53 - thing will just run you know they're in
84:55 - it as pid 1.
84:56 - um
84:58 - here is a shell script running as a knit
85:00 - and then at the end it execs another
85:02 - program
85:03 - um i wrote one called one it there's
85:05 - system five init which was the
85:07 - conventional one everybody was using 10
85:09 - years ago then android uses its own init
85:12 - program these days there's a horrible
85:14 - one called systemd
85:16 - um
85:17 - and then there's others like upstart and
85:19 - open rc when people were trying to move
85:21 - beyond the the main problem with system
85:24 - five in it is it predated the widespread
85:25 - use of smp so it brought the system up
85:27 - in a single threaded manner
85:29 - and people wanted to paralyze
85:31 - parallelize the init to bring it up to
85:34 - bring the system up faster and they
85:37 - couldn't quite agree on that because you
85:39 - know well this has to come up after the
85:41 - network interface comes up so suddenly
85:42 - we have a dependency resolver
85:45 - where everything has to know what else
85:46 - it depends on and
85:49 - people wrote up a lot of different
85:50 - things and red hat basically shouted
85:52 - everybody down by having more money
85:55 - okay so
85:58 - pid one the first process that linux
86:02 - launches is special
86:04 - and what's special about it
86:07 - is to start with
86:09 - uh it has no parent it is launched
86:11 - directly by the kernel
86:14 - if it ever exits the kernel will panic
86:16 - you saw that colonel panic earlier of
86:19 - you know we couldn't find init because
86:20 - it was where we couldn't run in it
86:22 - because it was dynamically linked so we
86:23 - got a panic message and then qamu exited
86:25 - and otherwise would have rebooted the
86:26 - system
86:27 - um because init should never exit
86:31 - um init has
86:33 - most signals blocked
86:36 - specifically the way they implement that
86:39 - not exactly but you can think of it as
86:41 - sig default is sig ignore for init
86:45 - where if you get a signal the default
86:48 - handler for it will ignore it rather
86:49 - than killing the program
86:51 - [Music]
86:53 - and
86:54 - if a program's parent process dies
86:58 - so that you have an orphaned child that
87:00 - when it exit it wants to send sig child
87:03 - to somebody to notify it of its exit
87:05 - code but its parent has gone away it
87:07 - will be re-parented to init
87:10 - and it is the reaper of orphan children
87:14 - okay so
87:16 - and it does a lot of things um
87:18 - if you run init equal slash bin slash sh
87:22 - your system will accumulate zombies if
87:24 - your shell does not know to listen for
87:26 - sig child
87:28 - which most of them don't there is
87:30 - actually a workaround if you set
87:33 - sig child to sig ignore
87:36 - in the signal handler tell it you know
87:38 - instead of having a signal or handler
87:39 - just set it to sig ignore
87:41 - sig child will be delivered and the fact
87:42 - that it was ignored is fine and then the
87:44 - child can exit
87:46 - so
87:47 - when you are running
87:49 - an init program if you're not going to
87:51 - handle sig child
87:53 - set the signal handler to sig ignore
87:56 - and you have you have to actually do
87:57 - that explicitly because the default one
88:00 - being like sig ignore isn't good enough
88:02 - in that case
88:03 - um
88:06 - so yeah
88:08 - and another thing is for example um init
88:10 - can't reboot the system because the
88:12 - reboot system call exits your process so
88:15 - the kernel will panic before rebooting
88:19 - so you have to fork a child have it call
88:22 - reboot and then you hang
88:24 - and wait
88:26 - yes i've i i mentioned that i wrote one
88:29 - it one it is a tiny little init program
88:31 - it's in toy box uh you can find it on
88:33 - the busy box mailing list way back when
88:35 - but they didn't merge it where
88:37 - it does just the basic setup another
88:40 - thing about init is that it inherits
88:42 - file handle zero file handle one file
88:44 - handle two pointing to dev console it
88:47 - starts with a standard in standard out
88:48 - in standard error pointing to whichever
88:50 - dev console you had on init ram fs
88:54 - if you didn't have it in it mfs or if
88:57 - you created an init ramifest but didn't
88:59 - add a dev console to it which you'll
89:01 - notice we haven't in any of the ones
89:02 - we've done so far
89:04 - those opens will fail and your standard
89:06 - in standard out and standard error in it
89:08 - will be closed
89:10 - meaning
89:12 - anything you write will be ignored
89:14 - and if you try to do that as a shell
89:17 - prompt you know if you try to then exec
89:19 - bin sh
89:22 - it will exit immediately because
89:24 - it has no input to read from and no
89:26 - output to write to and it basically gets
89:27 - a sig pipe and goes nope
89:29 - um
89:30 - so what this init script does
89:32 - this init script you know we start with
89:35 - pound sign exclamation point ben sh
89:38 - we then
89:39 - set a home directory and set a path
89:42 - because we didn't necessarily inherit
89:44 - one our environment is mostly blank
89:47 - so if we want you know some basic
89:49 - environment variables that you just sort
89:50 - of expect to be there we have to set
89:51 - them ourselves
89:52 - um
89:54 - we mount proc on proc we mount sysfs on
89:56 - sys the reason that it's doing this is i
89:59 - sometimes use this subnet script to
90:01 - change root into a directory and when
90:03 - you change root into a directory the
90:06 - system may already have some stuff there
90:08 - um
90:09 - so that's why i'm checking if they're
90:10 - already mounted
90:12 - uh is just for change root it won't be
90:13 - in your systems
90:15 - i then mount dev temp fs dev temp fs is
90:18 - a file system that was added a few years
90:20 - ago that automatically populates the dev
90:23 - directory with all the devices that are
90:26 - there so you don't need something like
90:28 - udev or system systemd to do it you
90:31 - don't need a demon listening for hot
90:33 - plug events and creating device nodes
90:35 - the colonel can do it for you and it
90:37 - took several years to browbeat greg
90:40 - crowe hartman and and company into going
90:42 - you know the kernel can really do this
90:44 - for you but what names will we use okay
90:46 - you notice how under
90:49 - sis fs
90:51 - cis class like you know mem
90:55 - there are names
90:57 - why don't you use these names
91:01 - eventually they went all right we'll use
91:03 - those names they are unique and it's
91:05 - like yeah so
91:07 - you know
91:08 - you you get a set of devices
91:11 - from uh dev temp fs
91:14 - and then pts is the pseudo terminals if
91:18 - you use the new pty format that auto you
91:21 - know that automatically allocates them
91:23 - rather than the static link from ones
91:24 - from way back when that requires a file
91:26 - system
91:27 - to you know every time you create one it
91:29 - shows up in this directory
91:31 - so that's where it expects it
91:34 - um
91:35 - so yeah that that does amount of dev pts
91:38 - amount of dev temp fs amount of cis fs
91:40 - an amount of proc
91:41 - it then does an if config of e0 and a
91:44 - route add default gateway for qemu
91:48 - if you are using qemu's emulated network
91:52 - this is the address
91:54 - that if you ran dhcp this is the address
91:57 - it would give you and this is the
91:58 - gateway that will talk to the outside
91:59 - world through its
92:01 - basically faked ip masquerading that it
92:03 - does
92:04 - um
92:06 - and then i attempt to set the
92:10 - the
92:11 - date in case i am emulating a system
92:14 - that doesn't have a persistent clock
92:17 - because you know some arm or sh boards
92:19 - or stuff like that it's like this system
92:21 - doesn't have a clock so the kernel
92:22 - doesn't know what to set the clock to so
92:24 - i can do it once i brought up the
92:26 - virtual network i can do a transaction
92:27 - with a host that says hey what time is
92:29 - it
92:30 - and get that set up
92:32 - i then figure out when i you know the
92:34 - kernel command line is available
92:40 - i think this is actually the uh
92:45 - yeah this is the kernel i just built so
92:47 - this is the emulated system actually
92:48 - that is still running under qemu but and
92:50 - proc command line this is the command
92:52 - line that i fed in you may remember that
92:54 - from the qemu command line
92:56 - so
92:58 - in procfs i can see what my command line
93:00 - is and what i did here
93:02 - was
93:03 - i
93:04 - ran said against proc cmdline to see if
93:07 - there's a command line argument if so i
93:10 - figure out what device it is
93:12 - and the reason i do that is
93:14 - remember that standard in standard out
93:16 - in standard error that init inherited go
93:18 - to slash dev console well dev console is
93:22 - a device
93:23 - that is an alias for whatever
93:25 - actual console device you're using to
93:27 - talk to the outside world but it does
93:30 - not provide a controlling tty
93:32 - so if i hit ctrl c
93:35 - it doesn't send a signal to my program
93:38 - and
93:39 - if i accidentally if i run like ping
93:42 - that just endlessly pings stuff
93:44 - and doesn't exit and i'm going ctrl c
93:46 - ctrl c ctrl c and it's ignoring me and
93:48 - i'm going right i have to reboot my
93:49 - emulator because i screwed up
93:51 - you know well what one it does is it
93:54 - closes the standard in standard out and
93:56 - standard error that it inherited and
93:58 - opens the ones from the actual console
94:01 - device the serial device that does
94:03 - provide a controlling tty so that if i'm
94:06 - connected to that one and i hit control
94:08 - c it sends the program a signal
94:12 - okay so that's why i'm doing that thing
94:14 - with the console you don't necessarily
94:15 - have to do that in your thing if you
94:17 - don't expect to have a command line
94:19 - running as pid 1
94:21 - you know your init will also do
94:24 - the proper setup to that thing if you
94:25 - run sys5 in it or something like that
94:28 - but i'm doing that here because
94:29 - trying to be simple
94:31 - um and then i figure out you know okay
94:34 - what program do i run next by default i
94:36 - just run bin sh but i can set the
94:38 - environment variable handoff in all caps
94:43 - one fun little thing about
94:48 - one fun little thing about this is
94:54 - let's see
95:07 - any unrecognized keyword equals value
95:10 - argument on the kernel command line
95:12 - it will set as an environment variable
95:15 - so i can set any environment variable i
95:17 - want to tell my init script to do stuff
95:20 - on the qemu command line
95:23 - so that's you know just a fun little
95:25 - thing now notice i had to put that
95:27 - before
95:30 - the rdnit line because
95:33 - init equals or rd init equals it will
95:35 - think that it's an argument to sh
95:38 - okay one once you get to that point
95:40 - everything else becomes an argument to
95:42 - sh so it would have to it does have a
95:44 - positioning dependency
95:47 - all right so getting back to this script
95:51 - so i create my init script and here is
95:53 - the eof of the here document if you know
95:56 - shell programming i just wrote this out
95:58 - as a here document so that the contents
95:59 - of the script could be in the uh in the
96:02 - script and then i change mod plus exit
96:05 - because if it can't execute the init it
96:07 - won't run and you can't run a shell
96:09 - script unless it has the executable bit
96:10 - set
96:11 - i then write out an etc password file to
96:14 - say these are the two users that are on
96:16 - the system
96:17 - and this is in the format that etc
96:18 - password has been in forever and i write
96:20 - out an etc group file
96:22 - i did not write out
96:24 - shadow
96:25 - files so there's no
96:28 - passwords associated with this i can't
96:30 - log in as any of these users but s u if
96:32 - you're switching user from root doesn't
96:34 - care
96:36 - and
96:36 - you know i could have set up a shadow
96:38 - thing but then what passwords would i
96:40 - assign to them it's like i just didn't
96:42 - bother but this lets me this lets them
96:44 - know uid 0 is root you know which uid 0
96:48 - is always root but this lets it know
96:50 - that the name root goes with that and if
96:52 - i log in as root
96:54 - my default shell should be bin sh and my
96:57 - home directory should be here
96:59 - and then i created a guest account to be
97:01 - uid 500
97:03 - and i told it you know here's your home
97:05 - directory here's the shell to run that's
97:07 - just what the etc password format is
97:09 - there's a i think there's a man page on
97:10 - it
97:11 - um
97:13 - and then i wrote name server 8.8.8.8
97:16 - into
97:17 - etcresolve.conf
97:19 - the file slash etc slash resolve dot
97:22 - conf is the file that the c library
97:24 - reads every time you attempt to do a dns
97:27 - lookup it goes where are my name servers
97:30 - 8.8.8.8
97:32 - is the ip of the google dns pool
97:36 - so
97:37 - i don't actually have to even put in a
97:39 - second one you're supposed to have
97:40 - fallback servers but like that's a pool
97:41 - of 30-something machines around the
97:43 - world that it does the automatic magic
97:46 - routing to the closest one to the
97:48 - through the weird backbone stuff
97:50 - um
97:52 - and that basically means that should all
97:54 - if i can get out to the net that's the
97:56 - dns server that should be up barring
97:58 - nuclear war
97:59 - and even then maybe um
98:04 - so then you know i
98:05 - so those were actually
98:07 - the
98:08 - directories i created and the
98:12 - uh the configuration files i added to
98:14 - give me a basic system where playing
98:18 - around on a shell prompt if i do ls-l it
98:20 - should give me like usernames for the
98:22 - files at least the ones belonging to
98:24 - root and group sort of thing
98:27 - then i build and install toybox which
98:30 - you know it it's only this and the only
98:33 - reason it's it's weird is you know i i
98:35 - did a make you know setup four is the
98:37 - thing that's basic guitar extract to the
98:39 - tarball make def config just like busy
98:41 - box
98:42 - um i then changed one of the symbols
98:45 - because the muscle libsy maintainer and
98:47 - i have this long-standing disagreement
98:49 - about how no mmu should be configured if
98:52 - you're not using a nom immune system
98:53 - this does not apply to you at all and
98:55 - i've actually updated that but i haven't
98:56 - pushed it to the repository yet so it
98:58 - only does it for no immune systems um
99:03 - if you care about no mmu's stay after we
99:05 - don't have time but i've done a lot with
99:07 - them
99:09 - i mentioned that elf is essentially an
99:12 - archive format for binary data well
99:14 - there's a slightly upgraded version
99:16 - called fdpic
99:18 - that annotates it with slightly more
99:20 - data
99:21 - and the reason for this is
99:24 - no mmu systems
99:26 - can't
99:28 - have two processes using the same
99:31 - address space to see different things
99:33 - because it doesn't have a memory
99:34 - management unit it can't remap them it
99:36 - can sometimes have you know low water
99:39 - marks and high water marks where if you
99:40 - access memory outside of this window
99:42 - you'll get a seg fault
99:44 - but if you can access that address you
99:46 - see the same thing for every process
99:49 - meaning if your elf thing wants to be
99:51 - loaded at address hex 1000 and you have
99:55 - two instances of it running
99:57 - you can't
99:58 - because the second instance would need
100:00 - to load at the same address as the first
100:02 - instance and they would get sad
100:05 - um
100:06 - and
100:07 - the way most elf programs are linked
100:10 - the you know there's like four
100:11 - interesting segments there's the code
100:13 - segment the data segment the uh bss and
100:18 - the other one
100:19 - um
100:21 - i'll think about it as soon as i stop
100:22 - trying um
100:24 - but
100:26 - the the problem is they're all put right
100:28 - after each other in memory
100:30 - and the addresses of them you know this
100:33 - piece of machine code will go where i am
100:36 - you know or the start of this you know
100:37 - the start of the program plus this many
100:39 - bytes
100:40 - for the data or for
100:42 - bss is the
100:45 - um
100:47 - ah ro data is the other one
100:49 - uh there's one code segment and three
100:51 - data segments basically one of the data
100:53 - segments is for data that you can uh
100:55 - that starts initialized to a value but
100:57 - you can then modify it afterwards it's
100:59 - basically your global variables that are
101:00 - initialized to a value bss is for your
101:03 - global variables that are initialized to
101:04 - zero so their contents don't actually
101:06 - have to be stored in the elf thing it
101:08 - basically maps a segment of memory there
101:10 - that isn't backed by the file and then
101:12 - goes you know have at and then the ro
101:14 - data is the stuff that's initialized to
101:15 - a value but then if you try to write to
101:17 - it you will get a seg fault because it
101:19 - is not writable you know and they're
101:21 - basically all glued together in elf as
101:23 - one big contiguous chunk of memory
101:26 - what fdpic does is it says these are now
101:29 - four con four distinct chunks of memory
101:32 - load them wherever you can fit
101:34 - and that means you can share the code
101:36 - segment with
101:38 - other programs
101:40 - that think they've you know loaded this
101:42 - and it they also it's a pick position
101:44 - independent code normally we only link
101:46 - libraries that way where we say we have
101:49 - saved in a register or saved in some
101:51 - global thing that you know either ties
101:53 - up a register or causes an extra
101:55 - indirect you know load to slow your
101:58 - assembly down
101:59 - but that means that
102:01 - wherever it can be loaded at different
102:03 - starting addresses
102:05 - and that means if you have shared
102:06 - libraries well
102:08 - each shared library doesn't magically
102:10 - know what all the other shared libraries
102:11 - you have running are so they can't at
102:13 - compile time pick a unique memory
102:16 - location to be so they have to be
102:17 - relocatable because they could be used
102:19 - in combination with who knows what other
102:21 - libraries
102:22 - well what they did is
102:23 - pi position independent executables are
102:28 - executables built as pick so that they
102:30 - can be relocated the security guys love
102:32 - this because that way if you try to
102:34 - exploit it using an absolute address and
102:36 - it's loaded at a random location each
102:38 - time you load it's harder to exploit
102:40 - well the no mmu guys love this because
102:42 - it's like i can have three instances of
102:44 - this loaded at different locations and
102:46 - they don't you know it's not going to
102:49 - conflict with other programs that think
102:51 - they're using the same thing but what
102:54 - fdpik lets you do is it lets you say
102:56 - okay
102:58 - the read-only section can be shared with
103:00 - other instances of the program the code
103:02 - section can be shared with other
103:03 - instances of the program the data
103:05 - section and bss you need your own
103:08 - instances of because you're going to
103:09 - write to that data so these two are
103:12 - shared wherever they can fit these two
103:15 - are unique wherever they can fit however
103:18 - if your memory is fragmented you can't
103:20 - use the mmu to collate it but you can
103:22 - fit it into smaller chunks because we've
103:24 - broken the program into four different
103:25 - pieces that can load wherever you can
103:27 - fit them fdpic is much much nicer for no
103:29 - immune systems
103:31 - but it means you need a different kind
103:33 - of
103:35 - program loader
103:37 - you know so it when you build the
103:39 - program you need to
103:40 - produce a different output format so
103:43 - again
103:44 - went off on a tangent
103:46 - um but anyway that
103:48 - me arguing with the muscle libsy
103:50 - maintainer uh
103:54 - yeah so anyway it it does a build
103:57 - statically linking and then it doesn't
103:59 - install and then cleanup is that rm-rf
104:02 - thing and then this is a busy box
104:04 - install where i did something called
104:06 - mini config
104:08 - and the
104:09 - the last little bit i'm going to get to
104:10 - and i think i'm going over time probably
104:13 - but the last little bit i'm going to get
104:14 - to is
104:16 - configuring you know
104:17 - drilling down into the kernel config
104:20 - this is the same format as the kernel
104:21 - config what i did is instead of a def
104:23 - config busy box i told it these are the
104:26 - symbols i want
104:28 - only these symbols start with all no
104:31 - config and there's there's a bunch of
104:33 - them
104:34 - you know but you know this is less than
104:37 - 100 symbols
104:39 - and busybox has hundreds and hundreds of
104:42 - symbols
104:44 - a full config file for busybox which i
104:46 - just built
104:56 - is 1097
104:58 - lines
104:59 - this
105:00 - is it ends on line 261 and it started on
105:05 - line
105:07 - uh
105:09 - 191
105:10 - so
105:12 - 150 symbols
105:13 - instead of a thousand and stuff and
105:15 - that's for selecting you know rather a
105:17 - lot of stuff
105:18 - and
105:19 - what this is this is a format called
105:21 - mini config
105:25 - which i did write up documentation on
105:26 - once here
105:35 - i
105:37 - tried to send this upstream to the
105:38 - kernel of documentation on how to do it
105:40 - you'll notice this was 2005.
105:44 - i resubmitted it again a year later to
105:46 - see if they change their minds like no
105:47 - bunch of people are using this doc
105:49 - documentation on it is not submitted
105:50 - upstream of the kernel if you ever think
105:52 - about linux kernel stuff oh well any
105:55 - interesting idea immediately gets
105:57 - implemented and done by the vast hordes
106:00 - of kernel developers
106:01 - i will point you at the fact that the
106:03 - squash fs developer
106:11 - the squash fest developer spent
106:14 - something like seven years
106:17 - attempting to merge squash fs into the
106:19 - kernel
106:20 - he took a year off to full time push it
106:24 - upstream into the kernel
106:26 - after it was already in red hat susie
106:30 - debbie and gentoo and like everything
106:32 - else it had been merged everywhere and
106:34 - the kernel developers wouldn't take it i
106:36 - spent something like seven years getting
106:39 - pearl removed from the kernel
106:42 - build environment
106:43 - from
106:44 - the first oh wouldn't it be a good idea
106:47 - to use temp fs for init ram fs from me
106:50 - first mentioning on the mailing list of
106:52 - you know is anybody working on this to
106:54 - me actually sitting down and doing it
106:56 - was something like nine years
106:58 - okay so
106:59 - yeah the the the normal state of things
107:02 - is for somebody to do it off in a corner
107:04 - and then it's abandoned and it never
107:06 - goes upstream into the kernel if you
107:07 - know brow beating all these developers
107:09 - for you know oh you implemented stuff
107:11 - for your company and you've been using
107:12 - it in-house for years but it isn't
107:13 - upstream in the car that's actually
107:14 - fairly normal
107:16 - uh it's sad but it's normal
107:19 - so
107:20 - before that tangent i was attempting to
107:22 - explain
107:25 - oh what was i attempting to explain i
107:26 - closed the window
107:28 - i don't need oh i was attempting to
107:29 - explain mini config where i did
107:39 - i actually did documentation
107:42 - describing you know all sorts of stuff
107:44 - about mini config but i will walk you
107:45 - through it right now
107:46 - basically what you do
107:48 - is you have keyword equals value config
107:51 - symbols like this
107:53 - in the same format they appear in the
107:54 - config file but the question you ask
107:57 - yourself is if i start with make all no
108:00 - config in the linux kernel in busybox
108:02 - and anything that's using menu config
108:04 - and i go
108:06 - okay i've switched everything off
108:08 - now i want to pull up that menu config
108:10 - tool and i have a checklist written down
108:13 - of look for this symbol and switch it on
108:16 - and every time i do so there's a
108:17 - dependency resolver that may switch on
108:19 - other symbols for me or change their
108:20 - values or whatever well that runs every
108:23 - time i poke a symbol in menu config
108:25 - switch it on or switch it off it may
108:27 - have fallout with other symbols in the
108:30 - curl but i don't really care all i care
108:31 - about is i started with all no config
108:33 - and then i went down my checklist
108:35 - switching on these symbols and then i
108:36 - saved the result and i built it i know
108:39 - how to do that by hand can i automate
108:41 - this process and yes you can that's
108:43 - exactly what miniconfig does and
108:46 - the magic line here is make all no
108:48 - config k config underscore all config
108:51 - equals the name of the file containing
108:53 - all these symbols
108:54 - it's a horrible name
108:58 - a large part of what that patch i had
109:00 - from many years ago was having a make
109:03 - mini config target that among other
109:06 - things would tell you if you tried to
109:07 - set a symbol that didn't exist instead
109:08 - of silently ignoring it it would go oops
109:11 - error you screwed up
109:13 - you know that kind of thing um
109:16 - and
109:17 - there was bike shedding from a guy named
109:19 - roman zippel and even though he's not
109:20 - there anymore it's
109:22 - i
109:24 - tangent tangent so this is a fairly
109:26 - useful technique
109:28 - for configuring busybox a lot more
109:31 - you know concisely and it used ldl oh
109:36 - it said it as an environment variable
109:37 - not on the command line
109:40 - make is terrible um
109:44 - i'm sorry it people give python guff
109:47 - about the significant white space and
109:49 - totally ignore the fact that make
109:50 - requires tabs not spaces
109:53 - in a lot of places like no it it
109:56 - combines imperative and declarative code
109:59 - in the same context where you have to
110:02 - care what order things happen in but
110:04 - have no control over it
110:05 - it's like
110:08 - no
110:09 - tangent there's a whole rant on there
110:12 - um yeah configure make and make install
110:15 - all kind of need to be replaced it's
110:16 - just nobody can really agree on what i
110:19 - already went into the whole autoconfiz
110:22 - you
110:22 - know totally does not work with cross
110:25 - compiling and half the things it's
110:27 - checking for specified by posix anyway
110:29 - and if your build environment isn't
110:30 - posix fix your build environment
110:32 - um
110:33 - and make install of course has no idea
110:35 - what a package manager is
110:37 - so
110:38 - things
110:40 - anyway but meanwhile we do configure
110:43 - make and make install
110:45 - and config prefix just tells it where to
110:46 - install
110:48 - and i'm installing the unstripped
110:50 - version in case i want to
110:52 - you know run
110:55 - gdb against or something
110:57 - and then this was my attempt to copy the
111:00 - dynamic libraries out of the cross
111:02 - compiler onto the system to give the
111:04 - option of dynamically linking and just
111:06 - ignore this entire section because it
111:08 - doesn't work you can actually see that
111:10 - it's my second attempt and
111:12 - the problem is i can get it easily to
111:14 - work with any one cross compiler getting
111:16 - it to work with all cross compilers
111:18 - which may be using different c libraries
111:21 - there's a lot of testing there it's on
111:22 - my to-do list so just
111:24 - ignore the thing about trying to make
111:26 - that work
111:27 - and then
111:28 - if i want to build additional packages
111:31 - you know i have a second example here
111:33 - that you know what if i want to cross
111:34 - compile more stuff well here's cross
111:36 - compiling you know zlib and dropbear and
111:39 - installing those into the system here's
111:42 - just examples of using the same
111:43 - infrastructure to do that with different
111:45 - packages in case you want to cross
111:46 - compile more stuff
111:49 - and then at the very end you may have
111:50 - noticed i kept pulling up this file to
111:52 - look at the end where it's like and
111:54 - here's the invocation to turn that into
111:56 - a cpio.gz file you know so that is what
111:59 - this build script does
112:01 - and if you feed it one of the muscle
112:03 - cross make uh
112:05 - tool chains which
112:07 - i've been talking to rich felker he and
112:09 - i actually worked together um
112:12 - to try to get him to do binary releases
112:14 - so i could just point you at a url of
112:16 - download the binary of the pre-built
112:18 - tool chain extract it add it to your
112:20 - path and then follow along building the
112:23 - thing and it's not up yet because he's
112:25 - been really really busy and i'm not
112:27 - hosting it anywhere because it's gpl v3
112:29 - and i don't want to get any of that on
112:30 - me
112:32 - um
112:34 - i launched the first gpl enforcement
112:36 - suits that actually wound up in court
112:38 - suing people back when i was busy box
112:41 - maintainer i know a whole lot more about
112:43 - gpl enforcement than any sane person
112:45 - would ever want to
112:47 - and after a year of empirically going
112:50 - through and proving that none of these
112:52 - companies that were shipping busybox
112:54 - binaries had any code we wanted not
112:56 - adding one line of code to the busybox
112:58 - repository after looking at a whole
113:00 - bunch of sourcetree dumps
113:02 - i basically went
113:05 - i
113:06 - i don't want to go there and i really
113:08 - don't but but it made me a lot more
113:11 - careful about license compliance stuff
113:13 - because you you can't
113:15 - you can't spend a whole lot of time
113:17 - dealing with legal stuff without being
113:19 - really careful to make sure you don't
113:21 - have to again
113:24 - okay so that is an example of building a
113:27 - simple root file system but building a
113:28 - simple kernel def config was terrible
113:31 - so let's walk through real quick because
113:34 - we're short on time
113:38 - let's walk through
113:42 - kernel
113:43 - building
113:44 - so i actually i showed you the start of
113:46 - this this file before
113:48 - um
113:50 - see i configure creates a config file um
113:53 - i haven't really had time to talk about
113:54 - device trees but
113:56 - when the kernel boots
113:58 - um
113:59 - the bootloader
114:00 - there's actually two bootloader stages
114:02 - on real hardware you have a bootloader
114:04 - stage one that does
114:07 - two minutes lovely okay um
114:10 - ask me afterwards the the real hardware
114:12 - does things that qmu doesn't have to um
114:16 - so
114:16 - cumulus are built in bootloader we've
114:18 - just been using that and explain it now
114:20 - so
114:22 - so we start with
114:23 - all no config and in order to do a
114:26 - standard x86 system these are in theory
114:29 - the three symbols you need what board am
114:31 - i using
114:32 - and where is my serial console
114:35 - so i set these three symbols
114:37 - i then do the make i then boot it and i
114:39 - get no output
114:41 - and the reason i get no output is that
114:43 - printf is switched off why is printf
114:46 - switched off because the symbol config
114:48 - embedded was broken by him by this
114:50 - commit which was really stupid special
114:53 - case nonsense that that says when all no
114:55 - config happens switch this symbol on
114:58 - which results in opening a menu so that
115:00 - a lot more symbols can be switched off
115:02 - and this this winds up switching off
115:04 - printf so what you actually do
115:08 - is you do a special commit
115:13 - oops
115:16 - um
115:17 - so you have a line
115:19 - that looks like this config embedded is
115:21 - not set which ordinarily and which is
115:24 - how you tell
115:25 - dot config a symbol is switched off yes
115:28 - pound sign means a comment but this
115:30 - special comment is functional
115:33 - so we add this line
115:38 - and then we get output but it says no
115:40 - file system could mount root so we have
115:42 - to tell it to enable the check for
115:44 - external and nrd which are these two
115:46 - symbols
115:48 - and then it says it couldn't execute bin
115:50 - sh
115:51 - so i have to basically
115:53 - switch on
115:54 - config bin format elf so it knows how to
115:57 - read an elf binary
115:59 - and then
116:01 - um
116:03 - then i get to the point where it reads
116:05 - hello world um in order to be able to do
116:07 - a shell script i have to switch on
116:09 - config bin format script
116:11 - and then i can run my init script except
116:14 - it can't mount dev temp it can't mount
116:17 - dev temp fs so i have to switch on two
116:19 - symbols in order to get the file system
116:21 - that gives me the dev directory
116:23 - and i i could
116:25 - i could go into more but basically this
116:27 - is the kind of thing that you know the
116:30 - the minimal set of symbols that i was
116:32 - using for each target back in four three
116:36 - uh let me github.com
116:42 - landley
116:44 - back when i was doing aboriginal linux
116:46 - the set of symbols that i used for uh
116:49 - each target
116:52 - was in the targets directory there were
116:54 - a bunch of things like here's the one
116:55 - for rmv5
116:58 - in order to boot a system i needed to
117:00 - know what arch equals value to tell the
117:03 - kernel when i built what path the
117:05 - resulting bootable file would would show
117:08 - up at
117:09 - that's for building gcc you don't have
117:10 - to care about that
117:12 - um what console value to feed it because
117:15 - which which console device am i using
117:18 - and then here is the all no can here's
117:21 - the symbols i added just for this
117:23 - architecture
117:24 - for this board and the set of devices on
117:26 - this board and here's the qemu
117:28 - invocation i would use to to load it and
117:31 - that
117:33 - set of symbols was actually added
117:36 - to base config linux which has more than
117:39 - you actually need but these were the
117:40 - common symbols that i would set on all
117:44 - the targets
117:45 - so you can actually read through and see
117:46 - what those symbols are you don't need a
117:48 - lot of these and if i if i had a little
117:50 - more time i'd go through the here's the
117:51 - list of the ones you need but
117:53 - unfortunately i am over time i can
117:55 - probably take one or two questions
117:59 - i cannot
118:00 - okay
118:02 - oh sorry somebody needs the room
118:04 - i'm sorry
118:05 - ask me afterwards
118:07 - [Applause]