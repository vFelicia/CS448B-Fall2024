00:00 - this complete c plus plus course will
00:03 - take you from being an absolute beginner
00:05 - to using advanced c plus plus features
00:08 - danielle gaguaya teaches this course he
00:10 - is an experienced software developer and
00:12 - has created many popular courses
00:15 - hello guys and welcome to this modern c
00:18 - plus plus 20 course this is a course
00:20 - that is going to take you from the
00:22 - absolute beginning where you know
00:24 - nothing about c plus plus and you're
00:26 - going to go all the way to a point where
00:28 - you can use some advanced features in
00:30 - the c plus plus programming language
00:33 - that includes things like
00:34 - object-oriented programming with
00:36 - inheritance and polymorphism with the c
00:38 - plus plus programming language now i'm
00:41 - not going to spend a lot of time
00:42 - convincing you on why you should use c
00:45 - plus plus but c plus plus is a very
00:47 - powerful programming language you can
00:49 - use to do all kinds of crazy things you
00:52 - can use it to do systems programming you
00:55 - can build games with it and it is used
00:57 - in a wide range of areas so you can do a
01:00 - lot with c plus plus now who is this
01:03 - course for this course is built for
01:05 - complete beginners if you already have
01:07 - some experience with c plus plus you
01:09 - will still find some good things you can
01:11 - learn from the course but i am going to
01:14 - go from the absolute beginning showing
01:16 - you every little thing showing you the
01:19 - tools showing you the compilers and the
01:21 - editor we're going to be using here so
01:23 - we're going to spend a lot of time
01:25 - making sure you understand the
01:26 - fundamentals by the time you are done
01:28 - with this course you will understand the
01:30 - bare fundamentals about c plus we will
01:33 - spend a lot of time exploring the
01:36 - procedure programming side of c plus
01:38 - plus so you're going to be writing
01:40 - programs that run from top to bottom and
01:42 - we're going to spend a lot of time in
01:44 - the editor writing code making sure you
01:46 - really understand what is going on here
01:48 - towards the end we're going to learn
01:49 - about object oriented programming and
01:51 - we're going to touch on classes
01:53 - inheritance and polymorphism and these
01:55 - are the tools you're going to be using a
01:57 - lot in your career as a c plus plus
02:00 - developer another great feature of this
02:02 - course is that we spend a lot of time
02:04 - making sure you understand the tools so
02:06 - if you don't know what a compiler is if
02:08 - you don't know what an ide is we're
02:10 - going to make sure you understand these
02:12 - things and we're going to spend a lot of
02:14 - time using these things and by the time
02:16 - you're done with the course you're going
02:17 - to be very comfortable using the tools
02:20 - the editor of choice for the course is
02:22 - going to be visual studio code so that's
02:25 - an editor that is going to allow us to
02:26 - type in the code and give us some things
02:29 - like a syntax highlighting but we're
02:31 - going to be connecting our editor to a
02:34 - background compiler which is going to
02:36 - make sure our code is transformed
02:39 - to run on our computer but don't worry
02:41 - about all that craziness right now we're
02:43 - going to go in detail about these things
02:46 - for now i just want you to have a bird's
02:48 - eye view on what you can expect from the
02:51 - course here now i hope you know what to
02:54 - expect from the course but i also expect
02:57 - you to be ready to take the course and
03:00 - the requirements are really not that bad
03:02 - the only requirement is that you have
03:04 - time set aside to really practice what
03:06 - you learn from the course here and you
03:08 - need to have a strong drive and
03:10 - willingness to learn now if you want to
03:12 - follow along i am going to share a link
03:14 - to the github repository for the code i
03:17 - use in the course so you can check that
03:19 - out and really follow along if you want
03:21 - if you want some support we have a
03:24 - discord server dedicated for our
03:26 - students so you can join and be part of
03:28 - the community if you have a question you
03:30 - can ask but another thing i would
03:32 - encourage you to do is to also help
03:35 - others so if you see somebody asking a
03:37 - question try to help them you're going
03:39 - to learn a lot that way okay now that
03:41 - you know a bit about the course let's
03:43 - talk about myself here my name is daniel
03:45 - cacoya i am a software engineer i have
03:48 - been writing code since 2011 or
03:50 - something
03:51 - and i am a professional c plus plus
03:53 - developer i do a lot of freelance work i
03:56 - work for a few companies i do all kinds
03:58 - of crazy things i also like to teach
04:00 - others so i have a few courses on udemy
04:03 - if you are interested in cute you can
04:05 - check these things out i also have a
04:07 - trending c plus plus course that you can
04:09 - check out but don't feel the need to go
04:12 - and check this ziplesque course out
04:14 - because a lot is covered in this youtube
04:17 - course here so that's really all about
04:19 - me okay now that you have an idea about
04:22 - the course we're going to head over in
04:24 - the next lecture and learn about the
04:26 - tools we're going to be using throughout
04:28 - the course here go ahead and finish up
04:30 - here and meet me there
04:32 - welcome to this new chapter where we're
04:34 - going to be exploring the c plus plus
04:37 - development tools you need to start
04:39 - writing your own c plus plus
04:41 - applications and you really need two
04:44 - kinds of tools the first one is going to
04:46 - be an editor or an ide through which
04:49 - you're going to be writing your c plus
04:51 - plus code we are going to be using
04:53 - visual studio code as an editor in this
04:56 - course because it is very easy to
04:58 - install it is cross-platform it is going
05:01 - to run well on windows mac and linux and
05:04 - it supports a host of tools that are
05:07 - going to make your job easier as a
05:08 - surplus plus developer but that's not to
05:11 - say you can't use your favorite ide if
05:14 - you can but visual studio code is going
05:16 - to be our main editor in this course so
05:18 - i would recommend installing it to be
05:20 - able to follow along with what we do
05:22 - here now after we have an ide or an
05:25 - editor in place we will need a compiler
05:28 - and the compiler is a piece of software
05:31 - that takes the code we write in the
05:33 - editor and compiles that into code that
05:37 - can directly run on the hardware or
05:40 - binary executable format so this is what
05:43 - we're going to be doing here we're going
05:45 - to be typing our code in an editor like
05:48 - visual studio code we're going to be
05:50 - kicking off a process to compile our
05:52 - program and this is going to turn our
05:54 - program into a format that can run it
05:56 - directly on the hardware so for example
05:59 - if you are on a windows machine you're
06:00 - going to generate a binary executable
06:03 - that can directly run on windows if you
06:05 - are on linux we will generate a binary
06:08 - that can run on linux and the same
06:10 - concepts can really extend on mac or any
06:13 - other kind of operating system you might
06:15 - be working on with the course here so we
06:18 - need two tools we need an ide or an
06:20 - editor and a compiler and the tools you
06:23 - install are going to be depending on the
06:26 - operating system you are using to watch
06:28 - the course if you are on windows you're
06:30 - going to install a set of tools that are
06:33 - specific to windows if you are on linux
06:36 - you're going to install a set of tools
06:38 - for linux if you are on a mac you're
06:40 - going to install a set of tools specific
06:44 - to the apple operating system for
06:46 - desktop now on windows in terms of ides
06:49 - or integrated development environment it
06:52 - is possible to use a host of ides for
06:55 - example you can use code lite it is an
06:58 - ide you can use you can use microsoft
07:00 - visual studio but in this course we're
07:03 - going to be using visual studio code
07:05 - because it is easy to install it has a
07:08 - set of features that are really good it
07:10 - is popular it has a great community
07:12 - around it i think you're going to have a
07:14 - great time as a beginner to start
07:17 - writing your c plus plus programs using
07:19 - visual studio code that's not to say
07:22 - that you can't use another ide you can
07:24 - if you want but i am going to be using
07:27 - visual studio code in this course here
07:29 - now on linux we are also going to be
07:31 - using visual studio code as our editor
07:34 - in the course but there are other ides
07:37 - you can use for example you can use cute
07:39 - creator if you want you can use
07:40 - codelight you can use a host of other
07:43 - ides on linux but again visual studio
07:45 - code is going to be our thing in the
07:47 - course here and i would recommend
07:49 - installing it on your linux box if you
07:52 - are watching this course on the linux
07:54 - machine so for osx we are also going to
07:57 - be using visual studio code as our
07:59 - editor as i said it is cross platforms
08:02 - it runs where regardless of the
08:04 - operating system you might be using to
08:06 - watch the course but if you want you can
08:08 - use the apple
08:09 - ide which is xcode or even code lite all
08:12 - these are going to work if you want but
08:14 - again i would recommend going with
08:16 - visual studio code.plus to start out so
08:19 - that we have a common ground and you
08:22 - don't get confused very easily
08:24 - especially if you are a beginner now
08:26 - after we have an ide rolling we will
08:28 - need a compiler
08:30 - and as we say the compiler is a tool
08:32 - that is going to transform your c plus
08:35 - plus code into a format that can run
08:38 - directly on the hardware so the compiler
08:40 - you use again is going to depend on the
08:42 - operating system where you are watching
08:44 - the course i am going to show you a
08:46 - bunch of compilers you can use but gcc
08:49 - is going to be our common base so on
08:52 - windows i will be using what we call
08:54 - mingw don't worry if you don't what it
08:56 - is i am going to show you in a minute
08:58 - when we install it but this is a project
09:01 - that brings the gcc compiler on windows
09:03 - so that we can use it easily and i am
09:06 - going to show you how to install it but
09:08 - i am also going to show you how to
09:09 - install the compiler from microsoft and
09:12 - the clang llvm compiler these are all
09:15 - available to you on windows and it is
09:17 - really easy to install them these days
09:20 - and i will be using them all if you are
09:22 - on windows i would recommend installing
09:24 - them all so that you really have a
09:27 - chance to try your c plus plus code on
09:30 - the different compilers and that's a
09:31 - really good thing to do if you test your
09:34 - c plus plus code against multiple
09:36 - compilers you will be increasing your
09:38 - chances for your code to really be
09:41 - portable and work on multiple compilers
09:43 - and operating systems and that cannot be
09:46 - a bad thing so i would recommend
09:48 - installing all these compilers if you
09:50 - are on windows i am also going to show
09:52 - you how to install two compilers on
09:54 - linux i am going to show you gcc we're
09:56 - going to install the shiny new feature
09:58 - in gcc we're going to install clang lvm
10:01 - on linux and we will be able to use all
10:03 - these compilers again if you are on
10:05 - linux i would recommend installing all
10:07 - these compilers so that you have a
10:10 - chance to try your code against multiple
10:12 - compilers and that's going to make your
10:14 - code much portable and easier to use on
10:18 - multiple compilers and platforms on the
10:21 - mac i am going to show you how to
10:22 - install gcc
10:25 - and i am going to show you how to
10:27 - install clangle lvm but if you want you
10:29 - can also install xcode and the compiler
10:32 - that comes with that for c plus but
10:34 - development all these are options to you
10:37 - but again in this course we are mostly
10:38 - going to be using the gcc compiler so i
10:41 - would recommend getting a hold of this
10:43 - if you don't want to install other
10:45 - compilers if you only have to install
10:47 - one compiler please install gcc that's
10:50 - going to be our main compiler in the
10:52 - course here okay so these are the tools
10:54 - we need we are going to head over in the
10:56 - next lecture and show you how to install
10:58 - the visual studio code editor on windows
11:01 - and really get started with that
11:03 - go ahead and finish up here and meet me
11:05 - in the next lecture this video i am
11:07 - going to show you how to install a c
11:09 - plus plus compiler on your windows
11:12 - operating system so we're going to be
11:14 - looking at three kinds of compilers
11:16 - we're going to look at the mingw
11:18 - compiler which gives us access to a gcc
11:21 - like compiler on windows we're going to
11:23 - look at clan llvm which is another
11:26 - compiler we're going to look at the
11:27 - compiler from microsoft
11:30 - now before we talk about any compiler i
11:32 - would like you to come to google or your
11:34 - favorite search engine and say
11:37 - c plus plus compiler support okay so
11:39 - we're going to choose this little guy
11:41 - here and this is really going to give us
11:43 - a berg's eye view
11:46 - on which feature is supported by which c
11:48 - plus plus compiler for example if we are
11:51 - interested in c plus plus 20 which is
11:54 - the lattice standard that we have in
11:56 - simplest plus at the time of recording
11:58 - this video i am recording of this in
12:00 - august
12:01 - 2021 but if we go here we're going to
12:04 - see c plus plus 20 core features and
12:07 - we're going to see that we have a list
12:09 - of what each compiler supports we have
12:12 - gcc we have clan we have msvc we have
12:15 - the clan version from the apple company
12:18 - and if we scroll down we can really see
12:20 - the features that are supported by each
12:22 - compiler again gcc is going to be our
12:26 - choice in this course this is going to
12:27 - be our main compiler but nothing really
12:30 - stops you from using the clan compiler
12:32 - or the msvc compiler and if you happen
12:34 - to see that your compiler of choice
12:36 - doesn't support what you need for
12:38 - example you can see that at the current
12:40 - time lambdas in an evaluated context are
12:44 - not supported in clan
12:46 - you can see that it is ready here but
12:49 - this is a feature you can use both in
12:51 - gcc and the msvc compiler from microsoft
12:55 - so keep an eye out on this page here to
12:59 - know which kind of things you can use in
13:01 - your compiler if you try something out
13:03 - and you see that it doesn't work this is
13:05 - a good place to come and figure out if
13:07 - your compiler supports the feature that
13:10 - you are using in this video i am going
13:12 - to show you how to install the three
13:14 - most common compilers and those are gcc
13:16 - clang msvc if you want you can come in
13:19 - your search engine and type gcc to see
13:22 - what this is it is a good thing to do to
13:24 - learn about your tools here you can see
13:27 - that it is a compiler that is mostly
13:28 - used on the lenox platform but we can
13:31 - also use it on windows the latest
13:33 - release that we're going to be
13:34 - installing is eleven two zero i think it
13:37 - was released
13:39 - six days ago so it is really fresh and
13:41 - we're going to be taking advantage of
13:43 - this another thing i should say here is
13:45 - that you should install the latest tools
13:47 - you can get your hands upon this is the
13:50 - version we're going to be mostly using
13:52 - in this course but if you are watching
13:54 - this in the future you're going to have
13:55 - a newer version i would recommend
13:57 - installing the latest version or the
14:00 - newest version you can get your hands
14:02 - upon so the first we're going to do is
14:04 - install a gcc compiler on windows i am
14:07 - going to show you a way we can get both
14:10 - gcc and clang in one go and to get
14:13 - access to that please go in your search
14:15 - engine and type windlabs and this is
14:17 - going to bring us to this project here
14:19 - if you want you can click upon this
14:22 - and this is a cool project by a guy who
14:25 - is providing worlds for these compilers
14:28 - that we can use on windows
14:30 - so if you want you can just go down here
14:32 - and look at the lettuce releases again i
14:35 - recommend using the
14:37 - lettuce you can get your hands upon in
14:39 - this case the lettuce happens to be 1120
14:43 - but in the future this is going to
14:45 - change you're going to find a version
14:46 - for 12 or 13 so please grab the newest
14:50 - version you can get your hands up on now
14:52 - i want you to install the version that
14:54 - says that it has llvm and clang so if
14:58 - you are on a 32-bit version on windows i
15:01 - would recommend getting this 7-zip
15:03 - archive on this zip archive here if you
15:06 - are on 64 i would recommend getting a
15:08 - hold of this or this little thing here
15:11 - it doesn't really matter but make sure
15:13 - you get the latest version you can get
15:15 - your hands upon and you can see that
15:16 - this conveniently says latest here so i
15:19 - am going to download the 64-bit version
15:22 - on windows i am going to grab the zip
15:24 - archive here and let's click upon this
15:27 - this should kick off my download and
15:30 - this is going to download on my system i
15:32 - can download this if i want and you're
15:34 - going to see that it is going to start
15:36 - downloading here and i am going to wait
15:38 - for this to finish again this is going
15:41 - to give us both the gcc compiler and the
15:44 - clan compiler and this is really like
15:46 - shooting two birds with one stone so
15:49 - this is going to be really good i
15:51 - already have this downloaded so i am
15:53 - just going to head over to the location
15:56 - where i have this downloaded i think i
15:58 - can just go in my drive here
16:01 - so let's crack this open and go in my
16:04 - downloads folder
16:06 - and if i go in my compressed folder i am
16:08 - going to find winlabs llvm and mingw
16:12 - this is what you really want but if you
16:15 - don't want the clan compiler you can
16:17 - grab the one that doesn't say llvm here
16:20 - because we really want both of these
16:22 - compilers we are going to grab the one
16:24 - that has both the gcc compiler and the
16:26 - clan compiler if we crack this open
16:28 - let's open this together so that you can
16:30 - see what is happening we are going to
16:32 - have this little folder here if we go in
16:35 - we're going to find a bin folder if we
16:37 - go in and crack that open we're going to
16:39 - have a folder
16:40 - that says clang you see we have a clang
16:44 - compiler we have our clan plus plus
16:46 - compiler for c plus plus and if we go
16:48 - down we're going to find our g plus plus
16:50 - compiler and the gcc compiler this is
16:53 - what we want so what we are going to do
16:55 - is extract this somewhere on our system
16:58 - i put this on my c drive so if you go
17:01 - here you're going to find mingw64
17:03 - so all you really have to do is go where
17:06 - you downloaded your compiler
17:08 - and say extract we're going to right
17:10 - click on this
17:12 - and say extract to a location and you're
17:14 - going to specify where you want this to
17:16 - go and this is going to be extracted or
17:19 - even if you want you can extract here
17:21 - this is something i like to do this is
17:23 - going to show up in the current folder
17:25 - and you can grab this and paste that in
17:28 - a location where you want this in my
17:30 - case i put this in my c drive as i said
17:33 - here so this is going to be my compiler
17:35 - now once you have these compilers
17:37 - installed again we have the clan
17:39 - compiler we have the gcc compiler if we
17:42 - go down we're going to find the g plus
17:44 - plus we even have gdb which is a
17:46 - debugger we can use to debug c plus plus
17:48 - applications but we will talk about this
17:50 - later once you have this i would
17:52 - recommend putting this in your
17:54 - environment variables on windows the way
17:57 - you do this you grab this path well we
17:59 - have our compilers here and we're going
18:00 - to copy this this is something i
18:02 - recommend
18:03 - and on windows 10 you can go on the
18:06 - start menu and type env
18:10 - and this is going to give us a window in
18:12 - which we can edit our environment
18:15 - variables we're going to click on this
18:16 - little thing this is going to open up on
18:19 - our system we're going to wait for this
18:20 - to open up and we're going to have a
18:22 - window that says system properties we're
18:25 - going to click on environment variables
18:26 - here and we can put this in our user
18:30 - environment variables or on our system
18:32 - environment variables since i am the
18:34 - only one using this system i like to put
18:37 - this in my path for my system variables
18:40 - so i am going to click on path and click
18:42 - edit here and i am going to add a path
18:45 - to my gcc and cloud installation here
18:48 - you can see that right here if you don't
18:50 - have this end you can click on new
18:52 - you're going to have a window here and
18:54 - you can paste this right in and you can
18:56 - click ok but i'm not going to do that
18:58 - because i already have this in here so
19:01 - what i am going to do is just delete
19:04 - this let's see if i can delete i can
19:06 - delete this little guy and i have my
19:08 - path in here so if you don't have this
19:11 - in please make sure you have this in
19:12 - your environment variables so we're
19:15 - going to cancel out of this but if this
19:17 - is the first time you do this you should
19:19 - click ok and one way to test that your
19:22 - environment variables are working or
19:24 - even if your compilers are working
19:27 - is to crack up a command line terminal
19:30 - so we're going to say cmd on the start
19:32 - menu here
19:34 - and all you need to do is say g plus
19:37 - plus just like this dash dash version
19:40 - if you do this you're going to see
19:41 - information about your c plus plus
19:43 - compiler
19:45 - and this is coming from the installation
19:46 - we just did and for clan you can say
19:49 - clan plus plus version and this is going
19:53 - to tell you the information about your
19:55 - clan compiler installation let's wait
19:57 - for this to come up i don't know why
19:58 - it's slow but you can see that we have a
20:01 - clank compiler the lattice version is
20:03 - 1201 for the gcc compiler the latest
20:06 - version is 1120
20:08 - and these are the compilers we can use
20:10 - to write c plus plus 20 applications
20:13 - okay so by now we have a gcc compiler
20:16 - through the main gw project we have a
20:19 - client llcm compiler on our system we
20:22 - are also going to see how to get a hold
20:24 - of the compiler from microsoft and to
20:27 - get hold of this you need to install
20:29 - microsoft visual studio
20:32 - to install microsoft visual studio all
20:34 - you have to do is come to your favorite
20:36 - search engine and say microsoft visual
20:38 - studio we can look at the 2019 version
20:41 - which is the latest i think and we're
20:43 - going to click on the download link here
20:45 - we have as the first link and we're
20:48 - going to see ways we can download this
20:50 - little guy now microsoft visual studio
20:52 - has a community version you can download
20:55 - for free but we also have a professional
20:57 - and enterprise versions that we're not
20:59 - going to care about in this course here
21:02 - we are just going to download
21:04 - the community version and that's going
21:06 - to be enough for our purposes here so if
21:09 - you click on free download here this is
21:11 - going to download and install the visual
21:14 - studio compiler you can click on this
21:16 - little guy and it is going to download
21:18 - an installer you're going to crack this
21:20 - open on your system and it is going to
21:22 - install the visual studio installer so
21:25 - once you have it installed you can come
21:27 - to the start menu here
21:29 - and say visual studio installer i think
21:32 - if you say visual studio you're going to
21:33 - have this pop-up somewhere on your
21:35 - system we're going to click on this and
21:38 - if you crack the installer open you're
21:39 - going to see a window like this which is
21:41 - really going to give you a chance to
21:43 - install the tools you want to use with
21:46 - the microsoft visual studio
21:48 - ide and in this case we are interested
21:51 - in desktop development with c plus plus
21:53 - so we're going to click this little guy
21:55 - here we're going to take it open
21:57 - and once you do this you going to click
22:00 - download and install and this is going
22:02 - to install the visual studio compiler
22:05 - with the underlying compiler you see
22:07 - that this is going to give us access to
22:08 - the msvc compiler and all kinds of crazy
22:11 - things we really needed to write c plus
22:13 - plus applications on windows using the
22:16 - compiler from microsoft now i have to
22:18 - say this is going to take some time to
22:20 - install so if you see that this takes up
22:22 - 20 minutes of your time don't worry this
22:24 - is really normal because this id and the
22:27 - compiler behind it and really large
22:30 - they're not like the gcc or the clan
22:33 - llvm compilers that we just installed
22:35 - okay so once you have this ticked or
22:38 - checked you're going to click on
22:39 - download or install whatever this button
22:41 - is saying here this is going to install
22:44 - both the microsoft visual studio ide
22:47 - and the compiler from microsoft that you
22:49 - can use directly to write c plus plus
22:51 - applications so once we have this open i
22:54 - am going to suppose that you have this
22:56 - installed already i am going to close
22:58 - out of this because i don't want to do
22:59 - this
23:00 - and you're going to have visual studio
23:02 - installed on your system once you have
23:04 - this installed you're going to come to
23:06 - the start menu and say developer
23:09 - and this is going to bring up two things
23:10 - one is going to be the developer
23:12 - powershell for visual studio 2019 and
23:15 - the other is going to be a command
23:16 - prompt it doesn't really matter what you
23:18 - choose i am going to click on the
23:19 - command prompt here
23:21 - and once you do this this is going to
23:23 - give you a terminal or a window through
23:26 - which
23:27 - the environment variables are already in
23:29 - to start using the compiler from
23:31 - microsoft and if we come here and type
23:34 - cl.exe
23:36 - we're going to see that we're going to
23:37 - see the information here if this gives
23:39 - you an error or something you're going
23:41 - to know that you didn't really install
23:43 - this properly so please go back and make
23:46 - sure you have this installed if you have
23:48 - a problem you can ask me i can do the
23:50 - best i can to help you out but by this
23:52 - moment we have three compilers on
23:54 - windows that we can use for c plus plus
23:57 - development we have the mingw or the gcc
24:00 - compiler in our hands we have the klanga
24:03 - lvm compiler and we have the compiler
24:06 - from microsoft and now we can install an
24:09 - ide or an editor and that's going to be
24:11 - visual studio code and we can connect
24:14 - that to these compilers so that we can
24:16 - start writing our own z plus bus 20
24:19 - applications we are going to head over
24:21 - in the next lecture and install the
24:23 - visual studio code editor
24:25 - go ahead and finish up here and meet me
24:27 - there in this lecture i am going to show
24:29 - you how to install the visual studio
24:31 - code editor on windows so if you are
24:34 - watching this course on windows this
24:36 - video here is going to be a must watch
24:39 - we are going to head over to our search
24:42 - engine and type visual studio code this
24:44 - is going to give you a link where we can
24:46 - download this cool editor if you want
24:48 - you can learn all you can about it it is
24:50 - a source code editor made by microsoft
24:52 - it supports multiple languages but we're
24:55 - going to be using that specifically for
24:57 - c plus plus in the course here here i am
25:00 - at the page for the editor and you can
25:03 - read all you want about it but we are
25:06 - interested in downloading this for
25:08 - windows if you want you can click on
25:10 - this download button here but i am just
25:12 - going to scroll down
25:14 - and have download links for windows if i
25:17 - want i can click on user installer
25:19 - system installer you can click on what
25:21 - you want if you are on a 32-bit system
25:24 - you're going to download a 32-bit
25:25 - version i am just going to click on
25:28 - 64-bit here because i am on a 64-bit
25:31 - operating system again
25:33 - in this video we are doing this for
25:36 - windows so this is going to be our area
25:38 - of interest here i am going to click on
25:40 - this download link and i am going to
25:43 - wait for things to kick off
25:45 - and i will have a window to start
25:47 - downloading visual studio code setup
25:49 - here i can save this file and it is
25:51 - going to start downloading once it is
25:54 - downloaded i am going to double click
25:55 - and really click my way through this
25:58 - until i have a visual studio code
26:00 - installed on my computer here
26:02 - okay the download is good i can crack
26:05 - this open let's click on this
26:07 - and you're going to see that it is
26:08 - saying that it has detected that visual
26:11 - studio code is already running on my
26:13 - system because i have it installed but
26:15 - if you don't have it installed you're
26:17 - going to click your way through and
26:19 - install this on windows and after you
26:21 - have it you can start it
26:23 - okay once you start visual studio code
26:25 - you're going to have a window like this
26:26 - if you run it for the first time you are
26:28 - probably going to see a windows with
26:30 - documentation and whatever
26:33 - let's look at the welcome screen you're
26:35 - going to probably see you're going to
26:36 - probably see something like this but i
26:38 - am not sure but the most important thing
26:40 - is that you're going to have a window
26:42 - like this with visual studio code the
26:44 - first thing we want to do for c plus
26:46 - plus development is going to scroll down
26:49 - and click on this little thing that says
26:51 - extensions i am going to click on this
26:54 - and i am going to go in my search box
26:57 - here and type c and c plus i can even
27:00 - type c plus plus it doesn't really
27:02 - matter and this is an area where we can
27:05 - install extensions to make visual studio
27:08 - code do all kinds of crazy things in
27:11 - this case we are interested in making it
27:13 - support c and c plus plus so we are
27:16 - going to click on this extension that
27:18 - says microsoft here cnc plus plus i am
27:21 - going to click on this and if you don't
27:23 - have it installed you can click on the
27:25 - install button and it is going to
27:27 - install this little thing and make your
27:29 - computer ready to use visual studio code
27:32 - for c plus plus so make sure you install
27:34 - this and at the end it is going to say
27:37 - disable or uninstall because it will be
27:39 - already installed and enabled on your
27:43 - computer and this is really the end of
27:45 - our installation video for visual studio
27:47 - code we are going to head over in the
27:49 - next video and show you how you can make
27:51 - a visual studio code use the compilers
27:54 - that we installed in the previous video
27:57 - so go ahead and finish up here and meet
27:59 - me in the next lecture
28:01 - in this video we're going to see how to
28:03 - connect our visual studio code editor to
28:06 - a compiler so that we can compile our
28:09 - projects easily through the visual
28:11 - studio code editor we already have the
28:14 - ide installed from the last two previous
28:17 - lectures when we have a compiler
28:18 - installed in the last lecture we
28:20 - installed the gcc compiler through the
28:22 - mingw project we installed the clangela
28:25 - vm compiler we even installed the
28:27 - compiler from microsoft now we're going
28:30 - to connect the ide to the compiler to
28:32 - make it really easy to compile c plus
28:35 - plus applications using these tools here
28:38 - what i am going to do is really set up a
28:40 - template project we're going to be
28:42 - reusing throughout this course here so i
28:45 - am going to go on a folder in my system
28:48 - and i am going to right click on the
28:50 - folder and say
28:52 - open with visual studio code
28:55 - let's do this this is going to open this
28:57 - folder in visual studio code and i am
28:59 - going to trust this folder here be
29:02 - careful what you trust because some
29:04 - things are going to do some malicious
29:06 - things on your computer make sure you
29:08 - trust the folders that you open up so i
29:11 - am going to trust myself because i am
29:12 - the creator of this folder here and this
29:15 - is going to open visual studio code
29:18 - now in our install video we installed
29:20 - the c plus plus extension for visual
29:22 - studio code again if you don't have this
29:24 - installed please make sure you go back
29:27 - and install and make sure this is saying
29:29 - that this is enabled and now we want to
29:32 - use this to write c plus plus
29:34 - applications here we're going to write a
29:36 - simple toy c plus plus application to
29:39 - just test that our compilers support c
29:42 - plus plus 20 and then we're going to use
29:44 - this as a starting point or as a
29:46 - template project so i want you to click
29:49 - on this little plus icon here
29:52 - and we're going to create a file called
29:53 - main.cpp
29:56 - and once you do that you will be able to
29:58 - type c plus plus code in this year so we
30:01 - are just starting out here i would
30:03 - recommend to type this exactly as i do
30:05 - here so we're going to say include and
30:08 - say opening angle bracket and say io
30:11 - stream
30:12 - and we're going to go down here and say
30:14 - and main
30:15 - and we're going to go inside these curly
30:18 - braces and say auto result and you are
30:23 - going to exactly type what i tap here
30:26 - don't worry we're going to have a chance
30:27 - to learn about all these things here so
30:30 - i am going to put a pair of parentheses
30:33 - and i am going to say 10. and i am going
30:36 - to put a weird operator here this is
30:39 - called the spaceship operator it is just
30:42 - something we can use to test that our
30:44 - compiler supports it plus plus 20 and
30:46 - we're going to put a 20 here and then
30:48 - we're going to try and see if this is
30:50 - greater than zero and we're going to
30:53 - print this out we're going to say stdc
30:55 - out again don't worry if you don't know
30:57 - what this is this is just a way for us
30:59 - to test and see if our compiler is going
31:02 - to be able to use c plus plus 20. we're
31:05 - going to say result here
31:07 - and this is going to be our program now
31:10 - we want to make sure we compile this
31:12 - program so to bring in your compilers in
31:14 - visual studio code all you have to do is
31:17 - come to the terminal menu here so please
31:19 - come here
31:20 - and we're going to have
31:22 - an option to configure tasks i want you
31:25 - to click on this
31:27 - and once you do this you're going to see
31:28 - that visual studio code is going to find
31:30 - the compilers that we just installed you
31:33 - see that it has found
31:35 - the
31:36 - gcc compiler we installed in mingw you
31:40 - see that it has found the clan compiler
31:42 - i know about the g plus plus compiler
31:45 - because you can see the path here you
31:46 - can see c major w ben g plus plus dot
31:50 - exe this is where we installed our g
31:52 - plus plus compiler and i know about the
31:55 - clank compiler because that's what's
31:56 - being found here for example on this
31:59 - entry here you see it says cmajw bin
32:02 - clan plus plus so we wanted to configure
32:05 - these two compilers here and later
32:07 - visual studio could use them to build
32:10 - our c plus plus 20 projects
32:12 - now what we're going to do is click on
32:14 - the g plus plus compiler first
32:17 - and when we do that this is going to
32:18 - create a tasks that json file in our
32:22 - project and you see that it has created
32:24 - a folder called dot vs code if i click
32:27 - on my main cpp file here and do reveal
32:30 - in explorer
32:33 - this is going to open up on my system
32:35 - and you see that this has created a dot
32:37 - vs code folder and if we go and we're
32:40 - going to find this tasks.json file this
32:43 - is going to be our configuration to
32:45 - configure which compilers that
32:47 - visual studio code is using to compile
32:50 - our main.cpp file here so if we go in
32:53 - it's going to really have everything
32:55 - ready for us so you're going to see that
32:57 - it's going to be using our g plus plus
32:59 - compiler this is the path to it and in
33:03 - our args options here we have the
33:05 - options that we pass to the compiler to
33:08 - compile our program here now i want to
33:11 - change this to say which kind of
33:13 - compiler we are using
33:15 - so we're going to change the level here
33:17 - to say world width
33:19 - g plus plus and say the version i think
33:22 - that's going to be more descriptive here
33:24 - so we're going to save world with g plus
33:26 - plus or gcc
33:28 - and we're going to say
33:31 - 11.2.0 because that's our version here
33:34 - and the rest is really going to be
33:36 - enough so let's try and see if we can
33:38 - compile our program here and see the
33:40 - thing here printing out
33:42 - but
33:43 - the other thing we need to do because
33:45 - this program is using c plus plus 20 we
33:48 - need to configure our compiler to use c
33:51 - plus plus 20. and one way to do that in
33:54 - gcc and you can really search these
33:56 - things for example
33:58 - if we come to our search engine here and
34:00 - say configure gcc to use c plus plus 20
34:04 - or even gcc
34:06 - and say c plus plus 20. you can search
34:08 - these things and find information and it
34:11 - is a really good way to test your things
34:13 - here
34:14 - so let's see if we can find a link to
34:16 - help out we have a stack overflow link
34:18 - here so we can crack this open and if we
34:22 - go and we're going to find a batch of
34:23 - things for example we can say std c plus
34:25 - plus 20 here as an option to our
34:28 - compiler and this is going to bring
34:31 - c plus plus 20 support in our gcc
34:33 - compiler so i am going to copy this
34:36 - and i am going to come back in my visual
34:38 - studio code editor
34:40 - and i am going to pass a flag to boiled
34:43 - in c plus 20 mode and it is something i
34:45 - just got from stack overflow here and we
34:48 - are going to pass this to our compiler
34:50 - and put a comma to make this a valid
34:52 - configuration file and i am going to
34:54 - close this
34:55 - now once we have this open and we want
34:58 - to build this we need to bring a
35:00 - terminal window so we we're going to
35:01 - bring the terminal window so that we can
35:03 - see things happening and we do that by
35:05 - coming to terminal and saying the new
35:07 - terminal
35:09 - and we will come back to terminal again
35:11 - and say that we want to run a task in
35:14 - this case we're going to be running our
35:16 - world with gcc 1120 again if you are
35:20 - using a newer version that's what you
35:22 - should use and if we click on this thing
35:25 - please make sure you have the main cpp
35:27 - file selected before you do this so i
35:29 - have this selected and i'm going to go
35:31 - to run task and i am going to click on
35:34 - this little thing you're going to see
35:36 - that this is going to kick off the
35:37 - process to build our program
35:40 - and we're going to wait for this to
35:41 - finish and you're going to see that it
35:43 - is using c plus plus 20 here we're going
35:46 - to see that the world finished
35:47 - successfully and we have a main.exe file
35:51 - created here so if we go in our terminal
35:55 - in visual studio code and click enter
35:58 - and
35:59 - type clear and hit enter this is going
36:01 - to clear the screen this is something
36:03 - you can do to clear things out we can
36:05 - run this main.exe binary directly here
36:09 - so we're going to run exe here and if
36:12 - you run it it's going to say zero and
36:14 - this is an indication that we have our
36:17 - visual studio code editor connected up
36:19 - to our gcc compiler and we can use that
36:22 - to compile c plus plus applications and
36:24 - this is really the configuration with it
36:27 - now you may ask how do i know this how
36:30 - do i did i know the steps to follow to
36:32 - get this to work
36:33 - well if you come to extension tab here
36:36 - and before we even do that i want to
36:37 - bring to your attention that we have a
36:39 - bunch of tabs here in visual studio code
36:42 - we have a tab that says file i think the
36:44 - one here saying explorer we have a one
36:47 - we can use for version control if you
36:50 - use something like git or whatever you
36:52 - can use this but in this course we're
36:54 - mostly going to be using the explorer
36:56 - tab here and the
36:58 - extensions tab to install things and at
37:01 - a later time i will show you how to use
37:03 - the debug tab here or run a debug tab
37:06 - but in most cases we're going to be
37:07 - using the explorer tab or the extensions
37:10 - tab here if you want you can click on
37:12 - this to close this so that you have some
37:14 - more space you can click again to bring
37:16 - this back these are some things you can
37:18 - do in visual studio code but i am going
37:20 - to show you how to configure your
37:22 - compilers where i got the information so
37:24 - click on extensions here
37:27 - and we're going to find our cnc plus
37:29 - plus extension
37:30 - if we scroll down we're going to find
37:32 - tutorials on how to set up this on
37:35 - different compilers for example you can
37:37 - crack this open
37:39 - to see how to set up a visual studio
37:41 - code to use your compiler from microsoft
37:44 - if we come back we can see a link to see
37:46 - how to use this with mingw on windows
37:49 - let's click on this
37:51 - and let's see what else we have we can
37:53 - come back to here and we can see how to
37:56 - use this with gcc on linux or clango on
37:58 - a mac you can really choose whatever is
38:00 - relevant for your operating system but
38:02 - in this case here we are just using the
38:05 - windows operating system so we're going
38:07 - to see how to use this with the mingw
38:10 - compiler that we just installed now we
38:13 - can use the mingw compiler and i would
38:16 - recommend reading up on this entire
38:18 - thing to have an idea on what is
38:21 - happening we already have our g plus
38:24 - plus compiler so this is this command is
38:26 - going to work again if we come back to
38:28 - terminal here and run g plus plus
38:30 - version i think we can see that we run
38:32 - these commands here to see these things
38:34 - working so we have this step here and if
38:37 - you wonder what gdb is it is just a
38:39 - debugger you can use to debug your
38:41 - programs and again if we come to our
38:43 - terminal here and say gdb
38:47 - version we're going to have this
38:48 - available from our mingw installation
38:51 - you can see that we have this here so
38:53 - this is working just fine you can really
38:55 - follow this and configure your visual
38:58 - studio code installation but i am just
39:00 - showing you how to do this pretty fast
39:02 - you can see that this is what we set up
39:04 - in our configuration file which is our
39:07 - tasks dot json file now one thing you
39:10 - can do is modify the task.json file to
39:14 - build every single file in your project
39:17 - and this is something that is going to
39:18 - make things easier what i'm going to do
39:20 - is go back to our visual studio code
39:23 - instance and find our project we're
39:25 - going to crack open our tasks that json
39:28 - file which is living in our dot vs code
39:31 - folder
39:32 - and i am going to take out the craziness
39:34 - i have in my arguments here i am going
39:37 - to select everything i am going to
39:39 - delete that
39:41 - and i am going to put in a configuration
39:43 - that i am using for my projects here to
39:46 - make this super easy what this is doing
39:48 - it is telling the compiler to build in c
39:50 - plus plus 20 mode it is going to tell
39:53 - visual studio it is going to tell the
39:55 - compiler to build every single cpp file
39:57 - in our project so if we have multiple
40:00 - files they are going to be built
40:01 - together and we're going to specify the
40:04 - name for our output file for example if
40:06 - we don't want our binary executable to
40:09 - be named mainly.exe we can give it a
40:11 - name and i am going to be naming mine
40:15 - rooster.exe in the course here i would
40:17 - recommend doing the same so that we can
40:19 - really have
40:20 - the same habits as we go through the
40:23 - course here but of course you are free
40:24 - to use whatever you want in your c plus
40:26 - plus programs here so once you have this
40:29 - you can click save here and this is
40:31 - going to save our json file here i can
40:33 - close this
40:35 - and i am going to bring my terminal by
40:37 - going to view
40:39 - and the terminal here this is going to
40:41 - bring back my terminal that i had before
40:44 - and i am going to run the clear command
40:46 - and hit enter
40:48 - and i am going to do dir to show the
40:51 - contents
40:52 - of my folder on windows here i wanted to
40:55 - remove the main.exe file from the
40:58 - terminal here so what i am going to do
41:00 - is say rm
41:03 - and i am going to say the name of the
41:05 - file i want to remove i am going to say
41:07 - main
41:08 - dot exe and if i hit enter notice what
41:11 - is going to happen the file is going to
41:12 - go away i don't see it anymore here i
41:15 - want to build again using my new
41:17 - configurations in my tasks the json file
41:21 - i am going to run the task to build with
41:23 - our gcc compiler
41:26 - this is going to build again and you see
41:28 - that it is using the configurations that
41:30 - i passed you see that it is building
41:32 - every single cpp file in the directory
41:35 - here and it is going to generate a
41:38 - program called rooster.exe and we if we
41:40 - look here we're going to find it we can
41:42 - hit enter in the terminal
41:45 - and we can type clear to clear things
41:47 - out and if we do the ir again we're
41:50 - going to see that we have rooster.exe
41:53 - and we can run it by doing
41:55 - rooster.exe here and this is going to do
41:58 - what we want this is really all you need
42:00 - to do to connect visual studio code to
42:02 - your gcc compiler now we're going to
42:05 - connect visual studio code to our clan
42:07 - compiler that we have installed we
42:09 - really want to be able to use it with
42:10 - our project here and we're going to go
42:12 - through the seven steps again so we're
42:14 - going to go to terminal and say
42:15 - configure tasks
42:18 - and we're going to choose something that
42:19 - says the clanger compiler and we're
42:22 - going to find clang plus plus so let's
42:26 - hunt for that i have something that says
42:29 - that here we have
42:32 - cloneplusplus.exe i am going to click on
42:34 - that and if i do this this is going to
42:36 - add an entry in my
42:39 - tasks.json file so watch out for this i
42:41 - am going to click on this
42:43 - and let's crack this test that json file
42:46 - open and you're going to see that this
42:48 - is going to also set up another
42:50 - configuration to world using my clang
42:54 - plus plus compiler
42:56 - and again i can edit this out a little
42:58 - bit to say what we want let's look at
43:00 - the version of cloud we have installed
43:02 - to say that out this is going to be 12
43:06 - 0
43:07 - 1 so we're going to say world with clank
43:10 - plus plus
43:11 - 12 0 1 let's say that here in our level
43:16 - 12.0.1 we can say that right here and
43:19 - you see that it is really doing the same
43:20 - thing we did with our gcc compiler so
43:23 - what i can really do is still everything
43:26 - i did in my gcc compiler i can
43:29 - copy this
43:30 - and i am going to take out the arguments
43:33 - i have in my args here and i use what i
43:36 - have in my gcc compiler you can see that
43:39 - you can use the client compiler and the
43:41 - gcc compiler in the same way and this is
43:44 - something really cool so now we have the
43:46 - option to use two compilers and this is
43:48 - really cool so we're going to close the
43:50 - json file and it's going to be saved
43:52 - automatically
43:54 - and we're going to bring up our terminal
43:56 - window again
43:58 - and let's bring this up a little bit and
44:00 - we're going to do dir on windows and
44:03 - we're going to remove the binary again
44:05 - we're going to remove roster.exe
44:08 - and again what you can do you can start
44:10 - typing the name of the file you want to
44:12 - remove and hit tab if you do that the
44:15 - terminal is going to autocomplete this
44:16 - for you and this is really cool so if i
44:18 - do this the file is going to go away you
44:20 - see that it is going right here
44:23 - and i can clear
44:25 - and what i am going to do is world with
44:27 - the clan compiler can do that by coming
44:29 - to terminal i am going to say that i
44:31 - want to run a task and i am going to be
44:34 - given an option i can either build with
44:37 - gcc so if i choose gcc here it's going
44:39 - to be used but i can also use clan let's
44:42 - use clang here so i'm going to click on
44:44 - this
44:46 - and you're going to see that visual
44:47 - studio code is going to kick off the
44:49 - world process
44:50 - this is going to build my binary
44:52 - executable and notice that it is using c
44:54 - plus plus 20 again the build is going to
44:56 - finish successfully and i will have a
44:58 - binary here and this is going to be all
45:00 - i need to do so if i hit enter and run
45:04 - my binary by tapping the name
45:07 - and hitting tab this is going to
45:10 - auto-complete if i run it it's going to
45:12 - say zero and this is what we expect here
45:14 - if you have some kind of error please
45:16 - try and fix it if you have a problem you
45:18 - can ask me and i will do the best i can
45:20 - to help you out
45:22 - okay now we have our two compilers
45:24 - working we need to configure the
45:26 - compiler from microsoft now the compiler
45:29 - from microsoft is a little bit weird
45:31 - again you can read up on this by coming
45:33 - to your extension documentation
45:35 - and going to using the compiler from
45:37 - microsoft with visual studio code on
45:39 - windows you can read up on all this if
45:41 - you want but i am just going to show you
45:43 - a quick way to get this running so the
45:46 - compiler from microsoft is special in
45:48 - that you have to specify the path to it
45:51 - for example if we open a regular
45:53 - terminal window and say
45:55 - cl.exe to call the compiler
45:58 - we're going to see that the terminal is
45:59 - going to say that the
46:01 - cl.exe compiler is not recognized and
46:04 - the reason is we don't have the proper
46:07 - environment variable settings for the
46:09 - operating system to find this compiler
46:11 - when we call it right here we are able
46:14 - to use g plus plus and clan because we
46:16 - put the environment variables in place
46:19 - if you remember when we installed them
46:20 - we did something like this we came to
46:22 - the start menu and did env we came to
46:25 - environment variables here and we put
46:28 - the path
46:29 - to our compilers in our environment
46:32 - variables here you can see them right
46:33 - here so we don't have the same thing for
46:36 - the compiler from microsoft and that's
46:37 - for a reason because we may have
46:40 - multiple compilers installed from
46:42 - microsoft
46:43 - then if you have multiple compilers it
46:45 - would be really cumbersome to choose
46:47 - which compiler you want the guys at
46:49 - microsoft opted for the option for you
46:52 - the developer to specify which compiler
46:54 - you want to run by coming to the start
46:57 - menu here and typing developer
47:00 - and choose which powershell for the
47:02 - compiler you want to use for example if
47:04 - we want to use the visual studio 2019
47:07 - compiler we can click on this and then
47:09 - we will have a terminal
47:11 - that can run
47:13 - the c plus plus compiler from microsoft
47:15 - for example if we wait for this to be
47:17 - ready and say cl.exe
47:20 - we're going to see that we're going to
47:22 - have a message saying that this is our
47:23 - compiler we can use it however we want
47:26 - so what we're going to do is set up a
47:28 - terminal like this and use this terminal
47:30 - to start visual studio code and the
47:33 - visual studio code is going to start in
47:34 - the mode
47:36 - where it can find the compiler from
47:38 - microsoft i know this is confusing but
47:40 - please bear with me this is what we need
47:41 - to do to get this to work if we start
47:44 - visual studio code in a mode where it
47:46 - knows about the environment variables
47:48 - for the compiler from microsoft we will
47:51 - have the ability to say cl.exe
47:54 - and we will be able to use that right
47:56 - here but you see that it is not
47:58 - recognized now but we can use the g plus
48:01 - plus compiler if we do this
48:03 - version
48:04 - we're going to see that it's available
48:05 - we can use it we can use clan plus plus
48:08 - and if we do version as well we're going
48:10 - to see that we can use this little guy
48:12 - here we also want the ability to use the
48:15 - compiler from microsoft but to have
48:17 - access to that we will have to close the
48:20 - visual studio code instance we have here
48:22 - and we're going to come back to our
48:24 - project let's see if i can find it here
48:27 - so we're going to go to the location
48:28 - where we have our project and we're
48:30 - going to change to the location of the
48:32 - project here so i can grab the location
48:34 - from my visual studio code project that
48:37 - i just set up i am going to come back to
48:39 - my powershell window that knows about
48:41 - the path to the c plus plus compiler
48:44 - from microsoft and i am going to change
48:46 - it to the location of my project here so
48:49 - i am going to say cd and paste in the
48:51 - path i just copied and if i hit enter
48:53 - this is going to change to my location
48:56 - and i really recommend using powershell
48:58 - if you have access to this because it is
49:00 - a little more convenient to use it
49:02 - supports more commands that you can use
49:05 - in the command prompt but again that's
49:07 - going to be your choice now i am in the
49:10 - location for my project if i do ls or
49:13 - dir
49:14 - you can see that i can see my main cpp
49:17 - file can see the binary we generated
49:19 - earlier but this is not problem so what
49:22 - i can do here is say code
49:24 - and i say a dot and this is going to
49:27 - start visual studio code in the current
49:29 - folder of our project year so if you hit
49:32 - enter we're going to wait for visual
49:34 - studio code to come up it is going to
49:36 - come up with the project we had in that
49:38 - folder
49:39 - and the special thing about
49:41 - starting visual studio code this way is
49:43 - that it's going to know about the
49:45 - compiler from microsoft if we come back
49:47 - to our terminal here
49:49 - and clear and say cl.exe
49:52 - you're going to see that now it knows
49:53 - about the compiler from microsoft and we
49:56 - can use it to do things so let's set
49:58 - this up again if you want you can read
50:00 - up on how to do this
50:02 - on the documentation from visual studio
50:05 - code itself but again i am going to show
50:07 - you how to do this you can see that it
50:08 - is really the same things they are doing
50:11 - here so let's come back to visual studio
50:13 - code and we're going to go to terminal
50:15 - and we want to configure a task
50:18 - now you see that we have the compiler
50:20 - from microsoft available you can see
50:22 - that we can use that right here so what
50:25 - i am going to do is click on
50:28 - cl.exe world active file
50:31 - and this is going to add a new entry in
50:33 - our configuration file and it is going
50:35 - to open up if we go here we are going to
50:37 - find that we have a command to build
50:40 - using the compiler from microsoft so
50:43 - let's change the level here and i say
50:45 - world with msvc i think this is going to
50:48 - be more descriptive and this is really
50:50 - going to build your thing now i am going
50:52 - to change this up so that it works
50:55 - everything in the current folder
50:57 - and again i am going to remove
50:59 - everything here and put in a
51:01 - configuration that i have ready on my
51:03 - system here this is what i use for all
51:05 - my projects again this is just calling
51:08 - the compiler and giving it options to do
51:10 - things we just need to specify that we
51:12 - want to use the lattice standard of the
51:14 - c plus plus standard and it is going to
51:17 - specify
51:18 - the input files we're going to be
51:20 - building everything in the current
51:22 - folder this is what we are saying here
51:24 - and the output file is going to be
51:26 - called rooster.exe
51:28 - if we save this by saying ctrl s or
51:31 - command s
51:33 - and close our tasks dot json file we can
51:36 - bring up our terminal window by going to
51:38 - view and saying the terminal here
51:41 - and we can go down and clear we can say
51:44 - clear and hit enter
51:46 - and if we do rm and say rooster and hit
51:50 - tab this is going to remove the binary
51:52 - we generated with the clang llvm
51:55 - compiler earlier now we want to build
51:58 - with the compiler from microsoft so
52:01 - let's do this we're going to say
52:02 - terminal and we're going to say that we
52:04 - want to run a task but this time we want
52:07 - to build with msvc this is what we want
52:10 - to do here if we click on this little
52:12 - thing we're going to kick off the
52:14 - process to build with the compiler from
52:16 - microsoft and we're going to wait for
52:18 - the compiler to do its thing
52:21 - and if we wait we're going to see that
52:23 - the world finished successfully and if
52:25 - we look in our folder we're going to see
52:27 - that we have our output file and we can
52:30 - come in our terminal and hit to enter
52:32 - and do clear to clear things up and if
52:34 - we say rooster just like this
52:38 - and hit enter you're going to see that
52:39 - it's going to say zero and this is
52:43 - confirmation that we are able to use our
52:46 - visual studio code editor and be able to
52:49 - use it with all kinds of crazy compilers
52:51 - and this is really cool if you are on
52:53 - windows i recommend setting this up
52:56 - because it's it's going to make it
52:57 - easier to run a c plus plus applications
53:00 - from visual studio code using
53:02 - state-of-the-art compilers like msvc
53:04 - clone and gcc here and this is really
53:07 - cool now we have everything we need to
53:09 - start running c plus plus applications
53:12 - but before i let you go let's show you
53:14 - how you can set this up so that you have
53:16 - an easier time with regards to
53:18 - intellisense and whatever so what we're
53:21 - going to do we're going to go to our
53:22 - view menu and we're going to choose
53:24 - command palette
53:25 - and in this we're going to say c or c
53:28 - plus plus
53:30 - we can say something like this and we're
53:32 - going to choose edit configuration ui
53:35 - this is going to give us an option to
53:36 - configure things
53:38 - and i want you to configure things your
53:40 - new system
53:41 - so i am on a windows system
53:43 - let's see the options we have here i am
53:46 - only going to have the option for win32
53:49 - but if we go down we can specify
53:52 - the things we need
53:54 - visual studio code configured for for
53:56 - example it's going to give us
53:57 - intellisense or autocomplete and all
54:00 - kinds of greater things using the
54:02 - setting we choose here if we want we can
54:04 - choose the gcc compiler or whatever i am
54:06 - just going to leave in the windows msvc
54:08 - compiler because i am on windows here
54:11 - but know that you can configure these
54:13 - things now if we go down we're going to
54:15 - see that we have the option to configure
54:17 - the c plus plus standard and the
54:20 - compiler path that is going to be used
54:22 - to figure things out we're going to be
54:23 - using the compiler from microsoft here
54:26 - but know that you have the option to
54:27 - choose any other compiler for example we
54:29 - can choose the g plus plus compiler we
54:31 - can choose the clank plus class compiler
54:33 - you can configure these things and if
54:35 - you need to change this please come back
54:37 - here and do these configurations here
54:40 - we're going to leave in this whole
54:41 - intellisense and what we will do
54:43 - is configure visual studio code to use
54:46 - the c plus plus 20 standard so we're
54:49 - going to do that right
54:50 - here and if you set this up you're going
54:53 - to see that visual studio code is going
54:55 - to generate a cpp properties
54:58 - file which is going to store all these
55:00 - configurations here so it is really
55:02 - going to be
55:03 - a configuration for what we choose in
55:06 - our configuration here so make sure you
55:08 - choose what makes sense again i would
55:10 - recommend using c plus plus 20 but if
55:12 - you go on top you can really use any
55:14 - compiler you want i am going to use the
55:16 - compiler from microsoft this is okay i
55:18 - am going to use windows msvc
55:20 - configuration for intellisense here and
55:22 - i am going to close this and we are
55:24 - really ready to start using visual
55:26 - studio code to ride c plus plus
55:28 - application so let's clean this up a
55:31 - little bit we're going to view our
55:32 - terminal and we're going to remove the
55:35 - junk that was generated by the compiler
55:37 - from microsoft i am going to say rm and
55:40 - say rooster
55:42 - and i can remove the binary i can say rm
55:46 - and say rooster and say tab this is
55:48 - going to autocomplete and really remove
55:51 - things i don't need i am going to remove
55:53 - the pdb file i am going to remove
55:56 - rooster
55:57 - you know i am going to remove the main
56:00 - object file so let's say main dot obj
56:04 - and i am going to remove main dot
56:07 - or vc we don't want to remove our cpd
56:10 - file so now we have a project we can use
56:13 - as a starting point to write c and c
56:16 - plus plus applications here so what we
56:19 - will be doing in the next few lectures
56:21 - or the next few chapters is reusing
56:24 - this thing here as a template project so
56:28 - what i can do is uh call this
56:31 - c plus plus 20 template project and
56:34 - let's do this here i think i need to
56:36 - close video studio code otherwise it's
56:37 - going to complain so i am going to call
56:40 - this little guy c plus plus 20 template
56:43 - project and
56:44 - later when we start learning about c
56:46 - plus plus proper we're going to be using
56:48 - this as a starting point and we want to
56:50 - have to reconfigure the compilers our
56:52 - project will be ready to use
56:55 - the compilers that we set up here namely
56:58 - the compiler from microsoft the g plus
57:00 - plus compiler and the clang plus plus
57:03 - compiler and that's going to be really
57:05 - cool this is really all i have to share
57:07 - in this lecture i hope you have visual
57:09 - studio code set up to use all these
57:10 - compilers we are going to stop here in
57:13 - this lecture the next one we're going to
57:15 - start and see how to set up your
57:16 - development environment on linux and
57:19 - we're going to start by installing
57:20 - compilers on ubuntu 2004
57:24 - go ahead and finish up here and meet me
57:27 - there in this lecture we're going to see
57:29 - how to install c plus plus compilers on
57:31 - linux we are going to be working on an
57:34 - ubuntu 2004 system and we will install a
57:38 - new version of gcc and the latest
57:42 - version i can get my hands on for clang
57:44 - llvm so let's do this okay so here i am
57:47 - on my linux box this is ubuntu 2004 if i
57:52 - do you name and say a
57:55 - we're going to see the information on
57:56 - this
57:57 - and you will have to adapt this for
57:59 - whatever linux distribution you are on
58:02 - and to install gcc it's really simple
58:05 - but the problem is the latest version of
58:08 - gcc at the time of recording this video
58:10 - is gcc 11 and it's not available in the
58:13 - ubuntu packages now for example if you
58:16 - do see do
58:17 - apt get install
58:20 - gcc 11
58:22 - this is how you get it
58:24 - if you do this
58:26 - you're going to put in your password
58:28 - you're going to see that this is really
58:30 - not available yet right we cannot find
58:33 - this so the best version we can install
58:36 - is gcc 10 which i happen to have
58:38 - installed already on this system so
58:40 - we're going to do gcc 10 that's what
58:43 - we're going to install here
58:44 - and if we do this we're going to see
58:46 - that this is already available you can
58:48 - also install g plus plus done i think
58:50 - you can do that
58:52 - okay so we're going to run the command
58:53 - here and we're also going to see that
58:56 - it's already available here but if you
58:58 - don't have these
59:00 - they are going to be installed and you
59:02 - can use them on your linux system
59:04 - another tool that is necessary on linux
59:07 - is the gdb debugger so we're going to do
59:09 - sudo apt
59:12 - get install
59:13 - gtb
59:15 - right if you install it it's going to be
59:17 - installed but i already have it
59:19 - installed already so now if i do gcc 10
59:23 - on my system here and say version we're
59:25 - going to see the version printed out we
59:27 - can do g plus plus stand we can see the
59:29 - version here let's do that for c plus
59:32 - plus
59:34 - so we're going to see the version here
59:36 - we can even do gdb version
59:40 - and it is going to show up let's wait
59:42 - for this we're going to see my gdp
59:44 - version here and now i can use these
59:46 - compilers to compile c plus plus code on
59:50 - my linux box here so this completes our
59:53 - steps to install a gcc compiler on linux
59:56 - we're going to look at how we can get a
59:57 - hold of the clang compiler
60:00 - on our linux box here and it is really
60:03 - simple all you have to do is to do
60:05 - apt get install
60:07 - and we're going to install clang 12
60:10 - because that's the latest version at the
60:12 - time of recording this video if we do
60:14 - this we're going to see that it's going
60:15 - to install i already have it installed
60:17 - here but if you don't have it installed
60:20 - it's going to install on your system and
60:22 - this is going to give you all the tools
60:24 - you need to compile with the clan
60:26 - compiler on this particular ubuntu
60:28 - system these installs are going to be
60:30 - installed in my user bin directory so if
60:33 - i see the there and do analysis to show
60:37 - everything in here
60:39 - and scroll up we're going to find all
60:41 - the versions for clan you see i have
60:42 - multiple versions clang 10 11 12
60:45 - and we have clan plus plus variance of
60:48 - this i think we do okay we have clank
60:51 - plus plus and clan here and this is
60:53 - going to do what we want we have the
60:55 - clan combiner and the gcc compiler
60:58 - installed on our system here now if you
61:01 - want to get the latest version of gcc
61:03 - installed on your system
61:05 - one easy way i found is to go through a
61:08 - package manager called homebrew let's
61:11 - search for this
61:12 - right if you search for this you're
61:14 - going to find it and if you want you can
61:16 - install it on your linux system
61:18 - and when you install it it's going to to
61:20 - be basically there ready to use
61:23 - and to install it i think there's a
61:25 - command there install home brew
61:28 - let's do this install here and if we do
61:30 - install
61:32 - we should find a link to install this
61:34 - let's find a link i think they have a
61:37 - link you can copy aha it is this little
61:39 - thing here you can copy it paste it in
61:42 - your terminal and it is going to install
61:44 - home brew on your system
61:45 - and when you have home brew installed
61:48 - you can go through it to install the
61:50 - latest version of gcc for example if we
61:52 - search for homo blue
61:54 - gcc in our search engine here
61:57 - we're going to find all the information
62:00 - to install this through home brew and
62:03 - you just have to do bro install gcc and
62:05 - this is going to install this on your
62:07 - system and you're going to see that it
62:09 - is going to install the latest version
62:11 - at the time of recording this video so
62:13 - this is what you should do for example
62:15 - if we go back to our linux box we can do
62:19 - let's cd into our home directory and
62:21 - we're going to say brew
62:23 - install gcc
62:26 - and it's going to tell me that it is
62:28 - already installed because i installed
62:30 - this
62:31 - but if you don't have it installed it's
62:33 - going to install it and you do this
62:34 - after you have gone through the steps
62:37 - to install
62:39 - the home brew package manager on your
62:41 - system and you do that by just copying
62:44 - this link and pasting that in your
62:45 - terminal and hitting enter and it's
62:48 - going to give you directions on what you
62:49 - can do to get this properly installed on
62:52 - your system here so this is really cool
62:54 - so if you want the absolute latest
62:56 - version in gcc this is one way you have
62:59 - to get a hold of it without really going
63:01 - through the complex steps to build the
63:04 - compiler yourself on linux okay it is
63:07 - taking some more time here i am just
63:09 - going to kill this because i already
63:11 - have the latest version of gcc here if i
63:14 - do jcc 11 on linux and the do version
63:19 - i am going to see that i have 11 2 and
63:21 - it was installed through homebrew and if
63:24 - you let this run to completion it's
63:26 - going to install this on your computer
63:28 - we don't have to wait for this so now we
63:30 - have the latest version of gcc on an
63:33 - ubuntu system we also have the latest
63:35 - version of clan this completes our
63:38 - tutorial on how to set up compilers on
63:40 - linux we are going to stop here in this
63:42 - lecture this one we're going to install
63:45 - visual studio code on the linux system
63:47 - and then in the next one we're going to
63:49 - link visual studio code to these
63:51 - compilers and be able to use visual
63:54 - studio code type code and compile our
63:56 - programs using these two compilers here
63:59 - so go ahead and finish up here and meet
64:01 - me in the next lecture
64:03 - in this lecture we're going to see how
64:05 - to install the visual studio code editor
64:08 - on a linux system and again we will be
64:11 - working on our ubuntu 2004 system here
64:15 - so let's head over to the website for
64:17 - visual studio code and download our
64:18 - binary and install it on our linux
64:22 - system here okay so here we are at the
64:24 - website for visual studio code you can
64:26 - get there by searching for visual studio
64:29 - code in your search engine and you're
64:31 - going to land here and all we really
64:33 - have to do
64:34 - is go down to find our download links
64:36 - we're going to see that for debian and
64:38 - ubuntu we can download here but you can
64:41 - also find something specific to other
64:43 - distribution okay so we are going to
64:45 - grab the 64-bit version of debian ubuntu
64:49 - here because that's my system and you're
64:51 - going to find whatever makes sense for
64:53 - your distribution so let's grab this
64:56 - here we're going to grab the link so if
64:58 - you click on this
65:00 - this is going to kick off the download
65:01 - process and you will see this downloaded
65:04 - on your system and once you have this
65:07 - downloaded you're going to install it
65:09 - and in ubuntu you can just double click
65:11 - on this to install it or you can install
65:13 - it like you install any debian package
65:16 - on a linux system for example if you are
65:19 - unsure on how to install debian packages
65:22 - all you have to do is do a simple search
65:24 - so let's do google.com and go there and
65:28 - we're going to see how to install
65:30 - to install debian
65:32 - packages
65:34 - on ubuntu
65:35 - 2004 so this is our version here and
65:38 - you're going to find a lot of
65:40 - instructions on how to do this it's
65:42 - going to be really simple so we can go
65:44 - down and find a way to install so all
65:47 - you have to do is says you do dpkga
65:51 - say i and you pass the name of the
65:53 - package and this is going to install
65:54 - visual studio code on your system once
65:56 - you do this you will have visual studio
65:58 - code installed and you will be ready to
66:01 - start it and use it on your system here
66:03 - once it is installed you will have the
66:05 - ability to come in your system here for
66:08 - example and say code dot and this is
66:11 - going to open a visual studio code
66:13 - instance on your system let's wait for
66:15 - this to come up so that you really see
66:17 - this
66:18 - okay so this is going to open visual
66:20 - studio coordinate system and you can
66:22 - start using it like we will do in the
66:24 - next lecture okay once you have a visual
66:27 - studio code installed and started up on
66:29 - your linux system the very first thing
66:31 - you need to do
66:32 - is to install the extension that is
66:35 - going to allow you to do some c and c
66:37 - plus plus and to do that you will come
66:40 - to this tab here that says extension and
66:43 - in our search box you can start typing c
66:45 - and c plus plus
66:47 - and you are going to have an entry that
66:50 - says microsoft here so please select
66:53 - this and this is going to be the
66:55 - extension you need to install you're
66:56 - going to click on install and it is
66:58 - going to install
66:59 - and this is what enables a visual studio
67:02 - code to do some c plus plus programming
67:05 - and this is really cool if you want you
67:07 - can check out how to use it on linux and
67:09 - you're going to have instructions on how
67:11 - to do this but we will do this in the
67:13 - next lecture and show you how to
67:15 - configure visual studio code to use the
67:18 - compilers that we have installed in a
67:20 - previous lecture so we're going to tell
67:22 - visual studio code to use our client
67:25 - compiler we're going to tell it to use
67:26 - our gcc compiler and we will have the
67:29 - flexibility to come to terminal and
67:31 - choose which compiler we want to use and
67:33 - we're going to do all this in the next
67:35 - lecture so go ahead and finish up here
67:38 - and meet me there
67:40 - in this lecture we're going to configure
67:42 - our visual studio code editor to use the
67:45 - compilers that we just installed in a
67:49 - few previous lectures so we will be able
67:51 - to type our code in our visual studio
67:53 - code editor just like we do here and we
67:56 - will pass the code through the compiler
67:58 - to generate a binary that can in turn
68:01 - run on our linux system here this is
68:04 - what we want to do so we want visual
68:06 - studio code to use the compilers that we
68:08 - installed so let's head over to our
68:10 - linux box and do this okay here i am on
68:13 - my linux box this is the current
68:15 - directory where i am at this is where i
68:18 - am going to do my things here so i am
68:21 - going to create a folder and call it a
68:24 - template project let's do this we're
68:26 - going to say
68:27 - mkdir and we're going to say c plus plus
68:31 - 20 template project i think this is
68:33 - going to do
68:34 - or we can even say cpp because i'm not
68:37 - sure the plus signs here are not going
68:39 - to give us a problem let's play it on
68:41 - the safe side and we are going to create
68:44 - this folder and we're going to cd into
68:46 - this folder
68:48 - okay once we are in this folder we're
68:50 - going to open this folder in visual
68:52 - studio code and the easiest way to do
68:55 - that
68:56 - once you have visual studio code
68:57 - installed is just to type code and type
69:00 - dot
69:01 - and you will basically be telling the
69:03 - operating system to open visual studio
69:05 - code in the current folder here so i am
69:08 - going to hit enter
69:10 - and this is going to kick it open and i
69:13 - trust this folder because i just created
69:15 - it and we are in our project here the
69:18 - very first thing we're going to do is to
69:20 - create a main cpp file so let's do that
69:23 - and i did that by clicking on the plus
69:25 - icon here
69:26 - and i typed in the name of the file and
69:29 - i am going to put in some dummy code
69:32 - here that we want to use our starter
69:34 - code we're going to say
69:36 - iostream and we're going to put in our
69:39 - code here we're going to say main and
69:41 - again you don't have to type all this if
69:43 - you want you can get the code from the
69:45 - resource section on the lecture so you
69:47 - can copy the code paste that in here and
69:49 - be on your merry way because we haven't
69:51 - really started learning about c plus
69:53 - plus we are setting up the environment
69:55 - so don't stress yourself here
69:57 - this is just some simple code to test
69:59 - our compilers to see if they support c
70:02 - plus plus 20 because we want to use the
70:04 - letter standard we can get our hands on
70:07 - here so let's do equals
70:10 - type exactly what i typed here so we're
70:12 - going to say 10
70:14 - and we're going to put this weird
70:15 - operator and say 20 and we want to see
70:18 - if this
70:19 - madness here is greater than zero this
70:22 - is what we want to do and we're going to
70:24 - say stdc out and the same result okay so
70:27 - type exactly what i type here and as we
70:30 - progress in the course we're going to
70:31 - make sense of all these madness we see
70:34 - here so now that we have a cpp file
70:38 - containing the code for our c plus plus
70:40 - program we want to compile this and we
70:44 - need to tell visual studio code which
70:46 - compiler it's going to use to compile
70:48 - this program here to give us a binary
70:50 - that we can run so what we're going to
70:52 - do is come to terminal here
70:55 - and we're going to say that we want to
70:57 - configure tasks
70:58 - and the task is really a set of
71:00 - instructions you give to visual studio
71:02 - code on how to take your c plus plus
71:05 - project and turn that into a binary that
71:08 - can run on that system here so that's
71:11 - what we want to do we want to tell
71:12 - visual studio code which compiler it's
71:15 - going to use we're going to configure
71:16 - task here and you're going to see that
71:18 - it's going to discover many compilers on
71:21 - my system here you see we have clan 10
71:24 - clang 11 clan 12 and we should also have
71:27 - gcc 11 if we keep scrolling down we're
71:30 - going to find these little guys here i
71:33 - have many compilers on this system so i
71:36 - am going to choose
71:38 - the
71:38 - gcc compiler
71:40 - which is installed through home brew
71:42 - this is what i'm going to choose here
71:44 - you say it's saying g plus plus 11 but
71:46 - if you have access to g plus plus 10 you
71:48 - can also use that it's going to work
71:51 - with what we want to do in this course
71:53 - here mostly so i am going to choose the
71:55 - best i have in terms of gcc
71:58 - and this is going to set up an entry in
72:01 - our tasks dot json file to build and run
72:04 - this program here and that's what we're
72:06 - going to do okay you see it is using
72:09 - this particular compiler and one thing
72:12 - we can do before we try and build this
72:14 - we can change the level here to make it
72:16 - a little bit
72:17 - more descriptive so we're going to save
72:19 - world
72:21 - with gcc
72:25 - 11.2.0 if i am correct
72:27 - and this is all we can save this
72:30 - and we can close this json file and if
72:33 - we bring up a terminal window we can do
72:35 - that by hitting terminal here and
72:37 - choosing a new terminal
72:40 - this is going to open up the current
72:42 - location for example if we do pwd in
72:46 - this terminal here let's use lowercase i
72:49 - think that's what it wants we're going
72:50 - to see the location here this is my
72:52 - project so to build i can come to
72:55 - terminal
72:56 - and i choose run task and i am going to
72:59 - choose the task to compile with my gcc
73:02 - installation here if i choose this
73:05 - it is going to kick off the weld process
73:08 - and you're going to see that the
73:09 - gibberish i have here is not supported
73:11 - because the
73:13 - compiler is not configured to use the c
73:15 - plus plus 20. so all we really need to
73:18 - do is go back to our command and tell it
73:22 - to use c plus plus 20. and we can do
73:24 - that by passing a specific instruction
73:26 - to the compiler to use c plus plus 20
73:29 - like we do on line 10 here so we're
73:32 - going to say std equals c plus plus 20.
73:35 - we are going to save this a little bit
73:36 - and i really wanted you to see this
73:38 - problem here because many people are
73:39 - going to forget this and we're going to
73:41 - try and build again making sure we are
73:43 - selecting the main cpp file here so
73:46 - let's go to terminal run task and use
73:49 - our compiler
73:51 - and wait for it to do its thing you're
73:53 - going to see that the world now finished
73:55 - successfully
73:58 - and if we come back to our terminal here
74:00 - and do ls we're going to see that we
74:02 - have a file called main
74:05 - and if we run it we should see a zero so
74:07 - let's say main here
74:10 - and if we run it we're going to see a
74:11 - zero meaning that our program is running
74:14 - and working correctly we are able to
74:16 - compile a c plus plus project on a linux
74:19 - system here now if you want to see how i
74:22 - came up with the information to use the
74:24 - tax json file please come back to the
74:27 - extensions tab here
74:30 - and choose the c and c plus plus
74:33 - extension we're going to click on this
74:35 - and we're going to see all the
74:36 - instructions on how to use this guy on
74:38 - the linux system here so gcc on linux we
74:41 - can choose this
74:43 - and we're going to see all the
74:44 - information here now you can read up on
74:46 - all this if you want but what i am going
74:48 - to do is go to visual studio code and
74:51 - show you exactly what you need to do to
74:52 - get this to work what i want to do in
74:55 - there is set this up to compile
74:57 - everything in my what i want to do is to
75:00 - set what i really want to do is to what
75:03 - i really wanted to do is to set this up
75:06 - so that it compiles every single cpp
75:09 - file in my directory here and i can do
75:11 - that by putting in
75:13 - a set of instructions i had prepared
75:15 - beforehand
75:17 - so we're going to tell it to compile in
75:18 - c plus plus 20 mode we're going to tell
75:21 - it to compile every single cpp file in
75:24 - this directory and then we're going to
75:26 - specify the output file name for our
75:28 - binary now this is code i used on
75:31 - windows i need to adapt it to be
75:33 - specific to linux
75:35 - so
75:36 - let's see what they say in the
75:37 - documentation there and we can
75:40 - we can scroll down a little bit and
75:42 - we're going to see that they use
75:44 - backslashes here so that's what we're
75:46 - going to use in visual video code to
75:47 - play it safe so we can say this
75:50 - a backslash and this is a backslash
75:53 - and we will try and build this and we're
75:56 - going to see what happens here this is
75:57 - going to build our project in c plus
76:00 - plus 20 mode we're going to be building
76:02 - every single cpp file in the project and
76:04 - the output will be called rooster this
76:07 - is what we want to do here let's save
76:09 - this up
76:10 - and i am going to close this json file
76:13 - and i will bring up my terminal by
76:15 - coming to view and save a terminal here
76:19 - and i can remove the main.exe file or
76:23 - the main executable i had in there if i
76:25 - do lsuc it's gone but now if we try and
76:28 - compile with the gcc compiler
76:31 - we're going to see what happens you see
76:33 - the world is good and we have a binary
76:35 - called rooster and we can run it here if
76:37 - we do rooster we're going to see it run
76:39 - and give us a zero and this is really
76:41 - all we need to do now we have this
76:43 - working for
76:45 - our gcc compiler but we wanted the same
76:48 - for a clanger compiler and we want the
76:50 - flexibility to be able to switch
76:52 - compilers by coming here and just
76:54 - selecting the right task so let's do
76:57 - this we're going to configure clan we're
76:59 - going to come to terminal we want to
77:01 - configure a task and we're going to
77:03 - choose the best we have in terms of
77:04 - clang that happens to be clang
77:07 - plus plus 12 here so we're going to
77:09 - choose this and this is going to add an
77:11 - entry in our
77:14 - tasks.json file we're going to change
77:16 - this to say that we want to build with
77:18 - clan let's do that we're going to say
77:21 - world with clang
77:23 - i think we have
77:26 - 12.0.1 if i remember correctly but we
77:29 - can ask
77:30 - our terminal here let's go to terminal
77:33 - and we're going to say clang plus plus
77:36 - and 12 that's the version and we're
77:37 - going to ask it what's your version it's
77:39 - going to tell us in detail and if we
77:42 - wait we're going to see this speed out
77:44 - on the terminal here and this happens to
77:47 - be clank version 1200
77:50 - so that's what we're going to say in our
77:52 - file here
77:53 - weld with clan 12 0 0
77:56 - to be super clear on this
78:00 - and uh this is really all all we need to
78:02 - do is put in the instructions
78:05 - to build in c plus plus 20 mod exactly
78:07 - what we did for gcc here so i am going
78:10 - to copy this and put that in my
78:14 - arguments here i'm i am going to take
78:16 - out whatever i had in there i am going
78:18 - to put in my new things and let's see if
78:20 - this compiler works now we're going to
78:23 - save our tasks.json file and come back
78:26 - to the cpp file we're going to bring up
78:28 - our terminal window
78:30 - and we're going to clear
78:33 - and remove rooster because we wanted to
78:35 - build a new one with our clank compiler
78:38 - and we will come to terminal run task
78:42 - now we're going to choose to build with
78:43 - clang 12.0 we're going to fix this in a
78:46 - minute but if we do this we're going to
78:48 - see that our weld process is going to
78:51 - start it's going to be building with our
78:53 - clan compiler it's going to be using c
78:55 - plus plus 20. it's going to be building
78:57 - every single cpp file in this location
79:00 - here and the output of the world will be
79:03 - a binary called rooster that we have
79:05 - right here so the build is good if we do
79:07 - ls we're going to find rooster and if we
79:09 - run it it's going to say zero exactly as
79:12 - we expect here and we have visual studio
79:15 - code properly configured to use our two
79:17 - compilers the client compiler and the
79:20 - gcc compiler let's come back to our
79:22 - configuration and change this to say
79:24 - 12.0.0
79:26 - to be super clear on the version we have
79:29 - we can close our json file here
79:32 - and come and try to build again if we do
79:35 - terminal and run task we will have our
79:38 - compiler here ignore all these things i
79:40 - think visual video code is going to give
79:42 - you duplicates but you can choose
79:44 - the version that says what you want and
79:47 - it is going to work so we're going to
79:48 - choose gcc oh we are saying gcc but we
79:52 - want clang here so let's say that we
79:54 - want to build with clan we're going to
79:56 - go to terminal
79:58 - and run task
79:59 - and we want clang
80:02 - 12.0.0 this is right here so we're going
80:05 - to select it
80:06 - and it's going to build successfully and
80:08 - we will have our binary here if we run
80:11 - it
80:11 - it is going to say zero and this is
80:13 - really what we need to do here so this
80:16 - is really all i had to share in this
80:17 - lecture showing you how you can
80:19 - configure
80:20 - visual studio code to compile using the
80:22 - compilers that we have installed another
80:24 - thing you can do to make your experience
80:26 - better is come back to view and select
80:30 - command palette here and you can do c
80:34 - and the c plus and edit the
80:36 - configurations through a user interface
80:39 - and if we do this you're going to see
80:40 - that this is going to create a cpp
80:42 - properties json file so this is where we
80:45 - can configure
80:46 - what kind of intelligence what kind of
80:48 - what kind of compiler is going to be
80:50 - used we can do all these things here so
80:53 - we're going to leave it to the default
80:55 - it's on our linux system it's going to
80:57 - be using gcc 11 which is the best we
80:59 - have
81:00 - in terms of gcc
81:02 - but uh one thing you should note in this
81:06 - course here is the c plus plus standard
81:08 - we wanted to use so we wanted to use z
81:10 - plus plus 20 and we want visual studio
81:13 - code to give us intellisense
81:16 - or
81:16 - format our main cpp file based on the c
81:19 - plus plus 20 standard year that's what
81:21 - we can achieve with this so once you
81:23 - have this and
81:24 - you can come and close this
81:27 - and if we go back to the main cpp file
81:29 - you see now
81:30 - that this is no longer flagged as a
81:33 - problem with squiggly lines visual
81:35 - studio code is properly understanding
81:37 - what is happening here and this is
81:39 - something you can do to make your
81:40 - experience a little bit better
81:42 - okay now that we have this project set
81:45 - up and ready on linux we're going to be
81:47 - reusing this as a template project every
81:50 - time we start something new on linux so
81:53 - every time we want to create a new
81:54 - project we will grab this entire folder
81:57 - so for example we will come to our
81:59 - terminal here and go up a little bit
82:03 - so cd and go up one level and if we do
82:06 - ls we're going to have our c plus plus
82:08 - 20 template project we will copy it and
82:11 - rename it to start a new project and
82:14 - that's going to give us all the
82:15 - configuration that we did we don't need
82:17 - to reconfigure the compilers or whatever
82:19 - it is going to work right out of the box
82:22 - and that's really what we did here we
82:25 - set up a template project that we will
82:27 - be reusing all over again in the course
82:30 - as we progress learning about c plus
82:32 - plus 20. i am going to stop here in this
82:35 - lecture the next one i am going to show
82:37 - you how you can set up a development
82:39 - environment on the mac os system
82:42 - go ahead and finish up here and meet me
82:45 - there
82:46 - in this video i am going to show you how
82:48 - to install c plus plus compiler on your
82:50 - mac os system and we have a bunch of
82:54 - options on the mac we can install the
82:56 - gcc compiler we can install the clang
82:59 - version
83:00 - of the apple company or we can install
83:03 - the clangle vm version all these are
83:05 - options and i will show you how to
83:07 - install these i don't have access to a
83:09 - mac device so i won't really be able to
83:12 - install xcode and show you but i think
83:14 - you can manage if you are using a mac
83:17 - system it is nothing complicated you
83:19 - just have to go to the apple store and
83:21 - click on xcode and it is going to
83:23 - install for a gcc and clang llvm i will
83:27 - show you how to do this using the
83:28 - homebrew package manager which is also
83:31 - going to make this super easy okay so
83:34 - let's head over to our browser and we
83:36 - have a good link here from digitalocean
83:39 - on how to install and use homobrew on a
83:42 - mac os system this is a really validated
83:45 - link you can see that right here and you
83:47 - can read up on this if you are using a
83:50 - mac system i am going to share the link
83:52 - here in the resources section of the
83:54 - course and to use this we will go
83:57 - through the mac os terminal and it is
84:00 - nothing complicated you can search for
84:01 - it and open it up and after you do this
84:04 - you will have to install the tools
84:07 - needed to build things on the mac os
84:10 - system and that's going to install xcode
84:12 - here so grab the command here and run it
84:15 - in your terminal and this is going to
84:18 - install everything you need and after
84:20 - you have this installed you're going to
84:22 - install home brew i do recommend coming
84:24 - up to the website here for homebrew and
84:29 - clicking on this copy icon here this is
84:32 - going to copy the entire thing and you
84:34 - can copy this
84:36 - and once you copy it it is going to give
84:38 - us a green tick here
84:40 - and you can go in the terminal on your
84:42 - mac os system i am using a linux
84:44 - terminal here and then you're going to
84:46 - paste this command in here and hit enter
84:49 - once you do that you will be prompted to
84:51 - put in the password it's going to tell
84:52 - you that it needs to install homebrew
84:54 - and you are basically going to wait for
84:56 - this to finish i have to warn you this
84:58 - is going to take some time even if you
85:00 - have a good internet connection this is
85:02 - going to take some time so be patient
85:04 - here when it's done it's going to tell
85:06 - you that it is finished and you will be
85:08 - ready to install the gcc compiler and
85:11 - the client llvm compiler through your
85:13 - homebrew installation here i am not
85:16 - going to click on this because
85:18 - i already have this installed on my
85:20 - linux system here let's go back to the
85:22 - link and see what they say next so after
85:24 - you paste that in it's going to install
85:27 - and after that you will see that
85:30 - homebrew is going to be installed on
85:32 - your system
85:33 - and uh
85:35 - you can use home brew to start
85:36 - installing and upgrading packages you
85:38 - can really read up on this but what i
85:41 - want you to see
85:42 - is that you can use home brew to install
85:44 - the gcc compiler and the clang ll vm
85:47 - compiler so if we come to the search
85:49 - here and say gcc homo
85:52 - broom we're going to find instructions
85:55 - on how to install this so all you need
85:57 - to do really is to say brew install gcc
86:00 - this is going to install the latest
86:02 - version of gcc on your mac
86:04 - if we come here and say llvm or clank
86:07 - let's say clan
86:09 - and
86:11 - we can find that right here llvm
86:15 - and it is going to give us instructions
86:17 - on how to install this and all you have
86:19 - to do
86:20 - is brew install llvm and this is going
86:22 - to install these two compilers on your
86:25 - mac system so once you do that you will
86:28 - have them stored somewhere let's go to
86:30 - the install link and we're going to see
86:33 - that homebrew is basically going to be
86:35 - installed into things in your user local
86:38 - directory on a mac device please tell me
86:41 - if this is true for your case and if you
86:43 - have a problem we'll try and go through
86:46 - that and fix that up so if you are on a
86:49 - mac i would really recommend going
86:51 - through this to install homebrew once
86:53 - you have that installed you will go
86:55 - through that to install both of the llvm
86:58 - compiler and the gcc compiler and that's
87:01 - going to give you the latest versions
87:03 - for these compilers to find out if they
87:05 - will installed you can go in your user
87:08 - local directory and you can hunt through
87:11 - these compilers and you're going to find
87:12 - binaries for them and start using them
87:15 - to build your c plus plus applications
87:17 - you okay so by now i am going to
87:19 - consider that you have both gcc and a
87:21 - clang installed on your mac system the
87:24 - next logical thing to do is to want the
87:27 - apple version of clang and i think
87:29 - that's going to come as part of xcode
87:31 - here
87:32 - and it is going to come as a result of
87:35 - running the command that we did before i
87:38 - think it was this little command here
87:40 - which is going to install everything you
87:41 - need from the
87:43 - xcode
87:44 - ide so this is all i have to share in
87:47 - this lecture again i apologize i don't
87:49 - have access to a mac device but if you
87:52 - have a problem you can tell me and i
87:53 - will try to help you out and get this
87:56 - sorted out
87:57 - we are going to stop here in this
87:59 - lecture the next one we're going to see
88:00 - how we can install xcode on your mac
88:03 - device go ahead and finish up here
88:06 - and meet me there
88:07 - in this video i am going to show you how
88:09 - to install the visual studio code editor
88:12 - on your mac os system please know that
88:15 - you can also use other ides like x code
88:17 - or code lite do c plus plus development
88:20 - but visual studio code is going to be
88:22 - our main editor in this course here and
88:25 - i would recommend to install it so that
88:27 - we are doing consistent things that's
88:29 - going to reduce chances for you to get
88:31 - confused so we are going to head over to
88:34 - the website for visual studio code
88:37 - and to get there we can just type visual
88:40 - studio code in here on in our search
88:43 - engine and we will have a link here that
88:45 - we can use to download our fans
88:47 - so we are going to go down and find
88:50 - download links for windows linux and mac
88:54 - please use the mac download button here
88:57 - and you're going to download the binary
88:58 - and install it i think it is going to be
89:01 - in the download folder by default so all
89:03 - you have to do
89:05 - is drag that up in your installation
89:07 - directory so that it becomes a runnable
89:10 - application after you do that you're
89:12 - going to run it and it is going to run
89:14 - and you will have a user interface like
89:17 - this with visual studio code opened up
89:19 - once you have that up you will need to
89:21 - install the c plus plus extension and
89:24 - what you need to do is come to the
89:26 - extensions tab here and type c and c
89:28 - plus plus in here and you're going to
89:30 - have an entry for microsoft click on
89:33 - that and install this extension on your
89:35 - system and your visual studio code
89:38 - instance is going to be ready to handle
89:40 - some c plus plus development and this is
89:43 - really all i had to share in this
89:44 - lecture showing you how you can get this
89:46 - installed again i apologize i don't have
89:49 - access to a mac device so i used my
89:51 - linux box running inside window
89:54 - subsystem for linux to show you this but
89:56 - this is good enough i think if you have
89:58 - a problem you can tell me and i will do
90:00 - the best i can to help you out for now
90:03 - we're going to stop here in this lecture
90:05 - in the next one i will try and show you
90:07 - how to set up a visual studio code to
90:09 - use the compilers that we installed in
90:12 - the last lecture
90:13 - go ahead and finish up here and meet me
90:15 - there
90:17 - in this lecture i am going to try and
90:19 - show you how to configure visual studio
90:21 - code to use the compilers that we
90:24 - installed on our mac system in a
90:26 - previous lecture so we want visual
90:28 - studio code to be able to pick up our
90:30 - gcc compiler and use it we want it to
90:33 - pick up our client compiler and use it
90:35 - we also wanted to pick up our clanger
90:37 - compiler from apple and use it to build
90:40 - binaries that we can then run on our
90:43 - system here so let's see how to do this
90:46 - i have to say i don't own a mac device
90:48 - so the best i can do here is describe
90:51 - the process to you and if you have a
90:53 - problem you can tell me i will do the
90:54 - best i can to help you out okay so once
90:57 - you have visual studio code installed
90:59 - you're going to create a folder
91:01 - somewhere and open visual studio code
91:03 - from that folder and what you will
91:06 - basically do is use the terminal to
91:08 - navigate to a location you're going to
91:10 - create a folder you can even call it cpp
91:12 - template project you're going to hop
91:14 - over into that folder and then open
91:17 - visual studio code from that folder here
91:19 - so for example we can hop over into cpp
91:23 - and run code and say dot that's going to
91:26 - open visual studio code in that folder
91:29 - and from that folder you will create a
91:31 - main cpp file by clicking on the plus
91:34 - button here and you will create the cpp
91:36 - file call it main cpp and you can put in
91:39 - the content here and once you have this
91:42 - the next task is going to be to set up a
91:45 - compiler to build this little thing so
91:48 - once you have this project you will come
91:50 - to terminal i think there's going to be
91:52 - a terminal menu somewhere and you will
91:55 - choose configure tasks once you do that
91:58 - visual studio code is smart enough to
92:00 - scan your system and find any compiler
92:03 - you have installed the first thing that
92:05 - is likely to be found is the apple
92:07 - client compiler so you're going to find
92:09 - a clone
92:10 - plus plus compiler so you can choose
92:12 - that and you can use that for the apple
92:15 - client compiler we are lucky we even
92:18 - have a tutorial on how to do that so if
92:20 - we click on our extensions tab here and
92:23 - choose our c and c plus plus
92:25 - extension
92:26 - if we scroll down we're going to see a
92:28 - link on using the client on mac os here
92:32 - this is going to give us all the
92:33 - instructions we need to use visual
92:36 - studio code with the client compiler
92:38 - from the apple company so if you scroll
92:41 - down you're going to be able to read up
92:43 - on all this but what i really want you
92:45 - to see is the configuration file you're
92:47 - going to see that it's going to be using
92:49 - the clang compiler from the user bin
92:51 - directory and this is mostly going to be
92:54 - the clang version from the apple company
92:57 - and sometimes you don't want this so if
93:00 - you want to use the clang version that
93:02 - we installed through home brew i think
93:04 - you will need to go through the user
93:07 - local directory because that's where
93:08 - homebrew is going to put it you're going
93:10 - to see that that's going to be the
93:12 - location here from our tutorial and
93:14 - you're going to hunt down for the clan
93:16 - compiler and find your binary and that's
93:19 - what we're going to be using next but
93:21 - for the first time if you want to use
93:23 - the clan compiler from apple this is the
93:26 - configuration you need and all you need
93:28 - to do in this case is change this to c
93:30 - plus plus 20.
93:32 - now once you have this configured you
93:34 - will have the ability to come to
93:35 - terminal let's show our files here you
93:38 - will have the ability to come to
93:40 - terminal and run task and choose the
93:42 - compiler that's going to be the clang
93:44 - compiler from apple but you can also
93:46 - configure other compilers and all you
93:48 - really have to do is choose them in the
93:50 - list here and you're going to have a
93:52 - configuration file it tasks
93:55 - json file to be exact let's show that up
93:58 - here
94:00 - and that's going to give you the
94:01 - instructions you need to build this
94:03 - and in most cases you will just need to
94:06 - be careful about the path to the
94:07 - compiler so for example if you are using
94:10 - the gcc version you installed through
94:12 - homo brew you're going to find that in
94:14 - your location you're going to make sure
94:17 - that's the correct one and you will put
94:19 - in these instructions here to tell your
94:22 - compiler to build every single cpp file
94:25 - in the directory here this is what we do
94:28 - if you use clan you're going to have
94:29 - something like this and again i am
94:32 - describing this to you because i don't
94:34 - have a mac available to me right now
94:36 - and if you have a problem you can tell
94:38 - me we can try and sort this out okay and
94:41 - by this time you will have the ability
94:44 - to use your visual studio code instance
94:46 - and compile
94:47 - c plus plus programs using either the
94:50 - apple client compiler the llvm glango
94:53 - compiler or the gcc compiler and all
94:55 - these are going to be compiling in c
94:57 - plus plus 20 mode again to both you need
94:59 - to make sure you have the file selected
95:02 - and choose whatever compiler you want to
95:03 - use for example if you want to use clone
95:05 - 12 from homebrew you're going to you're
95:08 - going to select that and it is going to
95:09 - be used to build your project and you
95:12 - will have the ability to run your
95:13 - projects just like we do here and it is
95:16 - going to work let's make sure we are
95:18 - running rooster here our binary
95:20 - and it is going to run and printer 0 and
95:23 - this is going to work again i am really
95:25 - sorry i don't have a mac device
95:27 - available to me
95:28 - but this is what i have to work with now
95:31 - if you have a problem on a mac device
95:33 - please tell me i will do the best i can
95:35 - to help you out
95:38 - in this lecture we're going to explore
95:40 - the option to use online compilers if
95:43 - for whatever reason we can't install a
95:46 - radio compiler on our system and again
95:49 - the goal is to be able to turn the code
95:51 - we type into what looks like an ide
95:54 - into a compiler and get a binary that we
95:57 - can run and see the output of there are
96:00 - a few online compilers that are very
96:03 - popular within the c plus plus community
96:05 - one box is one of them there is also
96:08 - compiler explorer and kodiro but there
96:11 - may be other ones out there if you do
96:14 - research on your own we're going to go
96:16 - to the browser and actually check each
96:19 - of these out okay here we are in our
96:22 - browser here i am on onebox.org
96:25 - and you see that it really looks like an
96:27 - ide inside we have the code we've been
96:30 - running all along to make sure that it
96:32 - compiles with c plus plus 20. on the
96:36 - left here we have a few options we can
96:38 - select which compiler we want to use you
96:40 - see that there is a couple of gcc
96:42 - versions
96:43 - you can see that this is a really nice
96:45 - way to test things across
96:48 - gcc versions you see we have clan 12
96:51 - so if you want to test clang out you can
96:54 - select it let's actually try this
96:57 - so we're going to use clang head
97:00 - and try to compile this
97:02 - so let's hit enter and see if clank 12
97:06 - supports c plus plus 20
97:09 - and you see that it really works clan
97:11 - version 12
97:12 - should support c plus plus 20 like this
97:15 - let's go back to
97:17 - gcc because that's what i like and you
97:20 - can try putting different things in your
97:22 - c plus plus code to see if the compiler
97:25 - actually responds for example we can say
97:28 - stdcl
97:29 - hello there
97:31 - stdendl
97:33 - and if we run
97:35 - we're going to see
97:37 - the message output here another good
97:40 - thing with these online compilers is
97:42 - that you can share this code and anybody
97:45 - will be able to look at the code here
97:48 - and run it so this is a really good way
97:50 - to
97:51 - get help from your instructor so i do
97:55 - encourage you if you run into a problem
97:57 - come and use one of these compilers and
97:59 - send me the link the way you can send
98:01 - the link you can hit on share here this
98:04 - button here you're going to get the url
98:07 - that you can copy and send to anybody
98:09 - and they will be able to see your code
98:12 - just like we're going to see here in a
98:14 - minute okay you see that it isn't the
98:16 - exact same thing and anybody on the
98:18 - internet will be able to see your code
98:20 - and try to find whatever the problem is
98:22 - and help you out
98:24 - very fast one box is one compiler you
98:27 - can play with the options that we have
98:29 - here you can
98:31 - load different libraries you see they
98:33 - have a lot of boost libraries but this
98:35 - is of no interest to us right now you
98:38 - can play with it and see what you like
98:40 - about it another one is kaliru which is
98:42 - another online compiler you see it
98:44 - doesn't have a lot of options like we
98:47 - had in one box for example you cannot
98:49 - change the compiler it's going to be
98:51 - using g plus plus but if we hit compile
98:54 - link and run it's going to run our code
98:56 - and we're going to get the output here
98:58 - again we can try and change this so that
99:00 - you know i'm not lying to you so we can
99:02 - say stdcl
99:04 - and say the sky
99:07 - is blue
99:09 - std endl if you want you can hit control
99:12 - plus on your browser and it's going to
99:15 - make this a little bigger
99:17 - and if we compile link and run
99:21 - we should see the sky is blue in the
99:24 - output window here this is really all
99:26 - you can do with kolero and if you like
99:28 - it you can donate to the developers i
99:30 - think we have the same thing
99:32 - on one box but it is in japanese so i
99:36 - can't really read this
99:39 - okay another one is compiler explorer
99:42 - which is a really good one the main
99:44 - purpose of this is really not giving you
99:46 - the output it is actually seeing
99:49 - assembly code that is generated for your
99:52 - c plus plus code this is something a
99:54 - little bit advanced for our purposes
99:56 - here so we're going to ignore this we're
99:58 - just going to be using it to test our
100:01 - code with some of the popular compilers
100:04 - if you look here on this drop box you
100:07 - see that they also have a lot of
100:08 - compilers you can use different gcc
100:11 - compilers i think they have clan they
100:13 - even have msvc how cool is this so you
100:16 - can use a lot of compilers gcc clang you
100:20 - see we have a lot of clan compilers we
100:22 - have clang
100:23 - 11 here so this is a really good way to
100:26 - try things out we're going to come back
100:28 - to gcc
100:30 - 10 2
100:32 - and i noticed that i passed the flag of
100:35 - c plus 20 to be able to support c plus
100:38 - plus 20. again if i come here in my code
100:41 - and say stdc out
100:44 - the sky
100:45 - is white
100:46 - don't worry about these errors they're
100:48 - going to go away in a minute
100:51 - let's wait for the program to compile
100:53 - you see that it is compiling let's wait
100:55 - a minute the sky is white and everything
100:58 - is fine
100:59 - if you don't see this output here it is
101:01 - possible that you didn't check this
101:04 - checkbox run the compiled output
101:06 - so come to this
101:08 - dropbox and make sure this is checked
101:10 - and you should have a window like i have
101:13 - here compiler explorer also allows you
101:16 - to share your code with people on the
101:18 - internet
101:20 - let me see if i can find the option to
101:22 - share
101:24 - you come to this drop box and you get a
101:27 - link here that you can copy
101:30 - i'm going to copy this
101:33 - and open a private window in my browser
101:36 - here so that we know that it is some
101:38 - other
101:39 - browser that is going to be opening this
101:42 - link and getting access to the same code
101:44 - we have in compiler explorer and this is
101:47 - going to be pretty cool
101:48 - and you see that we get compiler
101:50 - explorer privacy we're going to close
101:52 - this
101:53 - and you see that we have the same code
101:55 - we can try modifying this code for
101:57 - example we can take out this third line
101:59 - here it's going to start compiling you
102:01 - see that it is compiling and it is going
102:03 - to give us the output that we expect
102:06 - from this so this is a really good tool
102:08 - to try out if you want to share your
102:11 - code with some people that are not close
102:14 - to you this is a really good way to do
102:16 - this it is also good to try out
102:18 - different compilers for example if you
102:21 - don't have a gcc compiler you can try it
102:24 - out here and see if it does things for
102:26 - example we didn't install clang on our
102:29 - system but we can try it out and see if
102:32 - it runs or could but make sure you pass
102:34 - the correct flats here because you are
102:37 - responsible for this if you pass the
102:39 - flats that don't work
102:41 - you're going to get arrows for example
102:43 - if we say hello here
102:46 - we're going to get
102:47 - weird arrows
102:49 - and oh and recognize command line option
102:52 - std hello but if we say c plus plus 20
102:57 - it is going to work so make sure you
102:59 - pass the correct options
103:01 - in this lecture you're going to write
103:03 - your first c plus 20 program and we're
103:06 - going to start and attempt to understand
103:08 - our program let's hop over to visual
103:10 - studio code and actually do that the
103:13 - first thing we want to do is to set up
103:15 - our code so that we can open that in
103:18 - visual studio code we're going to start
103:20 - from our c plus 20 template project that
103:24 - we set up in the last lecture
103:26 - and i'm going to be doing the projects
103:28 - for this chapter in this folder here so
103:31 - we're going to do our very first c plus
103:33 - plus program so what we're going to do
103:35 - is go inside our c plus plus 20 template
103:39 - project
103:40 - and i noticed that we actually left in
103:42 - the boiled files we don't want so
103:45 - what we're going to do is remove this
103:47 - main file
103:49 - and that this vc 140 fan we don't want
103:52 - these here
103:54 - and we're going to copy
103:55 - the main cpp file and the dot vs code
103:59 - folder we're going to copy these things
104:02 - and we're going to put them in our first
104:04 - c plus plus program folder
104:07 - and we're going to open this folder in
104:08 - visual studio code visual studio code is
104:11 - not opened up you see that i have my
104:14 - developer powershell opened if you want
104:17 - you can open visual studio code directly
104:19 - without going through this if you're not
104:21 - going to be using the visual studio
104:23 - compiler but i want to have the option
104:26 - to use that compiler so this is how i am
104:28 - going to open my visual studio code
104:30 - instance i am going to type
104:32 - code.exe
104:34 - to open this up i'm going to hit enter
104:37 - and visual studio code is going to open
104:39 - and it is going to open whatever we did
104:41 - in the last lecture we don't want this
104:44 - project because this is a template
104:46 - project from the last chapter we're
104:48 - going to close this folder go to file
104:51 - and hit
104:52 - close folder and we're going to open the
104:54 - new folder we want to work on we're
104:57 - going to go to file and hit open folder
105:00 - we're going to go to the location where
105:02 - our project is so you're going to go
105:04 - where yours is i'm going to browse to
105:06 - mine
105:07 - and i'm going to go in the current
105:08 - chapter and choose 3 2 first c plus plus
105:12 - program
105:14 - i'm going to select the folder
105:16 - it's going to open up and you're going
105:18 - to see that our settings from
105:20 - the last template project are still
105:24 - valid here they were copied over if we
105:27 - open the main cpp file it's going to be
105:29 - the main thing we had in the last
105:30 - lecture
105:31 - so
105:32 - we have the option to run task you're
105:34 - going to see that we have two compilers
105:37 - available and this is really good we are
105:39 - ready to start using this let's try and
105:42 - build this with gcc
105:45 - and we're going to have our binary
105:47 - created
105:48 - we can click in the terminal here
105:51 - and if we want to open the terminal
105:53 - again we have the option to come in
105:54 - terminal and new terminal this is going
105:57 - to open this up if we do dir in the
106:00 - terminal
106:01 - we're going to see our program generated
106:04 - we can remove this thing here and say rm
106:07 - rooster
106:08 - dot exe and remove this we can clear
106:13 - and we have a clean project we can start
106:15 - learning from okay now we have the
106:17 - project and it is building successfully
106:20 - let's try to understand the code we have
106:22 - in here the first statement we have it
106:25 - this include io stream thung
106:28 - this is a feature c plus plus offers to
106:31 - load the pro built libraries that we can
106:34 - use iostream is specifically going to
106:37 - help us print thanks to the console
106:39 - we've seen that we can for example print
106:42 - hello world
106:43 - if we want
106:44 - let's take out all these things in here
106:47 - and say std column column c out
106:51 - this is coming from i iostream and we're
106:54 - going to put two less than symbols we're
106:57 - going to open two quotes and inside
106:59 - we're going to type hello world
107:02 - and we're going to go outside the quotes
107:05 - and do two less than signs and say std
107:09 - colon colon endl
107:12 - and put a semicolon this is going to
107:14 - print things on the console if we run
107:16 - this program
107:18 - so if we run this program the first
107:21 - thing we need to do is to build this
107:23 - program so we can come to terminal task
107:26 - and we're going to build it with gcc and
107:29 - after we've built it we can hit enter to
107:32 - close the terminal
107:34 - and we can do dirt to see the content of
107:36 - the folder you see that a program has
107:38 - been generated we can run it and if we
107:41 - run it it's going to say hello world
107:43 - this message is coming from this
107:46 - statement here and we have this
107:48 - statement because we have included io
107:51 - stream to really make this super clear
107:54 - we can try to remove this line that says
107:57 - include io stream
107:59 - and the moment we do that you're going
108:00 - to see that this tab says we have
108:03 - problems
108:04 - and if you open this tab
108:07 - you're going to see the message
108:08 - namespace sdd has no member c out name
108:11 - space std has no member a and dl
108:14 - this is because
108:16 - the z plus plus program doesn't know
108:18 - what sddc out means because we don't
108:21 - have the library included and you also
108:23 - see that we have these squiggly lines to
108:25 - make it really clear that we have a
108:27 - problem so to really be able to use this
108:30 - we have to include a third party library
108:34 - that brings these features into our
108:36 - program and that's what the include
108:38 - statement here is really doing so let's
108:41 - bring this in
108:42 - and we're going to say i o stream again
108:46 - and let's wait and see that the problem
108:48 - goes away
108:50 - and the one thing you should really know
108:51 - is that we don't have a semicolon at the
108:54 - end of the io stream statement we don't
108:57 - need to put it there but many c
109:00 - plus plus statements need a semicolon at
109:03 - the end
109:04 - okay i think this really makes it clear
109:06 - what the include statement here is doing
109:09 - the other thing we have in our program
109:11 - is this ant main parenthesis
109:15 - curly braces thing
109:17 - this thing here is called the main
109:19 - function
109:20 - a function in c plus plus is a block of
109:23 - code that does a lot of things
109:26 - but the main function here is special
109:28 - because it is the starting point of your
109:31 - c plus plus program
109:33 - we also call the main function the entry
109:36 - point of the c plus plus program and
109:38 - what that means is that if you open the
109:41 - program the main function is going to be
109:43 - the very first thing that is going to
109:46 - run and the things are going to be
109:48 - executed in the main function in order
109:50 - so the statement on the top is going to
109:52 - run first and the statement after that
109:55 - until we hit the end of the function so
109:57 - this is what we mean here to really
109:59 - drive this home we can come here in our
110:02 - main function and say sdd
110:05 - number one
110:06 - and say sdd engl and by the way this e n
110:11 - d l statement is going to print a new
110:13 - line
110:14 - we're going to
110:16 - see it in effect in a moment let's
110:19 - actually take it out so that we can see
110:22 - its effect we're going to also do sddc
110:25 - out number two
110:28 - and what this is going to do
110:30 - is to print number one and number two on
110:33 - the terminal let's build this program
110:36 - and if you want to build the default
110:38 - task you can hit ctrl shift b for it to
110:42 - happen very fast but i am always going
110:44 - to come here so that it is really clear
110:47 - what i am doing a program should be
110:50 - generated now if we try to run it
110:53 - by typing
110:55 - rooster.exe and again we can hit
110:58 - the app arrow button on our keyboard so
111:01 - that's the last command that we run from
111:03 - this terminal runs and this is going to
111:05 - speed things up a little bit so if we
111:07 - run this program it should say number
111:10 - one and number two as you see here
111:13 - but these two things are cramped on one
111:16 - line and the reason is we are not
111:19 - printing new line characters after we
111:21 - print number one and number two and we
111:24 - can solve this problem by putting in two
111:28 - less than symbols and saying std column
111:31 - column e n d l
111:33 - this is going to put a new line
111:35 - character after number one we can build
111:38 - again
111:39 - for our new changes to tech effect
111:42 - after we do that we click on the
111:43 - terminal hit enter we hit the app arrow
111:46 - button if we run it's going to say
111:48 - number one and number two on two
111:51 - separate lines because we are printing a
111:54 - new line character after number one i
111:56 - really hope this makes sense
111:58 - please do take some time to play with us
112:00 - because if this is the first time you're
112:02 - doing this some things might not be
112:05 - clear and the best way to really make
112:08 - sense of this is to type code run it and
112:10 - see the effect of what you type by
112:13 - running your program so let's do this a
112:15 - couple of times we're going to do sdd
112:17 - endl
112:19 - after
112:20 - the statement for number two we're going
112:22 - to do stdc out
112:25 - number three
112:28 - and we're going to do stdeandl
112:32 - to really show the problem again we're
112:34 - going to take out
112:36 - stdendl on the number two line
112:39 - we are going to weld the build is going
112:41 - to be successful
112:43 - we're going to click in the terminal hit
112:45 - enter hit the app arrow button run the
112:48 - program again and you're going to see
112:50 - it's saying number one it's going on the
112:52 - new line printing number two but we not
112:55 - to jump into the new line from number
112:57 - two so number two and number three are
112:59 - going to be cramped on one line that's
113:02 - what we see here we can solve this again
113:04 - by putting in a new line after number
113:07 - two
113:08 - let's do std
113:10 - e and d l here
113:12 - and uh this should solve the problem
113:14 - again let's build we're going to run our
113:17 - build task the build is going to be
113:19 - successful we're going to hit the app
113:21 - arrow to run the program if we run it
113:23 - it's going to say number one number two
113:25 - and number three and this is really good
113:28 - now it should be clear that statements
113:31 - in the main function are run in order
113:34 - from top to bottom and that the program
113:36 - is going to end when it hits the end of
113:40 - this curly brace that includes our
113:43 - function we're going to have a chance to
113:45 - learn more about functions
113:47 - in detail later in the course but we are
113:50 - just getting started and we need to
113:52 - start somewhere so that's why we're
113:54 - doing this main function thing here
113:56 - another thing you can do is return from
113:59 - the main function and in many examples
114:02 - you will see people do return 0
114:05 - something like this
114:06 - and this is a way for the main function
114:09 - to send the message to the operating
114:12 - system if it's finished successfully or
114:15 - if there was some kind of problem
114:17 - we're not going to go into any more
114:19 - details about the main function because
114:21 - that's really
114:22 - too much for now we are just getting
114:25 - started we are trying to get a feel of
114:27 - how c plus works the main message here
114:30 - is really that you should be able to
114:33 - print things to the console using sddc
114:36 - out you should be able to print a new
114:38 - line after your message
114:40 - using sdd ndl this stdc out and
114:45 - stdendl thank come from the iostream
114:49 - library that we are including here
114:52 - if we don't include this library we're
114:53 - going to have problems because
114:56 - our surplus plus program is not going to
114:58 - know where they are coming from so we
115:00 - should really put this in if we want to
115:03 - use these features
115:04 - and we can return from a function to let
115:07 - the system know the operating system
115:10 - if the program finished up successfully
115:13 - or if there was some kind of problem and
115:16 - again this project is using the
115:18 - templates we've done before
115:20 - and this is really all we set out to do
115:22 - in this lecture trying to make sense of
115:25 - the main function in c plus plus to
115:27 - really practice these things i would
115:29 - challenge you to write a c plus plus
115:32 - program just like this that is going to
115:34 - print your name 10 times try to do that
115:37 - and if you have a problem please do ask
115:39 - me and i will do the best i can to help
115:42 - you out
115:43 - this is really all we set out to do in
115:44 - this lecture i hope you found it
115:46 - interesting we're going to stop here in
115:48 - this lecture in the next one we're going
115:49 - to start and learn about comments in c
115:52 - plus plus go ahead and finish up here
115:55 - and meet me there
115:56 - in this lecture we're going to learn
115:57 - about comments and c plus plus
116:00 - comments are the way to put some
116:02 - messages in your c plus plus chord that
116:05 - are really meant to be read by humans
116:08 - and one way we have to do comments in c
116:10 - plus plus is through this backslash
116:12 - backslash thing we have here this is
116:14 - going to comment out the line so the
116:17 - compiler is really not going to care
116:18 - about it it's going to think that it is
116:20 - something that is meant for the
116:22 - developer to see so this is a one line
116:24 - comment and this is how you do it in c
116:26 - plus plus you can also comment out a
116:29 - block of code in your c plus bus code
116:31 - and this is something that comes in
116:33 - quite handy many times you put your
116:35 - comment in a backslash star and a star
116:39 - backslash like this this is going to
116:41 - comment things out in your code and the
116:43 - compiler is really not going to care
116:45 - about this let's hop over to visual
116:47 - studio code and actually play with us so
116:50 - here we are in the folder that is going
116:52 - to contain our code the first thing i'm
116:54 - going to do is go through the template
116:55 - project i'm going to copy my files
116:58 - and i'm going to go up again and we're
117:00 - going to be learning about comments so
117:02 - i'm going to put this in the folder on
117:04 - comments i am going to close whatever
117:07 - folder we have opened in visual studio
117:09 - code and i'm going to browse to the
117:11 - location where my project on comment
117:14 - says
117:15 - my project is in this folder that is
117:17 - named three three comments i'm going to
117:20 - open the folder and if i open the main
117:22 - cpp file i'm going to find the starter
117:25 - project we're going to remove this const
117:27 - eval thank because we're really not
117:29 - ready to understand this yet it was in
117:31 - here to help us
117:33 - test that our compilers support c plus
117:36 - plus 20. so we're going to remove this
117:38 - and we're going to put in a message that
117:40 - says hello world you already know how to
117:42 - do that from the last lecture so we're
117:45 - going to say sddc out
117:47 - hello world and we're going to say
117:50 - stdendl and don't forget this semicolon
117:54 - at the end if you do you're going to
117:55 - have problems so make sure your code
117:58 - looks like this try to build it to make
118:00 - sure it's working fine this is going to
118:03 - run the gcc tasked world we can click on
118:07 - the terminal here and it's going to
118:09 - close the terminal
118:10 - and we can open a new terminal here if
118:13 - we want if we do dir we're going to find
118:16 - our rooster program inside we can run it
118:19 - and it's going to say hello world we
118:21 - already know to do this from the last
118:23 - lecture and in this one we are going to
118:25 - be learning about comments the first
118:28 - thing you can do is use slash slash so
118:31 - let's do that
118:32 - and uh let's put some message here this
118:36 - branch and the iostream library this is
118:40 - a nice message that is going to give
118:41 - some more information about this
118:44 - statement to whoever might be reading
118:46 - this program and this is called a one
118:48 - line comment you can really put this
118:50 - wherever you want in your c plus plus
118:52 - file we can go in the main function for
118:54 - example and say this is going to print
118:56 - hello world to the console or the
118:59 - terminal we can really put this anywhere
119:01 - we can even put it after the return
119:03 - statement here and really put in
119:06 - whatever piece of information we think
119:08 - is going to make sense to wherever it's
119:10 - going to be reading our program okay
119:13 - this is how you do a line comment you
119:16 - can also do comments across different
119:19 - lines and the way you do that you put
119:21 - that in the
119:23 - slash star and go down and say star
119:27 - slash like this and whatever is going to
119:29 - be in the middle here is going to be a
119:31 - comment this is usually called a block
119:33 - comment you can put in whatever you want
119:36 - so if you have a piece of text that you
119:38 - would like to use as a comment in your
119:40 - program this is one way you can do this
119:43 - one thing you should know though is that
119:46 - you cannot nest these things but before
119:48 - we do that let's try to build our
119:50 - program to really show that there is no
119:52 - problem if we have these comments in the
119:55 - world is successful and if we click on
119:58 - this terminal and hit enter
120:00 - and hit clear to clear things out in the
120:03 - terminal we can try to run our rooster
120:06 - program and it's going to say hello
120:08 - world you see that all these green lines
120:10 - which are comments are really not
120:12 - affecting the program all the compiler
120:15 - is going to care about is this include
120:17 - thing it's going to care about the main
120:19 - function here it's going to ignore these
120:21 - green things it's going to be like these
120:23 - green lines that are our comments are
120:26 - not in there this is the effect comments
120:28 - have in your program and we're going to
120:30 - be using this a lot in this course
120:32 - one thing you should know though is that
120:34 - you cannot nest these block comments so
120:38 - if you try to do something like this
120:40 - and uh say this is one comment and uh
120:44 - come again and say this is another
120:46 - comment you see that we have problems
120:48 - already nesting is not allowed you're
120:50 - going to get a compiler error and we're
120:52 - going to learn more about these errors
120:54 - in the next lecture but don't do this
120:56 - don't nest these block comments if you
120:58 - do that you're going to get some
121:00 - confusing errors and this is going to be
121:03 - the cause for them so don't nest your
121:06 - blog comments it's going to give you
121:08 - headaches okay this is really all we set
121:10 - out to do in this lecture learning about
121:12 - comments in c plus plus you can do one
121:15 - line comments on a single line like this
121:17 - you can do block comments to comment out
121:20 - a block of text you can't nest your blog
121:23 - comments because that's going to give
121:25 - you a lot of problems you don't want
121:27 - that and really use comments wisely and
121:31 - don't overdo it because it's going to
121:33 - turn your program into a novel and i
121:36 - don't think people want that so use this
121:38 - feature when you need it to give some
121:40 - more information about your code and
121:42 - don't overdo this we are going to stop
121:44 - here in this lecture the next one we're
121:46 - going to learn about different kinds of
121:48 - errors and warnings you can see in your
121:51 - c plus plus program
121:53 - go ahead and finish up here and meet me
121:55 - there in this lecture we're going to
121:57 - learn about errors and warnings in your
122:00 - c plus plus programs there are three
122:02 - kinds of errors or warnings you can get
122:05 - you can get compile time errors you can
122:08 - get runtime errors and you can get
122:10 - warnings but what is really meant by
122:13 - these things remember the ultimate goal
122:15 - of every developer or every c plus plus
122:19 - developer in our case here is to be able
122:22 - to generate a binary executable file
122:25 - from the c plus plus code and we have to
122:28 - run the code through the compiler to be
122:30 - able to do that and one thing you should
122:32 - know is that there is a set of
122:34 - requirements
122:36 - that the compiler enforces on our code
122:38 - for it to be able to compile
122:40 - successfully and those requirements are
122:43 - the rules really that we have to follow
122:45 - in our c plus plus program and if we
122:47 - break those rules we're going to get
122:49 - problems and these problems are going to
122:51 - come in the form of compile time errors
122:54 - run time errors or warnings
122:56 - let's look at compile time errors in
122:59 - detail
123:00 - here we have a simple c plus plus
123:02 - program that has a few problems we have
123:05 - forgotten to put the semicolon at the
123:08 - end of our stdc out statement here and
123:12 - the compiler is going to freak out
123:14 - because of this
123:15 - if we compile this program we're going
123:17 - to get a bunch of errors and the ide is
123:20 - going to show us this problem some ides
123:22 - are going to give you different errors
123:24 - for example here i was using codelite
123:27 - and it was saying
123:28 - error expected semicolon before return
123:31 - or something like this so this is a
123:33 - compiler error and if you have this kind
123:36 - of errors your program is not going to
123:38 - compile compilation is going to fail
123:41 - you're going to get this error and
123:42 - you're not going to get your binary
123:44 - executable and when you have this you
123:46 - basically have to go back and fix this
123:48 - problem compile again and when you get
123:51 - rid of these problems the compilation is
123:53 - going to succeed this is what a compile
123:56 - time error is another thing you can have
123:58 - is the run time error this is not going
124:01 - to cause a compile time error the
124:03 - compilation is going to succeed but when
124:06 - you run the program it's not going to do
124:08 - what you intended it to do in the first
124:11 - place for example you may want it to
124:13 - print green on some user interface it's
124:16 - going to print gray or whatever it's
124:18 - really not going to do what you want so
124:20 - it's a logical error that you have in
124:22 - your program and you have to fix it to
124:24 - get rid of this and another thing you
124:26 - should know is that sometimes these run
124:29 - time errors can cause your program to
124:32 - fail and terminate immediately and we
124:35 - say that the program has crashed we're
124:37 - going to see an example of this in a
124:38 - minute the last kind of problem you can
124:41 - have in your program is a warning
124:44 - this is a problem that is not serious
124:46 - enough for the compiler to halt your
124:49 - compilation compilation is going to
124:51 - succeed but this is basically the
124:53 - compiler telling you you are doing
124:55 - something that has some problems and you
124:58 - should really fix it before it becomes a
125:00 - serious problem so that's going to be a
125:02 - warning for example here you see some
125:05 - compilers can warn you when you divide
125:07 - stuff by zero and we're going to see how
125:10 - this works the main message in this
125:12 - lecture is that you may have problems in
125:14 - your program and they are going to come
125:16 - in three forms some are going to be
125:19 - compile time errors some are going to be
125:22 - run time errors some are going to be
125:24 - warnings we are going to hop over to
125:26 - visual studio code and actually play
125:28 - with this okay here i am in visual
125:31 - studio code the first thing i'm going to
125:34 - do is to set up
125:36 - the template project we're going to be
125:37 - using in our project here the project is
125:40 - going to leave in this folder errors and
125:42 - warnings i am going to copy over the
125:44 - files and i am going to go in the
125:47 - current project we're going to be
125:48 - working on and i am going to open this
125:51 - folder in visual studio code i am going
125:53 - to go to file close folder i am going to
125:56 - close this one and i am going to open
125:58 - our new project i am going to browse to
126:01 - it the project is this one i am going to
126:03 - select it and select folder and it is
126:06 - going to open up in visual studio code i
126:08 - am going to close this welcome screen
126:10 - and open our main cpp file we are going
126:13 - to get rid of this constable fan this is
126:15 - a c plus plus 20 test
126:18 - thing we had and we don't really need it
126:20 - now we're going to get there in due time
126:22 - what we want to see is compile time
126:25 - errors we're going to put in our stdc
126:28 - out statement hello world
126:31 - as we usually do
126:33 - we're going to end this stdndm and we're
126:36 - going to
126:37 - remove the semicolon on purpose and if
126:40 - we try to compile our program like this
126:42 - we're going to get a compile time error
126:44 - this is what we want to see so let's try
126:47 - and build our program we're going to run
126:49 - the task to build with gcc and you see
126:52 - that the world fails we're going to get
126:55 - a bunch of errors in our terminal it's
126:57 - going to say in function it main
127:00 - expected a semicolon before return it's
127:03 - going to try its best to tell you what
127:05 - the problem is but sometimes these
127:08 - errors can be really confusing in this
127:10 - case it is really easy because we
127:12 - introduced this error on purpose so
127:15 - we're going to fix it in a minute but
127:17 - before we do that i want you to see
127:19 - these problems tab it is where the
127:21 - problems are going to show up in visual
127:23 - studio code so you should see your
127:25 - problems in here or through the terminal
127:28 - here okay one thing you should know is
127:30 - that when you have a compiler arrow
127:32 - compilation is not going to succeed and
127:34 - you're not going to have your binary
127:36 - file which is what you really want so to
127:39 - fix this problem we're going to put in
127:41 - our semicolon here we're going to build
127:43 - again we're going to go to terminal run
127:46 - task we're going to build with gcc and
127:49 - this time you're going to see that
127:50 - compilation is going to succeed and we
127:53 - have our program here we can run it
127:55 - through the terminal here so we're going
127:57 - to click the terminal is going to go
127:58 - away but we can open our own
128:01 - and if we do dur we're going to see our
128:04 - files in here and we can run our program
128:06 - we can say rooster and if we run we're
128:09 - going to have hello world so i hope this
128:12 - really makes it very clear what a
128:14 - compile time error as so this is one
128:18 - kind of error you can get the other one
128:20 - is around time error and this comes in
128:23 - the form of things that don't work as
128:26 - you really expected so let's say we are
128:28 - trying to do some computation in our
128:31 - program
128:32 - we
128:33 - try to take 7 and divide this by 0 for
128:37 - example and this is a statement there is
128:39 - a load in c plus plus so let's try and
128:42 - build this and see what we get because
128:44 - this is a common scenario where we have
128:47 - run time errors we're going to run the
128:49 - task to build with gcc okay if we do
128:53 - this you see that world finished with
128:55 - warnings we didn't get a compile time
128:58 - arrow and our build was successful so to
129:01 - really prove this i'm going to
129:03 - go back in our directory i'm going to do
129:06 - dur you're going to see that rooster is
129:08 - there i'm going to remove it i'm going
129:10 - to say
129:12 - rooster.exe this is how we remove stuff
129:14 - from the command line when i do this and
129:17 - do dirt again the
129:19 - executable file should be gone so let's
129:21 - try and build with this statement and
129:24 - and you're going to see that we get a
129:25 - warning and not a compile time error
129:28 - like we had here so we're going to go to
129:30 - terminal run task we're going to build
129:33 - with gcc and you're going to see that
129:35 - we're going to have our executable here
129:37 - but we had a warning and it's saying
129:39 - that division by 0 was detected in our
129:42 - program and it is a recipe for disaster
129:45 - so why is it a disaster let's try and
129:48 - run this program so we're going to
129:51 - dirt to prove it's here and we're going
129:54 - to run it if we run it it's going to say
129:56 - hello world and it's going to end let's
129:59 - try and actually use our own terminal to
130:02 - see if we have a better chance of seeing
130:04 - the problem here so i'm going to reveal
130:06 - in explorer by clicking on main cpp and
130:10 - i am going to try and open a terminal
130:12 - window here powershell that we open
130:15 - ourselves we've done this before
130:17 - this shouldn't be new to you by now
130:20 - so we're going to do dirt in here
130:23 - and we're going to try and run the
130:24 - program and it's going to run so so it's
130:27 - not really giving us a run time error
130:30 - here because we're not capturing this or
130:33 - trying to use the result of this
130:35 - division here we're just doing the
130:36 - division which is a problem so let's try
130:38 - and capture this we haven't learned
130:40 - about variables yet but what we're going
130:43 - to do now is do end value and we're
130:46 - going to assign the result of this
130:48 - division to this value and let's try
130:51 - printing the result of dividing a number
130:54 - by zero so we're going to do stdc out
130:56 - and we're going to say value and this is
130:59 - how you can print a value out on the
131:02 - console okay now that we have this and
131:04 - let's try and weld we're going to run
131:06 - tasks and worldwide gcc we're going to
131:09 - get the same warning but if we try to
131:11 - run the program we're not going to get
131:13 - what we expect let's run rooster exe we
131:17 - expect it to say hello world and printed
131:19 - the value but you see that it's really
131:21 - struggling to print the value and it
131:23 - gave up and ended immediately so this is
131:26 - one example of a runtime error that you
131:29 - can face in your program there are many
131:31 - other kinds that we're going to see as
131:33 - we progress in the course
131:35 - here we are just trying to raise your
131:37 - awareness on these problems so that you
131:39 - can know how to fix them when they come
131:41 - up okay so this is all i can share with
131:44 - you now about runtime errors we also had
131:46 - a chance to see that this is also going
131:48 - to give you a warning and a visual
131:50 - studio code here is also helping out
131:52 - telling us that we may have a problem
131:55 - it's turning the main cpp file yellow
131:58 - and it's saying that there is one
131:59 - problem in this file and if you go here
132:02 - you're going to see that we have a
132:04 - warning here okay so this is one way you
132:06 - have to see this so this is not
132:08 - recommended to do so we're going to
132:09 - comment this out okay this is really all
132:12 - i had to share in this lecture we had a
132:14 - chance to look at compile time errors we
132:17 - also had a chance to look at warnings
132:19 - and run time errors using this example
132:21 - if you get a warning it is a message the
132:24 - compiler is giving you that you should
132:26 - really look it up and fix the problem
132:29 - before it becomes more serious compile
132:32 - time errors are going to cause your
132:34 - compilation to fail and that's a really
132:36 - good thing because the compiler is going
132:38 - to stop you from generating a binary
132:41 - that doesn't really do what you expect
132:43 - it to do so that's a good thing but
132:45 - sometimes the compiler want to give you
132:47 - a compile arrow and you have a chance to
132:50 - run into a runtime error and that's
132:52 - really bad so be careful about these
132:54 - things and when you have problems visual
132:57 - studio code is going to show you the
132:58 - problem in terminal or in this problems
133:01 - tab and you're going to be able to fix
133:03 - it up we're going to stop here in this
133:05 - lecture in the next one we're going to
133:06 - learn a little more about statements and
133:09 - functions go ahead and finish up here
133:11 - and meet me there in this lecture we're
133:13 - going to learn about a little more about
133:15 - statements and functions in c plus plus
133:18 - a statement is a basic unit of
133:21 - computation in c plus plus you can say
133:23 - that it is the smallest thing your cpu
133:26 - can execute in your program every c plus
133:30 - plus program is a collection of
133:32 - statements so you're going to have a
133:33 - bunch of statements that are organized
133:37 - in a certain way to achieve whatever it
133:39 - is you want and statements in c plus
133:42 - plus must end with the semicolon we saw
133:44 - in the last lecture that not putting
133:47 - that semicolon is going to result in a
133:49 - compile time error here is a basic
133:53 - sample c plus plus program that we're
133:55 - going to use to learn about statements
133:58 - in the main function here we have two
134:00 - variables declared we haven't really
134:03 - learned about variables but they are a
134:05 - way to store data in your program and
134:08 - here we are storing two decimal numbers
134:11 - one is called first number the second is
134:13 - called second number we can do something
134:16 - with these variables that we have in our
134:18 - program for example we can add them to
134:20 - have another variable in our program and
134:23 - we can print that so you see here we are
134:25 - saying stdc out the sum of two numbers
134:28 - is sum so this is going to print 21
134:31 - because it's going to add 12 and 9 and
134:34 - the result of that is going to be
134:36 - displayed on the terminal if we run this
134:39 - program what i really want you to notice
134:41 - is that this and first the number equals
134:44 - 12 thing is a statement in c plus plus
134:47 - so it must end with a semicolon the line
134:50 - here with second number is also a
134:52 - statement so it must end with a
134:55 - semicolon every single line we have here
134:58 - in the main function is really a
134:59 - statement and it must end with a
135:02 - semicolon if we don't put the semicolon
135:05 - in place we're going to get a compiler
135:07 - error okay one other thing that is
135:09 - really important to keep in mind is that
135:11 - statements are executed in order in your
135:14 - program and the order is from top to
135:17 - bottom if you go back to our program
135:19 - here so the first statement is the one
135:21 - with first number here 12 is going to be
135:24 - installed in memory when this statement
135:26 - is executed by your computer and we're
135:29 - going to go to the second statement with
135:31 - second number and we're going to keep
135:33 - going until we hit the end of the main
135:35 - function and the return statement is
135:38 - going to execute and when the main
135:40 - function returns or terminates we're
135:43 - going to get the return value sent to
135:45 - your operating system and it's going to
135:47 - know if your program ended successfully
135:50 - or with a problem and the operating
135:52 - system is going to know what to do with
135:54 - that information execution keeps going
135:57 - until we hit the end of the program or
135:59 - if there is any other condition causing
136:02 - for the program to terminate and we're
136:04 - going to have more details about these
136:05 - things later i just want you to know
136:08 - that the statements are executed in
136:10 - order in your main function another
136:12 - concept i really want you to have an
136:14 - idea about is the concept of functions a
136:18 - function is really like a machine you
136:20 - give it input and it's going to give you
136:22 - output if we look at the operation here
136:25 - to add first a number to second number
136:27 - we can consider first number and second
136:30 - number as input to the function and sum
136:33 - is the output of the function we can
136:35 - visualize that like this so we have a
136:37 - first number and the second number we
136:39 - pass that into our machine which is
136:42 - really a function and we're going to get
136:44 - the result of this function in a return
136:46 - value or something that we get out of
136:49 - the function as our result c plus plus
136:52 - has a special syntax we use to define
136:55 - functions this is our function to add
136:57 - numbers on the left we have an integer
137:00 - which is code name for a whole number in
137:03 - c plus plus it's a number without
137:05 - decimal points and it's a whole number
137:07 - after that we have the name of the
137:09 - function and we can name it whatever we
137:11 - want and after that we're going to have
137:13 - the list of parameters that we can pass
137:16 - to the function and this is going to
137:17 - work as the input to the function
137:20 - after you do that you're going to have a
137:22 - pair of curly braces the one is here the
137:26 - other is here to the end and within
137:28 - those curly braces it's going to be the
137:30 - body of the function inside the function
137:33 - you see that we are declaring a variable
137:35 - which is called sum
137:37 - and we are storing the sum of first
137:39 - number and second number in this
137:41 - variable
137:42 - and we are making this function return
137:45 - the sum as the result and we're going to
137:47 - be able to capture it if we call this
137:50 - function in a function like me you're
137:52 - going to see how this works in a minute
137:53 - a function must be defined before it's
137:56 - used so you can't really call a function
137:58 - you haven't defined first in your c plus
138:01 - plus program and here is a slightly
138:04 - complete program to really put all these
138:06 - ideas together we have our function to
138:09 - add numbers it takes two numbers first
138:11 - number and second number it's going to
138:14 - add them up and store the results and
138:16 - we're going to return some to be used by
138:19 - whoever called this function and if you
138:21 - look in our main program we have a
138:24 - statement here we're going to store the
138:27 - result of add numbers in the sum
138:30 - variable and we pass first number and
138:33 - second number in the function and we're
138:35 - going to have that result stored in here
138:37 - here we also call the function with
138:39 - direct numbers you see that we pass in
138:42 - 34 and the seven and we're going to
138:44 - print out the result here this is the
138:46 - basic idea i want you to have about
138:48 - functions they are reusable pieces of
138:51 - code that group together a bunch of
138:53 - statements to do whatever it is we
138:55 - wanted to do in that function one
138:58 - benefit about functions is that we can
139:00 - reuse the code here if you look here we
139:02 - are calling this function multiple times
139:05 - without really rewriting these
139:07 - statements that are inside the function
139:10 - i know some of these concepts might be
139:12 - cryptic to you right now we are going to
139:14 - go to visual studio code and try this in
139:17 - code and you're going to see exactly how
139:18 - this works okay here we are in our
139:21 - folder where we are storing our projects
139:24 - i am going to grab the code from the
139:26 - template project i am going to put that
139:28 - in the current project which is
139:30 - statements and functions i'm going to
139:33 - paste that in here and i am going to
139:35 - open this up in visual studio code i am
139:38 - going to close the project we have right
139:40 - now and i am going to open our new
139:43 - project let's browse to its location i
139:46 - am going to open the project on
139:48 - statements and functions let's open this
139:50 - folder in visual studio code and we're
139:52 - going to have our starter project here i
139:55 - am going to take out whatever we have in
139:57 - the main function and take out this
139:59 - contival thing we don't really need it
140:01 - and we are going to try and define two
140:03 - variables using two statements we are
140:05 - going to say and first number and we're
140:08 - going to put in a value let's say three
140:10 - and we have to remember to end this with
140:13 - a semicolon so this makes our statement
140:15 - we can encode this in a comment to make
140:18 - this pretty clear we're going to also
140:20 - define a second variable so we're going
140:22 - to say ent to
140:24 - mean that it is a whole number it
140:26 - doesn't have decimal points like 2.5 it
140:30 - is a whole number like one or seven or
140:32 - ten so we're going to say second number
140:34 - we can give it a name and uh let's put
140:37 - in a seven we're going to store these
140:39 - values in our program and we can print
140:42 - these values out let's print them out
140:44 - first so we're going to say stdc out we
140:47 - already know how to do that and we can
140:49 - say first number and we can change these
140:53 - output statements and say the first
140:55 - number is first number you can do that
140:58 - std endl and you can notice that visual
141:02 - studio code is really helping out in
141:04 - auto completing things we have in our
141:06 - program let's print the second number to
141:09 - really practice this so if we do std
141:12 - you're going to see that it's going to
141:13 - give us a bunch of options we can choose
141:15 - from if you want you can scroll through
141:18 - this with your mouse or you can just
141:20 - type whatever you want to type so i am
141:23 - going to do c out and it's going to try
141:25 - and help out if i really want i can come
141:28 - on c out here and click on it and it's
141:30 - going to be auto completed which is
141:32 - pretty cool so we're going to say second
141:34 - number and we're going to say second
141:36 - number here and it's going to auto
141:38 - complete for us
141:40 - endl and we can try and compile this
141:43 - program before we do i want you to guess
141:46 - what we're going to get when we run this
141:49 - program give it a guess we are then
141:51 - going to go to terminal run task and
141:53 - we're going to build this with gcc the
141:56 - world is going to be successful we're
141:58 - going to open this in our terminal the
142:00 - terminal goes away no problem we're
142:02 - going to open it again and we are going
142:04 - to go in our folder and do the ir and
142:08 - you're going to see that we have
142:09 - rooster.exe our program we can run it
142:12 - and it's going to say first number three
142:15 - and second number s7 this is what we
142:18 - have stored in these variables and the
142:20 - benefit of storing your data in
142:22 - variables is that you can change the
142:25 - variables and let the rest of your
142:27 - program really do the same things and
142:30 - pick up the data that you have in those
142:32 - variables for example we can put 13 in
142:35 - the first number
142:37 - and if we build again this number is
142:39 - going to be picked up by this code and
142:41 - we didn't need to go in and manually
142:43 - change data in these sddc out statements
142:46 - here let's weld so that we can see this
142:49 - and we can close this by clicking and if
142:53 - we run rooster again it's going to say
142:55 - 13 and 7. play with this a couple of
142:58 - times until you really feel confident
143:00 - and if you have any problem don't
143:02 - hesitate to ask me i am going to do the
143:04 - best i can to help you out
143:06 - now that we have these numbers stored in
143:09 - our program we can add them up let's say
143:12 - and some we're going to declare another
143:14 - variable and we're going to say it's
143:16 - equal to first number plus second number
143:20 - and we're going to end this with a
143:21 - semicolon and we're going to print the
143:23 - sum out
143:25 - let's do sddc out and we're going to say
143:28 - the sum is sum we're going to print our
143:30 - variable here and we're going to print a
143:33 - new line character with std endl we're
143:37 - going to build our program so that our
143:39 - changes are reflected in our binary here
143:42 - so we're going to go to terminal
143:44 - run task weld with gcc the build is
143:47 - going to be successful we're going to
143:49 - press any key we are going to click here
143:51 - in the terminal and we're going to hit
143:54 - enter and run rooster again and we
143:56 - should see the sum and you see it says
143:58 - the sum is 20 which is what we expect
144:02 - now we are doing the sum here but it
144:05 - would really be better if we're not
144:07 - doing the sum in the main function here
144:10 - what if we actually took this code and
144:13 - wrapped it in a function that we could
144:15 - reuse whatever we want we have seen how
144:18 - we can declare a function so let's do
144:20 - that we're going to follow the same
144:22 - structure we saw in the slides earlier
144:24 - so we're going to say and this is going
144:26 - to be the return value or what we get
144:29 - out of the function then we're going to
144:30 - put in the name of the function we're
144:32 - going to say add numbers and we're going
144:34 - to pass in the parameters the parameters
144:36 - can really have any name you want but
144:38 - you have to specify
144:40 - the type of the parameter first so the
144:43 - parameters are also going to be whole
144:45 - numbers like 1 5 7 or whatever you want
144:48 - and we're going to say first program
144:51 - and the second is going to also be a
144:53 - whole number an integer and it's going
144:55 - to be second
144:56 - param okay after we do this we're going
144:59 - to specify the body of the function
145:02 - which is going to be between these curly
145:04 - braces i am going to jump to the next
145:07 - line so that this is really easy to see
145:09 - so i am going to define our sum variable
145:12 - inside the function it's going to be a
145:14 - whole number and i can call it whatever
145:17 - i want so let's call it result because
145:20 - it's going to be the result of this
145:23 - function and the result is going to be
145:25 - the sum of first param and second param
145:28 - okay i hope this makes sense and we're
145:30 - going to end this with a semicolon
145:32 - because every statement in c plus plus
145:35 - has to end with the semicolon after we
145:37 - have the result
145:38 - we need to give it back to whoever
145:40 - called this function and we're going to
145:43 - do that with a return statement and
145:45 - we're going to return the result to
145:47 - whoever
145:48 - might have called this function here now
145:50 - that we have the function we can
145:52 - actually use it we're going to go back
145:54 - in our main function and what we're
145:56 - going to do
145:58 - is to reuse this sum variable and store
146:01 - in whatever is returned from our
146:04 - function the syntax for that is going to
146:06 - be sum
146:07 - and we're going to say equals and we're
146:09 - going to say add numbers and we can pass
146:12 - in whatever two numbers that we want to
146:14 - add up let's pass in 25
146:18 - and 7 for example
146:20 - we would expect this to give us 32
146:23 - so if we print the sum again we can just
146:27 - complete this statement
146:29 - that prints the sum and reuse it here
146:32 - let's align this a little bit and i want
146:34 - you to take a guess at what we are going
146:37 - to get from this program right now we
146:39 - have these two numbers we are adding
146:41 - them up if we get here this should print
146:44 - the first number which is going to be a
146:46 - 13 so here we expect to get 13 and by
146:50 - the time we hit this second number
146:52 - statement we are going to print the
146:54 - second number it's going to be 7. if we
146:57 - get here we're going to print whatever
146:59 - is stored in sum and in sum we have the
147:02 - sum of first number and second number so
147:05 - this should print 20 right and here we
147:08 - are doing another sum of two numbers but
147:11 - we are using a predefined function
147:14 - that we have here before the main
147:16 - function because you have to define the
147:19 - function before you use it okay if we
147:21 - add 25 and seven we are going to fall
147:24 - into this function and it's going to add
147:27 - those numbers up and we're going to get
147:28 - a 32 in here
147:30 - and that's what we're going to return
147:32 - and it is going to be saved in this
147:34 - variable if we print it out it's going
147:36 - to give us 32. i hope this makes sense
147:39 - let's build and run our program run task
147:42 - world with gcc the world is going to go
147:45 - fine we're going to go back to our
147:47 - terminal here that's clear so that
147:49 - things don't disturb us and uh bring in
147:52 - some confusion we're going to run our
147:54 - rooster program and exactly what we have
147:58 - here we have a 13 from the first
148:00 - statement here we have a 7 from this
148:03 - statement here we have a 20 from this
148:06 - sum here which is here and we have a 32
148:09 - that we got from this function the good
148:12 - thing about functions is that we can
148:13 - reuse them now that we know how to use
148:16 - it we can use it again and we can say
148:18 - sum equals
148:20 - add numbers and we can say 30 and
148:24 - 54 for example you add them up and
148:26 - you're going to get the results so we're
148:28 - going to print the result some and we're
148:30 - going to put in the sum i really want
148:33 - you to take some time and play with this
148:35 - statement so that these things make
148:37 - sense it's really not that difficult but
148:39 - you just have to rock your brains around
148:41 - how c plus plus defines these things so
148:44 - we have this statement and we are adding
148:47 - 30 and 54 so it should get an 84 after
148:51 - the 32 here let's weld we're going to
148:54 - run the task to world with gcc we're
148:57 - going to click on the terminal here and
148:59 - hit enter let's clear so that we don't
149:02 - have things disturbing us and we're
149:04 - going to run our program and we have our
149:07 - trusty 84 here i really hope this makes
149:10 - sense and as a bonus i'm going to show
149:12 - you that you can also call things
149:15 - in the stdc out statement here without
149:19 - having to store them in some predefined
149:21 - variables and sometimes this comes in
149:24 - handy so you can say std see out and
149:27 - we're going to say sum and you might say
149:31 - add numbers right in here and you're
149:33 - going to say 3 for example and uh 42 and
149:37 - this is going to give us a 45 that's
149:40 - what we should expect to see after 84
149:43 - here
149:44 - so that's world and running the task to
149:46 - build with gcc the world is going to be
149:49 - successful we click on the terminal here
149:51 - we hit enter so that we see our terminal
149:54 - with output we're going to clear so that
149:56 - we see our output without noise we're
149:59 - going to run our program and we're going
150:01 - to see a 45 here i really hope this
150:04 - makes sense the whole point of this
150:06 - lecture was to make you aware of
150:08 - statements and function a statement is
150:10 - the most basic unit in your c plus plus
150:13 - program it basically lives on one line
150:16 - but it can also spread across different
150:19 - lines but we're not going to look at
150:20 - that here maybe we're going to see that
150:22 - later in the course statements are
150:25 - executed in order so when our main
150:27 - function gets to be run by the computer
150:30 - it's going to go from the first
150:31 - statement second statement third
150:33 - statement and it's going to go until it
150:36 - hits the end and we can see that here in
150:39 - the order in which our numbers are
150:40 - printed it is going from top to bottom
150:43 - we have also seen that we can split our
150:46 - code in different functions and wrap
150:48 - whatever functionality we have in a
150:50 - function we have seen the basic concepts
150:52 - on functions a function has a return
150:54 - value it has a name and you have to give
150:57 - it the parameters and you put the body
151:00 - of your function within these two curly
151:02 - braces as an exercise i would challenge
151:05 - you to do a function that multiplies two
151:09 - numbers and call it in the main function
151:11 - here to see the result if you have any
151:14 - problem please do ask me i am going to
151:16 - do the best i can to help you out this
151:18 - covers all we set out to do in this
151:20 - lecture and i hope you found it
151:22 - interesting we're going to stop here in
151:24 - this lecture in the next one we're going
151:26 - to see how we can input and output
151:29 - things from our c plus plus program go
151:32 - ahead and finish up here and meet me
151:34 - there in this lecture we're going to
151:35 - learn about how we can get thanks in our
151:38 - program and get things out of our
151:41 - program and that's basically input and
151:43 - output to and from our program we have
151:46 - actually been doing this all along we
151:49 - have been printing things from our
151:51 - program to the console
151:52 - and with this technique you can really
151:55 - think of stdc out
151:57 - as a highway that goes from your program
152:01 - to the terminal you can basically think
152:02 - of it like this data is going from your
152:05 - program to sddc out and it's going from
152:08 - here to the terminal and from this you
152:10 - might get an idea why these
152:13 - less than signs kind of point to the
152:16 - left because data is going from your
152:18 - program to htdc out and these two
152:22 - symbols point to the left they point to
152:25 - hddc out to signal to the fact that data
152:29 - is going from here to here i really hope
152:33 - this makes sense because sometimes these
152:35 - things can confuse people this is the
152:37 - reason why it's going from your data to
152:41 - stdc out data is basically going from
152:43 - your program into httc out and the sddc
152:47 - out is one way we have to get data from
152:50 - our program to the console there are
152:52 - many others we have std c e r r or std
152:57 - server this is what i'd like to call it
152:59 - and what it does it prints errors to the
153:02 - console we have stdc log which is going
153:05 - to print log messages why do we have
153:08 - these different things different
153:09 - programs might decide to format these
153:12 - messages differently because they are
153:14 - different messages one is a simple
153:17 - message from the program another is the
153:19 - narrows you might want to turn this red
153:22 - to really bring the attention
153:24 - to this message because the user has to
153:26 - solve that problem another might be a
153:28 - log message that you want to store in
153:30 - some file or some database
153:33 - uses for these things differ and c plus
153:35 - plus makes sure to give you different
153:37 - ways to state your intent through the
153:40 - tools that you use we have looked at
153:42 - sddc out sddc error and stdc log what
153:47 - does sd c i n do it does the reverse
153:51 - it's going to take data out of the
153:53 - program and bring that into the program
153:56 - so let's look at a few examples using
153:58 - these here we have an example of
154:01 - printing data from the program to the
154:04 - terminal through c out
154:06 - cr and c log
154:08 - here we have a hello world message going
154:10 - to c out
154:12 - here we have a number going to c out
154:15 - this is what we've been doing all along
154:17 - we can also do a variable storing the
154:20 - edge for example it's a whole number
154:22 - it's an integer
154:23 - so we print this out and the message is
154:26 - going to go from the program to cl so
154:30 - you can think that things are going from
154:32 - the program to sddc out i really wanted
154:35 - this to make sense okay if we go down
154:37 - we're going to see that we can use cr to
154:40 - print errors to the terminal and we
154:42 - might say something went wrong or
154:45 - something along these lines to bring the
154:47 - attention to the problem and we can use
154:50 - c log to print log messages and they
154:53 - work the same way they all use the
154:55 - stream output operator and it is going
154:58 - to take data from the program to
155:01 - the output stream really this is what we
155:03 - mean here here is an example of how you
155:05 - might read data and bring that into the
155:08 - program here we have two variables one
155:10 - is the age it's a whole number or an
155:12 - integer and z plus plus and the other is
155:15 - a string this is a type that allows you
155:18 - to store strings in c plus plus we're
155:20 - going to learn a little more about this
155:22 - later but here i want to use it to
155:25 - really make it clear that you can get
155:27 - things from the outside and bring that
155:29 - data in your program so we're going to
155:31 - let the user type in the last name and
155:34 - this statement here with cin
155:37 - is getting data from the stream or from
155:40 - the highway through which data comes
155:43 - into our program and bringing that in
155:45 - our program and here it should be clear
155:48 - that the flow of data is in this
155:51 - direction data is going from c i n and
155:54 - we're storing that in a variable that we
155:56 - have in our program that is called name
155:59 - we do the same thing and ask the user to
156:01 - print the age and they are going to
156:03 - print that and the data is going to come
156:06 - from cin and we're going to store that
156:09 - in our edge variable here after we
156:11 - collect the data from the user we're
156:13 - going to print that and we're going to
156:14 - say hello we're going to print the name
156:16 - and we're going to say they are whatever
156:18 - years old this is what this program does
156:21 - and i really hope it makes it clear
156:24 - how data input works through streams in
156:27 - surplus plus another thing we can do
156:29 - with
156:30 - sddcin is chaining input and we can use
156:34 - this technique to grab data in one
156:37 - statement look at the program down here
156:39 - to really understand this we have the
156:41 - same variables age and name we let the
156:43 - user type in the last name and age
156:45 - separated by spaces
156:47 - and we grab the data like this we first
156:50 - grab the name after that we grab the age
156:53 - and we're going to print the same things
156:55 - and we can chain
156:57 - input stream operators like this to grab
157:00 - the data in one go and this may come in
157:02 - handy sometimes
157:04 - before we try these things in visual
157:06 - studio code i want to bring your
157:08 - attention to a problem that you are
157:10 - likely to come in contact with and that
157:13 - is reading data with spaces what if the
157:16 - user types the name
157:19 - with spaces for example you asked me to
157:21 - type my name i'm not going to type
157:23 - daniel i'm going to type daniel cafwaya
157:26 - and your program is going to run into
157:28 - problems c plus plus allows to solve
157:30 - this problem using std get line and you
157:34 - use it
157:35 - using this syntax you're going to pass
157:37 - in the stream where the data is going to
157:39 - go and you're going to pass in the
157:41 - variable that is going to read the data
157:43 - and you're going to have this
157:45 - information stored correctly in your
157:47 - program this might be not making sense
157:50 - yet to you we're going to go to visual
157:52 - studio code and play with us and i am
157:55 - sure it is going to make sense okay here
157:57 - we are in visual studio code and we have
157:59 - our project where we're going to store
158:01 - our files data imported output we're
158:04 - going to copy code from our template
158:06 - project and we're going to put the data
158:08 - in and i am going to open this folder in
158:11 - visual studio code so let's close
158:13 - whatever we have now and i am going to
158:15 - open my folder let's browse there i am
158:18 - on this folder data input and output i
158:21 - am going to select that and the project
158:24 - is going to open up in visual studio
158:26 - code i am going to jump to my main
158:28 - function i am going to take out things
158:30 - we don't need and the first thing we're
158:32 - going to do is printing data we have
158:34 - really done this so we're going to
158:36 - practice this a little bit we can say
158:38 - stdc out
158:40 - and we can say hello c plus plus 20 why
158:44 - not and we're going to put an std
158:47 - endl at the end and remember our
158:50 - semicolon and here i want you to really
158:53 - put in your head that data is going from
158:56 - our program here to hddc out and sddc
159:01 - out is going to dump that on the
159:02 - terminal that's how this works you can
159:05 - also do a variable let's say ant
159:08 - age for example let's say 21 and end
159:11 - this with the semicolon and we can also
159:14 - print the h we can say sddc out
159:17 - and we can say
159:19 - age this is going to be sent to the
159:21 - output stream
159:23 - and we're going to do sdd and dl to add
159:26 - a
159:27 - new line character at the end and we can
159:30 - try and build this before the program
159:32 - gets more complicated let's go to
159:34 - terminal we're going to run the test
159:36 - world with gcc
159:38 - and if we hit enter on the terminal here
159:42 - the terminal is going to go away we're
159:44 - going to create a new one no big deal
159:47 - and uh if we do dir we're going to find
159:49 - our rooster program if we run it it's
159:52 - going to say hello c plus 20 and the age
159:56 - is going to be 21. we are successfully
159:59 - taking data from our program and
160:01 - printing that to the terminal this is
160:04 - pretty cool and you can think of sddc
160:06 - out as the highway that is really going
160:09 - to take your data from your program and
160:12 - bring that to sddc out like this
160:16 - we're also going to take the age it's
160:18 - going to go through sddc out and it's
160:20 - going to show up here you can think of
160:22 - this like this okay now that we have
160:24 - used sddc out we can use sddcr and sddc
160:29 - log in the same way so we're going to
160:31 - say sddcr
160:34 - i'm going to say error message and the
160:36 - message is going to be something is
160:38 - wrong you may do whatever you want in
160:41 - here and we have to remember to put a
160:43 - new line character otherwise data is
160:45 - going to be cramped on one line we can
160:48 - also use sddc log it really works the
160:51 - same way c log and we can say log
160:54 - message and we're going to say something
160:57 - happened
160:58 - and we remember to put std endl and our
161:03 - semicolon if we build this program you
161:05 - might guess what it's going to do it's
161:07 - going to print these things on the
161:09 - terminal
161:10 - but this might be
161:12 - useful
161:13 - to terminal programs that support
161:15 - features to format different messages
161:17 - directly the program is going to know
161:20 - that one message is a simple message the
161:22 - other is an arrow the other is a log
161:24 - message let's run our program
161:26 - but before we do that let's clear so
161:28 - that we don't have noise here we're
161:30 - going to run the program and it's going
161:32 - to say the error message and the log
161:34 - message here okay now what we're going
161:37 - to look at is how we can get data into
161:40 - our program and data is going to be
161:42 - going in a different direction
161:44 - it's going to be coming from the
161:46 - terminal and flowing into our program
161:49 - what we're going to do we're going to do
161:51 - ant age one this is a new variable so
161:54 - we're going to put in data and we're
161:57 - going to bring in a string library to
162:00 - allow our program to store strengths the
162:04 - way we're going to do that we're going
162:05 - to include
162:06 - strength this is how you do it in c plus
162:09 - plus we haven't really learned about
162:11 - this type it's a powerful type in c plus
162:13 - plus but we will get it there when we
162:15 - have more powerful tools to really
162:17 - understand it we are just getting
162:19 - started here so what we're going to do
162:21 - we're going to say std strength and
162:24 - we're going to say name
162:25 - and we're going to ask the user to print
162:28 - their name and age you already know how
162:30 - to do that so we're going to say please
162:33 - type your name and age and we're going
162:35 - to do stdndl on this and how we're going
162:38 - to get data in the program we're going
162:41 - to use
162:43 - stdcin and we're going to do std
162:46 - cim and data is going to be going from
162:50 - the stream to the program so the
162:53 - stream input operator here points to the
162:55 - right
162:56 - and the data is going to be going in the
162:59 - name variable because that's what
163:00 - they're going to be typing in first
163:02 - because that's what we told them to do
163:04 - so we're going to store the name
163:07 - and we're going to say
163:09 - stdcim data is going to be flowing from
163:12 - sddcin into our h1 variable okay now
163:17 - that the user has given us their
163:19 - information we can greet them with a
163:20 - personalized message we're going to say
163:23 - stdc out hello and we're going to put
163:26 - out their name and we're going to tell
163:29 - them you are and we're going to put the
163:31 - age
163:32 - one because that's what they're going to
163:34 - give us here and i'm going to say
163:37 - years
163:38 - and we're going to put an std endl here
163:41 - i'm going to grab this and pull this to
163:44 - the left so that we can see our entire
163:47 - program here that's helpful so what we
163:50 - are doing here we are getting data from
163:52 - the user and we are storing that in our
163:54 - variables and we are printing the
163:56 - message so that the user can see it i
163:58 - don't want the first things we did here
164:01 - to disturb us when we world and try this
164:04 - out so i am going to comment this out
164:07 - and comment the first block of code out
164:10 - using blog comments i think this is the
164:12 - first time we use this and uh this is
164:14 - going to be ignored by the compiler now
164:16 - and it is only going to consider this
164:18 - and this is going to be pretty cool
164:20 - let's go down a little bit here and i
164:22 - try to build the program we're going to
164:25 - run the task that welds with gcc and uh
164:28 - looks like the world is good we're going
164:31 - to hit enter and we're going to clear so
164:33 - that we are not disturbed by this we're
164:36 - going to run the program let's say
164:38 - rooster.exe
164:40 - it's going to ask me to type my name and
164:42 - age my name is daniel i'm going to type
164:44 - that hit enter it's going to want me to
164:47 - type my age
164:48 - so i am going to say
164:50 - 33 for example
164:53 - and it's going to tell me hello daniel
164:56 - you are 33 years old i put a slash here
164:59 - we can try and run it again so that i
165:02 - don't have to make that mistake again so
165:04 - daniel that's my name i hit enter i say
165:07 - 33
165:08 - and if i run
165:10 - it's going to say hello daniel you are
165:13 - 33 years old i really hope this brings
165:16 - the point home
165:17 - that
165:18 - stdcin is a highway
165:21 - that takes data from the terminal into
165:24 - your program so this is really what is
165:26 - happening here when i type daniel it's
165:28 - going to flow from the terminal and it's
165:30 - going to go into my variable which is
165:33 - name here and when i type the age it's
165:35 - going to go in my edge variable here and
165:38 - all these happening through
165:41 - in here okay one other thing we can do
165:44 - is
165:46 - grab the data and put that in our
165:48 - variables in one go so what we can do
165:51 - here is comment this out and we're going
165:53 - to do
165:54 - stdcin and we're going to put that in
165:57 - name and we're going to change these two
165:59 - things and put the other piece of data
166:02 - in h1 if you run the program it's going
166:05 - to work exactly the same way but we are
166:07 - grabbing the data in one line so let's
166:10 - weld to see this in action we're going
166:12 - to run the task that worlds with gcc
166:15 - we're going to click here and we're
166:16 - going to clear if we run rooster it's
166:18 - going to ask for the name and the age
166:21 - i'm going to put in daniel and i'm going
166:23 - to put my h and say 33 for example and
166:26 - it's going to do exactly the same thing
166:28 - but we have one compact line the last
166:30 - thing i want to show you in this lecture
166:32 - is how you can grab data with spaces
166:34 - because if i try to put in data with
166:37 - spaces here the program is going to fail
166:40 - miserably let me show you this i'm going
166:42 - to clear and i'm going to run rooster
166:44 - again and i'm going to say daniel i'm
166:47 - going to put in my full name and uh it's
166:50 - really not grabbing the second name and
166:52 - it didn't give me a chance to input my
166:55 - age and this is really bad
166:57 - so c plus plus provides a way to solve
166:59 - this using std get line so let's see
167:03 - what we are doing here and before we
167:04 - play with this we're going to comment
167:06 - out what we had here so that
167:08 - it doesn't disturb us in what we are
167:11 - about to do so let's come down here and
167:14 - say that we were doing data input this
167:16 - is helpful here and we're going to go
167:18 - down and grab data with spaces so i am
167:21 - going to set up another strength and
167:23 - this is going to store my full name
167:25 - that's what i'm going to say here and to
167:28 - grab it i'm going to tell the user to
167:30 - type in their full name and age so i am
167:33 - going to sddc out so the way i'm going
167:35 - to grab the data i'm going to do std get
167:38 - line you see that we have this function
167:40 - here and it's going to take an input
167:42 - stream so asd dcin is going to work and
167:45 - the second parameter is going to be the
167:47 - variable where this string data is going
167:49 - to be stored we're going to pass in our
167:51 - full name and this is going to work just
167:54 - fine and we're going to also grab the h
167:57 - using the same technique we've used
167:59 - before so we're going to say
168:01 - stdcin and we're going to store that in
168:04 - our h3 variable once we have the data we
168:07 - can greet our user using the same
168:10 - message we had before so i'm going to
168:12 - copy that if i can do that and i'm going
168:15 - to paste that here i'm going to bring
168:17 - this to the same location it's going to
168:19 - be full name here and it's going to say
168:21 - h3 and let's try and weld we're going to
168:25 - terminal run the task to bolt with gcc
168:28 - and we have a problem because we forgot
168:31 - our semicolon see how these problems
168:33 - might come to you uh-huh so we're going
168:35 - to put in our semicolon and another
168:38 - thing i really want you to see
168:41 - is that you can
168:42 - bring these things to the next line if
168:44 - they turn out too long like we see here
168:47 - so i can for example put this to the
168:49 - next line and it is going to work just
168:51 - fine so what i am going to do i'm going
168:53 - to try and weld again run task to build
168:56 - with gcc you see that the world is good
168:59 - we're going to
169:00 - bring in our terminal i'm going to clear
169:02 - so that we don't have noise here and
169:05 - we're going to run our program it's
169:07 - going to ask me to put in my full name
169:09 - i'm going to say daniel
169:11 - and it's going to want the age i'm going
169:13 - to say 33 and it's going to reach me
169:15 - hello daniel gaway you are 33 years old
169:18 - we are able to bring data with spaces
169:21 - into our program and this concludes what
169:24 - we had to say in this lecture i hope it
169:26 - made it very clear what these htd n and
169:30 - stdc out things are they are basically
169:33 - highways that take data out of your
169:36 - program or bring data into your program
169:38 - and the way you use them is what we've
169:40 - done here in this course i would
169:42 - encourage you to play with us a couple
169:44 - of times if this is the first time
169:45 - you're doing this we are going to stop
169:47 - here in this lecture in the next one
169:49 - we're going to try and recap on the c
169:51 - plus plus development workflow go ahead
169:54 - and finish up here and meet me there
169:57 - in this lecture we're going to explore
169:59 - the c plus plus execution model and show
170:02 - you a simplified version of the memory
170:04 - model of your c plus plus program here
170:08 - is how our program looks it is a simple
170:11 - program in our main function it is going
170:13 - to call a simple function that is going
170:15 - to add two numbers we have seen a
170:17 - program like this before and when we
170:19 - compile it it's going to be turned into
170:22 - a binary this black icon here represents
170:25 - the binary executable and it is not in
170:28 - the format
170:29 - that you can read with your eyes if we
170:31 - come back here to what we were doing in
170:34 - the last lecture we can see our rooster
170:36 - executable binary here if you try to
170:39 - open it here you're going to see that
170:41 - visual studio code is going to say the
170:43 - file is not displayed in the editor
170:45 - because it is either binary or uses an
170:48 - unsupported text encoding so it says i
170:52 - can't really say this because it's
170:53 - binary and it says do you want to open
170:55 - it anyway if i try to open it it's going
170:57 - to be just some gibberish because this
170:59 - is binary it is meant to be
171:02 - read by programs it is not meant to be
171:05 - by ides or text editors like visual
171:09 - studio code so this is the binary file
171:11 - we have here i tried to put a simplified
171:14 - version of this program to represent
171:16 - binary so that we can follow it up but
171:18 - it is not in the form that is readable
171:21 - by any human out there unless you are a
171:24 - machine so why is it in binary because
171:26 - binary format is easily understandable
171:29 - by your cpu and we're going to see how
171:31 - your program is loaded in memory and
171:34 - executed statement by statement by the
171:36 - cpu so that you can really understand
171:39 - this so here is a representation of your
171:41 - program here we have our how to drive
171:44 - and we have the program sitting
171:45 - somewhere on our hard drive in binary
171:48 - format and it's waiting to be run by you
171:52 - by double clicking on it or opening it
171:54 - in the terminal and on the left here we
171:56 - see a representation of the memory of
171:59 - our computer and when i say memory i
172:02 - mean random access memory i don't mean
172:05 - memory on your hard drive this should be
172:07 - really clear this is the random access
172:09 - memory of your computer that is running
172:12 - your programs very fast so when you
172:15 - double click on our program or if we
172:18 - open it in the terminal the binary file
172:20 - is going to be loaded up in memory and
172:23 - you see it in red here this is a
172:25 - representation of that and it is ready
172:27 - to be run by the cpu by the time the cpu
172:30 - says in the memory location it's going
172:32 - to know i have a program to run and the
172:34 - cpu is going to start running it
172:36 - statement by statement it is going to
172:38 - start by the top so it's going to see
172:40 - that it needs to allocate space to store
172:43 - our integer a it's going to allocate to
172:46 - that somewhere on the memory in yellow
172:48 - here you see a and it's going to see
172:50 - that it should store in a value of 10
172:53 - and it's going to do that you can see
172:55 - that here it's going to go to the next
172:57 - statement and the next statement tells
173:00 - it to allocate space for
173:02 - a value b and it's going to store in f5
173:06 - it's going to go to the next statement
173:08 - it's a variable called c it's going to
173:10 - allocate space for it but we didn't
173:12 - specify a value for c so what it's going
173:15 - to do is store in some junk value the
173:17 - value in there is really unspecified at
173:20 - the moment it's going to jump to the
173:22 - next statement and what it's going to do
173:25 - is print some things on the console and
173:27 - it is going to do that it's going to
173:29 - jump to the next statement and it is
173:31 - going to print statement 2 and here it
173:34 - is going to notice that it is going to
173:36 - call a function i don't know if you have
173:38 - noticed but the cpu has allocated a
173:40 - special memory location for our function
173:44 - the function doesn't leave with our code
173:46 - here or anywhere near the variables that
173:49 - we have here there might be a huge chunk
173:52 - of memory between these two or three
173:55 - things so the cpu knows that it is going
173:57 - to jump to another location it's going
174:00 - to ask itself if i jump to that location
174:02 - to run this function how am i going to
174:04 - come back and the cpu is smart enough to
174:07 - store the return address and that's what
174:10 - it's going to do it's going to say if i
174:12 - go to that function i want to come back
174:13 - to the address 6 and run whatever is
174:16 - after this address so it's going to
174:18 - store 6 and cpu memory and it's going to
174:21 - jump to the function it's going to take
174:23 - the first parameter as a and the second
174:25 - parameter as b so a is done the
174:28 - parameter 1 is going to be 10 it's going
174:30 - to take parameter 2 it's going to be 5
174:33 - because it is b here and in b we have a
174:35 - 5 and it is going to jump to the next
174:38 - statement in the function and it is
174:40 - going to add up parameter 1 and
174:42 - parameter 2. after it adds those things
174:45 - up it's going to return the result to c
174:48 - we can see that here okay that's what
174:50 - the cpu is going to do it's going to put
174:52 - the results in c and the result is a 15
174:55 - so we're going to write that in there
174:57 - and now that the function is really done
175:00 - it's going to come back to its address
175:01 - and it is going to jump to the next
175:03 - segment after that it is going to
175:06 - print three statement three it is going
175:09 - to jump through the next line and print
175:11 - statement four it's going to do that and
175:14 - by this time we have reached the end of
175:17 - our program and it is going to be popped
175:20 - off the memory and your program is
175:22 - basically going to end this is how your
175:24 - program is executed by your cpu and why
175:28 - am i showing you this because it is
175:30 - really good to have an idea of how
175:32 - memory is allocated and used by your
175:35 - program another good reason is that some
175:38 - c plus plus feature require you to have
175:40 - an understanding of a memory model like
175:42 - this to understand how they work for
175:44 - example you have seen that to call this
175:46 - function the program had to jump from
175:49 - address 6 to 30 and this is really heavy
175:53 - especially if you are running a simple
175:55 - function like we are doing here to add
175:57 - two numbers so the cpu can realize that
175:59 - and optimize this call to the function
176:02 - to an inline function and add these two
176:06 - numbers up right here at address six
176:08 - without jumping to this address here and
176:10 - this may come in handy and you need an
176:12 - understanding of this memory model to
176:14 - really understand these features this is
176:17 - just one example i am giving you you are
176:19 - going to reuse this model a lot in your
176:22 - career as a class plus developer and i
176:24 - thought it was a really good idea for
176:26 - you to understand it firsthand this is
176:29 - really all i had to share in this
176:30 - lecture i hope you found it interesting
176:33 - in the next one we're going to try and
176:34 - understand the difference between three
176:36 - key components of the c plus plus
176:38 - programming language go ahead and finish
176:41 - up here and meet me there in this
176:43 - lecture i want to highlight the
176:45 - differences between what we call a c
176:47 - plus plus core language feature or a
176:50 - standard library feature or an stl
176:53 - feature because these are terms that
176:55 - come up a lot if you happen to read some
176:57 - documentation about c plus plus a core
177:00 - feature is really a basic building block
177:03 - that makes up the c plus plus
177:05 - programming language you can think of it
177:08 - for example how you define variables the
177:10 - rules that govern how you can define and
177:13 - use a function in c plus plus the rules
177:16 - that say what you can do and not do with
177:18 - the basic features of c plus plus that's
177:21 - really what can be qualified as the core
177:24 - feature of the c plus plus programming
177:26 - language i don't know if that makes any
177:29 - sense if we come back in visual studio
177:31 - code we have a program we have used in
177:33 - the last few lectures for example these
177:35 - basic types that you use in c plus plus
177:38 - the rules that define how you can define
177:41 - a function for example if you put a
177:45 - an angle bracket here and try to compile
177:47 - this program it is not going to work
177:50 - because we have violated the rules of
177:53 - the c plus plus programs the basic rules
177:56 - that define how the c plus plus
177:59 - programming language works the basic
178:01 - types that are defined in the c plus
178:03 - plus programming language these little
178:05 - things make up the raw ingredients you
178:08 - use to make up a proper c plus plus
178:10 - programs and these little row components
178:14 - that you use to put together a c plus
178:16 - plus program are called core features
178:18 - you can
178:19 - think of them as the foundation on top
178:22 - of which we really build daily use c
178:25 - plus plus programs the standard library
178:28 - is a set of ready to use
178:31 - highly specialized components that we
178:34 - can easily use in our c plus plus
178:36 - programs and again coming back to our
178:38 - program in visual studio code iostream
178:41 - here is a standard library feature
178:44 - string here is a standard library thing
178:46 - we have in the c plus plus programming
178:49 - language and again the c plus plus
178:51 - standard library tries to provide highly
178:54 - specialized components that we can use
178:57 - in regular c plus plus programs when you
179:00 - use the c plus plus programming language
179:02 - you don't really want to extend the c
179:05 - plus plus programming language you want
179:08 - to use it to build something of your own
179:10 - and uh the standard library features are
179:13 - things you use to work on your programs
179:16 - very fast for example we have used sddc
179:18 - out without really going into the
179:20 - details of how the data is taken from
179:23 - this program to the terminal that's
179:25 - really advanced and probably complicated
179:27 - but it is wrapped into this reusable
179:30 - components and one of them is iostream
179:33 - and we can use it relatively easily in
179:36 - our c plus plus program okay i hope now
179:38 - you have a better idea of what the c
179:40 - plus plus standard library is now what
179:43 - is the stl the stl is really part of the
179:47 - c plus plus standard library but it is a
179:50 - collection of container types think of
179:53 - them as collections of things and we
179:56 - have a set of types that allow us to
179:58 - store collections we have algorithms or
180:02 - functions that work on these collections
180:04 - and we have specialized types that are
180:08 - called iterators that allow us to
180:10 - navigate through these containers
180:12 - potentially running these algorithms on
180:16 - each element in the collection this is
180:18 - probably not making sense by now but you
180:21 - can think of the stl as a highly
180:24 - specialized part of the c plus plus
180:26 - standard library and we're going to
180:28 - learn about many features of these
180:30 - things throughout the course but i want
180:32 - you to have a basic understanding
180:35 - between these three terms a core feature
180:37 - of the c plus plus programming language
180:40 - is standard library feature and the stl
180:43 - and i really hope this is clear to you
180:46 - by now in this chapter we're going to
180:48 - learn about variables and data types
180:51 - before we talk about variables and data
180:53 - types i would like to take a moment and
180:55 - recap on what we know by now
180:58 - and if you look at these cards many of
181:00 - these things should make sense now you
181:01 - know about the main function you know
181:03 - that it is the entry point of your
181:05 - program you know that your program is
181:07 - going to be made up of statements and
181:09 - statements and with a semicolon in c
181:12 - plus plus
181:13 - you know about functions errors warnings
181:15 - you now have an idea about how you can
181:18 - handle input and output from your
181:20 - program you can use comments you know
181:22 - about the memory model and the execution
181:25 - model that we talked about in the last
181:27 - lecture you know quite a lot now we have
181:29 - been using a program like this to do
181:31 - things in the last chapter but there is
181:34 - one thing that isn't really explained
181:36 - yet and that is this ant this end is a
181:39 - type that is predefined in c plus plus
181:42 - and c plus plus predefines many types
181:46 - here we have a couple of these types for
181:48 - you to see as examples it is one of them
181:51 - we have seen it a lot of times in the
181:53 - last chapter it is used to represent
181:56 - whole numbers like one two and three but
181:59 - we have others for example double and
182:02 - float are used to represent fractional
182:05 - numbers numbers that have decimal points
182:08 - for example 2.5 7.3 and numbers like
182:12 - that and we're going to see the
182:13 - difference between these two another one
182:15 - that is commonly used is char or car and
182:19 - it is used to represent characters in
182:22 - memory and you can store in characters
182:25 - like a b c and d and all the other
182:28 - characters you can really put in we have
182:30 - a bull which is a type that is going to
182:32 - store two possible states the only
182:35 - values you can really store in here are
182:37 - true or false and we're going to see how
182:39 - this works void is uh somewhat confusing
182:43 - because it represents a typeless type
182:46 - and it is really meaningful when we get
182:49 - to talk about functions in detail so
182:51 - we're going to learn more about the void
182:53 - type a little later in the course we
182:56 - also have the auto type which is really
182:59 - not a type it is a keyword you use in c
183:02 - plus plus to deduce other types and
183:04 - we're going to see how this works later
183:06 - in the course these are a few examples
183:09 - of types we can use in c plus plus and
183:12 - we are going to play with most of them
183:14 - in this chapter another thing i really
183:16 - want you to see is what does it mean to
183:19 - really put a 4 in a variable in your
183:21 - program everything you have in this
183:23 - program here is represented by ones and
183:26 - zeros in the computer's memory it really
183:29 - looks like this it's a bunch of ones and
183:31 - zeros in the ram of your computer and
183:34 - there must be a technique to make sense
183:36 - of this gibberish here and store data
183:39 - that makes sense to humans and the
183:41 - starting point is to group these ones
183:44 - and zeros into little chunks that we can
183:47 - manipulate each of these ones and zeros
183:49 - is called a bet so this zero here is a
183:52 - bit this one here is a bet and if we
183:55 - group eight beats together they are
183:57 - going to form what we call a byte okay
183:59 - if it makes sense you can group your
184:01 - bits in bytes or if it makes sense to
184:04 - group them in groups of 16 you can do
184:07 - that like we see here we're going to see
184:09 - a little more details about this in the
184:11 - next lecture okay here you see that if
184:13 - you really want you can treat each bit
184:16 - as a self-contained piece of data but
184:19 - this is really not very useful but there
184:21 - are some corner use cases for this okay
184:24 - now we really have two sides on the
184:26 - right we have data in the format that is
184:29 - really convenient and understandable by
184:32 - humans and on the left we have how data
184:35 - is represented in memory so there must
184:37 - be a way to transform between these two
184:40 - forms of data because humans can't
184:42 - really handle these ones and zeros well
184:44 - and we do the transformation between
184:47 - these two representations of data using
184:50 - number systems we have a few number
184:52 - systems available to us that we can use
184:55 - binary octal hexadecimal are a few
184:58 - examples and we're going to learn about
185:00 - them starting in the next lecture so go
185:02 - ahead and finish up here and meet me
185:04 - there in this lecture we're going to
185:06 - learn a little more about number systems
185:09 - number systems allow us to transform
185:11 - data from the form that is really
185:14 - convenient for humans in a form that is
185:16 - convenient for computers in these ones
185:19 - and zeros that you see on the left we
185:21 - can also use them to do the reverse go
185:23 - from ones and zeros and go in the format
185:26 - that is convenient to humans like this
185:28 - 22 or this steve name here to make sense
185:31 - of how these number systems work let's
185:33 - analyze the decimal system that we
185:36 - really use in daily life and that is
185:38 - usually called base 10. so if you look
185:41 - at this
185:43 - 2371 number here we can really split it
185:46 - in the form that you see to the right
185:48 - here if you try and take this expression
185:51 - we have on the right here and evaluate
185:53 - it you're going to get this number here
185:55 - 2 times 10 to the power of 3 this
185:58 - evaluates to 2000 and this one here is
186:01 - going to evaluate to 300 this one is
186:03 - going to evaluate to 70 and the last one
186:06 - is going to evaluate to one and if you
186:08 - add these things up you're going to end
186:11 - up with this number so this is how we
186:12 - can take a number and uh make up a base
186:16 - 10 representation of it we can do the
186:18 - same thing for 924 here or 47 here it
186:22 - really is basic math you don't need to
186:25 - have a lot of background in math to make
186:27 - sense of this so we're going to use this
186:30 - exact form and understand binary numbers
186:33 - if you look at what we have here we have
186:35 - a few binary numbers that are made up of
186:37 - ones and zeros that's why it's called
186:40 - binary because you can only have two
186:42 - states or zero or one in your numbers so
186:46 - we can really do the same thing we are
186:48 - in base two so instead of using a ten
186:51 - here we're going to be using a two but
186:53 - it is the same operations we really did
186:55 - if you take this and multiply and add
186:58 - these things up what you're going to end
187:00 - up is a base 10 representation of this
187:03 - number if we go in the middle here we
187:05 - have something we can easily do without
187:08 - using a calculator the expression on the
187:10 - left here is going to evaluate to
187:13 - zero because we are multiplying with
187:15 - zero the second one is going to be a two
187:18 - because we are taking one and
187:20 - multiplying this by two the others are
187:22 - going to be zeros but the last one is
187:24 - going to be 2 to the power of 4 which is
187:27 - 16 and we're going to add a 2 and this
187:30 - is going to evaluate to 18. we can
187:33 - actually bring up our calculator on
187:36 - windows 10 i think it can help in this a
187:38 - little bit we're going to bring it up
187:40 - and we want to put it in a programmer
187:44 - mode and we're going to go back on our
187:46 - slide and find our number which is one
187:48 - zero zero one zero so we're going to
187:51 - type it out one zero zero one zero in
187:55 - binary this is binary that we have typed
187:58 - here so let's clear this and do one zero
188:01 - zero one zero and you're going to see
188:04 - that in the decimal it is 18 which is
188:06 - what we came up by computing this in our
188:10 - brain let's try the one we had before
188:12 - that we couldn't really do in our brain
188:14 - we're going to say one zero zero one
188:16 - zero one let's do that we're going to
188:18 - clear one zero zero one zero one this is
188:22 - going to evaluate to 37 in decimal and
188:26 - you can use calculators like this to
188:28 - really do the transformations between
188:30 - these different number representations
188:33 - okay down below we have a one one one
188:35 - which is going to evaluate to a seven in
188:38 - base ten okay if we have three digits we
188:40 - can really represent numbers between
188:43 - zero and seven and you see a table here
188:45 - that is going to prove that zero zero
188:48 - zero is going to evaluate to zero in
188:50 - decimal zero zero one is going to be a
188:52 - one and if you go down to one one one
188:55 - that is going to evaluate to a seven you
188:57 - can try and use a calculator to prove
189:00 - this and really understand how this
189:02 - works if we use the three digits
189:05 - representation our numbers are going to
189:07 - look something like this in memory we're
189:09 - going to take the bits in memory and
189:11 - group them in groups of three and we are
189:14 - going to use binary to actually make
189:16 - sense of these numbers for example here
189:18 - on the left this is going to be a one
189:20 - the second one from the left is going to
189:22 - be a six and this is going to be a six
189:25 - as well this is going to be a zero this
189:27 - is going to be a three because we have
189:30 - one and two here we add those up we get
189:33 - a three if this doesn't make sense you
189:35 - can try and use a calculator you're
189:37 - going to see that it makes sense okay so
189:39 - what if we want to group our digits in
189:42 - groups of four we can do that and we're
189:45 - going to end up with something like this
189:47 - the values we can represent are going to
189:49 - go from 0 all the way to 15 and you can
189:52 - try and prove this using the calculator
189:55 - like we just did and it is going to look
189:58 - like this in memory so what we really
190:00 - are doing is grouping the bits in
190:03 - different sizes of data and we have a
190:06 - kind of formula that we can use to make
190:09 - sense of the data in memory for example
190:11 - on the left here we have zero one one
190:14 - zero if we go back to our table and
190:16 - defined zero one one zero this is a six
190:20 - and we're going to know that these four
190:21 - bits here are really storing s6 and
190:24 - there are ways you can manipulate this
190:27 - in your c plus plus program we're going
190:29 - to see that you can also use five digits
190:31 - and you're going to end up with
190:33 - something like this and the numbers are
190:35 - going to go from 0 all the way to 32 and
190:38 - this is how it's going to look in memory
190:40 - you can try and come up with what this
190:43 - represents in decimal i'm not going to
190:46 - tell you this but we can try and figure
190:48 - out the one on the left here so it is 0
190:51 - 1 1 0 1. if we go back we're going to
190:54 - come up to 0 1 1 0 1 which is a 13 here
190:59 - so this memory location these five bits
191:02 - represent a 17 number so if we want to
191:06 - kind of generalize what we have talked
191:08 - about in the last slides if you have one
191:11 - digit you can really represent two
191:14 - states zero and one if you have three
191:16 - digits you can represent numbers between
191:18 - zero and seven and you can go all the
191:20 - way down and if we generalize this in a
191:24 - mathematical formula we can say that if
191:27 - we have n digits we're going to be able
191:29 - to represent between 0 and 2 to the
191:31 - power of n minus 1. and if you try to
191:34 - plug in any number of digits you're
191:36 - going to see that this formula works
191:39 - okay so these are a few grouping of bits
191:43 - we have in practice we can use eight
191:45 - digits and we can represent numbers
191:47 - between zero and two 255 if we have 16
191:51 - bits we can represent this range if we
191:54 - have 32 bits we can
191:56 - represent this range if we have 64 bets
191:59 - we can really represent a really huge
192:02 - range i can't even say this number it's
192:04 - really bad okay now you should have a
192:06 - pretty good idea of the binary system
192:09 - and different representations we can use
192:12 - to make sense of binary numbers in a
192:16 - computer's memory the last thing i want
192:18 - you to see is what we call hexadecimal
192:21 - number system and it is a technique we
192:24 - use to shorten the length of how we
192:27 - represent a binary number in memory how
192:30 - does it work well we take our number and
192:32 - split it in groups of four bets and each
192:36 - group is assigned a symbol we can use to
192:38 - represent it if we have four zeros
192:41 - that's going to mean a zero in
192:43 - hexadecimal if we have zero zero zero
192:46 - one we're going to represent a one and
192:48 - you can see that if we go up to nine
192:51 - this is really similar to what we have
192:53 - in the decimal number system but once we
192:56 - hit 10 we're going to represent that
192:58 - with an a in hexadecimal 11 is going to
193:00 - be b 12 is going to be c 13 is going to
193:04 - be d 14 is going to be e and 15 is going
193:07 - to be f so how do we use this to
193:09 - represent binary numbers let's see an
193:11 - example here we have a huge number that
193:14 - we represent in memory it starts with
193:16 - zero and ends with the one here so the
193:18 - first thing we're going to do is to
193:20 - split this in groups of four and the one
193:23 - on the left is going to be a one one one
193:25 - one if we come back to our table here
193:28 - one one one one means f so we're going
193:30 - to represent this with an f if you go to
193:32 - the second group of four bets we have
193:35 - zero zero one one if we go back zero
193:39 - zero one one means three so we're going
193:42 - to have a three here i hope this makes
193:44 - sense and we're going to keep using the
193:46 - same transformations and we're going to
193:48 - come up with one f 0 3 e 6 and we can
193:52 - represent this binary number using these
193:55 - symbols you can see that we go from
193:57 - using 32 bits to using one two three
194:01 - four five six seven eight symbols to
194:03 - represent this and this is shorter and
194:06 - easily manipulable by humans and we use
194:09 - a zero x in front to mean that this is a
194:13 - hexadecimal number i really hope this
194:15 - makes sense so if we have numbers that
194:18 - don't really fit in groups of four we're
194:20 - going to go from the left and split this
194:23 - in groups of four and we're going to end
194:25 - up with a group on the left that doesn't
194:28 - really meet our requirements and what we
194:30 - can do is add the missing bits and make
194:34 - them zeros and we call this operation
194:36 - padding this is what you can do to
194:38 - really represent any number in
194:40 - hexadecimal if you don't have enough
194:42 - bits on the left we also have another
194:45 - system that is really not widely used
194:47 - today but i am mentioning it here for
194:51 - completeness it is called octal system
194:53 - it goes from zero all the way to seven
194:56 - and we can divide our binary number into
194:59 - groups of three and represent using
195:02 - these zeros and ones to shorten the
195:04 - length of the binary number we can
195:06 - really do the same thing we did with
195:07 - hexadecimal so we're going to take our
195:10 - binary number and divide this in groups
195:13 - of three the one on the left is going to
195:15 - evaluate to a 7 because it's 1 1 1 and
195:19 - one one one evaluates to seven in octal
195:22 - system the second one is also going to
195:23 - be a one one one the third one is going
195:26 - to be one zero zero if we go in our
195:29 - table it's going to be one zero zero
195:31 - it's going to be a four and you see we
195:33 - have a 4 here and you can do the same
195:35 - things until you have figured out the
195:37 - entire number here and you see on the
195:39 - left we are doing padding and adding a
195:42 - missing bit and making it to 0 so we are
195:44 - coming up with 0 0 1 and if we go back
195:48 - to our table here 0 0 1 is a 1 and
195:51 - that's what we put here so we're going
195:53 - to put this number here it's going to be
195:55 - 15 61 41 70 47 7 and we're going to add
195:59 - a zero in front to mean that this is a
196:03 - number represented in the octal system i
196:05 - really hope this makes sense okay so we
196:07 - have seen all these binary numbers and
196:10 - different number systems we can use to
196:12 - represent them but how do we use them in
196:15 - a c plus plus program well i'm glad you
196:18 - asked here is a simple example of how
196:20 - you can represent the number 15 through
196:23 - different number systems in c plus plus
196:26 - if you just say 15 like this it's going
196:28 - to be in decimal if you add a zero in
196:31 - front it's going to mean that the number
196:34 - is in octal system so this can be
196:37 - confusing sometimes if you do 0 17 it's
196:40 - not going to be 17. so if you say 0 17 c
196:43 - plus plus is going to interpret this
196:45 - number as if it is in octal system and
196:48 - it is going to turn this into 15. down
196:50 - here you see the same representation in
196:53 - hexadecimal we saw that you use a 0x in
196:56 - front to represent that it is in
196:58 - hexadecimal and this is going to be 15
197:01 - in memory and here we have
197:03 - representation in binary using zeros and
197:06 - ones and you use zero b in front like
197:09 - this i have to say that this was only
197:11 - possible since c plus plus 14. so if you
197:14 - are using an older standard of c plus
197:17 - plus you want to be able to represent
197:18 - binary like this and if we run this
197:21 - program it is going to print the same
197:22 - thing it is going to print 15 but we
197:25 - stored the number using different number
197:27 - systems let's go to visual studio code
197:30 - and try this out okay here we are in a
197:32 - folder i have on my system where i am
197:35 - going to be storing my projects for this
197:37 - chapter the first thing i am going to do
197:39 - is copy code from a template project i
197:42 - am going to go in and copy things over
197:45 - and i am going to put these in 4 2
197:48 - number systems i am going to open this
197:51 - folder in visual studio code so i am
197:53 - going to go to file close the folder we
197:55 - have now and i am going to open up a new
197:58 - one open folder and i am going to browse
198:01 - to the location of my project i am going
198:03 - to open this project here that says
198:05 - number systems we are going to get rid
198:08 - of the welcome screen and open our main
198:11 - cpp file we're going to get rid of this
198:13 - constival thing and clear everything we
198:16 - have in the main function here the first
198:19 - thing we want to do is to store an
198:21 - integer that is 15 and we're going to
198:23 - say and number one the exact same thing
198:26 - we had in the slides and we're going to
198:28 - store 15 in this variable here this is
198:31 - going to be represented in decimal and
198:33 - if we want to store the semi number in
198:36 - octo we saw that in our slides we could
198:39 - store this as 0 17. so let's do that
198:42 - we're going to say it number 2 and we're
198:45 - going to store in 0 17. this is not
198:48 - going to be 17 this is going to be a
198:51 - representation of a number in octo
198:54 - system so we're going to say that this
198:56 - is octo and we can represent the number
198:58 - in hexadecimal as well so we're going to
199:01 - say it number three and it is going to
199:04 - be
199:05 - 0x because it is hexadecimal and we're
199:08 - going to say zero f this is how we
199:10 - represent it you can use lowercase or
199:12 - uppercase it won't really matter let's
199:15 - use uppercase here and we can use binary
199:17 - because we are using c plus plus 20. so
199:19 - we're going to say and number four and
199:22 - we're going to store in a representation
199:24 - of 15 in binary and it happens to be
199:28 - four zeros and four ones and we have to
199:31 - prefix this with a zero b this is how it
199:35 - works so this is going to be in binary
199:37 - and if we print all these numbers up
199:40 - we're going to see let me not tell you
199:42 - this what do you think we'll see okay so
199:44 - i went ahead and typed this out what do
199:47 - you think we will see when we build and
199:50 - run this program before we do that we're
199:52 - going to open a terminal so that we see
199:54 - it here and we're going to go to
199:56 - terminal run task we're going to build
199:58 - with gcc let's wait and see if the world
200:01 - is successful world finished
200:03 - successfully we have a rooster program
200:05 - in here we're going to
200:07 - click somewhere in this terminal and our
200:10 - terminal is going to show up if we do
200:12 - dur you're going to see that our rooster
200:14 - program is here and if we run it i want
200:16 - you to take a moment and guess what
200:18 - we're going to see hmm number one 15
200:21 - number 215 in number 315 and number four
200:24 - 15. this is really the same number we
200:26 - are storing in these variables but we
200:28 - are using a different representation
200:31 - that is going to be convenient depending
200:33 - on whatever it is we are doing if it is
200:36 - more convenient to use binary we are
200:37 - going to use binary if it is more
200:39 - convenient use hexadecimal please do use
200:42 - hexadecimal but the representation of
200:45 - this number in memory is really going to
200:48 - be the same i really want you to take
200:50 - some time and let this sink in because
200:52 - you're going to see these things a lot
200:54 - of times in your career as a software
200:57 - developer so please do yourself a favor
201:00 - and make sure you really understand this
201:02 - okay this is really all we set up to do
201:04 - in this lecture trying to make sense of
201:06 - the binary numbers we have in memory and
201:08 - how we transform between them and
201:10 - different forms of data that is easily
201:13 - manipulable by humans all data is
201:16 - represented by a bunch of grouped cells
201:18 - of zeros and ones we have seen this as
201:21 - the range of your data grows so will be
201:23 - the number of digits you need to
201:25 - represent the data in memory we have
201:27 - seen that the hexadecimal system makes
201:29 - it a little easier for humans to handle
201:31 - streams of data in ones and zeros octo
201:34 - has the same goal as hexadecimal but
201:36 - it's almost no longer used in modern
201:39 - times i just mentioned it here for
201:41 - completeness we are going to stop here
201:44 - in this lecture in the next one we're
201:46 - going to look at integers in a little
201:48 - more detail so go ahead and finish up
201:50 - here and meet me there in this lecture
201:53 - we're going to learn a little more about
201:55 - integers in c plus plus integers are
201:58 - represented by ant and z plus plus it's
202:00 - what you see on the left here and they
202:03 - are used to store whole numbers things
202:06 - like 1 2 and 3. they typically occupy 4
202:09 - bytes or more in memory but in most
202:12 - times it's going to be 4 bytes so for
202:14 - example if you have a variable called
202:17 - age and it is an integer this is how
202:19 - it's most probably going to look in
202:21 - memory it's going to take four bytes and
202:23 - i really want to make it clear what a
202:25 - variable is it is a named piece of
202:28 - memory that you use to store specific
202:31 - types of data okay so here if we have a
202:34 - variable named age it is a named piece
202:37 - of memory edge is going to be the name
202:39 - of that piece of memory and we can store
202:42 - data in that memory it's going to look
202:44 - like this in memory but the value is
202:46 - going to be stored in here in binary
202:48 - format i really hope this makes sense a
202:51 - variable is a named piece of memory that
202:54 - we can use to store different kinds of
202:56 - data and okay now we're going to look at
202:58 - a few examples of how you can work with
203:01 - integers in your c plus program you can
203:04 - define a few variables here we have one
203:07 - that is going to store the number of
203:09 - elephants we have you can declare it
203:11 - like this and not put in a value and if
203:14 - you do it like this the compiler is just
203:17 - going to put in some garbage value that
203:19 - is really not meaningful for your
203:21 - program so you see the warning we have
203:24 - here as a comment the variable may
203:27 - contain random garbage value and this is
203:29 - something you need to be aware of
203:31 - another way we can define integers in
203:33 - our c plus plus program is this
203:36 - statement here that declares a variable
203:38 - called lion count it's going to
203:40 - initialize to zero if we use curly
203:43 - braces like this it's going to
203:44 - initialize to 0 by default we can also
203:47 - explicitly put in a value we can do the
203:49 - same with cat count and we can use these
203:52 - variables to do operations for example
203:55 - we can declare another variable and it
203:57 - is going to store the number of
204:00 - domesticated animals and we're going to
204:02 - add up the numbers for dogs and cats and
204:05 - we're going to store the result of that
204:07 - in our variable that is called
204:09 - domesticated animals this is something
204:11 - you can do another thing that can be
204:14 - problematic is trying to use variables
204:16 - that you haven't defined or declared in
204:19 - your program that is going to give you a
204:21 - compiler error and the compiler is
204:23 - basically going to say i don't know what
204:25 - doesn't exist one here is i don't know
204:27 - what this doesn't exist to is it is not
204:30 - defined anywhere in the program another
204:33 - thing you can do is try and store a
204:36 - fractional number in a variable that you
204:39 - declared as an integer and this is going
204:41 - to give you a warning because fractional
204:43 - numbers are usually bigger in size than
204:47 - integers and this is going to lose some
204:49 - of your data we don't really have enough
204:51 - tools to understand this now but we are
204:54 - going to understand this a little bit
204:55 - later in the course but this is
204:57 - something you can do you can take a
204:58 - fractional number and store that in an
205:01 - integer variable and we're going to do
205:03 - an example and see how this behaves with
205:06 - our compiler that is gcc10 okay here we
205:10 - have mostly used curly braces to
205:12 - initialize our variables but we can also
205:15 - use parenthesis and this is going to be
205:18 - usually referred to
205:20 - as functional variable initialization
205:23 - because we are using parenthesis and
205:25 - this is mostly going to do the same
205:26 - thing we saw in the last slide with
205:29 - curly braces but when we come to the
205:33 - example here where we are storing a
205:35 - fractional number this is going to
205:38 - silently chop off the data you have in a
205:41 - fractional number and turn that into an
205:43 - integer and this is called implicit
205:45 - conversions but if we go to the last
205:47 - example here where we are storing 2.9
205:50 - into an integer this is going to take
205:52 - this fractional number chop off the
205:54 - decimal point and only store 2 in this
205:57 - integer and this might not be what you
205:59 - want and it is going to happen silently
206:02 - so this is a really bad way to do this
206:04 - if you want to do something like this it
206:06 - is preferable to use curly braces
206:09 - because you are either going to get a
206:12 - warning that this is going to lose you
206:14 - data or you're going to get a compiler
206:16 - error and the compiler is going to
206:18 - completely stop you from doing this and
206:20 - again if any of this doesn't make any
206:22 - sense we're going to go in visual studio
206:25 - code play with us and see how the
206:27 - compiler behaves with these things we
206:29 - have another way we can initialize our
206:32 - variables in surplus plus we can use
206:34 - assignment and we have done this a
206:36 - couple of times in the course but this
206:39 - is something you can do and we are going
206:41 - to play with this in visual studio code
206:44 - in a minute and you're going to see how
206:45 - it works okay by now we have seen three
206:48 - ways we can initialize our integer
206:50 - variables we can use breast
206:53 - initialization which is basically using
206:55 - curly braces we can use functional
206:58 - notation which is using the parenthesis
207:01 - and we can use the assignment
207:03 - initialization which is what we have
207:05 - here another thing i really want you to
207:07 - see is that it is possible
207:09 - to query for the size of your variable
207:13 - here we are trying to print the size an
207:16 - integer is going to take on our
207:17 - operating system and compiler and if we
207:20 - try to run this on our compiler it's
207:22 - going to tell us exactly how much memory
207:25 - an integer occupies in our program we
207:28 - can either pass and explicitly like this
207:31 - or we can pass a variable name and it is
207:34 - going to work equally well okay ants are
207:36 - mostly going to take up four bytes in
207:38 - new memory so here we have a
207:40 - representation of three ants in memory
207:43 - if we go from this zero to this zero
207:45 - this is going to be exactly four bytes
207:48 - and this is how it may look in memory
207:50 - one other thing i haven't really talked
207:52 - about on purpose is that there are a few
207:55 - rules you have to follow to name your
207:57 - variables in c plus plus one of those
208:00 - rules is that a variable must start with
208:03 - a letter like a b c d up to z or an
208:06 - underscore you can't start a variable
208:08 - for example with a number that's going
208:10 - to be a problem after the first
208:13 - character in your variable name you can
208:15 - really put in anything you can put in
208:17 - numbers you can put in letters you can
208:20 - really put anything you want but the
208:22 - first one can't be a number variable
208:24 - names are also case sensitive so if you
208:27 - have a variable called bike account with
208:30 - the lowercase b
208:31 - and you have another one that starts
208:34 - with uppercase b
208:36 - these are going to be two different
208:38 - variables and uh you have to be aware of
208:40 - this no spaces or spatial characters are
208:44 - allowed in your variables you can use
208:46 - underscores but you can't use something
208:48 - like plus because that's going to be
208:50 - confusing to your compiler and these are
208:52 - a few rules you really need to be aware
208:54 - of and you're mostly going to be fine
208:57 - the general form for declaring and
209:00 - initializing your variable is what you
209:02 - see here you're going to pass the type
209:04 - in this case we have used and because we
209:07 - are learning about ants you're going to
209:09 - pass the variable name and you're going
209:11 - to put whatever it is you are
209:13 - initializing your variable with of
209:15 - course this is braced initialization
209:18 - because it is using curly braces but you
209:21 - can also use functional initialization
209:23 - or assignment initialization and it is
209:26 - going to work equally well okay now we
209:28 - have enough information to go in visual
209:31 - studio code and play with us okay here i
209:34 - am in my folder for the projects of this
209:37 - chapter i am going to hop over in my
209:40 - template project and copy the files that
209:43 - i need i am going to go up again
209:46 - and go on the project that is called
209:48 - integer types
209:50 - i am going to go in and paste in my
209:52 - files and i am going to open up this
209:55 - folder in visual studio code i am going
209:58 - to close the welcome screen here and
210:00 - open my main cpp file
210:02 - and i am going to do the usual take out
210:05 - the things we don't need to save on time
210:07 - i am going to put in a piece of code
210:10 - that i have lying on my drive and we're
210:13 - going to
210:14 - go through it to save on typing time i
210:17 - don't want you to suffer watching me
210:19 - type this the first thing we have is the
210:21 - elephant count this is a variable that
210:23 - is not initialized so this is going to
210:25 - contain garbage data it's not going to
210:28 - contain anything that is useful to us
210:30 - but some compilers are going to usefully
210:33 - put in a zero because that's a logical
210:35 - number to put in here if you didn't
210:37 - explicitly put a number in here the
210:40 - second one is using curly braces and
210:43 - this is going to automatically
210:45 - initialize to zero the third one is
210:47 - going to be explicitly initialized with
210:50 - the 10 and the cat count is going to be
210:53 - initialized with 15. you can try and
210:55 - print this out and see what you come up
210:58 - with after compiling this application
211:00 - another thing we have seen is that we
211:02 - can do something like this and put an
211:04 - expression into our curly braces and the
211:09 - value this evaluates to is going to
211:12 - initialize this domesticated animals
211:15 - variable and now you should know that
211:18 - this is probably going to take 4 bytes
211:20 - in memory because it is an integer
211:22 - this is really how c plus plus works
211:25 - each fundamental type has
211:28 - a size associated to it
211:31 - most times so integers is mostly going
211:34 - to be four bytes on your system and
211:36 - we're going to query this a little later
211:38 - in this video okay let's try and compile
211:41 - this program and see if it actually
211:44 - works we're going to start world and you
211:46 - see that the world is successful another
211:49 - thing we can do is try and use variables
211:51 - we haven't really declared in our
211:53 - program and you can guess what is going
211:55 - to happen if we try to do
211:57 - and new number for example and putin
212:01 - doesn't exist you know it's a number
212:03 - that doesn't exist the compiler is not
212:05 - going to know what this is because we
212:07 - didn't declare a variable called doesn't
212:10 - exist if you try to compile this you're
212:12 - going to get a problem you see that we
212:13 - have a problem before we even compile so
212:16 - visual studio code is this smart it can
212:19 - analyze our code before we compile it
212:22 - and give us hints to problems that might
212:24 - come up you see here it is saying
212:27 - doesn't exist isn't defined so if we try
212:30 - to compile this we're going to get an
212:32 - error that we expect it's going to say
212:34 - doesn't exist doesn't really exist i
212:36 - don't know what that is so you shouldn't
212:38 - really do that you shouldn't try to use
212:40 - variables you haven't declared this is
212:43 - braced initialization
212:45 - we can also do functional initialization
212:48 - as we have seen
212:50 - okay another thing we can do is store a
212:53 - fractional number in an empty variable
212:56 - and we're going to see what this does
212:57 - we're going to try and compile this code
212:59 - you see we have a 2.9 we're trying to
213:02 - store this in an integer if we try to
213:04 - compile this let's try and use gcc let's
213:07 - clear this let's bring up a terminal and
213:11 - try to build this we're going to try and
213:13 - run our gcc compiler on this program it
213:16 - is going to say errol narrowing a
213:19 - conversion of
213:21 - 2.899 from double to integer c plus plus
213:25 - 20 isn't even going to allow this so
213:28 - this is a good thing because you might
213:30 - think that you have a 2.9 and some
213:34 - compilers are going to chop this off and
213:36 - store a 2 instead so this is one of the
213:39 - safe things about this way of doing
213:42 - thanks so i am going to comment this out
213:44 - because otherwise our program wouldn't
213:46 - compile now that we know how to use
213:49 - these things we can try to print the
213:51 - values in here okay i am going to put in
213:54 - a piece of code i have lying around on
213:57 - my drive i am going to remove these
213:59 - spaces inside because it is annoying
214:01 - let's do this and if we try and build
214:04 - this program it should compile
214:06 - successfully and if we run it we should
214:08 - see our numbers we're going to go in our
214:11 - terminal here and do der and we're going
214:13 - to run rooster and we're going to see
214:15 - elephant count is one because this is a
214:19 - garbage value so it could really be
214:21 - anything
214:22 - lion count should be zero
214:24 - dog account should be 10
214:26 - cat count should be 15 it is what we
214:29 - have and a domesticated animal count is
214:32 - 25 because we have drug account
214:35 - and we add that to cat count and we're
214:38 - going to end up with 25. this is what we
214:41 - expect now that we know how to work with
214:43 - this we can also try and play with
214:45 - functional initialization before i put
214:48 - in my code i am going to comment all
214:50 - this out because i don't want this to
214:52 - disturb us as we work with our
214:55 - functional initialization code so i am
214:57 - going to comment all this out and go all
215:00 - the way down and put in my code for
215:02 - functional initialization
215:04 - and you see here we have a variable
215:06 - called ethel we initialize this to 5 we
215:09 - have orange count which is 10 we have
215:12 - fruit count
215:13 - and we have a bad initialization that is
215:16 - not going to work it doesn't exist 3 and
215:18 - doesn't exist 4 don't really exist so so
215:21 - this is going to give us a compiler
215:23 - error
215:24 - and if we do something like we do in
215:27 - narrowing the conversion function here
215:30 - this is mostly going to compile and this
215:32 - is going to chop off data and store a 2
215:36 - instead of the 2.9 this is something you
215:39 - should really be aware of and you see
215:41 - the comment here says information lost
215:43 - this is less safe than braced
215:46 - initializer because breast initializer
215:49 - is going to
215:50 - give you a compiler error if you try to
215:52 - do this and that's a good thing
215:54 - so we also try and print these out so i
215:57 - am going to tidy this up a little bit
216:00 - and i am going to try and compile this
216:02 - piece of code run task and world with
216:05 - gcc the world is going to pass through
216:08 - without a problem
216:09 - and if we do clear and run rooster we're
216:13 - going to see apple count is 5 which is
216:16 - what we have in here orange count is
216:18 - going to be 10 so this is right fruit
216:21 - count is going to be 15 because it is 5
216:24 - plus 10
216:25 - and what is really worrying is that
216:29 - narrowing conversion is 2 but we didn't
216:31 - store in a 2 we started in a 2.9
216:34 - and because an integer can really store
216:38 - 4 bytes 2.9 is more than 4 bytes and it
216:43 - is going to store what it can and it is
216:46 - going to chop off this 2.9 and only
216:48 - store in a 2 so this is really something
216:51 - you should be aware of sometimes this is
216:54 - going to cause problems in your program
216:56 - and
216:58 - really really if you are trying to store
217:00 - fractional numbers in an integer please
217:03 - use a braced initialization
217:06 - form because the compiler is going to
217:08 - stop you from doing this if you try okay
217:11 - so this is really the difference between
217:13 - functional notation and breast
217:15 - initializer notation functional notation
217:18 - is not going to give you an arrow if you
217:20 - try to store something that can't really
217:23 - fit in a net it is going to silently
217:25 - chop it off and put in whatever it can
217:28 - and braced initializer is going to give
217:31 - you a compiler error so this is the
217:33 - difference between these two okay i am
217:36 - going to comment this out as well and i
217:39 - am going to put the starting comment
217:41 - here and i am going to go down and show
217:43 - you that you can do assignment
217:45 - initialization as well i am going to put
217:48 - in my code here because i don't want to
217:50 - type it really and i am going to print
217:52 - all this out and we have a bike account
217:54 - variable that we initialize using the
217:57 - assignment notation track count is going
217:59 - to be seven fake account is going to be
218:02 - bike account plus track count and we're
218:04 - going to be narrowing conversion here
218:06 - and we're going to see if this actually
218:08 - works we're going to try and weld this
218:11 - we're going to run the task to world
218:13 - with gcc
218:15 - it is going to pass through you can
218:17 - guess what we're going to see if we run
218:19 - the program
218:21 - bike account is 2 track count is 7 which
218:24 - is what we expect vehicle count is nine
218:28 - and uh the narrowing conversion is also
218:31 - chopping off what we have here so this
218:33 - is something you need to be careful
218:35 - about another thing i want you to see is
218:37 - that you can check the size of your
218:39 - variables in memory so we're going to
218:42 - check the size
218:45 - with
218:46 - size of
218:48 - and i am going to put in a piece of code
218:50 - to really play with this i don't want to
218:52 - type all this because it's really
218:55 - self-explanatory by now we're going to
218:57 - print sites of ant and inside we're
218:59 - going to say size of ant and this is
219:02 - going to give us how much memory is
219:04 - really occupied by an end and we can use
219:07 - this form here by passing in a variable
219:09 - name track count is a variable we have
219:12 - declared and initialized here
219:15 - so if we build this program
219:18 - let's do that with gcc the build is
219:20 - going to pass through and if we run
219:23 - rooster we're going to see that the size
219:25 - of int is four you're going to see that
219:28 - this is in bytes and size of track count
219:31 - is for as well because track account is
219:34 - also an integer so these are all little
219:37 - tools you can really use to
219:39 - know how much memory is really being
219:42 - used and occupied by your program and
219:45 - this is really all we set up to do in
219:47 - this lecture to learn as much as we can
219:49 - about integers integers occupy 4 bytes
219:53 - in memory for the most part and we have
219:56 - seen different ways we can initialize
219:58 - our integer variables we can use breast
220:01 - initializers which is going to use curly
220:04 - braces we can do functional
220:07 - initialization using parentheses like
220:09 - this we can also do assignment notation
220:12 - using the from like this and we can use
220:15 - size of to check the size of our integer
220:18 - variables i have to say that these kinds
220:21 - of initialization also work on other
220:24 - variables but we took the chance to
220:27 - introduce all these concepts using
220:29 - integers this is really all we set out
220:31 - to do in this lecture i hope you found
220:33 - it interesting we are going to stop here
220:35 - in this lecture the next one we're going
220:37 - to start and learn about integer
220:40 - modifiers go ahead and finish up here
220:43 - and meet me there
220:44 - in this lecture we're going to learn
220:46 - about integer modifiers and these are
220:49 - little things you can sprinkle around
220:51 - your integer types to modify their
220:54 - behavior a little bit but before we dive
220:56 - deep into this
220:58 - let's talk about how we can store
221:00 - positive or negative numbers in integers
221:03 - and we can do something like this if we
221:06 - put a tan inside our value 1 variable
221:10 - which is an integer
221:12 - it's going to work we can also put in a
221:14 - negative number like minus 300
221:18 - and it is going to work so what's the
221:20 - magic here
221:21 - well
221:22 - this is signed by default and this is a
221:24 - modifier we can apply to our variable
221:28 - to signal that we have the possibility
221:31 - to store in negative or positive numbers
221:33 - and it is going to work if you only want
221:36 - to store positive numbers in your end
221:38 - variables you can use another
221:41 - modifier called unsigned and if you put
221:44 - in a negative number you're going to get
221:46 - a compiler error we're going to see how
221:48 - this works in a minute okay regardless
221:50 - of whether your integer variables are
221:53 - unsigned or signed they are going to
221:56 - still occupy 4 bytes in memory so this
221:58 - is how it's going to look in memory and
222:01 - here is a simple formula we can use to
222:03 - come up with
222:04 - the range of values we can store in our
222:07 - int values
222:08 - if they are unsigned or signed if the
222:12 - number is inside you can use this
222:14 - unsigned range formula and plug in the
222:17 - number of bits you have
222:19 - in your data type if you are using a
222:22 - signed integer
222:24 - this is what you're going to use and
222:26 - here is a simple example for example if
222:28 - we have an unsigned and this is the
222:31 - range of values we can store we can
222:33 - basically go from 0 all the way to 4
222:36 - billion if the number is signed the
222:38 - range is going to basically be divided
222:40 - into half the half is going to go on the
222:42 - left and store negative numbers and the
222:45 - other half is going to go to the right
222:47 - and store positive numbers and you can
222:49 - see that we can basically go from minus
222:52 - two billion to two billion if the number
222:55 - is signed okay by now we have seen two
222:58 - modifiers unsigned and designed but
223:01 - there are others for example you can
223:04 - flag your integer types as short or long
223:07 - what does this do well this is a table
223:11 - that i put together to try and come up
223:14 - with all the combinations you can come
223:15 - up with if you have a short variable it
223:19 - is going to be two bytes in memory this
223:21 - is the modification that this modifier
223:23 - does to your type if you have short and
223:26 - it's going to be two bytes if you have a
223:28 - signed short and it's going to be two
223:30 - bytes if you have unsigned shirt and
223:33 - it's going to be two bites you can see
223:35 - that the effect of short is really
223:38 - shortening the original size in memory
223:43 - for whatever type you applied this on
223:46 - this is really working on an editor even
223:48 - if we don't specify int here for example
223:51 - short short here it's going to
223:53 - implicitly be and that's why
223:55 - we have two bytes because it's basically
223:58 - an end that we have split into here in
224:01 - the second column we have ant which is
224:04 - going to be 4 bytes if it is assigned
224:07 - and it's going to be 4 bytes this is
224:09 - really the sizes you're going to come up
224:11 - with if you use these combinations of
224:14 - modifiers on your integer types one
224:17 - thing i really want you to be careful
224:19 - about is that these modifiers only work
224:22 - for integral types so they work for data
224:26 - types in which you can store
224:28 - decimal or whole numbers you can't use
224:31 - this on types in which you can store
224:34 - fractional numbers like 2.9 that's going
224:37 - to give you a compiler error now that
224:39 - you have an idea about this why don't we
224:42 - go in visual studio code and actually
224:44 - play with us okay here we are in our
224:47 - folder that contains our projects we're
224:50 - going to do the usual and copy the files
224:53 - from our template project and we're
224:55 - going to put those files in our integer
224:58 - modifiers project here let's open it up
225:02 - and paste in the files we're going to go
225:04 - up again and we're going to open this up
225:06 - in visual studio code the first thing i
225:08 - want to play with is storing positive
225:10 - and negative numbers in our integer
225:13 - types so we're going to say end value
225:15 - one and we're going to store in a 10 for
225:17 - example and we're going to do any value
225:20 - 2
225:21 - and we're going to put in a minus 300. i
225:24 - think this is what we had you know a
225:25 - slide so we're going to keep this
225:27 - if you try to print this out so we're
225:29 - going to say value 1 and we're going to
225:31 - say value 2
225:33 - and we're going to try and build this so
225:36 - we're going to open our terminal so that
225:38 - we can play with it right away
225:40 - and we're going to run the task to world
225:42 - with gcc the world is going to be
225:44 - successful if we run our program we're
225:48 - going to see that it's going to say
225:49 - value 1 is 10 and value 2
225:52 - is -3 300 this is really cool we can
225:55 - store positive numbers and negative
225:57 - numbers in our end times and this is
226:00 - going to occupy
226:01 - 4 bytes in memory we can prove this by
226:04 - printing the size of value 1 and value
226:06 - 2. let's do that so we're going to say
226:08 - size of value 1 is size of value 1. we
226:12 - can also do it for value 2 size of value
226:16 - 2 and it's going to be size of value two
226:21 - std and yeah if we build this again
226:24 - we're going to run the test world with
226:26 - gcc and uh we run our application it's
226:30 - going to save four bytes so it doesn't
226:31 - really matter if we store in a positive
226:34 - number or a negative number it's going
226:36 - to be 4 bytes this is the point i want
226:38 - to make here another thing you can do is
226:41 - actually make it
226:43 - very clear that you have signed numbers
226:46 - in here and you can use the signed
226:49 - integer modifier here so this is going
226:52 - to give us the same result and if we try
226:55 - to both again
226:56 - run the task to build with gcc the world
227:00 - is going to be successful if we run the
227:02 - program we're going to get the same
227:04 - result so if you don't put aside or if
227:07 - you put it here it's going to be exactly
227:09 - the same thing another thing you can do
227:12 - is make it very clear that you want to
227:14 - store
227:16 - positive numbers in your variables we
227:18 - can do that by using the unsigned
227:21 - integer modifier so we're going to say
227:24 - unsigned
227:25 - and value three for example and we're
227:28 - going to put in a four
227:30 - this is going to be fine but if you do
227:32 - unsigned and value 4 and put in a minus
227:37 - 5 for example
227:38 - this is going to give you a compiler
227:40 - error because you save this is unsigned
227:43 - and this really means that you want to
227:45 - store in only positive numbers but you
227:48 - are trying to put in a negative number
227:51 - if you try to build this let's try this
227:53 - we're going to run the task to build
227:55 - with gcc we are going to get a compiler
227:58 - arrow saying conversion from -5 to ant
228:02 - this is not allowed you're going to get
228:03 - a compiler arrow your program is not
228:05 - going to compile so this is a compiler
228:08 - error let's say this here and this is
228:10 - really all i had to share about these
228:13 - signed and unsigned modifiers
228:15 - signed is going to mean that you can
228:17 - store negative and positive numbers
228:19 - unsigned is going to mean that you can
228:22 - only put in positive numbers and if you
228:25 - try to put in a negative number you're
228:26 - going to get a compiler error now that
228:29 - this is commented out if you try to run
228:32 - the test to world with gcc
228:34 - the world is going to be good and we
228:36 - will be able to run our program
228:39 - and it's going to do whatever it was
228:40 - doing before as we see here we also saw
228:44 - that we could use the short and
228:46 - long modifiers and we're going to put a
228:49 - piece of code here that is going to
228:51 - allow us to play with them so i don't
228:53 - want to type this and if you don't want
228:56 - to type this as well you can get this
228:58 - code from the resource section it's
229:00 - going to be left you can open the link
229:03 - use the code copy the code and paste it
229:05 - in here and really play with it because
229:07 - the point is really not to type all this
229:09 - the point is to understand what these
229:11 - modifiers do
229:13 - to your variables what we are going to
229:15 - do we're going to try to print them out
229:17 - and print the size they actually have in
229:20 - memory we're going to do this in four
229:22 - groups we're going to do one for short
229:24 - and long we're going to do one for ant
229:26 - here we're going to do one for long and
229:29 - we're going to do one for long long
229:31 - these are things you can do and we're
229:33 - going to see how much memory is actually
229:35 - being used by all these variables we are
229:38 - going to start with the first group here
229:41 - so we're going to go down and print the
229:43 - size is out and this may be really hard
229:47 - to wrap your brain around but they are
229:50 - plain old
229:51 - see out statements that we have been
229:53 - doing all along i am going to split this
229:56 - on different lines so that you can
229:59 - really say this so
230:01 - we have an output statement for a short
230:04 - var which is what we have here so we
230:07 - expect this to take two bytes and all
230:09 - these things are probably going to take
230:11 - two bytes let's try and build the
230:13 - program with gcc the bullet is going to
230:16 - be successful we are going to run
230:18 - rooster and you're going to see that
230:20 - short end is two bytes signed short is
230:23 - two bytes and everything is basically
230:26 - two bytes
230:27 - in this group here and we did guess
230:30 - right the next thing we want to try out
230:32 - is this group of ants so
230:35 - we are going to go down and give
230:37 - ourselves some breathing room
230:39 - and we're going to paste this in and
230:41 - we're going to separate these again so
230:43 - that we can see what is really happening
230:45 - here and i think this is really enough
230:48 - so we're going to see the sizes for the
230:51 - thanks we have in this group here and we
230:54 - expect this to take four bytes so let's
230:57 - try and run the world task to build with
231:00 - gcc the world is going to be good we can
231:03 - run the program like we usually do and
231:05 - you're going to see that ant variable is
231:08 - 4 bytes and everything in that group is
231:11 - 4 bytes and this tells you that
231:15 - regardless of the side and unside
231:19 - modifiers you put here it's going to
231:22 - really use the size of it here okay it's
231:25 - going to take four bytes in memory let's
231:27 - try this group here we are going to go
231:30 - down and put in the code to print the
231:33 - sizes for them
231:34 - and this is what we should use
231:38 - let's split this on different lines so
231:40 - that it is easier on the eyes and again
231:43 - if you don't really want to type this
231:44 - you can get the code from the length
231:46 - resource section you're going to find
231:49 - the code here and you can copy and paste
231:51 - and really play with us but it is
231:53 - helpful to really type these things out
231:56 - and really bring these things in muscle
231:58 - memory because it's going to help okay
232:00 - so we have this and we're going to try
232:03 - and run the world task with gcc the
232:06 - build is good we're going to go in here
232:09 - and run rooster
232:10 - and it is going to say long variable is
232:13 - four bytes and everything in this group
232:16 - is basically going to be four bytes
232:19 - in here the last one is this long long
232:22 - thing
232:23 - it is going to really give you a huge
232:25 - range
232:26 - for your values you can store in the
232:28 - variable but don't really trust my world
232:31 - let's try this out so that you can see
232:33 - for yourself we are going to go down and
232:35 - really put this in so we're going to
232:38 - give ourselves some breathing room
232:40 - and paste the code in
232:42 - so i am going to
232:45 - bring this to the next line
232:47 - and what we are really doing is printing
232:50 - the sizes for the variables that we have
232:53 - in this group here
232:55 - let's build and see
232:57 - if this passes the world
232:59 - the world is going to be good
233:01 - now we can run rooster
233:04 - and we're going to see that long long is
233:06 - eight bytes eight bytes gives us a
233:09 - really huge range of values okay this is
233:12 - really all we set out to do in this
233:14 - lecture to learn about these integer
233:16 - modifiers they modify the way your
233:18 - integer variables behave for example we
233:20 - can specify that we only want positive
233:23 - numbers all that we want to both store
233:26 - positive and negative numbers for that
233:28 - you're going to use designed or unsigned
233:30 - modifiers you can also shorten or
233:33 - lengthen the range of values you can
233:35 - store in your variable by using the
233:38 - modifiers short and long and from the
233:41 - output of a program here you can really
233:43 - see all these effects here this is
233:46 - really all we set out to do in this
233:48 - lecture i hope you found it interesting
233:50 - we are going to stop here in this
233:52 - lecture in the next one we're going to
233:53 - start and learn about fractional numbers
233:56 - go ahead and finish up here and meet me
233:59 - there in this lecture we're going to
234:01 - learn about fractional numbers and as we
234:04 - work with these numbers i want you to
234:06 - keep in mind that any piece of data you
234:08 - work with in your c plus program
234:11 - is ultimately going to be stored in the
234:13 - form of ones and zeros in memory
234:17 - functional number are also called
234:18 - floating types in technical terms they
234:22 - are used to represent numbers with
234:24 - fractional parts in c plus plus and many
234:27 - other languages and we have three types
234:30 - that we can use in c plus plus we have
234:32 - float
234:33 - double and long double and the main
234:35 - difference is in the size they occupy in
234:39 - memory a float takes four bytes a double
234:41 - takes eight bytes and the long double
234:44 - takes 12 bytes typically so as the size
234:47 - goes up you can also notice that the
234:50 - precision goes up so what is the
234:52 - precision the precision is basically the
234:54 - number of bits you can represent with
234:58 - that type starting from the number in
235:01 - front of the decimal point so if we look
235:03 - at this number here we can try and
235:05 - figure out its precision so we're going
235:07 - to count 1 2 3 4 5 6 7 8 9 10 11 12. the
235:13 - precision here is 12.
235:16 - if we go back to our table
235:19 - we're really not able to represent a
235:21 - number like this with a float
235:24 - the smallest thing we can use to
235:26 - represent this number well
235:28 - is a double because the precision is 15
235:32 - and it is more than what we need for
235:34 - this number which is 12. one thing you
235:36 - should remember is that the number in
235:38 - front of the decimal point is also
235:40 - counted then when you are trying to
235:42 - figure out the precision for your
235:44 - floating point numbers in c plus plus so
235:48 - here we have an example of how we can
235:50 - declare and initialize floating point
235:53 - numbers in our c plus plus program
235:56 - number one is a really huge number so
235:58 - you can guess that this is more than we
236:01 - can handle with the float we're going to
236:03 - see how this is handled by our compiler
236:06 - a double has a precision of 15 so we
236:10 - should expect to store more numbers than
236:12 - we did in a float a long double should
236:15 - be able to handle this without a problem
236:18 - because if we go back to our table here
236:21 - our long double here should be able to
236:23 - handle this better than double but it is
236:26 - possible that it is the same thing as
236:29 - double depending on the compiler
236:31 - implementation and if we try to print
236:33 - out the sizes here we're going to see
236:35 - what the compiler gives us we're going
236:37 - to do this when we try this in visual
236:40 - studio code okay and here we are trying
236:42 - to print out the precision of these
236:44 - numbers we can use a special setting on
236:49 - our stream to control the maximum
236:53 - precision that we can see here you see
236:55 - that we are trying to show the precision
236:57 - for each number there is a special
236:59 - setting we can put on stdc out to make
237:02 - it control the precision to a given
237:04 - number here we are using 20 and we're
237:07 - going to see that for number one this is
237:09 - going to be seven digits for number two
237:12 - it should be 15 digits or something
237:14 - close to that the specifics are really
237:16 - dependent on the compiler implementation
237:19 - and for long double it should at least
237:22 - be the same as double or even more in
237:24 - some cases okay here we want to see that
237:27 - we can also have narrowing errors
237:30 - if we try to store something back in a
237:32 - float and a float can't really handle it
237:35 - here we have a number with a lot of
237:38 - digits one two three four five six seven
237:41 - eight nine and we know that the float
237:44 - can only handle seven digits so
237:47 - this is probably going to give us a
237:48 - compiler error as we've seen for breast
237:51 - initialization if we use functional
237:54 - initialization this problem is not going
237:56 - to be code at compile time so we're
238:00 - going to end up with a chunked piece of
238:02 - data and we're going to see this when we
238:04 - play with this with visual studio code
238:06 - and another format we can use with
238:09 - floating points is that we can use
238:11 - scientific notation and it is basically
238:15 - a way we can use a power of 10
238:18 - multiplier to multiply with our floating
238:22 - point number so for example here number
238:24 - 5 is going to be this number 1 9 2 4 0 0
238:28 - 0 23 we can use a floating point
238:31 - scientific notation to represent this
238:34 - so what we're going to do we're going to
238:36 - say 1.9 and we're going to multiply this
238:40 - with 10 to the power of 8. this is what
238:42 - this means this 8 here means to multiply
238:47 - with 10 to the power of 8. and if we
238:50 - multiply with that that basically means
238:52 - moving the decimal point 8 digits to the
238:55 - right so we can go one two three four
238:59 - five six seven eight and it is going to
239:02 - end at these three here and it is going
239:05 - to be basically the same number number
239:07 - seven is also another one and if we do
239:09 - this we're going to pad with zeros after
239:12 - these four and we're going to end up at
239:14 - this same location as the three but it
239:17 - is going to be a zero we're going to see
239:18 - about that in a minute and number eight
239:21 - is another floating point number and we
239:24 - can use scientific notation to represent
239:27 - it just like you see with number nine
239:30 - we're basically going to have the same
239:32 - thing when we have a minus in here it
239:34 - means we're going to multiply with 10 to
239:37 - the power of minus 11 and this is going
239:40 - to give us a number below one thing zero
239:43 - point zero zero seven or something like
239:45 - that so we're going to go 11 digits
239:48 - after the zero here and if we count one
239:51 - two three four 5 6 7 8 9 10 11 and the
239:57 - decimal point is going to go after three
240:00 - and we're going to basically end up with
240:02 - the same thing here we're going to play
240:04 - with this in a minute and you're going
240:05 - to see that all this makes sense and
240:07 - don't forget that any piece of data we
240:09 - store in a computer is going to be
240:12 - ultimately represented by ones and zeros
240:15 - in memory and for floating points we
240:18 - don't use the number systems like we've
240:20 - done for integers there is a special
240:22 - system that is used to do that but it is
240:25 - a little bit complicated to cover in a
240:27 - course like this i am just going to
240:29 - point you to it if you are interested
240:32 - and when you are done with this course
240:34 - you can come up and read on this the
240:36 - main point is that any piece of data
240:38 - that you represent in your c plus plus
240:40 - program is going to be represented in
240:43 - terms of ones and zeros in the memory of
240:46 - your computer okay there are a few
240:48 - things you can do with floating points
240:50 - that you can't really do with integers
240:53 - for example you can divide with zero if
240:56 - you take a floating point number and
240:58 - divide that with zero you're going to
241:00 - get what we call infinity if the number
241:03 - is positive you're going to get positive
241:05 - infinity if the number is negative
241:06 - you're going to get negative infinity
241:09 - and you can take two floating point
241:11 - numbers that are zeros and divide them
241:14 - and what you're going to get really is
241:15 - not a number it's something called nan
241:18 - which stands for naughty number
241:20 - and uh your program is going to not
241:23 - crash but very few things you can't do
241:25 - with these things for example you can't
241:27 - add them up you shouldn't really do this
241:29 - it's probably going to end up bad for
241:31 - your program here we have a few examples
241:34 - we have three numbers declared they are
241:37 - doubles they must be occupying eight
241:39 - bytes in memory number 10 is initialized
241:42 - to 5.6 11 is initialized to zero because
241:46 - we are using the braced initialization
241:48 - and we have nothing in here
241:50 - and infinity here is the result of
241:53 - dividing a number by zero so it's going
241:56 - to be positive infinity because number
241:59 - 10 is a positive number if you go down
242:01 - we're going to print number 10 divided
242:04 - by number 11 and we're going to say
242:06 - yields we're going to put the result out
242:08 - we're going to see that down here on the
242:10 - second line you see that we are trying
242:12 - to add something to infinity and this is
242:14 - also going to yield infinity because
242:17 - think of infinity as something super big
242:21 - and if you add something small to
242:23 - something big it's still going to be
242:24 - something big down here you see that
242:26 - result equals number 11 divided by
242:29 - number 12 and these two are zeros so
242:31 - we're going to end up with none and
242:33 - that's what we're going to print in this
242:35 - statement here
242:37 - down to the bottom okay you should
242:39 - really remember to put in the suffixes
242:41 - when you are initializing your floating
242:44 - point numbers otherwise the default is
242:46 - going to be double this is what we mean
242:49 - by this you see this floating number we
242:51 - have a suffix that is f to mean that it
242:54 - is a floating number if you don't put
242:56 - that in this is going to be interpreted
242:58 - as double and the compiler is going to
243:00 - try and turn that into a float by
243:03 - chopping off things that can't really
243:05 - fit in a float so to really make it
243:07 - clear that you are stirring in and
243:09 - loading number please put this f suffix
243:12 - here for double you don't need to put
243:13 - anything because it is the default
243:16 - assumed by the compiler but for a long
243:19 - double you have to suffix this with l
243:22 - just like this so that's what we really
243:24 - mean here we have seen that the
243:26 - precision for float isn't really enough
243:29 - for many of the computations we might
243:31 - want to do in our c plus plus
243:33 - applications okay we have talked a lot
243:36 - about floating point numbers let's head
243:39 - to visual studio code and actually play
243:41 - with them okay here we are in our folder
243:44 - that is going to contain our project the
243:46 - project is going to be called fractional
243:48 - numbers so we're going to copy our files
243:51 - go up a little bit
243:53 - and put those in and i'm going to go up
243:55 - again and open this in visual studio
243:58 - code we're going to close whatever it is
244:00 - we have opened now we're going to close
244:02 - folder and we're going to open our
244:04 - project in visual studio code and we're
244:07 - going to do the usual and remove things
244:09 - we don't need in here the first thing we
244:11 - want to do is to store a few floats in
244:14 - our program we're going to declare and
244:16 - initialize a few floating point numbers
244:18 - we have number one number two and number
244:20 - three and we want to make it clear that
244:23 - the sizes are what we expect we are
244:26 - going to open a terminal window here and
244:28 - we're going to build with gcc run the
244:31 - task to weld with gcc the world is going
244:34 - to be successful we're going to come to
244:36 - our terminal click a little bit and
244:37 - we're going to type dir we're going to
244:39 - see that a program is in place if we run
244:42 - it we are going to see that size of
244:44 - float is 4 size of double is eight and
244:48 - size of long double is 16. this is what
244:51 - we expected another thing we can do is
244:54 - try and play with the precision of these
244:57 - numbers and see what we can really go
244:59 - away with okay so we're going to
245:01 - actually put in a piece of code to play
245:04 - with this we're going to add a setting
245:06 - to our sddc out stream so that we can
245:09 - control the precision but for this to
245:11 - work we need to bring in a library that
245:14 - is called i o manip so we're going to
245:17 - include that i o manip and how do i know
245:20 - this i usually consult the c plus plus
245:22 - standard library documentation and you
245:25 - are not at the point where you can
245:27 - really understand it right now so we're
245:29 - going to be putting in these things here
245:32 - and explaining them as we go and i made
245:35 - the type here it is io manip and you see
245:38 - that
245:39 - now this is recognized our program
245:41 - should compile so we're going to try and
245:43 - weld it so that we can try this out
245:45 - we're going to build with gcc the world
245:47 - is going to go through we can run our
245:49 - program we're going to do dur and clear
245:52 - and rooster to run you see that things
245:55 - start to go off at sex and if we count
245:57 - what we have here it is one two three
246:01 - four five six seven we can only
246:03 - represent seven numbers accurately with
246:07 - a float and after that we're just going
246:09 - to have garbage because the computer
246:11 - can't really make sense of whatever we
246:13 - have after our
246:15 - seven digits that we can legally
246:17 - represent with the flood so the
246:19 - precision for our floating point number
246:21 - here is seven i really hope this makes
246:23 - sense let's check out number two
246:26 - we are using double so precision should
246:29 - be around something like 15. so we are
246:32 - putting in a number one through nine and
246:35 - we are starting over zero one two three
246:37 - four five up to zero again if we look at
246:40 - what we have in the output here we have
246:43 - one two three four five six seven eight
246:45 - nine zero
246:47 - one two three
246:48 - four five six and here things start
246:52 - falling off after our sixth year and if
246:54 - we count we're going to have 1 2 3 4 5 6
246:59 - 7 8 9 10 11 12 13 14 15 16 17 digits
247:07 - this is the precision we are having this
247:09 - compiler for double 17 so it is
247:12 - something around 15 and we should expect
247:14 - to have something more than that or at
247:17 - least the same thing as double with long
247:20 - double so if we look at this you see
247:23 - that it is one two three four five six
247:25 - seven eight nine zero one two three four
247:28 - five six seven eight nine we are able to
247:32 - represent up to 20 and you can see that
247:36 - long double leaves up to even the
247:38 - precision of 20 that we have set with
247:41 - std set precision here okay i really
247:44 - hope now that you have an idea about
247:46 - these precisions we have with our
247:48 - floating point types in c plus plus
247:51 - programs another thing i want you to see
247:54 - is
247:55 - what kind of narrowing errors we can get
247:58 - if we try to initialize with something
248:01 - that can't really be represented by a
248:03 - floating point number and here we have a
248:05 - float it is called number four and we
248:08 - are trying to put in something that is
248:10 - bigger than we can really fit in it has
248:12 - more than seven digits so one two three
248:15 - four five six seven eight nine it is
248:18 - more than seven digits and we would
248:21 - expect to have a problem with this
248:23 - because we are using braced
248:24 - initialization let's try and build this
248:27 - with gcc we're going to do that and this
248:30 - is going to work successfully so this is
248:32 - going to silently chop off our number if
248:35 - we try to print it out we're going to
248:37 - say sddc out number four and we're going
248:40 - to world again run the test tube world
248:43 - so that our changes are taken into
248:45 - effect i'm going to do dur and do
248:47 - rooster and this is going to print our
248:49 - number you're going to see that after
248:52 - the zeros
248:53 - we have junk our number has been
248:55 - basically chopped off and this is junk
248:57 - because we can't really represent this
248:59 - with the double the 16 here has been
249:02 - chopped off because we can't basically
249:03 - represent this with the floating point
249:05 - number if we change this to double this
249:08 - is going to probably give us what we
249:10 - expect so let's run again world with gcc
249:13 - the world is going to be good if we run
249:15 - the program it is going to show us the
249:17 - same thing okay this is a really good
249:19 - learning change why are we having the
249:22 - same results as
249:24 - before even if we changed the type to
249:27 - double try to think about it the reason
249:29 - is the suffix here is still saying f and
249:34 - this is going to be stored as float in
249:36 - memory so if we want this to really be
249:38 - treated like a double we can take out
249:41 - the float here
249:42 - and if we build again and run the
249:44 - application now you're going to see that
249:46 - we see the 23 this is basically being
249:49 - correctly stored as a double this is a
249:52 - really good thing you should keep in
249:53 - mind if you don't put in your suffixes
249:56 - here the number is going to be
249:58 - interpreted as double
250:00 - by now i hope you see that if you really
250:03 - try to put more than your floating point
250:06 - can handle
250:07 - the number is going to be chopped off
250:09 - and only the precision that it can
250:12 - handle is going to be stored in i hope
250:14 - this makes sense and you see that the
250:16 - behavior for numbers is really different
250:19 - we got the compiler error when we try to
250:22 - do narrowing conversion with integers
250:24 - but now it is silently chopping off our
250:27 - number if we try and use functional
250:29 - notation i think we're going to get the
250:31 - same result and change this back to a
250:34 - float and uh use float here and if we
250:37 - both again let's go to terminal run task
250:40 - use gcc we're going to run this
250:43 - let's run rooster and you see that we
250:46 - get the same results our 23 is chopped
250:49 - off here we can also use the assignment
250:52 - notation here just like we did with
250:54 - integers and this is going to do exactly
250:57 - the same thing it is going to chop off
250:59 - the 23 here and we're going to have some
251:01 - garbage which is 16 in this case if we
251:04 - weld the gun the world is going to go
251:06 - through and if we run we're going to see
251:08 - as it's in here okay narrowing
251:10 - conversions are something you should be
251:12 - aware of when storing your floating
251:15 - point numbers and you should really
251:17 - remember to put in your suffixes here
251:19 - and other thing we have seen that we
251:21 - should really play with is scientific
251:24 - notation
251:25 - as the comment here says what we have
251:27 - seen so far in floating point numbers is
251:31 - fixed notation it is what we have here
251:33 - but we can also use scientific notation
251:37 - which is exactly what we described in
251:39 - the slides and what we have here for
251:41 - example is e8 and it means that we are
251:45 - going to multiply this number here
251:48 - with 10 to the power of 8. if you go
251:51 - down here we have number 9 so we have
251:53 - 3.498
251:56 - and we have e minus 11 and what this is
252:00 - going to do is multiply with 10 to the
252:02 - power of minus 11. this is how i can
252:05 - represent this here and we can print
252:08 - these numbers out to really play with
252:10 - them to make a difference with what we
252:12 - have been doing before we're going to do
252:14 - sddc out and put a dividing line here
252:18 - this is one way we can do this so we're
252:20 - going to do stdndl
252:22 - we're going to weld this so we're going
252:24 - to run the attached world with gcc 10
252:27 - the world is going to go through if we
252:29 - do rooster we're going to see that our
252:32 - number here number five is what we
252:35 - expect number six is the same thing but
252:39 - we used scientific notation to do this
252:42 - because we took this number and
252:44 - multiplied by 10 to the power of eight
252:46 - number seven should be almost the same
252:48 - thing but the lower 23 here is going to
252:51 - be chopped off because we haven't
252:54 - specified it we're just multiplying with
252:56 - 10 to the power of 8 so that's why we
252:58 - have 0 0 here i hope that makes sense
253:01 - and if you look at number 8 you see that
253:04 - we stored it like this without using
253:06 - scientific notation we used fixed
253:08 - notation but on the terminal it's going
253:11 - to be printed out in scientific notation
253:13 - and this may be pretty cool the main
253:15 - usage for scientific notation is to make
253:19 - sense of numbers that are really huge so
253:22 - the way you interpret this you're going
253:24 - to
253:25 - move these numbers after the decimal
253:27 - points with 0 in front and it's
253:30 - basically going to be like this so if
253:32 - you count the zeros you have here we're
253:33 - going to have 1 2
253:36 - 3 4 5 6 7 8 9 10 and 11 is going to be
253:42 - directly after three and you're going to
253:44 - get the number here this is what we mean
253:46 - and number nine was explicitly stored in
253:49 - using scientific notation and you see
253:52 - that we have the same thing you can play
253:54 - with these things and really make sense
253:56 - of them and again we didn't specify any
253:59 - suffix here so these are going to be
254:01 - interpreted as doubles but this is not a
254:04 - problem because they are doubles here
254:06 - okay we are making some progress with
254:08 - this lecture which is a little lengthy
254:11 - the last thing we want to do is to play
254:13 - with infinity and nan
254:15 - we're going to put a message here to say
254:17 - what we want to do and we're going to
254:18 - have number 10 which is going to be
254:20 - positive we're going to have number 11
254:22 - which is going to be zero number 12 is
254:24 - also going to be zero
254:26 - if we take 10 and divide that with 11
254:30 - we're going to get infinity because we
254:32 - are dividing a floating number with zero
254:35 - if we try to print that out we're going
254:37 - to get infinity
254:38 - and we're going to get infinity for this
254:40 - result here because we are trying to add
254:42 - something small to infinity which is
254:44 - something really big and if we all
254:47 - trying to divide zero with zero in
254:49 - floating point
254:50 - we're going to get what is called
254:52 - naughty number and if we print that out
254:54 - we're going to see this in a minute
254:55 - let's build this with gcc we're going to
254:59 - weld successfully let's clear this out
255:02 - so that we don't have noise in here and
255:05 - we're going to run rooster and you see
255:07 - here it says infinity and none which is
255:11 - what we said here
255:12 - and if we go down here it is saying
255:14 - number 10 divided by number 11 and
255:17 - number 11 is zero you see that here it's
255:20 - going to yield infinity if we add five
255:23 - to infinity we're going to get infinity
255:26 - and if we try to divide a zero by a zero
255:29 - we're going to get none which is really
255:31 - a way to tell you that you're doing
255:33 - something wrong you should really be
255:34 - careful
255:35 - one other thing i want you to see is
255:37 - that if you turn this five into a minus
255:40 - five and build again we're going to
255:42 - build with gcc and we're going to run
255:45 - this rooster
255:46 - we're going to get minus infinity so if
255:49 - you divide a positive number with zero
255:52 - you're going to get positive infinity
255:54 - and if you divide a negative number with
255:56 - infinity you're going to get negative
255:58 - infinity and this is what we see here
256:00 - this is really all we set out to do in
256:02 - this lecture i hope you found it
256:03 - interesting and again the big message is
256:06 - that any data type you're going to be
256:08 - handling in your c plus plus program is
256:11 - going to ultimately be stored as ones
256:13 - and zeros in memory and we have learned
256:16 - about floating point numbers float
256:17 - double and long and they have these
256:20 - properties you see here and you should
256:22 - use them with this in mind otherwise
256:24 - you're going to have problems with your
256:26 - precision make sure you are using the
256:28 - correct precision that you need in your
256:30 - program we are going to stop here in
256:32 - this lecture the next one we're going to
256:34 - try and learn about booleans go ahead
256:37 - and finish up here and meet me there in
256:40 - this lecture we're going to learn about
256:41 - booleans booleans are types that can
256:44 - store two states in c plus plots it can
256:47 - store either true or false and we can
256:51 - use this to really do decisions in our
256:53 - program if you look in the program we
256:55 - have here we have two variables declared
256:57 - the data type is bull
256:59 - and one is called red light the other is
257:02 - called green light
257:03 - and we have true and false inside one
257:06 - thing we can do in c plus plus is make
257:09 - decisions we can say if the red light is
257:12 - true we can
257:13 - print a message that says stop and if
257:16 - it's not red we can print a message that
257:19 - says go through we can do that and
257:21 - booleans are really used in this way to
257:24 - make decisions in your c plus plus
257:26 - program we haven't really learned about
257:29 - if statements in this course but i am
257:31 - throwing this in here to really drive
257:33 - the point home that we can use this to
257:36 - make decisions in our program down here
257:38 - we have another way we can do this we
257:40 - can actually use the variable itself
257:42 - without checking if it is equal to true
257:46 - or false and we are going to get the
257:48 - same message the point here is that if
257:50 - green light is true we're going to say
257:53 - the light is green if it's not we're
257:55 - going to say the light is not green you
257:57 - can do something like this and again the
257:59 - big point here is that booleans data
258:02 - types are used to store two states true
258:05 - or false in your c plus plus program
258:07 - okay by default if you print a boolean
258:11 - that has two in it you're going to get
258:13 - true and this is what you see here and
258:15 - if you print one that has zero in it
258:18 - you're going to get false we can change
258:20 - that with a special setting that we can
258:22 - apply to our std out stream and you do
258:25 - that like this with std bull alpha and
258:28 - we're going to play with this in a
258:29 - minute you're going to see
258:31 - if we try to print with this setting
258:33 - applied we're going to see true on false
258:35 - and not c 0 and 1 like we did before
258:38 - we're going to play with this in a
258:40 - minute and you're going to see another
258:42 - thing you should know is that booleans
258:44 - occupy
258:45 - 8 bits in memory they take up an entire
258:48 - bite so you may think that this is
258:50 - wasteful and it is but with the amount
258:53 - of memory that we have today this is
258:55 - really not a big problem but if you are
258:58 - working on a device where memory is
259:00 - really a problem there are techniques
259:03 - you can use to pack even more data in a
259:05 - byte and we're going to learn about that
259:07 - later in the course okay so this is
259:10 - really all i have to say about booleans
259:12 - we're going to go to visual studio code
259:14 - and play with them in code okay here i
259:17 - am in the folder for my project here i
259:20 - am going to do the usual and copy the
259:22 - files over
259:23 - and i am going to go in my project on
259:26 - booleans i am going to go up and open
259:28 - this up in visual studio code i am going
259:31 - to close the current folder open the new
259:33 - one and browse to my project this is
259:35 - going to open up in visual studio code
259:38 - and i am going to close the welcome
259:40 - screen here i don't need it anymore
259:42 - so i'm going to remove what i don't need
259:45 - and we are going to play with the exact
259:48 - code that we had in the slides we're
259:50 - going to declare two variables one is
259:52 - going to be red light the other is going
259:54 - to be green light they are going to be
259:56 - booleans and in red light we're going to
259:59 - store a true and story false in green
260:02 - light and we can make a decision like
260:04 - this so try to guess what we're going to
260:06 - plant in this program we're going to try
260:09 - and decide and say if the red light is
260:12 - true we're going to print stop
260:14 - if it's not true we're going to fall in
260:16 - this block here and say
260:19 - go through if we look at our program in
260:22 - red light we have a true so this should
260:25 - really win and we should get in this
260:27 - block here i hope this makes sense so
260:30 - let's try and build this program to see
260:32 - that it actually works so we're going to
260:34 - build with the gcc we're going to run
260:36 - our program and our terminal just went
260:39 - away we're going to create a new one no
260:41 - big deal
260:43 - and uh if we do dir we're going to see
260:46 - rooster.exe
260:48 - we run it it's going to say stop okay so
260:51 - in red light we have true the test is
260:54 - going to succeed here and we're going to
260:56 - fall in this block and say stop i hope
260:59 - this makes sense you can try to store a
261:01 - false in here
261:03 - and both again going to world with gcc
261:06 - if we run this program now it's going to
261:09 - say go through because red light is not
261:12 - true anymore this is really what we mean
261:14 - when we say that we can make decisions
261:16 - based on booleans in our c plus plus
261:19 - code we can also try another example
261:22 - we're going to say if green light is
261:26 - true
261:26 - we're going to say the light is green if
261:28 - it's not we're going to say the light is
261:30 - not green and this is another form we
261:32 - can use instead of typing the entire
261:35 - thing
261:36 - comparing red light to true here and
261:39 - again we're going to learn about all
261:40 - these comparisons here
261:43 - it is just because i thought that
261:45 - talking about bulls without showing
261:48 - tests like this is really not going to
261:50 - drive the point home for you so try to
261:53 - understand this as simple tests you can
261:55 - do in math if one value is true i am
261:57 - going to do something if it's not true
261:59 - i'm going to do something else this is
262:01 - what we are doing here okay this program
262:04 - here is going to check if the green
262:06 - light is true so we're going to look
262:08 - here green light is not true so we
262:11 - should fall here and print this message
262:14 - that the light is not green
262:16 - let's build the program the world is
262:18 - going to go through we're going to run
262:20 - this
262:21 - and you're going to see go through and
262:23 - the light is not green this is what we
262:25 - have here another thing we can actually
262:27 - try to see is the amount of memory that
262:30 - a boolean takes up so we can use sizeof
262:33 - to do that we have seen this before if
262:36 - we build with gcc we're going to go
262:39 - through
262:39 - and we can run our program to actually
262:42 - this message and you're going to see
262:43 - that bull is actually going to take up
262:46 - one byte in memory this is what we saw
262:48 - in the slides another thing that can be
262:50 - really confusing is printing out boolean
262:53 - values for example here we are trying to
262:56 - print great light and green light let's
262:59 - go up and actually change them a little
263:01 - bit for example take green light here
263:04 - and make it true
263:06 - and we're going to go down again and
263:08 - here we are trying to print them out red
263:11 - light is going to print whatever value
263:13 - we have stored then and green light is
263:15 - going to store whatever value we have
263:17 - stored in and again true is going to be
263:19 - printed out as one
263:21 - and false is going to be printed out as
263:24 - a zero let's try and build this we're
263:26 - going to build with our gcc compiler the
263:29 - world is going to be good we're going to
263:31 - run this and you're going to see that
263:33 - red light is zero because we have a full
263:36 - sun here
263:38 - and green light is going to be one
263:41 - because we haven't a true here if you
263:44 - try to print out boolean variables
263:47 - you're going to get one and zero by
263:48 - default if you really want to see true
263:51 - and false there is a special setting you
263:53 - can apply to htdc out and you do that by
263:56 - saying stdc out std bull
264:01 - alpha and you do it like this
264:03 - and if you try to print again we are
264:06 - going to get true and false right now
264:08 - okay let's try and print again and we're
264:10 - going to work this with gcc and we're
264:13 - going to run this
264:15 - and now you see that we see red light is
264:17 - false green light is true
264:20 - this is really all i had to share about
264:22 - booleans in this lecture i really hope
264:25 - it drives the point home that booleans
264:28 - are mostly used in making decisions in
264:30 - your program and that's what you're
264:32 - going to be mostly using them for and
264:35 - another thing is that they take up one
264:37 - bite in your memory we are going to stop
264:40 - here in this lecture the next one we're
264:42 - going to try and learn about characters
264:44 - and text
264:46 - go ahead and finish up here and meet me
264:48 - there in this lecture we're going to
264:50 - learn about characters and text and we
264:53 - use a data type called car in c plus
264:56 - plus to represent characters and this is
264:58 - basically how you use it you store in
265:00 - characters like abc and here you see
265:02 - that we have a r r
265:05 - o w and you put your characters in
265:08 - single quotes like this to mean that
265:10 - they are characters if you don't do that
265:12 - you're going to get a compiler error
265:14 - after you have your characters declared
265:16 - and defined like this you can print them
265:19 - out with stdc out and we're going to see
265:22 - them on the terminal car occupies one
265:26 - byte in memory so it's going to take up
265:28 - eight bits okay so one thing we can do
265:31 - is map each value in these 256 possible
265:35 - values to a character and we can do
265:38 - something like this for example we can
265:40 - say that
265:41 - 33 represents the exclamation mark
265:44 - 48 represents the character 0 49
265:47 - represents the character 1 50 represents
265:50 - the character 2 and we can keep going up
265:53 - and say for example 70 represents f 71
265:56 - represents g
265:58 - or
265:59 - 112 represents p you can really use a
266:02 - mapping like this and come up with
266:05 - representations of your characters in
266:07 - memory and this is what we do you can
266:10 - learn about this encoding and on the
266:12 - link here this is a real thing and it is
266:15 - called the ascii encoding that takes
266:18 - characters and stores them in one byte
266:21 - and the data type to store these
266:23 - characters in c plus plus is car if this
266:26 - doesn't make sense please bear with me
266:28 - we're going to play with this in visual
266:30 - studio code and it is most probably
266:32 - going to make sense okay it is possible
266:35 - to assign a valid ascii code to
266:38 - a car variable and the corresponding
266:41 - character will be stored in that piece
266:44 - of memory so once you have that you can
266:46 - choose to interpret that either as a
266:48 - character or as a number that is
266:51 - something like an integer this is what
266:53 - we really mean if we declare a variable
266:55 - called value which is of car type 65 is
266:59 - going to be stored in memory but the c
267:02 - plus plus program is going to interpret
267:04 - this as a character if we go back to our
267:07 - table and see what is represented by 65
267:10 - this is what we're going to find we're
267:12 - going to find that 65 represents a
267:15 - and if we print this out by default it's
267:18 - going to print a it's not going to print
267:20 - 65 but there is a way you can take this
267:22 - character value and turn that into an
267:26 - integer and print it out and you see
267:28 - that here we are saying value and and we
267:32 - are saying static cast
267:34 - and and in the parents we have a value
267:36 - this is basically a way to say we wanted
267:38 - to take the value and interpret that as
267:42 - an integer and we're going to learn a
267:44 - little more about static cast later in
267:46 - the course but it is basically a way to
267:48 - transform between data types and in this
267:51 - case we are trying to transform from car
267:54 - to end and we're going to print this out
267:56 - okay what we just described is the ascii
267:59 - encoding a technique by which we can map
268:01 - the first 128 numbers in
268:05 - a byte two characters and use that to
268:08 - represent characters this technique
268:10 - doesn't work well if you have languages
268:13 - like arabic japanese and chinese because
268:15 - they are completely different beasts
268:18 - there are better ways to represent
268:19 - characters in your c plus program and
268:21 - that's usually unicode but that's really
268:24 - out of scope for a course like this so
268:27 - i'm not going to describe that anymore
268:29 - okay this is really all we need to learn
268:30 - about characters we're going to head to
268:32 - visual studio code and play with them
268:35 - okay here i am in my working folder i am
268:38 - going to go in my template project i am
268:40 - going to copy things over i am going to
268:43 - put that in my characters and text
268:45 - project and i am going to go up and open
268:48 - this up in visual studio code we're
268:50 - going to close the welcome screen here
268:52 - we're going to open up main cpp and
268:54 - we're going to put in the code to play
268:57 - with characters and text
268:59 - the first thing we can do is declare
269:02 - characters like this we can put in a r
269:05 - r o w here and we're going to see this
269:08 - printed out if we run this program we
269:10 - are going to put in some code to play
269:12 - with characters
269:14 - we have a few variables declared that
269:17 - are of car type
269:19 - we go from character 1 through character
269:22 - 5 and these are the characters we are
269:24 - storing and this is and this is the
269:25 - format you're really going to use to
269:27 - declare your characters after we have
269:30 - them declared we can print them out like
269:33 - we print any other variable and we can
269:36 - try and compile this program and see
269:38 - what we're going to get but before we do
269:40 - that i would invite you to try and guess
269:42 - so let's open our terminal
269:44 - and we're going to build with our gcc
269:48 - task we're going to world the build is
269:50 - going to go through and if we run
269:52 - rooster we're going to see that we are
269:54 - printing out
269:56 - a r o w we are storing our characters
270:00 - and and we are able to print them out
270:02 - this is really how you work with these
270:04 - guys another thing i want you to see is
270:06 - the size that a character occupies
270:10 - in memory by that i mean card type it's
270:13 - going to occupy one byte in memory and
270:16 - that means that we can only have
270:19 - 256 different values that go between 0
270:23 - and 255 if we have decided to store in
270:26 - positive numbers we are using the
270:28 - knowledge we learned from the integers
270:30 - lecture if these calculations we are
270:33 - doing here don't make sense please go
270:35 - back and check that out so down here we
270:38 - are declaring a character type the name
270:41 - is value and we are putting in a 65. the
270:44 - thing is if you try to print this value
270:46 - here it's not going to print 65 it's
270:48 - going to print a which is a character
270:51 - representation of 65. if you remember
270:54 - from our ascii table we had these
270:58 - mappings between characters and integers
271:01 - and 65 mapped to the character a
271:05 - upper case so if we print this out this
271:08 - is going to give us a but we have the
271:10 - option to
271:12 - interpret this as a number and we can
271:14 - pass this through a static cast and it
271:18 - is going to take a value turn this into
271:20 - an integer and we're going to be
271:22 - printing this integer on the console and
271:24 - we're going to see it we're going to try
271:26 - this out so we're going to run the task
271:28 - to build with gcc the build is going to
271:31 - go through we're going to run rooster
271:34 - and you're going to see that value is a
271:36 - for the first line here
271:39 - and the value and is 65 because we
271:42 - decided to interpret whatever is in this
271:46 - value as an integer and not as a
271:48 - character as it is done by default this
271:51 - is really all we set out to do in this
271:52 - lecture i hope you found it interesting
271:55 - we are going to stop here in this
271:56 - lecture in the next one we're going to
271:58 - try and learn about the auto key world
272:01 - in c plus plus
272:03 - go ahead and finish up here and meet me
272:05 - there in this lecture we're going to
272:07 - learn about the auto keyword in c plus
272:10 - plus
272:11 - this is a keyword that is going to let
272:14 - the compiler deduce the type for you and
272:16 - this is going to come in handy when you
272:18 - have longer type names that are really
272:22 - hard to type we can't really give you an
272:24 - example of that because that requires to
272:27 - have a good number of concepts mastered
272:31 - in clause plus but we are measuring this
272:34 - here for completeness because we are
272:35 - talking about variables and data types
272:38 - so let's hear how we can use this here
272:40 - we have an example where we are saying
272:42 - autovar one and what we initialize this
272:46 - with is an integer so the compiler is
272:49 - really going to try and guess the type
272:51 - of this thing and that's the type it's
272:54 - going to assign to variable one this is
272:56 - what ocho is really used for if we pass
272:59 - a double
273:01 - inside and it is a double because we
273:03 - have no
273:04 - suffix here
273:06 - so it is going to deduce a double if we
273:09 - pass a suffix of f it is going to
273:12 - interpret this as a fluid if we pass l
273:15 - it is going to interpret this as long
273:17 - double and if we pass in a character
273:19 - it's going to interpret this as a
273:21 - character and this is really the essence
273:24 - of what auto is used for it is used when
273:27 - you don't really want to explicitly type
273:30 - the type of your variable and you want
273:33 - the compiler to fill in that for you or
273:36 - it gets it for you down here you see
273:38 - that we have a few examples with
273:40 - integers so we can make this unsigned
273:43 - lung through this suffixes and the
273:45 - compiler is going to deduce the type
273:48 - based on what we pass in our initializer
273:51 - here down here you see that we have a
273:52 - few examples with integers if we pass a
273:55 - suffix of u this means that we are
273:57 - storing an an unsigned integer so that's
274:01 - what the compiler is going to deduce if
274:03 - we pass ul it is going to be unsigned
274:06 - long if we pass in ll this is going to
274:09 - be long long and that's what the
274:11 - compiler is going to deduce here you see
274:13 - that we are trying to print the sizes of
274:15 - these variables and we trying to
274:19 - prove to ourselves
274:21 - that the compiler deduced the right type
274:24 - and we are going to go to visual studio
274:26 - code and actually try this out
274:28 - okay here i am in my working folder i am
274:32 - going to open my template project i'm
274:34 - going to copy that
274:36 - and i'm going to
274:37 - save my files in the auto project here
274:41 - so i am going to go in and put in my
274:44 - files i'm going to go up again and i am
274:47 - going to close whatever it is i have in
274:49 - visual studio code because we're going
274:51 - to create a new project i am going to
274:53 - open my new folder we're going to close
274:55 - the welcome screen here and we're going
274:57 - to remove whatever it is we don't need
274:59 - for this project
275:01 - and we are going to put in the code we
275:03 - basically had in the slides i am pasting
275:07 - this code in to save on some time
275:10 - because i don't want you to see me type
275:11 - these things we're going to save some
275:13 - seconds here
275:14 - so the first statement here declares a
275:17 - variable var1 the type we don't really
275:20 - know but we're going to let the compiler
275:22 - deduce that for us
275:24 - and we can try and actually hover over
275:26 - this and we're going to see that the
275:28 - compiler already deduced that this is an
275:30 - integer if we go to vira 2 this is a
275:33 - double if we go to var3 you see it's a
275:36 - float if you go to var4 it's long double
275:40 - if you go to wire 5 it's a character you
275:42 - can see that visual studio code can even
275:45 - see what the compiler is going to deduce
275:47 - before we even compile the code this is
275:50 - the beauty of visual studio code we're
275:52 - going to look at virus 6 you're going to
275:55 - see that it's going to be unsigned and
275:57 - if we go to var 7 it's going to be
275:59 - unsigned long if we go to var 8 it's
276:03 - going to be long long this is really
276:05 - cool and you can see that our types are
276:07 - correctly deduced visuals video code was
276:10 - really helpful in showing us these types
276:13 - but we want to be sure by running this
276:16 - piece of code and seeing whatever size
276:19 - the deduced type is for example for var1
276:22 - we guessed that it's going to deduce an
276:25 - end so it better be a four
276:28 - in size we're going to try and run this
276:30 - we're going to open our terminal here
276:33 - and we're going to go to terminal and
276:35 - run task we're going to build with gcc
276:38 - and by the way if you want you can build
276:40 - with the compiler from microsoft by
276:43 - coming to terminal here and choose it
276:46 - with world with msvc but gcc is my
276:49 - favorite compiler and i am going to use
276:51 - it if i can so we're going to hit enter
276:55 - and enter we're going to see that our
276:58 - rooster.exe file is in place if we run
277:01 - it we're going to see our sizes so var
277:04 - one occupies four bytes in memory
277:07 - var2 occupies for eight bytes in memory
277:11 - because it is
277:13 - double fire 3 occupies 3 bytes because
277:15 - it is a float var4 occupies 16 bytes
277:18 - because it is a long double
277:20 - and var 5 better occupy 1 byte because
277:24 - it is a character and we see the same
277:26 - data for
277:27 - vera 6 virus 7 and var 8 and this proves
277:30 - that the auto keyword is really doing
277:33 - its job it is deducing the types for our
277:36 - variables without us explicitly
277:40 - specifying the variable type we didn't
277:42 - have to do something like and or double
277:45 - or whatever we can let the compiler do
277:47 - that for us and this will come in handy
277:50 - many times this is really all we set out
277:53 - to do in this lecture and i hope you
277:54 - found it interesting in the next one
277:56 - we're going to look at how we can do
277:58 - assignments and assign data to our
278:01 - variables in a unified way go ahead and
278:04 - finish up here and we'd be there in this
278:07 - lecture we're going to learn about
278:08 - assignments and the basic idea i really
278:12 - want to drive home here is that after a
278:15 - variable is initialized like we've been
278:18 - doing all along you can later assign a
278:21 - new value to it for example here we have
278:24 - our one declared it is an integer we can
278:27 - print it out and it is going to print
278:28 - one two three but later in the program
278:31 - we can put in another value for example
278:33 - here we are putting in a 55 and if we
278:36 - print var1 it's going to be 55 this time
278:39 - the same idea can be extended to doubles
278:42 - you see here we are doing the same thing
278:44 - booleans we are doing the same thing
278:46 - here the state is declared force and we
278:49 - are printing that and after we are
278:51 - changing this to a true value and if we
278:54 - print that it's going to be true one
278:56 - thing you really need to be careful
278:58 - about is if you are doing auto type
279:01 - deduction the type is not very apparent
279:04 - by looking at the declaration of the
279:06 - variable here for example here by
279:08 - looking at o2 var 3 we don't really know
279:12 - what that is and it is very easy to try
279:15 - and put in a value that is illegal for
279:17 - example here we have deduced an unsigned
279:20 - integer which is only going to store
279:23 - positive numbers but we are putting in a
279:26 - minus 22 and this is going to be a
279:28 - disaster we're going to get a compiler
279:30 - error and this is going to be bad so be
279:33 - careful when you are doing a type
279:35 - deduction in your assignments that you
279:38 - do to your variables this is really all
279:40 - we have to share in this lecture let's
279:43 - hop over to visual studio and show you
279:45 - this in action okay here i am in my
279:48 - working folder the project we're going
279:50 - to be working on is four nine here
279:52 - assignments i am going to grab my
279:55 - template files and put that in this
279:57 - folder here and i am going to open this
280:00 - up in visual studio code so let's close
280:02 - whatever it is we have now
280:05 - and open the folder and we're going to
280:08 - close the welcome screen here we don't
280:10 - want it and remove whatever we don't
280:13 - want from this file here the first thing
280:16 - we want to do is put in the code for our
280:18 - integer variable var1 and show you that
280:21 - you can
280:22 - assign a new value to it after it was
280:25 - initialized and if we run this code
280:27 - we're going to see var1 to b123 and the
280:31 - second statement is going to say var1
280:34 - equals
280:35 - 55. that's what we're going to see let's
280:38 - bring up our terminal and we are going
280:40 - to run the task to build with gcc
280:44 - and if we hop over here in the terminal
280:48 - and do dir
280:49 - we're going to see that our rooster.exe
280:52 - file is in here if we run it we're going
280:55 - to see var one one two three var 155
280:59 - exactly what we expect we have stored in
281:01 - a one two three at initialization using
281:05 - braced initialization here but after
281:08 - later on in our program we have decided
281:11 - to put a different value in this
281:14 - variable here
281:15 - essentially reusing it to store
281:17 - something else this is the basic idea
281:20 - here we can do the same things with
281:22 - doubles but before we do that let's put
281:24 - in a separation line so that we can see
281:27 - these vents clearly in the terminal and
281:30 - we're going to go down and put in our
281:32 - code for a double
281:34 - so we have a double variable called var2
281:37 - initially it has 44.50
281:40 - in and then we're going to assign a new
281:43 - value to it and that's going to be 99.99
281:46 - if we print that out we're going to see
281:48 - that
281:49 - let's work and see this in action we're
281:51 - going to build with gcc
281:54 - if we
281:56 - run the program now it's going to save
281:58 - r1 is one two three four one fifty five
282:01 - but we're also going to see that viral
282:03 - two starts out 44.55
282:06 - but after we put in the
282:09 - 99.99 it's going to show up here okay
282:12 - let's put in another separation line
282:15 - because we're going to need that in a
282:16 - minute
282:18 - we can do the same things with booleans
282:21 - here we are using this as just an
282:24 - example but this same concept
282:26 - essentially extends to any other kind of
282:29 - variable you're going to have in your c
282:31 - plus plus code if you initialize it with
282:34 - some value you have the option to change
282:37 - that value later on in your program by
282:40 - assigning that value to that variable
282:42 - essentially what we are doing here the
282:45 - variable state which is a bull
282:47 - was initialized to false we're going to
282:50 - print that out and notice that we have
282:52 - this setting to allow us to see true or
282:54 - false instead of ones and zeros we have
282:57 - seen this in a few lectures back
283:00 - and later on we are assigning true to
283:02 - this state and we are printing that so
283:05 - if we print these things out we're going
283:07 - to see false and true for the state here
283:11 - so let's build
283:13 - we're going to use gcc
283:16 - and the world is good if we run the
283:18 - program
283:19 - we're going to see false and true and it
283:22 - is exactly what we expect again you
283:24 - really need to be careful when you are
283:26 - using auto type deduction because you
283:29 - might have some serious problems if you
283:31 - are not paying attention let's put in
283:33 - the code so that we can play with it
283:36 - here we have a variable called var 3 and
283:39 - the type of it is not specified
283:41 - explicitly we are letting the compiler
283:44 - deduce this and because our initializer
283:47 - here is an unsigned integer the compiler
283:50 - is going to deduce that it is an
283:53 - unsigned integer the problem will come
283:55 - if you try to store in a negative number
283:58 - the compiler is not going to give you a
284:00 - compiler arrow it is going to silently
284:03 - put in some garbage value
284:05 - that we don't really want in there we
284:07 - want a minus 22 and you can see that
284:11 - this is what the compiler is turning our
284:13 - value into we want a minus 22 in this
284:16 - for three but if you hover over this
284:19 - minus sign here in visual studio code
284:22 - you're going to see that the value that
284:23 - we have in is not what we put in we put
284:26 - in a minus 22 and we are getting a
284:29 - really large number close to 4 billion
284:32 - so this is really something that can go
284:34 - silently wrong in your code and you're
284:36 - going to have
284:37 - a hard time trying to figure out why
284:39 - your code is not doing whatever it is
284:41 - you want so be careful about this let's
284:44 - try and weld this so we're going to
284:46 - build with gcc
284:48 - the world is going to be good you're
284:49 - going to see that we're not even going
284:50 - to get a compiler arrow if we run this
284:54 - and we're going to see that viral 3 is
284:56 - exactly what visual studio could guess
284:59 - and it is not good it is this value here
285:02 - and the problem is that the compiler is
285:04 - silently putting in a garbage value and
285:07 - not what we want here because virus 3 is
285:10 - basically not capable of storing
285:12 - negative numbers so the compiler is
285:14 - going to do its best and put in a
285:16 - garbage value and this is not what you
285:18 - want and you need to be aware of this
285:21 - this is really all we set out to do in
285:23 - this lecture i hope you know about
285:25 - assignments and be careful when you are
285:28 - doing assignments on variables whose
285:30 - types are deduced with auto and we're
285:33 - going to stop here in this lecture in
285:35 - the next one we're going to try and
285:36 - recap what we saw in this chapter go
285:39 - ahead and finish up here
285:41 - and meet me there in this lecture we're
285:43 - going to recap what we saw in this
285:46 - chapter and this chapter was really all
285:48 - about variables and data types we had a
285:52 - chance to look at different types that
285:54 - we can use in c plus plus we saw that we
285:56 - have fundamental types we can use to
285:58 - represent integers floating points
286:01 - booleans and we also saw that we can do
286:05 - type deduction with auto we had a chance
286:08 - to make it clear that data is
286:10 - represented in memory as zeros and ones
286:13 - and that there are some kinds of
286:15 - transformations we do on these pieces of
286:18 - data to turn them into a form that is
286:21 - easily usable and manipulable by humans
286:24 - and we saw that for integral types or
286:27 - integers we could do that through number
286:30 - systems and we had a chance to look at a
286:32 - few number systems like binary octal and
286:35 - hexadecimal and we had a chance to play
286:38 - with all these variable types in visual
286:41 - studio code and see the nuances of how
286:44 - you really work with them i would like
286:46 - to welcome you in this new chapter and
286:49 - this one we're going to be looking at
286:51 - operations we can do on our data and
286:55 - there is a bunch of them we can add
286:57 - things up we can subtract numbers we can
286:59 - divide numbers we're going to see all
287:01 - kinds of crazy operations we can do
287:04 - on the data all the variables that we
287:06 - have in our c plus plus program we are
287:10 - also going to have a chance to look at
287:11 - how we can format stuff when we print
287:14 - them out to stdc out and we are going to
287:17 - be using some utilities from the c plus
287:20 - plus standard library to do some
287:22 - operations on our variables this is
287:25 - going to be a fun chapter i can't wait
287:27 - to get started let's go in the next
287:29 - lecture and start doing this
287:31 - in this lecture we're going to be
287:33 - looking at some basic operations you can
287:35 - do
287:36 - on the data in your c plus plus program
287:39 - and we are going to be specifically
287:41 - looking at addition subtraction dividing
287:44 - numbers the modulus operator and
287:46 - multiplying stuff we have seen addition
287:49 - before
287:50 - here we have a simple example we have a
287:53 - variable called sum and we are
287:55 - initializing it with two numbers that we
287:58 - are adding up number one and number two
288:00 - this is something you can do in your c
288:02 - plus bus program you can also do
288:05 - some other things for example we have
288:07 - another one called other sum and we are
288:10 - adding up some other numbers and we are
288:12 - going to collect the result into this
288:15 - other sum
288:16 - variable and we're going to print these
288:19 - things out so that you can see them on
288:21 - your command prompt this is how you can
288:24 - do addition and we're going to have a
288:25 - chance to play with this in visual
288:27 - studio code in a minute we can also do
288:30 - subtraction we can take a number and do
288:33 - minus another number like we are doing
288:35 - here we're going to store the results in
288:37 - this div variable and we can do some
288:40 - other things
288:41 - and down here you see another example in
288:44 - other diff here we're going to subtract
288:46 - numbers and store the result in other
288:49 - def and we are also going to print this
288:52 - out you can also multiply stuff this is
288:54 - how you can do this you use this
288:56 - operator here it is the star operator
288:59 - and this is an operator that many
289:01 - programming languages use to do
289:03 - multiplication you should get familiar
289:06 - with this and again we print out the
289:09 - result so that you can see that this is
289:11 - actually working we can also do division
289:15 - division for integers is a little tricky
289:17 - if you are seeing this for the first
289:19 - time
289:20 - if we take for example
289:22 - 31 and divide that by 10
289:26 - we're not going to get fractional
289:27 - numbers c plus plus is going to try and
289:30 - figure out how many times it can fit 10
289:33 - in 31 and we are visualizing this here
289:37 - so in 31 we can only fit 10 three times
289:41 - so the result of 31 is going to be three
289:44 - this is the meaning here
289:46 - okay with integer division you're not
289:47 - going to be getting fractional numbers
289:50 - this is something you should really
289:51 - understand we have another operator that
289:54 - is called modulus operator and this
289:57 - operator is represented by this
289:59 - percentage symbol that we are doing here
290:02 - and the result of this operation here is
290:04 - going to be what remains
290:06 - after you have done the division of 31
290:10 - and 10. and here the result is going to
290:12 - be one and you might be wondering why
290:14 - this is useful it is going to be useful
290:16 - in many applications
290:18 - and i think we're going to have a chance
290:19 - to play with this later in the course
290:22 - but right now you just need to be aware
290:24 - of this operation and what it does okay
290:27 - these are the operations we're going to
290:28 - be learning about and playing with in
290:30 - this lecture let's head to visual studio
290:33 - code and actually play with this okay
290:36 - here we are in our working folder for
290:39 - this chapter you see that i have
290:41 - prepared all the lectures we're going to
290:43 - do in this chapter and i have my c plus
290:46 - 20 template project in place i am going
290:49 - to do what we have been doing all along
290:52 - so i am going to take these files and
290:54 - put them
290:55 - in the current lecture which is basic
290:58 - operations
290:59 - and i am going to paste those in and i
291:02 - am going to open this folder in visual
291:04 - studio code so let's do that pretty
291:06 - quick we are going to close the welcome
291:08 - screen here and we are going to open our
291:10 - main cpp file and we are going to remove
291:14 - things we don't need here the first
291:16 - thing we want to play with is addition
291:18 - so we're going to say that and we're
291:20 - going to declare two end variables we're
291:23 - going to call this number one and we're
291:25 - going to put in a two for example
291:27 - and we're going to do a number two
291:30 - and we're going to put in a seven why
291:32 - not and what we can do we can say
291:35 - result equals number one plus number two
291:39 - and we're going to store the result of
291:41 - this operation and the result variable
291:44 - here so what we can do is say sddcl and
291:47 - we're going to print the result we can
291:50 - try and compile this and see the result
291:53 - let's open our terminal here
291:55 - and we're going to build with gcc as we
291:58 - always do
291:59 - the world is going to go through and if
292:02 - we run rooster here we're going to see
292:04 - that the result of our operation is 9.
292:08 - so this is how you can do addition
292:10 - you can also do subtraction and here we
292:13 - know to declare a new variable we're
292:15 - going to store the result
292:17 - in
292:17 - our result variable here so what we're
292:20 - going to do here is say subtraction and
292:23 - we're going to say result
292:25 - equals for example let's take number two
292:28 - minus number one this is the operation
292:31 - we want to do this is number two what we
292:34 - are going to be storing in this result
292:36 - here is going to be a 5 because we are
292:39 - taking 7 and subtracting 2. i hope this
292:42 - makes sense so if we grab this line here
292:46 - and paste it in here so that we save on
292:48 - some typing time
292:51 - and i try to build again
292:53 - we're going to
292:54 - run the world task with gcc
292:57 - and we're going to run rooster again it
293:00 - is going to say result is 5 because we
293:02 - are
293:03 - taking 7 minus two here the result is
293:06 - going to be five we can also do a
293:09 - subtraction operation that is going to
293:11 - result in a negative number so for
293:14 - example we can say result equals
293:18 - number one minus number two
293:20 - and this is going to give us a negative
293:22 - number because two minus seven is going
293:24 - to be minus five so
293:27 - we're going to print that here i'm going
293:29 - to paste this end because i still have
293:31 - this on my clipboard
293:33 - if i bolt with gcc and run my program
293:37 - we're going to get -5 as a result of
293:40 - this operation here this is how you can
293:43 - do subtraction we can also do
293:45 - multiplication so let's go down here and
293:47 - say that and we're going to say result
293:50 - equals number one multiplied by number
293:53 - two and this is the operator we used to
293:56 - do multiplication in programming
293:58 - languages we're going to put in our
294:00 - print statement here
294:02 - and we're going to world with gcc
294:05 - and if we run rooster now we're going to
294:08 - get 14 because we are taking
294:12 - 2 and multiplying that with 7. this is
294:14 - how you can do multiplication
294:17 - so what happens if you take
294:20 - seven and divide that with two try to
294:22 - give this a guess based on what we saw
294:24 - in the slides we're going to go down
294:26 - here and do division and we're going to
294:28 - say result equals number two divided by
294:32 - number one and uh
294:34 - we're going to try and print this out if
294:36 - we build this the world is going to go
294:38 - through and if we run this we're going
294:41 - to see that result is three
294:43 - so to really make sense of this let's
294:45 - look at these numbers we are taking
294:47 - number two and dividing that with number
294:49 - one so it is seven
294:51 - divided by two
294:53 - and because we can't store fractional
294:55 - numbers in an integer the fractional
294:58 - part is going to be basically chopped
295:01 - off and we're going to store a three
295:03 - because
295:04 - two can fit in seven
295:06 - only three times i really hope this
295:08 - makes sense the last operation we're
295:10 - going to look at is modulus
295:12 - and it is a way to capture the reminder
295:15 - of a division operation so we're going
295:18 - to do result to play with us
295:20 - and we're going to say number two and
295:23 - we're going to say modulus using the
295:25 - percentage operator here and we're going
295:27 - to say number one
295:29 - and we're going to print the result of
295:31 - this and uh
295:33 - take a look at this here and try to
295:35 - guess what we're going to be doing what
295:37 - we're doing here is really
295:39 - seven
295:40 - modulus
295:41 - two
295:43 - and we're going to take seven divide
295:45 - this by two
295:46 - and the reminder of that is going to be
295:49 - one and that's what we're going to store
295:52 - in this results variable here and if we
295:54 - print that we expect to get a one here
295:57 - this is what modulus does let's build
296:00 - and build with gcc the world is going to
296:03 - go through if we run rooster here we're
296:06 - going to get a one let's do what we used
296:08 - in the slide so that this really makes
296:10 - sense we're going to go down here and i
296:13 - do
296:14 - equals 31 modulus 10. this is what we
296:18 - used in the slides
296:20 - so we're going to print the result here
296:22 - and here we are really asking
296:24 - what is going to be the reminder if we
296:27 - take 31 and divide that by 10 and that
296:30 - reminder is going to be stored in this
296:32 - research variable so here we're also
296:34 - going to get a one so let's weld with
296:37 - gcc and we're going to run the program
296:40 - and we are also going to get a one down
296:43 - here again the modulus operator can be
296:46 - hard to understand for beginners but it
296:49 - is really capturing the reminder of the
296:51 - division again we can see that here we
296:54 - are asking how many times can 10 fit in
296:58 - 31 and we visualize this here it can
297:01 - only fit in three times and the reminder
297:04 - is going to be this red thing you see
297:06 - here it's going to be one and when we do
297:08 - a modulus operation here we are
297:10 - interested in that reminder and that's
297:12 - what we're going to be storing in
297:14 - whatever variable that is capturing the
297:16 - result of this modules operation
297:20 - and that's what we basically have here
297:22 - and this is really all we set out to do
297:24 - in this lecture now i hope you have a
297:26 - good understanding of these operations
297:28 - you can do on integers we have used
297:31 - integers here but you can really do
297:34 - these operations on numbers except for
297:37 - the modulus operator which is really
297:39 - going to make sense for integral types
297:42 - so
297:43 - you can't really do modulus on floating
297:45 - points or fractional numbers that's not
297:48 - going to make any sense at all we're
297:50 - going to stop here in this lecture in
297:52 - the next one we're going to learn about
297:53 - precedence and associativity a very
297:56 - important concept for your operations in
297:59 - your c plus plus programs
298:01 - in this lecture we're going to learn
298:02 - about precedence and associativity so
298:05 - what do we mean by precedence and
298:07 - associativity really what we mean by
298:10 - this is a set of rules that we can
298:12 - follow
298:13 - to know what to do
298:15 - when we have multiple operators in the
298:18 - same expression
298:19 - like in the example we have here if they
298:22 - tell you to evaluate the result of this
298:24 - expression
298:26 - if we don't have clear rules to follow
298:28 - we might have multiple answers and we
298:31 - want to know which one is right or wrong
298:33 - for example one might want to do a and b
298:36 - first and then do c and then do d but
298:39 - one might want to do e minus f
298:43 - and do b multiply by c and then do
298:46 - things in different ways and get
298:48 - different results
298:49 - hopefully you are saying that this may
298:52 - be a big problem what we get from
298:54 - precedence and associativity is the
298:57 - rules we can follow to know which
298:59 - operator we have to do first for example
299:02 - in c plus plus
299:04 - the multiplication and division operator
299:07 - have to be done before you do addition
299:10 - and subtraction and if you want to
299:12 - evaluate this expression here you're
299:15 - going to have to do b and c first and
299:18 - then do d and e once you have those
299:21 - results then you can do addition and
299:23 - subtraction but the question remains
299:26 - still
299:27 - what do we do first if we have only
299:30 - addition and subtraction in an
299:32 - expiration and we solve that problem
299:35 - with associativity associativity defines
299:38 - if you do the operations from the left
299:41 - or from the right
299:42 - and again these things might not make
299:44 - sense yet we're going to do an example
299:47 - and you're going to really see what is
299:49 - meant by this
299:50 - to summarize precedence tells you which
299:53 - operation you can do first and
299:56 - associativity is going to tell you in
299:58 - which direction you're going to go from
300:00 - the left or from the right and some
300:02 - operators are going to be left
300:04 - associative and that means that you're
300:06 - going to start evaluating them from the
300:08 - left some operations are going to be
300:11 - right associative and you're going to
300:13 - start evaluating them from the right and
300:16 - i am not making these things up there is
300:18 - actually a c plus plus operator
300:20 - precedence table that you can consult to
300:24 - know which operators
300:26 - you should do first if you really are
300:29 - evaluating this thing with your mind
300:31 - okay for example if you look in this
300:33 - table there are many operators we
300:35 - haven't seen yet but that's not the
300:37 - problem the most important thing here is
300:40 - to know what precedence and
300:42 - associativity are and when we get to
300:45 - learn about these new operators you can
300:47 - come here and know where they sit in
300:50 - this precedence table for example we
300:52 - know how to do addition multiplication
300:56 - and modulus
300:57 - we see that the precedence for
301:00 - multiplication division and modulus
301:03 - is higher than for addition and
301:06 - subtraction
301:07 - and we can use this in our operators to
301:10 - know
301:11 - which one is going to be evaluated by
301:13 - our compiler first another thing i want
301:16 - you to notice in this table is this
301:18 - column here on associativity if you go
301:21 - back to our familiar operators here
301:24 - you're going to see that
301:25 - these operators are left to right so you
301:28 - should start evaluating things from left
301:31 - to right but some operators have right
301:35 - to left associativity and when we get to
301:38 - these operators you will start doing
301:40 - things from right to the left okay i
301:42 - think it is time we went to visual
301:45 - studio code and actually played with
301:47 - this thanks here we are in visual studio
301:49 - code we are in our working folder we are
301:53 - going to grab our template projects
301:55 - we're going to copy this and put that in
301:57 - our lecture on precedence and
302:00 - associativity we're going to put that in
302:02 - here we are going to open this project
302:05 - in visual studio code we are going to
302:07 - get rid of things we don't need and
302:09 - remove this here in the body and we are
302:12 - going to put in our test code so that we
302:15 - don't have to type this and save on time
302:18 - we have a few variables here a through g
302:21 - and we have an expression here or a
302:24 - statement
302:25 - that is combining multiplication
302:28 - division addition and subtraction and we
302:31 - have to figure out which operation we're
302:34 - going to do first
302:35 - i would challenge you to do this in your
302:38 - mind and try to guess what the result is
302:40 - going to be before we run this in our
302:43 - compiler we're going to compile this
302:46 - with gcc and we are going to open our
302:49 - terminal here
302:50 - and if we do durham we're going to see
302:53 - that we have rooster.exe
302:55 - if we run it we're going to see that the
302:58 - result is 30. how did we come up with
303:01 - that well the precedence and
303:03 - associativity table says that
303:06 - multiplication and division
303:08 - have to be done first
303:10 - before addition and subtraction we are
303:14 - going to take b and c and multiply those
303:16 - so b and c multiplied we're going to get
303:19 - a 24 we're going to try and do this in
303:21 - our brain d divided by a we're going to
303:24 - do that
303:25 - so d divided by e we're going to get a 3
303:28 - so we're going to have a 3 here and
303:31 - after we have this we're going to do
303:33 - addition and subtraction so we're going
303:36 - to take a and add that to the result of
303:39 - b and c so we're going to say
303:42 - 6 plus 24 which is the result of b and c
303:46 - we're going to minus the results of d
303:48 - and e and we're going to do minus here i
303:51 - hope you are following and then we're
303:53 - going to minus f and plus g we're going
303:56 - to minus f which is 2
303:59 - and do a plus g
304:01 - which is 5. okay so this is our
304:05 - expression here and now that we have
304:07 - this we have to think about how we're
304:09 - going to do this we can try to do this
304:11 - from the right do two plus five and then
304:14 - do three minus two plus five and go from
304:18 - right to left but our associativity
304:21 - table says that addition and subtraction
304:25 - have left to right associativity so we
304:28 - will start from the left so we're going
304:30 - to do 6 plus 24 we're going to get 30
304:34 - we're going to minus 3 and we're going
304:36 - to get 27 we're going to minus 2 we're
304:38 - going to get 25 we're going to add 5
304:41 - we're going to get 30. i hope you are
304:43 - following and we are really following
304:45 - the rules from our c plus plus operator
304:48 - precedence table here okay so this is
304:50 - really how you would use this precedence
304:53 - and the search activity rules to
304:56 - evaluate your expressions okay here i
305:00 - have another example for you so try to
305:03 - evaluate what we're going to get from
305:05 - this expression here
305:07 - we have a divided by b divided by c plus
305:10 - d minus e plus f try to do this in your
305:13 - brain and try to guess what we're going
305:15 - to get from the compiler if we print
305:18 - this out
305:20 - we're going to put in our htdc out
305:22 - statement here and we're going to try
305:24 - and build this with gcc of course we're
305:28 - going to run the rooster and you're
305:30 - going to get a 24. so how did we come up
305:33 - with that we're going to start by
305:35 - division and multiplication and again
305:39 - where do we start do we do b and c first
305:42 - or do we do a and b first well we can
305:46 - check our precedence table here
305:48 - and we're going to check the
305:50 - associativity of multiplication and
305:53 - division we're going to go to this entry
305:56 - here 13 and we see that it is left to
305:59 - right associative these operations here
306:02 - are left to right associative so what
306:05 - we're going to do we're going to start
306:06 - from left and go to right so we are
306:09 - going to take a and divide by b if we
306:12 - take a divided by b we're going to get a
306:14 - 2 so let's type that here then the
306:17 - result of that is going to be multiplied
306:20 - by c and if we go up we're going to see
306:22 - that c is eight so we're going to
306:24 - multiply by eight
306:26 - and get six so we can replace this with
306:29 - a 16
306:30 - and we should be here
306:32 - then we're going to add d d is nine then
306:36 - we're going to subtract
306:38 - e
306:39 - which is
306:40 - three then we're going to add f which is
306:44 - a five so we have 16 plus nine this is
306:47 - going to give us 25 minus three
306:50 - okay by checking this out i see that i
306:52 - made a mistake
306:54 - f is not
306:55 - five it is a two we have here
306:58 - and if we do this from left to right
307:01 - because addition and subtraction are
307:03 - left associative we have to do them from
307:05 - left to the right we're going to take 16
307:08 - and add a 9 we're going to get at 25
307:11 - minus 3 we're going to get 22 plus 2 we
307:14 - are going to get 24 and that's what we
307:17 - have here i really hope this makes sense
307:19 - okay so we have seen how we can use this
307:22 - precedence table
307:24 - but sometimes you want to make it really
307:26 - clear which operations should be done
307:29 - first
307:30 - and you can do that by using parentheses
307:33 - around your expressions let's grab the
307:36 - first expression here and do it again
307:38 - we're going to copy it
307:40 - and go down
307:41 - and put that in place and we're going to
307:44 - store the result in our result variable
307:48 - and notice that we are reassigning these
307:51 - things to the result variable so that we
307:53 - don't have to declare another variable i
307:55 - think this is
307:56 - clean and that's what we're doing here
307:59 - so what we can do here is make it clear
308:02 - that we want multiplication done first
308:05 - by using parenthesis
308:07 - and
308:08 - make it clear that we want the
308:11 - division to be done first
308:13 - and when you do this the compiler is
308:15 - going to see that you want this
308:16 - operation here done first and that's
308:19 - what it is going to do and if we print
308:22 - result again we're going to get exactly
308:25 - the same thing we had before stdc out
308:28 - result
308:30 - and we're going to put result out and
308:32 - let's make it clear that we are using
308:35 - parents here to
308:37 - signal which operation we want to be
308:39 - done first we can compile this with gcc
308:42 - we're going to run the task to
308:45 - build with gcc
308:47 - and if we run the program
308:50 - we're going to see that the result is 30
308:53 - exactly what we had before but now it is
308:56 - very clear to the reader of this piece
308:59 - of code that we want b and c done first
309:02 - they don't have to go through the
309:04 - precedence table to really try and
309:06 - figure this out potentially wasting
309:09 - precious time another thing you can do
309:11 - with this is for example what if the
309:14 - precedence table is not working
309:16 - according to your needs for example you
309:19 - really want a and b
309:21 - done first you can specify this with
309:23 - parents here and what this is basically
309:26 - going to do is going to force the
309:28 - compiler to do this first it's no longer
309:31 - going to do b multiply by c and d
309:33 - divided by e it's going to evaluate this
309:37 - first then it's going to follow the
309:39 - order in the precedence table that we
309:41 - have seen before so try to guess what
309:44 - we're going to get now and i am going to
309:46 - run the code and we're going to
309:48 - go through this together so let's run
309:51 - task and we're going to run rooster now
309:54 - you see that the result is 72. what is
309:57 - happening here well let's go through
310:00 - this line by line we are doing a plus b
310:03 - which is a
310:05 - 9 so we're going to get a nine here
310:08 - we're going to put that here as a
310:09 - comment then we're going to multiply
310:11 - that by c
310:13 - so we're going to do 9 multiply by 8 and
310:16 - that's going to yield a 72
310:20 - and by that time we're going to be here
310:23 - and we're going to do the division first
310:26 - d by e
310:28 - then we're going to take nine and divide
310:30 - by three that's going to yield the three
310:33 - so we're going to have a three here
310:35 - minus 3
310:36 - we're going to minus f which is a 2 and
310:39 - we're going to do plus g which is a 5.
310:42 - if we evaluate this
310:44 - we're going to get 72 minus 3 which is
310:47 - going to be 69 minus 2 it's going to be
310:50 - 67 plus 2 it's going to be 72 and that's
310:54 - what we have here hopefully you can see
310:57 - that using the parents not only can you
311:00 - make it very clear which operation you
311:02 - want to be done first you can also
311:04 - define the rules that are prescribed by
311:07 - the precedence tables that are defined
311:10 - in c plus plus i hope this makes sense
311:12 - and this is really all we set up to do
311:14 - in this lecture to learn a little more
311:16 - about precedence and associativity
311:19 - and my advice to beginning programmers
311:22 - is not to rely on the president's table
311:24 - too much it is to try and make your
311:27 - intent very clear using parenthesis and
311:30 - anyone reading your code you want to
311:32 - have to go check these rules in
311:35 - the reference c plus plus documentation
311:37 - they are going to directly understand
311:39 - what your expression is going to do and
311:42 - that's a good thing readability of your
311:44 - code is really something you should
311:46 - strive for this is really all we set out
311:48 - to do in this lecture i hope you have a
311:50 - better idea about precedence
311:54 - and associativity we are going to stop
311:56 - here in this lecture and the next one
311:58 - we're going to learn about some cool
312:00 - things we can do with addition and
312:02 - subtraction
312:03 - go ahead and finish up here and meet me
312:06 - there in this lecture we're going to be
312:07 - learning about prefix and postfix
312:10 - addition and subtraction we have an
312:13 - example here and it is a simple example
312:15 - we've seen a lot of times by now we have
312:18 - a variable value it is an integer and we
312:21 - have a 5 inside we can add a 1 to it or
312:25 - we can increment it by one this is
312:28 - another term we use in programming
312:30 - languages when we say we are
312:31 - incrementing a value we are adding
312:34 - something to it in this case we are
312:36 - incrementing it by one and we are
312:40 - basically going to store a six and this
312:42 - value here so if we print this out we're
312:45 - going to get a six here
312:47 - this is what we would expect we are
312:49 - resetting the value to five and that we
312:51 - are going to minus one or decrement by
312:54 - one and the result is going to be saved
312:57 - in value again so the second stdc out
313:00 - statement here is going to print a 4.
313:03 - this is something you should expect
313:06 - now another thing we can do in c plus
313:08 - plus is do something like value plus
313:11 - plus here
313:13 - and what do we mean by that when you use
313:15 - a postfix
313:17 - increment operator like this
313:19 - the first thing you should know is that
313:21 - this is going to increment by one it's
313:23 - not going to increment by any other
313:25 - value c plus plus doesn't provide a way
313:28 - for you to specify another number to
313:30 - increment by so value plus plus here is
313:33 - going to increment by one but another
313:36 - thing you should know
313:37 - is that it's not going to increment
313:39 - directly what's going to happen here if
313:41 - you look to the top here we have a value
313:44 - 5 when execution hits this stdcl
313:47 - statement
313:49 - we are going to grab the value here so
313:52 - here we're going to really print a 5 but
313:54 - as soon as this statement is done the
313:57 - value is going to increment by one so
314:00 - the next time somebody is going to use
314:02 - this value here is he's going to find in
314:04 - a 6 and that's what we have here so the
314:07 - first one is going to print a five
314:09 - because we're going to grab the value
314:11 - in here as is but as soon as we have our
314:14 - value this is going to increment by one
314:17 - this is what we mean by this value plus
314:19 - plus here and the second statement is
314:21 - going to print sx because it is already
314:24 - incremented and we call this postfix
314:27 - increment because plus plus is after the
314:30 - value here and this is really what this
314:33 - operator does and sometimes it is going
314:36 - to come in handy in your c plus plus
314:38 - applications we can also do the same
314:40 - thing with minus minus it is going to
314:43 - grab whatever value we have in this
314:45 - variable so we have in a five so that's
314:47 - what we're going to print here
314:49 - and the next statement is going to find
314:52 - it already decremented by one because
314:55 - after we have our five we're going to
314:57 - decrement by one that's what we are
314:59 - saying here and we're going to find the
315:01 - nf4 because 5 decremented by 1 becomes a
315:05 - 4. i really hope this makes sense ok so
315:08 - what we have seen here is postfix
315:11 - increment and decrement but we can also
315:14 - do a prefix version of this thing if you
315:17 - look at the example we have here we have
315:19 - a five
315:20 - and we are saying plus plus value so
315:23 - this is going to increment the value
315:25 - directly so as soon as this statement is
315:28 - executed the plus plus value statement
315:31 - here we're going to have a 6 inside and
315:35 - if we print it we're going to get a 6
315:37 - and this is what you see here if we go
315:39 - down we are resetting our value and we
315:41 - are going to
315:42 - prefix increment in place
315:45 - so in here we are going to increment the
315:48 - value before we actually print it here
315:51 - and we are also going to get a six year
315:54 - i hope this makes sense and if you have
315:56 - any problem with this i think if we go
315:58 - in visual studio code you're going to
316:01 - have a better way to say this you're
316:02 - going to see the code running and make
316:04 - sense of it okay so i think that
316:07 - now you understand why we're going to
316:09 - have these numbers printed if we go down
316:11 - we can do the same thing with
316:13 - decrementing we have a value here it's
316:15 - five
316:16 - if we
316:17 - prefix decrement it it's going to be a
316:20 - four here and if we print it we're going
316:22 - to get a four
316:23 - if you go down here we are resetting
316:25 - that to five and we are going to prefix
316:29 - decrement in place and this is also
316:32 - going to print a four because we have a
316:34 - five here and if we decrement it by one
316:37 - we're going to get a four and that's
316:38 - what we're going to get here okay this
316:41 - is really all these prefix and postfix
316:44 - increment and decrement operators are
316:46 - about we are going to go in visual
316:49 - studio code and actually see this
316:51 - running okay here we are in our working
316:54 - directory we're going to do the usual
316:56 - we're going to copy code from our
316:57 - template project we're going to put that
317:00 - in here we're going to go up and open
317:02 - this up in visual studio code so we're
317:05 - going to remove things we don't need and
317:08 - we're going to remove this
317:09 - and we are going to put in the code we
317:11 - exactly saw in the slides here we have a
317:15 - value it is an integer and it is five
317:18 - if we increment it by one we're going to
317:20 - get a six here okay and if we print it
317:24 - that's what we're going to get we are
317:26 - resetting this to five and if we
317:28 - decrement it by one we're going to get a
317:30 - four here
317:32 - so if we run this piece of code we
317:35 - should have a six here printed out
317:37 - and a four
317:39 - down here
317:40 - we're going to bring up our terminal
317:43 - and build this with gcc the weld is
317:47 - going to go through
317:48 - and if we run the program we're going to
317:51 - get the value a6 and it is four and this
317:54 - is really what we expect here okay now
317:57 - that this is really clear we're going to
317:59 - go down and play with post fix
318:02 - increment and decrement
318:04 - i am going to put in a separator here so
318:07 - that we can clearly see in our terminal
318:10 - here and we are going to put in our test
318:13 - code that we are going to use
318:16 - to play with this let's bring this down
318:19 - a little bit so that you can see
318:20 - everything we can remove these things we
318:23 - don't need them anymore okay we are
318:26 - going to take the value we had we're
318:28 - going to
318:29 - reset that to a five
318:32 - and if we value plus plus here
318:34 - this is going to be a five because we're
318:37 - going to capture the value as is so here
318:40 - we're going to get a five
318:41 - but next time we get this value it's
318:44 - going to already be a sex because we
318:46 - increment immediately after capturing
318:49 - the value here so here we're going to
318:52 - get a 5 and here we're going to get a 6.
318:55 - i hope this makes sense
318:57 - and if we go down here we are resetting
319:00 - our value to 5 before we do any
319:03 - decrementation
319:04 - we are going to capture the value as is
319:07 - because we are doing post fixed
319:09 - decrement
319:10 - and here we are going to get a 5 because
319:13 - we are capturing the value as s
319:15 - but as soon as we capture our value
319:18 - we're going to decrement it and the
319:20 - other statement here is going to get a
319:22 - decremented value and that's going to be
319:25 - a 4. so here we're going to print 5 6 5
319:29 - 4.
319:30 - let's try and build this with gcc
319:34 - to see that we have no problems we have
319:36 - no problems the world is good if we try
319:39 - to run rooster now
319:41 - we are going to get the
319:44 - results we had before
319:47 - but uh for this code we just put in here
319:51 - the value is going to be a 5 and that's
319:53 - what we have here
319:55 - and we're going to get a 6 which is
319:56 - coming from here
319:58 - after we are going to decrement and we
320:01 - are going to capture the value as is
320:03 - we're going to get this 5 here and for
320:06 - the last statement we're going to get a
320:08 - 4 because the value is already
320:11 - decremented and that's the for we are
320:14 - seeing here
320:15 - i really hope this makes sense and this
320:18 - really covers
320:19 - the postfix increment and decrement
320:22 - operators the last thing we want to see
320:24 - in this lecture is that we can also do
320:28 - prefix increment and decrementation
320:31 - we're going to go down here and
320:34 - set up a place where we're going to be
320:35 - playing with this so we're going to say
320:37 - prefix
320:39 - and we are going to put in our code
320:41 - because i don't want to type all this
320:43 - that would waste your valuable time but
320:46 - i do encourage you to type these things
320:48 - out and really
320:49 - drill them in your brain because that's
320:51 - how you're going to learn okay let's
320:53 - bring this down so that we can
320:55 - understand this piece of code so we are
320:58 - starting by resetting our value to 5 and
321:01 - notice here that we do plus plus value
321:04 - this is going to increment value right
321:06 - away by this time the value is going to
321:08 - be six and if we print it out here we're
321:12 - going to have a six printed down we're
321:14 - going to reset it to five and then we're
321:16 - going to implement that in place this is
321:19 - also going to be printing six and if you
321:22 - go down we're going to do the same
321:23 - version of the same thing but we are
321:25 - going to be decrementing so we're going
321:27 - to decrement the value that we just
321:30 - reset here
321:31 - here it's going to become a 4 and that's
321:33 - what we're going to print and if we go
321:35 - down here we reset it again to a 5 and
321:38 - we prefix decrement it in place
321:41 - so the 5 here is going to become a 4
321:44 - in here and that's what we're going to
321:46 - print out if we build and run that's
321:48 - what we're going to get we're going to
321:50 - run our task to build with gcc
321:53 - the build is good and if we run our
321:56 - rooster application the results for the
322:00 - code we just put in here are just going
322:01 - to show up here
322:03 - and you see that we get a six six this
322:05 - is six
322:06 - the other six and for the last two
322:09 - statements we're going to be getting
322:11 - fours and that's what we have here i
322:13 - really hope that now you have a better
322:15 - idea of this prefix and postfix
322:18 - increment and decrement operators and
322:21 - you're going to make use of them when
322:24 - they really helped you design your
322:26 - applications better okay so these are
322:28 - your tools use them when they make sense
322:31 - another thing that i want to emphasize
322:33 - here is that these operators only
322:35 - increment or a decrement by one you
322:38 - can't make them
322:40 - do things in increments of five or seven
322:43 - or ten they are going to work in
322:45 - increments or decrements of one we are
322:48 - going to see a way we can do that with
322:50 - other operators in the last lecture but
322:52 - these prefix and postfix operators can't
322:55 - do that and another thing that some of
322:58 - you might be wondering about is if we
323:00 - have the same kind of operators with
323:03 - multiplication or division and we don't
323:06 - have those operators in c plus plus
323:08 - maybe we're going to have them in the
323:10 - future when they make sense but in the
323:12 - current version of c plus plus we don't
323:14 - have them we are going to stop here in
323:16 - this lecture in the next one we're going
323:18 - to learn about compound assignment
323:21 - operators in this lecture we're going to
323:23 - learn about compound assignment
323:26 - operators
323:27 - and these are operators that allow you
323:30 - to do an arithmetic operation like
323:33 - addition subtraction multiplication
323:35 - division and modulus and assign the
323:39 - result to a value in one go let's look
323:43 - at an example here we have value here
323:45 - which is 45 it is an integer and we're
323:48 - going to print that out but if you go
323:49 - down here we are doing value plus equal
323:54 - five and if you look at the comment here
323:56 - this is equivalent to if you did value
323:59 - equals value plus five so what this is
324:02 - going to do it's going to take whatever
324:03 - value is in this value here it's going
324:06 - to increment that by five so that's
324:08 - going to become a 50 and we're going to
324:10 - store that 50 results back in this
324:14 - variable here so by this time if we
324:16 - printed this out we're going to get a
324:17 - 50. again we're going to take the value
324:20 - it is a 45 we're going to add a 5 it's
324:23 - going to become a 50 and we're going to
324:25 - store that result back in this value
324:28 - variable here it's going to become 50
324:31 - and if we print here we're going to get
324:33 - a 50. this is the addition version of
324:36 - the compound assignment operator we also
324:39 - have a version for subtraction and we
324:42 - have an example of that here so it's
324:44 - going to take whatever value is in this
324:46 - value variable it is going to find in a
324:48 - 50 we're going to subtract 5 we're going
324:51 - to get a 45 and that's what we're going
324:54 - to store in this value here
324:56 - and by the time we hit this stdc out
325:00 - statement we're going to print a 45.
325:03 - again we have another version for the
325:05 - multiplication here so that we can
325:07 - really play with all these things
325:09 - we're going to take whatever value is in
325:11 - here we're going to multiply that by 2
325:14 - here we're going to get a 90 and that's
325:16 - what we're going to store back in this
325:18 - value and if we print here we're going
325:20 - to get a 90
325:22 - printed out we're going to go down and
325:24 - do a version for a division the value is
325:27 - 90 we're going to divide that by 30 and
325:30 - we're going to store the result back in
325:32 - value here and we're going to get a 30
325:36 - stored in here and if we print out
325:38 - that's what we're going to get here
325:41 - we also have a modulus version of this
325:43 - and it works really well
325:45 - here we have unit 30 we're going to take
325:47 - it and do modulus 11 and what is the
325:51 - reminder of dividing 30
325:54 - by 11. the reminder is going to be 8
325:57 - because
325:58 - 11 can only fit in 30 two times and
326:02 - we're going to be left with the knight
326:04 - because
326:05 - 30 minus 22 is eight and that's what
326:08 - we're going to store in the value here
326:10 - and if we print out that's what we're
326:12 - going to get again
326:14 - if you have trouble understanding this
326:16 - modulus operator here please go back in
326:19 - a few lectures back we had a chance to
326:21 - learn about it make sure you understand
326:23 - it and then come back here and this is
326:25 - all going to make sense
326:27 - this is really all compound assignment
326:30 - is all about we're going to head to
326:32 - visual studio code and actually play
326:35 - with us okay here we are in our working
326:39 - directory we're going to copy our
326:41 - template project as we always do
326:44 - and we're going to put that in our
326:48 - compound assignment operators
326:50 - lecture here
326:52 - we're going to come up and we are going
326:54 - to open this folder in visual studio
326:56 - code the project is going to show up in
326:58 - here and we're going to open our main
327:01 - cpp file and we are going to remove what
327:04 - we don't need
327:06 - we are going to put in our code so that
327:08 - we can start exploring this we have a 45
327:12 - and this variable here which is an
327:14 - integer if we print it out we're going
327:16 - to get a 45
327:18 - and down here
327:19 - we are doing a compound addition
327:23 - so what we are doing here we're going to
327:25 - grab whatever value is in this variable
327:28 - we're going to add a five we're going to
327:30 - get a 50 and that's what is going to be
327:32 - stored in here
327:34 - and if we print this out we're going to
327:36 - get a 50. let's put in a terminal here
327:40 - so that we can see this running and
327:42 - we're going to run the task to build
327:45 - with gcc as we always do here
327:48 - and if we run our rooster
327:50 - executable we're going to get the value
327:53 - is 50 and that's what we expect here
327:56 - okay this is the
327:58 - addition version of our compound
328:01 - assignment operator and it is really
328:04 - equivalent to doing this in two steps
328:07 - saying value equals value plus five
328:10 - you're going to get the same result if
328:12 - you do that here actually let's do this
328:14 - so that you don't think that i am making
328:17 - this up so let's comment this out and we
328:20 - are going to say volume
328:22 - equals value plus five and if we build
328:25 - again run the gcc task
328:29 - and run the application
328:31 - we're going to see the same thing we can
328:33 - also go down and run the subtraction
328:37 - version of this example here here we are
328:40 - taking the value that we have in here
328:42 - which is a 50
328:43 - we are subtracting 5 we're going to get
328:45 - a 45 and 45 is what we're going to store
328:49 - in this value here
328:51 - that's what we're going to see if we
328:53 - print this out so
328:54 - let's run the test world with gcc
328:57 - so that our changes are reflected in our
329:01 - output we're going to run this and we're
329:03 - going to get a 45 this is what we expect
329:06 - we are going to go down and do a
329:08 - multiplication version of this
329:11 - here we have our compound assignment
329:14 - statement we are taking whatever value
329:16 - we have in here which is a 45 we're
329:18 - going to multiply that by 2 and the
329:21 - result of that is going to be 90 and
329:24 - we're going to store that back in value
329:26 - here and if we print value here we're
329:28 - going to get a 19. let's build this run
329:31 - the gcc task and we're going to run our
329:33 - program and we're going to see that
329:35 - we're going to see this 90 here we can
329:37 - go down by a few lines and put in the
329:40 - code to play with a division version of
329:42 - this
329:43 - again this is going to do really the
329:46 - same thing only it's going to be doing
329:48 - this for division we're going to take
329:50 - whatever value we have in here which is
329:52 - going to be a 90 we're going to divide
329:54 - that by 3 we're going to get a 30 and
329:57 - that 30 results is going to be stored
330:01 - back in value here and if we print this
330:04 - out that's what we're going to get
330:06 - let's build again and the build is going
330:08 - to go through if we run
330:11 - our program we're going to get a 30. we
330:13 - are going to go down by a few lines and
330:15 - put in a modulus version of this we're
330:19 - going to grab whatever value we have and
330:21 - this variable here which is going to be
330:23 - 30 we're going to do modulus 11 on that
330:27 - value
330:28 - and that's going to be basically 30
330:30 - modulus 11. the result of that is going
330:33 - to be 8
330:35 - and we're going to store that result in
330:37 - value here and if we print that out
330:40 - that's what we're going to see in this
330:42 - output statement here we can build again
330:45 - run with gcc and if we run our rooster
330:49 - program we're going to get an 8 printed
330:52 - out and this is really all
330:55 - these compound assignments are about and
330:58 - you might be asking
331:00 - why go through the trouble to do
331:01 - something like this if i can do this
331:04 - like this well c plus plus gives you
331:06 - different way to do things different
331:08 - people have different preferences and
331:11 - some people me included like to do
331:14 - things this way because it is compact
331:16 - and once you use this you're going to
331:18 - get used to this you're not even going
331:20 - to think about it in this lecture here i
331:22 - just wanted you to be aware of this
331:25 - possibility because you are definitely
331:27 - going to see it in c plus plus code out
331:30 - there
331:31 - this is really all we set out to do in
331:33 - this lecture i hope you found it
331:34 - interesting we are going to stop here in
331:37 - this lecture in the next one we're going
331:39 - to learn about relational operators in c
331:42 - plus plus in this lecture we're going to
331:44 - learn about relational operators in c
331:47 - plus plus and these are basically
331:49 - operators you use to compare stuff let's
331:53 - look at a piece of code here we have two
331:56 - numbers one is 45 and another is 60 they
332:00 - are stored in integer variables number
332:03 - one and number two
332:04 - we can print them out and we're going to
332:06 - see them on the console or our terminal
332:10 - and if we go down we can really compare
332:13 - them we can use the less than operator
332:16 - less than or equal operator
332:19 - greater than greater or equal operator
332:22 - we can check and see if two numbers are
332:24 - equal by using two equal signs here be
332:27 - careful about these two equal signs
332:30 - because if you use one you're not going
332:32 - to be comparing numbers you're going to
332:34 - be taking the thing on the right and
332:36 - assigning that to the thing on the left
332:39 - so if you want to compare you're going
332:41 - to have to type two equal signs another
332:44 - operator we can use to compare stuff is
332:47 - exclamation mark and equal which is
332:50 - going to basically test if two numbers
332:52 - are equal
332:54 - and we're going to get the result one
332:56 - thing you should notice here is that we
332:59 - are wrapping our comparison expression
333:02 - into parenthesis that's because if we
333:05 - don't we're going to get a weird
333:07 - compiler error that i am going to show
333:10 - you when we get in visual studio code
333:12 - but we don't have enough tools to really
333:15 - understand this error
333:17 - at this moment so what we are going to
333:19 - do is avoid that problem by putting
333:22 - parenthesis around our comparison
333:24 - expression here we're going to go to
333:26 - visual studio code and actually see this
333:29 - in action here we are in our working
333:32 - directory we're going to grab the code
333:35 - from our template here and we're going
333:37 - to put that in the current project which
333:39 - is
333:40 - relational operators we're going to go
333:42 - in and put in our code and we are going
333:46 - to open this up in visual studio code
333:48 - we're going to get rid of things we
333:50 - don't need here we are going to put in
333:52 - our code so that we can explore these
333:55 - things we have two variables in one we
333:57 - have a 45 in another we have a 60 and
334:00 - these are integers the name for these
334:02 - variables are number one and number two
334:05 - we're going to print them out and we're
334:07 - going to see them on the console now we
334:10 - are going to compare them
334:11 - one thing i haven't told you yet is that
334:14 - these comparison operators evaluate to
334:18 - booleans in other words they are going
334:21 - to return true all false if you look
334:24 - down here
334:25 - we want to know if number one is less
334:28 - than number two and the result of that
334:31 - is whether that's true or false and this
334:33 - really makes sense
334:35 - so because of that we are using std bull
334:39 - alpha here to force sddc out to print
334:42 - this boolean value here as a true or
334:45 - false instead of a one or a zero and we
334:48 - have seen this before so if we try to
334:51 - build this and run this let's bring up a
334:54 - terminal we can use
334:56 - and we're going to run the test to build
334:58 - with gcc if we go down here and run our
335:02 - rooster program we're going to get our
335:04 - two numbers 45 and six and we want to
335:07 - know if number one is less than number
335:10 - two and that's true 45 is less than 60
335:14 - so the result of this expression is
335:16 - going to be true now you know how to use
335:18 - this operator one thing i want you to
335:20 - see is what could happen
335:23 - if you
335:24 - didn't use this parenthesis around this
335:27 - expression here let's try this out we're
335:30 - going to remove this parenthesis and
335:32 - we're going to try and world we're going
335:34 - to run the task to world with gcc and
335:37 - we're going to get a really weird error
335:40 - because
335:41 - the compiler is going to try and
335:43 - evaluate this operator first if we go
335:47 - back to our c plus plus operator
335:49 - precedence table
335:51 - and look at the operators we are trying
335:53 - to use in the sddc out statement we're
335:57 - going to see that the
335:59 - operator to print fans on the console
336:02 - has high precedence than our comparison
336:05 - operators here so the precedence for our
336:08 - operator to print things to sdd out is
336:11 - 11 so it is higher and the
336:15 - precedence for our comparison operators
336:18 - is nine and eight so the compiler is
336:21 - going to try and do this operator first
336:23 - if we come back in visual studio code
336:26 - the compiler is going to try and think
336:27 - that you are printing number one but
336:30 - then again it's going to see this less
336:32 - than sign and things are going to blow
336:34 - up we don't really have enough tools to
336:37 - understand what is going on right now
336:39 - but i just don't want you to see this
336:41 - arrow and show you a way to go around it
336:46 - and move on with your life by comparing
336:48 - stuff in your c plus plus programs if
336:51 - you put parentheses around here the
336:53 - problem is going to go away let's try
336:55 - and build again
336:56 - we're going to build with gcc
336:59 - and everything is going to go back to
337:01 - normal and we're going to see our output
337:04 - if we run our rooster program here
337:07 - this is how you can do this okay now
337:10 - that we have a basic understanding of
337:11 - this we can try the other operators and
337:14 - it is going to be a walk in the park we
337:17 - are going to go down here and put in our
337:20 - remaining operators we can use less or
337:24 - eco operator to test and see if number
337:28 - one is less or equal to number two we
337:31 - can use the greater than operator to
337:33 - test and see if number one is greater
337:36 - than number two we can use the greater
337:38 - or equal operator
337:40 - we can use the equal equal operator to
337:42 - test that number one is equal to number
337:44 - two and we can use this operator here
337:47 - which is made up of the exclamation mark
337:50 - and an equal sign to test and see
337:53 - if two numbers are not equal
337:56 - and all these operators are going to
337:58 - evaluate to a boolean
338:00 - basically saying if what you are testing
338:03 - for is true or false and we can print
338:06 - this out and notice that we have this
338:08 - parenthesis around to avoid the problem
338:11 - i just showed you a few minutes earlier
338:14 - and if we run this we're going to see
338:16 - the results
338:17 - let's weld this with gcc as usual
338:22 - we're going to run our program and
338:24 - you're going to see that number one is
338:27 - less than number two this is true
338:30 - number one less or equal to number two
338:32 - this is also true
338:34 - number one greater than a number two 45
338:37 - is not greater than 60 so this is false
338:40 - it's not greater than equal so this is
338:43 - also false
338:44 - number one equals to number two this is
338:46 - going to be false and uh the last
338:49 - statement that is going to test and see
338:51 - if number one is not equal to number two
338:54 - is going to evaluate to true because
338:57 - number one is not equal to number two if
339:00 - this is not making sense yet please go
339:02 - through it a couple of times and if you
339:05 - have a problem please do ask me i will
339:07 - do the best i can to help you out
339:10 - another thing i want you to see before i
339:12 - let you go
339:13 - is that you can store the results of
339:16 - these operators into a variable and use
339:20 - that later in your program for example
339:22 - here we can take our expression to
339:24 - compare
339:25 - number one and number two the result of
339:29 - that is going to be installed in this
339:31 - bold variable
339:32 - and we can print it out later
339:35 - like this
339:36 - if we run this
339:37 - we're going to build with gcc and we're
339:40 - going to run the program
339:42 - we're going to see that 45 equals to 60
339:46 - is false and it is coming from this
339:49 - statement here you can try and change
339:51 - these numbers for example change this to
339:54 - a 20 and see the results that we get and
339:57 - you can try and run these in your mind
340:00 - and see that they really make sense if
340:03 - we run rooster now we're going to get to
340:05 - different results because we are now
340:07 - comparing 45 and 20 and here at the last
340:12 - statement you see that they are not
340:14 - equal if we put into equal numbers we're
340:16 - going to get a true there let's try this
340:19 - out we're going to run the task to build
340:22 - with gcc and if we clear so that we get
340:25 - rid of all this noise and run rooster
340:29 - we're going to get
340:30 - 20 is equal to 20 and this is true this
340:34 - is really all we set out to do in this
340:35 - lecture i hope you have a better idea of
340:38 - these relational operators in z plus
340:40 - plus
340:41 - we're going to stop here in this lecture
340:43 - in the next lecture we're going to learn
340:45 - about logical operators in c plus plus
340:48 - go ahead and finish up here and meet me
340:51 - there in this lecture we're going to
340:53 - learn about logical operators these
340:56 - operators will work on boolean operands
340:59 - we're going to look at end first to
341:01 - really make sense of how they work here
341:03 - is a simple table we can use to try out
341:06 - the end operation it is going to be
341:09 - working on two operands a and b
341:12 - and in the third column here we're going
341:14 - to have the result so if a is false and
341:18 - b is false and we do a and b
341:21 - the result is going to be false if a is
341:24 - false and b is true the result is going
341:27 - to be false if a is true and b is false
341:31 - the result is going to be false if a is
341:34 - true and b is true the result is going
341:37 - to be true the way you can think about
341:39 - this and operator is that
341:42 - if any of the operands is false the
341:47 - result is going to be false and if you
341:49 - really use this way of understanding
341:52 - this it is going to be really easy and
341:54 - the first line here we have a false so
341:56 - the result is going to be false and the
341:58 - second line we have a force it's going
342:00 - to be force in the third line we have a
342:02 - false the result is going to be false
342:04 - but in the line number four here we
342:08 - don't have a false a is true and b is
342:10 - true so the result is going to be true
342:13 - another operator we have is or
342:16 - and it is going to evaluate to true
342:20 - if any of the operands is true let's
342:24 - look at the first line here a is false
342:26 - and b is false so we don't have a true
342:29 - the result is going to be false on the
342:31 - second line we have a true the research
342:33 - is going to be true on the third line we
342:35 - have a true the research is going to be
342:37 - true on line number four we have a true
342:41 - the result is going to be true and you
342:43 - don't really have to memorize these
342:45 - tables if you use these operators long
342:49 - enough these things are going to be
342:51 - drilled in your memory if you have any
342:53 - problem with these operators just look
342:56 - up tables like this and you can find
342:58 - whatever it is you need without really
343:00 - memorizing these things another operator
343:03 - is the not operator which is going to
343:06 - negate whatever you give it so if a is
343:09 - true and we negate that we're going to
343:11 - get a false if a is false and when you
343:14 - get to that we're going to get it true
343:16 - and we use this exfoliation mark to say
343:19 - that we are negating something if you go
343:21 - back to or it is denoted by these two
343:25 - vertical bars and the end operator is
343:29 - denoted by these two ampersand
343:31 - symbols here okay now that we know about
343:34 - these logical tables for these logical
343:36 - operators we can actually try to use
343:39 - them in code
343:41 - here we have three boolean variables we
343:44 - have a b c
343:45 - a is true b is false c is true we can
343:49 - print them out and you see that we are
343:51 - setting up sddc out to give us the
343:54 - results in the format of true and false
343:57 - instead of ones and zeros
343:59 - and down here you see that we are trying
344:01 - to use the and logical operator
344:04 - down here you have a and b a and c and
344:08 - we are doing this on three operators and
344:11 - chaining these things up so we are
344:13 - saying a and b and c and let's try and
344:17 - do this in our mind to see that we
344:19 - really understand this we have seen that
344:22 - the end operator evaluates to true
344:25 - when all operands are true another way
344:27 - to say this is the end operator
344:30 - evaluates to false if any of the
344:33 - operands is false so we're going to end
344:36 - a and b a is true b is false so the
344:39 - result is going to be false because we
344:41 - have a false in here a and c is going to
344:44 - evaluate to true because a and c are
344:47 - true a and b and c is going to evaluate
344:50 - to false because we have a false in here
344:53 - even if you have 1 000 tools and you end
344:57 - that with one false that's going to be
344:59 - dragged down to evaluate to false that's
345:03 - what we are seeing here we can also do
345:05 - all operations on these things and
345:08 - this is going to give you a true if any
345:11 - of the operands
345:13 - is true we know that a is true and b is
345:16 - false so this is going to evaluate to
345:19 - true a and c is also going to evaluate
345:21 - to true because a is true
345:24 - a and b and c is going to evaluate the
345:26 - true because a is true
345:29 - so let's go back and see this these are
345:31 - the values we're going to be using here
345:34 - we can also try out the nut operator and
345:36 - it is going to negate whatever we gave
345:38 - it so if a is true we're going to get a
345:41 - false b is false we're going to get it
345:43 - true c is true we're going to get a
345:46 - false another thing you can do is
345:48 - combine this logical operators so we can
345:51 - do something like a and b and all of
345:54 - that with a c
345:55 - and you should notice that we are
345:57 - wrapping our expressions here in
346:00 - parenthesis so that we don't have the
346:02 - same problem we experienced and
346:04 - explained in the last lecture and one
346:07 - thing you should know is that for the
346:09 - compiler to evaluate these things we are
346:12 - going to follow the rules in our table
346:15 - for precedence and associativity but we
346:18 - used parentheses to really make this
346:20 - easy to follow so we are going to end a
346:23 - and b
346:24 - and the result of that is going to be
346:26 - ored with c and you can try and do this
346:29 - in your mind and you're going to figure
346:31 - this out but we're also going to go to
346:33 - visual studio code in a minute and we're
346:35 - going to see all these things in action
346:37 - the last thing you can do is combine
346:40 - logical and relational operators into
346:43 - expressions for example here we have d e
346:46 - and f they are integers and we can print
346:48 - them out like we are doing here but we
346:51 - can do something like
346:53 - d greater than e
346:55 - and we're going to end the result of
346:57 - that with d greater than f
347:00 - and we know that these relational
347:03 - operators evaluate to booleans so we can
347:07 - use these booleans with logical
347:10 - operators like we have been doing all
347:12 - along in this lecture so for example
347:15 - let's evaluate the first one here in
347:17 - mind so that you really see what this is
347:20 - all about
347:22 - d is 45 e is 20 so d greater than e is
347:27 - going to evaluate to true
347:29 - d greater than f
347:31 - that's also going to evaluate to true so
347:34 - true and true
347:35 - that's going to evaluate to true and
347:37 - this should print a true
347:39 - on the terminal
347:41 - we are going to go to visual studio code
347:43 - and actually play with this thanks
347:46 - okay here we are in our working
347:48 - directory we're going to jump into our
347:50 - template project and copy the files we
347:52 - need and we're going to put them in our
347:55 - lecture on logical operators we're going
347:58 - to put that in here
348:00 - we're going to open up this folder in
348:02 - visual studio code and it is going to
348:04 - show up here in visual studio code we're
348:06 - going to get rid of what we don't need
348:08 - and we are going to put in the code to
348:10 - play with these things we have three
348:14 - boolean variables a is true b is false c
348:18 - is true
348:20 - and we can print them out and we're
348:21 - going to see their values and you see
348:23 - the setup here so that sddc out is going
348:26 - to show thanks in the format of true and
348:29 - false and down here we are ending a few
348:33 - values we are using the and operator and
348:36 - it is denoted by these two ampersand
348:39 - signs
348:41 - so
348:41 - a is true and b is false and c is true
348:45 - a and b is going to evaluate
348:48 - to false because we have a false in here
348:51 - and again if this doesn't make sense
348:53 - please do consult the tables for all
348:56 - these logical operators and all these
348:58 - things are going to make sense this is
349:00 - going to evaluate to false because we
349:02 - have a false in here and a and c we have
349:06 - true and true so this is going to
349:08 - evaluate to true and
349:11 - a and b and c this is going to evaluate
349:14 - to false because we have a false in here
349:16 - remember as soon as you have a false in
349:19 - your and logical operation you're going
349:23 - to get a false in your result so we're
349:26 - going to have a false here we can try
349:28 - and compile this and see if this is
349:30 - actually what we expect we're going to
349:33 - bring up a terminal we're going to use
349:35 - here and we're going to run the tasks to
349:37 - build with gcc
349:39 - and if we run our rooster program we're
349:43 - going to see that a and b is false
349:46 - this is what we expect
349:48 - a and c is true this is what we expect
349:52 - a and b and c
349:54 - is false and this is what we expect
349:56 - this is how you can really play with
349:58 - your and logical operator if you want
350:02 - you can change things up to really
350:04 - try and see if they live up to your
350:07 - expectations
350:09 - now we have changed a to false let's try
350:12 - and build again we build with gcc
350:15 - and we're going to run our program
350:18 - and we're going to get a and b is false
350:20 - because they are all false a and b are
350:23 - false so false and false evaluates to
350:27 - false
350:28 - a and c is false because a is false so
350:31 - we're going to get a false as the result
350:34 - a and b and c is also going to evaluate
350:37 - to false okay we have this tension here
350:40 - let's bring this back to what it was
350:42 - before so a is going to be true b is
350:45 - going to be false c is going to be true
350:48 - and we're going to try and play with the
350:50 - or operator we are going to go down and
350:53 - put in code to actually play with this
350:57 - and it is really nothing special we are
350:59 - just using the or operator here which is
351:01 - denoted by these two vertical
351:04 - symbols and or is going to evaluate to
351:07 - true
351:08 - when at least one of the operands is
351:11 - true okay so we have our values here a
351:14 - is true b is false c is true a or b is
351:17 - going to evaluate to true because a is
351:20 - true
351:21 - a or c is going to evaluate to true
351:23 - because a is true
351:25 - a or b or c is going to evaluate to true
351:29 - because one of these things is true and
351:32 - a is true here
351:34 - we can try and run this we're going to
351:36 - build this first
351:38 - with gcc and if we run this
351:43 - we're going to go down here and run
351:46 - rooster again
351:48 - and you're going to see that all these
351:49 - things are true here because one of
351:52 - these things is shown and as long as you
351:55 - have one true operand your or operation
351:59 - is going to evaluate to true and again
352:02 - this is following the precedence and
352:04 - associativity rules we have if we go
352:07 - back to our table in our browser we're
352:10 - going to try and look at logical or
352:13 - it is
352:14 - left associative so we're going to try
352:16 - and evaluate this from left to right so
352:19 - we're going to or a and b and the result
352:22 - of this is going to be ord with c we
352:26 - have also seen the not operator which is
352:29 - denoted by the exclamation mark here and
352:32 - what it is going to do is basically
352:34 - flip off or negate whatever it is you
352:37 - have if you have it true in your
352:39 - variable the result is going to be false
352:42 - if you have uniforms the result is going
352:44 - to be true
352:45 - and not a is going to be false because a
352:49 - is true not b is going to be true
352:51 - because b
352:53 - is false and not c
352:56 - is going to be false because c is true
352:59 - as we can see here so let's run the
353:01 - application and see if this is what we
353:04 - expect
353:05 - we're going to run and build with gcc
353:08 - and we're going to run rooster and we're
353:11 - going to see that note a is false not b
353:14 - is true and not c is false and this is
353:18 - what we expect we have also seen that we
353:21 - can do combinations of these operators
353:24 - so for example we can look at the
353:26 - expression we have here
353:28 - we're going to
353:29 - take a and b this is going to evaluate
353:33 - to false because b is false
353:36 - we're going to negate this and we're
353:38 - going to get a true and we're going to
353:40 - order that with c
353:42 - but because it's true
353:44 - we know that the result of ordering this
353:46 - with anything is going to be true so we
353:48 - expect this expression here to evaluate
353:52 - to true if we run this
353:55 - we're going to see that this is going to
353:57 - evaluate to true and it is what we
353:59 - expect
354:00 - the last thing we want to see in this
354:02 - lecture is that we can combine
354:05 - these logical operators with the
354:08 - relational operators we have seen in the
354:10 - last lecture we are going to put in a
354:13 - piece of code to play with this this is
354:16 - lengthy but you can play with this and
354:19 - see what this is going to evaluate to to
354:22 - start you off we are going to do the
354:24 - first one together so it does test if d
354:28 - is greater than e and if you look here
354:31 - 45 is greater than 20 so this is going
354:33 - to evaluate to true
354:36 - and we're going to enter that with d
354:38 - greater than f
354:40 - the result of this is going to be true
354:43 - so we're going to be ending a true and a
354:46 - true and the result of this is going to
354:48 - be a true and again you notice that we
354:51 - are wrapping this in parenthesis to
354:53 - avoid problems
354:55 - with the compiler being confused with
354:58 - what we are trying to print this is
355:00 - going to get rid of the otherwise ugly
355:03 - problems we might have to deal with if
355:05 - we didn't wrap this into parentheses
355:07 - like this so we expect to see a true
355:10 - here and we're going to weld
355:13 - and run the task to build with gcc
355:16 - and we're going to run rooster and if we
355:19 - look at the first thing here this is
355:21 - going to be true and you can try and do
355:24 - the other ones in your mind as an
355:26 - exercise and if you have a problem don't
355:29 - hesitate to ask me i am going to do the
355:31 - best i can to help you out
355:34 - this is really all we set out to do in
355:35 - this lecture i hope you have a better
355:37 - understanding of these logical operators
355:41 - again you don't have to really memorize
355:43 - them all you have to do is consult the
355:46 - tables and you're going to basically
355:48 - know the result of your two operands
355:51 - depending on the values you have inside
355:53 - for and or and the not operator we are
355:57 - going to stop here in this lecture in
356:00 - the next one we're going to see how we
356:01 - can format our output to make it really
356:05 - look better go ahead and finish up here
356:08 - and meet me there in this lecture we're
356:10 - going to look at output formatting and c
356:13 - plus and this is the way we can format
356:15 - stuff we send it to the terminal through
356:18 - sddc out and make them show up better as
356:21 - an example let's say we have a table
356:24 - here that has names and ages
356:27 - and you see that they are cramped and
356:30 - through output formatting we can take
356:32 - this and turn this into this
356:35 - and hopefully we agree that this is
356:38 - better
356:38 - there are a set of tools we can use in c
356:41 - plus plus and those we're going to be
356:43 - using in this lecture are going to be
356:46 - coming from these two libraries ios and
356:49 - io manip and there are a lot of things
356:53 - in these two libraries here is a a set
356:56 - of cards that show a lot of them we are
357:00 - going to play with a lot of these in
357:01 - this lecture so you don't have to worry
357:03 - if some of them seem scary
357:06 - right now before we start looking at
357:08 - them i want to bring to your attention
357:11 - that there is a piece of documentation
357:13 - on these things the link is here the
357:15 - website is called
357:17 - cppreference.com
357:19 - and you can open this up and look at
357:21 - some of the things we're going to talk
357:23 - about in this lecture okay the first one
357:25 - we're going to look at is stdendl
357:29 - this is not new we have been using it
357:31 - all day long to print out a new line
357:34 - character so that our htdcl statements
357:38 - print things on different lines and if
357:40 - we don't have this manipulator you see
357:43 - here on the top we have hello and world
357:46 - and if we print them out they are going
357:48 - to show up on one line because we are
357:50 - not separating the lines with std e and
357:53 - dl down below here we have another way
357:56 - we can do this we can post a backslash n
357:59 - after our text and that's going to add a
358:02 - new line character just like std endl
358:06 - does okay stdndl and slash n in here
358:10 - seemingly do the same thing
358:13 - but they are different but we don't have
358:15 - enough tools to really understand the
358:17 - differences right now for now just think
358:20 - of them as two things that do the same
358:23 - thing they print out a new character
358:26 - that allows your text to show up on
358:28 - different lines like we have hello and
358:31 - world here okay stdndl is the first
358:34 - manipulator we're going to play with in
358:36 - this lecture the next one we're going to
358:38 - look at is sdd flush
358:40 - and this is going to send whatever is in
358:43 - the output buffer to the terminal
358:46 - and what the heck is an output buffer
358:48 - let's look at an example suppose we have
358:51 - sddc out here and we want to print on
358:54 - this terminal and the message we want to
358:56 - print is hello world how are you so what
359:00 - is going to happen if the sddc out
359:03 - statement is executed things are not
359:06 - going to be directly sent to the
359:07 - terminal they are going to go into an
359:10 - intermediary buffer you can think of
359:12 - this as some kind of storage in which
359:15 - data goes before it goes to the terminal
359:18 - and this is what's going to happen we
359:20 - print out hello hello is not going to go
359:21 - to the terminal directly
359:23 - we print out world
359:25 - it's not going to go to the terminal we
359:28 - print out how are you
359:30 - it's not going to go to the terminal and
359:32 - when the buffer is full
359:34 - the data is going to be sent to the
359:36 - terminal in one go and this may come in
359:39 - handy in some situations so if you want
359:42 - the data to go to the terminal directly
359:45 - you're going to add an sdd flash
359:48 - after your hddc out statement and we are
359:52 - going to play with this in a minute in
359:54 - visual studio code and you're going to
359:55 - see how this works another manipulator
359:58 - we have which is really cool is set with
360:01 - and it is std set w here and what it
360:05 - does it specifies a width for whatever
360:09 - text you want to print here we have two
360:12 - examples the first one is our table that
360:15 - is not formatted well and you see we
360:18 - just print out the data and it is going
360:20 - to show up like we see here on the right
360:23 - we can use std set with to set the width
360:27 - of the text here and for example the
360:30 - last name here is going to show up in a
360:32 - field which is 10 characters white this
360:36 - is what we mean here and we do the same
360:38 - for the first name and the age and if we
360:41 - do this
360:43 - data is going to show up nicely as we
360:45 - see here and again i hope we agreed that
360:48 - what we have down below here is much
360:51 - better than what we had here
360:53 - which was not formatted with set width
360:56 - and this is how you use this manipulator
360:59 - here we can also use what we call
361:01 - justification to control whether our
361:03 - data shows up on the right or on the
361:06 - left
361:06 - in the width that is allocated to it for
361:10 - example here the
361:11 - justification is sdd right so the data
361:14 - is going to show up to the right in its
361:16 - respective cells we can also use what we
361:19 - call internal justification by which if
361:23 - we are showing a negative number the
361:25 - sign is going to be left justified so it
361:28 - is going to show up on the left but the
361:30 - data is going to be right justified and
361:33 - this may come in handy if you want to
361:35 - display some tabular data
361:37 - in your terminal we can also use std set
361:41 - field to specify the field character in
361:44 - our empty spaces for example here we set
361:47 - the dash as a field character and the
361:49 - result is what you see down below here
361:52 - we have seen std ball alpha and its
361:56 - effect is to force
361:58 - stdc out to show boolean output in the
362:02 - form of true and false if you don't put
362:05 - this manipulator in you're going to see
362:08 - those pieces of data as ones and zeros
362:11 - so for example here we have two
362:12 - variables condition and other condition
362:15 - if we print them out they are going to
362:17 - show up as one and zero we are going to
362:19 - set our manipulator here so the data is
362:22 - going to show up as true and false we
362:24 - can disable this manipulator here with
362:28 - std noble alpha and the data is going to
362:31 - go back to be shown in the form of one
362:34 - and zero this is what this manipulator
362:37 - does we also have one to show the
362:39 - positive sign for positive numbers
362:42 - so
362:43 - if we don't enable it the data here is
362:45 - going to show up like this 34 and minus
362:48 - 45 you see that the minus sign is going
362:50 - to be shown regardless of the setting
362:53 - you have for this manipulator but if we
362:56 - enable std show pose
362:59 - we're going to show the positive number
363:02 - and this may make sense for whatever
363:04 - application you might be doing
363:06 - we can disable this with std no show
363:09 - posts and after we do this the data is
363:12 - going to show up in its default format
363:15 - that we have seen before this is how you
363:17 - use std show posts we also have
363:20 - manipulators to control
363:23 - the base in which the data is shown and
363:26 - we can show the data either in a decimal
363:28 - in octo or in hexodecimal if you look at
363:31 - the data here we have an integer which
363:34 - is positive we have an integer which is
363:35 - negative and we have a double variable
363:38 - here and we have some data n for us to
363:41 - play with we're going to show our
363:43 - positive integer in these three bases
363:45 - decimal hex and octo
363:48 - and the result is what you see here and
363:51 - this should be no surprise you already
363:53 - know
363:54 - these number systems and how they work
363:57 - we can take the negative number and also
363:59 - show it in different bases decimal
364:02 - hexadecimal and octo and it is what you
364:05 - have on the right here in our terminal
364:08 - if we go down and try to show
364:10 - a double or a floating point number in
364:14 - these bases the result is not going to
364:17 - change because these number systems have
364:20 - no effect on floating point numbers if
364:22 - you remember we have seen that floating
364:25 - point numbers
364:26 - are represented in memory following
364:29 - another protocol that is really advanced
364:32 - for
364:33 - a course like this so we are just going
364:35 - to use this but we're not going to try
364:37 - and understand it because it is out of
364:39 - scope for what we are doing here we can
364:42 - also use std show base
364:45 - to show the base of our output
364:48 - so here we have a positive number which
364:50 - is an integer and we can show it in
364:54 - decimal hex and act and we're going to
364:57 - see what we see here to the right but we
365:00 - can choose to also show the base of
365:03 - whatever it is we output if we want to
365:05 - specify that the output is in decimal
365:08 - we're going to say that here but we can
365:11 - also decide to show the base and we
365:13 - enable that with std show base like this
365:18 - and if we do this we're going to see
365:20 - decimal is not going to have anything in
365:22 - front hex is going to have a 0x in front
365:25 - oct is going to have a zero in front and
365:29 - by this it is going to be very easy to
365:31 - see
365:32 - the base in which your data is displayed
365:35 - we can also use std upper case for the
365:38 - data we print out to be shown in
365:40 - uppercase where it makes sense for
365:43 - example here we are trying to print
365:44 - numbers in hexadecimal here in the
365:47 - middle so if we don't use uppercase
365:50 - which is the default
365:51 - the number is going to show up like this
365:53 - you see a and f are lowercase but if we
365:57 - enable uppercase we're going to see this
366:00 - in uppercase and sometimes this is going
366:02 - to be helpful for whatever application
366:05 - you are using the sun we also have a few
366:08 - manipulators to control how floating
366:10 - point data is shown on the terminal and
366:13 - the two of these are std scientific and
366:16 - sdd fixed by default stdc out is going
366:19 - to show
366:20 - in scientific format where necessary and
366:23 - it is going to use fixed by default so
366:26 - what we have here
366:28 - we have three variables abc
366:31 - and if we just print them out they are
366:33 - going to show up in this format here if
366:36 - we use fixed we're going to force the
366:38 - output to be in fixed format and you're
366:40 - going to see that the third number in c
366:43 - here is going to show up as 0.0 and a
366:46 - few zeros after that because in the
366:49 - precision that we have now we can't
366:52 - really show a number that is as low as
366:55 - we have here in c again we have seen
366:57 - this scientific format this is
367:00 - basically 1.34
367:03 - multiplied by 10 to the power of minus
367:06 - 10 and this is a really really low
367:08 - number so we're going to do
367:10 - 0.000 up to 10 and that's when this
367:14 - decimal point is going to show so it's a
367:16 - number that is really close to zero
367:19 - that's why we are showing it like 0.0
367:21 - here i hope this makes sense we can also
367:24 - use scientific notation if we want that
367:27 - and if we force scientific notation
367:30 - everything is going to be shown in
367:32 - scientific notation another thing that i
367:34 - really want you to be aware of is that
367:37 - there is no official way to set
367:40 - the
367:41 - floating point output to its defaults
367:45 - and here is a hack i actually learned
367:48 - about when i was making this course the
367:50 - explanation of this is really out of
367:52 - scope for this course but just use this
367:55 - to set
367:57 - the floating point output format to the
368:00 - defaults and if you do this you're going
368:02 - to get whatever we had
368:04 - here with the defaults you're going to
368:06 - see that it is the same things the next
368:08 - thing we're going to look at is std set
368:10 - precision which we have seen before and
368:13 - this is going to set the precision
368:16 - with which the data is going to show up
368:18 - on the terminal if you use a precision
368:20 - of 10 that's what you're going to get
368:23 - here here you see that we have a double
368:26 - number it is a number that has a lot of
368:29 - numbers after the decimal point if we
368:32 - show it by default it's going to show up
368:33 - like this the precision is going to be
368:35 - sex we can increase the precision to 10
368:38 - to 20 and 50 and it is going to show up
368:41 - at whatever precision that you specify
368:43 - here
368:44 - please know that this precision is going
368:46 - to be limited by the type of this a
368:49 - variable
368:50 - if it is a floating point the precision
368:52 - is going to be something like 7 we have
368:55 - seen that if it is a double the
368:57 - precision is going to basically double
368:59 - to something like 15 and if you have a
369:02 - long double the precision is going to be
369:04 - something bigger than double but it
369:07 - can't go below that of a double we have
369:10 - seen this before we also have show point
369:12 - which is going to force
369:15 - showing the decimal point for floating
369:17 - point values you see here we have a 12.0
369:21 - this is the most important piece of data
369:23 - we have here
369:24 - if we don't do show point this is going
369:27 - to show up as 12 in the output here but
369:31 - we can use show point to force for the
369:34 - decimal point to be shown and you see
369:36 - that
369:37 - 12.00 here is shown another side effect
369:41 - of this is that
369:43 - show point is going to force the showing
369:45 - of trailing zeros and it is what we see
369:48 - here in d e and f we have seen a lot of
369:51 - manipulators here is a table that is
369:53 - going to show where many of these are
369:55 - going to be living so if you need to use
369:58 - set width this is going to be living
370:01 - in the i o manip header and here we have
370:05 - a few other ones so if you want to use a
370:07 - few of these things these are the
370:10 - libraries that you will need to include
370:12 - with pound include as we have been
370:14 - including i o stream and again the
370:17 - documentation for these things is shown
370:19 - at
370:20 - cppreference.com this is the exact link
370:23 - and you can check this out if it helps
370:26 - out
370:26 - now that we have an idea about these
370:28 - things we're going to go in visual
370:30 - studio code and actually see these in
370:33 - action okay here we are in visual studio
370:36 - code the project we're going to be
370:37 - working on here is output formatting so
370:41 - we're going to be
370:42 - grabbing
370:43 - our template files
370:45 - and put those in our project here
370:49 - and we're going to go up again and open
370:51 - up this folder in visual studio code
370:53 - let's do that we're going to close the
370:55 - welcome screen here and we're going to
370:57 - remove whatever it is we don't need
370:59 - we're going to take this out
371:01 - and we are going to put in the first
371:03 - code we want to play with and this is
371:05 - stdendl
371:07 - you don't really need a lot of
371:09 - explanations for this because we've used
371:11 - this all along
371:13 - if you don't put it out the data is
371:14 - going to show up on one line and uh
371:17 - you're going to have hello world on one
371:19 - line
371:20 - if we put stdndl like this we're going
371:23 - to have the data show up on different
371:25 - lines so we're going to have hello and
371:27 - world on different lines and it is
371:29 - possible to use a backslash n to achieve
371:33 - the same thing but these work very
371:35 - differently underground and we don't
371:38 - have enough tools to really understand
371:40 - the difference so for now just take this
371:43 - as the truth and i know that there are
371:45 - differences and the most important thing
371:48 - is that you recognize these things if
371:50 - you see them in code out there we are
371:53 - going to bring up our terminum and build
371:56 - this with our task that is going to
371:59 - build with gcc
372:01 - you're going to see that the world is
372:02 - going to go through
372:04 - and that we can run our rooster
372:06 - binary to see the output you see that we
372:09 - have hello world on one line
372:12 - we have hello and world on different
372:14 - lines and this is a result of these
372:17 - events we have here you see we have
372:19 - stdndl this is going to force
372:22 - the terminal to go to the next line and
372:24 - print world and after that we're going
372:26 - to force the terminal to go to the next
372:29 - line and that's where the next text is
372:31 - going to show up after that we have
372:34 - hello and world down here in the
372:36 - terminal and it is the output generated
372:39 - by the statements that we have in here
372:42 - and you can see that it is going to
372:44 - basically do the same thing as stdendl
372:47 - but again they work very differently
372:50 - under the hood okay so this is really
372:52 - how std endl works and you get access to
372:56 - it by including the i o stream
372:59 - library here the next thing we're going
373:01 - to play with is std flash
373:04 - this is going to flash the output buffer
373:07 - to its final destination and that's
373:09 - going to be
373:10 - the terminal in this case and if we add
373:13 - that to our
373:16 - stdcl statement like this
373:18 - this is going to be directly sent to the
373:22 - terminal and this may come in handy in
373:24 - some applications if we run this we're
373:27 - not going to really see a difference but
373:30 - underground under the hood the data is
373:32 - directly sent to the terminal and we had
373:35 - the chance to explain this in the slides
373:37 - earlier we can work this program and i
373:40 - see it running the world is going to go
373:43 - through if we run the rooster we're
373:45 - going to see that this is a nice message
373:47 - is sent
373:48 - to the terminal the next thing we're
373:50 - going to look at is set with i am going
373:52 - to put in the code here because i don't
373:54 - want to type all this and again you can
373:57 - get the source code for this
374:00 - in the results section of this lecture
374:03 - you don't really have to type all these
374:04 - things the most important thing is that
374:06 - you really understand how they work okay
374:09 - you see here we are going to use set
374:11 - with but we haven't really included the
374:14 - library that is going to give us access
374:16 - to this and if you don't know which
374:18 - library you will need to include to get
374:20 - access to this well you can check the
374:22 - documentation and to get access to the
374:25 - documentation you might want to consult
374:28 - your favorite search engine i am going
374:30 - to go in google here and type in std
374:34 - set w and i am going to search and this
374:38 - is going to come up with a few entries i
374:40 - am going to click on the one from
374:42 - cppreference.com because this is
374:44 - reliable in my opinion and if we open
374:47 - this up we're going to see that to work
374:49 - with us you need to include i o my net
374:52 - so this is what we need to put in visual
374:55 - studio code to get rid of this problem
374:57 - let's do that i really wanted you to see
375:00 - this process you can go through
375:02 - to know what you need to include we're
375:05 - going to put this in and hopefully the
375:07 - arrow is going to go away and we can
375:10 - focus on studying the effects of these
375:13 - things here this is going to print and
375:15 - formatted so the data is going to be
375:17 - cropped close to each other but we can
375:20 - format this using set width and if we
375:23 - pass in a 10 here we are basically
375:25 - saying last name is going to take the
375:28 - width of 10 characters even if we don't
375:31 - really have 10 characters in this so so
375:34 - you're going to have spaces fill the
375:36 - remaining spaces so that the data shows
375:39 - up nicely this is really hard to say in
375:42 - world so i am going to run this in a
375:44 - minute so that you can see this but
375:46 - before we run i want you to see that you
375:48 - can also store the width information in
375:51 - a variable like this and i use that
375:53 - instead in your std statements the
375:56 - benefit with that is that it is really
375:59 - easy to change this with if you happen
376:01 - to change your mind otherwise you would
376:04 - have to change a lot of things and this
376:06 - is really bad design i did this to show
376:08 - you how you can use this but in real
376:11 - code you are most probably going to
376:14 - store
376:14 - your weft information in a variable and
376:17 - that way it's going to be really easy to
376:20 - change and update if you happen to need
376:22 - that we can build this program with gcc
376:26 - and if we run it let's bring this up a
376:28 - little bit we're going to have our data
376:30 - that is unformatted and you see that it
376:32 - is really ugly but down below here we
376:35 - have our formatted table and it is
376:38 - really nice we have last name first name
376:40 - and age and it is easier to see these
376:43 - things we're going to see that it is
376:45 - possible to
376:46 - force the data to show on the left or to
376:49 - the right with justification and we're
376:51 - going to look at code that does that
376:53 - next
376:55 - if we go down here and put in the next
376:57 - piece of code we want to play with we're
376:59 - going to see that data is right
377:01 - justified by default but we have seen
377:03 - this also you see that gray is cramped
377:06 - to the right of the width of the cell
377:08 - for the first name so data is right
377:10 - justified by default and it is the same
377:13 - here
377:14 - if we
377:15 - change the width of our
377:18 - data here and trying to run we're going
377:20 - to have a better visualization of that
377:23 - so let's run a little bit we're going to
377:25 - build the world is going to go through
377:27 - and if we run this we're going to see
377:29 - that data is going to show up to the
377:31 - right gray is to the right woods is to
377:33 - the right and this is the default
377:36 - justification you get
377:38 - when you set with like this you can also
377:40 - cause for the data to be left justified
377:43 - and you do that by coming here and
377:47 - changing this to left you can do that
377:49 - but let's keep this in here instead
377:52 - for your reference and let's put in
377:55 - another piece of code to justify the
377:57 - data to the left okay let's go down and
378:00 - do that we're going to justify the data
378:02 - to the left and if we print this out the
378:05 - data here gray should come to the left
378:08 - and be aligned with the first name here
378:10 - i hope this makes sense we're going to
378:12 - run we build with gcc and if we run
378:16 - rooster gray is going to be justified to
378:19 - the left this is the meaning of std left
378:23 - and std right that we just saw and know
378:26 - that data is justified to the right by
378:29 - default and it is important to keep the
378:31 - defaults in your mind
378:33 - data is going to be justified to the
378:35 - right by default the next thing we can
378:38 - do is to make our data internal
378:41 - justified and what this is going to do
378:43 - is make the sign left justified and the
378:47 - data is going to be right justified and
378:50 - the best way to save this is really to
378:52 - see an example
378:53 - so here we have the data it's a negative
378:55 - floating point number the width is set
378:58 - to 10 it's going to be right justified
379:01 - but we are also going to set the
379:03 - justification to internal and see the
379:06 - difference
379:07 - let's weld and run this we're going to
379:09 - world with gcc and we are going to run
379:12 - our rooster program and if we look at
379:15 - the output here you see that if we have
379:18 - right justification
379:20 - the sign is going to go with the data
379:23 - whereas if we do internal justification
379:27 - the sign is going to go to the left and
379:29 - the data is going to go to the right and
379:31 - sometimes this is useful depending on
379:34 - the application that you are welded
379:36 - especially in applications where you
379:38 - have to display tabular data on the
379:41 - console or of the terminal we can also
379:44 - specify the field character using set
379:47 - field
379:48 - and this is really how it works the data
379:50 - is going to be left justified but we are
379:53 - going to fill empty
379:55 - spaces with a dash here and we can bring
379:58 - this up so that you see the entire thing
380:01 - but you don't really have to type this
380:02 - out you can use the code i have provided
380:05 - in the resources section of this lecture
380:08 - you can just copy it paste it in here
380:10 - and use it to play with these things
380:12 - okay with this our empty spaces are
380:15 - going to be filled with this dash
380:18 - character
380:19 - let's world and build with gcc we are
380:22 - going to run this and you're going to
380:24 - see that we have a field character here
380:27 - and you can change this basically to
380:29 - whatever you want if i want i can change
380:31 - this to a star let's do that and i can
380:34 - build again if i run this it's going to
380:37 - be filled with stars right now the next
380:39 - thing we're going to look at is std bull
380:41 - alpha we have seen this before but what
380:44 - it's really going to do is force the
380:46 - output to be in the format of true and
380:49 - false
380:50 - and the default is in the form of one
380:52 - and zero here we have a few variables
380:56 - and that they are of bull type
380:59 - the first set of stdcl statements here
381:02 - is going to print in the format of one
381:04 - and zero we are going to set the output
381:07 - to both alpha and it is going to be in
381:09 - the format of true and false and then we
381:12 - can disable the bull alpha with this
381:14 - setting here which says hdd no pull
381:18 - alpha we can vote this and see the
381:21 - effect of this so we're going to run
381:24 - rooster again and you're going to see
381:26 - that condition 1 0 condition true false
381:29 - condition 1 0 we are able to modify how
381:33 - our boolean data is displayed on the
381:36 - console using these two settings here
381:39 - use them if they make sense for your
381:41 - application the next thing we're going
381:43 - to look at is show pose and we're going
381:46 - to just put in the data
381:48 - we have two numbers positive number
381:50 - which is 34 a negative number which is
381:52 - minus 45 and we can decide if we want to
381:56 - show
381:57 - the plus sign for positive numbers by
382:00 - default the plus sign is going to be
382:02 - hidden it's not going to be shown if you
382:04 - want it shown you can use the show pose
382:07 - manipulator and if you want to disable
382:10 - that when it was enabled you can use no
382:13 - show pose and this is going to do what
382:15 - you want we can build this again and if
382:19 - we look at the output we're going to see
382:20 - that post num doesn't have a plus sign
382:23 - in front because by default the show
382:26 - pause is disabled and we set the setting
382:29 - here and we're going to see the plus
382:31 - sign and if we disable that we're not
382:34 - going to see the plus sign again this is
382:36 - the effect of std show posts and std
382:39 - neutral pose manipulators we can also
382:42 - affect the base in which the data is
382:45 - displayed on the terminal and we do this
382:48 - by setting the output base system
382:51 - we can set std deck to force the output
382:55 - in decimal
382:56 - std hex to force the output to be in
382:59 - hexadecimal and std act to force the
383:02 - output in octal and this is only to take
383:06 - effect for integral types this is not
383:09 - going to have effect for floating point
383:12 - numbers for example here we have a few
383:14 - variables a positive integer and
383:16 - negative integer and a floating point
383:18 - number which is the double
383:20 - and we're going to try and print these
383:22 - things in all these base systems we're
383:26 - going to
383:27 - print these things in the default format
383:29 - we're going to see how they look we are
383:31 - going to take the positive number and
383:33 - show that in these different number
383:36 - systems we're going to do the same for
383:37 - the negative number and we're going to
383:39 - show that
383:40 - this doesn't have effect on floating
383:43 - point numbers because these number
383:46 - systems don't really work for floating
383:48 - points we can run this and see the
383:52 - output we are going to run the task that
383:54 - is going to build with gcc and we're
383:57 - going to clear and run rooster and what
384:00 - we're going to see is that by default
384:03 - positive number is going to be this
384:04 - negative number is going to be this and
384:06 - our double var is going to be this and
384:09 - we are going to take the positive number
384:10 - show it in different base systems in
384:13 - decimal it's going to be like this in
384:15 - hex it's going to be like this in act
384:18 - it's going to be like this the negative
384:20 - number is also going to be
384:22 - in this format here so if we show it in
384:25 - decimal it's going to be like this hex
384:27 - it's going to be like this and octo it's
384:29 - going to be like this you can see that
384:32 - the double var which is a floating point
384:35 - is not really affected it's going to be
384:37 - showing in the same format regardless of
384:39 - the base that we set here one thing you
384:42 - should know is that this base setting
384:44 - here is going to stick so here for
384:47 - example you see that we have set output
384:49 - to octo
384:51 - so any other thing that we're going to
384:53 - print out is going to be shown in octo
384:56 - and we have to be sure that's what we
384:58 - want if that's not what we want we will
385:00 - have to reset
385:02 - the output
385:03 - number system and it's going to take
385:06 - effect this is how you can use these
385:08 - things to affect
385:09 - different number systems for output in
385:12 - your terminal we have seen that you can
385:14 - also force things to show up in
385:17 - uppercase if that's important for your
385:19 - application for example here we have a
385:21 - positive number if we show that in hex
385:24 - this is going to contain a few
385:26 - characters
385:27 - and if we don't set uppercase
385:30 - it is going to show up in lowercase and
385:32 - if we want it in uppercase we can set
385:34 - this setting and it is going to show up
385:37 - in uppercase this may be helpful in some
385:40 - applications and i just want you to be
385:42 - aware of these things we're going to
385:44 - world and run our application
385:48 - we're going to see that
385:50 - let's bring this up a little bit so that
385:52 - we have some breathing room our positive
385:55 - integer here is going to show up in
385:57 - lowercase here in hex because this is
386:00 - going to contain characters and if we
386:03 - set uppercase you're going to see that
386:05 - the characters are going to show up in
386:08 - uppercase and this is the effect of this
386:11 - setting here we can also affect how
386:13 - floating point data
386:15 - is printed out on the terminal
386:19 - for example here we have a few variables
386:21 - a b and c
386:23 - and by default they are going to show up
386:25 - with decimal points and use scientific
386:28 - notation where necessary but we can
386:31 - choose to use
386:33 - fixed for example if that's what we need
386:35 - in our application and the output is
386:39 - going to be shown using fixed notation
386:41 - with decimal points if we want we can
386:44 - force the scientific format and we do it
386:46 - like this and all output is going to be
386:49 - in scientific format and we can disable
386:52 - all these settings and reset this to the
386:54 - defaults
386:56 - with this piece of command here there is
386:59 - no official way to
387:01 - set floating point output to the
387:04 - defaults and this is a hack i actually
387:07 - learned about when i was preparing the
387:09 - code for this course and the proper
387:12 - explanations for this are really out of
387:15 - scope for this course so if you want to
387:17 - reset the floating point output format
387:20 - to the default you're going to use this
387:23 - but we don't really have enough tools to
387:25 - understand this yet so just take it by
387:29 - faith and you're going to see that if we
387:31 - run this it's going to work let's try
387:33 - and run this through the compiler and
387:36 - that the world is going to go through if
387:38 - we run this and i bring this up a little
387:40 - bit so that we have a little bit of
387:43 - breathing room we're going to see that
387:45 - our double values are a b and c and
387:48 - that's what we have in our code here and
387:51 - by default it's not going to be able to
387:53 - show these things because of the
387:55 - precision limits so we're going to have
387:57 - 3.14159
388:00 - it's going to go up to here and the rest
388:02 - is going to be chopped off if we use
388:04 - fixed formats you're going to see that
388:07 - whatever we had in scientific format
388:10 - it's going to show up in fixed format
388:13 - and again this is a really low number
388:15 - that's why we have 0.000
388:18 - here
388:19 - we can force the output to be scientific
388:22 - as we did
388:23 - right here
388:25 - and all output is going to be in
388:27 - scientific format
388:29 - down below here we use our hack to set
388:32 - to
388:33 - the defaults and you see that it's going
388:35 - to go back to the initial format that we
388:39 - had before this is how you use std fixed
388:42 - and std scientific
388:44 - to
388:45 - manipulate how your floating point
388:48 - numbers are printed to the terminal we
388:51 - have also seen that we can set the
388:53 - precision of our output in the terminal
388:57 - here we have a variable a it is of type
389:00 - double as you can see in a visual studio
389:02 - code here if you hover over a variable
389:05 - you're going to be able to see its type
389:07 - we can choose to see this in whatever
389:09 - precision we want 6 is the default in
389:12 - our case here but we can choose to set
389:15 - the precision to 10 20 or whatever it is
389:18 - really we want
389:20 - please note that this is going to be
389:22 - limited by the precision that your type
389:24 - supports so for example we know that a
389:27 - double has a precision of 15 and if we
389:30 - have more than 15 digits in here the
389:33 - rest is going to be garbage just be
389:35 - aware of that we're going to try and
389:38 - build this and we're going to use gcc as
389:40 - usual and if we run this
389:44 - we're going to get our numbers in
389:46 - different precisions the first one is
389:48 - using the default which is going to be
389:50 - 6.
389:51 - if we use 10 we're going to get 10
389:53 - digits if we use 20 we're going to get
389:54 - 20 digits but if we go over the
389:57 - precision that our type here supports
390:00 - we're going to get garbage i hope this
390:02 - makes sense the last thing we're going
390:04 - to see is show point and we have seen
390:07 - that
390:08 - this is used to force
390:11 - outputting the decimal point let's say
390:13 - that here and a good example for that is
390:16 - this 12 here
390:18 - if we print it out
390:19 - here we're not going to get the decimal
390:22 - point by default it's going to print 12
390:25 - but if we go down and force output of
390:28 - the decimal point here we're going to
390:31 - get something like 12.0
390:34 - and another effect of this is that it's
390:37 - going to add trailing zeros to fill
390:40 - whatever space is allocated for your
390:43 - output variable in the terminal
390:45 - let's try and run this so that we can
390:48 - actually see this running we're going to
390:50 - run our rooster executable and in the
390:54 - first group here we don't have the
390:56 - setting for show point and if you look
390:59 - at the numbers that we had in our code
391:02 - the first number is 34.1 and you see
391:05 - that we are padding a lot of numbers
391:07 - because we had set our precision to a
391:10 - really big number in the last example
391:13 - that we have run let's actually go there
391:15 - and show you that that's why we're
391:16 - seeing the precision of 20
391:19 - it is really huge but no big deal we can
391:21 - reset this to whatever we want if this
391:24 - is too much for us
391:26 - the important thing here is that we have
391:29 - 34.1 and that's what we are seeing and
391:32 - if you go to our 12 here you see we have
391:36 - 12.0 but our output is not showing
391:40 - the decimal point here if it is
391:43 - important to show the decimal point we
391:45 - can do std show point here and it is
391:48 - going to show up this is really what is
391:50 - important in this piece of code here and
391:53 - this is really all we set out to do in
391:54 - this lecture we had a chance to play
391:56 - with a lot of these manipulators and the
391:59 - best way to learn about these things is
392:01 - really to try them out in code
392:04 - and try to change a few things and see
392:06 - how that affects the output you get in
392:09 - the terminal and we had a chance to play
392:11 - with many of these things in this
392:14 - lecture there is a lot of these guys i
392:17 - tried to make this lecture as extensive
392:19 - as i can that's why it turned out to be
392:22 - pretty long but once you've learned
392:24 - about these fans and played with them in
392:27 - code you're never going to forget them
392:29 - one last point i want to emphasize again
392:32 - is that the documentation is of utmost
392:36 - importance it is really good to come
392:39 - here and check things out for example if
392:41 - we go to show point here we are going to
392:43 - get a nice explanation of what this
392:46 - manipulator does enables all disables
392:48 - the unconditional inclusion of the
392:50 - decimal point character and you can read
392:53 - all this
392:54 - and the nice thing is that if you go
392:56 - down you're going to have a piece of
392:58 - code
392:59 - that you can use to really understand
393:01 - whatever it is they are talking about
393:03 - and this is priceless if you are
393:05 - learning it is a good thing to be able
393:08 - to use the documentation this is really
393:10 - all we set out to do in this lecture it
393:13 - turned out to be really long but i
393:16 - really hope it was worth it for you
393:18 - we're going to stop here in this lecture
393:20 - in the next one we're going to learn
393:21 - about numeric limits go ahead and finish
393:24 - up here and meet me there in this
393:27 - lecture we're going to be playing with a
393:29 - few functions from this library
393:31 - specifically we're going to be looking
393:33 - at the minimum the maximum and the
393:36 - lowest functions
393:38 - and this is really how you use them you
393:40 - can think of this t as a placeholder for
393:43 - the type for which you want to know the
393:46 - minimum the maximum and the lowest point
393:48 - respectively i know this might be
393:51 - cryptic to some of you so we're going to
393:53 - look at a few specific examples here we
393:56 - have a simple explanation of what these
393:58 - functions mean
394:00 - for floating point values
394:02 - the minimum is going to represent the
394:05 - smallest positive number
394:07 - that is representable with that floating
394:10 - point type the maximum is going to be
394:12 - the maximum floating point number you
394:14 - can represent and at the lowest number
394:17 - is going to be the lowest negative
394:20 - number you can represent with that type
394:22 - things change a little bit when you
394:24 - start dealing with integers and these
394:27 - functions are going to look like this
394:29 - the minimum is going to be the minimum
394:31 - number you can represent with that
394:32 - integer and lowest doesn't really mean
394:35 - anything for integral types the maximum
394:38 - is going to be the maximum number one
394:41 - thing you have to keep in mind is that
394:42 - the minimum may be negative
394:45 - if you are using a signed integer if you
394:49 - are using an unsigned integer for
394:51 - example for short minimum is going to be
394:53 - zero and the maximum is going to be the
394:56 - maximum number representable with that
394:59 - integer type here we are looking at
395:01 - numbers for short and but the same story
395:04 - applies to whatever integer type you are
395:07 - using even if you happen to be using
395:10 - long end or end without any modifier
395:13 - remember that we had to do a lot of
395:15 - things to get this range and it was
395:19 - really hard to even do this for floating
395:22 - point types so this library is helpful
395:26 - in getting a sense of what we can
395:28 - represent with the given type b8
395:30 - floating point or integral let's head to
395:33 - visual studio code and play with us here
395:35 - we are in our working folder
395:38 - we are going to copy code from our
395:40 - template project
395:42 - and we are going to go in the current
395:44 - project which is numeric limits we're
395:46 - going to go and put in our files
395:49 - go up again and open this file up in
395:52 - visual studio code we're going to close
395:54 - this up open the main cpp file remove
395:57 - whatever it is we don't need we are
395:59 - going to include the limits library
396:02 - remember this is the first thing we need
396:04 - to do
396:05 - if we want to play with these facilities
396:09 - that we just looked at in the slides
396:11 - and we are going to go down here and put
396:13 - in the code we want to play with
396:16 - and it is ridiculously simple
396:19 - if you have watched the slides we just
396:21 - did in a minute so what we're going to
396:23 - be doing here we're going to be printing
396:25 - out the range for each possible type we
396:28 - want to play with here so we're going to
396:30 - say the range for short and is from
396:33 - and we're going to say std numeric
396:35 - limits
396:37 - short that's what we want to deal with
396:39 - now and we're going to call the minimum
396:42 - function this is going to give us
396:44 - the minimum value we can represent with
396:46 - short and we're going to say std numeric
396:49 - limits and we're going to call the max
396:51 - function
396:52 - passing in the type for which we want to
396:55 - get the range for
396:56 - and the same story applies for
397:00 - unsigned
397:02 - short
397:03 - you see that's the type we are using
397:05 - here we are also going to play with ant
397:08 - getting the range we're going to use
397:10 - unsigned and
397:12 - to see how these things behave we're
397:14 - going to use long
397:16 - and get to the range and we are also
397:18 - going to be playing with floating point
397:21 - types so we're going to compute the
397:24 - range using the minimum function and the
397:26 - maximum function and we are going to be
397:29 - also using the lowest function to see
397:32 - that this really is the same thing we
397:35 - described in the slides we're going to
397:37 - do this for double and long double and
397:40 - see how these ranges
397:41 - come up in this program what we're going
397:44 - to do is open up a terminal here we are
397:47 - going to run the task to build with gcc
397:50 - and the build is going to be good
397:52 - and we can go down and run rooster and
397:56 - we're going to get our values here the
397:57 - range for short and is from minus 32 768
398:02 - up to 32
398:04 - 767 and you see that this is exactly the
398:07 - same thing we saw in the lecture where
398:09 - we talked about number systems we saw a
398:11 - way you can do this manually by plugging
398:14 - the
398:15 - number of digits in some formula that we
398:18 - came up you can go back and check that
398:20 - out if you want we do the same for
398:22 - unsigned short and and then we look at
398:25 - floating point types we're going to
398:27 - print the range for float
398:29 - and if we use the
398:32 - minimum function to get the start of the
398:34 - range we're going to get the minimum
398:37 - positive number we can represent with a
398:40 - float if we use lowest we're going to
398:42 - get the lowest minimum number and that
398:45 - the maximum is going to be the same if
398:47 - you think this is really small you have
398:50 - the option to open up this folder in
398:52 - file explorer and you can open a command
398:56 - prompt or powershell window by hitting
398:58 - shift and right clicking and choosing
399:01 - this option here open powershell window
399:04 - here
399:05 - and you're going to get a bigger window
399:07 - in which you can type things we're going
399:08 - to run rooster and we're going to see
399:10 - things in a much easier way here
399:13 - this is an option you can use or you can
399:15 - even use the integrated terminal inside
399:19 - visual studio code here like we've been
399:21 - doing all along there are a few other
399:24 - facilities you can use in this library
399:27 - of limits for example we can try and
399:32 - print out if a number is signed or
399:34 - unsigned or get the number of digits we
399:37 - can represent in an integer type
399:40 - these are a few examples i just chose
399:42 - because they are easy to understand and
399:44 - really helpful but you can find more
399:47 - about this library
399:49 - in the documentation
399:51 - and if you come here at cppreference.com
399:54 - the link is here you can really find all
399:56 - about this library here this library
399:59 - provides a standardized way to carry
400:01 - various properties of arithmetic types
400:04 - for example the largest possible value
400:06 - of type and is this
400:08 - and we have a bunch of things we can do
400:10 - here don't be scared of by this template
400:13 - thing
400:14 - just think of them as placeholders for
400:18 - the type for which you are trying to
400:19 - query information for there are a few
400:22 - functions you can call on these things
400:24 - for example there is mean lowest max
400:27 - that we just played with in visual
400:29 - studio code but uh you can see that
400:32 - there are a lot of things you can play
400:34 - with especially if you have some math
400:36 - background to understand all these
400:38 - concepts here you can play with us and
400:41 - see if it is helpful for whatever
400:44 - application you are doing okay this is
400:46 - really all we set out to do in this
400:47 - lecture to learn a little bit about the
400:49 - limits library it is helpful in
400:53 - trying to understand the ranges for your
400:55 - types if you happen to need these kinds
400:57 - of things this is going to come in handy
400:59 - we're going to stop here in this lecture
401:01 - in the next one we're going to learn
401:03 - about some math functions we can use in
401:06 - c plus plus go ahead and finish up here
401:09 - and meet me there in this lecture we're
401:11 - going to learn about math functions and
401:14 - these are functions that are built into
401:16 - the z plus plus standard library that we
401:19 - can use to do some math if you are doing
401:22 - some math operations you're going to
401:24 - find this helpful
401:25 - they live in the c math library and if
401:30 - you want to use them you're just going
401:31 - to include that and you're going to have
401:33 - access to them what you see here is a
401:35 - simple summary of some of the things you
401:37 - can use in these math functions you can
401:40 - use std flower to round down or hdd seal
401:45 - to
401:46 - round up you can use the abs function to
401:49 - compute the absolute value of a number
401:51 - you can do trigonometry you can do the
401:54 - cosine sign and things like that you can
401:57 - compute the exponential of a number
402:00 - you're going to see what this means in a
402:01 - few lectures you can use std log and
402:04 - again if you have some math background
402:07 - these concepts are not going to be
402:09 - foreign to you many of these functions
402:11 - are documented here at cpp reference so
402:14 - it might be worthwhile to go there and
402:17 - check what functions are available there
402:19 - here is an example of something you
402:21 - might want to do for example you have a
402:23 - variable it's called weight inside we
402:25 - have a 7.7 and if you do std floor of
402:30 - this variable this is going to be
402:32 - rounded down to a 7. if you want to
402:35 - round up you're going to use std seal
402:37 - and you're going to get that and we're
402:39 - going to see what this is going to give
402:41 - us in a minute when we hit visual studio
402:44 - code here is how you would use the
402:46 - absolute value function you have a few
402:48 - variables here and if you try to plug
402:52 - them in this absolute value function
402:54 - you're basically going to get the weight
402:56 - of the number without any sign in front
403:00 - of the number positive or negative the
403:02 - absolute value is the weight of the
403:04 - number without caring about the sign if
403:07 - i may say it like that okay we also have
403:10 - the x function which is going to compute
403:12 - the exponential of a number this is a
403:15 - math concept so if you don't have a
403:17 - background in math this is going to be a
403:19 - little hard to wrap your brains around
403:22 - but in math we have this number which is
403:24 - called e
403:25 - and its value is approximately 2.7 18 28
403:30 - like you see here the exponential
403:32 - function is going to do what f x here is
403:35 - doing it's going to take e and elevate
403:38 - that to the power of x and for example
403:41 - in our code here we're going to get the
403:44 - exponential of 10 which is going to be e
403:46 - elevated to the power of tan and we're
403:49 - going to play with this in visual studio
403:51 - code and you're going to see the value
403:53 - of this we also have the power function
403:55 - here which is going to take the first
403:57 - parameter and elevate that to the power
403:59 - of the second parameter
404:01 - so
404:02 - this is going to be 3 to the power of 4
404:05 - and 9 to the power of 3 and we're going
404:08 - to get the answer if we plug this into
404:10 - visual studio code and we have look
404:13 - functions which is basically the reverse
404:16 - of the power function that we just
404:18 - looked at
404:20 - if you do log 8 in base 2 for example
404:24 - it is like you are asking to which power
404:27 - should i elevate 2
404:29 - so that i get 8.
404:31 - and the answer here is going to be a 3
404:33 - of course but the catch is that the log
404:36 - function by default works in base e
404:39 - so what we are asking for example if we
404:42 - say log 54.59
404:46 - is to which power should we elevate e
404:49 - to get this number in here and it is
404:52 - going to be computed and you're going to
404:54 - see this if you plug this into
404:56 - visual studio code or you can try to use
404:59 - one of the calculators available to you
405:01 - and you're going to see that this makes
405:03 - sense we also have a special function
405:06 - that is going to do the same thing but
405:08 - in base 10
405:09 - and this is going to be easier to
405:11 - understand for example here we are
405:14 - computing log 10
405:16 - so
405:17 - what we are really saying is to which
405:19 - power should we elevate 10
405:22 - to get 10 000 and this is easy because
405:25 - the answer is a 4 10 to the power of 4
405:28 - is 10 000 i really hope this makes sense
405:32 - we also have a square route function we
405:35 - can use so square out of 81 is going to
405:38 - be nine
405:39 - we have a function called std round
405:42 - which can round
405:43 - and uh what it's going to do by default
405:46 - halfway points are going to be rounded
405:49 - away from zero so if you have a 2.5 it's
405:52 - going to be rounded up to a 3 and if you
405:55 - have 2.4 it's going to be rounded down
405:58 - to a 2. we also have a host of functions
406:01 - we can use in trigonometry we have a
406:04 - sine function we have a cosine function
406:06 - we have a tan function if you know these
406:08 - concepts in math this is going to come
406:11 - in really handy if you want to do this i
406:14 - have to say that what we just talked
406:16 - about is a small set of what we can do
406:19 - with these functions here in c math and
406:23 - uh we are here at cppreference.com
406:26 - and we can see all these functions here
406:29 - we can do reminder we can do f men and
406:32 - if you want you can check this out in
406:34 - the documentation for example if you go
406:37 - to can here and click on it you are
406:40 - going to get the description and
406:42 - explanation of what this function does
406:44 - and you're going to have a simple
406:46 - example of how you can play with us okay
406:49 - now i hope you have a better idea of
406:51 - what we can do with these functions in
406:54 - the cmat library we're going to head to
406:56 - visual studio code
406:58 - and play with some of these functions
407:00 - here we are in visual studio code the
407:03 - current project we're going to work on
407:05 - is math functions we're going to copy
407:07 - over our template files
407:10 - and we're going to put them in our
407:12 - directory here math functions
407:15 - and we are going to open this up in
407:17 - visual studio code and we are going to
407:21 - remove whatever it is we don't need
407:23 - and we are going to include our library
407:26 - which is c math
407:28 - and we are going to put in our code so
407:30 - that we can play with us
407:32 - and here we have a variable called
407:35 - weight
407:36 - and we're going to try and use a few
407:38 - math functions on it so we can use sdd
407:41 - floor to round down
407:43 - and std seal to round up so weighted
407:46 - rounded to floor is going to be printed
407:49 - out and way to round it to seal is going
407:51 - to be printed out
407:53 - we're going to have a number here
407:55 - in this savings variable it's going to
407:57 - be a negative number and we're going to
407:59 - try and compute the absolute value of
408:02 - this we're going to see it printed out
408:04 - another thing we're going to
408:06 - compute is the exponential of the value
408:09 - we're going to do stdx 10
408:12 - and what this is going to do is going to
408:15 - take e
408:16 - and raise it to the power of 10 and
408:19 - that's what we're going to get printed
408:21 - here the other thing we want to do here
408:23 - is compute the power of a number we're
408:25 - going to take 3 and raise it to the
408:26 - power of 4 and take 9 and raise it to
408:30 - the power of 3 and we're going to see
408:33 - what these things evaluate to we're
408:35 - going to open up our terminal here and
408:38 - we're going to run the task to build
408:40 - with gcc the world is going to be good
408:43 - and if we run rooster we're going to get
408:46 - these things here so 7.7 rounded to
408:49 - floor is going to be seven so we're
408:51 - going to round down 7.7 rounded to sale
408:54 - is going to be eight and that's what
408:56 - we're going to get and the absolute
408:59 - value of weight is going to be
409:02 - 7.7 because it is a positive number and
409:06 - the absolute value of minus 5000 is
409:09 - going to be 5 000. and again when you
409:11 - compute the absolute value of something
409:14 - you are interested in the weight of that
409:17 - thing without considering the sign
409:21 - without really worrying if it is
409:23 - positive or negative you just want to
409:25 - get the magnitude of a number that's
409:27 - what we use in math to mean that
409:30 - magnitude okay so if we go down we're
409:32 - going to get the exponential of 10 is
409:35 - exponential
409:36 - and you're going to get that here and
409:38 - again what this function does is take e
409:42 - and raise it to the power of 10
409:45 - and that's the answer here we can try
409:47 - and prove this with a calculator so i am
409:50 - going to open my windows calculator you
409:52 - can use whatever calculator you have
409:54 - access to
409:55 - i am going to use a scientific
409:58 - calculator here and you see that we can
410:02 - hit e and we're going to get the value
410:04 - of this e number in math here it is
410:07 - simplified but if i take it and raise it
410:11 - to the power of 10 the answer is going
410:14 - to be 22.026
410:19 - and if we look in our program we have 22
410:22 - 0
410:23 - 26.5 okay it is rounded up a little bit
410:26 - but it is almost the same thing okay we
410:29 - also want to play with log functions a
410:32 - little bit
410:33 - log is basically the reverse of the
410:36 - power function
410:38 - and we just talked about this in the
410:40 - slides
410:41 - but
410:42 - if we do log 18 base 2 we are basically
410:45 - asking to which power should we raise 2
410:48 - to get an 8
410:50 - and the answer to that is going to be
410:52 - what this log
410:53 - number in base number is going to
410:55 - evaluate to the catch is that the log
410:58 - function if you use it row like this it
411:02 - is going to be using base e and we just
411:05 - saw that e is 2 to the power of 7 or
411:08 - something let's go back to our
411:09 - calculator and see if we can see that
411:12 - why not why try to guess when we have a
411:14 - good calculator in our hands we are
411:17 - using the scientific calculator so if we
411:20 - hit e here
411:22 - this is the value of e
411:24 - okay so
411:25 - when we do log
411:27 - we are basically asking to which power
411:29 - should we raise e
411:31 - so that we can get this
411:33 - 54.59 and the answer is going to be
411:36 - computed and printed out here
411:38 - we have a version of this that is going
411:41 - to use base 10 so if we use this
411:44 - we are basically saying to which power
411:46 - should we raise 10 to get 10 000 and the
411:49 - answer is going to be printed out here
411:51 - and it is going to be a four because
411:53 - this is easy to do in your mind so let's
411:57 - run this we're going to build the task
412:00 - we are going to run the task to build
412:02 - with gcc and we're going to run our
412:05 - program and uh we're going to get our
412:08 - output here to get
412:10 - 54.59 you would elevate e to the power
412:14 - of this number here this is the answer
412:16 - and if you want you can prove this with
412:18 - your favorite calculator you're going to
412:20 - get something close to this to get 10
412:22 - 000 you'd need to elevate 10 to the
412:25 - power of 4. that's what we're going to
412:27 - get in here let's print this out again
412:30 - many mistakes sorry but i hope you get
412:32 - the point if we build again so that we
412:35 - can see things properly and run we're
412:38 - going to get proper data and this is
412:40 - really what we expected to get we have a
412:42 - few more functions we can play with as
412:44 - we saw in our slides
412:47 - let's play with square root and the std
412:51 - round function here we are going to get
412:53 - the square root of 81 we're going to get
412:56 - it printed down and we're going to see
412:58 - what std round does it is going to
413:01 - round away from zero if we are at half
413:05 - point and if we are not at half point if
413:08 - we are below that we're going to round
413:10 - down if we are higher than that we're
413:12 - going to round up we're going to run
413:14 - this so that you can see this running
413:16 - and we're going to call rooster and the
413:19 - 2.5 is rounded to 3. 2.4 is rounded to
413:23 - 2. 3.6 is rounded to 4. this is what we
413:26 - expect and the square root of 81
413:30 - is 9. this is really all we set out to
413:32 - do in this lecture to play with a few of
413:35 - these c math function
413:37 - they are not really hard to use once you
413:40 - have the basics of math nailed down and
413:43 - again if you want to check the full list
413:46 - of these functions please come to our
413:48 - reference documentation here you're
413:50 - going to find a lot of them
413:52 - and if you want to see how to use one of
413:54 - these for example if you click on log 10
413:57 - here you're going to come here you're
413:59 - going to get an explanation of the
414:00 - function and even better you're going to
414:03 - go down and get a nice piece of code you
414:05 - can play with and really make sense of
414:08 - what is happening in these functions
414:09 - here this is really all we set out to do
414:11 - in this lecture i hope you found it
414:13 - interesting we are going to stop here in
414:15 - this lecture the next one we're going to
414:17 - learn about some weird integral types
414:21 - go ahead and finish up here and meet me
414:23 - there in this lecture we're going to
414:25 - learn about some weird integral types
414:28 - and what do i mean by this well if you
414:30 - look here integral types less than 4
414:33 - bytes in size don't support arithmetic
414:36 - operations and these are operations like
414:39 - addition subtraction multiplication
414:41 - division you can do these operations on
414:44 - those types
414:45 - and here i have an example of some of
414:48 - those types we have a car it is one byte
414:51 - in size and short end
414:54 - is two bytes in size on most processors
414:57 - so you can't do arithmetic operations if
415:00 - your integer value is stored in these
415:03 - types
415:04 - why is that well this has to do with
415:06 - processor design
415:08 - and they decided to choose and as the
415:11 - smallest type
415:12 - integral type for which they can do
415:15 - these arithmetic operations but
415:17 - compilers are really smart enough to
415:19 - notice if you are trying to do
415:22 - arithmetic operations on these types and
415:24 - they are going to implicitly convert
415:27 - from
415:28 - these smaller types to end
415:30 - and this is something you need to be
415:32 - aware of if we look at this program here
415:35 - for example we have var1 and var2 they
415:39 - are stored in variables that are of type
415:42 - short and
415:43 - and we have var 3 var 4 which are stored
415:46 - in a variable of type car we can try and
415:50 - print the resizes and we're going to get
415:52 - two two one one for these variables
415:54 - because a short end
415:57 - occupies two bytes in memory for my
415:59 - computer here and the car occupies one
416:02 - byte in memory but the catch is down
416:05 - here
416:06 - if you try to add them up
416:08 - the result is not going to be the same
416:10 - type as defense you added up and you
416:13 - would expect
416:14 - auto
416:15 - to deduce to the same type as var one
416:19 - and var2
416:20 - and it's not resort is going to be an
416:22 - integer because and is the smallest type
416:26 - for which we can support these
416:27 - arithmetic operations so if we print the
416:30 - size of result one and reserved two
416:32 - we're going to get four but this is the
416:34 - behavior you're going to get and we need
416:37 - to be aware of it the same behavior can
416:39 - be observed on other operators that we
416:42 - will have a chance to look at in a few
416:44 - chapters ahead and these are called
416:47 - shift operators you use them to shift
416:49 - bets but i don't want to talk anymore
416:51 - about them because we're going to have a
416:53 - chance to learn about them in detail
416:55 - okay now is time to head to visual
416:58 - studio code and actually see this in
417:00 - action here we are in our working
417:03 - directory we are going to copy our
417:05 - template project we're going to copy
417:07 - this
417:08 - quickly put that in our folder on weird
417:12 - integral types this is our current
417:14 - project here and we're going to open
417:16 - this up in visual studio code we're
417:18 - going to open this up and we're going to
417:20 - open our main cpp file remove whatever
417:23 - it is we don't need and we are going to
417:25 - put in our code this must be very
417:28 - familiar because it is what we just saw
417:30 - in the slides
417:31 - so what we are doing here we have four
417:34 - variables var one and var two are short
417:36 - and so these are going to take two bytes
417:39 - in memory on my computer here and uh car
417:43 - is going to take up one byte and we're
417:45 - going to print their sizes we're going
417:46 - to see them printed down and we are
417:48 - adding things up here we are taking two
417:51 - short end variables and adding them up
417:54 - so what the compiler is going to do it's
417:56 - going to take this turn it into an end
417:58 - and then do addition and the result is
418:00 - going to be an end the same story is
418:02 - going to happen for reserved 2 here
418:05 - var 3 is a car so it is one byte in
418:09 - memory but the compiler can't really add
418:12 - up integral types which are smaller than
418:14 - four bytes in memory so what is going to
418:17 - happen var three is going to be
418:18 - transformed implicitly behind the scenes
418:22 - to a net and var four is going to be
418:24 - transformed to a net and then we're
418:26 - going to add that up and we're going to
418:28 - store that in a neat variable which is
418:31 - resort here
418:32 - if we print this up we're going to see
418:34 - that size of result 1 and result 2 is a
418:37 - 4 and this is what we expect here and
418:40 - this is a behavior you need to be aware
418:42 - of because sometimes your application
418:44 - logic is going to depend on the size of
418:47 - data if that's the case you need to care
418:50 - about this
418:51 - and if you don't know this you're going
418:52 - to be beaten by this and it is really
418:55 - hard to find problems like this
418:58 - so what we can do is open up our
419:01 - terminal and we're going to build this
419:03 - with gcc as we usually do and that we
419:06 - can run our program rooster and we're
419:09 - going to see that this is what we expect
419:10 - var1 is two bytes in size var2 is two
419:14 - bytes in size wire three and waterfall
419:16 - are one byte in size but our result is
419:19 - four bytes because the compiler
419:21 - implicitly converted
419:24 - our operands here to x to be able to
419:27 - carry out this arithmetic operation this
419:30 - is really all we setup to do in this
419:31 - lecture i hope you found it interesting
419:34 - we are going to stop here in this
419:35 - lecture the next one we're going to try
419:37 - and recap what we saw in the chapter
419:41 - congratulations on hitting the end of
419:43 - this chapter and this chapter was really
419:46 - about
419:47 - doing operations and manipulating the
419:50 - data that you have stored in your
419:53 - variables the first thing we saw was
419:55 - that we could do arithmetic operations
419:57 - on the data we can add things up
419:59 - multiply divide we also saw the modulus
420:02 - operator which may seem weird for
420:05 - beginners but we had a chance to really
420:07 - play with us after that we learned about
420:09 - precedence and associativity we saw that
420:11 - that's a set of rules
420:13 - we have to follow to know which
420:16 - operation to do first if we have
420:18 - multiple operators in our expression we
420:22 - also had a chance to learn about prefix
420:24 - and postfix increment and decrement
420:26 - operators we had a chance to do compound
420:29 - assignments things like plus equal minus
420:32 - equal multiply equal modulus equal now
420:35 - these things must be making sense to you
420:37 - we had a chance to look at how we could
420:39 - compare things using relational
420:42 - operators like greater than lesser than
420:45 - and equal or not equal we also had a
420:47 - chance to look at output formatting and
420:50 - we saw a host of things we could do to
420:53 - make data show up better with sddc out
420:57 - after that we learned about numeric
420:59 - limits and this is a cool way to know
421:02 - the ranges for your data types but there
421:04 - are a host of other properties you can
421:06 - use in this limits library we learned a
421:09 - little bit about math functions and we
421:11 - played with things like the power of
421:13 - something the exponential the few
421:16 - rounding functions that we have in the
421:18 - cmat library and now you must have a
421:21 - good idea about these functions that you
421:24 - can use to manipulate and do math on
421:26 - your variables we ended the chapter by
421:29 - looking at some weird integral types and
421:32 - the main message in that lecture was
421:34 - that you can't do arithmetic operations
421:37 - on data types whose size is less than 4
421:41 - bytes in memory if you try to do that
421:43 - the compiler is going to insert
421:45 - implicit conversions and if your
421:48 - application depends on the size of
421:50 - things
421:51 - this is something you need to be careful
421:53 - about otherwise you're going to have a
421:55 - hard time
421:57 - finding these problems i would like to
421:59 - welcome you in this new chapter where
422:02 - we're going to be learning about a new
422:04 - way we can do things in c plus plus and
422:06 - we're going to be doing conditional
422:09 - programming in other words we're going
422:11 - to be able to do different things
422:14 - based on the conditions that we have set
422:17 - up in our code just to give you an
422:19 - example here we have a few variables
422:21 - they are booleans and we have a few
422:23 - initializers in there red is false green
422:26 - is true yellow is false police stop is
422:29 - true and we can do
422:31 - different things based on discipline
422:33 - conditions for example
422:35 - if the light is red we may be
422:38 - told to stop
422:40 - if the light is yellow we might be told
422:42 - to slow down if the light is green we
422:44 - might be told to go and do whatever it
422:47 - is we want to do so we're going to be
422:49 - able to do these kinds of things and c
422:51 - plus plus provides different constructs
422:53 - to be able to do conditional programming
422:56 - in uc
422:57 - code we just have one of them in this
423:00 - slide which is this if statement here
423:02 - this if keyword allows you to do things
423:05 - like this we have a few others we have
423:07 - the else keyword we have the switch
423:09 - keyword we also have a completely
423:12 - separate operator that is called ternary
423:15 - operator that allows you to do these
423:18 - kinds of things and we're going to be
423:19 - learning about all these things and more
423:22 - in this chapter we are going to start
423:24 - and learn about the if statement in the
423:26 - next lecture
423:27 - go ahead and finish up here and meet me
423:29 - there
423:30 - in this lecture we're going to learn
423:32 - about the if statement and this is a
423:34 - statement that is going to allow you to
423:36 - do things based on some condition being
423:39 - true
423:40 - or false here is a simple code example
423:43 - we have two variables number one and
423:45 - number two
423:46 - and we have a statement here that is
423:48 - going to compare number one and number
423:51 - two and we're going to store the result
423:53 - in this boolean variable
423:56 - that we have on the left then we're
423:58 - going to do something based on the value
424:01 - that we are storing in this result here
424:04 - if the result in there is true we're
424:05 - going to print
424:07 - number one is less than number two if
424:09 - the result is not true we're going to
424:11 - say number one is not less than
424:14 - number two and notice in the first if
424:17 - close year we are testing for the case
424:20 - where the result is true but sometimes
424:23 - we need to do something when this
424:25 - condition here is not true one way to do
424:28 - that is to negate what we have here
424:31 - inside the if parenthesis and test for
424:34 - the reverse of whatever we have in here
424:37 - if that is making any sense if you look
424:39 - here we are testing for the case where
424:42 - if not the result is a true and in other
424:45 - words we are testing for the case where
424:47 - the result here is false and we're going
424:50 - to say number one is not less than
424:52 - number two this is one way we can go
424:54 - about this again the if statement is
424:57 - used to do conditional programming this
424:59 - is the syntax we use to do it in c plus
425:01 - plus we say f we put a set of
425:04 - parentheses and inside the parenthesis
425:06 - we put the condition we want to test for
425:10 - and after that we're going to have a
425:11 - pair of curly braces and what we have
425:14 - inside these curly braces is going to be
425:17 - the body of our if statement and it is
425:20 - basically going to be the code we want
425:22 - to run if the test here is successful we
425:26 - can also use an else clause to catch the
425:28 - case where the test hasn't been
425:31 - successful in this case we can say if
425:33 - result equals true we're going to do
425:35 - something
425:37 - and else we're going to do something
425:39 - else in other words if research is true
425:42 - we're going to say is less than if it's
425:44 - not true we're going to say is not less
425:46 - than and this is a more compact way of
425:49 - doing what we just did in the slide here
425:52 - you can also directly use your
425:54 - expression as a condition and the
425:57 - requirement here is that the expression
426:00 - evaluates to something that we can treat
426:03 - like a boolean because the condition has
426:05 - to be a boolean it has to be true or
426:08 - false okay here is another simple
426:10 - example we have seen this in the last
426:12 - lecture we have a few variables
426:14 - containing our conditions and we are
426:18 - saying if the light is red for example
426:20 - we're going to do something if it's
426:22 - yellow we're going to do something if
426:24 - it's green we're going to do something
426:26 - we can also nest conditions for example
426:29 - we can put our outer
426:32 - if statement and inside that if
426:34 - statement set up other if statements and
426:38 - if our logic needs something like this
426:40 - you can do this and you can take
426:42 - advantage of this to achieve whatever it
426:44 - is you want to do in this case if the
426:46 - light is green we're going to
426:48 - fall in here and we're going to do
426:50 - another condition so if the light is
426:52 - green and if the police officer has
426:54 - stopped you you're going to stop and if
426:57 - they haven't stopped you you're going to
426:58 - go because the light is green and you
427:00 - can do something like this
427:02 - we can also use logical operators to
427:04 - kind of achieve the same thing and we
427:06 - say if the light is green and the police
427:09 - officer hasn't stopped you you're going
427:11 - to go else you're going to stop and you
427:14 - can do something like this and you see
427:16 - that you can combine the logical
427:18 - operators we've learned about with the
427:21 - conditional programming techniques we
427:23 - are learning about here to do really
427:25 - powerful stuff and we're going to be
427:27 - doing this all over the place in the
427:29 - course so we're going to head over to
427:31 - visual studio code and play with us here
427:34 - we are in our working directory we're
427:36 - going to be working on if statements and
427:39 - we're going to grab our template project
427:42 - the template files i should say and
427:45 - we're going to put them in here
427:47 - and we're going to open this up in
427:49 - visual studio code as we always do so
427:51 - let's do that open folder and we should
427:54 - fall in here and open our main cpp file
427:57 - let's do the usual and remove what we
427:59 - don't need
428:00 - and we are going to put in our code so
428:02 - that we can really play with us we have
428:04 - two variables in here number one and
428:07 - number two they are integers and we have
428:09 - the values 55 and 60 inside we can do a
428:14 - comparison between these two variables
428:16 - and what this comparison is going to
428:18 - yield is a boolean value that we're
428:22 - going to store in our boolean variable
428:24 - here which is called result
428:26 - and what we can do is use this to do
428:29 - some conditional programming so we're
428:31 - going to say if the result is true we're
428:33 - going to do something and if the result
428:35 - is not true we're going to do something
428:38 - else and this is how we say it this
428:40 - syntax here may be confusing to new
428:43 - students but try to think of it if not
428:47 - research is true and that's really the
428:49 - same thing as saying if result is false
428:53 - try to stream this in your mind a little
428:55 - bit and you really are going to
428:56 - understand okay so now that you have
428:58 - seen this piece of code
429:00 - try to
429:01 - guess what we're going to see if we run
429:03 - this what are we going to see on the
429:05 - console okay give it a try so we're
429:07 - going to run this in visual studio code
429:10 - let's open up a terminal first
429:12 - and we're going to world with gcc as we
429:14 - always do
429:16 - we're going to bring this up a little
429:17 - bit so that we have some breathing room
429:20 - and we're going to run rooster let's see
429:22 - what we have here we have reserved
429:24 - equals true and that's coming from this
429:27 - statement here
429:28 - and we have freestanding if statement
429:32 - which is coming from
429:34 - here and we have our meat of this
429:36 - program what we really are interested in
429:39 - we have 55 is less than 60. so our test
429:43 - here succeeded and we fell in this body
429:47 - and executed this sddc out statement
429:50 - that's why we're saying number one is
429:52 - less than
429:54 - number two and number one is 55 which is
429:56 - what we see here and number two is 60
430:00 - which is what we are seeing here
430:02 - so what can we do to make
430:05 - the second statement here execute you
430:08 - know it is testing for the case where
430:11 - not result is true so it's going to
430:13 - exactly do the reverse of what this test
430:16 - here is doing
430:17 - and if this fails this one is going to
430:19 - succeed which is what we have now so
430:22 - what we can do to really play with this
430:23 - we can go up and change for example
430:26 - number one to 65
430:29 - this is going to flip the order of these
430:31 - numbers if i may say it like that and if
430:34 - we run it we're going to build with gcc
430:37 - and run this
430:39 - we're going to see result is false so
430:42 - result became false because number one
430:45 - is not less than number two so this is
430:47 - going to be false and the test here is
430:50 - going to fail result is not true so
430:53 - we're not going to go in here and look
430:56 - at here if not result is true so
430:59 - research is true is false
431:01 - if we negate this this is going to
431:03 - become true and this test here is going
431:06 - to succeed and we are going to fall in
431:08 - here take some time to really understand
431:10 - this and if you have a problem ask me i
431:13 - am going to do the best i can to help
431:14 - you out but make sure you understand
431:17 - this because this is really fundamental
431:19 - in your journey as a software developer
431:22 - not just in c plus plus any career as a
431:24 - software developer you're going to need
431:26 - to understand this okay what we're going
431:28 - to do is comment out
431:31 - what we just did here because we're
431:32 - going to see another way to do this and
431:34 - we don't want to have noise output in
431:37 - our terminal this is going to just make
431:39 - things hard for us to see so what we're
431:42 - going to do
431:43 - we're going to go down in here and put
431:45 - in another piece of code and
431:47 - the result was commented out we don't
431:49 - want to comment that out so we're going
431:51 - to take this out because this is our
431:53 - condition we're going to grab it and put
431:55 - that outside our comment section this is
431:58 - going to do and if we go down again
432:00 - we're going to click on this file icon
432:02 - and uh give ourselves some more
432:05 - breathing room here we don't really need
432:06 - to see that main cpp file anyway
432:09 - so if we come here we can use the else
432:11 - clause
432:12 - to test for the case where our condition
432:14 - fails
432:15 - and if you look here we are essentially
432:18 - saying the same thing we are saying if
432:20 - result equals true we're going to fall
432:22 - in here and else we're going to fall in
432:25 - here so we don't need to do the double
432:27 - if statements that we just did
432:30 - here and this is much more compact and
432:32 - easy to read let's look again at the
432:34 - numbers we have here number one is 65
432:37 - number 2 is 60. this expression here is
432:39 - going to be false because 65 is not less
432:43 - than 60 we're going to have a false in
432:45 - here and if we come down
432:48 - result is going to be false this is
432:50 - going to fail and we are going to fall
432:52 - down here we're going to say
432:54 - number one
432:55 - or 65 is not less than 60 which is what
432:59 - we have in our values so we're going to
433:02 - build this again and we're going to run
433:04 - rooster that's clear so that we have
433:06 - some breathing room we're going to run
433:08 - rooster and you're going to see that 65
433:11 - is not less than
433:13 - 60 which is what we expect again if you
433:15 - go up and change these numbers to
433:17 - whatever you want try to change these
433:19 - numbers to different values to see what
433:22 - you get as output if we do this we're
433:25 - going to see that number one is less
433:27 - than 60 so this is going to be true
433:30 - and we're going to have a true in this
433:31 - result variable here if we go down
433:34 - result is true this test condition here
433:37 - is going to succeed and we are going to
433:39 - fall in here let's click in our terminal
433:42 - and hit enter we're going to run rooster
433:44 - we're going to see 55 is less than 60
433:46 - which is what we have here okay now i
433:49 - hope you have a better idea of how you
433:51 - can use the else close to make your if
433:54 - statements really compact and this is
433:56 - really cool okay another thing i want
433:58 - you to see is that you can
434:00 - not go through a variable like this and
434:03 - use an expression as a condition
434:05 - directly c plus plus allows you to do
434:07 - this so what we're going to do we're
434:09 - going to comment out what we just did
434:11 - let's do that i'm going to use a block
434:13 - comment i hope you know how to use this
434:15 - already
434:16 - and we're going to go down and put in
434:18 - our code it is exactly the same thing
434:21 - but we took the expression and put that
434:23 - in the place of our condition variable
434:25 - here because this is going to evaluate
434:28 - to a boolean anyway so we can use this
434:31 - as a condition and this is something
434:33 - very legal to do in c plus plus so if we
434:36 - run this we're going to see let's see
434:38 - what we have in the numbers i have
434:39 - forgotten
434:40 - by now so 55 number one sixty number two
434:44 - number one is less than number two this
434:46 - is going to be true
434:48 - so the test here is going to succeed and
434:51 - we are going to fall in here that's what
434:52 - we're going to say we're going to weld
434:55 - with gcc as usual
434:57 - and i'm going to clear and run rooster
435:01 - and you're going to see that this is the
435:02 - output we expect if we change up the
435:05 - numbers again let's take this and make
435:07 - it a 75 number one so number one
435:10 - is less than number two is going to
435:12 - evaluate to false the test here is going
435:15 - to fail and we are going to fall in this
435:18 - block here we're going to fall in the
435:20 - else close of our test here we're going
435:23 - to say
435:24 - 75 is not less than
435:27 - 55 is that what we have in there it's a
435:29 - 60 but this block here is going to
435:32 - execute that's the most important thing
435:34 - so we're going to run this and we're
435:36 - going to try and clear and run rooster
435:39 - we're going to get what we expect this
435:41 - is one way we can do this and it is
435:43 - really cool let's comment this out and
435:46 - see another example and if we go down we
435:48 - can see
435:50 - the example we saw in the slides which
435:52 - was using red green and
435:56 - yellow
435:57 - to simulate a traffic light
436:00 - so what we really want to see here is
436:02 - that we can nest stuff but before we do
436:05 - that we need to
436:06 - try and use these conditions because it
436:08 - is just fun so if red is true meaning
436:11 - that the red light is on we're going to
436:14 - stop if yellow is true we're going to
436:16 - slow down if green is true we're going
436:19 - to go
436:20 - and if we look at what we have here
436:23 - red is false green is true false is true
436:26 - and a police stop is true police stop is
436:28 - not really being used so green is true
436:30 - we're going to execute the green
436:32 - statement here and we're going to say go
436:35 - that's what we're going to say let's try
436:37 - and run this
436:38 - we're going to build with gcc
436:41 - bring this up a little bit so that we
436:43 - have some breathing room
436:45 - and we're going to clear
436:47 - and run rooster and you see that it is
436:49 - saying
436:50 - go here you can try and change these
436:53 - boolean variables to different things
436:56 - and see what is printed out here this is
436:58 - a great way to learn but what we really
437:00 - want to try here
437:02 - is nested statements and let's go down
437:05 - and do that okay again we don't want
437:07 - what we have on top here to disturb us
437:09 - so we're going to
437:11 - comment this out and we are going to go
437:14 - down and put in our code
437:17 - for nested if statements
437:20 - so what we're going to say
437:22 - is if the light is green we should go
437:25 - but the police officer has the right to
437:28 - stop us even if the light is green at
437:30 - least these are the laws in the country
437:32 - where i leave so we have a variable
437:34 - called police stop here so if they stop
437:37 - you even if the light is green you're
437:40 - going to stop and we're going to see
437:41 - what we see here so if the light is
437:43 - green we're going to fall in this body
437:45 - again and we're going to run this inside
437:49 - or nested if statement and if the
437:51 - officer has stopped us we're going to
437:53 - stop
437:54 - if they haven't stopped us we're going
437:56 - to go and go on our merry way this is
437:59 - what we want to see here and again i
438:01 - want you to stop for a moment try to run
438:03 - this through your brain and try to come
438:06 - up with the value we're going to see
438:09 - when we run this in visual studio code
438:11 - pause for a minute
438:12 - we're going to run this
438:15 - we're going to build with gcc
438:17 - and we're going to run a program and you
438:20 - see that police officer stops
438:22 - stop
438:23 - and why is that
438:25 - the light is green okay so we we should
438:28 - usually go but the police stop variable
438:31 - here is also true so if we fall in here
438:34 - this is going to execute and it is going
438:37 - to succeed and we are going to say stop
438:39 - and once this statement executes the
438:42 - else statement is not going to execute
438:45 - control is going to fall outside here
438:48 - and we're going to keep doing whatever
438:50 - we have outside this if statement here
438:53 - this is really critical to understand if
438:56 - one
438:57 - block of a statement succeeds all the
439:00 - others are not going to execute and try
439:03 - to really understand this okay we have
439:05 - seen this we can now comment this out
439:07 - because we have something else i want to
439:10 - show you
439:11 - we're going to comment this out and
439:13 - that's that you can combine the if
439:16 - statements here or conditional
439:18 - programming with the logical operators
439:21 - we have learned about earlier in the
439:23 - course and do really powerful stuff for
439:25 - example here we can actually
439:28 - not use this nested statement and do
439:31 - this in one go like this and i think
439:33 - this is much cleaner so we're going to
439:35 - say if the light is green and the police
439:38 - officer hasn't stopped us we're going to
439:40 - go and if they have stopped us we're
439:43 - going to stop and you're going to see
439:44 - that we're going to get exactly the same
439:46 - result that we had before but this is
439:49 - really much more compact so we're going
439:51 - to run and see the result of this and
439:53 - we're going to clear clear
439:56 - and run rooster you're going to see that
439:58 - they're going to stop us and this is
440:00 - really cool you can go
440:02 - up again and change up these variables
440:04 - to really anything you want and see what
440:07 - you get trying to really understand what
440:09 - is going on here it is not difficult and
440:12 - the if statement is really fundamental
440:14 - to any programming you're going to do so
440:17 - this is really all we set up to do in
440:19 - this lecture to learn about conditional
440:21 - programming using the if statement it is
440:24 - a powerful thing and you're going to see
440:26 - it all over your software development
440:29 - career so make sure you really
440:31 - understand this but even if it's not
440:33 - clear now we're going to have a chance
440:35 - to do many examples and you're going to
440:37 - really understand what this is all about
440:40 - we are going to stop here in this
440:41 - lecture the next one we're going to see
440:43 - how we can use the else if close
440:46 - go ahead and finish up here and meet me
440:49 - there in this lecture we're going to
440:50 - learn about the else if close that you
440:54 - can attach to your if statement
440:57 - and that's going to allow you to test
440:59 - for several conditions in your if
441:01 - statement
441:02 - and
441:03 - to really understand this suppose we are
441:06 - building a drawing application and at
441:09 - any given moment the user might be using
441:12 - the pan or the marker or the eraser
441:14 - already whatever tool that it is we
441:17 - provide in our application
441:19 - and if we want to draw
441:22 - we need to know which tool is currently
441:24 - selected by the user and we can do a
441:27 - piece of logic like this we can have the
441:29 - tool stored somewhere in our application
441:32 - and when we get to the moment where we
441:35 - want to do something for example when
441:36 - the user clicks with the mouse and they
441:38 - want to drag and start doing things then
441:41 - we're going to test for the current tool
441:44 - if the tool is the pan we're going to
441:45 - use the settings for the pen if the tool
441:47 - is the marker we're going to use the
441:49 - settings of the marker and we're going
441:51 - to keep doing this and select
441:53 - one tool that is actually selected as
441:56 - the current tool by the user and when
441:58 - you do something like this only one
442:00 - block in this whole chain of statements
442:03 - is going to execute so for example if we
442:06 - have the marker as the current tool the
442:09 - code inside this block is going to
442:11 - execute and say active tool is marker
442:14 - but nothing else in this block is going
442:17 - to execute after we run this statement
442:20 - control is going to jump at the end of
442:22 - this whole chain of if and else if
442:25 - statements here i really hope you
442:27 - understand this and uh this is really
442:29 - powerful stuff for example
442:31 - this is one of the applications i have
442:34 - done in one of my advanced course about
442:36 - qt and c plus qt is a framework that
442:39 - allows you to do graphical user
442:40 - interfaces like this and you can build
442:42 - applications like this so what i did
442:44 - here is i did the exact same thing that
442:47 - we have here i had the chain of if and
442:50 - else if statements and whatever tool
442:53 - was selected as the current tool was
442:56 - used to draw things on the canvas here
442:58 - for example if the current tool was the
443:00 - pen and the pen is this little pen tool
443:02 - here if it is active we're going to draw
443:04 - things like hello world here if we have
443:07 - the star selected we're going to draw
443:08 - stars if we have the rectangle selected
443:11 - we're going to draw rectangles we could
443:12 - do all kinds of crazy things using this
443:15 - piece of logic here but it is powerful
443:17 - stuff and you really have to make sure
443:19 - you understand this so this is how the
443:21 - else if clause can really help you the
443:24 - main thing is to allow you to test for
443:26 - several different conditions you could
443:28 - do this with a lot of if statements but
443:30 - that's not going to be really cool it's
443:32 - going to be ugly and hard to read this
443:34 - is what you should do
443:36 - now that you have an idea about this
443:38 - we're going to head to visual studio
443:39 - code and actually see this in action
443:41 - here we are in our working directory
443:44 - we're going to grab our template project
443:47 - pretty quick and we're going to use the
443:49 - else if project here that's our current
443:51 - project so we're going to do that and
443:54 - open this up in visual studio code as we
443:56 - always do we're going to open this up
443:58 - we're going to open main cpp and we're
444:01 - going to remove what we don't need
444:03 - the first thing i am going to do is to
444:05 - put in a set of variables that are going
444:08 - to store our tools and we can do
444:10 - something like this we have a variable
444:12 - for pen marker eraser rectangle circle
444:15 - and ellipse i have to say that this is
444:17 - not the way to go about this we're going
444:19 - to learn about another way we can do
444:21 - this but that's going to be there in the
444:23 - course when we have enough tools to
444:25 - understand this for now we're just going
444:27 - to be happy with this
444:29 - okay 10 is going to represent the pan 20
444:32 - is going to represent the marker 30 is
444:34 - going to represent the razor and we can
444:36 - go on until we hit ellipse which is
444:38 - represented by 60. now if we go in main
444:41 - and set up a variable and call it tool
444:43 - for example and initialize it with
444:46 - whatever tool we think that the user is
444:48 - currently using for example we can use
444:50 - circle and initialize this we can set up
444:53 - a chain of s and else if statements to
444:57 - do whatever it is we want to do when
444:59 - this tool here is selected okay we're
445:01 - going to go down and put in our code i
445:04 - don't want to type all this so i'm going
445:06 - to put this up here and if you want you
445:08 - can copy the code from the
445:10 - resource section the code is going to be
445:12 - there you can copy it and paste it in
445:14 - here and do things with that okay we
445:16 - have a chain of if and else if close is
445:19 - in here and the first one is going to
445:21 - test and see if the tool is the pan and
445:23 - notice that we are using double equal
445:26 - signs here this is what you use to test
445:28 - for equality you don't use one equal
445:30 - sign you have to use two equal signs if
445:33 - you use one equal sign that's going to
445:35 - be an assignment and this is going to
445:36 - always evaluate to true so you don't
445:38 - want to do that again to test for
445:41 - equality you're going to use double
445:43 - equal signs in c plus plus so if the
445:45 - current tool is the pen we're going to
445:47 - say active tool span if the current tool
445:49 - is marker we're going to say that so we
445:51 - are basically going to do this for all
445:54 - the tools that our application supports
445:57 - so what do you think we'll see
445:59 - when we run this the active tool is
446:01 - circle
446:02 - so we should print active tool is circle
446:05 - here
446:06 - let's try this out we're going to open
446:08 - the terminal so that we can see the
446:10 - output nicely and we're going to world
446:12 - with gcc and the build is going to go
446:14 - through if we run this we're going to
446:16 - see active tool is circle you can go up
446:19 - here and change the tool to rectangle
446:21 - for example if you build again you're
446:23 - going to see that the correct block of
446:26 - code is going to be executed we're going
446:27 - to clear and run rooster active tool is
446:30 - rectangle if we try to put in something
446:33 - that doesn't exist let's say let's put
446:35 - in bird
446:36 - just to mess with our compiler here
446:39 - we're going to get a compiler error
446:40 - because that type is not known by
446:43 - our code here so we're going to get bird
446:45 - was not declared in this scope we don't
446:47 - know what it is you have to put in
446:49 - whatever thing you have declared
446:52 - beforehand here so if we put in a razor
446:55 - for example we're going to weld with gcc
446:58 - the world is going to go through going
447:00 - to clear run rooster the tool is going
447:02 - to be eraser and this is exactly what we
447:04 - expect again the main message in this
447:07 - lecture is that you can use this else if
447:10 - close if you have several conditions
447:12 - that you want to test for just like we
447:15 - have here and again one of these blocks
447:17 - is going to execute and once we hit the
447:20 - end of this chain of if and else if
447:23 - closes we're going to fall here and code
447:26 - after that is going to execute so let's
447:28 - say moving on so that you can really see
447:30 - this here very clear moving on and if we
447:33 - bolt this we're going to see only one
447:36 - block from this whole chain and once one
447:39 - block executes control is going to go
447:42 - after all this chain and execute
447:45 - whatever is after that so we're going to
447:47 - say moving on after we print that the
447:50 - active tool is eraser here i think we
447:52 - have built this so let's
447:55 - try and run this and you see active tool
447:58 - is razer and moving on so after we print
448:01 - the code from the eraser block we're not
448:04 - going to execute rectangle or a circle
448:07 - or ellipse it's going to jump at the end
448:10 - of this whole block this is really
448:12 - what i want to be
448:14 - super clear and again make sure you
448:16 - understand the syntax here the else if
448:18 - statement is followed by a set of
448:20 - parentheses and inside the parenthesis
448:23 - we have the condition we want to test
448:25 - for the condition has to evaluate to
448:28 - boolean and after that we have the block
448:31 - of code that we want to execute and this
448:33 - is really all you have to do to get this
448:35 - to work to your advantage
448:38 - we are going to stop here in this
448:39 - lecture in the next one we're going to
448:41 - learn about switch
448:43 - go ahead and finish up here and meet me
448:45 - there
448:46 - in this lecture we're going to learn
448:48 - about the switch statement and this is
448:51 - an alternative way to do what we did
448:54 - with these else if clauses in the last
448:56 - lecture basically testing for several
448:59 - different conditions but it's going to
449:01 - be in a much more compact way than what
449:03 - we did in the last lecture we are going
449:06 - to be using the exact same example we
449:08 - did in the last lecture and we're going
449:10 - to look at the switch statement and how
449:12 - it works in c plus plus and this is how
449:15 - it works we have our variable which is
449:17 - going to store the current tool and
449:20 - we're going to say switch
449:21 - inside the parenthesis here we're going
449:23 - to
449:24 - pass the variable that we're going to be
449:26 - basically switching on or testing the
449:29 - conditions on
449:30 - and inside the block we're going to be
449:33 - basically testing for each case so we're
449:36 - going to say if the current tool is the
449:38 - pan we're going to say case pan we're
449:40 - going to put a colon in here and we're
449:42 - going to put the code we want to execute
449:44 - for the case
449:46 - where the current tool is the pan in
449:48 - these curly braces here and one thing
449:51 - you should notice from the start is this
449:53 - break statement here
449:55 - this is a statement that tells c plus
449:58 - plus
449:59 - that after we successfully execute a
450:02 - block of code we're going to jump out of
450:05 - this switch statement if you omit this
450:07 - break statement
450:09 - everything after the case that you just
450:12 - executed is going to execute and that's
450:14 - not probably going to be what you want
450:17 - if this is not making sense yet please
450:19 - bear with me you're going to see it run
450:21 - in visual studio code and you are going
450:23 - to understand so what you're going to do
450:25 - you're going to put all the tools you
450:27 - want to test for in separate cases you
450:30 - see here we have marker and after that
450:33 - you can put a default case that is going
450:36 - to be matched when nothing has been
450:39 - matched in whatever it is you have
450:40 - tested for in this switch block here and
450:44 - when we run this piece of code we're
450:45 - going to get exactly the same results
450:47 - that we had in the last lecture but
450:50 - hopefully you can see that this is much
450:52 - more compact than the series of else if
450:55 - closes that we had in the last lecture
450:58 - again the break statement is really
451:00 - useful if you don't put it in c plus
451:02 - plus is going to be confused and after
451:04 - you hit your successful case
451:07 - everything after that is going to be
451:09 - executed so the break statement is
451:11 - basically telling c plus plus if you hit
451:14 - it after a successful case is
451:17 - jump out of this switch block because
451:19 - you are done you don't have to do
451:21 - anything else in here and another thing
451:23 - you should know is that the condition
451:26 - which is what we have inside this
451:27 - parenthesis here can only be an integer
451:31 - or an enum so basically it can be ant
451:33 - long unsigned or car
451:36 - basically every integral type we have
451:38 - seen before but it can't be another type
451:40 - such as string because that doesn't
451:42 - really make sense so be sure to keep
451:45 - this in mind
451:46 - now that you have an idea about this
451:48 - switch statement let's head to visual
451:50 - video code and actually see this in
451:53 - action here we are in our working folder
451:56 - the current project is going to be
451:58 - switch so we're going to grab our
451:59 - template files and we're going to bring
452:02 - that in here i'm going to go up a little
452:04 - bit and open this up in visual studio
452:07 - code as we always do and we're going to
452:09 - open up our main file we're going to get
452:11 - rid of what we don't need we are going
452:13 - to go outside the main function here and
452:16 - put in our tools just like in the last
452:18 - lecture we are using integers each one
452:21 - is represented by 10 20 30 up to 60 and
452:24 - these are the tools we have and i don't
452:26 - think i explained this but we are
452:28 - flagging them const because we don't
452:30 - want them to be modifiable we have seen
452:33 - about const earlier in the course we are
452:36 - going to jump into main and set up our
452:38 - variable it's going to be ant and we're
452:40 - going to call it tool and we're going to
452:42 - initialize this whatever tool we want
452:44 - let's use eraser why not and then we're
452:47 - going to put in our switch block we're
452:49 - going to say switch
452:50 - and if i type this you see that visual
452:53 - studio code is going to give me
452:55 - intelligence or suggestions on what
452:57 - thing i could do one cool thing that
453:00 - visual studio code does is give you
453:01 - snippets to really help you type things
453:03 - out so we can click on this and it is
453:06 - going to auto complete a starter version
453:09 - of our case and we can type in our
453:13 - expression here which is going to be
453:15 - what we're going to be switching over so
453:18 - we're going to switch over the variable
453:19 - tool here and we can put in our cases so
453:22 - in our case we're going to start with
453:24 - pan which is what we have here so we're
453:26 - going to say case pan we're going to
453:28 - remove all this
453:30 - uh let's remove this and say pen
453:34 - i'm going to put a column
453:35 - and we're going to put
453:37 - a block of code that is going to execute
453:40 - when the current tool is the pen and
453:42 - we're going to put that in here let's
453:44 - bring this
453:45 - to the right a little bit and inside the
453:47 - block we can say sddc out active tool is
453:51 - pan okay so after that we're going to
453:54 - put this break statement if it's not
453:56 - here we're going to have a problem
453:58 - because when the current tool is the pan
454:00 - and this code here executes every case
454:03 - after that is going to execute and
454:05 - that's not what we want we have to
454:06 - remember to put this break statement
454:08 - here okay so we're going to put in all
454:10 - our other cases so we're going to copy
454:12 - this
454:14 - and look at the next one it's going to
454:15 - be marker so we can go on the next line
454:18 - and put in marker we're going to paste
454:20 - this in we're going to say marker and
454:22 - we're going to say active tool is marker
454:25 - and we can keep doing the same thing
454:27 - we're going to go download them and
454:29 - paste this in the next one is going to
454:32 - be eraser so let's do that we're going
454:34 - to say eraser and we're going to say
454:36 - current tool is razer and we're going to
454:38 - go down again
454:40 - i am doing this live because it really
454:42 - is important for you to see me type this
454:46 - otherwise you may be confused because
454:47 - this is a slightly confusing construct
454:50 - we have in c plus plus the next one is
454:54 - rectangle so we're going to use that and
454:56 - we're going to say current tool is
454:58 - rectangle the next one is going to be
455:01 - circle and ellipse so let's do that
455:03 - we're going to put in circle we're going
455:05 - to go down and paste this in and bring
455:08 - this back a little bit
455:10 - and i'm going to say circle and we're
455:12 - going to go down and put the next one in
455:15 - which is going to be ellipse and after
455:17 - that notice that video studio code also
455:20 - inserted a default block and this is a
455:23 - block that is going to execute when none
455:26 - of the cases here
455:27 - is head
455:29 - so this is really important so you can
455:31 - also add a block of code
455:34 - and say no match found okay so we want
455:37 - to see this print out and we're going to
455:39 - try this out in a minute
455:41 - okay after we do this we should get this
455:43 - to work and do whatever we were doing in
455:46 - the last lecture so the current tool is
455:48 - going to be razer
455:50 - the block here is going to be matched so
455:52 - code here is going to execute
455:54 - after that we're going to meet this
455:56 - break and what it's really saying is
455:59 - you have done what you have to do jump
456:01 - out of this switch block here and we're
456:03 - going to go to the end of this switch
456:05 - block and we're going to execute
456:07 - whatever is after that so just like in
456:09 - the last lecture we can say moving on
456:11 - and if we execute the program as we have
456:14 - it now
456:15 - it's going to say active tool is razor
456:18 - and it's going to print moving on
456:21 - let's bring up the terminal so that we
456:23 - can really see this and we're going to
456:25 - build with gcc the world is going to be
456:28 - good and if we run rooster let's clear a
456:31 - bit we're going to see that active tool
456:33 - is a razor and we are moving on this is
456:36 - really cool and it is exactly the same
456:38 - thing we had
456:39 - in the last lecture but now we are using
456:42 - a much cleaner construct which switch
456:45 - provides okay we can try to change the
456:48 - tool and see that this really works we
456:50 - can put in circle
456:52 - why not i'm going to build with gcc the
456:54 - world is going to go through as you see
456:57 - here and if we run rooster we're going
456:59 - to see active tool a circle we are
457:01 - moving on you can try and change this
457:03 - however you want if we put in ellipse
457:06 - and world again we're going to build
457:08 - with gcc and if we run we're going to
457:11 - get active tool is pan and moving on why
457:14 - is that ellipse we are saying active
457:17 - tool is pen we didn't change that so we
457:19 - just code a really bad bag here so let's
457:22 - fix this and we're going to build again
457:25 - i'm glad i found this so we're going to
457:27 - clear and rooster
457:29 - and we're going to see active tool is
457:31 - ellipse and we are moving on
457:33 - okay so let's see what could happen
457:36 - if you forgot your break statement after
457:40 - your case here so the current tool is
457:43 - ellipse
457:44 - and it is the last thing we have in here
457:46 - so it's not a good test case
457:49 - what i am going to do
457:51 - is make the current tool the pen or the
457:53 - marker let's use marker that's going to
457:55 - do
457:57 - and i am going to remove the break
457:59 - statement here
458:01 - okay so and i am going to remove all the
458:03 - bread statements we have until we hit
458:07 - the
458:08 - last default
458:10 - case
458:11 - so we're going to go down
458:13 - and we're even going to remove that for
458:16 - the default case here
458:18 - and if we both we're going to build fine
458:20 - you're going to see that the world was
458:22 - good but if we run this try to guess
458:25 - what we're going to get the current
458:26 - stool is the marker so we should print
458:29 - marker
458:30 - and hit the end of the switch block and
458:34 - do moving on but let's see what we get
458:37 - did we build let's build again just to
458:39 - be sure so we're going to run rooster
458:42 - and notice what happens
458:44 - active tool is marker active thought is
458:46 - eraser active tool is rectangle we
458:48 - basically
458:50 - print every other case after the macro
458:53 - case is head
458:54 - and if we try to change this for example
458:57 - not use marker and use eraser let's
459:00 - change this you're going to see that
459:01 - we're going to
459:02 - match the eraser case
459:05 - and everything after that is also going
459:07 - to execute and it is not what you want
459:10 - so let's clear and run rooster you're
459:12 - going to see eraser rectangle circle
459:14 - ellipse and no match found so you have
459:16 - ready to remember to put in this brick
459:18 - statement i am going to hit ctrl z a
459:21 - couple of times and bring those in and i
459:24 - think this is enough we have to hit
459:26 - again so that marker also has it and if
459:29 - we run now we're going to get what we
459:31 - expect let's try to use an eraser again
459:33 - and if we both again and clear and run
459:36 - rooster we're going to see active tool
459:38 - is razer and we are moving on
459:41 - this is what we expect okay this is
459:43 - really how you work with a switch
459:45 - block you have to pass in your
459:47 - expression or your test case and you
459:50 - catch each case using this case syntax
459:52 - here you say case you pass in whatever
459:55 - it is you want to match and you put a
459:57 - column and you put your code inside this
459:59 - block here and remember after each case
460:02 - you have to add this break otherwise
460:05 - everything else after this is going to
460:07 - execute and it is not going to be what
460:09 - you want before i let you go i want to
460:12 - show you that you can actually group
460:14 - these case statements if this is what is
460:16 - making sense for your application so for
460:19 - example
460:21 - for
460:22 - rectangle circle and ellipse
460:25 - this can be grouped into the group of
460:27 - shapes
460:28 - so we can actually say
460:31 - case rectangle
460:33 - and uh put them on different lines
460:36 - something like this so let's delete this
460:39 - and say case rectangle
460:41 - and we're going to delete the other
460:43 - things
460:44 - and say
460:46 - case circle just like this and we're
460:48 - going to say drawing shape i think this
460:51 - syntax is supported in c plus plus okay
460:54 - so let's try in world
460:57 - and uh we're going to world with gcc
461:01 - and the world is going to be good so if
461:03 - we have a razor which is what we have in
461:06 - here we're going to say drawing shape
461:08 - let's clear
461:10 - and run rooster
461:12 - you're going to see drawing shapes
461:14 - moving on we have grouped different
461:17 - cases and handles them with one block
461:21 - and this may come in handy in some
461:23 - situations
461:24 - one thing you should keep in mind is
461:26 - that there are limitations on what you
461:29 - can use as an expression or a condition
461:32 - in your switch statement and that has to
461:34 - be an integer something like ant car
461:37 - unsigned shorter things like that we
461:39 - have seen all of these things but it can
461:41 - also be an enum but enam is something we
461:44 - haven't learned about yet we will learn
461:46 - about it later when we have enough tools
461:48 - to understand that but know about this
461:50 - limitation
461:52 - so if we can in our project in visual
461:55 - studio code for example and say
461:58 - std string name and say
462:00 - john for example and use this as a
462:03 - switch condition or expression we have
462:06 - to include string for this to work so
462:08 - let's go up
462:10 - and include the string library we're
462:12 - going to do string and if we go down
462:14 - again and try to do switch and use name
462:17 - as an expression and take out everything
462:20 - we have in here and try to compile this
462:22 - you see that the compiler is not happy
462:25 - okay it's going to say expression must
462:27 - have an integral or enum type so this is
462:30 - not even going to compile this is a
462:32 - limitation you have and you have to make
462:34 - sure what you pass as a condition here
462:37 - is an integer something like ant or car
462:41 - or other integral types we have learnt
462:43 - about in this course
462:46 - this lecture we're going to learn about
462:48 - ternary operators and this is an
462:51 - alternative way to do tests with the if
462:54 - statement
462:56 - suppose here we have a variable called
462:58 - max we have two variables called a and b
463:01 - and we want to find the maximum between
463:03 - these two things
463:04 - one easy way we can do this is say if a
463:07 - is greater than b we're going to store
463:09 - the maximum in max else then b is going
463:12 - to be the maximum and we're going to
463:14 - store that in our maximum value and
463:17 - we're going to print this out if we do
463:18 - this we're going to get whatever is the
463:20 - maximum between a and b to be printed
463:23 - out on the console and this is going to
463:25 - work really well but we can also use a
463:28 - ternary expression and the ternary
463:30 - expression looks like this
463:32 - and it starts with a pair of parentheses
463:34 - you're going to put your condition
463:36 - inside the parenthesis you're going to
463:38 - follow that with the question mark
463:40 - you're going to put your option one and
463:42 - after that you're going to put a column
463:44 - and option two and because this is a
463:46 - statement in c plus plus we're going to
463:49 - end this with a semicolon here is an
463:52 - equivalent version of that
463:54 - using f as we have been doing all along
463:57 - so we say if condition results equals
464:00 - option one if condition is false result
464:03 - is going to be equal to option two and
464:05 - this is exactly the same thing we are
464:07 - doing with our ternary expression here
464:09 - if the condition is true we're going to
464:11 - take option one and assign that to
464:13 - result if it's false we're going to take
464:15 - option two and assign that to resort so
464:18 - this is really a syntactic sugar or a
464:21 - shorthand for this thing here and it's
464:24 - going to make your code shorter and
464:25 - you're going to see this all over the
464:27 - place
464:28 - in c plus plus code out there so you
464:30 - really need to be
464:32 - familiar with this okay so here is our
464:35 - example of computing the maximum you see
464:38 - that we have the same variables max a
464:40 - and b but we have a one liner that is
464:43 - going to store the maximum in max and we
464:45 - can print this out
464:47 - and hopefully you can see that this is
464:49 - shorter and better than this okay one
464:52 - other thing you should know is that
464:54 - option one and option two should be of
464:57 - the same type or at least the types must
465:00 - be convertible and if that fails you're
465:02 - going to get a compiler error we can
465:04 - also do ternary initialization here we
465:06 - have a boolean called fast
465:09 - we initialize this to false we can use
465:12 - this to
465:14 - initialize our speed variable here we
465:16 - are basically saying if fast initialize
465:19 - this with 300 if not fast
465:23 - initialize this with 150
465:25 - and we're going to print the speed here
465:27 - and this is going to work and here you
465:29 - see that i lied a little bit in my
465:31 - explanation to make it really obvious
465:34 - what we had in our ternary expression
465:36 - you don't have to always wrap your
465:39 - condition in parenthesis but it makes
465:41 - the code much cleaner okay now that you
465:44 - have an idea about distance it's time we
465:47 - headed to visual studio code and
465:49 - actually tried this and so for ourselves
465:53 - okay here we are in our working folder
465:56 - the current project is ternary operators
465:58 - we're going to grab our template files
466:02 - and put those where they belong it is in
466:05 - this lecture here on ternary operators
466:08 - and we're going to open this up in
466:09 - visual studio code as we always do we're
466:12 - going to open this and we're going to
466:14 - open main cpp and take out whatever we
466:17 - don't need we are going to go down and
466:19 - put in our test code we basically have a
466:22 - few variables let's kill these spaces so
466:25 - that our code is not cluttered here and
466:28 - we're going to print our maximum
466:31 - and we're going to be using a regular if
466:33 - we have three variables max a and b we
466:36 - are saying if a is greater than b
466:39 - we're going to store the maximum and max
466:43 - otherwise we're going to store b
466:45 - in max
466:46 - and this is going to allow us to print
466:48 - whatever is the maximum between 35 and
466:50 - 20. if we build this let's bring up a
466:53 - terminal
466:54 - and we are going to build with gcc as we
466:57 - always do let's bring this up a little
467:00 - bit and we're going to clear
467:02 - and run rooster we're going to see that
467:04 - the maximum is 35 if we put our maximum
467:07 - in a beam
467:08 - we're going to get the maximum steel so
467:10 - we're going to run this out to build
467:12 - with gcc
467:14 - and we're going to run this clear
467:16 - rooster
467:18 - max is 200 so we're going to get the
467:20 - maximum regardless of where it is stored
467:23 - in a or b this is how our code works but
467:27 - we can use ternary operators to do the
467:30 - same thing
467:31 - so what we're going to do here we're
467:32 - going to comment out our if statement
467:35 - and use
467:36 - a ternary version so what we're going to
467:39 - do we're going to say result equals
467:42 - and we're going to say a greater than b
467:44 - we're going to put a question mark to
467:47 - signal
467:48 - the
467:49 - start of our two options option one is
467:51 - going to be a because if a is greater
467:54 - than b then a is going to be the maximum
467:57 - so we're going to grab a here and if a
468:00 - is not greater than b
468:02 - then b must be the maximum so we're
468:04 - going to put that as a second option
468:06 - here this is what we mean with this
468:08 - statement and we don't have a variable
468:10 - called results that's why we have a
468:12 - problem here we're going to put our
468:14 - result in max and this should
468:17 - solve this problem
468:19 - you see the squiggly lines go away and
468:22 - we can build this and we're going to get
468:23 - exactly the same result so this is our
468:26 - ternary operator if we build this it is
468:29 - going to go through and if we run this
468:31 - we're going to get exactly the same
468:33 - result max is 200 and it is what we
468:36 - expect okay so take some time and really
468:39 - make yourself familiar with this syntax
468:43 - it is really nothing complicated you
468:44 - just have to make sure your brain is
468:47 - aware of something like this and you're
468:49 - going to recognize that everywhere you
468:51 - see it in code out there okay we have
468:54 - mentioned that you can't pass types that
468:57 - are not compatible and the requirement
468:59 - is that a and b be of the same type
469:02 - or at least types you can do conversions
469:05 - between so for example if we try to do
469:08 - something like
469:10 - pass a hello in here
469:13 - we can't really turn a strength into a
469:17 - integer and this is going to give us a
469:19 - compiler error and let's look at the
469:21 - error we see from visual studio code
469:23 - operand types are incompatible and and
469:26 - the const car are not compatible and
469:29 - they have to be compatible if we ignore
469:31 - this and go ahead and build we're going
469:33 - to also see an error from the compiler
469:36 - and it should be the same error so
469:39 - operands to
469:41 - question mark and column have different
469:43 - types and and cost car
469:46 - and they have to be
469:47 - stands you can really compare so for
469:50 - example we can take out this string here
469:52 - and put in a floating point let's put in
469:55 - a 22.5 and say that this is a fluid
469:59 - you're going to see that the problem is
470:00 - going to go away here let's wait for a
470:02 - minute it's not going away we're going
470:04 - to build anyway you see the world is
470:06 - good we're going to clear
470:08 - so that we don't have all this clutter
470:10 - you see problems by the way and if we
470:13 - both again let's try to do that the
470:15 - builder is going to go through and if we
470:17 - run this we're going to get
470:19 - max is 22 because we are comparing a and
470:23 - 22 here and the compiler inserted an
470:26 - implicit conversion from this floating
470:28 - point to integer that's why we are
470:30 - seeing this here
470:32 - so what is the type that's the compiler
470:34 - really used here okay to make it really
470:37 - clear what is going on we're not going
470:39 - to
470:40 - use max here let's say auto max one
470:44 - and see what the compiler is really
470:46 - deducing to
470:48 - so we're going to take this out
470:50 - and by this we're going to see
470:53 - what implicit conversion the compiler
470:56 - really did here because what we had
470:58 - before we were doing an assignment so
471:00 - whatever was on the left was being
471:03 - turned into an integer because we were
471:04 - doing an implicit conversion from an
471:07 - assignment so whatever is on the left is
471:09 - turned into the type of whatever we have
471:12 - on the left of the assignment i hope you
471:14 - know this already but if we do things
471:16 - like this we're going to deduce whatever
471:18 - is on the left and assign that into max
471:21 - one so we're going to do so we're going
471:23 - to see the implicit conversion that the
471:24 - compiler did in here and it is good to
471:27 - be able to see things like that it is a
471:29 - curiosity thing so
471:31 - let's see what happens here we're going
471:32 - to print max one and i'm going to world
471:36 - with gcc this is going to go through
471:39 - and we're going to see what is printed
471:41 - so let's run rooster
471:43 - and you're going to see that the
471:44 - implicit conversion happened from end to
471:47 - flood and we deduce the flood here in
471:50 - max one so this is really interesting
471:52 - one might have thought that we had a
471:54 - conversion from float
471:56 - to end but it was actually the reverse
471:59 - and this is quite interesting this is
472:01 - really all we set out to do in this
472:02 - lecture i hope you found it interesting
472:05 - again make sure you have this syntax
472:07 - here drilled in your brain because
472:09 - you're going to be seeing this a lot in
472:11 - your career as a software developer not
472:14 - only a c plus plus developer actually
472:16 - and it is going to be helpful
472:18 - for you to know this
472:20 - congratulations on hitting the end of
472:22 - this chapter this chapter was all about
472:24 - flow control and we had the chance to
472:26 - learn about many of the tools that c
472:29 - plus plus provides to do conditional
472:32 - programming and we were able to see all
472:34 - kinds of crazy things we had the chance
472:35 - to do things like if red is true we're
472:38 - going to run the code inside if yellow
472:40 - is true we're going to run code inside
472:42 - if green is true we're going to run code
472:44 - inside and you had a chance to play with
472:46 - those things on many occasions we have
472:49 - seen that the tools that c plus plus
472:51 - provides really revolve around these
472:53 - four things here we have if statements
472:56 - we can do else closes
472:58 - on this if statements we can do else if
473:02 - to really do long chains of things where
473:05 - we do different decisions to do things
473:07 - in our applications we also saw that
473:10 - switch is an option if you have several
473:12 - decisions you can make in your
473:14 - application and we saw that a ternary
473:17 - operator can really be used to do
473:20 - two decisions if you have two decisions
473:22 - you're going to be able to reduce the
473:25 - number of lines you used to do these
473:27 - decisions with to one line and we had a
473:30 - chance to really look at that in detail
473:32 - in the lecture on ternary operators this
473:35 - is really all i had to share in this
473:37 - chapter i hope you found it interesting
473:40 - we are going to stop here in this
473:41 - lecture in the next chapter we're going
473:43 - to start and learn about loops
473:46 - go ahead and finish up here and meet me
473:48 - there in this chapter we're going to be
473:50 - learning about loops and this is a
473:53 - construct that is provided by the c plus
473:56 - plus programming language to allow you
473:58 - to do repetitive tasks relatively easily
474:03 - suppose we have a task to print a
474:06 - message 10 times
474:08 - we can go down and do it like this and
474:10 - it is going to work but what if they try
474:13 - and tell you
474:14 - do this 100 times then you're going to
474:16 - start scratching your head you're going
474:18 - to type this 100 times and you're going
474:20 - to run your program and it is going to
474:22 - work then your manager comes up and they
474:24 - say i want you to do this 10 000 times
474:26 - or even 100 000 times and then you're
474:28 - going to start pulling your hair or
474:30 - running around breaking vents because
474:32 - that's impossible to do not to worry
474:34 - here c plus plus provides a way to do
474:37 - this relatively easily and we're going
474:40 - to be learning about ways we can do this
474:42 - in our program in this chapter the
474:45 - constructs we're going to be using are
474:46 - these you see here there is a for loop a
474:49 - range base for a loop a while loop and
474:51 - do a while loop and we can make use of
474:54 - these tools to not go crazy printing a
474:57 - message one million times because that's
475:00 - really bad
475:01 - okay so that's what we are up against in
475:04 - this chapter we're going to be learning
475:05 - about these loop constructs and you're
475:07 - going to find that they are really cool
475:09 - for your application i am excited to be
475:12 - teaching you this so let's get started
475:14 - in the next lecture and learn about the
475:16 - for loop go ahead and finish up here and
475:19 - meet me there in this lecture we're
475:21 - going to learn about four loops
475:24 - for loops are one of the constructs we
475:26 - have in c plus plus to do repetitive
475:29 - tasks they allow us to do something like
475:31 - this much more easily for example we
475:33 - don't have to type stdc out of c plus
475:36 - plus 10 times or 100 times we can do
475:40 - this in less than five lines and you're
475:42 - going to see how cool this is the syntax
475:44 - for for loops looks like this and it may
475:47 - look intimidating for first users but
475:50 - we're going to break this down we have a
475:53 - few parts in here the first part is the
475:56 - iterator which is a variable that we're
475:58 - going to be using to navigate through
476:01 - the loop and that variable is this
476:03 - unsigned int i here we are going to
476:06 - initialize this to zero and the value we
476:09 - initialize this with is going to be our
476:12 - starting value and that's another key
476:14 - point of any loop any loop is going to
476:17 - have a starting point we are also going
476:19 - to have a test which is going to control
476:22 - when our loop ends for example this loop
476:25 - is going to start with i equal to zero
476:27 - it is going to keep doing stuff until
476:30 - i is no longer
476:32 - less than 10. as long as i is less than
476:35 - 10 it's going to keep doing whatever it
476:37 - is we want to do and the first part of
476:40 - the loop is this plus plus i thing here
476:43 - and this is an incrementation part
476:45 - that's how i'm going to call it for
476:46 - simplicity but at least a part that
476:49 - keeps changing our iterator to make our
476:52 - loop move forward after these four
476:55 - points we are going to have a pair of
476:57 - curly braces and inside these curly
477:00 - braces we're going to have the body of
477:03 - our loop and this is the code we want to
477:05 - execute multiple times and inside this
477:08 - loop body we can really do all kinds of
477:10 - crazy things you're going to see how
477:12 - cool this is again we have a few parts
477:14 - with our loop we have our iterator which
477:16 - is this variable i here we're going to
477:19 - be initializing this with a value that
477:21 - denotes where we want our loop to start
477:24 - we then have a test which is going to
477:26 - control when the loop is going to end
477:28 - we're going to have our incrementation
477:30 - part which is going to allow our loop to
477:33 - move forward and it's going to be doing
477:35 - that through incrementation or
477:36 - decrementation but to make explanation
477:39 - easier here we're going to call this
477:41 - part the incrementation part of the loop
477:44 - after that we're going to have the body
477:46 - of the loop and it's going to be within
477:48 - this curly braces and it's going to be
477:50 - whatever it is we want to execute inside
477:53 - this loop okay these are the parts of a
477:55 - loop and you need to keep this in mind
477:57 - okay now that you know the main parts of
478:00 - the loop
478:01 - how does it really work let's go through
478:03 - this and see how it's going to print i
478:05 - love c plus plus 10 times so when this
478:08 - code gets executed we're going to start
478:10 - with i equal to 0 because that's what we
478:12 - are initializing this value with
478:15 - after the incrementation part we're
478:18 - going to run the test
478:19 - and the test is going to say is i is 0
478:23 - less than 10 and that's going to be true
478:25 - so if the test turns out to be true
478:28 - we're going to jump into the loop body
478:30 - and if it's false we're going to jump to
478:32 - the end of the loop and execute whatever
478:36 - is after our loop this is how it works
478:39 - so if we jump in for the first time when
478:41 - i is 0 we're going to print i love c
478:44 - plus plus for the first time then after
478:46 - the body is executed we're going to
478:48 - execute the incrementation part
478:50 - this is going to make i equal to 1 then
478:53 - we're going to come back to the test
478:54 - we're going to say is 1 less than 10
478:57 - that's going to be true we're going to
478:59 - come in the body and print i love c plus
479:01 - plus for the second time after that the
479:04 - incrementation part is going to run
479:05 - we're going to have a 2 inside i here 2
479:08 - is less than 10 this is going to be true
479:11 - so we're going to follow him the body
479:12 - again and print i love c plus plus for
479:15 - the third time we're going to keep doing
479:17 - this until we hit nine for example if we
479:20 - increment and get a nine we're going to
479:22 - form the test and say is nine less than
479:25 - ten that's going to be true so we're
479:27 - going to fall in here and print i love c
479:30 - plus plus again
479:31 - and after that we're going to run the
479:33 - incrementation part again this time i is
479:36 - going to become 10 we're going to do the
479:38 - test 10 is not less than 10 so the test
479:42 - is going to fail
479:43 - and we're going to fall on the outside
479:46 - of the loop here and by that time we'll
479:48 - have printed i love c plus plus 10 times
479:52 - and this is really how a loop works for
479:54 - the first time we're going to run this
479:56 - initializer part here to initialize our
479:59 - iterator which is this value i
480:01 - and then after that we're going to run
480:03 - the test
480:04 - if the test is good if it's successful
480:06 - we're going to fall in the body we're
480:08 - going to execute whatever code is in the
480:09 - body and after that we're going to keep
480:11 - doing the cycle increment test the body
480:14 - increment test body
480:16 - increment test body until
480:19 - we hit a point where the test fails and
480:22 - if the test fails we're going to fall
480:24 - outside
480:26 - this for loop here we're going to
480:28 - execute whatever is after this closing
480:31 - curly brace and this is how a loop works
480:33 - i want you to go through this one more
480:35 - time by printing i love c plus plus and
480:38 - making sure that this is printed 10
480:41 - times
480:42 - and one thing you should have noticed
480:44 - now is that we use this test to control
480:47 - how many times the loop is going to
480:49 - start for example if we wanted it to run
480:51 - 20 times we would start from zero and
480:54 - and at 20. and you don't always have to
480:57 - start from zero you can really start
480:59 - from anywhere for example you can
481:01 - initialize i with a value like 30 and
481:04 - end when i is equal to 55. let's say
481:08 - that as an example you can really do
481:10 - anything the main important thing is to
481:13 - understand how a loop works one thing i
481:15 - want you to notice is that we are saying
481:18 - unsigned int here
481:20 - to declare our iterator
481:23 - iterators are a common thing in c plus
481:26 - plus code and they're not just used for
481:29 - loops like we are doing it here there is
481:31 - a type we use to do iterators and it
481:34 - makes our code much more readable and
481:36 - that's called size t
481:38 - this event is a representation of some
481:42 - unsigned and type in your c plus plus
481:45 - compiler this is going to be different
481:46 - from compiler to compiler but for
481:48 - example on my system this is eight bytes
481:52 - so it has quite a good range of values
481:55 - you can put in there if we use size t
481:57 - type to declare our i iterator here
482:00 - we're going to say something like this
482:02 - for size t i
482:04 - we're going to put our curly braces
482:05 - we're going to put a semicolon we're
482:07 - going to put our test and we're going to
482:09 - put our incrementation part and i think
482:12 - i really emphasize this but the
482:15 - parts of our loop inside this
482:17 - parenthesis are separated by semicolons
482:20 - like this so we have the iterator
482:23 - declaration we have a semicolon we have
482:25 - the test we have a semicolon and we put
482:28 - our incrementation part and then we go
482:30 - on and put our curlies and inside we can
482:33 - do whatever it is we want to do
482:35 - inside the loop so size t is something
482:37 - you're going to see a lot make sure you
482:39 - know what it means remember that it is a
482:42 - representation of an unsigned and type
482:45 - so it can only represent positive
482:47 - numbers and it is used to represent
482:50 - things like sizes in c plus plus thank
482:53 - the number of students in a classroom
482:56 - for example that can never be negative
482:58 - think about the number of seats in a car
483:00 - that's something that is always going to
483:02 - be positive and it won't make sense for
483:05 - that to be negative so for those kinds
483:08 - of things we can use size t to represent
483:11 - the size of those things and you're
483:13 - going to see how this works in a minute
483:15 - okay now that you have a pretty good
483:17 - idea about how a loop works and the main
483:20 - parts that make it up i want you to know
483:22 - that you can also do all kinds of crazy
483:24 - operations inside the body of your loop
483:27 - for example here we are printing out the
483:30 - current value of our iterator and we're
483:32 - going to print the double that we can do
483:35 - this we can also leave out the curly
483:37 - braces and this is only valid if we have
483:40 - one statement we want to run in the loop
483:43 - so this is going to print this message
483:45 - here five times because this loop is
483:47 - going from zero all the way to four it
483:49 - is going to stop when i stops being less
483:52 - than five and this is going to be five
483:54 - times if you go through this you're
483:56 - going to see that this is going to print
483:58 - five times you should also know that
484:00 - this iterator that we are declaring like
484:03 - this is going to be scoped inside the
484:06 - body of the loop so you can only use it
484:08 - inside these curly braces and if you try
484:11 - to use it outside for example here after
484:15 - the closing curly braces of the body of
484:17 - the loop you're going to get a compiler
484:19 - error again you can only use this
484:21 - variable i which is our iterator
484:24 - inside the curlies that mark the
484:27 - start and the end of our loop body if
484:30 - you want the iterator to be usable
484:32 - outside the scope of the for loop you
484:35 - can do something like this you can
484:37 - declare your iterator outside the loop
484:40 - and you can initialize that with
484:41 - whatever you want and then you can set
484:43 - up your loop like this you can say for j
484:46 - and put and your test and your
484:49 - incrementation part and inside do
484:51 - whatever it is you want to do in the
484:52 - body of the look if we do it like this
484:55 - then j is going to be usable outside of
484:58 - the loop and we're going to see its
485:00 - value if we print it out like this so
485:02 - this is also something you can do
485:04 - you can even go all crazy and leave out
485:08 - the
485:09 - declaration part if you happen to have
485:12 - the
485:13 - iterator declared outside so if you do
485:16 - something like this it is also going to
485:18 - work okay the last thing i want you to
485:20 - see before we head over to visual studio
485:22 - code and actually try this out
485:25 - is that it is a bad thing to hard code
485:27 - your values in for example you see here
485:29 - we are saying j less than 10
485:32 - this is really bad design because every
485:34 - time you need to change the number of
485:37 - times that your loop is going to run
485:39 - you're going to have to hunt for these
485:41 - loops and change these values and this
485:43 - may be in a lot of places in your code
485:45 - so a good thing to do is to put the
485:48 - value that controls how many times your
485:51 - loop is going to run in a variable like
485:53 - this we're going to store that value in
485:55 - this count variable
485:56 - notice that it is of size t because it
485:59 - is a representation of the size of
486:01 - things something we don't really want to
486:03 - be negative and we're going to use this
486:05 - in our test part of our for loop here
486:09 - instead of saying j less than 10 we're
486:11 - going to say j less than count and if we
486:14 - want to change this we have one point of
486:16 - control to go and change this value here
486:19 - and this is really good design you
486:20 - should do this okay we have talked a lot
486:23 - about loops it is time we headed over to
486:25 - visual studio code and actually tried
486:28 - these things out here we are in visual
486:30 - studio code the current project is for
486:33 - loop here we're going to grab the code
486:35 - from our template project
486:37 - and we're going to put that in place
486:40 - here
486:41 - and we're going to open this in visual
486:43 - studio code so let's do that pretty fast
486:46 - for loop that's the current project we
486:48 - selected and we opened this in visual
486:51 - studio code
486:52 - we're going to open up our main cpp file
486:55 - which is going to show up here and we're
486:58 - going to remove things we don't need
487:00 - here
487:00 - so let's remove that okay the first
487:03 - thing i want you to do is the bad way to
487:05 - do things
487:06 - again if we want to print i love c plus
487:09 - plus 10 times we can do it like this and
487:12 - if we run the program it's going to work
487:14 - but this is really bad design because
487:16 - you would have to copy and paste this
487:18 - for example a thousand times or even a
487:20 - hundred thousand of times and that's
487:22 - really bad so if we bring up our
487:24 - terminal
487:26 - and build with gcc like we always do
487:31 - the build is going to go through you see
487:34 - it's successful we're going to clear and
487:36 - we're going to run rooster and it's
487:38 - going to say lfc plus plus 10 times if
487:40 - you count this it's going to be 10 times
487:43 - because that's what we're doing here but
487:45 - this is really bad design you don't want
487:46 - to do something like this so we're going
487:49 - to comment this out
487:50 - and do this better using a for loop
487:53 - let's say that this is the bad way and
487:55 - we're going to use for loop which is the
487:57 - good way sorry so we're going to start
487:59 - by declaring our iterator so we're going
488:01 - to say for we're going to say size t
488:04 - let's use unsigned end to show you that
488:06 - you can use that and we're going to say
488:08 - i and we're going to initialize this
488:10 - with a zero
488:12 - and this is going to be the declaration
488:14 - of our iterator this is the first part
488:18 - we have in this parenthesis here we're
488:20 - going to put in a semicolon and put in
488:22 - the test we want the
488:25 - loop to run ten times so it's going to
488:27 - run from zero to nine we're going to
488:29 - stop when i stops being
488:31 - less than ten this is one way you can
488:34 - understand this after we have our test
488:36 - and we're going to put the
488:38 - incrementation part which is going to
488:40 - change the iterator to make the loop
488:42 - move forward and we're going to do that
488:45 - by incrementing our iterator after that
488:48 - we're going to put a pair of curly
488:50 - braces not angle brackets and we're
488:52 - going to fall inside the body of the
488:55 - loop this block here delimitated by the
488:57 - curly braces is the body of the loop and
489:00 - inside here we're going to put whatever
489:02 - we want the loop to run so we can go
489:04 - down here and say i love c plus plus 10
489:07 - times let's say that but before we do
489:10 - that let's say i so that we know the
489:12 - current iteration where we are at
489:15 - and we're going to put a column and say
489:17 - i love c plus plus this is going to be
489:20 - better to follow in the terminal i guess
489:23 - and we're going to put in our
489:25 - new line character
489:28 - move to the new line
489:30 - and we need to put our stream output
489:33 - operator here for this to make sense to
489:36 - the compiler and this is our loop now if
489:38 - we run it we're going to see exactly the
489:40 - same thing like this but we're going to
489:42 - have these iterators prepended to the
489:45 - message so that it becomes easy to
489:47 - follow this and again how this is going
489:50 - to work we are going to run our code to
489:53 - declare and initialize the iterator
489:56 - after that we're going to do the test we
489:58 - are going to start with i zero so zero
490:01 - is less than ten this is going to
490:03 - succeed we are going to fall in the body
490:05 - here
490:06 - and after that we're going to
490:08 - print sddc out i love c plus plus and
490:11 - this is going to be zero we're going to
490:13 - increment i
490:15 - and we're going to do the test again
490:17 - we're going to have to do is one less
490:20 - than 10 the test is going to be
490:21 - successful so we're going to fall in
490:23 - here and we're going to print a one
490:26 - and we're going to run the
490:27 - incrementation part again we're going to
490:29 - run the test and we're going to keep
490:31 - doing this until we hit a point for
490:32 - example when we increment this to be a
490:35 - nine
490:36 - and after that we're going to run the
490:37 - test we're going to say is 9 less than
490:39 - 10 the test is going to be successful so
490:42 - we're going to follow in here and we're
490:43 - going to print nine
490:46 - and after that we're going to increment
490:48 - again we're going to run the
490:49 - incrementation part and we're going to
490:50 - make i 10 if we run the test we're going
490:53 - to say is 10 less than 10 the test here
490:56 - is going to fail we're going to stop
490:58 - running the loop all together and we're
491:00 - going to fall on the outside of the loop
491:02 - and say loop done let's say that so that
491:05 - we can see this on the terminal and this
491:08 - is going to run and print i love c plus
491:10 - plus 10 times and we expect i to go from
491:13 - zero all the way to nine
491:16 - try to run this in your mind
491:18 - take a piece of paper try to
491:20 - print this as you fall into the body of
491:22 - the loop you're going to see that's
491:24 - exactly what is happening here so what
491:26 - we're going to do we're going to boil
491:28 - this again so we're going to run the
491:31 - task to
491:33 - work with gcc
491:35 - the world is good we're going to go down
491:37 - and run this we're going to clear
491:40 - and run rooster
491:42 - and you're going to see that we have
491:43 - zero i love c plus plus all the way to
491:45 - nine i love c plus plus our loop is
491:48 - working exactly the way we want okay so
491:51 - this is the first step we are able to
491:53 - run our code a lot of times without
491:55 - really having to manually do things like
491:57 - this and the benefit of this is that if
492:00 - we want this to run for example 100
492:02 - times all we have to do is change our
492:05 - test
492:06 - to go until i
492:08 - is equal to 100 and we're going to stop
492:11 - when i stops being
492:13 - less than 100 and if we run this we're
492:15 - going to see
492:17 - the message from 0 all the way to 99 and
492:20 - this is pretty cool the torso is going
492:22 - to be 100 times so let's weld again to
492:25 - show you how cold this is
492:27 - we're going to run this task to weld
492:29 - with gcc again
492:31 - and we're going to clear
492:33 - run rooster prepare to be amazed run and
492:37 - it's going to run all the way to 99 we
492:39 - can change this to even 1 000 or even 10
492:42 - 000 why not we're going to weld again
492:45 - and we're going to be successful
492:48 - and we're going to clear
492:50 - and run rooster and this is going to go
492:52 - all the way to 10 000 times we're going
492:54 - to wait for this to get there
492:56 - now 3 000 4 000 5000 6000 7000 8000
493:03 - ten thousand it's going to go all the
493:05 - way to nine thousand nine hundred ninety
493:07 - nine and it is going to stop and the
493:09 - total of times the loop run
493:12 - was from zero all the way to
493:15 - this storping number here okay now we
493:18 - can see that our loop is really working
493:20 - fine we don't have to do these hddc out
493:22 - statements a crazy amount of times okay
493:25 - and the benefit again is that
493:28 - regardless of the number of times the
493:31 - code here is going to run our loop is
493:33 - going to stay relatively the same it's
493:36 - just going to be one two three four
493:38 - lines of code and this is really cool
493:40 - okay so i think this now makes it very
493:43 - clear how loops work so we're going to
493:45 - comment this out and show you another
493:47 - thing and we're going to show you that
493:49 - you can use size t to actually
493:51 - denote the type of your iterator
493:54 - and it is easy to do that so we're going
493:57 - to say use size t and for us to be able
494:00 - to see all this here let's hit this file
494:02 - icon here to close this pane and we're
494:05 - going to have a better chance of seeing
494:06 - our code here so what we want to do
494:09 - we're going to declare a group we're
494:11 - going to save for we're not going to say
494:12 - our design and we're going to say size t
494:15 - and this is going to be the type of our
494:18 - iterator we're going to say i we're
494:20 - going to initialize this with a zero
494:22 - and we're going to put a semicolon like
494:24 - we just did we're going to put in the
494:26 - end test we're going to put in the test
494:29 - so we're going to say i less than 10
494:32 - no problem with us
494:34 - and we are going to increment to put in
494:36 - place our incrementation part we're
494:39 - going to fall in the loop we're going to
494:41 - say stdc out this is the code we want to
494:43 - run so we're going to put in our
494:45 - coverage value for the iterator and
494:48 - we're going to say i love c plus plus
494:50 - again and we're going to put in our new
494:52 - line character and if we build and run
494:55 - this it's going to work and run the same
494:57 - so let's say loop done here
494:59 - so that we know when it's done and we're
495:01 - going to weld and run we're going to
495:03 - world with gcc
495:05 - the world is going to be good
495:07 - and what we're going to do we're going
495:09 - to clear
495:10 - and run rooster and this is going to say
495:13 - i love c plus plus 10 times from 0 to 9.
495:18 - again the message here is that you can
495:20 - use size t to represent the type of your
495:23 - iterators and this is the type that is
495:25 - even used in the c plus plus standard
495:27 - library so this is going to be something
495:30 - people expect from your code if you are
495:32 - representing sizes in code that should
495:35 - be compliant with the c plus plus
495:37 - standard library nothing stops you from
495:40 - using unsigned it like we do here but
495:42 - we're just going to follow the
495:43 - convention from the c plus plus standard
495:46 - library and use this type here to
495:48 - represent all sizes
495:51 - and some of you might be wondering how
495:53 - big is this thing we have the tools to
495:55 - know
495:56 - how big it is so let's do that pretty
495:58 - fast so we're going to go down here
496:01 - and say sddc out and we're going to say
496:03 - size of
496:05 - size t and we can print this out and
496:08 - let's say what we are doing here so that
496:10 - it is easy to
496:11 - use this code as the reference and if we
496:14 - print this out we're going to see
496:17 - the size of this thing on the system
496:19 - where this code here is going to run
496:21 - so we're going to
496:23 - build with gcc again
496:26 - the bolt is going to be good we're going
496:28 - to go here and clear and run rooster
496:31 - you're going to see that it is eight
496:33 - bytes on my system so you're going to
496:35 - have quite a huge range of numbers you
496:37 - can put in here because this is going to
496:39 - only be positive
496:41 - okay if you try to put in a negative
496:43 - number you're going to get an underflow
496:46 - and we have learned about overflow and
496:48 - underfloor in the previous chapter
496:51 - okay so let's comment this out and keep
496:53 - learning more things about for loops
496:56 - okay the next thing i really want you to
496:58 - focus on and learn is the scope of the
497:01 - iterator and we're going to grab our
497:03 - code again here
497:05 - so that we can use this
497:07 - as a learning tool so we're going to go
497:09 - down here and put that in
497:12 - and what we're going to have let's move
497:15 - this a little bit to the right i think
497:17 - we can do something like this i am going
497:19 - to select the entire thing here and hit
497:22 - tab and it is going to be aligned with
497:24 - whatever we have here
497:26 - okay so we have our loop it is going to
497:28 - run 10 times it's going to print i love
497:30 - c plus from 0
497:32 - to 9
497:34 - but
497:34 - what is the scope of this i think here
497:37 - and the fact is it is scoped inside this
497:40 - loop here you might have guessed that if
497:43 - you try to use it outside the loop
497:46 - you're going to get a compiler arrow
497:47 - because it is only usable inside the
497:50 - body of the you can also use it inside
497:53 - the control part of the loop here but
497:55 - you can't use it outside the loop so if
497:58 - you try to print i here for example
498:00 - you're going to get a compiler error so
498:02 - let's try and do that and show you how
498:04 - wrong this can be
498:06 - so if we try to print i here let's say i
498:10 - to make it clear what we want to print
498:12 - if we try to do this we're going to get
498:14 - a compiler error because i is not in
498:17 - scope it is only in scope inside these
498:20 - curly braces that show the body part of
498:23 - our loop okay visual studio code is
498:25 - showing the problem here it's saying
498:27 - eyes undefined here so you shouldn't
498:29 - really do this but if we move on and
498:32 - ignore the message from visual studio
498:34 - code and compile
498:36 - we're going to get a compiler error and
498:37 - it's going to say
498:39 - i don't know what you're doing here i
498:41 - was not declared in this scope where you
498:44 - are using it and i think it's even going
498:46 - to give me a line a number it's going to
498:48 - tell me 46 that's where you are doing
498:51 - something wrong and if we go in our code
498:53 - we're going to see that this is the line
498:55 - where we are making the mistake so i is
498:58 - not in scope here we're going to comment
499:00 - this out and say compiler error i is not
499:04 - in scope that's what you're going to get
499:06 - if you try to do this and the main
499:08 - message is that if you declare your loop
499:11 - like this ah is only going to be scoped
499:14 - in the body of the loop and that's the
499:16 - only place where you can mention its
499:18 - name and use it if we comment this out
499:20 - and world again the compiler error is
499:23 - going to go away you're going to see
499:25 - that the world is good let's clear so
499:27 - that our output here is good
499:30 - we're going to build again and show you
499:31 - that the build is good and uh this is
499:34 - really cool both finished successfully
499:36 - okay this is one way we can set up our
499:39 - loop but there is a way we can make our
499:42 - iterator usable outside the body of the
499:45 - loop and we're going to show you how you
499:46 - can do that next so let's comment this
499:49 - out and go down again
499:51 - and we're going to grab the code because
499:53 - we don't want to type all this again and
499:55 - we're going to say iterator declared
499:58 - outside the loop we're going to go down
500:01 - and put in our code
500:04 - and we're going to align this nicely
500:07 - and we're going to take the iterator and
500:10 - declare it on the outside of the loop so
500:13 - we're going to say size t
500:15 - and we're going to say i and initialize
500:17 - this to 0
500:19 - and we're going to say this very clearly
500:23 - iterator
500:25 - defined
500:28 - outside
500:30 - and we're going to say in our
500:33 - [Music]
500:34 - declaration part of the iterator we're
500:36 - going to just say i and this is going to
500:38 - work pretty fine if we build this you're
500:41 - going to see that the world is good and
500:43 - if we run this it's going to do the same
500:45 - thing it's been doing it's going to
500:47 - print i love c plus plus 10 times and if
500:50 - you want i usable on the outside of the
500:52 - loop now you can use it we can grab the
500:55 - code here that was failing
500:57 - in the last run of our code and put that
501:01 - out here and we're going to align this a
501:03 - little bit
501:05 - and if we compile this the book is going
501:07 - to be good
501:08 - and if we try to run rooster we're going
501:11 - to see i love c plus 10 times we're
501:13 - going to say loop done and we're going
501:15 - to print the value of i and you see that
501:18 - if we do things like this i is going to
501:20 - be usable on the outside of the loop
501:23 - body
501:23 - and sometimes these may come in handy
501:26 - depending on the logic of the
501:28 - application that you are designing just
501:30 - know that this is something you can do
501:33 - in your loops
501:34 - okay you can go even crazier and leave
501:38 - out this iterator declaration part in
501:41 - your loop all together so you can remove
501:44 - that and we're going to show you how you
501:45 - can do that in a minute so let's comment
501:47 - this out i don't want to remove code
501:49 - because i want you to have this as a
501:51 - reference if you need to look at this
501:53 - later so we're going to say leave out
501:56 - and what you can do is grab the code we
501:59 - had before i'm going to grab it
502:02 - and we're going to paste that in here
502:05 - and what we're going to do is take out
502:06 - this eye this can work and you may see
502:08 - code like this out there in the wild so
502:12 - we're going to run this task to build
502:14 - with gcc the world is going to be good
502:17 - and we're going to clear and run rooster
502:19 - and it's going to do exactly the same
502:21 - thing so this is one way you can set up
502:23 - your loops okay the last thing we need
502:25 - to see about loops is that
502:28 - this test here is using a hard coded
502:30 - value and if we needed to change this
502:33 - loop to run for example for a thousand
502:35 - times we would need to manually hunt for
502:38 - this line of code change this and this
502:40 - is really not good design so what is
502:43 - recommended is to store this value in a
502:45 - variable and test against that variable
502:48 - name instead
502:50 - let's comment this out and show you that
502:52 - so we're going to
502:54 - comment this out
502:55 - and go down and copy this entire thing
502:58 - i don't think i want to do my loops like
503:00 - this because this is really unintuitive
503:02 - most times so i am going to declare my
503:06 - iterator inside and i'm going to copy
503:08 - the code that does that here we're going
503:10 - to go down
503:12 - and say
503:13 - don't hardcord values okay we're going
503:16 - to say that it's really bad
503:18 - and we're going to go down and show you
503:20 - a better way to do things and again
503:22 - right now we are hard coding in this
503:25 - value but we can say const
503:28 - size t
503:30 - and we can call this value count for
503:32 - example and we can initialize it with
503:34 - whatever we want in this case we want to
503:36 - control our loop to run 10 times so
503:39 - we're going to put in a 10 and instead
503:42 - of hard coding and this 10 we're going
503:44 - to say count
503:46 - okay
503:47 - and if we build and run it the loop is
503:49 - going to do exactly the same thing it's
503:51 - going to print i love c plus plus 10
503:53 - times
503:54 - so let's do that
503:56 - and run rooster
503:58 - it's going to do the same thing but now
504:00 - we have one point of control if we want
504:02 - this to run for let's say 100 times we
504:06 - can change the count value to 100 times
504:09 - and if we both again that's how many
504:11 - times the loop is going to run and this
504:13 - is much cleaner so i do recommend you
504:15 - store
504:16 - the values you use in your loops in
504:18 - variables like this and it's going to
504:20 - make your code look better
504:22 - so it's going to run 100 times and this
504:25 - is exactly what we want
504:27 - this is really all we set out to do in
504:29 - this lecture i hope you found it
504:30 - interesting
504:31 - i am sorry that this lecture turned out
504:34 - lengthy because we had a lot of things
504:36 - to talk about but now i hope you really
504:39 - know a lot of things about ways you can
504:41 - use your for loops to make them do
504:44 - things and again many loops that we're
504:46 - going to use in our c plus plus code are
504:48 - going to have five parts we're going to
504:50 - have an iterator which is going to be a
504:52 - variable we use to manipulate how a loop
504:55 - moves forward and does things the
504:57 - starting point is going to be where the
504:59 - loop is going to start we're going to
505:00 - have a test in place which is going to
505:02 - control when the loop ends and we're
505:04 - going to have the end point encoded in
505:06 - that test we're going to have the
505:08 - incrementation part of the loop which is
505:10 - going to control how our loop moves
505:12 - forward and we are going to set up a
505:14 - pair of curly braces that are going to
505:18 - contain the body of our loop in this
505:20 - lecture we're going to learn about while
505:22 - loops and this is another construct we
505:25 - have in the c plus plus programming
505:27 - language to allow us to do repetitive
505:29 - tasks the syntax for a while loop looks
505:32 - like this we have five parts in our loop
505:35 - we have the iterator the starting point
505:37 - the test the incrementation and the loop
505:40 - body it's just going to be set up
505:41 - differently for while loops the iterator
505:45 - is declared on the outside and you see
505:47 - here we have unsigned in i which is
505:49 - exactly the same type of iterator we've
505:52 - used in the last lecture but know that
505:54 - you can also use size t here i am just
505:56 - using unsigned and for this case after
505:59 - you have your iterator declared you're
506:02 - going to fall to this part here and say
506:04 - while open a set of parentheses and
506:08 - inside you're going to put in your test
506:10 - after that you're going to open a pair
506:12 - of curly braces and design them you're
506:15 - going to put the body of your loop
506:17 - and you're going to do whatever it is
506:19 - you want to do in the loop in there and
506:22 - after your code to do whatever it is you
506:24 - want to do is executed you're going to
506:26 - put in your incrementation part after
506:29 - you code and that's what we have here
506:32 - and this is the setup we're going to be
506:33 - using for our while loops again
506:37 - we have the
506:38 - iterator declared on the outside and we
506:41 - can initialize it with whatever it is we
506:43 - want to
506:44 - start with
506:46 - then we're going to put in our test it's
506:48 - going to be within this parenthesis and
506:50 - after that we're going to set up a pair
506:52 - of curly braces and inside them we're
506:54 - going to put whatever code we want to
506:56 - run in the loop and then we're going to
506:58 - follow that with our incrementation part
507:01 - and if we try to run this we're going to
507:03 - run this line we're going to declare the
507:05 - iterator i and it's going to start with
507:07 - zero so the test is going to run and 0
507:10 - is less than 10
507:12 - and we're going to succeed and we're
507:14 - going to run the body here we're going
507:16 - to say i love c plus plus and after that
507:18 - we're going to run the incrementation
507:20 - part i is going to become one we're
507:22 - going to run the test again so one is
507:25 - less than 10 we're going to succeed
507:27 - we're going to fall in print i love c
507:29 - plus plus we're going to increment again
507:31 - then we're going to have a 2 in i here
507:34 - we're going to run the test again we're
507:36 - going to say is 2 less than 10 that's
507:38 - going to be true so we're going to be
507:40 - successful we're going to fall in the
507:42 - body of the loop we're going to
507:44 - increment and get a three we're going to
507:46 - test against our three value three is
507:48 - less than ten we're going to succeed
507:50 - we're going to print i love c plus plus
507:53 - we're going to increment again we're
507:55 - going to test again and we're going to
507:57 - say is for less than count or 10 we're
508:01 - going to be successful and we're going
508:02 - to keep running until we increment and
508:04 - get a 9. once we get a 9 we're going to
508:07 - run the test again and we're going to
508:09 - say is 9 less than 10 that's going to be
508:12 - successful so we're going to fall inside
508:14 - print i love c plus plus we're going to
508:16 - increment and get a 10
508:18 - and if we run the test again i'm going
508:20 - to say is 10 less than 10 that's going
508:23 - to fail and we are going to fall on the
508:26 - outside of the loop and we're going to
508:27 - run whatever code is on the outside here
508:30 - this is really how a while loop works
508:32 - and i hope you can see the similarities
508:34 - between the for loop we have seen it is
508:36 - really the same thing we just have
508:38 - different syntaxes to do these things
508:41 - okay if you look at these things we
508:42 - already have the same pieces of
508:44 - information it is just different
508:46 - syntaxes that c plus plus provides to do
508:48 - the same things and sometimes you're
508:51 - going to find it convenient to use while
508:53 - loops and sometimes you're going to find
508:54 - it convenient to use for loops and
508:57 - you're going to have to decide what
508:59 - works better for whatever it is you are
509:01 - working on for now we're going to head
509:03 - over to visual studio code and try this
509:05 - out okay here we are in visual studio
509:08 - code the current project is while loop
509:10 - we're going to grab our template files
509:13 - and we're going to go in our project and
509:15 - put those in
509:16 - and we're going to open this in visual
509:18 - studio code so let's do that
509:21 - we're going to open the folder
509:24 - and we're going to work on while loop
509:26 - here we are going to open our main cpp
509:28 - file pretty quick and we're going to get
509:30 - rid of this and what we're going to do
509:33 - is remove what we don't need and again
509:35 - we're going to show you the bad way to
509:36 - do things you don't really want to do
509:38 - this manually we want to print i love c
509:40 - plus plus 10 times
509:42 - so
509:43 - we're going to build let's bring up a
509:45 - new terminal so that we can
509:47 - use this when we run thanks and we are
509:49 - going to world with gcc let's do that
509:52 - pretty quick the world is good
509:55 - so we can clear and run rooster and
509:57 - we're going to have i love c plus
509:59 - printed out 10 times so what we can do
510:02 - is comment this out and use a while loop
510:05 - like we want to do in this lecture here
510:08 - and as we have seen with the slides
510:11 - the first thing we need to do is declare
510:13 - our iterator on the outside so we're
510:15 - going to say size ti we're going to
510:17 - initialize this with zero
510:19 - and that's going to be our iterator
510:21 - declaration and we're going to say while
510:24 - i is less than the value where we want
510:26 - to stop and again we don't want to hard
510:28 - code these values and so what we're
510:30 - going to say is really
510:32 - const size t and we're going to call
510:35 - this count and make it uppercase this is
510:38 - a convention we use to declare constants
510:40 - in c plus plus but you don't have to
510:42 - make them uppercase it is just a
510:43 - convention that is going to make your
510:45 - code easier to read for other people so
510:48 - we're going to
510:50 - put a 10 in here because we want our
510:52 - loop to run 10 times
510:54 - and we're going to say y i
510:56 - is less than count and we're going to
510:58 - set up a pair of curly braces and they
511:02 - are going to delimitate
511:03 - the start and the end of the body of a
511:07 - loop here and inside we're going to put
511:09 - in whatever code we want the loop to run
511:11 - multiple times and the code is now very
511:14 - familiar we're going to say sddc out
511:17 - and we're going to print the
511:19 - current iteration and we're going to say
511:22 - i love c plus plus sdd endl for our new
511:25 - line character and after that we will
511:28 - need to put in our own incrementation
511:30 - part if you forget that you're going to
511:32 - get something really bad happen we're
511:34 - really going to look at that later in
511:37 - the chapter but for now remember to put
511:40 - the incrementation part and we're going
511:42 - to say plus plus i this is really easy
511:45 - and we're going to say that this is the
511:47 - test
511:49 - and this is going to do what we want but
511:51 - let's go down here and say that loop is
511:54 - done when it is done so we're going to
511:56 - say loop done
511:59 - and we're going to say stdendya
512:03 - and before we run this we're going to go
512:05 - through it and see how it is going to
512:07 - work so let's click on this file icon
512:10 - here to close this pane so that we have
512:12 - some breathing room i am going to open a
512:15 - notepad file we're going to use to see
512:17 - these things really happen
512:20 - when this loop runs we're going to
512:22 - initialize the iterator here what we're
512:25 - going to do is put in a 0 and we are
512:27 - going to run the test to see if 0 is
512:29 - less than 10 and the test is going to be
512:31 - successful so we are going to fall in
512:34 - here and say
512:35 - 0 i love c plus plus so let's say that
512:38 - here to make this super clear inside the
512:41 - loop we're going to print this message
512:42 - zero i love c plus plus and after we
512:45 - execute this line we're going to
512:47 - increment i is going to become one we're
512:49 - going to go up again and run the test
512:51 - and we're going to say is 1
512:54 - less than count or is 1 less than 10.
512:57 - the test is going to be successful we're
512:59 - going to run inside the loop and we're
513:01 - going to print 1 i love c plus plus
513:03 - that's what we're going to do here so
513:05 - let's do that
513:07 - and after we do that we're going to run
513:08 - our incrementation part again
513:11 - i is going to become two we are going to
513:13 - run the test we're going to say is 2
513:15 - less than 10 that's going to be true of
513:17 - course and we're going to fall in the
513:19 - body again and say two i love c plus
513:22 - plus
513:23 - so let's say that
513:25 - we're going to increment and we're going
513:27 - to get a three we're going to run the
513:28 - test again the test is going to be
513:30 - successful because three is less than
513:32 - ten we are going to fall in here and say
513:35 - three i love c plus plus okay so we can
513:38 - really follow this
513:40 - and we are going to increment to get a
513:42 - four and the test is going to say is
513:44 - four less than ten that's going to be
513:47 - true so we're going to succeed and
513:48 - following the body again and we're going
513:50 - to say 4 i love z plus blocks
513:53 - we're going to keep doing this and we're
513:55 - going to increment again we're going to
513:56 - get a 5. the test is going to run again
513:59 - we're going to say is 5 less than 10
514:01 - that's going to be true of course and
514:03 - we're going to run the code to print
514:05 - five i love c plus plus
514:08 - we're going to increment again to get a
514:10 - six
514:11 - we're going to run the test we're going
514:13 - to say is 6 less than 10 that's going to
514:16 - be true of course again and we're going
514:18 - to print sets i love c plus plus and
514:21 - we're going to increment to get a 7
514:23 - we're going to run the test our iterator
514:25 - we're going to say is 7 less than count
514:28 - that's going to be true we're going to
514:30 - print the message again and say seven i
514:33 - love c plus plus and we're going to
514:35 - increment again to get an eight we're
514:37 - going to say is eight less than and
514:39 - count
514:40 - that's going to be true we're going to
514:41 - fall in the body and say eight i love c
514:44 - plus plus we're going to increment to
514:47 - get a nine
514:48 - we're going to run the test against our
514:50 - nine of course nine is less than ten so
514:54 - that's going to be true we're going to
514:55 - fall inside and we're going to say nine
514:58 - i love c plus plus
515:00 - and after that we're going to increment
515:02 - again and we're going to get a 10.
515:04 - now if we run the test we're going to
515:06 - say is 10 less than 10 and that's going
515:09 - to be false because 10 is not less than
515:12 - 10 and if the test here fails we're not
515:15 - going to fall in the body of the loop
515:17 - control is going to fall at the end of
515:20 - the loop body and we're going to print
515:22 - loop done that's what we're going to say
515:24 - here we're going to say loop
515:26 - done and our loop will have run 10 times
515:31 - by the time we print this loop down
515:33 - message here if you count here you see
515:35 - that the loop is going to run 10 times
515:37 - and it is going to say i love c plus
515:39 - plus 10 times which is really what we
515:41 - want okay i really had to show you this
515:43 - manually so that you can really see what
515:46 - is happening but now we can weld and run
515:48 - this and let the computer do the heavy
515:50 - duty of running this and showing us all
515:53 - these messages
515:54 - so the build is going to be successful
515:56 - of course
515:57 - we're going to run rooster and it's
515:59 - going to exactly show the same thing we
516:01 - just came up in our trusty notepad file
516:05 - here you see it is the same thing but
516:08 - the beauty is that we don't have to do
516:10 - all these crazy computations again what
516:12 - we can do is we can even change the
516:15 - count to 100 so it is going to run for
516:17 - 100 times
516:19 - that's pretty cool
516:21 - so we can
516:22 - clear and run rooster and is going to do
516:25 - that 100 times and that's pretty fast
516:28 - for computers
516:30 - this is really all we had to share with
516:32 - you in this lecture the main thing is to
516:35 - learn about the syntax of a while loop
516:37 - and again notice that we have these five
516:40 - parts that make up our loop we have an
516:42 - iterator we have the starting point we
516:44 - have a test we have the incrementation
516:46 - part and we have the loop body it is
516:49 - just set up differently with a while
516:52 - loop like we can see here in this
516:54 - lecture we're going to learn about do
516:56 - while loops and this is yet another
516:58 - construct we have in c plus plus to do
517:01 - repetitive tasks
517:03 - let's look at the syntax here we have
517:05 - our declaration of the iterator on the
517:08 - outside and after that you're going to
517:10 - say do you're going to put a pair of
517:13 - curly braces like this you're going to
517:15 - put whatever code it is you want to run
517:18 - inside the loop and then you're going to
517:20 - do your incrementation and after the
517:22 - closing curly brace you're going to say
517:25 - while and you're going to put in your
517:27 - text this is really the structure again
517:29 - notice that we have those five parts and
517:32 - this is the
517:33 - declaration of our iterator and we're
517:36 - going to initialize this in place for
517:38 - example if we want to do that
517:40 - after that we're going to
517:42 - fall in the body of the loop
517:44 - and after that we're going to do the
517:46 - incrementation after we run the code it
517:48 - is we want to run in the body of the
517:50 - loop and then we're going to do the test
517:53 - later and the special thing about a do
517:56 - while loop is that it is going to run
518:00 - first and then you do the test last
518:03 - this is really something you need to be
518:05 - careful about make sure that when it
518:07 - runs it is doing whatever it is you want
518:09 - to do because the test is going to run
518:12 - after your code has actually run and you
518:15 - can tweak this to do whatever it is we
518:17 - want it to do as we are going to see
518:19 - when we hit visual studio code in a
518:21 - minute okay again one thing you need to
518:24 - keep in mind is that the do while loop
518:26 - is going to run the body
518:28 - of the loop and then do the check or the
518:31 - test and that may come in handy in some
518:34 - of the applications you'll be doing
518:36 - within your career as a c plus plus
518:38 - developer okay this is really the syntax
518:40 - we're going to be using we're going to
518:42 - head over to visual studio code and play
518:44 - with us okay here we are in our working
518:48 - folder the current project is going to
518:50 - be do while loop
518:52 - we're going to grab the template files
518:54 - pretty fast and we are going to put them
518:57 - in our current project let's open this
519:00 - up and put them in there
519:02 - and we are going to open this in visual
519:04 - studio code do while loop is our project
519:07 - we're going to open this and the main
519:09 - cpp is opened up so let's remove
519:12 - whatever it is we don't need and we are
519:14 - going to show you the bad way to do
519:16 - things the bad way to do things is
519:19 - typing your code to do things manually
519:22 - if you wanted them to be done multiple
519:24 - times and this is something bad if we
519:26 - bought this and run we're going to go
519:28 - down and run this clear not
519:30 - that's g brush we're going to run
519:32 - rooster
519:34 - and we're going to get i love c plus
519:35 - plus 10 times and you don't want to do
519:37 - something like this what we want in this
519:40 - lecture is to use
519:42 - do while loops to solve this problem
519:45 - we're going to comment this out because
519:46 - it is really bad
519:49 - and we're going to go down and set up
519:51 - our do while loop the first thing we
519:53 - need to do is to set up the count
519:56 - because we want to store this in some
519:57 - variables so we're going to say const
519:59 - and
520:00 - count
520:01 - and we're going to put in our value
520:03 - let's put in a 10
520:05 - not 190 we're going to say 10 times
520:08 - and we're going to set up our iterator
520:11 - we're going to say size t
520:14 - and we're going to say i and initialize
520:16 - this with our starting point we're going
520:18 - to start from zero
520:20 - and what we're going to do is say do
520:24 - and put a pair of curly braces
520:27 - and inside this pair of curly braces
520:30 - we're going to put whatever it is we
520:31 - want to do
520:33 - multiple times so we want to print i
520:35 - love c plus plus so that's what we're
520:37 - going to say we're going to
520:38 - put in the current iteration
520:41 - and we're going to put a column and say
520:43 - i love c plus plus
520:46 - and then we're going to jump to the new
520:48 - line with stdendl
520:51 - and after that we don't want to forget
520:53 - our incrementation part so we're going
520:55 - to say plus plus i
520:57 - and this is going to be
520:59 - the part that moves our iterator to the
521:02 - next step this is going to be the
521:04 - incrementation and this is going to be
521:07 - the iterator
521:08 - declaration
521:11 - and after the closing brace we need to
521:14 - say our test
521:16 - so we're going to say while and we're
521:18 - going to put in our test here and we
521:19 - want to keep doing this as long as i is
521:22 - less than count of course
521:24 - and we're going to put in our closing
521:27 - semicolon here
521:28 - now this code is going to run 10 times
521:31 - but let's go through how it's going to
521:34 - run so that you can really see
521:36 - everything
521:37 - that is happening here okay so when this
521:40 - code here is run we're going to hit the
521:42 - initialization line here we're going to
521:44 - declare i and we're going to put in a 0.
521:48 - we're going to say do and inside we're
521:50 - going to print whatever we have in i and
521:52 - say i love c plus plus so we're going to
521:55 - say 0 because i is 0 at this point and
521:58 - we're going to say i love c plus plus
522:02 - and after that we're going to increment
522:04 - i is going to become one
522:07 - and we are going to do the test at this
522:09 - time
522:10 - we're going to say is one less than ten
522:12 - that's going to be successful so we're
522:14 - going to run the body again
522:17 - and we're going to say 1 i love c plus
522:20 - let's copy this and print this again so
522:22 - that we don't have to type this all the
522:24 - time we're going to say 1
522:26 - i love c plus and after that we're going
522:28 - to run the incrementation part again so
522:31 - we're going to get a 2 inside i we're
522:33 - going to test and say is 2 less than 10
522:36 - that's going to be true so we're going
522:38 - to run the body again and print 2 i love
522:41 - c plus plus
522:43 - and we're going to increment to get a
522:45 - three in there
522:46 - we're going to run the test against our
522:49 - three is three less than ten that's
522:51 - going to be true so we're going to fall
522:52 - in the body again and print three
522:55 - i love c plus plus let's do that we're
522:58 - going to do the incrementation we're
522:59 - going to get a 4 inside this i variable
523:02 - here we're going to run the test we're
523:04 - going to say is 4 less than 10 that's
523:06 - going to be true of course we're going
523:08 - to say four i love c plus plus when we
523:11 - fall in the body again
523:13 - we're going to do the implementation and
523:14 - get a five we're going to do the test
523:17 - it's five less than ten that's going to
523:19 - be true so we're going to fall in the
523:21 - body again and say five i love c plus
523:24 - plus
523:25 - let's say that
523:27 - we're going to increment again
523:30 - we're going to get a six the test is
523:31 - going to run and we're going to say is
523:34 - six less than ten
523:36 - that's going to be true again then the
523:38 - body is going to execute and say
523:42 - 6 i love c plus plus we're going to do
523:44 - the incrementation and get a 7. we're
523:47 - going to run the test against our 7 so
523:49 - we're going to say is 7 less than 10
523:51 - that's going to be true
523:53 - we are going to fall in the body again
523:55 - and say 7 i love c plus plus
523:58 - we are going to do the incrementation we
524:00 - are going to get 8 we're going to say is
524:03 - 8 less than 10 that's going to be true
524:06 - we are going to fall in the body again
524:08 - and say 8 i love c plus plus we're going
524:10 - to do the incrementation we're going to
524:12 - get a 9 and we're going to run the test
524:14 - we're going to say is 9 less than 10
524:16 - that's going to be true so we're going
524:18 - to go inside and say 9 i love c plus
524:21 - plus
524:23 - and we're going to do the incrementation
524:25 - again now we're going to get a 10 and
524:27 - the test is going to say is 10 less than
524:30 - 10
524:31 - and that's going to be false now the
524:33 - test is going to fail
524:35 - and we're going to fall after the while
524:38 - loop here so if we had a statement here
524:40 - that said stdc out loop done we would
524:44 - print that we would go down here and say
524:46 - loop done
524:48 - and this is what we're going to get if
524:50 - we run this program and again i
524:52 - encourage you to try this out in your
524:54 - mind print this in some file you have on
524:56 - your computer or you can even use a
524:59 - regular piece of paper but make sure you
525:01 - understand the flow we go through to get
525:04 - this code to run multiple times okay now
525:06 - that we have done this we can work this
525:08 - and let the computer
525:10 - do the heavy work for us and run this
525:12 - fence multiple times the world is going
525:14 - to be good so what we're going to do
525:16 - we're going to say clear
525:18 - and run rooster and it's going to say
525:21 - exactly what we expect i'll have c plus
525:23 - 10 times and then it's going to say
525:25 - loop done okay one thing i want you to
525:28 - see
525:29 - is that the do while loop runs before it
525:32 - does the test and this may cause crazy
525:35 - things happening in your program if
525:38 - you're really not careful
525:40 - let's say that you wanted this program
525:42 - not to run and initialize this thing
525:44 - with a zero for the count so it's going
525:47 - to run zero times but that's not going
525:49 - to do what you expect with the do while
525:51 - loop because
525:53 - it runs things before it does the test
525:57 - so if you run this program it's not
525:59 - going to just say loop done it's going
526:01 - to say i love c plus plus and have zero
526:03 - value in here and it's going to say loop
526:06 - done but
526:07 - that's not going to be probably what you
526:10 - intended by putting a zero in here you
526:12 - put a zero in here if you want this code
526:15 - to run zero times or the code in the
526:17 - body not to run that's another way to
526:20 - say that but in this case a do while
526:22 - loop is not going to do what you expect
526:25 - because it runs before it does the test
526:28 - here
526:29 - let's build this and show you this
526:33 - so we're going to go through the world
526:35 - is successful
526:38 - and we are going to clear
526:40 - and run rooster you're going to see that
526:42 - it's saying zero i love c plus plus loop
526:44 - done it is running even if we set our
526:47 - count to zero here so be sure the do
526:51 - while loop is doing what you want but if
526:53 - you are careful about this
526:55 - you're going to have no problems and if
526:57 - you want the rope to actually not do
527:00 - anything
527:01 - when you have zero counting here you can
527:03 - use the while loop or the full look like
527:06 - we have seen before
527:08 - i would like to welcome you in this new
527:10 - chapter
527:11 - where we're going to be learning about
527:13 - arrays and arrays are a way to
527:17 - set up collections in our c plus plus
527:19 - program so far we have been working with
527:22 - single variables for example you have a
527:24 - bunch of integer variables you can even
527:26 - have 10 or 20 variables of integer type
527:30 - and that's going to be fine but
527:32 - sometimes you don't want to manage all
527:34 - these variables it is really desirable
527:37 - to group all these variables into one
527:40 - single unity and manage them as one
527:43 - single entity and we can do something
527:45 - like this group them together and give
527:48 - them a name so that we can refer to them
527:50 - or manipulate them
527:52 - under this name here and c plus plus has
527:55 - the array construct to help us do this
527:59 - okay so again if you look in memory how
528:02 - things are laid out you're going to have
528:04 - a bunch of zeros and ones for example
528:06 - here each red defend is a net it is four
528:09 - bytes in size and it can be used to
528:12 - represent a net so if we have a bunch of
528:15 - events like this we might want to group
528:17 - them together and give them a name and
528:19 - manipulate them under this name this is
528:22 - another way to look at what we just
528:24 - talked about here and again arrays are a
528:27 - way to do these kinds of things in c
528:29 - plus plus and we're going to be learning
528:31 - all about it in this chapter we are
528:34 - going to stop here in this lecture and
528:36 - we are going to start and look at how
528:38 - you can declare and initialize an array
528:40 - in the next lecture
528:42 - go ahead and finish up here
528:44 - and meet me there in this lecture we're
528:46 - going to see how we can declare and use
528:48 - arrays in our c plus plus program and
528:52 - again arrays are a facility we have in
528:55 - the c plus plus programming language to
528:57 - group many variables together and
529:00 - manipulate them as a single unit for
529:03 - example here we have a bunch of integers
529:06 - in memory each of these red things is
529:08 - going to be four bytes in size so we can
529:11 - think of it as an integer and we can
529:13 - group them together and give them an a
529:16 - we call them scores here and they are
529:18 - going to be living under that scores
529:21 - entity so if we want to
529:24 - refer to each of these things z plus
529:26 - plus provides an indexing system so we
529:29 - cannot use angle brackets like this and
529:32 - refer to the first of these integers as
529:36 - zero so we can go from zero all the way
529:39 - to nine here but your array can even be
529:42 - bigger than this many times bigger than
529:44 - this and we're going to see examples of
529:46 - how we can do that but this is an
529:48 - example of how you can take many
529:51 - variables group them under one entity
529:54 - give them a name and be able to
529:56 - reference each of these events that are
529:59 - under that entity and now that the idea
530:01 - is pretty clear let's see how we can do
530:04 - this in c plus plus the way to do that
530:06 - is to say and you have to specify the
530:09 - type of your collection you have to
530:11 - specify the name after that and then
530:13 - you're going to put a pair of angle
530:16 - brackets like this and inside those
530:18 - angle brackets you can specify the size
530:21 - you want that collection to have or that
530:23 - array to have and after this statement
530:26 - is run we are basically going to have
530:29 - something like this in memory we're
530:30 - going to have 10 integers so if you
530:32 - count here 0 all the way through 9
530:35 - that's 10 integers they're going to be
530:37 - grouped together under one logic entity
530:39 - that logic entity is going to be called
530:41 - scores and we can go through that name
530:44 - to manipulate all these things that are
530:47 - in this entity okay after your array is
530:50 - declared and you have space for it in
530:52 - memory basically something like this we
530:54 - need a way to read data from at and
530:57 - we're going to see how we can do that
530:59 - and it is what we have here for example
531:01 - if we want to print the first of these
531:03 - elements we're going to say scores
531:05 - angle brackets and specify the index of
531:08 - the first element in that array or that
531:11 - collection of integers that is called
531:13 - scores okay one thing you should really
531:16 - keep in mind is that arrays are indexed
531:19 - from zero they don't start from one so
531:21 - the first element is going to live at
531:23 - index zero it's not going to live at
531:26 - index one so here scores zero is going
531:28 - to print the first element and scores
531:30 - nine is going to print the last element
531:32 - which happens to be the last in our
531:35 - collection here of integers okay once
531:38 - our array is declared it's not going to
531:40 - have data in it there is going to be
531:42 - data in but it's not going to be data
531:45 - that we put in so we can think of this
531:48 - data basically as garbage another thing
531:51 - i wanted to bring to your attention is
531:53 - that
531:54 - your array has clear boundaries when we
531:58 - declare an array like this notice that
532:00 - we specify 10 as the size of our array
532:04 - it's only going to have 10 elements
532:06 - inside and you can see that we have from
532:08 - index 0 all the way to 9 and inside we
532:11 - have garbage data but we're going to fix
532:13 - that in a minute what i want you to see
532:15 - here is that you can to try and read
532:18 - outside the bounds of your array
532:20 - c plus plus is funny in that it allows
532:23 - you to do that but if you do that you're
532:25 - going to get weird problems for example
532:27 - your program would crash or do something
532:29 - really bad so you shouldn't really do
532:31 - this be aware of the boundaries of your
532:35 - array if you try to read the data from
532:37 - the outside of your balance you may read
532:40 - garbage data you may even cause failure
532:42 - of the operating system because you
532:44 - don't really know whose memory you're
532:46 - reading it's not going to be memory that
532:49 - is allocated to your program so array
532:51 - boundaries are something you need to
532:53 - keep in mind when working with arrays
532:56 - okay we just saw that we could read data
532:58 - from the array using this angle bracket
533:00 - syntax we can even do that through the
533:03 - loops and
533:05 - read all the elements in the array and
533:07 - this is how we could do that and you can
533:09 - see that the loops we learned about in
533:11 - the last chapter
533:12 - are starting to come in handy okay we
533:14 - have seen how we can read data from the
533:16 - array
533:17 - but what if we want to put something
533:20 - back in what if we want to write our own
533:22 - data in an array well the syntax is
533:25 - pretty much what you would expect we
533:28 - also use this angle bracket syntax but
533:30 - we're going to assign data to that
533:33 - element in the array for example if we
533:35 - wanted to assign data to the first
533:38 - element in our array we're going to say
533:41 - scores
533:42 - angle brackets 0 and we're going to
533:44 - assign a 20 in it and we can assign a 21
533:47 - into the element at index 1 and the 22
533:51 - in the element at index 2 and if we do
533:54 - that we're going to have something like
533:56 - this in our array so index 0 we have a
533:59 - 20 index 1 we have a 21 index 2 we have
534:02 - a 22 and the rest is still garbage
534:05 - because we didn't put in our data we can
534:08 - also write data in a loop for example
534:10 - here we have our array declared
534:13 - and we're going to loop around putting
534:15 - data at different indexes notice that
534:18 - the index is going to be the current
534:20 - iteration we are at so this is a common
534:23 - way to do things in c plus plus and you
534:25 - need to be familiar with this and after
534:27 - we put in the data we can read that back
534:30 - and make sure that it is the actual data
534:32 - that we put in and we're going to have a
534:34 - chance to play with this in visual
534:36 - studio code in a minute so don't worry
534:38 - if some of these things don't make sense
534:40 - yet but again the main thing here is
534:43 - this angle bracket syntax we can use
534:45 - that to either write data in the element
534:49 - of the array or read data from the
534:51 - element of the array and this is the
534:53 - syntax here scores angle brackets i okay
534:56 - so far our array has been declared and
534:59 - we didn't really put in data and there
535:01 - was junk data inside but there's a way
535:04 - you can declare an array and put data in
535:07 - in one single statement and this is how
535:10 - you would do it here we have another
535:12 - array it's going to be grouping double
535:14 - variables
535:15 - we call the array salaries and we
535:17 - specify that it's going to be
535:19 - of size five and we can put these
535:23 - elements in a comma separated list using
535:27 - braced initialization like this and it
535:29 - is going to work if we try to print it
535:31 - out we're going to see these elements
535:32 - here and you see that we can read this
535:35 - using the same syntax we've learned
535:36 - about salaries we say the array name we
535:40 - do angle brackets and inside we put the
535:42 - index of the element we are reading from
535:44 - and this index is coming from our loop
535:47 - here and it is going to work you're
535:49 - going to get this element printed out
535:51 - this is pretty cool when initializing
535:54 - your array
535:55 - you can leave out elements for example
535:57 - here we have a neat array it is called
536:00 - families it's going to be of size 5 but
536:03 - we are just putting in three elements
536:05 - the rest are going to be initialized to
536:08 - zero when we do things like this and
536:10 - this is something you need to be aware
536:12 - of and we are going to try this out in
536:14 - visual studio code and you're going to
536:16 - see that this is actually true it is
536:18 - possible to also omit the size when you
536:21 - are declaring your array and the
536:23 - compiler is going to deduce the size
536:25 - from the elements that you initialize
536:28 - your array with for example here we have
536:30 - in one two three four five six elements
536:33 - this array is going to have a size of
536:35 - six and if we print elements we're going
536:38 - to get those printed out notice here
536:40 - that we are using a ranged base for loop
536:43 - and
536:44 - hopefully you can see that it is easier
536:46 - to read data from a collection like this
536:49 - using a ranged base for loop because we
536:51 - don't have to set up an iterator
536:53 - initialize it to do the test do the
536:55 - incrementation we can just read the
536:58 - value and use it and be on our merry way
537:01 - this is pretty cool it is possible to
537:03 - also declare your array constant and
537:06 - when you do that you won't be able to
537:08 - modify elements of that array
537:10 - that's what it means if you make it
537:12 - constant you basically want it to stay
537:14 - constant and you don't want to allow
537:17 - modifications of your array and we're
537:19 - going to see this in a minute when we
537:21 - get in visual studio code the last thing
537:23 - i want you to see is that you can
537:25 - actually do operations on the data that
537:27 - you have stored in an array for example
537:30 - here we can sum the elements up and
537:32 - store the result back in our variable
537:34 - sum and this is something you would do
537:36 - and it might come in handy in many times
537:39 - okay one thing i want you to see before
537:42 - we head over to visual studio code and
537:44 - play with us is that arrays store
537:47 - elements of the same type
537:49 - repeat after me arrays store elements of
537:53 - the same type you can't try and store
537:56 - variables of different types in an array
537:58 - i don't even know how you would actually
538:00 - declare that and if you try and store a
538:02 - different type
538:04 - than the type that was declared for the
538:06 - array you're going to get a compiler
538:08 - error so this is something you should
538:10 - keep in mind but it makes sense because
538:13 - when you declare an array you're going
538:15 - to be given a bunch of bytes in memory
538:18 - and those bytes are going to be
538:20 - collections of data that is of the same
538:23 - type for example here we have a bunch of
538:26 - integers again each of these red events
538:28 - is an integer and if you try to put in
538:31 - something that is smaller or bigger than
538:34 - an edge then the compiler is going to be
538:36 - confused that as to how to read these
538:38 - text so for arrays to work the types
538:42 - that you store in the array have to be
538:44 - the same and they need to be consistent
538:47 - this is something you should know and if
538:49 - you try to break this rule you're going
538:51 - to get a compiler error
538:53 - now that you know about arrays we're
538:55 - going to head over to visual studio code
538:57 - and play with them a little bit okay
538:59 - here we are in our working folder the
539:02 - current chapter is raised the current
539:04 - project is declaring and using arrays
539:07 - we're going to grab our template code
539:10 - and we're going to copy and move the
539:12 - files over
539:14 - and we're going to open this thing up in
539:16 - visual studio code pretty quick we're
539:18 - going to open up the main cpp file and
539:20 - remove things we don't need
539:23 - and we're going to see how we can
539:24 - declare an array of ants
539:28 - okay the way you do that you say the
539:30 - name of the arrays and you put these
539:33 - angle brackets and specify the size of
539:36 - your array if you want you can put a
539:38 - space in here it's really not going to
539:40 - make a difference and you're going to
539:42 - put a semicolon at the end the moment
539:44 - this line executes we're going to have
539:47 - the space for 10 integers allocated to
539:50 - us in memory and that space is going to
539:52 - be called scores and we're going to be
539:54 - able to read data from it or even write
539:57 - data back into it for now let's see how
539:59 - we can read the data and it is really
540:01 - simple we're going to use this angle
540:03 - bracket syntax that we just saw in the
540:05 - slides so if we want to read the first
540:08 - element we can say
540:10 - sddc out we want to print it out and
540:12 - we're going to say scores
540:14 - specify the index we want to read from
540:17 - so we say zero
540:19 - and we're going to say std endl to move
540:22 - to the next line if you have this typed
540:24 - out you're going to see that this is
540:25 - going to work and it is going to print
540:27 - whatever is stored in the first element
540:31 - in this array here and again i want you
540:33 - to keep in mind the memory structure of
540:36 - your data when you are working with
540:38 - arrays so what we're going to print
540:40 - right now is whatever junk data is in
540:44 - this first element here okay in here
540:47 - we're going to say that we haven't
540:48 - jumped yet
540:50 - and let's bring up a terminal
540:53 - so that we can play with us and we're
540:55 - going to build this with gcc as we
540:58 - always do
540:59 - the build is going to be good
541:01 - and we're going to clear
541:03 - and run rooster you see that this is the
541:06 - junk value we have in here we don't have
541:08 - any
541:09 - useful data in here it's just junk data
541:12 - because we didn't initialize this array
541:15 - we can also read the element at location
541:17 - two and see what we have in there when
541:19 - you run the program i'm not even sure if
541:22 - it is guaranteed that you're going to
541:23 - get the same data if you run the program
541:26 - multiple times but we don't really care
541:28 - we know that it is junk data so we can't
541:31 - use this in our program
541:33 - what we're going to do is run this
541:35 - and see the value for the element at
541:38 - index one
541:39 - let's build with gcc
541:42 - the world is going to be good we're
541:44 - going to clear
541:46 - and we're going to run rooster and
541:48 - you're going to see that at index 1 we
541:50 - have a zero end
541:51 - but
541:52 - doing it manually like this is really
541:55 - time consuming and it is possible to
541:58 - actually do this in a loop
542:00 - we know the size of this array so it's a
542:02 - 10. and we can loop around 10 times
542:06 - pretend each element at each iteration
542:09 - and the way we do that we're going to
542:11 - read with that loop and we're going to
542:13 - say for
542:14 - okay size t
542:16 - and we're going to start from index to
542:18 - zero this is really important because
542:20 - arrays are indexed from zero they don't
542:23 - start from one again this is something
542:25 - you need to drill in your brain
542:27 - and we're going to put in our test case
542:29 - we're going to say i less than 10
542:32 - because we want to go from 0 through 9
542:34 - and we are going to increment our
542:37 - iterator after we do that we're going to
542:40 - have to
542:41 - jump into the body of the loop and we
542:44 - didn't name our iterator that's why
542:46 - we're having this squiggly line here
542:48 - let's do that pretty quick we're going
542:50 - to jump into the body of our loop and we
542:53 - are going to say sddc out
542:55 - and we're going to say scores
542:58 - and we need to be careful about how we
543:00 - format this because i is not something
543:02 - we have we're going to be getting that
543:04 - from our iterator here so we're going to
543:06 - print it like this and this is going to
543:08 - work no big deal
543:10 - and we're going to say
543:12 - squares and we're going to say i that's
543:15 - going to be our index that we want to
543:18 - print the data for
543:20 - and we're going to say stdendl
543:23 - and uh because we don't want this to
543:25 - confuse us
543:27 - we're going to comment that out
543:29 - and we're going to go up and make sure
543:32 - our comment is nice and neat
543:35 - and we're going to try and run this and
543:37 - what do you expect to see
543:39 - well we don't have any real data in here
543:42 - we're going to have some junk data so it
543:44 - could really be anything we get printed
543:46 - here so let's build with gcc and we're
543:50 - going to give ourselves some breathing
543:52 - room we're going to go down and clear
543:54 - and run rooster and you see that um this
543:57 - is really some junk data and if we run
543:59 - it again let's see that we get the same
544:01 - output
544:03 - it is the same data in here if we want
544:05 - to have in some reliable data we need to
544:08 - write in our own data and we're going to
544:10 - see how we can do that we're going to
544:12 - see how we can write data into an array
544:16 - and the syntax is really simple so the
544:19 - way you do that
544:20 - you just say the index for which you
544:22 - want to write data in and you say scores
544:26 - and you specify the index let's say zero
544:29 - and i'm going to put in a 20 for example
544:31 - this is how you do this
544:33 - you say 20 let's say scores
544:36 - we're going to grab the index one the
544:38 - first element and we're going to put in
544:40 - a 21 why not
544:42 - and we're going to say scores we're
544:44 - going to say 2 for index 2 and we're
544:47 - going to put in a 22
544:49 - why not and after we do this we can
544:53 - print this out or read data with the
544:55 - loop and make sure that the data we did
544:57 - writing is actually n
545:00 - so we're going to copy this
545:02 - and comment this out because we don't
545:04 - want this to confuse us on the console
545:06 - and we're going to do that we're going
545:08 - to come down here and print the data out
545:12 - let's say what we're doing here and if
545:14 - we build this we expect to see
545:17 - that at index 0 1 and 2 we have the
545:20 - values 20 21 and 22.
545:23 - let's build and see we're going to run
545:25 - the test to build with gcc
545:27 - the build is going to go through we're
545:29 - going to clear and run the rooster
545:32 - and look at this score is a 0 20 score
545:35 - is 1 21 score is 2 22
545:38 - and our data is actually getting gain
545:41 - now we're going to see that we can also
545:43 - write the data using the loop to make it
545:45 - really easy without us manually doing
545:48 - things like this
545:49 - for that we're going to copy what we
545:52 - have here to print data out
545:54 - and we're going to comment what we had
545:56 - out here
545:57 - so let's comment this out and we're
545:59 - going to go down
546:01 - and uh print the data again we're going
546:03 - to put in the code here and before we
546:06 - print the data we're going to put data
546:08 - in
546:08 - with the loop so the loop is basically
546:11 - going to be the same thing we're going
546:12 - to say size
546:14 - ti we're going to initialize this we're
546:16 - going to say i less than 10 because we
546:18 - want to loop 10 times we're going to
546:20 - increment
546:22 - and we're going to fall in the body of
546:23 - the loop what we're going to do is write
546:26 - data at the index of the current
546:28 - iteration i should say so what we're
546:30 - going to do we're going to say scores i
546:32 - and we can really put in anything for
546:34 - now let's say we want to put an i
546:37 - multiplied by 10 so we're going to take
546:40 - the current index multiply it by 10 and
546:43 - we're going to store that in the index
546:45 - at the current iteration this is what we
546:47 - are doing here
546:49 - and if we print this out try to think
546:51 - about what we're going to get here
546:53 - so
546:54 - at index 0 let's put in a 0 to be super
546:56 - clear here that we are starting from
546:59 - index 0. at index 0 we're going to take
547:01 - 0 and multiply that with the 10 so we're
547:03 - going to store 0 at index 0. the loop is
547:07 - going to run again at index 1 we're
547:08 - going to take a 1 multiply with 10 we're
547:10 - going to get it 10 at index 2 we're
547:13 - going to multiply 2 with a 10 and store
547:16 - a 20 at index 2 and we're going to keep
547:19 - going and basically have 0
547:21 - 10 20 all the way to 90 stored in our
547:24 - array here so if we print it out we
547:26 - expect to see 0 10 20 all the way to 90.
547:29 - let's weld and see that that's actually
547:32 - what we have in our array we're going to
547:34 - work successfully let's clear and run
547:37 - rooster and you see that this is exactly
547:39 - the same thing we have in our array how
547:42 - cool is that okay another thing i want
547:44 - you to see is that we can declare and
547:47 - initialize an array
547:49 - in place but before we do that let's say
547:52 - what we were doing here we were trying
547:54 - to write data in a loop and we're going
547:56 - to comment this out because we don't
547:58 - want a lot of confusing output
548:01 - in our console and we're going to go
548:03 - down and put in the data because i don't
548:05 - want to type all these thanks
548:07 - so we can declare and initialize an
548:09 - array in place and the way we do that
548:13 - the array is going to store doubles now
548:15 - we can really declare an array of
548:17 - anything but so far we have seen that we
548:20 - can do that for ant now let's try a
548:22 - little bit and show you that you can do
548:23 - the same thing for double times so we
548:26 - can declare an array of double types the
548:28 - size is going to be five and we're going
548:31 - to initialize that with this data here
548:33 - so at index zero we're going to have a
548:35 - 12.7 index one a 7.5 index 2 a 13.2
548:41 - index 3
548:43 - an 8.1 and index 4 and 9.3 and that's
548:47 - what we're going to have if we print
548:49 - this out here we have a simple loop to
548:51 - print it out and it's going to basically
548:53 - say salary 0
548:54 - 12.7 and it's going to go all the way to
548:57 - salary 4 and print a 9.3 and this is
549:01 - something you can do
549:02 - if it makes sense for whatever you are
549:04 - designing with c plus plus we're going
549:07 - to build this with gcc
549:10 - let's clear and run and you see that
549:13 - this is exactly what we expect okay now
549:16 - this is super clear the next thing we're
549:18 - going to see is that if you don't
549:20 - initialize all the elements in the array
549:24 - those you leave out are going to be
549:26 - initialized to zero and we are going to
549:28 - put in a piece of code to play with that
549:31 - so here we have an array it's a net
549:33 - array it's going to be called families
549:35 - and the size is going to be five but we
549:38 - are only initializing three elements and
549:41 - these elements are going to be elements
549:43 - on the front so elements at index 3 and
549:47 - 4 are going to be left out and they are
549:49 - going to be initialized to 0 by the
549:52 - compiler so if we print this out we
549:54 - expect to get 12 7 5 and 0 0 at
549:58 - different indexes in this array here
550:01 - let's build this
550:03 - with gcc
550:04 - we're going to clear because the build
550:07 - is successful
550:08 - and we're going to run this
550:11 - this is exactly what we expect we have a
550:13 - 12 a 7 and 5 and the last two elements
550:16 - are initialized to zero and this may
550:18 - come in handy sometimes okay let's
550:21 - comment this out another thing we want
550:23 - to see is that we can actually
550:26 - omit the size when we are declaring our
550:29 - array
550:30 - and initializing it so here is a simple
550:33 - example we have an inter array called
550:35 - class sizes we don't specify the size
550:38 - but we initialize it and the compiler is
550:41 - going to deduce the size of this array
550:44 - from the elements we put in here so if
550:46 - we put in two elements so it's going to
550:49 - be of size 2 if we put in 10 elements
550:51 - it's going to be of size 10 and this is
550:54 - how this works but if you do something
550:56 - like this and not to initialize the
550:59 - array let's take this out for example
551:02 - you're going to get a compiler error
551:03 - because the compiler now doesn't know
551:06 - which size it's going to give to this
551:08 - array so be sure to
551:10 - either
551:12 - put in the size or initialize your array
551:15 - like this and it is going to work in
551:17 - this case we're going to have six
551:19 - elements and and you see that a range
551:21 - based for loop is going to come in handy
551:23 - here because we don't really know the
551:26 - size of this array if somebody comes and
551:28 - adds another element let's say 23
551:31 - the size is going to change and if we
551:33 - hard to code the size in our full loop
551:36 - the code is going to break but a range
551:38 - based for loop is going to use whatever
551:41 - size this already has so we're going to
551:43 - try and build this we're going to build
551:45 - with gcc as usual
551:47 - and the world is going to go through if
551:49 - we run rooster we're going to get the
551:51 - elements we have 10 12 15 11 18 17 23 if
551:56 - we add a new element this is going to
551:58 - work
551:58 - you see that we don't need to modify the
552:00 - loop here to
552:02 - put in the new size and this is really
552:04 - cool i like this about range based for
552:06 - loops we're going to build again
552:09 - and we're going to clear
552:11 - run the rooster and this is going to
552:12 - give us exactly the data we have in the
552:15 - array so this is one way you can do
552:17 - things another thing we saw is that you
552:19 - can't modify const arrays
552:22 - so let's do an example here for example
552:25 - we're going to grab this thing and uh
552:27 - put an array declared down here we're
552:30 - going to copy that and use that here and
552:32 - we're going to make this cost
552:34 - let's give it a name let's say
552:37 - birds for example for example we want to
552:39 - keep
552:40 - track of
552:42 - lines of birds or whatever this is just
552:44 - an example to show you that you can't
552:46 - modify this array so if you try to do
552:49 - something like birds
552:51 - and index 2 for example and you want to
552:54 - change this to an 8
552:57 - the compiler is going to complain you
552:59 - see that visual studio code is
553:01 - complaining already
553:03 - expiration must be a modifiable value so
553:06 - it is saying that the array stores const
553:09 - elements so you can't modify elements of
553:12 - this array okay so this is something you
553:14 - can do if you don't want people to be
553:16 - able to modify data in your array and
553:20 - the last thing i'm going to show you is
553:22 - that you can do operations on the data
553:26 - in an array
553:27 - so let's bring up our scores array again
553:30 - so we're going to go up and copy it
553:31 - because the code is using there so let's
553:34 - put in our own scores array
553:37 - it's going to be pretty fast and we're
553:39 - going to say that it is an array with
553:41 - this angle brackets we're going to
553:42 - initialize this let's put in a bunch of
553:44 - values and what we can do is sum these
553:47 - things up we're going to store our
553:49 - results in the sum variable and we're
553:52 - going to loop around with a ranged based
553:54 - for loop because we don't really know
553:56 - the size of this array it can change any
553:58 - time with however many elements and a
554:02 - range based for loop is really cool in
554:04 - that we don't have to keep track of the
554:06 - size of ourselves
554:07 - so we're going to go in here
554:10 - and get each element
554:12 - and add that to some
554:14 - so for example for the first time sum is
554:17 - going to be 0 because that's what we
554:18 - initialize it with we're going to get
554:20 - into this loop here the first element is
554:23 - going to be 2 we're going to add that to
554:25 - 0 and get 2 we're going to add a 5 we're
554:28 - going to get a 7 we're going to keep
554:29 - adding this element and at the end sum
554:33 - is going to contain the sum of all these
554:35 - elements in the array here and this is
554:37 - one cool way you can sum up the elements
554:40 - in your array so if we run this we're
554:43 - going to get the sun printed out let's
554:44 - do that pretty quick we're going to run
554:46 - this has to build with gcc and we have
554:50 - ourselves a compiler error
554:52 - what is happening here it's going to say
554:54 - redeclaration of scores where did we
554:58 - declare scores before let's go up and
555:00 - make sure it is not declared somewhere
555:03 - and it is declared here
555:05 - so we want to comment this out
555:07 - come back to our code so that we can see
555:09 - it
555:10 - and we're going to build again with gcc
555:14 - and now the world is going through we're
555:16 - going to clear
555:17 - and if we run rooster
555:19 - score
555:20 - sum is 37 and if you sum these things up
555:23 - i'm sure you get 37. this is really all
555:26 - we set out to do in this lecture i hope
555:28 - you have a better idea of how you can
555:30 - declare your arrays put data in read
555:33 - data out of those arrays make them const
555:36 - or even do all kinds of operations on
555:38 - them and this was really what this
555:40 - lecture was all about
555:42 - we are going to stop here in this
555:44 - lecture in the next one we're going to
555:46 - see a cool way we can use to get the
555:48 - size of an array
555:50 - go ahead and finish up here
555:52 - and meet me there in this lecture we're
555:54 - going to see a way we can query for the
555:56 - size of an array
555:58 - at runtime if you remember in the last
556:00 - lecture we had an example like this
556:02 - showing how we can declare an array and
556:05 - initialize it in a single statement like
556:08 - this
556:08 - but the problem we had with this is that
556:11 - if we tried to print the array using a
556:14 - for loop for example we would have to
556:17 - use the size and the size of this array
556:19 - may change if somebody decides to add
556:22 - elements or remove elements then the
556:24 - size is going to be irrelevant c plus
556:26 - plus provides a way we can query for the
556:29 - size of an array at runtime and we're
556:31 - going to get the real size accounting
556:34 - for the current number of elements that
556:36 - we have in the array and for that we use
556:39 - the std size function
556:42 - this is a function that comes with the c
556:44 - plus plus standard library so you're
556:46 - going to have it already if you have a
556:48 - compliant compiler if you see here you
556:50 - see that it was introduced in c plus 17
556:54 - and it is a cool addition we can use it
556:56 - to make our code easier to work with if
556:58 - you look here we have a simple loop
556:59 - which is going to print data out it is
557:02 - going to loop starting from zero all the
557:04 - way to the size of the array you see
557:06 - that we use this to control when this
557:09 - loop is going to end we then put in our
557:12 - incrementation part and then we jump
557:14 - into the body of the loop and print the
557:16 - current element in the loop and if we do
557:18 - things like this we're going to be able
557:19 - to print all elements in the array
557:22 - regardless of the number we initialize
557:24 - it with okay so this is one way and it
557:27 - was introduced in c plus plus 17. but
557:30 - some of you must be asking
557:32 - how did we do things before z plus plus
557:35 - 17
557:36 - well we had to kind of do a hack to get
557:39 - something like this we use the size of
557:42 - operator we have seen a lot of times
557:44 - right now
557:45 - and the way you use this
557:47 - if you do size of and passing the array
557:50 - you're going to get the entire size of
557:52 - the array so if we take that and divide
557:56 - that with the size of a single element
557:58 - in the array we're going to get the
558:00 - number of elements of the array and this
558:03 - is really what we are doing here we are
558:05 - setting up a count variable and we are
558:07 - taking the size of the array and
558:09 - dividing that with the size of a single
558:12 - element in the array and we are just
558:14 - grabbing the first element because you
558:17 - can really use any element here and once
558:19 - we have this we can use this count to do
558:22 - a loop like this and it is working
558:24 - pretty well
558:25 - please remember that you don't have to
558:27 - go through this craziness we're doing
558:29 - here you don't even have to use std size
558:32 - because you can use a ranged base for
558:35 - loop and get access to the elements you
558:37 - have in the array and it is going to
558:39 - work pretty well now that you have an
558:41 - idea about this let's head to visual
558:44 - studio code and actually play with us
558:46 - okay so here we are in our working
558:49 - folder we are going to be working on
558:52 - this project size of an array we're
558:54 - going to grab our template project we're
558:56 - going to copy the files and put them in
558:59 - place
559:00 - and we're going to open this up in
559:01 - visual studio code let's do that it's
559:03 - going to open up in visual studio code
559:05 - and we're going to try and
559:08 - clean it up a little bit and we are
559:10 - going to declare an array if we want to
559:12 - print this thing
559:14 - we need to know how many times we're
559:16 - going to loop and print elements in here
559:19 - so one thing you might want to do is to
559:21 - say okay we have 10 elements in here so
559:24 - i'm going to loop for 10 times you might
559:26 - think this is going to work and it is
559:28 - going to work if we
559:30 - bring up a terminal
559:32 - and build this with gcc like we usually
559:35 - do
559:36 - and uh clear
559:39 - and run rooster we are going to get our
559:42 - numbers this is what we have in the
559:44 - array from one to ten
559:46 - but what if somebody comes and changes
559:49 - the elements we have in here let's add
559:51 - an 11 and a 12.
559:54 - and
559:54 - the moment we change this we will need
559:57 - to come and change the size in here and
559:59 - this loop here might be buried somewhere
560:01 - deep in your project and it might not be
560:04 - as easy as it is now to see that we also
560:08 - need to change this this may be a really
560:10 - big source of hard to debug problems so
560:14 - what we really need is a way to get the
560:17 - size of the array at runtime and be able
560:21 - to dynamically query for that size and
560:23 - use it in our program and that's exactly
560:26 - what std size provides so we're going to
560:30 - say end count
560:32 - and we're going to put in a value let's
560:34 - use a braced initializer so we're going
560:36 - to say std size
560:38 - and we're going to pass the array we
560:40 - want to get the size for
560:42 - and if we do this we're going to get
560:44 - this size here
560:46 - and we're going to be looping for this
560:48 - number of times so we're going to test
560:50 - for i is less than the count here
560:53 - and now it doesn't matter how many
560:56 - elements we have in here we're going to
560:58 - get them at run time we need to only
561:00 - update this initializer here so what we
561:03 - can do is
561:04 - weld with gcc again now
561:07 - we're going to come here
561:09 - and run rooster and we're going to get
561:12 - the numbers here you see that we get all
561:14 - the elements if we take out a few of
561:17 - these elements let's take out a few of
561:19 - these let's leave it up to seven or
561:22 - eight
561:22 - let's build again and we are going to
561:25 - clear and run rooster we're going to get
561:28 - however many elements we have in there
561:30 - and this is pretty cool again you might
561:33 - ask how did we do things before c plus
561:35 - plus 17 because std size was introduced
561:39 - in c plus plus 17 let's say that here
561:42 - before that we had to get the size of
561:46 - the entire array and divide that with
561:49 - the size of each element in the array
561:52 - and we could use the size of operator to
561:55 - do that so before we do any of that we
561:58 - want to play with the size of method to
562:00 - really show you what it does
562:02 - so what we're going to do is say sdd the
562:05 - out size of
562:08 - scores the entire array and we're going
562:11 - to print that and we're going to say
562:13 - sddcl
562:15 - size of
562:17 - you know one element let's say
562:20 - scores and use the first element this is
562:24 - the easiest thing we can find here but
562:27 - you can use any element so we're going
562:29 - to say size of here and we're going to
562:31 - say scores and grab the first element
562:34 - which is at index 0 and we're going to
562:36 - print its size if we build and run this
562:39 - program
562:40 - we're going to build and run
562:43 - and the world is good we can clear now
562:46 - and run rooster you're going to see that
562:48 - we're going to get size of scores is 32
562:51 - the entire array the size of one element
562:54 - is four because we are storing in
562:56 - integers and i want you to see that 32
563:00 - is four times eight because we have an
563:03 - eight elements so it's going to give you
563:05 - the combined size of all of the elements
563:08 - that we have in here if you do size of
563:11 - an array
563:12 - but if you do size of a single element
563:14 - you're going to get the size of a single
563:16 - element so c plus plus developers were
563:19 - clever enough to see this
563:21 - and see that we could use this
563:23 - information and get the count of
563:25 - elements inside so we can do something
563:28 - like ant account
563:30 - and we're going to assign a value to
563:32 - this
563:33 - in our braced initializer so we're going
563:36 - to say size
563:37 - of
563:38 - we're going to say scores
563:41 - and we're going to divide that with size
563:43 - of and i'm going to grab scores we can
563:46 - really use any element in the array but
563:49 - we're going to grab the one at index 0
563:51 - and now we're going to get the count
563:53 - stored in our account variable without
563:55 - using std size and we can uncomment our
563:59 - array here
564:00 - or the code to print the array and if we
564:03 - run now it is going to work exactly the
564:05 - same thing regardless of the amount of
564:07 - elements you have in here let's put a
564:10 - few numbers randomly and if we will then
564:13 - run we are going to clear and run
564:16 - rooster and we're going to get all the
564:18 - elements here and
564:20 - you can really use any of these
564:22 - techniques just choose what you feel
564:24 - works better for you okay we are going
564:27 - through all this trouble to set up an
564:30 - iterator we're going to do the test
564:32 - we're going to increment this is really
564:34 - too much work to try and get data from a
564:37 - collection like an array so what we can
564:40 - do instead is comment out all this hard
564:43 - work here
564:44 - and we can use a ranged based for loop
564:47 - as we have seen before and it is
564:49 - ridiculously easy and convenient to work
564:52 - with so what you can do is say for
564:55 - auto i we're going to do
564:57 - type deduction on whatever it is we have
564:59 - stored in our array so we're going to
565:02 - put a column and say scores
565:04 - and we're going to print out the element
565:07 - so let's do that we're going to print
565:10 - stdcl and here we're going to say value
565:14 - let's say value in the array and we're
565:16 - going to say
565:17 - i and this is going to print all the
565:20 - elements and we can work with the values
565:22 - inside if we want that but you see that
565:25 - we have lost the information
565:27 - on the indexes so if you really need the
565:29 - indexes you will need to go through
565:32 - something like this and if you just need
565:34 - the values in the array ranged based for
565:38 - loops are going to be really cool let's
565:40 - say range base for loop and if we boiled
565:42 - and run this it's going to work pretty
565:44 - well
565:45 - so the world is going to go through
565:47 - let's bring this up so that we have some
565:50 - breathing room we're going to clear
565:53 - and run rooster
565:55 - and we're going to get our elements
565:56 - printed out here and you see that it is
565:58 - the exact same thing we have in scores
566:01 - here
566:01 - so this is really all we set out to do
566:03 - in this lecture i just wanted you to be
566:05 - aware of the sdd size
566:08 - facility that we have in the c plus plus
566:11 - standard library if you don't want to
566:13 - use it for any reason you can also go in
566:16 - and do the division we did here to get
566:18 - the count of elements in the array
566:21 - and uh do your best to try and use
566:24 - ranged basis for loops because they make
566:27 - it easier and cleaner to get data from a
566:30 - collection like we are doing here with
566:32 - an array we are going to stop here in
566:35 - this lecture and the next one we're
566:37 - going to see how we can work with arrays
566:39 - of characters
566:41 - go ahead and finish up here and meet me
566:43 - there
566:45 - in this lecture we're going to work on
566:47 - array of characters and show how special
566:49 - they are
566:50 - you can declare an array of characters
566:53 - just like any other array so here we
566:55 - have
566:56 - an array called message it stores
566:58 - elements of type character the size is
567:01 - five and we initialize it with a bunch
567:04 - of characters
567:05 - if we want to print it out we can look
567:07 - like we loop through any other array in
567:10 - this case we're going to be using a
567:12 - ranged base for loop we say for auto c
567:15 - we pass the message and then we're going
567:17 - to be printing each character in the
567:19 - message and if we do this we're going to
567:21 - see hello printed out on the console we
567:24 - can also modify elements in our array
567:27 - for example we can say message1 and
567:29 - change the e here to an a
567:31 - and if we print out we should see hello
567:33 - printed out on the console nothing
567:36 - really special so far the cool thing you
567:38 - can do with character arrays
567:41 - is that you can print them to the
567:43 - console directly without even doing the
567:45 - loop you can do something like this you
567:47 - can do sddc out you say whatever you
567:50 - want to do in quotes here and you're
567:52 - going to print the message but sometimes
567:54 - this one to do what you expect because
567:57 - only proper c strings can be printed on
568:01 - the console and what makes up a proper c
568:04 - string a proper c string has this thing
568:07 - you see on the end here this backslash
568:10 - zero
568:11 - is called a null termination string and
568:14 - it is what is going to tell c plus plus
568:16 - that we have hit the end of the string
568:19 - and we are going to stop printing it if
568:21 - we are printing with things like stdcl
568:24 - so this is really important to be in
568:26 - your strength if it's not there it may
568:29 - work but sometimes it's also going to
568:31 - print some garbage characters after this
568:34 - because what tells sddc out that we have
568:37 - reached the end of the string is this
568:39 - backslash zero here if it's not there
568:42 - it's going to keep printing until it
568:44 - sees one and then you're going to
568:46 - probably have some garbage characters
568:48 - added to your string and that's not what
568:51 - you want so to have your strengths
568:53 - printed out correctly be sure to have in
568:56 - this null termination character here and
568:58 - if we print it out we're going to get it
569:00 - and we're going to see the size printed
569:02 - out properly if we do things like this
569:05 - but it is possible to get to this auto
569:07 - field for us if you look here we have a
569:10 - character array called message2 inside
569:12 - we have said that we need six elements
569:15 - and we say hello so we have one two
569:18 - three four five elements and the
569:20 - elements we don't initialize properly is
569:24 - going to be initialized with a zero
569:26 - version of a character and that happens
569:28 - to be the null terminator of the null
569:31 - termination character so this is going
569:34 - to print correctly and we're going to
569:36 - have the
569:37 - backslash n appended to this for us by
569:40 - the compiler but be sure you understand
569:42 - the difference between this and this
569:45 - here we have specified the size to be a
569:48 - 5 and we are putting in five elements so
569:50 - we have no null character appended to
569:53 - this string but here we have said that
569:55 - we can put in six elements and we have
569:58 - only put five and the compiler is going
570:01 - to autofill then the null terminating
570:05 - character these two things are different
570:07 - and make sure you understand the
570:08 - difference okay so now take a look at
570:11 - what we have here we have a strand we
570:13 - didn't specify the size and we just
570:15 - initialize it with hello someone might
570:18 - think ah this is also going to autofill
570:20 - but it's not because the compiler is
570:23 - going to deduce the size of this array
570:25 - using what you initialize it with and
570:28 - you didn't put in a null character so
570:30 - it's not going to be accounted for
570:32 - you're only going to have this here and
570:34 - if you print this out you may get
570:36 - garbage characters appended to your
570:38 - string here so be careful but it is
570:40 - possible to do literal c strings and
570:44 - only say hello like this in quotes and
570:47 - you're going to get the null terminating
570:49 - character appended to your string here
570:52 - so if we print this this is going to
570:54 - pretty nicely and this is the
570:56 - recommended way to initialize your
570:58 - character arrays if you want to put in
571:01 - string data like this you have to use
571:04 - double quotes and the cool thing about
571:06 - this is that you can even put in
571:09 - spaces between words like this it is
571:11 - going to work this really looks like how
571:13 - you would like to type text and store
571:16 - that in your character arrays and we're
571:19 - going to be using this a lot in the
571:21 - course again i want to bring to your
571:23 - attention that character arrays are
571:25 - special
571:26 - in that you can directly print them on
571:29 - the console
571:30 - like we are doing here you see this is a
571:32 - character array and we are saying stdc
571:35 - out message for you can't do this with
571:38 - other arrays and this is really all i
571:40 - had to share about character arrays so
571:43 - what we're going to do next is head to
571:45 - visual studio code and play with us okay
571:48 - here we are in our working directory the
571:51 - current project is arrays of characters
571:54 - we're going to grab our template project
571:57 - and we're going to copy the files
571:59 - bring them in here
572:01 - and we are going to open our folder
572:04 - we're going to open the main cpp file
572:06 - and we're going to get rid of what we
572:08 - don't need here let's put in some
572:10 - startup code so that we can start
572:12 - playing with this without typing this
572:14 - too much so we're going to declare an
572:16 - array of characters it's going to be
572:18 - called message the size is going to be
572:20 - five and we're going to fill it with
572:22 - characters like this so if we do this we
572:25 - might want to print it like we print any
572:27 - other array we're going to use loops and
572:30 - in this case we chose to use
572:32 - a range base for loop so we take a toast
572:35 - c c for character
572:37 - in message and we're going to print out
572:39 - each character notice that we're not
572:41 - adding std endl here because we want the
572:44 - characters printed close to each other
572:47 - so that we can read this easily and
572:49 - after this we will need to go to the
572:51 - next line so that the next thing we
572:53 - print doesn't disturb us so we're going
572:55 - to say sddc out std endl and if we do
572:59 - this we're going to see hello printed
573:01 - out on the console but we had to do too
573:04 - much work to print something simple
573:07 - like hello but let's do this we are
573:09 - learning
573:10 - so we're going to bring up our terminal
573:12 - and we're going to build with gcc let's
573:15 - do that
573:16 - the world is going to go through and
573:19 - we're going to clear
573:20 - and run rooster you're going to see that
573:22 - it's going to say message is hello and
573:24 - this is what we expect and this is
573:26 - really how you would declare an array of
573:28 - characters and initialize it with
573:30 - whatever it is you want to initialize it
573:32 - with but you notice that it's really not
573:34 - convenient to put data in here if you
573:37 - want to store a message for example for
573:40 - someone you don't want to do this thing
573:43 - you see here it's really ugly it's
573:45 - convenient and nobody would definitely
573:48 - use your program if you required your
573:50 - users to type things like this so we
573:53 - need to change this and we will but
573:55 - before we get there let's also see that
573:57 - we can change characters in our array so
574:00 - if you look here this e here is at index
574:03 - two so what we can say is a message and
574:07 - uh we're going to target the element on
574:10 - index
574:11 - two oh it's index one
574:13 - let's use that so this is index zero the
574:16 - h and the e is at index one let's make
574:19 - sure we get this straight and we're
574:21 - going to store in an a
574:23 - in quotes remember characters are
574:27 - surrounded by single quotes like this
574:29 - once we do this and we try to print the
574:32 - array out again using our
574:35 - technique here we're going to copy the
574:37 - code and we're going to paste it down
574:39 - here
574:40 - just to do this simply
574:42 - and if we do this we're going to see the
574:45 - message printed out here to be hello
574:48 - and the second message is going to be
574:50 - hello with an a
574:53 - because we changed the second element
574:56 - to an a it's no longer an e so that's
574:58 - what we expect we're going to run the
575:00 - test to build with gcc and we're going
575:03 - to bring this up and clear and we're
575:06 - going to run rooster you see that we
575:07 - have message hello and message hello and
575:11 - we are able to print things successfully
575:13 - this is really cool but we are doing too
575:16 - much work really to print something on
575:18 - the console and there should be an
575:20 - easier way to do this and there is so
575:23 - what we're going to do is comment this
575:25 - out because we don't want noise output
575:28 - in the console when we try to do
575:30 - something else
575:31 - so what we're going to do is comment out
575:34 - all we've done so far we're going to
575:35 - leave in our message here and we're
575:38 - going to try and print it directly on
575:40 - the console so we can say sddcl
575:44 - and say message
575:46 - and we're going to print out the message
575:48 - and take a moment and look at this
575:51 - and try to compile this it is going to
575:54 - go through it is going to compile
575:56 - because c plus plus
575:58 - supports printing character arrays like
576:01 - this
576:02 - but uh
576:03 - in most times this is not going to do
576:05 - what you expect let's try and run this
576:09 - and see what we get
576:11 - we're going to run rooster
576:13 - and you see that
576:14 - we're lucky to get something that really
576:17 - isn't what we expect
576:19 - it's pretty hello and you see that we
576:21 - have a bunch of other things and the
576:23 - reason is what we have discussed in
576:25 - these slides for character arrays like
576:28 - this to be printed out properly
576:31 - on the console they need to be null
576:34 - terminated in other words they need to
576:36 - have the null character which is a
576:39 - backslash zero appended to the string
576:42 - for sddc out to know that it has reached
576:45 - the end of the string so this is what
576:47 - makes your character strings legal
576:51 - now you see that we are getting a
576:52 - compiler error because we have overflown
576:55 - the size of the array i think that's the
576:57 - message too many initializer values and
576:59 - this is exactly what we have done
577:02 - now we can try and change this guy to a
577:05 - six to say that we have six elements in
577:07 - here
577:08 - this wiggly line should go away and if
577:11 - we try to build and run
577:13 - we're going to build with gcc
577:15 - let's bring this up a little bit and
577:18 - we're going to clear
577:20 - and run rooster now
577:22 - and you see that now we have hello
577:24 - printed out correctly if we turn this
577:26 - back to five elements
577:29 - and take out the null terminator
577:33 - we're going to try and build again and
577:35 - we're going to clear and run rooster
577:37 - you're going to see that we get the
577:39 - garbage back so for your strings to be
577:41 - printed out correctly they need to be
577:44 - now terminated that's why it is not safe
577:48 - to prank something like this
577:50 - when your character array is not now
577:53 - terminated i really want you to
577:55 - understand this so in c plus plus we
577:58 - have a proper name for these strings
578:00 - that are null terminated a null
578:03 - terminated string is called the c string
578:05 - because these things come from the c
578:07 - programming language okay and we're
578:09 - going to see a few ways we can set up c
578:11 - strings now and the first one is to say
578:15 - car we can call this message one
578:18 - and it's going to be an array of
578:20 - characters and we're going to initialize
578:22 - this with hello let's copy this because
578:24 - i don't want to type all these
578:26 - things here so let's copy this
578:29 - and initialize this properly notice that
578:31 - we didn't specify the size so the
578:33 - compiler is going to get the size from
578:36 - however many elements we put in here and
578:38 - we're going to put in our null
578:41 - terminator here and if we print this
578:43 - this is going to work and we are going
578:46 - to comment this out and i'm going to say
578:48 - that this will give you garbage okay if
578:50 - we come down here we're going to see
578:52 - that we have a car array it is called
578:55 - message1 and we have initialized it with
578:57 - data we have hello and we have a null
579:00 - terminator here and the compiler is
579:03 - going to deduce the size so this is
579:04 - going to be a proper c string and we
579:07 - will print it correctly
579:09 - let's try and weld this the board is
579:11 - going to go through if we clear and run
579:14 - rooster we're going to get our message
579:15 - here and this is one way we can set up a
579:18 - proper c string the second way is to
579:21 - actually not putting the null terminator
579:25 - but let the compiler add that in for you
579:28 - and the way we can do that we can say
579:30 - car message to and we're going to say
579:33 - this array is of size 6. let's say that
579:37 - we're going to put in a six
579:39 - and a fix how we end things here we're
579:41 - going to put in our code
579:43 - and end this with a semicolon now what
579:46 - is going to happen is the compiler is
579:48 - going to see that this array is of size
579:50 - 6 but we are putting in five elements so
579:53 - the remaining slots are going to be auto
579:55 - filled and it is going to be using
579:58 - null terminators to autofill this then
580:01 - if we try to print the size here we're
580:03 - going to get a
580:05 - because the null terminator is added in
580:09 - by the compiler let's try and print the
580:12 - sizes here actually so that you can see
580:14 - these things so we're going to say size
580:17 - and we're going to say that size of
580:19 - message one and we're going to put in a
580:21 - new line character and this should be
580:24 - what we expect so what we're going to do
580:27 - we're going to copy this
580:28 - and i put that down here because we're
580:30 - going to be doing the same thing for
580:32 - message to so we're going to say message
580:34 - to let's select this
580:36 - and i say size of message to and do
580:38 - signs of message too so what we're going
580:40 - to see is a message 1 and message 2
580:43 - printing out and we expect to see a size
580:45 - of 6 because both of these guys have six
580:48 - elements inside so we're going to run
580:51 - the task to build with gcc
580:54 - and bring this up clear
580:56 - rooster
580:58 - and this is exactly what we expect
581:00 - message one is hello the size is six
581:03 - message two is hello and the size is six
581:05 - and these are a few ways you can declare
581:07 - your character arrays and initialize
581:10 - them with proper data that is going to
581:12 - print correctly with stdc out make sure
581:16 - you don't do something like we did here
581:18 - by printing message here because it is
581:21 - not null terminated this is going to
581:24 - give you a lot of problems again i want
581:27 - to make it really clear
581:29 - that message three here is not a proper
581:32 - c string because the compiler is going
581:35 - to deduce however many elements we have
581:37 - in here and this thing is going to be of
581:40 - size five
581:42 - and we're not going to have a null
581:43 - terminator and if we print it out we're
581:45 - going to get some garbage so let's try
581:47 - and copy this so that we are consistent
581:50 - with
581:51 - what we've done above here and if we
581:53 - compile with gcc
581:56 - we are going to compile successfully but
581:58 - we may get weird things if we print out
582:01 - message three like we do here and you're
582:04 - going to see that the size is five
582:06 - because we only have five elements in
582:09 - here so let's clear and run rooster and
582:13 - you're going to see that
582:14 - we have hello for message one we have
582:17 - hello for message two but for message
582:19 - three we have things we don't expect
582:22 - because it's going to keep printing and
582:24 - it's going to go overbound and it's
582:26 - going to stop when it hits the first
582:29 - no terminating character
582:32 - like what we have in here okay so this
582:34 - is not safe don't do it make sure your
582:37 - strengths are null
582:39 - it if you intend to print them with sddc
582:42 - out like this okay so working with
582:44 - character arrays like this to print
582:46 - messages and do all kinds of crazy
582:48 - things is nice but it really isn't
582:51 - convenient as i said before
582:53 - you wouldn't expect your users to type
582:55 - characters like this by surrounding them
582:58 - with single quotes this is really ugly
583:01 - and it is painful to do if you want to
583:04 - do some productive work so c plus plus
583:07 - allows you to use what we call string
583:10 - literals and we're going to see an
583:11 - example of that
583:13 - down below we're going to say string
583:15 - literals and uh what we can do is car
583:18 - message for it's going to be an array as
583:21 - usual
583:22 - and we can initialize it
583:25 - with a string that is surrounded by
583:27 - double quotes and what this is going to
583:30 - tell c plus plus
583:32 - is you know take these things break it
583:35 - into characters and store this in this
583:38 - array here and make sure you properly
583:41 - now terminate this string here so if we
583:44 - print the size of message four we're not
583:47 - going to get five we're going to get six
583:50 - because c plus plus is going to see
583:52 - these double quotes and know that we
583:54 - intend for these things to be properly
583:56 - null terminated and it's going to add a
583:58 - null terminator so let's try and print
584:02 - this out so that we really are sure and
584:05 - we're going to weld this with gcc as we
584:08 - always do
584:09 - the world is going to go through let's
584:11 - go up and clear and we're going to run
584:13 - rooster
584:14 - and you see that message 4 is hello
584:17 - and the size is indeed a sex
584:20 - so this is one way we have to do things
584:22 - and we can even put spaces
584:25 - and do all kinds of crazy things and
584:27 - it's really cool and if we try to build
584:30 - this we're going to get the proper
584:32 - message printed out you see the world is
584:34 - good if we clear and run rooster we're
584:38 - going to see hello world how are you
584:40 - doing and this is really cool so from
584:42 - now on if we need to store a string in
584:45 - our program this is how we're going to
584:47 - do it because this is much more
584:49 - civilized and it is how you would really
584:52 - like to type characters in your program
584:54 - i have said that character arrays are
584:57 - really special because you can directly
584:59 - print them out with stdc out like this i
585:03 - want to prove this so we're going to try
585:05 - and declare another array so we're going
585:07 - to call this numbers
585:09 - and we're going to make this an array
585:11 - and we're going to initialize with one
585:14 - two three four five this is going to do
585:17 - and we're going to put our closing
585:19 - semicolon and we're going to try and
585:21 - print this out i'm going to say std
585:24 - see out and say numbers
585:27 - let's see what we get
585:29 - let's try and compile this and see what
585:31 - we get it is not actually going to give
585:33 - us a compiler error but it's not going
585:36 - to print what we expect and let's put a
585:38 - message here so that we know that it is
585:39 - this thing we are seeing here so we're
585:42 - going to say numbers and we're going to
585:44 - put a column here
585:47 - and we're going to weld this
585:49 - with gcc
585:52 - and we're going to clear
585:54 - and if a run rooster look out for the
585:57 - output that says numbers here so let's
586:00 - run rooster it's not a one two three
586:02 - four five it's something we don't really
586:05 - know
586:05 - and we will get to understand what is
586:08 - happening here
586:09 - in the next chapter for now note that
586:12 - you can't directly print arrays other
586:14 - than those of characters if you try to
586:17 - do that you're going to get weird
586:19 - numbers printed out and we're going to
586:21 - understand why this is
586:23 - the next chapter so let's say that here
586:25 - okay this is really all we set out to do
586:27 - in this lecture i hope you found it
586:29 - interesting character arrays have a few
586:32 - things you need to be careful about and
586:34 - we try to cover those in this lecture we
586:37 - are going to stop here in this lecture
586:39 - and the next one we're going to try and
586:40 - look at array bounds
586:43 - go ahead and finish up here and meet me
586:46 - there in this lecture we're going to
586:48 - look at what could happen if you try to
586:50 - manipulate data out of the bounds of
586:53 - your array we have seen that when you
586:56 - allocate space for an array the computer
586:59 - is going to give you a bunch of memory
587:01 - locations you can use to store your data
587:03 - and it's going to be of the size that
587:06 - you have specified or that is deduced by
587:08 - the compiler so here is an example of an
587:11 - array that is going to store seven
587:13 - elements and we have green slots for
587:16 - these elements and these are the
587:18 - locations we are allowed to manipulate
587:21 - in our c plus plus program if we try to
587:23 - go overbound for example if we try to
587:26 - modify something before our array or
587:29 - after our array
587:31 - it might be a memory location that is
587:33 - owned by another program it might be a
587:35 - memory location that is even being used
587:38 - by the operating system so bad things
587:40 - can really happen if you try to use data
587:44 - that is outside the bounds of your array
587:47 - let's try to look at a simple example
587:49 - here here we have an array called
587:50 - numbers we have 10 slots inside so we
587:54 - are only allowed to modify the memory
587:57 - locations for these 10 numbers and if we
588:00 - try to access something outside the
588:03 - bounds of this array something might
588:05 - happen but some people say that c plus
588:07 - plus is really funny because it should
588:10 - be stopping you from doing something
588:12 - like this but c plus plus allows you to
588:14 - do this if you look at code here we have
588:17 - an array we have 10 elements n so the
588:20 - valid indexes we can really use are from
588:23 - 0 to 9. but if we try and access
588:26 - something at index 12 the code is going
588:29 - to compile and if we run it we're going
588:31 - to get something printed out but that's
588:33 - something this is going to give you
588:35 - garbage data or you might be even trying
588:37 - to read some restricted memory and your
588:40 - program is going to terminate
588:42 - immediately and we're going to say that
588:44 - it has crashed if you try to write over
588:47 - bounce the compiler is also going to
588:50 - allow it but you don't own the memory so
588:52 - other programs might come and change
588:55 - that memory location and if you try to
588:57 - read from it again you're not going to
588:58 - get what you expect another thing that
589:00 - could happen is that you try and modify
589:03 - data that is owned by other programs and
589:06 - you might imagine how bad that really is
589:09 - so the message here is don't go over
589:12 - your array balance and you're going to
589:14 - be playing in the safe zone let's head
589:17 - over to visual studio code and play with
589:20 - us a little bit here we are in our
589:22 - working directory the current project is
589:25 - array balance we're going to grab the
589:27 - template files
589:29 - and we're going to
589:30 - put them in place
589:33 - and we're going to open this up in
589:34 - visual studio code we are going to
589:36 - declare an array and try to read beyond
589:40 - the legal bounds of our array so let's
589:43 - try and bring up a terminal here and we
589:46 - are going to build this with gcc the
589:48 - world is going to go through you're not
589:50 - going to get a compiler error but if we
589:53 - run this we can really get anything and
589:55 - you see we have a number we don't really
589:58 - know what it means and this means that
590:01 - you have read
590:02 - out of the legal bounds of your array
590:05 - and c plus plus
590:07 - allows you to do this and the reason
590:09 - they do this is because they expect you
590:13 - the developer to know what you're doing
590:15 - when you try manipulating things like
590:17 - ray and now you know this and be careful
590:20 - when you are working with arrays like
590:22 - this so don't go overbound that's the
590:25 - message we may also try to modify data
590:28 - beyond balance so let's go down and put
590:31 - in the code to modify thanks and i have
590:34 - put a clear message here as a comment to
590:36 - let you know that this is really
590:38 - something you should be very very
590:40 - careful about so we're going to try and
590:42 - change that number to 1000 and we're
590:44 - going to try and print it out and see
590:46 - what we get but this memory location at
590:49 - index 12
590:51 - is not something we own so other
590:53 - programs might come and write to this
590:55 - location and if we try to read from it
590:58 - again we might not get what we put in
591:01 - here even worse this memory location
591:03 - might be owned by other programs and if
591:06 - they read they're going to get what they
591:08 - didn't put in they're going to get what
591:10 - you put in and this is something bad we
591:13 - might try and really go crazy with us
591:15 - let's put in a really huge number and
591:17 - see that we can do that
591:19 - this is a good way to learn by the way
591:21 - it's going to compile
591:23 - and let's try and print what we have in
591:25 - there and we're going to say
591:28 - this location here
591:30 - and that's what we're going to say here
591:32 - and we're going to build again the world
591:34 - is going to go through you see that we
591:36 - are doing something really crazy our
591:39 - array has 10 elements but we are trying
591:41 - to modify something
591:44 - 1 million memory locations away and uh
591:48 - this is really crazy and c plus plus
591:50 - allows you to do this
591:52 - so let's clear and run did we world
591:54 - let's make sure we have world so let's
591:58 - build with gcc
592:00 - and clear
592:02 - and run rooster our program is crashing
592:04 - because we are trying to access
592:06 - something
592:07 - that isn't really ours and you see it
592:09 - has crashed
592:10 - okay for example if we have something
592:13 - printed out after this let's say std
592:16 - program
592:18 - and then so that you can see it is
592:19 - really crashing
592:21 - and say stdndl
592:23 - this statement here is not going to
592:26 - print because once we hit this location
592:29 - we're going to try and modify this and
592:31 - the program is not going to be able to
592:33 - do that it's going to crash the
592:34 - operating system is going to notice that
592:36 - we are trying to do something crazy and
592:38 - it's going to say this program is really
592:40 - crazy it doesn't know what it's doing i
592:43 - am going to kill it and it is going to
592:44 - stop that's basically what is happening
592:47 - here so let's weld again with gcc
592:50 - and we're going to clear
592:53 - let's clear
592:55 - and run rooster you see that it's going
592:57 - to try and do this it's going to try and
592:59 - put a value in here the program is going
593:01 - to end here and this is really bad
593:04 - because memory locations you have
593:06 - allocated for before here are not
593:09 - properly released and returned to the
593:11 - operating system and this is something
593:13 - really bad so the message is
593:16 - don't go overbound make sure you are
593:19 - working within the legal boundaries of
593:22 - your array welcome to this new chapter
593:25 - and we are going to be talking about
593:27 - pointers pointers are one of the
593:29 - important topics in c plus plus and they
593:32 - allow you to do some of the things very
593:34 - conveniently and we're going to be
593:36 - learning about all those tricky things
593:38 - you can do with them in this chapter but
593:41 - now i want you to have a basic
593:43 - understanding of what a pointer really
593:45 - is
593:46 - so far we have been working with
593:47 - variables like this we set up a variable
593:50 - in our c plus plus code we get to a
593:52 - point where we put a value inside that
593:54 - variable and we could use it for example
593:56 - we could print it out on stdc out or we
594:00 - could even store a value or assign
594:02 - another value to the variable we've been
594:04 - doing that quite a lot but there is a
594:06 - point we haven't really been talking
594:08 - about those variables have an address in
594:11 - memory and here for example you see that
594:13 - our var
594:15 - is stored at location one zero zero
594:17 - eight of course this is a simple example
594:19 - i came up with
594:21 - but i hope it drives the point home all
594:24 - the variables you use in your code have
594:26 - some kind of address in memory
594:28 - and we can grab that address and store
594:31 - that in a special kind of variable which
594:34 - is really a pointer so we can say that a
594:36 - pointer
594:37 - is a special kind of variable
594:40 - that stores addresses of other variables
594:43 - make sure you really understand this
594:45 - here we have p var so it is a pointer
594:47 - its type is end pointer and we denote
594:50 - pointer using this star symbol after our
594:54 - type if you see something like this
594:56 - you're going to know that this type is a
594:58 - pointer to end its name is going to be p
595:00 - var because it's a variable
595:02 - and its value is going to be the address
595:04 - of another variable you see it is
595:06 - storing 1 0 0 8 which happens to be the
595:10 - address of our var here in memory
595:13 - pointers and variables we've been
595:15 - talking about can work hand in hand and
595:17 - we're going to be seeing how this is
595:19 - done in the next few lectures in the
595:21 - chapter but the basic idea is really the
595:24 - same here you see that we have a pointer
595:26 - to it but you can have a pointer ready
595:29 - to anything in your code you can have a
595:30 - pointer to car you can have a pointer to
595:33 - double you can have a pointer to float
595:35 - even pointers to custom types we haven't
595:39 - really talked about now but we will
595:40 - learn about them later in the course
595:42 - again a pointer is a special type of
595:45 - variable in your c plus program that is
595:48 - going to store addresses to other
595:51 - variables that's what it really is and
595:54 - we're going to start and see how you can
595:55 - declare initialize and use them in your
595:58 - code starting in the next lecture
596:00 - go ahead and finish up here and meet me
596:03 - there
596:04 - in this lecture we're going to see how
596:05 - we can declare and use pointers in our c
596:08 - plus plus code in the last lecture we
596:10 - say that a pointer is a special kind of
596:13 - variable
596:14 - that can store addresses to other
596:17 - variables in our c plus plus code and we
596:20 - have seen a slide like this to drive the
596:22 - point home now we're going to see how we
596:24 - can actually use pointers in our code
596:27 - here is a simple example of how you can
596:29 - declare a pointer variable in your c
596:32 - plus plus code you say ent you put a
596:34 - star after the type
596:36 - to mean that this variable is not a
596:39 - regular variable like we have seen
596:41 - before it is a special kind of variable
596:45 - that is going to store
596:47 - addresses to other variables and here i
596:49 - have to say that you have to be really
596:51 - careful and only store addresses to
596:54 - value the types of variable
596:57 - in your pointers for example this is a
597:00 - pointer to end it can only store an
597:02 - address of a variable of type and for
597:05 - other types if you try and put in their
597:08 - addresses in here you're going to get a
597:10 - compiler error down here you see we have
597:12 - another example and it's called p
597:14 - fractional number because it's a double
597:17 - and you see that our pointers here are
597:19 - initialized using braced initializers
597:22 - and this is going to initialize the
597:24 - pointers with a special address that
597:28 - really denotes that these pointers are
597:30 - not pointing to anything yet okay you
597:32 - can also say that explicitly and put now
597:35 - ptr inside and this is going to mean
597:38 - that these pointers are not pointing
597:41 - anywhere you can't really use the values
597:43 - at the addresses where they point this
597:46 - is the message here don't use pointers
597:48 - that contain null pointer all pointers
597:51 - on a given system are going to have the
597:54 - same size for example if you have a
597:56 - pointer to end and the pointer to double
597:59 - they are going to be the same size
598:01 - because they really store the same thing
598:03 - they store addresses to variables and
598:06 - addresses to different variables even if
598:08 - they happen to be of the same type on
598:10 - the same system are of the same size
598:13 - that's why all the pointers you're going
598:15 - to use in your code are going to have
598:17 - the same size and this is something you
598:19 - should keep in mind and here is a simple
598:21 - example to really play with that we have
598:23 - a size of it printed out we have a size
598:26 - of our pointers printed out and we're
598:28 - going to compare these things when we
598:30 - get to visual studio code in a minute
598:32 - and you're going to see that all
598:33 - pointers are of the same size a question
598:36 - i get from many people is if the
598:39 - position of this star symbol
598:42 - really matters and i have to break it to
598:44 - you it doesn't but i prefer to put it on
598:47 - the left some people prefer to put it on
598:49 - the right but definitely don't put it in
598:51 - the middle i've never seen anybody do
598:53 - this but it's going to work it's going
598:55 - to be legal c plus plus code another
598:58 - thing i see people do which is really
599:00 - confusing is to declare your pointers on
599:03 - the same line and do a comma like this
599:05 - this is really going to be confusing and
599:08 - now i want you to guess and see what is
599:11 - happening here is either it var a
599:15 - pointer or it's a regular end i want you
599:17 - to keep this in mind i'm not going to
599:19 - tell you we're going to try this out
599:21 - actually in visual studio code and we're
599:23 - going to figure this out together but
599:25 - now i want you to try and think about it
599:27 - we're going to leave this question
599:29 - unanswered and we're going to answer it
599:31 - in a little while but for now
599:33 - don't really do this because it's
599:35 - confusing and it's going to make your
599:37 - code less readable if you have to do
599:40 - something like this make sure you just
599:42 - put them on different lines and it's not
599:44 - going to be confusing for example if you
599:46 - look down here you're going to know that
599:48 - p number seven is a pointer other
599:50 - interval is a regular end and there is
599:52 - no room for confusion this time use code
599:55 - like this and don't put things on the
599:57 - same line like we have on top here okay
600:00 - now we have seen that we can declare and
600:02 - initialize pointers with null pointer
600:06 - now is the time to see how we can put
600:09 - actual data in those pointer variables
600:12 - here we have a variable which is called
600:13 - into var it is of type and and its value
600:17 - is a 43
600:18 - we can also set up another pointer
600:20 - variable end pointer
600:23 - its name is p
600:25 - underscore int and we can initialize it
600:28 - with the address of another variable and
600:31 - here is a new operator we haven't seen
600:34 - before this ampersand variable here
600:37 - really means the address of this ant
600:39 - variable that's what we mean here so
600:41 - we're going to initialize this p end
600:43 - variable with the address of enter
600:46 - variable and this is how we do it
600:48 - if we go down here we print antivirus
600:50 - we're going to get the value printed
600:52 - down if we print the pointer directly
600:55 - we're going to get the address of this
600:57 - little guy printed out on the console
600:59 - and we're going to see it okay so this
601:01 - is how you can store things in your
601:03 - pointer variables and what you have to
601:05 - store and has to be an address of
601:08 - another variable
601:09 - down here you see we have another
601:10 - variable called into r1 inside we have a
601:13 - 65 and if you go down here you see that
601:16 - we are storing something else
601:19 - in our point of variable here we had in
601:21 - the address of into var now we are
601:24 - putting in the address of into var1
601:27 - using an assignment operator and this is
601:29 - something you can definitely do it's
601:32 - legal c plus plus it's going to work if
601:34 - we print it out we're going to get a
601:36 - different address printed out this is
601:38 - how you can store values in your pointer
601:41 - variables again you can't cross a sign
601:44 - before different pointer types here we
601:46 - have an eight pointer which is called
601:48 - pn1 and we have a double variable it's
601:51 - called double var we can't take the
601:53 - address of double var and store that in
601:56 - pnt1 this is going to be a compiler
601:59 - error the variables whose addresses you
602:01 - store in payment 1 have to be of type
602:05 - and again the basic idea is that a
602:07 - pointer is really a special kind of
602:10 - variable that is going to store
602:12 - addresses to other variables and if your
602:15 - pointer is a pointer to end
602:18 - the variables whose addresses you can
602:20 - store in this pointer to end can only be
602:23 - ends if you try and put in doubles
602:26 - you're going to be in trouble you're
602:27 - going to get a compiler error and it's
602:29 - not going to work now we're going to
602:31 - head over to visual studio code and
602:33 - actually play with these things here we
602:36 - are in our working directory the current
602:39 - chapter is pointers the current lecture
602:41 - is declaring and using pointers we're
602:43 - going to grab our template files and put
602:46 - them in place
602:48 - so put them in our project here and
602:51 - we're going to open this in visual
602:52 - studio code the first thing we're going
602:54 - to see is how we can declare
602:56 - and initialize pointers and we're going
602:58 - to use a pointer to end as a first
603:00 - example we're going to set up an inch
603:02 - pointer and we say in store we're going
603:05 - to give it a name we're going to call
603:06 - this p number and you can leave it like
603:09 - this uninitialized but it is really
603:11 - advised to always initialize your
603:14 - pointers so we're going to do that with
603:16 - a brist initializer which is going to do
603:19 - that for us this is going to implicitly
603:21 - initialize it with zero equivalent of
603:24 - pointers and that happens to be null
603:26 - pointer so we'll initialize okay so this
603:29 - is what we're going to initialize with
603:31 - no
603:32 - pointer we say no ptr
603:34 - and this is how you should do things you
603:37 - can also do a pointer to double why not
603:39 - let's do double pointer and we're going
603:41 - to say fractional number pointer to
603:44 - fractional number and we can also
603:45 - initialize this with null pointer
603:48 - implicitly
603:50 - and
603:51 - once you do this the program is going to
603:53 - be legal if we try to world at with gcc
603:57 - like we always do the build is going to
603:59 - be good but we don't really have any
604:01 - useful thing we can see
604:03 - if we run this program we are just
604:05 - getting started we will get to see
604:07 - things later for now just understand
604:10 - that p number is a variable we have in
604:13 - our code this variable can only store
604:16 - addresses to other variables that happen
604:19 - to be of type and if you try and store
604:22 - in an address of a variable which is of
604:25 - type double for example or flute you're
604:27 - going to get a compiler error you
604:29 - shouldn't do that the same for p
604:31 - fractional number it can only store
604:34 - addresses to other variables which
604:36 - happen to be of type double keep this in
604:39 - mind we can also
604:41 - explicitly initialize with no pointer so
604:44 - we can say end pointer and say p number
604:47 - one why not and we're going to
604:49 - explicitly use no
604:51 - ptr like this and this is going to work
604:53 - as well you can also say
604:56 - p fractional number and say
604:59 - one why not and say now pqr this is
605:03 - going to work this is something you can
605:05 - do you're going to see that if we
605:06 - compile this the compiler is going to be
605:08 - happy with this the world is good okay
605:11 - now you know how you can declare and
605:13 - initialize your pointers now we want to
605:15 - see
605:16 - that pointers to different variables are
605:18 - actually of the same size
605:21 - on whatever system you are working on
605:23 - it's not consistent across operating
605:25 - systems or riffing systems but it is
605:28 - guaranteed to be of the same size on the
605:31 - same machine
605:32 - i am going to go down and put in a piece
605:34 - of code that is going to show us all
605:36 - these things on the console and i am
605:39 - going to click on this file icon here
605:41 - and give ourselves
605:43 - some breathing room so that we can see
605:45 - the entire thing here if you look here
605:46 - we are printing the size of ant we know
605:48 - that this is going to be a four
605:51 - size of double this is going to be an
605:53 - eight on our system here but we don't
605:55 - know what the size of a double pointer
605:58 - is or the size of an end pointer and
606:00 - we're going to see that in a minute here
606:03 - you see that we are also using the
606:04 - pointer variables immediately this is
606:06 - something you can do you see that visual
606:08 - studio code is not complaining and we
606:11 - can go on top here and boulder with gcc
606:14 - let's do that
606:16 - the world is going to be good now we can
606:19 - open up a terminal and actually run this
606:21 - program here we're going to clear if we
606:23 - do there
606:24 - we're going to see that
606:26 - in
606:27 - our directory here so you see that we
606:29 - have rooster.exe
606:32 - and we can run this and it's going to
606:34 - say
606:35 - sizeofant is four size of double is
606:38 - eight
606:39 - this is expected but pointer types are
606:43 - of size 8 on my system they occupy 8
606:47 - bytes in memory so it doesn't matter the
606:49 - type we are pointing to a pointer to it
606:52 - is always going to be 8 bytes in memory
606:55 - this is something you should really know
606:57 - and keep in your mind another thing we
606:59 - have said that i want to play with right
607:01 - now
607:02 - is the location of the star symbol some
607:05 - people say you should put it on the left
607:07 - some people say you should put it to the
607:08 - right i don't really think any of these
607:11 - dense matters i prefer to put it to the
607:13 - left but if you put it to the right it's
607:15 - also possible it's going to work you see
607:17 - that even if you put it in the middle
607:19 - here which is really crazy the compiler
607:21 - is going to take this we can run the
607:23 - task to build this to make sure the
607:25 - compiler is really happy and you see
607:27 - that there's no problem the compiler is
607:29 - going to accept this and we are going to
607:31 - build successfully if you put your
607:34 - declaration on a single line like this
607:36 - what is other ant var going to be is it
607:39 - going to be a regular end variable is it
607:41 - going to be a pointer to end
607:43 - we don't really know now and i don't
607:45 - want to tell you we're going to find out
607:47 - together so what we're going to do we're
607:49 - going to print the size of these things
607:52 - i am going to go down here and put in
607:54 - the code and come back in a minute here
607:56 - is our code typed out and we're going to
607:59 - see the size of these things what we're
608:01 - going to do is run the task to build
608:04 - with gcc as we always do let's clear
608:07 - properly
608:08 - and run rooster
608:10 - and you see size of p number five is
608:14 - eight
608:15 - because it's a pointer size of either
608:17 - end is four and the same applies to the
608:20 - second line here
608:22 - so from this we can tell that other
608:24 - interval and other ant versus x are not
608:28 - pointers they are regular integers and
608:30 - this can be really confusing so to avoid
608:34 - this confusion i would advise not to
608:37 - declare
608:38 - your thanks when you have pointers
608:40 - inside like this because that's going to
608:42 - be really confusing what you can do is
608:44 - put them on separate lines and do
608:46 - something like this so here it is very
608:49 - clear that p number seven is a pointer
608:51 - other eight var seven is a regular it
608:54 - variable and there is no room for
608:55 - confusion with this way of doing that so
608:58 - make sure you put things on separate
609:00 - lines like this and you're going to be
609:02 - fine now what i want you to see is that
609:05 - we can actually store data in all
609:07 - pointers i mean valid data that is not
609:10 - null pointer in this case we're going to
609:12 - set up a variable a regular end variable
609:14 - it's going to store a 43 inside and
609:17 - we're going to set up another pointer
609:19 - and initialize that with the address of
609:22 - this it variable and this is going to
609:24 - work properly what we can do now
609:27 - is print the interval we're going to
609:29 - print it out if we try to print the
609:31 - pointer we're going to get the address
609:33 - of this into var in memory and this is
609:36 - something you need to see with your eyes
609:38 - this is the first time we are printing
609:40 - out an address that is stored in a
609:42 - pointer and we're going to see that on
609:44 - the console here what i am going to do
609:46 - before we build and run this i am going
609:49 - to comment out everything we've done
609:50 - before because our console is now
609:53 - cluttered
609:54 - so let's come and comment out everything
609:58 - and let's go down again now if we print
610:01 - we're going to see these two statements
610:03 - and that's going to be easier to follow
610:07 - on the console here the build is good so
610:09 - we are cool
610:11 - let's run rooster
610:13 - and the var is 43 and its address in
610:16 - memory is this number here it is in
610:18 - hexadecimal so this is the address in
610:21 - memory and we can print that out and see
610:24 - what it is okay so this is really cool
610:26 - but we can also change what is stored in
610:29 - our pointer here for example we can set
610:31 - up another variable call it into our one
610:34 - and uh change pnt which is a pointer to
610:37 - contain the address of this new variable
610:40 - and we can do that now if we print
610:42 - payment we're going to see that it
610:44 - contains a different address and we can
610:46 - do that
610:48 - so let's build with gcc again
610:51 - we're going to go down and clear and run
610:53 - rooster and we're going to see that now
610:55 - we have a different address the one we
610:57 - had ended in d e4 now we end in de0
611:01 - these are different addresses and we are
611:04 - storing different things in our pointer
611:06 - this is really cool you can do something
611:08 - like this and the next thing we want to
611:10 - see now is that we can't cross a sign
611:14 - between pointers of different types and
611:16 - what i mean here is that for example if
611:19 - we have two variables here one is a
611:21 - pointer to end it is initialized with no
611:24 - pointer and we have another variable
611:26 - which is a double var it's going to be
611:28 - of type double
611:30 - and we can't do something like payment
611:33 - equals address of double bar you can't
611:37 - do something like this if you do it
611:38 - you're going to get a compiler error and
611:40 - you see that we have squiggly lines
611:43 - in visual studio code this is a good
611:45 - indication that something might be wrong
611:47 - if we open the problems tab we're going
611:49 - to say a value of double pointer cannot
611:52 - be assigned to an entity of type 8
611:54 - pointer so this is not something you can
611:57 - do if you do this you're going to get a
611:59 - compiler error be aware of this visual
612:02 - studio code has warned us enough but we
612:05 - can also try and get
612:07 - a clear compiler error by building this
612:10 - with gcc and we're going to get
612:12 - basically the same thing you can't
612:14 - cross-assign between pointers of
612:16 - different types we are trying to assign
612:20 - a double address
612:22 - into a pointer to enter and this is not
612:24 - going to work so let's comment this out
612:26 - because we don't want this compiler
612:28 - error now you know this and before we
612:31 - close this lecture i want to mention
612:33 - what is called the referencing and that
612:36 - is the act of reading something
612:39 - through a pointer so if we have an
612:41 - address in a pointer we can go through
612:43 - that address and actually read the value
612:46 - contained in that address and we can do
612:48 - something like this so if we have for
612:51 - example an end pointer let's call it p
612:54 - and two do we have a variable like this
612:57 - so let's say we initialize this with
612:59 - nodepointer and we have an end
613:02 - variable and this is a 56 for example
613:06 - and we do something like we do say
613:09 - pnt2 we're going to make it contain the
613:12 - address of int data this is something
613:14 - you know you can do now now we want to
613:16 - go through pm to 2 to read what is
613:19 - contained in interdata because pn 2
613:23 - contains the address of our integer here
613:26 - so what we can do we can do stdc out and
613:29 - say value and the syntax we use in c
613:32 - plus plus is like this we say store and
613:35 - we say our pointer variable we're going
613:37 - to say pnt2 and now if we run we're
613:40 - going to get the value here printed out
613:42 - okay now if we try to build we're going
613:44 - to build fine let's try with gcc
613:48 - the world is good
613:49 - we can clear
613:51 - so that the arrows from
613:53 - a previous run are cleared out
613:56 - you see the bullet is good we can now
613:59 - run rooster
614:01 - and we're going to see that value is 56
614:03 - we are successfully
614:05 - reading the value stored in the address
614:07 - pointed to by our pointer here and this
614:10 - is the syntax used and this is called
614:12 - the referencing a pointer we are
614:14 - basically reading something stored in
614:17 - the address of a pointer this is what we
614:19 - mean here this is really all we set out
614:21 - to do in this lecture the lecture turned
614:23 - out to be lengthy but we had a lot of
614:26 - ground to cover and now i hope you have
614:29 - a good grasp on how to declare
614:31 - initialize and use your pointers to do
614:34 - all kinds of crazy things
614:36 - we are going to stop here in this
614:38 - lecture in the next one we're going to
614:40 - learn a little more about pointer to
614:42 - character types because they are also
614:45 - special
614:46 - go ahead and finish up here and meet me
614:48 - there in this lecture we're going to
614:50 - explore pointer to characters
614:53 - and you can declare a pointer to a
614:55 - character just like this we have car
614:58 - pointer
614:59 - and we say p carvar to give it a
615:02 - variable name we initialize this with a
615:04 - null pointer and after that we set up a
615:06 - character variable and it is called
615:09 - corvar and we store in an a in uppercase
615:12 - a after that we take the address of car
615:16 - of r and assign that to our pointer
615:19 - variable this is how we store data in a
615:21 - pointer and we can go through this
615:23 - pointer to access data in this character
615:26 - variable if we do something like this
615:28 - we're going to print a down here we
615:30 - declare another variable we store in a c
615:33 - and we
615:34 - assign the address of this new character
615:37 - variable to our pointer variable and if
615:40 - we print this again we're going to get a
615:42 - c printed out this is really what we
615:45 - have done in the last lecture we are
615:46 - just extending that to character
615:48 - pointers but with character pointers you
615:51 - can do something really special what you
615:53 - can do that is special you can
615:55 - initialize that with a string literal
615:58 - something like hello world which is
616:00 - wrapped in quotes like this when you do
616:03 - something like this the string here is
616:05 - going to be expanded into a character
616:07 - array and the first character of our
616:11 - array is going to be pointed to by p
616:14 - message here this is what we mean i
616:16 - realize i might be throwing a lot of
616:18 - things at you right now i am mixing up
616:21 - arrays and pointers but they have a
616:23 - really strong relationship and we're
616:25 - going to learn about that in detail in a
616:28 - few lectures ahead but for now
616:30 - think of it like this this hello world
616:33 - string is going to be turned into a
616:34 - character array and the p message is
616:37 - going to point to the first character
616:40 - in this array here this is what is going
616:42 - to happen and this is going to give us
616:44 - the flexibility of treating our
616:46 - strengths as character pointers and this
616:49 - is going to come in handy at many
616:51 - occasions
616:52 - one thing i should tell you though is
616:54 - that some compilers will refuse to
616:57 - compile this code for example visual
617:00 - studio 19 that i have installed on my
617:02 - computer right now is going to refuse to
617:04 - compile this code and the reason is the
617:07 - compiler is going to expand this
617:09 - strength into
617:11 - a character array of const car
617:14 - and here what we are using to point to
617:17 - that is not a cost car pointer
617:20 - so this pointer here can be used to try
617:23 - and modify data into an array of cost
617:27 - cars and that's going to be disastrous
617:29 - because if you try to modify that
617:31 - that's going to fail and that's not
617:33 - going to be good so some compilers are
617:35 - going to try and protect you from this
617:37 - and force you to use pointers that are
617:41 - qualified with cost to really mean that
617:43 - they are closed car pointers and to get
617:46 - the code to work we will have to do that
617:48 - and i will show you how we do that in
617:49 - visual studio code but i have to tell
617:52 - you this in case you just want to jump
617:54 - ahead and try this code out if you get a
617:56 - compiler error that's going to be the
617:58 - reason now that we have our strength
618:00 - stored in memory we can really print it
618:02 - out like this if you print p message
618:04 - you're going to get this ring printed
618:06 - out but i want to give you a question
618:09 - here
618:09 - what do you think we will get if we
618:12 - dereference p message
618:14 - try to think about this
618:16 - i told you that the compiler is going to
618:19 - expand this hello world string into an
618:21 - array of characters or to be specific an
618:25 - array of const cards
618:27 - and p message is going to be pointing to
618:30 - the first character
618:31 - in that array
618:33 - so if we dereference p message we're
618:36 - going to get that character printed out
618:38 - in this case we will get an h and that's
618:40 - what is going to happen here but
618:42 - character pointers are special in that
618:45 - if you print them out directory the
618:48 - compiler is going to do its magic and
618:51 - make it possible to print out the entire
618:53 - string that is stored in p message here
618:56 - that's how character pointers are
618:58 - special and you really need to be aware
619:00 - of this because this is going to come in
619:02 - handy many times just to emphasize that
619:06 - this is going to be expanded into an
619:08 - array of constant characters if we try
619:11 - to modify
619:12 - something inside p message here for
619:15 - example we try to change the h into a b
619:18 - we can try to do that because p message
619:20 - is pointing to the first character so we
619:23 - can try to dereference and assign a new
619:26 - value and if we do that we're going to
619:28 - get a compiler arrow or even worse we
619:31 - might get a crash at run time so this is
619:34 - something you shouldn't really do and
619:36 - you should really flag
619:38 - your p message here as the cost card
619:41 - pointer and that's going to prevent you
619:43 - from doing things like this which may
619:45 - turn out to be very bad but most
619:47 - compilers are going to even prevent you
619:50 - from compiling this thing in modern
619:52 - times for example if you are using a
619:55 - very recent version
619:57 - of visual studio you're going to get a
619:59 - compiler error but i don't believe gcc
620:02 - is going to give us a compiler error so
620:04 - we will have to try this out and see how
620:07 - it behaves but the message is if you
620:10 - have to do something like this make sure
620:12 - you use the cost car pointer and you're
620:15 - going to be playing on the safe side
620:17 - okay now i think you know enough about
620:19 - character pointers what if we want our
620:21 - users to be able to change this string
620:24 - and make it be something else for
620:26 - example change the first character here
620:28 - into a b well in that case don't use
620:31 - character pointers use regular arrays
620:34 - like we have seen before so you can set
620:37 - up an array like this it's going to be a
620:40 - character array and you can initialize
620:43 - it with the string literal and this is
620:45 - going to allow you to modify things
620:47 - inside so if we do something like this
620:50 - we will get the message printed out and
620:52 - the message is going to be tailored
620:54 - because we changed the edge to be
620:57 - a t and this is going to work so this is
621:00 - something you really need to be aware of
621:02 - but character pointers are very helpful
621:05 - in many cases and in most cases you just
621:07 - want to store the string and print it
621:09 - out you're not interested in changing it
621:12 - so that's why this is going to come in
621:13 - handy in a lot of occasions now that you
621:17 - know this we're going to head over to
621:18 - visual studio code and actually try this
621:20 - out okay here we are in our working
621:23 - folder the current project is pointer to
621:26 - car that's what we are exploring here so
621:29 - we're going to grab our template files
621:31 - and put them in place and we are going
621:34 - to open this thing into visual studio
621:36 - code and we're going to jump into here
621:38 - and set up our first const car pointer
621:42 - let's do a car pointer to see how this
621:44 - thing behaves we're going to call this
621:46 - message and we're going to initialize
621:48 - this with our trusty message here hello
621:52 - world okay once you do something like
621:54 - this your string is going to be referred
621:56 - to
621:57 - by message let's try and compile this
621:59 - and see that gcc is happy we can compile
622:02 - with gcc
622:04 - and uh it's going to tell us we can't
622:06 - really do that and this is really good
622:09 - for base converting a string to constant
622:11 - card pointer so what we are doing really
622:14 - is making an array of const characters
622:19 - and refer to it as a car pointer and
622:22 - this is not going to work this is a good
622:24 - thing so you can't really do this and
622:26 - this is a good thing
622:28 - and let's try and see if visual studio
622:32 - can actually do this we're going to
622:34 - build with msvc in this case let's do
622:37 - read to rooster before we do that we can
622:40 - right click to add and say delete
622:43 - let's click to it first
622:45 - make sure it is selected and hit delete
622:48 - to remove it
622:49 - move to recycle bin in this case
622:52 - now we're going to clear here let's
622:53 - bring up our terminal again
622:56 - and we're going to clear
622:58 - and we're going to build with gcc
623:02 - we're going to choose the msvc compiler
623:05 - if you're trying to build this
623:08 - world finish it
623:10 - with errors and the error is going to be
623:12 - basically the same thing this line here
623:15 - won't work what we can do is make this
623:17 - cost and make it super clear
623:20 - that message here is going to point to
623:23 - an array of const car
623:26 - if we try to build again i think we're
623:27 - going to be good now so let's try and do
623:30 - that
623:31 - we're going to build with msvc this time
623:35 - and world finished successfully
623:38 - now this is really cool and we can print
623:40 - this out we can say sddc out
623:42 - message
623:44 - and we're going to say message
623:49 - and this is going to work
623:51 - let's go back to gcc because that's my
623:53 - favorite compiler and you see that the
623:55 - compiler from visual studio is going to
623:57 - clutter our folder here with a lot of
623:59 - files
624:00 - we don't want that what i'm going to do
624:02 - i'm going to select all this collector
624:04 - here and remove that and i'm going to
624:06 - hit delete with the right click
624:09 - and it's going to go away
624:11 - we're going to go back to gcc and use it
624:14 - and build with gcc
624:16 - the build is going to go through because
624:18 - we qualified our character pointer with
624:21 - cost here and everything is going to be
624:24 - good be sure
624:25 - you know what is happening here because
624:28 - this kind of problems can be really hard
624:31 - to solve okay now that we have this we
624:33 - can try and change something inside but
624:35 - the compiler is not going to allow it so
624:37 - if we try and do something like this is
624:40 - not going to work because message is a
624:43 - pointer to closed car
624:45 - and we can't go through this pointer to
624:47 - modify something so we're going to get a
624:50 - compiler arrow this is something you
624:52 - should know but we can add the reference
624:55 - this pointer and print something that is
624:58 - inside and i want you to guess again and
625:00 - see that you can come up with what is
625:02 - going to be printed if with the
625:03 - reference message and print out when we
625:06 - run this program if we have this thing
625:09 - printed out here again we are the
625:11 - referencing the pointer
625:13 - and printing whatever result we get from
625:16 - that remember that this string literal
625:19 - is going to be turned into an array of
625:23 - const cars and the first element of that
625:25 - array is going to be pointed to
625:28 - by this message car pointer here so if
625:32 - we dereference this thing we should get
625:35 - the h here printed out that's what i
625:37 - think we should get
625:39 - let's try and bolt
625:41 - with gcc of course
625:43 - the bolt is going to be good let's clear
625:45 - and run rooster
625:47 - see that message is h this is exactly
625:50 - what we expect here now that we have
625:52 - this working
625:54 - what if we really want this thing here
625:57 - to work what if we wanted to allow our
625:59 - users to go through
626:01 - this message thing and modify what is
626:04 - stored inside because sometimes that's
626:06 - going to be
626:07 - useful okay we wanted to allow our users
626:10 - to modify this trend if you want to do
626:11 - that you can use row character arrays
626:15 - and the way we do that we can say car
626:17 - message one and we can make it an array
626:20 - and initialize that with hello world and
626:23 - once we do this we can go through the
626:25 - angle bracket syntax and modify the
626:28 - first character or whatever character we
626:31 - really want to modify in this string
626:33 - here in this case we are going to target
626:36 - the first so we're going to say message
626:38 - 1 and we're going to grab the index 0
626:42 - because that's going to be the first
626:43 - character here and we're going to assign
626:46 - a new character let's say
626:48 - b like we just said and if we print this
626:51 - out say message one and uh put that out
626:56 - we're going to see what comes out if we
626:58 - run this program we're going to build
626:59 - with gcc
627:01 - so let's do that
627:03 - the world is good so we're good here
627:06 - if we're on we're going to get below
627:08 - printed down and we have successfully
627:11 - changed this thing here so if you don't
627:13 - want to allow modifications to your
627:15 - strength use this thing here if you want
627:18 - to allow modification to your strength
627:21 - use this syntax here and this is really
627:23 - all we had to say
627:25 - in this lecture in this lecture we're
627:27 - going to revisit our idea of a c plus
627:31 - plus program
627:32 - memory map we have seen that the c plus
627:34 - plus development workflow really goes
627:37 - like this we have a program typed out in
627:39 - our ide we pass that through the
627:41 - compiler and we get a binary executable
627:44 - which is a binary representation of the
627:47 - code we have in our c plus plus program
627:50 - you can then run that program on an
627:52 - operating system for example here i am
627:55 - on windows if i double click on my dot
627:58 - exe file for example our applications
628:01 - are called
628:02 - rooster.exe you've seen me run this a
628:05 - thousand times by now
628:07 - if we double click this program is going
628:09 - to be loaded in our computer memory and
628:12 - by memory i mean random access memory
628:15 - the memory that is going to be actively
628:17 - running things when they happen in your
628:19 - computer is different from the hard
628:22 - drive
628:23 - storage that can also be called memory
628:25 - and this can throw off a lot of
628:27 - beginners we are talking about ram here
628:30 - when we mean memory random access memory
628:32 - to be exact if you double click on your
628:34 - program or open it on the terminal like
628:36 - we've been doing the program is going to
628:39 - be loaded in memory and it's going to be
628:41 - stored in a special section of memory
628:44 - called program area and so far we have
628:47 - been thinking that our program is really
628:50 - loaded in real memory on our computer
628:53 - but that's not the case it is an idea of
628:57 - the memory that the program thinks it
628:59 - has but it's not the real thing and i am
629:02 - going to explain but before we explain
629:04 - let me elaborate on the reason why this
629:07 - is done if we have many programs and
629:10 - each program is going to use real memory
629:12 - on our computer we could quickly run out
629:15 - of memory because there are many
629:17 - programs you might even have hundreds or
629:19 - thousands of programs running on your
629:20 - computer you may never have enough
629:22 - memory to run them all if real memory
629:26 - was used by each program
629:28 - so the idea was born
629:30 - to
629:31 - create what is called virtual memory and
629:34 - it is a trick that pulls your program
629:36 - into thinking it is the only program
629:39 - running on your operating systems and it
629:41 - owns or the address space or all the
629:44 - memory on your computer that's what your
629:46 - program thanks and the view that your
629:49 - program has of that memory is called a
629:52 - memory map each program is abstracted
629:55 - into what we call a process you can
629:58 - think of rooster.exe
630:00 - that we have been welding as a process
630:03 - on the system and each process has
630:05 - access to the memory range between 0 and
630:08 - 2 to the power of n where n is the
630:11 - number of bits that your operating
630:14 - system supports for example i am on a
630:17 - 64-bit operating system so the range for
630:20 - my memory is going to be between 0 and 2
630:23 - to the power of 64. and that's a lot of
630:25 - memory my program is going to think that
630:28 - it owns all that all and it can never
630:31 - run out it's going to do whatever it
630:32 - wants if you are on a 32-bit system
630:35 - that's going to be between 0 and 2 to
630:37 - the power of 32 and that's going to be
630:39 - your virtual memory the amount of memory
630:42 - that your program fans that it owns and
630:45 - it happens to be the entirety of your
630:47 - ram that you have on your system each
630:50 - program basically thinks that it owns
630:52 - the entire memory and it can do whatever
630:55 - it wants okay so we have the rio memory
630:58 - which is random access memory and we
631:00 - have virtual memory which is going to be
631:02 - between 0 and 2 to the power of n okay
631:06 - so now we're going to update on the idea
631:09 - of the program execution model because
631:12 - now we know more we know about virtual
631:14 - memory here is our c plus program it's
631:16 - going to go through the compiler and we
631:18 - are going to generate a binary file
631:21 - which is going to be a representation of
631:23 - how things are going to be laid out in
631:25 - memory in our program
631:27 - and if we run the program
631:30 - it is going to go through a section of
631:33 - the cpu called memory management unit or
631:36 - mmu for short so that mmu is going to be
631:40 - basically transforming between the
631:43 - memory map of each process and the radio
631:47 - memory layout that we have in ram what
631:49 - the memory management unit does is
631:51 - really transform between the
631:54 - representation we have in the memory map
631:56 - and the real thing we have in ram the
631:58 - entire program is not loaded in real
632:00 - memory by the cpu
632:02 - only parts of the program that are
632:05 - really going to be used soon unloaded in
632:07 - memory and this is going to make
632:09 - effective use of the memory parts that
632:12 - are not likely to be used are going to
632:14 - be discarded from memory and stored on
632:17 - the hard drive instead and this is
632:18 - really cool please note that the real
632:21 - way these things are done is really
632:23 - complicated but it is buried down into
632:26 - the logic of the cpu and whatever you
632:28 - don't really need to worry about this as
632:30 - a super plus programmer but there are a
632:32 - few things you need to know as we are
632:34 - about to see in this lecture so memory
632:36 - management unit helps out in mapping
632:39 - between
632:40 - the memory map you have in your program
632:42 - basically the idea that your program has
632:46 - of memory and the real thing
632:49 - that we have in memory okay here is a
632:51 - slide that is going to drive this home
632:53 - we have a few programs with their own
632:56 - separate memory maps we have program one
632:59 - through four
633:00 - if we execute them they are going to go
633:02 - through the memory management unit and
633:05 - the memory management unit is going to
633:07 - assign them sections on the real
633:10 - ram that we have in our computer and
633:12 - they are going to be using that section
633:14 - on the real random access memory that we
633:17 - have on our computer the thing is your
633:19 - program is going to really think it owns
633:22 - the entire thing
633:23 - but it's not just going to be using a
633:26 - part of it and the memory management
633:28 - unit is going to be transforming between
633:30 - the idea that your program has and the
633:33 - real memory that we have on our computer
633:36 - and the memory map is a standard format
633:39 - that is defined by the operating system
633:41 - this is why for example you can't take
633:43 - an executable that was set up on windows
633:46 - and directly run it on linux this is an
633:49 - operating system thing the memory map or
633:52 - the structure of your program is defined
633:55 - by the operating system that is going to
633:57 - be running that program so all program
634:01 - written for an operating system must
634:03 - conform to the memory map that is
634:05 - defined by that operating system so all
634:08 - programs on windows if you had a way to
634:11 - go in and look at the memory map they
634:13 - are going to be pretty similar so we
634:15 - have been talking about the memory map
634:17 - but
634:18 - what does it look like
634:20 - well here is a slide that is going to
634:22 - try and clear that out so we're going to
634:25 - have a bunch of memory locations from 0
634:27 - all the way to 2 to the power of m
634:29 - and the memory map is really divided
634:32 - into a lot of parts for example we have
634:34 - the text section we have the data
634:36 - section we have the heap stack and
634:38 - system
634:39 - and this is one view you can have on
634:41 - this there are a few different versions
634:43 - of this slide that you're going to see
634:45 - on the internet but what is really
634:47 - important is stack and hip for our
634:50 - purposes here stack is what is going to
634:53 - store our local variables thank the a
634:56 - that we have here in main bc thanks we
634:59 - had inside functions those things are
635:01 - stored inside the stack section of our
635:05 - memory map
635:06 - besides the stack we also have the hip
635:08 - which is going to be the location where
635:10 - we get additional memory we can use to
635:13 - make things better for our program we
635:16 - also have the text section which is
635:17 - going to load the actual binary of our
635:20 - program so that the cpu can execute it
635:23 - but we're not going to worry too much
635:24 - about this section in this course
635:26 - because it is out of scope for
635:28 - what we are trying to do here we are
635:31 - going to focus on stack and hip because
635:33 - hip is actually going to be very
635:35 - important from the next lecture when we
635:38 - start talking about dynamic memory hip
635:41 - is going to be additional memory that
635:43 - you can use in your program if you run
635:45 - out of stack memory and we're going to
635:47 - see a few other reasons why you might
635:49 - want to use this as we progress in this
635:51 - chapter so our memory map is going to
635:54 - have a lot of parts but the parts that
635:57 - we really care about in this course are
635:59 - stack and heap this is really all we set
636:02 - out to do in this lecture i hope you
636:04 - have a better idea of the memory map and
636:06 - how this really works we introduced
636:09 - another view that you can have on how
636:11 - your c plus plus program is executed and
636:14 - i hope you have a better idea of the
636:16 - memory system and we are going to start
636:18 - and see how you can work with dynamic
636:21 - memory allocation which is going to
636:23 - really use the heap
636:25 - starting in the next lecture
636:27 - go ahead and finish up here and meet me
636:30 - there
636:30 - in this lecture we're going to start and
636:32 - learn about dynamic memory allocation
636:36 - and this is a technique we can use to
636:38 - start using hip storage that we have in
636:42 - the memory map of our c plus plus
636:44 - program we can use that to get
636:46 - additional memory we can use and do
636:48 - stuff if stack memory isn't enough for
636:51 - our purposes this is how we have been
636:54 - using pointers so far for example we
636:56 - have a variable we set up a pointer and
636:58 - we store the address of the variable n
637:00 - so we can go ahead and use this pointer
637:03 - to manipulate the variable or do all
637:06 - kinds of crazy things if you go down
637:08 - here we have a pointer p number one
637:11 - and we have a number one variable and we
637:14 - can store the address of number one into
637:16 - this pointer it's really the same thing
637:18 - like we have on top here but the pointer
637:21 - is not initialized at declaration here
637:24 - and you have to make sure you put
637:26 - invalid data and one thing i haven't
637:28 - really stressed enough is that it is
637:30 - really bad
637:32 - really bad to try and use a pointer that
637:34 - is not initialized for example here we
637:37 - have p number two which is a pointer it
637:39 - is not initialized it contains junk
637:43 - and we try and write into it okay so try
637:47 - to think about what we really are doing
637:49 - here this is a pointer that we have set
637:51 - up we haven't really initialized that so
637:54 - it's going to contain whatever address
637:56 - is possible it can contain an address
637:58 - that is used by another program it may
638:00 - contain an address that is being used by
638:02 - the operating system it's not your
638:04 - address to mess with and here we are
638:07 - actually trying to mess with that by
638:09 - storing in a 55 so this is going to
638:13 - cause the crash possibly or even
638:16 - corrupt data that is being used by other
638:18 - people so don't do this another thing is
638:21 - to try and use a pointer that is
638:23 - initialized to know for example here we
638:25 - have a pointer p number three and it is
638:29 - braced initialized this is going to
638:31 - initialize it to null pointer but we are
638:34 - trying and storing in a value here so
638:37 - this is also going to be bad it's not
638:39 - granted what you're going to get
638:40 - actually c plus doesn't give you any
638:43 - guarantees this is called undefined
638:45 - behavior so you're going to get a crash
638:47 - and don't do it as a good practice the
638:50 - first thing you should do is initialize
638:51 - your pointers
638:53 - before you use them you can initialize
638:55 - them with no pointer and make sure that
638:58 - you are
639:00 - modifying valid addresses into those
639:02 - pointers if you don't know what is in a
639:04 - pointer don't use that pointer because
639:06 - bad things can happen okay rule number
639:09 - one don't try to use a pointer that you
639:12 - didn't initialize
639:13 - rule number two don't try to work with a
639:16 - pointer that is pointing to no ptr
639:19 - that's going to give you bad things you
639:21 - don't want to really deal with okay so
639:23 - far we have been using memory that lives
639:26 - on the stack section of our memory map
639:28 - we were using variables that we have
639:30 - declared in the main function we were
639:32 - using the variables that we have
639:34 - declared inside some functions and
639:37 - that's all stuff that live on the stack
639:39 - now we want to see how we can use the
639:41 - hip okay let's take a closer look at our
639:44 - memory map we have the stack we have the
639:46 - heap
639:47 - and the differences between these two
639:49 - guys are
639:50 - laid out here
639:52 - the stack memory is finite so you don't
639:55 - have infinite memory but the same is
639:58 - true for the heap but hip is additional
640:00 - memory that you can use if you don't
640:03 - want to run out of stock memory for a
640:05 - stack memory the developer isn't in full
640:08 - control of the memory lifetime so if you
640:11 - declare something on the stack for
640:13 - example if you say int var1 and you
640:16 - initialize that to 23 you don't control
640:19 - when that variable is wiped out of
640:22 - memory the variable is going to be
640:24 - killed when the scope in which it was
640:26 - declared is going to run out
640:29 - and you developer don't really say when
640:32 - the variable dies and sometimes you
640:34 - really want to control
640:36 - when your variable dies so this is a
640:38 - limitation we have with the stack memory
640:40 - okay so for stack memory lifetime is
640:42 - controlled by the scope mechanism we
640:44 - just say that for heap the developer is
640:47 - in full control of when the variable
640:50 - comes to life and when the variable dies
640:53 - and this is a benefit you might have
640:55 - with heap storage and you might want to
640:57 - use this and we're going to see how we
640:59 - can use that in the next few lectures
641:01 - okay so make sure you understand the
641:03 - difference between stack and hip here if
641:05 - you look at the example here we have a
641:07 - variable which is called locoscope var
641:10 - it is stored within this block delimited
641:13 - by the curly braces and the variable is
641:16 - going to come to life when this
641:17 - statement is executed but it is going to
641:20 - die
641:21 - when we hit the closing curly brace here
641:24 - so the lifetime of this variable is
641:26 - controlled by the scope mechanism but it
641:29 - is possible to use dynamic memory or use
641:33 - memory on the heap and we're going to
641:34 - see a syntax you can use to do that the
641:37 - first thing we want to do it to set up
641:38 - employer that is going to be pointing to
641:41 - that heap allocated memory the way you
641:44 - do that you set up a pointer here we
641:45 - have p number four we initialize it with
641:48 - no ptr
641:50 - but what we do to allocate memory is the
641:52 - second statement here we say p number
641:54 - four and we say new end
641:58 - the moment this statement is going to be
642:00 - executed the operating system is going
642:03 - to allocate a piece of memory on the
642:06 - heap the memory is going to be large
642:07 - enough to accommodate for an integer so
642:10 - it's going to be four bytes long
642:12 - and it is your memory now your program
642:14 - can use it to do whatever it wants and
642:16 - no other program on the system can use
642:19 - this piece of memory so it is going to
642:21 - be yours until you explicitly return
642:25 - this piece of memory to the system and
642:27 - we're going to see how you can do that
642:29 - in a minute once this memory is yours
642:31 - you can use it you see here we already
642:33 - referencing the memory and the story
642:35 - again is 77 and if we're trying to print
642:37 - this 77 we're going to get it printed
642:39 - out okay this is how you can use dynamic
642:41 - memory and when you do this
642:44 - things are not being stored on the stack
642:47 - things are being stored on the heap i
642:49 - really hope you understand this because
642:51 - it is very important okay so here is our
642:54 - view of stack and heap so if you use new
642:58 - to allocate for memory stuff are going
643:00 - to be stored in this hip section here of
643:03 - your memory map here is another example
643:06 - to try and understand the lifetime of
643:08 - our variables docovar again is limited
643:11 - to this scope it is going to come into
643:13 - life when this statement here is
643:15 - executed and it is going to die when we
643:19 - run out of this scope here so if you try
643:21 - executing code out of this scope locovar
643:24 - is no longer going to be available you
643:26 - can't use it but that's not the case for
643:29 - locro ptr var because this is a pointer
643:33 - it lives on the heap
643:35 - and if you go out of this scope the
643:38 - memory is still going to be yours if you
643:40 - have a way you can access it and use it
643:42 - you're going to be able to use it and it
643:44 - is going to be yours until you decide to
643:48 - return it to the operating system so we
643:50 - have been talking about returning the
643:52 - memory to the system
643:54 - how do we do it well you use the delete
643:57 - keyword in c plus plus here we have our
644:00 - memory which is allocated using new and
644:03 - so the operating system is going to give
644:05 - us a new piece of memory it is going to
644:07 - be four bytes because we're going to
644:09 - store in an integer and we are going to
644:11 - be pointing to that memory through p
644:14 - number four here we can use this memory
644:16 - however we want through the referencing
644:18 - and do all kinds of crazy things and
644:20 - when we are done with this memory we are
644:22 - going to say delete p number four and
644:24 - this statement is going to return the
644:26 - memory to the operating system the
644:28 - memory is no longer going to be hours
644:30 - after this statement and a good thing to
644:33 - do after you release your memory is to
644:35 - reset it to
644:37 - no ptr so that other people know that
644:40 - you don't really have any valid data in
644:43 - that memory because if you try to use a
644:46 - deleted
644:47 - memory section bad things are going to
644:50 - happen that's not going to be your
644:51 - memory we're going to fall into the same
644:53 - problem of trying to use an
644:55 - uninitialized piece of memory don't do
644:58 - that so whenever you release memory also
645:01 - reset it to no ptr to play it safe we
645:04 - can also initialize our pointers with
645:06 - dynamic memory when we declare them and
645:09 - this is how you can do it we say p
645:11 - number five and we initialize that with
645:14 - new and this is going to give us a new
645:15 - piece of memory on the heap and it is
645:18 - going to be pointed to by p number five
645:21 - we get the same thing here but uh here
645:23 - we are just pointing in new values and p
645:25 - number six and p
645:27 - number seven the memory locations on the
645:29 - heap are going to be containing 22 and
645:32 - 23 for p number six and p number seven
645:35 - and here we have a few examples of how
645:38 - we can print the contents of these
645:40 - memory locations on htdc out
645:43 - and after you are done using your hip
645:46 - memory you're going to release it using
645:49 - the delete keyword and you are going to
645:51 - reset that to no ptr to really play it
645:54 - safe this is how you should use dynamic
645:57 - memory allocated on the heap another
646:00 - thing you should know is that it is
646:02 - really bad to call delete twice on a
646:05 - pointer so here we have a memory
646:08 - location that we allocate on the heap we
646:10 - stored this in a pointer and
646:12 - we are trying to use it here in sddc
646:15 - outputting whatever is inside
646:18 - and if we delete it for the first time
646:20 - that's going to be cool it is going to
646:21 - be returned to the system but if you try
646:23 - to delete it for the second time you're
646:26 - going to get a crash don't do this this
646:28 - is really bad okay now that we have a
646:31 - slightly clearer idea about pointers and
646:34 - dynamic memory allocation i think it is
646:36 - time we went to visual studio code and
646:38 - actually played with a few of these
646:40 - concepts here we are in our working
646:44 - directory the current project is dynamic
646:46 - memory allocation we're going to grab
646:48 - our template files and we're going to
646:50 - put them in place dynamic memory
646:52 - allocation let's do that and we're going
646:55 - to open this in visual studio code the
646:57 - first thing we're going to do is review
646:59 - how we have been using players so far
647:02 - we have been using them like this we had
647:04 - a variable stored somewhere on the stack
647:06 - again this is the stack memory that we
647:09 - are using here and we
647:11 - stored addresses of some variables you
647:14 - know pointers something like this and we
647:16 - could go through the pointer to
647:17 - manipulate that memory location for
647:19 - example
647:20 - we can print the address of that memory
647:22 - we can even the reference and print the
647:24 - value in here
647:26 - by doing something like we do here and
647:29 - we are not printing here so let's say
647:31 - that and say p number we can do
647:33 - something like this and we have been
647:35 - doing this quite a lot so far we can
647:38 - also have a piece of memory that is
647:40 - uninitialized and we store the address
647:43 - of some variable in that piece of memory
647:46 - and we can do the same thing for example
647:47 - if we print p number one we're going to
647:49 - get the value 12 printed out here and we
647:52 - could run this so let's try and do that
647:54 - we're going to bring up a terminal first
647:56 - and close this pane so that we have some
647:58 - breathing room and we are going to build
648:01 - with gcc like we always do
648:04 - we're going to build successfully going
648:06 - to clear and run rooster and we're going
648:08 - to see that we have these things printed
648:10 - out here the variable we have in here is
648:13 - 22 so we're going to get that if we
648:14 - print the variable directly
648:17 - if we print pointer we're going to get
648:18 - the address printed out we can also go
648:20 - through the address of operator to print
648:23 - the address of this variable here but we
648:26 - can also print our value through the
648:28 - referencing our pointer and we can get
648:31 - access to it here down here we have a
648:33 - pointer that is not initialized so it
648:35 - will contain a junk address that you
648:37 - shouldn't really use but we're not going
648:39 - to do that because we're going to store
648:41 - in the address of number one here and we
648:44 - can manipulate the value here through
648:47 - the pointer using the the reference
648:50 - operator here and if we print this p
648:52 - number one we're going to get 12 printed
648:54 - out this is pretty cool okay so this is
648:57 - how we have been using pointers so far
649:00 - let's comment this out because we're
649:02 - going to see some other things okay
649:04 - before we really look at how dynamic
649:06 - memory works we are going to show you a
649:08 - few bad things you need to be aware of
649:11 - so let's put in a piece of code for us
649:13 - to play with
649:15 - and here we are saying that writing into
649:18 - uninitialized memory is really bad so
649:21 - here we have a pointer it is
649:23 - uninitialized and we are trying and
649:25 - directly right into it through the
649:28 - reference and this is going to be bad
649:30 - you see that
649:31 - visual studio code is not complaining it
649:34 - thinks that we know what we are doing
649:36 - here and it's not going to warn us but
649:39 - this pointer could really be pointing
649:41 - anywhere including operating system
649:43 - specific memory and here you may be
649:46 - trying to
649:47 - modify things that your operating system
649:50 - is going to need so clearly the
649:53 - operating system is not going to be
649:54 - happy about this and the bad things can
649:57 - happen to this program
649:59 - so now we have this memory location
650:01 - we're going to try and write into it and
650:03 - we're going to see what happens if we
650:04 - run this program for now let's try and
650:07 - take this little section here and
650:08 - comment it out
650:10 - and we want to see what happens on the
650:13 - program here the code here that we might
650:16 - want to run
650:17 - let's try and build it with gcc we're
650:20 - going to run the task to do that
650:23 - the build is going to be good you see
650:24 - that we don't even get a compiler error
650:26 - and if we're trying to run rooster you
650:28 - see that the program is going to try and
650:30 - run you know the operating system is
650:32 - going to say this guy doesn't know what
650:34 - they are doing and i am going to close
650:37 - them you see that it's not even
650:39 - running
650:40 - this statement here let's go on top here
650:43 - and put in an sddc out statement so that
650:46 - we can really see
650:47 - where this program is failing
650:50 - let's say that stdc out
650:52 - writing in the 55
650:54 - okay so this is what we have we have a
650:56 - few statements other than and we want to
650:58 - see if we actually get to run these two
651:01 - things to see
651:03 - where the program is actually failing
651:06 - we are going to build it again with gcc
651:09 - and we are going to clear
651:11 - and run rooster you see that it's going
651:13 - to say writing in a 55 but this
651:17 - statement here is going to fail because
651:18 - we are trying to ride into memory that
651:22 - is not ours and the operating system is
651:24 - going to stop us so our program is
651:27 - crashing and it is terminating before it
651:30 - even runs the things that are down here
651:32 - hopefully you can see how bad this is
651:34 - you have designed your program to do
651:36 - things but it is going to stop
651:39 - without having done any of the other
651:41 - things that you have designed below so
651:44 - this is really bad and another bad thing
651:46 - is that
651:47 - you might have allocated some dynamic
651:50 - memory beforehand and your program is
651:53 - going to end before it even releases
651:56 - that memory properly and returns that to
651:58 - the operating system so this is bad you
652:01 - don't want crashes in your programs and
652:04 - don't ever try and use and reference
652:07 - memory that you haven't initialized this
652:10 - is one bad thing we're going to comment
652:12 - this out i hope you really know how bad
652:15 - this is and we're going to go down again
652:18 - and uncomment what we have done here
652:21 - and uh it's going to be another bad
652:23 - thing because we are trying to write
652:26 - into memory
652:27 - initialized to null pqr okay here we
652:30 - have a pointer this is called p number
652:32 - three and it is initialized with no ptr
652:36 - you can think of ptr as an address that
652:38 - says i don't have any valid thing in me
652:42 - don't use me that's what no ptr is
652:44 - saying so we have the pointer
652:46 - initialized to ptr but we are trying to
652:48 - store something in here and you can
652:51 - imagine how bad this is this is memory
652:54 - that isn't really valid the memory
652:56 - itself is saying i don't contain
652:58 - anything valid don't try to use me and
653:00 - if you try to use it bad things are
653:02 - going to happen so if we try and compile
653:05 - this program it is going to compile the
653:07 - compiler is not going to stop us to do
653:08 - something like this
653:10 - and these are some things you need to be
653:12 - aware of in c plus plus but if we try to
653:14 - run it you're going to see that we are
653:16 - also going to get a crash again let's
653:18 - try and put a statement in front of this
653:21 - failing line and uh below this line i
653:24 - can say
653:25 - done writing and i can do
653:27 - stdndl here
653:30 - and both of the programs so that we can
653:32 - see which std statements run and which
653:35 - dot after our program crashes so we're
653:39 - going to clear the world is good and run
653:40 - rooster you're going to see it's going
653:42 - to say what it's doing it's going to try
653:44 - and fail and the operating system is
653:46 - going to kill this program because it is
653:48 - crazy it is doing what it shouldn't
653:50 - really be doing so this is something bad
653:53 - don't do it be aware of this thing okay
653:55 - we're going to comment this out and
653:57 - actually look at how we can dynamically
654:00 - allocate memory from the heap and we're
654:02 - going to put in a piece of code to play
654:04 - with that
654:05 - it's not really complicated we have a
654:07 - pointer we initialize it with no pointer
654:09 - to say that this pointer doesn't point
654:12 - to anywhere valid don't use it and we
654:15 - are
654:16 - calling new and when we do this the
654:19 - operating system is going to give us a
654:21 - new piece of memory on the heap
654:23 - this piece of memory is going to have
654:25 - the size enough to contain it so it's
654:27 - going to be four bytes in memory and we
654:29 - are going to be pointing to that piece
654:31 - of memory using p number four here this
654:34 - is what we are trying to say here the
654:36 - moment we do this we own this piece of
654:38 - memory and nobody else on the operating
654:40 - system can use it so that's something
654:42 - you should know once you have it you can
654:44 - manipulate it through the pointer here
654:46 - so here we can go through the the
654:48 - reference operator and store in 77 and
654:51 - if we print it out we're going to get
654:53 - that printed out here okay this is
654:55 - really cool this is the first time we
654:57 - use hip memory and i am excited about
655:00 - showing you this thanks we're going to
655:02 - try and build this program and the build
655:04 - is going to be good and we are going to
655:06 - clear this
655:08 - and if we run rooster we should see a 77
655:11 - pretty down let's do that
655:13 - i'm going to get our 77 but this 77 is
655:16 - stored on the heap now it is not stored
655:19 - on the stack and this is really
655:21 - really cool we can control when this
655:24 - variable comes alive by allocating
655:27 - memory on the heap and we exactly
655:29 - control when this variable dies
655:32 - if we want and we're going to see how we
655:34 - can kill this variable from memory but
655:36 - for now just take a moment and
655:39 - appreciate how good it is to be able to
655:41 - allocate stuff on the heap it is really
655:43 - cool now that you have used the memory
655:46 - it is really time to return it to the
655:48 - system because we have no more use for
655:50 - it the way you release memory to the
655:52 - system is to call the delete keyword
655:56 - and say the pointer pointing to the
655:58 - memory that you are trying to release to
656:01 - the system so we're going to say p
656:03 - number four here let's bring this down a
656:05 - little bit so that you can see the
656:07 - entire story so we have a pointer here
656:09 - and it is pointing to dynamically
656:11 - allocated memory from the heap this
656:13 - memory is four bytes
656:15 - large because it stores an integer
656:18 - we have it dynamically allocated we use
656:21 - it here and it is time to return it to
656:24 - the operating system okay i hope this is
656:26 - clear the moment you call the delete
656:28 - keyword
656:30 - now the memory is going to be containing
656:32 - some junk and you don't want to really
656:34 - use that anymore if you try to use it
656:37 - it's not your memory you're going to run
656:39 - into trouble so for example after we
656:41 - delete this memory if we try to use it
656:43 - i'm going to show you here i think i can
656:45 - let's say p number four and um storing
656:48 - something notice that we are using the
656:50 - the reference operator and let's try and
656:53 - put in a 45 why not
656:55 - so let's build this with gcc as we
656:58 - always do it is going to world compiler
657:00 - is not going to stop you from doing
657:02 - something like this
657:03 - writing into memory that you have
657:05 - already
657:06 - released to the system but we're going
657:08 - to see what happens so run rooster and
657:12 - it is going to say done writing but you
657:14 - see that the program has really crashed
657:17 - because here we are trying to write into
657:20 - memory that we don't really own and this
657:22 - is bad don't do this so the moment you
657:25 - delete the memory or the moment you
657:27 - return the memory to the operating
657:29 - system it is good practice to reset that
657:32 - memory to no ptr so we're going to say p
657:35 - number four and
657:36 - make sure it contains no ptor
657:40 - at least when we do this other people
657:42 - have a chance to check and see that
657:45 - that's valid memory before they use it
657:47 - that's the use of resetting your memory
657:49 - here so this is something you should do
657:51 - again the flow to use dynamic memory is
657:54 - really simple you set up a pointer that
657:56 - is going to point to your memory
657:58 - you're going to
657:59 - allocate the memory from the heap using
658:02 - the new operator you're going to specify
658:04 - the type you want to allocate memory for
658:07 - the operating system is going to give
658:08 - you that memory and you're going to be
658:10 - pointing to that memory with your
658:12 - pointer you are going to manipulate that
658:14 - memory using your pointer and doing all
658:16 - kinds of crazy things and after you are
658:19 - done with that memory you're going to
658:20 - release it to the operating system and
658:23 - please
658:24 - please remember to reset your pointers
658:27 - after you have deleted them like this
658:29 - that's going to make your life a whole
658:31 - lot easier and other developers are
658:34 - going to thank you for doing this
658:36 - when they get to use your code because
658:38 - your code is going to be much safer to
658:40 - work with okay let's comment this out
658:43 - and show you another example of what
658:45 - cool things you can do with dynamic heap
658:47 - memory we're going to go down and put in
658:49 - a piece of code and show you that you
658:51 - can actually
658:52 - dynamically initialize your pointers at
658:55 - declaration this is something you can do
658:57 - the first one is not initialized so it's
659:00 - going to contain junk volume p number
659:02 - five if we try to print it we're going
659:03 - to get some junk address print it out p
659:06 - number six we're going to dereference it
659:08 - and print the value inside so we're
659:10 - going to see that and we can do the same
659:12 - thing for p number six and p number
659:14 - seven after we are done using the
659:16 - pointers we are going to release the
659:18 - memory here and notice that we are
659:20 - resetting the pointers to no pointer to
659:22 - say that they don't really contain
659:24 - anything useful don't use them make sure
659:27 - you have something valid and before you
659:29 - use them this is the meaning here if
659:31 - you're trying to run the program you can
659:32 - guess what we're going to see so try and
659:34 - guess and we're going to build we're
659:36 - going to weld successfully going to
659:38 - clear
659:39 - clear not clear and we're going to run
659:42 - rooster and we're going to see that p
659:44 - number five contains some junk address
659:46 - okay and if we try to dereference that
659:49 - we're going to get a junk value this is
659:51 - really not useful don't use this value
659:54 - because you didn't put this value in in
659:56 - the first place you're going to see that
659:58 - p number 6 is going to point to some
660:00 - other address but we're going to have a
660:02 - valid value inside because we have put
660:05 - that n at initialization here the same
660:09 - is true for p number seven it's going to
660:10 - point to some address and we're going to
660:13 - have 23 and because we put in our 23.
660:17 - this is how you really use these
660:18 - pointers another thing i want you to
660:20 - know is that even if we have called
660:23 - delete and reset these pointers they are
660:26 - still available for use in our program
660:28 - so if we want we can reuse these
660:30 - pointers so for example p number five we
660:32 - can take it
660:34 - and use it to allocate new memory so we
660:36 - can say new and
660:38 - and uh store an 81 why not
660:42 - okay so we can go down here and use that
660:44 - this is going to be valid c plus plus
660:46 - code
660:47 - okay take a moment and look at it it is
660:49 - p number five not p number
660:52 - and the visual studio code is going to
660:54 - take this because it is valid c plus
660:56 - plus code the memory has been returned
660:59 - to the operating system and the pointer
661:01 - has been reset to no ptr but we can
661:04 - reuse this end pointer to allocate new
661:06 - memory so we are allocating new memory
661:09 - on the heap the memory is going to be
661:11 - four bytes because it is
661:14 - going to contain an integer and we are
661:16 - using this pointer
661:18 - to point to that new memory so this
661:20 - pointer is being reused it was pointing
661:22 - to
661:23 - the memory that we allocated here which
661:25 - was uninitialized and we are using that
661:28 - to point to new
661:30 - memory location on the hip i really want
661:32 - you to understand these things because
661:35 - many beginners get them wrong and it is
661:37 - hard to correct these things in your
661:40 - mind once you have a wrong idea about
661:43 - them in the first place so make sure you
661:45 - understand this so if we print this
661:47 - we're going to get the 81 printed out
661:50 - but
661:51 - we have allocated new memory we have to
661:53 - remember to release it again so we have
661:55 - to come and say delete
661:58 - p number five and we need to reset it to
662:01 - no pointer
662:03 - and we're going to do that
662:04 - right here
662:05 - once we do this we're going to be
662:07 - playing it safe let's try and run and
662:09 - see that we see the at1 printed out
662:12 - we're going to build with gcc the world
662:14 - is going to go through
662:16 - and we are going to clear and run
662:18 - rooster and you see that we see our 81
662:21 - and we don't have any crazy crash for
662:23 - example to prove that we don't have a
662:25 - crash we can say that our program is
662:28 - ending well
662:30 - is ending well
662:32 - and uh
662:33 - we're going to know
662:34 - if the program has actually reached the
662:37 - end before it dies we're going to build
662:40 - again
662:42 - with gcc
662:44 - and we're going to clear
662:46 - and run rooster and you're going to see
662:49 - that the program is ending well
662:51 - the other thing i want you to see is
662:53 - that it is really bad to call delete
662:57 - twice on a pointer again it is really
663:01 - bad to call delete twice on a pointer
663:04 - don't do that okay we're going to see an
663:06 - example of that here
663:08 - so we're going to allocate new memory
663:10 - using p number five why not so we're
663:12 - going to say p number five and we're
663:14 - going to say new and going to allocate
663:17 - new memory on the heap and we're going
663:18 - to store in a 99 in that memory we can
663:22 - print out the 99 so we're going to say
663:24 - and after we are done using this memory
663:26 - we are a good c plus plus citizen so
663:28 - we're going to call delete
663:31 - and say p number five
663:33 - okay this is good it is going to work if
663:35 - we will then run we're going to get what
663:38 - we expect we should get a 99 printed out
663:42 - last in our program before it ends and
663:45 - we see that printed out here program
663:47 - ending well this is really cool
663:49 - but if we try to call delete twice
663:53 - and say p number five again
663:56 - and try to boil you see that the
663:57 - compiler is not going to stop us because
663:59 - it thanks
664:00 - we know what we are doing
664:02 - so this is something you need to be
664:04 - aware of in c plus plus if we run this
664:06 - program
664:07 - you're going to see ah the program is
664:09 - not going to end well the c plus plus
664:11 - runtime or the operating system is going
664:14 - to get here and see uh this guy is
664:16 - trying to release memory twice and i
664:18 - don't do that this is a bad program i am
664:20 - going to kill it and it is going to be
664:22 - killed the bad thing again is that
664:24 - anything you have in your program after
664:27 - these lines is not going to run because
664:29 - the operating system is going to kill
664:31 - your program at this line here so if you
664:34 - had memory allocated that you planned to
664:37 - release later on in your program your
664:39 - memory is not going to be released
664:41 - because those statements to release the
664:43 - memory will never be run this is where
664:45 - the program is going to be killed the
664:47 - operating system is going to see that
664:49 - you are a rug program and it is going to
664:52 - kill the program so don't delete your
664:55 - memory twice this is something you
664:57 - should really watch out for and you
664:59 - might think uh-huh i know this why would
665:01 - i call delete twice in a single line
665:03 - here well you may not do it like this
665:06 - but your program might have multiple
665:08 - files
665:09 - where you have pointers pointing to the
665:11 - same memory and if you try to delete
665:13 - that memory twice you're going to get
665:15 - this error and this is really good so
665:17 - watch out for these kinds of things and
665:19 - we're going to see different ways you
665:21 - can
665:22 - use to really make sure you are doing
665:24 - things right in c plus plus this is
665:26 - really all we set out to do in this
665:28 - lecture giving you first-hand practice
665:31 - on how to do dynamic memory allocation i
665:34 - hope you found this useful we are going
665:37 - to stop here in this lecture and the
665:38 - next one we're going to learn about
665:40 - dangling pointers
665:42 - go ahead and finish up here and we'd be
665:44 - there in this lecture we're going to
665:46 - focus on dangling pointers and show you
665:49 - how they can be bad a dangling pointer
665:51 - is a pointer that is pointing to a valid
665:54 - address and we have seen a few examples
665:56 - of this already but in this lecture
665:58 - we're going to focus on that and show
666:00 - you common solutions we can apply to
666:02 - these problems here and download
666:04 - pointers are really bad they are going
666:06 - to lead you programs to undefined
666:09 - behavior and we have seen that that can
666:11 - crush your program
666:13 - many times there are three kinds of
666:16 - dangling pointers we're going to look at
666:17 - in this lecture the first one is a
666:19 - pointer that is not initialized the
666:22 - second one is a deleted pointer and the
666:25 - third case may come if you have multiple
666:28 - pointers pointing to the same memory
666:29 - location and let's look at these cases
666:32 - one by one here we have an example of a
666:35 - pointer that is not properly initialized
666:37 - this is p number five it is a pointer to
666:40 - end
666:40 - and it is not initialized it doesn't
666:42 - really point anywhere and it is going to
666:44 - contain junk address if we try to
666:47 - dereference it we're going to get bad
666:49 - things to happen because we don't really
666:51 - know which address is stored in there
666:54 - and putting something in there might
666:56 - lead to a crash so this is something you
666:58 - need to watch out for the second kind of
667:01 - dangling pointer that can really lead
667:03 - you to bad places is a deleted pointer
667:06 - here is a pointer p number one it is
667:09 - initialized with dynamic memory and we
667:12 - can use it for example here we are
667:14 - dereferencing the pointer and printing
667:16 - the value inside and deleting the
667:18 - pointer after we delete the pointer
667:21 - don't really use it before you properly
667:23 - initialize it with some kind of memory
667:26 - if we try to do that this is going to be
667:28 - undefined behavior and your program
667:31 - might crash so make sure you don't do
667:33 - something like this another case is if
667:36 - you have multiple pointers pointing to
667:38 - the same address and here is a simple
667:40 - example to drive the point home we have
667:43 - pointer three which is pointing to
667:46 - dynamic memory here we are using new ant
667:49 - in our braced initializer and we are
667:52 - putting value 83 in that pointer
667:55 - location
667:56 - and here we set up another pointer p
667:58 - number four and we initialize that with
668:01 - another pointer and if we print these
668:03 - things out we're going to get that they
668:05 - contain the same address and they
668:07 - contain the same value we're going to
668:08 - see that
668:09 - if we delete p number three
668:12 - and try to use p number four later we're
668:15 - going to get problems because this
668:16 - memory has been deleted by p number
668:19 - three
668:20 - but p number four is still pointing to
668:22 - that and if it tries to use that it's
668:24 - going to be deleted memory basically and
668:27 - we're going to get undefined behavior so
668:29 - be sure you know these problems and try
668:32 - to avoid them in your programs okay
668:34 - these are problems but how do we solve
668:37 - them well there are a few solutions one
668:40 - is to always initialize your pointers
668:42 - the moment you declare a pointer make
668:44 - sure it is initialized if you don't know
668:46 - what you can initialize that pointer
668:48 - with put in null pointer first and then
668:51 - you're going to put in an address later
668:53 - when you have a clear idea of which
668:56 - address you can store in the second
668:57 - solution is to reset your pointers to
669:00 - now ptr after you delete the memory
669:04 - that's the second thing you should do
669:06 - every time you call delete that's going
669:08 - to give other developers or even
669:10 - yourself a chance to check and see if
669:12 - that memory location
669:14 - contains a valid address before you do
669:16 - that and for multiple pointers pointing
669:19 - to the same address you have to choose
669:22 - and make one pointer the master of the
669:24 - controller of the memory
669:26 - and all pointers are basically going to
669:29 - be slaves which can't release the memory
669:32 - but they can read and do something with
669:34 - that memory that they don't have the
669:36 - task of releasing that memory and here
669:39 - is how you can apply solution one for
669:41 - example we have pointer number five and
669:43 - we're going to brace initialize it this
669:45 - is going to initialize it to
669:48 - null pointer the other thing you can do
669:50 - is initialize the pointer with dynamic
669:53 - memory like we are doing here with p
669:55 - number six and this is going to put in
669:57 - the value and we are going to be playing
669:59 - on the safe side
670:00 - now if your pointers are initialized
670:03 - developers have a chance to check your
670:05 - pointers against no ptr to see that they
670:08 - contain something valid before they use
670:11 - it and if they see that it contains no
670:13 - ptr they are not going to try and use it
670:16 - and this is going to be very safe for
670:19 - the second problem with deleted pointers
670:21 - we are going to reset our pointers after
670:24 - we call delete for example here we have
670:26 - pin number seven initialized with
670:28 - dynamic memory and 82 is stored in we
670:31 - can print it out all do things with it
670:33 - when we delete the memory we're going to
670:35 - reset it to null p2r so that other
670:38 - developers or even ourselves can check
670:40 - this memory against no ptr and if it's
670:43 - different from no ptr we can use it if
670:46 - it's equal to no ptr we're going to
670:48 - leave it alone and do something else
670:50 - this is going to be very safe if you
670:53 - have multiple pointers pointing to the
670:55 - same address like we have here then
670:56 - you're going to have to decide which
670:58 - pointer is the master pointer and other
671:01 - pointers are going to be
671:03 - slave pointers and before use
671:06 - all the other pointers are going to
671:08 - check against the master pointer and see
671:10 - that it contains valid memory because
671:13 - the master pointer has the task of
671:15 - deleting this memory let's go through
671:17 - this and see how this could work in
671:19 - practice
671:20 - so p number five is our master pointer
671:23 - we are setting p number five and
671:26 - initializing it with p number eight we
671:29 - are creating things using p number eight
671:31 - we can either use p number eight or pin
671:33 - urban eye this is going to work but
671:35 - before we use the memory location we're
671:37 - going to check against the master
671:40 - pointer if the master pointer contains
671:42 - no ptr we're not going to use this
671:44 - memory if the master pointer doesn't
671:46 - contain now ptr we're going to use this
671:49 - memory here okay if you go down you see
671:51 - that the master pointer is going to be
671:53 - releasing the memory and if we try to
671:55 - use that memory after it was deleted
671:58 - we're going to see that it contains now
671:59 - ptr and we're not going to be using it
672:02 - this is something cool and it is really
672:04 - easy to implement this safety guidelines
672:06 - in your programs now that you know about
672:08 - this we're going to go to visual studio
672:10 - code and show you this in action okay
672:13 - here we are in our working directory the
672:16 - current project is dangling pointers so
672:18 - we're going to grab our template files
672:21 - pretty quick and put that in our project
672:24 - and we're going to open this in visual
672:26 - studio code we are going to look at the
672:29 - first case of a dangling pointer and
672:31 - this is a pointer that is not
672:33 - initialized properly like p number here
672:36 - if we try to reference it we're going to
672:38 - get something bad to happen
672:40 - so let's see that and let's go down and
672:43 - say that program is ending well just to
672:45 - know that we didn't get a crash because
672:47 - a crash is basically going to terminate
672:49 - your program on the offending line
672:52 - that's what it's going to do so if the
672:54 - program
672:55 - works well and ends well we're going to
672:57 - print this line here
672:59 - let's bring in
673:01 - gcc to build this program and let's open
673:04 - a terminal so that we can
673:06 - run it we're going to clear the world
673:08 - was good
673:09 - and we're going to run rooster
673:11 - you see that the program didn't end well
673:14 - it crashed and it crashed because we are
673:17 - trying to use
673:18 - uninitialized memory when the operating
673:21 - system is going to try and run this
673:23 - thing it's going to see ah this guy is
673:25 - trying to modify memory that doesn't
673:27 - really belong to him it is a road
673:29 - program i am going to kill it and it is
673:31 - going to be terminated on this line here
673:34 - this is really bad
673:35 - you should avoid these kinds of
673:37 - situations so don't do this we are going
673:40 - to comment this out and show you another
673:41 - offending event we can do in our program
673:44 - and that is using a deleted pointer if
673:47 - you do that you're going to get
673:48 - something bad in your programs
673:51 - so here we have a small example we have
673:53 - a pointer to end we initialize this with
673:57 - a dynamic piece of memory and we're
673:59 - going to store in a 67
674:01 - and we can print this out this is going
674:03 - to work pretty well
674:04 - but
674:05 - we delete the memory down here and we
674:07 - try to use it after we have deleted the
674:10 - memory so the operating system is not
674:12 - going to be happy about this because
674:14 - once the memory is deleted it is no
674:17 - longer our memory so we have no business
674:20 - the referencing pointer one and trying
674:22 - to use that here and we're going to get
674:24 - a crush
674:26 - and this is something you should avoid
674:27 - so let's try and build this and show you
674:30 - this in action we are going to clear
674:33 - and run rooster
674:35 - and you're going to see that program is
674:37 - ending well but in some cases it might
674:39 - crash and hopefully this shows you the
674:42 - danger
674:43 - that these things might put you into
674:46 - sometimes your program is going to seem
674:49 - working fine but sometimes when this
674:51 - memory that we are pointing to in p
674:54 - number one here is being used to do
674:56 - something really important by the
674:58 - operating system you are going to get a
675:00 - crash so you're not guaranteed to get
675:02 - the same behavior every time you run
675:05 - your program some of you might be saying
675:07 - aha the program is working here daniel
675:09 - why are you making this such a big deal
675:13 - well it is a big deal because you are
675:15 - not guaranteed to get the same results
675:18 - every time you run this program so be
675:21 - sure you really avoid these kinds of
675:24 - situations let's try and clear and run
675:26 - the program again hopefully we're going
675:27 - to see it crash but we're not okay so
675:30 - let's clear and rebuild again
675:33 - and see that we have a better luck that
675:35 - time
675:36 - that's clear
675:38 - and run rooster it is going to end well
675:41 - but you notice that we are trying to use
675:43 - a piece of memory that has already been
675:45 - deleted and this is bad don't do this
675:48 - make sure you don't do something like
675:51 - this we're going to comment this out
675:52 - again and show you another offending
675:55 - thing we can do with our programs and
675:57 - bad things might happen if you try to
676:00 - have multiple pointers played into the
676:02 - same address and that's what we have
676:04 - here we have p number three and p number
676:07 - four here p number three is allocating
676:09 - new space and it is pointing to it we
676:12 - have an 83 inside and a p number four is
676:15 - initialized with p number three we can
676:17 - do that so these two pointers are
676:20 - basically pointing to the same memory
676:23 - location
676:24 - let's run this and show you that
676:27 - we're going to comment out this delete
676:28 - statement here and run the program first
676:32 - to really prove that they are pointing
676:34 - to the same addresses and they contain
676:36 - the same values let's build and run
676:40 - we're going to use gcc for that
676:43 - and we're going to clear and run rooster
676:45 - and you see that
676:46 - p number three the address is this and
676:48 - it contains an 83 p number four contains
676:51 - the same thanks
676:52 - so let's see what happens if we try to
676:55 - delete using p number three
676:58 - and using p number four later to try and
677:01 - read stuff this is what we are doing
677:03 - here
677:04 - and we're going to see if the program
677:06 - actually gets to end well
677:08 - we're going to build again the world is
677:10 - going to be good let's bring this up and
677:12 - clear and run rooster
677:14 - and you're going to see that the program
677:16 - is also going to end well
677:18 - but we are using a deleted piece of
677:21 - memory here and anything can really
677:23 - happen okay so you might get garbage you
677:26 - might have really any piece of junk
677:28 - inside or you might get a crush in some
677:32 - extreme cases so this is really bad
677:34 - don't do it don't try to use a piece of
677:37 - memory that you have already deleted
677:40 - through a pointer and these are problems
677:42 - you might run into in your programs if
677:44 - you try to use dynamic memory allocation
677:47 - let's look at how we can solve them
677:49 - and the
677:51 - ultimate advice
677:52 - is to
677:53 - make sure you put a little ptr in a
677:56 - pointer if you don't know what that
677:58 - pointer is actually stored at okay let's
678:01 - go down and look at solution one
678:03 - solution one is to initialize your
678:05 - pointer to no pointer every time if you
678:08 - don't have a value you can put in use
678:10 - null ptr that's what we are using here
678:12 - implicitly but we can explicitly put
678:15 - that end because it is good and before
678:18 - you use a pointer you have to check and
678:20 - see if it doesn't contain null pointer
678:23 - this is how we do it if pointer six is
678:26 - different from null pointer we're going
678:28 - to use it if it is equal to no pointer
678:30 - we're not going to use it and we're
678:31 - going to be playing on the safe side and
678:34 - you're going to see that the program is
678:35 - going to end well here if we have a null
678:38 - ptr inside we can say
678:41 - else here
678:42 - and say
678:44 - invalid address okay and that the user
678:47 - is going to know that they are trying to
678:49 - do something really bad so let's try and
678:52 - check against p number five
678:54 - so let's go and store a null pointer in
678:57 - p number six to really try this out and
679:00 - show you that we're going to get this
679:02 - warning if we're trying to use it
679:05 - and we're going to build with gcc and
679:07 - we're going to clear and run rooster
679:10 - you're going to see that invalid address
679:12 - and the program is going to end well
679:14 - and if we try to put this statement
679:17 - somewhere where we're not shaking
679:19 - against
679:21 - no pointer we are going to get a crash
679:23 - so let's comment this out so that it's
679:26 - clear what it is we are running here
679:29 - so if we run this we're going to get a
679:30 - crash we have seen that but let's show
679:32 - this again
679:34 - and really highlight that we are solving
679:37 - the problem here if we run rooster the
679:39 - program is going to crash because we are
679:41 - trying to use
679:43 - uninitialized
679:44 - memory but if we try and check against
679:48 - no ptr like we are doing here let's do
679:50 - that we're going to be playing on the
679:52 - safe side because it's going to tell us
679:54 - invalid address and we're not going to
679:56 - get a crush and the program is going to
679:59 - end well this is really cool so let's
680:01 - try and do that again we're going to
680:02 - world
680:05 - the world is going to be good we can
680:07 - clear and run rooster and the program is
680:10 - going to end well okay so if we have a
680:13 - value inside we're going to get that so
680:15 - let's put that n and say new ant and put
680:18 - in an 87 for example it doesn't really
680:21 - matter what we put in
680:23 - so we're going to build again the work
680:24 - is going to be good and we can run
680:26 - rooster and you see that we are getting
680:29 - a value here if we are not storing no
680:31 - ptlr in p number six and you can do the
680:34 - same checks against p number five but i
680:37 - think this is really enough so this is
680:40 - one way you can avoid dangling pointers
680:43 - the next thing we're going to look at is
680:45 - if we are using a deleted pointer and
680:48 - again the solution is to set a pointer
680:50 - to no ptr
680:52 - after we delete it here we have p number
680:55 - seven it has 82 inside we are using it
680:59 - here and printing stuff out we're going
681:01 - to delete it after we are done using it
681:03 - and after that
681:05 - the first thing we do is to reset it to
681:07 - no ptr when we do that other people or
681:11 - even ourselves have a chance to check it
681:13 - against no ptr and we're going to know
681:15 - that it doesn't contain anything
681:18 - useful
681:19 - for our program and if we do something
681:21 - like this
681:23 - we're not going to run into all these
681:25 - weird problems
681:27 - and our program is going to have
681:28 - consistent behavior
681:30 - across different runs and this is really
681:32 - cool so we're going to run this we're
681:34 - going to get things printed out and the
681:36 - program is going to end well because
681:39 - right now we are checking against no ptr
681:43 - we can even be explicit in showing the
681:45 - warning here we can say invalid memory
681:48 - access and if you run this program
681:51 - you're going to really know this so
681:53 - let's finish this up and we're going to
681:55 - bolt and the bulk is going to be good if
681:57 - we run this and run rooster we're going
681:59 - to know that we are doing any valid
682:02 - memory access after we have deleted the
682:04 - pointer and this is going to save you
682:06 - from possible crashes that you might
682:09 - experience if you don't do this so this
682:11 - is a second solution you might want to
682:14 - implement in your programs
682:16 - and i'm going to comment it out and show
682:18 - you how you can get away from the
682:20 - problem of when you have
682:23 - multiple pointers pointing to the same
682:25 - address we are going to go down and put
682:27 - in the code it is what you have seen in
682:29 - the slides and it is really nothing new
682:32 - so we have pointer eight and pointer
682:34 - nine here and p number eight here is
682:37 - pointing to
682:38 - dynamic memory
682:40 - and the value inside is 382
682:43 - p number nine is initialized with
682:45 - whatever we have in p number eight so
682:48 - they are going to be pointing to the
682:49 - same addresses here but we have made p
682:52 - number eight the master pointer so it is
682:55 - the only pointer that is going to be
682:57 - able to delete this memory location even
682:59 - if we have multiple pointers pointing to
683:01 - that
683:02 - okay so every time we want to use this
683:04 - memory we have the option to check
683:07 - against the master pointer and see that
683:09 - we have some valid data inside if it is
683:12 - no pointer we're not going to use that
683:14 - and we're going to be playing on the
683:16 - safe side this is really what we are
683:18 - doing here if we run this we're going to
683:20 - see that the program is going to end
683:22 - well
683:23 - the world is going to be good and if we
683:25 - run rooster we're going to see that we
683:26 - get things printed out we're going to go
683:28 - through p number eight we're going to
683:29 - print stuff we're going to go through p
683:31 - number nine we're going to print stuff
683:33 - and if we try to use the pointer
683:36 - after the
683:38 - memory has been deleted we're going to
683:40 - get a clear warning that we are trying
683:42 - to do something really bad and this is
683:45 - really what you should aim for in your c
683:48 - plus plus programs that use dynamic
683:50 - memory allocation and pointers
683:53 - this is really all we set out to do in
683:55 - this lecture i hope you know how you can
683:56 - avoid these problems with dangling
683:58 - pointers we are going to stop here in
684:00 - this lecture the next lecture we're
684:02 - going to see what can happen
684:05 - if this new operator
684:07 - fails to give you the memory that you
684:09 - want to allocate on the heap and that's
684:11 - possible go ahead and finish up here
684:14 - and meet me there in this lecture we're
684:16 - going to explore what happens when new
684:20 - fails in the last lecture we saw that we
684:22 - could use the new operator to allocate
684:25 - for new memory on the heap and use that
684:28 - to do stuff and in most cases the new
684:30 - operator is going to succeed but in some
684:33 - rare cases it is going to fail and when
684:36 - you don't do anything about that failure
684:38 - your program is just going to crash and
684:40 - you might want to do something about
684:42 - that i have to say that it is very rare
684:45 - for new to fail in practice so you're
684:48 - going to see a lot of code out there
684:50 - that just uses the new operator it
684:53 - doesn't really care about
684:55 - checking if the operation actually
684:58 - failed or succeeded so this is a very
685:01 - rare case but if you need to handle it
685:03 - we're going to see how you can do that
685:05 - in this lecture here is a simple example
685:08 - that is going to try and force the new
685:10 - operator to fail
685:12 - in the first segment here we are using
685:14 - the new operator but we are using a
685:17 - syntax that is going to try and allocate
685:20 - a lot of integers in one go you see that
685:23 - it is an array but we haven't really
685:25 - seen how we can use an array like this
685:27 - so just think of this code as a piece of
685:30 - code that is going to allocate a lot of
685:33 - integers in one go and we're going to
685:35 - try and make this fail
685:38 - i have to say that this may give you an
685:40 - error on some compilers saying that you
685:42 - are exceeding the array size if that's
685:45 - the case no problem we're going to find
685:46 - another way to get this new operator to
685:49 - fail we are going to put a thing like
685:51 - this in a loop and we're going to loop a
685:52 - lot of times enough to exhaust the heap
685:56 - that is allocated to our program here
685:59 - and when that happens you're going to
686:00 - see that the program is going to crash
686:02 - and it is bad so new can fail and if you
686:05 - need to play on the server side you're
686:08 - going to
686:09 - handle that problem and we have two ways
686:12 - we can handle this problem we can go
686:15 - through the exception mechanism this is
686:17 - a built-in way we have in c plus plus to
686:20 - check for arrows and handle them we can
686:23 - also use the std no throw setting
686:26 - in our new operator and force it not to
686:29 - throw an exception and it's going to
686:31 - give us no pointer if the allocation
686:33 - fails i know this might sound cryptic
686:36 - right now but we're going to see an
686:37 - example shortly and you're going to
686:39 - understand this let's look at how we can
686:41 - use the exception mechanism the
686:43 - exception mechanism is there in c plus
686:46 - plus to let you handle problems when
686:49 - they arise and the way you use that you
686:51 - wrap code that is potentially going to
686:54 - give you problems
686:56 - and try and catch blocks you see here
686:59 - inside the loop we are saying try
687:01 - and inside the tri blocks we have the
687:04 - code that could fail we have our new
687:06 - operator
687:07 - and in the catch block you see we have a
687:10 - catch block here we're going to
687:13 - say that we have a problem
687:15 - and we have a way of catching the
687:17 - problem and if you look at this thing we
687:19 - have in this parenthesis after catch we
687:22 - have an ex variable and we can ask it
687:26 - what kind of problem happened
687:29 - leading to this exception happening in
687:31 - our code you can think of this like this
687:33 - i realize we haven't really talked about
687:35 - exceptions we are going to talk about
687:38 - them later in the course when we have
687:39 - enough tools to really understand what
687:41 - is happening but now
687:43 - think of them as a tool to handle
687:46 - when the new operator fails and you're
687:49 - not going to crash your program your
687:51 - program will keep running it will go
687:53 - through the end but the new operation
687:55 - that you wanted to do here will fail and
687:58 - you will be able to catch that and this
688:00 - is a good thing if you don't want to use
688:02 - exceptions you can use the std no throw
688:04 - option
688:06 - and this is a new version of the new
688:08 - operator you can use to tell the c plus
688:11 - plus system to not throw an exception
688:13 - when the operation fails it is just
688:16 - going to return no pointer and you can
688:18 - check for that and know that memory
688:19 - allocation actually failed this is what
688:22 - we're going to talk about in this
688:23 - lecture i hope you have an idea about
688:25 - this we're going to head over to visual
688:27 - studio code and actually try this in
688:29 - action okay here we are in our working
688:32 - directory the current project is when
688:35 - new fails
688:36 - we are going to grab our template files
688:38 - like we always do and we're going to put
688:41 - them in place so when new fails that's
688:44 - the lecture so we're going to do that
688:46 - and open this in visual studio code
688:49 - pretty quick and we are going to try and
688:51 - allocate a large piece of memory in one
688:54 - go so the way you do that we can do say
688:56 - end pointer
688:57 - let's call this data it really doesn't
688:59 - matter and we're going to say new and
689:02 - and we're going to say that we want a
689:04 - huge amount of events
689:05 - let's try and do that and we're going to
689:08 - go down and say program
689:11 - ending well to make sure
689:13 - we know when we are ending this program
689:16 - properly so let's try and compile this
689:19 - we're going to bring up the terminal and
689:21 - we are going to weld with gcc as we
689:24 - always do and the build is going to be
689:26 - good let's try and increase this number
689:29 - and push it to a really big number and
689:31 - you see that we
689:33 - have made visual studio code mad here
689:36 - array is too large so they can't really
689:38 - allow us
689:39 - to do
689:40 - a really large array in here okay so
689:43 - let's bring this down a little bit
689:45 - and if we're trying to compile the
689:47 - bullet is going to be good and if we run
689:49 - rooster you see that the program
689:53 - is going to not end well okay so this is
689:56 - really a case where new fails we can't
689:59 - really allocate this much
690:01 - on the heap storage that is allocated to
690:04 - this program here remember when we
690:06 - revisited the memory map idea we saw
690:09 - that each program is going to have its
690:11 - own memory map the memory map is going
690:13 - to have a lot of sections inside we have
690:15 - the stack we have the heap our hip is
690:17 - not infinite so we can run out and we
690:20 - just ran out with this allocation that
690:22 - we did here and our program is going to
690:25 - terminate immediately you see that it is
690:26 - not ending well
690:28 - if this is not working for whatever
690:30 - compiler you are using we can go and do
690:33 - this through a loop so what we can do we
690:35 - can
690:36 - comment this out and we can really loop
690:38 - many many times enough to exhaust the
690:40 - memory that is allocated for this
690:44 - process here rooster.exe
690:46 - in the memory map in the hip section
690:49 - that's what i mean and if we do this at
690:52 - some point the program is going to fail
690:54 - and we're going to get the same problem
690:56 - here so let's build again
690:58 - we're going to build with gcc
691:01 - and we are going to clear and run
691:04 - rooster and we're going to see it's
691:05 - going to loop loop loop and it's going
691:07 - to fail we're going to see
691:09 - the failure in a minute and we need to
691:11 - find a way to solve this problem we have
691:13 - seen that we have two options let's
691:15 - comment this out
691:17 - and uh look at those solutions here the
691:19 - first option is to go through the
691:21 - exception mechanism we can also use the
691:24 - std no throw option we're going to try
691:27 - the exception mechanism first and uh
691:29 - what we do
691:31 - is wrap possibly offending code in try
691:34 - and catch blocks and we're going to say
691:38 - try here and put a block and we're going
691:40 - to say
691:41 - catch and we're going to say std
691:44 - exception and we're going to put an
691:46 - ampersand symbol here just use this like
691:49 - this and we're going to get a chance to
691:51 - really explain these things when we have
691:53 - enough tools to understand this for now
691:56 - think of this as if i have code that is
691:58 - potentially going to fail
692:01 - like the new operator here i am going to
692:03 - put that in the try block
692:05 - and if something goes wrong we're going
692:08 - to get the error in the catch block this
692:10 - is the way we do these things here so
692:12 - for example i can take my loop here
692:16 - and copy it
692:17 - and put that down below here
692:20 - okay
692:21 - and i know that this line of code could
692:24 - fail okay
692:26 - so i am going to wrap that inside try
692:28 - and catch blocks so i am going to grab
692:31 - that
692:32 - and put that in my loop
692:35 - let's do that and align this a little
692:37 - bit
692:38 - and we are going to take the potentially
692:41 - offensive code
692:43 - and put that
692:45 - in the try block and when the operator
692:48 - here fails
692:50 - something goes wrong and we're going to
692:51 - catch the problem in the catch block
692:53 - this is what we mean here again we don't
692:56 - have enough tools to understand why we
692:58 - are doing this thing here what is the
693:00 - meaning of this ampersand symbol we're
693:02 - going to learn about that later in the
693:04 - course but for now we want to put
693:06 - together something good enough for this
693:09 - program not to crash like it was doing
693:13 - right here okay we're going to catch the
693:14 - arrow and say something went wrong
693:17 - and we're going to print out what
693:19 - actually went wrong we're going to say
693:21 - ex and we can call
693:23 - a function called what on this
693:26 - and we can say sdd
693:28 - endl
693:30 - let's hide this pen here because we want
693:33 - to see clearly what is happening here
693:36 - this is how you can prevent your program
693:38 - from crashing and it is going to end
693:40 - well because now we have handled the
693:42 - problem and that we haven't caused a
693:45 - crash
693:46 - like we were doing down here now we're
693:49 - going to try and build this code let's
693:51 - bring it up a little bit so that it is
693:53 - not messy here
693:55 - and we're going to weld with gcc the
693:57 - bolt is going to be good and we're going
693:59 - to clear and run rooster and it is going
694:02 - to do its thing it's going to keep
694:04 - looping around
694:06 - and it's going to say something went bad
694:08 - it's going to hit a point where all
694:09 - these allocations are going to fail and
694:11 - if we really wait for it it is going to
694:13 - end and we're going to see that it's
694:15 - going to end well
694:16 - let's try and hit ctrl c and terminate
694:19 - it because we don't want to wait for
694:21 - this amount of time
694:22 - and let's bring that
694:24 - down to 100 and increase this number
694:27 - here
694:27 - let's see if that actually works so
694:30 - we're going to boil for now we just want
694:32 - to see that the program is not really
694:34 - crushing
694:35 - so we're going to run rooster and you
694:38 - see that
694:38 - it's going to keep running and at some
694:41 - point
694:42 - it's going to fail to allocate memory
694:44 - and it's going to say something went
694:45 - wrong but if you keep going down you're
694:48 - going to see that the program is ending
694:50 - well
694:51 - so what is happening here is that
694:53 - the new operator actually failed
694:56 - but we code the problem and could handle
694:59 - it in here so what is called handling
695:02 - the problem
695:03 - you're going to handle it in whatever
695:04 - makes sense in your program if we were
695:07 - for example trying to set up a color in
695:09 - some
695:10 - widgets in your application and the
695:13 - color fails and you fail to set up the
695:15 - color you may show your user interface
695:17 - in black and white and keep running your
695:19 - program instead of getting it crashed
695:21 - this is just a way to show you
695:24 - that you can handle stuff
695:26 - when new fails this is one way we can
695:28 - solve the problem so we're going to look
695:30 - at the second way
695:31 - the exception mechanism is the first
695:34 - so we're going to comment this out
695:36 - because we're going to see another way
695:38 - and let's do that we can also use the
695:40 - std no throw setting on our new operator
695:44 - when we are
695:46 - allocating for new memory so we're going
695:48 - to do that and we're going to bring up
695:51 - our loop here
695:52 - we're going to reuse that for this here
695:54 - we're not going to be using the
695:56 - exception mechanism so we're going to do
695:58 - something like this get rid of the try
696:00 - and catch block but we're going to still
696:02 - be in a loop here
696:04 - so what we can do is pass the new
696:07 - operator a parameter and say std no
696:10 - throw and when we do this if new fails
696:14 - we are going to get no pointer stored in
696:16 - data here so we can check this against
696:18 - the null pointer we can say
696:20 - f
696:21 - data is different from null pointer
696:25 - and we can do whatever we want to do we
696:27 - can do that and say
696:29 - sddc out
696:32 - get it allocated and we can try and
696:34 - compile this program
696:35 - so what we're going to do is run this
696:38 - through our compiler through gcc
696:42 - and you're going to see that the world
696:43 - is going to be good and you see that
696:45 - visual studio code was giving us a
696:47 - squiggly line because it can't really
696:49 - understand this but this is going to go
696:51 - through the compiler and it is going to
696:53 - work exactly how we expect
696:56 - so let's try and run this program
696:59 - we're going to ignore visual studio code
697:00 - for now because the world was good we
697:02 - could build with gcc and we saw that
697:05 - this was welding successfully so we can
697:08 - clear
697:10 - let's clear properly and run rooster and
697:12 - it's going to say data allocated a few
697:14 - other times and the program is going to
697:16 - end you see that the program is not
697:18 - crashing because we are also handling
697:21 - the problem but we are going through a
697:23 - new mechanism to do that and that's
697:25 - using the std no throw option with our
697:28 - new operator here this is really all we
697:31 - set out to do in this lecture i hope it
697:32 - is very clear that the new operator can
697:35 - fail and you have a couple of options at
697:38 - your hands to handle things when new
697:41 - fails you can either go through the
697:43 - exception mechanism by using try and
697:45 - catch blocks like we did here or you can
697:47 - use the std no throw option we are going
697:51 - to stop here in this lecture and the
697:53 - next one we are going to learn about no
697:55 - pointer safety
697:57 - go ahead and finish up here and meet me
698:00 - there in this lecture we're going to
698:02 - explore the concept called null pointer
698:05 - safety and this is a series of measures
698:07 - you take to make sure that when you are
698:10 - using a pointer it contains a valid
698:13 - address if you don't have a valid
698:15 - address inside you don't use that
698:17 - pointer and we do that through a series
698:19 - of checks we can do against the null
698:21 - pointer for example here we have a
698:23 - pointer that is initialized to null
698:25 - pointer
698:26 - implicitly through braced initializers
698:30 - and what we can do is check if p number
698:33 - doesn't contain
698:35 - null pointer and this is how we say it
698:36 - in c plus and if it contains no pointer
698:39 - we're not going to use it we're going to
698:41 - say it points to an invalid address this
698:44 - is something you can do it is simple in
698:46 - nature but it is going to save you lots
698:49 - of trouble this is one version we can do
698:51 - this on but we can also directly plug in
698:54 - p number and use it like this if it
698:57 - contains no pointer we're going to get
698:58 - the message printed out that we have an
699:00 - invalid address if we have something
699:04 - other than no pointer we're going to
699:05 - have a valid address and we can do
699:07 - something with that this is going to
699:09 - work because a pointer can also be
699:11 - implicitly converted into a boolean
699:14 - expression that our if statement expects
699:17 - here and it is going to work exactly how
699:19 - we want here so we're going to see this
699:21 - in a minute when we hit visual studio
699:23 - code before we do that though i want you
699:25 - to be aware that you can call
699:28 - delete on a pointer containing no
699:31 - pointer without doing the check here it
699:33 - is going to be okay we have seen many
699:35 - rules about pointers and many students
699:37 - will develop an intuition that you have
699:40 - to check for no pointer before you do
699:42 - anything on your pointer and they even
699:44 - do that before they call delete i have
699:46 - to break it to you that it is safe to
699:48 - call delete on a pointer that contains
699:51 - null pointer so you don't need to do
699:53 - something like we have here say and
699:55 - check if p number one and then delete p
699:57 - number one and reset that to low pointer
700:00 - this is really overkill you can call
700:02 - delete on the pointer and it is going to
700:04 - be fine even if it contains no pointer
700:06 - now we're going to go to visual studio
700:08 - code and see these things in action here
700:10 - we are in our working directory the
700:13 - current project is no pointer safety
700:16 - we're going to grab our template project
700:18 - and we're going to put that in the
700:20 - current project that we are interested
700:23 - in
700:24 - and we are going to open this in visual
700:26 - studio code open folder and we are going
700:28 - to put in a verbose no pointer check
700:31 - what we are doing here is nothing new we
700:33 - have a pointer called p number it is a
700:35 - pointer to ant and it is initialized to
700:39 - null pointer through implicit
700:41 - initialization here using braced
700:44 - initialization and we are checking to
700:47 - see if it contains null pointer if it
700:49 - does
700:50 - we're going to say it contains an
700:51 - invalid address if it doesn't we're
700:53 - going to say that it has a valid address
700:55 - and you see that we are using a negation
700:57 - here you can do this however you want if
700:59 - we try to build this
701:01 - with gcc let's see what we get
701:04 - the vote is going to go through
701:07 - and if we run rooster we're going to see
701:09 - that p number points to an invalid
701:12 - address because it contains
701:14 - null pointer but if we try and set up a
701:17 - new variable for example and say p
701:19 - number
701:21 - and let's use dynamic memory we have
701:23 - learnt about that and initialize that
701:26 - with a 7 for example and when it points
701:28 - to a valid address we're going to print
701:30 - whatever is in there we know how to do
701:32 - that so we can say p number and we're
701:35 - going to print whatever is inside and
701:37 - say p number through the reference end
701:40 - and we're going to say stdndl now the
701:43 - pointer is not going to contain
701:45 - no pointer because it contains the
701:47 - address
701:48 - of the memory that was allocated on the
701:51 - hip here
701:52 - but once we do that we have to remember
701:55 - to release this memory so please
701:57 - remember to release your memory after
701:59 - you are done using it so we're going to
702:01 - say delete p number after that and we
702:04 - need to reset it to no pointer in this
702:07 - case it really is useless because nobody
702:10 - is going to be using this pointer
702:11 - anymore the program is about to end but
702:14 - it is a good practice to do this even in
702:17 - this case because once this way of doing
702:20 - events is burnt into your memory it has
702:23 - become your habit you're going to be
702:25 - writing cipher c plus plus code now
702:28 - we're going to try and run this so we're
702:30 - going to build again the bold is going
702:31 - to go through and it is going to say
702:34 - that
702:35 - we have a valid address in memory which
702:37 - is this guy and what is inside is a
702:40 - seven and now we are writing cipher c
702:42 - plus plus code through null pointer
702:45 - safety here we can also do a direct
702:48 - check using p number without checking if
702:51 - it is equal to null pointer because this
702:53 - is verbose but it is something you will
702:55 - see in practice you can also do
702:57 - something like this and say if p number
702:59 - and you're going to get exactly the same
703:01 - thing so if we have some valid
703:04 - address inside we're going to print
703:06 - that let's print the same thing as
703:09 - in the
703:10 - previous code here
703:12 - and if we build and run we're going to
703:13 - get exactly the same thing
703:16 - okay so that's
703:18 - clear because the world is good let's
703:20 - clear and run rooster you see that we
703:22 - get exactly the same thing and if we
703:25 - didn't initialize this guy with the new
703:27 - dynamic piece of memory we're going to
703:30 - get that the memory is invalid the
703:32 - address we have in the pointer is going
703:34 - to be invalid and we're going to print
703:36 - that out through our code here
703:38 - run rooster invalid address
703:41 - okay the last thing i want you to see is
703:43 - that it is okay to call delete
703:46 - on a null pointer and we're going to say
703:48 - that here so we're going to go down here
703:50 - and put in a piece of code we are
703:52 - setting up a new pointer p number one
703:55 - initialized with no pointer if we call
703:58 - delete on it this is going to work
704:00 - really well and you're not going to get
704:01 - a crush or anything this is valid c plus
704:04 - plus code so if we're trying to compile
704:06 - this it is going to work fine and you
704:09 - don't really have to
704:11 - do a no pointer check before you delete
704:14 - like this because that's overkill you
704:16 - see that the program both successfully
704:19 - and we can clear and run it and we're
704:21 - going to get exactly the same things we
704:23 - had before so some people are going to
704:25 - do something like
704:27 - they're going to check for no pointer
704:29 - and they're going to say if p number one
704:31 - for example is not equal to no pointer
704:34 - and they're going to say something like
704:36 - delete here and they're going to do
704:38 - something like this
704:39 - and this is going to work but it is
704:41 - really overkill you don't need to do
704:43 - this test because it is safe to call
704:46 - delete on a pointer even if it contains
704:49 - no pointer in the first place so you
704:51 - don't need to do things like this this
704:53 - is going to work just fine don't be
704:56 - afraid to call delete on a pointer
704:59 - because it might contain null pointer
705:02 - this is really all we mean by null
705:04 - pointer safety and i hope i gave you a
705:06 - few examples to make this pretty clear
705:09 - we are going to stop here in this
705:11 - lecture the next one we're going to
705:12 - learn about memory licks
705:15 - go ahead and finish up here and meet me
705:17 - there in this lecture we're going to
705:19 - learn about memory leaks
705:21 - and a memory leak is when you have lost
705:24 - access to a piece of memory that was
705:28 - dynamically allocated to your program
705:30 - you basically lose the pointer that was
705:32 - pointing to that dynamically allocated
705:35 - piece of memory here we have a few
705:37 - examples of that for example here we
705:39 - have p number which contains a
705:41 - dynamically allocated piece of memory
705:43 - which is going to contain an integer
705:44 - it's going to be 4 byte the value inside
705:47 - is going to be a 67. this p number is
705:50 - our only key to manipulate that memory
705:53 - and it is the key through which we even
705:55 - go to release that memory and return
705:58 - that to the operating system but notice
706:01 - what we do down here
706:02 - we are setting up a new number variable
706:06 - it is an integer and it is allocated on
706:08 - the stack because this is a local
706:09 - variable it's not a pointer it's not
706:11 - dynamically allocated and we take the
706:15 - address of number and assign that to our
706:17 - pointer the moment we do that
706:20 - we have no way to release the memory
706:23 - that was allocated to p number in the
706:26 - first place
706:27 - and if we do that the operating system
706:29 - is going to think that this memory is
706:31 - ours but we don't have a way to release
706:34 - this memory anymore because the pointer
706:37 - that was
706:38 - helping us access this memory has been
706:41 - repurposed to point to this number
706:43 - variable here i hope you see that
706:45 - and the memory leak is something like
706:47 - this when you lose the pointer that
706:49 - would otherwise be used to release the
706:52 - memory and your program is basically
706:54 - going to keep using this memory and the
706:56 - operating system is not going to have a
706:58 - way to reclaim this memory so it is
707:01 - useless so you are no longer using this
707:03 - memory because you can't access it and
707:05 - do things with it and the operating
707:07 - system can't use it either because it
707:09 - fences your memory hopefully you can see
707:11 - that this is a really bad situation and
707:14 - you should avoid these things in your
707:16 - application so do avoid memory leaks
707:19 - like a plague
707:21 - this is one situation in which we can
707:23 - have a memory leak here is another
707:25 - example where we have double allocation
707:28 - we have a pointer p number one it is
707:30 - pointing to dynamically allocated memory
707:33 - again and the value inside is a 55.
707:37 - if we use this pointer to allocate new
707:39 - memory the first memory that we were
707:41 - pointing to is going to be leaked
707:43 - again it is the same thing we have lost
707:46 - access to the first memory now we are
707:49 - pointing to the second dynamic
707:52 - memory that was allocated to contain the
707:54 - 44 here and again this is a memory leak
707:58 - your program has lost access to the
707:59 - memory containing 55 here and the
708:03 - operating system also thinks that you
708:05 - are using this memory because you didn't
708:08 - explicitly return it to the operating
708:11 - system through the delete operator again
708:14 - memory leaks are bad do avoid them in
708:17 - your programs here is another simple
708:20 - example of a case where you might have a
708:22 - memory leak you go in a nested scope
708:24 - like this and allocate a new piece of
708:27 - memory dynamically of course and point
708:29 - to that through p number two here but p
708:32 - number two
708:34 - itself is a pointer and it is a local
708:36 - variable nested in this scope
708:39 - when this scope ends p number two is
708:41 - going to die but the dynamic memory
708:44 - itself is not going to die you just lost
708:46 - access to it and you can't access it
708:48 - again this is a memory leak and you
708:50 - should avoid this in your programs
708:53 - memory leaks are really bad and in
708:56 - extreme cases they might even lead to
708:58 - your program crashing if your program
709:01 - keeps running for an extended period of
709:03 - time think of programs like those
709:06 - running in servers for example they can
709:08 - even run for three months without
709:10 - stopping and if your program is
709:14 - increasingly leaking memory the
709:16 - operating system is going to think that
709:18 - you are taking too much hip memory it's
709:20 - going to terminate your program like we
709:22 - saw
709:23 - in the lecture where we learned on
709:26 - conditions where the new operator failed
709:28 - so if you allocate too much memory then
709:31 - your program can really take the next
709:33 - operations you're going to do with new
709:35 - are going to fail and your program is
709:37 - going to terminate the message here is
709:39 - memory leaks are bad you should avoid
709:41 - them in your programs and whenever you
709:44 - think that you're no longer using a
709:46 - piece of memory make sure you delete it
709:48 - and return it to the operating system
709:50 - you're going to be writing much safer c
709:53 - plus plus code we're going to head over
709:55 - to visual studio code and actually try
709:57 - this here we are in our working
710:00 - directory the current project is memory
710:02 - leaks we're going to bring in our
710:05 - template files
710:06 - and we're going to put them in place in
710:08 - the lecture on memory leaks and we are
710:12 - going to open this in visual studio code
710:14 - we are going to clean this up a little
710:15 - bit bring this up here we have a
710:18 - variable called p number it is a pointer
710:20 - to end and we initialize that with the
710:22 - address of a piece of memory that is
710:25 - allocated dynamically on the heap we
710:28 - store a 67 inside and here down you see
710:31 - we set up another variable on the stack
710:34 - again this says a stack variable
710:37 - it lives on the stack it's not on the
710:39 - heap and we text the address of this
710:41 - thing and assign that to our pointer
710:43 - here the moment we do that we have no
710:45 - more way we can access this dynamic
710:47 - memory and we have leaked it and this is
710:50 - really bad the thing is this program is
710:52 - going to compile
710:54 - i don't think compilers have a way to
710:56 - stop you from making mistakes like this
710:58 - so you really have to be careful and
711:00 - make sure that you are not leaking
711:02 - memory in your program so if we run this
711:04 - program it's going to run it's going to
711:06 - run and finish let's say that it is
711:08 - ending well okay so we're going to build
711:11 - and see this run the build is good so we
711:14 - can clear and run rooster and we're
711:16 - going to see that the program is ending
711:18 - well but we are
711:20 - leaking memory here because the
711:22 - dynamically piece of memory that we
711:24 - allocated here
711:26 - wasn't released to the system and when
711:29 - we did this assignment here we just lost
711:32 - access to it so the operating system is
711:34 - going to thank this memory belongs to
711:36 - this program that is ours here but your
711:39 - program is either not going to be using
711:41 - this piece of memory because we have
711:44 - just lost the key
711:46 - that would allow us to go and do
711:48 - something useful with this memory here
711:50 - so this is something bad and you should
711:52 - avoid it the second example of memory
711:55 - leaks is when you do double allocation
711:57 - on a pointer for example here we have
711:59 - pin number one again and we are going to
712:02 - make this point to
712:04 - an address
712:05 - of a piece of memory that was allocated
712:09 - dynamically on the heap the value inside
712:12 - is going to be 55 but we are using this
712:15 - pointer again to make it point to a new
712:18 - piece of memory containing the address
712:22 - of the newly allocated piece of memory
712:25 - on the stack on the heap i mean and this
712:27 - is really bad because again once we do
712:29 - this we lose access to this memory here
712:32 - and it is linked
712:33 - the program here is not going to have
712:35 - access to it and the operating system is
712:37 - going to thank we own this memory and it
712:40 - is going to be bad and uh down here
712:43 - maybe you can go and say delete number
712:45 - one p number one but this is not going
712:48 - to release the memory here it is going
712:50 - to release the memory here with the 44
712:53 - and the memory containing 55 here is
712:55 - going to be leaked let's be good c plus
712:58 - plus citizens and reset our pointers
713:00 - after we delete so we're going to say p
713:02 - number one equals no pointer and we are
713:05 - going to be playing it safe here and
713:08 - again we just lift memory here and it is
713:10 - something you should avoid in your
713:12 - programs if you run this program it is
713:15 - going to run just fine so let's see that
713:18 - because i don't want to leave you with
713:20 - programs containing errors
713:22 - if i run rooster again it's going to end
713:25 - well but it is going to be leaking
713:27 - memory here
713:28 - so we don't want to leak memory avoid
713:31 - this like a plague we're going to
713:33 - comment this out
713:35 - and show you that you can also leak
713:37 - memory when you have some nested scopes
713:40 - in your programs okay let's go down here
713:42 - and put that in and here is a simple
713:44 - example we have a nested scope nested
713:47 - inside the main function and inside the
713:49 - scope here we are setting up a new
713:52 - pointer
713:53 - and it is going to be pointing to
713:55 - dynamically allocated memory and that
713:57 - memory is going to contain a 57.
714:00 - the only key we have to this dynamic
714:02 - memory is this p number two pointer here
714:05 - but this p number two pointer lives on
714:08 - the stack itself so when the scope here
714:11 - is going to end p number two is no
714:13 - longer going to be accessible and the
714:15 - memory is going to be linked if you
714:17 - really want to play it safe you can go
714:20 - do whatever you want with the dynamic
714:22 - memory and when you are done with that
714:24 - you can delete that piece of memory here
714:26 - while you still have access to p number
714:28 - two but if you don't
714:30 - delete here
714:31 - in the scope where this thing was
714:34 - declared
714:35 - if you hit the end of this scope you're
714:38 - going to lose access to this pointer and
714:40 - you will be losing access to this
714:42 - dynamic piece of memory
714:44 - and you're going to be leaking memory
714:46 - because you're not deleting it even if
714:48 - you want to delete it you won't be able
714:50 - to do that because you don't have a key
714:52 - that is going to lead you to that
714:54 - dynamic memory so if we try and do
714:56 - delete p number two here this is not
714:59 - going to compile because we don't have
715:01 - access to p number two p number two is
715:03 - scoped inside this nested scope here
715:06 - this is what i mean so be sure you are
715:09 - aware of this memory leak problem the
715:12 - cases we have seen here are really
715:15 - extensive enough to give you an
715:17 - intuition on how this is bad and you're
715:20 - going to be avoiding this new programs
715:23 - and you're going to be on your way to
715:24 - become a better c plus plus developer
715:28 - this is really all we set out to do in
715:29 - this lecture to learn about memory leads
715:31 - show you a few examples of them i hope
715:33 - now you understand them we are going to
715:36 - stop here in this lecture and the next
715:37 - one we're going to learn about
715:38 - dynamically allocated arrays
715:42 - go ahead and finish up here and meet me
715:44 - there
715:45 - in this lecture we're going to look at
715:47 - dynamic arrays and these are arrays you
715:51 - can allocate on the heap and they're not
715:53 - going to be stored on the stack like we
715:55 - have seen before the arrays we have
715:57 - learned about so far have been living on
716:00 - the stack we want to see how we can
716:03 - allocate arrays on the heap if we happen
716:05 - to need that in our applications arrays
716:08 - are allocated on the hip with the new
716:10 - operator we can also use the sdd no
716:13 - throw version of the new operator if we
716:16 - don't want exceptions in our c plus plus
716:19 - programs here is a simple example of how
716:21 - you can do that we have a pointer called
716:23 - p salaries it's going to be a pointer to
716:25 - double and it is going to contain the
716:28 - address to the dynamic memory that we
716:31 - allocate on the heap which is going to
716:33 - contain an array
716:35 - of doubles of this size here okay this
716:38 - is an array that is going to be
716:40 - initialized with junk values because we
716:42 - are not initializing that
716:45 - explicitly so this is something you need
716:47 - to be aware of okay p students is also
716:49 - going to be containing the address of an
716:52 - array that is going to be allocated on
716:54 - the heap we are using the sdd nothro
716:57 - version of the new operator because in
717:00 - this case for example we might not want
717:02 - exceptions and we're going to say that
717:04 - it is an array of events it's going to
717:06 - be this size but we are using breast
717:09 - initializer so this is going to be
717:11 - initialized to zero
717:13 - all the values inside are going to be
717:15 - initialized to zero this is what we mean
717:17 - here we also have a p scores array we
717:20 - are using the std no throw version of
717:22 - new and it is going to be this size and
717:25 - initialized with one two three four five
717:28 - okay if
717:29 - the array is bigger than five the
717:31 - remaining slots are going to be
717:33 - initialized with zeros just like we saw
717:35 - with the arrays we have learned about
717:37 - previously that we're stored on the
717:40 - stack this is really how you work with
717:41 - these things and i hope it is super
717:44 - clear again we are calling the new
717:46 - operator
717:47 - this is going to allocate however memory
717:50 - space is needed to store these things on
717:53 - the heap so if this array is going to
717:55 - contain 10 elements we're going to
717:57 - allocate enough space to contain 10
718:00 - double elements on the heap and we're
718:02 - going to be pointing to that with the p
718:04 - salaries pointer that's what we mean
718:06 - here once you have your dynamic array
718:09 - allocated on the hip you can try to do
718:11 - things with it for example we can try
718:13 - and loop through the squirrels and print
718:15 - them out here you see that we are using
718:18 - the angle bracket syntax and the
718:21 - pointer arithmetic syntax it is going to
718:23 - work equally well you can choose
718:25 - whatever you want but i just wanted you
718:27 - to see that you can use both versions
718:29 - here the next logical thing to think
718:31 - about when you talk about dynamic memory
718:34 - allocation is how you release the memory
718:36 - to the operating system when you're no
718:38 - longer using it and this is the syntax
718:41 - to do it with arrays you say delete you
718:43 - put angle brackets and you say the
718:45 - pointer that was used to allocate that
718:48 - memory in the first place and after you
718:50 - do that you have to remember to reset
718:52 - the pointer to null pointer because you
718:54 - are a good c plus plus citizen and this
718:57 - is really all we had to say in this
718:59 - lecture this is how you dynamically
719:01 - allocate a raise on the hip before we
719:04 - head over to visual studio code and play
719:06 - with this though i want you to keep in
719:08 - your mind that arrays you allocate
719:11 - dynamically on the heap are very
719:14 - different from the arrays that we have
719:16 - learned about before and that's because
719:18 - they don't work with std size and they
719:21 - don't work for range based for loops
719:24 - and that the reason for all these
719:26 - limitations is that when you do
719:28 - something like this the array really
719:30 - decays into a pointer and it loses
719:34 - information that would otherwise be used
719:36 - to deduce the size that is used by sdd
719:39 - size and there are other things that are
719:41 - used by the range base for loop that
719:44 - they lose when you store and refer to
719:46 - them using a pointer like this that's
719:48 - why we have this limitation keep this in
719:51 - mind if you are using a dynamically
719:53 - allocated array on the heap you're going
719:56 - to be using other techniques to deduce
719:58 - its size and it is not going to work
720:01 - with a range base for loop so we will
720:03 - have to use other kinds of loops that we
720:05 - have learned about in this course and it
720:08 - is going to work pretty well
720:09 - this is really all i had to share in
720:11 - this lecture now i think it's time we
720:14 - went to visual studio code and actually
720:16 - tried this out
720:18 - here we are in our working folder the
720:21 - current project is dynamically allocated
720:24 - arrays
720:25 - we are going to grab our template files
720:27 - and put them in place
720:29 - and we're going to put that in the
720:31 - current project and open this in visual
720:34 - studio code like we always do and we are
720:36 - going to go down and put in some starter
720:39 - code we can play with here we're going
720:41 - to click on this
720:43 - file icon to remove this pane
720:46 - and we're going to try and show the code
720:48 - here and again you see that visual
720:50 - studio code is freaking out when it sees
720:53 - the std no throw version of the new
720:55 - operator here but it is going to work
720:57 - when we hit the compiler okay so we are
720:59 - allocating three arrays on the heap
721:02 - dynamically and we are going to be
721:04 - storing the addresses to these arrays
721:07 - and these pointers for example p
721:10 - salaries is going to store the address
721:12 - to this dynamic array which is going to
721:14 - be leaving on the heap and it is going
721:16 - to be the same case for p students here
721:18 - and p scores i don't think there is much
721:20 - to explain here because we have already
721:23 - learned about arrays we know about the
721:25 - size of an array we know that it is a
721:27 - piece of contiguous memory location that
721:29 - is going to be storing variables of the
721:32 - same type this is really what we're
721:33 - going to have
721:34 - so let's try and compile this and see
721:36 - that it actually goes through our gcc
721:39 - compiler and it is going to work fine
721:42 - and another thing you should notice is
721:44 - that this is really compiling even if
721:46 - what we are using to store the size of
721:49 - the array is not const remember for
721:52 - stack arrays or static arrays that we
721:55 - had on the stack
721:56 - we had to make sure this guy here is
721:58 - const
721:59 - okay that was
722:02 - a requirement and if you didn't fulfill
722:04 - that your code wouldn't compile now you
722:07 - see that with dynamic arrays the code is
722:09 - actually compiling even if it's not cost
722:12 - and this is something you should be
722:14 - aware of let's build this again i just
722:16 - messed up my things here
722:19 - and the world is good if we go down and
722:22 - run it we're not going to see anything
722:23 - really because we're not having any
722:26 - output in this program but this is how
722:28 - you can allocate
722:30 - space for a dynamic array on the heap
722:33 - now let's try and print some of the data
722:36 - in this course here let's go down here
722:38 - and actually do that we are going to do
722:41 - a no pointer check because we want to
722:43 - make sure that memory was actually
722:45 - allocated for the p scores array
722:48 - and after we do that we're going to loop
722:50 - for size times
722:52 - and we're going to be printing whatever
722:54 - element is at each iteration the index
722:56 - at each iteration and you see that we
722:59 - can either use the angle brackets
723:01 - notation or the pointer arithmetic
723:04 - notation it is going to work equally
723:06 - well
723:07 - if we built this
723:08 - let's bring up our terminal we haven't
723:10 - opened one and let's go down and clear
723:13 - and run rooster
723:15 - you're going to see that
723:16 - successfully allocated
723:18 - memory for scores
723:20 - and we're going to be printing the data
723:22 - first using the angle brackets notation
723:25 - second using pointer arithmetic and you
723:28 - see that it is working pretty well
723:30 - one thing you should have noticed now is
723:32 - that we haven't actually
723:34 - released the memory that we have
723:36 - allocated here and this is something
723:37 - really bad so we're going to see how we
723:39 - can do that we have allocated space for
723:42 - salaries p students and scores so let's
723:45 - go down and do that and we're going to
723:47 - say delete
723:48 - and we're going to have angular brackets
723:50 - because this is an array we are
723:53 - releasing memory for or to be exact a
723:56 - dynamic array which was allocated on the
723:59 - heap so we're going to say p
724:01 - salaries
724:03 - and we're going to reset that pointer
724:06 - to no pointer because we are good c plus
724:09 - plus citizens so we're going to do that
724:11 - no pointer and we're going to do the
724:13 - same thing delete
724:15 - we are deleting
724:17 - space for a dynamic array so the angle
724:20 - brackets here
724:21 - the square brackets i should say and we
724:24 - are going to delete p students i think
724:27 - yes so we're going to say p student
724:30 - and we're going to say p students and
724:32 - we're going to reset this to no pointer
724:35 - and we're going to do the same for p
724:37 - scores
724:38 - let's grab this here that's what we want
724:42 - no that's not what we want we're going
724:44 - to say delete and say square brackets
724:46 - ourselves and we're going to say p
724:48 - scores and we're going to release that
724:50 - and say p scores
724:52 - and reset this to null pointer now we
724:56 - are really playing it safe and our
724:57 - program is going to release the memory
725:00 - that we allocated in these three
725:02 - statements here
725:03 - if we build the program it is going to
725:05 - go through well so we're going to build
725:07 - with gcc
725:10 - and we are going to clear
725:13 - and run rooster and it is going to run
725:15 - pretty well you see that for peace
725:17 - corpse
725:18 - we initialized the first five elements
725:22 - and the remaining elements were
725:24 - initialized
725:25 - implicitly by the compiler to zero and
725:28 - you can see that here i don't think i
725:29 - explained this but this is my chance to
725:32 - explain this i hope you understand the
725:33 - next thing i wanted to explore before we
725:35 - close this video is the difference
725:37 - between static arrays and dynamic arrays
725:40 - a static array is an array you allocate
725:42 - on the stack like we have been doing
725:44 - before and you do it using a syntax like
725:47 - let's say scores why not and it is going
725:49 - to be an array that says it is going to
725:51 - contain 10 elements
725:54 - and we are going to put in our values in
725:56 - the format that we know
725:57 - and we're going to go all the way to 10
726:00 - let's put in a 10 here and we're going
726:01 - to end this with a semicolon
726:04 - this array is cool and you can loop
726:06 - through it you can do all kinds of crazy
726:08 - things with it but i am going to
726:10 - emphasize two differences we have with
726:13 - dynamic arrays one is that this guy is
726:15 - going to work with sdd size so we're
726:17 - going to say the out
726:19 - okay this is going to work if we compile
726:21 - this
726:22 - we're going to get a good world at least
726:25 - i hope yes the world is good and if we
726:27 - run rooster
726:30 - we're going to get scores the size is
726:32 - 10.
726:33 - the other thing is that you can use a
726:35 - range based for loop to loop through
726:37 - this guy here so for example we can say
726:40 - for
726:41 - auto score s for score in scores
726:45 - and it is going to work so let's go down
726:47 - and say what we are doing here or we can
726:50 - even say a single line to separate fence
726:52 - here i don't want to be confused so i am
726:55 - going to do something like this so that
726:57 - i know where my output here is going to
727:00 - start
727:01 - so i am going to build this
727:03 - with gcc of course the world is going to
727:07 - go through
727:08 - and if i clear
727:10 - and run rooster
727:12 - i am going to see that the size is 10
727:14 - and i am going to print my elements here
727:17 - with a range based for loop
727:21 - okay let's see how these things behave
727:23 - when we use a dynamic array we are going
727:25 - to set up a similar array but on the hip
727:28 - which is going to leave on the hip this
727:31 - array here is the static array in that
727:33 - it is going to live on the stack you
727:35 - have to be aware of these differences
727:37 - okay we're going to do another one which
727:38 - is going to leave on the heap and the
727:40 - way we do that we say end pointer let's
727:43 - say p scores one to make sure this is
727:45 - different from p squares that we have on
727:47 - top here and we're going to have 10
727:49 - elements inside and we can even
727:51 - initialize this guy exactly like we are
727:53 - doing here but the data is not going to
727:56 - leave on the stack the data is going to
727:58 - leave on the heap
728:00 - if we do something like this first let's
728:02 - make sure that the code compiles we're
728:04 - going to try and run this
728:06 - through gcc
728:08 - and watch the compiler output here the
728:10 - bolt is good so this is valid c plus
728:12 - plus code
728:14 - we can try and use hdd size on that and
728:17 - we're going to go down and do that
728:21 - and if we do that we're going to say p
728:24 - scores size
728:26 - one size and say p scores if we try to
728:29 - pass this pointer here you're going to
728:31 - see that visual studio code is going to
728:33 - freak out because this won't work
728:36 - the
728:37 - array here has decayed into a pointer
728:40 - when we refer to it using a row pointer
728:43 - like this so we can't really use it
728:46 - inside std size
728:48 - so if we look at this we're going to get
728:50 - a weird compiler error but this is going
728:53 - to be the problem here
728:54 - okay so you can't do this with dynamic
728:57 - arrays this is one limitation the other
729:00 - is that you can't use dynamic arrays
729:03 - like we are using a range based for loop
729:06 - here so if we grab this loop and try to
729:09 - work with it on p scores for example
729:12 - this is something somebody might want to
729:14 - do
729:15 - let's say
729:16 - pscores1 okay and try to print something
729:19 - inside you're going to see that this is
729:21 - not going to work the compiler visuals
729:23 - video code is not going to like it first
729:25 - and if we try and run this through gcc
729:29 - we're also going to get a weird compiler
729:31 - arrow and the problem is going to be
729:34 - that p scores is really not an array it
729:37 - is just a pointer that is pointing to
729:39 - some location in memory that's all it is
729:42 - and it doesn't have information that
729:44 - could be used otherwise to loop through
729:46 - elements
729:47 - like we can do for a real static array
729:52 - that is leaving on the stack again let's
729:54 - be super clear here and say that this
729:57 - array is going to leave
729:59 - on the heap you have to understand these
730:02 - things but this is really not a big
730:04 - limitation because you can store the
730:06 - size of this guy in some variable and
730:09 - refer to it if you need that and you can
730:11 - loop through the array exactly like we
730:13 - did here using size and it is going to
730:15 - work pretty well so don't be afraid to
730:18 - store your arrays on the heap if that's
730:20 - what you need in your application it is
730:23 - going to work pretty well you just have
730:25 - to be aware of some limitations that
730:28 - come with doing things this way here
730:31 - this is really all we set out to do in
730:33 - this lecture i hope you have a better
730:35 - idea about dynamic arrays you set them
730:38 - up like this the size here doesn't have
730:40 - to be cost like we have with static
730:43 - arrays and they have a few differences
730:45 - compared to static arrays that were
730:48 - stored on the stack and that std size
730:51 - doesn't work for them and they don't
730:53 - work with range based for loops other
730:57 - than that dynamic arrays are ridiculed
730:59 - and you should use them when that helps
731:02 - whatever it is you are designing
731:04 - welcome to this new chapter where we are
731:07 - going to be talking about references
731:10 - references are a way you can set up
731:12 - alliances for your variables and have
731:15 - other variable names you can go through
731:18 - to modify that same variable for example
731:21 - here we have a variable called var it is
731:23 - an integer it leaves at this address
731:25 - here and the value inside is 33.
731:29 - if we set up another alliance to it as
731:32 - var elias we can go through this var
731:35 - elias variable and use it in pretty much
731:38 - the same way we use the original
731:40 - valuable and this is going to come in
731:42 - handy in many situations as we are about
731:45 - to see in this chapter we are going to
731:48 - start in the next lecture and see how we
731:50 - can declare initialize and use
731:52 - references in our c plus plus
731:54 - applications
731:55 - go ahead and finish up here and meet me
731:58 - there in this lecture we're going to see
731:59 - how we can declare and use references in
732:02 - our c plus application again a reference
732:05 - is an elias variable that you can use to
732:09 - reference an original variable and use
732:11 - that reference in pretty much the same
732:13 - way you use the original variable let's
732:16 - see how that can work in c plus plus
732:19 - here is a simple example we have two
732:21 - variables one is an integer we have 45 n
732:24 - the other is a double we have 33.65
732:28 - n
732:28 - we want to set up references to this
732:31 - variable and the syntax is ridiculously
732:33 - easy
732:34 - for the edge value its reference is
732:37 - going to be something like ant ampersand
732:39 - you put the ampersand symbol you say the
732:42 - name of the reference and you initialize
732:45 - this with the value in the variable that
732:48 - you want this to reference so reference
732:50 - to h value is going to be referencing
732:52 - our integer here and we can use this
732:54 - name to reference this variable here and
732:58 - it is going to be like we are using the
733:00 - original variable which is interval here
733:03 - we're going to see how this works in a
733:04 - minute we can do the same using
733:06 - assignment initialization and down here
733:09 - you see that we have an example for the
733:11 - double value and we have a reference to
733:13 - it once we have these references we can
733:15 - use them like we use
733:17 - the original variables for example if
733:19 - you come here you see we are printing
733:20 - stuff out if we print any value we're
733:23 - going to get the value printed out if we
733:25 - print double value we're going to get
733:26 - the value printed out we can also print
733:28 - through references you're going to see
733:30 - that they are going to print exactly the
733:32 - same value as we have in the original
733:34 - variables
733:36 - but the interesting thing is going to be
733:38 - that
733:39 - if you print the addresses through the
733:41 - original values and print the addresses
733:44 - through the references you're going to
733:46 - get the same addresses printed out which
733:49 - is really going to say this to variable
733:51 - names are almost exactly the same thing
733:55 - in c plus plus and this is really cool
733:57 - you can use the reference as if you are
734:00 - using the original variable name in your
734:02 - c plus plus code we're even going to try
734:05 - and go through the sizes and print them
734:06 - out and you're going to see that they
734:08 - are going to be exactly the same thing
734:10 - and we are going to see how important
734:12 - this can become in c plus plus code as
734:15 - we go through this chapter okay now that
734:16 - we have the reference declared we can go
734:19 - through that and modify the value and if
734:21 - we do that the changes are going to be
734:24 - reflected in the original variables and
734:27 - if we print stuff like this again we're
734:29 - going to see that the changes are going
734:31 - to be reflected in the original
734:33 - variables okay if you modify the
734:36 - original variable the changes are also
734:38 - going to be reflected in our references
734:41 - and this is exactly what we would expect
734:43 - from our references okay so this is
734:45 - really all there is about references
734:47 - they are alliances to your variables and
734:49 - you can use them pretty much the same
734:51 - way you use your variables let's head
734:54 - over to visual studio code and see some
734:56 - of these things in action here we are in
734:59 - our working directory the chapter is
735:02 - references and the lecture is declaring
735:04 - and using references we are going to
735:06 - grab our template files here
735:09 - and we're going to put them in place and
735:12 - we are going to open this in visual
735:14 - studio code we are going to set up a new
735:16 - variable let's call this data or it's
735:19 - data this is going to be much more
735:21 - descriptive and we're going to
735:23 - initialize this with a 33 why not and
735:26 - we're going to do a double and say
735:28 - double data and we're going to put in a
735:31 - 55 in
735:32 - and we're going to set up references to
735:34 - these variables
735:36 - and again a reference is an elias that
735:39 - you can use in pretty much the same way
735:41 - you use the original variable so we're
735:44 - going to set up a reference to int data
735:46 - we're going to say
735:47 - and
735:49 - reference mean reference by putting the
735:51 - ampersand symbol here and we're going to
735:54 - say rough
735:55 - and
735:56 - yeah and you initialize that
736:00 - with the variable name you want this
736:03 - reference to reference
736:05 - and uh here we want to reference into
736:07 - data so we're going to pass in into data
736:10 - and this is going to be it our reference
736:12 - is declared we can do the same for
736:14 - double data so let's do that
736:16 - double and we're going to say it's a
736:18 - reference we're going to say rough
736:20 - double data and we're going to reference
736:22 - devo data here so let's do that okay
736:25 - let's bring up our terminal and see if
736:28 - we can compile this code here we're
736:29 - going to compile with gcc like we always
736:32 - do and let's close this then on the left
736:35 - because it takes up
736:37 - some of the space here the world is good
736:40 - so this syntax is valid c plus plus
736:43 - syntax
736:44 - so what we can do is read values from
736:47 - all these things and show you that they
736:49 - really are the same things so we're
736:51 - going to print stuff out and i am going
736:54 - to put here some code and i am going to
736:56 - come back when i have typed this i don't
736:58 - want you to suffer watching me type
737:01 - these things okay here i have the code
737:03 - type down and you see that i am just
737:05 - going to print dana through the original
737:08 - variables i am going to print the actual
737:10 - data and print the address of the
737:12 - variable and do the same for the debo
737:15 - data which is of type double
737:17 - how convenient and we're going to print
737:20 - references we're going to print the
737:21 - reference and the address of the
737:23 - reference and we're going to do the same
737:25 - thing for our ref devil data here let's
737:28 - try and build this with gcc
737:31 - so we're going to run the task to do
737:33 - that
737:35 - and we are going to clear the book is
737:37 - good and run rooster if we run rooster
737:40 - you see that let's put a separate end
737:43 - line here so that we see the entire
737:44 - thing so
737:45 - i really like to see my fans easily
737:49 - so let's do that and build again okay
737:51 - the build is good we can clear and run
737:53 - rooster now and we're going to see the
737:55 - original data and data is 33 the address
737:59 - is this guy here we have demo data the
738:02 - value is 55 and this is the address if
738:05 - we look at our references we have
738:07 - exactly the same thing the addresses are
738:09 - even the same it really is like we are
738:11 - using the original variable and this is
738:13 - really cool it can allow you to pass
738:16 - data around much easily
738:18 - using references and whatever you are
738:21 - using when you have sent this data for
738:23 - example to some other file or some other
738:25 - function you're going to be
738:27 - affecting the same data okay so you're
738:29 - not going to be making copies and we're
738:31 - going to see how cold this can be
738:33 - especially when we get to working with
738:36 - functions this is going to be super cool
738:38 - okay now we have seen that the
738:40 - references are really referencing the
738:43 - original values let's try and modify the
738:46 - data through
738:48 - the original values and see that the
738:50 - references are going to pick up the
738:51 - changes let's do that we're going to
738:53 - take 80 data and change that to
738:56 - 111 and we're going to take the apple
738:58 - data and change that to 67.2
739:03 - why not and after we do this we're going
739:05 - to print data again so we're going to
739:07 - grab the code here
739:10 - and
739:11 - use that again here and we should see
739:13 - the same changes applied
739:15 - so we're going to weld with dcc the bolt
739:18 - is going to be good
739:20 - as you see here and if we clear and run
739:23 - rooster
739:24 - we are going to see that
739:26 - the value is 55 let's put a separation
739:30 - line in here this is cramped and it is
739:33 - really hard to see what is happening
739:35 - here so i am going to put an std endl in
739:39 - here and weld again so let's do that and
739:43 - the book is good so we can clear and run
739:46 - rooster again and now we see things
739:48 - separated out and it is easier on the
739:50 - eye here we have empty data to b33 and
739:53 - the depot data is 55 and we are going to
739:56 - print our references which are going to
739:58 - pick up the same things because a
740:00 - reference is really analyzed to
740:02 - the original variables but if you go
740:05 - down you're going to see that the data
740:06 - has actually changed and together has
740:08 - changed to 111
740:10 - and nabodana has changed to 67.2
740:14 - and the interesting thing is that the
740:16 - references have also picked up those
740:18 - changes because they really are
740:20 - referencing the same things in memory
740:22 - it's like we are using the original
740:24 - variable to
740:26 - read these things like we are doing with
740:29 - references here and this is really cool
740:31 - here we have used the original variables
740:33 - to modify data but we can also modify
740:35 - the data through references and the
740:37 - original variables are going to pick up
740:38 - those changes so let's do that we're
740:40 - going to say ref data and we're going to
740:43 - change this to
740:45 - 12 for example
740:47 - and let's use
740:50 - 1014 or 12. this is going to do we're
740:53 - going to do ref double data and put in
740:57 - another large number let's say 1000.45
741:00 - why not and we're going to print the
741:02 - data again so we're going to grab
741:04 - this and print stuff out again so we're
741:08 - going to go down and put in the code to
741:10 - print stuff and you see it's going to
741:12 - use the original variables and the
741:14 - references and we should see the changes
741:16 - reflected in our terminal here
741:19 - so let's do that
741:20 - and we're going to weld with gcc as we
741:23 - always do
741:24 - the bullet is going to be cool we're
741:26 - going to clear and run rooster we're
741:28 - going to see that we have 33 and 55 the
741:31 - references are going to pick that up
741:33 - that's what we have here we're going to
741:35 - put in
741:36 - 111 and 67 through the original
741:39 - variables and the references are going
741:41 - to be picking that up and we're going to
741:43 - use references and modify data you see
741:46 - that the original variables are also
741:48 - picking that up because we are really
741:51 - modifying data in the same memory
741:53 - location that's why these changes are
741:55 - being shared between references and the
741:57 - original variables and this is really
742:00 - all we set out to do in this lecture to
742:01 - show you how you can set up a reference
742:03 - and prove that the changes we do either
742:06 - through original data or references are
742:09 - reflected between these two guys meaning
742:11 - references and the original
742:13 - variables
742:14 - we are going to stop here in this
742:16 - lecture in the next one we're going to
742:18 - do a comparison between pointers and
742:20 - references because they seem to be doing
742:23 - quite the same thing
742:25 - go ahead and finish up here
742:27 - and meet me there and this lecture we're
742:29 - going to be looking at the similarities
742:32 - and the differences between references
742:34 - and pointers okay we know that a pointer
742:36 - is really something that is going to
742:38 - store the address of the variable and we
742:40 - can go through that pointer and modify
742:43 - the original variable or really do
742:45 - things with that but in the last lecture
742:47 - we saw that we could also do the same
742:49 - thing with references so why have these
742:52 - two mechanisms in place
742:54 - and what are the differences between
742:56 - them here is a simple slide that i put
742:59 - together to put the important points
743:02 - about references and pointers together
743:04 - the first thing is that if you use
743:06 - references you are not going to go
743:08 - through the star symbol to the reference
743:11 - and get to the value you are
743:12 - manipulating so that's going to really
743:15 - feel like you are using the original
743:17 - variable but with pointers you are going
743:19 - to go through the referencing so that's
743:21 - the first difference
743:23 - another thing about references is that
743:25 - you can't change them to reference
743:27 - something else later but with pointers
743:30 - we saw that we could do that we can
743:31 - change a pointer to point somewhere else
743:34 - if it happens to be a non-const pointer
743:37 - the other thing is that for references
743:39 - you have to initialize them at
743:41 - declaration you can't declare a
743:43 - reference and not initialize that if you
743:46 - do that you're going to get a compiler
743:47 - error and we're going to see that in a
743:49 - minute but for pointers you can declare
743:52 - a pointer and not initialize it and it
743:54 - is going to just contain a junk address
743:57 - and if you try to use that uninitialized
743:59 - you are going to be setting yourself up
744:01 - for trouble so we saw that so these are
744:04 - the main differences between pointers
744:06 - and references and now we are just going
744:08 - to be looking at how these translate in
744:11 - code here is a simple example we have a
744:14 - variable called double value which
744:15 - happens to be double and we have a
744:17 - reference to it and a pointer to it so
744:20 - you already know these concepts
744:22 - now if we want to read the value in here
744:25 - through our pointer and references we're
744:27 - going to be using two different syntaxes
744:30 - if we go through the reference we can
744:32 - use this reference variable name
744:35 - directly and read the value or change it
744:38 - and we can do something like
744:39 - ref double value to print that out this
744:42 - is going to work but if we want to go
744:44 - through the pointer we will have to go
744:47 - through the referencing and this is
744:49 - really bad
744:50 - you know sometimes people don't like
744:52 - this syntax they think that it is not
744:55 - direct enough so they prefer to use
744:57 - references to do these kinds of things
745:00 - but pointers are still important as we
745:02 - will see later as we progress in the
745:04 - course so this is one difference with
745:06 - references you don't have to go through
745:08 - the dereferencing mechanism to use this
745:11 - star here to print stuff or even
745:13 - manipulate the data inside you just use
745:15 - the variable name and it is going to
745:17 - work with pointers you have to reference
745:19 - because if you don't the reference
745:21 - you're going to be referring to the
745:23 - address stored in this pointer this is
745:25 - the first difference and we see that the
745:28 - same applies if we are trying to
745:30 - write data into our variable if we go
745:33 - through the pointer we will have to
745:35 - dereference and use this dollar symbol
745:37 - in front here
745:39 - if we are using a reference we can do
745:41 - that directly as if we are modifying the
745:44 - original variable so this syntax is much
745:46 - more readable the other difference is
745:48 - that we can't make a reference
745:51 - reference something else but we can
745:53 - change a pointer to point to something
745:55 - else let's look at an example here we
745:57 - have ref double value which is a
745:59 - reference to double value
746:01 - and here
746:02 - we are doing an assignment to this thing
746:05 - here we are saying either double value
746:07 - and assigning that
746:09 - to our reference but what we are doing
746:12 - here is not making ref double value
746:15 - reference this other variable we are
746:17 - just grabbing the value in other double
746:19 - value and assigning that to our
746:21 - reference and the value in either double
746:24 - value is going to be reflected in the
746:26 - original value here so this is what we
746:29 - are doing we are not reassigning to our
746:31 - reference to make it reference something
746:33 - else we are assigning the value to the
746:36 - reference as it is now and it is going
746:38 - to be still referencing the same
746:40 - variable in memory if you print out the
746:43 - address in memory you're going to see
746:44 - that the address of the reference here
746:46 - hasn't changed so this is something you
746:48 - should keep in mind but we know that a
746:50 - pointer can point somewhere else if we
746:52 - have a pointer here for example p double
746:54 - value we can reassign it another address
746:57 - and make it point to that new address so
747:00 - in this regard we can think of
747:02 - references as cost pointers because cost
747:05 - pointers can't also be made to point
747:07 - somewhere else and if you're trying to
747:09 - do that for example here we have a cost
747:11 - pointer it is called cost p double value
747:15 - and if we try and make it point
747:17 - somewhere else through this assignment
747:19 - here we're going to get a compiler error
747:21 - okay so this is really all in terms of
747:24 - the comparisons that we had to make
747:26 - between references and pointers now
747:28 - we're going to head over to visual
747:30 - studio code and see how these things
747:32 - work in real code so here we are in our
747:35 - working folder the current project is
747:37 - comparing pointers and references we are
747:40 - going to grab our template files and put
747:43 - them in place
747:44 - and we are going to open this project in
747:47 - visual studio code like we always do we
747:50 - are going to go down and put in some
747:52 - starter code and let's align this a
747:54 - little better
747:56 - so and we can close this pane so that we
747:58 - have some breathing room here we have a
748:00 - variable of double type and we set up a
748:03 - reference to it and a pointer to it this
748:05 - is how we do this thanks you already
748:07 - know this
748:08 - and we can try and read through
748:11 - the original variable through the
748:12 - reference and through the pointer and
748:15 - see how these syntaxes differ and how
748:18 - one might be better than the other for
748:21 - example if we look at how we are using
748:24 - the reference it's really like we are
748:26 - using the original value here we don't
748:28 - have to do reference if we try to print
748:30 - the pointer directly like this without
748:32 - the referencing this is going to print
748:34 - the actual address stored in this
748:37 - pointer it's not going to print the
748:40 - actual value stored in the address
748:43 - pointed to by this pointer i really want
748:45 - this to be clear so this is the syntax
748:47 - we can use for reading stuff either
748:50 - through references or pointers we can
748:52 - also use these syntaxes to write stuff
748:54 - into our variables for example here we
748:56 - can go through the pointer and we have
748:58 - to the reference and we can go through
749:01 - the reference to really do the same
749:03 - thing and we're going to see that our
749:04 - syntaxes here are going to pick up the
749:07 - changes
749:08 - regardless of whether we write through
749:10 - pointer or a reference because all these
749:13 - things really are going to be
749:15 - referencing the same location in memory
749:18 - let's try and bring up a terminal here
749:21 - and we are going to world with gcc let's
749:24 - do that the build is going to be good
749:26 - and we're going to clear and run rooster
749:29 - and you're going to see that at first
749:31 - we're going to have a 12
749:33 - point 34 in
749:35 - that's going to be the value we can get
749:37 - it through original value the reference
749:39 - or the pointer through the referencing
749:42 - and the address is this one here
749:44 - if we change the value through the
749:46 - pointer we're going to see the changes
749:48 - reflected here and if we change the
749:50 - value through the reference we're going
749:52 - to see the changes reflected in here so
749:54 - this is how you can use pointers and
749:56 - references to do these things here and
749:59 - you can really choose what makes sense
750:00 - for your application they mostly do the
750:02 - same things but some people say that the
750:04 - syntax to the reference the pointer here
750:07 - is really ugly that's why most people
750:09 - prefer to use references like this but
750:11 - references have other benefits as well
750:14 - as we're going to see as we progress in
750:16 - the course another thing i want you to
750:18 - see is that you can't change a reference
750:20 - to reference something else in memory
750:22 - for example here we have our reference
750:24 - which is ref double value if we try and
750:27 - make it reference something else
750:30 - we're not going to get that result let's
750:31 - go down and try to do that
750:33 - so we're going to set up another double
750:35 - variable so if we try to
750:38 - make our ref double value reference this
750:41 - guy
750:42 - the syntax that comes to mind is saying
750:45 - ref
750:46 - double value and assign that the some
750:50 - other
750:51 - double value here now let's see what
750:53 - happens if we do that we're going to try
750:55 - and print whatever we have in memory
750:58 - using the
751:00 - ref double value here let's grab this
751:04 - and go down here and say that we are
751:06 - changing the reference making the
751:08 - reference reference something else let's
751:11 - say that so if we try to build this
751:13 - let's see what we get we're going to run
751:15 - and build with gcc
751:18 - and we're going to try and run this
751:20 - clear not clear and we're going to run
751:22 - rooster
751:24 - we're going to see that
751:25 - the last line of output here say 78.45
751:31 - but the address is still the same so we
751:35 - are still referencing the same memory
751:38 - with our reference and what we just did
751:40 - here was just grab the value in some
751:43 - other double value
751:45 - and assign that in here but the
751:46 - reference is referencing the same memory
751:49 - location it's been referencing so in c
751:52 - plus plus you don't have a way you can
751:55 - go through
751:56 - to make a reference reference something
751:58 - else the only chance you have to make it
752:01 - reference something is through
752:03 - declaration here and that's the reason
752:06 - you can't declare a reference and not
752:09 - initialize it if you do that you're
752:10 - going to get a compiler error so let's
752:13 - try and do something like this we're
752:14 - going to take out this double value and
752:16 - the moment we do this you're going to
752:18 - see that visual studio code is going to
752:20 - be unhappy you see the squiggly line and
752:22 - it is going to say initial value of
752:24 - reference to non-cos must be an l value
752:27 - so what is that
752:29 - okay if we take out the initialization
752:31 - altogether it's going to give us a
752:33 - better error i think reference variable
752:35 - requires an initializer so every time
752:38 - you declare a reference you have to
752:41 - initialize it and we should do like we
752:44 - just did before here and we're going to
752:46 - be fine again you can't declare a
752:49 - reference and not initialize it if you
752:51 - do that you're going to get a compiler
752:53 - error and the reason is that
752:56 - this is the only shot you get to make
752:58 - your reference reference something else
753:00 - okay if there was a way for you to
753:02 - bypass this and let the compiler compile
753:05 - this you would never get another chance
753:08 - to make this guy actually reference
753:09 - something and it would really be a
753:12 - useless reference so make sure you
753:14 - understand this you can't make a
753:16 - reference reference something else and
753:19 - if you try to do something through a
753:21 - syntax like this
753:23 - you're going to be assigning the value
753:24 - of whatever variable you have to the
753:27 - reference you're not going to be making
753:29 - the reference referencing something else
753:31 - the reference is going to keep
753:33 - referencing the same variable in memory
753:35 - as we have seen here so let's say what
753:37 - we were trying to do here but we know
753:39 - that we can make pointers reference
753:42 - something else so here we have a pointer
753:44 - again
753:45 - this pointer called the p double value
753:47 - and it has the address of double value
753:50 - inside
753:51 - but we can set up another variable
753:53 - okay so we can make that reference this
753:57 - other variable here and let's do that
753:58 - you're going to see that our pointer now
754:00 - is going to be containing another
754:02 - address so what we can do
754:04 - is say p double value
754:07 - which is our new pointer and we're going
754:09 - to assign it
754:10 - the address of some other double value
754:15 - and if we print the data now and go down
754:19 - we are going to say make the pointer
754:22 - point to something else that's what we
754:24 - are doing here and we're going to say
754:26 - the same thing here through a comma and
754:29 - if we print this try to guess what we're
754:31 - going to get
754:32 - the pointer is going to contain a
754:34 - completely new address because we can do
754:36 - that we can make it point
754:38 - to somewhere else
754:40 - let's run rooster
754:42 - and we're going to see our data here
754:44 - let's make sure we see the entire fan
754:48 - okay i think this is the data we have
754:51 - let's go up again
754:53 - there's no harm in that so we have our
754:56 - fence that we have seen before but what
754:58 - is going to be important here is that pw
755:01 - value now contains a new address
755:05 - okay so this is really important and you
755:07 - have to understand that so we made the
755:10 - pointer successfully point to something
755:12 - else and if we change the data in the
755:14 - pointer now
755:16 - we're not going to be affecting the data
755:18 - we have in here in double value we're
755:20 - going to be affecting the data we have
755:23 - and some other double value here let's
755:25 - do that we're going to change the data
755:27 - through the pointer so we're going to
755:28 - say p double value and we're going to
755:31 - change this to
755:32 - 555
755:35 - and now we can print the data and see
755:37 - that things have changed in memory and
755:39 - we can print this to see the differences
755:42 - here but before we do that let's also
755:44 - print the address of the original
755:46 - variable and the address because for now
755:49 - we are just printing only the address
755:52 - through the pointer so what we can do
755:54 - here is grab htdc out and say
755:58 - address of double volume and we're going
756:00 - to put that out through htdc out here
756:03 - we're going to do that and we're going
756:04 - to print the address of the reference
756:07 - why not
756:08 - ref double value and we're going to put
756:11 - that out as well i'm going to say
756:13 - address of ref
756:15 - double value
756:16 - and we're going to say std endn and
756:19 - after that we are going to grab the
756:21 - entire thing here and print it out after
756:24 - we modify the value in the pointer
756:27 - i hope this is going to show thanks in a
756:29 - much more
756:30 - clear way so we're going to weld this
756:33 - with gcc let's do that the build is good
756:36 - so let's clear and run rooster and what
756:39 - you're going to see is that
756:41 - now
756:42 - the original variable is living at
756:45 - address here
756:47 - which we can see in our reference but
756:49 - the pointer now is pointing to something
756:51 - else
756:52 - no wonder that the changes we did
756:54 - through the pointer are not being
756:56 - reflected in our double value because
756:58 - these two variables now
757:00 - are living in different memory locations
757:03 - i really hope you see that and this is
757:05 - really all we had to share in terms
757:08 - of the differences between pointers and
757:10 - references i hope you have a clear
757:12 - picture of what these two things are and
757:15 - we are going to stop here in this
757:16 - lecture this one we're going to see how
757:18 - the const key world works with
757:21 - references
757:22 - go ahead and finish up here and meet me
757:25 - there in this lecture we're going to see
757:27 - how the const key world can be used with
757:30 - references
757:31 - and again the idea is to set up an alias
757:34 - to a variable and make it const so that
757:37 - we can't go through it to modify the
757:40 - original variable this is the syntax we
757:42 - used to set up a non-const reference
757:44 - that we have seen so far so for example
757:47 - we can say int age put in a value 27 in
757:50 - this case and set up a reference to age
757:52 - and initialize that
757:54 - with the age variable once we do this
757:57 - riff edge can be used to modify
757:59 - this edge variable here and whatever is
758:02 - inside for example we can go through ref
758:05 - age to increment the age and if we print
758:08 - the edge now we should get a 28 printed
758:10 - out because this reference is going to
758:12 - change these two things at the same time
758:15 - or another way to say this these two
758:18 - things age and ref age are referencing
758:20 - the same memory
758:22 - in your computer so if you change one
758:25 - the other is going to pick up the change
758:27 - we can also set up accounts reference
758:28 - and the syntax is ridiculously easy you
758:31 - say constant reference like this and
758:34 - your reference is suddenly caused and
758:36 - you can't go through it to modify the
758:39 - original variable
758:40 - if you need something like this in your
758:42 - application this is how you do it you
758:44 - can also duplicate the behavior with
758:46 - count references with pointers and for
758:48 - that we can use a construct like const
758:51 - end pointer cost this is going to set up
758:53 - a cost pointer to cost which we can't
758:56 - use to modify the value that we are
758:58 - pointing to
758:59 - but it can't also be used to point to
759:02 - something else so this is going to
759:04 - simulate the behavior we have with
759:06 - references and you can do that if you
759:08 - want and please know that we have no
759:10 - such thing as constant reference cost
759:13 - this is going to give you a compiler
759:15 - error because we have no such concept in
759:17 - c plus plus and my head is hurting right
759:20 - now trying to think about what this
759:23 - would even mean and another thing i want
759:25 - to make clear before we head over to
759:27 - vg's video code and play with us is that
759:30 - the const key world is going to apply to
759:32 - the variable name
759:34 - that you apply it to for example here we
759:37 - have cost reference age which is going
759:39 - to be a const reference but this doesn't
759:42 - mean that the edge variable here has to
759:44 - be cost
759:46 - okay it can be cost or it may not be
759:48 - cost but the cost here applies to this
759:51 - variable name constraint age and we
759:53 - can't go through this variable name and
759:55 - modify the age if you're trying to do
759:58 - that we're going to get a compiler error
760:00 - now we can head over to visual studio
760:02 - code and play with us here we are in our
760:05 - working directory the current project is
760:08 - reference and cost we're going to grab
760:11 - our template files pretty quick let's do
760:14 - that
760:14 - and we're going to put them in place
760:17 - and we are going to open this in visual
760:20 - studio code we are going to review the
760:22 - references we have seen so far in this
760:24 - little example here we have the edge
760:27 - variable it has a 27 inside and it is a
760:30 - net and we have a reference to it
760:33 - and this reference is not const so we
760:35 - can go through this reference modify the
760:37 - age and if we do that this is going to
760:40 - work and if we print the edge here we're
760:42 - going to see that it has turned into a
760:45 - 28 and we can try and print this through
760:48 - the terminal so that you can see this
760:50 - for yourself so let's run the task to
760:53 - build with gcc
760:55 - we are going to clear
760:57 - and run rooster
760:59 - and if we do that you're going to see
761:01 - edge is 27 now it is 28 and we have
761:04 - successfully modified data through our
761:06 - reference here
761:08 - but if we change this reference to be
761:10 - const we won't be able to do that
761:12 - anymore so let's try and make it a const
761:14 - reference
761:15 - if we do that we're going to get a
761:17 - compiler error if we try to do something
761:19 - like this because this is now a const
761:22 - reference we can't go through it to
761:24 - modify our data here and we're going to
761:26 - get a compiler error here we have visual
761:28 - studio called complaining here but if we
761:30 - ignore that and go through the compiler
761:34 - we're going to see that we get the same
761:36 - compiler error we can't implement a read
761:38 - only reference which is this ref age
761:41 - here so this is what a cost reference
761:43 - really is you can't go through it to
761:45 - modify the data that is being referenced
761:48 - and another thing i want you to really
761:49 - understand is that this const keyword
761:52 - here has nothing to do with the original
761:55 - variable this is a constant reference we
761:57 - can't go through it to modify the edge
761:59 - variable but this doesn't matter if age
762:02 - is either const or not const the
762:04 - constants here applies to this variable
762:08 - name here so this cost h may be cost if
762:11 - it's cost it's going to work equally
762:13 - well and we're going to still get a
762:14 - compiler error here if it's not cost
762:17 - it's going to be the same the cost we
762:19 - have on our reference applies to this
762:22 - reference variable name here this is
762:24 - what i want you to understand okay this
762:26 - is what a cost reference really is
762:29 - another thing we want you to see
762:32 - is that we can simulate the same
762:34 - behavior
762:35 - with pointers so let's set up a const
762:37 - pointer to const on this edge here and
762:40 - we're going to see that we can have the
762:41 - same behavior but for that we're going
762:43 - to have to comment this out because we
762:45 - don't want noise output and we're going
762:48 - to go on top here and comment this out
762:50 - and say what we are intending to do we
762:53 - can say that we are simulating reference
762:56 - behavior with pointers and the way we're
762:58 - going to do that we're going to say
762:59 - const and pointer cost and we're going
763:02 - to say ph
763:04 - and we're going to initialize this with
763:06 - our age variable or the address of our
763:09 - age to be super clear okay so we have
763:12 - our pointer set up let's try and go
763:15 - through it and modify the age let's see
763:17 - what happens we the reference because
763:19 - this is a pointer and we're going to say
763:21 - ph and say plus plus or even change this
763:25 - to another age let's say 45 and if we do
763:28 - this we're going to get the same
763:29 - compiler error so if we build this
763:33 - let's clear here clear not clear
763:36 - and above again we're going to get
763:38 - another compiler error saying that we
763:40 - can't modify something that is read only
763:43 - assignment of read only location this
763:46 - pointer can't be used to modify the data
763:50 - in this age location here so this is the
763:53 - same behavior with references because
763:56 - the reference by default can't be made
763:58 - to point somewhere else we had to make
764:01 - this pointer also a const pointer
764:04 - preventing us from making it point to
764:07 - other locations so this is how you can
764:08 - simulate references with pointers and
764:12 - this is really all we set out to do in
764:14 - this lecture i hope you found it
764:15 - interesting
764:16 - the main idea was to let you know how
764:19 - you can work with cost references and
764:21 - once you have your const reference you
764:23 - can't go through it to modify the
764:25 - original data if you do that you're
764:27 - going to get a compiler error
764:29 - welcome to this new chapter where we
764:31 - will be doing cool stuff with text data
764:34 - we have seen that we can model a
764:36 - character array and store in a bunch of
764:39 - characters and we could for example call
764:41 - this character array message and
764:43 - manipulate it in memory in this
764:45 - structure we will see that this is
764:47 - actually the way text data is stored in
764:50 - c plus plus and we have a lot of
764:52 - facilities built on top of this
764:55 - character already construct to make it
764:57 - easy to work with text data we will see
765:01 - that we can use character arrays to
765:03 - model c strings which are a facility we
765:05 - use in c plus plus to handle text data
765:09 - and we will see that there are a few
765:12 - built-in facilities we can use to
765:13 - manipulate that we can get the length of
765:16 - a string we can concatenate strings and
765:18 - put them together we can copy strings we
765:20 - can search for data inside strings we
765:22 - can do all kinds of crazy things but we
765:25 - will see that c strings are not that
765:27 - easy or convenient to work with for
765:30 - example you need to keep track of how
765:32 - big the string is in memory you need to
765:35 - also remember to make sure it ends
765:38 - correctly and we will see the details
765:39 - about that in this chapter long story
765:42 - short c strings are not safe or
765:44 - convenient to work with in c plus plus
765:47 - and c plus plus provide another type
765:50 - that really builds on top of character
765:52 - arrays but it gives us an easier
765:55 - interface to work with and we can just
765:58 - focus on storing in the data and doing
766:00 - stuff with it in our c plus programs and
766:03 - the big idea about what we're going to
766:05 - be doing in this chapter is learn about
766:08 - the facilities we have in c plus plus to
766:10 - handle text data in our c plus plus
766:13 - programs in the next lecture we're going
766:15 - to start and show you how you can
766:17 - manipulate
766:18 - individual characters in a character
766:20 - array
766:21 - go ahead and finish up here and meet me
766:23 - there
766:24 - in this lecture we're going to be
766:25 - learning about some facilities in the c
766:28 - plus plus standard library
766:30 - that can help us manipulate characters
766:33 - and here are a few things you might want
766:35 - to do with those facilities for example
766:38 - you might want to know if a character is
766:40 - alphanumeric or if it's a number or a
766:43 - character you might want to know if it
766:45 - is alphabetic you might want to know if
766:48 - it's a blank character you might want to
766:50 - know if it's a lowercase or uppercase
766:52 - character depending on what you want to
766:54 - do in your application of course there
766:56 - are facilities to check if characters
766:58 - are digits there are even those that
767:01 - help us you know transform characters
767:04 - make them lowercase or uppercase and
767:06 - we're going to see
767:07 - these examples here all of these are
767:10 - documented at
767:11 - cppreference.com so you can go there and
767:14 - find the documentation here is the same
767:17 - link opened in my browser you see that
767:19 - they leave in the cc type library so you
767:23 - need this included if you want to use
767:25 - them and you see that there is quite a
767:27 - bunch of them we are going to cover just
767:30 - a section of them and i will leave you
767:32 - to use the documentation if you need to
767:34 - use any more of these guys our first
767:37 - example here is going to help us check
767:39 - if a character is alpha numeric and the
767:42 - function we're going to use from the c
767:44 - plus plus standard library is std is l
767:48 - num
767:48 - and you just pass it a parameter of a
767:51 - character and it's going to tell you if
767:54 - a character is either alphanumeric or if
767:57 - it's not if it is alphanumeric you're
767:59 - going to get a value that is different
768:00 - from zero which can be treated like a
768:02 - true if it's not you're going to get a
768:04 - value that you can treat like a zero and
768:07 - how do i know this well we can check the
768:09 - documentation so if i come back to our
768:12 - link here
768:13 - and there is a function here is i'll num
768:16 - i can open it in another tab and it is
768:19 - going to tell me what this function does
768:21 - checks if the given character that you
768:23 - pass as a parameter here is an
768:26 - alphanumeric character as classified by
768:29 - the current siluca
768:30 - so
768:31 - it's going to tell us if the character
768:34 - is
768:34 - alphanumeric or not you give it a
768:37 - character and what you get from it is
768:40 - the return value here it's going to
768:42 - return a non-zero value if the character
768:44 - is alpha numeric so this non-zero value
768:47 - which is an integer because that's what
768:49 - we get out of this function is going to
768:51 - be treated like a true
768:53 - and if this character here is not alpha
768:56 - numeric we're going to get zero that we
768:58 - can treat like a false this is really
769:00 - cool and if you go down here you're
769:01 - going to find a few examples i don't
769:03 - want you to worry about this c local
769:06 - thing
769:06 - it is a
769:08 - setting that allows you to
769:10 - say more about the meaning of the
769:12 - characters that you are storing in
769:14 - memory but for now we're just going to
769:16 - be happy with the defaults and use this
769:18 - function as is it is going to work
769:21 - enough well okay here is our function
769:23 - again so here c is alphanumeric we
769:26 - expect to get a value
769:28 - different from zero because c is
769:30 - alphanumeric and the second example here
769:33 - is not alphanumeric so we expect to get
769:35 - a value that is equal to zero and we can
769:38 - use the return of this function
769:40 - in a test for example we can say a
769:42 - character we put in a star here it is
769:44 - called input car and we say f is al num
769:48 - and we pass this character we're going
769:50 - to print out this character is alpha
769:52 - numeric if it's not we're going to print
769:54 - is not alpha numeric you can do that and
769:57 - you can do all kinds of crazy tests in
769:59 - your c plus plus applications here is
770:02 - another example that we can use to know
770:04 - if the character is alphabetic so it's
770:08 - going to return a value different from
770:11 - zero if the character is a an alphabet
770:14 - character a through z that's going to
770:16 - return something different from zero and
770:19 - if we pass something that is not for
770:21 - example
770:22 - this second line here or the seven at
770:25 - the third line here we're going to get a
770:27 - value equal to zero because that's not
770:29 - alphabetic we have another facility to
770:32 - help check if a character is a black
770:34 - character and we see an example that
770:37 - here we have a character array called
770:39 - message we have a couple of blanks
770:41 - inside and we can hunt for them using
770:44 - the ease blank facility from the c plus
770:47 - plus standard library here we have a
770:49 - variable that is going to keep track of
770:51 - how many black characters are in here it
770:54 - is initialized to zero and we're going
770:56 - to loop around okay and we're going to
770:58 - look by the amount equal to the size of
771:02 - the message array here we can use std
771:04 - size again because this is a row array
771:07 - it is a static array and we can use sdd
771:09 - size it is going to give us how many
771:11 - characters we have in this array you
771:13 - already know this and if we get inside
771:16 - we are going to try and check and see if
771:19 - the current character
771:20 - is a blank if it is we're going to print
771:23 - that out and we're going to increment
771:26 - our blank account by the time this loop
771:29 - is done we will have printed out a lot
771:32 - of blank characters if we happen to
771:34 - have them in our message and at the end
771:37 - we're going to say in total we found
771:39 - however many blank characters this is
771:41 - what we're going to see
771:43 - if we run this program and hopefully you
771:45 - can see how useful
771:47 - this can be in text processing
771:49 - applications if that happens to be what
771:52 - you are working on we're going to run
771:54 - this example in visual studio code in a
771:56 - minute here is another example that we
771:58 - can use to check if a character is
772:00 - uppercase or
772:02 - lowercase we have an array of characters
772:04 - here inside we have some text
772:07 - and we have a few variables to keep
772:10 - track of how many characters are
772:12 - lowercase or uppercase we're going to
772:15 - set up a loop which is going to be a
772:17 - range based for loop and we know that
772:20 - through std is lower
772:22 - we're going to increment the lowercase
772:25 - count if it is uppercase we're going to
772:27 - increment the uppercase count this is
772:29 - how we can do this
772:30 - and we are going to print that
772:32 - information when the loop here is done
772:35 - okay we still have a few examples ahead
772:37 - the current one is going to check if a
772:38 - character is a digit if you want to do
772:40 - that you can use this and we have a
772:43 - character array here and we're going to
772:45 - have for digits inside this message here
772:49 - so we're going to do basically the same
772:51 - thing we're going to set up a variable
772:53 - that is going to keep track of how many
772:56 - digits we have in this message we are
772:59 - going to loop around using a range based
773:01 - for loop we're going to check if the
773:03 - current character is a digit and we're
773:05 - going to
773:06 - increment
773:08 - our variable here if it happens to be
773:10 - the case and at the end we're going to
773:12 - say how many digits we found in our
773:16 - message here it is this simple the last
773:18 - example we're going to look at is to
773:20 - help us turn a character into lowercase
773:23 - or uppercase and here is an example that
773:26 - is going to help us play with us we're
773:28 - going to have a
773:30 - character array called home the feeling
773:33 - of belonging and we will set up a
773:35 - destination character array
773:38 - that we're going to store whatever we
773:40 - want to set up in
773:41 - here you see a loop that is going to
773:43 - turn our message here into uppercase
773:47 - and you see we're going to loop around
773:49 - by this amount the size of original
773:52 - strength
773:52 - and we're going to be grabbing each
773:55 - character at each iteration
773:57 - and turning that to uppercase this is
774:00 - what std to upper function does the
774:04 - result of that is going to be stored in
774:06 - our destination string and by the time
774:09 - we are done here original string is
774:11 - going to be however it was but uppercase
774:14 - string is going to be stored in our
774:16 - destination array and if we print it out
774:19 - we should see this thing printed in
774:21 - uppercase we can basically do the same
774:24 - thing and turn the string into lowercase
774:27 - and our destination string is going to
774:29 - be now lowercase and you're going to see
774:31 - that this works out pretty well
774:34 - now that you have a basic understanding
774:36 - about how these things work we're going
774:39 - to head over to vg studio code and play
774:41 - with us okay here we are in our working
774:44 - directory the current project is
774:46 - character manipulation
774:48 - we are going to grab our template files
774:50 - like we always do and we're going to put
774:53 - this in place and we're going to open
774:55 - this in visual studio code pretty quick
774:57 - and we are going to go down and put in
774:59 - our first example this example is going
775:02 - to be using the std is al num facility
775:06 - and this is going to be checking if the
775:08 - character is alpha numeric we're going
775:10 - to see what we get from this if we print
775:12 - this out we're going to check if c the
775:14 - character c is alphanumeric we're going
775:17 - to see what we get and we're going to
775:18 - check if this character here i don't
775:21 - know how to pronounce it i'm sorry
775:23 - we're going to check if it is
775:25 - alpha numeric we're going to see that
775:27 - and we're going to use this in at
775:29 - condition we're going to check and see
775:31 - if our star character here is
775:34 - alphanumeric and we're going to print
775:35 - that out we're going to say it is alpha
775:37 - numeric or it is not from the
775:39 - documentation we know that this thing
775:41 - lives in the cctype
775:44 - library so we may want to include that
775:46 - but it is possible that it is coming
775:49 - from iostream here that's why we don't
775:51 - see
775:52 - visual studio code complaining here as
775:54 - an example if we try and comment out
775:56 - this include here
775:58 - you're going to see that
776:00 - this is not going to make sense anymore
776:02 - okay so the include needed to use these
776:06 - guys here is coming from io stream okay
776:09 - so we're not going to include that here
776:11 - we are going to open up a terminal
776:15 - and build this with gcc and you're going
776:18 - to see that the block is good if we go
776:20 - down and clear let's clear properly and
776:23 - run rooster we're going to see that c is
776:26 - alphanumeric because we have a one the
776:28 - one can be treated like a true and the
776:30 - character here is not alphanumeric
776:33 - because the result is zero
776:35 - and you see that the star here is also
776:37 - not alpha numeric and we know this
776:40 - through our test here and you see that
776:42 - we can do things like this
776:44 - with this facility here if you want to
776:47 - get true or false from this function you
776:50 - can turn this into booleans using static
776:53 - cast but we're not going to do that here
776:55 - you already know that we can comment
776:58 - this out for now and look at another
777:00 - facility from the
777:02 - cctype library there are many of these
777:05 - we're going to look at quite a few of
777:07 - them we're going to comment this out and
777:09 - go down and put in a code here and this
777:12 - is going to check if a character is
777:14 - alphabetic so if it is an alphabet
777:17 - character
777:18 - a from z lowercase and uppercase
777:21 - c is alphabetic the character here is
777:23 - not alphabetic and seven here is not
777:26 - alphabetic so for the first one here
777:29 - we're going to get something
777:31 - not equal to zero we should get a one
777:34 - that's what they use in most cases for
777:37 - this we're going to get a zero the
777:39 - second one and for the third one we're
777:41 - going to also get a zero this is what we
777:43 - expect
777:44 - we are going to build with gcc of course
777:47 - and we are going to clear and run
777:50 - rooster
777:51 - and we're going to get that c is
777:53 - alphabetic this guy is not alphabetic
777:56 - and seven is not alphabetic if we change
777:59 - this c to uh
778:01 - e for example lowercase
778:03 - and both again you're going to see that
778:05 - the results are going to be what we
778:07 - expect e is alphabetic
778:09 - let's clear and run rooster this is
778:12 - going to be exactly what we expect but
778:14 - you see that it is not a one and this is
778:16 - not guaranteed to always give you a one
778:19 - it is guaranteed to give you something
778:21 - different from zero if the character is
778:24 - alphabetic and zero if not and we can
778:27 - use this guy here in a test
778:30 - for example
778:31 - we can say f sdd is alpha and if we're
778:35 - boiled the both is going to be good and
778:37 - we're going to clear and run rooster and
778:40 - you see e is alphabetic i should put a
778:42 - space here i do encourage you to change
778:45 - these characters up and see what you get
778:47 - here and see how you can use this that's
778:49 - in tests that's the best way to learn
778:52 - okay before we continue i do encourage
778:54 - you to try and run these methods through
778:56 - different compilers for example here we
778:58 - also have an msvc compiler from
779:01 - microsoft setup so we can use that and
779:04 - try to build this thing here but before
779:06 - we do that let's bring up our pen here
779:09 - and remove
779:11 - rooster.exe here because
779:14 - we don't want to override it we're going
779:16 - to select it and do delete
779:19 - and i am going to remove this and move
779:22 - that to the recycle bin
779:24 - and i am going to clear whatever i have
779:26 - here on the terminal
779:28 - and i am going to go there i am going to
779:30 - choose run task
779:32 - and i am going to choose world with msvc
779:35 - here
779:37 - i am going to use that it is going to
779:39 - build my thang you see the output here
779:41 - and we have rooster.exe here
779:44 - and it should say that the world is good
779:46 - in a minute world finished successfully
779:49 - microsoft is going to give us a lot of
779:51 - output here but no problem the build is
779:54 - good
779:55 - if we go in
779:56 - we can actually check
779:58 - and see what we have
780:01 - in our folder here you're going to see
780:02 - that we have these files one of them is
780:05 - rooster.exe
780:07 - if we run it we are going to get the
780:10 - outputs that we expect and you see that
780:11 - it is exactly the same thing we got
780:14 - with gcc
780:16 - i am telling you to try and use
780:17 - different compilers because some
780:19 - compilers are going to flat some of the
780:23 - facilities from cctype
780:25 - or those that start with c as unsafe
780:29 - because there are some tanks that can
780:31 - really throw you off about them and
780:33 - we're going to learn about them in this
780:34 - chapter as we move forward just know
780:37 - that it is a good idea to try these
780:38 - things on different compilers and see
780:41 - the errors you get and make yourself
780:43 - familiar with those things
780:45 - for now we're going to move on and we
780:47 - are going to keep using
780:48 - gcc because that's my favorite compiler
780:51 - you can use whatever compiler you want
780:53 - the next example is going to check if
780:55 - the character is blank let's close this
780:58 - thing
780:58 - and clear
781:00 - and give ourselves some breathing room
781:03 - we're going to bring this down a little
781:05 - bit and we're going to check if the
781:06 - character is blank the facility for that
781:09 - is std is blank
781:11 - and if it's a blank character we're
781:13 - going to get something different than
781:15 - zero and we can use that in a test like
781:17 - this and if it's not a black we're going
781:19 - to get something equal to zero and this
781:21 - test here is going to fail so what this
781:24 - example here is going to do it's going
781:25 - to count how many blank characters we
781:27 - have in this
781:28 - message here and we're going to print
781:31 - the counter of that on the console using
781:33 - this line here so let's go through this
781:34 - loop and see what it does the first
781:36 - thing we do is initialize blank count to
781:39 - 0 and we are using an integer and
781:41 - because this is a count i think blank
781:44 - count is of wrong type because it can be
781:47 - negative so to really be safe in our
781:50 - program here we should make this
781:52 - unsigned or even use size t
781:54 - this is better okay so let's use size
781:58 - t
781:59 - because this is a size and size t is a
782:01 - good type to keep track of sizes in your
782:04 - c plus plus programs so make sure you
782:07 - size t here
782:09 - and what we're going to do
782:11 - is go in the loop at each iteration
782:13 - we're going to check if each character
782:15 - at each iteration is a blank if it is
782:17 - we're going to fall in here and say that
782:19 - we found a blank character at this index
782:22 - in our array here
782:24 - and we're going to increment our blank
782:26 - account and by the time this loop is
782:28 - done we're going to have the blank
782:30 - account stored in this blank account
782:32 - variable and we're going to print that
782:34 - out it is this simple
782:36 - now we can build with gcc let's do that
782:39 - we're going to world with our gcc
782:42 - compiler
782:43 - and the world is going to be good can
782:45 - clear
782:47 - and run rooster
782:48 - and you're going to see that
782:50 - it's going to say we found a blank
782:52 - character at index 5
782:54 - 12 20 24 31 35 39 and 42
782:59 - and in total we have found nine blank
783:01 - characters do we have that many let's
783:04 - count so one one blank character
783:08 - we have two here we have three we have
783:11 - four
783:12 - we have five
783:13 - here
783:14 - we have six
783:16 - seven
783:17 - eight and nine if you count you're going
783:18 - to find that we have them and the first
783:21 - one is at index five so index zero is h
783:25 - one two three four the first one is at
783:27 - index five and this is doing exactly
783:30 - what we want we can go down and check if
783:33 - a character is uppercase or lowercase we
783:36 - can do that through an example like this
783:39 - and the facility is going to be std
783:41 - lower and std is upper we have a message
783:44 - here
783:46 - we're going to loop around using a range
783:48 - based for loop and we're going to check
783:50 - if each character is either lowercase or
783:52 - uppercase
783:53 - and if the test is good we're going to
783:55 - jump in the loop and we're going to
783:57 - increment lowercase count which are a
784:00 - few variables to keep track of how many
784:03 - uppercase and lowercase characters we
784:05 - have in here and again these variables
784:07 - are going to store counts so it is
784:09 - better
784:10 - to use a size t or some unsigned integer
784:13 - type but now we're going to use size t
784:16 - because it is good so we're going to
784:18 - keep this stored in here and we're going
784:20 - to build this and see what we get
784:22 - before we run we want to clear
784:26 - and we are going to build with gcc
784:29 - the bolt is going to be good we're going
784:31 - to clear and run rooster
784:34 - and you see that the original strand is
784:36 - this guy here what we're going to do
784:38 - we're going to print whatever character
784:40 - we are at i'm going to put a space in
784:42 - front of that and we're going to see
784:45 - increment this is the output why do we
784:48 - have this method here because we are
784:50 - printing out
784:52 - each character and we are not printing
784:55 - the upper case ones we are printing
784:57 - lowercase ones that's why you see
785:00 - this guy here this is really interesting
785:02 - you can keep this in if you want i am
785:04 - going to keep this on the important
785:06 - message is that we found lowercase
785:09 - characters and uppercase characters and
785:11 - we have five uppercase characters if we
785:14 - go in and count we're going to find that
785:16 - we have t here one
785:18 - two and three and four and five five
785:22 - uppercase characters and if you count
785:24 - the lowercase characters one by one i am
785:26 - sure that you're going to get a 47 like
785:29 - we did here we're going to comment this
785:30 - out because this was just an example
785:33 - i am leaving this in here so that you
785:35 - can use this as a reference if you want
785:37 - we can also check if a character is a
785:40 - digit
785:41 - and we're going to use std is digit to
785:44 - check that the return type is going to
785:46 - be different from zero
785:48 - if the test succeeds if it fails we're
785:51 - going to get a zero and we can use that
785:52 - like this so we have a message here
785:55 - stored in the character array called
785:58 - statement
786:00 - and we're going to loop around checking
786:02 - if each character we are at is actually
786:04 - a digit or not if it's a digit we're
786:06 - going to say found a digit i'm going to
786:08 - say whatever digit we found and we're
786:10 - going to increment the digits count and
786:12 - we're going to store that information in
786:14 - this digit count variable here we don't
786:17 - want to make it an end so we're going to
786:19 - make it a size t
786:21 - and we're going to build and run this
786:23 - program
786:24 - and see how many digits we found you
786:26 - know it is this number here i'm not
786:28 - going to say it
786:30 - we're going to let our program figure
786:32 - this out so rooster and we're going to
786:34 - find two two and one so we found three
786:38 - digits and it is exactly what we expect
786:40 - here
786:41 - we're going to comment this out and show
786:43 - you another example and in the last
786:46 - example we're going to be showing you
786:48 - that you can change the case of a
786:49 - character if it's lowercase make it
786:52 - uppercase if it's uppercase make it
786:54 - lowercase and you can do things like
786:56 - that we have a message here stored in
786:59 - our character array called original str
787:02 - we set up another array which is going
787:04 - to store our message that is transformed
787:08 - and we're going to loop around turning
787:10 - everything we come across uppercase
787:12 - the way we do that we're going to say
787:14 - std to upper
787:17 - and we're going to pass in the character
787:19 - that we want to turn to uppercase if we
787:21 - do that we're going to get an uppercase
787:23 - character out of that and we're going to
787:26 - store that in our destination
787:28 - array at this index here it is this
787:31 - simple after that we're going to print
787:33 - the original strand and the uppercase
787:35 - string we should get that printed out
787:37 - because it is stored
787:39 - in destination string here
787:42 - and we're going to do the reverse and
787:43 - turn that back into lowercase
787:46 - we're going to grab the original
787:47 - strength loop over it and at each
787:50 - iteration we're going to get whatever we
787:52 - have
787:53 - and turn that to uppercase to lowercase
787:56 - i should say
787:57 - and the result of that is going to be
787:59 - stored back in our destination strand so
788:02 - we're going to overwrite whatever we
788:04 - have in our destination string here and
788:07 - after that we're going to branch the
788:08 - lowercase string and we should get that
788:11 - printed out this is how the example
788:12 - works and if you have any problem
788:14 - understanding this i am always around
788:17 - please do ask i will do the best i can
788:20 - to help you out for now we are going to
788:22 - build this
788:24 - with gcc the builder is going to be good
788:26 - we're going to clear and we're going to
788:28 - run booster and we're going to see that
788:31 - the message is here it is turned
788:33 - uppercase it is turned lower case and
788:35 - this is how you can do these things here
788:38 - so we have looked at a few of this
788:41 - facilities from cctime i don't really
788:43 - want to look at all of them because that
788:45 - would be really boring i hope you have
788:48 - an idea about how they work and if you
788:50 - want to look at all of them all you have
788:52 - to do is come to the documentation here
788:55 - choose one
788:56 - open it up and look at the documentation
788:59 - and in most cases they are going to have
789:01 - examples down here that you can look at
789:04 - and play with
789:05 - for now we are going to stop here in
789:06 - this lecture this is really all we set
789:08 - out to do to play with many of these
789:11 - facilities from the cctype library in
789:14 - the next lecture we're going to look at
789:15 - how we can manipulate c strings and by
789:18 - that we mean concatenating them or
789:20 - putting them together copying them out
789:23 - and doing all kinds of crazy things
789:25 - go ahead and finish up here and meet me
789:28 - there
789:29 - in this lecture we're going to look at
789:30 - the facilities from the c plus plus
789:33 - standard library to play with c strings
789:36 - all of these are going to be leaving in
789:38 - the c string library you can go and
789:40 - check it out at cpp reference and we're
789:42 - going to start and look at a few
789:44 - examples of some of the things we can do
789:47 - with this library i mean c string the
789:49 - first thing we're going to look at is an
789:51 - example of how we can check the length
789:53 - of a strength here we have a character
789:56 - array called message one it is a
789:58 - character array and you see that we made
790:01 - it const we also have another array that
790:04 - is pointed to by pointer you know that
790:07 - if we do things like this this array is
790:09 - going to decay into a pointer and there
790:11 - are a few things we can do with that for
790:13 - example we can't use it with std size
790:16 - and we can't use a range based for loop
790:19 - to loop through this message to thank
790:21 - you
790:22 - but
790:23 - sdr then is going to help us check the
790:26 - length of this thing here so we can use
790:28 - it for example if we do hdd sdr lam
790:33 - message one we're going to get the
790:34 - number of characters
790:36 - in this
790:38 - string here this is not going to count
790:40 - the null character though so the null
790:42 - character that is implicitly added in by
790:44 - the compiler is not going to be counted
790:46 - in here you're going to see this in a
790:48 - minute when we hit visual studio code to
790:50 - play with this thanks but this facility
790:52 - can work regardless of whether you are
790:55 - using a row array like this or even for
790:58 - pointers like this and it is really cool
791:00 - so we can use it like this we're going
791:02 - to get it printed out please note that
791:05 - we can also use the size of operator to
791:08 - get the same thing so it is going to
791:10 - work almost the same way but the size of
791:13 - operator is going to include the null
791:15 - character you need to be aware of this
791:17 - the good thing about str lan here is
791:20 - that it still works for a decade arrays
791:23 - so if we use it on message 2 we're going
791:25 - to get
791:26 - the correct output we're going to get
791:28 - the number of characters in here which
791:30 - is really cool
791:31 - and we can also try and print out the
791:34 - size of
791:35 - message two but here we're going to get
791:37 - the size of a pointer printed out okay
791:39 - that's how hdr lan works it lets you
791:43 - evaluate the length of a strand here is
791:45 - another example and it is str cmp or
791:49 - string compare it is used to compare
791:51 - strings what you're going to do with
791:53 - this facility is give it two strands c
791:56 - strands we should be exact
791:58 - and one is this guy here l h ace or left
792:02 - hand string i think that's what this
792:04 - stands for and we're going to give it a
792:06 - right hand strand and by the way these
792:08 - signatures are copied straight from the
792:11 - documentation so that we can look at
792:13 - this in one slide to make it really easy
792:15 - to follow this is going to return a
792:17 - negative value if the first guy happens
792:20 - to come before
792:22 - the second guy in lexicographical order
792:26 - so it is something like a comes in front
792:28 - of b c comes in front of d or something
792:30 - like that if the two strands are equal
792:33 - it is going to return
792:34 - zero and it's going to return a positive
792:37 - value
792:38 - if the first guy appears after the
792:40 - second guy
792:41 - okay and we're going to try it out we
792:43 - have two strings alabama and la bama
792:46 - here and they are stored in character
792:48 - arrays that are pointed to by these two
792:50 - pointers string data one and string data
792:52 - two and we can do something like this
792:55 - below here so we're going to print
792:56 - something out
792:58 - and we're going to say std string
793:00 - compare and we're going to pass in the
793:02 - first string and the second string for
793:04 - now i want you to pause a little bit and
793:06 - try to guess what we're going to get
793:07 - printed out here
793:09 - the first string is alabama the second
793:11 - one is blah blah so the first one comes
793:14 - in front of the second
793:16 - and we see that we're going to get a
793:18 - negative value if the first guy comes in
793:21 - front of the second guy so alabama comes
793:23 - in front of blabama
793:25 - and we would expect to get something
793:27 - negative from this thing we are doing
793:30 - here
793:31 - and again if we try and change them up a
793:33 - little bit you see that alabama still
793:35 - comes before a la bomb
793:38 - so we're going to get a negative value
793:39 - pointed out and we can change these
793:41 - things up to see what we get it is
793:43 - really simple if you know how to use
793:46 - them we can also use another version of
793:48 - string compare which is going to let us
793:50 - specify the number of characters that we
793:52 - want to compare
793:54 - we can specify that we want to compare n
793:57 - characters in this case it is three
793:58 - characters and it is going to compare a
794:01 - section of the strings that you specify
794:04 - as a first and second parameter here so
794:07 - for example if we change string that i
794:09 - want to be a a i a and string data two
794:12 - to b a a a n c a and we are comparing
794:16 - three characters in here so we are
794:17 - comparing aaa to aaa we're going to see
794:20 - that they are equal and we're going to
794:22 - get a 0 printed out here you're going to
794:24 - see that this is exactly the case when
794:26 - we get to play with us in visual studio
794:28 - code in a minute
794:30 - we have a facility that we can use to
794:32 - search in a string and search for a
794:34 - character the facility for that is sdr
794:37 - chr and it is going to find the first
794:40 - occurrence of a character in a string
794:43 - and the documentation for this is right
794:45 - here
794:46 - and please note that this example is
794:49 - actually copied
794:50 - straight from the documentation
794:52 - okay so we have a message here
794:55 - it is a character array and it is
794:57 - pointed to by a const car pointer called
795:00 - hdr and we have a target character that
795:02 - we are looking for
795:04 - and the result is going to be stored in
795:06 - the result character array here and we
795:09 - have a variable called iterations that
795:12 - is going to keep track of how many
795:14 - iterations we did to find our target
795:16 - here the way this guy works it is going
795:19 - to return a pointer to what you find
795:22 - if it is found for example in here if we
795:24 - find this first t this function here or
795:28 - this facility is going to return a
795:29 - pointer to this first t here
795:32 - if it doesn't find what we want it is
795:34 - going to return a null pointer that's
795:36 - how it works and you can see that in the
795:38 - documentation here we are going to take
795:40 - advantage of how it works in this while
795:42 - loop here and the way you use this
795:44 - facility you give it the strength you
795:46 - want to search in and you give it the
795:49 - character that you are looking for so if
795:51 - we look at how it works in the while
795:53 - loop here we are going to call the
795:55 - function
795:56 - and we are going to store the result in
795:58 - our character pointer here and if we go
796:01 - inside we're going to hit the first
796:03 - character here at the first iteration so
796:06 - we're going to find this t here and when
796:08 - we find it the result of this is going
796:10 - to be stored back in result here
796:12 - i hope this makes sense so we're going
796:15 - to find it we're going to print it and
796:17 - we're going to increment result to make
796:19 - it point to the next character this is
796:21 - pointer arithmetic in action here
796:24 - and after we do that we're going to
796:26 - increment the iterations so we should
796:28 - have one iteration by now and we're
796:30 - going to jump into the loop again so the
796:33 - string we search in is going to be
796:34 - starting from r here
796:37 - so we're going to try and find
796:39 - an uppercase tn and it is going to find
796:42 - this uppercase t here so it is going to
796:45 - point to it and the pointer to this t
796:48 - is going to be stored in this result
796:50 - here okay and we're going to jump into
796:52 - our body here we're going to say that we
796:54 - found this t we're going to print it out
796:57 - and we're going to increment results if
796:59 - we increment reserved now research is
797:01 - going to be pointing to the h here
797:04 - okay and we're going to
797:06 - say how many iterations we did to find
797:08 - our thing we will have printed out the t
797:11 - that we have found and we're going to
797:13 - jump to the next iteration which is
797:15 - going to be searching for t
797:17 - in the reminder of the string here it's
797:19 - not going to find it of course it's
797:20 - going to return no pointer and the test
797:22 - here is going to fail and we're going to
797:24 - fall down here and say how many
797:27 - iterations we found i realize this
797:29 - example can be really confusing i am
797:31 - going to try and explain it again when
797:34 - we hit visual studio code for now note
797:36 - that this facility can help you find
797:39 - characters in a string that's the
797:41 - message here there is also another
797:43 - function that helps you find the last
797:45 - occurrence of a character in a string
797:48 - for example here we have a character
797:50 - input
797:51 - it is a path to a file on some limit
797:54 - system or mac system
797:56 - and we have an output character pointer
797:59 - which is going to store the pointer to
798:01 - the character that we found okay if we
798:04 - find the character we're going to store
798:06 - in the pointer to that character if we
798:08 - don't find it we're going to return no
798:10 - pointer i think that's how this thing
798:12 - works
798:13 - so what we really want here
798:15 - is to hunt for the file name in this
798:18 - path here and this is really interesting
798:20 - so we're going to search for the
798:23 - backslash the last one and this string
798:26 - here and it is going to find this guy
798:28 - here because that's the last occurrence
798:30 - of the backslash
798:32 - in our input string here once we find it
798:34 - we're going to get a pointer to this guy
798:37 - stored in the output character pointer
798:39 - here and we're going to print it out
798:41 - what we're going to do we're going to
798:43 - use pointer arithmetic to move this
798:45 - pointer to the next guy because that's
798:47 - what we really want we want to print
798:49 - starting from the edge here and that's
798:51 - what we're going to get when we print
798:52 - this out
798:53 - now that we have looked at all these
798:56 - examples i think it is time we headed to
798:58 - visual studio code and actually played
799:00 - with them okay here we are in our
799:02 - working folder the current project is c
799:05 - string manipulation that's what we're
799:07 - going to work on we're going to copy our
799:10 - template files and we're going to put
799:12 - that in place
799:14 - and we're going to open this in visual
799:16 - studio code pretty quick let's include c
799:19 - string because that's what we're going
799:20 - to be using many of the things we're
799:22 - going to be playing with in this lecture
799:24 - are documented in this piece of
799:26 - documentation here so you can come here
799:29 - and get more details than we could even
799:31 - cover in a course like this let's bring
799:33 - this up a little bit and we're going to
799:35 - go in our main function and put in the
799:37 - first piece of code we can play with the
799:40 - str land facility is going to find the
799:43 - length of the strength and it's going to
799:45 - work regardless of whether you are using
799:48 - a row array like this or even if you are
799:50 - using the character pointer to point to
799:52 - your array and this is pretty cool so
799:55 - here we have strlen message one we're
799:57 - going to print that out we're going to
799:58 - print how many characters we have in
800:00 - this guy here
800:01 - we're going to also use the size of
800:03 - operator to try and compare these things
800:06 - but please know that the null character
800:08 - is going to be included if you use
800:10 - sizeof here on a row array
800:13 - this is very important to know
800:16 - but one interesting thing about hdr lan
800:19 - is that it is also going to work if you
800:21 - are storing your array
800:23 - and something that is pointed to by
800:25 - pointer so even decayed pointers
800:28 - are going to be usable here and this is
800:30 - pretty cool so we can also try and print
800:33 - the size of message 2 which is pointed
800:35 - to by a row pointer and we're going to
800:37 - see what we get but we know that we're
800:39 - going to get the size of a pointer
800:41 - because that's what it really is message
800:43 - two here is just a pointer okay let's
800:46 - close this on the left
800:48 - and we are going to bring up our
800:50 - terminal
800:51 - and i try and build this with gcc we're
800:54 - going to do that so we're going to use
800:55 - gcc to build this
800:57 - the world is going to go through
800:59 - and we're going to clear and run rooster
801:01 - again
801:02 - and this is going to give us what we
801:04 - want sqr lan message 1 is 16
801:07 - size of message 1 is 17 because sizeof
801:10 - is also going to count
801:12 - the null character htrlen message2 you
801:16 - see that it works even if
801:18 - we have a decayed array
801:21 - that is pointed to by a pointer and this
801:23 - is really useful if you happen to need
801:26 - the size of an array like this you can
801:28 - use hdr then and you're going to get the
801:30 - size of data in there but know that the
801:33 - null terminating character is not
801:36 - counted if you use hdr ln here and size
801:39 - of message 2 is going to be 8 because
801:42 - that's the size of a pointer on our
801:44 - system here so know that this guy is
801:47 - just a pointer
801:48 - okay that's the message here
801:51 - we are going to comment this out the
801:52 - next thing we're going to look at is
801:55 - strcmp which can be used to compare
801:57 - strengths
801:59 - so it works exactly like we say it's
802:01 - going to return something negative if
802:04 - the first string happens to come in
802:06 - front of the second string in
802:08 - lexicographical
802:10 - order
802:25 - for example here we have a few variables
802:26 - we have alabama and blabama there are
802:29 - strengths pointed to by
802:31 - pointers
802:32 - so they are c strings
802:34 - and we have a couple of other strings
802:37 - stored in row arrays like this and by
802:40 - doing this i want to prove that this
802:42 - facility is going to work regardless of
802:44 - how your array or your c string is
802:46 - stored so we're going to use that here
802:50 - for our
802:51 - c string pointer 2 by pointers
802:54 - we're going to try and compare whatever
802:56 - is in a string data one
802:58 - with string data two string data one has
803:01 - alabama string data two has blah blah so
803:04 - if we compare these guys we expect to
803:06 - get a negative value out of this thing
803:09 - here
803:10 - strcmp
803:12 - because alabama comes in front of
803:16 - blabama in our alphabet so a is in front
803:19 - of b so we're going to get a negative
803:21 - value out of this and we expect to get
803:23 - the same thing in the second example
803:25 - here which is going to be using what we
803:27 - store in our row array
803:30 - so make sure you understand this and
803:32 - we're going to try and build this to see
803:34 - that it passes through our gcc compiler
803:38 - the buzz is good
803:39 - so we're going to clear
803:42 - and run rooster and you're going to see
803:44 - that we get a negative one
803:46 - i want you to play with this thanks and
803:47 - try and change for example the 8 with c
803:50 - and see what you get
803:52 - okay we're going to try and build but
803:54 - before we do try to expect to see what
803:56 - you get c comes after blah blah
803:59 - so
804:01 - if we look at this description here we
804:03 - should get a positive value because
804:06 - the first guy comes after
804:08 - the second guy in lexicographical order
804:11 - so we should get a positive value
804:13 - for the first thing that we print here
804:17 - okay let's weld and see if that's the
804:19 - case we're going to build successfully
804:21 - we're going to clear and run rooster and
804:24 - you see that the first guy prints a one
804:26 - because
804:27 - cla gamma comes before blah blah
804:30 - and the second one is going to
804:32 - still be a negative one because we still
804:35 - have
804:36 - whatever we had before in there okay
804:38 - this is how you work with this thanks
804:40 - let's turn this back to alabama
804:42 - so that we are not confused
804:45 - and we're going to keep
804:47 - working on this and the next piece of
804:50 - code we are going to try and modify
804:51 - whatever is stored in string data 1 and
804:54 - string data 2 and print the comparisons
804:56 - out
804:58 - for example we have alabama and album
805:00 - and by the way we are able to modify
805:02 - that
805:04 - because it is a pointer to a strength
805:07 - and notice that this is not the
805:09 - conspirator so we can really change
805:11 - where this guy is pointing and that's
805:13 - what we are doing here but we can't do
805:15 - that with string data 3 and string data
805:17 - 4 because these are arrays and remember
805:20 - you can't change where an array points
805:23 - so this is going to compile nice but if
805:25 - we try and do the same thing with string
805:28 - data 3 and string data four
805:30 - let's do that you're going to get a
805:31 - compiler error
805:33 - so we're going to put this guy here and
805:35 - say three
805:37 - and four
805:39 - and we should see visual studio code
805:41 - complaining here because this is not
805:43 - allowed you're not allowed to make an
805:45 - array
805:46 - point to another location and this is
805:48 - just another
805:50 - character array or cost character array
805:52 - in memory that we want this pointers to
805:55 - point to or this array to point to and
805:57 - this is not possible so we're going to
805:59 - get a compiler error if we do this this
806:00 - is something i wanted you to know that's
806:03 - why i set up this example here so if we
806:05 - run this we're going to see the first
806:07 - line of output here
806:10 - or i think i should comment that out
806:14 - or let's not comment it out now if we
806:16 - run this program we're going to get the
806:18 - output for obama and alabama printed out
806:21 - and alabama comes after alabama so we
806:24 - expect to get a negative one because the
806:27 - first guy here comes in front of the
806:28 - second guy so we're going to get a
806:30 - negative one
806:31 - out of
806:32 - the
806:34 - thing we are doing here let's try in
806:36 - world with gcc
806:39 - the builder is going to be good so we're
806:41 - going to clear and run rooster and we're
806:43 - going to see that we have a negative one
806:45 - here alabama comes in front of a lab
806:49 - so this is cool so we can try and put in
806:51 - many other examples for you to play with
806:53 - i am going to do that because i don't
806:55 - want to type all this thanks and we're
806:56 - going to print the results out for
806:58 - example we put in india and france we
807:00 - put in kigali and kigali and we're going
807:02 - to get things printed out here so let's
807:04 - build this so that we don't waste time
807:08 - we're going to clear and we're going to
807:10 - run rooster
807:11 - and we're going to see that we get these
807:13 - things here alakama comes after alabama
807:15 - so we get a one
807:17 - india comes after france we get a one
807:20 - shigari comes together with kigali and
807:23 - we get a zero you can try and put in
807:24 - whatever you want these are just a few
807:27 - examples for you to play with and by now
807:30 - i hope you really understand how this
807:31 - function works or this facility works so
807:34 - we're going to comment it out whatever
807:37 - we did here
807:38 - so we're going to comment all this out
807:40 - so that we don't have noise output in
807:42 - whatever we want to do next and what we
807:44 - want to look at next is this function
807:47 - here which is going to compare
807:49 - strings in the same ways but we're going
807:51 - to tell it to compare however many
807:54 - characters in the string and you see
807:56 - that my string here has been commented
807:58 - up i can quickly take it and bring it
808:01 - down here let's do that i can't find
808:03 - that
808:04 - let's find that and copy it down
808:08 - and we're going to find them here so i'm
808:10 - going to find this
808:12 - and bring that down here so that i can
808:13 - compare these things so let's come down
808:16 - here and print and put in our
808:19 - declarations for this strengths and you
808:20 - see that visual studio code is happy now
808:23 - so what we're going to do is compare a
808:25 - set of characters in these strings here
808:28 - okay so we're going to compare any
808:31 - characters in our strengths so we're
808:32 - going to compare allah to blah here and
808:36 - allah is going to come in front of black
808:38 - so we're going to have a negative one
808:39 - printed out here but if we change the
808:42 - strengths to aaa and aaa here and
808:46 - compare the first three characters we're
808:48 - going to get a zero printed out because
808:50 - the first three characters are equal and
808:53 - again the special thing about this
808:55 - function is that it allows you to
808:56 - specify
808:58 - a number of characters you want compared
809:00 - in these two strings so you can say i
809:03 - want to compare three strands you can
809:04 - say i want to compare four strings or
809:06 - five
809:07 - just make sure that you don't go over
809:09 - the size of the string and if you do
809:12 - that it's not going to make sense what
809:13 - you are trying to do here if we go down
809:15 - here we're going to change n to 5 and
809:17 - we're going to be comparing all these
809:19 - things in here and we're going to get
809:21 - that
809:22 - the first one comes in front of the
809:24 - second one because i comes in front of n
809:28 - in our alphabet if we change the data to
809:32 - o here and n
809:33 - o is going to come after n and we're
809:35 - going to get a positive number printed
809:38 - out here we're going to try and run this
809:40 - so let's run the task to build with jcc
809:45 - the bullet is going to be good and we're
809:47 - going to clear and run rooster
809:49 - and we're going to see that alabama
809:51 - comes in front of blabama because we are
809:55 - comparing the first three characters
809:58 - if we have aaa in here and we compare
810:01 - the three characters you're going to see
810:02 - that they are equal we get a zero
810:04 - if we change i
810:06 - and n here we're going to get a negative
810:09 - one because i comes in front of n
810:11 - if we use o here and n we're going to
810:14 - get a one because o comes after n this
810:17 - is really simple to understand now that
810:19 - we know how to use the first version of
810:22 - string compare this version is just
810:24 - going to allow us to specify how many
810:27 - characters in the string we want
810:29 - compared so we're going to comment this
810:31 - out and we are going to go down and do
810:34 - another example that allows us to search
810:37 - for a character in a string
810:40 - and the method we use to do that is std
810:43 - str
810:45 - chr
810:46 - so this guy is going to find whatever
810:48 - target you want to find and if it finds
810:50 - that it's going to return you a pointer
810:52 - to dot's target if it doesn't find it
810:55 - it's going to return you no pointer so
810:58 - we set up an array here and we store
811:00 - that in a location that is pointed to by
811:03 - the pointer to character here and we say
811:06 - whatever target we are looking for in
811:08 - this case we want to find this t here
811:11 - we are going to set up another character
811:13 - array that is going to store our results
811:16 - the result is really going to be a
811:17 - pointer which is going to be pointing to
811:19 - something valid if we find the target
811:22 - and it's going to be no equator if we
811:24 - didn't find the target and we set up
811:26 - another variable which is going to store
811:28 - how many iterations we did we should
811:30 - really make this an unsigned integer or
811:32 - size t so let's make that here and we're
811:35 - going to loop here so the first time
811:37 - we'll open here we're going to call this
811:38 - guy we're going to say i want to find a
811:40 - t
811:41 - and result here and the result is going
811:43 - to be pointing to this line here because
811:45 - we did the assignment here so it's going
811:47 - to go and try to find the t it's going
811:49 - to find the guy here at the first index
811:52 - and the test here is going to succeed
811:55 - when it succeeds it's not going to be
811:57 - equal to no pointer it's going to be
811:59 - pointing to a valid pointer
812:01 - and it's going to succeed and return the
812:04 - pointer to be stored in resort after
812:07 - this guide returns the pointer is going
812:09 - to be stored in the result here and
812:11 - that's going to be a pointer to this
812:13 - team and we're going to jump in the body
812:15 - here i really want you to understand how
812:16 - this thing is going to work
812:18 - once we get to the body we're going to
812:20 - say uh-huh we found our target that's
812:22 - going to be our t print it out and it's
812:24 - going to start at this location
812:26 - okay and we're going to print starting
812:29 - from the t here because that's what our
812:32 - result here is pointing to after we do
812:34 - that we're going to increment the result
812:36 - to make it point to the next character
812:39 - if we do that with pointer arithmetic
812:41 - now we're going to be pointing to the r
812:43 - in here
812:44 - i hope this makes sense and we're going
812:46 - to increment our iterations so we're
812:48 - going to say we have done one iteration
812:51 - and we're going to try and run this
812:52 - again and by the time we get in here
812:55 - we're going to have this string here in
812:58 - which we are searching for a t
813:00 - and it is going to be found starting at
813:03 - this second t here there here
813:06 - and it's going to find it
813:08 - it's going to store the pointer to it to
813:11 - resort here or i should say the search
813:14 - is going to be successful so we're going
813:16 - to find the pointer to this t
813:18 - and return it from this function here
813:21 - and the pointer is going to be stored in
813:23 - our result
813:24 - pointer here we're going to jump in the
813:26 - body and we're going to print we found
813:29 - the target starting at this t we're
813:31 - going to print that out and stdc out is
813:33 - going to print until it meets an old
813:35 - character so we're going to print this
813:37 - thing through the end and we're going to
813:39 - put a slash n which is going to move us
813:42 - to the next line after we do that we're
813:43 - going to increment result
813:45 - and uh result now is going to point to
813:48 - the h here
813:50 - and we're going to increment iterations
813:52 - now we're going to have done two
813:54 - iterations by now and we're going to run
813:57 - the loop again this time the loop is
813:59 - going to fail because starting from here
814:01 - we don't have a t
814:03 - and that this function is going to
814:04 - return no pointer and this test here is
814:07 - going to fail okay we are going to
814:09 - return no pointer no pointer is not
814:12 - going to be different from no pointer so
814:14 - this is going to fail and we're going to
814:16 - fall down here and say how many
814:18 - iterations we're going to find so in
814:20 - total we're going to do two iterations
814:22 - and we are going to find two t's and
814:24 - we're going to print whatever we find
814:26 - here make sure you really understand
814:28 - this
814:28 - and i put in this example on purpose
814:31 - because it is a little complicated but
814:34 - it is going to really bring your game up
814:36 - in how you use these functions from the
814:39 - c plus plus standard library and you
814:41 - really need to know this if you have any
814:43 - problem with this
814:45 - be sure to ask me i will do the best i
814:47 - can to help you out so we're going to
814:49 - build this and run this we're going to
814:51 - build with gcc as always and we are
814:53 - going to clear and run rooster and
814:56 - you're going to see that we are looking
814:57 - for t
814:58 - we are going to say we found t starting
815:01 - at the t here so we're going to say try
815:04 - okay we're going to print all the
815:06 - message out and the second iteration is
815:08 - going to find t
815:10 - starting at this location here and we're
815:12 - going to do two iterations in total
815:14 - we're going to comment this out and
815:16 - again if you don't understand this
815:18 - please go through it again and if you
815:20 - still don't understand be sure to ask me
815:23 - i am going to do the best i can to help
815:25 - you out and some of you might be asking
815:28 - why did we go through the trouble to
815:30 - store this guy in a result
815:34 - why don't we use htr
815:36 - in the first place in here
815:38 - and the explanation i can come up with
815:40 - is that you don't really want to modify
815:43 - this guy here because somebody is going
815:45 - to look at this thing and say
815:47 - this is the message i have in sdr here
815:50 - but if you try and modify this in the
815:52 - loop it's going to be messed up because
815:53 - you're going to be incrementing it and
815:55 - doing all kinds of crazy things on it so
815:57 - you don't really want to modify this so
816:00 - a better way to even do this is to mark
816:02 - this as a const pointer and we know how
816:05 - to do that so we can say cost here and
816:08 - if you even try to increment htr
816:10 - somewhere you're going to get a compiler
816:12 - error
816:13 - so let's make sure we see that for
816:16 - example we try and do plus plus sdr
816:19 - we're going to get a compiler error
816:20 - because this is a const pointer by now
816:22 - and this is much safer
816:25 - okay
816:26 - we're going to comment this out and show
816:28 - you something that might throw off many
816:31 - of you guys so we're going to comment
816:32 - this out and i am going to bring that in
816:35 - okay let's go down here
816:38 - and we are going to do basically the
816:39 - same thing
816:41 - but we will try
816:43 - and use str in the first place here
816:46 - okay this is how we're going to do this
816:48 - we're going to have our string we're
816:50 - going to have our target we're going to
816:51 - have our result here which is equal to
816:53 - null pointer and we have our iterations
816:56 - which is an integer let's make this a
816:58 - size t and what we're going to do in
817:00 - here we're going to use htr to search
817:03 - okay and we're going to basically do the
817:06 - same checks we're going to jump in here
817:08 - and say we found the target starting at
817:10 - result and we're going to increment hdr
817:13 - here because it is not a constrainer now
817:16 - try to go through this thing here and
817:18 - see how many times you're going to loop
817:21 - okay go through it and when you are done
817:24 - we're going to try and run this we're
817:26 - going to build with gcc the build is
817:28 - going to be good we are going to clear
817:31 - and run rooster and you see that this
817:34 - guy is going to look 25 times
817:37 - and this is crazy why is this happening
817:39 - why is this happening
817:41 - what we really are doing here we are not
817:44 - assigning the result in this trend that
817:48 - we are searching at
817:49 - okay let's try and go through this a
817:51 - couple of times so the first time we're
817:53 - going to do our search okay so we're
817:56 - going to search in sdr
817:58 - and if we find our target we're going to
818:01 - return the pointer to the target
818:03 - if we don't find it we're going to
818:05 - return a null pointer the first time
818:07 - we're going to find this t here okay and
818:09 - we're going to return a pointer to it
818:10 - and store that in result
818:13 - okay so after we do this we're going to
818:15 - fall in our body here
818:17 - and we're going to say we found t
818:19 - starting at this location here that's
818:21 - going to work and we're going to
818:23 - implement str okay notice that we're not
818:27 - incrementing result here
818:29 - if we increment sdr it's going to point
818:31 - to the next character which is r here
818:34 - okay
818:35 - and we're going to increment our
818:36 - iterations and we're going to start in
818:38 - loop again
818:39 - we're going to search in here
818:41 - and we're going to be searching from
818:43 - this location here
818:44 - and we're going to find the t starting
818:46 - at this location we are going to find
818:48 - this t here and we're going to
818:50 - return that and store that in reserved
818:53 - but the problem is that what we are
818:55 - incrementing here but the problem here
818:58 - is that we are incrementing one by one
819:00 - we are not jumping to this t here and we
819:03 - had a way to jump to this t
819:06 - by assigning the result into the same
819:09 - variable that we are searching in okay
819:11 - so this is going to loop 25 times and it
819:13 - is not really good and some of you might
819:16 - try to set up something like this and it
819:18 - is really not going to be good try to go
819:20 - through this and you're going to see the
819:22 - reason why it is looping 25 times okay i
819:25 - wanted you to see this don't do
819:27 - something like this and we are going to
819:28 - comment this out the next thing we're
819:30 - going to see is how we can find the last
819:32 - occurrence of the character and this is
819:35 - a really cool example i like it it is
819:37 - going to do something very practical we
819:39 - are going to take a path which is going
819:41 - to be an array basically stored in this
819:43 - input array and we're going to strip off
819:46 - all the things we don't need and we're
819:47 - going to hunt down for the file name
819:50 - from a full path and this can be useful
819:53 - in whatever application you are doing so
819:55 - we are going to hunt for the last
819:57 - occurrence of a backslash character
820:00 - using the str or
820:03 - chr facility in the ziploc squad
820:06 - standard library and you can find the
820:08 - documentation on this guy here i'm not
820:09 - going to go there you should really
820:11 - practice to go there and read what these
820:13 - things do that's why i am living in the
820:16 - lens to the documentation you should go
820:18 - there and read and if you have a problem
820:20 - you can ask me i will do the best i can
820:22 - to help you out
820:24 - so this line here is going to hunt for
820:26 - the last
820:27 - backslash it's going to find this guy
820:29 - here and we're going to store a pointer
820:31 - to that in our output character pointer
820:33 - here after we do that we're going to say
820:35 - if we found something useful if this is
820:38 - not no pointer we're going to print that
820:40 - out but we don't want to print starting
820:42 - from the backslash we are going to use
820:44 - pointer arithmetic and move to the next
820:47 - character which is going to be this h
820:49 - here so if we print this out we're going
820:51 - to have hello cpp printed out because
820:54 - sddc out is going to print until it
820:56 - meets
820:57 - the last now character and that's going
821:00 - to be after the last p here because this
821:03 - is a c string let's roll here okay we're
821:05 - going to build this the build is going
821:07 - to be good we're going to clear
821:09 - and run rooster and you're going to see
821:11 - that we have hello cpp
821:13 - printed out here okay this is really all
821:15 - we set out to do in this lecture i
821:17 - apologize that it turned out to be
821:19 - lengthy these things can take long to
821:22 - explain and i really wanted you guys to
821:24 - have as many explanations as i could
821:27 - come up with
821:28 - we are going to stop here in this
821:30 - lecture the next one we're going to see
821:31 - how we can copy and concatenate
821:34 - c strings using the facilities from c
821:38 - string here go ahead and finish up here
821:41 - and meet me there
821:42 - in this lecture we're going to look at
821:44 - a few more facilities from the c string
821:47 - library and those are going to allow us
821:50 - to concatenate and copy strings over the
821:53 - documentation for what we're going to be
821:54 - talking about can be found here if you
821:57 - go there you're going to fall on this
821:58 - link here and you're going to
822:00 - find that c string was originally in the
822:03 - c standard library as string dot h but
822:07 - in c plus plus we can use it like this
822:10 - we have a couple of functions we can
822:11 - copy stuff we can concatenate we can get
822:14 - the string length we have seen this but
822:17 - now we're going to look at things that
822:18 - allow us to copy and concatenate stuff
822:21 - because
822:22 - that's something you may want to do a
822:24 - lot the first example we're going to
822:26 - look at is
822:27 - stdstr cat which is going to allow you
822:30 - to join strengths
822:32 - again you can browse to the
822:34 - documentation here and see more about
822:36 - this facility here and you're going to
822:38 - see all about it for now we're just
822:40 - going to play with it we're going to set
822:42 - up two arrays one is going to be called
822:44 - dest
822:45 - it's going to contain hello the other is
822:47 - going to be source here and it's going
822:49 - to contain worlds notice that these are
822:51 - row static arrays that are stored on the
822:54 - snap
822:55 - and uh that's how we set them up here
822:57 - okay so we can concatenate strengths
822:59 - using the syntax like this we're going
823:02 - to say hdd hdr cache we're going to say
823:04 - the destination string and we're going
823:07 - to say the source string we want to copy
823:09 - from okay so after we do this the
823:11 - destination is going to contain
823:13 - these two strings joined together and
823:16 - before you do this you have to be sure
823:19 - that your destination strength is big
823:22 - enough and this is a problem because you
823:24 - have to really keep track of your
823:26 - destination strength and it is easy to
823:29 - put in many more characters that can
823:31 - really fit in the destinations rank
823:34 - that's the reason many of these
823:36 - functions here are considered unsafe by
823:38 - many compilers i don't think you can
823:40 - compile this on visual studio it's going
823:42 - to stop you from doing this because of
823:45 - this
823:46 - way
823:47 - you have to keep track of things
823:48 - yourself but i am just showing you so
823:51 - that you know how to avoid these
823:53 - problems if you happen to be on a
823:55 - compiler that doesn't protect you from
823:57 - this so we're going to append goodbye
823:59 - world to whatever is in dust and down
824:02 - here if we print this we're going to
824:04 - have hello world goodbye world printed
824:06 - out we are going to play with this in a
824:08 - visual studio code in a minute don't
824:10 - worry if any of this doesn't make sense
824:13 - yet here is another example of how we
824:15 - can join strengths through strcat
824:18 - we have two strengths and we set them up
824:20 - with a simple characters like this you
824:22 - can do this and put in your own now
824:25 - terminating character this is a legal c
824:28 - plus plus could and notice that this
824:30 - array is a dynamic array it's going to
824:32 - leave on the hip because of this new
824:34 - operator here we also have a source
824:37 - array which is also going to leave on
824:39 - the hip it is 30 characters long so it
824:42 - is really long and we're going to try
824:44 - and concatenate stance here but before
824:46 - we do that we're going to check their
824:48 - length we're going to print them out and
824:50 - we are going to concatenate the syntax
824:52 - is the same you are going to say hdr cat
824:55 - you're going to specify your destination
824:57 - and your source you're going to be
824:58 - copying stuff from and you are going to
825:01 - store the result in destination here
825:03 - what this is going to do it's going to
825:05 - grab whatever is in source and copy it
825:08 - so it's going to copy the entire thing
825:09 - here from source and it's going to
825:11 - append that to whatever we have in
825:13 - destination starting from the last null
825:17 - character here so it's going to
825:19 - overwrite from this null character and
825:21 - it's going to basically copy everything
825:23 - and the destination here and if we print
825:26 - whatever we have in destination here
825:28 - we're going to have firelord
825:30 - the phoenix kind of printed out and
825:32 - you're going to see that this is going
825:33 - to be the case when we hit visual studio
825:36 - code in a minute you can also use a
825:37 - version of the sdr cat version that is
825:40 - going to allow you to specify
825:42 - how many characters you want to
825:45 - concatenate from the source string in
825:48 - this case we have destination which is
825:50 - hello and we have source which is there
825:51 - is a bird
825:53 - on my window
825:55 - and down here you see that we do hdr and
825:58 - cat we save the destination we save the
826:00 - source and we say how many characters we
826:03 - want copied from the source here and we
826:06 - say six characters so we are going to
826:08 - count from the source we're going to say
826:10 - one two three four five six we're going
826:12 - to grab this their string with this
826:14 - space here and we're going to append
826:17 - that to the source and that's what we're
826:18 - going to get in here we're going to say
826:21 - hello space and there and that's what
826:24 - we're going to have printed out here if
826:26 - we print dust we can also copy stuff and
826:29 - the str cpy function here is going to do
826:32 - that and here we have an example that is
826:34 - going to try and drive this home for you
826:37 - we have a source strength which is c
826:39 - plus plus is a multi-purpose programming
826:41 - language okay guest three here is going
826:44 - to be the same length as the source we
826:46 - made sure of that in here because we're
826:48 - going to grab the length of the source
826:50 - strength please remember that sdrlam is
826:53 - not going to count
826:54 - the null character that's why we are
826:57 - adding a one here to account for the
826:59 - noun terminating character here okay
827:01 - after that we're going to jump down here
827:03 - and say htr cpy dest 3 and source 3 we
827:07 - are basically going to be copying from
827:10 - source and pasting
827:12 - in destination here that's what we are
827:14 - doing if we print destination we're
827:16 - going to see that now it's going to
827:17 - contain whatever we had in source and
827:20 - this is how you can use these methods
827:22 - here we also have a version
827:25 - with which we can specify how many
827:27 - characters we want copied from the
827:29 - source here we have a source string
827:31 - which is hello we have a destination
827:33 - string which is zest 4 and we are going
827:36 - to copy stuff we're going to copy from
827:38 - the source we're going to paste in the
827:40 - destination and we are just going to
827:42 - copy five characters what this is going
827:45 - to do is copy everything from the source
827:48 - and paste in our destination and it is
827:51 - going to override whatever we have in
827:54 - the starting indexes in destination here
827:57 - so we're going to have a b c d e here
827:59 - replaced by hello and if we print this
828:02 - here we're going to have hello f printed
828:05 - out this is how these things work and if
828:08 - you wonder how i know how these things
828:10 - work i just come and read the
828:12 - documentation here for example htr and
828:15 - cpy here if we click on it we are going
828:17 - to get the documentation this is going
828:19 - to say copies at most count characters
828:22 - of the byte string
828:23 - source including the null terminating
828:26 - character to the character array pointed
828:28 - to by desk that's what it does we have
828:30 - the destination we have the source and
828:33 - we have how many characters we want
828:34 - copied and they say a few things you
828:36 - need to be careful about this guy here
828:38 - one thing that you usually care about is
828:41 - the return value you see that the return
828:43 - value is going to be the destination
828:45 - strength so if you want this pointer you
828:47 - can use it and you can go down and look
828:50 - at a few examples here and play with
828:52 - them to really drive the point home okay
828:55 - now that you have an idea about how
828:57 - these guys work we are going to head
828:59 - over to visual studio code and play with
829:02 - them
829:02 - right away okay here we are in our
829:05 - working folder the current project is c
829:08 - string concatenation and copy that's
829:10 - what we are doing here we're going to
829:12 - copy our template files and uh jump to
829:15 - our current project and put them in
829:18 - place we're going to open this in visual
829:20 - studio code pretty quick we are going to
829:22 - include c string because that's what
829:24 - we're going to be using here we are
829:26 - going to bring this up a little bit and
829:28 - we are going to put in our first example
829:30 - here we have two strengths
829:32 - destination and source and you see that
829:35 - we tried and made sure that they are
829:37 - large enough to contain however many
829:39 - characters we want to put in
829:42 - and they are row arrays stored on the
829:44 - stack because they are set up like this
829:47 - and again you can check out the
829:49 - documentation here if you want to know
829:51 - how this function works and we are going
829:53 - to call strcat here to concatenate the
829:57 - source to our destination here so if we
830:00 - do this we're going to have world here
830:02 - concatenated to what we have in hello
830:05 - here and we're going to have hello world
830:07 - in place for example if we try and print
830:10 - this out i'm going to try and do that
830:13 - after we do the first concatenation here
830:16 - let's do that that's going to be better
830:18 - to show you how these things work okay
830:20 - after the first function here runs we're
830:23 - going to have source concatenated to
830:26 - destination here so what we're going to
830:28 - have is hello world stored in
830:30 - destination here the second
830:32 - concatenation here is going to append
830:34 - goodbye world to whatever we have in
830:37 - destination here so what we're going to
830:39 - have printed down is if we print that of
830:42 - course is hello world and goodbye world
830:44 - okay we're going to have this written
830:46 - down let's try and run this and actually
830:49 - make sure that that's the case and then
830:51 - we're going to see how this function can
830:53 - be unsafe for some compilers we're going
830:56 - to build this with gcc you see that it's
830:58 - going to go through
831:00 - and if we run this we're going to have
831:01 - hello world hello world goodbye world
831:04 - printed out this is what we expect and
831:06 - again
831:07 - this function here sdr cat is going to
831:10 - have whatever you have in source and it
831:12 - is going to append that to whatever you
831:14 - have in destination and for this to work
831:17 - you have to be sure that the destination
831:19 - is modifiable for example if it was an
831:22 - array of cost core let's do that and
831:25 - show you the compiler error we should
831:27 - get a compiler error because now
831:29 - destination is not modifiable it is an
831:32 - array of cost characters and we can't
831:34 - modify it so be sure
831:37 - the destination array is modifiable and
831:40 - in this case it is okay please note that
831:42 - some of these functions can be treated
831:44 - as unsafe by some compilers but i tried
831:47 - this out on both on gcc and the compiler
831:50 - from microsoft and they work pretty well
831:52 - so you can try them out here to prove
831:54 - that let's go and try and build with the
831:57 - compiler from microsoft we have it
831:59 - set up here
832:01 - so we're going to run the task to build
832:02 - with msvc here
832:05 - and you're going to see that the world
832:06 - is going to be good the world finished
832:08 - successfully and if we go and we're
832:11 - going to clear
832:12 - and run rooster you're going to see that
832:14 - it is going to do exactly the same thing
832:16 - but some compilers might give you
832:18 - warnings or errors if you try to do
832:20 - something like this and the reason is
832:22 - you really have to be careful using
832:24 - these functions because if for example
832:26 - destination array is not large enough
832:29 - you may do some crazy things running
832:32 - over the balance of your array and it
832:33 - can be really bad for example if we try
832:36 - and make destination array here for
832:38 - example a size of three it is possible
832:41 - to do that and you see that we get a
832:43 - warning from visual studio code and if
832:46 - we try and build this with gcc let's try
832:49 - and remove the garbage we have from
832:51 - visual studio first now that this is
832:54 - clean we can uh try and build with gcc
832:58 - let's do that our compiler we're going
833:00 - to choose gcc and you're going to see
833:02 - that it's going to give you an error
833:03 - it's going to actually protect us from
833:05 - doing something like this but in some
833:08 - cases some compilers are not going to
833:10 - stop you from doing this but any
833:12 - compiler that really respects itself
833:15 - it's going to have these safety checks
833:17 - in and it's going to protect you from
833:19 - doing something crazy like this okay
833:21 - this is how you can do concatenation
833:23 - using hdr cat like we did here let's try
833:27 - and weld and see that now we are
833:29 - building fine because i don't like these
833:31 - red lines here the world is good and we
833:33 - are all fine now i am going to comment
833:36 - this out
833:37 - and we're going to see another example
833:38 - of how we can concatenate stuff we are
833:41 - going to go down here let's bring this
833:43 - down and hide this
833:45 - and we are going to put in our simple
833:47 - example exactly the same thing we saw in
833:49 - the slides we have two
833:52 - character arrays they are dynamic arrays
833:55 - but we initialize them with characters
833:57 - like this and we make sure to put in our
834:00 - null
834:00 - terminator we have our source strength
834:03 - which is going to say the
834:05 - femix king and it's going to have a
834:07 - terminator here
834:08 - and what we're going to do we're going
834:10 - to take soros and concatenate that to
834:13 - our destination so what is really going
834:15 - to happen we are going to overwrite the
834:17 - null terminator here and we're going to
834:19 - start pasting in things from source here
834:22 - so after the concatenation is done what
834:24 - we are doing here we are concatenating
834:27 - source one to test one
834:29 - we are going to have fire lord the
834:32 - phoenix kang stored in our destination
834:35 - string here
834:36 - and notice that we made sure that
834:39 - large enough to contain our characters
834:42 - here and if we print it out we're going
834:44 - to have the thing printed out we can try
834:46 - and weld with gcc that's going to go
834:49 - through let's bring this up the bulb is
834:51 - good
834:52 - if you go down here the build is good
834:54 - we're going to clear and run rooster
834:57 - okay this is the output here you see
834:59 - that the destination is eight characters
835:01 - long if we count one two three four five
835:05 - six seven eight remember sdrl lan
835:08 - doesn't count the null character so this
835:10 - is what we expect eight characters the
835:12 - source is going to be 17 characters if
835:14 - you count all this that's what you're
835:16 - going to get
835:17 - and if we concatenate them now this
835:19 - donation is going to be
835:21 - 25 characters long
835:24 - in the eyes of hdr land and you see that
835:26 - we print the destination and it is
835:28 - exactly what we expect fire lord the
835:31 - phoenix gang okay we're going to comment
835:34 - this out i just wanted you to see an
835:35 - example of this and the one thing i
835:37 - really want to stress in this example
835:40 - is that strcat is going to start
835:42 - overriding whatever is in dust starting
835:45 - at the last null character okay so this
835:49 - guy is going to be overridden by the
835:52 - comma here and we're going to start and
835:54 - putting stuff and that's what we're
835:55 - going to see here let's comment this out
835:58 - because we want to move on and show you
836:00 - a few other examples okay the next thing
836:02 - we're going to look at is a new version
836:04 - of str cat that allows you to specify
836:08 - how many characters you want
836:09 - concatenated
836:11 - from source for example here we have two
836:13 - strengths destination and source and
836:16 - here we are basically saying i want to
836:19 - concatenate six characters from source
836:22 - and put them at the end of the
836:24 - destination here and what it's going to
836:26 - do it's going to grab one two three four
836:30 - five six it's going to grab this entire
836:33 - thing and it's going to append that to
836:35 - hello and we're going to have hello
836:37 - there stored in the destination and the
836:40 - return value is going to be a pointer to
836:42 - destination 2. and how do i know the
836:44 - return value well i know that from the
836:47 - documentation if you go in your favorite
836:50 - search engine and do
836:51 - stdstr and cat and you're going to see a
836:54 - link here if you click on it from cpp
836:57 - reference it's going to give you
836:58 - everything you need to know about this
837:00 - function here it's going to append
837:02 - source to destination and and count
837:05 - characters are going to be copied so the
837:07 - third parameter here is going to be how
837:09 - many characters you want copied and
837:11 - pasted into our destination
837:14 - and the return value is going to be dest
837:16 - okay if we try this out we're going to
837:18 - see hello there printed out we're going
837:20 - to print it out directly and we're going
837:22 - to print that out
837:24 - using the destination pointer that is
837:26 - going to be returned from this guy here
837:29 - so if we try and build this we're going
837:30 - to build with gcc the bullet is going to
837:33 - be good we're going to clear and run
837:35 - rooster and you're going to see that we
837:37 - have hello there twice here and this is
837:39 - exactly what we expect
837:41 - we are going to comment this out and we
837:43 - are going to go down and look at sdr cpi
837:48 - i should say sdr cpy which is going to
837:51 - copy stuff from the source and paste
837:53 - those in the destination and one thing
837:57 - you should know is that the copy is
837:59 - going to happen starting from the start
838:01 - of the destination array here we have
838:03 - two arrays one is called source three
838:06 - the other is called destination three
838:08 - destination 3 is set up on the heap
838:11 - using the new operator so it is a
838:12 - dynamic array and you see that we make
838:15 - sure that it is the same size as the
838:17 - source
838:18 - we are using sdr lan to figure out how
838:21 - many characters we have in here
838:23 - and remember that sdr land doesn't
838:26 - account for the null character so we are
838:28 - adding one to account for the null
838:30 - character that's what we are doing here
838:32 - and after that we are going to do std
838:34 - str cpy and what that is going to do is
838:38 - copy stuff from source to destination
838:41 - character by character so we are
838:42 - basically going to have this guy pasted
838:46 - into destination here and if we print
838:48 - things out we're going to see that
838:50 - destination contains the same thing as
838:52 - source here if we built this with gcc
838:55 - let's do that the build is going to be
838:57 - good we can clear
838:58 - and run rooster and you're going to see
839:00 - that the destination has exactly the
839:03 - same thing we had in the source and if
839:05 - you need to copy stuff from arrays sdr
839:08 - cpui is going to be very helpful
839:11 - we are going to comment this out because
839:13 - we still have a few things we want to
839:15 - see
839:15 - so let's comment this out we are going
839:18 - to go down and see that we can also use
839:20 - a another version that allows us to
839:23 - specify how many characters we want
839:25 - copied from the source okay in this
839:28 - example here we are using std str and
839:31 - cpy and this n here means that we can
839:34 - specify the count of characters we do
839:38 - whatever
839:39 - the current function is doing here okay
839:41 - so we are specifying i want five
839:43 - characters copied from source and i want
839:46 - those pasted into destination here
839:49 - that's what we are saying here and the
839:51 - source is going to contain hello
839:53 - destination is going to contain the
839:54 - world and the copy is going to happen
839:57 - starting at the first index here so
840:00 - we're going to have hello override
840:02 - whatever we have in a b c d e because
840:05 - that's five characters here and the dust
840:07 - is going to contain hello f if we print
840:10 - it out let's build this and see if
840:12 - that's what we're going to get we're
840:14 - going to build with gcc the build is
840:16 - going to go through
840:17 - we are going to clear and run rooster
840:20 - and you see that that's exactly what we
840:22 - have here
840:23 - okay this is how these methods work
840:25 - there are many more functions you can
840:27 - use
840:27 - from the c string library and again if
840:30 - you want to see
840:32 - a list of them all you can go through
840:34 - your
840:36 - favorite search engine and search for c
840:38 - string
840:40 - and we can specify cpp reference here
840:43 - let's try and do that okay we can find a
840:45 - link to that we can click on that and
840:47 - it's going to open up and show us many
840:49 - more functions we can use and if you
840:52 - need to know about a special function
840:53 - you can click on it and see what it does
840:55 - and if you go down you're going to find
840:57 - even an example of how you can use it
840:59 - for now we are going to stop here in
841:01 - this lecture and this is actually going
841:03 - to be the last lecture we see on c
841:05 - strings the next one we're going to
841:07 - start and look at std strength which is
841:10 - a compound type that makes working with
841:12 - strengths
841:13 - very easy in c plus plus
841:16 - go ahead and finish up here and meet me
841:18 - there in this lecture we're going to
841:20 - start and learn about hdd strength which
841:23 - is a type that is going to make it super
841:25 - easy to work with string data we have
841:28 - seen many ways we can work with
841:30 - character arrays by now we can use row
841:32 - rays we can point to them with pointers
841:35 - we can even allocate arrays on the hip
841:37 - but all these character arrays had a few
841:40 - problems that are really a pain in the
841:43 - neck to deal with on a daily basis
841:46 - one of those problems was that you had
841:48 - to keep the size in check you have to
841:50 - know how many
841:51 - elements you have in the character array
841:54 - and that was defining the bounds that
841:57 - you can work in if you go over bounds we
842:00 - have seen that that can cause crashes of
842:02 - your program and you don't want that
842:04 - another problem was that we had 3d to
842:07 - remember to keep track of the null
842:09 - character if we don't have it in place
842:11 - we're going to have problems when our
842:13 - string is printed out and it's really
842:16 - annoying to always have to think about
842:18 - these little details when all you really
842:21 - want is to store a strand so c plus plus
842:24 - offers a high level type that we can use
842:27 - and it is going to hide all these little
842:29 - details underground and all we have to
842:32 - do is put in our string and use it and
842:35 - we can be on our merry way and do
842:37 - whatever we want to do with string data
842:39 - in our c plus plus application so that's
842:41 - what we're going to do we're going to
842:42 - have a type that is going to wrap on top
842:44 - of the ugly array computations we have
842:47 - been doing on character arrays we're
842:50 - going to call that std string and we're
842:52 - going to be able to do many of the
842:54 - things we were doing with c strings but
842:57 - in a much better way we can concatenate
842:59 - we can search we can copy we can do all
843:01 - kinds of crazy things really but it's
843:04 - going to be in a way that you don't have
843:06 - to worry about these little details
843:08 - about array bounds the null character
843:10 - you're going to just use it for what you
843:12 - want which is storing character or text
843:16 - data okay so that's what we're going to
843:17 - be doing in the next few lectures we're
843:19 - going to be learning about std string
843:21 - and how you can use it in your c plus
843:22 - plus applications and it's going to make
843:25 - your life a whole lot easier we are
843:27 - going to stop here in this lecture the
843:29 - next one we're going to see how you can
843:30 - declare initialize and use std strength
843:34 - in your c plus plus application go ahead
843:36 - and finish up here and meet me there and
843:39 - this lecture we're going to see how you
843:40 - can declare and use hdd strength in your
843:43 - c plus plus applications
843:45 - std strength is a type that is going to
843:47 - wrap on top of arrays and give us a
843:49 - really nice interface
843:51 - that we can use to
843:53 - store string data without having to deal
843:55 - with the ugly little details like
843:58 - keeping track of array bound remembering
844:00 - to keep in check the null character and
844:02 - things like that to use std strength you
844:04 - will need to include the string library
844:07 - and after you do this you can declare
844:09 - and use your strings just like this here
844:11 - we have a series of examples just to get
844:14 - you started on this you declare your
844:16 - strengths just like you declare any
844:18 - other time you specify the type on the
844:20 - left the type is going to be std
844:22 - strength by the way you'll have to
844:24 - remember to use std column column like
844:26 - this and we will have a chance to
844:28 - explain why in a few chapters ahead but
844:32 - for now we're just going to think of std
844:34 - strength as a type so we declare a
844:37 - string type we call it full name and we
844:39 - can leave it like this uninitialized and
844:41 - it is going to be an empty strand we can
844:43 - also put in our string and initialize
844:46 - that with a string literal and it is
844:48 - going to work another way of doing this
844:51 - is initializing a string with another
844:53 - string which we are doing down here you
844:55 - can also set up another string and
844:57 - initialize it with part of another
844:59 - string literal so for example message
845:02 - here is going to be hello and it's only
845:04 - going to grab five characters from this
845:06 - string literal this is something you
845:08 - might want to do
845:09 - if it makes sense for whatever
845:10 - application you are doing here we can
845:12 - also initialize our strength with
845:15 - multiple copies of one character and
845:18 - this is the syntax to do it you say
845:20 - the name of your variable you say
845:22 - however many times you want the
845:23 - character repeated and you say which
845:25 - character it is just like this we can
845:28 - also initialize a string with part of
845:31 - another existing string so for example
845:34 - here we have saying hello and it is
845:36 - initialized with part of what we have in
845:39 - greeting here so we're going to start at
845:41 - index 6 which is going to be
845:44 - 0 1 2 3 4 5 6 on the w here and we're
845:48 - going to grab five characters so one two
845:51 - three four five and that's what we're
845:53 - going to use to initialize this saying
845:54 - hello here and if we print it out we're
845:56 - going to see that this is going to be
845:59 - exactly the case so hopefully you can
846:01 - see that it is easier you don't have to
846:03 - use pointers you don't have to use
846:05 - arrays and the best part is std strength
846:08 - can grow automatically if you happen to
846:10 - store in more characters than you
846:12 - initialized it with in the first place
846:15 - and that's pretty cool so now we're
846:16 - going to head over to visual studio code
846:19 - and play with us so that you can see for
846:20 - yourself okay here we are in our working
846:23 - folder the current project is declaring
846:26 - and using std strength which is what we
846:28 - are doing here we're going to grab our
846:30 - template files pretty quick and we're
846:32 - going to go and store in the files and
846:34 - we're going to open the folder and we're
846:36 - going to include the strength library
846:38 - let's do that okay this is how we do it
846:41 - and now that we have it included in our
846:44 - project we can start declaring and using
846:47 - std string
846:48 - types in our c plus plus program we are
846:51 - going to go down and put in the code to
846:53 - play with this a little bit so you can
846:55 - declare an empty string like this and
846:57 - it's not going to have anything inside
846:59 - you can declare a string and put in a
847:02 - string literal like we are doing here
847:04 - and std string knows how to handle this
847:07 - so it's going to store it inside using a
847:09 - character array but we don't have to
847:12 - really worry about that character array
847:14 - is going to work we're just going to use
847:16 - std string here we can set up a string
847:20 - using another string in our initializer
847:23 - like this we can also use
847:26 - part of a literal to initialize the
847:28 - string so for example
847:29 - this string literal here we're going to
847:31 - grab part of it and we're going to grab
847:33 - five characters and use those to
847:35 - initialize our message std string here
847:38 - and this is pretty cool we can also use
847:40 - multiple characters to initialize a
847:42 - string like this we say however many
847:44 - copies we want of this character in this
847:46 - string here and it is going to be
847:48 - exactly what we want so it's going to be
847:50 - four e's
847:51 - in this weird message string
847:54 - and we can initialize the string with
847:56 - part of another string and this is
847:58 - really cool and it may come in handy in
848:01 - many applications so for example here
848:03 - saying hello is going to contain
848:06 - world here and we are saying that this
848:08 - is what we want by saying we want to
848:10 - start at index six in this string here
848:13 - so if we go zero one two three four five
848:17 - six this is going to be our character at
848:20 - index six and from this index we're
848:22 - going to grab five characters so we're
848:24 - going to count one two three four five
848:27 - and that's going to be what's stored in
848:29 - this string here and if you don't
848:31 - believe me we can print all these things
848:33 - out and they are going to be exactly
848:35 - what we expect and by this you can even
848:37 - see that we can print std strengths
848:39 - using sddc out
848:41 - very conveniently like this and this is
848:44 - very cool okay so we can try and weld
848:46 - this with gcc the build is going to go
848:49 - through so we're going to bring up a
848:50 - terminal so that we can run this and
848:52 - we're going to clear and let's see what
848:55 - we see when we
848:57 - run rooster here so we're going to print
849:00 - the full name the full name is empty
849:02 - okay so we're not going to see anything
849:04 - because it is empty we're going to see
849:06 - planet planet is this thing we have in
849:08 - here planet where the sky is blue so
849:11 - this is what we expect we can say
849:14 - preferred planet and put in the text for
849:17 - the planet here so we're going to get
849:19 - the same thing here
849:20 - and if we have a message and say hello
849:23 - there and grab the
849:24 - first characters in this string literal
849:27 - message is going to say hello which is
849:29 - what we are saying here let's go down
849:31 - and look at where the message is going
849:33 - to be for ease which is what we have
849:35 - here and we can initialize saying hello
849:39 - with part of what we have in greeting
849:41 - and we have targeted this word string
849:44 - here and it is what we see here and this
849:46 - is pretty cool the good thing about hdd
849:49 - string however is that you can
849:51 - store in more characters than we
849:53 - initialize this guy with so for example
849:57 - here we have this message here but we
849:59 - can say
850:00 - planet let's go down here and say it
850:02 - we're going to change std string at run
850:05 - time so we're going to say planet and
850:07 - we're going to assign something to it
850:08 - we're going to put in whatever was in
850:10 - there first and we're going to paste
850:12 - that in multiple times let's do three
850:14 - times i think that's going to be enough
850:16 - or we can even bring this back so that
850:19 - we see the entire thing here doesn't
850:21 - really matter all we want is for this
850:24 - thing to be larger than it was initially
850:27 - declared
850:28 - in a planet here so we're going to
850:31 - remove these quotes because they are
850:33 - making things ugly for us and now it's
850:35 - going to be a valid strength let's wait
850:37 - for visual studio code to realize that
850:40 - and it's going to remove these squiggly
850:42 - lines now we are good std string is
850:45 - automatically going to take care of the
850:47 - logic
850:48 - to make this string grow we don't have
850:51 - to worry about that and if we print
850:53 - planet now we're going to see the same
850:55 - details and taken care of okay this is
850:57 - really cool and it makes it super easy
851:00 - to work with
851:01 - text and string data like you see here
851:04 - so let's build again so that our changes
851:07 - are
851:08 - reflected in our output we're going to
851:10 - clear and run rooster and we're going to
851:13 - see that planet is now really large okay
851:15 - we can change
851:17 - this thing the size of this thing at
851:19 - runtime and this is something we
851:21 - couldn't do with arrays so for example
851:23 - if we go down here and use a row array
851:25 - to do something like this this code is
851:28 - going to run but try to think about what
851:30 - is really happening here we have an
851:32 - array which contains this text here
851:35 - and it is pointed to by this cost card
851:38 - pointer that we have if we try and do an
851:40 - assignment like this this is really
851:42 - going to be to make it point to another
851:46 - character array in memory and this piece
851:49 - of memory here is basically going to be
851:50 - wasted because we think we have our
851:54 - planet strength in here
851:57 - this is not the case with std strength
851:59 - because std strength when we do
852:01 - something like this the initial memory
852:04 - that was allocated to store
852:06 - planet here is going to be returned to
852:08 - the operand system and a new memory is
852:11 - going to be allocated to contain this
852:13 - new thing so the waste we're doing here
852:16 - by just leaving this in memory and not
852:19 - using it is not being done here so if we
852:21 - try to print we're going to get the same
852:23 - output but inside and how our memory is
852:26 - managed hdd string is better in that the
852:29 - memory that was used to initialize this
852:32 - guy is not wasted out
852:34 - here with array what we really are doing
852:37 - is just make this planet pointer point
852:39 - to another string and leaving this to be
852:42 - wasted in memory this is what we are
852:43 - doing here and we can avoid that with
852:46 - std strength
852:47 - in this lecture we're going to learn
852:49 - about the one definition rule and this
852:52 - is a rule that says definitions can't
852:55 - show up more than once in your entire c
852:58 - plus plus program or in some cases a
853:01 - definition can show up more than once in
853:04 - a translation unit we are going to look
853:06 - at the one definition rule in the
853:08 - context of freestanding variables
853:10 - functions classes member functions and
853:13 - static members in our classes in most
853:17 - cases a definition can't really show up
853:19 - more than once in your entire c-plus
853:22 - plus program but we have exceptions to
853:24 - this rule and the exception is for
853:27 - classes a definition for a class can
853:30 - show up in multiple translation unit and
853:34 - the reason is
853:35 - we need to create objects of those
853:37 - classes so each translation unit really
853:39 - needs to see the definition for the
853:42 - class and we are going to try and make
853:45 - this super clear with examples once we
853:47 - hit visual studio code okay so it is
853:50 - time to head over to visual studio code
853:52 - and shed some more light on the one
853:55 - definition rule here we are in our
853:57 - working folder the current project is
853:59 - one definition rule we're going to grab
854:01 - our template files like we always do
854:04 - we're going to put them in place and
854:06 - we're going to open this little guy in
854:08 - visual studio code let's do that i'm
854:10 - going to drag and drop and we're going
854:12 - to have our main cpp file here we're
854:13 - going to clean it up that's what we
854:15 - always do
854:17 - and now we want to explore the one
854:20 - definition rule in the context of
854:22 - variables so we have a freestanding
854:24 - variable here
854:27 - and that's going to be the same variable
854:28 - we had in the last lecture we're going
854:30 - to initialize this and this is really
854:33 - good we can use it we can go in main and
854:36 - use it however we want we can print the
854:38 - way
854:39 - and if we won't run this program it is
854:41 - going to work but the one definition
854:43 - rule says we can't have more than one
854:46 - definition for anything and for this
854:50 - variable here we have seen that this is
854:52 - both a declaration
854:54 - and a definition so we can't have more
854:57 - than one definition for the weight name
854:59 - here for example if we try and grab it
855:02 - and copy and paste it here so we're
855:04 - going to try and build this program
855:06 - we're going to use gcc
855:08 - we're going to see that we have a
855:09 - problem and the problem is going to say
855:12 - redefinition
855:13 - of double weight and it is not going to
855:16 - help even if you take this and put that
855:18 - in another file so let's create another
855:20 - file to really show you that we're going
855:22 - to call it some other file that cpp and
855:26 - we're going to grab our redefinition
855:29 - and move that there
855:31 - and you're going to see that if we try
855:33 - and build this program
855:35 - we're going to get the same problem
855:37 - we're going to have redefinition so
855:39 - we're going to see
855:40 - what is the problem here the compiler
855:42 - error is a little bit different but it
855:44 - is going to say multiple definitions of
855:47 - weight
855:48 - and it's going to say one is defined in
855:50 - the main cpp file so this is a linker
855:53 - error this was caught by the laker
855:56 - because the redefinition is showing up
855:58 - in multiple files so the linker was
856:01 - linking this program and it needed to
856:03 - see a definition for weight and it had
856:06 - seen one definition in the main cpp file
856:09 - and it has seen another definition and
856:10 - some other file and this is a problem
856:13 - the linker doesn't know which one to
856:15 - choose so it's going to throw an error
856:17 - and you can't really have multiple
856:19 - definitions for a variable in your c
856:21 - plus plus program and this is the one
856:23 - definition rule and the context of
856:26 - freestanding variables like the weight
856:28 - here but this is the same in the context
856:31 - of functions if we go down and put up
856:34 - our add function here we're going to say
856:36 - double
856:37 - a
856:38 - and double b here and we're going to put
856:40 - the definition below the main cpp file
856:43 - let's grab this
856:45 - we can copy this and put this in the
856:48 - code here i'm going to remove this
856:49 - little thing we don't want it we're
856:51 - going to put in our body and we're going
856:53 - to return a plus b here okay so this is
856:56 - our function it is working we can take
856:58 - out what we had here because it has
857:00 - served its purpose you can say double
857:03 - result and we're going to add up 10 and
857:05 - 20 like we did in the last lecture
857:08 - no problem and we can try and print out
857:10 - our results here
857:12 - if we build and run this program it is
857:14 - going to work without a problem because
857:16 - we only have one definition for the add
857:19 - function
857:20 - what is the problem here we have weight
857:23 - defined multiple times we're going to
857:25 - comment out one the definition for
857:27 - weight
857:28 - and we're going to build again
857:31 - now the build is good and we can run
857:33 - this program we can
857:35 - kill our terminal here and bring up
857:37 - another one and run rooster you're going
857:39 - to see that the result is 30 and the
857:42 - program is working just fine but if we
857:45 - set up another definition for add even
857:47 - if we put this in the same file
857:50 - we're going to get a problem because we
857:52 - are violating the one definition rule
857:55 - let's run again
857:57 - you're going to see the problem here
857:58 - we're going to see redefinition
858:00 - redefinition of the add function this is
858:02 - not allowed your program is not going to
858:04 - compile we see the compiler error here
858:07 - even if you put the definition in
858:08 - another file that's not going to help
858:11 - we're going to take this and put this in
858:13 - our some other file
858:15 - and try to compile the program
858:20 - we're going to get a linker error and it
858:22 - is going to say multiple definition of
858:24 - the add function and this is not allowed
858:27 - this is a linker error in this time if
858:29 - we comment out one definition let's do
858:31 - that we're going to comment out the one
858:33 - in the main function this is going to
858:35 - work and we want to be violating the one
858:38 - definition rule so this is good the
858:41 - world is good we can clear
858:43 - and run rooster we're going to see our
858:45 - result here so the one definition rule
858:48 - says you can't have multiple definitions
858:50 - for
858:51 - freestanding variables or even functions
858:54 - and reserve that if you do that you're
858:55 - going to get a compiler error let's look
858:58 - at this in the context of classes we're
859:00 - going to do a class we're going to say
859:01 - struct and we're going to call this
859:04 - point like we always do
859:06 - mostly we're going to call this point
859:08 - and we're going to put in a few member
859:10 - variables one is going to be mx the
859:13 - other is going to be m y
859:15 - and this is going to be our definition
859:17 - here
859:18 - but what you're going to see
859:20 - is that it is possible to have multiple
859:23 - definitions for classes for example if
859:26 - we take this and
859:28 - have a copy of this in another file
859:30 - we're going to do that we're going to
859:32 - declare this structure here
859:34 - and we're going to try and build this
859:36 - program you're going to see that it is
859:39 - working we have multiple definitions of
859:41 - these guys we can go in main for example
859:44 - and say point
859:46 - p1
859:47 - and we can up weld and see that the
859:49 - program is going to work okay so if you
859:51 - go in here for example and try to print
859:54 - sdd cl
859:56 - p1 and the print x we're going to do
859:58 - that we're going to say p1 mx we're
860:01 - going to be able to use this because
860:03 - this is a struct the member variables
860:05 - are public by default we can do this
860:08 - and we can say
860:09 - p1 y
860:11 - is
860:13 - p1y my let's do that and we can say
860:16 - stdndl what is the problem here we need
860:20 - to put our output stream operator
860:23 - i think now the compiler is going to be
860:25 - happy
860:26 - and therefore world
860:27 - we're going to use gcc
860:30 - we're going to see that if we run the
860:31 - program we're going to see our things
860:34 - here and we have some junk values inside
860:36 - because these things are not initialized
860:38 - but if we initialize them to zero using
860:40 - the braced initialization here
860:43 - we're going to build again
860:45 - and we should see zero inside so let's
860:47 - clear and run rooster now we have 0 in x
860:51 - and y for our object here this is
860:53 - working fine and we have multiple
860:55 - definitions for our class but the
860:58 - definitions can't show up in a single
861:01 - translation unit for example if we took
861:03 - this definition here
861:06 - and brought that back in main and put
861:08 - that just below
861:10 - our structure here if we try to weld the
861:13 - compiler is going to complain because
861:15 - now we have multiple definitions for the
861:17 - same class in the same translation unit
861:20 - for classes
861:22 - we can have multiple definitions but the
861:24 - definitions have to show up in different
861:27 - translation units and that's what i want
861:29 - you to see here so we have a
861:31 - redefinition of our point struct and it
861:34 - is not good it is going to violate the
861:36 - one definition rule okay now that you
861:38 - have seen this we also want to see this
861:40 - in the context of a class
861:43 - that also has some static member
861:45 - variables we're going to take this out
861:47 - because we have already seen this and
861:49 - we're going to bring in our person class
861:51 - like we used in the last lecture we're
861:54 - going to add in a new header file it's
861:56 - going to be called person
861:59 - dot h
862:00 - and we're going to jump into
862:02 - what did we do is this folder let's
862:06 - remove this we didn't want a folder
862:09 - we're going to delete this folder we
862:11 - don't want it
862:13 - and we're going to just add a file
862:15 - called person.h
862:18 - that's all file here and we're going to
862:20 - put in the content the content is going
862:22 - to be our personal class let's close
862:24 - this so that you can see more of this
862:26 - class here okay so we have our person
862:29 - class here we have our include card we
862:32 - have our person class definition we have
862:34 - a constructor and we have a printer
862:36 - phone function we have our member
862:37 - variables and down below here you see
862:40 - that we have a static variable which is
862:42 - person account we need to put in the
862:44 - definition for these guys so let's go
862:47 - down and do that we're going to put in
862:49 - the definition for the person
862:51 - constructor we're going to go on top
862:53 - here and include our person header file
862:56 - and we're going to put in place our
862:58 - constructor we can go down and do that
863:00 - we can say person and say person
863:03 - that's going to be our constructor we're
863:04 - going to go back to the class and grab
863:07 - the parameters because i don't want to
863:09 - type all these lengths
863:11 - so let's do that we're going to put them
863:13 - in
863:14 - we are going to put in our initializer
863:17 - list i think we should also delete a
863:19 - parenthesis here we're going to go down
863:22 - and put in our initializer list we're
863:24 - going to say full name we're going to
863:26 - initialize this with name param
863:28 - and we're going to also put in our age
863:32 - and we're going to initialize this with
863:34 - edge param the parameter we have from
863:36 - the function and this is going to be all
863:39 - inside the body we're going to implement
863:41 - the static variable we're going to say
863:43 - increment person count okay now select
863:46 - that here and this is going to be good
863:48 - we also need to initialize our static
863:51 - variables so we're going to say ends
863:52 - person person account let's do person
863:56 - account and we're going to initialize
863:58 - this to maybe eight like we did in the
864:00 - last lecture and this should be all we
864:03 - need here so if we build and run this
864:05 - program i think it's going to run
864:08 - let's select the main function here
864:10 - and what problem do we have here let's
864:12 - build and see we're going to let the
864:14 - compiler figure this out
864:16 - we're going to see that the world is
864:18 - good and we can create person objects
864:20 - and really use them in our program so
864:22 - let's come down here and delete whatever
864:24 - we had we're going to include the person
864:27 - and we're going to go down here and
864:28 - create a person object we're going to
864:30 - say person
864:32 - p1 and we're going to specify the name
864:34 - to be jon snow why not
864:37 - and we're going to say that they are
864:39 - 35 why not
864:41 - and we can preach information about this
864:42 - person we can say person principle and
864:45 - if we try to build this program let's
864:48 - use gcc to do that
864:50 - the world is going to be good as you see
864:52 - down here we can clear
864:54 - and run rooster we're going to see jon
864:56 - snow he is
864:58 - 35 years old so this is working just
865:00 - fine but we can't have
865:02 - multiple definitions for the same class
865:06 - in the same translation unit here for
865:09 - example if we come in the main function
865:11 - notice we are including a person so this
865:13 - is bringing in the definition for a
865:15 - person we have in our person.h here if
865:19 - we also try to declare another class
865:21 - called person
865:22 - even if we don't put anything in the
865:25 - compiler is going to complain because we
865:28 - have two definitions for the same name
865:31 - which is person here if we try to build
865:34 - i think we are going to get a compiler
865:36 - error saying that we have a definition
865:38 - you see we have a redefinition of person
865:41 - so this is not allowed we can't really
865:42 - do this but notice that this person
865:45 - class is included both in some other
865:48 - file which is a separate translation
865:50 - unit and main we have it included here
865:54 - so it is really in a separate
865:56 - translation unit we have the definition
865:58 - for the class in separate translation
866:01 - units and that's not a problem but if
866:03 - you try and put the same definition
866:05 - multiple times in a single translation
866:09 - unit you're going to get a problem and
866:10 - you need to be aware of that what i want
866:13 - you to see right here is that you can't
866:16 - also have multiple definitions
866:18 - for your static variables and the member
866:22 - functions of your class for example if
866:25 - we grab what we have here
866:28 - and also put that in our main function
866:30 - we can do that why not we're going to
866:32 - come in our main function here and we're
866:35 - going to put the same definitions here
866:37 - now we're going to have a problem
866:39 - because the linker is going to see two
866:40 - definitions for the static variable and
866:43 - the constructor for a person here and
866:45 - this is going to be a problem you can't
866:47 - really do that if we build we're going
866:49 - to see
866:50 - a problem we're going to see
866:53 - that the problem is
866:55 - we have multiple definitions for the
866:57 - constructor and we have multiple
866:59 - definitions for person account and this
867:02 - is not allowed you can't really do that
867:04 - you can either remove the one from some
867:07 - other file.cpp for example if we comment
867:09 - this out
867:11 - let's do that we can come on top here
867:13 - and comment this out and try to build
867:16 - the program now the program is going to
867:18 - work because we have one definition for
867:20 - these guys you see the world is good we
867:22 - can even run the program to show you
867:25 - that it works or we can remove the one
867:28 - in the main cpp file and we can leave
867:31 - this alive so let's go back in the cpp
867:33 - file the main cpp file i should say and
867:36 - remove this and if we work we're going
867:38 - to see that this is going to work and
867:40 - that we are
867:42 - compliant with what the c plus plus
867:45 - standard expects us to do in our c plus
867:49 - plus programs if we're around we're
867:50 - going to see that this is going to work
867:52 - and this is really cool this is really
867:54 - all i wanted you to see in this lecture
867:56 - the one definition rule which says that
867:59 - you can't have multiple definitions for
868:02 - the same name in your entire c plus plus
868:06 - program but for classes we can violate
868:09 - this rule a little bit and make the same
868:12 - definition show up in multiple
868:14 - translation units we are going to stop
868:17 - here in this lecture in the next one
868:19 - we're going to learn about linkage
868:22 - go ahead and finish up here and make me
868:24 - there
868:25 - in this lecture we're going to learn
868:26 - about functions a function is a reusable
868:29 - piece of code that you can use multiple
868:31 - times to do different things it can take
868:35 - input and once it has input it can do
868:38 - some processing and when the processing
868:40 - is done the function can optionally give
868:43 - you a result you can think of a function
868:46 - as a machine which can take input and
868:48 - give you some output when you give input
868:50 - to the machine the machine is going to
868:52 - do some processing and then it's going
868:54 - to give you the output and the output is
868:57 - going to be dependent on the input that
868:59 - you gave to the machine this is really
869:01 - how a function works in c plus plus and
869:04 - once you have the machine set up you can
869:06 - really reuse it however many times you
869:09 - want let's look at how a function looks
869:11 - in c plus plus the syntax is this you
869:13 - first specify the return type which may
869:16 - be and double or whatever after that
869:18 - you're going to specify the function
869:20 - name
869:21 - and after that you're going to have a
869:23 - pair of parentheses inside this
869:25 - parenthesis you're going to have your
869:27 - parameters which is going to be a comma
869:29 - separated list of things you pass to the
869:32 - function and after all these parameters
869:35 - you're going to have a pair of curly
869:37 - braces and inside those curly braces
869:40 - we're going to have the body of the
869:42 - function we're going to be doing our
869:44 - processing in the body and when the
869:46 - processing is done we can get the result
869:49 - of the function through this return
869:52 - mechanism here so if we want to get
869:55 - something out of the function we have to
869:57 - return that thing and it is going to be
869:59 - visible to whoever used this function
870:03 - here is a simple example of a function
870:05 - with no input and output the syntax is
870:08 - going to be this void means that this
870:10 - function is not going to return anything
870:12 - and you notice that our pair of
870:15 - parentheses is empty because we have no
870:18 - input in this function we have our curly
870:21 - braces and inside these curly braces is
870:24 - going to be the body of this function
870:25 - it's going to do some processing and
870:28 - when processing is done we return out of
870:30 - this function now remember that i said
870:33 - that this function doesn't return
870:34 - anything because it is of void type here
870:39 - but we can return and i'm going to show
870:41 - you the exact syntax of how you can do
870:43 - that okay so we can have many functions
870:46 - in c plus plus but each function has to
870:48 - be unique otherwise you're going to have
870:50 - problems in your c plus plus programs a
870:53 - function is going to be unique based on
870:55 - its signature and the signature is
870:58 - really a function name
871:00 - plus the function parameters if we go
871:02 - back to our example here and try to
871:05 - figure out the signature of this
871:06 - function it's going to be function name
871:10 - and plus the parameters and you see that
871:12 - we have no parameters in here so this
871:15 - signature is going to uniquely identify
871:18 - this function in our c plus plus program
871:21 - if we set up another function that has
871:23 - this same function name and doesn't take
871:25 - any parameter we're going to have
871:27 - problems even if we happen to have a
871:30 - different return value for the function
871:33 - and don't worry if this is not making
871:35 - sense yet we will see a lot of examples
871:38 - and i am sure by the time we are done
871:40 - with this lecture you will be a master
871:42 - at using functions okay now that we have
871:45 - seen how we can declare or define a
871:47 - function in c plus plus let's see how we
871:49 - can use the function
871:51 - and when you call a function in most
871:53 - cases you will want to get something out
871:55 - of that function so suppose here result
871:58 - var is a variable that is going to catch
872:00 - the result of the function
872:02 - and we're going to call the function
872:03 - with the syntax like this we're going to
872:05 - say the function name we're going to put
872:08 - our pair of parentheses here and we are
872:11 - going to pass in the arguments or of the
872:13 - values of our parameters this is the
872:16 - syntax it is going to call the function
872:18 - and the result of the function is going
872:20 - to be assigned to this result var
872:24 - variable of hours here is how you can
872:26 - call a function that doesn't take any
872:28 - parameter the parameter list is
872:31 - basically going to be empty and now
872:33 - we're going to look at a few examples of
872:35 - how you can really declare functions in
872:38 - your c plus plus program for example
872:40 - here we have a function called into bar
872:43 - it doesn't return anything so we can't
872:45 - catch the result of this function and
872:47 - it's going to have one input in the form
872:50 - of an integer so the parameter is called
872:53 - h here it's an integer and inside the
872:56 - function we are going to test if
872:58 - somebody is old enough to enter a bar so
873:02 - we do a test to see if the age is
873:04 - greater than 18 if it is we're going to
873:06 - tell them please proceed f the h is not
873:10 - greater than 18 we're going to tell them
873:12 - you cannot enter this is an example of a
873:15 - function you can set up in your c plus
873:16 - plus programs here is another function
873:19 - that is going to compute the maximum
873:21 - between two numbers it is going to give
873:23 - us a result so the return value is an
873:26 - integer here the function name is max
873:29 - and we're going to put in our list of
873:31 - parameters and again these are the
873:33 - parameters when you are defining your
873:36 - function
873:37 - this comma separated list of things we
873:40 - have in this parenthesis are called
873:42 - parameters and when you call the
873:45 - function the values that you pass in the
873:47 - places of these parameters are called
873:50 - arguments so these are a few terms that
873:53 - can really throw you off and i just want
873:55 - you to be super clear about these things
873:58 - once we have the signature of the
873:59 - function set up we jump in the body and
874:01 - we do whatever we want this function to
874:03 - do so we're going to say if a is greater
874:06 - than b then a must be the maximum we're
874:08 - going to send it that back to whoever
874:11 - called this function or in other words
874:14 - we're going to return a
874:15 - and if a is not greater than b then b
874:18 - must be the maximum and we're going to
874:20 - return it that's what we're saying here
874:22 - here is another example of a function
874:24 - that doesn't have any output and doesn't
874:27 - take any input it doesn't return
874:30 - anything because the return type is void
874:33 - and it doesn't take any input because
874:35 - the parameter list here is empty and the
874:38 - body of the function we're just going to
874:40 - greet somebody and tell them hello there
874:43 - and we're going to return out of the
874:44 - function notice that for avoid function
874:48 - we can either omit the return statement
874:50 - here or we can just put it in like this
874:53 - say return and the semicolon and
874:55 - whatever c plus plus compiler you are
874:58 - using is going to accept this as valid c
875:01 - plus plus syntax
875:02 - here is another example of a function
875:04 - that returns something but doesn't take
875:07 - any input the return value is going to
875:10 - be an integer but we don't need to pass
875:12 - something to this function when we call
875:14 - it it's just going to give us output we
875:17 - can call it and get our lucky number and
875:20 - use that however we want in our c plus
875:22 - plus application i think we have seen a
875:25 - lot of examples of how we can set up
875:27 - functions now let's see how we can call
875:30 - these functions here is a simple c plus
875:32 - plus program in the main function we
875:34 - just set up a few variables a value b
875:37 - value a and b here and we use those
875:40 - variables to call functions remember we
875:42 - set up an inter bar function the
875:45 - function looked like this and it was
875:47 - testing to see if somebody's age was
875:50 - greater than 18. if the age is greater
875:52 - than 18 they are going to enter the bar
875:55 - if the edge is not greater than 18 we
875:58 - won't let them end the function takes
876:01 - input but it doesn't return anything so
876:03 - we can call this function like we do
876:05 - here and say into bar
876:07 - and you notice that we're not catching
876:09 - something out of this function we're
876:11 - just going to call it and we're going to
876:13 - give it input which is 22 here and the
876:16 - function is going to do its thing so
876:18 - it's going to let us in because our age
876:21 - is greater than 18. down here you see we
876:24 - are calling the max function here we are
876:28 - giving it two inputs a value and b value
876:31 - and it's going to return something and
876:34 - the return value of this function is
876:36 - going to be used to initialize this
876:38 - maximum number variable here this is
876:41 - what we are doing if we go down we see
876:44 - that we can call the maximum function
876:46 - directly and use its return value in an
876:49 - sddc out statement here and this is
876:52 - going to print out the maximum between a
876:54 - and b
876:55 - and down here you see we have the
876:57 - function say hello which is going to
876:59 - just greet somebody and not return
877:01 - anything here is another example of how
877:03 - you can call the lucky number you say
877:05 - lucky number you pass a pair of
877:07 - parentheses
877:08 - and this is going to return the lucky
877:10 - number and print it out in this htdc out
877:13 - statement here down here we set up a few
877:16 - variables a and b and we are going to
877:19 - use them to call the maximum functions
877:22 - you see we call max a b or we can even
877:25 - pass in number literals like we are
877:28 - doing down here
877:30 - one thing i want you to be careful about
877:32 - is implicit conversions that might
877:34 - happen when you are calling you
877:36 - functions
877:37 - suppose we have a minimum function like
877:39 - we see here which is going to be taking
877:42 - in integer parameters but here we are
877:45 - calling the function with f and g
877:48 - which happen to be of double type like
877:51 - we see on top here so what is going to
877:54 - happen is the compiler is going to
877:55 - notice that what you are passing in is
877:58 - not really what the function takes but
878:00 - the compiler knows that it can insert a
878:03 - transformation from double to integer
878:06 - and it is going to do that without your
878:09 - involvement so be really careful about
878:11 - implicit conversions and make sure they
878:14 - are working to your advantage otherwise
878:16 - you're going to have really hard to
878:18 - debug problems in your c plus plus
878:21 - programs
878:22 - one other thing i want you to be aware
878:24 - of is that if we have a function set up
878:26 - like this this function is going to be
878:29 - taking parameters as copies so if you
878:33 - have two variables for example c and d
878:35 - and you call this function with those
878:37 - two variables you're not going to be
878:39 - manipulating those two variables what
878:41 - you will be working with inside the body
878:44 - of this function are going to be copies
878:46 - of the parameters that you passed in
878:48 - here so if for example you happen to
878:51 - increment either of the parameters for
878:53 - example here we increment a and we
878:55 - increment b
878:56 - the changes we make here inside the body
878:59 - of the function are just going to be
879:01 - affecting copies we have inside the
879:03 - function here and these copies are going
879:05 - to die the moment we hit the end of this
879:08 - function here this is something i want
879:10 - you to be aware of and we will play with
879:12 - that in more detail when we hit visual
879:15 - studio code in a minute here is a simple
879:17 - example of how you can call that
879:19 - function we have two variables h and i
879:22 - and we are going to print them out after
879:25 - that we're going to call the function
879:27 - we're going to store the result back in
879:30 - mult results but the important thing is
879:33 - that we call the function here with h
879:35 - and i
879:36 - remember in the body of the function we
879:38 - are incrementing h and i as arguments
879:41 - but the changes we do inside of the body
879:44 - of the function are not going to be
879:46 - visible when the function returns if we
879:50 - print h and i here we're just going to
879:52 - see the same thing we saw before we call
879:55 - the function
879:56 - i realize this is a lot of information
879:58 - to take in now we are going to head over
880:00 - to visual studio code and actually play
880:03 - with us step by step
880:05 - okay here we are in our working
880:07 - directory the chapter is on functions
880:10 - the current lecture is first hand on
880:12 - functions we are going to grab our
880:15 - template files like we always do we're
880:18 - going to put this on
880:19 - and we are going to open this in visual
880:21 - studio code let's open the folder
880:25 - and we are going to go in the correct
880:27 - chapter
880:28 - and choose first hand on functions here
880:31 - this is what we want to open and we are
880:33 - going to open our main cpp file and
880:36 - clean it up a little bit
880:39 - and the first thing we want to do is to
880:41 - set up a function that takes a single
880:42 - parameter and doesn't give back any
880:45 - result so the function is going to be
880:48 - interbore we have seen that the function
880:50 - is not going to return anything so it's
880:52 - going to be void its return type is
880:54 - going to be void the name of the
880:56 - function is going to be interbar and
880:59 - what we want to pass in here is a
881:00 - variable to represent the age of
881:02 - somebody and we know that the age can
881:05 - really not be negative so it is
881:08 - advised to at least use an unsigned
881:11 - integer type so we're going to use
881:13 - unsigned end and the parameter name is
881:16 - going to be called age
881:18 - once we have our parameter list we're
881:20 - going to put in the function body and
881:22 - remember the function body is going to
881:24 - leave within these two
881:26 - curly braces
881:28 - now this is a valid c plus plus function
881:31 - it's not going to return anything it's
881:33 - going to take a single parameter whose
881:34 - type is unsigned and its name is
881:37 - interbar we can get inside the function
881:40 - and actually do whatever it is we want
881:42 - to do so once we go in we're going to
881:44 - test and see if the age is greater than
881:47 - 18 do something if the age is not
881:50 - greater than 18 we're going to do
881:52 - something else let's do that we're going
881:53 - to say if
881:54 - age is greater than 18 we're going to
881:57 - tell them the age and tell them that
881:59 - they can actually go in this is logical
882:03 - and we're going to say else and in the
882:05 - body of this else block
882:08 - we're going to say something else
882:10 - we're going to tell them sorry you are
882:12 - too young for this and we are going to
882:14 - get out of this block here and this is
882:16 - really our function again let's try to
882:19 - analyze the syntax here we have the
882:21 - return type this is required in c plus
882:24 - plus if you don't put it in you're going
882:26 - to get a compiler error because you
882:29 - can't have a function without a return
882:31 - type in c plus plus you notice that we
882:33 - have our squiggly lines here visual
882:35 - studio code is not happy so we're going
882:37 - to tell it the return type we're going
882:40 - to save the function name after that
882:42 - and after the function name we're going
882:44 - to pass the parameters we can have any
882:47 - number of parameters or inputs to the
882:49 - function but in this case we just have
882:52 - one because it is enough for our
882:54 - purposes after that we have the body and
882:56 - inside the body we do whatever it is we
882:58 - want to do in this function here because
883:01 - this function returns void we don't
883:03 - really need to explicitly return from
883:06 - this function here but this is an
883:08 - exception only for functions that return
883:11 - void for other return types you will
883:14 - have to put in the return statement but
883:16 - even for void functions you can put the
883:18 - return statement if you want and you can
883:20 - do that like this say return
883:24 - and you're going to put a semicolon
883:25 - after this this is also valid c plus
883:28 - plus syntax okay now we have declared
883:30 - the function it is a valid c plus plus
883:33 - functions let's try and call it we're
883:35 - going to go down in main because that's
883:37 - where we want to be calling our
883:38 - functions for now and we are going to
883:41 - say interbar we're going to call the
883:44 - function and you use the function name
883:46 - to call it and you're going to put in a
883:48 - pair of parentheses and pass an argument
883:51 - to the function again what you pass to
883:54 - the function when you call it it's
883:55 - called an argument but what you pass
883:57 - through the function when you are
883:58 - defining it like we did here that's a
884:01 - parameter
884:02 - okay so function parameters when
884:04 - declaring functions and when you are
884:07 - calling the function what you pass are
884:09 - function
884:10 - arguments and now we need to pass in
884:12 - some age to this function and let's say
884:15 - 22 and if we do that this is going to be
884:18 - a valid c plus plus program
884:21 - notice that we have this squiggly line
884:23 - it is because we forgot a semicolon here
884:26 - because
884:27 - c plus plus requires to have a semicolon
884:30 - after each statement and now we have a
884:33 - valid c plus program that is declaring a
884:37 - function and calling a function down
884:39 - here in main we can try to build it
884:42 - let's use gcc to do that the world is
884:44 - going to be good you see world finished
884:46 - successfully and we can bring up a
884:49 - terminal and actually try to run this
884:51 - function here let's clear and run
884:53 - rooster because our program is going to
884:55 - be called rooster like we have been
884:57 - doing all along and at the output is
884:59 - going to be you are 22
885:02 - please proceed notice that we have this
885:05 - function defined once but we can call it
885:08 - multiple times so for example if you go
885:10 - down here and say into bar
885:12 - and we give it 15 as the age
885:15 - and we try and build again let's build
885:18 - with gcc
885:19 - the builder is going to be good we can
885:21 - clear and run rooster now it's going to
885:24 - say you are 15 please proceed why is
885:27 - that
885:28 - what are we really doing here uh if age
885:30 - is greater than 10 we say 10 here we
885:32 - should say 18. sorry for this we're
885:36 - going to weld again
885:38 - and now it should behave accordingly so
885:42 - let's say rooster here
885:43 - you are 22 please proceed you are too
885:46 - young for this no offense because the
885:49 - age is 15 here you can keep calling this
885:52 - function and you're going to see things
885:53 - printing out you can even call this
885:55 - function in the loop i can't really
885:57 - resist so let's do that we're going to
885:59 - say for size t
886:03 - i and say start from 0 for example or 1
886:06 - why not
886:07 - and we are going to say while i is less
886:10 - than
886:11 - 10 or
886:12 - 20. we're going to increment uh you
886:15 - already know how to use loops so we're
886:18 - going to be using this as an example
886:20 - and we can
886:21 - comment out all these guys in front
886:23 - because we don't want them to print
886:25 - stuff by now
886:27 - and what we're going to do is call the
886:29 - function with whatever iteration we are
886:31 - at
886:32 - notice that we have a size t here and
886:35 - the function is going to be taken
886:37 - an unsigned integer so we're going to
886:40 - have implicit conversions from size t
886:43 - to end or if we really want this to not
886:47 - cause any problems we can change the
886:50 - type of our parameter to be size t this
886:53 - is also valid c plus plus code let's say
886:56 - size t properly
886:58 - and if we go down here
887:01 - we're going to say
887:02 - enter bar
887:04 - and we're going to pass an i
887:06 - watch what is going to happen this is
887:08 - going to loop
887:09 - from 1 all the way to 19 and it's going
887:12 - to be calling this function with
887:14 - whatever iteration we might be at so
887:16 - it's going to look from 1 all the way to
887:19 - 18 and it's going to
887:21 - tell us we are too young for this but
887:23 - for 19 it's going to let us in because
887:26 - we will be old enough to enter a bar
887:29 - let's try this i think it's going to be
887:31 - fun we're going to weld with gcc
887:34 - and we're going to clear
887:36 - and run rooster ah sorry you're too
887:38 - young for this you too young with us and
887:40 - that once we hit 19 it's going to tell
887:42 - us we are young enough to enter a bar
887:45 - and we're going to go and and have as
887:47 - much fun as we want so this is really
887:50 - how you can declare a function remember
887:53 - a function is uniquely identified by its
887:56 - signature and the signature is really
887:58 - the name of the function and the
888:00 - parameters that you have in here okay
888:02 - once you have the function declared
888:04 - you're going to do whatever you want in
888:05 - the body you are going to optionally
888:07 - return something from the function and
888:10 - once the function is declared or set up
888:13 - you can go in main and call it and do
888:15 - whatever it is you want with it okay now
888:17 - i think we are mature enough to try out
888:20 - a few other functions let's go down and
888:22 - put in another function which is going
888:24 - to compute the maximum of two numbers
888:26 - the signature of this function is going
888:28 - to be its name here and the parameters
888:30 - notice that we are taking two parameters
888:32 - because we want to be computing the
888:34 - maximum between two numbers and this
888:37 - function is going to return something we
888:38 - want to get the maximum out of the
888:40 - function and use it to do something else
888:43 - when we call it
888:44 - so this is the declaration of the
888:46 - function once we hit the body of the
888:48 - function we are going to compute the
888:49 - maximum we're going to say if a is
888:52 - greater than b then a must be our
888:54 - maximum so we're going to return that
888:56 - and if a is not greater than b then b
888:59 - must be the maximum we're going to
889:01 - return b as our maximum here this is
889:04 - what the function is doing we can go in
889:06 - main and call it let's go down and
889:08 - comment this out because we don't want
889:10 - noise output from these guys so calling
889:13 - interbore that's what we were doing now
889:15 - we are calling max so we're going to go
889:17 - down and set up a variable call it
889:20 - result why not and we're going to
889:23 - compute the maximum between 10 and 20
889:26 - why not okay so let's see what we get
889:28 - and we're going to print the maximum
889:30 - this time we're going to say
889:32 - max as resort okay now if we build this
889:36 - program and run it try to guess what
889:38 - we're going to get we're going to call
889:39 - the maximum function
889:41 - and what we pass in here are arguments
889:44 - again we are not passing parameters here
889:47 - we are going to pass in 10 and 20 as our
889:50 - arguments and when we call the function
889:52 - control is going to jump to the body of
889:55 - the function and we are going to fall
889:56 - inside here the arguments we're going to
889:58 - pass in are just going to be copied in
890:01 - the function and we will have them
890:03 - through these names a and b so we're
890:05 - going to test and see if the first
890:07 - parameter is greater than the second in
890:09 - this case the first parameter is not
890:11 - greater than the second because the
890:13 - first one is 10 the second is a 20.
890:16 - let's go down and see that and the test
890:18 - here is going to fail and we're going to
890:20 - run whatever is in the else block here
890:23 - and we are going to return b as our
890:25 - maximum when we return b
890:28 - b is going to basically be the result of
890:30 - this expression here
890:32 - and that result is going to be assigned
890:34 - to our research variable and we're going
890:36 - to print it out with this sddc out
890:38 - statement here so let's try and build
890:40 - this we're going to build with gcc again
890:43 - the world is going to be good we're
890:45 - going to clear and run rooster you see
890:47 - that maximum is 20. if we try and change
890:50 - this for example make the first
890:51 - parameter 100 and both again
890:55 - let's see what maximum we get
890:58 - going to clear and run rooster we're
891:00 - going to say that maximum is 100 and
891:02 - again you can call this function however
891:04 - many times you want for example we can
891:07 - call it again and say result equals
891:10 - max using two variables that we have
891:13 - let's say x and y
891:15 - and go on top and declare these two
891:17 - variables why not we're going to say and
891:19 - x and we're going to put in it 22
891:22 - and we're going to say end y and put in
891:26 - a 44 right now
891:27 - and now if we print the result we're
891:30 - going to get 44 because that's the
891:32 - maximum that was assigned back to our
891:35 - research variable here let's weld again
891:38 - we're going to run the task to build
891:40 - with gcc
891:42 - you can clear and run rooster you see
891:45 - max is 44 and this is really how you can
891:47 - declare and use a maximum function like
891:50 - this
891:51 - we're going to comment this out because
891:52 - we have a few more functions we want to
891:55 - try out let's go on top and put in
891:58 - another function and again notice that
892:00 - we are declaring functions
892:02 - before the main function here this is a
892:05 - requirement of a c plus plus compiler
892:07 - because before you use the function the
892:10 - function must be declared somewhere so
892:13 - we need to go before the main function
892:16 - and declare our functions here the
892:18 - function we're going to do now is say
892:20 - hello here it's not going to take any
892:22 - input and it's not going to give us any
892:24 - output it's just going to say hello and
892:27 - die off we can go down and call it this
892:29 - is going to be super easy calling hello
892:32 - and we're going to call it say hello see
892:35 - that even visual studio code knows about
892:37 - this function we can call it like this
892:39 - it's going to be activated so we're
892:41 - going to hit the body of the function
892:43 - we're going to say hello there and the
892:45 - function is going to return or die off
892:47 - please know that you could omit this
892:49 - return statement for functions that
892:51 - return void so if we comment this guy
892:54 - out the function is going to work
892:55 - equally well you can use this however
892:57 - you want now we're just going to build
893:00 - with gcc and see this function run
893:03 - the build is good we're going to run
893:05 - rooster and it is saying hello there
893:08 - let's go down and look at another
893:10 - example here
893:12 - the next function is going to be lucky
893:14 - number it's not going to take any input
893:17 - but it is going to give us an output in
893:19 - the form of an integer so we can call it
893:22 - let's go down and comment out saying
893:24 - hello here and say that we want to call
893:27 - lucky number
893:28 - and we can go down and set up a variable
893:30 - let's do that we're going to say int
893:32 - result
893:33 - and we
893:34 - are going to brace initialize this guy
893:37 - so it's going to be initialized to zero
893:39 - and we're going to say result
893:42 - equals lucky number and we're going to
893:45 - take the result returned by our lucky
893:48 - number function and assign that to the
893:50 - result variable and we can print it out
893:52 - if we want so we can say sddc out and
893:56 - say result
893:59 - and we're going to put that out here say
894:01 - result
894:05 - and if we build and run this program
894:08 - we're going to get this guy printed out
894:10 - we should see a 99 because that's what
894:12 - we are returning from our function here
894:15 - and resort is 99 as you see in the
894:18 - output here so this is really how you
894:20 - can declare
894:22 - your functions a function has a unique
894:24 - signature so for example into bar here
894:26 - has this particular name
894:28 - and these parameters here
894:31 - if you go down mats has its own name and
894:34 - the parameters that it takes in if you
894:37 - go down say hello and lucky number are
894:40 - different in their own ways if you try
894:42 - and set up another function that has the
894:44 - same signature as max here your compiler
894:48 - is going to freak out let's try and do
894:49 - that we're going to set up another
894:51 - function it's going to have a void
894:52 - return type we're going to call it max
894:54 - because we want to match this signature
894:56 - here
894:57 - and we're going to give it two
894:58 - parameters into a and it b
895:02 - and we can do whatever we want in this
895:04 - function notice that we have a squiggly
895:06 - line if we open our problems tab here
895:09 - you're going to see that visual studio
895:11 - code has a few problems with this
895:13 - because we are setting up a function
895:16 - with the same signature twice let's try
895:19 - and different make this a net and see
895:21 - what we get right now we don't seem to
895:23 - have a problem but if we get to run this
895:25 - program we're going to have problems
895:28 - let's go down and actually activate the
895:30 - code to call the max function to really
895:33 - show you this
895:34 - because you need to know so we're going
895:36 - to comment out calling lucky number and
895:38 - we want to call max we're going to
895:41 - activate the code to call max
895:43 - and we are going to build this with gcc
895:46 - notice what we're going to see uh-huh we
895:48 - have problems here we have a compiler
895:50 - error saying re definition of int max
895:53 - and ant
895:54 - and
895:55 - one might think what if i name my
895:58 - parameters differently here for example
896:01 - i call this guy
896:02 - c
896:04 - and this other guy d
896:06 - let's do that
896:07 - using different names like this is not
896:09 - going to solve your troubles because if
896:11 - we try and uh bold again we're going to
896:14 - get the same compiler error this is not
896:16 - going to change your thing we don't have
896:18 - enough tools to really understand this
896:20 - problem but know that you can't have two
896:23 - functions
896:24 - with the exact same signature in a
896:27 - single c plus plus program and we're
896:29 - going to learn more about this later but
896:31 - note that the signature of a function
896:34 - must be unique to it throughout your
896:37 - entire c-plus program if you remember
896:40 - this simple rule you're not going to
896:41 - have many problems so let's try and weld
896:44 - again to make sure we have no more
896:46 - problems in here
896:48 - the bolt is good and we can run the
896:50 - program to see our maximum printed out
896:53 - so let's do that clear
896:56 - rooster and max is 44 it is exactly what
897:00 - we expect
897:02 - the last thing i want to do in this
897:04 - lecture is make it super clear in your
897:06 - mind that what we pass to functions we
897:09 - have been setting up so far
897:11 - are copies so let's go on top and set up
897:15 - a simple function the function is going
897:17 - to increment and multiply it returns a
897:20 - double type the name of the function is
897:22 - increment and multiply and it is going
897:25 - to take two parameters and a double a
897:27 - and a double b
897:29 - once we hit the body of the function
897:30 - we're going to increment a and b
897:34 - the arguments that were passed to the
897:36 - function and we're going to multiply
897:38 - them and we're going to store the result
897:39 - of that in a reserved variable the
897:42 - result variable is what we're going to
897:44 - return to the function and whoever
897:46 - called this function is going to use
897:48 - that to do whatever they want what we
897:50 - really want to see is that the changes
897:53 - we do inside the function are not going
897:55 - to be visible to the arguments that we
897:59 - pass to this function here to really
898:01 - make this super clear let's go down in
898:04 - main and set up a few variables we're
898:06 - going to have a double h and the double
898:08 - i the values are going to be three and
898:11 - four we're going to print them out and
898:13 - we're going to call our increment
898:15 - multiply function notice that we pass h
898:17 - and the i
898:18 - to the function and the result of the
898:21 - function is going to be stored in uh the
898:24 - anc mult resort variable here but the
898:27 - return value is really not important
898:29 - what we want to see
898:30 - is if the changes we do to the arguments
898:34 - are going to be visible on the outside
898:36 - of the function here so remember we have
898:38 - h and i here we pass them to the
898:40 - function once we hit the inside of the
898:42 - function
898:44 - we're going to increment a and b
898:46 - and we are going to return from the
898:48 - function so let's see
898:50 - if a which was a 3 and b which was a 4
898:55 - have been incremented to 4 and 5. that's
898:57 - what we want to see so we're going to
898:59 - boil this and run this so let's use gcc
899:02 - to do that the bulk is going to be good
899:05 - we're going to clear
899:07 - and run rooster
899:09 - and notice what we have here let's go
899:11 - down and look at the variables again
899:14 - we set up h to contain a 3 so before we
899:18 - increment h
899:20 - and i are four
899:22 - okay so that's what we're going to print
899:23 - here once we hit the inside of the
899:26 - function
899:27 - we are going to say what we have inside
899:29 - the function before we do the operation
899:31 - before the increment again a and b are
899:33 - four so these are copies we have inside
899:36 - we're going to
899:37 - do the increment and after we have the
899:40 - increment a and b are going to be four
899:43 - but once we hit the outside of the
899:45 - function
899:47 - and a print
899:48 - with this guy here we're going to see
899:50 - that h and i
899:52 - are still three and four so
899:55 - we didn't really affect h and i when we
899:58 - did this increment here what we affected
900:01 - are copies that were passed to a and b
900:04 - here
900:05 - and this is something you need to know
900:07 - because some people will think that
900:08 - because i pass
900:10 - h and i in my argument list here i can
900:14 - manipulate h and i what you are
900:16 - manipulating are copies that were made
900:19 - by the compiler to pass the arguments to
900:22 - the function here this is something you
900:24 - need to keep in mind and we will learn
900:26 - more about this but i wanted you to
900:28 - learn this firsthand and this is really
900:31 - all we set out to do in this lecture i
900:33 - hope you have a better understanding of
900:35 - what a function is and what you can do
900:37 - with it in c plus plus we are going to
900:39 - stop here in this lecture in the next
900:41 - one we're going to learn a little more
900:43 - about function declarations and function
900:45 - definitions
900:47 - go ahead and finish up here and meet me
900:49 - there in this lecture we're going to
900:51 - learn about function declarations and
900:54 - function definitions the motivation for
900:57 - the topic we're going to be talking
900:58 - about here is that sometimes you really
901:01 - want to separate a function header from
901:05 - its implementation because you don't
901:07 - want to expose all the details about how
901:10 - you do stuff let's look at the simple
901:12 - example in the last lecture we declared
901:14 - a max function which was computing the
901:16 - maximum between two numbers the output
901:18 - was an integer so that's what we
901:20 - returned the name of the function was
901:22 - max and we had two parameters into a and
901:25 - and b but what we did in the last
901:27 - lecture was crop the entire function
901:31 - body
901:32 - in front of main but sometimes people
901:34 - don't want to really see the details of
901:36 - how you do stuff they just want to know
901:39 - a summary of what your function does
901:41 - what we can get out of the function and
901:43 - what we need to give to the function for
901:45 - it to do its job and that's what we're
901:48 - going to see in this lecture if you look
901:49 - here we have the function header in
901:52 - front of the main function and the
901:54 - function header is made up of its return
901:56 - type the name of the function and the
901:59 - list of the parameters and after that
902:01 - we're going to put a semicolon this is
902:03 - called a function header or a prototype
902:06 - and when we do that the compiler is
902:09 - going to be happy and it's going to work
902:10 - with us to compile our program but when
902:13 - we get to link our program to really put
902:16 - it together and make one binary the
902:18 - definition of the function is going to
902:20 - be needed and if you look after main
902:23 - here what we have is a function
902:25 - definition if you look closely you see
902:27 - that it is exactly the same thing we had
902:30 - in the last lecture we have our header
902:32 - information we don't have a semicolon
902:34 - after our parameter list but we have a
902:37 - pair of curly braces and inside these
902:41 - curly braces we have the body of our
902:44 - function
902:45 - now
902:46 - it is really easy to look at this
902:48 - program because we don't have to look at
902:50 - all these details about how this
902:52 - function works we can get
902:54 - first-hand information on how we can use
902:57 - this function and that is what most
902:59 - people are going to be interested in
903:01 - about your function they want to really
903:03 - want to go in and see how you do stuff
903:06 - they will want to use your function to
903:08 - get the output and use it to do whatever
903:10 - it is they want to do if you look here
903:12 - in the body of the main function we have
903:15 - two variables a and b and we use them to
903:17 - call the maximum function we can also
903:19 - set up a minimum function which works in
903:21 - the similar way and we call another
903:24 - function called increment which is going
903:26 - to increment and multiply whatever
903:28 - arguments we pass to this function so
903:31 - the main idea here is that we can split
903:33 - our function in two parts one is going
903:36 - to be the function header which is
903:37 - really going to be the function
903:39 - declaration and the other is going to be
903:41 - the function body with all the details
903:44 - about how the function works and that's
903:46 - going to be our function definition and
903:48 - once we have these two things in place
903:50 - we can call the function in our main
903:52 - function and do whatever we want with
903:54 - that okay now it should be super clear
903:56 - that we can separate our function in two
903:59 - parts declaration and definition and
904:01 - sometimes the declaration part is also
904:03 - called a prototype that's a prototype of
904:05 - a function and it is made up of the
904:08 - return type
904:09 - together with the function name together
904:11 - with the parameters and after that
904:13 - you're going to add a semicolon to make
904:15 - it valid c plus syntax and another thing
904:18 - you should know is that the prototype
904:21 - needs to come before wherever it is
904:24 - called if you're trying to call a
904:25 - function before its prototype is seen in
904:29 - your c plus plus program you're going to
904:31 - get a compiler error and now you might
904:33 - be asking but why did our programs in
904:37 - the last lecture work we didn't split
904:39 - things up and our program was working
904:42 - fine
904:43 - well
904:44 - if you put a function definition in
904:46 - front of the main function that function
904:49 - definition is also going to double as a
904:51 - function declaration that's why the code
904:54 - in the last lecture worked okay now that
904:56 - you have an idea about what a function
904:58 - declaration and the function definition
905:01 - is let's head over to visual studio code
905:03 - and play with us okay here we are in our
905:06 - working folder the current project is
905:08 - function declarations and definitions we
905:11 - are going to grab our templates files
905:14 - like we always do
905:16 - we're going to put them in place
905:18 - and we are going to open this guy in
905:20 - visual studio code let's do that
905:24 - we open this up
905:25 - and we are going to open our main cpp
905:28 - file clean it up a little bit and let's
905:31 - close this pane so that we have some
905:33 - breathing space the first thing we're
905:35 - going to do is set up a maximum function
905:37 - you already know how to do that we're
905:39 - going to specify the return type
905:41 - we are going to specify the function
905:43 - name and the parameters we're going to
905:44 - take in it a and into b and we're going
905:47 - to go in and do whatever we need to
905:50 - compute the maximum between these two
905:52 - guys we're going to say if a is greater
905:54 - than b
905:55 - then
905:56 - a must be the maximum so we're going to
905:59 - return that
906:00 - else we are going to return
906:03 - b
906:04 - okay this is the function and it is
906:06 - really simple we can go down in main and
906:09 - use it so let's say ant
906:11 - x and i put in a five for example
906:14 - and let's say
906:16 - y and put in a two or a three put in
906:20 - whatever you want
906:21 - and then we're going to set up the
906:24 - research variable
906:25 - which is going to catch the maximum i
906:27 - think we can do that and what we're
906:29 - going to assign to this is whatever is
906:32 - returned from our function call so we're
906:34 - going to call this function with x and y
906:36 - so we're going to be computing the
906:37 - maximum between
906:39 - 5 and 2 here the maximum is going to be
906:42 - stored in this result variable and we're
906:44 - going to print it out so we're going to
906:45 - say std
906:47 - see out and i'm going to say max
906:50 - as result this is going to do
906:54 - okay let's try and build this and make
906:57 - sure it actually works
906:59 - this is nothing new so far it is
907:01 - everything we have done in the last
907:03 - lecture
907:05 - now the world is good we can clear and
907:08 - run rooster we're going to get the
907:09 - maximum as a five here and if we try to
907:12 - change this things for example make y 12
907:15 - and world again
907:16 - we're going to use gcc
907:19 - and we are going to clear these thanks
907:21 - and run rooster we should get max equals
907:24 - 12.
907:25 - this is all fine and dandy but sometimes
907:28 - we don't really want to have the details
907:31 - about how our function works shown in
907:35 - front of the main function here and we
907:37 - can split our function in two parts a
907:40 - declaration and a definition the
907:43 - declaration is really going to be the
907:44 - header part of the function and that's
907:47 - going to be the return value the name of
907:49 - the function and the parameter list but
907:51 - to make it a valid declaration we have
907:54 - to put a semicolon after this so this is
907:56 - our function
907:58 - declaration
907:59 - sometimes it is also called a prototype
908:04 - and please make sure you understand the
908:06 - difference between a prototype and a
908:09 - signature in the last lecture we saw
908:11 - that the signature was only made of the
908:14 - name of the function and the parameter
908:16 - list but the return value was not part
908:20 - of the function signature but the
908:21 - prototype includes all these guys so
908:24 - signature doesn't include
908:27 - return type
908:30 - okay so now that we have our function
908:32 - declaration setup we need to put in
908:36 - a function definition because if you try
908:38 - to compile this program and link it
908:42 - you are going to get problems let's try
908:44 - and do that before we put in the
908:45 - definition
908:47 - we can weld with gcc we are learning so
908:49 - we don't
908:50 - have to fear breaking things a little
908:52 - bit
908:53 - let's clear and try to build with gcc
908:58 - and you're going to see ah we have a
909:00 - problem here and what kind of problem we
909:03 - have the c plus plus compiler is going
909:05 - to compile this program but when we hit
909:08 - the link stage
909:10 - i realize i haven't really talked about
909:12 - this in more detail but we will do in
909:14 - this lecture but the main problem here
909:17 - is that we don't have the definition of
909:20 - this function in place and the compiler
909:22 - is going to search for it and not find
909:24 - it and you see that it is saying
909:26 - undefined reference to max
909:29 - okay so it has seen the declaration of
909:31 - the function
909:33 - but it doesn't know how the function
909:35 - does its job because we don't have a
909:37 - function body in here so to really make
909:39 - this code work exactly as we want we
909:42 - need to put in a definition and the
909:45 - definition can show up anywhere in your
909:47 - c plus plus program in this case we're
909:49 - going to put that
909:50 - after the main function and the
909:52 - definition is really
909:55 - what we have been using so far as our
909:57 - function definition in the last lecture
910:00 - but notice that it has the body
910:02 - information and now when the compiler
910:05 - tries to compile this program it will
910:08 - know how the maximum function is
910:11 - computing its maximum because we have
910:13 - all that information in here so let's
910:15 - say that this is our function definition
910:17 - and shows up after main in this case and
910:21 - we can try and build this and see if the
910:23 - work is good now you see the world is
910:25 - good
910:26 - and if we try to run it we're going to
910:29 - get our maximum exactly like we did when
910:32 - we had
910:33 - the declaration and the definition
910:35 - cramped up before main here but
910:38 - hopefully now you can see that our
910:39 - program is much cleaner because when you
910:42 - look at this you know that we have a
910:44 - function called max it's going to take
910:46 - two parameters it's going to return
910:48 - something and it is called mats so it
910:51 - must be computing the maximum of these
910:53 - two guys but we don't really care how
910:56 - this function does its job how it
910:58 - computes the maximum here and this is
911:00 - the main message here we can split a
911:02 - function in two parts a declaration and
911:05 - a definition okay just to play around we
911:08 - can also set up a minimum function
911:11 - before we do that let's set up its
911:13 - definition down here we're just going to
911:15 - copy the maximum and adapt it
911:18 - we're going to put a copy of that guy
911:20 - here we're going to call it men
911:23 - it's going to take two parameters it's
911:25 - going to return an end but what we test
911:27 - for is if a is less than b if a is less
911:31 - than b then a is a minimum
911:33 - if a is not less than b then b must be
911:36 - our minimum and we can put the
911:38 - declaration of this function on top here
911:40 - so let's go there and say men
911:43 - and say end a and end b
911:47 - and now we can change the call here to
911:48 - say mean and it is going to compute the
911:50 - minimum why not let's do that we're
911:53 - going to say min here and we're going to
911:55 - grab whatever is the minimum between x
911:57 - and y here and that's what we're going
911:59 - to have in this result variable here
912:01 - let's do that we're going to try and use
912:04 - this
912:05 - the build is good
912:07 - so we're going to clear and run rooster
912:09 - now the minimum is five we are calling
912:11 - our minimum function
912:13 - in the last lecture we also set up a
912:15 - function to increment and multiply let's
912:17 - try and do the same thing
912:19 - but split that into a declaration and
912:22 - the definition just to practice a little
912:24 - more we're going to call this and
912:26 - malt and it's going to take a and b in
912:30 - and inside and we're not going to put
912:32 - the body on top here we're going to put
912:34 - the body down with the other definitions
912:37 - that we have for all these other
912:39 - functions for max and mean here so we're
912:42 - going to put in our body it's really
912:43 - simple so we're going to put a body
912:45 - inside this curly braces
912:48 - and we are going to return
912:50 - plus a
912:51 - we're going to increment a
912:53 - and we're going to multiply that with an
912:56 - increment of b
912:58 - and we're going to return that i think
913:00 - this is going to be valid c plus plus
913:01 - syntax and if we try to call this
913:04 - function in main let's do that say in
913:06 - mult and we're going to pass an x and y
913:09 - the program is going to just work fine
913:11 - we're going to grab the result and store
913:14 - that
913:15 - in our variable let's do that
913:18 - and we can print the result
913:21 - and we're going to say result here this
913:23 - is going to do
913:25 - and if we build and run this program
913:28 - we're going to see the output here let's
913:30 - see what we get
913:33 - the results is going to be 78 because if
913:36 - we increment a 5 it becomes a 6.
913:38 - if we increment y we're going to get 13
913:42 - 13 times 6 should be 78 let's be sure
913:46 - we're going to bring up the calculator
913:48 - let's do that so that you know that i am
913:51 - not making these things up 78. so our
913:54 - program is really working like it should
913:56 - and this is the main message here we can
913:58 - really split up functions into a
914:00 - declaration
914:02 - and a definition and that's going to
914:04 - make our programs much easier to work
914:07 - with and read
914:08 - one thing you should know is that the
914:10 - names of the variables aren't really
914:13 - important in function declarations like
914:15 - this
914:16 - so for example we can take out the a and
914:18 - b here
914:19 - or we can take out all the variable
914:22 - names in our function declarations let's
914:25 - do that
914:27 - and you might think is this program
914:29 - going to compile well i hate to break it
914:32 - to you but it is going to compile so
914:34 - let's weld with gcc
914:37 - you're going to see that the both is
914:38 - good so the function header or
914:41 - declaration doesn't really care about
914:44 - the variable names
914:46 - in the definitions we care about these
914:48 - variable names because we are going to
914:50 - be using them in the bodies but if you
914:52 - want you can leave them out in your
914:55 - function declarations but i like to keep
914:58 - them in place because i like my
915:00 - functions to be self-documented if
915:03 - somebody looks at this they will know
915:05 - the variable name here but if you really
915:07 - want you can leave the variable names
915:09 - out and it is going to work pretty well
915:12 - this is really always enough to do in
915:13 - this lecture i hope you found it
915:15 - interesting we are going to stop here in
915:17 - this lecture in the next one we are
915:19 - going to see how we can split our
915:20 - programs in multiple files now that we
915:24 - know how to split into declaration and
915:26 - definition
915:27 - go ahead and finish up here and meet me
915:29 - there
915:31 - in this lecture we're going to revisit
915:33 - our c plus plus program compilation
915:36 - model along the way we are also going to
915:38 - see how we can work with functions
915:40 - across multiple files
915:43 - if you remember our compilation model
915:45 - looked something like this you have seen
915:47 - this slide a lot of times by now what it
915:50 - describes is what happens when we
915:53 - compile our program the moment we run
915:55 - the compilation command our c plus
915:58 - program which lives in the main cpp file
916:01 - by now is going to be passed through the
916:03 - compiler the compiler is going to
916:05 - process it and it is going to come up
916:07 - with a binary executable that is mostly
916:10 - called rooster in this course and when
916:12 - we execute this rooster file or binary
916:15 - file we're going to get the program to
916:17 - run the program is going to be executed
916:20 - instruction by instruction when it is
916:22 - loaded by the operating system and we
916:24 - are mostly going to see the output of
916:26 - that program on the terminal in this
916:29 - course this is the compilation model we
916:31 - know but now what we want to do is zoom
916:35 - in on this compilation part here and see
916:38 - what really happens under the hood
916:40 - we are going to suppose that we have a
916:43 - program which is made of a lot of source
916:46 - files as we have here on the left
916:48 - suppose we have two three or five source
916:51 - files unlike what we have so far which
916:54 - is one file the main cpp file when you
916:57 - compile such a program you're going to
916:58 - go through a stage called
917:00 - pre-processing and what this is going to
917:03 - do
917:04 - it's going to look for your include
917:07 - statement
917:08 - and it is going to take whatever file
917:10 - you are including and it is going to
917:12 - paste that in place so for example here
917:15 - you see we have an include io stream
917:18 - statement
917:19 - when the pre-processing stage is run
917:23 - this includes statement is going to be
917:25 - replaced with whatever we have in this
917:28 - io stream file here so this is going to
917:32 - be wiped out and we're going to put in
917:34 - the content that we have in io stream in
917:38 - this exact place where we have the
917:40 - include statement i hope this is clear
917:42 - so when we go through preprocessing
917:45 - we're going to have
917:46 - a version of our source files
917:49 - with the included parts put in our
917:52 - source files we're basically going to go
917:54 - copy everything in that file that we
917:56 - include and we're going to paste inside
917:59 - our new files here that we're going to
918:02 - be referring to as translation units by
918:05 - now these are translation units in a c
918:08 - plus plus program
918:11 - once you have this translation unit then
918:13 - you're going to compile them they are
918:14 - going to go through the compiler the
918:16 - compiler is going to generate what we
918:19 - call an object file and this is a binary
918:22 - representation of the content you have
918:25 - in your translation unit so each
918:28 - translation unit is going to generate
918:30 - one object file and for example if you
918:33 - had 20 translation units in your program
918:36 - you're going to have 20 object files
918:39 - once we have object files they are going
918:41 - to be processed by what we call the
918:43 - linker
918:44 - and the linker is going to stitch them
918:46 - together and have one single binary file
918:49 - out of all these object files so we're
918:52 - going to have something like this and
918:53 - this is basically going to be our binary
918:56 - that we can run on our target operating
918:59 - system so by now you see that our
919:01 - compilation model has expanded to
919:03 - contain three phases we have
919:05 - pre-processing compilation and linking
919:09 - now you might be asking why am i showing
919:11 - you this now well it is going to matter
919:14 - because we're going to split to a
919:15 - program across multiple files some of
919:18 - those files are going to matter on the
919:20 - compilation phase and some of those
919:23 - files are going to matter on the linking
919:25 - stage so we really need to make a clear
919:28 - distinction between the compilation and
919:30 - linking here okay this should be a more
919:32 - complete compilation model to go by for
919:35 - now now that we know about this
919:37 - compilation model we can look at how we
919:40 - can split our program across multiple
919:42 - files suppose we have three functions
919:44 - one we can use to get the maximum of two
919:46 - numbers called max a function called men
919:49 - we can use to get the minimum between
919:51 - two numbers and a function we can use to
919:53 - increment and multiply like we have seen
919:56 - in the last lecture now the two
919:57 - functions maths and men are going to
919:59 - live in their own file and that file is
920:02 - going to be split in two files we're
920:04 - going to have a header file and a cpp
920:06 - file which is going to contain the
920:08 - implementation in the header what we're
920:10 - going to have is just a prototype and we
920:13 - are going to set up our code in a way
920:15 - that our anchor mult function here is
920:18 - going to live in zone file we're going
920:20 - to split that in two files so we're
920:22 - going to have a header file called
920:24 - operations.h
920:25 - and we're going to have an
920:26 - implementation file called
920:28 - operations.cpp
920:30 - which is going to contain the
920:31 - implementation of this function here
920:33 - when we hit the main file what we're
920:35 - going to do is nothing special we're
920:37 - just going to include the headers and we
920:40 - are going to use these functions like we
920:42 - have been using them all along if you
920:44 - look on the first line here we are
920:45 - calling max on the second line we are
920:48 - calling men and on the third line here
920:50 - we are calling incur mult to do whatever
920:53 - it does okay when you start splitting
920:56 - your functions between the definitions
920:58 - and the declarations remember the one
921:01 - definition rule and this says that you
921:04 - can't have a function defined
921:07 - multiple times in your entire c-plus
921:10 - class application if you do that the
921:12 - lincoln stage is going to find those two
921:14 - functions and it's going to
921:16 - not know which one you really want to
921:18 - use and you're going to get a linker
921:20 - error we're going to see that when we
921:22 - hit visual studio code in a minute
921:24 - another thing is that you know that your
921:26 - definition can really leave anywhere in
921:29 - your code
921:30 - the linker is smart enough to parse your
921:32 - entire project looking for
921:35 - the definition for whatever function
921:37 - it's found in your source code and it's
921:40 - going to keep looking until it finishes
921:42 - looking in all translation units and
921:45 - when it doesn't find the definition it's
921:47 - going to give you a link error which is
921:49 - probably going to say undefined
921:51 - reference to something and we're going
921:53 - to see an example of this in a minute
921:55 - okay now that you know about this
921:57 - updated compilation model and you have
921:59 - an idea that we can split our functions
922:03 - across multiple files we're going to
922:05 - head over to visual studio code and play
922:07 - with us
922:08 - okay here we are in our working folder
922:11 - the current project is multiple files
922:14 - here we're going to grab our template
922:16 - files let's copy that
922:18 - and put that in the project of interest
922:22 - and we're going to open this in visual
922:23 - studio code let's do that we're going to
922:25 - open the folder i'm going to choose the
922:28 - project and open it
922:30 - and we are going to open up the main cpp
922:32 - file here
922:34 - and clean it up a little bit we are
922:36 - going to set up a max function and
922:39 - remember the function has to show up
922:41 - before it is used somewhere
922:44 - and uh we are going to split this into a
922:47 - definition and a declaration i think we
922:49 - already know how to do that so let's do
922:51 - that we're going to
922:53 - put a definition down here and we're
922:55 - going to change what we have on top here
922:58 - into a declaration let's say that to be
923:01 - super clear and what we have down here
923:03 - is a definition and we can call this
923:05 - function we're going to set up the
923:07 - variable which is going to store our max
923:09 - for example
923:11 - and we're going to assign whatever we
923:13 - get from the function
923:15 - to max here so we want to find the
923:17 - maximum between 34 and 56 for example
923:22 - and we're going to print this out i'm
923:23 - going to say max is the maximum
923:26 - and if we boil and run this program
923:29 - let's use gcc to do that we have a
923:31 - compiler error here what is that we need
923:34 - a semicolon not a column here
923:36 - i think the squiggly line is now going
923:38 - to go away and our things are named the
923:41 - same way the compiler is not going to
923:43 - like it let's bring up a terminal so
923:45 - that we see our problems tab expression
923:48 - preceding parentheses or parallel must
923:50 - have
923:51 - ah okay the problem here is that these
923:54 - two guys max and max are called
923:57 - the same and this is going to confuse
923:59 - the compiler a little bit so what we're
924:01 - going to do is call this maximum
924:04 - no big deal here
924:06 - and we're going to do maximum here
924:09 - and the compiler is going to be happy
924:11 - now we can compile and i've built this
924:14 - program world is good and if we run it
924:18 - we should get our maximum printed out
924:21 - let's see that the maximum is 56
924:24 - and if we change 34 here to be 134
924:29 - and both again we should grab that as
924:31 - the maximum let's see if that's the case
924:34 - here
924:35 - run the program the maximum is 134.
924:38 - so this is working exactly as we want
924:41 - the next thing we want to do is to split
924:44 - this function across multiple files so
924:47 - we're going to set up two different
924:48 - files one is going to be a header file
924:51 - the other is going to be a cpp file and
924:53 - you have to follow this structure in c
924:55 - plus so we're going to go on the left
924:57 - here and add a new file in visual studio
925:00 - code you can click on this little icon
925:02 - that says new file to create a new file
925:05 - once you do that you're going to be
925:06 - given this little window in which we can
925:08 - type the name of the file we're going to
925:10 - call this compare
925:14 - dot h it's going to be our header file
925:17 - and we're going to add another one which
925:19 - is going to say compare that cpp okay
925:22 - our two files are going to be compare
925:24 - that h and compare that cpp
925:27 - and they are going to contain
925:29 - our functions to compare stuff so we're
925:32 - going to have in a function called max
925:34 - and another function called men for
925:37 - computing the minimum let's go there and
925:39 - actually do that we're going to move our
925:41 - declaration in the header file
925:44 - so your declarations are going to be
925:46 - leaving in header files and we're going
925:48 - to grab our definition and move that
925:51 - in another file called
925:54 - compare.cpp so i'm just going to cut it
925:57 - out and paste that and compare cpp here
926:01 - once we do that we're going to go back
926:02 - in main
926:04 - and see that we have a problem now
926:06 - the main function doesn't know what this
926:08 - max function is because it's not
926:10 - declared anymore and if we're trying to
926:12 - compile our program we're basically
926:14 - going to get the same error we see here
926:16 - and visual studio code identifier max is
926:19 - undefined because it doesn't know what
926:22 - this function is if we ignore this and
926:24 - try to weld let's do that we are
926:26 - learning so no big deal here we're going
926:29 - to get an even
926:30 - much weirder error but the message is
926:34 - going to be the same maths was not
926:36 - declared in the scope so the compiler
926:39 - doesn't know what to do with whatever we
926:41 - typed here but there is a way in c plus
926:43 - plus we can solve this problem by
926:45 - including the header that contains our
926:49 - declaration for the function that we are
926:51 - using here we can go back in main and do
926:53 - that and we're going to say include and
926:55 - we're going to say compare
926:59 - that h
927:00 - that's going to bring in our header and
927:02 - if you wait a minute you're going to see
927:04 - that the squiggly line is going to go
927:05 - away so what happened the preprocessor
927:09 - is going to come in and copy whatever we
927:12 - have inside compare.h it's basically
927:15 - going to go and compare that age copy
927:18 - everything we have in here and come back
927:21 - in main and paste all that in the place
927:24 - where we have the include directive here
927:27 - this is called an include directive or
927:30 - an include preprocessor directive this
927:33 - is what the preprocessor is going to do
927:35 - here and now if we try to build this
927:37 - program let's try to do that we should
927:40 - be fine world finished successfully and
927:43 - we can run our program to see the
927:45 - maximum printed out let's run rooster
927:48 - maximum is 134 now everything is working
927:51 - let's add another function here because
927:53 - just having one function is really
927:55 - boring so we're going to put in a main
927:57 - function it's going to type into a and
927:59 - into b
928:01 - and we're going to go in the cpp file
928:03 - and put in another definition for the
928:05 - minimum function here we're going to
928:07 - call this man
928:10 - let's do that
928:13 - let's call this man and we're going to
928:15 - test for a is less than b this is going
928:18 - to give us a minimum and now if we go
928:21 - back in main cpp we will be able to use
928:24 - our minimum function because it is
928:26 - protein also by this preprocessor
928:30 - directive we have here so we can go down
928:33 - and say end minimum and we're going to
928:35 - say man
928:36 - and let's grab
928:38 - 146
928:40 - and 23 why not and we're going to print
928:42 - the minimum here and we're going to
928:44 - build this with gcc
928:47 - the bullet is going to be good if we run
928:49 - this we should see both the maximum and
928:52 - the minimum from these calls we make
928:54 - here
928:55 - okay by now you should have an idea
928:57 - about how to split your functions across
929:01 - multiple files you should also know that
929:03 - you will have to include whatever header
929:07 - contains the declarations for the
929:09 - functions that you want to use another
929:11 - thing i want you to see is that the
929:14 - definitions for your functions don't
929:16 - have to live in a file that is named the
929:20 - same as the header file for example here
929:23 - our header file is called compare and
929:25 - the comparison tpp contains our
929:27 - definitions but the definitions don't
929:29 - have to live here they can really live
929:32 - in any translation unit that you have in
929:35 - your c plus plus program
929:37 - and our c plus plus programs the
929:39 - translation unit is mostly equivalent to
929:42 - a cpp file so let's set up another file
929:45 - and show you that we can move this
929:47 - definition there and the program is
929:49 - going to keep working we're going to add
929:51 - another cpp file and call it some
929:53 - other file
929:55 - that cpp it has to be a cpp file because
929:58 - it's going to contain the
929:59 - implementations and let's take the
930:02 - implementations for example let's take
930:03 - them all put them in another file why
930:06 - not
930:07 - we're going to grab all these guys here
930:09 - let's catch them out and put them in
930:12 - some other file
930:14 - and i'm going to build this and see that
930:16 - it works it should
930:18 - because the linker is smart enough to go
930:21 - find these definitions
930:23 - and whatever translation units that we
930:25 - have set up in our project here and you
930:28 - see the world is good we can upload this
930:31 - we can run this i should say and we're
930:33 - going to have our output here we can
930:35 - even take one of these guys let it leave
930:38 - in our
930:40 - compare.cpp file for example let's take
930:42 - the minimum function here
930:45 - and we're going to bring that
930:46 - back and we're going to work notice that
930:49 - now
930:50 - our maximum function is living in some
930:54 - other file and that the minimum function
930:56 - definition is leaving and compare that
930:59 - cpp but if we will this is going to work
931:02 - again the linker is
931:04 - going to parse all the translation units
931:07 - looking for whatever
931:08 - definition it needs to find and in this
931:11 - case it will be looking for the maximum
931:14 - here and it's going to find that in some
931:17 - other file and for the
931:19 - minimum function here it's going to be
931:21 - looking and compare and it is going to
931:24 - find it and the world is going to be
931:26 - good and we can run the program again
931:28 - and see our output here
931:31 - one thing i really need to point out is
931:34 - that if the definition is not available
931:37 - let's say the minimum function here is
931:39 - not there we can comment it out to hide
931:42 - it to the compiler or hide it from the
931:44 - compiler
931:45 - and if we try to vote now
931:48 - we will get a linker error let's try to
931:50 - build with gcc
931:53 - uh-huh world finished with errol's the
931:55 - terminal process terminated with execute
931:58 - code -1 but the main message here is
932:02 - that we have an undefined reference to
932:05 - min and and so when we compile the
932:08 - compiler is going to be happy with the
932:10 - declarations that it has found in our
932:13 - compare.h file if we go there we see
932:16 - that we have a declaration for max and
932:19 - the declaration for man the compiler is
932:21 - going to be happy it's going to compile
932:23 - our code and when the compiler compiles
932:26 - it's going to generate object files and
932:28 - it will hand the job over to the linker
932:31 - to stitch all those little object files
932:33 - together to have one single binary file
932:36 - once the linker tries to do that it's
932:38 - going to look at main because that's
932:40 - where it's mostly going to start from
932:42 - and it's going to see uh-huh main is
932:44 - calling minimum here where is the
932:47 - definition for the minimum function it's
932:49 - going to parse every single translation
932:51 - unit in the project it's going to come
932:54 - here and compare that cpp it's not going
932:55 - to find it it's going to look in
932:57 - main.cpp it's not going to find it it's
932:59 - going to look in some other file it's
933:01 - not going to find the definition and the
933:03 - linker is going to say
933:05 - i didn't find my definition for the
933:07 - minimum function so i'm going to throw a
933:09 - linker error and you the developer
933:11 - you're going to fix this problem and
933:14 - you're going to see this error here and
933:16 - again this is a linker error gcc doesn't
933:20 - give you
933:21 - more visible stuff to show you that this
933:23 - is a linker error but what you should
933:25 - look for is ld returned 1 here because
933:30 - ld is the linker that gcc uses so this
933:33 - is a linker error
933:35 - i think i should show you how a linker
933:37 - error looks if you are using a microsoft
933:39 - compiler so we're going to build again
933:42 - but now we're going to build with msvc
933:46 - if you don't have visual studio that's
933:47 - not a problem you can keep using gcc but
933:50 - i just want you to see how different
933:52 - compilers handle these arrows i have the
933:56 - luxury to do that because i am
933:57 - developing this course on a windows
933:59 - machine and i have a microsoft compiler
934:02 - handy that we can use directly from
934:04 - visual studio code here so i am going to
934:07 - choose this compiler
934:09 - and you're going to see that it is going
934:10 - to start welding it is building
934:12 - and it is going to fail and throw a link
934:15 - arrow also so you see here some other
934:18 - object file okay
934:22 - when
934:22 - this object file was being taken and
934:25 - stitched together with other object
934:27 - files to put together a binary it didn't
934:30 - find the definition for the minimum
934:32 - function and it is going to throw a
934:34 - linker error and in visual studio you're
934:36 - going to have a problem like this l and
934:39 - k
934:40 - and it's going to give whatever version
934:42 - of the compiler you are using but down
934:44 - here you see unresolved external symbol
934:47 - this is how visual studio says it and
934:51 - it's basically going to be
934:53 - an undefined reference to something this
934:55 - is just visual studio's compiler's way
934:57 - to say this and again it's going to say
935:00 - this is a linker error here
935:02 - it is basically the same error we saw
935:04 - when we were using gcc in a minute video
935:06 - studio the compiler from microsoft is
935:09 - also going to put a lot of junk in our
935:11 - folder here so let's remove all these
935:13 - things i'm going to select them all
935:17 - and i hate to delete here
935:20 - and they are going to go to my recycle
935:22 - bin and we have another one here we
935:24 - should remove let's remove it
935:28 - and now we should go back in some other
935:30 - file.cpp or compare.cpp that's where we
935:33 - have a minimum function we can activate
935:35 - it and if we're both now the world
935:38 - should be good because the linker is
935:40 - going to find this definition here
935:42 - okay let's build with gcc because that's
935:45 - my favorite compiler
935:47 - now you see that the world is good we
935:49 - can clear and run rooster and our
935:52 - program is going to work as it should
935:54 - this is really how you can split your
935:57 - functions across multiple files the
936:00 - headers are going to contain the
936:01 - declarations the cpp files are going to
936:04 - contain the definitions your definitions
936:07 - can really leave anywhere it's going to
936:08 - be a matter of what works better for
936:11 - your project but for organizational
936:14 - purposes your cpp files are going to be
936:17 - basically like this you're going to have
936:18 - some declarations in the header like
936:21 - compare.h
936:23 - and in a corresponding cpp file you're
936:26 - going to have and the definitions for
936:28 - whatever declarations you have in the
936:30 - header but you don't have to do it this
936:32 - way if it makes sense for your
936:34 - definition to show up somewhere else
936:36 - please go ahead and do that c plus plus
936:38 - is going to accept that this is really
936:40 - all we set out to do in this lecture but
936:43 - before we go i'm going to give you a
936:45 - chance to set up another function
936:47 - suppose we have a function called
936:51 - anchor malt and we're going to have the
936:54 - function set up in here we're going to
936:56 - return
936:58 - a plus plus
936:59 - we already know how to do these things
937:01 - we've used this example a couple of
937:03 - times by now plus plus b
937:07 - and that's what we're going to return
937:09 - now your job is to split this function
937:12 - into
937:14 - a declaration and a definition and put
937:16 - those in two separate files one is going
937:19 - to be called operations.h and the other
937:21 - is going to be called
937:23 - operations.cpp pause the video go ahead
937:26 - set up your project like that and call
937:28 - that function in main cpp and see if you
937:31 - can pull that together okay post the
937:33 - video do that and once you are done come
937:35 - back again and see how i do this so
937:37 - we're going to set up a new file called
937:39 - operations here
937:42 - it's going to be a header file dot h and
937:45 - we're going to add another file called
937:47 - operations.cpp
937:50 - that's going to be our cpp file which is
937:52 - going to contain our definitions we're
937:56 - going to go back in main and grab the
937:58 - entire function here we don't want it in
938:01 - main so we're going to go in
938:03 - the header here
938:05 - we should go in the operations header
938:08 - that's where we want this
938:10 - and we're going to put in our definition
938:12 - and we're going to put in our
938:13 - declaration the declaration doesn't have
938:15 - a body so we're just going to put a
938:17 - semicolon at the end here you already
938:19 - know this we're going to go in the cpp
938:21 - file and put in our definition
938:24 - this is going to work and to be able to
938:26 - use this function
938:28 - we will need to include the
938:30 - corresponding header here why is this
938:33 - file called
938:34 - uh it's called ccp
938:37 - it's cpp we're going to rename it
938:40 - and we're going to change this to cpp
938:44 - now we should be fine we should have our
938:47 - thanks colored
938:48 - properly and uh to use this function we
938:51 - will need to include the corresponding
938:53 - header which is operations.h
938:56 - let's do that we're going to go in main
938:58 - and go down and include
939:03 - operations
939:06 - dot h this is going to work
939:09 - and notice that the way we include our
939:11 - own headers is different from the way we
939:14 - include
939:15 - the libraries or headers that come with
939:18 - the c plus plus standard library this is
939:20 - a conversion that is used by many
939:22 - compilers this is how we will have to do
939:25 - things please remember this if you are
939:27 - including your own header please put
939:29 - that
939:30 - in the quotes like we do here if you are
939:33 - including a standard library header
939:36 - please use angle brackets like this now
939:38 - that we have this
939:40 - included we can go down here and say
939:42 - result
939:43 - we're going to set up two variables x
939:45 - and y
939:46 - why not we're going to have a 4 here
939:49 - and we're going to have a y which is a
939:53 - five let's do that and we're going to
939:55 - have an integer to store our results
939:57 - it's going to say anchor mount and it's
940:00 - going to do the operations on x
940:04 - and y let's do that and we're going to
940:06 - print the results here so we're going to
940:08 - say result
940:12 - and it's going to be whatever we have in
940:14 - that variable
940:18 - okay if we build this program it is
940:19 - going to work we're going to use gcc to
940:22 - world the world is good if we run it we
940:25 - should
940:27 - see our output here going to run rooster
940:30 - and the result is 24 because
940:32 - okay if we increment x we're going to
940:34 - get a 5
940:36 - and if we increment a 5 we're going to
940:38 - get a 6.
940:40 - if we multiply these guys we should get
940:42 - a 30 and that's not what we have here so
940:45 - what is happening let's look at our
940:47 - definition here
940:49 - ah we said a plus plus
940:52 - we should say plus plus a
940:54 - because we want to increment immediately
940:57 - okay let's build again
940:59 - we are going to
941:00 - well successfully
941:02 - and we are going to clear and run
941:04 - rooster now we have the result that we
941:06 - expect let's go back in main and look at
941:09 - our program this is what we are using
941:11 - here and this is the output we expect
941:14 - this is really all we set out to do in
941:16 - this lecture showing you how you can
941:18 - set up your project to split
941:21 - functions across multiple files this is
941:24 - really good if you want to organize your
941:26 - project for example somebody who comes
941:28 - to the header here is not going to be
941:30 - bothered by looking at all the
941:32 - definitions and the details of how we
941:34 - compute this maximum and minimum and we
941:38 - have the flexibility now to move our
941:40 - headers in some other file because we
941:43 - really want to keep the main function or
941:45 - the main file here really clean we don't
941:48 - want all those definitions to show up
941:50 - here because it is possible for your
941:53 - project to contain hundreds or even
941:55 - thousands of definitions if you make all
941:58 - those declarations show up in the main
942:00 - cpp file here that's going to be really
942:03 - hard to follow and work with now we have
942:06 - the flexibility to split those guys
942:09 - across multiple files and we can even
942:11 - use lots of headers if that is what is
942:14 - going to work for our project this is
942:16 - really all we set out to do in this
942:18 - lecture i hope you found it interesting
942:20 - we are going to stop here in this one in
942:22 - the next one we're going to see how we
942:23 - can pass parameters to functions by
942:26 - value go ahead and finish up here and
942:29 - meet me there
942:31 - in this lecture we're going to see what
942:32 - is meant by passing parameters to a
942:35 - function by value and we're going to
942:37 - look at an example of that here we have
942:40 - a simple function called say age it's
942:42 - going to take one parameter which is an
942:43 - integer called age and in the body of
942:46 - the function we are printing out the age
942:49 - after incrementing it suppose this is
942:52 - something useful
942:53 - for your program the function is split
942:56 - into declaration and definition we have
942:58 - a declaration on top here and we have
943:01 - our definition below the main function
943:04 - in the main function we will attempt to
943:06 - use this function we're going to call it
943:08 - down here and we're going to pass a
943:11 - local variable which is called age as
943:14 - our age when we do that we expect this
943:17 - to print you are 24 years old because
943:19 - we're going to increment the age and
943:21 - we're going to say hello you are 24
943:23 - years old this is what this program is
943:25 - going to do but we want to keep track
943:28 - of how the outside variable here is
943:31 - going to change and the age we have
943:34 - passed as a parameter here because this
943:37 - edge we pass as a parameter is not going
943:39 - to be the same as the age we have on top
943:42 - here what we pass here as a parameter is
943:45 - going to be a copy of the actual
943:47 - variable that we passed here and this
943:50 - mechanism is called passing a parameter
943:52 - by value and what you really pass is
943:55 - going to be copy and what you work on
943:57 - inside the body of the function is not
943:59 - going to be the original stuff you
944:02 - passed as an argument to the function so
944:04 - we're going to try and prove that here
944:06 - we're going to print the age before we
944:08 - call the function we're going to print
944:10 - the age after we call the function and
944:12 - what we print here is going to be the
944:14 - outside variable because here we are in
944:17 - the scope
944:18 - of the main function
944:20 - inside the say edge function what we're
944:23 - going to be modifying is a locker copy
944:26 - so we expect the edge here to stay the
944:28 - same before and after the function call
944:32 - so the way this is going to work when
944:33 - control has this function here it's like
944:36 - we're going to have a situation like we
944:38 - have here on the left we're going to set
944:40 - up local copies in the function that are
944:43 - going to contain whatever was passed as
944:46 - an argument to this function and this
944:49 - edge here was passed as an argument to a
944:51 - function so we're going to have a local
944:53 - copy of this h and we're going to store
944:56 - it and it is what we're going to be
944:57 - manipulating in our program when the
945:00 - function goes out of scope the local
945:03 - copy is going to die and the outside
945:05 - variable we have here is basically going
945:07 - to be unaffected let's head over to
945:09 - visual studio code and show you this in
945:11 - action
945:13 - okay here we are in our working folder
945:15 - the current project is passed by value
945:18 - we're going to grab our template files
945:20 - and we're going to put them in place in
945:22 - the correct project and we're going to
945:25 - open this up in visual studio code let's
945:28 - do that we're going to open the folder
945:30 - that contains the project pass by value
945:33 - let's do that we are going to open it up
945:36 - and i'm going to go in the file and
945:39 - clean it up a little bit and we are
945:42 - going to set up a function it's going to
945:44 - not return anything
945:46 - and it's going to say age
945:49 - and it's going to take an integer which
945:50 - is going to be our age
945:52 - and inside we're going to increment our
945:55 - h i think this is what we saw in the
945:57 - slides and we're going to say however
945:59 - many years you are old we're going to
946:01 - say hello
946:02 - you are
946:04 - age old and we can set up a variable and
946:07 - the main function we're going to call it
946:09 - h
946:10 - and it is going to contain 23 as our age
946:14 - we're going to say age and we're going
946:15 - to pass in our age here we can do that
946:19 - if we're trying to run this program
946:20 - let's try to do that we're going to
946:22 - build with gcc and we are going to bring
946:25 - in a terminal we can use to run this
946:28 - program easily from
946:30 - visual studio code here let's run
946:32 - booster we're going to say hello you are
946:33 - 24 years old and this is what we expect
946:36 - because when this function is called
946:38 - we're going to increment the age then
946:39 - we're going to say the age but we want
946:42 - to see
946:43 - what happens to the outside edge ear
946:46 - if we modify the inside edge that we
946:49 - have on this function here that was
946:51 - passed as an argument and again what you
946:53 - pass when you are declaring your
946:55 - function is the parameter and what you
946:57 - pass when you are calling the function
946:59 - is called an argument in c plus plus
947:01 - please remember this okay what we pass
947:04 - as an argument is our anti-age variable
947:06 - which is local to the main function
947:09 - and we're going to see what happens to
947:11 - it let's print the age
947:14 - and say age before call
947:17 - i think this is descriptive enough and
947:19 - we're going to print that and we're
947:21 - going to go after the function is called
947:23 - we're going to say the same thing but
947:25 - we're going to say after call
947:28 - and
947:28 - by after we mean after we call the
947:30 - function say h here i think this is
947:32 - descriptive enough and we're going to
947:34 - see that if incrementing the local
947:37 - variable to the function here affects
947:40 - the variable that we have and the scope
947:42 - of the main function okay so let's see
947:45 - that we're going to build with gcc as
947:47 - always
947:50 - and the wealth is good so let's clear
947:52 - and run rooster you're going to see that
947:54 - before the call we have 23 and after the
947:57 - call we have 23 we didn't change the
948:00 - second call
948:02 - this is a classical copy paste error
948:04 - we're going to change that
948:06 - for our program to really be descriptive
948:08 - enough
948:10 - okay the world is good we can clear and
948:12 - run rooster and now we have before call
948:15 - 23 after call age is 23 it wasn't
948:18 - changed by what we have inside here and
948:22 - we can even go further and look at the
948:24 - memory addresses of these guys
948:26 - here we can try and print the address of
948:29 - the age variable let's let's do that
948:31 - we're going to say
948:34 - address of age
948:36 - and put that out here we're going to say
948:39 - address of age
948:41 - no big deal here we can close the pane
948:43 - on the left here because it is taking up
948:46 - valuable space and we're going to go to
948:48 - the second statement and put in the
948:50 - address of age
948:53 - and we're going to print that out we can
948:54 - do that now we know
948:56 - the address of operator
948:59 - okay we can do that
949:00 - and when we hit the body of our function
949:03 - here we can also print the address of
949:04 - age
949:06 - no big deal
949:07 - so we can say
949:09 - address of age let's do that here and
949:12 - we're going to print the address of the
949:15 - local edge variable here which was
949:17 - passed as a parameter here okay now we
949:20 - can build our program and watch those
949:23 - addresses we're going to build with gcc
949:27 - the world is good we can clear
949:29 - and run a rooster
949:31 - now you see that the outside variable is
949:33 - going to leave at an address that ends
949:36 - in dec
949:38 - and the local variable is going to leave
949:39 - at an address that ends in dc0 so this
949:43 - is a completely new memory location that
949:46 - we are using and it is just going to
949:48 - contain a copy of what we passed as a
949:51 - parameter here and the compiler is going
949:54 - to take care of setting up this copy
949:56 - variable and have it available for use
949:58 - in the local function here we don't have
950:00 - to worry about that but we have to be
950:02 - aware that what we are working on and
950:06 - the same age function here is a copy
950:08 - it's not the original value this is
950:11 - really all we set out to do in this
950:12 - lecture making you aware of the call by
950:15 - value mechanism and the main message is
950:18 - that what you are working on in the body
950:21 - of your function when it is called is
950:23 - going to be a copy of what you have
950:25 - passed as an argument when your function
950:29 - was called here
950:30 - in this lecture we're going to see how
950:32 - we can pass parameters to functions by
950:35 - pointer this is going to allow us to
950:37 - avoid the copies that we were
950:39 - experiencing when we were passing
950:41 - parameters by value like we have seen in
950:45 - the last few lectures here is a simple
950:47 - example showing the syntax we can use to
950:50 - pass parameters by pointer
950:52 - on top here we have our function
950:54 - declaration and down here we have our
950:57 - function definition and you see that the
950:59 - syntax is the same we are passing by
951:02 - pointer and by pointer and the
951:04 - definition here and another thing you
951:07 - should be careful about is that when you
951:09 - call a function that passes by pointer
951:12 - you have to give it an address and
951:14 - that's what we are doing here so we are
951:16 - passing the address of our age variable
951:20 - which is going to be passed by pointer
951:22 - when we pass by pointer we want to be
951:24 - modifying a copy inside the body of our
951:28 - function if you look here we are
951:31 - incrementing the edge variable but we
951:34 - are doing this through the referencing
951:36 - so when we pass a pointer here the
951:39 - pointer is going to contain the address
951:41 - of this guy
951:42 - and in the body of the function the
951:45 - pointer we will have this edge pointer
951:48 - is going to be pointing to the original
951:51 - variable here okay so this edge pointer
951:54 - is going to be pointing to the original
951:56 - edge variable
951:57 - when we dereference it and modify the
952:00 - variable we're going to be affecting the
952:02 - original variable i really hope this
952:03 - makes sense and this is really what
952:05 - passing by pointer is all about you
952:08 - declare your functions by passing in
952:10 - pointers like this and in the definition
952:12 - you do the same and when you call the
952:14 - function you need to pass in an address
952:17 - of the variable because that's what we
952:19 - store in a pointer here and this is
952:21 - going to work if we try to run this
952:23 - example here we're going to print 23
952:26 - because that's the original value we are
952:29 - going to call the say age we are going
952:31 - to increment and this is going to change
952:33 - the original value if we print here
952:35 - we're going to get 24 and when this
952:38 - function terminates we're going to hit
952:41 - this statement here and we're going to
952:43 - print 24 this is what we're going to see
952:46 - when we get to run this program here and
952:48 - this is really all there is about
952:50 - passing by pointer we are going to head
952:52 - over to visual studio code and play with
952:54 - us a little more okay here we are in our
952:58 - working folder the current project is
953:00 - passed by pointer we are going to grab
953:03 - our template files here
953:05 - and we're going to put them in the
953:07 - current project which is pass by pointer
953:11 - we are going to open this in visual
953:12 - studio code pretty quick we're going to
953:14 - choose that pass by pointer we open this
953:18 - and our main cpp file should show up
953:20 - here
953:21 - we're going to clean it up a little bit
953:25 - we are actually going to grab the code
953:27 - from the last lecture and put that in
953:29 - here and that's going to be our starting
953:32 - point let's close the left pane here so
953:34 - that we have some breathing space the
953:37 - function here say h is going to pass by
953:39 - pointer so we should take out this cost
953:42 - here
953:43 - and uh have a pointer here like we had
953:46 - in the slides we're going to do the same
953:48 - in our
953:50 - definition here if we go down we're
953:52 - going to do that we're going to pass by
953:54 - pointer and we are going to uncomment
953:56 - the line that increments our age here
953:59 - okay after we do that you see that we
954:01 - have a squiggly line at this line that
954:03 - calls the say age function what we need
954:06 - to do is to pass it the address of the
954:09 - edge variable here like we saw in the
954:12 - slide so this is the syntax we have to
954:14 - follow
954:15 - once we do this this program is going to
954:17 - be valid and if we run it here we're
954:19 - going to print 23 because that's the
954:22 - value we have in here we're going to
954:24 - call the say age function we are going
954:26 - to increment age and here we forgot to
954:29 - do our dereferencing so what we need to
954:32 - do here is to dereference the age and
954:35 - increment it this is going to increment
954:38 - the original variable here and we're
954:40 - going to be accessing this through the
954:42 - the referencing operator of our pointer
954:45 - here if we hit this line and the
954:48 - function here we're going to print 24
954:50 - because the value has been
954:52 - incremented through this statement here
954:56 - and after the function call we're going
954:58 - to hit this statement here on line 10
955:02 - and it is going to print 24. this is
955:04 - what we expect
955:05 - take a moment to make sure you really
955:07 - understand this the things you need to
955:09 - be careful about is the syntax we use to
955:12 - declare the function here we say that we
955:15 - are passing by pointer because of this
955:17 - little star here and we have the same
955:19 - thing when we hit the definition of the
955:21 - function we have this little star so we
955:24 - are passing by pointer another thing you
955:26 - should remember is to pass the address
955:28 - of a variable when you call the function
955:31 - like we do here and please remember to
955:33 - use the the reference operator whenever
955:36 - you want to modify whatever variable is
955:39 - leaving at the address that you passed
955:42 - in here so that's why we are the
955:44 - reference in here through the star
955:46 - operator like we are doing here this is
955:48 - really all you need to be careful about
955:51 - so we are going to try and run this
955:53 - program let's do that we're going to
955:54 - build with gcc
955:58 - the boiler is going to go through we
956:00 - need to bring in a terminal
956:02 - so that we can run this program and
956:05 - again we expect to see a 23 24 and 24
956:09 - here print it out
956:11 - so let's run rooster
956:13 - okay here is our output before we call
956:17 - the say age function the age is 23 the
956:19 - address is dec when we hit the function
956:23 - we are saying hello you are
956:25 - uh years old so here we should have the
956:29 - reference to access something inside the
956:32 - variable here so we should say you are
956:34 - age old we need to dereference this guy
956:37 - because now it is a pointer i forgot
956:39 - that i really am sorry but we are
956:41 - learning so
956:43 - this is a good learning chance for you
956:45 - not to make the same mistake as i am
956:47 - making here so let's try and build again
956:50 - we should see the correct output we are
956:52 - going to clear
956:54 - and run rooster now we see that before
956:57 - the call
956:58 - ages 23 when we call the function h
957:01 - becomes 24 because we just incremented
957:04 - through our reference operator and after
957:07 - the function call the edge is going to
957:09 - be 24
957:10 - because we have modified the original
957:12 - variable here through our the
957:15 - referencing of the pointer here this is
957:18 - really all there is about passing by
957:20 - pointer this is the syntax you have to
957:22 - pass a pointer in the declaration you
957:24 - have to pass a pointer in the function
957:26 - definition and when you call the
957:28 - function you have to use the address of
957:31 - the variable and pass that as an
957:33 - argument to the function and whenever
957:35 - you need to use the past parameter
957:37 - you're going to go through the the
957:39 - reference operator like we did here
957:42 - and here in the body of our function
957:45 - here
957:46 - in this lecture we're going to see how
957:48 - we can pass parameters to a function by
957:51 - reference
957:52 - and this is another technique we can use
957:54 - to avoid passing by value which is going
957:57 - to create a copy and the syntax is
957:59 - really simple if you look at the
958:01 - declaration here you're going to see
958:03 - that we say and reference and again if
958:07 - we hit the definition we're going to say
958:09 - into reference as you see here
958:11 - when we call the function we don't have
958:13 - to pass the address of operator we just
958:16 - passed the variable because this is
958:17 - going to be treated as a reference by
958:20 - the compiler and in the body of the
958:22 - function we don't have to go through
958:25 - ugly the referencing like we did with
958:27 - pointers and hopefully you can see that
958:30 - if you want to avoid copies passing by
958:33 - references is much cleaner you don't
958:35 - have to use the address of operator when
958:37 - you call the function like we do here
958:40 - and you don't have to go through the
958:42 - reference and to access and modify your
958:45 - variables and the modification we do
958:48 - here by incrementing age is going to be
958:51 - seen on the outside because we are going
958:54 - through a reference and the reference is
958:56 - a true alliance to the variable that the
958:59 - reference is referencing so by
959:01 - incrementing the edge here and the body
959:03 - of the function the change is going to
959:05 - be seen after the function call before
959:08 - the function here we're going to get 23
959:11 - in the body of the function we're going
959:12 - to get 24 because we just incremented
959:15 - the function and after the function call
959:17 - we're going to get a 24 because the
959:20 - change was propagated to the original
959:23 - variable and the reason is because we
959:26 - are going through a reference here
959:28 - let's head to visual studio code and
959:30 - actually play with us a little more okay
959:33 - here we are in visual studio code the
959:35 - current project is passed by reference
959:37 - 1710 here so we're going to grab our
959:41 - template files and put them in place
959:44 - 1710
959:45 - let's do that and we are going to open
959:48 - this in visual studio code pretty quick
959:50 - let's do that the main cpp file is going
959:52 - to show up here again we are going to
959:55 - grab the code from the last lecture and
959:57 - use that as a starting point and we're
960:00 - going to be modifying the signature of
960:02 - our function here so what we want to do
960:05 - is to pass by reference we're going to
960:07 - say enter reference here you already
960:09 - know references from a previous chapter
960:12 - and we are going to hit the definition
960:14 - here and do the same thing so let's say
960:17 - and reference
960:19 - age
960:21 - and when we call the function we don't
960:23 - need to pass the address of operator
960:25 - because this is a reference we can use
960:27 - it right away the compiler is going to
960:29 - know that this is going to be a
960:31 - reference to the original variable that
960:33 - we passed here
960:35 - and in the body of the function let's
960:37 - take out this last line here we don't
960:39 - need it and in the body when we want to
960:42 - modify
960:43 - the reference we can do that right away
960:46 - without the referencing so we can just
960:48 - say plus plus h here and the changes are
960:51 - going to be propagated to the original
960:53 - variable here because we are going
960:56 - through a reference let's go down and
960:58 - modify this because this is a reference
961:00 - we can use it right away
961:02 - and we can close this left pane here so
961:05 - that we have some more breathing space
961:08 - and you see that visual studio code is
961:11 - no longer giving us any squiggly lines
961:14 - so this must be valid c plus plus code
961:17 - again notice the syntaxes we are using
961:19 - here we are passing a reference in our
961:23 - declaration we are passing a reference
961:26 - in our function definition here when we
961:28 - call the function we don't need to do
961:30 - any address of operator we pass the
961:33 - variable as is
961:34 - and in the body of the function we don't
961:36 - have to do any dereferencing we can
961:39 - increment right away
961:40 - or modify the variable however we want
961:43 - the changes are going to be propagated
961:45 - to the original variable because we are
961:47 - passing a reference so the
961:49 - incrementation here is also going to
961:51 - affect the original variable that was
961:54 - declared in the main function here let's
961:56 - take this out and down here if we need
961:59 - to use our variable we're going to just
962:01 - use it right away we don't need any
962:03 - referencing and if we print the address
962:06 - of age here we're going to see the same
962:08 - address we see on the outside because
962:10 - this is a true alias it's going to be
962:12 - referencing the same variable that we
962:15 - have in main here okay now that you have
962:17 - a better idea about this we are going to
962:19 - try and build this we're going to use
962:22 - gcc as always you can see that the build
962:24 - is good
962:25 - if we bring up a terminal to try and run
962:28 - this program
962:30 - we can clear and run rooster
962:33 - we're going to see that before we call
962:35 - the function the h is 23 but the address
962:38 - ends in dec
962:40 - when we hit the function the edge is 24
962:42 - because we just incremented that here
962:46 - but notice that the address of the
962:48 - variable is the same as on the outside
962:51 - so we are modifying the same variable
962:53 - and when the function is done the edge
962:56 - is still going to be 24 because we just
962:59 - modified the original variable through a
963:02 - reference here okay this is the effect
963:04 - of passing by reference you can use a
963:07 - claim syntax to modify the original
963:10 - variable in your functions and this is
963:12 - going to avoid copies like we have seen
963:15 - when we were passing parameters by value
963:18 - a few lectures back i would like to
963:21 - welcome you in this new chapter where we
963:23 - will be focusing on how to get data out
963:26 - of functions again the model of the
963:29 - function is really what you see here it
963:31 - is like a machine and you can give input
963:34 - to that machine and you expect to get
963:36 - something out of that machine this
963:39 - chapter is going to focus on this part
963:41 - here
963:42 - and we're going to see the different
963:43 - facilities offered by the c plus plus
963:46 - programming language to get output from
963:49 - functions and we are going to start in
963:51 - the next lecture and see how we can use
963:53 - input and output parameters go ahead and
963:56 - finish up here and meet me there in this
963:59 - lecture we're going to see how we can
964:00 - use function parameters to get data out
964:03 - of the function
964:05 - here is a simple example and we have
964:07 - three functions here we have max str
964:10 - max and and max double and you notice
964:13 - that we have three parameters for each
964:16 - of these functions the first two
964:17 - parameters are going to be input they
964:19 - are going to get data and the function
964:22 - and the third one is going to be the
964:24 - output parameter and it is going to get
964:27 - data out of the function
964:29 - let's focus on max hdr here and really
964:33 - drive the point home the key idea here
964:35 - is that for the third parameter
964:38 - we are using a modifiable reference and
964:42 - if we use a reference the changes we do
964:44 - inside the function are also going to be
964:46 - visible on the outside and we explicitly
964:50 - left out the const that we have on the
964:53 - other parameters because we want to be
964:55 - able to modify
964:57 - the output variable here inside the
965:00 - function if we marked the third
965:02 - parameter as const we would get a
965:04 - compiler error if we're trying to do
965:06 - something like this and assign something
965:09 - to the output parameter here so the main
965:11 - purpose of this function is to compute
965:13 - the maximum between these two strings we
965:16 - are going to say if input 1 is greater
965:18 - than input 2
965:20 - then input 1 is going to be our maximum
965:23 - and we are going to store that in our
965:26 - output parameter here if input 1 is not
965:29 - greater than input 2 then input 2 is our
965:32 - maximum we're going to store that in our
965:34 - output and whoever has access to input 2
965:38 - outside the function is going to see the
965:40 - changes that we are making in the body
965:42 - of the function this is really the
965:44 - technique we can use
965:46 - to
965:46 - send output from the function and make
965:49 - it visible
965:50 - when the function has returned and again
965:53 - the key idea is that we set up the
965:55 - function in a way that the changes we do
965:57 - inside the function are going to be
965:59 - visible on the outside and we are able
966:02 - to do that because output here is a
966:04 - reference this is really key we have
966:07 - used references here but we can set up
966:09 - the same thing using pointers because we
966:12 - have seen that with pointers we can also
966:14 - make our changes inside the function
966:17 - visible to the outside the two other
966:19 - examples here are really extensions of
966:22 - the same thing we have two input
966:24 - variables input 1 and input 2
966:27 - and
966:28 - output is going to store the output from
966:30 - the function you notice that output is a
966:33 - reference and because of this the
966:35 - changes we do in here are going to be
966:37 - visible when this function has returned
966:40 - and we do exactly the same thing on max
966:43 - double here
966:44 - but you see that it is using a pointer
966:46 - okay i really wanted you to see this so
966:48 - inside we're going to try and figure out
966:50 - who is the maximum and if input 1 is the
966:54 - maximum we're going to write that in our
966:56 - output variable here and you notice that
966:58 - we are the referencing here because this
967:01 - guy is a pointer and if input 2 is our
967:04 - maximum we're going to write that in our
967:07 - output variable here one thing i don't
967:09 - think i explained here is that we have a
967:12 - cost std string reference here for maxed
967:15 - hdr and the reason is that the input
967:19 - variables aren't really meant to be
967:21 - changed that's why we market them as
967:23 - cost and if you want to modify them in
967:26 - some way you can take the const away and
967:28 - it is going to work okay this is really
967:30 - the big idea we are playing with in this
967:32 - lecture using function parameters as a
967:35 - way to output data from the function and
967:38 - here are a few ideas you should keep in
967:40 - mind output parameters should be passed
967:43 - in such a way that you can modify the
967:45 - arguments from the inside the functions
967:48 - and we have seen that we have two ways
967:50 - to do that we could either use
967:51 - references or even use pointers but
967:54 - references are what you should prefer in
967:56 - modern c plus plus input parameters
967:59 - shouldn't be modified they are meant to
968:01 - just get data in the function and that's
968:04 - why in most cases you're going to see
968:06 - that they are marked const okay now that
968:08 - we have seen all these ideas i think it
968:11 - is time we headed over to visual studio
968:13 - code and actually played with them okay
968:15 - here we are in our working folder the
968:17 - current project is input and output
968:20 - parameters we are going to grab our
968:22 - template files like we always do we're
968:24 - going to put them in place and we are
968:27 - going to open this guy in visual studio
968:29 - code we're going to just drag it and
968:31 - drop on top of visual studio code here
968:33 - and it is going to open up we have our
968:35 - main function here we can close the pane
968:37 - here and clean the file up a little bit
968:40 - we're going to remove what we don't need
968:42 - here and we're going to have a bare main
968:45 - function we can play with here the first
968:47 - thing we're going to do is to put in our
968:49 - max str function it is nothing special
968:52 - we just have two input parameters and
968:55 - one output parameter the output
968:58 - parameter is going to be what we use to
969:00 - get output outside the function and
969:03 - inside we're just going to compute the
969:04 - maximum if input 1 is the maximum we're
969:07 - going to write that in our output
969:09 - parameter if input 2 happens to be our
969:11 - maximum we're going to write that in our
969:14 - output parameter because our output
969:16 - parameter is a reference the changes we
969:19 - make inside the function are going to be
969:21 - visible on the outside because we will
969:24 - be working on the original variable
969:27 - through the reference which is really a
969:29 - true alias here okay now that we have
969:32 - the function set up like this we can
969:33 - head in the main function and try it out
969:36 - we're going to set up three variables of
969:38 - type std strand i think we should
969:40 - include the string library here let's do
969:43 - that and we're going to have an out
969:45 - string which is going to be our output
969:48 - variable and we have two input strings
969:51 - one is initialized with alabama the
969:53 - other is initialized with bell view and
969:56 - we're going to call our max sdr function
970:00 - here you notice that it's not going to
970:02 - be using the return mechanism we're
970:04 - going to be grabbing the output from
970:06 - this function using an output parameter
970:10 - which is going to be our out hdr
970:13 - variable here okay once the function is
970:15 - done we're going to have the maximum
970:17 - stored in our out sdr variable here and
970:21 - we can print it out now that we have
970:22 - this setup we can actually try and build
970:25 - this we're going to use gcc let's do
970:27 - that the build is good we can bring up a
970:29 - terminal and clear and run rooster now
970:32 - you see that the maximum is going to be
970:34 - bell view let's try and change this to
970:38 - casablanca why not and we're going to
970:39 - see that the maximum now is going to be
970:41 - casablanca and our function is going to
970:44 - be smart enough to store the maximum in
970:47 - this output variable here let's build
970:50 - again the world is going to be good
970:51 - going to clear and run rooster now the
970:54 - maximum is casablanca hopefully you
970:56 - understand that we are able to make the
970:59 - changes in the function processed
971:02 - because our output parameter here is
971:06 - passed by reference this is a true
971:08 - reference and any change we do to the
971:10 - output parameter here is going to be
971:13 - visible in whatever variable you passed
971:16 - as an argument for this third argument
971:19 - here this is what is making this work
971:21 - now that this is working we're going to
971:23 - comment this out
971:24 - and
971:25 - put in another example for you to play
971:28 - with the next function we're going to
971:29 - play with is going to be max and as you
971:32 - see here and it is very similar to our
971:35 - max hdr but you notice that our inputs
971:39 - are no longer references because we
971:42 - don't really mind copying fundamental
971:44 - types in c plus plus they are small in
971:47 - memory so copying them is really cheap
971:49 - we can pass them by value and this is
971:52 - not going to be so wasteful in our
971:54 - program but the first parameter must be
971:57 - passed by reference because we want to
971:59 - use it as an output parameter and we're
972:02 - going to use it to get output from the
972:04 - function and the way we're going to do
972:06 - that we're going to write whatever
972:08 - variable is the maximum in our output
972:11 - parameter and the changes are going to
972:13 - be visible on the outside now we are
972:15 - going to head over in our main function
972:17 - set up a few variables and play with us
972:19 - so we're going to say and out and this
972:22 - is going to be our output variable and
972:25 - we're going to say input one let's say
972:27 - in one and we're going to initialize
972:29 - this with a 45 why not and we're going
972:32 - to say ent in two and we're going to
972:34 - initialize this with 23 why not now that
972:37 - we have this we're going to say max and
972:39 - and we're going to put in our input
972:41 - we're going to say n1 and n2 then we're
972:44 - going to say out and as our output
972:46 - variable now that we have this we can
972:49 - actually print out whatever number is
972:51 - the maximum through an output statement
972:53 - like this really simple we're going to
972:55 - say max and and we're going to say out
972:58 - to end that's where it is going to be
973:00 - stored and we are able to do this
973:02 - because again the third parameter here
973:05 - is passed by reference and any change we
973:08 - do and the function here is going to
973:10 - stack even when the function here has
973:13 - returned and we're going to have that
973:16 - stored in our third parameter here and
973:18 - this is a really common technique
973:20 - especially in code that has to interface
973:23 - with c code out there from c plus plus
973:27 - and you really need to be aware of this
973:29 - now if we run this program we're going
973:31 - to see our maximum printed out and it is
973:33 - going to be stored in our out variable
973:36 - here let's do that we're going to use
973:38 - gcc to world the world is good you can
973:40 - clear and run rooster and you're going
973:42 - to see that the maximum is 45 if we
973:45 - change and store our maximum in into
973:49 - here and for example let's make this a
973:51 - 723
973:54 - let's build it in to take the changes
973:57 - into account in our
973:59 - rooster.xe binary we're going to clear
974:01 - and run rooster and you're going to see
974:03 - that that's the maximum here we are able
974:06 - to grab whatever is the maximum from
974:08 - these two input parameters and store
974:11 - that in our output parameter here
974:13 - because we are passing that third guy as
974:17 - a reference this is really important we
974:19 - have seen that we can use references to
974:21 - make changes we do in the function stick
974:24 - and be visible in outside variables but
974:28 - we can also use pointers and i am going
974:30 - to show you an example of how we can do
974:32 - that first we're going to comment this
974:33 - out because we don't want noise output
974:36 - in our program and we are going to go on
974:38 - top and set up a max double function
974:41 - which is going to grab our output using
974:45 - pointers the name of the function is max
974:48 - double it's not going to return anything
974:50 - and it is going to take two input
974:52 - parameters input 1 and input 2 and it is
974:55 - going to tell us whichever of these 2 is
974:58 - the maximum the maximum is going to be
975:00 - stored in our output parameter but we
975:03 - are using pointers to make these changes
975:05 - inside the body of the function stick
975:08 - and be visible on the outside of the
975:10 - function so we are going to the
975:12 - reference here because the third guy
975:14 - here is a pointer and we're going to
975:15 - store in whichever is the maximum and
975:18 - when the function returns the maximum is
975:20 - going to be visible on the outside so
975:22 - let's go down and try this out we're
975:24 - going to say double out double and we're
975:26 - going to
975:28 - set up our input here we're going to say
975:30 - in double one and we're going to make
975:32 - this
975:33 - 45.8 why not and we're going to do a
975:36 - second input parameter and int we should
975:39 - say n not end sorry for this in double
975:43 - for input double so we're going to say
975:45 - double 2 and we're going to initialize
975:47 - this with 6.9
975:50 - for example we can really put in
975:51 - anything now that we have this we can
975:54 - call our max double function let's do
975:56 - that going to say max double we're going
975:58 - to say in double one and in double two
976:01 - let's do that and we're going to have
976:03 - out double as our output parameter and
976:07 - uh because it's a pointer we need to
976:09 - pass this guy as an address so we're
976:12 - going to say address of how to double
976:14 - here that's how we're going to be able
976:16 - to manipulate that inside the function
976:19 - here once we do this we are going to
976:21 - have our maximum stored and out double
976:24 - and we can print that out so we're going
976:26 - to say stdcl max double and we're going
976:29 - to say mac and we're going to say out to
976:32 - double std e and el and if we weld why
976:36 - do we have a squiggly line here we don't
976:38 - have a semicolon at the end of our
976:40 - function called here so we're going to
976:42 - build with gcc as always you're going to
976:45 - see that the world is good we can clear
976:47 - and run rooster max is 45.8
976:51 - if we change and store our maximum and
976:54 - in double to here we can change this guy
976:57 - to 76.9
976:58 - we're going to build and see that we are
977:01 - actually grabbing the maximum regardless
977:04 - of the variable in which it is stored if
977:06 - we run rooster we're going to have our
977:08 - maximum and this is working exactly as
977:11 - we want this is really all we set out to
977:12 - do in this lecture showing you how you
977:14 - can use references to use parameters as
977:18 - output channels for data to get outside
977:21 - of the function and be used in variables
977:24 - that are outside the function here i
977:27 - really hope this makes sense and this is
977:29 - a technique you need to be aware of
977:31 - we're going to see other techniques to
977:32 - do the same thing and uh starting in the
977:35 - next lecture we're going to see how we
977:37 - can return from functions for now i hope
977:39 - you found this lecture interesting we
977:42 - are going to stop here in this one in
977:44 - the next one we're going to see how we
977:45 - can use the return mechanism to get data
977:48 - outside our function go ahead and finish
977:51 - up here and make me there
977:54 - in this lecture we're going to see how
977:55 - we can get data outside of a function
977:58 - through the return mechanism and this is
978:01 - going to be an alternative to the way we
978:04 - have been doing things in the last
978:06 - lecture where we used function
978:08 - parameters as channels to get data
978:12 - outside the function
978:14 - let's look at the simple example of how
978:16 - this is done here we have a simple
978:17 - function called sum the function is
978:19 - going to return end
978:21 - and it is going to sum up two parameters
978:24 - that we pass to at nta and end b
978:27 - if we get inside the function we're
978:28 - going to do something really simple
978:30 - we're going to set up a new variable
978:31 - which is local to the function we're
978:33 - going to call that reserved it's going
978:35 - to be the same type as our input
978:37 - parameters and we're going to add up a
978:39 - and b and store the results back in our
978:41 - result variable here
978:43 - once we have this we're going to return
978:45 - this for this variable to be visible by
978:49 - whoever called this function here one
978:52 - thing you should know is that this
978:53 - variable is local to this function here
978:57 - and it will be destroyed the moment we
979:00 - hit the end of the function here and the
979:02 - function terminates
979:04 - so if we go in main here we're going to
979:06 - try and see an example of how we can
979:08 - call this function we have two variables
979:11 - a and b and we have a new result
979:14 - variable set up in the main function
979:16 - please note that this variable is very
979:19 - different from the variable we have and
979:21 - the
979:22 - sum function here because they live in
979:24 - different scopes okay we are calling our
979:27 - sum function here and we are passing it
979:30 - two arguments in the form of a and b
979:33 - here the function is going to compute
979:35 - our sum and it's going to return it and
979:37 - we're going to store that back in our
979:40 - local variable to the main function here
979:42 - the result variable here again is local
979:45 - to this main function okay once we call
979:47 - this function we're going to have our
979:49 - results stored in here and if we print
979:52 - like we do here we're going to see it
979:53 - printed out on the console in this case
979:55 - it's going to print 50 because 34 adding
979:59 - 16 that's going to be 50. but one thing
980:02 - i want you to know is that this is going
980:04 - to return by value and what we mean by
980:06 - this is that we're going to copy
980:08 - whatever we return here and store a copy
980:12 - of that in this result variable that we
980:15 - have in the main function and we're
980:17 - going to prove this
980:18 - notice the stdc out statement we have
980:21 - here this is going to print the address
980:25 - of this local variable and once the
980:27 - function terminates we're going to try
980:29 - and print the address of this resort
980:32 - variable in the local scope of the main
980:34 - function and we're going to see two
980:36 - different addresses and hopefully this
980:38 - is going to prove that we are returning
980:41 - a copy it's not the original variable
980:43 - that we have in the sum function here
980:46 - that we are returning okay hopefully
980:48 - this drives the point home that we can
980:50 - use the return mechanism to get data
980:53 - outside the function and we're going to
980:55 - grab the result in our result variable
980:58 - here and we're going to use it however
981:00 - we wanted the main function
981:02 - but things don't always work like this
981:06 - sometimes the compiler is going to
981:08 - insert optimizations
981:10 - and not really returned by value but
981:12 - returning by value is the default but if
981:15 - the compiler notices that it can do
981:18 - things better it is going to optimize
981:20 - your returns by value to return by
981:23 - reference and you're not going to make a
981:25 - copy but you're going to somehow reuse
981:28 - the local variable in the main function
981:30 - let's look at a simple example to really
981:33 - drive this home we have a function here
981:35 - which is going to add strength it is
981:37 - going to basically concatenate them
981:39 - using the plus operator here and you
981:41 - notice that inside the function here
981:43 - we're going to set up a local variable
981:45 - which is going to store our concatenated
981:47 - string here
981:49 - and we're going to print the address of
981:51 - the local string after that we're going
981:53 - to return the strength so that it is
981:55 - usable by whoever calls this function
981:58 - let's go in main and see how we can use
982:00 - this function here we are setting up a
982:03 - variable called sdr result which is
982:05 - going to store our result strength we
982:08 - are saying add strings here we are
982:10 - calling our function and we are passing
982:13 - in two strings hello and world and we
982:16 - want to concatenate these guys this is
982:18 - going to give us our result and if we
982:20 - print it out we're going to get hello
982:21 - world printed out but the main message
982:24 - here is that the address of the outside
982:28 - string here is going to be the same as
982:30 - the address we have on the inside here
982:33 - and this is going to mean that the
982:35 - compiler has actually
982:37 - done some magic
982:39 - to return the local variable because it
982:42 - has seen that we could really be wasting
982:44 - this guy here inside the function when
982:47 - the function returns this string result
982:49 - here is going to die off but the
982:52 - compiler knows that we can reuse that
982:54 - and avoid the work of copying this
982:57 - string which might be really large
983:00 - suppose this string has a thousand
983:02 - characters inside and copying it would
983:04 - be a waste so the compiler is not going
983:07 - to return by value which is the default
983:10 - it is going to do some kind of return by
983:12 - reference but it's really not a return
983:14 - by reference because this is a local
983:16 - variable we can't really have a
983:18 - reference to a local variable to a
983:20 - function that would be really bad
983:22 - because we might be able to modify it
983:24 - when the variable is actually dead after
983:27 - the function has returned so it is a
983:29 - magic that the compiler is doing to save
983:31 - you from unnecessary copies but you
983:34 - should be aware of this and not make
983:36 - your code rely on returning by value
983:39 - okay now that we know this we're going
983:41 - to head over to visual studio code and
983:43 - actually play with us here we are in our
983:46 - working folder the current project is
983:48 - returning from functions by value we're
983:51 - going to grab our template files pretty
983:54 - quick we're going to copy them let's do
983:56 - that and we're going to put them in the
983:58 - current lecture or project
984:00 - and we're going to open this guy up in
984:03 - visual studio code pretty quick let's do
984:05 - that
984:06 - now we have our main cpp file here we
984:09 - can clean it up a little bit
984:11 - and close the left pane here because we
984:14 - don't need it the first thing we're
984:15 - going to do is to put in our function
984:17 - which is going to compute the sum of two
984:19 - integers and return as the sum of these
984:22 - two guys inside the function we're going
984:24 - to set up a result variable which is
984:27 - going to store the sum and we're going
984:29 - to return it and it is going to be
984:31 - visible to whoever has called this
984:33 - function here again i am going to
984:35 - emphasize that this is going to return
984:37 - by value so what we return is really
984:40 - going to be a copy of this variable here
984:43 - and we're going to prove that by
984:45 - printing the address of this variable
984:47 - inside and outside the function here so
984:50 - we're going to set up two variables in
984:52 - main we're going to say and x let's call
984:54 - our input parameters x and y we're going
984:57 - to put in a five and the second guy is
985:00 - going to be a y and it's going to store
985:02 - an n9 why not after that we're going to
985:05 - set up a variable which is going to
985:07 - store the results let's call this result
985:09 - why not and we're going to say some x
985:12 - and y okay we are passing these guys by
985:14 - value because we don't really care about
985:17 - copying and and it is a fundamental type
985:20 - it is really small in memory so it's
985:22 - going to be very cheap to copy it's not
985:25 - going to hurt the performance of our
985:28 - application but what we want to do now
985:31 - is to print
985:33 - the address of the reserved variable in
985:37 - the main function here and see that it
985:39 - is the same as the
985:41 - address of the variable we have inside
985:44 - here another thing you should watch out
985:46 - for is that we are able to get data
985:48 - outside the function here the sum was a
985:50 - local variable but we are able to get it
985:53 - out of the function through the return
985:56 - mechanism here okay before we go ahead
985:59 - and run this program we're going to fix
986:01 - the statement here we forgot to change
986:04 - this to say out to mean that it is
986:07 - outside the function here that's the
986:09 - meaning we're going to build with gcc
986:12 - the world is good we can clear and run
986:14 - rooster now we're going to see that
986:16 - inside the function the address of the
986:19 - result variable here
986:22 - ends in dac
986:24 - and outside the function when we hit
986:27 - the end of the function here we're going
986:29 - to see that the address ends in de4 so
986:32 - this proves that the local variable
986:35 - inside the function and the outside
986:38 - variable here in the main function
986:40 - leaving two different memory addresses
986:42 - there are two different variables and
986:44 - the return mechanism here is just going
986:47 - to copy whatever we have in the local
986:50 - variable and make it available on the
986:52 - outside here so that we can assign it to
986:56 - the reserved variable in our main
986:58 - function here this is how the return
987:00 - mechanism is working and it is going to
987:02 - be returning by value by default it is
987:05 - going to be making copies this is the
987:07 - message here now that we know this i
987:09 - want to show you that there are
987:11 - exceptions to that rule
987:13 - if you return by value like this you
987:15 - won't be really always using separate
987:18 - memory addresses for the inside and the
987:21 - outside here and we're going to prove
987:23 - that with a function that is going to
987:25 - add up two strings
987:26 - let's comment what we have out because
987:29 - we don't want this to confuse us so
987:31 - we're going to bring this inside our
987:34 - block comment here and we are going to
987:36 - go below our sum function here and set
987:38 - up a new function which is going to be
987:40 - called add strands it is going to return
987:43 - a string by value okay it is by value
987:46 - because this return type here is not
987:49 - qualified with anything like a pointer
987:51 - or a reference so by default it is going
987:53 - to be by value and inside you see we are
987:56 - doing the exact same thing we did in the
987:58 - sum function here we are adding up two
988:01 - strands we are storing the results in a
988:03 - local variable and we are returning that
988:06 - but if we run this program you're going
988:08 - to see that the address on the inside is
988:11 - going to be the same as the address on
988:14 - the outside so let's set up something
988:16 - that we can play with here we're going
988:18 - to go down in the main function and set
988:20 - up a few variables we're going to say
988:22 - hdd strand we're going to say
988:24 - nstr1 and we're going to store in hello
988:28 - let's do that and we're going to say std
988:30 - strength
988:31 - and str2
988:33 - and we're going to store and world by
988:36 - now you know what i am trying to do here
988:38 - i am trying to say hello world okay once
988:40 - we have this we're going to set up a
988:42 - resort strike so we're going to say std
988:45 - strength and i say result str and we're
988:48 - going to say add sdr and we're going to
988:51 - add up
988:52 - nstr1 and in str2 this is how we do this
988:57 - and after we do this we're going to
988:59 - print out the address of the variable
989:02 - here so let's do that and it is going to
989:04 - be the address of result hdr let's say
989:08 - that here and we also need to print the
989:11 - actual result of this operation here so
989:14 - let's do that we're going to say sddc
989:17 - out result sdr we're going to print the
989:20 - actual
989:21 - strength i don't think we did that on
989:24 - our
989:25 - sum function here but we can quickly go
989:28 - there and prove that to you so let's
989:30 - comment this out sorry for this this is
989:33 - going to be confusing but i don't want
989:35 - to leave you with
989:36 - unexplained thanks
989:38 - so we're going to see that if we print
989:40 - this out we're going to get the sum
989:42 - which is 14 printed out let's do that
989:45 - pretty quick we're going to go down and
989:47 - say sddcl and say result and we're going
989:50 - to say result and we're going to build
989:52 - it pretty quick with the gcc and if we
989:55 - clear and run the rooster we're going to
989:58 - see the result which is 14 here and you
990:00 - can change these guys up to really play
990:02 - with us for example if we make this 15
990:04 - and put in a 9 we're going to get a 24
990:07 - printed out let's build again
990:09 - just to have fun with this and we're
990:11 - going to clear and run rooster we're
990:13 - going to get a 24 here now we can
990:15 - comment this back i am happy i have
990:18 - showed you this and we can uncomment our
990:20 - string code here and uh build and run it
990:24 - so we're going to build with gcc the
990:27 - build is good we can clear and run
990:29 - rooster and again what we want to see
990:32 - is that the compiler is going to
990:34 - optimize this out it is not going to
990:36 - return by value like we had was the sum
990:39 - function where we had the address on the
990:42 - inside different from the address on the
990:44 - outside you see here that inside ah we
990:48 - forgot again to change this guy to out
990:50 - uh sorry for this so we're going to make
990:52 - this guy out and we're going to build
990:54 - again and we're going to clear
990:56 - clear and run rooster now we're going to
990:59 - see that inside the address ends in d30
991:03 - and outside the address ends in d30 this
991:07 - can be really confusing because we said
991:10 - we want to return by value by not
991:12 - decorating our return type with a
991:15 - pointer or a reference or something like
991:17 - that it is going to be returning by
991:19 - value and if you return by value you're
991:21 - going to make copies and if we made the
991:23 - copies the address on the inside and the
991:27 - address on the outside should be
991:29 - different but they are the same the
991:31 - reason is the compiler is going to
991:32 - notice that you are trying to copy
991:35 - strands
991:36 - and it is going to see that the variable
991:38 - here which is inside the function is
991:40 - going to be wasted when the function
991:42 - returns
991:43 - by default this should be really
991:45 - destroyed and you should copy
991:48 - because you are returning by value but
991:50 - the compiler is going to insert an
991:52 - optimization to do some magic and make
991:55 - it look like you are returning by
991:57 - reference and it is really not going to
991:59 - make a copy so it is going to reuse the
992:01 - address on the inside and hopefully this
992:04 - is going to prove this to you the
992:06 - message here is that you shouldn't rely
992:08 - on your functions
992:10 - returning by value because if the
992:12 - compiler sees that it can do a better
992:15 - job than you it is going to optimize
992:17 - your return by value to return by
992:20 - reference and you're going to not be
992:22 - making copies so don't make your code
992:25 - rely on returning by value and making
992:28 - copies and you should be aware of these
992:31 - optimizations that the compiler can do
992:34 - behind your back i would like to welcome
992:37 - you in this new chapter where we will be
992:39 - learning about function overloading
992:42 - function overloading is a mechanism we
992:44 - have in c plus plus
992:46 - to have multiple copies of the same
992:49 - function but taking different parameters
992:52 - for example here you see that we have
992:54 - different functions but all these
992:56 - functions have the same function name
992:58 - and these are said to be different
993:01 - overloads of the same function there are
993:04 - a couple of rules you need to be aware
993:06 - of to be able to set up your overalls
993:08 - correctly and get them to work and
993:10 - that's what we're going to be learning
993:11 - about in detail in this chapter but now
993:14 - i just want you to see the flexibility
993:16 - you can get with function overloading
993:19 - for example here if we have a few
993:21 - variables in our program we can call the
993:24 - max function and the compiler is going
993:27 - to select the most fitting overloading
993:29 - here so for example if we call our
993:32 - function with integer arguments the
993:35 - compiler is going to choose this
993:37 - overload here if we call a function with
993:39 - std string arguments the compiler is
993:42 - going to choose this overload here and
993:45 - we don't really need to concern
993:47 - ourselves
993:48 - with making sure we have the correct
993:50 - arguments the compiler is going to
993:52 - choose the correct function overload for
993:54 - us and it is going to call it and it's
993:56 - going to be very flexible to call these
993:58 - functions from our c plus plus code this
994:01 - is how function overload can be really
994:04 - useful we are going to stop here in this
994:06 - lecture in the next one we're going to
994:08 - learn about how you can set up function
994:10 - overloads based on different function
994:13 - parameters
994:14 - go ahead and finish up here and meet me
994:17 - there in this lecture we're going to see
994:19 - how we can overload functions based on
994:22 - the parameters that we pass to the
994:24 - function when we are declaring it or
994:27 - defining it and here is a simple example
994:29 - to drive the point home here we have a
994:32 - function called max
994:34 - and this is the name
994:36 - it is taking two parameters which are of
994:38 - type and here
994:40 - and by overloading this function we will
994:43 - have to use the same name as this
994:46 - function here so the differences really
994:48 - will be in the parameters that we pass
994:51 - to the function because the return type
994:54 - isn't
994:55 - involved in defining the signature of
994:58 - the function so if we try to set up
995:00 - another function called max here which
995:02 - takes the exact
995:04 - same parameters as our max on top here
995:07 - the difference is only going to be in
995:09 - the return type the compiler is not
995:11 - going to allow us to do this because the
995:13 - return type isn't really significant
995:17 - in making two functions different okay
995:19 - the only way we have to set up a
995:21 - function which is legal in c plus plus
995:24 - is to change something about the
995:27 - parameters that we have here we can
995:29 - change the types like you see here for
995:31 - example we change the types to b double
995:33 - if the types are different we might even
995:36 - change the order of the parameters you
995:38 - just have to make sure the parameter
995:40 - list is different in one way or another
995:43 - that's how you're going to get this
995:45 - function to run with the same names here
995:48 - and if we manage to set up multiple
995:49 - functions with the same name in c plus
995:52 - plus these functions are going to be
995:54 - called overloads of each other okay if
995:56 - we go down here we have another overload
995:59 - for the max function this overload is
996:01 - going to take two parameters and the
996:03 - parameters are going to be of type
996:05 - string view they are different from what
996:08 - we have on top here which is ant so this
996:10 - is a legal overload for this max
996:13 - function here and we can use it okay we
996:16 - really have a few ways we can make our
996:18 - function overloads by now we can change
996:21 - the order of the parameter we can change
996:23 - the number of the parameters or even we
996:26 - can change the types of the parameters
996:28 - again function overloads are a mechanism
996:31 - we have in c plus plus to set up
996:34 - multiple functions with the same name to
996:36 - make our code easier to work with okay
996:39 - now that you know that let's look at a
996:41 - simple example of how we can call our
996:43 - overloads we have a few variables
996:45 - declared here we have ant variables we
996:48 - have double variables and we have std
996:50 - string view variables
996:52 - and if you go down here we are calling
996:54 - our max function passing in integers so
996:57 - the overload that takes integers for
997:00 - this max function is going to be called
997:02 - here down here we are passing in integer
997:05 - literals so this is going to call the
997:07 - int overload down here we are calling
997:10 - the function with double parameters or
997:12 - arguments so this is going to call our
997:15 - double overload for the match function
997:17 - here and down here we are passing in our
997:20 - string view parameters and this is going
997:22 - to call the overload that takes string
997:25 - view parameters and the last guy here is
997:28 - going to take
997:29 - two string literals string literals can
997:33 - implicitly convert to std string view so
997:37 - our std string view overload for the max
997:40 - function here is going to be called
997:43 - now that we know this we're going to
997:44 - head over to visual studio code and play
997:46 - with this a little more okay here we are
997:49 - in our working folder the current
997:51 - project is overloading with different
997:54 - parameters here we're going to grab our
997:57 - template files like we always do we're
998:00 - going to put them in place
998:02 - and we are going to open this guy in
998:04 - visual studio code by dragging and
998:06 - dropping on top of visual studio code
998:08 - here this is going to open our project
998:10 - here we're going to click on our main
998:12 - cpp file and open it we're going to
998:15 - clean it up a little bit and close the
998:18 - left pane here we are going to go on top
998:20 - here and put in our first max function
998:23 - here the return type is and in this case
998:26 - it is going to take two parameters and
998:28 - it is going to return whichever number
998:30 - is the maximum and we are taking
998:33 - parameters in by value and returning by
998:35 - value here nothing special we can go in
998:38 - main and call this function and you
998:39 - already know how to do that i don't
998:41 - think i really need to do that
998:43 - but now what we really are interested in
998:46 - is being able to set up different
998:49 - functions with the same function name
998:51 - like we have here because if for example
998:54 - you take this function and put that down
998:56 - below we're going to make a copy of it
998:58 - and only change the return type if we
999:01 - try to compile this program you see that
999:03 - even visual studio code is unhappy now
999:06 - if we bring up a terminal it is going to
999:08 - tell us cannot overload function
999:11 - distinguished by the return type alone
999:14 - so again the message is super clear here
999:17 - the return type is not enough to make
999:20 - two functions different because the
999:22 - return type isn't involved in making the
999:26 - signature unique what makes the
999:28 - signature unique is either the function
999:30 - name or the parameters that you pass to
999:33 - the function here so we're going to make
999:36 - this return type back a double and we're
999:38 - going to figure out a way to make these
999:40 - two functions different but have the
999:42 - same name here because sometimes you
999:44 - really want this
999:45 - one way we have to do this is to change
999:47 - the types of the parameters that we pass
999:49 - in here so we're going to make them
999:51 - double and we're going to make them
999:53 - double here and this is going to be
999:55 - valid c plus plus could these two
999:58 - functions are different even if they
1000:00 - have the same name here they are two
1000:02 - different functions because they take
1000:04 - different parameters so if you try to
1000:06 - call this function with
1000:08 - integers this one is going to be called
1000:11 - which takes integers n if you call it
1000:14 - with double arguments this guy here is
1000:16 - going to be called let's try and prove
1000:17 - this so we're going to go inside and say
1000:20 - stdc out and overload called i think
1000:24 - this is enough and we're going to go in
1000:26 - the double function here and say sddc
1000:28 - out double overload cool
1000:31 - okay once we have this we also have to
1000:33 - change the return type here to double
1000:35 - because it's going to make things a
1000:37 - little bit consistent here but now we
1000:39 - want to go in our main function here
1000:43 - and set up a few variables we're going
1000:44 - to say and x and we're going to make
1000:46 - this a four and we're going to say into
1000:48 - y and we're going to make this a nine
1000:51 - why not
1000:52 - we're going to set up also double
1000:54 - variables let's say double a
1000:57 - and say five
1000:59 - point four to make it a double variable
1001:02 - and we're going to say double
1001:04 - b and put in 7.4
1001:08 - why not
1001:09 - now we are going to call max we're going
1001:11 - to say auto result and say max and
1001:15 - passing x and y
1001:17 - what do you think we're going to return
1001:19 - here so what we really are interested in
1001:22 - is the return type of the result
1001:24 - variable here and the compiler is going
1001:26 - to deduce whatever is returned by this
1001:29 - function if we call the function with x
1001:31 - and y x and y are integers so the
1001:34 - compiler is going to search for a
1001:36 - function that takes integers and it's
1001:38 - going to find this guy here and that's
1001:39 - what it's going to be called
1001:41 - let's weld and run this program we are
1001:44 - not interested in looking at the output
1001:46 - here we're just going to see this std
1001:49 - out statement here print whatever
1001:52 - function was called okay we expect the
1001:55 - end one to be called so we're going to
1001:56 - see ant overload called on the terminal
1001:59 - here when we run this program so let's
1002:02 - do that we're going to build with gcc
1002:04 - like we always do the world is good so
1002:07 - we can clear and run rooster
1002:09 - we're going to see int overload called
1002:12 - okay so this proves that
1002:14 - we can set up two functions with the
1002:16 - same name and make them different only
1002:19 - in the parameters that they take and the
1002:22 - differences may be either in the types
1002:24 - of the parameter like we are doing here
1002:27 - they may also be in the order of the
1002:29 - parameters and we're going to see an
1002:31 - example of that in a minute but before
1002:34 - we do that we also need to try this with
1002:36 - a and b and show you that the double one
1002:38 - is going to be called because we are
1002:41 - passing in double arguments here so
1002:43 - let's build again the bullet is good we
1002:45 - can clear and run rooster this is going
1002:48 - to call our double overload hopefully
1002:51 - this really drives the point home
1002:54 - that we can set up multiple overloads
1002:56 - for the same function name and again the
1002:59 - differences are going to be in the
1003:00 - parameters that we pass here we have
1003:03 - been able to pass different types for
1003:06 - the parameters and this was a vehicle c
1003:08 - plus plus code but we can also set up
1003:10 - another overload just by changing the
1003:14 - types and the order of the parameters
1003:17 - let's do that we're going to make the
1003:18 - first parameter here and and once we do
1003:21 - that this is different from any of the
1003:23 - overloads we've had so this is a valid
1003:26 - overload for this max function here this
1003:29 - is going to work we can even change the
1003:31 - order of these two guys and it is also
1003:33 - going to be
1003:34 - a valid overload let's put in another
1003:37 - variant of this guy
1003:39 - and we're going to change the first
1003:40 - parameter to double and the second one
1003:43 - to end and now we have four overloads
1003:46 - for the max function and again the
1003:48 - message here is that you just have to
1003:51 - make sure the parameters are different
1003:54 - in some way and your overload is going
1003:56 - to be valid and again i'm not telling
1003:59 - you to set up functions like this
1004:00 - because in this case this is really
1004:02 - useless but i am trying to expose this
1004:05 - facility to you so that you can use it
1004:07 - to your advantage if it makes sense for
1004:10 - whatever application you are designing
1004:12 - here so let's go down and put in
1004:15 - meaningful output i think we can come in
1004:18 - here and say the parameters that we are
1004:20 - passing in here so we can say and double
1004:22 - overload called and if we go down here
1004:25 - you can take this out and say double and
1004:28 - overload called and to get any of these
1004:30 - guys to be called we have to pass the
1004:32 - parameters or of the arguments in this
1004:35 - order
1004:36 - so if we pass in an end which is x x is
1004:39 - in it and we pass in a double which is a
1004:42 - b here this is going to call our
1004:44 - overload which takes the first argument
1004:47 - to be an integer and the second argument
1004:50 - to be double
1004:51 - let's prove that we're going to
1004:53 - build with the gcc the bolt is good so
1004:55 - we can clear and we can run rooster and
1004:57 - we see ant double called because x is an
1005:00 - end
1005:01 - and b is a double if we flip these guys
1005:04 - let's say b and x then we're going to
1005:07 - have the overload that takes the first
1005:09 - argument of double type and the second
1005:12 - argument of into type to be called and
1005:15 - that's this guy here and we're going to
1005:17 - see this message printed out on the
1005:19 - terminal here let's build with gcc to
1005:22 - really prove this so we're going to do
1005:24 - that
1005:25 - the bullet is good we can clear and run
1005:27 - rooster
1005:28 - and the double end overload called
1005:30 - hopefully you can really see that you
1005:32 - can set up all kinds of crazy overloads
1005:35 - for your functions the next thing i want
1005:38 - you to see is that we can even change
1005:39 - the number of the parameters for example
1005:42 - here we can set up another guy here and
1005:44 - i call it max it is going to be exactly
1005:47 - like the one on top here for the first
1005:49 - two parameters but let's add a third
1005:52 - parameter maybe make it an end and say c
1005:56 - and this is going to be
1005:57 - a valid overload for the max function
1006:00 - here so we're going to say double and
1006:02 - because it takes
1006:04 - three parameters i won't go into the
1006:06 - details of how we can compute the
1006:08 - maximum between these three guys what i
1006:11 - really am interested in is showing you
1006:13 - that you can set up overloads here so
1006:15 - for this case we are just going to
1006:17 - return let's just say a this is going to
1006:20 - work but this is a valid overload for
1006:23 - the match function and it is going to
1006:25 - compile so let's draw and do that we're
1006:27 - going to pass and a double a net and the
1006:30 - net so we're going to pass in b which is
1006:32 - a double and x and y
1006:34 - let's see what is called here we can
1006:36 - compile with gcc the border is good we
1006:39 - can clear and please
1006:41 - try to come up with what is going to be
1006:43 - printed out here what is going to be
1006:44 - printed okay now that you have guessed
1006:47 - we're going to run and we're going to
1006:48 - see double and ant because this is going
1006:50 - to call this overload again you can
1006:53 - overload based on the differences in the
1006:56 - types of the parameters that you pass
1006:58 - you can change the order of the
1007:00 - parameters like we are doing here double
1007:03 - end and end double or you can even
1007:06 - change the number of the parameters
1007:08 - using these techniques you can make sure
1007:11 - that your overloads are different in
1007:13 - some way
1007:14 - before i close this lecture i'm going to
1007:16 - show you that you can also use another
1007:18 - overload that takes
1007:20 - string view parameters let's go down
1007:22 - here and put that in
1007:24 - again the name of the function is max
1007:26 - the return type isn't really meaningful
1007:29 - in making sure two functions are
1007:31 - different but watch the parameters we
1007:33 - pass here the types are string view
1007:36 - and we have a and b here and we are
1007:38 - going to compute the maximum so if we go
1007:40 - down here and say max and pass n hello
1007:44 - and world the compiler is going to try
1007:46 - and look for a function that takes two
1007:49 - character array parameters it's not
1007:51 - going to find it because we don't have
1007:53 - that guy in here but it's going to see
1007:55 - which function can
1007:57 - take something i can come up with
1008:01 - through implicit conversions and the
1008:03 - compiler is going to see that it can
1008:04 - really convert from
1008:06 - a string literal to a string view type
1008:09 - and it is going to insert an implicit
1008:12 - conversion from
1008:13 - string literal to string view and this
1008:16 - function here is going to be called so
1008:18 - we're going to put in a an output
1008:21 - statement here we're going to say
1008:23 - string view string view overload called
1008:27 - and if we try and run this program let's
1008:30 - build with gcc make sure that the build
1008:32 - is good
1008:33 - the world is good so we can clear and
1008:36 - run rooster this is going to show string
1008:38 - view string view overload called we are
1008:41 - able to call this guy here and again the
1008:44 - message is that we really have a lot of
1008:46 - flexibility in how we can set up
1008:49 - overloads for a function in c plus plus
1008:52 - and please use this facility at your
1008:55 - advantage if this makes things better
1008:57 - for whatever application you are
1008:59 - designing i would like to welcome you in
1009:02 - this new chapter where we're going to be
1009:04 - learning about lambda functions lambda
1009:06 - functions are a mechanism we have in c
1009:09 - plus plus to set up anonymous functions
1009:12 - once we have anonymous function set up
1009:15 - we can do all kinds of crazy things with
1009:17 - them for example we can give them names
1009:19 - and code them multiple times or we can
1009:22 - even call them directly without even
1009:25 - giving them a name i realize this can be
1009:27 - really cryptic so we're going to head
1009:29 - over to the next lecture and see how we
1009:31 - can declare and use our lambda functions
1009:35 - go ahead and finish up here
1009:37 - and meet me there in this lecture we're
1009:39 - going to see how we can declare and use
1009:42 - our lambda functions and again lambda
1009:44 - functions are a mechanism we have in c
1009:47 - plus plus to set up anonymous functions
1009:51 - and an anonymous function is a function
1009:53 - without a name we're going to see how we
1009:55 - can set up an anonymous function
1009:57 - optionally give it a name and call it or
1009:59 - we can even call it directly without
1010:02 - giving that a name let's see how we can
1010:04 - do that before we talk about anything
1010:06 - about lambda functions we're going to
1010:08 - first to see
1010:09 - the lambda function signature and there
1010:12 - is a special syntax you have to follow
1010:15 - if you want to set up a lambda function
1010:16 - in c plus plus the first thing you have
1010:18 - to put in place is angle brackets like
1010:21 - this and that's going to be your capture
1010:24 - list we are not going to talk anymore
1010:26 - about this we're going to have a chance
1010:27 - to talk about this in detail after your
1010:30 - capture list which is going to leave in
1010:32 - this pair of angle brackets you're going
1010:35 - to have the parameters to your lambda
1010:37 - functions and this is where you can pass
1010:39 - arguments if you want to call your
1010:41 - lambda function after that you're going
1010:43 - to have a return type for your lambda
1010:46 - function but you don't have to put this
1010:49 - in explicitly you can live this out and
1010:52 - the compiler is going to deduce your
1010:53 - return type by itself
1010:56 - after all these things you have to put
1010:58 - in a pair of curly braces and inside
1011:01 - these curly braces we're going to have
1011:03 - our function body and we can do whatever
1011:06 - we want our lambda function to do in
1011:09 - this function body here after this you
1011:11 - will have to remember to put your
1011:12 - semicolon to make whatever statements
1011:15 - contain
1011:17 - this along the function to be valid and
1011:19 - this is the syntax you have to follow
1011:21 - here we have a simple example so we have
1011:23 - our lambda function we want to say hello
1011:26 - to the console this is what we have in
1011:28 - the body of the lambda function but
1011:30 - notice that we have our capture list
1011:32 - which is going to be
1011:34 - delimited by these angle brackets we
1011:37 - have our parameter list which is going
1011:40 - to be empty in this moment because this
1011:42 - lambda function doesn't take any
1011:43 - parameter and we have our body which is
1011:46 - going to leave within
1011:48 - these two curly braces and after that we
1011:51 - have our semicolon to make this a valid
1011:54 - c plus plus statement if we try and put
1011:57 - this thing in our c plus plus source
1011:59 - code
1012:00 - this is going to be a valid lambda
1012:02 - function but it isn't really useful by
1012:04 - now because we can't call it one way we
1012:07 - have to call it is to give it a name and
1012:09 - we can give it a name by assigning our
1012:12 - lambda function to a variable like we
1012:15 - see here once we have our lambda
1012:17 - function declared like this this entire
1012:20 - thing is going to be our lambda function
1012:22 - type we can take this and assign that to
1012:25 - a variable which is going to deduce the
1012:28 - type
1012:28 - using auto type deduction here this is
1012:31 - what we are doing
1012:32 - once this thing has a name then we can
1012:35 - call it with the syntax we have here and
1012:38 - if we run this code now it is going to
1012:40 - print hello world to the console i
1012:43 - realize this syntax can be really
1012:45 - cryptic but if you try to remember this
1012:48 - you're going to find that lambda
1012:50 - functions are really cool and later in
1012:53 - the course we will see that they really
1012:54 - make a lot of things easier in c plus
1012:57 - plus so try to remember the syntax here
1013:00 - and everything is going to flow from
1013:02 - here again the syntax is to have the
1013:04 - capture list which is going to be the
1013:06 - first thing the second thing is going to
1013:08 - be the parameters the third thing is
1013:11 - going to be the return type which is
1013:13 - optional you can leave this out and the
1013:14 - compiler is going to deduce this and
1013:16 - after this you're going to have your
1013:18 - pair of curly braces and the body of our
1013:21 - lambda function is going to leave within
1013:24 - these curly braces this is the syntax
1013:26 - you need to remember okay we have seen
1013:28 - that we can give a name to our lambda
1013:30 - function and call it but it is also
1013:33 - possible to call our lambda function
1013:36 - directly without giving it a name and we
1013:39 - do that by appending a pair of curly
1013:42 - braces to the lambda function definition
1013:45 - here so we have a lambda function we
1013:47 - have our curly braces and we have our
1013:49 - parameter list we have our body here and
1013:52 - after the closing curly brace we're
1013:55 - going to add a pair of parentheses to
1013:57 - call this lambda function and because
1014:00 - this lambda function takes no parameter
1014:02 - we're not going to put any argument
1014:04 - within our parenthesis here and this is
1014:06 - going to call our lambda function don't
1014:09 - worry if you find this confusing we're
1014:11 - going to head over to visual studio code
1014:12 - in a minute and all of this is going to
1014:14 - make sense okay so far we haven't really
1014:17 - seen that we can pass parameters to our
1014:19 - lambda function here is a simple example
1014:22 - that takes parameters this is a lambda
1014:24 - function because it follows the syntax
1014:27 - for lambda functions we have
1014:29 - our capture list we have our parameter
1014:31 - list we have our curly braces and the
1014:34 - body is going to live inside these guys
1014:36 - and we are calling this lambda function
1014:38 - directly with this parameter list the
1014:41 - lambda function is going to take two
1014:43 - parameters of double type we're going to
1014:45 - print out the sum of these two numbers
1014:48 - and that we are going to call this
1014:50 - lambda function directly notice that we
1014:52 - are passing in our arguments
1014:55 - as
1014:56 - double
1014:57 - literals okay this is how you can set up
1015:00 - a lambda function that takes parameters
1015:02 - and call it directly another thing we
1015:04 - can do is make our lambda function
1015:07 - return something and that's really
1015:09 - simple we're going to set up the lambda
1015:11 - function like this so it's going to take
1015:12 - two parameters a and b
1015:15 - and here you see that we are returning a
1015:17 - plus b and we can do that the lambda
1015:20 - function is now going to return
1015:21 - something and this entire thing we have
1015:24 - here is going to be a lambda expression
1015:28 - the lambda function is going to be
1015:29 - called it is going to return something
1015:31 - and what the lambda function returns is
1015:34 - going to be assigned to this result
1015:36 - variable here and if we print it we're
1015:38 - going to get the sum of whatever pass in
1015:40 - here printed out on the console and
1015:42 - you're going to see it printed out on
1015:45 - the terminal it is also possible to put
1015:47 - your lambda function directly in an
1015:50 - output statement i realize this can be
1015:52 - really confusing but please look at this
1015:56 - entire lambda function is same here
1015:59 - as a single value because this is a
1016:02 - lambda function that is going to return
1016:04 - something and what is returned by this
1016:06 - lambda function is going to be printed
1016:09 - as our result here
1016:11 - again i realize this may be confusing to
1016:14 - many of you guys we are going to head
1016:16 - over to visual studio code in a minute
1016:18 - and we're going to see this and you're
1016:19 - going to really understand okay the last
1016:21 - thing we're going to look at is that we
1016:23 - can specify a return type to our lambda
1016:26 - function and the syntax to do this is to
1016:29 - do a dash
1016:30 - a greater than symbol and put your type
1016:34 - after that and when you do that now this
1016:36 - lambda function is going to be forced to
1016:39 - return double type even if you pass it
1016:42 - to parameters that are not of double
1016:45 - type we are going to add them up and the
1016:47 - return type is going to be implicitly
1016:49 - converted to double and that's what
1016:51 - we're going to return and we can print
1016:53 - it out on the console and we're going to
1016:55 - see an example of this in a minute when
1016:57 - we hit visual studio code in fact this
1017:00 - is really all i had to share with you in
1017:02 - the slides i realized many of these
1017:04 - things may be confusing we are going to
1017:07 - head over to visual studio code and play
1017:09 - with these things step by step and i am
1017:12 - sure you're going to understand here we
1017:14 - are in our working directory the current
1017:17 - project is declaring and using lambda
1017:19 - functions we're going to grab our
1017:21 - template files and put them in place
1017:24 - let's do that and we're going to grab
1017:26 - our folder here and drag and drop it in
1017:29 - visual studio code and this is going to
1017:30 - open it it is opened here we have our
1017:33 - main cpp file opened we can close the
1017:36 - left pane here because we don't want it
1017:38 - anymore and we can clean up our function
1017:40 - here and the first thing we're going to
1017:42 - do is to put in the syntax for a lambda
1017:45 - function here and use it as a reference
1017:48 - as we learn about this i think this is
1017:50 - going to make things a little easier so
1017:52 - the first thing we want to do is to
1017:54 - declare a lambda function and the first
1017:56 - thing we need to put in is a capture
1017:58 - list a capture list is going to be in
1018:00 - globe in this angle bracket so this is
1018:03 - our empty capture list and after this
1018:05 - we're going to put in a parameter list
1018:07 - which is going to leave inside this
1018:10 - parenthesis here after that we're going
1018:12 - to put in
1018:13 - an optional return type for now we're
1018:15 - going to ignore this and after that
1018:17 - we're going to put in our pair of curly
1018:20 - braces and inside this pair of curly
1018:22 - braces is where the body of our lambda
1018:26 - function is going to leave so inside
1018:28 - here we can do whatever we want in the
1018:30 - body of this lambda function for example
1018:32 - we can say hello world which is
1018:35 - the logical thing to do at this point so
1018:37 - we're going to say hello world here and
1018:39 - we're going to put in our new line
1018:41 - character with endl okay now we have a
1018:44 - lambda function declared but we have to
1018:47 - put in a closing semicolon because this
1018:50 - is a c plus plus statement okay now we
1018:52 - have our lambda function declared and
1018:55 - this is valid c plus plus code if we're
1018:58 - trying to compile this program you're
1018:59 - going to see that it is going to compile
1019:01 - fine cape world finished successfully
1019:04 - and if we try to run it it is not going
1019:06 - to do a thing because we are declaring
1019:09 - the lambda function here but we're not
1019:11 - calling it to get it to do things
1019:14 - so let's bring up a terminal and show
1019:16 - you that if we run this program it is
1019:18 - not going to do anything so let's do
1019:21 - clear and run rooster you're going to
1019:23 - see that it's not going to print
1019:24 - anything and we can even go down here
1019:27 - and put in a closing stdc out statement
1019:30 - saying it done to me that we are hitting
1019:33 - the end of the function here without
1019:35 - doing anything so if we vote again the
1019:38 - vote is going to be good we can clear
1019:40 - and we're going to run rooster you see
1019:42 - we are printing done we are hitting the
1019:44 - end of the function here and are we not
1019:46 - seeing hello world so this function here
1019:49 - or this lambda function here to be exact
1019:52 - is not being called one way we have to
1019:55 - call it is to give it a name
1019:57 - and we have seen that to give it a name
1019:59 - we have to assign the entire lambda
1020:02 - function thing we have here to a
1020:04 - variable and we're going to use auto
1020:06 - type deduction here so we're going to
1020:08 - say auto func and we're going to assign
1020:10 - our lambda function here to this
1020:14 - variable and this is going to be
1020:16 - basically a handle we have in our
1020:18 - program here to the lambda function and
1020:21 - we can use this handle to do things with
1020:24 - the lambda function but by now i want
1020:26 - you to see that even if we run the
1020:28 - program now it is not going to do
1020:31 - anything because we're still not calling
1020:33 - the lambda function here let's show you
1020:35 - that we're going to world again and the
1020:37 - world is going to be good no problem we
1020:39 - can clear and run rooster still not
1020:42 - hello world because we're not calling
1020:44 - our lambda function to call our lambda
1020:46 - function we have to use our handle here
1020:49 - which is this variable and use regular
1020:53 - function called syntax so we can go down
1020:55 - here and say func and we can put in our
1020:58 - parenthesis we're not putting in any
1021:00 - parameter because this lambda here
1021:02 - doesn't take any parameters and now if
1021:06 - we run this program it is going to say
1021:08 - hello world because this line here is
1021:10 - going to call this lambda function let's
1021:13 - bolt and see that
1021:15 - we're going to use gcc to build
1021:17 - so now if we clear and run rooster we're
1021:21 - going to see hello world we can call
1021:23 - this function multiple times because we
1021:25 - have a handle to it the handle is going
1021:27 - to be valid
1021:29 - throughout the scope of the main
1021:30 - function here so we're going to go down
1021:32 - and call it again and if we build we're
1021:35 - going to build with gcc the world is
1021:38 - good we can clear and run rooster we're
1021:40 - going to say hello world twice because
1021:43 - we are calling our lambda function twice
1021:46 - this is one way we have to call our
1021:48 - lambda function here
1021:50 - so we're going to comment this out
1021:52 - because we're going to see a few other
1021:54 - things and on top here what we were
1021:56 - doing is declaring around the function
1021:58 - and call it through an a now we're going
1022:01 - to go down set up a lambda function and
1022:03 - call it directly without giving it a
1022:06 - name because that's also a possibility
1022:08 - in c plus plus for that we're going to
1022:10 - grab our lambda function here and we're
1022:12 - going to copy it and we're going to say
1022:14 - declare a lambda function and call it
1022:16 - direct and the syntax to do that is
1022:18 - really simple
1022:20 - you set up your lambda function like we
1022:22 - have seen before you see this is our
1022:24 - lambda function statement here but
1022:26 - you're going to go to the closing curly
1022:28 - brace and add a pair
1022:31 - of parentheses this is going to declare
1022:33 - the lambda function and call it directly
1022:36 - notice that we don't have a handle to
1022:39 - this lambda function so if you do things
1022:41 - like this you will have only one chance
1022:44 - to call the lambda function so we're
1022:46 - going to say hello world once because we
1022:48 - are declaring the lambda function and
1022:50 - calling it directly here and after that
1022:53 - we're going to say done because we're
1022:55 - going to be hitting the end of the main
1022:57 - function here
1022:59 - let's build the program and show you
1023:00 - that we're going to build with gcc like
1023:03 - we always do we're going to clear
1023:05 - and run rooster this is going to say
1023:07 - hello world and we're going to be done
1023:09 - here because we are calling this lambda
1023:12 - function once again notice that now we
1023:15 - don't have a handle to this lambda
1023:17 - function so we really have one chance to
1023:19 - call this and you will do this if you
1023:22 - just want to set up some function that
1023:25 - you want to call directly and you don't
1023:27 - care about calling it ever again in your
1023:29 - c plus plus application and we're going
1023:32 - to see that we have many kinds of
1023:34 - problems where we want to do these kinds
1023:37 - of things
1023:38 - okay now that you have seen this the
1023:39 - next thing i want to show you is how to
1023:42 - set up a lambda function that takes
1023:44 - parameters and we're going to comment
1023:46 - out what we have on top here because we
1023:48 - don't want noise output on our terminal
1023:51 - and we're going to grab this lambda
1023:53 - function and adapt it
1023:56 - so let's copy it we're going to go down
1023:58 - here and put it in and we want to pass
1024:00 - two parameters now let's pass in double
1024:02 - parameters we're going to pass in double
1024:04 - a and double d you can do that
1024:07 - and inside the lambda function we can
1024:10 - print the sum of these two variables so
1024:13 - we're going to say a plus b for example
1024:16 - and we're going to print out whatever is
1024:18 - the result of a plus b let's do that and
1024:21 - after we do that you're going to see
1024:22 - that we get a compiler error because now
1024:26 - our lambda function is taking parameters
1024:29 - but we are calling that with an empty
1024:32 - list of parameters
1024:34 - so we need to give it something to sum
1024:36 - up let's give it 10.0 for example and a
1024:40 - 5.0 and see what we get and after this
1024:43 - we need to put in our semicolon because
1024:45 - this is a z plus plus statement and any
1024:48 - c plus plus statement needs to end with
1024:51 - a semicolon now try to think about what
1024:54 - we are doing here we are setting up a
1024:56 - lambda function okay it's going to end
1024:59 - at this closing
1025:00 - curly brace and this lambda function is
1025:03 - going to take two parameters of double
1025:05 - type
1025:06 - and inside the lambda function we are
1025:08 - going to print out whatever is the sum
1025:10 - of these two parameters that we are
1025:12 - taking in here
1025:14 - after that we are calling our lambda
1025:16 - function with two variables 10.0 and 5.0
1025:20 - or i should say two double literals
1025:24 - that's what we are calling our lambda
1025:25 - function with and now if the program
1025:28 - runs the lambda function is going to be
1025:30 - called once and we're going to print out
1025:32 - whatever is the sum of these two numbers
1025:35 - and that's going to be 15. let's build
1025:37 - so we're going to build with gcc
1025:40 - the world is good we can clear and run
1025:42 - rooster we're going to see a plus b is
1025:45 - 15. we are calling a lambda function
1025:47 - here if we put in a 50 here for example
1025:50 - we're going to get 60 printed out
1025:52 - because that's going to be our sum okay
1025:54 - let's boil it again and see that print
1025:56 - it down if we run rooster we're going to
1025:58 - see 60 because that's the sum of 10 and
1026:01 - 50 here
1026:02 - another thing we can do is actually
1026:05 - not call the lambda function directly
1026:07 - here we can actually comment this out i
1026:09 - don't want to take this out because you
1026:11 - might want to use this as a reference so
1026:13 - we're going to comment this out and set
1026:15 - up another example
1026:17 - that is going to name our lambda
1026:19 - function and then we will have a handle
1026:21 - to the lambda function and we can call
1026:23 - it multiple times
1026:25 - so let's take out the call we are doing
1026:28 - here and we're going to assign our
1026:30 - lambda function to a variable we're
1026:32 - going to say auto func one we can call
1026:34 - this func one no problem and now
1026:38 - we can call this lambda function
1026:39 - multiple times for example we can say
1026:42 - funk one and pass in 10 and 20 okay and
1026:46 - we can say funk one and pass in five
1026:50 - and seven why not
1026:52 - if we run this program it is going to
1026:54 - print the sum of 10 and 20 and it is
1026:56 - going to print the sum of five and seven
1026:59 - and it is going to be calling this
1027:01 - lambda function multiple times hopefully
1027:03 - you can see that if you want a chance to
1027:05 - call your lambda function multiple times
1027:08 - you will need to give it a handle like
1027:10 - we are doing here and then you can use
1027:12 - that handle
1027:14 - multiple times and call your lambda
1027:16 - function however many times you want so
1027:18 - let's build this program and see what we
1027:21 - get on the console
1027:23 - i'm going to clear and run rooster
1027:26 - now we're going to see a plus b it's 30
1027:28 - as a result of this call here and we're
1027:31 - going to see a plus b is 12
1027:34 - as a result of this call here notice
1027:36 - that we are passing an integer literals
1027:40 - so the compiler is going to insert an
1027:42 - implicit conversion from and to double
1027:45 - because our lambda function here is
1027:47 - taking double type you really need to be
1027:49 - aware of these implicit conversions and
1027:52 - make sure they are working to your
1027:54 - advantage if they are working against
1027:56 - you trying to find a way to make your
1027:58 - code work exactly like you want because
1028:01 - we are learning about all these cool
1028:03 - tricks in c plus plus you're going to be
1028:06 - using them at your advantage okay
1028:08 - hopefully now you know how you can set
1028:10 - up a lambda function that takes
1028:11 - parameters we're going to go down and
1028:14 - comment this out because now we want to
1028:16 - see how we can return something from a
1028:19 - lambda function and we're going to be
1028:20 - using the same lambda function here so
1028:22 - let's grab it and we're going to say
1028:24 - lambda function that returns something
1028:26 - and we're going to set up our lambda
1028:28 - function here let's put that in place
1028:31 - correctly
1028:32 - and instead of printing out the sum of a
1028:35 - and b
1028:36 - we can return that we can go in our
1028:39 - lambda function and say return
1028:41 - a plus b okay now that we have this we
1028:44 - can either call it directly by saying
1028:47 - for example 10 and 20 but now if we try
1028:51 - and run this code it is not going to do
1028:54 - anything try to guess why
1028:56 - this lambda function is not printing to
1028:59 - the concept directly it is just
1029:01 - returning whatever is the sum of 10 and
1029:04 - 20.
1029:04 - and if we return it we're not doing
1029:07 - anything with whatever is returned from
1029:09 - this lambda function so we're not going
1029:11 - to print anything and we're just going
1029:12 - to print done here
1029:14 - let's boil and make you see this because
1029:16 - you really need to be aware of these
1029:18 - little things
1029:19 - so the build is good we can clear and
1029:21 - run rooster we're going to see down our
1029:24 - lambda function is returning something
1029:26 - but we're not doing anything with the
1029:28 - return value
1029:30 - if we want to print the return value we
1029:32 - need to catch it somehow and we can put
1029:35 - that in a variable for example we can
1029:36 - say auto result and assign the return
1029:39 - value of our lambda function to this
1029:42 - variable now we have a chance to print
1029:44 - this for example by doing sddc out
1029:47 - result and we're going to
1029:49 - print that out and save result now if we
1029:53 - build this program it is going to print
1029:54 - whatever is the sum of 10 and 20. let's
1029:57 - do that and show you that this is
1029:58 - actually the case
1030:00 - so world is good so we can clear and run
1030:04 - rooster result is 30. if we pass in 10
1030:08 - and 50 for example we're going to get
1030:11 - the same thing let's pass in 60 here
1030:14 - so we're going to build with gcc the
1030:16 - build is good we can clear pretty quick
1030:18 - and run rooster now the sum is 70 and
1030:21 - this is how you can return stuff from
1030:23 - your lambda function and once you return
1030:26 - stuff you have to be sure you cut your
1030:28 - results and print them out another thing
1030:31 - you can do is print out the result
1030:33 - directly after you call your lambda
1030:36 - function so for example we can grab this
1030:38 - entire lambda function thing here and
1030:41 - put that in an sddc out statement so
1030:44 - we're going to put in a second one here
1030:46 - and say result or we can even comment
1030:48 - this out we don't want to be confused
1030:51 - when we look at the terminology we're
1030:53 - going to comment out the first sddc out
1030:56 - statement here and we're going to say
1030:59 - stdendl here and put in a placeholder
1031:02 - for our lambda function and we're going
1031:05 - to paste it in
1031:06 - if we do something like this again this
1031:08 - entire lambda function thing is going to
1031:11 - return the sum and that's what we're
1031:13 - going to print i realize this syntax is
1031:15 - really cryptic but it is going to work
1031:18 - let's try and build our program here the
1031:21 - world is good so we can clear and run
1031:23 - rooster we're going to see that result
1031:25 - is 70 and this is coming from our call
1031:29 - here which is nested inside our htdc out
1031:32 - statement you can do this if you want
1031:35 - another thing you can do as we have seen
1031:37 - before is give your lambda function a
1031:40 - name and call it repeatedly so for
1031:42 - example we can try and comment out what
1031:44 - we have here and set up another lambda
1031:47 - function because we
1031:48 - don't want to confuse you again so we're
1031:50 - going to grab our lambda function here
1031:53 - we're going to copy it because we don't
1031:55 - want to type this a thousand times
1031:57 - and we don't want to call this lambda
1031:59 - function directly instead we want to
1032:01 - give it a name and we're going to say
1032:03 - aro funk 2 and we're going to assign our
1032:07 - lambda function type to func one
1032:10 - now that we have this we can say auto
1032:12 - result 1 for example
1032:14 - and we can say func and we can pass in
1032:17 - whatever we want let's put in 23 and a
1032:19 - seven
1032:20 - and this is going to add up 23 and seven
1032:23 - we're going to grab the result and we're
1032:25 - going to assign that to result one
1032:27 - if we go down and say auto for example
1032:29 - result two and say for example funk one
1032:33 - and say
1032:34 - 9 and 45
1032:37 - why not and go down and print out these
1032:40 - result variables we're going to see the
1032:41 - sums printed out and again the message
1032:44 - is that we can use this handle to call
1032:47 - our lambda function multiple times so
1032:49 - let's go down and print this out we're
1032:51 - going to say
1032:52 - result one and we're going to say result
1032:54 - one here we're going to go down and say
1032:56 - result two and we're going to print that
1032:58 - out and we can even call this lambda
1033:00 - function directly and put that in sddc
1033:03 - out here so let's say that we're going
1033:05 - to say result to 3 for example or direct
1033:08 - call i think this is descriptive enough
1033:11 - so we're going to say func
1033:13 - one the name of our lambda function or
1033:15 - the handle to the lambda function and we
1033:18 - can put in a five and a two for example
1033:20 - and we're going to see this print out
1033:22 - the result if we build our program let's
1033:25 - do that with gcc the bolt is going to be
1033:29 - good we can clear and run rooster we're
1033:32 - going to have result 1 is 30 which is 23
1033:35 - and 7 so the sum is 30. the second one
1033:38 - should say 54 because that's the sum and
1033:42 - the third one should say 7 because
1033:44 - that's the sum of 5 and 2 and it is what
1033:47 - we have here and after that we're going
1033:49 - to see that our program is done this is
1033:51 - how you can set up a lambda function
1033:54 - that returns something and we have seen
1033:56 - many ways we can work with us let's
1033:58 - comment this out because there is one
1034:01 - more thing i want you to see and that's
1034:03 - along the function whose return type is
1034:06 - specified explicitly okay we are going
1034:08 - to reuse the same lambda function we
1034:11 - have been using all along and we're
1034:12 - going to copy that
1034:14 - and we're going to go down and put it
1034:16 - down here and now we want to specify the
1034:19 - return type as a double the way we do
1034:22 - that we go after our parameter list and
1034:25 - we put in a dash symbol and we put in a
1034:27 - greater than symbol and then we're going
1034:29 - to specify the return type of our lambda
1034:32 - function let's say that we want our
1034:34 - return type to be ant this is how we say
1034:37 - it now our function here is going to
1034:39 - return end regardless of the types that
1034:42 - we put in so what the compiler is going
1034:45 - to do when we call this lambda function
1034:47 - it is going to take the parameters it is
1034:48 - going to add them up for example now
1034:50 - they are double so it's going to add a
1034:52 - and b as double it's going to produce a
1034:54 - double variable then it is going to
1034:57 - convert that to end and return it you
1035:00 - notice that now we have forced our
1035:03 - lambda function to really return a
1035:06 - specific
1035:07 - type here
1035:08 - before the return type was deduced from
1035:11 - the operation that we did here and
1035:14 - before we were returning double because
1035:16 - that's what the compiler was deducing
1035:18 - for a and b here to really drive the
1035:21 - point home let's assign this lambda
1035:24 - function to func one or func three let's
1035:27 - do that we're going to say func three
1035:30 - and this is a lambda function that is
1035:32 - going to explicitly return and and we're
1035:35 - going to set up another one which is
1035:36 - going to deduce the return type we're
1035:38 - not going to specify
1035:40 - the return type explicitly so we're
1035:42 - going to take out our return type here
1035:45 - let's do that
1035:46 - and we're going to go down and say auto
1035:49 - result 3 and we're going to say funk 3
1035:53 - and add up two double variables let's
1035:56 - set up these variables explicitly so
1035:58 - that you really see what is happening so
1036:00 - we're going to say it a and put in
1036:03 - a 6.9
1036:05 - why not and let's make this guy a double
1036:08 - because that's what our function here
1036:10 - expects and we're going to do another
1036:12 - one do double b and we're going to put
1036:14 - in a 3.5
1036:17 - for example and we are going to use this
1036:20 - variables as arguments here we're going
1036:22 - to say a and b and we're going to say
1036:24 - auto result
1036:26 - for
1036:27 - this should be funk 4 sorry for this
1036:30 - and i'm going to say result 4 and this
1036:32 - should say result i am making many typos
1036:36 - so we're going to assign our lambda
1036:38 - function the result of our lambda
1036:41 - function i should say to result for here
1036:44 - and we're going to pass in
1036:46 - a and b
1036:47 - now we want to see the types of result 3
1036:50 - and result 4 here we're going to go down
1036:53 - and print them out we're going to say
1036:55 - sddc out size of this is one way we have
1036:59 - to get
1037:00 - the types of our variables
1037:03 - we're going to pass in result three
1037:05 - we're going to say size of result three
1037:07 - and we're going to go down and say size
1037:09 - of result for okay we have our code in
1037:13 - place and what we want to see
1037:15 - is the type that is deduced by the func
1037:18 - 3 lambda function here we are explicitly
1037:22 - turning the return type into end the
1037:25 - parameters we pass in are going to be
1037:26 - double that's what we have here we are
1037:29 - going to add up a and b and the result
1037:31 - of this is also going to be double but
1037:33 - the compiler is going to notice that we
1037:35 - are returning and explicitly here and it
1037:39 - is going to take this double result and
1037:41 - transform that to end and we're going to
1037:44 - get
1037:45 - and we're going to get the result of
1037:47 - that assigned to func 3 here for the
1037:49 - second lambda function here we are going
1037:52 - to automatically deduce the return type
1037:54 - so what we return here is going to be
1037:57 - a double type and we should see a size
1037:59 - of it for research 3 here printed out so
1038:02 - we should see a 4 on my system and for
1038:06 - the second statement here we should see
1038:08 - a size of double printed out this is one
1038:10 - way we have to try and prove this so
1038:13 - let's build this program and see what we
1038:15 - get okay the world is good we can clear
1038:17 - and run rooster and we're going to see
1038:20 - that this is exactly what we expect here
1038:23 - if we want we can even print result 3
1038:25 - and result 4 and see what we get so
1038:28 - let's do that we are learning so let's
1038:31 - experiment with this a little bit we're
1038:32 - going to say result 3 and we should go
1038:36 - back and say result three if i can type
1038:39 - e and dl here and we're going to go down
1038:42 - and say sddc out result for okay if we
1038:45 - build and run this
1038:47 - we're going to see the results printed
1038:49 - down the both is good we can clear and
1038:52 - run rooster
1038:53 - now we have result is 10 for the
1038:57 - first thing here for the
1038:59 - first lambda function and for the second
1039:02 - one result is 10.4 you can see that for
1039:05 - the first one the result was transformed
1039:08 - from double to and and for the second
1039:11 - one we deduced double so we still have
1039:13 - our decimal point here hopefully this
1039:16 - makes sense and this is really all we
1039:18 - set out to do in this lecture showing
1039:20 - you different ways you can set up your
1039:22 - lambda functions we saw the syntax of
1039:25 - setting up a lambda function we saw that
1039:27 - you can declare a lambda function and
1039:29 - call it through a name like func here we
1039:32 - went down and so that you can declare a
1039:34 - lambda function and call it directly
1039:36 - through the syntax you see here we saw
1039:38 - that how we could specify parameters to
1039:40 - our lambda function this is the syntax
1039:42 - and once you do this you have to
1039:44 - remember to call your lambda functions
1039:46 - with parameters like we see here we can
1039:48 - even use a handle given to our lambda
1039:52 - function and call our lambda function
1039:54 - multiple times after that we saw that we
1039:57 - could return something from a lambda
1039:59 - function and we had many chances to play
1040:01 - with us
1040:02 - and we
1040:03 - finished by looking how we could specify
1040:06 - the return type explicitly and the
1040:09 - syntax to do that is what you see here
1040:12 - we are going to stop here in this
1040:13 - lecture the next one we're going to see
1040:15 - how we can use our capture lists here
1040:18 - and make them do useful things
1040:21 - go ahead and finish up here
1040:23 - and meet me there
1040:25 - in this lecture we're going to see how
1040:26 - we can use capture lists in our lambda
1040:30 - functions and do some useful things we
1040:32 - have seen that the syntax of our lambda
1040:35 - functions includes these angle brackets
1040:38 - here but we haven't really used them to
1040:40 - do anything for what we have done in the
1040:43 - last lecture they were empty all the
1040:45 - time in this lecture we're going to use
1040:48 - them here is a simple example of how we
1040:50 - can use our capsule list
1040:52 - we have two variables a and b they are
1040:55 - of double type and they contain these
1040:57 - values 10 and 20. but sometimes we want
1041:00 - to use thanks outside the scope of the
1041:02 - lambda function
1041:04 - inside the lambda function here and if
1041:06 - you set up your lambda function with an
1041:08 - empty capture list suppose you don't
1041:10 - have these two guys in
1041:12 - and you try to use a and b like this
1041:14 - you're going to get a compiler error
1041:16 - because
1041:17 - the body of the lambda function doesn't
1041:20 - have access to the outer context here it
1041:24 - can only use things inside the lambda
1041:27 - functions or events that you pass to the
1041:29 - lambda function here but it can't
1041:32 - directly access things outside the
1041:34 - lambda functions and we can have access
1041:37 - to thanks that are declared and defined
1041:40 - outside the lambda function through our
1041:42 - capture list if you look here we are
1041:44 - saying a and b and this is the syntax we
1041:47 - have to capture
1041:49 - these two variables a and b and have
1041:52 - access to them inside our lambda
1041:55 - function here and this is what capture
1041:57 - lists are really for giving you access
1042:00 - to things that are declared outside the
1042:03 - scope of the lambda function because if
1042:05 - you really think about it this lambda
1042:08 - function thing we have here is really a
1042:11 - type
1042:12 - so it is its own thing
1042:14 - that has these behaviors well then so
1042:16 - that we can call it and do things but it
1042:19 - doesn't really have direct access to the
1042:21 - outside
1042:23 - where it was declared and you have to
1042:25 - give it access through the capture
1042:27 - mechanism here okay now that you know
1042:29 - this we're going to see different ways
1042:31 - we can use the capture mechanism one
1042:33 - thing we can do is capture by value and
1042:36 - if we capture by value what we're going
1042:38 - to have inside the lambda function is
1042:40 - going to be a copy suppose we have a
1042:42 - variable here which is c the value is
1042:44 - going to be 42 as you see here we're
1042:47 - going to set up a lambda function and
1042:49 - capture our c variable
1042:51 - by value in this lambda function here
1042:54 - and what we're going to do outside the
1042:56 - lambda function notice the lambda
1042:58 - function has a handle so we can call it
1043:00 - we're going to loop five times
1043:02 - and at each iteration we're going to
1043:04 - call our lambda function and print the
1043:07 - inner value here
1043:08 - but after that we're going to increment
1043:10 - our c variable and this is going to
1043:12 - increment the
1043:14 - outer variable here and what we want to
1043:16 - see is that the changes we are doing on
1043:19 - the outside here are picked up by the
1043:21 - inner value that we have in our lambda
1043:23 - function here and ahead to break it to
1043:26 - you this is going to not be the case
1043:28 - because what we have inside the lambda
1043:30 - function is a copy of the outside
1043:33 - variable here so what we're going to
1043:35 - have is for the outer value to go from
1043:38 - 42 all the way to 47 we're going to go
1043:40 - five times incrementing this little guy
1043:42 - but the thing on the inside is not going
1043:45 - to change because it is a copy the
1043:47 - incrementation here is affecting the
1043:50 - outside variable here but it is not
1043:52 - affecting the copy we have inside our
1043:55 - lambda function so for all these loops
1043:57 - here we're going to see 42 print it down
1044:00 - and we're going to see this in a minute
1044:02 - when we hit visual studio code let's say
1044:04 - 42 correctly
1044:06 - excuse my typing here okay so now you
1044:08 - know that we can capture by a value and
1044:10 - you know what this really means another
1044:12 - thing we can do is capture by reference
1044:15 - and the syntax to do that is to add an
1044:18 - ampersand symbol in front of the
1044:20 - variable that we capture here and if we
1044:22 - do this and run the semicolon we run in
1044:25 - the last lecture we're going to see now
1044:27 - that the changes we do on the outside
1044:30 - are going to be picked up by the inner
1044:32 - side of our lambda function because we
1044:35 - are capturing by reference what we have
1044:38 - inside our lambda function here is a
1044:41 - true reference to the outside the
1044:43 - variable here and we're going to see
1044:45 - that now the outside and the inside are
1044:48 - going to be incrementing together and
1044:50 - we're going to have 43 42 44 and things
1044:53 - like that printed out on the console
1044:55 - okay this is really all i have to share
1044:57 - with you in this lecture showing you how
1044:59 - you can use your capture lists and that
1045:02 - you can capture either by value or by
1045:04 - reference we're going to head over to
1045:06 - visual studio code and play with this a
1045:08 - little more okay here we are in our
1045:11 - working folder the current project is
1045:13 - capture lists we're going to grab our
1045:16 - template files pretty quick and we're
1045:18 - going to put them in place we're going
1045:19 - to
1045:20 - put them in the current project and
1045:23 - we're going to open this guy in visual
1045:25 - studio code by dragging and dropping in
1045:27 - place here and we're going to open our
1045:29 - main cpp file clean it up a little bit
1045:33 - and close the left pane here what we
1045:35 - want to do in here is uh learn a little
1045:38 - more about capture lists and we're going
1045:40 - to put in a piece of code to play with
1045:42 - just that we have two variables a and 10
1045:46 - here and we have our lambda function
1045:49 - setup and let's take out our capture
1045:51 - list so that you can see the compiler
1045:53 - error we see
1045:54 - if we try to use them as is here so we
1045:57 - have our two variables and we have a
1045:59 - lambda function set up here and inside
1046:02 - the lambda function notice that we are
1046:05 - trying to access the variables that have
1046:08 - been declared on the outside of the
1046:10 - lambda function here and by default if
1046:12 - we try to do this we're going to get a
1046:14 - compiler error because these two
1046:16 - variables don't exist in the scope of
1046:19 - the lambda function here let's bring up
1046:21 - a terminal and see what visual studio
1046:23 - code is saying about this
1046:25 - and it is going to say an enclosing
1046:27 - function local variable cannot be
1046:30 - referenced in
1046:31 - lambda body unless it is in the capture
1046:35 - list and you see that this is really
1046:36 - descriptive okay we have sent this error
1046:39 - but we want to see what the compiler
1046:41 - says about this we're going to pass this
1046:43 - through gcc and we should get a similar
1046:46 - error it is going to say a is not
1046:49 - captured and it is going to go down here
1046:52 - and say b is not captured here and this
1046:55 - is the error we are trying to use
1046:57 - outside variables in our lambda function
1047:00 - but to really do that we need to capture
1047:02 - a and b
1047:03 - and the syntax to capture our variables
1047:06 - is to put them inside our angle brackets
1047:09 - here with a comma separate to the list
1047:12 - of the variables that we want to capture
1047:14 - so we're going to say a comma b because
1047:16 - that's what we want to capture here and
1047:19 - the moment we do that
1047:20 - visual studio code should be happy it is
1047:22 - not happy i think we need to compile
1047:24 - this for it to be happy so let's do that
1047:27 - and you see now
1047:29 - our variables are being captured and we
1047:32 - are summing them up and we are printing
1047:35 - the result of adding them up here by
1047:38 - calling the function through a handle we
1047:41 - have set up here hopefully this is
1047:43 - really making sense let's build the
1047:45 - program again
1047:46 - so let's use the gcc
1047:49 - you're going to see that the world is
1047:50 - good we can clear and run rooster we
1047:53 - should see a plus b is 30 but the values
1047:57 - are getting inside the lambda function
1048:01 - through our capture list they are not
1048:03 - going through the parameter list here
1048:06 - this is really something you need to be
1048:08 - aware of
1048:09 - now that you know how capture lists work
1048:12 - let's see that you can capture either by
1048:15 - value or by reference and we're going to
1048:17 - see what that means exactly i am going
1048:20 - to go down here and put in a piece of
1048:22 - code to play with capturing by value
1048:24 - okay let's do that we have a variable
1048:27 - called c the value is 42
1048:30 - and we set up a lambda function which is
1048:32 - going to capture c
1048:34 - with this syntax here and this is the
1048:36 - default syntax we saw
1048:38 - like we did on top here so we are going
1048:40 - to be capturing like this and if we do
1048:43 - this we're going to be capturing by
1048:44 - value the meaning of that is that what
1048:46 - we have inside our lambda function is
1048:49 - not going to be the original value here
1048:51 - it is going to be a copy of what we have
1048:54 - there
1048:55 - what we can do here is use this thing in
1048:57 - a loop and really prove this
1049:00 - so we're going to loop five times from
1049:02 - zero all the way to four because this is
1049:05 - going to go until i is no longer less
1049:08 - than 5
1049:09 - and inside we're going to print the
1049:11 - outer value which is going to be
1049:13 - the c here after that we're going to
1049:15 - call our lambda function which is going
1049:17 - to predict the inner value in the lambda
1049:18 - function and we're going to see that the
1049:21 - incrementation we do on the outside
1049:23 - which is going to affect the outer value
1049:26 - here is going to be visible inside the
1049:28 - lambda function here and that's not
1049:30 - going to be the case the change we do
1049:32 - here is not going to be picked up by the
1049:34 - lambda function here because what we
1049:36 - have inside is a copy so what we're
1049:39 - going to see is for the outer value to
1049:41 - go from 42 43 43 45 and it is going to
1049:46 - go until we hit the end of this loop
1049:48 - here but the inside value is not going
1049:51 - to change because the change we do in
1049:53 - here is not going to affect the copy
1049:56 - that we have in our lambda function here
1049:59 - hopefully this makes sense and again if
1050:01 - you have a problem please make sure you
1050:03 - ask
1050:04 - through the
1050:05 - course platform and i will do the best i
1050:07 - can to help you out for now we're going
1050:10 - to build and run this program you see
1050:12 - the world is good so let's clear and run
1050:15 - rooster you're going to see outer value
1050:17 - is 43 outer value is 43 outer value is
1050:21 - 44 outer value is 45 the outer value is
1050:25 - changing but the inner value is staying
1050:28 - at 42
1050:30 - as you see here
1050:32 - hopefully this proves that the outer
1050:34 - value and the inner value are two
1050:36 - different things but we can even go
1050:39 - further and print the addresses of the
1050:41 - outer value and the inner value let's do
1050:43 - that
1050:44 - we're going to add that to our statement
1050:47 - here and say the address of this guy
1050:50 - so we're going to say address of outer
1050:53 - value or say address of inner value we
1050:55 - can say it like that
1050:57 - to really be descriptive in our terminal
1051:00 - here so we're going to say the address
1051:02 - of c
1051:03 - and on the outer value we're going to
1051:05 - add another piece of information and say
1051:08 - address of outer value and we're going
1051:10 - to say the address of c
1051:13 - and this is going to pick up the outer
1051:15 - value that we have here and this is
1051:17 - going to use the inner value we have in
1051:20 - our lambda function here
1051:22 - let's try and work and hopefully these
1051:24 - two addresses the inner and outer
1051:27 - addresses are going to be different
1051:29 - that's what we want to see here and
1051:31 - really proving that what we have inside
1051:34 - the lambda function is a copy through
1051:37 - the capture mechanism so let's run the
1051:40 - program the world was good so the outer
1051:42 - value the address is the e4 the inner
1051:45 - value the address is de0 we are proving
1051:48 - that what we have inside our lambda
1051:50 - function is really a copy so this is how
1051:54 - you can capture by value and that's
1051:56 - going to make a copy but sometimes you
1051:58 - really want to capture by reference and
1052:00 - we're going to see how you can do that
1052:02 - so we're going to comment out the code
1052:05 - to capture by value here we're going to
1052:07 - grab the code and reuse it because
1052:09 - that's going to be very similar to what
1052:11 - we had before we're going to say capture
1052:14 - by reference we're going to put in our
1052:16 - code and we're going to change it a tiny
1052:18 - bit what we're going to do is add an
1052:21 - ampersand symbol
1052:22 - in front of our variable here that we
1052:25 - are capturing and we're going to say
1052:27 - ampersand
1052:29 - the moment we do this what we have
1052:31 - inside the lambda function is no longer
1052:34 - a copy it's going to be a true reference
1052:37 - to the outer value here and now the
1052:40 - changes we do to our outer value are
1052:43 - going to be visible inside the lambda
1052:45 - function here and you're going to see
1052:47 - the addresses to be the same
1052:49 - let's build and really see this we're
1052:51 - going to use gcc to build our program
1052:54 - the world is good we can clear now and
1052:57 - run rooster and we're going to see that
1052:59 - the outer value let's make sure we have
1053:02 - some spaces after these guys and let's
1053:05 - go up and do that and both again because
1053:08 - things are really cramped together and i
1053:10 - don't like this
1053:11 - so the boost is good we can clear and
1053:13 - run rooster
1053:14 - so we're going to see the outer value
1053:16 - and the inner value are changing
1053:18 - together and the addresses are now the
1053:21 - same
1053:22 - because we have captured by reference
1053:25 - the inner value and the outer value are
1053:27 - referencing the same variable we have
1053:30 - outside here this is really all we set
1053:32 - out to do in this lecture i hope you
1053:34 - found it interesting the main idea was
1053:37 - the capture mechanism we have with our
1053:39 - lambda functions to capture thanks
1053:42 - outside the context of lambda functions
1053:45 - we can capture by specifying a comma
1053:47 - separate to the list of the variables
1053:50 - that we want to capture and we have the
1053:52 - option to either capture by value by
1053:54 - using
1053:55 - the variable directly in the capture
1053:57 - list like we do here or by prepending an
1054:01 - ampersand symbol here and capture by
1054:03 - reference and you are going to have to
1054:05 - choose whichever way you want to capture
1054:07 - your variables now that you know about
1054:10 - all these options here
1054:12 - we are going to stop here in this
1054:13 - lecture in the next one we're going to
1054:15 - see how we can capture everything from
1054:18 - the outside context to the lambda
1054:20 - function
1054:21 - go ahead and finish up here
1054:23 - and meet me there in the last lecture we
1054:25 - saw that we could capture things outside
1054:28 - the context of the lambda function now
1054:31 - we want to see that we can capture
1054:32 - everything living outside the context of
1054:36 - the lambda function the syntax to do
1054:38 - that is ridiculously simple if you want
1054:41 - to capture everything by value you just
1054:44 - put an equal sign in your lambda
1054:46 - function capture list and if you do
1054:48 - something like this now you're going to
1054:50 - have access to everything outside the
1054:53 - scope of the lambda function for example
1054:55 - we can access the c variable here from
1054:57 - the lambda function but if we have any
1055:00 - more variables declared outside the
1055:02 - scope of the lambda function we will
1055:05 - have access to them inside our lambda
1055:08 - function here again this is enabled by
1055:11 - the syntax that we use here by putting
1055:14 - an equal sign inside a lambda function
1055:17 - notice that if you use the equal sign
1055:19 - like we do here we're going to be
1055:21 - capturing by value what we have inside
1055:23 - the lambda function is going to be a
1055:25 - copy if you don't want to capture all by
1055:28 - value you can capture all by reference
1055:31 - and again the syntax is really simple
1055:34 - all you have to do is put an ampersand
1055:37 - symbol inside your capture list the
1055:39 - moment you do this you're going to have
1055:41 - access to everything outside the context
1055:44 - of your lambda function but that's going
1055:47 - to be by reference what you have inside
1055:49 - the lambda function are going to be true
1055:51 - references to the outside variables and
1055:55 - you can do pretty nasty things with them
1055:58 - because the changes you do inside the
1056:00 - lambda function are going to be visible
1056:02 - outside the lambda function and any
1056:05 - change you do from the outside is also
1056:07 - going to be visible inside the lambda
1056:09 - function so if you do this make sure
1056:12 - this is what you want and you can use
1056:14 - this to your advantage okay now that you
1056:16 - know this we're going to head over to
1056:18 - visual studio code and play with us a
1056:20 - little more okay here we are in our
1056:22 - working folder the current project is
1056:25 - capture all lists we're going to
1056:28 - grab our template files pretty quick and
1056:31 - we're going to put them in place and
1056:33 - we're going to open this little guy in
1056:35 - visual studio code let's do that we are
1056:37 - going to have our folder open we can
1056:40 - open our main cpp file clean it up like
1056:43 - we always do and we're going to close
1056:46 - the left pane here the first thing we
1056:48 - want to do is to capture everything by
1056:50 - value and we're going to put in the code
1056:51 - to do that which should be very easy to
1056:54 - understand by now and again the syntax
1056:56 - to capture everything by value is by
1056:59 - putting an equal sign within your
1057:02 - capture list you have to put that within
1057:05 - these angle brackets and that's going to
1057:07 - capture everything by value now now if
1057:09 - we run the program we're going to see
1057:11 - that c has been captured by value if we
1057:14 - look around we're going to see that the
1057:15 - outer value is going to
1057:17 - change but the inner value is going to
1057:20 - stay the same this is the same behavior
1057:22 - we have seen before by capturing by
1057:24 - value so let's build again we're going
1057:26 - to build with gcc the world is good we
1057:29 - can clear and uh bring up a terminal so
1057:31 - that we can clear properly so let's do
1057:34 - clear and run rooster now we see that
1057:37 - the outer value is changing but the
1057:39 - inner value is not changing and again
1057:42 - this is classic capturing by value if
1057:46 - you want to capture all by reference
1057:48 - you're going to use the ampersand symbol
1057:50 - here and let's do that we're going to
1057:52 - comment this out and we're going to take
1057:55 - this out and uh
1057:57 - use the code here we can do that we're
1058:00 - going to go down and put in a code and
1058:02 - say that we are capturing by reference
1058:05 - we should say capturing all by reference
1058:08 - and all we have to do to make that work
1058:11 - by reference is to put our ampersand
1058:14 - symbol within this angle brackets here
1058:17 - and this is going to capture everything
1058:19 - by reference if we run now we're going
1058:21 - to see that the changes we do from the
1058:23 - outside are going to be visible from the
1058:25 - inside here
1058:26 - let's weld with gcc and see that this is
1058:29 - actually the case the bolt is good as
1058:32 - you see here we can clear and run the
1058:35 - rooster we're going to see that the
1058:36 - outer value is 42 the outer value is
1058:40 - changing and the inner value is changing
1058:42 - as you see in our output here and this
1058:46 - is really how you can capture
1058:48 - by reference just to play with this
1058:51 - we're going to set up another variable
1058:52 - call it d and we're going to say it
1058:55 - contains a 5 and we can try to print
1058:58 - that inside our inner value here and it
1059:00 - is going to work you're going to see
1059:02 - that it has been captured we can say
1059:04 - sddc out inner value let's say that it
1059:07 - is the d variable we are trying to
1059:09 - access here and we're going to say d and
1059:12 - it is going to be visible inside our
1059:14 - lambda function here because it was
1059:16 - captured by reference here let's build
1059:19 - again we're going to use gcc to do that
1059:22 - the bolt is good we can clear and if we
1059:24 - run booster we should see d printed out
1059:27 - multiple times d
1059:29 - d
1059:30 - d
1059:30 - d and we are able to access it through
1059:34 - the capture mechanism and we are
1059:36 - capturing everything in the context by
1059:39 - reference here this is really all we set
1059:41 - out to do in this lecture i hope you
1059:43 - found it interesting i hate to say it
1059:45 - but this happens to be the last lecture
1059:48 - in this chapter on lambda functions we
1059:50 - still have a lot to learn about lambda
1059:53 - functions but unfortunately we don't
1059:55 - really have enough tools to understand
1059:57 - that now but for now we're going to stop
1059:59 - here and learn a little more things
1060:01 - about c plus plus then we're going to
1060:03 - come back and see some crazy things you
1060:05 - can really do with lambda functions i
1060:08 - would like to welcome you in this new
1060:10 - chapter where we're going to be learning
1060:12 - about function templates function
1060:14 - templates are a mechanism we have in c
1060:18 - plus to set up blueprint for functions
1060:21 - and have one point of control to set up
1060:24 - the function but the compiler is going
1060:26 - to generate the actual function that
1060:28 - gets called when it sees the function
1060:31 - call so this is going to solve the
1060:33 - problem we had before with function
1060:35 - overloads if you look at the code here
1060:37 - we have multiple overloads for the
1060:39 - maximum function but what we really are
1060:42 - doing in the body of these functions
1060:45 - is the same and suppose you have
1060:48 - 12 or 13 or 20 overloads of the same
1060:51 - function you're going to be basically
1060:53 - repeating the same logic in the bodies
1060:56 - of this function and this code
1060:58 - repetition is bad function templates are
1061:00 - an effort to
1061:02 - solve problems like this the way they
1061:05 - work you set up a blueprint for your
1061:06 - function and this is the syntax to do
1061:09 - something like that you say template
1061:12 - type name t here don't worry about this
1061:14 - syntax we're going to have a chance to
1061:16 - go through it in detail but if you do
1061:19 - things like this this is going to be a
1061:21 - blueprint for your maximum function and
1061:24 - the compiler is going to use this
1061:26 - blueprint to generate an actual function
1061:30 - when you call this function and this is
1061:31 - going to make things super easy i
1061:34 - realized some of this is really cryptic
1061:36 - so let's head over to the next lecture
1061:39 - and let you set up your very first
1061:41 - function template go ahead and finish up
1061:44 - here and meet me there in this lecture
1061:46 - we're going to set up our very first
1061:49 - function template and again function
1061:51 - templates are a mechanism we have in c
1061:54 - plus plus to avoid code repetition for
1061:57 - example if you are setting up function
1062:00 - overloads if you look here we have our
1062:02 - max function and we have multiple
1062:05 - overloads for this function we can call
1062:07 - it with and double and string view here
1062:10 - but if you look inside you see that we
1062:12 - really are repeating the same logic
1062:15 - and it is even possible to have dozens
1062:18 - of overloads if you want to support tons
1062:21 - of types for your function
1062:23 - and this code repetition is really bad
1062:27 - function templates are a mechanism we
1062:29 - have in place to avoid things like this
1062:32 - and what you do
1062:33 - you set up a function blueprint using
1062:36 - the syntax you see here and your
1062:38 - function template is going to be
1062:40 - prefixed
1062:41 - with this template type name teeth and
1062:44 - here type name t is going to be in this
1062:46 - angle brackets
1062:48 - and then you're going to put the
1062:50 - blueprint for your function t is a
1062:53 - placeholder for the types that you use
1062:55 - in your function you see that t is in
1062:58 - the return type here it's in the
1063:01 - parameters that we pass to the function
1063:03 - and because it is the same character
1063:05 - here all these things have to be of the
1063:07 - same type the return type the first
1063:09 - parameter the second parameter they have
1063:11 - to be of the same type okay so once you
1063:14 - have your function template set up like
1063:16 - this you're going to implement it like
1063:17 - we see down below here it is nothing
1063:20 - complicated we just set up the prototype
1063:23 - for the function on top
1063:25 - and inside we put our implementation you
1063:27 - see here we have separated this into
1063:30 - function declaration and function
1063:32 - definition but inside you see that it is
1063:34 - the same logic we had to compute our
1063:37 - maximum between these two parameters
1063:39 - that we pass to this function
1063:42 - so how does this work when the compiler
1063:45 - sees you call this max function for
1063:48 - example as we are doing here it's going
1063:51 - to look at the types that you pass in
1063:54 - and in this case a and b
1063:56 - are of ant type so it is going to
1063:59 - replace the t in here for and and it is
1064:03 - going to generate a function initial
1064:05 - code
1064:06 - and this really brings up a big point
1064:08 - about function templates many people
1064:10 - think that function templates are actual
1064:13 - c plus plus code they're not they're
1064:16 - just a blueprint from which the compiler
1064:18 - is going to generate the actual function
1064:21 - that is called by the compiler for
1064:23 - example when you issue a call like this
1064:26 - again
1064:27 - function templates are not real c plus
1064:29 - plus code they are just a blueprint that
1064:32 - the compiler uses to generate your
1064:35 - function
1064:36 - based on the arguments you pass to the
1064:38 - function when you call it so when we
1064:40 - issue the call like we do here an int
1064:43 - version of our maximum function is going
1064:45 - to be created so the compiler is
1064:47 - basically going to go in and replace n
1064:50 - and for t here the return type is going
1064:52 - to be nt the first parameter is going to
1064:54 - be end the second parameter is going to
1064:56 - be empty it's going to go in the
1064:57 - definition it's going to do that and
1064:59 - we're going to have an it function
1065:01 - if we issue a call with c and d like we
1065:04 - do here in the second line here then the
1065:06 - compiler is going to see that c and d
1065:09 - are of double type so it is going to
1065:11 - generate another function from this
1065:13 - blueprint here and it is going to
1065:14 - replace in double then we're going to
1065:17 - have another double function if we go to
1065:19 - the third line here we're going to do
1065:21 - the same we're going to call it with
1065:22 - strengths and it is going to generate a
1065:24 - stringed version of the maximum function
1065:27 - here so what we achieve with function
1065:30 - templates is to avoid
1065:33 - several overloads for the same function
1065:35 - and we have one point of control in our
1065:37 - code but the compiler is still going to
1065:40 - generate this function overloads but one
1065:43 - thing about this is that if a function
1065:45 - is not used for example if you never
1065:47 - call a maximum function with string
1065:50 - then the string version is never going
1065:52 - to be created the compiler is going to
1065:54 - generate the overloads that you only
1065:57 - call in your c plus plus program and
1065:59 - this is really all function templates
1066:01 - are all about they give you a mechanism
1066:04 - to set up a blueprint for your function
1066:06 - and then the compiler is going to
1066:07 - generate actual functions based on what
1066:11 - you call in your c plus plus code okay
1066:13 - we have saved this but i want to
1066:14 - emphasize this again
1066:16 - function templates are just blueprints
1066:19 - they're not real c plus plus could and
1066:22 - when we hit visual studio code in a
1066:24 - minute we're going to see a tool
1066:26 - that allows us to see how the compiler
1066:29 - instantiates your function templates
1066:32 - based on the arguments you call your
1066:35 - function with but keep this in mind
1066:37 - function templates are not real c plus
1066:40 - plus code the rio c plus plus functions
1066:43 - get generated by the compiler
1066:45 - when you call your function and another
1066:47 - thing i wanted to point out is that
1066:50 - once a function template instance is
1066:53 - generated for example the interversion
1066:55 - of our maximum function template then if
1066:59 - it is needed again the compiler is not
1067:01 - going to generate that again it's going
1067:03 - to see if there is one generator already
1067:05 - and it is going to reuse that okay this
1067:07 - is really all i have to share about
1067:09 - function templates at this point in this
1067:11 - chapter for now we're going to head over
1067:14 - to visual studio code and play with this
1067:15 - a little more okay here we are in our
1067:18 - working directory the current project is
1067:21 - trying out function templates we're
1067:23 - going to grab our template project and
1067:25 - one thing i should point out here is
1067:27 - that our template project has been now
1067:30 - updated to have the launch.json file
1067:34 - which is going to allow us to debug our
1067:36 - programs so you should use a template
1067:38 - that includes the launch.json file here
1067:41 - that's going to allow us to debug your
1067:43 - programs and we're going to do that in a
1067:45 - minute when we have set up the example
1067:47 - here so we're going to grab our template
1067:49 - files and put them in place and we're
1067:52 - going to open this little guy in visual
1067:54 - studio code by dragging and dropping on
1067:57 - top here this is going to do our job
1068:00 - then we're going to open up the main cpp
1068:02 - file and i think we should close the
1068:04 - left pane here we don't need it anymore
1068:06 - and we're going to clean this up a
1068:07 - little bit so one thing i want to do is
1068:10 - to first do things the bad way so we're
1068:12 - going to set up a max function
1068:14 - let's call this maximum
1068:16 - and it's going to take end parameters
1068:18 - and we're going to return the maximum
1068:21 - between a and b and the way we do that
1068:23 - we say a greater than b we are going to
1068:26 - use our ternary operator here we're
1068:28 - going to put a question mark we're going
1068:29 - to return a or b and this is going to be
1068:32 - our function but suppose we need another
1068:34 - function that works on doubles if we put
1068:38 - double arguments in here the compiler is
1068:40 - going to insert implicit conversions
1068:42 - from double to end this may seem to work
1068:45 - but suppose you use a parameter type
1068:48 - that is not convertible to end for
1068:50 - example you use a string or something
1068:52 - let's put in std string
1068:54 - here just for an example so we're going
1068:57 - to say maximum std strength
1069:01 - a and std strength b
1069:04 - and we should make these const
1069:06 - references because we're not interested
1069:08 - in modifying these strings here
1069:11 - let's finish the name here
1069:13 - and we're going to say const std string
1069:16 - reference a this is much better it's
1069:18 - going to avoid unnecessary copies of
1069:20 - strings and we're going to say const htd
1069:23 - string reference
1069:25 - be here then inside we're not going to
1069:27 - do anything different we're just going
1069:29 - to use the same logic okay let's do that
1069:32 - suppose you have another function
1069:35 - which takes what should i say long long
1069:38 - end if we need that we need to copy this
1069:41 - function and put that in okay we need to
1069:44 - do that and we're going to change this
1069:46 - to long long end and we're going to do
1069:48 - the same here
1069:50 - long long and our parameter and we're
1069:53 - going to say the same here and you see
1069:55 - we are setting up a lot of functions
1069:58 - with basically the same thing inside and
1070:00 - that this is a lot of code copies
1070:03 - suppose we have this function maybe 20
1070:06 - times it is possible or even worse the
1070:09 - logic in this function is really long
1070:12 - maybe 20 or 30 lines and we will have to
1070:15 - repeat this thing in aku so the
1070:17 - designers of the c plus plus language
1070:19 - saw this problem and they said why don't
1070:22 - we set up a one point of control
1070:25 - where we can set up our logic to do the
1070:27 - maximum and we let the compiler generate
1070:31 - actual
1070:32 - functions based on the arguments we call
1070:35 - our functions with and they came up with
1070:39 - function templates and that's what we're
1070:41 - going to see so we're going to take out
1070:42 - all the other functions and we're going
1070:44 - to turn this maximum and function into a
1070:47 - function template the syntax to do that
1070:50 - is ridiculously easy
1070:52 - so we're going to say template this is
1070:54 - what you say you put an angle bracket
1070:56 - and you say type name and you specify
1070:58 - the placeholder for the type in this
1071:01 - angle brackets here this is the syntax
1071:03 - you have to use
1071:04 - then you have to specify your function
1071:07 - in terms of this placeholder t it is
1071:10 - going to take the place of the type so
1071:12 - for example here we want to return and
1071:15 - we're going to change this to t and the
1071:17 - parameters are going to be taken by
1071:19 - value t and t
1071:21 - let's do that
1071:23 - and now we have a legal c plus plus
1071:26 - function template it is going to take
1071:28 - this template here and use it to
1071:30 - generate actual c plus plus functions so
1071:34 - for example if we go in the main
1071:36 - function here and say ent result
1071:39 - equals max maximum we should say and say
1071:42 - x and y for example let's create these
1071:45 - variables on top here so we're going to
1071:47 - say ent x and we're going to put in a
1071:49 - five and we're going to create a y and
1071:52 - put in a seven why not now this function
1071:55 - is going to store the result and print
1071:57 - it out
1071:58 - let's do that so that we can see that
1072:00 - this actually works so we're going to
1072:02 - say result and say results this is going
1072:05 - to do and if we build and run this
1072:08 - program we're going to use gcc you're
1072:10 - going to see that the world is going to
1072:11 - be good
1072:13 - and uh world finished successfully we
1072:15 - can run this program like we always do
1072:18 - let's bring up a terminal and clear a
1072:20 - little bit and run rooster you're going
1072:23 - to see that we're going to see that
1072:24 - result now is 7 because that's the
1072:27 - maximum you see it is working here so
1072:29 - how is this mechanism working here the
1072:33 - compiler is basically looking in the
1072:34 - main function here and it is noticing
1072:37 - the call and it is going to look around
1072:39 - and see if it can find a declaration for
1072:43 - the maximum function here it's not going
1072:44 - to find it because there is none then
1072:47 - it's going to look at the function
1072:49 - templates it has in here and it's going
1072:51 - to see that it can do a replacement and
1072:54 - replacing the types that we are passing
1072:56 - in here so it is going to do that it is
1072:58 - going to take this template and it is
1073:00 - going to replace
1073:02 - t by end and then it is going to
1073:05 - generate a function that basically looks
1073:08 - like what we have here we're going to
1073:10 - copy this and we're going to put this in
1073:13 - the compiler is going to take the first
1073:14 - t here it's going to turn that into a
1073:16 - net it's going to take the second one
1073:18 - here it's going to turn that into an end
1073:20 - it's going to take the third one here
1073:23 - and turn that into an it and we're going
1073:25 - to have a function definition for the
1073:28 - call here this is what the compiler is
1073:30 - going to do
1073:31 - one thing some of you might be thinking
1073:33 - is there a way to really prove this and
1073:36 - somebody was nice enough to design a
1073:38 - tool
1073:39 - to let us see
1073:41 - this function or template instances
1073:44 - generated by the compiler and i happen
1073:46 - to have that opened it is a web-based
1073:49 - tool so you can use this in your browser
1073:51 - just go to
1073:53 - cppinsights.io
1073:55 - and then we're going to grab the code we
1073:57 - had in our main cpp file we're going to
1074:01 - copy it all and we're going to go back
1074:04 - to our browser and remove whatever i had
1074:07 - in here because i don't want this
1074:09 - anymore and i'm going to put in my
1074:11 - function template if we want we can even
1074:13 - take this sddc out statement because we
1074:16 - don't want all the junk that comes with
1074:18 - that we are just interested in looking
1074:21 - at the template instances
1074:24 - generated by the compiler now that we
1074:26 - have the code in here we're going to see
1074:29 - what the compiler generates because of
1074:31 - the call we have here i think i could
1074:33 - increase the size of the font here so
1074:35 - that you guys
1074:36 - can see this i think this is a little
1074:38 - better
1074:39 - then if you hit this play button here
1074:42 - let's click on it it's going to do its
1074:44 - processing and then the code generated
1074:47 - by the compiler is going to show up to
1074:48 - the right here you see it has detected
1074:51 - that we have
1074:52 - called the function template on line 13
1074:55 - here you see this line is highlighted
1074:58 - and then if you go to the right we're
1074:59 - going to see the functions generated by
1075:02 - the compiler so if you go here you see
1075:04 - that we have an interversion
1075:06 - of our function template and another
1075:09 - thing i should prove here is that
1075:12 - template instances that are not needed
1075:14 - are not going to be generated by the
1075:16 - compiler another way to say this the
1075:18 - compiler is only going to generate the
1075:21 - template instances it needs and again a
1075:24 - template instance is what you have here
1075:27 - the function the actual function that is
1075:29 - callable by the compiler generated from
1075:32 - your blueprint so if for example we
1075:34 - change the type of our
1075:37 - parameters to double let's do that okay
1075:39 - so we changed our types to double we're
1075:42 - going to hit the play button again
1075:44 - you're going to see that now it is going
1075:46 - to generate a double function here you
1075:48 - see that here if we change this for
1075:51 - example to
1075:52 - what can we use let's use long long end
1075:55 - like we did in our lecture we can do
1075:58 - that we can say long long and and if we
1076:02 - hit the play button that's what is going
1076:04 - to be generated by the compiler so
1076:07 - hopefully this proves that the compiler
1076:10 - is only going to generate the instances
1076:13 - that are needed for the calls you do in
1076:16 - your c plus plus program and this is
1076:18 - really function templates are all about
1076:21 - okay now that you know this let's set up
1076:22 - a few more examples to see that this
1076:25 - really works
1076:26 - so let's change the types of these guys
1076:28 - to
1076:29 - double let's do that and we're going to
1076:32 - play with this a little more in visual
1076:33 - studio code and let's use double
1076:37 - liters 5.5 and 7 or
1076:41 - 78.7 here let's do that 78.7 and we're
1076:46 - going to build this and one thing i
1076:48 - should point out is that template
1076:50 - instances are generated when the
1076:52 - compiler is doing its job and then they
1076:55 - are going to be put
1076:56 - in the binary representation of your
1076:59 - source code so the world is good as you
1077:02 - see here we can clear and run a rooster
1077:05 - we're going to see that the result is 78
1077:08 - and it is transformed to end because we
1077:11 - are assigning to end here to really get
1077:13 - to the correct results here we should
1077:15 - use auto type deduction if we do that
1077:18 - the compiler is going to deduce the type
1077:20 - of result here based on the return type
1077:22 - of this function or the function
1077:24 - template instance i should say
1077:27 - now we're going to change this to auto
1077:29 - to do auto type deduction
1077:31 - and if we both again we should see a
1077:33 - double printed out correctly the both is
1077:36 - good we can clear and run the rooster
1077:38 - now we have the correct value printed
1077:41 - out from our function template here
1077:44 - let's change this to std string we can
1077:47 - do that so let's include
1077:49 - a
1077:50 - the string library
1077:52 - and we're going to change these two guys
1077:53 - to std string why not std string x is
1077:57 - going to be a string electro let's use
1078:01 - hello for example and uh for
1078:04 - y we're going to say std strength and
1078:07 - we're going to put in a world here okay
1078:10 - this is going to do and you notice that
1078:12 - we don't even have a compiler error
1078:14 - visual studio code is not complaining
1078:16 - the compiler is going to look at the
1078:18 - types we call our function with then it
1078:21 - is going to generate is an sdd string
1078:23 - version of this function and what it is
1078:26 - going to do it's going to replace in t
1078:28 - and replace that for std strand we can
1078:31 - actually put this thing entirely in
1078:35 - cpp inside so let's copy this code
1078:37 - before we run it so that you can really
1078:39 - see what is happening here we're going
1078:41 - to take out whatever we had before we're
1078:43 - going to put in our code and then we're
1078:45 - going to hit the play button here it's
1078:46 - going to generate our thumb we wait for
1078:48 - it to do its thing and if you look here
1078:51 - you see that it has generated
1078:54 - std strength this is really a compiler
1078:56 - representation of std string we don't
1079:00 - have enough tools to really understand
1079:02 - this but hopefully you can see that it
1079:04 - has replaced t
1079:06 - with some other type we don't know yet
1079:09 - std basic string car it has a few things
1079:12 - inside that we don't really know yet we
1079:14 - will have to learn a few more things
1079:17 - about this as we progress in the course
1079:19 - but for now
1079:21 - i want to prove to you that the compiler
1079:23 - is doing the replacement you see t was
1079:25 - replaced by this thing here std basic
1079:28 - strength and we have angle brackets and
1079:30 - this entire thing is really hdd strength
1079:34 - in the eyes of the compiler okay now
1079:36 - that we know this let's go back to
1079:37 - visual studio code and run this we're
1079:40 - going to build with gcc as we always do
1079:43 - the world is good we can clear and run
1079:45 - rooster
1079:46 - going to see that the maximum is world
1079:49 - and this is going to be using the
1079:51 - greater than operator
1079:53 - and this is going to compare two
1079:55 - strengths based on this and we know that
1079:57 - w here comes after h
1080:00 - in lexicographical order so the
1080:03 - comparison that is done here is
1080:04 - lexicographical
1080:06 - for this strength here or i should say
1080:08 - it is comparing things in alphabetical
1080:11 - order in abcde and things like that okay
1080:14 - now hopefully you have a big idea about
1080:17 - function templates they are just
1080:18 - blueprints you use
1080:20 - to generate actual functions and this is
1080:23 - going to allow you to avoid multiple
1080:26 - function overloads as we have seen
1080:28 - before
1080:28 - one thing i want you to see
1080:30 - is that you have to be sure that the
1080:33 - logic you do inside your function is
1080:36 - supported by the types that you pass to
1080:38 - the function and i'm going to show you
1080:40 - what i mean here we're going to set up
1080:42 - another function template we're going to
1080:43 - say template type named we're going to
1080:46 - set up another one pedem and we're going
1080:48 - to use t here you can use
1080:50 - this however many times you want and
1080:52 - then we're going to set up the function
1080:54 - which is going to do a multiplication so
1080:57 - we're going to say t that's going to be
1080:59 - the return value and we're going to say
1081:01 - multiply and we're going to multiply two
1081:03 - parameters we're going to say t a and t
1081:05 - b okay and we're going to put in the
1081:08 - logic and we're going to just return a
1081:11 - multiplied by b this is our
1081:12 - multiplication operator in c plus plus
1081:16 - and we can use this function so for
1081:18 - example we can say we can comment this
1081:21 - out and we can set up two variables
1081:23 - we're going to say and x and we're going
1081:25 - to put in whatever we had before let's
1081:27 - put in five
1081:28 - and end to y we're going to say 7 i
1081:31 - think this is what we used before you
1081:33 - can really put in whatever you want and
1081:35 - now we're going to call the multiply
1081:37 - function template so what this is going
1081:39 - to do is to generate a function template
1081:41 - instance which is going to be of type
1081:44 - and it's going to do a replacement in
1081:46 - here and replace t with ant and then
1081:49 - we're going to multiply two end
1081:51 - parameters that are passed to this
1081:52 - function and we're going to return end
1081:55 - and if we do that we're going to get 35
1081:57 - printed out let's prove this we're going
1081:59 - to use gcc to bolt the bolt is good we
1082:02 - can clear and run rooster we get a 35 if
1082:05 - we change this to double it is going to
1082:07 - work so let's change this to double and
1082:10 - maybe put in five point one and
1082:13 - 7.0 why not and then we're going to see
1082:16 - what we get we're going to build with
1082:18 - gcc the build is good we can clear run
1082:21 - rooster we get
1082:23 - 35.7 this is what we expect
1082:26 - but watch what happens if we try
1082:29 - to use the std string types okay i want
1082:33 - you to see that so we're going to enable
1082:35 - our std strength variables here
1082:38 - and if we try to bolt we're going to get
1082:41 - a compiler error but i want you to try
1082:43 - and guess why why do we have this
1082:45 - compiler if we look at what gcc is
1082:48 - saying here
1082:49 - it is saying an instantiation of our
1082:52 - function template required from here and
1082:56 - no match for operator
1082:58 - multiplication here and this is the
1083:01 - problem
1083:02 - the compiler is going to do what it
1083:04 - knows to do it is going to do a
1083:06 - replacement in our function template and
1083:09 - it is going to replace t
1083:11 - by std strength because that's the type
1083:13 - we are using as an argument here the
1083:16 - problem is we can't really multiply two
1083:19 - strands if you try to multiply two
1083:21 - strands like we do here it's not going
1083:23 - to make sense what do you expect to get
1083:26 - if you multiply two strings it doesn't
1083:28 - make sense the compiler doesn't know
1083:30 - what to do with this operation it's
1083:32 - going to give you a compiler error okay
1083:34 - to really drive this home let's go back
1083:36 - to cpp insights
1083:39 - and put in the code here and see what is
1083:41 - generated by the compiler
1083:43 - you should use these tools to your
1083:45 - advantage because they really help in
1083:48 - understanding what is going on so let's
1083:50 - hit the play button here i just put in
1083:52 - my code and it is going to say
1083:54 - compilation failed because we have the
1083:57 - same error cpp insights needs to compile
1084:00 - the code correctly
1084:01 - to give you the template instantiations
1084:05 - but here you see that it is basically
1084:07 - giving us the same error let's try and
1084:10 - see the entire thing here and see if we
1084:12 - see the real error and we can't really
1084:15 - scroll around with this i'm having
1084:17 - trouble scrolling around here i can use
1084:20 - these buttons i guess okay so let's see
1084:22 - if we see the actual error and we're not
1084:25 - seeing it here auto result multiply
1084:28 - error generated so we're going to get an
1084:30 - error if we try to instantiate our
1084:32 - template with the types that we are
1084:34 - passing in here which are hdd strength
1084:37 - cpp insights isn't really helpful here
1084:40 - but hopefully you understand the problem
1084:42 - the problem is if the compiler tries to
1084:45 - generate a template instance using std
1084:49 - strand multiplying two strands isn't
1084:51 - going to make sense so the compiler is
1084:53 - going to give you a compiler error
1084:55 - because this is not supported so the
1084:57 - message here is that you should make
1085:00 - sure that the template instances
1085:02 - generated by the compilers support
1085:04 - whatever operations you are doing in the
1085:08 - body of your function template this is
1085:10 - the message here
1085:11 - another thing i want you to see before
1085:13 - we close this off i'm going to take out
1085:15 - this
1085:16 - problematic line here and we're going to
1085:18 - go back to our maximum function what i
1085:21 - want you to see is that if you pass
1085:23 - different types for this function
1085:25 - template you're going to get a compiler
1085:27 - error and what do i mean by that let's
1085:30 - take out our std strength because it's
1085:32 - no longer useful for our purposes here
1085:35 - and we're going to just use double and 8
1085:38 - parameters let's use ant here
1085:42 - and we
1085:43 - make this an intellectual
1085:46 - and then we call our maximum function
1085:48 - you see that we have a squiggly line
1085:50 - because the function template is forced
1085:52 - to use the same type for the return type
1085:56 - the first parameter and the second
1085:57 - parameter here because the placeholder
1086:00 - is the same so the compiler is supposed
1086:02 - to use the same thing for the first
1086:04 - argument here the second argument and
1086:07 - the return type that we get from this
1086:09 - maximum function here but the problem is
1086:11 - we are passing in parameters of
1086:13 - different types and this is going to
1086:15 - give us a compiler error because the
1086:17 - compiler want to know what to do with
1086:20 - the types that you pass in as arguments
1086:23 - and if we look at our problems tab here
1086:26 - visual studio code should give us an
1086:29 - error no match for operator uh this is
1086:31 - the error we had before we can try and
1086:33 - build again we're going to get a
1086:35 - compiler error again but this time it's
1086:38 - going to be different it's going to say
1086:39 - no instance of function template maximum
1086:43 - matches the argument list that we are
1086:45 - using here which is double and end
1086:48 - so
1086:48 - this is a problem but we will see ways
1086:51 - around this as we progress in the
1086:52 - chapter but what you should know
1086:55 - is that if we set up a function template
1086:57 - like this this is going to enforce for
1087:00 - all the types where we will place in t
1087:03 - to be the same if they're not the same
1087:05 - the compiler won't know how to do its
1087:07 - replacement and it is going to give you
1087:09 - a compiler error okay the last thing i
1087:11 - want you to see is that we can use the
1087:14 - debugger to debug function templates so
1087:17 - let's turn this back to end because we
1087:19 - wanted this to compile
1087:21 - so let's take out the decimal point here
1087:24 - so that we have proper intellectuals and
1087:27 - if we compile again this should compile
1087:30 - okay the world is good now what really
1087:32 - happens if you try to debug a program
1087:36 - with
1087:36 - function templates
1087:38 - are you going to be working on the
1087:40 - template instances because remember the
1087:43 - function templates are going to generate
1087:46 - function template instances with actual
1087:48 - types for example our template instance
1087:50 - here is going to have ants because we
1087:53 - are passing ant as argument here so how
1087:56 - are we exactly going to debug this let's
1087:59 - try this we're going to set up a break
1088:02 - point here
1088:03 - on the call to our maximum function
1088:06 - and we're going to start debugging we're
1088:08 - going to go to our
1088:10 - run tab here
1088:11 - and we're going to use the debugging
1088:13 - tools that come with gcc we have seen
1088:16 - how to do that in the last chapter and
1088:18 - we're going to start debugging let's
1088:20 - minimize this guy here so that we have
1088:23 - some breathing room
1088:25 - and we're going to run our debugger
1088:28 - let's maximize this a little bit
1088:30 - and push this a little to the left
1088:33 - and we're going to start debugging and
1088:35 - see what really happens here so we hit
1088:37 - the green button here we're going to
1088:39 - start debugging our code is building now
1088:41 - the build is done
1088:43 - the binary has been passed to the
1088:45 - debugger and now we have hit our break
1088:48 - point here so let's minimize this a
1088:50 - little bit so that we have an easier way
1088:53 - to see this we have hit or break point
1088:55 - you see the locals are what we have in
1088:57 - the main function which happens to be to
1088:59 - the top of the call stack here
1089:01 - okay now we want to jump into the
1089:03 - maximum function and see the types that
1089:05 - we have inside
1089:07 - so what we want to do here is head the
1089:09 - step into function and you notice it is
1089:12 - going to jump into our function template
1089:14 - here but the locals here are not giving
1089:17 - us the types and this is because this is
1089:20 - a function template it's not going to
1089:22 - give you the types
1089:24 - because it's not easy to get those here
1089:27 - but if we look at the call stack you see
1089:30 - that we have information about the types
1089:32 - of the function that is being called we
1089:34 - are calling it a and it b
1089:36 - and it is going to return and you see
1089:38 - that in the angle brackets here and
1089:40 - again this is possibly another way to
1089:42 - look at what template instances were
1089:45 - generated by the compiler because we see
1089:47 - the function called here is taken into
1089:49 - parameters and it is going to return end
1089:52 - let's kill our debugger because this is
1089:54 - really all we want to see and change the
1089:57 - types to double here and we're going to
1089:59 - see that the function to the top of the
1090:01 - call stack is going to be
1090:03 - taking double parameters so let's change
1090:06 - this back to five point something 5.5
1090:09 - maybe 7 and 0.9 why not and we're going
1090:13 - to print our results here
1090:15 - but uh what we really are interested in
1090:17 - is seeing the function template instance
1090:21 - generated by the compiler because of
1090:23 - this call here and we can do this
1090:25 - through the debugger this is a little
1090:27 - bit convoluted because you have to set
1090:29 - up breakpoints and whatever but it is
1090:31 - helpful if you don't want to use things
1090:33 - like cpp insights as we have seen before
1090:36 - and again this is also useful because
1090:38 - you will need to debug your code if it
1090:40 - is using function templates let's run
1090:42 - this to really prove our point here
1090:45 - the world is going to go through the
1090:47 - binary executable is going to be passed
1090:49 - into
1090:50 - the debugger and we're going to hit our
1090:52 - breakpoint here again you see our locals
1090:55 - are not giving us the types here but we
1090:57 - cannot use
1090:59 - the function call stack to really see
1091:01 - this we have hit the breakpoint here at
1091:03 - line 15 so we can step into the call
1091:06 - and if we hit the body of the maximum
1091:09 - function here and look at the call stack
1091:12 - we're going to see that the parameters
1091:15 - we have in our function call are of
1091:18 - double type and again this hopefully
1091:21 - proves to us
1091:22 - that the compiler has actually generated
1091:25 - a double
1091:26 - function template instance okay since we
1091:29 - are debugging we can actually try and
1091:31 - follow this program let's hit next so
1091:35 - that we can hit the end of this function
1091:37 - we can
1091:38 - finish it and hit the main function by
1091:40 - the moment we hit the main function
1091:43 - results is going to be 7.9 which is what
1091:46 - we have here and it is what we're going
1091:47 - to print we can just step over this
1091:49 - because we don't want to step into the
1091:51 - logics of sddc out so step over we're
1091:54 - going to print our result and our
1091:56 - debugging session is going to basically
1091:58 - end because we have hit the end of the
1092:01 - main function let's try and use the
1092:03 - compiler from microsoft to see the
1092:06 - information it gives us because these
1092:08 - things can be different depending on the
1092:10 - compiler and the debugging tools that
1092:12 - you are using we have the luxury to have
1092:15 - these two set up here so all we have to
1092:17 - do is switch the tool we want to use
1092:19 - here and this is going to be using the
1092:22 - one from microsoft if you are not on
1092:24 - windows or you don't want to use the
1092:27 - compiler from microsoft and its
1092:30 - debugging tools you can just use gcc and
1092:33 - its debugging tools here i just want you
1092:35 - to see different ways to do the same
1092:37 - things and that compilers and debuggers
1092:39 - can give us different information we're
1092:42 - going to try and debug with this so
1092:44 - we're going to hit the green button here
1092:46 - notice that this is going to be using
1092:47 - the compiler from microsoft if we look
1092:50 - at the world output here you see that we
1092:53 - are calling cl.exe
1092:55 - it is what we are using to build our
1092:57 - binary the binary is going to be passed
1093:00 - to the debugger and then we're going to
1093:02 - hit the breakpoint here as we know
1093:05 - and then we're going to have our output
1093:07 - here these are our locals
1093:10 - you see in the main function we don't
1093:12 - see the types of our locals why is that
1093:15 - i don't know why but we see the values
1093:17 - here in the main function
1093:19 - and if we hit the step into button to
1093:23 - jump into our maximum function a is
1093:25 - going to have this value b is going to
1093:27 - have this value and we look at the
1093:30 - template instance we can see the same
1093:32 - information but we are using a different
1093:34 - compiler this is really how you can
1093:37 - debug your code that uses function
1093:40 - templates and this is going to give us a
1093:42 - peek into the actual template instance
1093:46 - that was generated by our compiler this
1093:49 - is really all i had to share in this
1093:51 - lecture and before i let you go let's
1093:53 - summarize a little bit function
1093:55 - templates are blueprints we have seen
1093:57 - that the compiler is going to use those
1093:59 - to generate actual function template
1094:01 - instances real function definitions and
1094:04 - uh
1094:05 - declarations are going to be created
1094:07 - when you call the function with
1094:08 - arguments if the template parameters are
1094:11 - of the same type maybe t and t then the
1094:14 - arguments you call the function with
1094:16 - must also match otherwise you'll get a
1094:18 - compiler error we have seen this okay
1094:20 - here we have a point we haven't already
1094:22 - covered template instances won't always
1094:25 - do what you want a good example is when
1094:27 - you call our maximum function with
1094:29 - pointers so let's go back and really say
1094:31 - this
1094:32 - because i want this to cover as much as
1094:34 - possible about function templates
1094:37 - so let's go back to our code and we're
1094:39 - going to modify things a little bit okay
1094:41 - so what we're going to do here is take
1094:42 - out whatever we have here we're going to
1094:44 - set up into variables x and y
1094:47 - x is going to be 5 as we have seen
1094:49 - before and
1094:51 - y is going to be seven let's use this
1094:54 - and then we're going to set up two
1094:55 - pointer variables we're going to say
1094:57 - endpointer
1094:58 - px and we're going to initialize this
1095:00 - with the address of x nothing
1095:02 - sophisticated so far and we're going to
1095:04 - say end p y and we're going to
1095:06 - initialize this with the address of y we
1095:09 - can do this the problem is going to come
1095:11 - when we try to call our function here
1095:14 - with the
1095:15 - pointers let's use px and py to call
1095:18 - this function and py and what this is
1095:21 - going to do is to generate a template
1095:24 - instance that takes end pointer this is
1095:26 - what the compiler knows to do we're
1095:28 - going to take the types that we pass in
1095:30 - here which happen to be end pointer and
1095:32 - we're going to change the return type to
1095:34 - end pointer we're going to change the
1095:36 - first parameter to end pointer the
1095:37 - second parameter to end pointer and
1095:39 - we're going to compute the maximum
1095:41 - if we compute the maximum here we're
1095:43 - going to be comparing pointers okay
1095:46 - notice this and if we try to do that we
1095:48 - might not get what we want because what
1095:51 - we get now depends on the address used
1095:55 - to store these guys in memory hopefully
1095:57 - you can see that and let's try and debug
1096:00 - this program so that you can really see
1096:02 - this we're going to use the tools from g
1096:06 - plus plus or gcc
1096:09 - and we're going to try and debug it
1096:10 - let's do that it is going to run through
1096:13 - the debugger and what we're going to
1096:15 - have is our terminal here i think this
1096:18 - is not needed anymore so let's put this
1096:20 - to the right here and minimize a little
1096:23 - bit and now you notice that px contains
1096:27 - an address and py contains an address
1096:30 - hopefully you can see that in the body
1096:32 - of our template instance we're going to
1096:34 - be comparing these addresses because
1096:36 - we're comparing what we pass by value
1096:38 - here and what we pass are these two
1096:40 - addresses so whichever is the maximum in
1096:43 - these guys and i think that's going to
1096:46 - be dd4 here it is the maximum so
1096:49 - whatever is contained in px is going to
1096:52 - be considered the maximum let's kill
1096:55 - this because we have seen this
1096:56 - information so if we have a value in px
1096:59 - and that happens to be at a bigger
1097:01 - address it's going to be considered the
1097:03 - maximum let's see what we print if we
1097:05 - run this program we're going to build
1097:07 - with gcc let's do that the world is good
1097:10 - we can clear
1097:12 - and run rooster now you see result is
1097:15 - some address because we are returning a
1097:17 - pointer and printing that out but we can
1097:20 - easily dereference this and get to the
1097:22 - value inside this pointer let's build
1097:25 - again we can clear and run rooster this
1097:28 - is going to give us result is 5 and
1097:30 - hopefully you can see that this is
1097:32 - really bad and not correct we are trying
1097:35 - to compute the maximum between x and y
1097:38 - and we are seeing that the maximum is
1097:41 - five so how can five beat the maximum
1097:44 - between five and seven the problem is
1097:46 - we're not comparing the values here we
1097:49 - are comparing the addresses stored in
1097:52 - these pointers because that's what we
1097:54 - are passing here hopefully you can
1097:55 - really see this and we can prove this
1097:57 - again through our debugger we can run
1098:00 - this through the debugger we're going to
1098:03 - hit the breakpoint let's minimize this
1098:05 - so that we can see our terminal window
1098:07 - here and we're going to move this around
1098:09 - a little bit and now we have hit our
1098:11 - break point if we hit next to jump into
1098:14 - the function you see that what we are
1098:16 - really comparing are a and b here and a
1098:20 - contains a much larger address so it is
1098:22 - the pointer that is going to be returned
1098:25 - and if we dereference that we're going
1098:27 - to be dereferencing the pointer that
1098:29 - contains this x value and the message
1098:32 - here is that you should be careful
1098:35 - that your function templates are really
1098:37 - what doing what you want somebody might
1098:39 - do this if they are not careful just
1098:41 - pass in pointer and expect to get the
1098:43 - maximum but the compiler is just going
1098:46 - to compare pointer addresses and you're
1098:49 - going to get something you probably
1098:50 - don't expect okay this is what is meant
1098:53 - by template instances won't always do
1098:55 - what you want a good example is when you
1098:57 - call a maximum function with pointers
1098:59 - you're going to get a wrong value
1099:01 - possibly there are tools like cpp
1099:04 - insights which can show the template in
1099:05 - spatial instruments we have seen that
1099:07 - and again the arguments passed to a
1099:10 - function template must support the
1099:12 - operations that you are doing in your
1099:14 - function template we have seen an
1099:16 - example of this by setting up a
1099:18 - multiplication function template and we
1099:20 - saw that we had a compiler error if we
1099:22 - try to pass std strength arguments
1099:25 - because we can't multiply two strings
1099:27 - this is really all i had to share in
1099:30 - this lecture i apologize it turned out
1099:32 - to be lengthy but i really had to put
1099:35 - this in one lecture so that i can really
1099:37 - show you different sides of the same
1099:39 - things we are going to stop here in this
1099:42 - lecture and the next one we're going to
1099:43 - learn about template type deduction and
1099:46 - explicit arguments
1099:49 - go ahead and finish up here
1099:50 - and meet me there
1099:52 - in this lecture we're going to learn
1099:53 - about template type deduction and
1099:56 - explicit arguments what we mean by
1099:59 - template type deduction is the mechanism
1100:02 - the compiler uses
1100:04 - to deduce the type it would use to
1100:08 - set up our template instance from the
1100:10 - arguments that we passed to our function
1100:12 - call here
1100:14 - for example the compiler is going to
1100:15 - look at a and b here in a call to the
1100:18 - maximum function and it is going to
1100:20 - notice that they are of into type and
1100:22 - then it is going to say okay you are
1100:24 - calling your function with it types and
1100:27 - i see that your function templates takes
1100:30 - three replacers in here so i am going to
1100:33 - replace these guys with and and it is
1100:36 - going to guess that from the call that
1100:38 - you make here there's no other mechanism
1100:40 - to help the compiler out this is really
1100:42 - what template type deduction is about
1100:45 - and for the first example here we are
1100:47 - passing an end parameter so
1100:50 - nt is going to be deduced for the second
1100:52 - function call we are passing in double
1100:55 - parameter so a double function template
1100:57 - instance is going to be generated for
1100:59 - the third call here we are using std
1101:02 - string parameters
1101:04 - so we are going to deduce a template
1101:07 - instance that uses hdd string here this
1101:10 - is what we mean by template type
1101:12 - deduction but we have seen that
1101:14 - automatic template type deduction can
1101:17 - really have problems especially if you
1101:19 - pass parameters of different types for
1101:22 - example if we call a maximum function
1101:24 - here with
1101:26 - a and c which happen to be end and
1101:29 - double type then we're going to have a
1101:31 - problem because this function template
1101:33 - can't handle
1101:34 - parameters with different types because
1101:37 - the replacer is the same the compiler is
1101:40 - going to enforce that all the template
1101:42 - arguments are of the same type and the
1101:45 - template arguments are going to be what
1101:47 - you pass in here so a and b must be the
1101:49 - same if they happen to be not the same
1101:51 - for example ant and double you're going
1101:53 - to get a compiler error
1101:55 - now we're going to see that we can use
1101:57 - explicit template arguments and again i
1102:00 - want to make it very clear the
1102:02 - difference between a template parameter
1102:05 - and the template argument a template
1102:07 - parameter is what you have in your
1102:09 - function declaration or a definition so
1102:12 - what we have in our function setup here
1102:15 - are template
1102:16 - parameters ta here and tb are template
1102:20 - parameters but what we have when we call
1102:22 - a function template is going to be
1102:25 - template arguments for example c and d
1102:28 - here
1102:29 - are template arguments and we're going
1102:31 - to be using this terminology in this
1102:34 - chapter and many more chapters to come
1102:36 - in this course make sure this is super
1102:38 - clear so what we're going to look at is
1102:40 - using explicit template arguments and
1102:44 - what this means
1102:46 - is a mechanism through which you can
1102:48 - force the compiler to use some type to
1102:51 - generate your template instance and the
1102:53 - syntax to do this is really simple it is
1102:56 - what we have here we say maximum and we
1102:58 - put the type we want
1103:00 - to use to generate our template instance
1103:03 - in angle brackets like we see here so
1103:05 - this is going to use double so this is
1103:07 - going to explicitly tell the compiler we
1103:10 - want the double version called and it's
1103:12 - going to generate that and that's what
1103:14 - is going to be called by this call we
1103:16 - have here a good benefit with this is
1103:18 - that now this is going to support
1103:21 - template arguments of different types so
1103:24 - if we make the call like this the
1103:25 - compiler is going to see that uh-huh we
1103:27 - are calling with intent double types
1103:30 - because a is ant and c is double
1103:33 - but it's going to see that you want
1103:36 - the
1103:36 - double template instance generated now
1103:39 - the compiler will have the possibility
1103:42 - to do implicit conversions from other
1103:45 - types to double and if this implicit
1103:47 - conversion fails then we're going to get
1103:50 - a compiler error so if you look here for
1103:52 - example
1103:53 - this is the example for that we are
1103:54 - passing in a and e and a is ant and e is
1103:59 - an std strength we cannot do an implicit
1104:02 - conversion from
1104:03 - std strength to double so this is going
1104:06 - to give us a compiler error and this is
1104:08 - really all template type deduction and
1104:11 - explicit arguments are about we can use
1104:14 - these things to really make our code
1104:15 - easier now that you have this understood
1104:18 - we're going to head over to visual
1104:20 - studio code and play with this a little
1104:21 - more here we are in our working
1104:24 - directory the current project is
1104:26 - template type deductions and explicit
1104:29 - arguments we're going to grab our
1104:31 - template files pretty quick and put them
1104:33 - in place and after that we're going to
1104:36 - open this in visual studio code let's
1104:38 - drag and drop on top of visual studio
1104:40 - code here this is going to open our
1104:42 - folder and we can open our main cpp file
1104:46 - and
1104:47 - set up our function template let's clean
1104:49 - this up a little bit and we're going to
1104:51 - set up our function template let's type
1104:54 - this out to just to practice so we're
1104:56 - going to say template and we're going to
1104:58 - say type name and we're going to say t
1105:01 - and if you want you can put this on a
1105:02 - single line but i prefer to put this on
1105:05 - separate lines but let's show you that
1105:08 - so we're going to say t here and we're
1105:10 - going to say maximum and we're going to
1105:12 - say the parameters they are going to be
1105:14 - of type t and we can pass them by value
1105:17 - just for now and after this we're going
1105:19 - to go in the body of our function
1105:21 - template and then we can return
1105:23 - whichever parameter is the maximum we're
1105:26 - going to say a greater than b here we're
1105:28 - going to use our ternary operator and if
1105:31 - a is greater we're going to return a if
1105:34 - b is greater we're going to return b and
1105:36 - this is our function here okay now that
1105:38 - this function is set up let's set up a
1105:40 - few variables to really play with that
1105:42 - so we're going to include the string
1105:44 - library because we're going to be using
1105:46 - it a little bit and we're going to go
1105:49 - down in the main function and put in our
1105:52 - few variables we have a through f here a
1105:56 - and b are end c and d are of type double
1106:00 - and e and f are of type std strand the
1106:04 - first thing we can do we can say auto
1106:06 - max and we can assign whichever is the
1106:09 - maximum between a and b and once we do
1106:11 - this we're going to have that maximum
1106:13 - stored in max here but what i want you
1106:16 - to see is what the compiler does when it
1106:19 - sees the code like this the compiler has
1106:22 - no other outside help
1106:25 - to know the function template instance
1106:28 - it should really generate it is going to
1106:30 - look at the types we have here a and b
1106:33 - it's going to see that they are of type
1106:34 - and it's going to see that it can use
1106:38 - the function template we have here and
1106:40 - it's going to use that and generate a
1106:41 - template instance that it's going to
1106:43 - take and and it is going to call it to
1106:45 - get our maximum here again we can prove
1106:48 - this through the debugger we're going to
1106:50 - set up a breakpoint we're going to go to
1106:51 - our run tab here and we're going to run
1106:55 - this through our debugger
1106:57 - we're going to build our thing and when
1106:59 - we hit the main function you're going to
1107:01 - see that a is 10 b is 23 which is what
1107:05 - we have here cd we have our values n and
1107:08 - std string because it is a compound type
1107:11 - or a custom type we can expand on this
1107:13 - and really see more information about
1107:15 - this but we don't have enough tools to
1107:17 - really understand this by now so we're
1107:19 - going to just to use this as a wrapper
1107:22 - on our stream information here now we
1107:25 - want to call the maximum function and
1107:27 - see what was generated by the compiler
1107:30 - and we can step into this function
1107:32 - because we have hit the breakpoint by
1107:34 - now
1107:34 - so if we hit step into we're going to
1107:37 - step into this function and we're going
1107:39 - to see that it is an int function
1107:41 - instance that was generated this is
1107:44 - enough for our purposes
1107:46 - if we change our call here to use c and
1107:49 - d we're going to generate a double
1107:51 - instance so let's do that we're going to
1107:53 - generate a double instance and if we
1107:55 - print this out we're going to see this
1107:56 - printed out but we can use the debugger
1107:59 - to really prove this not that we know
1108:01 - how to use it we don't have to look
1108:03 - through the terminal output window but
1108:05 - you can do that if you want you can set
1108:07 - up sddc out and print max here you're
1108:09 - going to see it printed out so let's run
1108:12 - our debugger we're going to see the
1108:13 - template instance that was generated
1108:16 - through the divider we're going to hit
1108:18 - the breakpoint at line 17 here
1108:21 - if we step inside we're going to see the
1108:23 - local variables for our function here a
1108:25 - and b
1108:26 - and we're going to have the maximum
1108:29 - function to the top of the call stack
1108:31 - and you're going to see that it is a
1108:33 - double instance for our function
1108:35 - template here
1108:37 - okay this is what we mean by
1108:39 - template type deduction it is the
1108:43 - default mechanism
1108:45 - that the compiler uses to know
1108:48 - which template instance to generate from
1108:50 - your function calls but as we have seen
1108:53 - in the last lecture this can be
1108:55 - problematic
1108:56 - one way this can be bad is if you pass
1108:59 - different types to the maximum function
1109:02 - here let's pass in a and c for example
1109:05 - or a and d this is going to work equally
1109:07 - well you see that we get a compiler
1109:09 - error because the compiler now it says
1109:12 - that we are calling with different types
1109:15 - but the template parameters here are
1109:18 - really of the same type they should be
1109:20 - of the same type because t is going to
1109:22 - be replaced for a single time so the
1109:24 - call we do here is going to fail and if
1109:26 - we run this through the compiler again
1109:28 - let's do that we're going to use gcc
1109:31 - we're going to get a compiler error and
1109:32 - it is going to say deduce conflicting
1109:34 - types for parameter t
1109:36 - and then double so it can't really know
1109:39 - which one you want you want ent or
1109:41 - double the compiler doesn't know and it
1109:43 - is going to give us a compiler error but
1109:46 - now we're going to see a mechanism we
1109:48 - can use to make this work and that's
1109:50 - going to be explicit template arguments
1109:53 - okay what we can do to do this we can go
1109:56 - down and put in our call we're going to
1109:59 - say auto and say result or max we can
1110:02 - call this however we want we're going to
1110:03 - say the name of the function and we're
1110:05 - going to specify
1110:07 - the template type that we want generated
1110:10 - for our function template here so if we
1110:12 - do something like this with double
1110:14 - inside angle brackets here we're going
1110:17 - to be basically telling the compiler
1110:19 - please generate a double template
1110:22 - instance for this call we are doing here
1110:25 - so if we pass in c and d for example
1110:28 - this is going to give us what we want
1110:29 - and we can print this out if we
1110:31 - want so let's say max okay this is going
1110:34 - to work if we build let's build with gcc
1110:37 - let's use that
1110:39 - the build is going to be good because we
1110:41 - are passing any double
1110:43 - arguments and if we run this we should
1110:46 - see our maximum let's bring up a
1110:48 - terminal window and a visual studio code
1110:51 - here so that we can use that to see
1110:53 - things running we're going to clear and
1110:55 - run rooster you see that we have our
1110:57 - maximum here but using explicit template
1111:02 - arguments like we are doing here is
1111:04 - going to allow us to even pass different
1111:07 - types for our template arguments and for
1111:10 - example now we can change the first
1111:12 - argument here to ba which is going to be
1111:14 - an end and we're going to leave the
1111:16 - second one to bd which is of type double
1111:19 - now the compiler is going to see that
1111:21 - we're going to generate a template
1111:24 - instance of type double and it is going
1111:26 - to know that it can do implicit
1111:28 - conversions for the arguments we pass in
1111:31 - here so this is going to work if we pass
1111:34 - an argument that is implicitly
1111:36 - convertible to the type we passed in the
1111:39 - angle brackets here and let's debug this
1111:42 - again to show you that we're going to
1111:44 - generate a double template instance that
1111:47 - is going to be called and give us the
1111:49 - maximum that we print here so we can run
1111:52 - our debugger by hitting the green run
1111:55 - button here let's minimize this so that
1111:57 - we can see
1111:59 - our terminal window and it is down here
1112:02 - let's grab it and put it to the left so
1112:04 - that we can really see things printed
1112:07 - out as we debug
1112:08 - we have hit the breakpoint here and we
1112:11 - have our local variables you can look at
1112:13 - this if you want it is basically what we
1112:15 - have in the main function here but what
1112:17 - we want is to step into this maximum
1112:19 - function
1112:20 - and we're going to see
1112:22 - the template instance that was generated
1112:25 - you see that it is of a double type here
1112:27 - okay hopefully now you can see that even
1112:30 - if we passed different values for our
1112:34 - template arguments i should say
1112:36 - different types because a is of type and
1112:38 - and d is of type double but we're not
1112:42 - getting a compiler error the compiler is
1112:44 - going to insert implicit conversions
1112:47 - from whatever arguments we pass here to
1112:50 - the explicit template argument that we
1112:53 - specified here again the explicit
1112:56 - template argument like we are doing here
1112:58 - using the syntax with angle brackets and
1113:01 - putting in our type is going to tell the
1113:03 - compiler please use this type and
1113:06 - replace that for t in our function
1113:09 - template here and generate a template
1113:11 - instance we can call to service this
1113:14 - call here and we're going to do implicit
1113:16 - conversions basically from
1113:18 - and to double because that's what we
1113:20 - want then d is going to be of double
1113:22 - type we're not going to do any implicit
1113:24 - conversion then we're going to call this
1113:26 - function we're going to return a double
1113:28 - from it because that's our template
1113:30 - instance and we're going to print that
1113:32 - out here this is what is happening and
1113:34 - we can prove that a double instance was
1113:36 - generated through our call stack here we
1113:39 - see the maximum function is taking in
1113:42 - double parameters and it's going to
1113:44 - return double as our explicit
1113:48 - template argument here this is the
1113:50 - syntax that gcc uses is using but we
1113:54 - know now that it is a double template
1113:56 - instance for a function call here okay
1113:59 - if you're not happy with what we are
1114:02 - seeing with the debugger you can also
1114:04 - use cpp insights to really prove this
1114:07 - let's open this up we're going to say
1114:09 - cpp insights
1114:11 - let's do that and we're going to have it
1114:13 - open here okay we're going to
1114:16 - erase whatever we have in here and we're
1114:17 - going to put in another piece of code we
1114:20 - have our maximum function i should say
1114:23 - template function or function template
1114:25 - and we have alcohol here and it is
1114:27 - passing different types a and d remember
1114:30 - the last time we did something like this
1114:32 - by passing in different types for the
1114:35 - template argument this guy failed it
1114:38 - couldn't really generate a function
1114:40 - template instance because the template
1114:43 - parameters we have on top here specify
1114:45 - that these guys should be of the same
1114:48 - type but now we are able to use
1114:50 - different types as arguments because we
1114:53 - have an explicit argument specified
1114:56 - let's run this and see the template
1114:58 - instance that is generated and you can
1115:00 - see that it is of double type we
1115:02 - basically replaced every instance of t
1115:06 - here with double and this function is
1115:08 - going to be called to service the call
1115:11 - we are making here okay this is really
1115:13 - all we set out to do in this lecture i
1115:15 - hope you found it interesting the main
1115:17 - message was template type deduction a
1115:19 - default mechanism c plus plus uses to
1115:22 - know which template instances to
1115:24 - generate from your function calls but if
1115:27 - the defaults aren't working for you you
1115:30 - can use explicit template arguments to
1115:33 - specify the template instance you want
1115:36 - to generate it we are going to stop here
1115:39 - in this lecture in the next one we're
1115:40 - going to see how we can pass template
1115:42 - parameters by reference
1115:45 - go ahead and finish up here and meet me
1115:47 - there in this lecture we're going to
1115:49 - show you that you can pass your template
1115:51 - type parameters by reference and we're
1115:54 - going to look at a simple example to
1115:56 - really drive this home what we have seen
1115:58 - so far is that we can do things like
1116:00 - this and specify our t like this and
1116:03 - this is going to generate a template
1116:05 - instance that passes our arguments by
1116:08 - value for example if we pass in double a
1116:11 - and double b here for our maximum we're
1116:13 - going to generate a template instance
1116:16 - which takes double as parameters and
1116:18 - returns a double here and this is going
1116:20 - to be doing things by value okay this is
1116:23 - what i want you to focus on right now it
1116:25 - is that this is going to do things by
1116:27 - value so if we go in our function here
1116:30 - and compute the maximum you're going to
1116:32 - see that the addresses we have on the
1116:34 - outside are going to be different from
1116:37 - the addresses we have on the inside here
1116:39 - if we try to print them out but you can
1116:42 - also pass your template parameters by
1116:44 - reference and the syntax to do that is
1116:47 - ridiculously easy you just use this like
1116:50 - you would use any reference we say cast
1116:52 - t reference here and this is going to
1116:54 - just replace in whatever type that you
1116:58 - pass when you call the function here for
1117:00 - example here we are passing in double
1117:02 - arguments so this is going to deduce a
1117:05 - double template instance which basically
1117:08 - says cost double reference maximum cost
1117:11 - double reference a and cost double
1117:13 - reference b and this is going to be the
1117:15 - function that is called so this is going
1117:17 - to really do things by reference and the
1117:20 - values we have inside a function
1117:22 - template body here are going to be true
1117:25 - references to the values we have on the
1117:27 - outside if we happen to do any
1117:29 - modification inside the body of the
1117:31 - function the modification is going to be
1117:33 - visible on the outside what we're going
1117:35 - to be doing in this lecture is just
1117:38 - printing the addresses here and we're
1117:40 - going to see that they are the same here
1117:42 - on the outside and inside the body of
1117:45 - our function template here okay this is
1117:48 - what we want to really play with in this
1117:50 - lecture but before we head over to
1117:52 - visual studio code i want to show you
1117:54 - that you can confuse your compiler if
1117:57 - you are not careful if you set up these
1117:59 - two function templates you see here
1118:02 - they are going to be overloads and we
1118:04 - can use function overloads with
1118:06 - templates but for now we're just going
1118:08 - to focus on the parameters that we are
1118:10 - passing in here the first one is taken
1118:12 - thanks by volume
1118:15 - and the second one is taking thanks by
1118:17 - reference as we see here
1118:19 - and if we issue a call like this we're
1118:21 - going to have the same problem we have
1118:24 - seen with function overloads before this
1118:26 - is not going to know whether you are
1118:28 - calling by value or by reference and
1118:30 - this is going to cause a compiler error
1118:32 - i really want you to be aware of this
1118:34 - okay now that you know this we're going
1118:36 - to head over to visual studio code and
1118:38 - really play with us a little more okay
1118:40 - here we are in our working folder the
1118:42 - current project is template parameters
1118:45 - by reference we're going to grab our
1118:47 - template files and put them in place so
1118:50 - let's do that and we are going to open
1118:52 - this little guy in visual studio code by
1118:55 - dragging and dropping here the folder is
1118:58 - going to open up we're going to open it
1119:00 - and we're going to close the left pane
1119:02 - here and clean up our main file here and
1119:05 - we are going to put in our function
1119:08 - template one thing i want you to see in
1119:10 - this lecture is that it is possible to
1119:12 - separate these things into function
1119:14 - declaration and function definition
1119:16 - let's just try and do that here so that
1119:18 - you can really see this and then you're
1119:20 - going to have to choose what you like a
1119:22 - little more so let's grab a function
1119:24 - header here and use that as a prototype
1119:27 - we're going to put that in front of the
1119:29 - main function and that's going to be our
1119:31 - declaration and if we go down after the
1119:34 - main function here what we have is our
1119:37 - definition this could work and this is
1119:39 - going to generate template instances for
1119:41 - the calls we do in the main function
1119:44 - here okay now that we have this we can
1119:45 - head in the main function and really
1119:47 - play with the function template here
1119:50 - we're going to set up two double
1119:51 - parameters and we're going to call the
1119:53 - function for example we say addon result
1119:56 - and we're going to call the maximum
1119:58 - function and we're going to pass in a
1120:00 - and b this is going to do
1120:02 - default template type deduction and it
1120:05 - is going to generate a double function
1120:08 - template instance here but what we
1120:10 - really want to prove is that this is
1120:12 - going to pass things by value and one
1120:14 - way we have to prove this is to bridge
1120:16 - the addresses both on the outside and on
1120:20 - the inside of the function here you see
1120:22 - we are already doing that in our
1120:24 - function template body we are going to
1120:26 - print the address of a so we can really
1120:28 - grab this and we use this stdc out
1120:32 - statement
1120:33 - and we are going to change it to say out
1120:36 - here and we're going to print the
1120:37 - address of a let's grab this again and
1120:40 - use this after the function call and
1120:42 - what we expect to see
1120:44 - is some address on the outside so for
1120:47 - example we may have something like zero
1120:50 - x and a one one one abc which is some
1120:54 - hex number here and that's the same
1120:57 - thing we're going to have on the outside
1120:59 - because the value we have before the
1121:01 - function call and the value we have
1121:04 - after the function call are going to be
1121:05 - leaving at the same address but what we
1121:08 - have inside the function body is going
1121:11 - to be a copy so it's going to live at
1121:13 - some other address for example let's say
1121:15 - d a
1121:16 - and uh the main point here is that what
1121:19 - we have on the outside is going to be
1121:20 - different from what we have on the east
1121:22 - side and hopefully this is going to
1121:24 - prove that we are passing by value so
1121:27 - let's print out our maximum here and see
1121:30 - the addresses printed out we're going to
1121:32 - build with gcc and we're going to build
1121:35 - successfully we can bring up a terminal
1121:38 - to play with us a little more we can
1121:40 - clear and run rooster we're going to see
1121:42 - that the address on the outside ends in
1121:45 - dd8 and the address on the outside ends
1121:48 - with dd8 after the function call but
1121:51 - inside you see that we have a different
1121:53 - address and this is going to tell us
1121:56 - that we are passing by value and what we
1121:58 - have inside the body of the function is
1122:01 - basically a copy again i don't expect
1122:04 - you to see the same addresses as me here
1122:06 - because your operating system is going
1122:08 - to set up the addresses however it wants
1122:10 - the main point here is that the
1122:13 - addresses you see on the outside are
1122:15 - going to be different from the addresses
1122:17 - you see on the inside here and this
1122:19 - proves that we are passing by value but
1122:22 - what if you don't really want to pass by
1122:24 - value and make your function template
1122:27 - work by reference well we can do that we
1122:29 - can change our function here to do
1122:31 - things by reference and all we have to
1122:33 - do
1122:34 - is use t reference like this okay and
1122:37 - when we start using references we really
1122:39 - need to be careful and make sure people
1122:42 - don't modify things without our
1122:45 - knowledge and a good practice is to mark
1122:48 - your things as cost references so we're
1122:50 - going to do that and we are going to do
1122:52 - the same in our function definition so
1122:55 - we're going to change this to cost t
1122:57 - reference let's do that and let's say
1123:00 - cost t reference for the first parameter
1123:02 - here and say the same for the second
1123:05 - parameter here and this should be it we
1123:07 - shouldn't be able to use this reference
1123:10 - to modify the data inside the body of
1123:12 - the function and our function is a
1123:14 - little safer but what the compiler is
1123:16 - going to do is really what it's been
1123:18 - doing all along it's going to look at
1123:20 - the arguments that we pass to the
1123:22 - function call here it's going to see
1123:23 - that it is double and it's going to do
1123:26 - default template type deduction so it's
1123:28 - going to generate a double template
1123:31 - instance for the function template here
1123:34 - and it's going to replace in double and
1123:36 - we're going to have const double
1123:38 - reference maximum cost double reference
1123:40 - a constant double reference b
1123:42 - and we can prove this by going into cpp
1123:46 - insight i think we can do that so we are
1123:48 - here in cpp insights we can take out
1123:51 - whatever we had we're going to put in
1123:52 - new code here and we can
1123:55 - hit the run button
1123:57 - to generate our instances and here we
1124:00 - have our template instance here
1124:03 - generated you see that it is going to
1124:05 - generate a double version of our
1124:08 - function template here and this is what
1124:10 - we have so const double reference
1124:13 - maximum and it is going to put in a
1124:16 - double explicit argument here but this
1124:18 - is business of the compiler what we
1124:20 - really care about is that it generated a
1124:23 - double template instance for our
1124:25 - function template here now if we run
1124:27 - this it is going to be passing
1124:29 - parameters by reference and what we have
1124:31 - on the inside should have the same
1124:33 - address as what we have on the outside
1124:36 - here so
1124:37 - to really drive this home we should
1124:39 - change
1124:40 - our address to abc to comply with what
1124:44 - we have on the outside here we can try
1124:46 - and build our program we're going to use
1124:48 - the gcc to do that the build is going to
1124:50 - be good we're going to clear and if we
1124:52 - run rooster we should see the addresses
1124:54 - being the same out d e 0 in d e 0 and
1124:59 - out d e 0 and you see now we are passing
1125:02 - our parameters by reference and if you
1125:04 - want to set up a function template that
1125:07 - passes template parameters by reference
1125:10 - this is how you can do this
1125:12 - and i think we can also try and debug
1125:14 - this and see if we can see any more
1125:16 - information on how this works we're
1125:18 - going to hit our run tab here and we're
1125:21 - going to hit the green button to start
1125:24 - debugging this program we're going to be
1125:26 - using the debugging tools from gcc
1125:29 - and we see our local variables here we
1125:32 - have hit the breakpoint and we have the
1125:35 - main function to the top of the call
1125:37 - stack this is what we have here and if
1125:40 - we try and step into the maximum
1125:42 - function we're going to see that the
1125:44 - template instance now is using const
1125:47 - double references and this is the
1125:49 - template instance that was generated i
1125:52 - think this is all we can really see here
1125:55 - and let's stop this and show you one
1125:58 - last thing
1126:00 - what i'm going to show you is that you
1126:01 - can't really have
1126:03 - the function template that passes by
1126:07 - value and the other one passing by
1126:09 - reference if you do that you're going to
1126:10 - have problems when you issue the call
1126:12 - like this because the compiler is going
1126:14 - to be confused let's change the second
1126:16 - one here to pass by value so we're going
1126:19 - to remove the cost reference here i
1126:21 - think it's going to do let's do that
1126:22 - pretty quick we'll remove the cost and
1126:25 - the reference we remove the cost and the
1126:28 - reference here and we use this guy as
1126:31 - our function prototype in front of the
1126:33 - main function here and how can we say
1126:36 - that we're going to go on top here and
1126:39 - say that okay we're going to put our
1126:41 - semicolon and this is going to be our
1126:43 - declaration but the moment we do this
1126:45 - you see that our compiler is going to be
1126:47 - confused because we have two possible
1126:49 - candidates for the call here it can
1126:52 - either be by value or by reference and
1126:55 - if we try to build this program we're
1126:56 - going to get a compiler error and it is
1126:59 - basically going to be saying what is
1127:01 - wrong here so it's going to say call
1127:03 - overloaded maximum double ambiguous
1127:05 - because we have two candidates again one
1127:08 - by reference one by value and this call
1127:11 - can be surfaced by both of these
1127:14 - candidates here so the compiler is going
1127:16 - to give us a compiler error and we have
1127:18 - no choice but to use either of these two
1127:21 - but we can't have them all
1127:23 - in our code and for example if we take
1127:26 - out the one by value here and leaving
1127:28 - the one by reference so let's comment
1127:31 - this out again if we're boiled we're
1127:32 - going to bolt you see the world is good
1127:34 - and we're going to print our data
1127:36 - however we have it in our code we see
1127:38 - the addresses are the same and another
1127:40 - thing i don't think i really proved to
1127:43 - you is that we are passing by const
1127:45 - reference here so the template instance
1127:48 - that is going to be generated is going
1127:50 - to be passing by const double reference
1127:52 - because we are passing in double
1127:54 - parameters but because of this cost in
1127:57 - front of our arguments here we want to
1128:00 - be able to modify the data referenced by
1128:03 - this name here if we go inside for
1128:05 - example and say plus plus a try to
1128:08 - modify a in any way through this
1128:10 - reference we're going to get a compiler
1128:12 - error let's work again and we're going
1128:13 - to see that and uh world finished with
1128:17 - an error
1128:18 - and it is saying
1128:20 - increment of read only reference a
1128:22 - because we are passing by const
1128:24 - reference here so you should really
1128:26 - remember this even if we are doing the
1128:29 - things in the context of function
1128:31 - templates
1128:32 - this is really all we set out to do in
1128:34 - this lecture showing you that you can
1128:35 - set up function templates that take
1128:38 - parameters by reference and contrasting
1128:41 - this with passing by value and seeing
1128:43 - the differences between these two things
1128:45 - we're going to stop here in this lecture
1128:47 - and the next one we're going to learn
1128:49 - about template spatialization
1128:52 - go ahead and finish up here and meet me
1128:54 - there
1128:55 - in this lecture we're going to learn
1128:56 - about template specialization and this
1128:59 - is a feature we have in c plus plus to
1129:02 - bypass the default mechanism of how
1129:05 - function templates work in c plus plus
1129:08 - okay let's make myself super clear here
1129:10 - we have a simple function template we
1129:12 - have seen a thousand times by now it is
1129:15 - the maximum function and it is going to
1129:17 - compute the maximum between a and b here
1129:20 - and it is going to return that it is a
1129:22 - function template so if we pass in a and
1129:24 - b which are of type and we're going to
1129:26 - generate a net instance of the template
1129:29 - here if we pass in c and d of double
1129:32 - time we're going to generate a double
1129:34 - instance of the function template here
1129:37 - if we pass in hdd string parameters
1129:40 - we're going to generate an std string
1129:43 - instance of this template here and this
1129:45 - is going to basically be comparing the
1129:47 - parameters we pass so we're basically
1129:49 - going to say if a is greater than b then
1129:52 - return a if a is not greater than b then
1129:55 - return b okay that's going to work if
1129:58 - what we're doing is what we have here
1130:00 - but the moment we pass something like
1130:02 - what we have here closed car pointers
1130:06 - then we're going to have a problem
1130:08 - because we're going to be calling our
1130:10 - function template with cost car pointer
1130:13 - parameters
1130:14 - the
1130:15 - default mechanism is going to deduce
1130:18 - a template instance that works on cost
1130:21 - car pointer arguments here and what
1130:24 - we're going to be comparing now are
1130:26 - going to be pointers to the string
1130:28 - rather than the string data itself and
1130:32 - hopefully you can see that this is going
1130:33 - to be a problem template specialization
1130:36 - is a mechanism we have to tell the
1130:38 - compiler for a template function
1130:41 - if i pass you this type please don't do
1130:44 - the default thing you do of replacing in
1130:47 - the
1130:48 - argument type for the template parameter
1130:50 - instead use the implementation that i am
1130:53 - going to give you and you tell that to
1130:55 - the compiler using the syntax we have
1130:57 - here you put a template keyword here you
1131:00 - put an empty pair of angle brackets and
1131:03 - then you specify your function the way
1131:06 - you want it you see it's going to return
1131:08 - a const card pointer the function name
1131:10 - is maximum which should be the same as
1131:12 - the function template here
1131:14 - it's going to be specialized for const
1131:16 - car pointer so we specify an explicit
1131:19 - template argument here and then we pass
1131:21 - our parameters which are also of cost
1131:24 - card pointer and when we do this then we
1131:27 - can head in the body of the function and
1131:29 - do the comparison however we want okay
1131:31 - so how do we do this comparison here
1131:33 - here is a simple implementation of the
1131:36 - function template we just saw on the
1131:38 - previous slide you see that it really is
1131:40 - the same thing we have the template
1131:42 - keyword we have our angle brackets and
1131:44 - we have the function header here it's
1131:47 - going to return cost car pointer it's
1131:50 - going to be called maximum and an
1131:52 - explicit template argument is specified
1131:55 - within these angle brackets and then we
1131:57 - have our parameters what is really
1132:00 - important about this function is that
1132:02 - it's not going to do the comparison
1132:04 - we've been doing all along it's going to
1132:06 - use a built-in function
1132:08 - and it's a c plus plus standard library
1132:10 - which is specialized for comparing c
1132:12 - strings okay if we come at cpp reference
1132:15 - here and look at a function called
1132:17 - htrcmp we have seen this before i guess
1132:21 - it is going to compare two null
1132:23 - terminated byte strings
1132:24 - lexicographically and you see this is
1132:26 - really what we want we have two const
1132:28 - car pointers one is going to be the
1132:30 - first parameter the other is going to be
1132:32 - the second parameter we're going to
1132:34 - compare them and look at the return
1132:36 - value we get from this function we're
1132:38 - going to get a negative return value if
1132:40 - the first parameter comes before the
1132:43 - second parameter in lexicographical
1132:45 - order we're going to get a zero if they
1132:48 - are equal
1132:49 - and we're going to get a positive value
1132:51 - if the first parameter comes after the
1132:54 - second parameter in lexicographical
1132:57 - order so we're going to use this
1132:58 - information here and compare
1133:00 - our two c strings here and return
1133:03 - something in visual studio code okay so
1133:06 - this is the function here it's going to
1133:07 - be using the logic from hdr cmp
1133:10 - and notice what we return we're going to
1133:12 - return whichever strength
1133:15 - compares the greater to the other so
1133:17 - we're going to do strcmp we're going to
1133:19 - pass in our two arguments here and we're
1133:22 - going to say
1133:23 - if this returns something greater than 0
1133:26 - return a because in that case
1133:28 - a is greater than b
1133:31 - lexicographically this is the comparison
1133:33 - we want to do here and otherwise you're
1133:35 - going to return b and this is going to
1133:36 - compare our strings and not compare
1133:38 - pointers directly which is what we are
1133:41 - trying to avoid here and you see that
1133:43 - template specialization is really
1133:45 - helping out here now if we have this n
1133:48 - and the compiler sees a call like this
1133:51 - it's not going to compare pointers it's
1133:53 - going to use the template specialization
1133:55 - because the compiler knows that this is
1133:58 - a better
1133:59 - fit for the call that we are doing here
1134:02 - because we are passing cost card
1134:04 - pointers this is how template
1134:06 - specialization works and it can really
1134:08 - come in handy if you are doing things
1134:11 - that work with pointers we are going to
1134:14 - head over to visual studio code and play
1134:16 - with this a little more okay here we are
1134:18 - in our working folder the current
1134:20 - project is template specialization we're
1134:22 - going to grab our template files
1134:25 - we're going to put them in place and
1134:27 - we're going to open this in visual
1134:29 - studio code by dragging and dropping on
1134:32 - top of visual studio code here this is
1134:34 - going to open our project and we're
1134:36 - going to clean it up a little bit and
1134:38 - we're going to close the left pane here
1134:39 - we don't need it anymore the first thing
1134:41 - we're going to do is to put in our
1134:43 - function template the same thing we have
1134:46 - been doing for a gazillion times by now
1134:48 - the maximum function is going to return
1134:50 - whichever is greater between a and b and
1134:53 - it is doing this by value after that
1134:55 - we're going to head over in the main
1134:57 - function and set up a piece of code to
1134:59 - really play with us we're going to set
1135:01 - up a few variables and we're going to
1135:03 - call our functions so we're going to say
1135:06 - maximum a and b this is going to return
1135:09 - the maximum between a and b the compiler
1135:11 - is going to deduce that the template
1135:14 - instance should be of ant type so it's
1135:16 - going to generate that and call it it's
1135:18 - going to give us the return value here
1135:20 - we can print it out and see it and we're
1135:22 - going to basically do the same
1135:23 - for double type and the string types
1135:26 - here and you're going to see that this
1135:27 - is going to work just fine so let's
1135:30 - build this we're going to use gcc to do
1135:32 - that the bolt is good we can clear and i
1135:35 - bring up a terminal to run this
1135:38 - and really see the output here we can
1135:40 - clear and run rooster you see max end is
1135:43 - 23 because that's what we have here max
1135:46 - double 34
1135:48 - and that's what we have here and we
1135:50 - called max double to be of int type we
1135:53 - should use auto type deduction here to
1135:55 - avoid these mistakes
1135:57 - because the compiler can do this better
1135:59 - than us
1136:00 - that's what we're going to do and we're
1136:02 - going to deduce max sdr here and we're
1136:05 - going to build again let's weld with gcc
1136:08 - because that's my favorite compiler i'm
1136:10 - going to clear and run rooster now we
1136:13 - have correct output we have 23 which is
1136:16 - the maximum between a and b
1136:18 - we have 34.7 which was deduced to be of
1136:21 - type double here and then we have the
1136:24 - maximum strength which happens to be
1136:26 - world here again
1136:28 - when comparing strengths the default is
1136:30 - going to compare them
1136:32 - lexicographically and what that means
1136:35 - the one that comes after the other in
1136:38 - alphabetical order is going to be
1136:40 - greater by that logic world is greater
1136:42 - than hello and it is what we are seeing
1136:45 - printed out here okay this is working
1136:47 - just fine but what if we use cost card
1136:50 - pointers and try to call our maximum
1136:52 - function template and by that i mean
1136:55 - doing something like this we have two
1136:57 - variables
1136:58 - g and h which are of type cost card
1137:01 - pointers so they are c strings they are
1137:04 - going to be now terminated because we
1137:06 - are initializing them with a string
1137:08 - electron and we are comparing them here
1137:10 - we are saying maximum g and h and we're
1137:13 - going to print whichever is the maximum
1137:15 - after we return that from the function
1137:18 - when the compiler sees the call like
1137:19 - this it's going to do what it knows to
1137:21 - do it's going to replace an
1137:23 - scar pointer in our function template
1137:26 - here so it's going to return cost card
1137:28 - pointer it's going to pass the
1137:30 - parameters as coast guard pointers and
1137:32 - we're going to be comparing these
1137:33 - pointers here and we're going to return
1137:36 - whichever pointer is greater again here
1137:39 - you must be noticing the problem we're
1137:41 - going to return whichever pointer is
1137:43 - greater and we're not going to be
1137:45 - returning the actual string data we're
1137:47 - going to be returning just the address
1137:50 - and this can be really wrong because if
1137:52 - the addresses happen to be messed up
1137:55 - we're going to get the wrong output so
1137:57 - let's try and prove this again for that
1138:00 - i am going to comment out what we had on
1138:02 - top here because this could mess things
1138:05 - up a little bit
1138:06 - so i'm going to comment all this now and
1138:08 - i am going to debug this
1138:10 - so we're going to look at this line here
1138:13 - and i think we should say
1138:15 - cos car pointer result and i say equals
1138:18 - max c mom g and h and i printed the
1138:22 - result here this is going to make it
1138:24 - easier to step into this function
1138:26 - without the noise from stdc out here so
1138:29 - we're going to set up our breakpoint
1138:31 - here we're going to hit our
1138:33 - run tab and we're going to debug this
1138:36 - program and we're going to hit this
1138:37 - breakpoint here let's see the types that
1138:40 - we have inside our function call
1138:43 - so now that we are here we're going to
1138:45 - see that our locals are g and h and they
1138:48 - contain our strength if we go inside
1138:51 - we're going to see that g is really a
1138:54 - pointer to the first element in our
1138:56 - string here and it contains
1138:59 - w here
1139:00 - which is what we have here
1139:03 - and h is going to be a pointer to a
1139:05 - that's what we have here okay
1139:08 - and result is going to contain some junk
1139:10 - data because it's not initialized yet
1139:13 - but we can step into this function
1139:15 - and see things happening a again is an
1139:18 - address and b is an address you see that
1139:21 - the debugger is really smart it's
1139:23 - noticing that this is a pointer to a
1139:25 - strength and it's going to show us the
1139:27 - string here but what we compare are
1139:29 - these two addresses and you see that b
1139:33 - lives in a larger address it leaves at
1139:36 - address that ends in 55 and a lives at
1139:40 - the address that ends in 50. so if we
1139:43 - really execute this function we're going
1139:45 - to return the pointer to b but you see
1139:48 - that b is not really the greater string
1139:51 - and this is really something bad you
1139:52 - should be aware of this this is what the
1139:54 - compiler is doing by default and it is
1139:56 - going to give us a result that is not
1139:59 - correct let's close this and see a way
1140:02 - we can solve this problem and we can use
1140:05 - template specialization for this what we
1140:07 - really need is a way to compare c
1140:10 - strings and not compare pointers like we
1140:12 - are doing here we're going to do that
1140:14 - using a template specialization
1140:16 - and the syntax for this to work you say
1140:18 - template and you specify an empty pair
1140:21 - of angle brackets and then you specify
1140:24 - whatever function you want to use so
1140:26 - we're going to go down here and specify
1140:28 - that we want to return the cost card
1140:30 - pointer
1140:31 - the function is going to be called
1140:32 - maximum we're going to specify an
1140:34 - explicit template argument which is of
1140:38 - const car pointer because we want this
1140:40 - template instance to work for scar
1140:42 - pointers
1140:43 - so once we have this end we're going to
1140:45 - specify our parameters we're going to
1140:47 - say cos car pointer a and cost car
1140:50 - pointer b and we're going to head into
1140:53 - the body of our function template here
1140:55 - now we have our two parameters and we're
1140:58 - going to compare them as if they were
1141:00 - const color strengths and we have seen
1141:02 - that we have a built-in facility from
1141:04 - the c plus plus standard library it is
1141:07 - this htr cmp function we can use it to
1141:10 - compare two strengths and we're going to
1141:12 - use the logic that we have here so if
1141:14 - the first parameter is less than the
1141:17 - second parameter i am talking in a
1141:19 - lexicographical order we're going to
1141:21 - return something negative if they are
1141:23 - equal dexicographically we're going to
1141:24 - return zero and if the
1141:27 - first parameter is greater than the
1141:30 - second parameter lexicographically we're
1141:33 - going to return a positive value so
1141:36 - let's transform this logic into a
1141:38 - ternary operator we're going to say
1141:41 - return sdd str cmp we can say that and
1141:46 - if you have access to this function
1141:47 - we're going to need to include c string
1141:50 - let's do that we're going to include the
1141:52 - c string library and now we can say this
1141:55 - and we're going to pass in a and b and
1141:58 - we're going to ask ourselves is this
1142:00 - greater than zero okay if it's greater
1142:02 - than zero then if the first parameter is
1142:05 - greater than the second parameter let's
1142:07 - see graphically so we're going to return
1142:09 - a
1142:10 - if it's not the case we're going to
1142:12 - return b this is our ternary operator
1142:14 - here and it is going to work now that we
1142:16 - have this n the compiler is going to
1142:19 - know we have a template specialization
1142:22 - for a const car pointer if we call the
1142:25 - function like we did here calling the
1142:27 - maximum function the compiler is not
1142:29 - going to use this function template we
1142:31 - have on top here it's going to see that
1142:34 - this template specialization is better
1142:37 - for the cost card pointer type that we
1142:40 - are passing here and now if we try to
1142:42 - build and run the program the boat is
1142:45 - going to be good if we clear and run
1142:47 - rooster we're going to see that now the
1142:49 - maximum is wild
1142:51 - let's see what we see if we don't have
1142:54 - this specialization and we're going to
1142:56 - comment this out because i don't think i
1142:58 - really showed you we're going to build
1143:00 - again and again if we do this
1143:02 - this function template is going to be
1143:04 - used and you know that it is going to
1143:06 - deduce a function that compares pointers
1143:08 - directly and that's going to be really
1143:10 - bad we can build this with gcc and
1143:13 - really see what we get as output we can
1143:16 - clear and run rooster now you see that
1143:18 - we are saying animal is the maximum
1143:21 - between these two guys but that's not
1143:23 - true animal is less than wild in
1143:27 - lexicographical order we need a way to
1143:30 - really compare
1143:32 - c strings properly and our template
1143:35 - specialization
1143:36 - is really doing that using the htd crmp
1143:40 - function and it is working pretty well
1143:43 - this is really all template
1143:44 - specialization is all about you're going
1143:47 - to do this if the default function
1143:49 - template you have is really not working
1143:51 - according to your needs for the type
1143:53 - that you want to use for this and use
1143:56 - this to your advantage because it's
1143:58 - available to you and now you know how to
1144:00 - use this the syntax is really simple you
1144:02 - say template and you say angle brackets
1144:04 - and then you specify whichever
1144:07 - implementation you want for your
1144:09 - specific type for example here our
1144:12 - specific type for which we want to
1144:14 - specify this function template is cost
1144:16 - card
1144:17 - you specify that as an explicit
1144:20 - template argument and then you specify
1144:22 - your return value your parameters and
1144:25 - you do whatever logic you need to do to
1144:27 - do things right in the body of this
1144:29 - template specialization here i would
1144:32 - like to welcome you in this new chapter
1144:34 - where we're going to be learning about
1144:36 - concepts concepts are a mechanism we can
1144:40 - use to set up constraints or
1144:42 - restrictions on the template parameters
1144:45 - in our function templates for example we
1144:47 - can use this technique to say that we
1144:49 - want our function to be only called with
1144:51 - integers and if you call it with
1144:53 - something that isn't an integer it's
1144:55 - going to give you a compiler one thing i
1144:58 - should emphasize is that concepts are
1145:00 - one of the big four features in c plus
1145:03 - plus 20. so we're going to be learning
1145:05 - about this in this chapter we have just
1145:07 - said that we use them to place
1145:09 - constraints on our template parameters
1145:12 - but we saw that we could do something
1145:14 - like that in the last chapter where we
1145:16 - could use type trades and static
1145:19 - concerns for example if you look at the
1145:21 - function here it's going to print a
1145:22 - number but we have a requirement for
1145:25 - this number to be an integral type
1145:28 - through the static assert that we have
1145:30 - here we're going to see that we can do
1145:32 - something really similar with concepts
1145:35 - but it's going to be much cleaner and
1145:37 - that the logic to enforce our
1145:40 - constraints is not going to be in the
1145:43 - function body it's going to be somewhat
1145:45 - in the function declaration in the
1145:47 - constraints that we put on the template
1145:49 - parameter here we're going to see
1145:50 - specific syntaxes of how you can do this
1145:53 - starting in the next lecture there are
1145:56 - two sides to concepts in c plus plus
1145:59 - there are standard built-in concepts
1146:01 - that come with the c plus plus
1146:03 - programming language but if for some
1146:05 - reason these happen not to be enough you
1146:08 - can build your own and we're going to
1146:10 - see how we can do that later in this
1146:12 - chapter here are a few examples of
1146:15 - concepts you can use in your c plus plus
1146:17 - program you can use the integral
1146:19 - concepts to enforce that your parameters
1146:21 - be integrals you can use the floating
1146:24 - point concept to enforce that your
1146:26 - template parameters be of floating point
1146:29 - type you can do all kinds of crazy
1146:31 - things okay concepts are really cool and
1146:33 - they are going to make your function
1146:35 - templates much safer to work with we are
1146:38 - going to stop here in this lecture and
1146:40 - show you how you can use concepts
1146:42 - starting in the next lecture go ahead
1146:45 - and finish up here and meet me there in
1146:47 - this lecture we're going to learn about
1146:49 - concepts again concepts are a mechanism
1146:53 - we have in place in c plus 20 to place
1146:56 - constraints on our function templates
1146:59 - for example we can use concepts to
1147:01 - specify
1147:03 - that we want our function template to
1147:05 - only be called with integers or doubles
1147:08 - or strings or whatever
1147:10 - and when somebody violates our concept
1147:13 - they're going to get a compiler error in
1147:15 - this lecture i am going to show you how
1147:17 - you can set up your concept and the
1147:19 - different syntaxes you can use and how
1147:21 - we can understand them
1147:23 - but before we do that please note that
1147:25 - there are two sides to concepts there
1147:28 - are concepts that are standard and built
1147:31 - into the c plus plus standard library
1147:34 - and those are ready to use and these are
1147:36 - what we're going to be using in this
1147:37 - lecture but know that you can also build
1147:40 - your own concepts and use them to do
1147:43 - whatever it is you want to do here are a
1147:45 - few examples of built-in concepts we can
1147:48 - use from the c plus plus standard
1147:50 - library we have for example a concept we
1147:53 - can use to enforce
1147:55 - that people call our functions only with
1147:57 - integral types if they violate this
1148:00 - they're going to get a compiler error we
1148:02 - can also enforce for our template
1148:04 - parameters to be floating point we can
1148:07 - do all kinds of crazy things okay now
1148:09 - that you know this let's see how we can
1148:11 - set up a concept on our function
1148:13 - templates and this is the first syntax
1148:16 - we're going to look at all you really
1148:18 - have to do is to put in your template
1148:21 - declaration like we have been doing all
1148:23 - along you also have to add in the
1148:26 - requires keyword here after the requires
1148:29 - keyword you're going to specify your
1148:31 - concept and specify your template
1148:34 - parameter in angle brackets here
1148:37 - when you have this thing in front of
1148:39 - your function template like we have here
1148:42 - the function template can only work
1148:44 - right if the concept in here is
1148:47 - satisfied and this concept in this case
1148:50 - is going to be satisfied if somebody
1148:53 - tries to call this function template
1148:56 - only with integral types if they violate
1148:59 - that again they are going to get a
1149:00 - compiler error okay once we have this
1149:03 - concept set up we can look at the piece
1149:05 - of code that tries to use it and try to
1149:08 - guess what is going to happen here is a
1149:11 - piece of code we would set up in the
1149:12 - main function and try to call a function
1149:15 - template we have two variables of car
1149:17 - type we know that car is an integral
1149:20 - type so if we issue a call like this
1149:23 - this call is going to work the template
1149:25 - instance is going to be generated and
1149:28 - it's going to be called and give us the
1149:29 - results that we can print here this is
1149:32 - right on the second piece of code here
1149:35 - we have two variables of type and
1149:38 - we're going to call them we're going to
1149:40 - call our function template with and
1149:42 - and this is also an integral type int is
1149:45 - an integral type so this is going to
1149:47 - generate our function template instance
1149:50 - and we're going to call it and get the
1149:51 - results that we print here and if we try
1149:54 - to call our function template with
1149:56 - double types
1149:58 - the concept is not going to be satisfied
1150:00 - and we're going to get some kind of
1150:02 - error and our function template instance
1150:04 - is not going to be generated this is
1150:06 - really how you can use concepts to force
1150:09 - some rules on users of your function
1150:13 - templates if i can say it like that we
1150:15 - have been able to do something like this
1150:17 - using typed traits and the static
1150:19 - asserts in the last chapter but concepts
1150:22 - are much cleaner and that they are kind
1150:24 - of built into the signature of your
1150:27 - function you don't have to go in the
1150:28 - body of your function and set up static
1150:30 - asserts the function is already
1150:33 - supporting concepts when you declare and
1150:36 - define it and this is really cool okay
1150:38 - this is our first syntax we can use to
1150:40 - set up concepts
1150:43 - for our function templates using the
1150:45 - requires close after our template
1150:47 - declaration and following that with
1150:50 - whatever concept we want to enforce on
1150:53 - our function template here please note
1150:55 - that you can also use type traits
1150:57 - directly
1150:58 - in the required clause here and this is
1151:00 - going to work and this really says that
1151:03 - all you really have to put after the
1151:05 - requires close
1151:07 - is an expression that can be evaluated
1151:09 - at compile time but also results in a
1151:13 - boolean value once you satisfy these few
1151:16 - requirements you can really set up your
1151:19 - concept however you want you just have
1151:21 - to be careful that the expiration can be
1151:24 - evaluated at compile time and that it
1151:27 - evaluates to a boolean value and when
1151:30 - the expression evaluates to true the
1151:32 - concept is going to succeed if the
1151:35 - expression evaluates to false you're
1151:37 - going to get a compiler error because
1151:39 - the concept is not satisfied this is how
1151:42 - these things work now that we have seen
1151:44 - the first syntax i think it is big time
1151:46 - we looked at the second way you can set
1151:48 - up concepts and that's going to be in
1151:51 - your template declaration you're going
1151:53 - to say template put in your angle
1151:55 - brackets and inside instead of saying
1151:58 - type name t like we have been doing all
1152:00 - along you just specify your concept
1152:03 - directly and save the template parameter
1152:06 - like this once you do this this concept
1152:09 - is going to be enforced on this function
1152:12 - template here this is just another
1152:14 - syntax to really do the same thing we
1152:16 - also have a third syntax we can use if
1152:18 - we use auto to set up our function
1152:21 - templates and the way this works is to
1152:23 - just add your concept in front of the
1152:26 - auto keyword and once you do this the
1152:30 - compiler is going to enforce for the
1152:31 - first parameter and the second parameter
1152:33 - to this function
1152:35 - to satisfy the integral concepts so if
1152:38 - you have to use auto to set up function
1152:41 - templates this is how you can use
1152:43 - concepts to constrain
1152:45 - ways in which people use your function
1152:47 - we still have another way we can use
1152:50 - concepts in c plus plus and this is how
1152:52 - you do it you specify your template
1152:54 - declaration like we have been doing all
1152:56 - along you specify your function template
1152:59 - but after the parameter list as we see
1153:02 - here you're going to put your requires
1153:05 - close and you can put that in this place
1153:07 - here and it is going to work i realize
1153:10 - these are many syntaxes to process for
1153:12 - the first time but some of these
1153:14 - syntaxes are going to work better in
1153:16 - some situations and they are there just
1153:19 - to make it flexible for you to use
1153:21 - concepts in your c plus plus code okay
1153:24 - now that we have seen different ways we
1153:26 - can set up concepts for our function
1153:28 - templates i think this big time we
1153:30 - headed over to visual studio code and
1153:32 - tried them out okay here we are in our
1153:35 - working folder the current chapter is
1153:37 - concepts the current lecture is using
1153:40 - concepts we're going to grab our
1153:42 - template files we are going to put them
1153:45 - in place
1153:46 - and we are going to open this thing in
1153:48 - visual studio code by dragging and
1153:50 - dropping on top of visual studio code
1153:53 - here we do that this is going to open
1153:55 - our folder we're going to open up our
1153:57 - main cpp file and close the sidebar here
1154:01 - and we're going to clean things up a
1154:02 - little bit and we're going to set up a
1154:04 - function template which is going to add
1154:06 - two numbers we already know how to do
1154:08 - that so we're going to say template type
1154:10 - name and it's going to have a template
1154:12 - parameter of t then we're going to set
1154:14 - up the function like we have been doing
1154:17 - all along we're going to say add we're
1154:19 - going to say t a and t b and this is
1154:22 - going to return the sum of a and b once
1154:25 - you have the function in we can go in
1154:27 - the main function and set up code that
1154:30 - would call this function and if we try
1154:32 - to compile this program it is going to
1154:34 - work now because we are not placing any
1154:37 - constraints on this function template
1154:40 - here let's try to build with gcc like we
1154:43 - have been doing all along you see it is
1154:45 - going to weld okay you see the world is
1154:47 - good world finished successfully and if
1154:50 - we want we can run this application and
1154:52 - it is going to print result a
1154:54 - result b let's take this out because we
1154:57 - haven't done this yet but it's not going
1154:59 - to print result c but if we want we can
1155:02 - really print it it's going to work so
1155:03 - let's
1155:04 - put that in and we're going to say
1155:07 - result c and print result c here and
1155:11 - world again let's world now to take this
1155:13 - into account
1155:14 - world is good we can bring up a terminal
1155:16 - to try this out and we can clear and run
1155:19 - rooster now you see result a is 30
1155:22 - because that's the sum of a and b here
1155:24 - result b should be 16 which is what we
1155:27 - have result c is 13 which is what we
1155:31 - should get by adding these two double
1155:34 - variables
1155:35 - now we wanted to constrain this function
1155:38 - to only work if somebody passes integral
1155:41 - types and when we put that constraint in
1155:44 - place it is going to work if we add up
1155:46 - two character variables because they are
1155:49 - integral types it's going to work if we
1155:52 - add up two integer variables because
1155:54 - they are integral types but once we hit
1155:57 - this guy here
1155:58 - with the double variables we should get
1156:00 - a compiler error because the constraint
1156:03 - is not satisfied let's do that we're
1156:05 - going to comment the double thing first
1156:08 - because we want to really isolate it and
1156:11 - see it and see the compiler error that
1156:13 - we get and we're going to add a
1156:14 - constraint to our function template
1156:17 - using concepts okay if you want to use
1156:20 - concepts in c plus plus 20 the first
1156:22 - thing you need to do is to include the
1156:24 - library that gives us access to concepts
1156:27 - and we're going to do that by saying
1156:28 - include concepts this is easy now that
1156:31 - we have this end we're going to use the
1156:33 - first syntax we saw in the slides and
1156:36 - we're going to add the requires close
1156:38 - after the template declaration
1156:40 - and we're going to say std integral and
1156:43 - we're going to say the template
1156:45 - parameter here i think this is the
1156:46 - syntax okay watch what happens if we do
1156:49 - this down in the code we are calling the
1156:52 - function with car types
1156:54 - and
1156:55 - integer types so this is going to
1156:57 - compile fine because the concept here
1157:00 - is satisfied this concept is going to
1157:03 - enforce for the template parameters we
1157:05 - call a function template with to be
1157:08 - integral types let's build and see if we
1157:12 - get to compile successfully you see both
1157:14 - finished good everything is going to
1157:16 - work and if we run our program we should
1157:19 - see results a and result to be printed
1157:21 - out let's run the program we see our
1157:23 - result here now we're going to comment
1157:25 - out the others and leave in the double
1157:29 - example and we're going to uncomment
1157:32 - that and i want you to see the problem
1157:33 - we get when we try to use
1157:36 - our function template with double
1157:38 - variables here you see visual studio
1157:40 - code is already complaining it is saying
1157:42 - there is something wrong if we look at
1157:44 - the problems tab is going to say no
1157:47 - instance of function template add
1157:48 - matches the argument list but this is
1157:50 - really not descriptive enough but the
1157:53 - problem is our concept is not satisfied
1157:56 - by calling our function template with
1157:59 - double types because we clearly said
1158:03 - that we want the function to only be
1158:05 - called with integral types let's build
1158:08 - our program we're going to pass this
1158:10 - through gcc
1158:12 - and we're going to get a compiler error
1158:14 - that says that some concept was
1158:16 - unsatisfied
1158:18 - and we see we see in function main
1158:21 - use of function t add with double with
1158:25 - unsatisfied constraints and this is
1158:28 - really clear when we see an error like
1158:30 - this we will go and look at the
1158:32 - constraints that the function has and
1158:35 - we're going to see if we satisfied those
1158:37 - constraints by calling
1158:39 - like we did in the main function here
1158:41 - and we will know that the function
1158:42 - doesn't support non-integral types and
1158:45 - we will fix this problem this is really
1158:48 - how concepts can help
1158:50 - in writing safer function templates now
1158:53 - that we have seen the first syntax i
1158:55 - think it is big time we looked at the
1158:57 - other syntaxes so let's do that let's
1159:00 - copy the code here because we're going
1159:01 - to be reusing this a couple of times and
1159:04 - adapt it instead of typing this entire
1159:07 - thing the second syntax involves getting
1159:10 - rid of the requires close all together
1159:12 - and just using the concept instead of
1159:16 - type name here so i'm going to say std
1159:19 - integral and this is going to be enough
1159:21 - this is going to tell the compiler to
1159:23 - enforce this concept for this function
1159:27 - call
1159:27 - for all the template parameters that go
1159:31 - in the place of t here i hope this makes
1159:33 - sense now if we go back we see that we
1159:36 - still have our squiggly lines here if we
1159:38 - try to compile we will get the same
1159:41 - compiler error okay and you see we have
1159:43 - the same compiler error function add t
1159:46 - called with unsatisfied constraints i
1159:49 - think if you go down we're going to see
1159:50 - even more stuff out of this it's going
1159:53 - to say required the satisfaction of std
1159:57 - integral with t but now we are trying to
1160:00 - call this with double so this is really
1160:03 - going to lead to a compiler error so
1160:06 - this is the second syntax and it is
1160:08 - going to do the same thing now that we
1160:10 - have seen this we also have a third way
1160:13 - we can do this and that's through the
1160:15 - auto mechanism let's set up a function
1160:18 - using auto so we're going to say auto
1160:21 - add auto a and auto b we have seen that
1160:24 - we can do that in the last chapter and
1160:26 - we're going to return a and b a plus b i
1160:28 - should say if we do this you see that
1160:31 - the squiggly line goes away and we can
1160:33 - add these things up and print the result
1160:35 - the return type is going to be deduced
1160:37 - by the compiler automatically but know
1160:40 - that this is going to generate a
1160:41 - function template behind the scenes this
1160:44 - is just a nicer syntax we have to use
1160:46 - auto to set up functions that work for
1160:48 - multiple types let's build and uh see
1160:52 - how gcc handles this the world is good
1160:55 - because we have no constraints here and
1160:57 - if we run our program it's going to work
1161:00 - it's going to give us 13 as the sum of
1161:03 - 11.1 and 1.9 but we can also place
1161:07 - constraints on this function here and
1161:09 - you do that by specifying your concept
1161:12 - in front of the auto keyword here so for
1161:15 - example we can say std integral and std
1161:18 - integral fold the second parameter here
1161:21 - let's say that and once we do this if we
1161:23 - go down we should see our squiggly line
1161:26 - on the call of the function here because
1161:28 - now the way we are calling this function
1161:31 - is not valid the function clearly says
1161:34 - that it wants to be called only with
1161:37 - arguments that satisfy this concept here
1161:41 - if we're trying to build again with gcc
1161:43 - we're going to get the semicompiler
1161:45 - error let's do that and it's going to
1161:47 - say use function with
1161:50 - unsatisfied constraints the same error
1161:52 - and if we go down we should see that it
1161:55 - requires the integral
1161:58 - concept to be satisfied here so this is
1162:01 - the third syntax you can use if you
1162:03 - happen to be using the auto syntax for
1162:06 - your function templates let's comment
1162:08 - this out because we still have another
1162:10 - syntax we need to learn about this is
1162:12 - going to be our syntax three and we're
1162:15 - going to comment this out and the last
1162:17 - one involves
1162:19 - just leaving in our function template
1162:22 - let's copy this because i don't want to
1162:23 - type this again we're going to go down
1162:26 - and say syntax form and put in our
1162:28 - function template we're going to take
1162:30 - this requires close we're going to cut
1162:32 - it out and we're going to put it after
1162:36 - the function parameter list
1162:38 - like this and this is going to be valid
1162:40 - c
1162:41 - syntax to enforce a concept on your
1162:44 - function template if we go down you see
1162:46 - we have this wiggly line and i should
1162:49 - prove that this works with other
1162:51 - integral types here let's just comment
1162:54 - out the double line here and uncomment
1162:56 - the other we had for car and ant if we
1162:59 - try to build this program now it is
1163:01 - going to work fine because the
1163:03 - constraints are satisfied but the moment
1163:06 - we uncomment the calls with double types
1163:09 - we're going to get a squiggly line which
1163:12 - is a good warning that we have a problem
1163:14 - but if we ignore the squiggly lines
1163:17 - and adjust build with gcc we're going to
1163:19 - get the same compiler error and it's
1163:22 - going to say that to call our function
1163:25 - we need to satisfy
1163:27 - the integral concept for the arguments
1163:31 - that we pass here and the double
1163:33 - arguments we're passing in here are
1163:35 - violating our concept so we get a
1163:37 - compiler error this is really how you
1163:40 - can use concepts in c plus plus i tried
1163:43 - and came up with simple examples to show
1163:45 - you different syntaxes you can use
1163:47 - concepts with
1163:49 - and this is really it try to get
1163:52 - yourself familiar with these syntaxes
1163:54 - and it's not going to be really hard to
1163:57 - use concepts in your c plus plus
1163:59 - programs okay this is really all i had
1164:01 - to share in terms of the syntaxes you
1164:04 - can use with c plus plus 20 concepts if
1164:07 - you go to the documentation you're going
1164:09 - to have more information about this but
1164:12 - we're going to do a few more lectures to
1164:14 - really drive this dancehall for now you
1164:16 - can come to cpp reference here and see
1164:19 - more concepts that you can use we have a
1164:22 - lot of this and we can really use this
1164:25 - to tune our function templates however
1164:27 - we want okay for example you see our
1164:29 - integral concepts you see a floating
1164:31 - point concepts and there are even more
1164:34 - that are usable with
1164:37 - classes but we haven't learned about
1164:39 - classes yet and we will do that starting
1164:41 - at the next chapter but now i just want
1164:43 - you to be familiar with concepts that
1164:47 - were introduced in c plus plus 20. and
1164:49 - here is another piece of documentation
1164:51 - you can look at just to complement what
1164:53 - we are talking about in this chapter but
1164:56 - i wouldn't recommend reading this just
1164:58 - yet because it's just going to confuse
1165:00 - you there is a lot of things we still
1165:02 - need to learn to really be able to
1165:04 - understand this so try to go through
1165:06 - this chapter and i am going to try and
1165:08 - break this down in ways that you can
1165:11 - understand this the main message is that
1165:13 - there are more concepts here you can try
1165:16 - in your c plus plus code if it makes
1165:18 - sense for the problem you are trying to
1165:20 - solve with c plus plus we are going to
1165:23 - stop here in this lecture in the next
1165:24 - one we're going to show you how you can
1165:26 - set up your own concepts in c plus plus
1165:29 - go ahead and finish up here and meet me
1165:32 - there in this lecture we're going to see
1165:33 - how you can build your own concepts and
1165:36 - this is going to bring us into the
1165:38 - second part of concepts we can use in c
1165:41 - plus plus in the last lecture we used
1165:44 - the concepts from the standard library
1165:46 - that are built into the c plus plus
1165:48 - programming language starting in c plus
1165:51 - plus 20. in this one we're going to be
1165:53 - building our own concepts and without
1165:56 - waiting anymore let's see how you can do
1165:59 - that and this is the syntax you can use
1166:01 - to do that and it is really simple the
1166:03 - way you do that you say a template
1166:05 - declaration specifying the template
1166:08 - parameter you want to constrain and then
1166:11 - you say concept you say the keyword
1166:13 - concept you give your concept a name you
1166:16 - put the equal sign after that and then
1166:19 - you're going to specify the requirements
1166:22 - for your concept so for example here we
1166:24 - are using a type trait to specify that
1166:28 - this type trait is going to determine
1166:31 - what works for this concept here and
1166:34 - what this is going to do is to enforce
1166:36 - for our template parameter to only be
1166:39 - integral if it's not integral we're
1166:41 - going to get a compiler error and one
1166:43 - thing i should tell you is that the std
1166:46 - integral concept is exactly built like
1166:49 - this in the c plus plus standard library
1166:51 - this is really cool so if you want to
1166:53 - set up your own concept and you want to
1166:55 - do that using typed traits you can do
1166:58 - that like this and it is going to
1166:59 - enforce for your template parameters to
1167:03 - satisfy that typed rate or to be exact
1167:06 - this concept is going to be satisfied
1167:09 - when the type trait evaluates to true if
1167:12 - the typed rate evaluates to false at
1167:14 - compile time the concept is not going to
1167:17 - be satisfied that's another way to look
1167:19 - at that down here we have another syntax
1167:21 - we can use if we have multiple
1167:24 - statements in our concept all you have
1167:26 - to do is specify the concept keyword you
1167:30 - give it a name you go to the equal sign
1167:32 - and then you add a requires close the
1167:35 - requires close is going to specify the
1167:37 - template parameters for which you want
1167:39 - to enforce your concept and then you're
1167:42 - going to put a pair of curly braces and
1167:45 - inside that you're going to specify the
1167:48 - syntax you want your concept to satisfy
1167:51 - for example here we want
1167:53 - for the two parameters to be
1167:55 - supporting the multiplication operator
1167:58 - if this multiplication operator is not
1168:00 - supported for the template parameters
1168:03 - that we passed the concept is going to
1168:05 - fail and again i should emphasize that
1168:09 - this doesn't check for the value of a
1168:11 - multiplied by b it's just going to
1168:13 - enforce from the syntax to be supported
1168:16 - so for example if you call a function
1168:18 - template with this concept and you try
1168:21 - to pass in integers it's going to work
1168:24 - because you can multiply integers but if
1168:26 - you pass two strings this is going to
1168:29 - fail because it doesn't really make
1168:31 - sense to multiply strings okay this is
1168:33 - the syntax now we only have one
1168:36 - statement to enforce inside but if you
1168:38 - want you can even put more statements if
1168:41 - you go down here we have another example
1168:42 - called incrementable this is going to
1168:45 - require for the template parameter to be
1168:48 - incrementable we specify the concept key
1168:50 - world we say the concept name we put in
1168:53 - our equal sign and then we say requires
1168:56 - we put on template parameter and put in
1168:58 - our requirements for any template
1169:01 - parameter that is using this concept the
1169:04 - syntax here must make sense so you must
1169:07 - be able to take the value that you get
1169:09 - from here and for example say i plus
1169:11 - equals one this is going to be valid
1169:13 - syntax you're going to say plus plus a
1169:16 - and plus plus b all these are going to
1169:18 - be valid c plus plus syntaxes for the
1169:21 - template parameter that you try to call
1169:23 - this function template with and if this
1169:26 - doesn't work you're going to get a
1169:27 - compiler error because your template
1169:30 - argument isn't really satisfying this
1169:32 - concept so this is really how you can
1169:34 - set up your own concepts in c plus plus
1169:37 - once you have your own concepts set up
1169:40 - you can use them like we have been using
1169:42 - the other concept from the ziploc plus
1169:44 - standard library for example we can use
1169:47 - syntax one to put a requires clues and
1169:50 - say that we want to satisfy our own
1169:53 - concept with this particular syntax you
1169:56 - will have to put in these angle brackets
1169:59 - and put your template parameter inside
1170:01 - this is the syntax you have to use you
1170:03 - can also use syntax 2 and specify my
1170:06 - integral directly in this angle brackets
1170:09 - in your template declaration and this is
1170:11 - also going to work we can even use this
1170:14 - with the auto syntax for our function
1170:16 - templates it is going to work okay now
1170:18 - that you have sent this i think it is
1170:20 - time we headed over to visual studio
1170:22 - code and play with us a little more okay
1170:24 - here we are in our working folder the
1170:27 - current project is building your own
1170:29 - concepts we're going to grab our
1170:31 - template files like we always do and
1170:34 - we're going to put them in place and
1170:35 - we're going to open this thing in visual
1170:38 - studio code let's do that we have our
1170:41 - project open here or folder i should say
1170:44 - we're going to clean this up a little
1170:45 - bit and we're going to include our
1170:47 - concepts library and we wanted to set up
1170:50 - our own concept the first syntax we're
1170:52 - going to see is by using type trades and
1170:56 - we're going to say template type name t
1170:59 - and we're going to say this concept we
1171:01 - want this template parameter to satisfy
1171:04 - we're going to say concept and we're
1171:06 - going to say my integral which is going
1171:08 - to be the name of our concept we're
1171:10 - going to put an ecosign and then we're
1171:12 - going to say
1171:14 - std integral v and specify that we want
1171:18 - this type trait to be satisfied for this
1171:21 - concept here and after this we need to
1171:23 - put in our semicolon and i think we need
1171:26 - to include the type traits library
1171:29 - because we are using that we should say
1171:32 - std is integral so sorry for this and
1171:35 - this is going to work now okay now that
1171:37 - we have the concept set up we can use it
1171:40 - like we have been using other concept
1171:43 - for example we can set up a function
1171:45 - which is going to add up two numbers and
1171:47 - it is going to use this concept here we
1171:50 - have multiple syntaxes we can use so
1171:52 - let's go down and try this out we're
1171:54 - going to say template and say type name
1171:56 - t and we're going to require this
1171:59 - concept to be satisfied for our function
1172:02 - template we saw that we could use the
1172:04 - requires close here and say my integral
1172:07 - and say the template parameter we want
1172:10 - to enforce this on and after this we're
1172:12 - going to just put in our function
1172:14 - template we're going to say add what we
1172:16 - have been doing all along in the last
1172:18 - lecture we're going to say t a
1172:20 - and t b and we're going to return a plus
1172:23 - b now this function is going to support
1172:26 - our concept let's go down and set up two
1172:28 - variables we're going to say and x
1172:31 - and we're going to say 6 for example and
1172:33 - into y and i'm going to make this a 7
1172:36 - why not and we're going to say add
1172:39 - x and y once we do this you see that we
1172:41 - have no problem because the concept is
1172:43 - satisfied for the arguments that we are
1172:46 - passing in here the concept is satisfied
1172:49 - because the type trait here is going to
1172:52 - return true for this type here because
1172:54 - it is an integral type when the type
1172:57 - trait returns true then the concept is
1172:59 - going to be satisfied if the type trait
1173:01 - returns false the concept is going to
1173:04 - fail let's try and bolt and really drive
1173:06 - this home you see that the world is good
1173:08 - our function is working so the function
1173:11 - template and stands for this code here
1173:13 - is going to be successfully generated
1173:15 - and we're going to call it when the
1173:17 - program runs
1173:19 - now let's change the type of these guys
1173:21 - to double and try to violate our concept
1173:24 - and make it fail once we do this you see
1173:26 - the call here has a squiggly line and a
1173:29 - visual studio code is not going to say
1173:31 - that it is a concept problem which is a
1173:34 - shame but we can still run this through
1173:36 - the compiler and the compiler is going
1173:39 - to tell us what is wrong so it's going
1173:41 - to say use of function add with
1173:44 - unsatisfied constraints and if we go
1173:47 - down we're going to see the exact
1173:49 - constraints we violated and we're going
1173:52 - to say required for the satisfaction of
1173:55 - my integral with t we are calling this
1173:57 - with double and double is going to
1173:59 - evaluate this to false hopefully you can
1174:03 - see that you can really set up your own
1174:05 - concepts using the syntax here and we
1174:08 - can use our concept with all the
1174:09 - syntaxes we have seen in the last
1174:11 - lecture so for example we can take out
1174:13 - the requires close all together here and
1174:16 - say my integral in the
1174:18 - template declaration here so we're going
1174:20 - to say my integral and if we do this
1174:23 - we're going to fail again because the
1174:25 - concept is not going to be satisfied
1174:28 - we're going to have the same problem we
1174:30 - can change the syntax to use the auto
1174:33 - syntax but before we do that let's
1174:35 - change this back to type name t and then
1174:39 - put our requires close after the
1174:42 - parameter list of our function template
1174:44 - we're going to say requires
1174:46 - and we're going to say my integral and
1174:48 - specify the template parameter and this
1174:51 - is a valid function template with a
1174:54 - concept applied to app and if we both
1174:56 - again we're going to get the same
1174:57 - compiler error so you see the same error
1175:00 - and we can use the auto syntax let's do
1175:03 - that we're going to take out the
1175:05 - template declaration here we're going to
1175:08 - take out the requires close here and
1175:10 - we're going to change our t to auto and
1175:14 - the way we do that we're going to say
1175:16 - std no no std we are using our own
1175:19 - concept so we're going to say my
1175:21 - integral auto this is going to work and
1175:24 - we're going to say my integral auto and
1175:26 - my integral auto here the moment we do
1175:29 - this you see that we have squiggly lines
1175:31 - here because our concept is violated but
1175:34 - if we're trying to build again we're
1175:36 - going to use gcc to do that the build is
1175:38 - going to fail you see that the same
1175:40 - concept is violated and we are able to
1175:43 - use our concept throughout the four
1175:46 - syntaxes that we saw in the last lecture
1175:49 - and this is really cool now that we have
1175:50 - this we're going to comment this out and
1175:53 - we're going to see that we can set up
1175:55 - concepts that have requirements spanning
1175:58 - multiple statements or multiple lines
1176:01 - okay let's go down and do that suppose
1176:03 - we want to set up a concept that is
1176:05 - going to enforce for the templates
1176:07 - parameters to be multipliable
1176:10 - with the multiplication operator we have
1176:13 - here we can use this syntax here we're
1176:15 - going to put in our template declaration
1176:17 - we're going to say concept we're going
1176:19 - to say the concept name we're going to
1176:20 - put in an equal sign and then we're
1176:22 - going to put in a requires close
1176:25 - with our template parameters and and
1176:28 - after that we're going to put a pair of
1176:30 - curly braces and inside the curlies
1176:33 - we're going to put the requirements for
1176:35 - example in this case we require for the
1176:38 - template parameter here to support the
1176:41 - multiplication operator between two of
1176:43 - these types if the multiplication
1176:45 - operator is not supported we're going to
1176:48 - have a problem and that this is the
1176:49 - concept that is going to enforce that
1176:52 - one thing you should know is that this
1176:54 - is just going to check
1176:56 - that multiplying a and b is valid syntax
1177:00 - it's not going to check the value of a
1177:02 - multiplied by b and you should really
1177:04 - understand this now that we have this n
1177:07 - we can set up a function to use these
1177:09 - two guys why not use the function we
1177:12 - have seen before to add two numbers
1177:14 - let's do that and we're going to put in
1177:16 - our requires close and we're going to
1177:18 - require now to support the multipliable
1177:22 - concept and we're going to specify our
1177:24 - template parameter we have the concept n
1177:27 - so we can use that to do whatever we
1177:30 - want now we're going to say t
1177:32 - add and we're going to say t a and t b
1177:35 - and we're going to return a plus b this
1177:38 - is the same function we've been using
1177:40 - all along okay now we have our concept
1177:42 - in place and we have a function template
1177:45 - that is going to use this concept
1177:47 - let's see if we can add up x and y and
1177:51 - see what we get we're going to world
1177:53 - with gcc we're going to see that the
1177:55 - world is going to be good because our
1177:57 - concept here is satisfied we are passing
1178:01 - double types for our function template
1178:03 - and it is legal to multiply two double
1178:06 - variables if we multiply two doubles
1178:08 - we're going to get a value and that's
1178:10 - going to be valid c plus plus syntax but
1178:12 - let's see what happens if we try to
1178:15 - change our arguments to hdd strength
1178:17 - let's do that so we're going to say x is
1178:20 - hello and we're going to say why is
1178:22 - world why not let's go down and put in a
1178:25 - semicolon and the moment we do that you
1178:27 - see that we have a problem and visual
1178:30 - studio code is not good at this yet
1178:34 - but if we go inside
1178:36 - and run this through gcc we're going to
1178:38 - get that our concept is violated let's
1178:42 - look at the compiler error here it's
1178:44 - going to say constraints not satisfied
1178:47 - and it's going to tell us that we are
1178:49 - calling the add function with the values
1178:52 - that can't be multiplied it's going to
1178:54 - say the required expression here is
1178:56 - invalid and this is how you can set up a
1178:59 - concept like this and you can really use
1179:01 - this to
1179:02 - put constraints however you want on your
1179:05 - function templates but here we have just
1179:08 - used one statement inside our concept
1179:11 - here we can even put in more so to drive
1179:13 - this home we're going to set up another
1179:15 - concept let's go down and put that in
1179:17 - place the concept is going to be called
1179:20 - incremental it's going to be using the
1179:22 - same syntax we saw here but we're going
1179:24 - to be putting a requirement on the
1179:26 - template parameter here to support
1179:29 - incrementation and we want for every
1179:32 - type that goes in the place of t here we
1179:34 - must be able to say a plus equals one
1179:37 - this must be valid c plus plus syntax we
1179:40 - must be able to say plus plus a this
1179:42 - must be valid c plus plus syntax and we
1179:45 - must be able to say a plus plus this
1179:47 - must be valid c plus plus syntax
1179:50 - now that we have this we can change our
1179:53 - add function to use this concept why not
1179:56 - we're going to say incrementable and now
1179:58 - this function is going to be required to
1180:01 - use things that we can increment on and
1180:04 - you see it is failing already because we
1180:06 - can't really increment strengths what
1180:08 - does that even mean so let's build and
1180:10 - show you the compiler error okay you see
1180:13 - incremental is not satisfied and that
1180:16 - the required expressions aren't valid
1180:18 - you see plus plus a is not valid a plus
1180:21 - plus is not valid and a plus equals one
1180:25 - should not also be valid but we're not
1180:28 - seeing that here but hopefully you see
1180:30 - the message here that our concept is
1180:33 - failing here if we comment out our
1180:36 - strengths here and uncomment double all
1180:39 - these operations we have here are
1180:40 - supported for the double type
1180:43 - so we should not fail here if we try to
1180:46 - compile this because the concept is
1180:49 - going to be satisfied
1180:50 - let's use the gcc
1180:53 - compiler to build you see the build is
1180:55 - good now
1180:56 - and we can clear and we can bring up a
1180:58 - terminal to really see this that our
1181:01 - binary was generated let's do the ir
1181:04 - we're going to see our rooster
1181:06 - executable here and if we go down let's
1181:08 - say done we're going to see that if we
1181:10 - build again to bring this in
1181:13 - consideration clear run rooster the
1181:15 - program was generated and it is really
1181:18 - running because the concept here
1181:21 - is satisfied
1181:23 - with our call using double arguments
1181:27 - here okay so this is really all i set
1181:30 - out to share with you guys in this
1181:32 - lecture i hope you know the syntaxes you
1181:34 - can use to create your own concepts you
1181:37 - can either use type traits like we have
1181:39 - seen here and the syntax is to put the
1181:41 - keyword concept put in your concept name
1181:45 - put an ecosign and then specify your
1181:47 - type trait here this is going to work if
1181:50 - you need something a little more
1181:51 - complicated then you're going to use
1181:53 - this syntax here and put the
1181:55 - requirements for your concept in these
1181:59 - curly braces you can either put one
1182:01 - statement like we did here or you can
1182:04 - even put as many statements as you want
1182:07 - just remember to end them with
1182:08 - semicolons and another thing you
1182:10 - shouldn't really take lightly is that
1182:13 - this is just going to check for syntax
1182:16 - it's not going to check for the value
1182:18 - you get after you add one to a here for
1182:21 - example it's not going to check for the
1182:23 - value you get after you multiply b it's
1182:25 - just going to see that a multiply b
1182:28 - is valid syntax for the types that our
1182:32 - template parameter is using here we are
1182:35 - going to stop here in this lecture this
1182:37 - one we're going to zoom in a little more
1182:40 - on the requires close here go ahead and
1182:43 - finish up here
1182:44 - and meet me there in this lecture we're
1182:46 - going to learn about some more things we
1182:49 - can do with our requires close but
1182:52 - before we do that let's look at the
1182:54 - kinds of requirements we can put in our
1182:57 - requires close the first one is a simple
1183:00 - requirement which is what we have seen
1183:02 - so far we can also do a nested
1183:04 - requirement and we're going to learn
1183:06 - about this in a minute and we can do a
1183:08 - compound requirement which is going to
1183:10 - allow us to specify more things about
1183:13 - what we require for our concept there
1183:16 - are also type requirements but these are
1183:19 - really advanced for the scope of this
1183:21 - course so we're not going to talk about
1183:22 - these in this course what we're going to
1183:24 - look at are these three first here so
1183:27 - let's look at a simple requirement this
1183:30 - is what we have seen already here we
1183:32 - have our template declaration we have a
1183:35 - concept declared the concept name is
1183:38 - tiny type we're going to put in our
1183:40 - requires close we're going to put in our
1183:42 - parameter list and we're going to put in
1183:45 - our curly braces inside the requires
1183:48 - close we have a statement here which is
1183:50 - going to enforce that size of t is less
1183:54 - than 4.
1183:55 - and what this really means it's going to
1183:58 - check that size of t the syntax here is
1184:01 - correct and this can really throw people
1184:04 - off i have said this in the last lecture
1184:06 - but i set up this little example to
1184:09 - really drive this home and show you that
1184:11 - if you are not careful your concepts are
1184:14 - going to be really wrong this is going
1184:16 - to check for the syntax so for example
1184:19 - if we call a function template with this
1184:22 - concept with a car type
1184:25 - the concept is going to be satisfied
1184:27 - even if the size of the car is less than
1184:30 - 4 obviously but that's not going to be
1184:32 - the job of this concept here this
1184:34 - concept is not going to enforce for the
1184:37 - expression here to evaluate to true it's
1184:40 - going to just check the syntax and if
1184:42 - you pass something smaller than a net in
1184:45 - a function template with this concept
1184:48 - this is going to be valid c plus plus
1184:50 - syntax so the concept is going to work
1184:53 - so now you must be asking how can i
1184:55 - enforce for the value of this expression
1184:58 - to be true
1185:00 - using concept well for that you will
1185:03 - have to use nested requirements and a
1185:06 - nested requirement is going to have
1185:08 - another requires keyword inserted in
1185:11 - front of it now if you use the syntax
1185:14 - like this now this is going to check
1185:16 - that size of t is actually less than 4.
1185:19 - if it's not less than 4 this is going to
1185:22 - return false here and the concept is
1185:24 - going to fail and this is how you can
1185:26 - use nested requirements to enforce for
1185:29 - some expressions to be true in your
1185:31 - requires close another kind of
1185:33 - requirement you can set up for your
1185:35 - concept is the compound requirement and
1185:38 - this is going to allow you to check if
1185:41 - something doesn't throw an exception you
1185:43 - can do that using the no accept keyword
1185:46 - but we're not going to use this now
1185:48 - because this is not in scope for what we
1185:50 - can do at this point in the course but
1185:53 - you can also check the return type of an
1185:56 - expression and divorce that it satisfies
1185:59 - some type trait for example so here we
1186:02 - are saying for our concept and if we
1186:05 - pass in two parameters the syntax for
1186:08 - adding a and b must be correct and
1186:11 - supported for those types but the result
1186:14 - of a and b must also be convertible to
1186:18 - ant and you can do something like this
1186:20 - and this is going to work you can
1186:21 - enforce these kinds of things using
1186:23 - compound requirements okay now that you
1186:26 - know about these kinds of requirements
1186:28 - you can put in your requires close let's
1186:31 - head over to visual studio code and play
1186:34 - with us a little more okay here we are
1186:36 - in our working folder the current
1186:38 - project is zooming in on requires close
1186:41 - we're going to grab our template files
1186:43 - and we're going to put them in place and
1186:46 - we're going to open that in visual
1186:47 - studio code pretty quick by dragging and
1186:50 - dropping here this is going to open up
1186:52 - our folder we're going to do the usual
1186:54 - we're going to close the pane here we're
1186:56 - going to clean things up a little bit
1186:59 - and we're going to include our concepts
1187:01 - library let's do that we are going to
1187:03 - set up a simple concept we're going to
1187:05 - say template and we're going to say what
1187:07 - the concept is the concept is going to
1187:10 - be called the tiny type and we're going
1187:12 - to say
1187:13 - what makes this concept a tiny time
1187:16 - we're going to put in our requires close
1187:19 - and we're going to put in the template
1187:21 - parameter call it t why not and we're
1187:23 - going to put in our closing semicolon
1187:25 - here now what is going to make this
1187:28 - concept a tiny type is that the size of
1187:31 - the template parameter view is going to
1187:33 - be less than four let's suppose we are
1187:35 - doing the function and we wanted to use
1187:37 - for
1187:38 - integral types that are smaller than
1187:41 - four bytes in memory suppose you want to
1187:43 - do this and it is useful
1187:45 - in the problem that you are trying to
1187:47 - solve in c plus plus the way we can
1187:49 - enforce this we can say size of t is
1187:52 - supposed to be less than four let's say
1187:55 - size of properly can't type can i okay
1187:57 - the moment we do this you're going to
1187:59 - see that this is valid c plus plus
1188:01 - syntax so we're not going to have any
1188:03 - squiggly lines but what you should know
1188:06 - is that this is a simple requirement in
1188:08 - c plus plus concepts and what this is
1188:11 - going to do
1188:12 - it's just going to enforce the syntax of
1188:15 - what we do here what we put here must be
1188:17 - valid c plus plus syntax so only
1188:20 - enforces syntax this is what you should
1188:22 - really remember okay now that we have
1188:24 - this end let's try it out and show you
1188:27 - some problems you can really run into
1188:30 - we're going to set up two character
1188:31 - variables we're going to call the first
1188:33 - one x we're going to initialize this
1188:35 - with 57 why not 67 and we're going to
1188:39 - put in the other variable which is going
1188:41 - to be y and it's going to have a 56 n
1188:44 - you can put in whatever you want just
1188:47 - make sure that you are within the range
1188:49 - of the card type which is between 0 and
1188:51 - 255 if you remember okay now that we
1188:54 - have this n i realize we don't have a
1188:56 - function we can try this on let's set up
1188:59 - another function pretty quick we're
1189:01 - going to say tiny type auto we can do
1189:03 - that you already know this syntax and
1189:06 - we're going to say add tiny type auto a
1189:09 - and a tiny type auto p we can do that
1189:12 - and we're going to return a plus b now
1189:15 - that we have this let's say a and b down
1189:18 - here and call this function we're going
1189:19 - to say x and y and we're going to try
1189:22 - and compile this program and it is going
1189:24 - to compile fine because the type we are
1189:26 - using to call the function which is car
1189:29 - its size is going to be less than four
1189:31 - okay so this is going to work and it is
1189:33 - going to compile
1189:34 - let's build with gcc you're going to see
1189:36 - that the build is good let's try and uh
1189:40 - change the type here to end or even
1189:42 - double you know double is 8 bytes in
1189:45 - memory so we expect this to probably
1189:47 - give us something wrong double type is
1189:49 - eight bytes in memory so we expect the
1189:52 - size of t here
1189:54 - to be false because the size of t is
1189:57 - going to be eight and eight is not less
1189:59 - than four this is going to be false so
1190:02 - some might expect this concept here to
1190:04 - fail
1190:05 - but let's try and really prove you wrong
1190:08 - we're going to build with gcc and you
1190:11 - see it's building successfully what this
1190:13 - is really doing is that with simple
1190:16 - requirements like we have here c plus
1190:19 - plus is only going to enforce for this
1190:21 - to be valid c plus plus syntax and size
1190:24 - of t is less than four
1190:26 - is going to be valid c plus plus syntax
1190:29 - even if this expression here evaluates
1190:32 - to false this is not going to enforce
1190:34 - for the value of this expression to be
1190:36 - false you can't do that with simple
1190:38 - requirements what you will do is check
1190:41 - that this is valid syntax now what do we
1190:44 - do if we really want to enforce that
1190:46 - size of t should be
1190:48 - less than four if you want that you
1190:50 - should use nested requirements and the
1190:53 - syntax to do that is really simple we
1190:55 - can go down here and put that in we're
1190:58 - going to say requires we're going to add
1191:00 - a requires keyword in front of this then
1191:02 - we're going to put our expression here
1191:04 - let's copy it and put it in i don't want
1191:06 - to type this again the moment we do this
1191:09 - now compilation is going to fail if we
1191:12 - pass a type whose size is not less than
1191:15 - four
1191:16 - and let's try and build again you're
1191:18 - going to see that the world is going to
1191:20 - fail now and we're going to have a
1191:22 - failed concept and you see world
1191:24 - finished with errors we have constraints
1191:27 - not satisfied and if we go down here
1191:29 - we're going to see required for the
1191:31 - satisfaction of tiny type auto and we
1191:34 - passed in a double type whose size is 8
1191:37 - bytes in memory and it is less than four
1191:40 - bytes you see the requirement here it is
1191:43 - not satisfied we can do this using
1191:46 - nested requirements okay if we go down
1191:49 - for example and change this to car some
1191:51 - people call this char but i call this
1191:54 - car that's my habit if we change this to
1191:56 - car
1191:57 - and try to bolt again you're going to
1191:59 - see that it is going to weld fine
1192:01 - because now what is wrong here let's see
1192:04 - what we got wrong huh we are getting a
1192:07 - compiler error here what is the problem
1192:10 - it's going to say
1192:11 - let's go up and try to analyze this a
1192:14 - little bit it's saying deduce the return
1192:17 - type does not satisfy placeholder
1192:19 - constraints
1192:21 - and we are requiring for the return type
1192:23 - of this guy to be tiny time uh-huh i
1192:25 - think i know what the problem is the
1192:28 - problem is the arithmetic operations
1192:30 - like the addition we're doing here are
1192:32 - not supported for types which are
1192:35 - smaller than ant and is the smallest
1192:37 - type we can use with arithmetic
1192:40 - operations so what the compiler is going
1192:42 - to do is going to do implicit
1192:44 - conversions from car to end and inside
1192:47 - here what we will have are going to be
1192:49 - ant the result of this is going to be
1192:52 - ant and the return type is going to be
1192:54 - deduced to be at but ant
1192:56 - is going to violate the requirement we
1192:59 - have here which is saying that the size
1193:01 - of tiny type here should be less than
1193:04 - four and the return of ant is not less
1193:06 - than four so we can try and fix this by
1193:09 - putting an equal sign here and i think
1193:12 - it's going to work let's do that and
1193:14 - world again this is a good learning
1193:16 - experience and now you see that the
1193:18 - build is going to work because now the
1193:20 - return type is going to satisfy our
1193:22 - requirements so let's prove that we are
1193:25 - getting a net out of this actually we're
1193:27 - going to do our own result and we're
1193:29 - going to say equal and grab the result
1193:31 - of this guy we should really prove these
1193:33 - thanks and after this we're going to
1193:36 - print the results we can do that and we
1193:38 - can even go further and print the size
1193:41 - of result here so we're going to say
1193:43 - size of result okay now that we have
1193:46 - this end we can weld with gcc and the
1193:49 - world is good don't mind this squiggly
1193:52 - line it is probably visual studio code
1193:55 - messing with us you see that the world
1193:56 - is good we can now bring up a terminal
1194:00 - and run this and see the size of the
1194:03 - return type and really prove
1194:05 - that the compiler turned that into an
1194:07 - end even if we called our function with
1194:10 - car arguments this is interesting so
1194:13 - clear and run rooster now we're going to
1194:15 - see results is going to be 123 and the
1194:18 - size of the result is for even if we
1194:21 - passed in car types as our arguments
1194:24 - okay so hopefully this proves that you
1194:26 - can set up nested requirements to
1194:29 - enforce for the expression here to be
1194:31 - checked another type of requirement you
1194:33 - can do is a compound requirement let's
1194:36 - put this in and we're going to put in a
1194:38 - simple example to drive this home i
1194:40 - think i should take this function and
1194:42 - put that below our concepts so a
1194:46 - compound requirement looks like this you
1194:48 - put your expression in acrylics like
1194:51 - this and then you can even put
1194:53 - requirements on the values of the
1194:56 - expression for example we can enforce
1194:58 - that the value of a plus b here should
1195:00 - be convertible to and if it's not
1195:03 - convertible to end the concept here is
1195:05 - going to fail this is a compound
1195:08 - requirement you can even put no except
1195:10 - keywords in here but we're not going to
1195:13 - go this far because we haven't really
1195:15 - learned about exceptions so for now i'm
1195:18 - going to test this out i just wanted you
1195:19 - to be aware that you can do that now
1195:22 - that we have this concept n let's play
1195:24 - with it and see how we can make it break
1195:26 - thanks we're going to change our concept
1195:29 - to edible let's say edible here and
1195:31 - we're going to say edible and we're
1195:33 - going to
1195:34 - put in our car types here and it is
1195:36 - going to slay work because
1195:39 - we can add two car variables and this is
1195:42 - going to work because we can add two car
1195:44 - variables and this is valid syntax what
1195:47 - we're going to get out of that is going
1195:48 - to be an ant because remember the
1195:50 - compiler is going to insert implicit
1195:52 - conversions from card to end because it
1195:55 - can't really add two card types and is
1195:58 - the smallest thing you can do arithmetic
1196:01 - operations on so the result of this is
1196:04 - going to be an end so a lens is
1196:06 - convertible to an edge this is going to
1196:07 - work let's build and show you that this
1196:10 - is going to work we're going to weld
1196:12 - this with the gcc you see build is good
1196:15 - we can try and run this and see what we
1196:17 - get after calling the function we get
1196:20 - result is 123 and this is going to be
1196:23 - the size of four because we get a net
1196:25 - out of this let's try and change this to
1196:27 - double and see what we get so double
1196:29 - let's say double here and if we would we
1196:32 - expect this to work because adding up
1196:34 - two doubles is going to give you a
1196:36 - double
1196:37 - and we're going to return a double from
1196:39 - this function
1196:40 - and uh a double is convertible to a net
1196:43 - so we're going to return a double from
1196:45 - this guy and this should say eight now
1196:48 - because that's what we are returning
1196:49 - from the function here let's build with
1196:51 - gcc you see the both is good we can
1196:54 - clear and run rooster this is going to
1196:56 - say size of result is eight because now
1197:00 - what we are returning is going to be a
1197:01 - double from this function here and
1197:04 - double satisfies our concept adding up
1197:07 - two doubles is valid syntax and what we
1197:10 - get out of that is going to be a double
1197:12 - and a double is convertible to a net
1197:14 - this is going to work let's try and
1197:16 - change our parameters here to strength
1197:19 - we're going to comment out our x and y
1197:21 - variables here and we're going to set up
1197:23 - two strings going to say std string x
1197:26 - and we're going to say hello and you
1197:28 - know what we're going to say and why
1197:30 - we're going to say std strength y
1197:33 - and we're going to say world why not and
1197:35 - the moment we do this you see that we
1197:37 - have a problem why do we have a problem
1197:40 - because it is now a requirement for the
1197:44 - result of a and b to be convertible to
1197:46 - end remember that you can add up two
1197:48 - strands for example you can say auto s
1197:51 - and say x plus y this is going to work
1197:55 - because you can add up two strings and
1197:57 - this is going to concatenate them so
1197:58 - this is valid syntax why are we failing
1198:02 - here because we have a requirement for
1198:04 - this to be convertible to an end and the
1198:07 - strength isn't really convertible to an
1198:09 - end so this is going to fail let's build
1198:12 - this program and show you that this is
1198:14 - actually the case we're going to see
1198:16 - world finished with arrows and let's see
1198:20 - the error we have okay so constraints
1198:22 - not satisfied it's going to say required
1198:25 - the satisfaction of audible with auto
1198:28 - here in requirement and it's going to
1198:30 - say
1198:31 - a plus b does not satisfy the type
1198:34 - requirement because what we get after
1198:36 - adding a and b is not convertible to an
1198:39 - end and you see that here
1198:42 - a plus b convertible to an end this is
1198:44 - going to fail okay so let's try and
1198:47 - remove this requirement to convert to
1198:50 - end and see that this actually works
1198:52 - we're going to remove this i'm going to
1198:54 - cut this out
1198:56 - and try to build again i am going to use
1198:58 - gcc to build and now you see that this
1199:00 - is welding because we no longer
1199:03 - have the requirement of the return value
1199:06 - of this expression or result i should
1199:08 - say the result of this function
1199:11 - now doesn't have to be convertible to an
1199:13 - okay let's put this back because i want
1199:15 - you to see this later as a reference and
1199:17 - now you know how you can use compound
1199:19 - requirements to really put constraints
1199:22 - on your function templates this is
1199:25 - really all we set out to do in this
1199:27 - lecture i hope you found it interesting
1199:29 - i think i should comment out these guys
1199:32 - because i don't like to leave you with
1199:35 - code that has compiler errors let's turn
1199:37 - this back to double so that this works
1199:39 - we're going to weld again okay the world
1199:41 - is good and we are going to stop here in
1199:44 - this lecture in the next one we're going
1199:45 - to see how we can combine concepts and
1199:48 - do some crazy things
1199:50 - go ahead and finish up here and meet me
1199:52 - there in this lecture we're going to see
1199:54 - how we can combine concepts using
1199:57 - logical operators we can combine
1200:00 - concepts using the and operator and the
1200:03 - r operator as you see here let's look at
1200:06 - a simple example here we have a concept
1200:09 - it is time type we have seen before and
1200:12 - it's going to check that the size of the
1200:14 - template parameter we pass is less than
1200:17 - four it's going to enforce the syntax
1200:19 - with a simple requirement but it's also
1200:21 - going to enforce for the value of this
1200:23 - expression to be true if the value is
1200:25 - not true the concept is going to fail
1200:28 - and we are using a nested requirement
1200:30 - for this so this is our concept here
1200:33 - let's try and set up a function and see
1200:35 - how we can combine this concept with
1200:38 - other concepts here we have a function
1200:41 - it is going to return a t the name of
1200:43 - the function is func it is taking in our
1200:45 - parameter and here we have the body of
1200:48 - the function within these two curly
1200:50 - braces but what we have here is a
1200:52 - concept we want to apply to this
1200:55 - function here and the first line here is
1200:58 - going to show that we can combine the
1201:00 - concept
1201:01 - like we do here so this entire thing is
1201:03 - going to be a logical combination of
1201:06 - concepts so we can require that the
1201:09 - template parameter be either an integral
1201:11 - type or a floating point type using the
1201:14 - or operator here another thing we can do
1201:17 - is use the and operator as you see down
1201:20 - here in the second line and we're going
1201:22 - to require that
1201:24 - the
1201:24 - template parameter is both integral and
1201:28 - a tiny type and the compiler is going to
1201:30 - enforce these things as we are about to
1201:33 - see in a minute when we hit visual
1201:35 - studio code you can even specify your
1201:37 - concepts in place for example the third
1201:40 - line here is going to say we require for
1201:43 - the concept to be integral so it should
1201:46 - be an integral type and we're going to
1201:48 - specify our tiny type concept in place
1201:51 - you see we are doing that right here in
1201:54 - the function declaration and this is
1201:56 - going to work this is a valid c plus
1201:58 - plus syntax but i don't recommend this
1202:01 - because this is going to make your
1202:02 - function declarations really ugly so now
1202:05 - that you know this we're going to head
1202:07 - over to visual studio code and play with
1202:08 - this a little more it's just using the
1202:11 - or and and operator to combine concepts
1202:14 - okay here we are in our working folder
1202:16 - the current project is combining
1202:18 - concepts we're going to grab our
1202:21 - template files pretty quick and put them
1202:23 - in place and we're going to open this in
1202:25 - visual studio code as we always do by
1202:28 - dragging and dropping here we have our
1202:30 - file we're going to open that up and
1202:32 - close the left pane here i don't like it
1202:34 - and we're going to include our concepts
1202:37 - library let's do that we have this and
1202:40 - the first thing we're going to do is to
1202:41 - put in our tiny type concept here so it
1202:44 - is tiny type it's going to require that
1202:47 - the syntax for the size of t less than
1202:49 - 4b supported this is a simple
1202:51 - requirement again and we're going to
1202:53 - require that this expression be true and
1202:56 - we're doing this
1202:57 - using a nested requirement okay now that
1203:00 - we have this concept we can combine this
1203:02 - with other concepts let's use the same
1203:05 - function we've been using all along so
1203:07 - we're going to say template type name
1203:09 - team and we're going to put in our
1203:12 - requires clause so we're going to say
1203:14 - requires we can use std intergroup and
1203:17 - say t
1203:18 - and say or it should be htd floating
1203:22 - point i think we have this end this is a
1203:24 - concept we have which is built into the
1203:28 - c plus plus standard library we can use
1203:30 - this now that we have this we can then
1203:32 - say the signature of a function t x is
1203:35 - going to add up t a and t b and it's
1203:38 - going to return the sum of a and b now
1203:40 - you can only call this function with
1203:42 - either integers or floating points if
1203:45 - you try to deviate from this the concept
1203:47 - is going to fail and we're going to get
1203:49 - a compiler error let's go down and try
1203:51 - this out we're going to say and x and
1203:54 - put in a 6 for example and into y and
1203:57 - put in a 4 and we're going to add this
1203:59 - up we're going to say add x and y and if
1204:02 - we do this this is going to work because
1204:04 - this is an integer so the concept here
1204:06 - is going to succeed let's weld with gcc
1204:09 - and show you that the build is good the
1204:11 - world is good so no problem we can
1204:13 - change this to double it is going to
1204:15 - work because double is a floating point
1204:17 - let's say double properly and if we blow
1204:20 - it again the bullet is going to go
1204:22 - through but if we try and use for
1204:25 - example a strength let's say std
1204:27 - strength string that's a strength and
1204:30 - we're going to change this into double
1204:32 - quotes we can do that and say std
1204:35 - strength and i put this in quotes again
1204:39 - double quotes okay if we do this you see
1204:42 - we have a squiggly line and if we walk
1204:44 - we're going to have violated our concept
1204:48 - because the parameters that we pass
1204:50 - don't satisfy this concept it's neither
1204:53 - an integral type or a floating point
1204:55 - type and if we go up here we're going to
1204:58 - see that we have violated a concept
1205:01 - constraint not satisfied and it's going
1205:03 - to say the concept that was not
1205:06 - satisfied here which is right here okay
1205:09 - you can combine two concepts using the
1205:11 - or operator but we can also use the and
1205:13 - operator
1205:14 - let's go down and try and put up a
1205:16 - simple example that is going to do that
1205:18 - now what we're going to require for
1205:21 - people to use this function is to
1205:23 - satisfy
1205:24 - both tiny type and integral so we're
1205:27 - going to say requires std integral i
1205:30 - think we have this n and we're going to
1205:32 - say and
1205:33 - tiny time and we're going to say our
1205:35 - template parameter here the moment we do
1205:38 - this and let's turn this back to being
1205:40 - at let's say ant x and put in a seven
1205:44 - what we had before and at y and let's
1205:46 - say four or a five doesn't matter
1205:49 - if we do this
1205:51 - let's see our thing again so tiny type
1205:54 - requires for the size to be less or
1205:57 - equal
1205:58 - to four so ant is going to work this is
1206:00 - going to build because the concept is
1206:02 - going to be satisfied it is both
1206:04 - integral and tiny type
1206:07 - let's work and see this run you see the
1206:10 - world is good our concept is satisfied
1206:13 - but the moment we try and use something
1206:16 - that is greater than four
1206:18 - we're going to have a problem
1206:20 - let's use a double for example we're
1206:23 - going to change this to double and world
1206:26 - we expect compilation to fail because
1206:29 - the type which is double doesn't satisfy
1206:32 - the tiny type concept and we're going to
1206:34 - see that here okay so we're going to see
1206:36 - weld finished with arrows and we're
1206:39 - going to have a lengthy error here but
1206:41 - the meat of this is that we have a
1206:44 - constraint which is not satisfied
1206:47 - and it is
1206:48 - that for required for the satisfaction
1206:51 - of std integral so double is not going
1206:55 - to satisfy this i think double was a
1206:57 - really bad example because it's not
1206:59 - integral so integral is going to fail
1207:01 - what if we pass in long ant okay which
1207:04 - is really
1207:05 - an integral type but it's not going to
1207:07 - satisfy tiny type so let's say long end
1207:10 - and we're going to build now we are
1207:12 - going to violate let's use long long ant
1207:15 - because i think long end is not large
1207:18 - enough so we're going to build now we're
1207:20 - going to fail because tiny type is not
1207:23 - satisfied you see required for a
1207:25 - dissatisfaction of tiny type and it's
1207:27 - going to say size of t is less than 4 is
1207:31 - not satisfied because guess what the
1207:34 - size of lung lung ant is greater than 4.
1207:37 - you can try and prove that by taking out
1207:40 - this guy here and saying stdc out size
1207:44 - of a long long end we're going to see
1207:47 - this print out
1207:49 - and if we're boiled now we're not going
1207:50 - to violate our concepts because we're
1207:52 - not calling the function
1207:54 - the word is going to be good what we
1207:56 - want to do is run the program and see
1207:58 - the size of lung lung ant we can do this
1208:01 - rooster eight the size of lung lung ant
1208:05 - is eight and it is going to violate our
1208:08 - tiny type concept okay you can do things
1208:11 - like this and combine the concepts but
1208:13 - we can even put our concepts in place we
1208:16 - can do something crazy and for example
1208:19 - say let's copy this and we're going to
1208:21 - go down and say requires integral but
1208:24 - we're going to put timely type in place
1208:27 - for example we're going to grab the
1208:28 - requires close here and copy it
1208:31 - and put that in place of tiny type here
1208:33 - we're going to do this
1208:35 - and you're going to see that this is
1208:36 - going to be valid c plus plus syntax if
1208:39 - we take out the semicolon because it
1208:41 - shouldn't be there but look at this this
1208:43 - is really ugly this is going to make
1208:45 - your functions really hard to read but
1208:48 - it is going to work exactly the same way
1208:50 - it did if we call this function we're
1208:52 - going to violate tiny type let's do that
1208:55 - we're going to build with gcc we have an
1208:57 - error let's bring this up so that we can
1209:00 - see what is wrong nested requirement
1209:02 - size of t is not satisfied this is a
1209:05 - syntax you can use but i don't really
1209:08 - recommend this because this is going to
1209:10 - make you code hard to read and this is
1209:12 - really all we set out to do in this
1209:14 - lecture looking at how we can combine
1209:16 - our concepts using the and operator and
1209:20 - the or operator and you can really use
1209:22 - this in all the syntaxes for concepts we
1209:26 - have seen but i just used this in this
1209:28 - lecture because it is simpler to show
1209:30 - we are going to stop here in this
1209:32 - lecture the next one we're going to look
1209:34 - at concepts and auto go ahead and finish
1209:37 - up here and meet me there in this
1209:39 - lecture we're going to zoom in on
1209:41 - concepts and the auto key world we have
1209:44 - already seen that we can do something
1209:46 - like this use the auto keywords with our
1209:48 - functions and let the compiler generate
1209:51 - a function template behind the scenes
1209:53 - and this worked pretty well we could use
1209:55 - this syntax to put constraints on our
1209:58 - other keywords and we saw that the
1210:00 - compiler could actually enforce this and
1210:03 - throw a compiler error if our concept
1210:05 - here is violated what i haven't shown
1210:08 - you is that you can even enforce
1210:11 - concepts on variables that you declare
1210:13 - you can do something like this set up a
1210:15 - variable say auto x and call the
1210:18 - variable x and enforce for the variable
1210:21 - to be an integral type i don't really
1210:23 - think you have much use for this because
1210:26 - once you call the function and assign a
1210:29 - value to a variable you already have an
1210:31 - idea of what is going to come out of the
1210:34 - function but if you have a use case for
1210:36 - something like this please go ahead and
1210:38 - use this it is going to enforce your
1210:40 - concepts you can even use concepts like
1210:43 - this set up a variable and assign a
1210:45 - literal to the variable name using the
1210:48 - auto keyword here but i personally find
1210:51 - this useless because you are putting in
1210:54 - the value yourself
1210:55 - why do you want to put a protection if
1210:58 - you know that you are putting in a
1211:00 - double literal then the variable should
1211:02 - be a double type i find this a little
1211:05 - bit useless but it is supported in c
1211:07 - plus plus if you have a use case for
1211:09 - this please go ahead and use this now
1211:11 - that you know this we're going to head
1211:13 - over to visual studio code and play with
1211:15 - us a little more okay here we are in our
1211:18 - working folder the current project is
1211:20 - concepts and auto we're going to grab
1211:22 - our template files and we're going to
1211:24 - put them in place and we're going to
1211:27 - open this up in visual studio code let's
1211:29 - do that pretty quick we're going to have
1211:31 - our folder open we're going to open the
1211:33 - main cpp file close the left pane and
1211:36 - clean things up a little bit and we're
1211:38 - going to include our concepts library
1211:41 - and we're going to put in our function
1211:43 - which is going to be using the auto
1211:45 - keywords to
1211:46 - really make the syntax nice and cool but
1211:49 - we're going to be constraining our auto
1211:51 - parameters here to use integral types if
1211:54 - we call this function with something
1211:56 - that is not an integer or any trigger
1211:59 - type really we're going to get a
1212:00 - compiler error so if we go down here for
1212:02 - example and say add and say
1212:05 - 10.9 and 0.1 we're going to get a
1212:09 - compiler error because 10.9 and 0.1 are
1212:14 - double literals and we only support
1212:16 - integral types in this function here so
1212:19 - let's work and show you the error but
1212:21 - you must know this by now because we
1212:23 - have done this like a gazillion times
1212:25 - the concept integral is going to be
1212:27 - violated and it's going to say required
1212:29 - for the satisfaction of integral so the
1212:32 - concept is failing here we're going to
1212:34 - get a compiler error but if we change
1212:36 - this for example to 10 and 5 put in
1212:39 - whatever you want which is an integer
1212:41 - this is going to work we're going to
1212:42 - build with gcc
1212:44 - you see the wealth is good so you can
1212:46 - use auto with concepts like this we have
1212:49 - seen this syntax already a couple of
1212:51 - times in this chapter what we haven't
1212:53 - seen is that for example you can set up
1212:55 - a variable in main and call this x y
1212:59 - naught and say this variable should
1213:02 - satisfy the concept and specify the
1213:05 - concept you want for example let's say
1213:06 - std integral and if you do something
1213:09 - like this let's see what we get from
1213:11 - this we're going to world you see the
1213:12 - work is good because if we add up these
1213:14 - guys we're going to generate an integer
1213:17 - instance for this function and we're
1213:19 - going to deduce the return type as ant
1213:22 - so the return type is going to be
1213:23 - integral and it's going to be assignable
1213:26 - in our variable here but if we change to
1213:29 - floating point i think we have this
1213:31 - concept in place yes we do but it is
1213:34 - going to fail because what we get from
1213:36 - this function is going to be an integer
1213:38 - and we can't assign to this because this
1213:41 - concept here is saying
1213:43 - what you try to assign to this variable
1213:46 - here should be a floating point this is
1213:48 - the meaning here and if we do this we're
1213:50 - going to get to the error probably so we
1213:52 - have the arrow and it's going to say
1213:54 - constraint not satisfied and it is going
1213:57 - to say the
1213:59 - constraint we didn't satisfy which is
1214:01 - its floating point here this is how you
1214:03 - can put constraints on your variables
1214:06 - even when you are declaring them so
1214:08 - another thing we can try here is to
1214:11 - assign
1214:12 - a literal to this variable here let's
1214:15 - put in a 3.9 and see if this actually
1214:18 - boils and compiles
1214:20 - let's build with gcc
1214:22 - you see the build is good and the
1214:24 - requirement is for what we assigned to
1214:27 - this variable here should be a double
1214:30 - and a 3.9 is already a double so no
1214:33 - problem but if we try and make this
1214:36 - seven for example
1214:38 - this is going to fail so let's build
1214:40 - again you see the concept is going to
1214:42 - fail and this is how you can use these
1214:45 - things to constrain your variables i
1214:48 - personally find this a little bit
1214:50 - useless at least in this case here
1214:53 - because i know that i have an integer
1214:56 - literal
1214:57 - and i am assigning this to a variable
1215:00 - why do i need the help of concepts to
1215:02 - really
1215:03 - constrain my variable here but in the
1215:05 - case where you are calling a function
1215:07 - for example using a 5 and an 8
1215:11 - this can come in handy because it's not
1215:14 - easy to keep track of the return type
1215:16 - you get from a function because the
1215:18 - function might have a return expression
1215:21 - that has multiple different variables
1215:24 - and it's not easy to keep track of what
1215:26 - you get back from a function and you can
1215:28 - use a constraint like this to make sure
1215:31 - what you get from the function is what
1215:33 - you want and if it's not what you want
1215:35 - you're going to throw a compiler error
1215:37 - because the concept you use is going to
1215:40 - fail i would like to welcome you in this
1215:42 - new chapter where we're going to be
1215:43 - learning about classes classes are a
1215:46 - mechanism we have in c plus plus to
1215:49 - build our own types and use them like we
1215:52 - have been using other bulletin types
1215:54 - like and to double or whatever and we're
1215:57 - going to be able to do that by setting
1215:59 - up blueprints of our class types and
1216:03 - we're going to be using those blueprints
1216:05 - to build actual objects that we can use
1216:08 - in our c plus plus program so for
1216:10 - example we can have a class as a
1216:12 - blueprint and we can create real class
1216:16 - objects in our c plus plus program as we
1216:19 - need them and we're going to be learning
1216:21 - all about this in the next few chapters
1216:24 - we are going to head over in the next
1216:25 - lecture and let you set up your very
1216:28 - first c plus plus class go ahead and
1216:31 - finish up here and meet me there in this
1216:33 - lecture you are going to build your
1216:35 - first c plus plus class classes are a
1216:39 - mechanism we have in c plus plus to be
1216:42 - able to build our own types if you
1216:45 - remember so far in this course we have
1216:47 - been using basic types like ant and
1216:50 - double
1216:50 - and we were using them like this we said
1216:53 - the type of the variable we give the
1216:55 - name of the variable and then we
1216:57 - initialize this variable and we can use
1216:59 - this throughout our program now we are
1217:03 - at a point where we need to start
1217:05 - designing our own types suppose we want
1217:08 - to build our own type that models a
1217:12 - person for example suppose a person is
1217:15 - defined by the name
1217:17 - the age and the address and we want to
1217:20 - model persons in our program
1217:23 - and use them as players for example and
1217:27 - when we have the properties of a person
1217:29 - we can do all kinds of crazy things with
1217:31 - them we can make them jump up for
1217:33 - example if we are designing a game we
1217:35 - can make them run we can make them fly
1217:38 - we can do all kinds of crazy things in
1217:40 - this lecture we're going to use a
1217:42 - cylinder as an example and we're going
1217:44 - to model a cylinder in our c plus plus
1217:48 - program a cylinder is defined by two
1217:51 - things it has a base radius which is
1217:54 - modeled by this r you see here and it
1217:56 - has a height
1217:58 - and when we have this information about
1218:00 - our cylinder we can really do all kinds
1218:03 - of crazy things for example we can
1218:05 - compute its area the base area and the
1218:08 - formula to do that is pi
1218:10 - r squared this is a formula you get from
1218:13 - your basic mathematics education
1218:16 - you can compute the volume of the
1218:18 - cylinder and the formula to do that is
1218:21 - area multiplied by the height and we can
1218:24 - really do all kinds of crazy things with
1218:26 - the cylinder if we have this information
1218:30 - so we're going to use this information
1218:32 - and model a cylinder we can use in our c
1218:35 - plus plus program and we're going to be
1218:38 - using classes to do that the syntax to
1218:41 - set up your class in c plus plus it's
1218:43 - really simple you say class this is the
1218:45 - keyword you have to put in here you say
1218:48 - the name of your class in this case it
1218:50 - is cylander as you see here and then we
1218:53 - put a pair of curly braces in place the
1218:57 - start is on top here and the end is down
1218:59 - here and after your class definition
1219:02 - you're going to put a semicolon inside
1219:04 - the class we really have two parts we
1219:07 - have member variables which are going to
1219:09 - model the properties that your class is
1219:11 - going to have in this case we have two
1219:14 - properties that really define a cylinder
1219:16 - we have the best radius and we have the
1219:19 - height we have decided to model these
1219:21 - things as double types inside our class
1219:24 - and this is going to make the first part
1219:27 - of our class the member variables the
1219:30 - second part is going to be made of
1219:33 - behaviors or functions that do things on
1219:37 - the class using the properties and one
1219:40 - function we have is the volume function
1219:43 - which is going to help us compute the
1219:45 - volume of our cylinder here if you look
1219:48 - at its syntax it really is a function we
1219:51 - have a return type we have the name of
1219:54 - the function we have the parameter list
1219:56 - which is empty by now and we have our
1219:58 - curly braces that delimit the body of
1220:01 - our function inside the function we're
1220:03 - going to do nothing special we're just
1220:05 - going to return the volume of our
1220:08 - function here and if you remember the
1220:10 - volume is the base area
1220:13 - multiplied by the height and this thing
1220:16 - here is going to model the base area you
1220:19 - see it's pi
1220:20 - multiplied by the square of the radius
1220:24 - and then we're going to multiply this by
1220:25 - the height and we're going to return the
1220:27 - volume for use by whoever is calling
1220:30 - this function
1220:32 - one thing we haven't really talked about
1220:34 - is this public thing you see here
1220:36 - and what this says is that the members
1220:40 - that we have in this class are going to
1220:42 - be accessible from the outside of the
1220:44 - class for now we can't really understand
1220:47 - this but when we hit visual studio code
1220:49 - i'm going to show you what this exactly
1220:52 - means
1220:53 - now that we have the class declared we
1220:55 - can really use it like we use any other
1220:58 - types in c plus plus for example we can
1221:00 - head in our main function
1221:03 - and set up a variable called cylinder
1221:05 - one as you see here is type is going to
1221:07 - be cylinder and notice that this is
1221:10 - really a type that we build ourselves
1221:12 - and we can really use it like we use
1221:15 - other variables for example we can call
1221:17 - it function using the syntax here and
1221:20 - print the volume this is going to print
1221:22 - the volume using the volume function
1221:25 - that we just set up in a minute if we go
1221:27 - down we can modify things about our
1221:30 - cylinder for example we can use the dot
1221:33 - notation here to change the base radius
1221:36 - and change the height and if we try to
1221:38 - print the volume again this information
1221:41 - is going to be picked up and be used by
1221:43 - the volume function to compute the
1221:46 - volume of our cylinder here this is
1221:48 - really cool if you want you can also set
1221:50 - up another cylinder like we do here and
1221:52 - we're going to print the volume and we
1221:54 - can really do all kinds of crazy things
1221:56 - with our types like this okay this is
1221:59 - our class and we can really use it to do
1222:01 - a lot before we head over to visual
1222:04 - studio code and play with us i want to
1222:07 - bring to your attention that members of
1222:09 - a class
1222:11 - are private by default and what i mean
1222:14 - by that is that for example if we don't
1222:16 - put this public keywords in here we want
1222:19 - to be able
1222:21 - to use the volume function for example
1222:24 - like we have used it in our main
1222:27 - function as you see here
1222:30 - if the member is private it won't be
1222:32 - usable outside the class this is what we
1222:35 - mean here we are trying to use this
1222:37 - member in the main function
1222:39 - outside the class definition it won't be
1222:42 - accessible if it is private and we make
1222:45 - it public by putting the public keyword
1222:48 - and the column like we do here
1222:50 - everything after this public keyword is
1222:52 - going to be public until we change this
1222:55 - to private somewhere in our program if
1222:57 - we need that now that you have an idea
1223:00 - about how you can declare and use your
1223:02 - class in c plus plus let's head over to
1223:05 - visual studio code and play with us a
1223:07 - little more okay here we are in our
1223:10 - working folder the current project is
1223:12 - your first class you are going to build
1223:14 - your very first class in c plus plus
1223:17 - we're going to grab our template files
1223:19 - we're going to copy them and put them in
1223:22 - place and then we're going to open this
1223:24 - little guy in visual studio code by
1223:26 - dragging and dropping here this is going
1223:29 - to open our folder we're going to close
1223:31 - the left pane here and clean things up a
1223:33 - little bit the first thing we want to do
1223:35 - is to declare our class
1223:38 - but before we do that we're going to
1223:40 - need the pi variable because remember
1223:43 - we're going to model pi
1223:45 - for use in computing the area and the
1223:48 - volume of our cylinder that we want to
1223:51 - model like we did in the slides so the
1223:53 - way we're going to do that i am going to
1223:54 - declare a const variable and i am going
1223:57 - to call it pi
1223:58 - and i am going to initialize this with
1224:01 - pi to get pi i'm going to cheat a little
1224:04 - bit i'm going to go in my calculator and
1224:07 - let's see if i can get pi here and i
1224:10 - click on this and i'm going to grab pi
1224:12 - here and copy it this is the easiest way
1224:15 - i can find so i'm going to put it in
1224:17 - here and this is going to be our
1224:19 - variable now that we have this we're
1224:21 - going to set up our class and that to
1224:24 - define a class you say class you have to
1224:27 - put in this keyword and then we're going
1224:29 - to say the name of the class the name of
1224:31 - the class is going to be cylinder and
1224:34 - after we do this we're going to put a
1224:36 - pair of curly braces and we're going to
1224:38 - end this with a semi-colon you have to
1224:41 - remember this if you don't put it here
1224:43 - the ziploc plus compiler is going to
1224:45 - complain
1224:47 - now that we have the class blueprint
1224:49 - here we're going to put in our member
1224:51 - variable and these are going to be the
1224:53 - variables we use to model the base
1224:56 - radius and the height of our cylinder
1224:58 - we're going to put in a double variable
1225:01 - and we're going to call this base radius
1225:03 - and we're going to brace initialize this
1225:05 - to zero we can do this and we're going
1225:07 - to set up another one and call it height
1225:10 - and we're going to also initialize this
1225:12 - to zero okay now that we have this we're
1225:14 - going to put functions or methods in our
1225:17 - class and we do that by just putting the
1225:20 - function definition in our class so our
1225:22 - function is going to be returning double
1225:24 - because it's going to be returning the
1225:26 - volume
1225:27 - of our cylinder so it's going to return
1225:30 - double here the name is going to be
1225:32 - volume and it's going to be computing
1225:34 - the volume and returning that remember
1225:37 - the formula to compute the volume
1225:40 - is going to be pi we have a pi variable
1225:42 - on top and we're going to multiply by
1225:45 - this radius twice because the base
1225:48 - radius has to be squared let's do that
1225:50 - and multiply by base radius again and
1225:53 - then we're going to multiply by height
1225:55 - and notice that these are guys declared
1225:58 - in the body of the class if i can say
1226:00 - that this is the definition of the class
1226:02 - we are able to use this guys because we
1226:05 - are inside this class here okay now that
1226:08 - we have this our class is really defined
1226:10 - but we can't really use it quite yet
1226:13 - what do i mean by that let's go in the
1226:15 - main function and we're going to set up
1226:17 - a variable of type cylinder we can do
1226:20 - that and let's call this cylinder one if
1226:23 - we do this and try to compile this this
1226:26 - is going to work fine let's do that
1226:28 - we're going to
1226:29 - world with gcc
1226:31 - world finished successfully this is
1226:33 - welding but we have a function called
1226:36 - volume here and we can try and call it
1226:38 - using the dot notation that we saw in
1226:42 - the slides let's try and print the
1226:44 - volume of our cylinder here and see what
1226:46 - we get so we're going to say volume we
1226:48 - can save that and we're going to say
1226:50 - cylinder one and do volume okay let's
1226:53 - see if we can call this function here
1226:55 - and the moment we do that you see that
1226:57 - we have a squiggly line here so visual
1227:00 - studio code has detected that something
1227:02 - is wrong let's hit the problems tab here
1227:05 - and see what we get it's going to say
1227:08 - expected an identifier on line what this
1227:12 - is not making sense
1227:14 - uh we put three columns here let's
1227:17 - correct this a little bit
1227:19 - and the error is going to change to be
1227:23 - suddenly the volume declared at line 6
1227:26 - is inaccessible from this location here
1227:29 - this is what the error says and it is
1227:31 - not sensible
1227:33 - because members of the class are private
1227:36 - by default so they want to be accessible
1227:40 - from the outside of the class like we
1227:42 - are doing in the main function here
1227:44 - notice that we are able to access them
1227:46 - from the inside of the class you see
1227:48 - base radius is declared down here and we
1227:51 - are able to use in the function because
1227:53 - the function volume here is inside the
1227:56 - class so the members are accessible even
1227:59 - if they are private but private members
1228:02 - can't be accessible from the outside of
1228:04 - the class like we are doing in the main
1228:06 - function here that's why we have this
1228:08 - problem let's see what the compiler says
1228:10 - we're going to pass this through gcc and
1228:13 - we're going to get a compiler error that
1228:14 - we expect and the compiler is really
1228:18 - specific on this it's going to say
1228:20 - double cylinder volume the volume
1228:23 - function from the cylinder class is
1228:26 - private within this context and which
1228:28 - context the line 19 when we are trying
1228:31 - to use it in the main function so if you
1228:34 - really want thanks inside the class to
1228:37 - be accessible from the outside you need
1228:40 - to make them public and change them from
1228:43 - private how do we do that it is really
1228:45 - simple you use the syntax we saw in the
1228:47 - slides we're going to say public and put
1228:50 - a column here and when you do this it is
1228:53 - advised to align your things a little
1228:55 - bit properly so when we do this
1228:58 - everything after this public keyword is
1229:01 - going to be public in this class and it
1229:04 - will be accessible from the outside
1229:07 - let's try and build now but before we
1229:09 - build let's show you that the squiggly
1229:11 - line should be gone visual studio code
1229:14 - is still confused let's try and vault
1229:17 - let's pass this through gcc now you see
1229:19 - that the world is good okay now if you
1229:21 - try and print the volume here we're
1229:23 - going to get zero because the base
1229:26 - radius is braced initialized to zero the
1229:29 - height is zero and if we multiply like
1229:31 - this we're going to get a zero and
1229:33 - return that let's try and run this
1229:35 - program because we just build it
1229:37 - successfully we can bring up a terminal
1229:40 - to do that and let's clear and run
1229:43 - rooster and we can see that the volume
1229:45 - is zero and it is what we expect okay
1229:48 - now our class is working but there is
1229:50 - really something bad about it and
1229:54 - that is because the public keyword is
1229:57 - going to make everything public in this
1229:59 - class the member variables are also
1230:01 - going to be public so we can go down
1230:04 - here and print the base radius and the
1230:06 - height for example let's do that and
1230:08 - show you that this is the case so we're
1230:10 - going to say cylinder one and say base
1230:12 - radius this is going to print and we're
1230:15 - going to say hi we're going to print
1230:18 - this out if we try and print these guys
1230:21 - let's build and pass this through gcc
1230:23 - you see the bolt is good and if we clear
1230:26 - and run rooster we're going to see that
1230:28 - this radius and height are or accessible
1230:31 - to show you that this can also be
1230:33 - different from zero let's change the
1230:36 - base radius to one and the height to one
1230:38 - to make it a unit cylinder let's try and
1230:42 - weld we're going to change these guys to
1230:44 - one and the volume is going to be
1230:46 - 3.14 or something let's run rooster
1230:49 - we're going to see our volume here and
1230:52 - we have the base radius and the height
1230:54 - but this is really bad design because
1230:57 - the member variables
1230:59 - in most cases you're going to want to
1231:01 - keep them private from the outside
1231:04 - because users of your class don't really
1231:07 - care about the member variables they
1231:09 - just want to do things with your class
1231:11 - for example calling the volume function
1231:12 - here so what we usually do in
1231:15 - practice is to flag our member variables
1231:18 - as private and we can do that using the
1231:21 - private keyword as we do here and at the
1231:24 - moment we do this everything after this
1231:27 - private keyword is going to be private
1231:29 - to the class it is only going to be
1231:31 - accessible from the inside of the class
1231:34 - but if we try to access that from the
1231:36 - outside we're going to get the same
1231:38 - compiler error we saw before when we
1231:41 - tried to access private stuff from the
1231:44 - class in the main function here visual
1231:46 - studio code is going to give us a
1231:48 - problem saying that these member
1231:49 - variables are not accessible from this
1231:52 - context here and if we pass this through
1231:54 - gcc we're going to get a clear compiler
1231:57 - error saying that the height
1232:00 - and the
1232:01 - base radius are now private in the class
1232:04 - and we can't access them from the
1232:07 - outside this is really what i wanted you
1232:09 - to see and this is good design okay now
1232:12 - that we have our class declared and that
1232:14 - we can use it in the main function i
1232:16 - want you to see that it is possible to
1232:19 - change these member variables but to do
1232:22 - that we will need to turn this back to
1232:24 - public and we're going to see a better
1232:26 - way to do this later but for now let's
1232:29 - make them public and show you that we
1232:30 - can change things around and make our
1232:33 - cylinders a little more interesting so
1232:35 - now that they are public we can go in
1232:37 - the main function and do crazy things
1232:40 - change the data for example we can
1232:42 - change our member variables to be
1232:44 - something else let's go down and say
1232:46 - cylinder one and say base radius we can
1232:49 - use the dot notation and put an ecosign
1232:53 - and give another value to our base
1232:55 - radius let's make it 10 for example and
1232:58 - change the height to be something else
1233:01 - we can change that and we're going to
1233:03 - put in a 3 for example why not now if we
1233:06 - print the volume again we're going to
1233:08 - get another value let's copy this and
1233:10 - put that down below
1233:12 - our changes here and if we build the
1233:15 - program it should well define the world
1233:18 - is good
1233:19 - so we can hit enter and clear and if we
1233:22 - run rooster we're going to get
1233:24 - the volume to be
1233:25 - 3.14 first here the first line here and
1233:29 - the second line is going to give us
1233:31 - another volume and if we multiply these
1233:33 - guys with pi
1233:35 - and if we use our formula to compute the
1233:38 - volume we're going to basically get the
1233:39 - same thing let's try and prove this with
1233:42 - our calculator we have it around so we
1233:45 - have pi in here we're going to multiply
1233:48 - this with
1233:49 - 100 which is
1233:51 - the radius squared we're going to put
1233:54 - 100 here and we're going to multiply
1233:56 - this with 3 which is our height let's
1233:58 - put this in and we have
1234:01 - 942.47 which is what we have here
1234:04 - roughly the same thing so you see that
1234:06 - our function is really computing our
1234:08 - volume we can even go down and change
1234:10 - the height to something else for example
1234:12 - we're going to change the height to
1234:15 - let's make an eight and i printed the
1234:17 - volume again you can keep playing with
1234:19 - us and really make it clear
1234:22 - that our volume function is computing
1234:24 - our volume using the data that we have
1234:27 - in the member variables this is the
1234:29 - message here let's build again the world
1234:32 - should be good we're going to clear and
1234:34 - run rooster now we see another
1234:36 - number for our volume and this is really
1234:39 - how you can declare a class again you
1234:42 - use the syntax you see here class you
1234:43 - say the class name you put a pair of
1234:46 - curly braces and you put your semicolon
1234:49 - don't forget this
1234:50 - members of your class are private by
1234:53 - default but you can make them public if
1234:55 - you want using the public keyword as we
1234:58 - did here inside your class you're going
1235:00 - to have two parts you're going to have
1235:02 - the member variables which are going to
1235:03 - be properties that define what your
1235:06 - class is and we're going to have
1235:09 - functions or methods let's say that and
1235:12 - these are going to be behaviors
1235:14 - of your class you're going to go through
1235:17 - these functions to make your classes do
1235:19 - things and once you have the class
1235:21 - definition in place you can use it to
1235:24 - create
1235:25 - variables as we do in the main function
1235:27 - here and the variables we create from
1235:30 - our class are usually called objects in
1235:33 - c plus plus terminology okay the class
1235:35 - is really a blueprint and we create
1235:39 - objects using that blueprint and objects
1235:42 - are going to have runtime data that we
1235:45 - store in our class okay so for example
1235:47 - if we hit this point here the base
1235:49 - radius is going to be 10 and the height
1235:52 - is going to be eight and that's going to
1235:54 - be runtime information for our class
1235:57 - object stored in this variable that we
1236:00 - call cylinder one here this is really
1236:03 - what i wanted you to see okay let's try
1236:05 - and recap what we know about classes so
1236:08 - far a class can have member variables
1236:10 - but so far we have used member variables
1236:13 - as stack variables if we go back for
1236:16 - example you see that we say base radius
1236:18 - here you notice it is not a pointer or a
1236:21 - reference or anything it is a stack
1236:23 - variable inside our class so member
1236:26 - variables can only be stack variables
1236:29 - like we have here but they can also be
1236:32 - pointers but they can never be
1236:34 - references and the reason is a reference
1236:37 - can never be left uninitialized and in
1236:41 - the classes when we declare member
1236:42 - variables the ability to leave them
1236:45 - uninitialized is really important and we
1236:48 - can't really do that with references i
1236:50 - can't really go into the details of that
1236:53 - as we will see that as we progress in
1236:56 - the chapter but know that member
1236:58 - variables can either be stacked
1237:00 - variables or pointers but they can never
1237:03 - be references in z plus okay that's what
1237:05 - we just said here members can't be
1237:08 - references classes can have functions or
1237:11 - methods that let them do things we saw
1237:13 - an example of this with our volume
1237:16 - function class methods have access to
1237:19 - the member variables regardless of
1237:21 - whether they are public or private we
1237:24 - have seen that the volume function will
1237:26 - have access to our member variables
1237:30 - regardless of whether it is public or
1237:32 - private and last but not least private
1237:35 - members of classes aren't accessible
1237:38 - from the outside as we saw in the main
1237:40 - function you can't access them from the
1237:43 - main function you can only do that from
1237:45 - the class definition itself this is
1237:47 - really all i had to share in this
1237:49 - lecture i hope you found it interesting
1237:52 - we are going to stop here in this one in
1237:54 - the next one we're going to see how
1237:56 - class objects are built
1237:58 - from constructors go ahead and finish up
1238:01 - here and meet me there in this lecture
1238:04 - we're going to learn about constructors
1238:06 - and constructors are special class
1238:10 - methods or functions
1238:12 - that are called by the compiler to
1238:15 - construct your class objects and they
1238:18 - are special because they have no return
1238:20 - type a constructor can never have a
1238:23 - return type as you see here they have
1238:26 - the same name as the class so for
1238:28 - example for our class in the last
1238:31 - lecture that was called silenter the
1238:33 - constructors are also going to have the
1238:35 - same name as the class they are going to
1238:37 - be called also slander constructors can
1238:41 - have parameters but if it makes sense
1238:43 - for whatever it is you are trying to do
1238:46 - you can also leave the parameters out
1238:48 - and constructors are usually used to
1238:51 - initialize the member variables and put
1238:54 - them in a state where you want them in
1238:57 - your c plus plus application
1238:59 - let's look at how you can declare
1239:01 - constructors for your classes
1239:03 - here is our cylinder class you see we
1239:06 - have our member variables we had they
1239:08 - are private now and we have
1239:11 - a public section which is going to have
1239:13 - our functions or behaviors as you see
1239:15 - here the member variables are what we
1239:17 - have seen from the last lecture but if
1239:20 - you look here we have a few new things
1239:24 - here
1239:24 - we have two things that look like
1239:27 - functions but they don't have return
1239:29 - values that's something you should
1239:30 - notice
1239:32 - they have a parameter list as you see
1239:34 - here and we have a pair of curly braces
1239:37 - because these are really functions and
1239:39 - these are special functions that are
1239:41 - going to be called by the compiler to
1239:44 - initialize your class objects if you
1239:47 - look here in this example we are
1239:50 - using the
1239:52 - constructor with no parameters to
1239:54 - initialize our member variables to 2 and
1239:57 - we have another constructor as you see
1239:59 - down here which is going to take
1240:01 - parameters directly and it's going to
1240:03 - take the radius parameter and the height
1240:06 - parameter the parameters are of double
1240:09 - type because that's what we expect in
1240:11 - our class and we are passing them by
1240:14 - value here because they are fundamental
1240:16 - types and we don't really mind copying
1240:18 - them but please keep in mind that they
1240:20 - are going to be passed by value and what
1240:23 - you have inside your constructor body
1240:26 - are going to be copies of the original
1240:30 - arguments that were passed to your
1240:32 - constructor and this is really how you
1240:34 - declare constructors for your c plus
1240:37 - plus classes constructors can either
1240:39 - have parameters like we have again on
1240:41 - this example here or they can have no
1240:44 - parameters and this is going to be a
1240:46 - default constructor we're going to see
1240:48 - that this is going to be called when you
1240:50 - try to create
1240:52 - variables of this cylinder type without
1240:55 - passing the parenthesis like we do when
1240:58 - we call this second constructor here
1240:59 - we're going to see this in a minute okay
1241:01 - this is all i think i have to share in
1241:03 - the slides about how you declare
1241:05 - constructors let's head over to visual
1241:08 - studio code and play with this a little
1241:09 - more okay here we are in our working
1241:12 - folder the current project is
1241:14 - constructors we're going to put in our
1241:17 - template files pretty quick let's do
1241:20 - that and we are going to open this in
1241:22 - visual studio code by dragging and
1241:24 - dropping on top here
1241:26 - this is going to open our folder let's
1241:28 - open our main cpp file
1241:31 - and we're going to take out what we
1241:33 - don't need in the main function and on
1241:35 - top here and i am going to reuse code
1241:39 - from the last lecture because we don't
1241:40 - want to type that again so let's put in
1241:43 - our class definition we have our
1241:45 - variable pi which is going to be used to
1241:48 - compute the volume in the class here and
1241:51 - we have member variables okay now that
1241:53 - we are here let's change the member
1241:56 - variables to be private because making
1241:58 - them public is really going to be bad
1242:01 - design it's going to expose them in the
1242:03 - main function and people can mess with
1242:05 - them and really change the logic of how
1242:08 - our class works without our concept it
1242:12 - is advised to make your member variables
1242:14 - private unless you really have a
1242:17 - compelling reasons to make them public
1242:20 - okay now that we have our class here
1242:22 - let's set up constructors for it so
1242:24 - we're going to go down here in the
1242:26 - public scope and say constructors and
1242:29 - we're going to set up the first
1242:30 - constructor which is not going to take
1242:33 - any parameter so we're going to say the
1242:35 - name of the class remember a constructor
1242:37 - doesn't have a return type and it has to
1242:40 - have the same name as the class so we
1242:43 - need to comply with that and we're going
1242:45 - to put our pair of curly braces and
1242:48 - inside we're going to initialize our
1242:50 - member variables however we want so what
1242:53 - we're going to do here we're going to
1242:54 - set the base radius to something let's
1242:57 - make it a 2 like we saw in the slides no
1243:00 - problem with that and we're going to set
1243:02 - the height to something else and we are
1243:04 - going to set the height to 2 as well we
1243:07 - can do that you can use what you want
1243:10 - and now we have our constructor and it
1243:13 - is initializing our thanks okay now that
1243:16 - we have the constructor in place
1243:18 - how is it really called by the compiler
1243:20 - and notice that our constructor is in
1243:23 - the public scope of the class
1243:26 - if it isn't public you want to be able
1243:28 - to access it from the outside and the
1243:31 - compiler will fail to build your objects
1243:34 - and we're going to see this in a minute
1243:36 - but before we do that let's try and
1243:38 - create a cylinder object now so we're
1243:40 - going to say cylinder and say cylinder
1243:42 - one like we did in the last lecture
1243:45 - and when we do this notice what we see
1243:48 - if we print the volume of our cylinder
1243:52 - object here this is an object because
1243:55 - we're creating this from our blueprint
1243:58 - which is the class definition here you
1244:00 - really need to know this this is a class
1244:02 - object let's say that and we're going to
1244:04 - print its volume we're going to say
1244:06 - cylinder one and we're going to call our
1244:08 - volume method we should say and if we
1244:11 - build you're going to see that this is
1244:12 - going to work but
1244:14 - the volume is not going to be coming
1244:16 - from the initial values we have here we
1244:19 - will have changed these guys to 2
1244:22 - from our constructor here because the
1244:25 - compiler is going to look at this line
1244:26 - here and see that we are trying to build
1244:29 - a silent object it's going to look at
1244:32 - the class definition and it is going to
1244:34 - say do i have any constructor
1244:36 - that i can use to build an object from
1244:39 - the syntax i see here and it's going to
1244:41 - see that it has a constructor that
1244:43 - doesn't take any parameter and it's
1244:45 - going to use it to build our object and
1244:48 - it's going to be using this information
1244:50 - to build our cylinder object so the base
1244:53 - radius is going to be two the height is
1244:55 - going to be two and it's going to use
1244:57 - that to compute the volume
1244:59 - that we print here you really need to
1245:01 - understand this let's vote
1245:04 - and see
1245:05 - if gcc accepts this you see the both is
1245:08 - good now we can bring up a terminal and
1245:11 - clear and run rooster you're going to
1245:13 - see that we have 25 something which is a
1245:16 - result of using this information we have
1245:19 - here if we take pi multiplied by this
1245:22 - base radius multiply by this base radius
1245:24 - again and multiply by height we're going
1245:27 - to get this here you can try this out it
1245:29 - is going to be what you see here and
1245:31 - this hopefully proves that the compiler
1245:34 - is using our constructor here but we can
1245:37 - also use a debugger
1245:39 - let's set up a breakpoint here
1245:42 - and we're going to run this through our
1245:44 - debugger we can come back to the run tab
1245:47 - here
1245:48 - as we have done before
1245:50 - and we're going to try and use the
1245:52 - debugging tools that come
1245:55 - with the gcc compiler that's what we can
1245:57 - use if you are on windows you can also
1246:00 - use the
1246:01 - tools that come with the compiler from
1246:03 - microsoft but we're not going to use
1246:05 - that now gcc is going to be fine we're
1246:08 - going to start the debugging and we
1246:10 - should hit our breakpoint when the build
1246:12 - is done let's wait a minute okay we have
1246:15 - hit our breakpoint
1246:17 - we can minimize this a little bit and i
1246:20 - show the terminal to the right here i
1246:22 - think we can do that let's do that let's
1246:24 - put that a little bit to the right here
1246:27 - and minimize a little bit okay we have
1246:29 - our thunk in place we have hit our break
1246:32 - point you see these are the local
1246:34 - variables we have here we have a
1246:36 - cylinder object which is not initialized
1246:40 - yet because you see what we have inside
1246:42 - is really junk data we haven't put in
1246:45 - anything yet but now that we are at this
1246:48 - break point here we can hit step into
1246:51 - and step into the code that constructs
1246:54 - our cylinder object because at this
1246:57 - point liner 25 here hasn't run yet so
1247:01 - we're going to step into and you're
1247:02 - going to see that we hit the constructor
1247:05 - for our cylinder object
1247:08 - and
1247:09 - this again proves that our constructor
1247:11 - is being used to build our cylinder
1247:14 - objects
1247:15 - now we can move to the next line we're
1247:17 - going to set up the base radius and if
1247:19 - we hit next here this is going to set
1247:22 - our base radius to 2
1247:24 - and you see that height is in one
1247:26 - because we haven't set it up yet but if
1247:29 - we execute this line you're going to see
1247:31 - that height is also going to change to
1247:33 - two
1247:33 - and now if we hit next we're going to
1247:36 - get out of our constructor and our
1247:38 - cylinder object will be already
1247:40 - constructed if we look again here we're
1247:43 - going to see that radius is 2 height is
1247:46 - 2 and we can print the volume and if we
1247:49 - hit step over we're going to see our
1247:50 - volume printed out here hopefully again
1247:53 - this proves that our constructor here is
1247:56 - being used to build
1247:58 - objects and it is doing that because it
1248:01 - is the syntax here we don't pass any
1248:04 - parameter to our cylinder object as we
1248:07 - created so this must be calling the
1248:10 - default constructor which doesn't take
1248:12 - any parameter this is the message here
1248:15 - let's close our debugging session and
1248:17 - maximize our visual studio code instance
1248:20 - because we're going to set up another
1248:22 - constructor which is going to take
1248:23 - parameters now and you have seen the
1248:26 - syntax to do that in the slides it is
1248:28 - nothing complicated we're going to say
1248:30 - the name of the constructor which is
1248:32 - going to be the name of the class and
1248:33 - we're going to say double
1248:35 - and say rad param for radius and we're
1248:38 - going to say
1248:40 - height param for our
1248:42 - height and we're going to make this
1248:44 - double and after that we're going to
1248:46 - head in the body of our constructor and
1248:49 - we're going to initialize our guides to
1248:51 - the parameters that will pass to the
1248:54 - function here and this is really
1248:55 - powerful after we have this constructor
1248:58 - end we will be able to pass
1249:00 - parameters that will be used to
1249:02 - construct our cylinder object so we can
1249:05 - say base radius and pass in
1249:08 - red param and we can say height and say
1249:11 - height param here and these are going to
1249:13 - be used to construct our object now we
1249:16 - can head over in the main function and
1249:18 - change how we construct our cylinder
1249:20 - object if we want to use tan as the
1249:23 - radius and
1249:25 - five or four as the
1249:27 - height we can do that by passing
1249:29 - arguments to our constructor here
1249:33 - let's run this through the debugger
1249:35 - again and see that our information here
1249:37 - is being used
1249:39 - now this constructor here is going to be
1249:42 - chosen by the compiler because it is
1249:44 - more fitting for the call that we are
1249:47 - doing here let's run our debugging
1249:50 - session the program is going to be bolt
1249:53 - and we are going to try and maximize
1249:55 - this a little bit and bring up our
1249:58 - terminal output okay we have hit the
1250:00 - breakpoint here we can step into our
1250:03 - constructor and notice the constructor
1250:05 - that the compiler chooses our
1250:08 - constructor that takes parameters is
1250:10 - chosen here and we can do things inside
1250:13 - let's hit next we're going to initialize
1250:16 - the base radius to 10 and we're going to
1250:18 - initialize the height to
1250:21 - four okay we can see that to the left
1250:23 - here if we hit next the height is going
1250:26 - to be changed to four and our
1250:28 - constructor is going to be done we're
1250:29 - going to head over
1250:31 - in the main function again and if we
1250:33 - step over now we're going to print a new
1250:35 - volume which is based on the information
1250:38 - we used to construct our object here
1250:41 - this is really what constructors do they
1250:43 - are used by the compiler to build your
1250:46 - objects and we saw the syntax we can use
1250:49 - to set up constructors for our own
1250:52 - classes okay now you must be saying if
1250:54 - we need constructors to build our
1250:57 - objects
1250:58 - why was the code in the last lecture
1251:01 - working
1251:02 - in the last lecture we did something
1251:04 - like this we said cylinder cylinder one
1251:06 - cylinder one and this was welding and
1251:10 - compiling fine and let's try and take
1251:12 - out our constructors we can do that
1251:15 - let's comment them out and if you look
1251:17 - you're going to see that the code is
1251:19 - going to compile fine even if we don't
1251:21 - have any constructors in here let's
1251:24 - build with gcc to show you that the code
1251:27 - is going to compile both is good so how
1251:30 - is this working how is this
1251:32 - constructing our objects even if we
1251:35 - don't have any constructors in here well
1251:37 - the reason is the compiler is going to
1251:40 - set up its own constructor and what it
1251:42 - is going to set up is a constructor
1251:44 - which is really empty and doesn't have
1251:47 - anything inside it's basically going to
1251:49 - be as if we put in an empty constructor
1251:52 - let's copy this and actually show you
1251:54 - this we can do that and we're going to
1251:57 - make this constructor empty and not do
1252:00 - anything in the body this is the
1252:02 - constructor that your compiler is going
1252:04 - to generate and if we're both now and i
1252:07 - try to
1252:09 - set up a break point here you're going
1252:11 - to see that our empty constructor is
1252:13 - going to be chosen let's debug and show
1252:16 - you that okay you see that we're going
1252:18 - to hit the breakpoint here and if we
1252:20 - step into the compiler is going to
1252:22 - choose this guy and it's not going to do
1252:24 - anything so it's basically going to take
1252:27 - our member variables as
1252:29 - they are and it's going to use the
1252:31 - information to print the volume here we
1252:33 - can
1252:34 - hit next again
1252:35 - and get out of our constructor
1252:39 - and if we
1252:41 - step over we should print our volume
1252:44 - which is going to be 3.14 because the
1252:47 - compiler
1252:48 - just used the
1252:50 - initial values we have in our member
1252:53 - variables here so again the message is
1252:55 - if you don't have any constructor in
1252:58 - your class the compiler is going to
1253:01 - generate an empty constructor for you
1253:03 - and the empty constructor is going to
1253:05 - take no parameters and it's not going to
1253:08 - have anything in the body it's going to
1253:09 - be an empty constructor and it is called
1253:13 - a default constructor generated by the
1253:15 - compiler this is really all i had to
1253:18 - share in this lecture i hope you found
1253:19 - it interesting now you should have
1253:22 - enough knowledge to build your own
1253:24 - constructors for your classes we are
1253:26 - going to stop here in this lecture the
1253:29 - next one we're going to learn about
1253:30 - default constructors
1253:32 - go ahead and finish up here
1253:34 - and meet me there in this lecture we're
1253:36 - going to learn about default
1253:38 - constructors and this is a syntax you
1253:40 - can use to let the compiler
1253:43 - generate a default constructor for you
1253:46 - all you have to do is do things like
1253:48 - this you're going to say the name of the
1253:51 - constructor which is going to be the
1253:52 - same name as the class you're going to
1253:54 - put in an empty parameter list and then
1253:56 - you're going to say equals default
1253:59 - if you do this the compiler is going to
1254:01 - generate a default empty constructor for
1254:05 - you
1254:05 - in the last lecture we have seen that we
1254:07 - can set up our own constructors
1254:10 - basically like this what i haven't told
1254:13 - you is that the moment you set up your
1254:15 - own constructor the compiler is going to
1254:19 - not generate the default constructor and
1254:22 - if you want to keep the ability to
1254:24 - construct objects without passing
1254:27 - parameters you're going to have to put
1254:29 - in your own default constructor and you
1254:32 - can use this syntax here to do that
1254:35 - let's head over to visual studio code
1254:37 - and talk about this a little more okay
1254:39 - here we are in our working folder the
1254:42 - current project is defaulted
1254:44 - constructors we're going to grab our
1254:46 - template files and we're going to put
1254:49 - them in place and we are going to open
1254:51 - this in visual studio code by dragging
1254:53 - and dropping here and we're going to
1254:55 - open our main cpp file let's take out
1254:58 - what we don't need we're going to clean
1255:00 - the main function here and we are going
1255:03 - to bring in the class definition we had
1255:05 - in the last lecture
1255:07 - if you remember we had two constructors
1255:10 - and one constructor which didn't take
1255:12 - any parameter and another constructor
1255:16 - which was initializing our member
1255:18 - variables with parameters that we passed
1255:21 - in this parameter list here but in this
1255:24 - lecture let's take out this constructor
1255:27 - that doesn't take any parameter
1255:30 - and show you that when you set up your
1255:32 - own constructor the compiler is not
1255:35 - going to generate a default constructor
1255:37 - for you and we're going to lose the
1255:39 - ability to construct objects without
1255:42 - passing parameters the syntax we
1255:45 - basically see here we're going to say
1255:46 - cylinder and say cylinder one let's use
1255:49 - a lowercase c and if we do this you see
1255:52 - that we have a squiggly line the
1255:54 - compiler is not going to generate an
1255:56 - empty non-parameter taking constructor
1256:00 - because it sees that we have a
1256:02 - constructor here this is how c plus plus
1256:04 - compilers work if they see that you have
1256:07 - any constructor in your class they're
1256:09 - not going to generate a default empty
1256:11 - constructor and if we try to build we're
1256:13 - going to get an arrow that says
1256:15 - something like
1256:17 - we don't have a constructor that can
1256:19 - basically construct an object from the
1256:21 - line here it's going to say no matching
1256:23 - function call for cylinder cylinder you
1256:26 - see here it is trying to call a
1256:28 - constructor that doesn't take any
1256:30 - parameter but we have no such
1256:32 - constructor in our code we could go in
1256:35 - and put in that constructor
1256:37 - and for example say cylinder and put an
1256:40 - empty parameter list and put an empty
1256:43 - body now this line here is going to work
1256:46 - because we have a default empty
1256:47 - constructor and if we weld you see that
1256:50 - the build is going to be good okay we
1256:53 - are building fine but having to type all
1256:56 - this if what you really want is an empty
1256:59 - constructor
1257:01 - is too much type in and in c plus plus
1257:03 - we have a syntax we can use to let the
1257:06 - compiler generate this kind of
1257:08 - constructor for us and the way we do
1257:10 - that is say cylinder and we say the name
1257:13 - of the constructor we say equals and we
1257:15 - say default if we save this the compiler
1257:18 - is going to generate this constructor
1257:20 - for us and the line here is going to
1257:22 - work so let's bring this up and build
1257:25 - again we're going to build with gcc
1257:28 - you're going to see that the build is
1257:29 - good and we can bring up the terminal
1257:32 - and clear and run rooster we're not
1257:35 - going to see anything because we're not
1257:37 - printing the volume of our cylinder here
1257:40 - but we can do that let's call this
1257:42 - cylinder one to be consistent with what
1257:44 - we did in the last few lectures and
1257:46 - we're going to say hddc out and print
1257:49 - the volume of this cylinder we're going
1257:51 - to say volume and call our volume method
1257:54 - and now that we have this we can weld
1257:56 - we're going to use gcc to do that the
1257:58 - build is good we can go down and clear
1258:01 - and run rooster we're going to see that
1258:03 - we see our volume here and this is
1258:06 - really all i wanted to share with you in
1258:08 - this lecture that you can use this
1258:10 - default syntax here to set up an empty
1258:13 - default constructor for your classes and
1258:16 - one thing i haven't shown you
1258:18 - is that your constructors have to be
1258:22 - public to be able to be called like this
1258:25 - and to show you that let's go up and
1258:27 - actually change this to private and show
1258:29 - you what happens the moment we do this
1258:31 - we're going to get a squiggly line in
1258:33 - the main function here and if we try to
1258:36 - build but before we build let's show you
1258:39 - what visual studio code is saying it's
1258:41 - going to say cylinder cylinder declared
1258:44 - is inaccessible so you see the
1258:46 - constructor which is declared inside of
1258:49 - a class as private
1258:51 - it accessible from the outside when we
1258:54 - try to call it to build our cylinder
1258:56 - objects so for constructors to be usable
1259:00 - on the outside here and both your
1259:02 - objects they have to be public let's
1259:05 - build and see what gcc says about this
1259:08 - we basically going to have the same
1259:09 - error the constructor is private within
1259:12 - this context so we can't really call it
1259:14 - so if we want our code to build we need
1259:16 - to make our constructors public and this
1259:19 - is something
1259:20 - you need to know let's build again and
1259:22 - see that the cold is now building the
1259:25 - world is good and this is really all i
1259:27 - had to share in this lecture we are
1259:29 - going to stop here in this one in the
1259:31 - next one we're going to see how we can
1259:32 - use setters and getters to modify things
1259:36 - about our class objects
1259:39 - go ahead and finish up here and meet me
1259:41 - there
1259:42 - in this lecture we're going to learn
1259:43 - about setters and gators and these are
1259:46 - methods in our class that we can use to
1259:49 - read member variables or modify data in
1259:52 - our member variables let's look at a
1259:55 - simple example and by the way i am sorry
1259:58 - for my bad pronunciation of cylinder
1260:00 - here i have said it was cylinder and
1260:03 - after some careful thought i checked
1260:05 - online for the pronunciation on this and
1260:08 - i found that it was cylinder sorry for
1260:11 - this if it was bothering you i apologize
1260:13 - for the bad pronunciation and i am going
1260:16 - to do this right starting from now okay
1260:18 - here we have our cylinder class we have
1260:21 - a few member variables and we have the
1260:23 - base radius we have the height and now
1260:26 - we want to go through some public
1260:28 - functions to do operations on these
1260:31 - member variables because now that they
1260:33 - are private we can't really modify them
1260:35 - or manipulate them from the outside and
1260:38 - we really need to do things with them so
1260:40 - if we want to read things from them we
1260:43 - will use the getter functions
1260:45 - and if you look here this is a simple
1260:47 - function the only special thing about it
1260:50 - is that it leaves inside the class it
1260:52 - has a return value it has a function
1260:55 - name it has a parameter list and then
1260:56 - the body we're just going to return the
1260:59 - member variable of interest because this
1261:01 - is a getter we use that to get stuff
1261:04 - from the class this is the meaning here
1261:06 - here we have another getter function
1261:08 - which is going to return the height and
1261:10 - notice that these functions live in the
1261:13 - public scope of our class this is key
1261:16 - because we want to be able to go through
1261:19 - them to modify and do things with our
1261:22 - member variables but they will be used
1261:25 - from the outside so they must be public
1261:27 - otherwise they want to be accessible
1261:29 - from the outside we also have a pair of
1261:33 - setup functions they are going to be
1261:35 - modifying our member variables so set
1261:38 - base radius is going to take a parameter
1261:40 - that it's going to use to set a base
1261:42 - radius set height is going to do the
1261:44 - same it's going to take a parameter and
1261:46 - it's going to use that to assign a value
1261:49 - to our height member variable here and
1261:52 - because these functions are members of
1261:55 - the class
1261:56 - they have access to our member variables
1261:59 - regardless of whether they are public or
1262:02 - private so this is going to work we're
1262:04 - going to go through them from the
1262:06 - outside and they are going to do the
1262:08 - dairy work for us and do things using
1262:11 - our member variables to which we don't
1262:14 - have access to
1262:15 - from the outside this is the meaning
1262:17 - here now that you have an idea about
1262:20 - this we're going to head over to visual
1262:22 - studio code and play with us a little
1262:23 - more okay here we are in our working
1262:26 - folder the current project is setters
1262:28 - and getters we're going to grab our
1262:30 - template files pretty quick and put them
1262:33 - in place
1262:34 - setters and getters it is let's grab the
1262:36 - folder and we're going to open this in
1262:38 - video studio code by dragging and
1262:40 - dropping here this is going to open our
1262:42 - folder we're going to open our main cpp
1262:45 - file and we're going to clean it up a
1262:47 - little bit we are going to grab the
1262:49 - cylinder class from our previous lecture
1262:53 - and use that as a starting point here
1262:55 - and if you look we have a pair of
1262:57 - constructors here we have the volume
1263:00 - function which is going to give us the
1263:02 - volume of our cylinder here and we have
1263:04 - our member variables now what we want to
1263:07 - do is to be able to do things with these
1263:10 - member variables from the outside in the
1263:13 - main function here and we're going to go
1263:15 - through setter and getter methods which
1263:17 - must be public so let's do that so we're
1263:20 - going to set up our getter first so
1263:22 - we're going to say double get base
1263:25 - radius it's going to return double it's
1263:27 - not going to take anything and and in
1263:29 - the body we're just going to return our
1263:32 - radius let's return that okay so we're
1263:34 - going to set up another getter which is
1263:36 - going to give us the height and it's not
1263:38 - going to take anything and it's going to
1263:40 - just return our height member variable
1263:43 - now these are our getters they are going
1263:46 - to be getting things from the class
1263:49 - object we're going to set up other
1263:50 - functions that are going to be our
1263:52 - setters they're not going to return
1263:54 - anything and we're going to say set base
1263:57 - radius and it's going to take a double
1263:59 - parameter in and we're going to use that
1264:01 - to set our base radius so we're going to
1264:03 - say base radius and we're going to say
1264:05 - equals red parameter here and we're
1264:07 - going to do the same for our height so
1264:09 - it's not going to return anything the
1264:11 - function here and we're going to say set
1264:13 - height and we're going to take our
1264:15 - parameter n so i'm going to say double
1264:17 - height param and we're going to use that
1264:20 - to
1264:21 - assign
1264:22 - stuff to our member variable we're going
1264:24 - to say hi and we're going to say height
1264:27 - param okay so this is our thing here now
1264:30 - we have two functions to get stuff from
1264:33 - our class and we have two functions to
1264:35 - set data to our member variables here
1264:38 - and again remember that we can't have
1264:41 - direct access to these member variables
1264:44 - on the outside of the class and if we
1264:46 - want to do that we're going to be able
1264:48 - to do that through our setter and getter
1264:50 - functions now for these functions
1264:52 - setters and getters to be accessible
1264:54 - from the outside they needed to leave in
1264:57 - the public section of our class you see
1264:59 - this public keyword here is going to
1265:01 - apply to anything after it until we
1265:05 - change this to private software so the
1265:07 - public scope is basically going from the
1265:10 - constructors here
1265:11 - all the way to our set height function
1265:14 - and once we put this private keyword
1265:17 - here everything after that is going to
1265:19 - be private this is how these things work
1265:21 - so let's try and use this in main we're
1265:23 - going to set up a cylinder object
1265:25 - cylinder one and let's put in for
1265:28 - example two and three why not and now if
1265:31 - we want to have access to the base
1265:33 - radius remember if we tried to access
1265:36 - that directly let's say that if we try
1265:39 - to do something like cylinder one and
1265:41 - say base radius you're going to see that
1265:44 - we're going to have a squiggly line
1265:45 - meaning that there's something wrong
1265:47 - with our call here let's bring up a
1265:48 - terminal
1265:49 - and see what visual studio code thinks
1265:51 - about this membership base radius
1265:53 - declared this inaccessible here if we
1265:55 - try to weld we probably going to get a
1265:57 - compiler error that says that base
1265:59 - radius is private in this scope and
1266:02 - that's what we have here declare the
1266:04 - private here so we can't access this
1266:07 - from the main function here but now that
1266:09 - we have our getter functions we can go
1266:12 - through them and have access to
1266:14 - private member variables and notice that
1266:16 - because we are returning by value here
1266:19 - what return is going to be a copy you
1266:21 - really need to keep an eye for whether
1266:24 - what you are manipulating is the
1266:26 - original stuff or a copy so here we're
1266:29 - going to be returning by value and we're
1266:31 - going to return a copy but this is still
1266:33 - useful in some cases so here we can use
1266:36 - allocator let's take out this here and
1266:39 - say get base radius it is a method or a
1266:42 - function so we need to put our function
1266:45 - call here and now if we try to build
1266:47 - let's pass this through gcc and see what
1266:50 - we get you see the build is good we can
1266:52 - run this program let's clear and run
1266:55 - rooster you're going to see that the
1266:57 - base radius is two now now that we have
1266:59 - this sense we can actually modify stuff
1267:01 - about our cylinder here let's put in 10
1267:05 - and 10 just to be able to follow this
1267:07 - easily and we're going to print the
1267:09 - volume let's say volume and we're going
1267:12 - to say volume here we're not going to
1267:14 - use the getter here i'm going to say
1267:16 - volume this is going to print our volume
1267:19 - but we're going to modify our member
1267:21 - variables remember this is an object of
1267:24 - our cylinder class
1267:26 - so we're going to say cylinder 1 set
1267:28 - base radius we can do that and we can
1267:31 - change this to 100 for example and we
1267:33 - can change the height that height we can
1267:36 - use this member function because we have
1267:39 - it now and we're going to set this to 10
1267:41 - why not now if we print the volume
1267:44 - you're going to see that the volume has
1267:46 - changed because we are going through our
1267:49 - public
1267:50 - setter and getters methods so the
1267:52 - cylinder is now going to be using this
1267:54 - data and for the first case here the
1267:56 - cylinder is going to be using the data
1267:59 - we used in our constructor here let's
1268:01 - both and run this application the build
1268:03 - is good we can clear and run rooster now
1268:06 - for the first time we're going to see
1268:07 - that our volume is this number and for
1268:10 - the second time our volume is going to
1268:13 - be multiplied by 10 because we changed
1268:16 - the base radius to 100 and if you put
1268:19 - these numbers in you're going to see
1268:21 - that they make sense we are able to
1268:23 - modify our member variables through our
1268:26 - setter and getter functions and again
1268:28 - for this setter and getter functions to
1268:30 - work they have to be in the public scope
1268:33 - of your class because if you make them
1268:35 - private they're not going to be
1268:36 - accessible from the outside and you're
1268:38 - going to get a compiler error let's try
1268:40 - and do that we are learning so we're not
1268:43 - afraid to break things a little bit so
1268:45 - let's make them private we can do that
1268:47 - and bring this a little bit to the left
1268:50 - and at the moment we do that we should
1268:51 - have a few squiggly lines in our main
1268:54 - function and we do expect this because
1268:57 - they are private now so we have no
1268:59 - business accessing them from the main
1269:01 - function like this they are meant to be
1269:04 - used from the inside of the class if
1269:06 - they are private like this and if you
1269:08 - try to use them from the outside you're
1269:10 - going to get a compiler error let's pass
1269:13 - this through gcc to really see the
1269:15 - compiler error and we're going to get
1269:17 - set height is private from the context
1269:20 - of the main function and if we go up i
1269:22 - think we're going to see the same thing
1269:24 - for a set base radius and that's here
1269:28 - this is really all we set out to do in
1269:29 - this lecture showing you how you can use
1269:32 - setters and getters to manipulate your
1269:34 - member variables from the outside
1269:36 - and i hope you found this useful we are
1269:39 - going to stop here in this lecture in
1269:41 - the next one we're going to show you how
1269:42 - you can split your class across multiple
1269:45 - files but before i let you go let's fix
1269:49 - this so that we don't have a compiler
1269:50 - error here so we're going to remove this
1269:53 - private keyword we have put here and
1269:55 - we're going to build again to make sure
1269:57 - the world is good let's use gcc for that
1270:00 - the world is good and i will see you in
1270:03 - the next lecture go ahead and finish up
1270:05 - here and meet me there in this lecture i
1270:07 - am going to show you how we can split
1270:10 - our class information across multiple
1270:13 - files so far what we have been doing is
1270:16 - really cramping everything in the main
1270:18 - function we had our constant declaration
1270:21 - we had our cylinder class definition and
1270:24 - we had our main function to use these
1270:27 - things all cramped into the main cpp
1270:30 - file now we're going to see how we can
1270:32 - do things better the first thing we can
1270:34 - do is move our constant in another file
1270:38 - because if you think about it users of
1270:40 - your class in the main function don't
1270:43 - care about this constant pi because it
1270:46 - really is an implementation detail
1270:49 - that should leave somewhere else or even
1270:51 - inside the cylinder class but we're
1270:53 - going to put this in a separate file
1270:55 - because that's going to give us room to
1270:57 - put as a constant if we need to do that
1271:00 - so if we split things up like this
1271:03 - when we want to use the pi variable we
1271:05 - will need to include the constants file
1271:08 - because that's going to give us access
1271:10 - to it but we don't have to maintain it
1271:12 - in the main function so this is a little
1271:15 - better but another thing we can do is
1271:17 - remove the cylinder in another separate
1271:19 - file and do something like this so now
1271:22 - you see that our cylinder declaration
1271:25 - and definition has moved in a file
1271:27 - called cylinder.h
1271:29 - and we have our constant pi
1271:32 - living in another file called
1271:33 - constants.h
1271:35 - and if we want to use our cylinder class
1271:37 - like we have been using it all along we
1271:40 - will need to include the header that
1271:43 - brings it in and this is how we're going
1271:45 - to do it and we will be able to use it
1271:47 - in the main function if we set things up
1271:50 - like this but we can go even further we
1271:52 - can split our class declaration and
1271:55 - definition in two separate files what
1271:58 - we're going to have in the header is
1271:59 - going to be really a preview of the
1272:01 - class
1272:02 - and in the cpp file which is going to be
1272:05 - called
1272:05 - cylinder.cpp we're going to have the
1272:08 - implementation details of our class and
1272:11 - again this is going to make things a
1272:13 - little easier to manage because it's
1272:15 - really not good to have everything
1272:17 - cramped into your main cpp file it
1272:20 - should really have high level details
1272:23 - about how your application works and all
1272:26 - the low level details should be split
1272:28 - into different files this is good design
1272:31 - now that you have an idea about this
1272:33 - let's head over to visual studio code
1272:36 - and show you how you can do this okay
1272:37 - here we are in our working folder the
1272:40 - current project is class across multiple
1272:43 - files we're going to grab our template
1272:46 - files and put them in place and we're
1272:48 - going to open this in visual studio code
1272:50 - so that we can really play with us this
1272:52 - is going to open our folder we can open
1272:55 - the main cpp file we are going to clean
1272:58 - it up a little bit and we are going to
1273:00 - grab our class definition and put that
1273:03 - on top here so this is our cylinder
1273:05 - class we have the constructors we have
1273:07 - the functions the volume function here
1273:10 - and we have our setters and getters
1273:12 - inside down we have our member variables
1273:14 - which happen to be private to this class
1273:16 - here now what we want to do is to
1273:19 - organize
1273:20 - our code better and the first thing we
1273:22 - need to do is to move this constant from
1273:26 - the main file here because it's really
1273:28 - not that useful at this point here users
1273:31 - of your classes won't really care about
1273:33 - what pi is because it is an
1273:36 - implementation detail to the cylinder
1273:38 - class because we are using that to
1273:40 - compute our volume so this constant
1273:42 - really has no business being in the main
1273:45 - file we're going to move this in a
1273:46 - separate file we're going to set up a
1273:48 - new file we're going to come to the left
1273:50 - here click on the plus icon here that
1273:52 - says new file we're going to say
1273:55 - constants and we're going to call this
1273:57 - constants.h because it's going to be a
1273:59 - header file and we can just come from
1274:02 - the
1274:03 - main cpp file we're going to copy this
1274:06 - we're going to cut this actually and
1274:08 - we're going to put this in our separate
1274:11 - file which is constants.h
1274:13 - after we do this we're going to come in
1274:15 - our main cpp file and we're going to
1274:18 - include that header file so let's do
1274:20 - that we're going to include constants.h
1274:24 - and the moment we do that you're going
1274:25 - to see now visual studio code knows
1274:28 - where this constant is but we don't have
1274:30 - to deal with that directly here another
1274:32 - benefit of doing things like this is
1274:34 - that we can go in this header file and
1274:37 - declare thousands of other constants and
1274:40 - we can have access to them in the main
1274:42 - function by just using this single line
1274:46 - that includes our file here so this is
1274:48 - good design if we build our application
1274:51 - you're going to see that it is going to
1274:52 - work let's try and set up a cylinder
1274:54 - object we're going to say cylinder 1 and
1274:57 - we're going to put 10 and 10 n as our
1275:00 - parameters and we're going to print the
1275:02 - volume of this little guy so this is
1275:04 - easy to do now we're going to say volume
1275:07 - and we're going to print that out
1275:08 - cylinder one and we're going to call the
1275:10 - volume method and this is going to print
1275:13 - our thumb and again i am going to be
1275:15 - using the terms functions and methods
1275:19 - interchangeably in this course and what
1275:21 - i mean in the context of the class
1275:23 - that's going to be the member functions
1275:25 - of the class so don't be confused by
1275:27 - this right here if we build and run this
1275:30 - application it should be working right
1275:32 - because we have everything we need for
1275:35 - it to work
1275:37 - let's see if the world was good the
1275:39 - build was good we can bring up a
1275:41 - terminal and actually run this let's
1275:43 - clear and run rooster this is going to
1275:45 - print our volume so the code is working
1275:47 - right the second thing we want to do is
1275:49 - to move this class all together in
1275:52 - another file because we don't really
1275:54 - want to see it
1275:56 - here in the main function what we really
1275:59 - want is to use stuff and we don't care
1276:01 - about how those things are set up in the
1276:04 - same logic we used when we used std
1276:07 - strength we didn't really care about how
1276:09 - hdd strength is put together all we
1276:12 - really wanted was to include the class
1276:14 - that brings it in and use it in our code
1276:18 - we're going to be setting up the same
1276:20 - behavior for our cylinder class here and
1276:22 - it is going to be given in its own
1276:24 - separate file so let's set up another
1276:27 - header file we're going to call this
1276:28 - cylinder dot h and we're going to grab
1276:31 - our class definition all together so
1276:33 - we're going to go from the bottom here
1276:36 - and select everything that includes our
1276:39 - class we're going to cut this out we're
1276:41 - going to go in our cylinder header and
1276:43 - we're going to paste this in there and
1276:46 - we're going to come back to our main
1276:47 - file and include our cylinder class so
1276:50 - let's do that we're going to include and
1276:52 - we're going to say cylinder.h
1276:54 - and this is going to make things work
1276:56 - remember the preprocessor is going to
1276:59 - put these things on the preprocessor is
1277:01 - basically going to go in constants it's
1277:04 - going to take whatever is inside and
1277:06 - then it's going to paste that here and
1277:08 - it's going to take everything inside our
1277:11 - cylinder class and it's going to paste
1277:13 - that here so it's basically going to be
1277:15 - like we are declaring these things in
1277:18 - the main function but our code is going
1277:20 - to be better organized now if we try to
1277:23 - build this program it is going to world
1277:25 - exactly like it did because we have all
1277:27 - the information for its world let's
1277:30 - build world has finished successfully so
1277:32 - the world is good and we can run this
1277:35 - program and it's going to do what it was
1277:36 - doing all along we can clear and run
1277:39 - rooster don't worry about visual studio
1277:41 - code here i don't know what the problem
1277:43 - is with that it's just having ah it's
1277:45 - having a problem with the pi
1277:48 - constant here because it's not included
1277:50 - in here so what we can do is say include
1277:53 - and include our constants header and if
1277:56 - we do this the problem here is going to
1277:58 - go away but we're going to have a
1278:01 - problem if we're trying to run this
1278:03 - program now because try to think about
1278:05 - it in the main function we are including
1278:08 - the constants header
1278:09 - and in the
1278:11 - header of cylinder we are also including
1278:14 - this little guy here so if the processor
1278:17 - comes it's going to include
1278:19 - this and it's going to have this little
1278:21 - guy inside our main function and the
1278:24 - cylinder is also going to include this
1278:26 - because it's including this header so
1278:29 - when the preprocessor is done we're
1278:31 - going to have our constant here declared
1278:34 - twice and if we try to build this
1278:36 - program you can expect bad things to
1278:38 - happen because it's really not good to
1278:40 - have the same thing defined more than
1278:43 - once in your entire program and let's
1278:47 - try and build and show you this
1278:48 - hopefully we're going to get a compiler
1278:50 - error
1278:51 - and it's going to blow up in our face
1278:53 - it's going to say hero redefinition of
1278:55 - const double pi so what is going on here
1278:58 - we are including this thing twice once
1279:01 - here and at the second time it's coming
1279:04 - in directly from the cylinder class
1279:06 - because we are including that in this
1279:09 - location here and what the preprocessor
1279:11 - is basically going to do it's going to
1279:14 - copy the entire file here and it's going
1279:16 - to paste that in the place of cylinder.h
1279:19 - here and this constants header is
1279:22 - basically going to be included twice so
1279:24 - it's going to be redefined here that's
1279:26 - the problem we have one way we have to
1279:28 - solve this in c plus plus is by using
1279:32 - include chords and the way we do that we
1279:34 - come in our constants header and we say
1279:37 - pound if
1279:39 - and def
1279:40 - this is a way to say
1279:42 - if something is not defined yet and
1279:45 - let's say cylinder underscore h and
1279:48 - we're going to say define
1279:49 - cylinder underscore h and we're going to
1279:52 - come down to the end and say and f this
1279:56 - is a way we have to tell the
1279:57 - preprocessor to only do something or
1280:00 - include the code we have within these
1280:03 - things if the condition on top here is
1280:07 - satisfied so for example the code inside
1280:10 - here is going to be put in our c plus
1280:14 - source file
1280:15 - if the cylinder name here is not defined
1280:18 - in the eyes of the preprocessor so it's
1280:21 - going to say if cylinder underscore h is
1280:24 - not defined i am going to define that
1280:26 - and i am going to put this code here but
1280:29 - if it's already defined it's going to
1280:31 - skip all these things and it's not going
1280:32 - to include this okay so this is the
1280:34 - logic here and i noticed this is really
1280:37 - not a cylinder file so we're going to
1280:39 - change this to constants
1280:41 - underscore h let's say that and let's do
1280:44 - the same here and this is going to do
1280:46 - our thing and we're going to go in our
1280:48 - cylinder header and do the same thing
1280:51 - and put in our include guard it is
1280:54 - basically a guard that is going to guard
1280:56 - against something
1280:58 - being included more than once
1281:01 - so let's do that in our cylinder header
1281:03 - so we're going to wrap this inside our
1281:06 - include guards we're going to say if n
1281:08 - def you see visual studio code is really
1281:10 - helping out here and we're going to put
1281:12 - in the name we're going to use for this
1281:14 - this is a cylinder class so i think it
1281:16 - makes sense to call this cylinder
1281:19 - underscore h and we're going to do the
1281:21 - same thing here define cylinder and
1281:24 - we're going to end f at the end of the
1281:27 - file here so we're going to say end f
1281:29 - and again this is the syntax of the
1281:31 - preprocessor i don't want to get too
1281:33 - much into this because we will learn
1281:35 - about this later in the course but we
1281:37 - can now use this to guard against
1281:41 - something being included more than once
1281:44 - and if we're trying to build the program
1281:46 - now hopefully it's going to world let's
1281:48 - use the gcc and now you see that the
1281:50 - world is good even if we are including
1281:53 - the constant header multiple times in
1281:56 - the main file here we can even go down
1281:59 - and do that like a thousand times so
1282:02 - let's do that and you're going to see
1282:03 - that if we try to compile it is going to
1282:05 - boil define because now we have a guard
1282:09 - guarding against including this thing
1282:11 - more than once the preprocessor is
1282:13 - basically going to come in here and say
1282:15 - if
1282:16 - the constant's name is not defined i'm
1282:19 - going to define that name
1282:21 - and i am going to put the code here in
1282:24 - the source file that includes me
1282:26 - if it happens to be already defined this
1282:29 - condition here is going to fail it's not
1282:30 - going to do any more than in this file
1282:33 - the preprocessor is basically going to
1282:35 - give up on this file here this is what i
1282:38 - want you to know so now we should be
1282:40 - able to split our code into multiple
1282:43 - files and now that i think about it we
1282:45 - don't really need to include the
1282:47 - constants header here because it's going
1282:49 - to be broadened by the cylinder class
1282:51 - but it was a good opportunity to teach
1282:53 - you about the include guards here now
1282:56 - that you notice we're going to remove
1282:57 - this and we're going to build and show
1282:59 - you that this is going to work anyway so
1283:01 - weld is good we can run our program
1283:04 - clear and run rooster this is going to
1283:06 - work the last thing i want to show you
1283:08 - is that we can go even further and split
1283:11 - our class into two separate files
1283:14 - because people who come to the header
1283:16 - file are usually interested in your
1283:19 - class definition they are really not
1283:23 - interested in your implementation
1283:25 - details for example they want to see
1283:27 - that you have a volume function and they
1283:30 - want to know that they can call that
1283:32 - function but they don't really want to
1283:34 - know how you compute your volume and we
1283:36 - can really make events simple for them
1283:38 - and hide the implementation details in a
1283:41 - separate cpp file so let's do that we're
1283:44 - going to set up a new cpp file we're
1283:46 - going to call this cylinder that's cpp
1283:48 - and we're going to
1283:50 - move the implementations
1283:53 - of our functions
1283:55 - in the cpp file and i am doing this just
1283:58 - to show you that it is possible in
1284:01 - practice you're going to have to decide
1284:02 - for yourself what you want to keep in
1284:04 - the header file and what you want to
1284:06 - keep in the cpp file so the cylinder
1284:09 - default constructor here is going to
1284:11 - stay this way but we can move the other
1284:14 - constructor here in the cpp file and the
1284:16 - way we do that we're going to just grab
1284:18 - this and i am going to change this line
1284:20 - by line so that you can see this
1284:23 - and in the cpp file the first thing we
1284:25 - want to do is to include the cylinder
1284:27 - header because the implementations here
1284:30 - are going to be using this
1284:32 - and we're going to put in our
1284:33 - constructor and modify it to be fit for
1284:36 - living in a cpp file so let's come here
1284:39 - and do that the way we tell this that
1284:42 - this is really an implementation of a
1284:44 - function we have in our header here is
1284:47 - to put the class name in front we're
1284:49 - going to say cylinder and put two
1284:50 - columns the moment we do that the
1284:53 - compiler is going to know that this is
1284:55 - an implementation of a function we have
1284:58 - in our header file and this is the
1284:59 - function here and now we can take out
1285:02 - the body here and live this as a
1285:05 - prototype for the function which is our
1285:07 - constructor view we can do this
1285:09 - okay if we do this in world the code is
1285:12 - going to world it's going to construct
1285:13 - our objects let's go back in main cpb
1285:16 - and make sure that that's the
1285:18 - constructor we are using it is we can
1285:20 - weld and make sure that what we just did
1285:24 - didn't break anything we are building
1285:26 - and we can clear things up a little bit
1285:28 - and run rooster this is going to give us
1285:31 - our volume and we have started to split
1285:34 - things up
1285:35 - in our class here some things are going
1285:38 - to leave in the header file some other
1285:40 - things are going to leave in the
1285:41 - implementation file so we have moved our
1285:43 - constructor here let's move the volume
1285:45 - function we can grab it and i move
1285:47 - things line by line i think this is the
1285:49 - best way to learn
1285:51 - and i think we can move this things a
1285:53 - little bit to the left let's do that and
1285:56 - we're going to say that this is a
1285:58 - function implementation for some
1286:01 - function that is declared in the class
1286:03 - here so we're going to say cylinder and
1286:05 - we're going to put two columns this is
1286:07 - going to tell the compiler this is an
1286:09 - implementation of the function we have
1286:12 - in our class and the return type has to
1286:15 - live in front of this scope resolution
1286:18 - operator okay what we have here cylinder
1286:21 - column column is called the scope
1286:23 - resolution operator and is basically
1286:26 - telling the compiler that our function
1286:29 - called volume leaves in the scope of the
1286:32 - cylinder class this is what the syntax
1286:34 - here is saying and this little thing
1286:37 - here is called a scope resolution
1286:39 - operator
1286:40 - okay so we have moved our volume
1286:42 - function we can now take the body out
1286:45 - from the class and keep the prototype
1286:48 - here we can go down and really practice
1286:50 - on the setters and gators so let's do
1286:52 - that so we're going to grab them all
1286:54 - together because now you have the gist
1286:56 - about how this works we can copy them
1286:59 - and move them into the cpp file and
1287:02 - we're going to fix the code lined by
1287:04 - line here so let's make sure they are
1287:07 - aligned properly we have two left to do
1287:11 - let's do that and i really have to show
1287:13 - you this life because some people are
1287:15 - going to have problems regarding how i
1287:18 - did this so i want you to see this live
1287:20 - as i do this i'm not going to edit this
1287:23 - out so we're going to put our scope
1287:25 - resolution operator after our return
1287:28 - type here i'm going to say cylinder
1287:30 - cylinder can't type can i okay we have
1287:32 - this in and we can really copy this and
1287:35 - paste this into place wherever it is
1287:37 - needed so i'm going to paste that here i
1287:40 - am going to paste that here and i am
1287:42 - going to paste that here now we have
1287:44 - successfully moved all the functions in
1287:47 - the implementation file
1287:49 - cylinder.cpp and we can go back in our
1287:52 - header and remove the bodies because we
1287:54 - don't need them here if we keep them
1287:57 - here we're going to have two definitions
1287:59 - for this functions and we're going to
1288:00 - have compiler errors let's take this out
1288:03 - we're going to take the body out we're
1288:05 - going to take the body out and we're
1288:07 - going to take the body out let's do that
1288:09 - for a gate base radius here
1288:11 - and now if we build our program it
1288:14 - should work we're going to work with gcc
1288:17 - see the world is good and if we try to
1288:19 - run the program it should give us what
1288:21 - it was given before this is the volume
1288:23 - here
1288:24 - one thing i want you to see is that you
1288:26 - don't want to keep two definitions for
1288:29 - your functions so for example we can
1288:32 - grab the body here and bring this back
1288:34 - in the header file i want you to see
1288:36 - what's going to happen if you do that i
1288:38 - am going to paste that in here and i am
1288:41 - going to move things a little bit to the
1288:43 - right to align things properly here so
1288:46 - if we do this the compiler is going to
1288:48 - see that we are calling that constructor
1288:51 - and the compiler is going to have no
1288:53 - problem with us but once we hit the
1288:55 - linker stage the linker is going to find
1288:57 - that we have two definitions for the
1288:59 - constructor here we have one in the
1289:02 - header and we have one in the
1289:04 - implementation file and this is going to
1289:07 - raise a compiler error saying we have
1289:09 - two definitions for the constructor here
1289:12 - and the linker want to know which one to
1289:14 - use so it's going to give you an error
1289:17 - let's build and really show you this
1289:18 - because this can be hard to debug if you
1289:21 - don't know what is happening okay you
1289:22 - see we have world finished with errors
1289:25 - and the problem is cylinder cylinder
1289:28 - double double is redefined we don't want
1289:31 - to have two definitions for the sum
1289:33 - function so once you move things from
1289:36 - header to implementation file be sure
1289:39 - you don't have any more definitions left
1289:41 - in the header or you're going to have
1289:43 - really hard to debug problems
1289:46 - and now i think we have our program
1289:49 - organized fairly well for what we know
1289:52 - so far about c plus plus we have our
1289:55 - constants living in another header file
1289:58 - and we have learnt about include cards
1290:00 - what we can use to guard against our
1290:03 - stuff being included more than once by
1290:05 - the preprocessor we have our cylinder
1290:08 - class living in its own file and again
1290:10 - we have an include guard here and you
1290:12 - can see that this class now is really
1290:14 - easy to look at we can look at the
1290:16 - information about the member functions
1290:18 - we have for example we have a default
1290:21 - constructor we have a constructor that
1290:23 - takes two parameters but we don't see
1290:25 - the details about how these things do
1290:28 - their jobs for example we don't see the
1290:30 - details about how the volume is computed
1290:33 - those details are hidden in the cpp file
1290:36 - and if you want to see them you need to
1290:38 - go to this implementation file here this
1290:40 - is a good design and i encourage to
1290:43 - split your c plus plus programs in
1290:46 - multiple files like this this is going
1290:48 - to make your life easier in this lecture
1290:50 - we're going to see how we can manage our
1290:52 - class objects through pointers and in
1290:55 - most cases we need to manage our class
1290:58 - object through pointers if we are using
1291:01 - some form of dynamic memory allocation
1291:04 - here is a simple example we have our
1291:06 - cylinder class included and down here
1291:08 - you see that we can create cylinder
1291:11 - objects on the stack if we use the
1291:13 - syntax like we do here the objects are
1291:15 - going to be created on the stack and we
1291:18 - have seen that we can access the
1291:20 - behaviors or data inside our class
1291:22 - object using the data notation like we
1291:25 - do here for example here we are calling
1291:27 - our volume function but sometimes we
1291:30 - want to manage our objects through
1291:32 - pointers for example if you look at the
1291:35 - syntax we have here we are saying
1291:37 - cylinder and using the asterisk here
1291:40 - this is going to say that this is going
1291:42 - to be a pointer to a cylinder type
1291:45 - and i'm going to give it a name c2 and
1291:47 - we can allocate our object on the heap
1291:51 - using the new operator this is going to
1291:53 - dynamically allocate space from the heap
1291:56 - and that memory space is going to be
1291:58 - used to store our cylinder object now
1292:02 - the interesting thing is going to happen
1292:04 - when you try to access behaviors from
1292:08 - your cylinder object here for example if
1292:10 - we look at this line here we are trying
1292:13 - to print the volume of this cylinder and
1292:16 - you notice that we have to go through
1292:18 - ugly dereferencing here we have to
1292:20 - dereference the object and then call our
1292:24 - method through the dot operator here but
1292:27 - what i want you to see is that we can
1292:29 - avoid this ugly the reference that we
1292:31 - are doing here and use the pointer
1292:34 - access notation this dash greater than
1292:37 - symbol you see here is going to allow us
1292:40 - to access stuff directly using the
1292:42 - pointer to an object that is dynamically
1292:45 - allocated on the hip okay after we are
1292:48 - done using our cylinder object remember
1292:51 - it is memory that was dynamically
1292:53 - allocated from the hip we have to
1292:55 - release the memory so that it can be
1292:57 - used by the operating system and we
1293:00 - release the memory using the delete
1293:02 - operator as we do here okay the idea i
1293:05 - wanted to introduce here is that we can
1293:07 - use players to manage our cylinder
1293:10 - objects and this is one way we can do
1293:12 - this and once we are using a pointer as
1293:16 - a handle to our cylinder object we can
1293:19 - use the pointer access operator here to
1293:22 - access stuff from our class objects
1293:25 - easily and another thing you should know
1293:27 - is that we can actually create a
1293:29 - cylinder object and store in the address
1293:32 - of objects that we have on the stack and
1293:34 - we're going to see this in a minute when
1293:36 - we hit visual studio code now that you
1293:38 - have an idea about this let's head over
1293:41 - to visual studio code and play with this
1293:43 - a little more okay here we are in our
1293:46 - working folder the current project is
1293:48 - managing class objects through pointers
1293:51 - we can see the entire name here and now
1293:54 - we're not going to grab our template
1293:56 - project because we want to start from
1293:58 - the project we had in this lecture on a
1294:02 - class across multiple files so we're
1294:04 - going to go in that project and grab
1294:06 - everything from there
1294:08 - except for the executable because we
1294:10 - obviously don't want this
1294:12 - and we're going to go in our current
1294:14 - project and paste in the code and this
1294:17 - is going to give us a good starting
1294:18 - point so we can grab this and open
1294:21 - this project in visual studio code it's
1294:23 - going to open the folder and we're going
1294:25 - to have everything we want to start
1294:27 - doing what we want to do in this lecture
1294:29 - here so now we should have access to our
1294:32 - cylinder class and if you look here we
1294:35 - have an object of cylinder type already
1294:38 - created by this line on liner number six
1294:41 - here and we have seen that we can use
1294:43 - the syntax like cylinder volume here
1294:46 - using the dot call operator to access
1294:49 - stuff from our class object and this is
1294:53 - going to work but we want to see that we
1294:54 - can use pointers to manage our object
1294:57 - here and the first thing i want you to
1294:59 - see is that we can manage a stack object
1295:01 - through pointers and to really show this
1295:04 - off let's set up a
1295:06 - another variable it's going to be a
1295:07 - cylinder pointer and it's going to be p
1295:10 - cylinder one it's going to be a pointer
1295:12 - to cylinder one here that's what i mean
1295:15 - and we can give it an address of
1295:18 - cylinder one as a value so we can do
1295:20 - that for example and put in the address
1295:22 - of operator and this is going to work
1295:25 - now we can go through our pointer here
1295:27 - and do stuff with this cylinder object
1295:30 - but the syntax is going to be pretty
1295:32 - ugly so for example let's try and print
1295:35 - the volume of our cylinder
1295:37 - we're going to say htdcl and say volume
1295:40 - can save that and we're going to have to
1295:42 - go through the dereference operator so
1295:45 - if we do something like p cylinder one
1295:47 - and try to use the dot operator
1295:50 - you're going to see that we have the
1295:53 - volume function but if we try to call it
1295:56 - let's do that let's make sure we are
1295:59 - using the dot operator here if we try to
1296:01 - compile this program it's not going to
1296:03 - compile because
1296:05 - we are trying to call stuff from a
1296:08 - pointer and remember a pointer is just
1296:11 - going to store an address it doesn't
1296:13 - really have information about the type
1296:16 - that it is pointing to if we try to
1296:18 - compile this program we're going to get
1296:20 - a compiler error so let's use gcc to do
1296:22 - that
1296:23 - and we're going to get request for
1296:25 - member volume in pc lender 1. remember p
1296:28 - cylinder 1 is just a pointer it's not an
1296:31 - object so we can't really call the
1296:33 - volume function to f
1296:35 - if we want to use the dot call operator
1296:38 - here we have to the reference and
1296:40 - actually get to the actual
1296:42 - object that the pointer is pointing to
1296:45 - and we do that using the star operator
1296:47 - you already know how to dereference a
1296:49 - pointer so we can dereference our
1296:51 - pointer and then call the volume
1296:53 - function on what the pointer is pointing
1296:55 - to and this is going to work it's going
1296:57 - to print out volume let's build now now
1297:00 - that we are dereferencing correctly and
1297:02 - you see that this is going to work and
1297:04 - if we try to print this let's bring up a
1297:07 - terminal so that we can run this program
1297:09 - let's run rooster you're going to see
1297:11 - that we have our volume here so to
1297:14 - really get to what is pointed to
1297:17 - you need to use the reference operator
1297:19 - and then call whatever method you want
1297:21 - to call on your object but we can do
1297:23 - things even easier there is a syntax we
1297:26 - can use to use the pointer directly here
1297:28 - because going through all this
1297:30 - dereferencing ugliness is really not
1297:33 - cool so we're going to grab this and
1297:35 - show you that we can use the dash
1297:37 - greater than operator that's how i
1297:40 - called it
1297:41 - and if we use that we don't need to the
1297:44 - reference
1297:45 - all we need to do is use the dash
1297:48 - greater than symbol here and it's going
1297:50 - to
1297:51 - directly tell the compiler don't code
1297:54 - stuff on the pointer directly do the
1297:57 - reference the pointer internally and
1297:59 - then call the volume function on
1298:01 - whatever you get after referencing so
1298:04 - this is basically going to push the the
1298:07 - referencing ugliness here behind the
1298:09 - curtains of the compiler and we can use
1298:12 - a nice syntax like this and i think this
1298:15 - is much better than what we were doing
1298:17 - here so if we try to bolt now we're
1298:19 - going to build and print our volume
1298:21 - you're going to see the bolt is good you
1298:23 - can clear and run rooster you see we see
1298:26 - our volume here so this is what i want
1298:28 - you to see it is possible to manage your
1298:31 - cylinder objects through pointers and
1298:35 - this is one way we can do this by
1298:37 - managing a stack object through pointers
1298:39 - and this is what we are doing here if
1298:41 - you want to call stuff on your class
1298:44 - object you can either do the ugly stuff
1298:47 - we do here or you can use the nice
1298:50 - pointer access operator and it is going
1298:52 - to be cool okay now that we have seen
1298:54 - this let's see another use case in which
1298:57 - we're going to be creating a cylinder
1298:59 - object on the heap through the new
1299:01 - operator okay we can go down and save
1299:03 - that we're going to say cylinder pointer
1299:06 - it's going to be p
1299:07 - c lender 2. we can call it like this and
1299:10 - then we're going to say new cylinder and
1299:12 - you're going to see that we can call a
1299:15 - constructor
1299:16 - we have two types of constructors we can
1299:19 - call we're going to call our constructor
1299:21 - that takes two parameters and we can
1299:24 - pass in 100 and
1299:26 - 100 why not oh let's put the two after
1299:29 - here we can put in whatever we want this
1299:31 - is going to create a new cylinder object
1299:34 - the space for the cylinder object is
1299:36 - going to be allocated on the hip so this
1299:38 - is a hip object and because we are using
1299:41 - the new operator here
1299:43 - the other thing you should have in mind
1299:45 - is that you will need to release this
1299:47 - memory and let's go and do that directly
1299:49 - this is a good practice because you will
1299:52 - forget to release your memory if you
1299:54 - don't really keep this in mind so we are
1299:56 - going to delete p cylinder 2 because
1299:59 - that's what we used to allocate our hip
1300:02 - memory here okay now that we have taken
1300:05 - care of memory management we can go in
1300:07 - and use our p cylinder to object
1300:10 - and for example we can print its volume
1300:12 - by using the stdc out statement here so
1300:16 - let's go down and save that
1300:18 - let's align this properly and we're
1300:21 - going to say volume
1300:22 - cylinder 2 to really make this super
1300:25 - clear and then we're going to say p
1300:27 - cylinder 2
1300:28 - and call the volume function here this
1300:30 - is going to work let's draw in world the
1300:33 - world is good we can clear and run
1300:36 - rooster this is going to give us our
1300:38 - volume and if we try and use this
1300:41 - information to create a cylinder we're
1300:43 - going to see that the volume is what we
1300:45 - see here we can even try and print its
1300:47 - base radius
1300:49 - let's do that we're going to say sdd cl
1300:52 - we're going to say p cylinder 2 and
1300:54 - we're going to say base radius we can
1300:56 - hit the dot operator here you're going
1300:59 - to see we're going to have a few options
1301:01 - in a visual studio code here if we
1301:03 - double click on get base radius here
1301:05 - you're going to see that visual studio
1301:07 - code is going to use the pointer access
1301:09 - operator here and this is really cool so
1301:12 - we can hit std and yeah we can close the
1301:14 - left pane here because we need some more
1301:17 - breathing space and if we try to
1301:20 - build and run this program and we have a
1301:23 - compiler error here and the reason is
1301:26 - get base radius is a function
1301:29 - if we go back in our cylinder class we
1301:32 - see that we have a function called get
1301:34 - base radius so if we want to call this
1301:37 - in the main function we need to call
1301:39 - that as a function so we need to put a
1301:42 - pair of parentheses here and if we build
1301:45 - we should build without a problem let's
1301:47 - do that again
1301:48 - you see the build is good and if we run
1301:50 - the program we're going to see exactly
1301:52 - what we expect let's run a rooster we're
1301:54 - going to see what we expect here and the
1301:58 - message here was really that you can
1302:01 - manage your
1302:02 - class object through pointers one case
1302:06 - is when you have a pointer that is
1302:07 - pointing to a stack object and we saw
1302:10 - that we could do that here we can also
1302:12 - use pointer notation to allocate
1302:15 - objects on the heap and point to them
1302:17 - with our pointer here and whenever we
1302:19 - are using a pointer we have the option
1302:21 - to use the pointer call operator here to
1302:24 - do things easily i am going to be
1302:26 - calling this the pointer call operator
1302:29 - to mean this from here on if we happen
1302:32 - to need this and you should know what i
1302:34 - mean by that this is really all i set
1302:36 - out to share in this lecture i hope you
1302:38 - found it interesting we are going to
1302:40 - stop here in this lecture the next one
1302:42 - we're going to learn about these
1302:44 - structures
1302:45 - go ahead and finish up here and meet me
1302:48 - there in this lecture we're going to
1302:49 - learn about these structures these
1302:52 - structures are spatial functions or
1302:54 - methods in a class that are called by
1302:57 - the compiler to destroy your object and
1303:00 - these are going to be especially useful
1303:03 - if you are for example allocating memory
1303:06 - in your constructors
1303:07 - let's look at the simple example here we
1303:10 - have a class called dog it has two
1303:13 - sections the public section and the
1303:15 - private section in the public section we
1303:18 - have two constructors a default
1303:20 - constructor that doesn't take any
1303:22 - parameter and a constructor that takes
1303:24 - two parameters n
1303:26 - the parameters are going to be used to
1303:29 - initialize our member variables and they
1303:31 - are passed by a value here for
1303:33 - simplicity and they are going to be used
1303:35 - to initialize these member variables
1303:38 - doug name dog breed and dog age
1303:41 - the special thing about this class is
1303:43 - that it has a destructor and you declare
1303:46 - the destructor using this
1303:49 - syntax here he puts a tilde character in
1303:51 - front you say the name of the class and
1303:53 - then you put an empty parameter list it
1303:56 - is also possible to declare a destructor
1303:59 - and put in its entire body in the header
1304:01 - and this is the syntax to do this
1304:04 - inside the body you're going to do
1304:05 - whatever it is you need to destroy your
1304:08 - object for example if the class here is
1304:11 - allocating some memory in the
1304:12 - constructor the destructor is the best
1304:15 - place to release that and this is an
1304:17 - example of how you can do that here is a
1304:20 - more direct example of how we allocate
1304:23 - for dynamic memory in the constructor
1304:26 - and release that memory in the
1304:28 - destructor we have our three variables
1304:30 - but we have chosen to allocate
1304:33 - our dog edge variable on the heap using
1304:36 - dynamic memory allocation and after we
1304:39 - dynamically allocate a piece of memory
1304:41 - to store our age variable we're going to
1304:44 - set that to 0 because we are in a
1304:46 - constructor if we are using the three
1304:49 - parameter constructor here we might use
1304:52 - the past parameter to initialize our age
1304:55 - variable but the important thing here is
1304:58 - that it is being
1305:00 - dynamically educated memory on the hip
1305:03 - here and when our object dies we need to
1305:07 - remember to release that memory and the
1305:10 - destructor is the best place to release
1305:12 - that memory as you see here we say
1305:14 - delete dark age when our object dies and
1305:17 - the compiler is going to call this
1305:20 - function when it's about to kill the
1305:22 - object
1305:23 - so you might ask when are destructors
1305:27 - really called we are going to start by
1305:29 - looking at obvious cases here for
1305:31 - example when a local stack object goes
1305:34 - out of scope
1305:36 - the destructor is going to be called
1305:37 - because that object is going to be wiped
1305:40 - out from memory so this is an obvious
1305:42 - case
1305:43 - in which the compiler will need to call
1305:45 - a destructor also when a hip object is
1305:48 - released from memory using delete the
1305:51 - destructor is also going to be called
1305:53 - but there are some indirect ways in
1305:55 - which the structures are also called for
1305:57 - example when an object is passed by a
1305:59 - value to a function
1306:01 - this is going to call the destructor to
1306:04 - kill the object when the object goes out
1306:07 - of scope in the function because when an
1306:10 - object is passed by value we're going to
1306:12 - have a copy in the local scope of the
1306:14 - function and when the function exits
1306:17 - that local copy is going to be killed
1306:19 - and we're going to see an example of
1306:20 - that another case where you might have
1306:23 - the the structure called is when a local
1306:25 - object is returned from a function
1306:27 - another copy is going to be created to
1306:30 - be used outside the function and the
1306:32 - copy inside the function is going to be
1306:34 - killed but this is not guaranteed as
1306:37 - some compiler may optimize your return
1306:40 - value and use some kind of reference so
1306:43 - you're not guaranteed to see this
1306:44 - behavior but it is possible to see it
1306:47 - now that you have an idea about
1306:49 - destructors it's time we headed over to
1306:52 - visual studio code and play with us a
1306:54 - little more okay here we are in our
1306:56 - working folder the current project is
1306:58 - the structures we're going to grab our
1307:00 - template files pretty quick and we're
1307:02 - going to put them in place and after
1307:05 - that we're going to open our folder in
1307:07 - visual studio code by dragging and
1307:09 - dropping here this is going to open our
1307:12 - folder and we will see our main cpp file
1307:15 - here we can open it and i clean up and
1307:18 - remove what we don't need we have an
1307:20 - unneeded breakpoint here we can remove
1307:22 - that and we're going to clean up the
1307:24 - main function the first thing we want to
1307:26 - do is to put in our dog class i am going
1307:29 - to just put this in here because i don't
1307:32 - want you to watch me type all this
1307:34 - that's just going to waste your time we
1307:36 - have two sections in the dog class we
1307:38 - have a public section which is going to
1307:40 - now contain our constructors and we have
1307:43 - a private section which is going to
1307:45 - contain three member variables we have
1307:47 - two strengths one for the name and the
1307:49 - other for the breed of our dog and we
1307:52 - have another one which is an end pointer
1307:54 - which is going to store the edge of the
1307:56 - dog and you see that this is initialized
1307:59 - to no pointer one thing you should
1308:00 - notice is that for our parameter taken
1308:03 - constructor we are passing the string
1308:06 - information here using string views to
1308:09 - avoid copies with the std string view
1308:12 - type you already know this because we
1308:14 - learned about this but for this to work
1308:16 - we will need to include a string view so
1308:18 - let's do that and now we have our class
1308:20 - and we can use it however we want
1308:23 - so but before we do we need to put in
1308:26 - the implementations for these functions
1308:29 - one way we can do that is do that
1308:31 - directly in the function here but i want
1308:33 - you to see that you can also do that
1308:35 - directly outside the class here i don't
1308:38 - think i have shown you this but it is
1308:40 - possible to do that so we're going to
1308:42 - grab the prototype for our constructor
1308:44 - and say the scope resolution operator
1308:47 - and we're going to just paste in what we
1308:49 - have copied which is the prototype here
1308:52 - and we're going to go inside put in our
1308:54 - body and in the body we're going to
1308:56 - initialize these three guys
1308:59 - so the name is going to be initialized
1309:01 - to nem param and the bridge is going to
1309:03 - be initialized to breed the param we can
1309:06 - do that and the age is going to be
1309:09 - dynamically allocated from the hip you
1309:12 - see that it is a pointer so we're going
1309:14 - to say ph equals new and because we're
1309:17 - going to allocate dynamic space to store
1309:20 - an end and we're going to put data in
1309:23 - using our good old dereference operator
1309:26 - we're going to say ph
1309:28 - equals whatever ph parameter they passed
1309:31 - and i think we should say edge here
1309:33 - because it's not a pointer so we're
1309:35 - going to say age i think this is going
1309:37 - to do better age param this is probably
1309:40 - going to be better and we're going to
1309:42 - say age param okay so now we have our
1309:45 - constructor n and it's going to allocate
1309:48 - memory from the heap and we're going to
1309:50 - put data in that new memory location
1309:53 - that has just been allocated to our
1309:56 - class here so this is our class and we
1309:58 - can go in the main function and really
1310:00 - use it however we want for example we
1310:02 - can set up a dog object so we're going
1310:05 - to say my dog and we're going to give it
1310:07 - a name the name is going to be fluffy
1310:09 - and we're going to put the breed in and
1310:12 - it's going to just be a shepherd and
1310:14 - we're going to put in the age which is
1310:16 - going to be for example a 2. let's say
1310:18 - our dog is 2 years old
1310:20 - this is valid c plus plus code it's
1310:22 - going to be setting up an object of our
1310:25 - class here and we can world to see that
1310:27 - this program is going to world without a
1310:29 - problem so both is good but if we run
1310:32 - the program we're not going to see
1310:34 - anything but we don't really need to see
1310:36 - our constructor here called because we
1310:38 - already know about constructors what we
1310:40 - want to learn about are these structures
1310:43 - and these are spatial methods that are
1310:45 - called by the compiler when your object
1310:48 - dies let's set up a destructor and see
1310:51 - it called when our dog objects die the
1310:54 - syntax to do that is to use the tilde
1310:56 - character here you're going to say the
1310:58 - name of the class you're going to put an
1311:00 - empty parameter list and if you want you
1311:02 - can put a body and do whatever you want
1311:04 - to do in the body of your destructor
1311:07 - here but again we're going to move the
1311:10 - entire definition of the destructor to
1311:13 - the outside so let's go down and save
1311:15 - that we're going to say the scope
1311:17 - resolution operator we're going to say
1311:19 - dog and we're going to put in our body
1311:21 - and the first thing we want to do in our
1311:24 - destructor is to release this memory
1311:27 - that was dynamically allocated for us if
1311:31 - we don't release it when this dark
1311:33 - object dies we're going to link memory
1311:35 - and that's really bad so let's do that
1311:37 - directly in the destructor we can say
1311:39 - delete and say ph this is going to
1311:42 - release the memory that was allocated in
1311:45 - the constructor here and we have access
1311:48 - to this ph variable because the
1311:51 - destructor is part of our class
1311:54 - any member function of your class is
1311:56 - going to have access to any member
1311:58 - variable even if it happens to be
1312:00 - private
1312:02 - okay so we forgot our tilde character
1312:05 - let's put that in here and this is going
1312:07 - to be valid c plus plus code but to
1312:10 - really see things happening here let's
1312:12 - put in an sddc out statement we're going
1312:14 - to say doug destructor called 4 and
1312:17 - we're going to say the name of the dog
1312:19 - let's say name and we're going to say
1312:21 - the same thing in the constructor we're
1312:23 - going to say hddcl and say dog
1312:26 - constructor cold for and we're going to
1312:29 - say the dog name going to use our member
1312:31 - variable and now we have our thing in
1312:33 - place we have the destructor declared in
1312:36 - the class definition and this is the
1312:39 - syntax again this is what we really want
1312:41 - to learn about in this lecture we have
1312:43 - the tilde character we have the class
1312:45 - name and we put an empty parameter list
1312:48 - let me tell you that it is not possible
1312:50 - to pass parameters to your destructor if
1312:53 - you do that you're going to get a
1312:54 - compiler error the structures will
1312:57 - always have no parameters in c plus plus
1313:00 - here we have the definition of our
1313:03 - destructor and it is going to release
1313:05 - whatever memory we have dynamically
1313:07 - allocated from the constructor here if
1313:10 - we run this program
1313:12 - we're going to see our constructor
1313:14 - called as a result of this line here
1313:16 - because we are constructing a dog object
1313:19 - and we're going to see the destructor
1313:20 - called when the main function is about
1313:22 - to end
1313:24 - let's put an stdc out state to mention
1313:26 - the main function here and say done just
1313:28 - to prove that we have hit the end of our
1313:31 - main function here i think this is
1313:32 - useful and we're going to build so let's
1313:35 - do that we're going to build with gcc
1313:37 - you're going to see that the world is
1313:39 - good so we can clear and run or program
1313:42 - let's hit enter here and clear and run
1313:44 - rooster you're going to see that the
1313:46 - constructor was called we are going to
1313:49 - say done when the main function is about
1313:52 - to end but before the main function ends
1313:54 - we're going to destroy any stack data
1313:57 - that we have in the main function and
1313:59 - our dog object is on the stats so it's
1314:02 - going to be destroyed as part of that
1314:05 - process and the destructor for dog is
1314:07 - going to be called and we're going to
1314:09 - release our memory and we're going to
1314:11 - say that dog destructor was called for
1314:13 - whatever name
1314:15 - we have assigned to our dog here so this
1314:18 - is how destructors are called when your
1314:21 - objects are killed
1314:23 - and we didn't put in the correct name
1314:26 - we said fluffy let's say fluffy because
1314:29 - that's what i wanted and now you see
1314:31 - that our destructor is really being
1314:33 - called and releasing memory however we
1314:35 - want but we can also go a little further
1314:38 - and show you another example of a case
1314:40 - where the structures are called and
1314:42 - we're going to look at a function that
1314:45 - sets up a local object of a dog we're
1314:47 - going to see the dog constructed and
1314:49 - we're going to see it destroyed when the
1314:51 - function is about to end let's do that
1314:54 - we're going to say void some funk and
1314:56 - it's going to be just some function to
1314:58 - play with us we're going to
1315:00 - move our dog declaration in some funk
1315:04 - here
1315:05 - and this is really it we're going to
1315:07 - call this function
1315:08 - and when we call it we're going to
1315:10 - construct the object here when the
1315:12 - function is about to end the compiler is
1315:14 - going to call the destructor because
1315:15 - it's going to destroy this object here
1315:18 - and we're going to see the destructor
1315:19 - called by that point the some funk
1315:22 - function is going to be popped off the
1315:24 - top of the stack we're going to hit the
1315:26 - main function here and we're going to
1315:27 - say done and the program is going to end
1315:30 - let's call some funky name here so we're
1315:32 - going to say some funk and we're going
1315:34 - to world to really see this happening so
1315:37 - we have worked successfully we can clear
1315:39 - clear properly and run rooster we're
1315:41 - going to see constructor called for
1315:44 - fluffy the structure called for fluffy
1315:46 - and you see done we have hit the main
1315:48 - function and really finished executing
1315:51 - our program here we can even see this
1315:54 - through the debugger we're going to set
1315:56 - up three break points one in the main
1315:59 - function here before we call the some
1316:01 - funk function we're going to set up
1316:03 - another one in our destructor before we
1316:06 - print the message here and we're going
1316:08 - to put another one in the constructor
1316:11 - when we are about to print this message
1316:13 - here on line 20. after we set up these
1316:16 - break points we kind of kill the
1316:19 - terminal here and minimize a little bit
1316:22 - let's kill these things here so that we
1316:24 - have a clean ah we have a lot of windows
1316:27 - here okay we have our editor here
1316:30 - and now if we go to the tab here that
1316:34 - says start or run we're going to be able
1316:37 - to click the green button here to start
1316:39 - our debugging session we are going to
1316:42 - have a terminal here so let's bring that
1316:44 - to the side so that we can see things
1316:46 - printed out nicely let's do like this
1316:49 - and now we have hit the break point in
1316:52 - the main function we can step into
1316:54 - the sum func function and we're going to
1316:56 - do that using the step into button here
1316:59 - let's click that we're going to jump
1317:01 - into some funk
1317:03 - now we have the option to step into but
1317:06 - this is going to jump us into the logic
1317:09 - of transforming the string literal here
1317:12 - into a string view because if you see
1317:15 - the constructor is going to take string
1317:16 - view parameters we can actually see this
1317:19 - let's try
1317:20 - and hit the step into button you see
1317:22 - that we are in the string view class and
1317:24 - we don't really want this so let's step
1317:27 - out and we're going to step over this
1317:30 - so that we can hit the next breakpoint
1317:32 - and you see the next breakpoint is in
1317:35 - our constructor and this proves that the
1317:38 - compiler is going to call our
1317:39 - constructor here to build our object
1317:42 - if we step over this we're going to
1317:45 - print the message from the constructor
1317:47 - and if we keep going we're going to get
1317:50 - out of
1317:51 - our constructor and you see where this
1317:54 - is going to go this is going to go in
1317:55 - the destructor because before we leave
1317:58 - the some func function our dot objects
1318:01 - is going to be destroyed so we're going
1318:03 - to release our memory and we're going to
1318:05 - branch the message from our constructor
1318:08 - and if we hit next and a step out of
1318:12 - this i think we can do that because this
1318:14 - is logic we don't want we're going to
1318:16 - try and step over this and now if we hit
1318:19 - next we're going to come back in some
1318:22 - funk and some funk is already going to
1318:24 - be finished and if we hit next we're
1318:26 - going to come back in main and we're
1318:27 - going to print done and the program is
1318:30 - basically going to be done hopefully you
1318:32 - can see that
1318:34 - the compiler is going to call our
1318:36 - destructor after it leaves some funk
1318:39 - here because it's going to be destroying
1318:41 - the local object that we have inside
1318:44 - some funk here so this is one case where
1318:46 - the destructor is going to be called by
1318:48 - the compiler and it is if you have a
1318:51 - local object that needs to be destroyed
1318:54 - when function scope finishes another
1318:57 - case where the destructor may be called
1319:00 - is if you pass
1319:02 - a
1319:02 - class object
1319:04 - parameter by value so let's change some
1319:07 - function here and make it take something
1319:09 - by value so we're going to pass a dog
1319:11 - inside and we're going to say dog param
1319:14 - this is going to do okay now that we
1319:16 - have changed some func here we can
1319:18 - really do all kinds of crazy things with
1319:21 - it for example we can set up our dog
1319:22 - object inside our main function here so
1319:26 - let's do that we can say dog and dog the
1319:29 - variable name is going to be dog we can
1319:31 - give it
1319:32 - a name which is going to be fluffy it's
1319:35 - going to have a breed of shepherd and we
1319:37 - can give it the age of 2 like we have
1319:39 - been doing all along we can call our
1319:42 - function with the dog object here but be
1319:45 - careful about what is going to happen
1319:47 - here when we do something like this
1319:49 - we're going to be passing by value and
1319:51 - the compiler is going to see that it
1319:53 - needs to copy a dog object
1319:56 - now we haven't really told our class
1319:59 - here how to copy dog objects and we do
1320:03 - that through constructors we call copy
1320:05 - constructors we haven't really learned
1320:07 - about yet but what the compiler is going
1320:09 - to do by default is copy these things
1320:12 - member by member so it's going to set up
1320:14 - a doug copy object which is going to be
1320:16 - initialized with empty strings and a
1320:20 - null pointer here and then it's going to
1320:22 - copy from our dog object
1320:25 - that we have here it's going to take the
1320:27 - name and copy that in the name member
1320:29 - variable of our dark copy it's going to
1320:31 - take the breed and copy that n in the
1320:34 - second member variable here and it's
1320:36 - going to take the age from our dog and
1320:38 - copy that in the problem is going to
1320:41 - come to this pointer here it's going to
1320:42 - copy the address and it's not going to
1320:45 - copy what it's pointed to and this is
1320:47 - going to be a recipe for a disaster i
1320:50 - don't really want to go through this
1320:51 - right now but if we try to run this
1320:54 - program it's not going to work like we
1320:56 - expect for example if we pass fluffy
1320:58 - here we're going to see
1321:01 - things that we don't expect so let's try
1321:03 - to build we're going to build with gcc
1321:06 - and the bolt is good so what we expect
1321:09 - is to have the constructor of fluffy
1321:11 - here called and we're going to copy the
1321:14 - dot object for use in some funk here and
1321:17 - to set up this copy it's not this
1321:20 - constructor here that is going to be
1321:21 - called
1321:22 - so it's not our constructor here which
1321:24 - is going to be called so we're not going
1321:26 - to see
1321:27 - this called for the copy that we set up
1321:30 - inside some funk another thing is
1321:32 - because now these two dog objects are
1321:35 - pointing to the same thing because what
1321:37 - we just copied is the address as we see
1321:41 - in our member variable here the two dog
1321:44 - objects are going to be pointing to the
1321:46 - same thing in memory and when we hit the
1321:48 - destructor we're going to call delete
1321:50 - twice and this is going to be a recipe
1321:52 - for disaster our application could
1321:55 - really crash you already know that
1321:57 - deleting a pointer twice is really bad
1322:00 - we shouldn't do this and we are doing
1322:02 - this here because we are copying i
1322:04 - realize this is a slightly confusing
1322:06 - example
1322:07 - but what i want you to know is that if
1322:09 - you pass a class object by value like
1322:11 - this
1322:12 - the copy you have inside is going to
1322:15 - cause for the destructor to be called
1322:18 - when the function exits because the copy
1322:20 - is going to be scoped inside the
1322:22 - function here so let's take out this
1322:24 - example because it really is confusing
1322:26 - but i hope you know that and i am going
1322:28 - to show you that another case where you
1322:30 - might see the destructor called is when
1322:32 - you call the destructor explicitly using
1322:37 - the delete operator on your object so we
1322:39 - can set up some func again let's do that
1322:41 - some funk and we're going to repurpose
1322:44 - it and inside we're going to set up a
1322:45 - dag object so let's grab this and reuse
1322:48 - that in our function here and we're
1322:51 - going to say dog pointer so let's say
1322:53 - dog pointer we're going to say p dog p
1322:56 - underscore dog it's going to be equals
1322:59 - to new dog and we're going to pass in
1323:02 - what we need to initialize our dog
1323:04 - object with this is going to create a
1323:07 - dark object on the hip and it is going
1323:09 - to be pointed to by p dog here
1323:11 - now i want you to see that if we don't
1323:14 - explicitly release the memory that we
1323:17 - allocate through the new operator we're
1323:20 - going to leak memory so we created an
1323:22 - object on the hip here but we're not
1323:24 - deleting that in some funk when some
1323:27 - funk exits we're going to lose this
1323:29 - pointer this variable because it is on
1323:31 - the stack itself and we won't have any
1323:34 - way to release this memory let's call
1323:36 - some funk here and really show you this
1323:38 - so we're going to call some funk and
1323:40 - we're going to build let's use gcc for
1323:42 - that the build is good we can bring this
1323:44 - up a little bit and clear and run
1323:47 - rooster we're going to see that the
1323:48 - constructor for fluffy was called
1323:51 - because of this new operator but we
1323:54 - didn't see the destructor called and
1323:55 - this is really bad
1323:57 - so for the destructor to be called we
1323:59 - need to explicitly release the memory in
1324:02 - this function here and we do that by
1324:04 - using the delete keyword and saying the
1324:07 - pointer that is pointing to the memory
1324:09 - that we want to release if we do this
1324:12 - this is going to cause for the the
1324:14 - structure of doubt to be called and if
1324:16 - we run we're going to see our destructor
1324:18 - called let's do that we're going to use
1324:20 - gcc the bolt is good you can clear and
1324:23 - run rooster now you see that the
1324:25 - constructor is called full fluffy and we
1324:27 - have the destructor cold this is really
1324:30 - all i wanted to share with you in this
1324:32 - lecture i apologize if you found it
1324:35 - confusing but if you have any problem i
1324:37 - am always available please do ask and i
1324:40 - will do the best i can to help you out
1324:42 - so the destructor is a special method
1324:45 - which is going to be called when your
1324:47 - object dies it is going to be called
1324:50 - when an object is passed by a value to a
1324:52 - function we have seen an example that
1324:54 - it's going to be called when a local
1324:56 - object is returned from a function by
1324:58 - value but this is going to be compiler
1325:00 - dependent because some compilers are
1325:02 - going to optimize this out and make it
1325:05 - look like when you returned by reference
1325:08 - so i don't want to go into this because
1325:10 - this is subject to compiler optimization
1325:13 - but other cases where you're going to
1325:15 - have your destructor called is when a
1325:17 - local stack object goes out of scope and
1325:20 - when a hip object is deleted
1325:23 - through the delete key world this is
1325:25 - really all i had to share in this
1325:27 - lecture i hope you found it interesting
1325:30 - we are going to stop here in this one
1325:32 - and the next one we're going to see the
1325:33 - order in which constructors and these
1325:36 - structures are called and you really
1325:38 - need to be aware of this
1325:40 - go ahead and finish up here
1325:42 - and meet me there
1325:44 - and this lecture i wanted to raise your
1325:47 - awareness on the order in which
1325:50 - constructors and the structures are
1325:52 - called suppose we have our class which
1325:54 - is dug here and we have the constructor
1325:57 - which is doing its thing in the body
1325:59 - here and we have the destructor which is
1326:02 - releasing our memory and printing
1326:04 - something out so suppose we have created
1326:07 - a few objects
1326:08 - of this class here and they have
1326:10 - different names and they have the same
1326:13 - breed and different edges as you see
1326:15 - here
1326:16 - and if we run this code in main
1326:19 - what do you think will see printed from
1326:21 - the constructors and the destructors if
1326:24 - you asked me and i was learning about c
1326:26 - plus plus i would say that the
1326:28 - constructors are going to be called in
1326:30 - order dog one dog two dog three dog four
1326:33 - they are going to be constructed in this
1326:35 - order and the destructors would be
1326:37 - called in the same order but this is not
1326:40 - true the destructors are going to be
1326:42 - called in the reverse order as you see
1326:45 - on the right here
1326:47 - so we're going to call this constructor
1326:48 - for doug d1 delegate2w3 doge4 which is
1326:52 - exactly what i expected but you're going
1326:55 - to see that the destructors are going to
1326:57 - be called in reverse order so the object
1327:00 - that was constructed last
1327:02 - is going to be destroyed first as you
1327:05 - see here and the object that was
1327:07 - constructed first is going to be
1327:09 - destroyed
1327:10 - last and the compiler follows this order
1327:14 - to make it easy for it to do things we
1327:16 - can't really get into those details but
1327:19 - for now we're going to head over to
1327:21 - visual studio code and play with us a
1327:23 - little more okay here we are in our
1327:25 - working folder the current project is
1327:28 - order of constructor and destructor
1327:30 - calls here we're going to grab our
1327:32 - template project pretty quick
1327:35 - and we're going to put them in place the
1327:37 - files i mean and we're going to open
1327:39 - this in visual studio code like we have
1327:41 - been doing all along this is going to
1327:44 - open up our folder we can close the left
1327:47 - sidebar here and let's clean up our main
1327:50 - function we are going to bring in the
1327:53 - class for dog from the last lecture this
1327:55 - is exactly what we had there
1327:58 - no change and we're going to include the
1328:00 - string review library for this to work
1328:02 - so we're going to include string view
1328:04 - here and once we do this we're going to
1328:06 - head over in the main function and set
1328:09 - up a few
1328:10 - objects of the dog class here but before
1328:13 - we go there notice that we have a few
1328:15 - htdc out statements in our constructor
1328:18 - and destructor and we want to see the
1328:21 - order in which they are called so we're
1328:23 - going to set up four objects of our dog
1328:26 - we're going to say dog dog one and we're
1328:28 - going to say the name to be won and it's
1328:32 - going to be a shepherd and it's going to
1328:34 - be for example 2 years old why not we
1328:37 - should say dog here and we are going to
1328:39 - copy these four times here and we're
1328:41 - going to call this dog 2
1328:44 - the other is going to be dog 3 and this
1328:46 - is going to be dog 4
1328:48 - and i'm going to say the same thing here
1328:50 - doggy two
1328:52 - three and four
1328:54 - the names are what is really important
1328:56 - because we're going to see them printed
1328:58 - out here but if you want you can change
1329:00 - the ages let's make this a three let's
1329:03 - make this a five let's make this a one
1329:05 - why not for dougie for and now we're
1329:07 - going to run our program if we run it
1329:10 - we're going to see the constructors
1329:12 - called in the order doggy one doggie 2
1329:14 - w3 dog e4 and the destructors are going
1329:18 - to be called in the reverse order
1329:20 - dogifur
1329:21 - all the way to doggy one let's boil and
1329:23 - show you that this is actually the case
1329:26 - so the build is good we can bring up a
1329:28 - terminal and really run this let's clear
1329:31 - and run rooster you're going to see that
1329:34 - dog constructor called for a doki one
1329:36 - all the way to dog e4 and now we have
1329:38 - the dagger destructor called from doge4
1329:41 - all the way to doge one and the compiler
1329:44 - is going to enforce this order for
1329:47 - calling constructors and destructors
1329:49 - because it makes it easy for it to
1329:52 - manage the memory of objects for example
1329:55 - if duck one has been around for a long
1329:58 - time and it has because it's going to be
1330:00 - around before a dog one
1330:03 - if you
1330:04 - delete duck one
1330:06 - after dog four here there might be other
1330:09 - objects that depend on dog one so that's
1330:11 - why the object that was created the last
1330:15 - is deleted first because chances for
1330:18 - other objects to depend on that last
1330:21 - object are really slim and you can
1330:23 - delete it without any problem but the
1330:26 - object that was created first might have
1330:29 - other dependencies and you're going to
1330:31 - be deleting dependent object first
1330:34 - before you delete that object i think
1330:36 - this is the logic the compiler follows
1330:39 - to really enforce this order here and
1330:41 - you need to be aware of that and make
1330:43 - sure that at any time in your c-plus
1330:46 - plus application this is working to your
1330:49 - advantage this is really all i had to
1330:51 - share in this lecture i hope you found
1330:53 - it interesting we are going to stop here
1330:55 - in this one and the next one we're going
1330:57 - to learn about the this pointer go ahead
1331:00 - and finish up here and meet me there
1331:03 - in this lecture we're going to learn
1331:04 - about the this pointer and this is a
1331:07 - special pointer that is maintained by c
1331:11 - plus plus to really help you manipulate
1331:14 - the current object and it is the current
1331:17 - object for which a given method is being
1331:20 - executed here is a simple example with
1331:23 - our dog class and we're going to show
1331:26 - some usefulness for the this pointer the
1331:28 - first thing we're going to look at is
1331:30 - the syntax for example here we might
1331:32 - need to print the address in memory
1331:35 - where the object was created and do that
1331:38 - from the inside of the function and to
1331:40 - do that we use the this pointer for
1331:42 - example we can put out a message and we
1331:44 - can do that through a statement like we
1331:46 - have here we are printing dog dog name
1331:49 - constructed at a given memory address
1331:52 - and we use the this keyword to get the
1331:55 - address of the character object for
1331:58 - which a specific method or function is
1332:00 - being called in this case it was the
1332:03 - constructor of the dot object here we
1332:06 - can also do the same thing for the other
1332:08 - constructor and you see we are using the
1332:10 - this pointer this is one of the uses you
1332:13 - have for the this pointer again the this
1332:16 - pointer is a special pointer that is
1332:18 - maintained by the c plus plus system and
1332:21 - it is going to be pointing to the
1332:23 - current object that is being manipulated
1332:26 - by the z plus plus run time and it's
1332:29 - going to be manipulated through a
1332:31 - special function of the class object
1332:35 - that is being called this is the meaning
1332:37 - here here is another use case for the
1332:40 - this pointer it may be used to resolve
1332:43 - conflicts when you have a parameter and
1332:47 - a member variable that are named the
1332:49 - same way for example here we are calling
1332:51 - the set name function it has a parameter
1332:54 - with a name doug name and it has a
1332:56 - member variable called dog name so if
1332:59 - you do a statement like we have on top
1333:02 - here the compiler is going to be
1333:04 - confused they're going to say dog name
1333:06 - equals dog name and it won't really know
1333:09 - which dog name you are referring to we
1333:11 - can resolve this conflict by saying
1333:14 - this and say pointer access notation
1333:18 - and say dog name and this thing here is
1333:20 - going to be the member variable and
1333:22 - we're going to be assigning to the
1333:24 - member variable from the parameter this
1333:27 - is the meaning here and we can use the
1333:29 - desperator to resolve such conflicts
1333:32 - another use we have for use pointer is
1333:34 - if we want to set up chained calls for
1333:37 - example using pointers and we might need
1333:39 - to do something like this so we have a
1333:42 - dog pointer set up on top here and we
1333:45 - can do something with our new object for
1333:48 - example we can call a function called
1333:50 - printful on a dog object after we print
1333:53 - the information we're going to set some
1333:55 - information on the doc and you see we
1333:57 - are setting all of the information
1334:00 - through one statement the way we achieve
1334:02 - this our setters are going to be
1334:05 - returning a pointer to the current
1334:08 - object and we're going to be grabbing
1334:10 - that return value and calling
1334:13 - on it directly because it's a pointer
1334:15 - and we are going to be using the pointer
1334:17 - access notation so we're going to call
1334:19 - set name set name is going to return a
1334:21 - pointer we're going to use that pointer
1334:23 - to say to the breed and set the breed is
1334:26 - going to return a pointer we're going to
1334:28 - use that pointer to set the age and
1334:30 - after this entire line all the
1334:33 - information is going to change about our
1334:35 - dog and we can see that here and after
1334:37 - we do whatever we want with our dog
1334:39 - object we're going to release it from
1334:41 - memory so this is another thing you can
1334:43 - achieve using the this pointer and this
1334:46 - is how you can set up these setters it
1334:49 - is nothing complicated we have set name
1334:51 - it's going to return the dot pointer and
1334:53 - we're going to return this okay and this
1334:56 - is going to be a pointer or the memory
1334:58 - address of the current object of the dog
1335:02 - class we have the same setup for seti
1335:04 - dog breed we return the dog pointer and
1335:07 - we return this the same setup for set
1335:10 - doug age we return a dog pointer and we
1335:13 - return
1335:14 - this we can do the same thing using
1335:16 - references but our setup is going to be
1335:19 - somewhat a little bit different
1335:22 - we have our dog object here and we're
1335:25 - going to do our change call here so
1335:27 - we're going to say set name through the
1335:29 - pointer
1335:30 - because we have a dot pointer here but
1335:33 - after that we're going to return a
1335:35 - reference from the functions here so set
1335:38 - name is going to return a reference
1335:39 - we're going to go through that reference
1335:41 - to set the breed
1335:43 - set dog breed is going to return a
1335:45 - reference and we are going to go through
1335:47 - that reference to set the dog age and if
1335:50 - we print the information now we're going
1335:52 - to see that we have new information in
1335:55 - our dog object and after we are done
1335:57 - with our dog object we have to remember
1336:00 - to release it from memory because it was
1336:03 - allocated dynamically from the heap here
1336:06 - is how you can set this up it really is
1336:09 - nothing complicated we just have our
1336:11 - setters and we are going to return a
1336:13 - reference but before we return through
1336:16 - the desperator we will need to
1336:18 - dereference the displayer and get to the
1336:21 - actual thing that is being pointed to
1336:24 - that's why we have this star operator
1336:26 - here and for the other setters we're
1336:28 - going to do the same thing we're going
1336:30 - to return a reference we're going to
1336:31 - return a dereferenced version of this
1336:34 - we're going to return a dog reference
1336:36 - for set dog age and we're going to
1336:38 - return a dereferenced this pointer
1336:41 - because this is the reference we are
1336:42 - returning here so this is what the this
1336:46 - pointer is about now we're going to head
1336:48 - over to visual studio code and play with
1336:50 - us a little more okay here we are in our
1336:53 - working folder the current project is
1336:55 - the displayer we're going to grab our
1336:58 - template files and we're going to put
1337:00 - them in place and then we're going to
1337:02 - open this in visual studio code by
1337:04 - dragging and dropping here this is going
1337:06 - to open our folder we're going to open
1337:08 - the main cpp file and we're going to
1337:10 - close the left sidebar here
1337:13 - so that we have some more space to work
1337:15 - with i am going to put in a version of
1337:18 - our dog class
1337:20 - it is pretty limited right now it just
1337:23 - has a destructor and a constructor and a
1337:25 - constructor and we have our member
1337:27 - variables and we're going to
1337:29 - tune this a little bit so that we can
1337:31 - work with us however we want the first
1337:33 - thing we want to do is to print the
1337:36 - addresses of dug objects that we
1337:40 - construct and destruct here and we're
1337:42 - going to do that in our constructor so
1337:45 - let's go to our hd dc out statement here
1337:48 - and we're going to say add to mean the
1337:51 - memory address where the object was
1337:53 - constructed and we're going to say this
1337:55 - so when we do this this is going to be
1337:59 - the address in memory of the current
1338:02 - object that is being constructed
1338:05 - by our constructor here and we're going
1338:07 - to say the same thing in our destructor
1338:10 - we're going to say at and we're going to
1338:12 - say the memory address where the current
1338:14 - object is being destroyed from so after
1338:17 - we do this
1338:19 - if we go in the main function and for
1338:22 - example set up a doug object we're going
1338:24 - to say dark we're going to say dog one
1338:26 - and we're going to give it the
1338:27 - information we're going to give it the
1338:30 - name which is going to be fluffy we're
1338:32 - going to give it the breed which is
1338:33 - going to be a shepherd and we're going
1338:35 - to give it the age of two like we have
1338:37 - been doing all along when we do
1338:39 - something like this this is going to
1338:40 - call the constructor because we are
1338:42 - trying to set up an object and before
1338:45 - the main function ends we're going to
1338:47 - call the destructor and we're going to
1338:49 - see things happening here let's say done
1338:51 - so that we know that the code is
1338:53 - actually running i'm going to say sddc
1338:55 - out done here okay we have the setup
1338:58 - done
1338:58 - we can uh build and run the application
1339:01 - we're going to use gcc to build and the
1339:04 - build is good we can bring up a terminal
1339:06 - to try and run the application and now
1339:09 - if we run rooster we're going to see
1339:11 - that dog constructor called for a fluffy
1339:14 - at this memory location and the current
1339:17 - object is this object here which is
1339:20 - being constructed and we're going to
1339:21 - have access to its memory through the
1339:23 - this pointer hopefully you can see how
1339:26 - powerful this is if we didn't have the
1339:29 - this pointer the only way to get the
1339:31 - address to
1339:32 - this object would be to grab the address
1339:35 - from the main function or from wherever
1339:38 - we are setting up our object here but we
1339:41 - have access to this address from the
1339:44 - inside of the functions for the class
1339:46 - and this is really cool so we can
1339:48 - manipulate these addresses if we need to
1339:51 - and we're going to show you another use
1339:53 - for this so suppose we need to set up
1339:55 - setters for our class here so we need a
1339:59 - setter to set the name the breed and to
1340:01 - set the age here so let's set up our
1340:03 - setters we're going to say setters and
1340:05 - we're going to say void set
1340:07 - name or let's be explicit set dog name
1340:10 - that's going to be better and we're
1340:12 - going to pass a string view we're going
1340:15 - to say stds friend of you and we're
1340:18 - going to say name program and we're
1340:20 - going to put the bodies in our class
1340:22 - here but i would encourage you to be
1340:25 - consistent if you are doing this in real
1340:28 - code we are learning here and we are
1340:31 - taking some shortcuts so that we can do
1340:33 - things simply but what we want to see
1340:35 - now is what happens if we have a
1340:38 - parameter named the same as a member
1340:40 - variable so how do you set
1340:44 - this name to the member variable called
1340:46 - the name so if you have a case like this
1340:48 - you're really going to be in trouble
1340:49 - because if you say name equals name
1340:52 - let's try this
1340:53 - we should get a compiler error or a
1340:55 - squiggly line because the compiler is
1340:57 - not going to know
1340:59 - which name are you using here is it the
1341:01 - memorial is it the parameter it's not
1341:03 - going to know and let's try to build and
1341:05 - see what we get we're going to use the
1341:07 - gcc
1341:09 - and surprisingly gcc is taking this
1341:13 - and it's probably knowing that we have a
1341:15 - member variable named name and it's
1341:17 - going to assign the parameter to that
1341:19 - member variable so behind the scenes gcc
1341:22 - is going to change this to this it's
1341:25 - going to use this name equals name
1341:29 - this is the syntax we want which is
1341:31 - really not confusing but what we have on
1341:34 - top here is going to be confusing and
1341:36 - some compilers are not even going to
1341:38 - take this let's leave this in and
1341:40 - actually build it in with us i want to
1341:43 - see that this actually works so we're
1341:45 - going to weld successfully and if we go
1341:48 - down in main and try to say
1341:50 - dog one set dog name let's say pumbaa
1341:54 - let's see what happens if we do
1341:55 - something like this we're going to try
1341:57 - and build again and gcc is going to take
1342:00 - this and this is really cool so let's
1342:02 - put in a function which is going to
1342:03 - print information about our dog we can
1342:06 - do that down here and it's going to
1342:08 - return nothing it's going to be called
1342:11 - print info and it's going to basically
1342:13 - print the name of the breed and the age
1342:15 - so it's going to say sddc out we're
1342:17 - going to say the address where the dot
1342:19 - object leaves
1342:21 - i think that's more meaningful we're
1342:23 - going to say this and then we're going
1342:25 - to
1342:26 - put a parenthesis and say the name i
1342:28 - think we can put a an angle bracket here
1342:32 - and say name and we're going to say the
1342:34 - dog name we can go down and say the age
1342:38 - or the breed and say the age and we're
1342:41 - going to dereference the age member
1342:43 - variable because it's a pointer we're
1342:44 - going to say the reference ph here and i
1342:47 - think this is going to be it now we can
1342:50 - put a new line character std e ndm and
1342:53 - if we go down now and say printable
1342:56 - before we set the name we're going to
1342:58 - say
1342:59 - dub1
1343:01 - printful we're going to print the
1343:02 - information about this dog and after we
1343:05 - set the dog name we're going to go down
1343:07 - and also say dog one principle you can
1343:10 - play with these things and i really
1343:12 - encourage you to do so so we're going to
1343:14 - build this we're going to use gcc so the
1343:16 - world is good we can clear and run
1343:19 - rooster this is going to say the
1343:20 - constructor was called for fluffy at the
1343:23 - given address
1343:24 - we're going to say the dog we're going
1343:27 - to print the information and we're going
1343:28 - to say it's a dog object at this address
1343:31 - the name is fluffy and we're going to
1343:34 - print the dog for the second time you're
1343:35 - going to see that the name is still
1343:37 - fluffy and we have a problem here why is
1343:40 - that
1343:41 - why is our object not being modified
1343:44 - let's go up and see our set dog name
1343:48 - function here so we're going to
1343:50 - remove this and we're going to use the
1343:53 - this pointer and we're going to
1343:55 - weld again and let's clear now and run
1343:58 - rooster and now you see that the changes
1344:00 - are actually making sense so what is
1344:03 - happening with the assignment here the
1344:06 - compiler is assigning the value of the
1344:09 - variable to the variable itself and this
1344:11 - is really doing nothing and it is not
1344:14 - what you expect i was fooled a little
1344:16 - bit by the compiler because this was
1344:18 - compiling but it's not going to do what
1344:20 - you want when you call set doug name you
1344:23 - probably want to take this name and
1344:26 - assign that to the member variable name
1344:28 - of this class but this is not what it's
1344:31 - going to do let's build again and really
1344:33 - show you this
1344:34 - so it is a really good advice to
1344:37 - practice and really try things out
1344:39 - yourself we're going to run a rooster
1344:41 - you're going to see that after we set
1344:43 - the dog name here to pumbaa and we try
1344:45 - to print the information the information
1344:47 - is not going to be end the name is not
1344:49 - going to be pumbaa for the second call
1344:51 - here and what this is really doing is
1344:54 - doing nothing here this does nothing and
1344:56 - you really need to know this if you want
1344:58 - to affect
1344:59 - your remember variable you will have to
1345:01 - go through the this pointer and this is
1345:03 - going to tell
1345:04 - take the name member variable of
1345:07 - the current object and assign the value
1345:10 - in name the name parameter to that and
1345:12 - that's going to set your name to
1345:15 - whatever new name you passed when you
1345:17 - called the set dog name function here so
1345:20 - hopefully you really understand this now
1345:22 - if we both are going to see that the
1345:23 - pumbaa name has been applied let's boil
1345:26 - again so we're going to clear and run
1345:29 - rooster and we're going to see now that
1345:31 - the name is pumbaa and there is some
1345:33 - annoying thing we have in our
1345:35 - constructors we don't have a space
1345:37 - before at here and it is really annoying
1345:40 - to look at here so let's build again and
1345:43 - fix this we are going to use gcc the
1345:45 - world is good we can clear and run
1345:47 - rooster and now we have what we want so
1345:50 - this is the second use case you might
1345:52 - have for this pointer through setters
1345:55 - let's use the parameter that is named
1345:58 - the same as your member variables so
1346:01 - we're going to set up all the other
1346:03 - setters we're going to set up a setter
1346:05 - for the breed we're going to say std
1346:07 - strength view and it's going to be breed
1346:10 - we can do that because now we have tools
1346:12 - to really do this properly we're going
1346:14 - to say this breed and we're going to say
1346:17 - equals read this is going to do and we
1346:20 - can set the age and we're going to say
1346:22 - void set age
1346:24 - dog age and we're going to pass in a
1346:26 - value and we're going to go inside what
1346:28 - is it called it's called ph i don't
1346:31 - think it makes sense to call the
1346:32 - parameter ph because it's not a pointer
1346:35 - so we're going to go inside and just the
1346:37 - reference of a pointer so we're going to
1346:39 - dereference that
1346:40 - and we're going to say this so we're
1346:43 - going to go inside and say this ph
1346:46 - equals h i think this is going to work
1346:49 - and we need to reference this pointer
1346:51 - because what we have as a member
1346:53 - variable is the pointer so we need to go
1346:55 - through the ugly syntax you see here and
1346:57 - this is going to set our age so we can
1346:59 - go through this and really change the
1347:01 - information so we're going to change the
1347:03 - breed here set dog breed let's go down
1347:06 - and choose that and we're going to say
1347:08 - wirefox terrier and we're going to go
1347:11 - down and set the age we're going to say
1347:13 - guilt 1 set dog age and we're going to
1347:16 - say for why not so we change the
1347:19 - information of our dog through our
1347:22 - setters here and we're going to print
1347:24 - new information
1347:25 - let's build again we're going to use gcc
1347:27 - for that the build is good we can clear
1347:30 - and run rooster this is going to give us
1347:32 - new information for the second print
1347:34 - here so name is going to be pumba breed
1347:37 - is going to be wirefox terrier and age
1347:39 - is going to be four and we have the
1347:41 - information for our dog object here okay
1347:43 - now we have this and we want to see how
1347:46 - we can set up chained calls
1347:48 - using the this pointer and in this case
1347:51 - we will be using pointers let's change
1347:53 - our setters to return dog pointers we
1347:56 - can do that and we're going to go down
1347:58 - to say to dog breed we're going to
1348:00 - return the dog pointer
1348:02 - and we're going to go to set dog age and
1348:04 - we're going to return a dog pointer now
1348:07 - after we do this we will need to return
1348:09 - these pointers and we're going to go
1348:11 - inside and say return this remember this
1348:14 - contains the memory of the current
1348:16 - object so we can return this and fit
1348:19 - that to a returned pointer so we can go
1348:21 - down in all the other functions and
1348:23 - really save this we're going to say
1348:25 - return thus we return the memory address
1348:28 - of the current object
1348:30 - through the setters that we are doing
1348:32 - here we're going to return this
1348:34 - and after we do this we can change the
1348:38 - setting we are doing here to b1
1348:40 - statement and we can comment this out i
1348:42 - think we can do that and what we're
1348:44 - going to say is dope one and we're going
1348:47 - to say
1348:48 - set dog name and we're going to pass in
1348:50 - pumbaa but this is going to return a
1348:53 - pointer now set dog name is returning a
1348:55 - pointer to the current object and you
1348:58 - can see that here this is what we are
1349:00 - returning so we can go through this
1349:02 - pointer and call some other functions
1349:05 - for example we can say set dot breed
1349:08 - directly and the visual studio code is
1349:10 - going to figure out that what we are
1349:11 - returning is a pointer and it's going to
1349:14 - change our access notation here to a
1349:16 - pointer axis notation and we're going to
1349:19 - use this in one single statement so
1349:22 - we're going to put in our breed and
1349:24 - we're going to call the function to set
1349:26 - the age okay you see that it uses
1349:28 - pointer access notation and this is
1349:30 - really cool so we're going to put in our
1349:32 - four and you're going to see that this
1349:33 - actually works and this is really cool
1349:36 - if you don't want to do thanks in three
1349:38 - steps you can give your users the option
1349:41 - to do things in one step using returned
1349:44 - pointers like this and this is really
1349:46 - cool i use this all the time for my
1349:48 - classes that i design in my applications
1349:51 - so if we're both we're going to see that
1349:54 - the world is good and we're going to
1349:55 - clear and run rooster we're going to see
1349:58 - that the information is n name is pumbaa
1350:01 - breed is waterfox terrier and the age is
1350:04 - for and we were able to do all these
1350:06 - changes in one go so we can even change
1350:09 - this to use references here we are using
1350:12 - pointers so let's say that we are using
1350:15 - pointers but we can also use references
1350:17 - let's go on top here and say that this
1350:20 - is using pointers and we're going to
1350:22 - comment this out but before we do we're
1350:24 - going to copy all this because we're
1350:26 - going to need that
1350:28 - and we're going to
1350:29 - comment all this out and we're going to
1350:31 - go down and say change calls using
1350:34 - references and we're going to go down
1350:36 - and put in our code and we're going to
1350:38 - change our setters to return references
1350:41 - instead of pointers we can do that so
1350:43 - we're going to change the star here to
1350:45 - an ampersand symbol here and this is
1350:48 - going to do the magic so we have a dog
1350:50 - reference returned from all these
1350:52 - functions so because we are no longer
1350:54 - returning a pointer returning this
1350:56 - directly is going to give us a compiler
1350:58 - error we need to dereference this
1351:00 - pointer and get to what what is pointed
1351:03 - to now the compiler will know that we
1351:05 - are returning a reference to the current
1351:08 - object and this is the syntax we can use
1351:10 - to do this let's go down and dereference
1351:13 - all the returned pointers and if we go
1351:16 - down we're going to see that this is
1351:17 - good already and we can go down and set
1351:20 - up our chained call using references and
1351:23 - we're going to go down and say dog one
1351:25 - we're going to set dog name and we're
1351:27 - going to pass in pumbaa
1351:29 - what we have been doing all along now
1351:31 - we're going to use the dot access
1351:33 - notation because what we are returning
1351:36 - is a reference and you're going to see
1351:38 - that visual studio code is going to pick
1351:40 - this up the breed is going to be wirefox
1351:43 - and we're going to say set dog age and
1351:46 - we're going to pass in our four and
1351:49 - you're going to see that this is valid c
1351:51 - plus syntax and if we print the
1351:53 - information we're going to have new
1351:55 - information applied to our dog object
1351:58 - here we can weld and see that this is
1352:00 - actually working you see the world is
1352:02 - good we can clear and run rooster and
1352:05 - we're going to see that information has
1352:07 - been applied to our dog object so these
1352:10 - are a few examples
1352:12 - showing some of the usefulness for the
1352:14 - this pointer we have seen that we can
1352:16 - use the this pointer to print the memory
1352:18 - address of the current object if we go
1352:21 - down and look at our constructor and the
1352:24 - destructor we are printing the address
1352:26 - of the current object in our debug
1352:29 - statement here and this is really cool
1352:31 - we can use the this pointer to resolve
1352:33 - conflicts in our setters for example we
1352:35 - can use a parameter that has the same
1352:38 - name as the member variable and it's not
1352:40 - going to be really confusing and lead to
1352:43 - bad results it's going to change the
1352:45 - actual member variable and change it to
1352:48 - whatever you pass as the parameter and
1352:50 - this is really cool we can also use the
1352:52 - this pointer to set up change calls for
1352:55 - our function and we have seen that we
1352:56 - can do that either through returning
1352:58 - pointers like we are doing here and
1353:00 - using the this pointer as a return
1353:03 - object for our function here or we can
1353:06 - use returned pointers to do this and if
1353:09 - we do that we're going to be able to
1353:11 - call our functions in one go like we are
1353:14 - doing here using pointers or do the same
1353:17 - thing using references like we are doing
1353:20 - here this is really all we set out to do
1353:22 - in this lecture i hope you found it
1353:24 - interesting we are going to stop here in
1353:26 - this one the next one we're going to
1353:28 - learn about struct go ahead and finish
1353:31 - up here and meet me there in this
1353:33 - lecture we're going to learn about the
1353:35 - struct keyword and this is another
1353:37 - syntax you can use to create classes in
1353:40 - your c plus plus program we have seen
1353:42 - that we can already use the class
1353:44 - keyword to create our classes i have to
1353:47 - break it to you that we can also use
1353:49 - struct to do the same so the syntax here
1353:51 - is going to create a class called cat
1353:54 - and it's going to have a member variable
1353:56 - called string name the difference
1353:58 - between struct and class is that for
1354:01 - classes members are going to be private
1354:04 - by default and when you do something
1354:07 - like this and create class objects you
1354:09 - want to be able to access the name here
1354:11 - directly for example from the main
1354:13 - function if you do that you're going to
1354:15 - get a compiler error because class
1354:17 - members are private by default but if
1354:21 - you use struct members are going to be
1354:23 - public by default and you will have
1354:26 - direct access from the outside this is
1354:28 - the only difference between class and
1354:31 - struct otherwise you can use them
1354:33 - interchangeably and they are going to do
1354:35 - the same things we have been seeing for
1354:37 - classes they really are the same things
1354:39 - the only difference is that classes are
1354:41 - going to have private member variables
1354:43 - by default and struct will have public
1354:46 - member variables by default but we can
1354:49 - change this defaults by putting in our
1354:51 - own public and private sections inside
1354:54 - our class so for example here you see
1354:57 - that we have changed our dog class to
1354:59 - have a public member variable through
1355:01 - the public keyword here and we can do
1355:04 - the same for cat for example we can put
1355:06 - in a public section and a private
1355:08 - section and it's going to behave like
1355:10 - classes we have been welding so far
1355:12 - one common use we have for struct is
1355:15 - when we have to set up classes that only
1355:19 - have public member variables for example
1355:21 - you can need to set up a point
1355:24 - model in your c plus plus program and
1355:26 - you can set up a class like this you can
1355:28 - say struct point you're going to put in
1355:30 - the member variables and they are going
1355:32 - to be directly accessible from the
1355:34 - outside and this is something you will
1355:36 - see a lot out there so this is really
1355:39 - all about struct we're going to head
1355:41 - over to visual studio code and play with
1355:43 - us a little more okay here we are in our
1355:46 - working folder the current project is
1355:48 - struct we're going to grab our template
1355:51 - files and we're going to put them in
1355:53 - place struct that's all project here
1355:56 - and we're going to open this in visual
1355:58 - studio code
1356:00 - let's grab extract and drag and drop on
1356:02 - top of visual studio code here this is
1356:04 - going to open our folder we can now open
1356:07 - the main cpp file and clean things up a
1356:09 - little bit okay so we're going to set up
1356:11 - a simple class called dog we're going to
1356:13 - say class dog and inside we're going to
1356:16 - have a member variable called name it's
1356:18 - going to be an std strand let's say dog
1356:21 - name or m name to mean that it is a
1356:23 - member variable this is a syntax you
1356:25 - will see a lot in c plus plus out there
1356:28 - so let's use this from now on we're
1356:30 - going to say m name and we're going to
1356:33 - have another class let's put our
1356:36 - semicolon we're going to use struct to
1356:38 - set up another one and it's going to be
1356:40 - called dog let's call this cat and we
1356:43 - are going to go inside and set up our
1356:44 - member variable we're going to say std
1356:46 - strength m name and it's not going to
1356:48 - have anything m so if we create objects
1356:51 - of these classes and try to access them
1356:54 - we're going to see the fundamental
1356:56 - difference between structure and dog
1356:59 - let's create a dog and we're going to
1357:00 - say dog one and we're going to create a
1357:03 - cat and we're going to say cat one and
1357:05 - if we do dog 1 and try to access the m
1357:08 - name member variable
1357:10 - maybe set it to something else let's say
1357:13 - fluffy we're going to have a compiler
1357:15 - error because members of a class are
1357:18 - private by default and we can't really
1357:20 - do this
1357:21 - so we are trying to access something
1357:23 - that is private from the outside we're
1357:25 - going to get a compiler error okay so we
1357:27 - have a squiggly line here but if we try
1357:29 - to do the same for a cat it's going to
1357:31 - go through because cat is destruct and
1357:34 - members of structs are public by default
1357:37 - let's do that and really show you this
1357:39 - we're going to say cat1 and we're going
1357:41 - to say m name and we're going to give it
1357:44 - a name and let's say johnny i am making
1357:47 - this up i don't know if there is any cat
1357:49 - named johnny but we're going to use this
1357:51 - and you're going to see that we don't
1357:53 - have any squiggly line we're going to
1357:55 - build and see if gcc is going to take
1357:58 - this it's going to take it the world is
1357:59 - good we can bring up a terminal and run
1358:02 - the program and we're not going to see
1358:04 - anything because we're not printing
1358:06 - anything from the main function here but
1358:09 - if we want we can print this name of our
1358:11 - cat we're going to say sddc out and say
1358:15 - cat one name and if we build we're going
1358:17 - to see that so the both should be good
1358:20 - it is good we can clear and run rooster
1358:23 - and we have johnny printed out and this
1358:25 - is the name of volca and this is really
1358:27 - the difference between class and strut
1358:29 - members of classes are going to be
1358:32 - private by default members of struct are
1358:34 - going to be public by default but we can
1358:36 - change these defaults for example let's
1358:38 - make everything public we can do that no
1358:41 - big deal here
1358:42 - and we can move this a little bit to the
1358:45 - right so that things are aligned nicely
1358:48 - and we can do the same for struct okay
1358:51 - so let's align this now if we do this we
1358:54 - will be able to go in the main function
1358:56 - and say dog name and change that and
1358:58 - we're going to be able to see that if we
1359:00 - print that out so let's go down and say
1359:03 - stdc out and say dog1 name and print
1359:08 - that out
1359:09 - and if we build now we're going to see
1359:11 - the name of our dog printed out okay
1359:13 - well this is good we can bring this up
1359:15 - and clear a little bit and run rooster
1359:18 - we're going to see fluffy our dog name
1359:20 - and johnny our cat name so this is
1359:22 - really all about classes and struct they
1359:25 - are the same things but the only
1359:27 - difference is the defaults that come
1359:29 - with these things but the common use we
1359:31 - have for struct is when we want to set
1359:34 - up a class that only has direct member
1359:37 - variables and we don't intend to put
1359:40 - methods into that class a good example
1359:43 - of this is the struct off point so
1359:45 - suppose we want to model points in our c
1359:47 - plus plus program so we can do something
1359:50 - like this and a point is going to have
1359:52 - two coordinates x and y we're going to
1359:55 - say double y and from this point on we
1359:57 - will be able to create point objects and
1359:59 - print them out however we want so for
1360:02 - example we can go down and say point
1360:04 - point one and from this point we can go
1360:07 - in and say 0.1 and say x and assign a
1360:11 - value to x let's put in a 10 and we're
1360:13 - going to go down and say point 1 y and
1360:17 - we're going to give it a value let's put
1360:18 - in
1360:19 - 55.5 why not and we can do whatever we
1360:22 - want with this point for example we can
1360:24 - set up a function which is going to
1360:25 - print a point we can do that let's say
1360:28 - void print point and we're going to pass
1360:30 - the point by value or we can even use
1360:33 - references because this is going to be
1360:35 - an object const point reference i think
1360:37 - this is going to do and we're going to
1360:39 - go inside and print the information
1360:41 - we're going to say
1360:43 - hddc out point and we're going to put
1360:45 - the coordinates on we're going to say x
1360:48 - is going to be point x and y is going to
1360:51 - be point y why not and we're going to
1360:54 - put in our closing square bracket and
1360:57 - we're going to say stdndl
1360:59 - to put a new line character after our
1361:02 - print here now we can go down and say
1361:04 - print point and pass on point one
1361:07 - and if we do that we're going to build
1361:10 - and we're going to do that through gcc
1361:11 - you see the both is good now if we print
1361:14 - we should see the information about our
1361:16 - point and we see point x 1 y
1361:19 - 55.5
1361:21 - and we see
1361:22 - point x is 10 y is 55.5
1361:26 - we can go down and change the
1361:28 - information about our point for example
1361:30 - we can copy this and go down and change
1361:33 - x to
1361:35 - 40.4
1361:37 - and y to
1361:39 - 2.7 why not and if we print the
1361:42 - information about our point we're going
1361:44 - to see that we have new information and
1361:46 - we're going to print point one and
1361:48 - therefore world we're going to see the
1361:50 - new information so the build is good we
1361:52 - can clear and run rooster now you see
1361:55 - new information in our point so this is
1361:57 - really the difference between class and
1361:59 - struct the only difference is going to
1362:01 - be in the defaults and struct is mostly
1362:03 - useful if you want to set up classes
1362:07 - that only have public member variables
1362:09 - and you don't really want to use
1362:12 - functions or methods in that class and
1362:14 - we have an example of that here and if
1362:17 - you have a case like that you will use
1362:19 - struct your code is going to be much
1362:21 - easier to read and understand from the
1362:24 - perspective of other c plus plus
1362:26 - developers we are going to stop here in
1362:29 - this lecture and the last one we're
1362:30 - going to learn about the size of objects
1362:34 - go ahead and finish up here and meet me
1362:36 - there
1362:37 - in this lecture we're going to learn
1362:38 - about sizes of class objects and try to
1362:42 - think about it
1362:43 - what are we going to see if we try to
1362:46 - print the size of our class here called
1362:49 - wrapper inside we have two member
1362:51 - variables which are of and type
1362:54 - and we have a member variable which is
1362:56 - of std string type what do you think
1363:00 - we'll see
1363:01 - when we print the size of this wrapper
1363:04 - object here
1363:05 - try to think about it so what c plus
1363:08 - plus does it's going to only account for
1363:11 - the size of your member variables so
1363:13 - it's going to add to the sizes of these
1363:15 - guys in memory so we know an end is
1363:17 - going to take four bytes in memory so
1363:19 - we're going to have eight bytes for
1363:21 - these two ants and we're going to have
1363:23 - an unspecified amount of memory for a
1363:26 - strength because a strength is
1363:28 - internally implemented as a class and it
1363:32 - stores its data as cost car pointers so
1363:35 - we have really a pointer
1363:37 - and the size of an object doesn't really
1363:41 - account for thanks you are referring to
1363:43 - using pointers it may count to the size
1363:46 - of the pointer itself but it's not going
1363:48 - to count what is pointed to and in the
1363:51 - case of string for example we really
1363:53 - want to know
1363:54 - the range of things that we are pointing
1363:57 - to so we're not going to have correct
1363:58 - information with hdd string here but in
1364:01 - general the size of an object is going
1364:04 - to be the sum of the sizes of its member
1364:07 - variables the functions are not going to
1364:09 - be counted then the functions are just
1364:11 - helper functions that live somewhere in
1364:14 - memory but they're not going to be
1364:16 - accounted for in the size of your object
1364:19 - another reason you might think functions
1364:21 - are not accounted for in the size of the
1364:23 - object is that really functions are
1364:26 - affiliated with the class itself
1364:29 - functions are not affiliated with class
1364:31 - objects the class is going to be the
1364:33 - blueprint from which we're going to
1364:35 - generate thousands of objects if we want
1364:38 - but the functions or the methods are
1364:39 - going to be associated to the blueprint
1364:42 - itself so it really wouldn't make sense
1364:45 - to associate the size of those functions
1364:47 - in memory to class objects now that you
1364:51 - have this idea let's head over to visual
1364:53 - studio code and play with this a little
1364:54 - more okay we have saved that the size is
1364:57 - mostly going to be the sum of the sizes
1364:59 - for the member variables but this is not
1365:01 - always correct because of a phenomenon
1365:04 - we called
1365:05 - boundary alignment
1365:07 - binary alignment is a thing most
1365:10 - compilers do when they have member
1365:13 - variables of different types and member
1365:16 - variables that have the size of four
1365:18 - bytes in memory are going to be stored
1365:20 - at memory locations that are multiples
1365:23 - of four and because of this phenomenon
1365:26 - we might have gaps between our memory if
1365:29 - we have variables for example that are
1365:32 - of two bytes in memory and four bytes in
1365:34 - memory and we're going to have gaps
1365:36 - inside and the size of the object is
1365:39 - going to be slightly off the sum we
1365:42 - might do for the sizes of our object i
1365:44 - realize this may be confusing we're
1365:46 - going to head over to visual studio code
1365:48 - and we're going to see a few examples
1365:50 - okay here we are in our working folder
1365:53 - the current project is size of class
1365:56 - objects we're going to grab our template
1365:58 - files pretty quick and we're going to
1366:01 - put them in place and we're going to
1366:03 - open our project in visual studio code
1366:06 - by dragging and dropping here we have
1366:08 - our main cpp file we can close the left
1366:11 - sidebar
1366:12 - and we can clean the main function here
1366:15 - we're going to set up a simple class
1366:16 - let's call this dog why not we have been
1366:19 - using dove so let's use this again
1366:22 - we're going to put our closing semicolon
1366:24 - we're going to put a public section and
1366:26 - it's going to just contain a constructor
1366:29 - and we're going to say dog and we're
1366:30 - going to use the default and we're going
1366:32 - to put in a private section and
1366:35 - in here we're going to put in a size t
1366:38 - and say
1366:39 - this is the leg count of the dog why not
1366:42 - let's say we are modeling this okay so
1366:45 - now we have our dog class in place we
1366:48 - can create objects of this dog class
1366:50 - we're going to say dog
1366:52 - dog one and if we do this we are
1366:54 - interested in knowing the size of our
1366:57 - dog class here
1366:59 - so we are going to say stdc out size of
1367:03 - dog and save that and uh fingers crossed
1367:06 - we're going to see the size of our dog
1367:08 - object here and try to guess what we're
1367:10 - going to get in the slides we have seen
1367:12 - that the size is mostly going to be
1367:15 - the sum of the size of the member
1367:17 - variables
1367:18 - and let's print the size of size t here
1367:21 - because size d is our only member
1367:24 - variable so i think it's going to be
1367:25 - helpful to see its size printed out
1367:28 - so we're going to have some context if
1367:30 - we do that we're going to say size of
1367:32 - size t and we're going to
1367:34 - save that and we're going to build this
1367:36 - program let's do that we're going to
1367:38 - pass this through gcc you see the both
1367:41 - is good
1367:42 - and we're going to bring up a terminal
1367:44 - and run this see what happens okay we
1367:47 - see size of size t is eight and the size
1367:50 - of our dark object is eight and this is
1367:53 - really cool because we see that the size
1367:56 - of our class object is really the size
1367:59 - of our
1368:00 - member variables that we have in here
1368:03 - let's set up another member variable and
1368:05 - really show you this so we're going to
1368:07 - have arm account okay so we are just
1368:10 - messing with us to learn
1368:11 - i don't aim for this class here to make
1368:14 - some sense practically we just want to
1368:17 - see how the member variables affect the
1368:20 - size of our class object now we have two
1368:23 - member variables and we're going to try
1368:25 - and world we're going to use gcc to do
1368:27 - that and we're going to clear and run
1368:30 - rooster
1368:31 - now you see that size of doug is 16 and
1368:33 - this is really
1368:34 - proven that the size of an object is
1368:37 - only accounting for the sizes of the
1368:40 - member variables it's not going to count
1368:42 - the functions that we have here so if
1368:45 - for example we had a function that says
1368:48 - printful and we have another one that
1368:50 - says do something this is not going to
1368:52 - change the size of our object because
1368:55 - functions aren't accounted for in the
1368:58 - size of our object here
1369:01 - so let's build and really show you this
1369:04 - the world is good we can clear and run
1369:06 - rooster we see that we have the same
1369:08 - sizes the size of dog is 16 the size of
1369:11 - size t is eight we can even use object
1369:14 - names here for example we are using the
1369:16 - class itself but we can use dog one here
1369:19 - and we're going to get the same
1369:20 - information let's both and we're going
1369:23 - to clear and run rooster
1369:25 - and you see that we have the same size
1369:28 - so if we change this thing to put in a
1369:30 - pointer we're going to see something
1369:32 - else let's put in an end pointer
1369:35 - and let's say ph like we have been doing
1369:38 - all along and see what we get and we
1369:40 - know that the size of a pointer on my
1369:43 - system let's print that out so that we
1369:45 - have no doubt let's for example say size
1369:48 - of end pointer is going to be size of
1369:51 - end pointer okay let's build we're going
1369:54 - to
1369:55 - pass this through gcc and the both is
1369:58 - going to be good we can clear and run
1370:00 - rooster we're going to see that we have
1370:02 - 24 because we have two member variables
1370:05 - that are going to be eight bytes in
1370:07 - memory of size t they are of type size t
1370:10 - and we have a pointer which is going to
1370:13 - have a size of h in memory but we don't
1370:15 - care what this pointer is pointing to
1370:18 - if for example this pointer is pointing
1370:20 - to something really large
1370:22 - we don't care we're just going to
1370:24 - account for the end pointer here and
1370:26 - this is really phenomenal because if for
1370:29 - example we tried to set up an sdd string
1370:32 - object
1370:33 - and by now you should know that std
1370:35 - strand itself is implemented as a class
1370:39 - in c plus plus so it's really a class
1370:41 - and we can print its size so let's set
1370:44 - up a string object here we're going to
1370:45 - say std strung and we're going to say
1370:48 - name and we're going to initialize this
1370:50 - with hello world okay we're going to see
1370:52 - something really strange here so if we
1370:55 - print the size of name here we're going
1370:57 - to say size of name and we're going to
1371:00 - print that let's see what we get we're
1371:02 - going to run
1371:03 - and we're going to
1371:05 - see the block is good and can clear and
1371:08 - run roaster we're going to see that size
1371:10 - of name is 32.
1371:12 - let's change the text inside our string
1371:16 - and see that we change accordingly
1371:18 - because this can really be confusing
1371:20 - let's say i am the king of the universe
1371:23 - why not and we're going to build again
1371:26 - let's see what we get fingers crossed
1371:28 - this is going to blow your mind you see
1371:30 - we have the same size for name even if
1371:32 - we are changing the text in here so what
1371:35 - is really happening the strength is
1371:38 - storing our text here as cost card
1371:41 - pointer
1371:42 - and what we have is a pointer inside and
1371:45 - what we probably have inside
1371:47 - is a member variable which is a pointer
1371:50 - like we have here so what we will be
1371:52 - accounting for in the strength class is
1371:55 - the size of the pointer but it's not the
1371:57 - size of what is pointed to okay so the
1372:00 - car pointer may be pointing to thousands
1372:03 - of characters in memory but as long as
1372:06 - the compiler is concerned it's just
1372:08 - going to use the pointer member variable
1372:10 - and it's going to account for it in the
1372:12 - size of your object hopefully you can
1372:14 - understand why
1372:15 - the size of our string objects is going
1372:18 - to be the same
1372:19 - regardless of how large is this strand
1372:22 - this is really something you need to
1372:24 - understand otherwise this is going to
1372:26 - throw you off as you design your c plus
1372:28 - plus applications and this is really all
1372:30 - i had to share in this lecture the size
1372:33 - of your object is mostly going to be
1372:35 - determined by the
1372:37 - member variables you have and the size
1372:39 - is going to be the sum of the sizes of
1372:41 - your member variables i would like to
1372:44 - welcome you in this new chapter where
1372:46 - we're going to be learning about
1372:48 - inheritance and inheritance is a feature
1372:51 - that c plus plus provides
1372:54 - to allow us to build classes in terms of
1372:57 - other classes
1372:59 - and what i mean here is that we can
1373:01 - build complete hierarchies of classes
1373:04 - that depend on other classes for example
1373:06 - if we think of a person as a type we can
1373:09 - have different types of persons we can
1373:12 - have a doctor a doctor is a person we
1373:15 - can have a physician a physician is a
1373:18 - person we can have an engineer an
1373:20 - engineer as a person we can have really
1373:23 - all kinds of persons and we can capture
1373:25 - these kinds of relationships in c plus
1373:28 - plus using inheritance for example here
1373:31 - we have an inheritance hierarchy we can
1373:34 - set up a person type in our c plus
1373:36 - program and put in whatever member
1373:38 - variables we need to define a person for
1373:42 - whatever purposes we are building our c
1373:44 - plus plus application for once we have
1373:46 - this type we can build other types that
1373:49 - depend on this person for example we can
1373:51 - build an engineer type which is really
1373:54 - going to embody the person type inside
1373:57 - so what we will be doing is really
1373:59 - setting up a layer of a person type and
1374:02 - in our engineer type which is going to
1374:05 - depend on person we will boil the novel
1374:08 - layer on top of that and really reuse
1374:10 - that person type without having to
1374:13 - rebuild this from scratch hopefully you
1374:15 - can see that this is going to improve
1374:17 - code reuse we can also reuse this
1374:20 - engineer type and well the other types
1374:22 - on top of it for example we can have a
1374:23 - civil engineer we can have an electrical
1374:26 - engineer we can have all kinds of crazy
1374:28 - engineers modeled in our c plus plus
1374:31 - program
1374:32 - using the inheritance and this is going
1374:33 - to be really cool so this is what we are
1374:36 - going to be exploring in this chapter
1374:39 - looking at the facilities that c plus
1374:41 - plus provides to capture these kinds of
1374:44 - relationships in our c plus plus
1374:46 - programs please note that inheritance is
1374:49 - a really big feature and it is a
1374:51 - defining feature of object oriented
1374:54 - programming c plus plus object oriented
1374:57 - programming is a paradigm or a way of
1375:00 - thinking about programming that uses
1375:03 - objects and the most basic defining
1375:05 - feature of object oriented programming
1375:08 - in c plus plus is classes that we have
1375:10 - learned about using classes we can
1375:13 - define things for example we can set up
1375:15 - a car we can set up a house we can set
1375:17 - up a spaceship we can do all kinds of
1375:20 - crazy things with classes and ziplocs
1375:22 - plus inheritance is going to build on
1375:24 - top of classes and allow us to build
1375:27 - classes that depend on each other and
1375:30 - will the complete inheritance
1375:31 - hierarchies that are going to make our
1375:34 - design much easier to look at and
1375:36 - understand and work with okay so this is
1375:39 - what we are up against in this chapter
1375:41 - learning about inheritance and really
1375:43 - exposing you to as much as possible to
1375:46 - let you use inheritance in an easier way
1375:49 - in your c plus class programs we are
1375:52 - going to start in the next lecture and
1375:54 - try out inheritance for the first time
1375:56 - go ahead and finish up here and meet me
1375:59 - there in this lecture we're going to try
1376:01 - out inheritance for the first time in
1376:04 - this course
1376:05 - but before we do that let's remind
1376:07 - ourselves of what inheritance really is
1376:11 - inheritance is a feature we have in c
1376:13 - plus plus
1376:14 - to be able to build new classes in terms
1376:17 - of the classes we have predefined
1376:20 - and the new classes are going to be
1376:23 - stealing features from the already
1376:25 - pre-existing classes if i can say it
1376:28 - like that and the more classes we build
1376:31 - in terms of others we're going to end up
1376:33 - with what we call an inheritance tree
1376:36 - which is basically going to go from the
1376:38 - top to the bottom with the most
1376:40 - fundamental class on top and the derived
1376:43 - class at the bottom here we have a
1376:45 - simple example for example we can have a
1376:48 - person class
1376:49 - and this class may be
1376:51 - defining the basic features of a person
1376:54 - but based on that personal class we
1376:56 - might want to derive other classes that
1377:00 - build on top of this person class for
1377:03 - example we might want to define an
1377:05 - engineer and a doctor and we know that
1377:07 - an engineer is also a person so they are
1377:10 - going to inherit some features from the
1377:12 - person class the same goes for the
1377:15 - doctor class it is going to inherit
1377:18 - some features from person but all these
1377:21 - derived classes are also going to add
1377:23 - their own features to the person class
1377:26 - siplus plus allows us to build these
1377:28 - kinds of relationships
1377:30 - here is another simple example we have a
1377:33 - vehicle class to the top of our
1377:36 - inheritance hierarchy and below this
1377:39 - class we might derive a track class
1377:42 - which is also a vehicle we might have a
1377:44 - minivan we might have a truck we might
1377:46 - have a pickup truck we may really do all
1377:49 - kinds of crazy vehicles which are going
1377:52 - to inherit the basic features from the
1377:54 - vehicle class and add their own
1377:57 - specialization
1377:58 - on top of the vehicle class so this is
1378:00 - the basic idea behind inheritance in c
1378:04 - plus plus so the examples we're going to
1378:06 - do in this lecture
1378:09 - so here is a simple example of what
1378:11 - we're going to do in this lecture we're
1378:12 - going to set up a person class which is
1378:14 - going to be our base class
1378:17 - it is going to be defining two member
1378:18 - variables which are going to be of std
1378:21 - string type we're going to have a last
1378:23 - name for the person and the first name
1378:25 - for the person
1378:27 - we are going to derive from this class
1378:30 - and set up a player class
1378:32 - the player class is going to inherit
1378:35 - these features from the person class so
1378:37 - it is going to have a last name and a
1378:39 - first name built into it but that's
1378:42 - going to be our base or our starting
1378:45 - point we are going to add to this base
1378:48 - and add another member variable from
1378:50 - player and we're going to be having the
1378:52 - player class which is really a person
1378:56 - but it is going to add things to person
1378:58 - to customize on what we can do with a
1379:01 - player
1379:02 - that we wouldn't originally be able to
1379:05 - do or have with a person class this is
1379:08 - the basic idea okay now that we know
1379:10 - this we're going to set up our personal
1379:12 - class which is going to be our base
1379:14 - class it is going to have our two member
1379:16 - variables first the name and last name
1379:19 - we're going to have a bunch of
1379:20 - constructors and we're going to have a
1379:22 - stream output operator to be able to
1379:25 - print this on the console and see our
1379:27 - information here nothing special but now
1379:30 - that this class is done we can build
1379:33 - other classes on top of this class so
1379:36 - what we can do for example we can derive
1379:38 - a player class
1379:40 - so the syntax is what you see here we
1379:41 - say class player we say column column
1379:45 - and then we say public
1379:47 - and specify the class that we are
1379:50 - inheriting from so the parent class for
1379:53 - this class is going to be person or in
1379:55 - other words we're going to be deriving
1379:58 - from the person class and we're going to
1380:00 - be doing that publicly okay for now i
1380:03 - don't want you to worry too much about
1380:05 - this public keyword we're going to be
1380:07 - learning this in steps just know that
1380:10 - this is the syntax you use to derive
1380:12 - from another class
1380:14 - now the moment we do this the player
1380:17 - class is going to have the person
1380:19 - information embedded inside but we will
1380:22 - also have the ability to customize or
1380:25 - add other things
1380:27 - at the level of the player class this is
1380:29 - what we do we have a private member
1380:31 - variable and it is going to specify the
1380:34 - game at the player place we're going to
1380:36 - have our own set of constructors we can
1380:39 - really build player objects but they are
1380:42 - going to have a person part inside that
1380:46 - is going to store information about this
1380:49 - player person
1380:51 - you notice we don't have a member
1380:52 - variable here for the first name we
1380:54 - don't have a member variable here for
1380:56 - the last name but that information is
1380:58 - going to be baked into this player
1381:01 - object and this is really how
1381:03 - inheritance helps us out we can derive
1381:07 - from classes
1381:08 - and build on top of them without having
1381:11 - to redo the fundamental work to build
1381:14 - our base classes we can just build on
1381:16 - top of them and really do things faster
1381:19 - and more efficiently okay so here are a
1381:22 - few things you need to know about the
1381:24 - public inheritance that we just did and
1381:27 - we are saying public inheritance because
1381:29 - of the syntax we used here
1381:32 - public person this is doing public
1381:35 - inheritance and we're going to see what
1381:37 - this gives us so with public inheritance
1381:40 - derived classes can access and use
1381:43 - public members of the base class
1381:46 - but the derived class can't directly
1381:49 - access private members from the base
1381:52 - class i want you to let this sync end
1381:54 - what this means from the player class we
1381:58 - can't directly access the private member
1382:01 - variables we had in person remember our
1382:04 - first name and last name are private to
1382:07 - person and we can't directly access them
1382:10 - in any deriving class that is doing
1382:13 - public inheritance okay so in our player
1382:17 - class if we try to access the first name
1382:19 - and the last name we're going to have
1382:21 - compiler errors because we can't
1382:23 - directly access them but not to worry
1382:25 - here we can still go through
1382:27 - the public getters that we have in the
1382:31 - person class
1382:32 - to access the private member variables
1382:34 - from the base class and that's what
1382:37 - we're going to do in this lecture here
1382:39 - because we don't have access to more
1382:41 - powerful tools we're going to learn
1382:43 - about in the next few lectures the same
1382:46 - is also going to apply to friends of the
1382:48 - derived class
1382:50 - they are going to have access to private
1382:52 - members of the derived class but they
1382:55 - don't have access to
1382:57 - the private members of the base class if
1383:00 - you try to access the private parts of a
1383:04 - base class
1383:05 - from a friend of the derived class
1383:08 - you're going to have a bunch of compiler
1383:10 - errors
1383:11 - okay now that you know this we're going
1383:13 - to head over to visual studio code and
1383:15 - play with this a little more and really
1383:17 - drive this home
1383:18 - here we are in our working folder the
1383:21 - current project is first try on
1383:24 - inheritance we're going to grab our
1383:26 - template files and put them in place
1383:28 - let's do this
1383:30 - and we are going to open this in visual
1383:32 - studio code pretty quick by dragging and
1383:34 - dropping here let's do that properly and
1383:36 - we're going to have our main cpp file we
1383:38 - can clean this up a little bit and we're
1383:41 - going to add our classes the first class
1383:43 - we're going to add is the person class
1383:46 - so we are going to create its header
1383:48 - file and let's do the cpp file i am
1383:52 - going to grab the code i have lying on
1383:54 - my drive for the header here i am going
1383:56 - to put the class in we are including the
1383:59 - classes we're going to need we need
1384:01 - string and io stream here because we're
1384:03 - going to be outputting thanks through
1384:05 - the output stream operator
1384:08 - and down here we have our two member
1384:10 - variables we have first name and last
1384:12 - name they are of std string type and we
1384:15 - have a bunch of constructors here a
1384:17 - default constructor and one that takes
1384:19 - two parameters we are taking them by
1384:22 - copy here this is bad we should at least
1384:26 - pass them by reference here let's
1384:28 - correct this
1384:29 - pretty fast
1384:31 - and we're going to make the second one a
1384:33 - reference as well let's do this and we
1384:36 - have a destructor which is going to do
1384:38 - nothing because we really aren't doing
1384:40 - any dynamic memory allocation here we're
1384:43 - going to head over to the cpp file and
1384:46 - put in the code for that we're going to
1384:47 - include the person and we're going to do
1384:50 - our constructors put in the
1384:51 - implementations i should say and we're
1384:54 - going to pass our parameters by
1384:56 - reference again let's do this and our
1384:59 - constructor should be done now we have a
1385:01 - person class that we can use to derive
1385:05 - other classes and use this class as a
1385:08 - foundation to build other classes to
1385:11 - visualize this again our class person is
1385:14 - going to be the base class for our
1385:16 - player class
1385:18 - so if we build a player class it's going
1385:20 - to have
1385:22 - a person part of it which is going to be
1385:25 - the foundation on top of which we're
1385:27 - going to build notice that in player we
1385:29 - don't need to set up last name and first
1385:31 - name they are going to come from our
1385:34 - personal part of player all we need to
1385:36 - do in player is set up the game member
1385:39 - variable to make him a full player who
1385:42 - can have the game they happen to be
1385:44 - playing this is the idea here okay so
1385:47 - now that we know this we're going to put
1385:48 - in our player class we're going to
1385:50 - create the files for it let's do player
1385:54 - dot h we're going to put this in and
1385:56 - we're going to do player
1385:58 - that cpp we're going to put him and
1386:01 - we are going to hop over to the header
1386:03 - file and put in our code the class is
1386:07 - going to be player and it is going to be
1386:09 - inheriting from person this is the
1386:11 - syntax again we say colon colon we say
1386:14 - the kind of inheritance we want to do in
1386:17 - this case it is public and then we say
1386:19 - the class that we are going to be
1386:21 - inheriting from from this point on the
1386:24 - player class is going to have a person
1386:26 - part of it and we are going to prove
1386:28 - this in a minute when we run this code
1386:30 - here notice that we can build player
1386:32 - objects by just passing in the game
1386:35 - parameter here which is going to be used
1386:38 - to initialize our member variable let's
1386:40 - also make it a reference because this is
1386:43 - good practice it is going to avoid
1386:44 - copies you can even use string views but
1386:47 - that's going to be your choice
1386:50 - we are going to hop over to the cpp file
1386:52 - and put in our implementation
1386:55 - and this is going to complete our setup
1386:58 - for the player class which is going to
1387:00 - be inheriting from our person class here
1387:03 - we can actually head over to the main
1387:06 - cpp file and include the player class
1387:09 - let's do this we're going to say player
1387:11 - and we can create player objects let's
1387:14 - look at the code again for a player we
1387:16 - have a constructor which is going to
1387:18 - take a string parameter we can use this
1387:21 - to create a player and specify the game
1387:24 - they are going to be playing
1387:26 - but
1387:27 - for now we don't have enough tools to
1387:30 - put in the data that would initialize
1387:33 - the member variables in the base class
1387:36 - which is person here if we go back to
1387:38 - person we're going to see that we have
1387:39 - the first name and the last name
1387:42 - but in our player class
1387:44 - these member variables are going to be
1387:46 - inherited because a player is inheriting
1387:49 - from a person this is the syntax to do
1387:52 - that but even if the player class has a
1387:55 - person part inside of it we can't really
1387:58 - access private members from person
1388:02 - from a player object we're going to see
1388:05 - a few ways we can get around this and
1388:08 - one of those is to go public methods
1388:11 - from the person class to access
1388:13 - private parts of the person class this
1388:16 - is going to give us access to these
1388:17 - member variables if you go down in our
1388:20 - stream output operator you're going to
1388:23 - see that we are using these getters here
1388:26 - the parameter is a player objects that
1388:28 - we want to print out but to get access
1388:31 - to the names we are getting the first
1388:33 - name and the last name through our
1388:36 - getters here before we really explore
1388:39 - this any further i think it is a good
1388:41 - idea to go in the main cpp file and
1388:44 - create a player object so we're going to
1388:46 - do that we're going to say p1 and we're
1388:48 - going to specify that they play
1388:50 - basketball why not okay so we have our
1388:54 - player object
1388:56 - and we can really do all we want with
1388:58 - that for example we can print the
1389:00 - information about this player object if
1389:03 - you remember in player we have a stream
1389:05 - output operator which is going to print
1389:07 - all the information
1389:09 - and here we have a problem because this
1389:12 - guy is taking the data by reference
1389:16 - and this is not a reference this is a
1389:18 - temporary object that we are passing
1389:20 - here
1389:21 - so we could go back and change this to
1389:24 - take a string view parameter
1389:27 - let's go back and do that we're going to
1389:29 - include a string view here in player and
1389:32 - we're going to change our parameter to
1389:34 - be std string view by value and we're
1389:37 - going to do that in the cpp file let's
1389:40 - do that we're going to say std string
1389:43 - view and this should take care of our
1389:46 - problem here you see that the problem
1389:48 - goes away now that we have this guy we
1389:50 - can print it out we can say sddc out
1389:53 - player and i put the information out
1389:56 - okay so now that we have this we cannot
1389:58 - try and build our program we're going to
1390:01 - use gcc
1390:02 - our favorite compiler and you're going
1390:05 - to see that we have a problem undefined
1390:07 - reference to player destructor let's go
1390:10 - back in the header and see that we have
1390:12 - a destructor but we probably didn't put
1390:15 - a destructor in the cpp file so let's do
1390:18 - that or because we're not doing any
1390:22 - dynamic memory allocation we can even
1390:24 - completely take out this destructor and
1390:27 - we're just going to use the one the
1390:28 - compiler generates for us this is going
1390:31 - to be
1390:32 - much easier to handle in our code so we
1390:34 - can build again with gcc okay the world
1390:37 - is good we can run this program
1390:40 - and let's see if we have a powershell
1390:43 - window we don't we're going to bring up
1390:44 - a new one and we're going to run rooster
1390:47 - we should see information about our
1390:49 - player so player the game is basketball
1390:52 - the names are mysterious person because
1390:55 - that's the default data we inherit from
1390:58 - a person if you go back to person you're
1391:00 - going to see that
1391:02 - the default data in first name is
1391:05 - mysterious the default data in last name
1391:08 - is person and it is what we see printed
1391:11 - out here
1391:12 - in our powershell window when we print
1391:15 - information about our player object
1391:18 - another thing i want you to see is that
1391:20 - we can actually really prove
1391:23 - that any player object is going to have
1391:26 - a person part of it
1391:28 - backed in and that's going to be storing
1391:31 - the information that is modeled into our
1391:34 - person class and we can use a debugger
1391:36 - to do that for this to work i am going
1391:39 - to put a break point here on line 8
1391:43 - which is printing things out
1391:45 - this break point is going to be hit
1391:48 - after our object is set up and we can
1391:50 - really see the data inside this guy here
1391:53 - so what we're going to do we're going to
1391:55 - hit this run tab
1391:57 - and we're going to use g plus plus we're
1391:59 - going to use the debugging tools that
1392:01 - come with gcc because this is our
1392:04 - favorite we're going to hit the green
1392:05 - button here
1392:06 - this is going to start our debugging
1392:09 - session a binary is going to be built
1392:12 - and it is going to be plugged into our
1392:14 - debugger and we're going to hit a break
1392:16 - point here
1392:17 - now if you look on the left here you're
1392:19 - going to see a title that says locals
1392:22 - we're going to expand this and we're
1392:24 - going to see that the p1 object actually
1392:27 - has a person part of it and you see that
1392:29 - visual studio code is being helpful here
1392:32 - it is saying that this is the base class
1392:34 - and if we expand we're going to see that
1392:36 - we have our member variables we have
1392:38 - first name and last name and this is a
1392:41 - player object that we are looking at
1392:43 - don't forget that and on top of our
1392:46 - person part we also have our own member
1392:49 - variable which is the game that we play
1392:51 - and it is right here hopefully this
1392:53 - proves to you
1392:55 - that any derived class object is going
1392:58 - to have a base part embedded into it and
1393:02 - that's going to be the foundation on top
1393:04 - of which the derived class is going to
1393:06 - be building its own tank this is the
1393:08 - basic idea here okay now that you've
1393:11 - seen this we're going to kill our debug
1393:13 - session
1393:14 - and we're going to see some of the
1393:17 - things you need to be careful about when
1393:19 - doing public inheritance like we are
1393:21 - doing here the first thing i want you to
1393:23 - see is that you don't have access to
1393:26 - private parts
1393:27 - of the base class if you go back to
1393:30 - person here
1393:31 - let's kill this so that you're not
1393:33 - confused if we go back to our personal
1393:36 - class we're going to see that our first
1393:38 - name and last name are private
1393:41 - so they want to be accessible to any
1393:44 - class
1393:45 - that does public inheritance like we are
1393:48 - doing here they are just going to be
1393:50 - private they are going to be part of the
1393:53 - class but the derived class would have
1393:56 - access to them this is the idea here and
1393:59 - if we go in our output stream operator
1394:02 - and comment out what we have here and
1394:05 - try to directly access these member
1394:08 - variables let's do that i am going to
1394:10 - copy the code here and put that on top
1394:13 - and we are not going to go through the
1394:16 - getter methods from the base class we
1394:19 - are going to try and access m first name
1394:22 - let's go back and look at the names for
1394:25 - the member variables it is first name
1394:26 - and last name let's use that we're going
1394:29 - to say first name you see that through
1394:31 - intellisense but trying to access that
1394:34 - is going to give us squiggly lines you
1394:36 - see that we have this in our
1394:38 - autocomplete but we have squiggly lines
1394:40 - we can't access these if we try to
1394:42 - compile our program let's do that again
1394:45 - we're going to use gcc and we are going
1394:48 - to get compiler errors and the compiler
1394:50 - errors are basically going to say
1394:52 - first name is private within this
1394:55 - context again the meaning is that
1394:58 - first name is private to the base class
1395:02 - and we have no business accessing that
1395:04 - in a derived class which is
1395:07 - the player class here this is the
1395:09 - meaning so we can't really access that
1395:12 - okay i realize this is a global function
1395:14 - but even if we try to do that from a
1395:16 - member function let's do that from
1395:19 - a constructor we're going to try and say
1395:22 - first name okay i realize the access we
1395:24 - are trying to do from the output stream
1395:27 - operator is really not a good example
1395:29 - because this is not a member function it
1395:32 - is a global freestanding function so we
1395:35 - can try and change the first name and
1395:37 - last name from the constructor for
1395:38 - example and we're going to see that this
1395:40 - is not going to work either so we can
1395:42 - take this out and we're going to
1395:45 - remove our block comma so we're going to
1395:48 - take out what we just did here
1395:51 - and we're going to uncomment our good
1395:53 - code here which is using getter member
1395:55 - functions from the base class and we're
1395:57 - going to try and change
1395:59 - the first name and last name from the
1396:01 - base class and change those into our
1396:05 - constructor of the derived class we're
1396:07 - going to try and change for example the
1396:09 - first name and make it john and we're
1396:12 - going to take the last name and change
1396:14 - that to
1396:15 - snow let's do that and let's go back and
1396:18 - make sure we have the correct names
1396:20 - and you see that we have squiggly lines
1396:22 - we can't really do this because these
1396:24 - are private members of the base class
1396:27 - and we can't access them from a derived
1396:30 - class they are part of the player class
1396:33 - which is a derived class but we don't
1396:35 - have access to them we can't modify them
1396:37 - or do anything we can't read from them
1396:40 - we can't write from them this is the
1396:41 - message here if we try to build our
1396:43 - program we're going to use gcc to do
1396:46 - that
1396:47 - we are going to get compiler errors and
1396:49 - uh let's see the compiler error we get
1396:53 - again the error is that first name and
1396:55 - last name are private to the base class
1396:58 - and we have no business accessing them
1397:01 - from a derived class like we have here
1397:03 - so if you need any kind of access to a
1397:06 - private
1397:07 - member of the base class you will have
1397:10 - to go through
1397:11 - something that is public and a good
1397:13 - example is getter methods which are
1397:15 - going to allow you to
1397:17 - change things so for example if we want
1397:20 - the ability to change the first name and
1397:22 - the last name we can set up a bunch of
1397:24 - setter methods let's do that we're going
1397:26 - to say setters and we're going to say
1397:28 - void
1397:29 - set
1397:30 - first name and we are going to pass an
1397:33 - std strength view
1397:35 - let's do that we're going to say string
1397:37 - view here fn for first name
1397:41 - this is going to modify our class so we
1397:44 - are not going to mark this as a custom
1397:46 - member function and we're going to say
1397:48 - first name
1397:49 - equals
1397:51 - fn this is going to do
1397:53 - we are going to set up a setter for the
1397:56 - last name set and we're going to pass a
1397:59 - string view here and we're going to say
1398:01 - ln for the last name again this is not
1398:04 - going to be a cast member function so
1398:06 - we're going to say last name and we can
1398:09 - pass in ln as our new name here now that
1398:13 - we have these end we can take out
1398:16 - these things we have in the constructor
1398:18 - i think the job for this is done and
1398:21 - this is going to give you compiler
1398:23 - errors and we can go in our main cpp
1398:26 - file and change the names for this
1398:28 - person here for example we can say p1
1398:31 - set
1398:32 - first name we're going to pass john and
1398:35 - we can also set to the last name we're
1398:37 - going to say p1 set
1398:40 - last name and we're going to pass snow
1398:43 - and this is going to do if we build and
1398:44 - run this program we're going to see that
1398:46 - the world is going to be good this is
1398:48 - the first step
1398:50 - and if we run we should see the
1398:52 - information printed out we want to join
1398:54 - snow printed out and the game should be
1398:57 - basketball
1398:58 - let's clear and run rooster we're going
1399:01 - to see that the data is in here the name
1399:04 - the names are jon snow and we have our
1399:06 - game to be basketball here but notice
1399:09 - these are base methods and we are
1399:12 - calling them from a derived object and
1399:15 - this is living proof that the public
1399:18 - members from the base class are going to
1399:20 - be inherited and usable
1399:23 - from a derived class that does public
1399:26 - inheritance like we are doing here and
1399:29 - this is really the main message you can
1399:31 - inherit publicly and have access to
1399:33 - public stuff from the base class and use
1399:36 - them in your derived class but private
1399:39 - data is going to still be private to the
1399:42 - base class you can't use that in a
1399:44 - derived class this is the message here
1399:47 - and this is really all i wanted you to
1399:49 - see in this lecture the big thing is to
1399:52 - notice the syntax you use to do
1399:54 - inheritance and if you do this the
1399:57 - player class is going to be derived from
1399:59 - person
1400:00 - and it will have a person part
1400:03 - baked inside and we can build on that
1400:06 - foundation and for example put in our
1400:09 - own member variables and do all kinds of
1400:11 - crazy things
1400:12 - public stuff from the base class are
1400:14 - going to be inherited and usable from a
1400:17 - derived class we just saw that by
1400:20 - setting up a bunch of setters that live
1400:22 - in the public scope of the base class
1400:25 - and they were usable from the outside
1400:28 - because they will be inherited as public
1400:31 - in a derived class so we can really call
1400:34 - these methods and use them from the
1400:36 - outside like we are doing here but
1400:38 - private data from the base class is not
1400:41 - going to be accessible and usable from a
1400:43 - derived class and we saw that by setting
1400:46 - up this piece of code in the constructor
1400:48 - of player this is going to give us a
1400:50 - compiler error saying that first name
1400:52 - and last name are private to the base
1400:55 - class we are going to stop here in this
1400:57 - lecture in the next one we're going to
1400:59 - learn about another kind of access
1401:01 - specifier we have in c plus plus and
1401:04 - that is protected
1401:06 - so go ahead and finish up here and meet
1401:08 - me there
1401:10 - in this lecture we're going to learn
1401:12 - about the protected access specifier you
1401:15 - can use in your c plus plus class
1401:18 - and we're going to be reusing the same
1401:20 - example from the last lecture we're
1401:22 - going to have a person class which is
1401:23 - going to act as our base class and we're
1401:26 - going to be deriving from this person
1401:28 - and creating a new class called player
1401:32 - the player class is going to have a
1401:33 - person part baked in
1401:35 - and we can use this as a foundation to
1401:38 - build other fans in player class for
1401:40 - example we can set up our own member
1401:42 - variables and do all kinds of crazy
1401:45 - things and this is the setup we used in
1401:47 - the last lecture we set up a person
1401:49 - class and our members were private as
1401:52 - you saw here but in the last lecture we
1401:55 - saw that
1401:56 - private member variables are not going
1401:58 - to be accessible and usable from derived
1402:01 - classes that do public inheritance and
1402:05 - sometimes we want members from the base
1402:07 - class to at least be accessible and
1402:10 - usable from a derived class but still be
1402:14 - inaccessible from the outside and we can
1402:17 - achieve this using the protected access
1402:20 - specifier so for example we can change
1402:22 - the access specifier of our member
1402:24 - variables from private to protected and
1402:27 - at the moment we do this we will be able
1402:30 - to access for example read from and
1402:32 - write into these member variables from
1402:35 - derived classes so for example we will
1402:38 - be able to modify these guys from a
1402:41 - constructor of the derived class and we
1402:44 - thought that that was impossible from
1402:46 - the last lecture but still we want to be
1402:48 - able to use these from the outside of
1402:51 - our derived class which is person here
1402:54 - so we're going to still do public
1402:55 - inheritance like from the last lecture
1402:57 - but now that our member variables in the
1403:00 - base class are protected we will have
1403:03 - the ability to do whatever we want with
1403:05 - them in the derived class and when we
1403:07 - say in the derived class we mean from
1403:10 - any method from the derived class for
1403:13 - example we can go in our constructor
1403:15 - here and then set data into the member
1403:18 - variables from the base class and that's
1403:20 - going to work as we're going to see
1403:23 - in a minute now that you know this we're
1403:25 - going to head over to visual studio code
1403:26 - and play with this a little more okay
1403:29 - again our member variables from the base
1403:31 - class are going to be protected
1403:34 - okay so we can really say that here
1403:36 - let's say protected and at the moment we
1403:38 - do this they are going to be accessible
1403:41 - and usable from a derived class so from
1403:44 - the derived class we will have the first
1403:46 - name for example
1403:48 - so from the derived class we will have
1403:50 - our members baked then we will have a
1403:52 - last name and the first name and because
1403:55 - they are protected in the base class and
1403:57 - we are doing public inheritance we will
1404:00 - be able for example to set data into
1404:02 - these member variables from a derived
1404:04 - class and that's going to be
1404:06 - really cool now that you know this we're
1404:08 - going to head over to visual studio code
1404:10 - and play with us a little more okay so
1404:12 - here we are in our here we are in our
1404:15 - working folder the current project is
1404:17 - protected members we're going to grab
1404:20 - the code from the last lecture and reuse
1404:22 - that because that's going to have our
1404:24 - inheritance hierarchy already set up we
1404:27 - will have our person and player class
1404:30 - and we can reuse them we will have our
1404:33 - person and player classes and we will
1404:35 - reuse them without needing to completely
1404:38 - set them up from scratch that's going to
1404:40 - save us a few seconds so we're going to
1404:43 - put them in here
1404:45 - and we are going to open this little guy
1404:47 - in visual studio code by dragging and
1404:49 - dropping here and we will have our
1404:51 - person class which is going to be the
1404:53 - base class it's going to have our member
1404:56 - variables which are going to be private
1404:58 - from the last lecture we will have a
1405:00 - player class which is going to be
1405:02 - inherited publicly from the player
1405:05 - we will have a player class which is
1405:07 - going to be publicly inheriting from
1405:09 - person and we have our main cpp file
1405:12 - which is going to set up a player object
1405:14 - and try to use it and we're going to see
1405:16 - how this goes in this lecture so what we
1405:19 - want to do is to change the access
1405:21 - specifier in the base class and make
1405:24 - that protected we can do that we can say
1405:26 - protect it and this is going to change a
1405:29 - few things about this class what this is
1405:32 - going to do
1405:33 - if you do public inheritance from this
1405:35 - person class you will have the ability
1405:38 - to do whatever you want with these
1405:40 - member variables from a derived class
1405:43 - you will have the ability to write into
1405:45 - these member variables and change the
1405:47 - data that we have inside you will also
1405:50 - have the ability to read from them and
1405:52 - that's something we couldn't do from the
1405:54 - last lecture and this may come in handy
1405:56 - sometimes another thing you should know
1405:58 - is that these members are still not
1406:01 - going to be accessible from the outside
1406:03 - so from the standpoint of the main
1406:06 - function for example here they are going
1406:08 - to behave as if they are private because
1406:11 - they want to be accessible from the
1406:13 - outside they will only be accessible and
1406:16 - modifiable from derived classes
1406:20 - that do public inheritance this is
1406:23 - really important to understand now that
1406:25 - we have this we can really do all kinds
1406:27 - of crazy things for example we can go in
1406:30 - our constructor of player and comment
1406:33 - what wasn't working from the last
1406:35 - lecture and this is going to work now so
1406:38 - let's uncomment this and we're going to
1406:40 - see that the squiggly lines are going to
1406:42 - go away and if we build a player object
1406:45 - using this constructor we're going to
1406:47 - see that we're going to have jon snow in
1406:50 - even if we don't set using the setters
1406:52 - from the base class so we can take these
1406:54 - out
1406:55 - and if we print information about this
1406:57 - player we're going to see the game to be
1406:59 - basketball and the names are going to be
1407:01 - john snow because we are setting up this
1407:05 - in the constructor of player that's no
1407:08 - longer that's no longer going to be the
1407:10 - data we get from the constructor of a
1407:13 - person object which was here
1407:17 - in the base class let's try to build and
1407:20 - run this program so that you can really
1407:22 - see this i just used clan here but it is
1407:25 - also going to work no big deal here the
1407:28 - build is going to be good we can clear
1407:31 - and bring up a powershell window we can
1407:34 - use to run this program we're going to
1407:36 - say rooster and you're going to see that
1407:37 - player is going to be
1407:40 - having the information the game is going
1407:42 - to be basketball the names are going to
1407:44 - be jon snow and we are setting this data
1407:48 - from a derived class and we have the
1407:50 - ability to do this because these members
1407:53 - are now protected in the base class so
1407:56 - they are accessible and usable from a
1407:59 - derived class
1408:00 - now that we have this ability we can
1408:02 - really change how our class at least the
1408:06 - derived class works we're going to
1408:08 - change it to have two more parameters
1408:12 - and we're going to pass the first name
1408:14 - and the last name and pass this data
1408:17 - back into the base class by setting the
1408:20 - data in the body of the constructor this
1408:22 - is going to work so let's add our
1408:24 - parameters we're going to say std string
1408:26 - view
1408:28 - and this is going to be
1408:30 - first name param and we're going to put
1408:32 - in another one which is going to also be
1408:34 - a string view parameter and it's going
1408:37 - to be last name param we can say that
1408:39 - and we're going to hop over in our
1408:42 - implementation let's grab what we just
1408:44 - added because we will need to put that
1408:46 - in our cpp file we are going to go in
1408:50 - player.cpp and we're going to add this
1408:53 - data we're going to put that here
1408:55 - we can close the left sidebar to have
1408:58 - some more breathing room and then we're
1409:00 - going to not do
1409:03 - an initializer list here because this is
1409:05 - really going to be useless we are
1409:07 - changing data in the body anyway so what
1409:10 - we can do
1409:11 - is say game param or a game and we're
1409:14 - going to say
1409:15 - gamipuram i am really sorry i am not
1409:18 - following the same convention for the
1409:21 - naming of my member variables but we can
1409:23 - change this later so let's say first
1409:26 - name we are going to pass in first name
1409:29 - ram and for the last name we're going to
1409:31 - say last name param and that's going to
1409:33 - do now we have the ability to go in the
1409:36 - main cpp file and create player objects
1409:40 - and specify the first name and the last
1409:42 - name and this is going to be much more
1409:45 - flexible so let's go back to the
1409:47 - constructor and see the order of our
1409:50 - parameters game first name last name so
1409:53 - we can come here and say first name is
1409:56 - going to be
1409:58 - john and the last name is going to be
1410:00 - snow and if we build and run we're going
1410:02 - to see the information printed out here
1410:04 - and now we have the flexibility to be
1410:06 - able to specify this
1410:08 - in a constructor and this is going to
1410:10 - make the job of building our objects
1410:13 - much easier and we can forward this data
1410:16 - back into the base class using the
1410:19 - protected mechanism that we just learned
1410:22 - about in this lecture and this is really
1410:23 - cool so let's build we're going to pass
1410:26 - this through gcc and the world is going
1410:28 - to be good we can clear and run rooster
1410:31 - we're going to see that the data is
1410:33 - passed back to the base class this is
1410:35 - working
1410:36 - really well okay so this is really all i
1410:38 - wanted you to see in this lecture we can
1410:41 - set up protected member variables and
1410:44 - they are going to be accessible and
1410:45 - usable from any derived class that does
1410:49 - public inheritance but they want to be
1410:52 - accessible from the outside so if you
1410:54 - try and for example say p1 and say
1410:58 - first name and try to change that to
1411:01 - something else let's say daniel for
1411:02 - example you're going to have compiler
1411:04 - errors because this is not going to work
1411:07 - so let's try and build and show you the
1411:09 - compiler error okay so protected members
1411:11 - are not accessible from the outside
1411:14 - they will be just accessible from
1411:16 - derived classes or to be more specific
1411:19 - they are going to be accessible from
1411:22 - the members of the derived class and by
1411:25 - members i mean member functions because
1411:27 - that's where you will be accessing and
1411:29 - modifying stuff so let's go back to the
1411:32 - main cpp file and remove this
1411:35 - and this is really all i wanted to share
1411:37 - with you and i hope you found this
1411:39 - lecture interesting we are going to stop
1411:42 - here in this one
1411:43 - and in the next one we're going to zoom
1411:45 - in on the syntax here we are using to
1411:48 - derive from other classes we just did
1411:51 - the public inheritance here but in the
1411:54 - next lecture we're going to see that it
1411:55 - is possible to actually do protected and
1411:59 - private inheritance and we're going to
1412:01 - see what this means in the next lecture
1412:03 - so go ahead and finish up here and meet
1412:06 - me there in this lecture we're going to
1412:07 - learn about base class access specifiers
1412:11 - and in case you didn't know we have been
1412:13 - using base class access specifiers in
1412:15 - this chapter all along and to really
1412:18 - understand this let's look at our player
1412:21 - class which is inheriting from person
1412:23 - and we are doing public inheritance the
1412:27 - public keyword here is a base class
1412:29 - access specifier and it is going to
1412:32 - control
1412:33 - how accessible our base class members
1412:37 - from a derived class and we have three
1412:40 - options okay so if we do public
1412:43 - inheritance like we see here in our
1412:45 - player class
1412:47 - anything that is public in the base
1412:49 - class is also going to be public you see
1412:52 - m1 here is also public in the derived
1412:54 - class
1412:55 - anything that is protected is going to
1412:57 - stay protected and anything that is
1413:00 - private in the base class is also going
1413:02 - to stay private in the derived class
1413:06 - try and take a moment to look at this
1413:08 - again
1413:09 - the member access specifiers we have in
1413:13 - the base class are going to stay intact
1413:16 - if we do
1413:17 - public inheritance again anything that
1413:20 - is public in base is going to be public
1413:22 - and derived anything that is protected
1413:25 - in base is going to be protected and
1413:27 - derived and anything that is private in
1413:30 - base is going to be
1413:32 - private in derived this is one kind of
1413:36 - inheritance we can do in c plus plus but
1413:39 - we can also do protected inheritance and
1413:42 - the syntax to do that you just use the
1413:44 - protected keyword here you say class
1413:47 - player column column and specify that
1413:49 - you want to do protected inheritance and
1413:52 - then you specify the base class you want
1413:55 - to inherit from the moment you do this
1413:58 - anything that is public in the base
1414:00 - class is going to be protected in the
1414:02 - derived class
1414:04 - anything that is protected is going to
1414:06 - stay protected anything that is private
1414:08 - is going to be private
1414:11 - and in one way you can see that we can
1414:13 - use these base class access specifiers
1414:17 - to constrain
1414:18 - the access specifier in derived class
1414:21 - but we can't make the access specifiers
1414:24 - in derived class
1414:26 - more relaxed we can only make things
1414:28 - more constrained or more restricted for
1414:31 - example the m1 member variable was
1414:33 - public but now we have made it become
1414:36 - protected by using the protected base
1414:40 - access specifier here okay so now you
1414:42 - know that we can do public and protected
1414:45 - inheritance but it is also possible to
1414:48 - do private inheritance and you do that
1414:51 - by using a private base class access
1414:54 - specifier the moment you do this
1414:56 - anything that is public in the base
1414:58 - class is going to become private in the
1415:00 - derived class anything that is protected
1415:03 - in the base class is going to become
1415:05 - private in the derived class and
1415:07 - anything that is private is going to
1415:09 - stay private in the derived class and
1415:12 - again you see that this is going to
1415:13 - constrain thanks things that were public
1415:16 - are now private in derived and we can't
1415:18 - really do anything with them from any
1415:21 - other class that might derive from our
1415:23 - player class so this is the setup we
1415:26 - have okay to sum this up through the
1415:29 - base class access specifier we can
1415:31 - control how relaxed or constrained
1415:35 - is the access to base class members from
1415:38 - the derived class and this is really
1415:40 - important to understand if you want to
1415:42 - say as relaxed as they are in the base
1415:44 - class you can use public inheritance if
1415:47 - you want to constrain a little bit you
1415:49 - can use
1415:50 - protected inheritance and things are
1415:52 - going to be inherited as protected
1415:54 - except for the private data in the base
1415:57 - class if you want things to be super
1415:59 - constrained you can use the private
1416:02 - inheritance that we just learned about
1416:04 - and everything in your derived class is
1416:06 - going to be private and you can use this
1416:09 - if it makes sense for the application
1416:11 - you are designing and you can use these
1416:14 - kinds of features if they make sense for
1416:16 - whatever application you are designing
1416:18 - with c plus plus one thing you should
1416:20 - know though is that regardless of the
1416:23 - base class access specifier we use
1416:26 - private members of the base class can
1416:29 - never be accessible from a derived class
1416:32 - so anything that is private is going to
1416:34 - stay private and you have no way to
1416:37 - relax things a little bit that's not
1416:39 - going to work you should really know
1416:40 - this now that you know these kinds of
1416:43 - inheritances we can do in ziplus plus
1416:46 - we're going to head over to the next
1416:47 - lecture and play with them a little more
1416:49 - in this lecture we're going to play with
1416:51 - the base class access specifiers we
1416:54 - learned about in the last lecture in
1416:56 - other words we're going to play with
1416:58 - public protected and private inheritance
1417:01 - in visual studio code so let's review a
1417:03 - little bit what we talked about in the
1417:05 - last lecture we say that we can have
1417:07 - public inheritance and the syntax to do
1417:10 - that is what you see here and at the
1417:12 - moment you do this what was public in
1417:15 - the basic class is going to be public in
1417:17 - the derived class what was protected is
1417:19 - going to stay protected what was private
1417:21 - is going to become private in the
1417:24 - derived class in other words public
1417:26 - inheritance is really not going to
1417:28 - change the accessibility of the member
1417:31 - variables we have in the base class
1417:33 - we're going to inherit the data as it
1417:35 - was with the same access level we had in
1417:38 - the base class this is a defining
1417:40 - feature of public inheritance in c plus
1417:43 - plus we can also do protected
1417:45 - inheritance and what this is going to do
1417:49 - is to make protected the highest access
1417:52 - level we can have in the derived class
1417:55 - so anything that was public in the base
1417:57 - class is going to become protected
1417:59 - anything that was protected is going to
1418:01 - stay protected because that's the
1418:03 - highest level we can do now
1418:05 - and anything that was private in the
1418:07 - base class is going to be private in the
1418:10 - derived class we say private in the
1418:13 - sense that it is going to be private to
1418:15 - the base class so you can't really use
1418:17 - m3 from the player class in this case if
1418:21 - you're trying to do that you're going to
1418:22 - get a compiler error okay we can also do
1418:25 - private inheritance and the syntax to do
1418:28 - that is what you see here and now
1418:31 - private is going to be the highest level
1418:33 - we can do
1418:34 - in the player class in terms of the
1418:37 - members that we get from the base class
1418:39 - so anything that was public is going to
1418:41 - become private anything that was
1418:43 - protected is going to become private
1418:45 - anything that was private to the base
1418:48 - class is going to stay private to the
1418:49 - base class this is what we mean here but
1418:52 - now
1418:53 - m1 and m2 just became public to the
1418:58 - player class if anybody else tries to
1419:01 - derive or inherit from a player these
1419:04 - things are not going to be accessible
1419:07 - and this is in some way the player class
1419:10 - being selfish it is saying i am going to
1419:13 - get everything i can from my parent
1419:15 - class or my base class but i am going to
1419:18 - make it all mine nobody else can take
1419:21 - this and this is the kind of setup we
1419:23 - can achieve
1419:24 - with private inheritance okay so now
1419:27 - that we have this in mind we're going to
1419:28 - play with us in visual studio code we're
1419:30 - going to set up a bunch of classes we're
1419:32 - going to set up a personal class we're
1419:34 - going to be inheriting from we are going
1419:36 - to set up a nurse class which is going
1419:38 - to do protected inheritance and we're
1419:41 - going to set up an engineer class which
1419:43 - is going to do private inheritance and
1419:45 - we're going to really play with this and
1419:47 - see how this plays out in real c plus
1419:50 - plus code so let's do this here we are
1419:52 - in our working folder the current
1419:54 - project is base access specifier a demo
1419:58 - we're going to do a demo on this but
1420:00 - before we do that we're going to grab
1420:02 - our template files and put them in place
1420:05 - and we are going to open this little guy
1420:07 - in visual studio code by dragging and
1420:09 - dropping here this is going to give us a
1420:11 - good starting point we're going to have
1420:13 - our main cpp file we're going to clean
1420:16 - it up and we're going to set up our base
1420:18 - class which is going to be the person
1420:19 - class so let's put this in from scratch
1420:22 - we're going to add our files we're going
1420:24 - to say person page and we're going to
1420:26 - say person.cpp
1420:28 - we are going to hop over in our header
1420:30 - file and put in our code nothing special
1420:33 - so far we have an include gourd we have
1420:35 - our person class it has a bunch of
1420:37 - member variables we have the full name
1420:40 - which is public we have the age which is
1420:42 - protected and we have the address which
1420:45 - is private to this class here this is
1420:49 - going to be our starting point
1420:51 - we also have a bunch of constructors we
1420:53 - have a default one we also have another
1420:55 - one which is going to take all the data
1420:57 - we can use the constructor person object
1421:00 - and here we are passing a cost string by
1421:03 - reference i think we can fix this and
1421:05 - pass a string view this is going to be
1421:07 - better let's say string view and we're
1421:10 - going to change the first parameter here
1421:12 - to be an std string view by value this
1421:15 - is going to be much better okay we have
1421:18 - our class we can hop over in the cpp
1421:21 - file and put in our implementation we
1421:24 - are going to change the constructor a
1421:26 - little bit and make sure we are taking
1421:28 - an std string view by value and if you
1421:31 - wanted to type all this code you can get
1421:33 - it from the resource section of this
1421:36 - lecture i am going to attach all the
1421:37 - source code and you can download and use
1421:40 - this however you want to really make
1421:42 - your learning experience as pleasant as
1421:44 - possible so we have our constructor here
1421:46 - it is going to forward the data into our
1421:49 - member variables the full name is going
1421:50 - to go into our full name member variable
1421:53 - we're going to grab the age and the
1421:54 - address and we're going to store all
1421:56 - this information we also have an output
1421:58 - stream operator which is going to be
1422:00 - printing all this information here it is
1422:02 - going to go through the getters because
1422:04 - we have a person object passed as a
1422:07 - parameter here and this is going to work
1422:10 - we can go in the main cpp file and
1422:12 - include our person class and create an
1422:15 - object of it we can do something like
1422:17 - person person one and we can pass the
1422:20 - data that our constructor expects we can
1422:22 - pass in the full name the age and the
1422:25 - address so let's do that we're going to
1422:27 - say the full name daniel gray why not
1422:30 - and the age is going to be 27 we can put
1422:33 - in whatever we want and we're going to
1422:35 - put in the address we're going to say
1422:37 - blue sky streak you can say two three
1422:40 - three for example and say the number of
1422:43 - the house to b56 why not this is a
1422:46 - possible address for a person so we can
1422:48 - say person one or we can use htdc out to
1422:52 - print this out because we have an output
1422:54 - stream operator for our person class we
1422:57 - can do this we're going to say person
1422:59 - one and we're going to put him out and
1423:02 - if we build and run this program we're
1423:04 - going to see that this is going to work
1423:06 - hopefully and we have a problem because
1423:09 - we don't have a semicolon at the end of
1423:11 - line 6 here let's fix that we're going
1423:14 - to run this task to build with gcc the
1423:17 - builder is going to be good we can bring
1423:19 - up a powershell window
1423:21 - and we're going to use this to run our
1423:23 - program if we say rooster we're going to
1423:25 - see that we have the person printed down
1423:27 - the full name is daniel gray the age is
1423:30 - 27 the address is blue sky street 233
1423:35 - and the number of the house is 56 so
1423:38 - this is a possible implementation for
1423:40 - the person class but we are really not
1423:42 - interested in setting up a prison class
1423:44 - and doing things with that we are
1423:46 - interested in inheriting from the person
1423:49 - class and learn about different kinds of
1423:52 - base class access specifiers we can do
1423:55 - so we're going to set up a player class
1423:57 - which is going to inherit publicly from
1424:00 - the person class let's do that we're
1424:02 - going to put in our player we're going
1424:04 - to put in the header file let's say
1424:06 - player not person and we're going to say
1424:09 - player.h we're going to put in a cpp
1424:12 - file we are going to hop over in the
1424:14 - header of player and put in our class
1424:17 - let's close the left sidebar here so
1424:20 - that you can really see everything we
1424:22 - have an include guard in
1424:23 - we have the class player declared it is
1424:26 - going to do public inheritance from
1424:28 - person
1424:29 - and what this is going to do is that
1424:32 - anything that is public in person is
1424:34 - going to stay public in player anything
1424:37 - that is protected is going to stay
1424:39 - protected in player
1424:41 - and anything that is
1424:43 - private is going to stay private so we
1424:46 - want to be able to access private data
1424:48 - from a person object for example we
1424:50 - can't access
1424:52 - the address member variable here because
1424:54 - it is private but we can use the full
1424:57 - name and the age
1424:58 - from the
1425:00 - derived class
1425:02 - let's make sure we have a cpp file and
1425:05 - before we try things out
1425:07 - so let's hop over to the cpp file and
1425:09 - put in a possible implementation we are
1425:12 - going to include the person and player
1425:15 - because we're going to be using these
1425:17 - and we are going to set up a constructor
1425:20 - which is not going to do anything for a
1425:22 - player we also have our output stream
1425:25 - operator which is going to print the
1425:27 - data it is going to be using the getters
1425:29 - we have in the base class and we have
1425:32 - access to them
1425:33 - because we are doing public inheritance
1425:36 - so they are going to be public and we
1425:38 - can call them from the outside like we
1425:40 - are doing here notice that this is an
1425:43 - outside player object and we are calling
1425:46 - our public members on it and this is
1425:48 - going to work we also have a destructor
1425:50 - and which is really not going to do
1425:52 - anything but we're going to keep it in
1425:54 - here because it's not going to hurt so
1425:57 - now what we want to try out
1425:59 - is to see if we can access thanks from
1426:02 - the base class the first thing we have
1426:04 - in the base class is the
1426:07 - full name and i think we can actually
1426:09 - copy these blanks or we cannot just use
1426:12 - them m full name mh and m address we're
1426:15 - going to try and use them in the derived
1426:18 - class so let's try and say m full name
1426:21 - and change the full name for example to
1426:24 - be
1426:24 - daniel gray or jon snow and we're going
1426:27 - to
1426:28 - change the age to be
1426:30 - 55 why not and we're going to try and
1426:33 - access the address let's see what we
1426:36 - called our address member variable it is
1426:38 - m address we can grab that and use that
1426:40 - in our class if we try to access that
1426:43 - we're going to get a compiler error
1426:45 - because that's going to be
1426:47 - private to the base class you notice
1426:50 - that if we even try to put some junk
1426:52 - data we're going to have a squiggly line
1426:54 - because this is not accessible here and
1426:57 - visual studio code is going to say that
1426:59 - this is not accessible
1427:01 - because it is private to the base class
1427:04 - so we can access m full name because it
1427:06 - was inherited as public so this is going
1427:10 - to be okay we can use age because it was
1427:13 - inherited as protected we can use it in
1427:17 - a derived class but we can't use the
1427:19 - address because it was inherited as
1427:22 - private and it is private to the base
1427:24 - class so this is not going to work even
1427:27 - if we try to call biola code we're going
1427:28 - to get a compiler error let's try to do
1427:30 - that so that you can really see for
1427:32 - yourself okay so we have a compiler
1427:35 - error and this was declared in the base
1427:39 - class as private this is what the
1427:41 - compiler error is saying so we shouldn't
1427:43 - really be doing this the derived class
1427:46 - has no business
1427:48 - modifying a private member of the base
1427:51 - class this is the message here so we're
1427:53 - going to comment this out and say that
1427:55 - this is going to give you a compiler
1427:56 - error but we are also going to create a
1427:59 - player object and try to access these
1428:02 - guys and see how accesses from the
1428:05 - outside so we're going to go in the main
1428:07 - cpp file and we're going to include
1428:09 - player dot h and we're going to create a
1428:12 - player object we can put in a separator
1428:14 - and say a bunch of dashes here this is
1428:17 - going to do i think this is going to
1428:19 - work and we're going to create a player
1428:21 - object we can say player and player and
1428:24 - not put any parenthesis here this is
1428:27 - going to call the default constructor
1428:29 - that we have in our player class and we
1428:33 - can try to use this but before we do
1428:35 - let's try and build and see that this is
1428:37 - going to build just fine we're going to
1428:39 - work with gcc let's do that we're going
1428:42 - to see that the world is good we can try
1428:44 - and access stuff from this player object
1428:47 - we can say player and say m full name
1428:50 - you see that this is accessible we can
1428:52 - actually change this
1428:54 - to samwell jackson we can do that but if
1428:58 - we try and say player mh we're going to
1429:01 - see that this is not accessible here
1429:03 - because this was inherited as protected
1429:06 - if we go back to person we're going to
1429:07 - see that the age is protected so it will
1429:11 - be accessible in derived classes just
1429:14 - like we did in our play method of the
1429:18 - player class but we can't access the age
1429:20 - from the outside of a player object
1429:24 - because that's not going to be
1429:25 - accessible from the outside this is a
1429:27 - defining feature of the protected access
1429:30 - level so this is not going to work even
1429:32 - if we try to build we're going to get a
1429:34 - compiler error along the lines of this
1429:38 - is not accessible in this context and it
1429:41 - was declared in the base class so we
1429:43 - can't really access it from the outside
1429:46 - this is the compiler error here so we're
1429:47 - going to comment this out and say that
1429:50 - this is going to give you a compiler
1429:51 - error okay so i hope you know that you
1429:53 - can't even have a chance accessing a
1429:55 - private member of a base class from a
1429:59 - derived object in the main function like
1430:02 - we do here so if we try and do player
1430:05 - and say m address this is not going to
1430:08 - work okay so if we try to change this
1430:09 - for example to some junk data this is
1430:12 - not going to work we're going to get a
1430:13 - compiler error because this was declared
1430:16 - private in the base class and it is
1430:19 - private to the base class you can't
1430:20 - really access it from the outside you
1430:23 - can't even access it from a derived
1430:25 - class so let alone access this on the
1430:28 - outside in the main function so this is
1430:29 - not going to work it is going to give
1430:31 - you a compiler error but we're going to
1430:33 - weld and show you the compiler error
1430:35 - because we are learning here so we're
1430:37 - going to get a compiler error that says
1430:40 - m address is private within the context
1430:43 - where we are trying to use it so we
1430:45 - can't really use it from the outside
1430:47 - here again this is going to give us a
1430:50 - compiler error let's say that here and
1430:52 - this is really what i wanted you to
1430:55 - learn about public inheritance anything
1430:57 - that is public in the base class is
1430:59 - going to be public in the derived class
1431:02 - anything that is protected is going to
1431:04 - stay protected and what that means it
1431:06 - will be usable in the derived class but
1431:10 - you can't use that from the outside and
1431:12 - anything that is private in the base
1431:14 - class is going to stay private so you
1431:16 - can't use that from the derived class
1431:18 - and you can't even use that from the
1431:20 - outside like we are doing in the main
1431:22 - function here this is not going to work
1431:25 - okay so now that we have this in place
1431:27 - we're going to set up another class that
1431:29 - is going to do
1431:30 - protected inheritance and that's going
1431:33 - to be our nurse class so we're going to
1431:35 - put this in let's put in a nurse header
1431:38 - file this is going to be nurse.h we're
1431:40 - also going to put in nurse.cpp okay so
1431:44 - we're going to head over in the header
1431:45 - file and put in the code for our nurse
1431:48 - class we're going to say cluster nurse
1431:51 - and say protected to mean that we want
1431:53 - to do protected inheritance and what
1431:55 - this is going to do anything that is
1431:57 - public in the base class is going to be
1432:00 - protected in the derived class which is
1432:03 - our nurse class anything that is
1432:05 - protected is going to stay protected
1432:07 - anything that is private is going to
1432:09 - stay private
1432:10 - to the base class this is what we mean
1432:12 - here okay now that we have this end we
1432:15 - can put in the implementation for our
1432:18 - nurse class and we're going to have a
1432:20 - constructor and we're going to have our
1432:22 - output stream operator and we're going
1432:24 - to have a destructor which is really not
1432:26 - going to do anything because we don't
1432:28 - have any dynamic memory allocation in
1432:31 - our class
1432:33 - we are going to try and build this code
1432:35 - to see that it is going to work we have
1432:38 - a squiggly line in the main cpp file but
1432:41 - it was because of the line 15 here and
1432:44 - it has been commented down let's see if
1432:46 - we can build this program okay you see
1432:49 - that the world is going to be good and
1432:51 - we are able
1432:52 - to call
1432:54 - thanks from our output stream operator
1432:56 - you see we have an earth operand we are
1432:59 - able to call this gateful name and get
1433:03 - age member function
1433:05 - because they are now protected in the
1433:07 - nurse class but we are able to call them
1433:09 - from the outside
1433:11 - because this operator is a friend of our
1433:15 - nurse class here i want you to say this
1433:18 - some of you are going to ask
1433:20 - aren't we using an object and calling a
1433:23 - method using the dot operator this
1433:25 - qualifies as calling thanks from the
1433:28 - outside and yes that's true but this
1433:31 - method is really like a member function
1433:34 - in that it has access to private and
1433:38 - protected data from our nurse class and
1433:40 - the reason is it is a friend of the
1433:43 - nurse class here that's why we are able
1433:45 - to do
1433:46 - something like this but what i really
1433:48 - want you to see now that that doubt is
1433:51 - cleared is the kind of access we have to
1433:54 - thanks from the base class we will still
1433:56 - be able to use m full name here because
1433:59 - it was inherited as protected so we can
1434:02 - use it from a derived class we can say m
1434:05 - full name jon snow this is going to work
1434:08 - because this was
1434:10 - inherited as protected now it is
1434:12 - protected in the eyes of the nurse class
1434:15 - this is what we mean here so this is
1434:17 - okay this is going to work we can get
1434:19 - the age we can use that and we can say
1434:23 - john's and we can say
1434:25 - 23 for example this is going to work
1434:27 - because this is protected but we can't
1434:30 - use the address if we do that we want to
1434:33 - be able to change it we will get a
1434:34 - compiler error because
1434:37 - this is private to the base class this
1434:39 - is the same thing we saw in the last
1434:41 - lecture this is going to give us a
1434:42 - compiler error if we try to build this
1434:45 - program let's try and build it to really
1434:48 - prove this the body is going to be good
1434:50 - without line 17 here but if we
1434:53 - uncommented and trying to build the
1434:55 - program let's do that we are going to
1434:58 - get a compiler error and the compiler
1435:00 - error is going to say let's go up and
1435:03 - see if we can get this message it's
1435:05 - going to say
1435:06 - m address is private within this context
1435:10 - where we are trying to use it and that's
1435:12 - line 17 of the nurse class if we go
1435:15 - there we're going to find the offending
1435:16 - line here so we're going to comment this
1435:18 - out and say that this is going to give
1435:20 - us a compiler error okay so you
1435:22 - shouldn't do this now that we know
1435:24 - things from the inside let's see how
1435:26 - things fair
1435:28 - on the outside we are going to hop over
1435:31 - to the main cpp file and include our
1435:34 - nurse class and we're going to create a
1435:36 - nurse object we can go down and say
1435:39 - stdcl and we're going to put in our
1435:42 - dashes and we're going to create a nurse
1435:44 - object i think we have a default
1435:46 - constructor for a nurse we're going to
1435:48 - say nurse 1 and we're going to basically
1435:51 - try and do the same things we did for
1435:53 - the player object from the outside if we
1435:56 - try to access the full name now it's not
1435:59 - going to be accessible because it was
1436:01 - inherited
1436:02 - with protected access level so if we do
1436:06 - nurse and say m full name you're going
1436:08 - to see that autocomplete is not here
1436:11 - this is a good sign that this is not
1436:13 - accessible from this place if we say
1436:16 - davy jones we're going to get a compiler
1436:18 - error and if we try to build we're going
1436:20 - to get a descriptive compiler error at
1436:23 - least i hope so let's build we're going
1436:25 - to see that with world with errors and
1436:28 - if we go up we're going to have our
1436:30 - error nurse was not declared in this
1436:33 - scope did you mean nurse one yes we met
1436:36 - nurse one sorry for that we're going to
1436:38 - build again thank you gcc for pointing
1436:41 - this out we are going to get another
1436:43 - kind of error and if we look at our
1436:46 - error here we're going to see that m
1436:48 - full name is inaccessible within this
1436:50 - context because it is a protected member
1436:54 - of the nurse class now it was inherited
1436:57 - as protected and we can't access it from
1437:00 - the outside we can access that from the
1437:02 - inside because it is protected but if we
1437:05 - try to access it from the outside we're
1437:07 - going to get a compiler error and this
1437:09 - is a defining feature
1437:11 - of protected inheritance even things
1437:14 - that were public in the base class are
1437:16 - going to become protected in the derived
1437:19 - class so this is the message here and
1437:21 - this is going to give us a compiler
1437:23 - error okay so if we also try to access
1437:25 - nurse 1 and say m
1437:28 - h this is also going to give us a
1437:30 - compiler arrow let's try to put in an
1437:32 - edge here let's put in 51. you're going
1437:35 - to see that we're going to get the same
1437:36 - kind of error
1437:38 - let's really try these things out and
1437:40 - learn about every possible way we can
1437:43 - set up these things
1437:45 - if we look at the error we're going to
1437:47 - see that image is protected within this
1437:49 - context so we can't really access it so
1437:52 - this is the compiler error we get and i
1437:54 - hope you know that if you try and access
1437:57 - the address you're also going to get a
1437:59 - compiler error because that's private to
1438:01 - the base class so we can't even use that
1438:04 - from a derived class like nurse here
1438:07 - that's not going to work let's say that
1438:08 - here we have a compiler error and we're
1438:10 - going to set up another class which is
1438:13 - going to inherit privately and see how
1438:16 - that works out the class is going to be
1438:18 - engineer we're going to see that the
1438:19 - error here goes away so let's create our
1438:22 - engineer class we're going to put in a
1438:24 - header file that's going to be our
1438:27 - engineer.h we are also going to put in
1438:31 - cpp okay so we're going to hop over to
1438:34 - our header file and put in our engineer
1438:37 - class we're going to say engineer and
1438:39 - say that we want to inherit privately
1438:42 - from the person class this is the syntax
1438:44 - here and this is going to do private
1438:46 - inheritance and what this means is that
1438:49 - anything that is public is going to
1438:51 - become private to this class anything
1438:54 - that is protected in the base class is
1438:56 - going to become private to this class
1438:58 - and anything that was private in the
1439:00 - base class is going to stay private we
1439:03 - won't have access to that whatsoever in
1439:06 - the derived class directly we are going
1439:09 - to hop over to the cpp file and put in
1439:12 - our implementations we're going to have
1439:15 - a default constructor for engineer which
1439:17 - is not going to be taking any parameter
1439:19 - we're going to have our output stream
1439:21 - operator which is going to still work
1439:24 - because it is a friend of the engineer
1439:26 - class so all these things that were
1439:29 - inherited to be private are going to be
1439:32 - private to the engineer class and any
1439:35 - friend of the engineer class will have
1439:37 - access to that that's why we are able to
1439:40 - call get full name get age and get
1439:42 - address here and get these things to
1439:45 - work okay now that this is out of the
1439:47 - way we can try and access our thanks
1439:50 - we're going to try and do the same
1439:52 - things we did in our nurse header we're
1439:55 - going to copy the code because we are
1439:57 - trying to access the same member
1439:58 - variables and we're going to see how
1440:00 - this fairs in our engineer class this is
1440:03 - going to save us a few seconds
1440:06 - if we try to access the full name this
1440:08 - is going to work because it is private
1440:10 - to this class if we try to access the
1440:13 - edge this is going to work because all
1440:15 - these guys are now private
1440:17 - to this class here but if we try to
1440:20 - access the address this is going to give
1440:22 - us a compiler error because address is
1440:25 - private to the base class if we go back
1440:27 - to person we're going to see that this
1440:29 - is the case
1440:30 - and if you try to inherit from this
1440:33 - class in any way you're not going to be
1440:35 - able to change this access level this
1440:38 - member variable is always going to stay
1440:40 - private to the base class and no derived
1440:43 - class will be able to modify or read
1440:46 - from this in any way so this is the
1440:48 - setup we have here if we try to build
1440:50 - we're going to get a compiler error
1440:52 - let's first take this out and show you
1440:54 - that this is going to build
1440:56 - just fine without this line here
1440:59 - and i am going to build again and show
1441:02 - you that if we bring that in we're going
1441:04 - to get a compiler error so the build is
1441:06 - good we can go back in our engineer
1441:08 - class and bring in the offending line we
1441:12 - can uncomment this and if we want we're
1441:14 - going to get a compiler error let's make
1441:17 - sure you see the compiler error here so
1441:19 - the world was finished with errors and
1441:22 - if we go up we're going to see that we
1441:23 - have an error here and the error is
1441:26 - going to say m address is private within
1441:28 - this context and the context is what we
1441:31 - have at line 17 in the
1441:34 - engineer class so we can go there and
1441:36 - find the offending line and we're going
1441:38 - to comment this out and this is going to
1441:40 - give us a compiler error now you know
1441:43 - this but this is how things are going to
1441:45 - work from the inside but we also need to
1441:48 - look at how things fare from the outside
1441:51 - let's go back in our main cpp file we
1441:54 - are going to include our engineer class
1441:57 - and we are going to create an engineer
1441:59 - object we can go down and say sddc out
1442:02 - and put in a bunch of dashes to separate
1442:05 - on thanks and we can create a
1442:08 - engineer object and that's going to be
1442:10 - engineer one and if we try to access the
1442:14 - full name that's not going to work
1442:15 - because it is now private
1442:18 - to the engineer class
1442:20 - if we say engineer one and try to say m
1442:23 - full name and try to change the name in
1442:26 - any way and say for example
1442:28 - olivier godson i am making this up i
1442:31 - don't know if this name exists but the
1442:34 - point is that this is not going to work
1442:36 - it is going to give you a compiler error
1442:38 - because m full name is now private to
1442:41 - the engineer class it was inherited to
1442:44 - be private to the engineer class and if
1442:47 - you try to do this you're going to get a
1442:48 - compiler error let's try and work with
1442:51 - gcc to really show you this and the
1442:53 - world is going to be finished with
1442:55 - errors and if we go up we're going to
1442:57 - find our error
1442:58 - full name is inaccessible from within
1443:01 - this context and the offending line is
1443:04 - at line 27 of the main cpp file if we go
1443:09 - there we're going to find our line and
1443:11 - we're going to say that this is going to
1443:12 - give us a compiler error so let's say
1443:15 - that and we can't even access the age
1443:19 - and the address member variables the age
1443:21 - is also going to be private to engineer
1443:24 - but the address is private to the base
1443:27 - class
1443:28 - so that's not going to work either so we
1443:30 - can't really access that from the
1443:32 - outside because it is now private to the
1443:35 - engineer class so let's go down and
1443:38 - really show you that we're going to go
1443:40 - down and say engineer one and say mh if
1443:43 - we try to do that that's not going to
1443:45 - work that's going to give us a compiler
1443:47 - error and if we try to build we're going
1443:49 - to get a compiler error along the same
1443:51 - lines as what we just got here
1443:54 - the book is going to finish with errors
1443:56 - and if we look at our error we're going
1443:58 - to see that mh is protected within this
1444:00 - context so we can't use it at line 28 of
1444:04 - the main cpp file this is going to give
1444:07 - us a compiler error let's do that we're
1444:09 - going to say that here and if we try and
1444:12 - access the m address member variable
1444:15 - that's not also going to work because
1444:17 - this is even more restricted for access
1444:21 - it is private to the base class so we
1444:23 - can't access it from a derived class
1444:25 - directly we can't even access that from
1444:27 - the outside so you should really know
1444:29 - this so if we put in some junk data here
1444:31 - and try to build this is going to give
1444:33 - us a compiler error that says that this
1444:36 - is not accessible from the main cpp file
1444:40 - like we are trying to do on line 29 here
1444:43 - so we're going to get an error and the
1444:45 - error is going to say m address is
1444:47 - private within this context and the
1444:50 - offending line is at 29 of the main cpp
1444:53 - file we're going to take this out and
1444:55 - we're going to say that this is going to
1444:56 - give us a compiler error this is really
1444:58 - all i wanted you to see in this lecture
1445:01 - and before we wrap this up let's try and
1445:03 - build again and make the error go away
1445:05 - because i don't like to leave you with
1445:08 - code that has compiler errors and the
1445:11 - book is good and this is really all i
1445:13 - wanted you to see in this lecture that
1445:16 - you can do all kinds of inheritances in
1445:19 - your c plus plus code you can do public
1445:21 - inheritance you can do protected
1445:23 - inheritance you can do private
1445:25 - inheritance and we had a chance to look
1445:27 - at all these scenarios in this lecture
1445:29 - here the message is the same as we saw
1445:32 - in the last lecture if you do public
1445:35 - inheritance anything that is public in
1445:37 - the base class is going to stay public
1445:40 - in the derived class anything that is
1445:42 - protected is going to stay protected
1445:44 - anything that is private is going to
1445:46 - stay private and this is really
1445:49 - misleading in a way the private data
1445:52 - from the base class is not going to be
1445:54 - private to the derived class it's going
1445:56 - to stay private to the base class so if
1446:00 - you try to use this in any way from the
1446:03 - derived class you're going to get
1446:04 - compiler errors because you can't access
1446:07 - that even if it is part of you player
1446:10 - has a person part of it but it can't
1446:12 - access private members from the base
1446:15 - class you should really know this we
1446:17 - have seen that we can also do protected
1446:19 - inheritance and that's going to
1446:21 - constrain events to have
1446:23 - the highest level of access to be
1446:25 - protected so anything that is public is
1446:28 - going to be stripped down to protected
1446:30 - access anything that is protected is
1446:33 - going to stay protected anything that is
1446:35 - private is going to be private to the
1446:38 - base class you should really make this
1446:40 - super clear we can also do private
1446:42 - inheritance as we saw and this is going
1446:45 - to strip down the highest level access
1446:47 - to be private so anything that is public
1446:50 - is going to be constrained to be private
1446:52 - anything that is protected is going to
1446:54 - be inherited as protected to the player
1446:57 - class but anything that was private in
1447:00 - the base class is going to stay private
1447:03 - to the base class even the player class
1447:05 - won't have access to this member
1447:07 - directly if we really need access to
1447:10 - private data from the base class we
1447:12 - might go through public getters or
1447:15 - anything we get from the base class but
1447:17 - we can't access m3 directly and use it
1447:20 - from the derived class that's going to
1447:22 - give us a compiler error this is really
1447:24 - all i wanted you to see in this lecture
1447:26 - and i hope you find this interesting we
1447:29 - are going to stop here in this lecture
1447:31 - in the next one we're going to try and
1447:32 - zoom in on private inheritance and show
1447:36 - you some things you really need to be
1447:38 - careful about
1447:39 - so go ahead and finish up here and meet
1447:41 - me there
1447:42 - in this lecture we're going to zoom in
1447:44 - on private inheritance and we're going
1447:47 - to see that the class that does a
1447:49 - private inheritance is really selfish
1447:52 - here is a simple structure we will be
1447:54 - using in this lecture here we will set
1447:56 - up a person class which is going to act
1447:58 - as our base class we are going to
1448:01 - inherit from this class privately and
1448:04 - create an engineer class
1448:06 - and what this is going to do it's going
1448:08 - to take everything from the class person
1448:12 - and make it private to the engineer
1448:15 - class so the m1 member variable which
1448:17 - was public in the base class is going to
1448:20 - be private to the engineer class this is
1448:22 - what we have here the m2 member variable
1448:25 - which was protected is going to become a
1448:28 - private in engineer that's what we have
1448:31 - here
1448:32 - and the m3 member variable which was
1448:34 - private to person class is going to stay
1448:37 - private to person in the eyes of
1448:40 - engineer this is the situation we have
1448:43 - here so the problem is going to really
1448:45 - show up when somebody else tries to
1448:48 - inherit from engineer because m1 and m2
1448:52 - are now private to engineer they will be
1448:55 - inherited but still inaccessible to the
1448:59 - civil engineer class here m1 and m2 will
1449:03 - be private to the engineer class but m3
1449:07 - will be private to the base class which
1449:10 - is person so hopefully you can see the
1449:12 - message that if a member variable is
1449:15 - private
1449:16 - it can't be inherited in any way it
1449:19 - doesn't matter which kind of inheritance
1449:21 - you do so starting from engineer which
1449:23 - has made m1 and m2 private to itself
1449:28 - it's no longer possible to forward these
1449:31 - guys down in the inheritance hierarchy
1449:34 - another way to look at this is to see
1449:36 - that the engineer class is really
1449:38 - selfish it is saying i am going to take
1449:41 - everything i can get from my parent
1449:43 - classes because i am
1449:46 - inheriting privately but nobody else
1449:49 - will be able to take things from me
1449:51 - because i'm going to make them private
1449:52 - to myself so even if civil engineer is
1449:55 - doing public inheritance
1449:58 - that's not going to give him any access
1450:00 - to these member variables which are now
1450:03 - private to the engineer class hopefully
1450:06 - you can really see this and private
1450:08 - inheritance is going to really constrain
1450:12 - what you can forward down to other
1450:14 - classes that are going to be inheriting
1450:17 - from you this is the message i am trying
1450:19 - to convey here okay so here is the same
1450:22 - example in code we have our person class
1450:25 - it's going to have our member variables
1450:27 - we're going to have the full name the
1450:29 - age and the address they are going to
1450:31 - have public protected and private access
1450:35 - we are going to inherit from person and
1450:37 - create our engineer class we are going
1450:40 - to privately inherit from person and
1450:42 - this is going to take everything we get
1450:45 - from person and make it private to the
1450:48 - engineer class and one exception is
1450:51 - going to be
1450:52 - what was already private to the base
1450:55 - class which is our person class here
1450:57 - this is going to still stay private to
1451:00 - the person class regardless of what kind
1451:03 - of inheritance you do from person but
1451:05 - any other thing if we have any member
1451:08 - variable which are public or protected
1451:10 - or even if we have some member functions
1451:12 - which are public or protected everything
1451:15 - is going to be private to the engineer
1451:18 - class because we have done private
1451:20 - inheritance here so if we inherit from
1451:24 - engineer and do any kind of inheritance
1451:27 - we are going to do the most relaxed kind
1451:30 - of inheritance which is going to keep
1451:32 - the kind of access we had in the base
1451:35 - class but this is not going to improve
1451:37 - anything everything is going to stay
1451:40 - private to the engineer class and the
1451:43 - civil engineer is really not going to
1451:45 - have any access to any member variable
1451:48 - or member function that is inherited
1451:50 - from the engineer class and we are going
1451:53 - to see this in a minute when we hit
1451:54 - visual studio code
1451:56 - so again if a class is doing private
1451:59 - inheritance it's really another way to
1452:01 - say this class is selfish it's going to
1452:04 - take everything it can from the parent
1452:07 - class but it's not going to forward
1452:09 - nothing to downstream inheritance
1452:12 - classes and this is the setup i really
1452:14 - want you to understand here and only do
1452:17 - private inheritance when you want this
1452:20 - kind of behavior now that you know this
1452:22 - we're going to head over to visual
1452:23 - studio code and play with us a little
1452:25 - more
1452:26 - here we are in our working folder the
1452:29 - current project is closing in on private
1452:32 - inheritance we're going to zoom in on
1452:34 - this and really understand the effects
1452:37 - of doing private inheritance we're going
1452:40 - to grab the code from the previous
1452:42 - lecture and we're going to grab the
1452:43 - engineer
1452:45 - and
1452:46 - the person class these are going to be
1452:49 - our starting point here make sure you
1452:51 - grab the dot vs code folder if you are
1452:54 - using vs code with this course that's
1452:56 - going to give you the basic settings we
1452:58 - need to do our c plus plus program i am
1453:01 - going to copy these guys down and put
1453:04 - these in our current project and again
1453:07 - make sure you have the main cpp file the
1453:10 - person class and the engineer class and
1453:13 - these are going to be our starting point
1453:15 - so we're going to open this little guy
1453:17 - in visual studio code by dragging and
1453:19 - dropping here we're going to look at our
1453:22 - main cpp program we are not going to
1453:25 - include nurse because we don't have this
1453:28 - included here
1453:29 - and we can really take out everything we
1453:32 - have in the main function we're going to
1453:35 - be adding our own thing here we also
1453:37 - don't need the player class here we're
1453:40 - just going to be using person and
1453:42 - engineer let's look at the person class
1453:45 - it is going to have the member variables
1453:46 - that we expect
1453:48 - we are going to have a public member
1453:50 - variable the full name a protected
1453:53 - member variable mh and a private member
1453:55 - variable m address here we are going to
1453:58 - create an engineer class which is going
1454:01 - to privately inherit from person
1454:04 - so it is going to make everything
1454:06 - private to itself the engineer class is
1454:09 - going to have a person part in at but
1454:12 - the member variables we get from the
1454:15 - person class are going to be stripped
1454:17 - down to private access level except for
1454:22 - the member variables which are already
1454:24 - private in the base class and that
1454:26 - happens to be the address so it doesn't
1454:29 - matter which kind of inheritance you do
1454:31 - the m address member variable is going
1454:33 - to still be not accessible to
1454:36 - inheritance classes this is going to
1454:38 - still be private to the base class which
1454:41 - is the person class here so the
1454:44 - full name is going to be stripped down
1454:46 - to private access level in engineer the
1454:50 - edge is also going to be stripped down
1454:52 - to private access and these are going to
1454:54 - be private now to the engineer class and
1454:58 - any class that tries to inherit from
1455:01 - engineer is not going to have access to
1455:03 - these guys so if we do any kind of
1455:06 - inheritance from engineer we want to
1455:08 - have access to full name we want to have
1455:10 - access to mh because these are going to
1455:12 - be private to this class here this is
1455:16 - the setup we want to understand in this
1455:18 - lecture so what we're going to do we're
1455:20 - going to set up a new class which is
1455:22 - going to inherit from our engineer class
1455:25 - and it is going to do public inheritance
1455:28 - and we're going to see how this works
1455:29 - we're going to create a civil engineer
1455:31 - class which is going to inherit from
1455:33 - engineer so let's do this we're going to
1455:35 - create a header file for our civil
1455:37 - engineer class and we're going to create
1455:40 - a cpp file
1455:41 - we are going to head over in our header
1455:44 - file and put in the class it's not going
1455:46 - to be anything sophisticated we're just
1455:49 - going to have in our include guard we're
1455:51 - going to create a civil engineer class
1455:53 - which is going to publicly inherit from
1455:55 - engineer but remember everything was
1455:58 - made private to the engineer class so
1456:01 - even if we're doing public inheritance
1456:03 - the full name member variable is going
1456:05 - to be private to engineer the age is
1456:08 - going to be private to engineer and
1456:10 - engineer won't have any access to these
1456:12 - guys but before we really play with that
1456:14 - we're going to put in our implementation
1456:17 - in the cpp file
1456:19 - so let's put in the code here we're
1456:21 - going to put in the implementation and
1456:24 - we're going to have our constructor in
1456:26 - place but notice what happens on our
1456:29 - output stream operator the output stream
1456:32 - operator is a friend of the civil
1456:35 - engineer class so it should have access
1456:38 - to anything we have in our civil
1456:40 - engineer class but notice what is
1456:43 - happening here
1456:44 - the get full name method is not working
1456:47 - because it has been made
1456:49 - private to the upstream class which
1456:53 - happens to be
1456:54 - our engineer class and we can't really
1456:57 - access them even if we know that they
1456:59 - are really part of the interface of the
1457:02 - person class we have them as public
1457:04 - members of the person class but when the
1457:08 - engineer class did private inheritance
1457:11 - it made everything that is not private
1457:14 - to person private to itself so these
1457:17 - gators are going to be private to
1457:20 - engineer when the engineer does private
1457:23 - inheritance the member variables which
1457:25 - are public and protected all these
1457:27 - things are going to be stripped down to
1457:30 - private access level so they are going
1457:32 - to be private to engineer and any kind
1457:35 - of inheritance you're going to do is not
1457:37 - going to change that they are going to
1457:39 - be inherited as private to the engineer
1457:42 - class that's why we can't even call them
1457:45 - from a function which is a friend of our
1457:48 - civil engineer class and we know that if
1457:51 - you mark something as a friend it's
1457:53 - really going to have access to anything
1457:55 - you have including private members but
1457:58 - we can't call any of the members from
1458:01 - the engineer class because everything is
1458:03 - now private to the engineer class this
1458:06 - is what i want you to see if you do
1458:08 - private inheritance this is going to
1458:10 - really strip down
1458:11 - anything from the upstream class and
1458:14 - make that private to the class that is
1458:16 - doing private inheritance this is the
1458:18 - message here and again if you go in any
1458:22 - method of the civil engineer class and
1458:24 - try to do any kind of access for example
1458:27 - calling the get full name
1458:29 - method is not going to board well we're
1458:32 - going to see that this is inaccessible
1458:34 - here if we try to access m full name
1458:37 - for example change this to be something
1458:39 - else let's say daniel
1458:41 - gray this is not going to work if you
1458:44 - try to access mh
1458:46 - and change it to 45 for example this is
1458:48 - not going to work we already know that
1458:50 - the address is private to person so we
1458:52 - shouldn't really try to access it
1458:54 - because it is inaccessible regardless of
1458:58 - any kind of inheritance you do but the
1459:00 - members that were public from person
1459:03 - can't be accessed from any class that is
1459:06 - inheriting from person even if we know
1459:09 - that these things are public or
1459:11 - protected in the person class
1459:13 - and this is really what i want you to
1459:15 - see if we try and build our program
1459:18 - we're going to get a bunch of compiler
1459:20 - errors saying that we can't access these
1459:22 - guys
1459:23 - from our civil engineer class we are
1459:26 - going to use the gcc compiler here
1459:29 - because it is our favorite and we're
1459:31 - going to see our compiler errors here
1459:33 - okay so we're going to get a bunch of
1459:35 - errors let's go up and see all of them
1459:39 - we're going to get an error saying that
1459:41 - getfullname is inaccessible within the
1459:44 - context of the c4 engineer header class
1459:48 - at line 13 we are calling this method
1459:51 - that's not going to work we have another
1459:54 - error here saying that the getfullname
1459:57 - method is not accessible from line 13 of
1460:01 - the civil engineer header
1460:03 - okay it is really the same error but if
1460:05 - we go down we see that we get a bunch of
1460:07 - other errors we have m full name which
1460:10 - is not accessible we have m edge which
1460:13 - is not accessible we can't really do
1460:16 - these kinds of things from the civil
1460:18 - engineer class because all these are
1460:20 - going to become private to the upstream
1460:23 - class that did private inheritance so
1460:26 - let's take this out and
1460:29 - show you that even if we can't access
1460:32 - these guys they are still part of our
1460:34 - civil engineer class and we're going to
1460:36 - use a debugger to do that i am going to
1460:39 - take out these things or i can comment
1460:41 - them out and say that they are going to
1460:44 - give you compiler errors i think this is
1460:46 - going to be more descriptive so let's
1460:48 - say compiler error
1460:49 - and access to the edge is also going to
1460:52 - give you a compiler error and we're
1460:54 - going to go down and show you that we're
1460:56 - also going to have the same problem in
1460:59 - our output stream operator so if you
1461:01 - really want your output stream operator
1461:04 - to work here what you can do is put some
1461:07 - public members
1461:09 - in the engineer class and make it give
1461:12 - you access to the members that were
1461:15 - eclipsed to private access in this class
1461:18 - here for example you can return the full
1461:20 - name you see that we can access that
1461:22 - here you can return the age but you
1461:24 - still don't have access to the m address
1461:27 - member variable because this is private
1461:29 - to the person class but i really don't
1461:32 - even want to do this because doing this
1461:34 - kind of design
1461:35 - is sign of bad design in the first place
1461:39 - so if you need to do those kinds of
1461:41 - getters and forward them down to
1461:44 - inheritance classes why not change the
1461:46 - design in the first place and not to do
1461:49 - private inheritance here for example if
1461:52 - you change this inheritance to protected
1461:54 - or public these members are going to be
1461:57 - directly automatically forwarded down to
1462:00 - any inheritance class so just know that
1462:04 - you can put in public getters that are
1462:06 - going to give access to the full name
1462:09 - and age but you still want to be able to
1462:11 - access the address member
1462:14 - from the inheritance class because this
1462:17 - is the design you achieve by marking
1462:19 - something as private in the base class
1462:22 - if you want the address to be forwarded
1462:24 - down you might change the access level
1462:26 - we have here and maybe make it protected
1462:28 - or public so this is the ideas i really
1462:31 - want you to grasp i am going to comment
1462:33 - out the offending code here because i
1462:36 - want you to be able to build this
1462:38 - program and see that even if we can't
1462:41 - access this get full name and get
1462:43 - address members from inheriting classes
1462:46 - they are still part of our interface we
1462:49 - just can't have access to them because
1462:52 - of the choices we have made in upstream
1462:55 - classes so what i am going to do i am
1462:57 - going to go in my main cpp file and i am
1463:00 - going to create an engineer object
1463:03 - i will also include civil engineer here
1463:06 - let's do that and i am going to create
1463:09 - an engineer object and i am going to
1463:12 - create a civil engineer object
1463:14 - and i am going to just say done here and
1463:18 - i am going to put the break point on
1463:20 - line 12. we are going to use a debugger
1463:23 - to really see
1463:24 - that engineer objects and the civil
1463:27 - engineer objects
1463:29 - still have a person part of them we just
1463:32 - can't access the interface that was
1463:34 - eclipsed by the engineer class so we are
1463:37 - going to hit the run tab here
1463:41 - and we are going to
1463:43 - start our debugging session by clicking
1463:45 - on the green button here
1463:47 - we are going to build our program and if
1463:50 - the build is good we're going to plug
1463:52 - the binary that was generated into our
1463:55 - debugger and we are going to hit our
1463:57 - break point in a minute once we hit our
1464:00 - break point we are going to look at the
1464:02 - local variables we have in the main
1464:04 - function we're going to see them on the
1464:06 - left here if we expand we're going to
1464:09 - see that we have an engineer one object
1464:12 - and we have a civil engineer one object
1464:14 - if we look at our engineer we're going
1464:17 - to see that we have a person part of
1464:19 - this which is our base class and if we
1464:22 - look at civil engineer it's also going
1464:25 - to have a base of engineer so any civil
1464:29 - engineer is also going to be an engineer
1464:32 - but the engineer part of the civil
1464:34 - engineer also has a person part of that
1464:38 - you should really see this information
1464:40 - and the main message i want to convey
1464:42 - here is that all these objects have a
1464:45 - person part of them we just can't access
1464:48 - that part in objects of our inheritance
1464:51 - classes because of the design decisions
1464:54 - we have made let's close this off now
1464:57 - that you have seen this and again
1464:59 - we are really working on this
1465:01 - inheritance hierarchy the base class is
1465:04 - person
1465:05 - and it's going to have these member
1465:07 - variables
1465:08 - but if we do private inheritance from
1465:10 - the person class anything that is not
1465:13 - public is going to be eclipsed down to
1465:16 - private level access so any other class
1465:19 - that is going to inherit from our
1465:21 - engineer class now is not going to have
1465:24 - direct access to these members because
1465:26 - they are going to become private to this
1465:29 - class here and that's the experience we
1465:31 - have if we try to
1465:33 - use any of this methods and members we
1465:36 - get from engineer
1465:38 - this is not going to work because they
1465:40 - are now
1465:41 - private to the engineer class this is
1465:43 - the message here so the get full name
1465:46 - get age
1465:47 - methods are not going to work if we try
1465:50 - to use the contract count member which
1465:52 - comes from the engineer class that's not
1465:55 - also going to work if we look in our
1465:57 - header and try to use any of these
1465:59 - members we're going to get compiler
1466:00 - errors because all these guys are now
1466:02 - private to the engineer class this is
1466:05 - really all i wanted to share in this
1466:07 - lecture let's head over to the cpp file
1466:10 - and comment this out again because i
1466:12 - don't want to leave you with these
1466:14 - compiler errors i hope you found this
1466:16 - lecture informative and fun
1466:19 - we are going to stop here in this one in
1466:21 - the next one we're going to see that we
1466:23 - can actually resurrect some members back
1466:26 - in scope
1466:27 - if they were eclipsed by the kind of
1466:30 - inheritance we did from an upstream
1466:32 - class
1466:33 - go ahead and finish up here and meet me
1466:36 - there
1466:37 - in this lecture we're going to explore
1466:39 - how we can resurrect members back in
1466:42 - scope so what do we mean here suppose we
1466:44 - have our trusty inheritance tree here we
1466:47 - have a base class person the engineer
1466:50 - class is going to do private inheritance
1466:52 - and it's going to really be selfish and
1466:54 - say
1466:55 - i am going to take everything i can from
1466:57 - the upstream person class but i am going
1467:00 - to make everything my own and nobody
1467:04 - inherited from me will have access to
1467:06 - these guys for example m1 and m2 are
1467:10 - going to be private to the engineer
1467:12 - class
1467:13 - starting here when the engineer class
1467:16 - does private inheritance so any other
1467:19 - class for example civil engineer which
1467:21 - is inheriting from
1467:23 - the engineer class in any way won't have
1467:26 - access
1467:27 - to the m1 and m2 member variables so
1467:31 - suppose for some reason that we have
1467:34 - this kind of setup here but again we
1467:36 - want some members to be accessible to
1467:40 - other downstream classes
1467:42 - suppose for example we want the m1
1467:45 - member variable to still be accessible
1467:47 - to downstream classes while we have done
1467:50 - private inheritance c plus plus is
1467:52 - really weird in a way it is going to
1467:55 - work hard to really prevent you to do
1467:57 - thanks and that gives you a back door
1468:00 - you can go through to
1468:01 - allow the same thing you were trying to
1468:04 - avoid in the same place it is the same
1468:06 - kind of logic we have here it allows you
1468:08 - to use private inheritance to prevent
1468:11 - downstream classes to access to anything
1468:15 - you get from upstream classes but then
1468:18 - again it allows you to change that and
1468:20 - relax the access to downstream classes
1468:23 - for example we can change the access of
1468:25 - m1 and m2 make it more relaxed make it
1468:29 - public or protected if we wanted that so
1468:32 - let's take a look at some code because i
1468:35 - know that these things can really be
1468:36 - confusing okay we are going to start
1468:39 - from a person class which is going to
1468:41 - have a bunch of member variables we will
1468:43 - also have a bunch of getters that are
1468:45 - going to return all these member
1468:46 - variables and we are going to do private
1468:49 - inheritance from person in an engineer
1468:52 - class this is going to strip down access
1468:56 - to the members we get from person
1468:58 - to
1468:59 - private level access for example they
1469:02 - get full name member function the gate
1469:04 - age the gate address member functions
1469:06 - are going to be private to the
1469:09 - engineer class now but for some reason
1469:12 - you might want to resurrect them
1469:15 - to a more relaxed access level and you
1469:18 - do that using the using keyword so the
1469:21 - first thing you need to do is to choose
1469:23 - the section in which you're going to be
1469:24 - putting these using statements for
1469:27 - example because we put them in a
1469:29 - protected section
1469:31 - all these guys are going to be
1469:32 - resurrected with a nexus level of
1469:35 - protected if we put them in a public
1469:38 - section they are going to be resurrected
1469:40 - with a public access level and they are
1469:43 - going to be accessible from inheriting
1469:46 - classes one thing you should know is
1469:48 - that you can't resurrect
1469:51 - something that is already private to an
1469:54 - upstream class for example we know that
1469:56 - our m address member variable was
1469:58 - private to the person class so we can't
1470:01 - really resurrect that in an inheritance
1470:04 - class if we do that we're going to get a
1470:06 - compiler error and hopefully this is
1470:08 - going to drive the point home that
1470:09 - private inheritance is really really
1470:12 - serious and that it's going to strip
1470:14 - down access to private level access in
1470:17 - an inheritance class and any downstream
1470:20 - inheritance class will never be able to
1470:23 - resurrect those member variables to a
1470:26 - more relaxed access level so because
1470:29 - everything here is inherited as private
1470:32 - by default any downstream inheriting
1470:35 - class will never be able to resurrect
1470:37 - these guys for example to public or
1470:39 - protected scope this is the message here
1470:42 - and you can use this kind of design if
1470:44 - you want that but personally i don't
1470:46 - like to do this because it's going to
1470:48 - make your code much more
1470:50 - hard to read and understand if you want
1470:52 - these guys to be public or protected why
1470:55 - not make them public or protected in the
1470:58 - first place and really not use private
1471:00 - inheritance that's going to be much more
1471:03 - direct to see and understand and your
1471:05 - code is going to be easier to work with
1471:07 - for you in the future or for some other
1471:10 - developers that will get to work on your
1471:12 - code in the future so this is the
1471:14 - message here you can use this feature to
1471:16 - resurrect members back
1471:18 - to a relaxed access level and now that
1471:22 - you have an idea about this we're going
1471:24 - to head over to visual studio code and
1471:27 - play with us a little more
1471:28 - here we are in our working folder the
1471:31 - current project is resurrecting members
1471:33 - back in context we are going to
1471:36 - completely reuse the code from the last
1471:38 - lecture because it's going to give us a
1471:40 - good starting point we can copy
1471:42 - everything except for the binary here we
1471:44 - don't need that in our current project
1471:47 - we're going to put in our starter code
1471:50 - and we're going to open this little guy
1471:51 - in visual studio code so we're going to
1471:54 - have our code we're going to have our
1471:56 - main function and we're going to have
1471:58 - all these objects created here i'm
1472:00 - really not sure if we're going to need
1472:02 - this yet so let's take this out and
1472:04 - we're going to look at our personal
1472:06 - class it is going to have our members
1472:08 - here and we are going to have a bunch of
1472:11 - getters which are going to be returning
1472:13 - these member variables and we have a
1472:15 - constructor here which is really going
1472:16 - to build a person object nothing
1472:19 - complicated here we have an engineer
1472:21 - class which is going to privately
1472:23 - inherit from person and we know that
1472:26 - this is going to eclipse everything that
1472:29 - is not private in the person class to
1472:32 - private level access so everything is
1472:35 - going to be private to the engineer
1472:37 - class now but sometimes we don't want to
1472:40 - do that for example if we go down in our
1472:43 - civil engineer class
1472:45 - we're going to see that
1472:46 - the get full name and the getage methods
1472:49 - are going to be private to the app
1472:51 - stream engineer class and that's going
1472:53 - to break the code for our output stream
1472:56 - operator and it's not going to work
1472:58 - because we want to have access to get
1473:00 - full name and get age and that's also
1473:03 - going to kill access we had on the get
1473:05 - address method which would give us
1473:08 - access to the address member that we
1473:11 - have in our person class let's make sure
1473:14 - we are looking at person
1473:16 - i am confused here we have a lot of
1473:18 - pieces of code here
1473:20 - where is the person header
1473:23 - it is down here so we have the get
1473:25 - address method which is going to return
1473:27 - the address we want to have access to
1473:29 - that in our civil engineer class to be
1473:32 - able to print all this information if we
1473:35 - also want to print the contract count we
1473:37 - can go in our engineer class and put in
1473:40 - a method which is going to return that
1473:43 - so we can say end
1473:45 - and say get contract count and this is
1473:47 - going to be a const member function
1473:49 - because it's not going to be modifying
1473:51 - our object we're just going to return a
1473:53 - value we're going to return the contract
1473:55 - count and we can go in our civil
1473:58 - engineer implementation file and change
1474:01 - this to say
1474:03 - operand
1474:04 - get contract account we can do that okay
1474:06 - we have this method now we want this to
1474:08 - work this is going to work because we
1474:11 - are doing public inheritance from the
1474:13 - civil engineer class but we want this to
1474:15 - work we want to get full name get age
1474:18 - and get address to work here and we can
1474:20 - use the using feature to resurrect these
1474:23 - members to an access level which will
1474:26 - allow our civil engineer class to pick
1474:29 - them up so we can go in our engineer
1474:32 - class and set up for example a public or
1474:35 - protected scope we're going to use
1474:36 - protected because we want these to only
1474:39 - be accessible from
1474:40 - inherited classes for example so we're
1474:42 - going to say protected and we're going
1474:44 - to say using this is the syntax we're
1474:46 - going to say person and we're going to
1474:48 - say get full name we're going to say
1474:50 - using person get age going to choose
1474:53 - this and we are going to say using
1474:55 - person and say get address i think we
1474:59 - have that method here the moment we do
1475:01 - this we're going to go in our civil
1475:03 - engineer class you're going to see that
1475:04 - it is going to work now because what we
1475:07 - just did is resurrect these members to
1475:11 - have protected access level in the
1475:14 - engineer class so the inheritance
1475:17 - classes are going to look at this and
1475:18 - see that they have a protected access
1475:21 - level in the engineer class and they are
1475:24 - going to be forwarded down to any
1475:26 - inheritance class we could also change
1475:28 - this to public this is also going to
1475:30 - work they are going to be inherited as
1475:32 - public and hopefully you can see that
1475:35 - any member that you resurrect it's going
1475:37 - to take the excess level of the section
1475:39 - where you resurrect it if we resurrect
1475:42 - them in a public scope they are going to
1475:45 - be resurrected with a public access
1475:47 - level if we resurrect them in a
1475:50 - protected scope they are going to be
1475:52 - resurrected with
1475:54 - protected access level and this is the
1475:56 - message here now if you happen to have a
1476:00 - bunch of overloads in an upstream class
1476:03 - for example suppose we have a bunch of
1476:06 - add
1476:07 - functions in the person class we can go
1476:10 - in and put in let's do that we can go
1476:13 - down and say
1476:15 - double or ent let's say and that's going
1476:18 - to be much simpler we can say add and
1476:20 - say end
1476:22 - a and say ent b and say ent c we're
1476:25 - going to have
1476:26 - three things that we are adding this is
1476:28 - going to be a const member function it's
1476:31 - not going to be modifying our members in
1476:33 - any way so we're going to return
1476:36 - a plus b
1476:38 - plus c this is something we can return
1476:40 - from a member function here
1476:42 - and we're going to do an overload of the
1476:45 - add member
1476:47 - to do
1476:49 - the addition of two parameters so we're
1476:51 - going to only have a and b and i think
1476:54 - we can use a and b in the first
1476:57 - overload here that's going to be much
1476:59 - easier to follow so we have one that
1477:01 - adds two parameters
1477:04 - and we have another one which is going
1477:05 - to add three parameters if we
1477:08 - privately inherit from person these guys
1477:11 - are going to be stripped down to private
1477:14 - level access in the engineer class and
1477:17 - they want to be accessible from in any
1477:19 - other downstream class so for example if
1477:22 - we head over in our civil engineer class
1477:25 - and try to say add
1477:27 - 10 to two for example we're going to get
1477:30 - a compiler error because we don't have
1477:32 - access to this but we can also resurrect
1477:35 - these ad members in our engineer class
1477:38 - so let's go there and we're going to set
1477:40 - up a public
1477:41 - section in this class here and we're
1477:44 - going to say using person add this is
1477:47 - going to resurrect all the overloads
1477:50 - that we have in our upstream class and
1477:53 - this is going to be the case because we
1477:55 - resurrect only based on the name of the
1477:57 - function
1477:58 - and
1477:59 - the same name for a member function can
1478:02 - be shared by many overloads so if we do
1478:05 - this kind of resurrecting we are doing
1478:08 - for the add
1478:10 - member function from person we are going
1478:12 - to get all the overloads if we go in
1478:14 - civil engineer we will be able to use
1478:17 - the member function taking two
1478:19 - parameters we will also be able to use
1478:21 - the one that takes three parameters they
1478:24 - are all going to be resurrected here
1478:26 - this is the message i want to convey if
1478:28 - we do this you're going to see that this
1478:30 - is going to work and our code is going
1478:32 - to just world fine let's build and see
1478:35 - if the build is good actually we're
1478:37 - going to pass this through gcc the world
1478:40 - is going to be good so everything is
1478:42 - working just fine and the message i
1478:45 - really wanted to convey is that it is
1478:47 - possible to resurrect members
1478:49 - in a more resurrected access level if
1478:53 - you are inheriting using a really
1478:56 - constrained base class access specifier
1479:00 - for example we are inheriting using a
1479:02 - private
1479:03 - access specifier this is going to
1479:05 - eclipse everything we get from the
1479:07 - upstream class to private level but if
1479:10 - you think that's too much and you have a
1479:12 - few members that you would like to put
1479:15 - in a more relaxed access level you can
1479:18 - use this resurrecting feature and it is
1479:20 - going to make things accessible in
1479:23 - downstream classes if that's what you
1479:25 - want in your program and again i hope
1479:27 - this drives the point to home that
1479:29 - ziploc plus is going to sometimes work
1479:31 - really hard to prevent you from doing
1479:34 - one thing and then again give you a back
1479:36 - door you can go through to do that same
1479:39 - thing this is the same thing here we are
1479:41 - doing private inheritance but we aren't
1479:44 - allowed to
1479:46 - kill
1479:47 - or
1479:48 - relax the effects of private inheritance
1479:50 - by bringing things in a more relaxed
1479:54 - access level and you can use this if it
1479:56 - makes sense for your code again i don't
1479:59 - like this personally because it's going
1480:00 - to make code confusing if other
1480:02 - developers see that you are doing
1480:04 - private inheritance they are going to
1480:06 - expect everything from the app stream
1480:08 - class to be private
1480:10 - to the class that is doing private
1480:11 - inheritance and if they see that they
1480:14 - can use this thanks that should be
1480:16 - private by default and downstream
1480:18 - classes this is really going to confuse
1480:20 - them and it is going to cost them more
1480:23 - minutes to look at your code to really
1480:25 - understand what is going on so if you
1480:27 - really want this dance to be accessible
1480:29 - in downstream classes why not do public
1480:33 - or protected inheritance in the first
1480:35 - place this is my argument here but it is
1480:38 - going to be your choice my job here is
1480:40 - to make you aware of the possibilities
1480:42 - that you have in the ziploc plus
1480:45 - programming language okay the last thing
1480:47 - i want you to see in this lecture is
1480:49 - that if there is something that was
1480:51 - already private in an app stream class
1480:54 - you can't resurrect that if you try to
1480:56 - do that you're going to get a compiler
1480:58 - error this is also going to drive the
1481:00 - point home that you can also resurrect
1481:02 - member variables so far what we have
1481:04 - only resurrected was all member
1481:07 - functions and we can also resurrect
1481:09 - member variables so we're going to try
1481:11 - and resurrect the m address member in
1481:15 - the engineer class and let's see how
1481:17 - this works out so let's go in our
1481:20 - engineer class we can go in our
1481:22 - protected section we can do this really
1481:25 - in any kind of section we're going to
1481:27 - say using and we're going to say person
1481:29 - and we're going to say m address you see
1481:32 - that this is not going to be
1481:34 - available in autocomplete this is going
1481:36 - to be a sign that this is going to give
1481:38 - us a compiler error and if we're trying
1481:40 - to do that we're going to see that we're
1481:41 - going to get a compiler error the
1481:43 - message here is that if something is
1481:46 - already private in a nap stream class
1481:50 - you can't resurrect it it is it claps
1481:53 - down
1481:54 - forever
1481:55 - and hopefully this drives the point home
1481:57 - again that private inheritance is really
1481:59 - serious for example in our civil
1482:02 - engineer class we can't resurrect
1482:06 - something that was already eclipsed to
1482:08 - private level access by the engineer
1482:11 - class let's go in our personal class and
1482:14 - see if we have any other member function
1482:16 - we can
1482:17 - play with we're going to put in a member
1482:19 - function that says do something we're
1482:21 - going to say void
1482:23 - do something and it's going to be
1482:25 - constant it's just going to say hello we
1482:27 - can do something like this we are
1482:29 - learning
1482:30 - and this method is going to be eclipsed
1482:32 - down to private level access because we
1482:36 - are doing private inheritance from
1482:37 - person let's go back in our engineer and
1482:40 - comment this out because it is going to
1482:42 - give you a compiler error if you build
1482:44 - you're going to get
1482:45 - a weird compiler error i think i should
1482:48 - really show you this because we are
1482:49 - learning here so we're going to try and
1482:51 - build our program anyway we're going to
1482:53 - pass this through gcc
1482:56 - and we're going to see the kind of
1482:57 - compiler error we get
1482:59 - and we are going to see that there's no
1483:02 - member std this is a problem we just
1483:05 - introduced in our class here i think to
1483:09 - solve this problem we can just put our
1483:12 - definition in the cpp file we can do
1483:15 - that we're going to grab this and we're
1483:18 - going to put the definition in
1483:20 - person.cpp because we have io stream
1483:23 - included in there this is going to make
1483:25 - our code work much better let's do this
1483:28 - we're going to say void and say person
1483:30 - and we're going to say sddc out hello
1483:33 - this is going to fix our problem here
1483:36 - and the only problem we will have will
1483:38 - be in engineer
1483:40 - where we are trying to access things
1483:42 - that are now private to the base class
1483:46 - why do we have this weekly line here
1483:48 - let's take out this
1483:50 - and try to build really make sure that
1483:53 - this problem is not existent
1483:55 - and it was a visual studio code messing
1483:58 - with us so we're going to bring this in
1484:02 - and the world and we're going to see the
1484:03 - kind of compiler error we get here
1484:06 - this is what i am trying to make you see
1484:09 - you see the bullet is finished with
1484:10 - errors if we go back we're going to see
1484:13 - that string person m address is private
1484:16 - within this context we can't really
1484:19 - resurrect it if we do this we're going
1484:20 - to get this compiler error here this is
1484:23 - the message you shouldn't really try to
1484:26 - resurrect
1484:27 - something that is already private to an
1484:30 - upstream class and that's what we are
1484:32 - doing here we are trying to resurrect a
1484:34 - member which is private to person and
1484:37 - this is not allowed in c plus plus if we
1484:39 - do that we're going to get a compiler
1484:41 - error
1484:42 - okay so but what i want you to see here
1484:44 - is that a public member which was in the
1484:48 - base class was also eclipsed down to
1484:51 - private level access in engineer so if
1484:54 - we try and resurrect
1484:57 - the do something method in our civil
1485:00 - engineer class we're going to get a
1485:01 - compiler error so let's try and do that
1485:03 - we're going to put a public section why
1485:06 - not
1485:08 - and we're going to go down and say using
1485:10 - person
1485:13 - and it say do something we have this
1485:15 - method here but if we do this we're
1485:17 - going to get a compiler error because
1485:20 - this method is now private to the
1485:22 - engineer class and why is it private to
1485:25 - engineer well engineer is doing private
1485:28 - inheritance that's going to accept
1485:30 - everything to private level access by
1485:33 - default so this member is private to
1485:36 - engineer we are inheriting from engineer
1485:39 - in civil engineer
1485:41 - and this is going to be already private
1485:43 - to engineer and we can't resurrect this
1485:46 - back so if you eclipse something using
1485:49 - private inheritance you want to be able
1485:51 - to resurrect that to a more relaxed
1485:54 - access level in downstream classes this
1485:58 - is the message i am trying to convey
1485:59 - here so this is also going to give us a
1486:01 - compiler error
1486:03 - and if we try to build our program we're
1486:05 - going to see that let's pass this
1486:07 - through gcc we are going to see that's
1486:09 - the world finished with errors and if we
1486:12 - go back we are going to get some kind of
1486:14 - error that says that do something is
1486:17 - private to some class it is inaccessible
1486:20 - within this context this is the message
1486:22 - we get from this particular compiler we
1486:25 - are using but the bottom line is that
1486:28 - you shouldn't really try to resurrect
1486:30 - something that is already private to an
1486:33 - upstream class and this is what we are
1486:34 - doing here you shouldn't really do that
1486:37 - let's comment this out and get a code to
1486:39 - compile again
1486:41 - so the web is good and we are all fine
1486:43 - here this is really all i had to share
1486:45 - in this lecture i hope you found it
1486:47 - interesting we are going to stop here in
1486:50 - this one the next one we're going to
1486:51 - explore how constructors work with
1486:55 - inheritance
1486:56 - go ahead and finish up here and meet me
1486:58 - there
1487:00 - in this lecture we're going to zoom in
1487:01 - at how derived objects are built and
1487:05 - we're going to zoom in on the
1487:06 - constructors that we have been ignoring
1487:09 - on purpose so far so here we have the
1487:12 - inheritance hierarchy we will be using
1487:14 - it is what we are familiar with at this
1487:17 - point we have a personal class which is
1487:19 - going to be our base class we have an
1487:20 - engineer class which is now going to be
1487:23 - doing public inheritance because we have
1487:25 - seen enough of private inheritance our
1487:29 - engineer class is now going to be nice
1487:31 - and say
1487:32 - i am inheriting from person but i also
1487:35 - want my downstream classes to have
1487:38 - access to the cool stuff i am getting
1487:40 - from person this is how
1487:42 - our engineer class is behaving now we
1487:45 - are also going to have a civil engineer
1487:47 - class which is going to publicly inherit
1487:49 - from engineer but what we want to focus
1487:52 - on here is what we get from base classes
1487:55 - so the engineer class is going to have a
1487:57 - person part of that but it is also going
1488:00 - to build on top of that and add an
1488:03 - engineer level and customize what kind
1488:06 - of person it is so if we inherit from
1488:09 - engineer and that weld our civil
1488:12 - engineer class the first link to be
1488:14 - built by c plus plus is the person part
1488:16 - of this it is going to build an engineer
1488:19 - level of this and then we are going to
1488:21 - add a civil engineer level
1488:24 - to add the customizations that the civil
1488:27 - engineer class is adding
1488:30 - and a c plus plus is going to do this
1488:32 - using constructors by default we are
1488:35 - going to be using default constructors
1488:37 - if we don't specify a way for the
1488:40 - basical structure to be called c plus
1488:42 - plus is going to call the default
1488:44 - constructor to build your base objects
1488:47 - so if we set up something like this and
1488:50 - try to run a program we're going to get
1488:52 - output like this we're going to see that
1488:54 - the person default constructor is going
1488:56 - to be called first and notice that we
1488:58 - are building a civil engineer object so
1489:01 - the default constructor from the most
1489:04 - base class is going to be called then
1489:06 - we're going to be building an engineer
1489:08 - layer on top of the person stuff that we
1489:11 - get then we're going to build a civil
1489:13 - engineer layer on top of the engineer
1489:17 - stuff that we have already got and the
1489:19 - compiler is going to do this using the
1489:21 - default constructors by default so we're
1489:23 - going to call the default constructor
1489:25 - for person first we're going to call the
1489:27 - default constructor for engineer and
1489:29 - then we're going to call the default
1489:31 - constructor for civil engineer to
1489:33 - complete the construction of our object
1489:36 - the object will be complete at this
1489:38 - point and we will be able to use it
1489:40 - later on in our program here and
1489:43 - hopefully this is going to drive the
1489:45 - point home
1489:46 - that you should really really always
1489:49 - provide to the photoconstructors for
1489:51 - your classes because the compiler may
1489:54 - call these default constructors in
1489:56 - unexpected ways especially if your class
1490:00 - is part of an inheritance hierarchy for
1490:03 - example if somebody tries to build the
1490:05 - civil engineer object and you don't have
1490:08 - a default constructor for a person the
1490:11 - compiler is going to try and code that
1490:13 - and it's not going to find that and it
1490:14 - is going to throw a compiler error as we
1490:17 - are about to see in a minute okay so the
1490:20 - message really in this lecture is that
1490:22 - the most base part of your class is
1490:24 - going to be bolt so for example for our
1490:27 - civil engineer class we're going to
1490:28 - build the prison port first then we're
1490:30 - going to build the engineer park and
1490:33 - then we're going to build the civil
1490:34 - engineer part of that and then we're
1490:36 - going to finish the construction of our
1490:39 - object this is the message here now that
1490:42 - you notice we're going to head over to
1490:43 - visual studio code and play with this a
1490:45 - little more
1490:46 - here we are in our working folder the
1490:49 - current project is default argument
1490:52 - constructor with inheritance we are
1490:55 - going to reuse the code from the last
1490:56 - lecture because that's going to give us
1490:58 - the classes that we need to play
1491:01 - with what we want to do in this lecture
1491:03 - and that's playing with default
1491:04 - constructors let's put in our starter
1491:07 - code and we're going to open this little
1491:09 - guy in visual studio code let's do this
1491:12 - so we're going to have our classes we're
1491:13 - going to have the main function which we
1491:16 - can play with
1491:17 - and we are going to look at the person
1491:20 - class and make sure we have a default
1491:23 - constructor we are not going to default
1491:25 - it this time because we want to have a
1491:28 - body we can put our output statements in
1491:32 - so in this case we're going to go in the
1491:34 - cpp file and put in a default
1491:36 - constructor we're going to say person
1491:38 - and person and person here and this is
1491:41 - going to be our constructor we're going
1491:43 - to say stdcl defaults constructor for
1491:47 - person called
1491:48 - okay so the personal class is done we
1491:51 - have a default constructor that works as
1491:53 - we want and we're going to go to our
1491:56 - engineer class and we're going to change
1491:58 - it to do public inheritance i think this
1492:01 - is going to be much easier to deal with
1492:03 - now
1492:04 - and we're going to remove all these
1492:06 - resurrection we were doing here from the
1492:09 - last lecture because this is no longer
1492:11 - going to be needed
1492:14 - and what we really want is to look at
1492:16 - our default constructor which is really
1492:18 - in here already let's look at the
1492:21 - implementation all we really need to do
1492:23 - is put in sddc out and say default
1492:26 - constructor
1492:27 - for
1492:28 - engineer
1492:30 - called
1492:31 - and we're going to hop over to the civil
1492:33 - engineer class and see if we have a
1492:36 - default constructor and we do have it
1492:38 - and we're going to go to the cpp file
1492:41 - and say sddcl
1492:44 - default constructor called
1492:46 - for civil engineer
1492:49 - so this is going to basically do what we
1492:52 - want and what we really want to see
1492:54 - is how or the order in which our
1492:57 - constructors are going to be called if
1492:59 - we build a civil engineer object as we
1493:02 - have seen here the person part is going
1493:04 - to be built first so this is going to
1493:06 - call the constructor from person and
1493:08 - because we are not doing any kind of
1493:11 - customization on which constructor is
1493:13 - going to be called the compiler is going
1493:15 - to call the default constructor by
1493:17 - default so we're going to build the
1493:19 - person port first and we're going to see
1493:21 - the default constructor for a person
1493:22 - called after that we're going to build
1493:25 - the engineer part of us
1493:27 - and this is going to call the default
1493:29 - constructor for engineer and after that
1493:32 - we're going to weld the civil engineer
1493:34 - part of us and that's going to call the
1493:36 - civil engineer default constructor this
1493:39 - is what we want to see
1493:41 - if we build a civil engineer object so
1493:44 - we are going to hop over in the main cpp
1493:47 - file and actually build the civil
1493:49 - engineer object we're going to say civil
1493:51 - engineer and we're going to say ce1 we
1493:55 - can do that and we're going to see what
1493:57 - happens let's try and build this program
1494:00 - we're going to build that with gcc the
1494:03 - book is going to be good we could run it
1494:05 - let's bring up a powershell window we
1494:08 - can play with
1494:10 - we want to bring up a powershell window
1494:13 - we can clear
1494:14 - and run rooster
1494:16 - and you're going to see that default
1494:17 - constructor for a person called the
1494:20 - first constructor for engineer called
1494:22 - default constructor for
1494:24 - engineer called this is what we want to
1494:27 - see and hopefully this proves that the
1494:30 - compiler is really going to build a
1494:31 - civil engineer object in parts the
1494:35 - compiler is going to see that it is a
1494:36 - derived object and it's going to see all
1494:38 - the classes that this is deriving from
1494:41 - so it is going to build the most base
1494:44 - part first after that it is going to
1494:46 - build other layers until it reaches the
1494:48 - level where we are at at this civil
1494:51 - engineer objects again if we put another
1494:55 - statement out here i'm going to say
1494:57 - hello in here
1494:58 - and we're going to say sdd-endl
1495:01 - and i am doing this so that i just have
1495:04 - a point where i can put my breakpoint
1495:07 - some ides are not going to like it if
1495:09 - you put a breakpoint at an empty line so
1495:12 - that's why i am doing it here and i am
1495:14 - going to try and debug and really show
1495:16 - you that we have an engineer and a
1495:19 - person part in us i have shown you this
1495:21 - before but it doesn't really hurt to
1495:23 - repeat this
1495:24 - because debugging is really cool it's
1495:27 - going to give you more information than
1495:30 - you could ever ask for
1495:32 - we're going to hit our break point here
1495:34 - and if we look in our
1495:37 - locals we're going to have our civil
1495:39 - engineer object which is in scope now
1495:42 - and you see that we have an engineer
1495:44 - part of us and the engineer has a person
1495:47 - partner so what the compiler is really
1495:49 - going to do when it is building a civil
1495:51 - engineer object it is going to build the
1495:54 - most based part of us so it is going to
1495:57 - build a personal part after that it is
1495:59 - going to build an engineer layer on top
1496:01 - of that and then it is going to world
1496:03 - the servo engineer layer and that's what
1496:06 - we see in our output when we get to run
1496:09 - our program here if we go back we're
1496:11 - going to see that we still have our
1496:13 - binary we can still run it
1496:15 - let's bring up a terminal window we can
1496:17 - use to run this we're going to run
1496:19 - rooster and we're going to see the order
1496:21 - in which our constructors are called
1496:24 - this is really cool now that we have
1496:26 - just debugged this program you can take
1496:28 - out this hello line because it's really
1496:30 - useless and this is really what i wanted
1496:32 - you to see constructors are going to be
1496:35 - called in your inheritance hierarchy
1496:38 - starting from the most basic
1496:41 - going down to the most specialized one
1496:44 - so we're going to call the most best
1496:45 - constructor which is person and we're
1496:47 - going to keep going until we reach the
1496:49 - most specialized which is a civil
1496:52 - engineer here to build our object and
1496:56 - our object is really going to be build
1496:58 - up in layers this is the message i am
1497:00 - trying to convey here this is really all
1497:03 - i had to share in this lecture i hope
1497:05 - you found it interesting we are going to
1497:07 - stop here in this one the next one we're
1497:09 - going to see that we can actually
1497:11 - actively call a base class constructor
1497:15 - from our derived class and that's going
1497:17 - to add much more flexibility in how our
1497:21 - objects are built we are not going to
1497:23 - call the default constructor we're going
1497:25 - to be calling our own constructors and
1497:28 - have much more control on how our
1497:30 - derived objects are set up in the world
1497:34 - go ahead and finish up here and meet me
1497:36 - in the next lecture
1497:38 - in this lecture we're going to see a way
1497:40 - we can instruct for custom constructors
1497:43 - to be called
1497:44 - when our derived objects are being built
1497:47 - and set up
1497:49 - in the last lecture we saw a figure like
1497:51 - this we had an inheritance hierarchy
1497:54 - that went from person to engineer and to
1497:57 - civil engineer and we saw that if we set
1497:59 - up a civil engineer object a personal
1498:02 - part is going to be built first an
1498:04 - engineer part is going to be built on
1498:06 - top of that and the civil engineer part
1498:08 - of that is going to be
1498:09 - built and then we're going to have the
1498:11 - construction complete for our civil
1498:13 - engineer object but in the last lecture
1498:16 - we saw that this was calling the default
1498:18 - constructors and sometimes you don't
1498:21 - want this you want your objects built in
1498:24 - a specific way for example through a
1498:27 - bunch of parameters that you pass to
1498:29 - your constructor what if you want this
1498:30 - kind of setup this is what we are going
1498:32 - to learn about in this lecture and what
1498:35 - we want to end up with is something like
1498:37 - this we will be able to build a person
1498:39 - object by passing in a bunch of
1498:41 - parameters we can pass in
1498:43 - the full name we can pass in the age i
1498:45 - think this is the age we can pass in an
1498:47 - address we can build an engineer object
1498:50 - by passing in this kind of information
1498:52 - we can pass in the name the age and the
1498:54 - address but we can also pass in the
1498:56 - contract count i think this is the new
1498:59 - member variable we had in our engineer
1499:02 - class but we're not going to stop there
1499:04 - we can also build the civil engineer
1499:06 - object and we can pass in the
1499:08 - information again a civil engineer is
1499:11 - also a person so we're going to be
1499:13 - passing the information that is going to
1499:15 - initialize the person part and that
1499:16 - happens to be the name the age and the
1499:19 - address but a civil engineer is also an
1499:22 - engineer so we're going to pass
1499:24 - information that portrays to the level
1499:27 - of an engineer and that's going to be
1499:28 - the contract count and we're going to
1499:31 - pass the information to initialize the
1499:33 - civil engineer part of this object and
1499:36 - that's going to be the road strength
1499:39 - and hopefully from this you can see that
1499:41 - we need a way
1499:42 - to forward all this information to the
1499:44 - constructor where this information is
1499:47 - needed for example if we are building a
1499:49 - civil engineer object we want to forward
1499:53 - the name the age and the address to the
1499:56 - person part of us so we need to parse
1499:59 - this to our personal constructor in a
1500:01 - way we need to pass the 31 here to our
1500:06 - engineer constructor because this
1500:08 - information is going to be stored at our
1500:12 - engineer level and we need to store the
1500:14 - road strength information into the civil
1500:18 - engineer part of us because that's where
1500:20 - this member variable is declared
1500:23 - hopefully you can see the need to call
1500:24 - custom constructors which are not to
1500:27 - default these custom constructors are
1500:29 - going to allow us to forward information
1500:32 - when building our objects like we are
1500:35 - doing here in the main function so let's
1500:37 - see how we can do this some of you might
1500:40 - think uh-huh if i am building an
1500:42 - engineer object i can just grab the
1500:44 - information and pass that to my base
1500:47 - class and that is simple right so we can
1500:49 - grab all this information we can grab
1500:51 - the full name the age and the address
1500:54 - and pass that to our base class using
1500:57 - the syntaxes we have here if we are
1500:59 - doing public inheritance we're going to
1501:01 - have access to these guys anyway so we
1501:03 - can say full name equals full name mag
1501:06 - equals age and say m address equals
1501:09 - address
1501:10 - except
1501:11 - for the address is actually private to
1501:15 - the person class and we can't do
1501:18 - something like this if we try to access
1501:21 - the address member variable from the
1501:23 - base class and modify it we're going to
1501:25 - get a compiler error that says that the
1501:27 - address is actually private to the base
1501:30 - person class we can't do this so this is
1501:33 - not going to work okay some of you might
1501:35 - think uh-huh what if i try to use an
1501:38 - initializer list and do something like
1501:41 - this so i can say m full name and pass
1501:43 - in my information i can say mh and put
1501:46 - in my information i can say m address
1501:49 - and put in my information and then
1501:50 - initialize
1501:52 - the member variable that actually
1501:54 - belongs to the engineer class that we
1501:57 - are trying to build an object for here
1502:00 - and hopefully this is going to work
1502:01 - except the compiler is not also going to
1502:04 - accept this the reason is with
1502:07 - initializer lists you can't initialize a
1502:10 - member variable that doesn't belong to
1502:13 - the class that you are trying to build
1502:15 - an object for so for example here we are
1502:17 - trying to initialize m full name mh and
1502:20 - m address but these member variables
1502:23 - don't belong to the engineer class that
1502:26 - we are trying to build an object for so
1502:28 - we're going to get a compiler error here
1502:30 - this is not going to work it is not
1502:32 - engineer's job
1502:34 - to build or set up this member variables
1502:37 - so this is not going to work okay so
1502:40 - how are we supposed to forward
1502:42 - information from derived classes to base
1502:45 - classes
1502:46 - not to worry here we can still use
1502:48 - initializer lists but we are going to
1502:51 - use constructors whose job is going to
1502:54 - be to initialize these member variables
1502:56 - so if we are building an engineer object
1502:59 - and we have information that really
1503:01 - belongs to the person part of us we're
1503:04 - going to call the person constructor to
1503:05 - actually use this information to build
1503:08 - the personal part of us and we're going
1503:10 - to be calling the person constructor in
1503:13 - our initializer list here and after we
1503:16 - do that we're going to initialize a
1503:18 - member variable that actually belongs to
1503:20 - us in our initializer list this is going
1503:24 - to forward information from derived
1503:25 - classes in this case the engineer is the
1503:28 - derived class and the information is
1503:30 - going to be forwarded to the person
1503:33 - constructor which is our base class this
1503:35 - is how this is going to work
1503:37 - okay now that you know this we're going
1503:39 - to head over to visual studio code and
1503:41 - play with us a little more
1503:42 - here we are in our working folder the
1503:45 - current project is constructors with
1503:47 - inheritance we are going to grab the
1503:50 - code from the last lecture because
1503:52 - that's going to be our starting point
1503:54 - and we're going to
1503:55 - paste this
1503:57 - in our current project
1503:59 - we are going to open this little guy in
1504:02 - visual studio code by dragging and
1504:03 - dropping here and this is going to give
1504:06 - us our starter code we're going to have
1504:08 - a person class an engineer class and a
1504:11 - civil engineer class and this is
1504:13 - basically going to set up the hierarchy
1504:15 - we have here and what we want to achieve
1504:18 - is to be able to call our own custom
1504:21 - constructors
1504:22 - when we build our object in layers
1504:25 - information is going to be coming from a
1504:27 - civil engineer object
1504:29 - and we are going to initialize the
1504:31 - person part of us with relevant
1504:33 - information
1504:34 - we're going to initialize the engineer
1504:36 - part of us with relevant information and
1504:38 - we're going to initialize the civil
1504:40 - engineer part of us with relevant
1504:42 - information this is what we want to
1504:44 - achieve okay for that to work we need to
1504:47 - not call default constructors we want to
1504:50 - call actual constructors that are going
1504:52 - to grab the information and forward that
1504:55 - in our member variables for example in
1504:58 - person we have a constructor which is
1505:00 - going to take three pieces of
1505:01 - information
1505:03 - and it is going to pass this information
1505:05 - into our member variables we need to
1505:08 - apply a few changes here for example our
1505:11 - third parameter is passed as a cost
1505:14 - strength member type we are going to
1505:17 - change this to be std strength view
1505:20 - because this is going to save us
1505:22 - on copies
1505:24 - let's say string view here this is going
1505:26 - to work
1505:27 - and this is going to forward information
1505:30 - in a way we want we're going to change
1505:32 - our third parameter to bhtd string view
1505:36 - let's say string view here we're going
1505:38 - to say std string view this is what we
1505:41 - have in our header we're going to be
1505:44 - having the same signature for our
1505:46 - function here
1505:48 - and what is wrong
1505:50 - we have m full name mh and we have m
1505:55 - address here let's try to build and see
1505:57 - if the error goes away sometimes visual
1505:59 - studio code is playing games on us
1506:02 - if we get a compiler error we're going
1506:03 - to try and fix that you see that it is
1506:05 - visual studio code playing with us the
1506:08 - code is just fine here
1506:10 - so
1506:10 - we have our constructor for person it is
1506:13 - going to forward information using our
1506:15 - initializer list here we're going to
1506:18 - look at our
1506:19 - engineer class if we go there we're
1506:22 - going to see that we don't have any
1506:23 - constructor which is going to grab
1506:26 - information in any meaningful way and
1506:29 - put that in our class
1506:31 - so we are going to put in a constructor
1506:34 - that looks like the one we have in our
1506:37 - person class so we can just grab this i
1506:40 - like copy and pasting because that's
1506:42 - going to save me
1506:44 - a few seconds so i am going to put my
1506:46 - constructor here only it is not going to
1506:48 - be called the person it is going to be
1506:50 - engineer and i am going to add a
1506:53 - construct count
1506:54 - member and this is going to be an
1506:56 - integer here to keep things simpler
1506:59 - and we are going to put an
1507:01 - implementation of this constructor in
1507:03 - our engineer class we can go down here
1507:06 - and put that in front of other
1507:08 - constructors let's look at the order we
1507:10 - have in our
1507:12 - header because i like to be consistent
1507:14 - the default constructor is first so
1507:17 - this constructor is going to be second
1507:19 - and we're going to say that it belongs
1507:21 - to the engineer class
1507:23 - using a scope resolution operator here
1507:26 - and we are going to put in our
1507:28 - initializer list
1507:30 - now what we want to do is to call
1507:33 - the constructor for person to initialize
1507:36 - a person part of us and then we're going
1507:38 - to grab the information from the
1507:40 - contract count and we're going to
1507:41 - forward that in our own member variable
1507:44 - the way we're going to achieve this
1507:45 - we're going to call the person
1507:47 - constructor and we're going to pass in
1507:49 - the full name we're going to pass the
1507:51 - age and we're going to pass the address
1507:54 - and then we're going to initialize our
1507:56 - own member variable which is contract
1507:59 - count i think
1508:00 - let's go to the header and look at that
1508:02 - we're going to see that our member
1508:04 - variable is contract count so we're
1508:06 - going to say contract count and we're
1508:08 - going to say contract count param we're
1508:11 - going to name this differently because
1508:13 - we don't want issues with naming here so
1508:16 - let's name our parameter here param
1508:19 - this is going to not confuse the
1508:21 - compiler and once we have this end we
1508:23 - can just put in the body which is going
1508:26 - to be empty because all the
1508:28 - initialization is now done in our
1508:30 - initializer list here
1508:32 - so if we do this we're going to see that
1508:34 - the compiler is going to be happy with
1508:37 - our thing here we're going to go down in
1508:39 - our
1508:40 - civil engineer class
1508:43 - and we're going to grab the constructor
1508:45 - we have an engineer because we're going
1508:46 - to be using this as a starting point
1508:48 - we're going to copy it and go in our
1508:51 - civil engineer class we're going to see
1508:52 - that we don't have a customer
1508:54 - constructor we're going to put this and
1508:56 - we're going to name this civil
1508:58 - engineer and we're going to add a
1509:01 - speciality member
1509:03 - that we want to initialize so we're
1509:05 - going to say
1509:06 - std string view because we want to
1509:08 - forward string data we're going to say
1509:10 - std string view here and we're going to
1509:13 - say speciality and we are going to put
1509:16 - the implementation of this
1509:18 - in our cpp file for a civil engineer
1509:22 - we're going to put this below our
1509:24 - default constructor
1509:26 - let's grab this i lost the desk somehow
1509:29 - so we're going to copy
1509:31 - and we're going to paste down here
1509:34 - we're going to say that this constructor
1509:35 - belongs to the civil engineer class i'm
1509:38 - going to use our scope resolution
1509:40 - operator and after this we're going to
1509:42 - put our initializer list in civil
1509:46 - engineer we will call our engineer
1509:48 - constructor
1509:50 - and it is going to be taking four thanks
1509:53 - we're going to pass in the full name
1509:56 - we're going to pass in the age we're
1509:57 - going to pass in the address and we're
1509:59 - going to pass in the contract account
1510:01 - which we will get from our constructor
1510:05 - from civil engineer but we will also
1510:07 - initialize our specialty member
1510:11 - variables so we're going to say m
1510:12 - speciality and we're going to pass the
1510:15 - spatiality information here
1510:18 - and this is going to initialize our then
1510:20 - we're going to put in an empty body and
1510:22 - our information is going to be properly
1510:24 - forwarded to our base classes so if we
1510:28 - build the civil engineer object proper
1510:31 - information is going to be forwarded to
1510:32 - the engineer part of us
1510:35 - and the proper information is going to
1510:37 - be forwarded to the person part of us
1510:40 - now that we have this in place we can
1510:43 - put in our htdc out statements to let us
1510:47 - know
1510:48 - which constructor was actually called to
1510:51 - build authen we're going to say that it
1510:53 - was our custom constructor that was
1510:56 - called let's say that here we're going
1510:57 - to say
1510:59 - customer constructor called for civil
1511:01 - engineer we are going to go to our
1511:04 - engineer class and also say the same
1511:07 - thing let's go to this cpp file for that
1511:11 - and we're going to put in our htdc out
1511:13 - statement and we're going to say custom
1511:15 - constructor we can copy this to be
1511:18 - consistent with what we had in our
1511:21 - constructor default constructor i should
1511:24 - say and we're going to say custom
1511:25 - constructor called for our engineer
1511:28 - class we're going to go back to person
1511:30 - and we're going to go to the
1511:32 - implementation file and we're going to
1511:34 - copy the message from our default
1511:36 - constructor and we're going to put this
1511:38 - in and say that the custom constructor
1511:41 - was called for person here so now that
1511:44 - we have these guys in we can go to our
1511:46 - main cpp file and include the classes
1511:49 - they are included here we can try to
1511:52 - create a person object just like we saw
1511:55 - in the slides and we're going to try and
1511:57 - build this program and see which
1511:59 - constructor is called to set up this
1512:01 - person object
1512:03 - this shouldn't be rocket science by now
1512:05 - we know that our custom constructor is
1512:08 - going to be called because we are
1512:10 - passing three parameters which should be
1512:13 - forwarded to our member variables
1512:15 - through this initializer last so let's
1512:18 - build with gcc and make sure this is
1512:21 - what we expect we're going to use our
1512:23 - compiler here
1512:25 - the bolt is going to be good as you see
1512:27 - here and if we bring up our powershell
1512:30 - window and run rooster we're going to
1512:32 - see that our custom constructor is
1512:34 - called let's bring up the main cpp file
1512:37 - so that we can see our thing we are
1512:40 - passing this information here and we are
1512:42 - printing our person object and we're
1512:44 - going to see that the full name is jon
1512:46 - snow the age is 27 and the address is
1512:49 - winterfell called and all this gibberish
1512:52 - we have here our constructor is really
1512:54 - being called okay so this is working we
1512:57 - can also set up an engineer object and
1512:59 - see that the information is being
1513:01 - properly propagated to the person part
1513:04 - of our engineer object because engineer
1513:08 - is inheriting from person
1513:10 - we are passing the information for the
1513:12 - full name the age the address but we are
1513:15 - also passing in the contract count which
1513:18 - should be used to initialize the
1513:20 - engineer part of us so we are going to
1513:23 - run the task to build with gcc
1513:26 - the build is going to go through
1513:28 - successfully and we can bring up our
1513:31 - powershell window and run the program
1513:33 - again
1513:34 - we're going to see that we're going to
1513:36 - branch the information for person custom
1513:38 - constructor for person called but what
1513:41 - we really are interested in here
1513:43 - is seeing that the custom constructor
1513:46 - for person is called
1513:48 - for building our engineer object and
1513:51 - then we call the engineer constructor
1513:54 - and again this falls in line with what
1513:57 - we saw in the last lecture the most
1513:59 - based constructor is called first and
1514:01 - then the must specialize constructor is
1514:05 - called last in this case we are just
1514:07 - setting up thanks in such a way that our
1514:10 - custom constructors are called and we do
1514:13 - that from our engineer class by calling
1514:17 - the base constructor explicitly
1514:21 - using the syntax that we have here in
1514:23 - our initializer list after we have the
1514:26 - base constructor called we are going to
1514:28 - initialize our own member variables and
1514:31 - that's what we see
1514:33 - and in this way the information for the
1514:35 - current class will be initialized
1514:37 - properly and this is what we see here i
1514:40 - think this is a little bit misleading
1514:42 - because we still have the information
1514:44 - from
1514:45 - the person objects that we bought
1514:47 - printed out here we can comment this out
1514:50 - and build again we're going to pass this
1514:52 - through gcc to build our program the
1514:55 - build is going to be good we can
1514:57 - clear and run rooster and we're going to
1514:59 - see that the custom constructor is
1515:01 - called for a person to set up the person
1515:04 - part of us and then another layer of
1515:07 - engineer is going to be set up in our
1515:09 - object to initialize the contract count
1515:12 - member variable part of us and we're
1515:15 - going to have the information here so if
1515:16 - we print the full name we're going to
1515:18 - get daniel gray the age is going to be
1515:20 - 41. the address is going to be the
1515:22 - gibberish we expect here and the
1515:24 - contract count is going to be passed in
1515:26 - successfully and this is really cool we
1515:29 - can also comment this out and set up a
1515:33 - civil engineer object we can do that
1515:36 - okay so let's go down and put this in
1515:38 - place we're going to create a civil
1515:40 - engineer object we can close up
1515:43 - the left side bar here to have some more
1515:45 - breathing room we're going to build a
1515:47 - civil engineer object we're going to
1515:49 - pass in full name age address contract
1515:52 - count and a speciality which i think we
1515:55 - expect from our civil engineer custom
1515:59 - constructor here
1516:00 - that's going to be an std strength
1516:02 - that's what we are passing in here i
1516:04 - should say that's going to be
1516:06 - a string view but we can pass in string
1516:09 - data just like this and the string view
1516:12 - is going to take
1516:13 - so what we're going to see here we're
1516:15 - going to see the person constructor
1516:17 - called the person custom constructor i
1516:19 - should say we're going to see the
1516:21 - engineer custom constructor called and
1516:24 - after that we're going to see
1516:26 - the civil engineer custom constructor
1516:29 - called to pass and forward all this
1516:31 - information
1516:32 - in related parts of our civil engineer
1516:36 - object let's build and see that this is
1516:39 - actually going to even compile
1516:41 - the book is going to be good we can
1516:43 - clear
1516:44 - and run rooster and we're going to see
1516:46 - that this is exactly what we expect the
1516:49 - custom constructor for person is going
1516:50 - to be called after that
1516:53 - the custom constructor for engineer is
1516:54 - going to be called and then the custom
1516:57 - constructor for a civil engineer is
1517:00 - going to be called
1517:01 - and this really falls in line with what
1517:03 - we expect if we are building a civil
1517:06 - engineer object and the civil engineer
1517:08 - class happens to be inheriting both from
1517:11 - engineer and from person we're going to
1517:15 - have the person part of us world first
1517:19 - and because of this we're going to see
1517:20 - the person constructor called but in
1517:23 - this lecture the rio focus is getting
1517:25 - our custom constructor called so the
1517:28 - person custom constructor is going to be
1517:30 - called after that we're going to call
1517:32 - the custom constructor for the engineer
1517:34 - part of us and that's going to set up
1517:37 - the engineer specific member variables
1517:40 - in our object after that we're going to
1517:42 - set up another layer of civil engineer
1517:45 - in our object and this is going to
1517:48 - initialize the member variable that
1517:50 - belongs to the civil engineer
1517:52 - part of us in our object so this is
1517:55 - really the main goal in this lecture
1517:58 - showing you that you can set up fans in
1518:00 - such a way that your custom constructors
1518:03 - are called when setting up your object
1518:06 - in layers
1518:07 - as you see here okay now that we have
1518:10 - this working i want you to see that
1518:12 - there are some bad ways to do these
1518:14 - things and some people are actually
1518:16 - going to try to set things up in that
1518:19 - way the first bad way is to try and
1518:22 - initialize our member variables in the
1518:24 - body of the class if you do things like
1518:27 - this again this is going to work because
1518:30 - full name and age are going to be
1518:32 - inherited publicly from the person class
1518:35 - so the code here is going to work but we
1518:38 - have no way to initialize the address
1518:40 - member variable because it is private to
1518:42 - the person class so if we try to access
1518:45 - that we're going to get a compiler error
1518:47 - let's try this out in code and see the
1518:49 - actual compiler error to try this out i
1518:52 - am going to comment out the good code
1518:54 - here and i am going to copy and put in
1518:57 - something that is going to be
1518:59 - problematic as we saw in the slides i am
1519:02 - going to paste in my constructor here i
1519:04 - should close my powershell window here
1519:07 - and i am going to take out my
1519:09 - initializer lust because we're not going
1519:11 - to be using that here
1519:13 - and we're going to just grab the data
1519:15 - and use that to initialize our data in
1519:19 - our member variable here so we're going
1519:21 - to grab the full name and say m full
1519:23 - name equals full name we can do that
1519:26 - we're going to say mh equals h that's
1519:29 - the information we get we're going to
1519:31 - say m address and you see that we don't
1519:34 - even have that in autocomplete so we're
1519:37 - going to pass the address we're going to
1519:38 - be stubborn and ignore these squiggly
1519:41 - lines and we're going to say m
1519:43 - speciality and we're going to grab the
1519:45 - speciality and pass that in but you see
1519:49 - that line 26 has a bunch of squiggly
1519:51 - lines
1519:52 - and the reason is the m address member
1519:55 - variable is invisible and not
1519:57 - manipulable from a civil engineer class
1520:00 - again the reason is that the address
1520:03 - member variable is private to the person
1520:05 - class so the civil engineer class has no
1520:08 - business initializing this in the body
1520:12 - this is not going to work so if we try
1520:15 - and build this we're going to pass this
1520:18 - through gcc we are going to see that the
1520:20 - world is going to finish with errors and
1520:22 - if we go up we're going to probably see
1520:25 - the error person m address is private
1520:28 - within this context and we have no
1520:31 - business accessing that in the civil
1520:33 - engineer cpp file at line 26 this is
1520:37 - what we see here and this is the
1520:39 - offending line we shouldn't really be
1520:41 - doing this if we comment out this line
1520:44 - this is going to work but our member
1520:46 - variable is going to be left
1520:48 - with a junk value and this is really not
1520:51 - good because our address that we worked
1520:54 - so hard
1520:55 - to set up in our parameter here is just
1520:57 - going to be ignored so this is bad you
1521:00 - shouldn't really be initializing your
1521:02 - member variables like this especially if
1521:04 - you have an inheritance hierarchy in
1521:07 - your classes so we're going to comment
1521:09 - this out and say that this is really bad
1521:11 - it's going to give you compiler errors
1521:13 - and some of you are going to say okay
1521:15 - this is not working but what if we try
1521:18 - to use an initializer list directly
1521:21 - let's see if that actually works
1521:23 - we are going to
1521:25 - set up another constructor here and we
1521:27 - are going to set up the data in our
1521:30 - initializer list we're going to say
1521:33 - let's say m full
1521:34 - name and pass in the full name we can do
1521:37 - that let's try this out we're going to
1521:39 - say mh
1521:42 - and we're going to pass age we can do
1521:44 - that and we're going to grab the address
1521:48 - and we're going to pass an address here
1521:50 - and after that we're going to say m
1521:52 - spatiality and we're going to pass in
1521:54 - our spatiality information
1521:56 - what if we do something like this but
1521:59 - you're going to see that we have
1522:00 - squiggly lines here and the problem with
1522:02 - this way of doing things is that the
1522:05 - civil engineer class has no business
1522:08 - initializing thanks
1522:10 - that belong to the person class in the
1522:13 - initializer list your initializer list
1522:17 - only has the capability to initialize
1522:19 - the member variables that belong to the
1522:21 - current class and m full name mh and m
1522:25 - address don't belong to the cipher
1522:28 - engineer class that's why we're going to
1522:30 - have a compiler error if we try to set
1522:32 - up things in this way if we're trying to
1522:34 - build the program we're going to get a
1522:37 - weird compiler error
1522:39 - we're going to see that the build is
1522:41 - going to finish with errors and it is
1522:43 - going to say expected initializer before
1522:46 - m full name
1522:49 - and we need a column column here sorry
1522:51 - for this so this is not the error we
1522:54 - expect but you see that the moment we do
1522:56 - this we have a bunch of squiggly lines
1522:58 - on full name age and address and let's
1523:02 - build and see the problem we have and
1523:04 - we're going to build with errors as we
1523:06 - see here if we go up
1523:08 - we are going to see our errors civil
1523:11 - engineer does not have any field called
1523:13 - m full name we're going to see that
1523:16 - civil engineer doesn't have any field
1523:18 - called mh and civil engineer doesn't
1523:20 - have any field named m full name or m
1523:24 - address here that's the problem we have
1523:27 - no business initializing these member
1523:29 - variables that don't belong to the civil
1523:32 - engineer class in the first place so
1523:34 - this is also not going to work the best
1523:37 - bet we have already is to call the best
1523:39 - constructor and let that initialize the
1523:42 - member variables that belong to our
1523:44 - upstream class
1523:46 - in the inheritance hierarchy for example
1523:49 - in our civil engineer constructor here
1523:52 - we need to call the engineer
1523:54 - constructor to initialize the engineer
1523:57 - part of us and we're going to be
1523:59 - forwarding the information the full name
1524:01 - the age the address and the contract
1524:03 - account the engineer class is in turn
1524:06 - going to call its base constructor to
1524:08 - forward the information about the full
1524:10 - name of the agent the address and it is
1524:13 - going to initialize its own member
1524:14 - variable m construct count and the
1524:17 - information is going to be passed in
1524:19 - correctly and if we try to build our
1524:21 - class now we're going to see that
1524:23 - everything is going to work and i really
1524:25 - wanted you to be aware of this because
1524:27 - the moment you understand this you're
1524:29 - going to set up your inheritance
1524:31 - hierarchies in a way that is going to
1524:33 - make sense and you're not going to be
1524:34 - getting all these weird compiler errors
1524:37 - this is really all we set out to do in
1524:39 - this lecture showing you how you can set
1524:41 - up your own custom constructors in your
1524:45 - own inheritance hierarchy and at the
1524:48 - moment you do that you're going to get
1524:49 - your classes called in the order that
1524:52 - you expect things are going to be set up
1524:54 - in layers the base constructors are
1524:57 - going to be called in a way that you
1524:59 - expect and your objects are going to be
1525:01 - built in a way that you can print them
1525:03 - and see the information that you expect
1525:06 - set up in your object if you want you
1525:08 - can also use a debugger to see the
1525:10 - information in your thumb so we're going
1525:13 - to set up a breakpoint here and we're
1525:15 - going to bring up our
1525:17 - debugging tab we're going to hit the
1525:19 - green button to start debugging this
1525:21 - program the binary is going to be set up
1525:24 - once the vote is good the binary is
1525:26 - going to be passed in our debugger and
1525:29 - we are going to hit our breakpoint in a
1525:31 - minute let's wait for this so we have
1525:34 - hit the break point at line 20 and if we
1525:37 - expand our civil engineer object in our
1525:40 - locals we're going to see that we have
1525:42 - an engineer part of us we can expand
1525:46 - that and see that we also have a person
1525:48 - part of us
1525:49 - if we look at person we're going to see
1525:51 - that the full name is we can see john
1525:54 - travolta which is what we are passing
1525:56 - here we can also look at our age the age
1526:00 - is 51 as you see here
1526:03 - and we're going to also have information
1526:05 - about our address
1526:07 - if we expand this we're going to see
1526:09 - that the address is this gibb brush that
1526:13 - we just put in tiny dog
1526:16 - 42 stret and
1526:19 - number 89 we can see this information
1526:21 - here and you can really expand and see
1526:23 - all these things that make up our object
1526:26 - for example we can see the information
1526:28 - about the contract count which is 31 and
1526:30 - it is what we are passing when we build
1526:33 - this object here and the speciality
1526:35 - happens to be road strength as we see in
1526:40 - our locals here you can really see all
1526:42 - these things we are going to stop here
1526:44 - in this lecture in the next one we're
1526:46 - going to explore how copy constructors
1526:49 - work in our inheritance hierarchy so go
1526:53 - ahead and finish up here
1526:54 - and meet me there
1526:56 - in this lecture we want to explore how
1526:59 - copy constructors work
1527:01 - with our inheritance hierarchies and we
1527:04 - will still be using the same example we
1527:07 - have been using in this chapter we will
1527:09 - have this inheritance hierarchy and we
1527:12 - will still be using the same example we
1527:14 - have been using in this chapter the base
1527:17 - class is going to be person we're going
1527:18 - to be inheriting from that publicly to
1527:21 - create an engineer class and we will be
1527:24 - inheriting from the engineer class
1527:26 - publicly to create the civil engineer
1527:28 - class and with this we want to be able
1527:31 - to copy construct objects and the code
1527:34 - we want to be running is something like
1527:36 - this we have an engineer object we want
1527:38 - to be able to create another object from
1527:41 - this engineer object using the syntax
1527:44 - here and from what we already know this
1527:46 - is going to call our copy constructor
1527:48 - the funny thing is this is going to work
1527:50 - by default even if you don't put in your
1527:53 - copy constructor the reason is the
1527:55 - compiler is going to insert a copy
1527:57 - constructor for you and things are going
1527:59 - to be copied in a way that you expect
1528:01 - because none of our classes is using
1528:05 - dynamic memory allocation so everything
1528:08 - is just going to fall in place and it is
1528:10 - going to work but if you happen to need
1528:12 - to set up your own copy constructor
1528:14 - we're going to see how you could do that
1528:15 - in this lecture and we're going to start
1528:17 - by the base class we're going to set up
1528:19 - a copy constructor for the person class
1528:21 - and this is nothing complicated we just
1528:24 - pass our parameter by reference this is
1528:26 - going to be our source object and we
1528:28 - will be copying the data from our source
1528:31 - object to initialize the member
1528:33 - variables in the current object that we
1528:36 - are copying here again this is a copy
1528:39 - constructor which will be copy
1528:40 - constructing from the parameter that we
1528:43 - pass by reference now how do we do the
1528:46 - constructor for the engineer class which
1528:49 - happens to be inheriting from person try
1528:52 - to think about that one way to do things
1528:54 - is to set up things like this and this
1528:56 - will be just initializing the engineer
1528:59 - layer of our class but nothing is going
1529:03 - to be initializing the person part of us
1529:06 - and this is bad this is going to call
1529:07 - the default constructor to initialize
1529:10 - the person part of us and we will just
1529:12 - be left in with junk data that is
1529:15 - initializing the person object by
1529:17 - default and all the data we have in our
1529:20 - parameter engineer object is just going
1529:23 - to be lost for the person part of us so
1529:26 - we don't want to do this this is bad
1529:28 - design you shouldn't do this some of you
1529:30 - are going to say but what if we call the
1529:33 - best constructor we have seen that we
1529:35 - could do that right but remember this is
1529:38 - a copy constructor what we have on the
1529:40 - left is an object
1529:42 - and it happens to be that
1529:45 - if you set up a syntax like this with
1529:47 - the copy constructor the compiler is
1529:49 - going to set up a temporary person
1529:52 - object and a copy from that object to
1529:55 - initialize the person part of us so this
1529:57 - is going to be creating a temporary copy
1530:00 - object containing the same data we have
1530:02 - in our engineer object so to some extent
1530:06 - this is going to work but the problem we
1530:08 - still have is that we are using the m
1530:11 - address member variable directly from an
1530:14 - engineer object and from what we already
1530:16 - know this m address member variable is
1530:19 - private to the person class and we have
1530:22 - no business accessing this
1530:24 - from an engineer construct so this is
1530:26 - going to give us a compiler error but
1530:28 - you know that it is possible to set up a
1530:31 - getter in the engineer class that is
1530:34 - going to return this address and you can
1530:36 - call that together here and get this
1530:38 - thing to initialize your data this is
1530:41 - going to work but this is really weird
1530:43 - you shouldn't do this this is bad design
1530:45 - there is a better way i am going to show
1530:47 - you but before we look at that wave
1530:49 - let's try and summarize the problems we
1530:51 - have with this way of doing things this
1530:54 - is not going to be reusing the copy
1530:56 - constructor we have worked hard to set
1530:59 - up in person so this is just going to be
1531:01 - called duplication another thing is that
1531:04 - the m address member variable is private
1531:07 - to person so if we try and use it like
1531:10 - this we're going to get a compiler error
1531:12 - again it is possible to set up a getter
1531:15 - that could return that and we could use
1531:17 - that getter in this place but this is
1531:20 - bad design we are really forced to set
1531:23 - up a getter that is possibly only used
1531:26 - in this place that's bad design we don't
1531:28 - want to do something like this another
1531:30 - thing is that this is going to create a
1531:32 - temporary copy of person from which we
1531:35 - will be copying to initialize the person
1531:38 - part of us we don't want to be making
1531:40 - that copy because we hate copies in c
1531:43 - plus plus code so the best way to do
1531:46 - this is to set up your copy constructor
1531:48 - in this way we are going to say person
1531:51 - and directly passing our engineer object
1531:54 - the compiler is smart enough to see that
1531:56 - we are passing an engineer object to
1532:00 - initialize a person object and what the
1532:03 - compiler is going to do is really smart
1532:05 - suppose our engineer object is made up
1532:09 - of two layers the inner layer is going
1532:11 - to be containing the information about
1532:14 - the person part of us and the outer
1532:16 - layer is going to be containing the
1532:18 - engineer part of us okay so this is the
1532:21 - setup we have so the compiler is going
1532:23 - to see that we are passing in an
1532:25 - engineer object to initialize a person
1532:27 - object and what it is going to do is
1532:29 - really smart it is going to strip off
1532:31 - all this engineer part if i can describe
1532:35 - it like this we're going to strip off
1532:37 - all this engineer part
1532:39 - that we have in our engineer object and
1532:42 - we will be just left with the person
1532:45 - part that we passed then to initialize
1532:48 - our person object and this is really
1532:50 - smart and it is going to work so again
1532:52 - the syntax is what you see here
1532:55 - we say person we pass in our source
1532:57 - object and then we can initialize the
1533:00 - member variable that belong to the
1533:02 - engineer part of us we will be
1533:04 - initializing contract count and this is
1533:06 - going to work now that you know this
1533:08 - we're going to head over to visual
1533:09 - studio code and play with us a little
1533:11 - more here we are in our working folder
1533:14 - the current project is copy constructors
1533:16 - with inheritance we will be reusing the
1533:19 - code from the last lecture so we're
1533:22 - going to grab everything from that
1533:24 - except for the binary and we're going to
1533:26 - copy that and put that in our current
1533:30 - project let's do this and we are going
1533:32 - to open this bad boy in visual studio
1533:34 - code by dragging and dropping here and
1533:37 - we will have our starting point we will
1533:40 - have our person class the engineer class
1533:42 - and the civil engineer class and we will
1533:46 - just be doing public inheritance to make
1533:49 - things easier here so engineer is going
1533:51 - to publicly inherit from person and
1533:54 - civil engineer is going to publicly
1533:56 - inherit from engineer and this is
1533:58 - everything we had from the last lecture
1534:00 - nothing special but what we want is to
1534:03 - set up copy constructors in such a way
1534:06 - that we will be able to build objects
1534:09 - from others for example if we leave in
1534:12 - our engineer object i think this is what
1534:14 - we used in the slides we're going to
1534:16 - have our engineer 1 object
1534:19 - we want to be able to create a another
1534:23 - engineer let's say engineer two and
1534:25 - above that from engineer one the thing
1534:28 - that might be puzzling to some of you is
1534:31 - that this is going to work out of the
1534:32 - box even if we didn't really put in a
1534:35 - copy constructor but the thing is the
1534:37 - compiler is going to insert a copy
1534:40 - constructor for you but that constructor
1534:42 - is going to be memberwise
1534:45 - copy so it is basically going to be
1534:47 - copying thanks memberwise it is going to
1534:50 - take the contract count from engineer
1534:52 - one and copy that into engineer two and
1534:55 - we are basically going to have the same
1534:57 - data from
1534:58 - engineer one in engineer two let's try
1535:01 - and print engineer two can do that we're
1535:03 - going to say and two and we're going to
1535:06 - put this out and we are going to run the
1535:09 - task to build with gcc that's what we
1535:12 - want here and you're going to see that
1535:14 - it is going to work out of the box if we
1535:16 - bring up a powershell window and run
1535:19 - rooster we're going to see that we have
1535:21 - the data in here we have engineer full
1535:23 - name daniel gray that's the data we have
1535:26 - in engineer one but notice that we are
1535:28 - printing engineer two here the age is
1535:31 - going to be 41 and the address is going
1535:33 - to be exactly what we had in engineer
1535:35 - one and you're going to see that the
1535:37 - constructors are going to be called to
1535:39 - set up engineer 2 and the custom
1535:42 - constructor for a person is going to be
1535:44 - called the custom constructor for
1535:46 - engineer is going to be called and this
1535:47 - is exactly
1535:49 - what we expect here but what if we want
1535:52 - to set up our own copy constructor and
1535:54 - the need to do that might arise
1535:57 - if we happen to be doing some dynamic
1535:59 - memory allocation in our classes suppose
1536:02 - maybe person class has some dynamic
1536:05 - memory allocation it has some pointer
1536:07 - member variable and in the personal
1536:09 - custom constructor we are doing some
1536:12 - dynamic memory allocation to initialize
1536:14 - that pointer we may be doing the same
1536:16 - thing at the engineer level or the civil
1536:19 - engineer level and that will force you
1536:21 - to set up your own copy constructor and
1536:23 - we're going to see how you could do that
1536:25 - in your classes we are going to start
1536:28 - with the person class we're going to go
1536:29 - on top and set up a copy constructor in
1536:32 - front of our destructor here we're going
1536:35 - to say person and we're going to say
1536:37 - const person reference source
1536:40 - this is the syntax you use to set up
1536:42 - your copy constructor you already know
1536:44 - this from a previous chapter and we're
1536:46 - going to put in the implementation for
1536:48 - this we're going to go in the cpp file
1536:51 - before the destructor or we should go
1536:54 - after
1536:55 - our custom constructor it doesn't really
1536:58 - matter where you put this and we're
1537:00 - going to put in our scope resolution
1537:02 - operator let's do person here and we
1537:05 - will just be copying the data from the
1537:07 - source person so we're going to put in
1537:09 - our initializer list and we're going to
1537:12 - say m full name we're going to grab the
1537:14 - name from the source person we're going
1537:16 - to say source m full name we're going to
1537:18 - initialize the age we're going to say mh
1537:21 - and we're going to grab the age from the
1537:23 - source person so mh here
1537:26 - and we can go to the next line so that
1537:28 - we see the entire thing here and say m
1537:31 - address and we're going to say source
1537:34 - and say m address this is going to set
1537:36 - up our constructor and down below we can
1537:39 - put in our body this is going to work
1537:41 - but this is everything we have seen so
1537:43 - far this is nothing new the syntax to
1537:46 - set up your copy constructor you just
1537:47 - pass it by const reference if you don't
1537:50 - pass by reference here you're going to
1537:52 - get an endless chain of copy constructor
1537:55 - calls
1537:56 - if this is confusing to you please go
1537:58 - back to the chapter on classes you're
1538:00 - going to see everything about this and
1538:03 - this is really all we need to do here to
1538:05 - have a copy constructor for a person now
1538:08 - let's do things at the engineer level
1538:10 - we're going to go to our engineer class
1538:13 - and we need to set up a copy constructor
1538:15 - the syntax is going to be the same we're
1538:16 - going to say engineer and we will be
1538:19 - constructing from a cost engineer object
1538:22 - we pass as a parameter here so we're
1538:24 - going to say cost engineer by reference
1538:27 - and say source and the problem is going
1538:29 - to be how we implement this thing we're
1538:32 - going to copy this and go in our
1538:34 - engineer cpp file we're going to put our
1538:37 - copy constructor after our customer
1538:40 - constructor and we're going to put in
1538:42 - our scope resolution operator we're
1538:44 - going to say engineer and we're going to
1538:46 - put in our body let's go below and put
1538:48 - that in if we do things like this this
1538:50 - is just going to initialize our engineer
1538:53 - with junk data we don't want that but
1538:55 - some of you might say uh-huh i don't
1538:58 - know how to call my base constructor but
1539:01 - at least i can initialize my contract
1539:04 - count okay let's go back and see if we
1539:07 - have this member variable here yes it is
1539:09 - called contract count we can say
1539:12 - contract count here and we are going to
1539:14 - initialize this with source contract
1539:17 - count this is going to work but this is
1539:19 - going to call the default constructor of
1539:21 - person to initialize the person part of
1539:24 - us and let's go back in our main cpp
1539:27 - file and see what we are using to try
1539:30 - things out we are building an engineer
1539:32 - object from another let's try this out
1539:34 - and see if our copy constructor is
1539:37 - called here so we're going to say custom
1539:40 - copy constructor called for engineer
1539:42 - we're going to put in the message and
1539:44 - we're going to say custom copy
1539:46 - constructor and we're going to build our
1539:49 - code let's build we're going to pass
1539:51 - this through gcc to see what happens the
1539:54 - build is going to be good and let's see
1539:57 - what happens we're going to clear and
1539:58 - run rooster we are going to see that the
1540:01 - constructors are going to be called to
1540:03 - set up person one
1540:05 - but we see that the copy constructor for
1540:07 - engineer is called
1540:10 - and what i want to do to really make
1540:11 - this super clear is put a separator
1540:14 - between these two guys to really know
1540:16 - what is happening here i am going to put
1540:18 - in a bunch of dashes just like this i am
1540:20 - going to put in my new line character
1540:22 - and i am going to bolt again the bolt is
1540:24 - going to be good as you see here we can
1540:26 - clear and run rooster now we are going
1540:29 - to see that the default constructor for
1540:31 - person was called to set up the person
1540:34 - part of us in our engineer copy
1540:37 - constructor and the reason is we are not
1540:40 - doing anything to call the custom copy
1540:43 - constructor from person
1540:46 - and let's go back in person and make
1540:48 - sure we are printing proper information
1540:50 - to really see this
1540:52 - when we get to do this right we are not
1540:54 - putting in any message here so we should
1540:57 - do that we are going to say custom
1540:59 - constructor or custom copy constructor
1541:02 - called for person but this is not called
1541:05 - you see that we are calling the default
1541:07 - constructor and this is going to
1541:08 - initialize our person part with junk
1541:12 - data if we print engineer two here
1541:14 - you're going to see that the full name
1541:15 - is none the edge is zero and the address
1541:18 - is none so we are basically getting the
1541:21 - default data we have in our person
1541:24 - object let's go back and really show you
1541:25 - that the
1541:27 - default full name is going to be none
1541:29 - the default address is going to be none
1541:31 - of the edge is going to be 0 by default
1541:33 - and this is what we get because in our
1541:36 - copy constructor we're not doing
1541:38 - anything to get our customer constructor
1541:42 - in person to be called okay so this is
1541:44 - not going to work this is bad we don't
1541:46 - want to do something like this but let's
1541:49 - comment this out and show you another
1541:51 - way we might try to do things and we are
1541:53 - going to copy our copy constructor let's
1541:56 - go down and do this we're going to put
1541:58 - in another copy of this but we don't
1542:00 - want to just initialize our contract
1542:03 - count member variable
1542:04 - instead we want to do something else
1542:07 - we're going to put a comma here and
1542:09 - we're going to say person some of you
1542:11 - might be thinking what if we call the
1542:13 - base constructor directly we can do
1542:16 - something like this we can say person
1542:17 - and we can say source m full name we can
1542:20 - do that we can say source mh and some of
1542:24 - you are going to say source m address
1542:27 - let's do that source m address and we're
1542:29 - going to build the person object and use
1542:32 - that to initialize the person part of us
1542:35 - we are basically going to be calling the
1542:37 - other person constructor that we have
1542:40 - which takes three parameters this
1542:42 - constructor here this is what we are
1542:44 - trying to call
1542:46 - in our copy constructor but as we saw in
1542:49 - the slides this is going to have a bunch
1542:51 - of problems this is going to be creating
1542:53 - a temporary person object that we are
1542:55 - going to be copying from to set up the
1542:57 - person part of us but another problem we
1543:00 - have which is actually going to cause a
1543:01 - compiler error is that we don't have
1543:03 - access to the m address member variable
1543:06 - from an engineer constructor and this is
1543:08 - going to give us a compiler error let's
1543:10 - actually try and compile this program to
1543:12 - really show you this we are learning we
1543:14 - should really see
1543:15 - as many compiler errors as we can so the
1543:19 - world is finished with errors and if we
1543:21 - go up we're going to see that our error
1543:24 - is the m address member variable is
1543:27 - private to the person class and we have
1543:30 - no business accessing that in the
1543:32 - engineer cpp file at line 27 in our
1543:35 - constructor here and this is going to be
1543:38 - our offending line we can't do this one
1543:41 - could go in our person class and set up
1543:44 - a public getter method which is going to
1543:46 - be inherited by engineer and we could
1543:48 - call that to return the address let's
1543:50 - actually do that to show you that you
1543:53 - can do that
1543:54 - so we are going to go in and put in a
1543:58 - public method which is going to return
1543:59 - the address we actually have that here
1544:02 - so we can call that we can say
1544:04 - source get address this is going to work
1544:06 - this is going to set up our thumb
1544:09 - let's try to build because i think a
1544:11 - visual studio code is messing with us
1544:13 - here okay you see the both is good it is
1544:15 - visual studio code which wasn't
1544:18 - understanding our code here and if we
1544:20 - run our program we're going to see that
1544:22 - things are going to work exactly as we
1544:24 - expect let's actually
1544:26 - run the program here we're going to
1544:27 - clear and run rooster we're going to see
1544:30 - that now the information is being
1544:32 - forwarded properly but we are setting up
1544:34 - a temporary person copy which we are
1544:37 - copying from
1544:39 - to then forward the data to the person
1544:42 - part of us this is not good design and
1544:45 - what we really want is the setup that is
1544:47 - going to allow us to call the copy
1544:50 - constructor that we worked hard to set
1544:53 - up in our base class here let's go back
1544:55 - to person and see that if we go up we're
1544:57 - going to see that we have a copy
1544:59 - constructor we really worked hard to set
1545:01 - up we wanted to reuse this in our
1545:04 - engineer class and that's what we're
1545:06 - going to see here so this is working but
1545:09 - it is not optimal
1545:11 - and we should really try to reuse our
1545:14 - code as much as we can so what we're
1545:16 - going to do is set up a mechanism that
1545:19 - is going to reuse the copy constructor
1545:21 - we have in person and all we need to do
1545:24 - to get that to work we can say person
1545:26 - and then call the copy constructor of
1545:29 - person by directly passing in our source
1545:32 - object notice that we don't need to set
1545:35 - up a temporary person object we will
1545:37 - directly be copying from our engineer
1545:40 - object but this is going to do the
1545:42 - slicing we saw in the slides again if we
1545:45 - have two layers on our object the inner
1545:48 - layer is going to be the person part of
1545:50 - us and the outer green layer is going to
1545:54 - be
1545:55 - the engineer part of us
1545:57 - what the compiler is going to do the
1545:59 - compiler is going to see that we are
1546:01 - actually passing again
1546:02 - an
1546:03 - engineer object to initialize the person
1546:07 - part of us here and it is going to say
1546:08 - that we just need the red part we don't
1546:11 - need the green part here the compiler is
1546:13 - really smart so it is going to slice off
1546:16 - the outer engineer layer
1546:18 - and only leaving
1546:20 - the green
1546:21 - person part and it is going to use that
1546:24 - to initialize the person part of our
1546:26 - engineer object and this will be reusing
1546:29 - the copy constructor we have in our
1546:33 - person object then this is really cool
1546:35 - this is the optimal way to set up your
1546:38 - copical structures if you have an
1546:41 - inheritance hierarchy so let's try and
1546:44 - build the code again we're going to pass
1546:46 - this through gcc to see if this actually
1546:48 - works the bullet is going to be good we
1546:50 - can clear and run rooster we're going to
1546:52 - see that the copy constructor is going
1546:54 - to be called for person to set up the
1546:56 - person part of us and then the custom
1546:59 - copy constructor for engineer is going
1547:01 - to be called to set up the engineer part
1547:03 - of us and if we look at the information
1547:06 - we have in the main function you're
1547:08 - going to see that it is the same data
1547:10 - daniel gray for the full name ages 41
1547:13 - address is this gibberish here and the
1547:16 - contract count is 12 it is exactly what
1547:18 - we passed here and our copy constructor
1547:21 - is working now that we have this working
1547:23 - we can safely reuse the same ideas
1547:27 - in our civil engineer copy constructor
1547:30 - we can head over in our civil engineer
1547:33 - and set up the copy constructor so let's
1547:35 - do that we can
1547:37 - close the left sidebar here so that we
1547:39 - see the entire thing we are going to say
1547:43 - civil engineer and we want to set up a
1547:46 - copy constructor so we're going to say
1547:47 - cast civil engineer here and we will be
1547:51 - passing this by reference we're going to
1547:53 - say source and we're going to put the
1547:55 - implementation of this in our cpp file
1547:59 - we can hop over there and go below our
1548:02 - custom constructor we can put in our
1548:05 - constructor here we're going to say
1548:06 - civil engineer and put in our scope
1548:09 - resolution operator and we're going to
1548:11 - go down and put in the body and in our
1548:14 - initializer list we're going to call the
1548:16 - copy constructor from engineer because
1548:18 - remember civil engineer is inheriting
1548:21 - from the engineer class so we are going
1548:24 - to call the engineer copy constructor
1548:27 - we're going to pass in source and again
1548:29 - this is going to slice off the civil
1548:31 - engineer port and only use the engineer
1548:35 - part of us to construct an engineer
1548:37 - object from this sliced of engineer
1548:41 - object we get from our copy constructor
1548:44 - here and this is really cool after that
1548:46 - we will initialize our contract count
1548:49 - member variable oh it is m speciality if
1548:52 - i remember correctly and we're going to
1548:55 - grab a source m speciality and we will
1548:58 - use that to initialize the civil
1549:01 - engineer part of us here let's go in and
1549:04 - say that the custom copy constructor is
1549:06 - being called here and we're going to say
1549:09 - custom copy constructor called for a
1549:11 - civil engineer what did we do here we
1549:14 - said engineer let's do engineer this is
1549:18 - what we want and we're going to say
1549:20 - engineer here properly sorry for this
1549:23 - but this is no big deal and now that we
1549:25 - have this in place we can actually build
1549:28 - civil engineer objects and copy
1549:30 - constructed them we can
1549:32 - comment out the engineering stuff we
1549:34 - have and we can just put this in a black
1549:37 - comment and we're going to copy
1549:39 - construct civil engineers how cool is
1549:42 - that we're going to set up a civil
1549:44 - engineer let's do that
1549:46 - and this is going to be a civil engineer
1549:49 - and we're going to say daniel gray we're
1549:51 - going to put in all the data and we're
1549:53 - going to specify the speciality to be
1549:55 - road strength this is something i just
1549:57 - made up i don't even know
1549:59 - if this kind of speciality exists and we
1550:02 - will set up another civil engineer
1550:04 - object called n2 which we are going to
1550:07 - be copy constructing from and we will
1550:10 - see what happens when we copy construct
1550:13 - this thing here we should call our copy
1550:15 - constructor in civil engineer and the
1550:18 - things should propagate up all the way
1550:21 - to the person part of us and we're going
1550:23 - to see what happens let's build this
1550:25 - code we're going to pass this through
1550:27 - gcc as we always do the budget is going
1550:30 - to be good so this is good news we're
1550:32 - going to clear and run rooster and we're
1550:35 - going to see that the custom copy
1550:36 - constructor is called for person the
1550:38 - custom copy constructor is going to be
1550:40 - called for engineer and the custom copy
1550:43 - constructor is going to be called full
1550:44 - civil engineer and you see that things
1550:47 - are really propagating all the way to
1550:49 - the person part and we are calling and
1550:51 - reusing our copy constructors and this
1550:53 - is really cool if you go down you're
1550:55 - going to see that the information is
1550:57 - printed out correctly the full name is
1550:59 - daniel gray which we have in engineer
1551:02 - one the age is 41 the address is all
1551:05 - this gibberish the contract count is 12
1551:08 - and the speciality is road strength and
1551:10 - we are
1551:12 - properly reusing our copy constructors
1551:15 - in our inheritance hierarchy this is
1551:18 - really all i had to share in this
1551:19 - lecture again the syntax you should be
1551:21 - using to set up your copy constructors
1551:24 - is what we see here this is going to be
1551:26 - reusing the code we have in our upper
1551:30 - classes in our hierarchy we will be
1551:33 - avoiding the temporary copies we saw
1551:35 - when we called the other constructor
1551:37 - directly and this is much cleaner it is
1551:40 - reusing code we have in other classes we
1551:43 - are going to stop here in this lecture
1551:45 - in the next one we're going to see that
1551:47 - it is actually possible to inherit base
1551:50 - constructors go ahead and finish up here
1551:52 - and meet me there in this lecture we're
1551:55 - going to explore the fact that we can
1551:57 - inherit base constructors and use them
1552:00 - in our derived classes we will build
1552:03 - we're using the same hierarchy we have
1552:05 - been using so we will have the person
1552:07 - class and we will be inheriting from
1552:09 - this person to create an engineer class
1552:12 - and that's what we're going to be using
1552:14 - to learn about this concept here so the
1552:17 - personal class is what we know from the
1552:20 - previous lectures we have a bunch of
1552:22 - member variables here we have the full
1552:25 - name the age and the address and we have
1552:27 - a bunch of constructors now we have a
1552:29 - default constructor a custom constructor
1552:32 - and a copy constructor that we set up
1552:35 - tirelessly in the last lecture now what
1552:38 - do we mean when we say that we can
1552:40 - inherit a constructor well based
1552:42 - constructors are not inherited by
1552:45 - default and what we mean by that is that
1552:48 - by default it is really not possible
1552:51 - to get derived classes to use base
1552:54 - constructors to set up things but it is
1552:58 - possible to tell the compiler to use the
1553:00 - base constructor to set up our own
1553:03 - objects for example we can put our
1553:06 - statement here saying
1553:08 - using person column column person this
1553:12 - is going to tell the compiler when
1553:14 - welding engineer objects don't use your
1553:17 - own constructor set up a base like a
1553:20 - constructor which is going to only
1553:22 - initialize the base member variables and
1553:25 - the compiler is going to see this
1553:27 - statement and it is going to generate a
1553:30 - constructor for you that looks something
1553:32 - like this so it is going to be engineer
1553:35 - it is going to be taking in the full
1553:36 - name the age and the address and it is
1553:39 - going to be forwarding the work to
1553:41 - initialize your object to the person
1553:44 - class and this is all this constructor
1553:46 - is going to do hopefully you can see
1553:48 - that this is called inheriting a base
1553:51 - constructor because all this constructor
1553:53 - is really doing is initializing the base
1553:57 - member variables it's not initializing
1554:00 - any member variable that belongs to the
1554:03 - engineer class so the engineer part of
1554:05 - us is going to be basically empty
1554:07 - containing junk data that we get by just
1554:10 - calling the default constructor and we
1554:12 - will only be initializing the data
1554:15 - belonging to the person part of us this
1554:18 - is really what i want you to see again
1554:20 - the syntax is what we see here
1554:23 - this is going to tell the compiler to
1554:25 - generate a constructor that is only
1554:27 - going to initialize the base member
1554:30 - variables but this constructor will be
1554:32 - callable and usable from the engineer
1554:36 - class
1554:37 - okay so this is really what we mean
1554:39 - by inheriting constructors one thing you
1554:43 - should know is that the constructor is
1554:45 - going to be inherited with whatever
1554:47 - access
1554:48 - specifier it had in the base class so if
1554:51 - our constructor was in the public scope
1554:54 - it's going to be inherited with public
1554:56 - access so we will be able to use it from
1554:58 - the outside and world engineer objects
1555:01 - if it was in a protected scope we want
1555:03 - to be able to use it from the outside if
1555:05 - it was private we won't even be able to
1555:08 - use it from a derived class you should
1555:10 - really know that so it is going to be
1555:12 - inherited with whatever access specifier
1555:15 - we had in our base class now that we
1555:18 - know this let's see some things you
1555:20 - should really be careful about the first
1555:23 - is that copy constructors are not
1555:25 - inheritable if you try to do that you're
1555:28 - going to get a compiler error but you
1555:30 - won't usually notice this because the
1555:32 - compiler is going to insert copy
1555:34 - constructors for you anyway this is
1555:36 - going to become a problem if you are
1555:38 - doing some dynamic memory allocation and
1555:40 - you're going to get pointers copied this
1555:42 - is really bad if you don't know about
1555:44 - this please go back to the chapter on
1555:47 - classes and you're going to see all the
1555:49 - story about shallow copying and deep
1555:51 - copying we talked about these things
1555:53 - another thing you should know is that
1555:55 - inherited constructors are really based
1555:58 - constructors and what we mean by this is
1556:00 - that they will only be initializing the
1556:03 - base member variables because they are
1556:05 - based constructors they have no
1556:07 - knowledge of derived member variables
1556:10 - that's why they only initialize base
1556:12 - member variables again as we said the
1556:14 - constructors are inherited with whatever
1556:17 - access specifier they had in the base
1556:19 - class and it is possible to set up your
1556:21 - own constructors on top of the inherited
1556:25 - constructors and you can use these
1556:27 - things another thing i should really
1556:28 - tell you is that inheritance
1556:30 - constructors is going to make your code
1556:32 - really confusing it is a technical
1556:34 - possibility but i strongly advise
1556:37 - against using this in your code because
1556:40 - it is just going to confuse people
1556:41 - people are going to see for example an
1556:43 - engineer constructor and they are going
1556:45 - to think that that constructor is going
1556:47 - to even initializing the engineer member
1556:50 - variables but it's not going to do that
1556:52 - because it is a base constructor it's
1556:55 - only going to be initializing the base
1556:57 - member variables and that may lead to
1556:59 - some confusion or even really bad
1557:02 - problems in your code so don't use this
1557:04 - it is just going to make things
1557:06 - confusing but i wanted you to be aware
1557:08 - of this and if you see this kind of
1557:11 - setup in classes out there you will know
1557:14 - what they mean this is just going to
1557:16 - inherit a base constructor and use it to
1557:18 - build objects now that we know this
1557:20 - we're going to head over to visual
1557:22 - studio code and play with us a little
1557:23 - more here we are in our working folder
1557:26 - the current project is inheriting based
1557:30 - constructors we are going to steal code
1557:33 - from the last lecture and we will be
1557:35 - using the main cpp file the person class
1557:38 - and the engineer class this is just
1557:40 - going to be enough for our purposes here
1557:43 - we're going to go back in our current
1557:45 - project and we're going to put this in
1557:48 - and we will open this in visual studio
1557:50 - code by dragging and dropping here this
1557:52 - is going to give us our thumb
1557:54 - and let's go to person and see that we
1557:56 - have our constructors and we have a
1557:59 - default constructor we have a custom
1558:01 - constructor and we have a copy
1558:03 - constructor one thing you should know is
1558:05 - that copy constructors are not inherited
1558:08 - so you will need to set up your copy
1558:10 - constructors explicitly if you want to
1558:12 - use them know that they want to be
1558:14 - coming from the upstream class you
1558:16 - should know that okay so this is the
1558:18 - message here now let's look at our
1558:21 - engineer class the engineer class is
1558:23 - publicly inheriting from person and it
1558:26 - has a bunch of its own constructors but
1558:30 - what we want to do is to take out all
1558:32 - these constructors and we're going to
1558:35 - take them out i think we can uh yeah
1558:38 - we're going to take them out let's do
1558:40 - that and we're going to go in our cpp
1558:42 - file and also take out all these
1558:44 - constructors here we're going to comment
1558:46 - them out i think we can take out all
1558:48 - these bad code we got from previous
1558:50 - lectures and we're going to just comment
1558:53 - out our constructors we're going to
1558:55 - close them all with a blog comment and
1558:58 - what we are going to do in our class is
1559:01 - say
1559:02 - using person person we're going to say
1559:04 - using person person this is going to
1559:07 - inherit the constructors from person and
1559:10 - now that we have this in place the
1559:12 - compiler is really going to generate a
1559:14 - base like constructor in our engineer
1559:17 - class in other words we're going to have
1559:19 - a default engineer constructor which is
1559:22 - just going to not initialize anything we
1559:24 - are going to have a custom constructor
1559:27 - which is going to take three parameters
1559:29 - but it is going to be an engineer
1559:31 - constructor and let's prove this we're
1559:33 - going to go in our main cpp file and
1559:35 - we're going to take out everything we
1559:37 - have here and we don't have a civil
1559:40 - engineer file so we shouldn't really
1559:41 - include that and we are going to create
1559:44 - an engineer object we can say and one
1559:46 - using the default constructor we can try
1559:48 - and print that out and you're going to
1559:50 - see that this code seems to work in
1559:53 - visual studio code we can try and build
1559:55 - this we're going to pass this through
1559:56 - gcc and we are going to
1560:00 - set up a powershell window we can use to
1560:02 - run and see things
1560:04 - and we're going to see that the default
1560:06 - constructor for person was called to
1560:08 - initialize this guy
1560:10 - and the data is really junk data we have
1560:12 - in person so what the compiler is really
1560:15 - doing behind the scenes is to generate a
1560:18 - bezel-like constructor at the engineer
1560:21 - level and it is going to call the base
1560:23 - constructor to initialize the person
1560:25 - part of us so the data is just going to
1560:28 - be junk data we have in person and
1560:31 - you're going to see that the contract
1560:32 - count is going to be zero this is just a
1560:34 - default constructor which is just going
1560:36 - to grab whatever default data we have in
1560:38 - our object you see the contract count is
1560:41 - zero if we go back in person we're going
1560:43 - to see that the full name is none which
1560:46 - is what we see here the age is zero and
1560:48 - the address is none this is a default
1560:50 - constructor but we can even explicitly
1560:53 - pass in the data and that's going to
1560:55 - also work so we can pass in the full
1560:57 - name to be
1560:58 - daniel gray we can pass in the edge to
1561:00 - b23 for example and we can pass in a
1561:03 - junk address let's say something like
1561:05 - this and you see that this is going to
1561:07 - work even if we don't have any engineer
1561:10 - constructor
1561:11 - that takes three parameters let's go
1561:13 - back and you're going to see that all
1561:15 - our constructors are commented out but
1561:18 - this is working because we told the
1561:20 - compiler to generate
1561:23 - a base like constructor for our engineer
1561:27 - so it is going to also have in
1561:30 - an engineer constructor that looks like
1561:33 - this constructor here which takes in
1561:35 - three parameters and this is really cool
1561:38 - and this is really crucial to understand
1561:40 - so again we are going to set up a
1561:42 - constructor for engineer so it is going
1561:44 - to be an engineer constructor but it is
1561:46 - going to be taking three parameters just
1561:49 - like the person constructor here and
1561:51 - this is the message i really want to
1561:53 - convey here so if we run this code
1561:55 - you're going to see that it is going to
1561:57 - work it is going to call our baseline
1562:00 - constructor for engineer and we're going
1562:02 - to have the data forwarded and but
1562:04 - you're going to see that the contract
1562:06 - count is not going to be taken into
1562:08 - account so it is going to still contain
1562:10 - some default data if we try and pass
1562:13 - that in we're going to see that we're
1562:15 - going to get a compiler error because
1562:16 - now we have no such constructor that
1562:19 - takes four parameters the only one we
1562:21 - have is one that is generated because of
1562:24 - this statement here and this is going to
1562:26 - be a baseline constructor which is just
1562:29 - going to take three parameters just like
1562:32 - this constructor here and another thing
1562:34 - i don't think i made clear enough is
1562:37 - that this is going to bring in all the
1562:39 - constructors you have notice that we
1562:41 - just put in this statement but it is
1562:44 - going to grab all these constructors we
1562:46 - have except for the copy constructors
1562:49 - which are not inherited in c plus plus
1562:52 - so you should really know this if we
1562:54 - build this code we're going to get a
1562:55 - compiler error because the compiler
1562:58 - wants to know
1562:59 - what to do with the 45 parameter that we
1563:01 - have here but let's build and really
1563:04 - show you this you need to see this
1563:05 - compiler error with your own eyes let's
1563:08 - go in so the world is finished with
1563:11 - errors and we have an error saying no
1563:13 - matching function called to this
1563:15 - constructor which takes four parameters
1563:18 - if we take this out we're going to see
1563:19 - that this is going to work this is going
1563:21 - to use the compiler generated
1563:24 - constructor
1563:25 - as a result of this statement we have in
1563:28 - our code now if we will we're going to
1563:30 - see that this is going to work okay the
1563:32 - build is good can clear and run rooster
1563:34 - we're going to see that we have the full
1563:36 - name to be daniel gray we have the h2b23
1563:39 - we have our address which is really some
1563:41 - junk data and the contract count has no
1563:44 - data in it is just the default data we
1563:47 - have in our member variable here we have
1563:50 - no way to initialize this from a base
1563:53 - like a constructor but not everything is
1563:55 - really bad news if you don't want to be
1563:58 - limited by the constructors that are
1564:00 - generated by your compiler as a result
1564:02 - of inheritance you can set up your own
1564:04 - constructors for example we can uncover
1564:07 - our engineer constructor here and bring
1564:10 - it out of our comment we can do
1564:12 - something like this we can go in the
1564:15 - implementation file and also bring this
1564:18 - out of our comment section and now we
1564:22 - will be able to use this constructor
1564:24 - which is going to take the fourth
1564:25 - parameter here and do something with
1564:28 - that now if we go back in main the code
1564:31 - with three parameters is going to work
1564:32 - it is going to use the compiler
1564:34 - generated constructor but if we pass the
1564:38 - contract count to b4 this is also going
1564:41 - to work because it is going to be using
1564:43 - our own constructor here if we build the
1564:46 - code we're going to see that it is going
1564:47 - to work just fine let's use gcc to show
1564:50 - this
1564:51 - you're going to see that the world is
1564:52 - good we can clear
1564:54 - and run rooster
1564:56 - now our contract count is taken into
1564:59 - account this is really cool this is
1565:01 - really all i wanted you to see in this
1565:03 - lecture that you can let the compiler
1565:06 - generate the baseline constructor using
1565:09 - the syntax we have in our header here
1565:12 - this using statement can really show up
1565:14 - anywhere but it is going to inherit the
1565:17 - constructor with whatever access
1565:19 - specifier the constructor had in the
1565:22 - base class and you should really keep
1565:24 - these points in mind especially the last
1565:27 - one that
1565:29 - inheriting constructors is going to make
1565:31 - your code confusing people are going to
1565:34 - notice that they can call constructors
1565:36 - that are really not going to be
1565:38 - initializing derived member variables
1565:41 - and this may cause serious problems in
1565:43 - your code we are going to stop here in
1565:46 - this lecture in the next one we're going
1565:48 - to explore how inheritance works with
1565:51 - these structures so far we have been
1565:53 - ignoring the structures we are going to
1565:56 - focus on them in the next lecture so go
1565:58 - ahead and finish up here and meet me
1566:00 - there in this lecture we're going to
1566:02 - focus on how destructors work with
1566:05 - inheritance and suppose we have an
1566:07 - inheritance hierarchy like we have been
1566:10 - using all along in this chapter so our
1566:13 - base class is person we have the
1566:15 - engineer class which is publicly
1566:17 - inheriting from person and we have a
1566:19 - civil engineer class which is inheriting
1566:21 - from engineer publicly so when we create
1566:25 - a civil engineer object we have seen
1566:28 - that the burst part is built first so we
1566:31 - are going to build the personal part of
1566:33 - us we are going to build the engineer
1566:35 - part of us on top of that and we are
1566:37 - going to build the civil engineer part
1566:39 - of us on top of that so the constructors
1566:42 - are going to be called in this order we
1566:44 - will call the person constructor first
1566:46 - engineer constructor after that and then
1566:48 - a civil engineer constructor after that
1566:51 - to set up our civil engineer object the
1566:54 - thing i want you to see in this lecture
1566:57 - is that the structures are called in the
1566:59 - reverse order to that so the most
1567:02 - specialized destructor is going to be
1567:04 - called first then we're going to destroy
1567:07 - the engineer part of us and the person
1567:10 - part of us is going to be destroyed last
1567:13 - so we are going to construct things in
1567:15 - this order from the base part to the
1567:17 - most specialized one and then we are
1567:20 - going to destroy thanks in this order so
1567:24 - these structures are going to be called
1567:26 - in the reverse order than the
1567:28 - constructors that's the message i want
1567:31 - to convey here and we're going to set up
1567:33 - a simple example to play with us we're
1567:35 - going to create a civil engineer object
1567:37 - and we're going to see the order in
1567:39 - which these things are called and let's
1567:41 - head over to visual studio code and
1567:43 - actually do this here we are in our
1567:46 - working folder the current project is
1567:48 - inheritance and destructors we are going
1567:51 - to be reusing the code from a previous
1567:54 - lecture i don't think the last lecture
1567:56 - is a good example because we don't have
1567:58 - a civil engineer class so we are going
1568:01 - to go to the lecture before that and use
1568:03 - the code from our lecture or the copy
1568:06 - constructors with inheritance that's
1568:08 - going to give us all the classes we have
1568:10 - person engineer and civil engineer and
1568:12 - we need that in this lecture here so
1568:14 - let's grab all these things we're going
1568:17 - to copy them and put them in our current
1568:20 - object
1568:21 - which is inheritance and the structures
1568:24 - and we are going to open this in visual
1568:26 - studio code and it is going to be our
1568:28 - starting point here so we have person
1568:31 - engineer and civil engineer let's see
1568:33 - what we are doing and the main cpp file
1568:36 - we can take out all the junk here or we
1568:39 - can leave in the civil engineer object
1568:42 - we are creating here and we're going to
1568:44 - see how
1568:45 - the constructors and the instructors are
1568:48 - called we're going to go to person and
1568:50 - make sure we have a constructor and we
1568:52 - have a bunch of constructors and
1568:56 - let's go to the cpp file and see that we
1568:58 - have messages in our constructors this
1569:01 - is really
1569:02 - what we expect but we want to also put a
1569:05 - message in the destructor let's say sddc
1569:08 - out and say destructor for person called
1569:11 - this is going to do we're going to go in
1569:13 - our engineer class we're going to see
1569:15 - that we have a bunch of constructors we
1569:17 - have a destructor here we're going to
1569:19 - hop over in the cpp file
1569:22 - and make sure we take out the bad code
1569:24 - here because we don't really need that
1569:26 - we only need good code and we make sure
1569:29 - that we have output statements in our
1569:32 - constructors to know when they are
1569:34 - called looks like we are good we're
1569:36 - going to put an sddc out statement in
1569:38 - our destructor for engineer or engineer
1569:41 - called this is going to do and we are
1569:43 - going to hop over in our civil engineer
1569:46 - class we're going to have a bunch of
1569:47 - constructors we're going to have a civil
1569:50 - engineer
1569:51 - destructor
1569:53 - we can go in the cpp file and make sure
1569:55 - that we have output statements in our
1569:58 - civil engineer constructors looks like
1570:00 - we are good here we can take out all the
1570:02 - bad code we don't need and we are going
1570:05 - to put a message in our destructor here
1570:08 - so let's do that the the structure
1570:11 - called for civil engineer i think this
1570:14 - is going to be good enough let's go back
1570:16 - and make sure we have the same messages
1570:18 - here for engineer
1570:20 - and we have a destructor for person
1570:22 - called message and we're going to try
1570:24 - and run the code and see how
1570:26 - constructors and destructors are called
1570:29 - this is the order we want to make sure
1570:31 - we understand if you want you can even
1570:34 - use a debugger to follow things but i am
1570:36 - not going to do that here i am just
1570:38 - going to weld and show you the output
1570:40 - statements
1570:41 - hopefully that's going to be proof
1570:43 - enough
1570:44 - that things happen in the order that i
1570:47 - just described in the slides the build
1570:49 - is good we can clear we can bring up a
1570:51 - powershell window and then clear and
1570:54 - we're going to run rooster we're going
1570:56 - to see that the constructor is going to
1570:57 - be called for person for civil engineer
1571:01 - and you're going to see that things are
1571:02 - going to happen from the must-based
1571:05 - constructor to the most specialized
1571:08 - constructor so we are going to call
1571:11 - person engineer and civil engineer but
1571:13 - you're going to see that the structures
1571:15 - are going to be called in the reverse
1571:17 - order
1571:18 - the most specialized the destructor is
1571:20 - going to be called the first then we're
1571:22 - going to call the distractor for
1571:24 - engineer then we're going to call the
1571:26 - destructor for the base class so things
1571:29 - are going to be happening in reverse
1571:30 - order we will build thanks starting from
1571:33 - the base and then
1571:35 - finish by the most specialized class
1571:38 - which is doing the inheritance and then
1571:40 - we're going to call the destructor for
1571:42 - the most specialized class first and
1571:45 - then the destructor for the most based
1571:48 - class is going to be cold last you
1571:50 - should really make sure you understand
1571:52 - this because sometimes your things are
1571:54 - going to be depending on this order and
1571:57 - you need to understand this and this is
1571:58 - really the main message here that the
1572:00 - structures are ridiculed in the reverse
1572:03 - order
1572:04 - than the constructors
1572:06 - we are going to stop here in this
1572:07 - lecture in the next one we're going to
1572:09 - see that we can actually reuse names in
1572:12 - our inheritance hierarchy and we're
1572:15 - going to see how that works out in the
1572:16 - next lecture so go ahead and finish up
1572:18 - here and meet me there in this lecture
1572:21 - we're going to see that we can reuse
1572:23 - names in our inheritance hierarchy
1572:27 - and what we mean by that is that we can
1572:29 - have a parent class for example and have
1572:32 - a child class inheriting from the parent
1572:34 - class and have exactly the same names
1572:38 - for the member variables and types or
1572:41 - the same signatures for functions for
1572:43 - example in the parent class you see that
1572:45 - we have a member function called
1572:48 - printfur it is going to be printing some
1572:50 - information we can have a function named
1572:53 - exactly the same in the child class and
1572:56 - c plus plus is going to allow this we
1572:58 - can also do the same things for member
1573:00 - variables for example we have m var
1573:03 - which is of type and we have exactly the
1573:06 - same thing in our child class and c plus
1573:09 - plus is going to allow this now the
1573:12 - problem is if you create an object of
1573:14 - child which method will be called if you
1573:17 - call printvar now
1573:20 - what c plus plus does is it is going to
1573:23 - override or hide
1573:25 - things you have in the base class if you
1573:27 - happen to set up exactly the same thing
1573:30 - in a derived class so for example the
1573:33 - members in our child class are going to
1573:36 - hide the members we had in the base
1573:39 - class and if we call these methods on a
1573:41 - child object we are going to get the
1573:44 - versions in the child class called if we
1573:46 - call these methods on a parent object we
1573:49 - are going to get the parent version
1573:51 - called and we're going to see the data
1573:53 - in the parent class printed out this is
1573:55 - the message here it is possible to use
1573:57 - the same names in both parent and child
1574:00 - classes and if you do that things in
1574:03 - child classes are going to hide or
1574:05 - override what we had in the parent class
1574:08 - this is the message i want to convey
1574:10 - here and here is a simple example to
1574:13 - drive home how you can use these things
1574:15 - for example we can create a child object
1574:18 - using this syntax here
1574:20 - and if we call a method on the child
1574:23 - object this is going to call the method
1574:24 - in child but it is possible to force the
1574:27 - compiler to call the version in the base
1574:31 - class and you're going to see this
1574:32 - syntax used somewhere in your code out
1574:35 - there so the syntax is to say the object
1574:38 - name you put it up you say the name for
1574:41 - the parent class and then you call the
1574:44 - method using the scope resolution
1574:46 - operator here and this is going to hold
1574:48 - the method in the parent okay now that
1574:50 - you know this we're going to head over
1574:52 - to visual studio code and play with this
1574:54 - a little more here we are in our working
1574:56 - folder the current project is reused
1574:59 - symbols and inheritance we are going to
1575:02 - just grab the template files because we
1575:05 - are going to be building things from
1575:07 - scratch here and we're going to put in
1575:09 - our files no big deal here and we can
1575:12 - open this in visual studio code this is
1575:14 - going to give us a bare minimum main cpp
1575:18 - file we can clean it up a little bit and
1575:21 - we're going to set up our parent class
1575:22 - let's do that pretty fast we're going to
1575:24 - say parent and set up the header and
1575:27 - we're going to set up the implementation
1575:29 - cpp file we are going to set up the
1575:32 - header file and this is going to do
1575:35 - everything we want we have a constructor
1575:38 - which is really defaulted here so let's
1575:40 - say default and we cannot default the
1575:43 - destructor can we default it let's do
1575:45 - this and see what happens and we don't
1575:47 - really need to do anything in the cpp
1575:50 - file we can leave it empty this is not
1575:52 - going to hurt anything and with this we
1575:54 - can create parent objects let's do that
1575:57 - we're going to say
1575:58 - we're going to hop over to the main cpp
1576:00 - file and include current and make sure
1576:02 - that we can use that and we're going to
1576:04 - create a parent object let's do that
1576:07 - we're going to say parent p1 and say
1576:10 - p1 print values we can do that and we
1576:13 - can work and run this program i think it
1576:15 - is going to work just fine okay the
1576:17 - build is good we can clear or we can set
1576:20 - up a powershell window and a clear
1576:23 - and run rooster this is going to say the
1576:25 - value in parent is 100 which is what we
1576:27 - have by default here we have a simple
1576:29 - member variable which is of ant type it
1576:32 - is protected because we want it to be
1576:35 - inherited and we have a bunch of
1576:38 - constructors here we have a constructor
1576:40 - which is going to take a value but we're
1576:41 - not going to use that here the default
1576:43 - is just fine you can use that if you
1576:45 - want and we have a member function which
1576:47 - is going to print the value in parent
1576:49 - now that this is working we can set up a
1576:51 - child class which is going to be
1576:53 - inheriting from the parent class here so
1576:56 - let's do that we're going to set up the
1576:58 - child header file child dot h and we're
1577:01 - going to set up a cpp file for that that
1577:03 - cpp so we are going to put the data in
1577:06 - the header file again it is nothing
1577:08 - complicated it is just a simple class
1577:11 - which is going to be inheriting from
1577:13 - parent and we are going to have our own
1577:16 - member variable which is going to
1577:17 - eclipse what we had in the parent so the
1577:20 - names here must be the same m a member
1577:22 - of r if we go in parent it is m member
1577:25 - for and what we have in child is going
1577:28 - to eclipse what we had in the parent
1577:31 - class in other words if we print the
1577:34 - member variable in child we're going to
1577:36 - see 1000 printed out here we want to see
1577:39 - 100 that we have in the parent printed
1577:43 - out hopefully this is going to drive the
1577:45 - point home that if you have members
1577:48 - named exactly the same
1577:50 - what you have in your derived classes is
1577:53 - going to eclipse or hide what we had in
1577:56 - the parent class this is the message
1577:57 - here but even if this is the case c plus
1578:01 - plus allows us to specify that we want
1578:04 - to grab the data in parent from a child
1578:07 - object for example in our show values
1578:10 - method we can print the value in child
1578:13 - directly using m member war but we can
1578:16 - also specify that we want the value in
1578:18 - the parent class because even if this is
1578:21 - a child object it has a current part of
1578:24 - it so we can access the data in parent
1578:27 - and print that if the data happens to be
1578:30 - accessible from our derived class and
1578:32 - that's why we set up our member variable
1578:34 - to be protected for it to be accessible
1578:37 - in our derived classes this is going to
1578:39 - allow us to print something like this
1578:41 - and this is going to really work now
1578:44 - that we have this in place we can go in
1578:46 - the main cpp file
1578:48 - and only include the child we can do
1578:50 - that and we're going to create a child
1578:53 - object or we can just take out
1578:55 - everything here
1578:57 - and adjust putting the code we can use
1578:59 - to play with this things we can create
1579:01 - the child object
1579:03 - and on this child we can print for we're
1579:06 - going to see that the data is going to
1579:07 - be printed out but we can also use this
1579:10 - syntax to print the data in the parent
1579:13 - part of us and we're going to see that
1579:14 - the data is printed out we can also show
1579:17 - the values and make sure we see this
1579:20 - from a member function of the child
1579:22 - class this is going to call this member
1579:25 - and we're going to get to the value in
1579:26 - child and we're going to get the value
1579:28 - in parent printed out on the console now
1579:31 - that we have this we can actually try
1579:34 - and work this we're going to use gcc to
1579:36 - do that
1579:37 - we're going to see that we're going to
1579:39 - finish building with errors what is the
1579:42 - problem here we have an undefined
1579:44 - reference to child destructor
1579:46 - we didn't put in a definition for the
1579:49 - child destructor so let's go there
1579:52 - and default it we can do that we're
1579:54 - going to say equals default and the
1579:56 - compiler is going to generate one for us
1580:00 - and now if we build we're going to build
1580:02 - with gcc again the bolt is going to be
1580:05 - good you can clear and run rooster and
1580:08 - we're going to see that the value in
1580:09 - child is 33 because we passed that in
1580:12 - explicitly and this is going to call the
1580:15 - constructor we have in child that
1580:17 - happens to be this guy here and you see
1580:20 - that we are really keeping things simple
1580:22 - we are not calling the base constructor
1580:24 - here the compiler is just going to call
1580:27 - the default constructor we have in
1580:30 - parent here and this is going to just
1580:32 - work the main message here is that you
1580:34 - can set up member variables and member
1580:37 - functions named exactly the same way in
1580:40 - the parent class and in child classes
1580:43 - and what you have in your derived
1580:45 - classes is going to hide what we have in
1580:48 - our current classes so if we call a
1580:51 - method on a child object for example
1580:54 - like we are doing here this is going to
1580:56 - call the method in child but we still
1580:58 - have the ability to call data in the
1581:00 - parent part of us and this is what we do
1581:02 - here i would like to welcome you in this
1581:05 - new chapter where we're going to be
1581:07 - learning about polymorphism and
1581:09 - polymorphism is the setup we can do in
1581:12 - our c plus plus programs
1581:15 - to use a base pointer and manage derived
1581:18 - objects suppose we have an inheritance
1581:21 - hierarchy like we have here we have
1581:23 - shaped as our base class and we can
1581:26 - inherit from oval and create a circle
1581:28 - class imagine that we can create all
1581:31 - kinds of crazy shapes that inherit from
1581:34 - shape in our simplest path program for
1581:36 - example we have a rectangle class we
1581:38 - have a triangle class we have all kinds
1581:40 - of crazy shapes now if we have this
1581:42 - inheritance hierarchy here is something
1581:45 - we might want to do we might want to set
1581:48 - up a base pointer that is managing a
1581:50 - derived object and set up code like this
1581:53 - for example we say shape pointer and i
1581:56 - set up a pointer variable here and use
1581:58 - this pointer to manage a circle object
1582:01 - that we dynamically allocate for on this
1582:04 - line here we can also do a shape pointer
1582:07 - that is managing a rectangle we can set
1582:09 - up a shape pointer that is managing a
1582:11 - novel object we can really set up a base
1582:14 - pointer that is managing any kind of
1582:16 - object we support in our inheritance
1582:19 - hierarchy now some of you are going to
1582:21 - ask a few questions one of them is going
1582:23 - to be is this even legal c plus plus
1582:27 - syntax and the answer is yes because if
1582:30 - circle is inherited somehow from shape a
1582:33 - circle is really a shape and if
1582:35 - rectangle is inheriting from shape it is
1582:37 - a shape and if we try to assign a circle
1582:40 - to a shape we're going to see that
1582:41 - that's going to work so this is valid c
1582:44 - plus plus syntax and we can do the same
1582:46 - thing using references as we see here we
1582:49 - can set up a reference that is going to
1582:50 - be managing
1582:52 - a circle object that we have through
1582:55 - circle one we can set up a reference to
1582:57 - manage a rectangle that we have in shape
1582:59 - two we can set up a reference to manage
1583:02 - an awful object we can really do all
1583:04 - these things
1583:05 - now some of you are asking
1583:08 - why would we want to do something like
1583:10 - this now try and think about your
1583:12 - inheritance hierarchy here and try to
1583:14 - think about what if you want to
1583:17 - draw this kind of ship for example if
1583:20 - you didn't use polymorphism you would
1583:22 - need to set up all kinds of crazy
1583:24 - methods to draw each kind of object and
1583:27 - we have no way around this because these
1583:29 - are different types if you have a method
1583:32 - that takes a novel and you pass in a
1583:34 - circle that's going to give you a
1583:35 - compiler error but with polymorphism we
1583:38 - can set up a single method which takes a
1583:40 - shape pointer or a shape reference
1583:43 - and we can pass in all kinds of crazy
1583:45 - objects whose class derive from shape so
1583:48 - for example we can pass in the address
1583:50 - of the circle and this function is going
1583:52 - to draw a circle we can pass in the
1583:54 - address of a rectangle this is going to
1583:56 - draw a rectangle we can pass in the
1583:58 - address of a novel and this is going to
1584:00 - draw a novel hopefully you can see how
1584:02 - this is useful we can even do this using
1584:04 - references so if we pass in a rectangle
1584:07 - this is going to draw a rectangle if we
1584:09 - pass in a circle this is going to draw a
1584:11 - circle you get the idea this is one of
1584:14 - the benefits of using polymorphism again
1584:17 - polymorphism is about using base class
1584:20 - pointers or references to manage derived
1584:23 - objects in our inheritance hierarchies
1584:26 - another benefit of polymorphism is to
1584:29 - allow us to be able to store
1584:31 - different kinds of objects in a single
1584:33 - collection remember an array can store
1584:36 - objects of different types if you say
1584:39 - tap an end array and try to store in a
1584:41 - string or a double you're going to get a
1584:43 - compiler error because that's not
1584:44 - allowed so if you have an array that is
1584:47 - going to store circles you can't put in
1584:49 - a novel you can't put in a rectangle you
1584:52 - can put in a star you can't really do
1584:54 - that because an array by design is going
1584:57 - to store objects of the same type but we
1585:00 - can avoid this limitation using
1585:02 - polymorphism again we can set up an
1585:04 - array that is going to store base class
1585:07 - pointers and we can store in all kinds
1585:10 - of crazy objects whose class derived
1585:13 - from this base class here so here we can
1585:16 - store in a circle object we can store in
1585:18 - a novel we can store in any kind of
1585:20 - object that is part of our inheritance
1585:23 - hierarchy with the base class as shape
1585:26 - and this is going to work and this is
1585:28 - going to be using polymorphism for
1585:29 - example if you look through this
1585:31 - collection calling the joe method for
1585:33 - the first element this is going to call
1585:35 - the draw method on the circle for the
1585:37 - second element we're going to call the
1585:39 - draw method on a novel and this is going
1585:41 - to be
1585:42 - really cool this is something we can
1585:43 - achieve with polymorphism and i want to
1585:46 - back up a little bit and talk about what
1585:48 - is really meant by polymorphism
1585:50 - polymorphism really means multiple forms
1585:53 - and in my opinion what this means is
1585:56 - that the base class pointer or base
1585:58 - class reference can take multiple forms
1586:01 - at one point it might be managing a
1586:03 - circle at one point it might be managing
1586:05 - a rectangle at one point it might be
1586:07 - managing a novel object so it is a basic
1586:10 - pointer but it can take multiple forms
1586:13 - because it can be managing multiple
1586:14 - kinds of objects whose class are part of
1586:18 - our inheritance hierarchy this is what
1586:21 - we mean by polymorphism so again the
1586:23 - idea is that we can use the base class
1586:25 - pointer or reference to manage all kinds
1586:27 - of crazy objects in our program and this
1586:30 - is going to have many benefits as we are
1586:32 - about to experience in this chapter here
1586:35 - i am really excited to be explaining
1586:37 - this to you this is one of the most
1586:39 - powerful features in c plus plus we are
1586:42 - going to start in the next lecture and
1586:44 - show you that you don't get polymorphism
1586:46 - by default in c plus plus and what you
1586:49 - get is static binding go ahead and
1586:52 - finish up here and meet me there
1586:54 - manage derived objects in our c plus
1586:57 - plus program hopefully this is going to
1586:59 - give you a clear idea on why we might
1587:02 - need to do this so let's look at our
1587:04 - classes that we're going to be using
1587:06 - here we're going to set up a shape class
1587:08 - which is going to be representing our
1587:10 - shapes this is going to be our base
1587:12 - class that's the basic use for this here
1587:15 - it has a simple member variable which is
1587:17 - going to store the description for our
1587:20 - shape it is also going to have our draw
1587:22 - method which is really not going to draw
1587:24 - anything it is just going to say the
1587:26 - description for our shape here once we
1587:29 - have this shape we can create other
1587:31 - shapes from it for example we can create
1587:33 - a novel class which is going to be
1587:35 - representing a shape like this it is
1587:38 - going to have two member variables one
1587:40 - is going to be mx radius the other is
1587:43 - going to be m y radius this may
1587:45 - represent
1587:47 - the radiuses for our oval here for
1587:50 - example the x radius might be something
1587:53 - like this the y radius might be
1587:55 - something like this and this is how
1587:57 - we're going to be representing
1587:59 - this shape here we also have a draw
1588:01 - method which is going to print the
1588:03 - information about this shape here it is
1588:05 - going to say the description that we're
1588:07 - going to be inheriting publicly from
1588:09 - shape but it is also going to say the
1588:12 - radius information for this shape it is
1588:14 - going to give us the x radius and the y
1588:17 - radius here and we have a bunch of
1588:19 - constructors here we have a default
1588:21 - constructor which is really not going to
1588:23 - do anything we also have a constructor
1588:25 - that is going to be taking two
1588:27 - parameters to forward the data in our
1588:30 - member variables here this is the kind
1588:32 - of class we're going to set up in our
1588:34 - program we also have another derived
1588:37 - class from oval and this is going to be
1588:40 - a circle class it is going to be a
1588:42 - specialization on oval in which both x
1588:47 - and y radius are equal so the x radius
1588:50 - is going to be something like this and
1588:52 - the y radius is going to be something
1588:54 - like this and both of these are going to
1588:57 - be equal so this is going to give us a
1588:59 - circle shape we also have a draw method
1589:02 - which is going to print the description
1589:05 - and the radius we can really pick any
1589:07 - radius we can pick the x radius we can
1589:10 - pick the y radius they are really going
1589:12 - to be the same because they are equal
1589:14 - for our circle shape we also have a
1589:17 - simple constructor which is going to
1589:19 - take the radius and we are going to be
1589:21 - using this radius
1589:23 - to forward the data to our oval part of
1589:26 - us and we're going to be setting this as
1589:29 - both x and y radius this is the setup we
1589:32 - have here okay now that we have our
1589:34 - inheritance hierarchy we're going to try
1589:37 - and use it and really explore the idea
1589:39 - of static binding in c plus plus
1589:42 - inheritance hierarchies so here we are
1589:45 - trying to create simple
1589:47 - objects of our classes we have a shape
1589:50 - object we have an oval object and we
1589:52 - have a circle object we are going to go
1589:55 - through a base pointer and try to manage
1589:58 - our objects here
1590:00 - in our first line we're going to set up
1590:02 - a shape pointer and we're going to store
1590:03 - in the address of shape one and what we
1590:06 - would want in our c plus plus program is
1590:09 - that if we call the draw method on this
1590:12 - shape pointer we would want the shape
1590:15 - draw method to be called because we have
1590:17 - a shape object stored in our base
1590:20 - pointer here or in other words we are
1590:22 - using a base pointer to manage this
1590:25 - object in memory down here we store a
1590:28 - novel object in our shape pointer or in
1590:32 - other words we're going to be using this
1590:34 - base pointer to manage an actual oval
1590:37 - object in memory and the setup we want
1590:40 - is that if we call the draw method on
1590:42 - this shape pointer now we are going to
1590:44 - get the oval draw method to be called
1590:47 - this is the setup we want
1590:49 - and down here we have another example
1590:52 - where we are using this base pointer to
1590:54 - manage a circle object we are going to
1590:57 - store the address of the circle object
1591:00 - in this base pointer this is how we do
1591:02 - this and when we call
1591:04 - a draw method on this base pointer we
1591:07 - want the circle draw method to be called
1591:10 - so with polymorphism what we really want
1591:13 - is to call a method on the base pointer
1591:18 - and get the most specific possible
1591:20 - method called on our pointer this is the
1591:23 - setup we want but this is not what we
1591:25 - get by default in c plus plus if we
1591:28 - happen to do this and run our program as
1591:31 - is now with the current knowledge that
1591:33 - we have on the first line here we're
1591:36 - going to get the shape draw method
1591:37 - called this is what we want but on the
1591:40 - second example here we will see that we
1591:42 - see the shape draw method also called
1591:44 - and on this line we will also see that
1591:47 - we get the shape draw method to be
1591:49 - called this is not what we want and this
1591:52 - is static binding so what is happening
1591:54 - here is the compiler is looking at the
1591:58 - type of the pointer and it is using that
1592:00 - to decide which draw method to call so
1592:03 - the compiler is so the compiler is
1592:06 - basically saying i have a shape pointer
1592:08 - so i am going to call the joe method on
1592:11 - the shape class down here it is going to
1592:14 - see that it also has a shape pointer and
1592:16 - it is going to call the draw method on
1592:19 - shape and down here it is going to see
1592:22 - that it has a shape pointer and it is
1592:24 - going to call the jaw method on the
1592:27 - shape class this is what static binding
1592:30 - is all about the compiler is going to
1592:31 - resolve the joe method statically and
1592:35 - what that means is that the compiler is
1592:37 - going to look at the type of the pointer
1592:39 - that we have and it is going to use that
1592:42 - to decide which joe method to call in
1592:46 - our inheritance hierarchy so this is the
1592:48 - default and it is called static binding
1592:51 - in c plus plus we also get the same
1592:53 - behavior if we try to use a base
1592:55 - reference to manage our actual object in
1592:58 - memory here we have the same kinds of
1593:01 - objects we had in a previous slide and
1593:04 - we are using a base reference to manage
1593:07 - our object and what we really want is
1593:10 - that if we go through a base reference
1593:13 - to call our draw method we will get the
1593:16 - most specific draw method called so if
1593:19 - our base reference is managing a shape
1593:22 - we will get the shape draw method called
1593:24 - if our base reference is managing an
1593:27 - alpha object we want the oval draw
1593:30 - method to be called here and if our base
1593:33 - reference is managing a circle object we
1593:36 - want the circle joe method called here
1593:39 - this is what we want but again the
1593:41 - compiler is just going to look at the
1593:43 - type of the reference so for the first
1593:45 - line here it's going to say i have a
1593:47 - shape reference so i am going to call
1593:50 - the shape draw method that's what we're
1593:51 - going to get here on the second line
1593:54 - here it's going to say uh-huh i have a
1593:56 - shape reference so i will call
1593:59 - the draw method of the shape class
1594:01 - that's what we're going to see here by
1594:02 - default and on this line here it is
1594:04 - going to say i have a shape reference so
1594:07 - i am going to call the draw method on
1594:09 - the shape class and this is the behavior
1594:11 - we get by default and this is static
1594:14 - binding in action okay so now that we
1594:16 - have seen what static binding is all
1594:19 - about let's re-examine the idea of why
1594:22 - we need polymorphism and i am going to
1594:24 - give you a simple example here suppose
1594:26 - we have a bunch of shapes we manage in
1594:29 - our programs and we want to draw all
1594:32 - these shapes if we want to draw a circle
1594:34 - with the current setup we have we would
1594:37 - set up a draw circle method if we want
1594:39 - to draw a novel we would need to set up
1594:41 - a draw over method and this will call
1594:44 - our circle draw method and this will
1594:46 - call our oval joe method this is going
1594:48 - to do what we want but try to think
1594:51 - about this if we have 100 shapes in our
1594:54 - program we will need to set up 100 such
1594:57 - methods and this is a mess i don't think
1594:59 - you want to do something like this
1595:01 - and we have another simple case that i
1595:04 - want you to consider suppose we want to
1595:06 - store all these objects in collections
1595:10 - and we're going to use an array to try
1595:12 - and drive this point home here if we
1595:14 - want to store these guys in collections
1595:16 - we will need to set up different
1595:18 - collections because as we have it now we
1595:21 - can't store different types in an array
1595:24 - so what we would need to do now is to
1595:27 - set up an array for circles and set up
1595:29 - an array for ovals and do more
1595:32 - collections for different kinds of
1595:34 - shapes that we support in our program
1595:36 - and if we want to draw them we have no
1595:38 - choice but to set up different kinds of
1595:40 - loops and each of these loops is going
1595:43 - to be looping on each of these
1595:44 - collections here hopefully you can see
1595:47 - that this is by design we don't want to
1595:49 - do this we want to set up something that
1595:51 - is really easier to manage in our
1595:53 - program and polymorphism was
1595:56 - and polymorphism and c plus plus was
1595:59 - designed to exactly solve this kind of
1596:02 - problem
1596:03 - what we really want in our c plus plus
1596:05 - programs is to set up one draw method
1596:08 - for example we can give it a base
1596:10 - pointer and it doesn't matter which kind
1596:12 - of object we pass it when we call this
1596:15 - we will get that method to be called at
1596:17 - run time when we actually need to draw
1596:20 - this shape if we pass in a circle this
1596:23 - is going to draw the draw method on a
1596:25 - circle if we pass in a novel it will
1596:28 - call the draw method on our oval object
1596:32 - if we pass in a rectangle for example it
1596:34 - is going to call the draw method on our
1596:36 - rectangle object this is what we want we
1596:39 - also want the same kind of setup if for
1596:41 - example our functions are taking
1596:43 - reference and this is what we're going
1596:44 - to get this is what we want with
1596:46 - polymorphism and this is really going to
1596:49 - improve on the design that we had
1596:51 - earlier when we needed to set up a
1596:54 - specific method for each shape and we
1596:56 - would end up with hundreds of draw
1596:58 - methods and that's really bad it's not
1597:00 - manageable this is also going to solve
1597:02 - our problem with collections
1597:05 - we really need to set up one collection
1597:07 - which is going to be taking into account
1597:09 - all the ships that we manage in our
1597:12 - inheritance hierarchy so the setup we do
1597:15 - is something like this we're going to
1597:16 - set up an array that is going to be
1597:18 - storing pointers to shape and we can
1597:21 - store in the address of a shape we can
1597:24 - store in the address of a novel we can
1597:26 - store in the address of the circle
1597:28 - because if you really think about it a
1597:30 - circle is a shape a novel is the shape
1597:32 - and the shape is the shape so this is
1597:33 - going to work and when we get to loop
1597:36 - through this collection and call the
1597:38 - draw method for the first item here we
1597:41 - will call the draw method on the shape
1597:43 - for the second element here we will call
1597:45 - the joe method on the oval object and
1597:48 - for the third element here we will call
1597:51 - the draw method on our circle object and
1597:54 - we will draw a shape a novel and a
1597:56 - circle with just one loop and this is
1597:59 - really cool this is the design we want
1598:01 - now this is not the default behavior we
1598:03 - get in our c plus plus classes if we set
1598:06 - up an inheritance hierarchy
1598:08 - with our draw methods what we get by
1598:10 - default is static binding but we will
1598:13 - see how we can get dynamic binding or
1598:16 - polymorphism in the next lecture for
1598:19 - this one we're going to explore static
1598:20 - binding and we're going to head over to
1598:22 - visual studio code and play with us a
1598:24 - little more here we are in our working
1598:27 - folder the current project is static
1598:29 - binding with inheritance we are going to
1598:32 - grab our template files this is going to
1598:35 - be our starting point here we're going
1598:37 - to put in these files and i am going to
1598:40 - put in our classes to save time
1598:42 - if you want you can download these
1598:44 - classes from the attached
1598:47 - resource section on this lecture you're
1598:48 - going to find them and you can use them
1598:50 - as a starting point this is going to
1598:52 - save us a few seconds because we don't
1598:54 - really want to type these classes you
1598:56 - already know how to create classes if
1598:59 - you made it this far in the course so i
1599:02 - am going to drag this and drop here to
1599:04 - open in visual studio code and this is
1599:07 - going to give us a good starting point
1599:08 - here we have a base class which is our
1599:11 - shape class it is going to have a simple
1599:13 - member variable which is going to be the
1599:15 - description one thing i think we need to
1599:18 - improve on this is to use a string view
1599:21 - to pass our parameter here
1599:23 - so let's include string view we can
1599:26 - include that here we're going to say
1599:28 - include string view because we are using
1599:31 - modern c plus plus and we're going to
1599:32 - change this to be an sdd string view by
1599:36 - value we can do this okay so we have our
1599:39 - class here and we have a draw method
1599:41 - which is really not going to do anything
1599:43 - special it's going to just print the
1599:45 - description here and we're going to see
1599:47 - it printed out on the output stream
1599:50 - if we look at the cpp file we just have
1599:53 - an implementation of our constructor and
1599:56 - we have a destructor we're going to fix
1599:58 - our parameter here to make it an std
1600:01 - string view let's look at our oval class
1600:05 - it is going to be
1600:06 - deriving publicly from shape
1600:09 - and we have a bunch of member variables
1600:11 - here two to be exact one is going to be
1600:13 - the x radius the other is going to be
1600:16 - our y radius we have a constructor here
1600:19 - which is going to be taking three
1600:21 - parameters two parameters for the data
1600:24 - for our radius here and we have a
1600:28 - third parameter which is going to store
1600:30 - our description data we're going to also
1600:33 - change this to bstd string view and this
1600:36 - is going to do we have a draw method
1600:38 - which is going to be printing the
1600:41 - description and our radius data and this
1600:44 - is really it we don't need anything
1600:46 - fancy here let's look at our oval cpp
1600:50 - file it is going to have the
1600:51 - implementation for our constructor
1600:54 - and our destructor here
1600:56 - we just need to change the type for our
1600:59 - description here and make this an sdd
1601:01 - string view let's do this and we will
1601:04 - look at our circle class which is going
1601:06 - to be inheriting from
1601:10 - publicly it won't have any member
1601:12 - variable because it's just going to
1601:14 - forward the data to the over portoverse
1601:18 - it doesn't really need to do any other
1601:20 - specialization but what we need is a
1601:23 - method which is going to return the
1601:24 - radius because we want to print that
1601:26 - here so we can head over in our oval
1601:30 - class and set up a protected section
1601:33 - which is going to give us these methods
1601:34 - here so i'm just going to put them in
1601:36 - here to save on some time it is
1601:39 - protected because we want this to be
1601:41 - usable in derived classes but we don't
1601:44 - want this usable from the outside this
1601:47 - is the setup we can achieve by making
1601:49 - these guys protected here get x rad is
1601:52 - going to return the x radius get y rad
1601:55 - is going to return the y radius they are
1601:57 - const because we don't intend for this
1602:00 - to modify our object and if we go in our
1602:03 - circle class this is going to work now
1602:06 - we will be able to print our
1602:08 - information on our circle object and we
1602:11 - will see on our output stream if we look
1602:14 - at the implementation of our circle
1602:17 - class it is nothing complicated it is
1602:19 - just going to take the double radius and
1602:22 - it is going to forward the data to the
1602:24 - oval part of us and our description here
1602:27 - will need to change
1602:29 - to take into account that we want to use
1602:32 - std string view here so let's change
1602:34 - this to bhd string view we can do that
1602:38 - and we are going to head over in our cpp
1602:42 - file and change that as well std string
1602:45 - view you can do that and now our classes
1602:48 - are really complete we can head over in
1602:51 - our main cpp file we can clean that up a
1602:54 - little bit and we're going to remove
1602:56 - what we don't need here
1602:58 - we are going to include our classes so
1603:00 - we're going to include shape let's do
1603:02 - that
1603:03 - we are going to put in oval let's do
1603:05 - that oval dot h and we are going to put
1603:09 - in circle and we are going to create
1603:11 - objects of these classes and try to
1603:13 - print their information so we're going
1603:15 - to set up a shape called the shape one
1603:18 - we're going to set up a novel called
1603:19 - oval one we're going to set up a circle
1603:21 - called circle one and we're going to see
1603:23 - what kind of information we see
1603:25 - if we try to call the job method again
1603:28 - in shape the draw method is just going
1603:30 - to say that we are calling shape joe
1603:33 - in alvo we are going to say that we are
1603:35 - drawing an oval and we're going to say
1603:38 - the description and the radius in circle
1603:40 - we're going to say that we are calling
1603:42 - the draw method on the circle object and
1603:44 - say the description and the radius here
1603:47 - this is the information we want so we
1603:49 - are going to try and build this program
1603:52 - using gcc our favorite compiler you can
1603:55 - really use any compiler you have your
1603:57 - hands on but we are going to use gcc
1604:00 - here because it is our favorite and
1604:02 - we're going to have a bunch of errors
1604:05 - what it is that we have here what is it
1604:08 - that we have here let's go in shape
1604:10 - header
1604:11 - at line 4 and see what we have and we
1604:14 - have a j here that we don't want let's
1604:17 - take this out and we're going to build
1604:19 - it and we're going to pass this through
1604:20 - gcc and the bolt is going to be good we
1604:23 - can bring up a powershell window to run
1604:26 - our program let's run rooster and we're
1604:28 - going to see that shape draw was called
1604:30 - drawing shape one you see we have just
1604:33 - created shape one here and we are
1604:36 - printing its information
1604:38 - we are going to call the oval drill
1604:41 - method and we're going to print
1604:43 - the information on that you see that it
1604:45 - is over one here and we're going to put
1604:48 - out our radius data x radius is going to
1604:50 - be 2 as we specified here y radius is
1604:54 - going to be 3.5 and this is our
1604:56 - information we are also going to call
1604:58 - the draw method on our circle object
1605:01 - this is what we get and we're going to
1605:03 - say we are drawing circle 1 and the
1605:05 - radius is going to be 3 3 this is our
1605:08 - information here but we don't want to go
1605:11 - through direct objects to manage our
1605:14 - data here what we want is to either go
1605:16 - through base pointers or base references
1605:20 - so we are going to set up a shape
1605:22 - pointer let's do that we're going to say
1605:24 - shift because that's our base class and
1605:26 - we're going to say
1605:27 - shape ptr to represent our pointer and
1605:30 - we're going to store in the address of
1605:33 - shape one we can do something like this
1605:35 - and that's really see what is happening
1605:37 - we're going to comment out our calls to
1605:39 - draw methods here and we're going to see
1605:42 - what happens so if we say shape ptr and
1605:46 - call the draw method we can do that
1605:48 - let's try and build our program
1605:50 - we're going to pass this through gcc
1605:52 - you're going to see that it is going to
1605:54 - work and it is going to do what we
1605:56 - expect if we run this program here you
1605:58 - can clear and run rooster we're going to
1606:00 - see that shape draw was called and we
1606:03 - are going to be drawing shape one here
1606:05 - this is what we expect but if we go down
1606:08 - and say we don't want to call the draw
1606:11 - method here we are going to store in
1606:13 - let's say shape ptr and we're going to
1606:15 - store in the address of our over one
1606:19 - object
1606:20 - and we want to call the draw method here
1606:23 - now if you do this as we saw in the
1606:26 - slides what we really want
1606:28 - is to get the draw method on our actual
1606:32 - oval object called and if we will for
1606:35 - example drawing things on the screen we
1606:37 - would draw a novel this is what we want
1606:39 - here but this is not what we're going to
1606:41 - get you're going to see that we still
1606:42 - get the
1606:43 - job method from the shape class called
1606:46 - and it is going to and it is going to
1606:48 - say drawing over one let's try and build
1606:51 - this program and i really want you to
1606:53 - see this so the builder is good we can
1606:55 - clear and run rooster you're going to
1606:57 - see
1606:59 - row even if we are storing again
1607:02 - a novel
1607:03 - object so this is the default behavior
1607:07 - we get and this is static binding that
1607:09 - we get by default in our inheritance
1607:12 - hierarchies so what the compiler is
1607:15 - really going to do here it's going to
1607:16 - look at the type of the pointer that we
1607:19 - have here it is going to say i have a
1607:21 - shape pointer so i am going to call the
1607:24 - jaw method on the shape type that i have
1607:26 - in my pointer here and we are going to
1607:29 - see
1607:30 - that this is calling the draw method on
1607:32 - our shape and this is not what we want
1607:35 - in most cases we are going to see that
1607:38 - we get the same behavior if we store an
1607:41 - a circle object let's do that we're
1607:43 - going to say shift pointer and we're
1607:45 - going to store in the address of our
1607:48 - circle one and then we're going to call
1607:50 - our draw method on our shape pointer
1607:53 - again this is going to draw a shape it's
1607:57 - not going to draw a circle that we
1607:59 - really are managing with our base
1608:02 - pointer here and some of you must be
1608:04 - thinking
1608:05 - why are we able to store circle pointers
1608:09 - for example in a shape well a circle is
1608:11 - a shape according to our inheritance
1608:14 - hierarchy if we take a closer look again
1608:16 - here you're going to see that oval is
1608:19 - going to be inheriting from shape
1608:22 - and the circle is going to be inheriting
1608:25 - from oval so from what we learned in the
1608:28 - last chapter
1608:30 - oval has a shape part in it and the
1608:32 - circle has a novel part in it which in
1608:36 - turn is going to have a shaped board in
1608:38 - it so from this understanding it
1608:40 - shouldn't really be surprising that we
1608:43 - are able to manage a
1608:45 - novel object with a shape pointer or the
1608:49 - fact that we are able to manage a circle
1608:52 - object
1608:53 - using a shape pointer this is why we are
1608:55 - able to do something like this okay so i
1608:58 - hope this is super clear but again we
1609:00 - are not getting the default behavior
1609:03 - that we want but we will see how we can
1609:05 - achieve that in the next lecture for now
1609:08 - i really want you to understand what
1609:10 - static binding is all about and it is
1609:13 - the fact that the compiler is going to
1609:15 - look at the type of the pointer here and
1609:17 - use that to decide which method it is
1609:20 - going to be calling
1609:21 - in our inheritance hierarchy the
1609:24 - compiler for example is going to see
1609:25 - that we have a circle object stored n at
1609:28 - lineup 25 here but when it wants to
1609:31 - decide which joe version to call it is
1609:34 - going to look at the type of this
1609:36 - pointer here and it is going to use that
1609:38 - to decide which draw method to call and
1609:41 - in this case it is going to call the
1609:43 - shape version because the type of this
1609:45 - pointer is shape okay so i really hope
1609:48 - this is super clear here we are going to
1609:50 - get the same behavior if we try to
1609:52 - manage our objects using references for
1609:55 - example if we go through a shape
1609:58 - reference let's do that we're going to
1609:59 - say shape reference and say shape ref
1610:02 - and we are going to store in shape one
1610:04 - for example let's do that
1610:06 - and we want to call the draw method on
1610:09 - ship reference let's do that so let's
1610:13 - call the joe method and you're going to
1610:15 - see that we will get the shape method
1610:18 - called
1610:19 - and this is really making sense because
1610:20 - we have a shape object
1610:23 - managed by this reference here so if we
1610:25 - build our program let's do that we're
1610:27 - going to pass this through gcc
1610:29 - you're going to see that we get what we
1610:31 - expect the build is going to be good
1610:32 - we're going to clear and run rooster and
1610:35 - we see shape drill called this is what
1610:37 - we want but if we use this reference to
1610:40 - manage derived object for example let's
1610:43 - put in over one we can do that we're
1610:45 - going to see that we don't get the most
1610:48 - specific draw method for oval here
1610:51 - called we will still get the method
1610:54 - for a shape called let's build and show
1610:56 - you this this is static binding again
1610:59 - okay the build is good we can clear and
1611:01 - run rooster we're going to see that
1611:02 - shape draw it is drawing we don't get
1611:05 - the ovo draw method called we get shape
1611:08 - drill method again the compiler is going
1611:10 - to look at the type of this reference by
1611:12 - default and it is going to use that to
1611:15 - decide which draw method to call if we
1611:17 - even put in a circle we are going to get
1611:20 - the same behavior let's build with gcc
1611:23 - the bolt is good we can clear and run
1611:25 - rooster we see that shape draw is called
1611:27 - and this is really not
1611:29 - what we want okay so this is static
1611:31 - binding and it is the default behavior
1611:34 - we get if we have an inheritance
1611:36 - hierarchy with the same method spread
1611:40 - across each derived class we're going to
1611:43 - get the shape version called even if
1611:45 - what we are really managing with a shape
1611:47 - pointer or a shape reference is a
1611:50 - derived object i really want you to
1611:52 - understand this now let's see why this
1611:55 - is really badly designed by default in c
1611:58 - plus plus if you happen to need to pass
1612:00 - ship parameters to functions for example
1612:02 - we might do something like this we might
1612:04 - need a function to draw a circle we
1612:06 - might need a function to draw a novel
1612:08 - and if you happen to have 100 objects
1612:11 - you can draw in your program you have no
1612:14 - choice but to set up 100 drawing methods
1612:17 - or functions this is really bad design
1612:19 - you don't want to do something like this
1612:21 - so what you would do in your program for
1612:23 - example is go down
1612:25 - and say drawing
1612:27 - and you would say for example draw
1612:29 - circle and pass in a circle and say draw
1612:32 - oval do we have a draw or full function
1612:35 - let's see yes we have that we can go
1612:37 - down and say draw oval and pass in our
1612:40 - oval one this is going to work just fine
1612:43 - but hopefully you can see that this is
1612:44 - bad design if you have a lot of shapes
1612:47 - in your program this is going to quickly
1612:50 - become and manageable and you don't want
1612:52 - to do something like this what we want
1612:54 - is to be able
1612:56 - to only have one method and get to the c
1612:59 - plus plus runtime to resolve which one
1613:02 - is called at runtime when we get to pass
1613:05 - our actual objects and we will only have
1613:08 - one function which is going to take into
1613:10 - account hundreds of shapes that we might
1613:13 - potentially have in our c plus plus
1613:14 - program this is going to be much easier
1613:17 - to manage and we will actually be able
1613:19 - to achieve this in the next lecture so
1613:22 - stay tuned for that another problem with
1613:24 - us is if you happen to need to store
1613:26 - these shapes in collections if you need
1613:29 - to set up something like this you will
1613:31 - have no choice but to set up different
1613:33 - collections for each type for example we
1613:36 - might set up a collection for a circle a
1613:39 - collection for oval and here we are just
1613:41 - using arrays to model our collections
1613:44 - this is really bad design if you happen
1613:46 - to have 100 shapes in your program you
1613:49 - will set up 100 such collections and the
1613:52 - only difference is that they are just
1613:54 - different types and this is really bad
1613:56 - design because even if they are
1613:58 - different types they are related and
1614:00 - they are all shapes in our c plus plus
1614:02 - program and what we really want is to
1614:05 - set up one collection which is going to
1614:07 - take into account all these kinds of
1614:09 - shapes that we might have in our c plus
1614:11 - plus program and we will be able to
1614:14 - achieve this again in the next lecture
1614:16 - but the whole point of this lecture was
1614:18 - to show you static binding that we get
1614:20 - by default with our inheritance
1614:22 - hierarchies static binding may be bad if
1614:26 - you really are managing a lot of related
1614:29 - objects in your c plus plus program
1614:31 - and all these objects have the same
1614:34 - method
1614:35 - that each derived class is specializing
1614:38 - but you want the most specialized method
1614:40 - to be called on the actual object that
1614:43 - you are managing with a base pointer or
1614:46 - a base reference hopefully this is super
1614:48 - clear i apologize this lecture turned
1614:51 - out to be really long but i wanted you
1614:54 - to make this super clear and everything
1614:56 - else we do in the reminder of this
1614:58 - chapter is really going to fall in place
1615:00 - so make sure you understand this and if
1615:02 - you have a problem do you ask me i will
1615:04 - do the best i can to help you out this
1615:07 - is really all i had to share in this
1615:08 - lecture i hope you found it interesting
1615:10 - we are going to stop here in this
1615:12 - lecture in the next one we're going to
1615:14 - show you how you can achieve dynamic
1615:16 - binding using virtual functions in c
1615:20 - plus plus
1615:21 - go ahead and finish up here and meet me
1615:23 - there in this lecture we're going to see
1615:25 - how we can achieve dynamic binding or
1615:28 - polymorphism
1615:30 - using virtual functions in our
1615:32 - inheritance hierarchies in the last
1615:35 - lecture we had a hierarchy like this
1615:37 - where the base class was shaped we had
1615:40 - an overclass which was publicly deriving
1615:43 - or inheriting from shape and we had a
1615:45 - circle class which was publicly
1615:48 - inherited from over and the problem we
1615:50 - had was that if we happen to be managing
1615:53 - oval or circle objects using
1615:56 - shape pointers or shape references we
1615:59 - don't get the correct methods called if
1616:02 - we call the draw method
1616:04 - on our base pointer or base reference
1616:07 - and this was really bad and this is
1616:09 - something we want in practical c plus
1616:12 - plus programs i am here to tell you in
1616:14 - this lecture that you can just achieve
1616:16 - that
1616:17 - by doing a tiny modification on your
1616:20 - inheritance hierarchy all you need to do
1616:22 - is to mark the methods you need to be
1616:25 - dynamically resolved
1616:27 - virtual and we do that by inserting this
1616:30 - virtual keyword in front of our function
1616:33 - so we're going to do that on our shape
1616:35 - class we're going to do that on our over
1616:37 - class and we're going to do that on our
1616:40 - circle class once we do this the c plus
1616:42 - plus compiler is going to know i want to
1616:45 - be looking at the type of the pointer or
1616:47 - reference to know which kind of method
1616:50 - to call and my inheritance hierarchy if
1616:53 - i happen to be using a base pointer or a
1616:55 - base reference to manage a derived
1616:58 - object and we're going to be making this
1617:00 - super clear in a minute and if you are
1617:02 - lost please bear with me you're going to
1617:04 - understand so let's do this we're going
1617:06 - to modify our shape class and change our
1617:10 - draw method to be virtual
1617:12 - as you see here we're going to head over
1617:14 - in our oval class we're going to modify
1617:16 - our draw method and mark it to be
1617:18 - virtual using the virtual keyword here
1617:21 - and we're going to move in our circle
1617:24 - class and change it to be virtual as you
1617:27 - see down here this is really all we need
1617:29 - to do
1617:30 - from what we had in the last lecture and
1617:33 - this is going to be magic let's look at
1617:36 - what we can achieve now we're going to
1617:38 - set up three objects shape oval and
1617:41 - circle as you see here and we're going
1617:43 - to be calling our method which is going
1617:45 - to be taking references and we're going
1617:46 - to see that we get the correct most
1617:50 - specific method called so for example
1617:52 - here we will call the shape joe down
1617:55 - here we will call the oval draw method
1617:57 - because we just passed in a novel object
1618:00 - and on the third line here we will get
1618:02 - the circle joe method called and we will
1618:05 - see it printed out on the console this
1618:07 - is really cool this is what we want to
1618:09 - achieve if we want to call our methods
1618:12 - that take pointers we can do that and on
1618:14 - the first line here we will call shape
1618:16 - draw on the second line here we will
1618:19 - call overdraw and on the third line here
1618:21 - we will call circuit draw this is what
1618:24 - we want to achieve and if we happen to
1618:26 - be setting up a roll base pointer like
1618:29 - we do here and store in
1618:31 - a derived object like this or another
1618:34 - way to say this if we happen to be using
1618:36 - this base pointer to manage a derived
1618:39 - object and we call the draw method on
1618:42 - the base pointer the compiler is going
1618:44 - to know that it will need to resolve
1618:47 - this draw method dynamically the reason
1618:50 - is this is a virtual method and if a
1618:53 - method is virtual the compiler want to
1618:56 - do
1618:56 - static binding like we did in the last
1618:58 - lecture the compiler is going to be
1619:00 - doing dynamic binding and with dynamic
1619:04 - binding the compiler is not going to
1619:06 - look at the type of the pointer it is
1619:08 - going to look at the type of the actual
1619:11 - object that the pointer is managing and
1619:14 - this is going to give us the behavior
1619:16 - that we wanted starting from the last
1619:19 - lecture okay now that you know this
1619:20 - we're going to head over to visual
1619:22 - studio code and play with us a little
1619:24 - more here we are in our working folder
1619:26 - the current project is polymorphism with
1619:29 - virtual functions we are going to be
1619:32 - reusing the code from the last lecture
1619:34 - because that's going to give us
1619:35 - everything we want
1619:37 - we will leave out the
1619:39 - binary file here which is rooster and
1619:42 - we're going to copy everything we want
1619:43 - we're going to put that in the current
1619:46 - project and we're going to open this in
1619:48 - visual studio code we are going to have
1619:51 - our main cpp file with a bunch of
1619:54 - methods here
1619:55 - and we will just need to modify this a
1619:58 - little bit to achieve dynamic binding as
1620:01 - we saw in the slides all we need to do
1620:03 - is to mark all these draw methods as
1620:06 - virtual so we're going to say virtual
1620:08 - void draw in the shape class we're going
1620:11 - to go in the oval class and do that
1620:14 - we're going to mark our method as
1620:15 - virtual and we are going to go in our
1620:18 - circle class and mark our draw method as
1620:21 - virtual let's do that and at the moment
1620:23 - we do this we're going to get dynamic
1620:25 - binding behavior in our inheritance
1620:29 - hierarchy here and this is really cool
1620:31 - so let's go back and try to play with
1620:34 - what we had before i am going to comment
1620:36 - out everything we had and we're going to
1620:39 - be doing things in step here let's go
1620:42 - through the code that uses base pointers
1620:45 - because
1620:46 - that's where we started out from in the
1620:48 - last lecture
1620:49 - and we are going to
1620:52 - mark that here let's put in some space
1620:54 - to make it easy to follow so we are
1620:57 - going to uncomment the line here that
1621:00 - calls the draw method when we have a
1621:02 - shape object stored in our base pointer
1621:05 - or when we are using a base pointer to
1621:08 - manage a shape object here we can also
1621:10 - comment out all these lines because we
1621:12 - don't want this to do anything
1621:15 - and let's see yes this is what we want
1621:17 - we are setting up our shapes and we are
1621:20 - using a base pointer to manage an actual
1621:22 - shape object and if we call the draw
1621:25 - method we expect this to call
1621:27 - shape draw and this is what we're going
1621:29 - to get let's build our program we're
1621:31 - going to pass this through gcc our
1621:33 - favorite compiler the build is going to
1621:35 - be good we can bring up a powershell
1621:38 - window we can use to play with us if we
1621:40 - call rooster we're going to see that
1621:42 - shape draw is called and we are drawing
1621:44 - shape one now if we change this to
1621:46 - manage an actual oval object we can do
1621:49 - that we can do that through this line
1621:51 - here and we expect this to call overdraw
1621:54 - and because the draw method is now
1621:57 - virtual this will use dynamic binding
1622:00 - again with dynamic binding we are
1622:02 - telling the compiler don't look at the
1622:04 - type of the base pointer look at the
1622:07 - type of the actual object that the
1622:10 - pointer is managing and the compiler is
1622:12 - going to see that this object is a novel
1622:14 - object and it will call
1622:17 - the oval version of the draw method here
1622:20 - and this is really cool this is what we
1622:22 - want let's run the task to build with
1622:24 - gcc again the world is going to be good
1622:27 - as you see here we can clear
1622:29 - and if we run booster look at this
1622:31 - overdraw calls and we are going to be
1622:34 - drawing our oval object and this is the
1622:37 - data we have inside we can use this
1622:39 - radius data to draw this on the screen
1622:42 - if that's what we are after in our c
1622:44 - plus plus program and this is really
1622:46 - cool we can even use our base pointer to
1622:49 - manage a circle object we can do that
1622:52 - and if we do that and call the joe
1622:54 - method because this draw method is now
1622:57 - virtual the compiler will note that it
1623:00 - doesn't need to look at the type of the
1623:02 - pointer that we are using to manage our
1623:05 - object
1623:06 - the compiler is going to look at the
1623:08 - type of the actual object that the base
1623:11 - pointer is managing and in this case it
1623:13 - happens to be a circle object so here we
1623:16 - will call circle draw and this is going
1623:19 - to draw a circle on the screen and this
1623:21 - is really going to be super cool so
1623:23 - let's pass this through gcc
1623:26 - and we're going to see this in action
1623:28 - the build is going to be good we can
1623:29 - clear and run rooster and you see that
1623:32 - we are drawing a circle and this is
1623:34 - really cool and just using virtual
1623:37 - functions we can really achieve powerful
1623:40 - features and you see that this wasn't
1623:42 - really hard to achieve all we had to do
1623:45 - was to mark our inherited methods as a
1623:48 - virtual and this is going to tell the
1623:50 - compiler to do dynamic binding and this
1623:53 - is going to be super cool let's see that
1623:55 - we can also achieve the same thing using
1623:58 - base references i am not going to run
1624:00 - the code where we are using a
1624:03 - base reference i am not going to be
1624:06 - running the code where we are using a
1624:08 - base reference to manage
1624:11 - a base
1624:12 - object because that's going to be really
1624:14 - boring but what we can do is put in an
1624:17 - awful object for example you can say
1624:19 - over one and say shape ref and call the
1624:22 - draw method again this is dynamic
1624:24 - binding because the draw method is
1624:27 - virtual so the compiler is not going to
1624:29 - look at the type of the reference to
1624:31 - decide which version of the draw method
1624:33 - to call it is going to look at the
1624:36 - actual object that this reference is
1624:39 - managing and it is going to see that the
1624:42 - type of the object is awful so c plus
1624:44 - plus is going to call the oval version
1624:48 - of the draw method that's what we're
1624:50 - going to get if we run this program here
1624:52 - let's build and see this we're going to
1624:54 - pass this through gcc the voltage should
1624:56 - be good as we see here we are going to
1624:59 - clear and run rooster you see we are
1625:01 - drawing oval if we happen to be using
1625:04 - this to manage our circle object let's
1625:06 - do that
1625:07 - we will see that we will get the circle
1625:10 - method called okay let's build and we're
1625:12 - going to pass this through gcc to do
1625:14 - that the both is going to be good we can
1625:16 - clear and run rooster you see that we
1625:19 - are drawing a circle because our base
1625:21 - pointer is now managing a circle object
1625:25 - now because we are using dynamic binding
1625:29 - or late binding as some people call it
1625:32 - we can really do all kinds of crazy
1625:33 - things the first thing we can achieve is
1625:36 - set up one single method which is really
1625:38 - going to draw any kind of shape we throw
1625:41 - at it so let's do something like this
1625:43 - we're going to say void and we're going
1625:44 - to say draw shape and it is going to
1625:47 - take a shape pointer let's say s and the
1625:50 - only thing we're going to do in this
1625:51 - function and say s draw this is going to
1625:54 - call the draw method on whatever
1625:56 - parameter that we pass in here
1625:58 - and watch this if we go down here and
1626:01 - uncomment this section on drawing shapes
1626:04 - if we say draw and pass in a circle for
1626:08 - example or let's pass an oval and do
1626:10 - this one level and to do this level by
1626:13 - level we're going to pass in over one
1626:15 - and we should pass an address because
1626:16 - this is taking a pointer let's so let's
1626:18 - do this and if we build and run this
1626:21 - program let's see what happens here
1626:23 - we're going to build with gcc the world
1626:25 - is going to be good as you see here if
1626:27 - we clear and run rooster you see
1626:30 - and let's take out this thing using base
1626:33 - references here because this is just
1626:35 - going to confuse us we're going to build
1626:37 - again and i use gcc for this the build
1626:40 - is going to be good within clear and run
1626:42 - rooster you see oval drill because we
1626:44 - are passing in a novel object if we pass
1626:47 - in our shape let's say shape one for
1626:50 - example we're going to build the book is
1626:52 - going to be good as you see here if we
1626:54 - clear and run rooster we're going to see
1626:57 - shape draw if we pass in circle let's do
1626:59 - that
1627:00 - and the bold again we're going to build
1627:02 - with gcc we're going to clear and run
1627:05 - rooster you're going to see that circle
1627:07 - draw is called and this is really cool
1627:09 - we can only use a single method and this
1627:12 - method is going to take any shape we
1627:14 - throw at it and it is going to draw it
1627:16 - if we happen to be having 100 kinds of
1627:19 - shapes in our program we can just for
1627:21 - example loop through a collection
1627:23 - containing those shapes and if we call
1627:25 - the draw method on any shape we store in
1627:28 - our collection we're going to get the
1627:30 - correct shape drone and this is super
1627:32 - cool this is really powerful and i hope
1627:35 - you are excited to be able to achieve
1627:37 - this in c plus plus now we can also
1627:39 - achieve the same thing by using a method
1627:42 - that takes a reference for example so we
1627:44 - can say void joe shape let's say v1 and
1627:48 - we're going to pass a reference
1627:50 - we can say const and pass a reference
1627:53 - and say sr to say ship reference we can
1627:56 - do that and we're going to say sjo we're
1627:59 - going to call the jaw method on this
1628:01 - reference and let's see what happens if
1628:03 - we try this out let's say sr that's what
1628:06 - we should say here and this is going to
1628:08 - be taken by our visual studio code
1628:11 - editor if we go in here and change this
1628:14 - to say
1628:15 - draw shape v1 we can pass in shape one
1628:19 - we can do that because this is taking a
1628:21 - reference now
1628:22 - if we build with gcc we are going to see
1628:25 - that the world is good we can clear
1628:27 - let's clear we're going to run the
1628:29 - rooster this is going to call shape draw
1628:31 - because we are using a reference to
1628:33 - manage a shaped object we can also pass
1628:36 - it over one and we're going to build
1628:38 - again and see how this works the bolt is
1628:41 - going to be good we can clear and run
1628:43 - rooster we're going to say overdraw and
1628:45 - we're going to see our information here
1628:47 - if we pass in our circle object
1628:50 - and the bolt we're going to pass this
1628:52 - through gcc the bolt is going to be good
1628:55 - we can clear and run rooster this is
1628:57 - going to draw a circle for us this is
1628:59 - really cool we have one method again
1629:02 - that is taking a parameter by reference
1629:04 - but we can use this method to draw any
1629:07 - kind of shape in our inheritance
1629:09 - hierarchy this is going to work really
1629:12 - well and it is doing dynamic binding
1629:15 - which is powered by virtual functions we
1629:17 - are using in our inheritance hierarchy
1629:20 - here you should really keep this in mind
1629:22 - now let's go back and see if we can even
1629:25 - use row pointers to do stuff i am going
1629:28 - to comment this out and i am going to
1629:30 - say roll pointers because i want you to
1629:33 - see something we're going to set up a
1629:34 - shape pointer we're going to say shape
1629:36 - ptr
1629:37 - do we have that on top here let's see if
1629:40 - we do
1629:41 - yes we have shape ptr so let's say shape
1629:44 - ptr
1629:46 - and pass it a novel object we're going
1629:48 - to pass a novel again and we're going to
1629:50 - pass the address of 01 this is going to
1629:53 - do we can call the draw method and get
1629:56 - it called polymorphically
1629:58 - or get it called using dynamic binding
1630:00 - we can say shape ptr
1630:03 - and say draw this is going to call the
1630:05 - correct version but one thing i want you
1630:08 - to see is that if a method is not
1630:11 - polymorphic or if a method is not
1630:14 - virtual
1630:15 - you want to get it called using
1630:18 - polymorphism for example if we go to our
1630:21 - oval class we're going to see that we
1630:22 - have a bunch of getters let's go in and
1630:25 - make them public so that they are
1630:27 - callable from the outside and if we try
1630:31 - and get this called
1630:33 - polymorphically or using dynamic binding
1630:36 - that's not going to work let's do that
1630:38 - we're going to say get x rad and the
1630:41 - reason we might want to do something
1630:42 - like this is because we have this method
1630:45 - here
1630:46 - and it is set up on our oval class
1630:49 - so because we are using a base pointer
1630:52 - to manage a novel object some of you
1630:54 - might think uh-huh i might be able to
1630:57 - call this method because i am able to
1631:00 - call the job method which is also in the
1631:03 - public scope of our overclass but that's
1631:06 - not going to work because this method
1631:08 - here is not virtual
1631:10 - dynamic binding or polymorphism is only
1631:14 - going to work if your methods are
1631:16 - virtual and they are set up across your
1631:19 - inheritance hierarchy so this is not
1631:22 - going to work if you try to do something
1631:24 - like this this is going to give you a
1631:26 - compiler error let's try and build and
1631:28 - see the compiler error and we're going
1631:30 - to see an error that says that no such
1631:33 - method on this object let's go here
1631:36 - class shape has no
1631:38 - class shape has no member name to get x
1631:41 - red
1631:42 - because the method is not virtual the
1631:44 - compiler is going to do static binding
1631:46 - and it is going to be using the type of
1631:49 - the pointer which is shaped to resolve
1631:51 - this method and it is going to see that
1631:54 - in shape we don't have a method called
1631:56 - get xrad and the compiler is going to
1631:58 - throw this compiler error here this is
1632:00 - what we get so this is not going to work
1632:02 - and i want you to be aware of this
1632:05 - another thing i want you to see
1632:06 - is that because we are using dynamic
1632:10 - binding now
1632:11 - we don't need we don't need to set up
1632:14 - all kinds of crazy collections to take
1632:16 - into account different shapes that we
1632:18 - have in our c plus plus program what
1632:22 - we're going to do here is use a base
1632:24 - pointer to manage the data that we store
1632:27 - in our array here so all i am going to
1632:30 - do is remove all this dirt here because
1632:33 - this is really dirt you don't want to do
1632:35 - something like that and we're going to
1632:37 - use a base pointer which is a shape
1632:39 - pointer and use that to set up an array
1632:42 - which can handle any kind of shape we
1632:44 - have in our inheritance hierarchy so we
1632:47 - can store it shape objects we can store
1632:50 - it over objects we can store in circle
1632:52 - objects and if we look like we do here
1632:54 - we're going to get the correct method
1632:56 - called and this is going to be super
1632:58 - cool so let's try and run this program
1633:01 - we're going to pass this through gcc why
1633:03 - do we have the red thing here let's
1633:05 - build and see if it goes away maybe this
1633:08 - is visual studio code having a problem
1633:11 - with our code the world is good so
1633:13 - visual studio code was playing with us
1633:15 - we're going to clear and run rooster
1633:17 - you're going to see that we're going to
1633:19 - be looping through this array here and
1633:22 - on the first iteration we're going to
1633:24 - call shape draw because the first thing
1633:26 - is the shape on the second iteration
1633:28 - we're going to call overdraw because the
1633:30 - second thing is a novel and we're going
1633:33 - to
1633:34 - hit the third iteration and call circle
1633:36 - draw because the third thing in this
1633:39 - collection is a circle hopefully you can
1633:41 - see that this is going to simplify our
1633:44 - programs a lot compared to what we were
1633:47 - able to do
1633:48 - in the last lecture and this is really
1633:50 - all i had to share in this lecture
1633:52 - showing you that you can achieve dynamic
1633:54 - binding or polymorphism or late binding
1633:58 - as some people call it using virtual
1634:01 - functions in your inheritance hierarchy
1634:03 - again all we had to do was mark our
1634:06 - member functions as a virtual and the
1634:09 - compiler is going to know that it can
1634:11 - set up dynamic polymorphism for your
1634:14 - types if you happen to be managing them
1634:17 - using a base pointer or a base reference
1634:20 - we are going to stop here in this
1634:21 - lecture and the next one we're going to
1634:23 - learn about slicing and the size of
1634:26 - polymorphic objects
1634:28 - go ahead and finish up here and meet me
1634:31 - there in this lecture we're going to
1634:32 - explore the size of polymorphic objects
1634:37 - or objects that use dynamic binding and
1634:40 - we're going to learn about the concept
1634:42 - of slicing if you happen to assign a
1634:45 - derived object to a base object we're
1634:48 - going to see how this works out in the
1634:50 - last two lectures we saw that we could
1634:52 - achieve static binding using a setup
1634:54 - like this we can set up an inheritance
1634:57 - hierarchy and we're going to have oval
1635:00 - derive or inherit from shape and we're
1635:02 - going to have circle inherit or derive
1635:06 - from over here and our methods are going
1635:09 - to be row they are not going to be
1635:11 - virtual on anything and this is going to
1635:13 - do static binding if you happen to
1635:16 - manage a derived object through a base
1635:18 - pointer or reference you want to get
1635:21 - dynamic holes you will get static
1635:23 - binding and the compiler will use the
1635:25 - base pointer or base reference to decide
1635:28 - which draw method to call on your object
1635:31 - we also saw that we could achieve
1635:32 - dynamic binding using virtual functions
1635:36 - and all we needed to do was mark our
1635:38 - methods as virtual in our inheritance
1635:41 - hierarchy here and this would give us
1635:44 - polymorphism or dynamic binding but one
1635:47 - thing you should know is that dynamic
1635:50 - binding is not free you're going to be
1635:52 - paying in terms of memory to get all
1635:55 - these cool things we saw in the last
1635:57 - lecture and we're going to be proving
1635:59 - that in this lecture what we're going to
1636:01 - be doing is basically set up our
1636:03 - inheritance hierarchy and we are going
1636:05 - to set that up in such a way that it is
1636:08 - going to be using static binding we're
1636:10 - going to see the sizes we get printed
1636:12 - out here and we're going to use dynamic
1636:14 - binding and compare the sizes and the
1636:17 - constitution is going to be that with
1636:19 - dynamic binding your objects are going
1636:22 - to be much larger because your simplest
1636:25 - plus program will need to keep track of
1636:28 - the information
1636:30 - that allows it to resolve
1636:32 - function calls dynamically and that
1636:35 - information is stored in what we call
1636:37 - virtual tables but i am not going to go
1636:40 - into that here because it is really out
1636:42 - of scope of a course like this but i
1636:45 - want you to be aware of this if you use
1636:47 - dynamic if you use dynamic binding your
1636:50 - objects are going to be much larger okay
1636:53 - the first thing i want to bring your
1636:55 - attention to
1636:56 - is object slicing and we're going to
1636:58 - look at a simple example here we have
1637:01 - our objects we have a shape object we
1637:03 - have an oval object and we have a circle
1637:06 - object and down here we want to assign
1637:10 - our circle object to a shape object
1637:14 - now notice that here we are not using a
1637:16 - pointer or a reference these are just
1637:19 - the row objects that we are assigning to
1637:21 - each other and what the competitor is
1637:23 - basically going to do
1637:25 - it's going to notice that a circle has a
1637:28 - shape according to it and it is going to
1637:30 - strip off the outer layers or in other
1637:33 - words it is going to strip off the
1637:35 - circle layer it is going to strip off
1637:38 - the oval layer and it is going to leave
1637:40 - in the shape part and that's what it is
1637:43 - going to assign to our shape object here
1637:46 - let's visualize this our shape class
1637:49 - looks like what we have here on the left
1637:51 - our oval class has a shape part into it
1637:55 - and our circle is going to have an over
1637:57 - part into it and that oval part is going
1637:59 - to have a shape part of it and this is
1638:02 - the setup that we have here now if we do
1638:05 - our assignment we're going to do
1638:06 - something like this the compiler is
1638:08 - going to see that we are already
1638:10 - assigning a circle
1638:12 - to a shape and the compiler is going to
1638:14 - notice that what we have on the left is
1638:16 - just a shape and we don't have enough
1638:19 - space to store information about oval
1638:22 - and the circle here so what the compiler
1638:24 - is going to do it is going to strip off
1638:26 - all these things that we don't really
1638:28 - need and it is going to leave in only
1638:31 - the
1638:32 - shape part that we can assign on what we
1638:36 - have to the left so it is going to strip
1638:38 - off all these stands and we are going to
1638:40 - be left with something like this and
1638:42 - then what we have on the right is going
1638:44 - to be assigned on the left and we will
1638:46 - have our data stored in our ship to
1638:50 - object and if we try to use it that's
1638:52 - what you're going to get in memory so
1638:55 - this is referred to as slicing again the
1638:57 - compiler is going to notice that it
1638:59 - doesn't really have enough space on the
1639:01 - left to store
1639:03 - everything we have to the right of the
1639:04 - assignment here and it is going to strip
1639:07 - off or slice off
1639:09 - everything we don't need and it is only
1639:12 - going to leave in the shape part and
1639:15 - that's what it is going to assign on our
1639:18 - object that we have on the left of the
1639:21 - assignment operator here and this is
1639:23 - referred to as slicing in c plus plus
1639:27 - terminology i just want you to be aware
1639:29 - of this and we're going to see a lot of
1639:31 - this starting from now now that you know
1639:34 - this we're going to head over to visual
1639:35 - studio code and play with this a little
1639:37 - more here we are in our working folder
1639:40 - the current project is size of
1639:42 - polymorphic objects and slicing we are
1639:46 - going to grab the code from the last
1639:48 - lecture so let's grab everything except
1639:50 - for the binary file we are going to copy
1639:53 - everything and we're going to put that
1639:55 - in the current folder and we're going to
1639:58 - open this little guy in visual studio
1640:00 - code by dragging and dropping here this
1640:03 - is going to give us our project and we
1640:05 - can head over in the main cpp file
1640:09 - and clean up all the mess we got from
1640:11 - the last previous lectures we can also
1640:14 - take out these functions because i don't
1640:16 - think we need them here
1640:18 - and we are going to check out on our
1640:21 - classes notice that we are using dynamic
1640:24 - polymorphism because we have virtual
1640:26 - functions here so if we happen to be
1640:29 - using base pointers or base references
1640:31 - to manage our derived objects we will
1640:35 - get polymorphic results okay the first
1640:37 - thing we want to see is the size of
1640:40 - objects for our classes here because we
1640:43 - are using virtual functions let's head
1640:46 - over in the main cpp file and we're
1640:48 - going to put in a piece of code which is
1640:51 - just going to use the size of operator
1640:53 - to print the sizes
1640:55 - of objects of these classes we can try
1640:58 - to build and run this program we're
1641:00 - going to use gcc here the world is just
1641:02 - going to be good we can bring up a
1641:05 - powershell window we can use to run
1641:07 - these programs
1641:09 - we're going to do that new terminal this
1641:11 - is going to bring us our window here we
1641:13 - can clear and run rooster we're going to
1641:16 - get 40 56 and 56
1641:19 - so you see that these are our sizes so
1641:22 - let's say that with uh dynamic is going
1641:25 - to be 40 for the base class with dynamic
1641:28 - portal morphism we're going to get 56
1641:31 - for the
1641:32 - oval object and we're going to get
1641:35 - dynamic 56 for the
1641:38 - circle object here now we're going to
1641:41 - remove the setup that uses polymorphism
1641:44 - and we're going to see the results that
1641:46 - we get all we need to do is to remove
1641:48 - the virtual keyword here we can comment
1641:51 - it out you can do something like this in
1641:53 - shape and we're going to hop over in
1641:56 - oval and comment out the virtual key
1641:59 - world we can do something like this and
1642:00 - this is going to
1642:02 - work without removing this completely
1642:04 - from our code because we still need to
1642:06 - leave this in as a reference we're going
1642:09 - to hop over to circle and do the same
1642:12 - thing
1642:13 - and now that we have this setup we can
1642:15 - hop over to our main cpp file we're
1642:17 - going to see that we don't have any
1642:19 - squiggly lines of some kind so this is
1642:22 - going to be accepted by the compiler but
1642:24 - if we build and run this program we're
1642:26 - going to see different sizes let's see
1642:28 - if the world is good it is good as you
1642:30 - see here we can clear and run rooster
1642:33 - now you see that with
1642:36 - static binding the base object is 32
1642:39 - bytes the awful object is going to be 48
1642:43 - and hopefully you can see that with
1642:45 - dynamic polymorphism our objects are
1642:48 - going to be much larger because the
1642:50 - compiler has to keep track of the
1642:52 - information that allows it to
1642:54 - dynamically resolve
1642:56 - virtual function calls that's why our
1642:59 - objects are larger with polymorphism and
1643:02 - you should know that you are not getting
1643:04 - polymorphic results for free you are
1643:07 - going to be paying in terms of much more
1643:11 - memory that you use for your objects in
1643:13 - your c plus plus programs this is the
1643:16 - first thing i want you to see in this
1643:17 - lecture the second thing i want you to
1643:19 - be aware of is the concept of slicing
1643:23 - and this is going to happen if you
1643:25 - happen to take a raw
1643:27 - derived object and assign that to a row
1643:30 - based object let's do something like
1643:32 - that we are going to create a circle
1643:34 - object and then we're going to say shape
1643:36 - and say shape here and we're going to
1643:39 - say equals circle one
1643:41 - this is something we could do
1643:43 - but notice that the compiler is not
1643:46 - giving us any kind of compiler error
1643:48 - because we can assign a circle to a
1643:50 - shape because a circle is really a shape
1643:52 - but from what we know in our inheritance
1643:54 - hierarchy a circle is really much more
1643:57 - than a row shape a circle has awful
1644:00 - information in it and it also has circle
1644:03 - information in it so it is really much
1644:05 - larger and much wider than a shape
1644:08 - object but the compiler is going to see
1644:10 - that we are trying to assign a circle to
1644:12 - a shape and it is going to be smart
1644:15 - enough to know
1644:16 - that we don't really need oval and
1644:18 - circle information in our shape object
1644:21 - that we are storing here so the compiler
1644:23 - is going to slice off circle and oval
1644:26 - information and it is going to leave in
1644:29 - shape information and that's the only
1644:30 - thing we will be able to use with this
1644:33 - shape variable that we have in our c
1644:35 - plus plus program so if we say shape
1644:38 - drill you can try to guess what we are
1644:40 - going to get and let's go back and
1644:42 - re-enable polymorphism because some of
1644:45 - you might think we are going to get
1644:47 - polymorphic results
1644:49 - with this setup here that's not what
1644:51 - we're going to get because we are not
1644:54 - going through bezel references or base
1644:57 - pointers to
1644:58 - do what we are doing in this example on
1645:01 - slicing here so because we are not using
1645:03 - base references or base pointers in this
1645:06 - line here the compiler is going to see
1645:08 - that these are raw objects and it is
1645:10 - going to do slicing and slice of things
1645:13 - we don't need in our shape variable
1645:16 - that we are setting up on line 16 here
1645:19 - so if we call the draw method this is
1645:21 - going to call shape draw
1645:23 - it is not going to do dynamic
1645:25 - polymorphism here you should be aware of
1645:27 - this if you're not using the base
1645:29 - pointers or references and you hope to
1645:32 - get dynamic polymorphism results i hate
1645:35 - to break it to you but you're going to
1645:37 - be disappointed because the compiler is
1645:39 - going to slice off derived class
1645:41 - information and all you're going to be
1645:43 - left with is base class information here
1645:46 - that's why this is going to call ship
1645:48 - draw let's build and run and really make
1645:51 - you see this this is going to go through
1645:52 - gcc our favorite compiler the bullet is
1645:55 - going to be good we cannot clear and run
1645:58 - rooster you're going to see that it is
1646:00 - going to say shape draw even if we try
1646:03 - to assign a circle to a shape here this
1646:06 - is going to disappoint us because this
1646:08 - is really going to slice off circle and
1646:11 - oval information
1646:12 - and it is just going to leave in the
1646:14 - shape nucleus that we have in our circle
1646:18 - object here
1646:19 - if i can say it like that this is really
1646:22 - all i had to share in this lecture i
1646:23 - hope you found it interesting we are
1646:26 - going to stop here in this lecture in
1646:27 - the next one we're going to see what
1646:29 - happens if we try to store polymorphic
1646:32 - objects in collections
1646:35 - go ahead and finish up here and meet me
1646:37 - there in this lecture we're going to
1646:39 - explore what happens if you try to
1646:42 - directly store polymorphic objects in a
1646:46 - collection like an array
1646:48 - in the last lecture we have seen that if
1646:50 - you assign a derived object to a base
1646:54 - object
1646:55 - the data from the derived object is
1646:58 - going to be basically sliced off if you
1647:01 - assign an oval to a shape the oval part
1647:04 - of the object is going to be sliced off
1647:07 - and we're going to be left with only
1647:10 - shaped data that we assigned to our
1647:12 - shape object we saw that this was
1647:15 - referred to as slicing in c plus plus
1647:18 - and the same is going to happen if you
1647:20 - assign a circle object to a shape the
1647:23 - circle information is going to be sliced
1647:25 - off
1647:26 - then the oval information is also going
1647:29 - to be sliced off and we're going to be
1647:31 - left with the inner shape part
1647:34 - that we assign to our shape object here
1647:38 - now i want you to see that this can
1647:39 - happen indirectly in ways that you might
1647:42 - not expect and we are going to use our
1647:45 - inheritance hierarchy again the base
1647:48 - class is going to be shape we're going
1647:50 - to inherit from that and get oval and
1647:53 - we're going to inherit from oval and get
1647:55 - our circle class here
1647:57 - so let's look at a piece of code here we
1648:00 - are creating a bunch of objects we have
1648:03 - a bunch of circles and ovals and we are
1648:06 - setting up an array that is going to
1648:08 - directly store shape objects
1648:11 - but what we are doing is storing our
1648:14 - pre created objects in our array here
1648:19 - and from what you already know if you
1648:22 - store objects in an array like this this
1648:25 - is going to create copies even if you
1648:27 - can't see that directly so what we have
1648:30 - in our array here is not dirt so what we
1648:33 - have in our array here is not any kind
1648:36 - of direct reference to the object we
1648:39 - have on top here these are just copies
1648:42 - and notice what is happening we are
1648:44 - copying derived objects
1648:47 - in spots that are designed to store
1648:49 - direct shape objects and you might guess
1648:52 - what this is going to do this is going
1648:54 - to slice off
1648:56 - circle and oval information and only
1648:59 - shape information is going to be stored
1649:01 - in this array here so if we happen to
1649:03 - look through this array like we do here
1649:05 - and try to
1649:07 - call the draw method
1649:09 - this is not going to call the most
1649:11 - specific drill method for circle or oval
1649:14 - this is just going to call the shape
1649:16 - version of our draw method here this is
1649:19 - something i want you to see okay some of
1649:22 - you might say what if i take my
1649:24 - shape information in here and assign
1649:27 - that to a pointer and then go through
1649:29 - that pointer to call the draw method
1649:31 - well i hate to break it to you but the
1649:34 - moment your data is sliced off in a
1649:36 - situation like this you'll never get
1649:39 - that data back so even if you try and
1649:41 - take the object and sign that to a
1649:43 - pointer or a reference you're never
1649:45 - going to get polymorphic data again the
1649:48 - data has been lost permanently and you
1649:51 - never get that so even if you try to go
1649:53 - through a pointer or a reference to
1649:55 - manage your object that we have in this
1649:58 - array if we call the draw method we want
1650:00 - to get polymorphic behavior we will get
1650:03 - to the shape version of our draw method
1650:06 - called so the data has been sliced off
1650:09 - permanently if we store our derived
1650:11 - objects in an array like this or even if
1650:15 - we directly assign a derived object to a
1650:18 - base object this is going to slice off
1650:21 - the data and we will never get it back
1650:24 - anyway you should really know this okay
1650:27 - anytime i try to explain this
1650:29 - students mostly come up with this
1650:31 - question what if i try to store
1650:34 - references in my array
1650:37 - and do something like this now this is
1650:39 - not going to work and this is not even
1650:42 - go past the compilation stage of your
1650:45 - program the reason is we can't store
1650:48 - references in a collection and the
1650:50 - reason has to do with the left
1650:53 - assignability rule you can't assign to a
1650:56 - reference and i changed the reference to
1650:59 - store somewhere else and it really drive
1651:02 - this home let's look at this example
1651:04 - here we have a variable called a it is
1651:07 - of entertype and we have a 56 value
1651:09 - inside and we set up a reference which
1651:12 - is going to be referencing the data we
1651:14 - have in a and down on this line here we
1651:17 - try to change the data in our reference
1651:20 - but this is not going to be changing
1651:22 - where this reference is pointing to or
1651:25 - where this reference is referencing this
1651:28 - will merely be changing the values in
1651:32 - our reference here and once we have this
1651:35 - reference we'll never be able to change
1651:38 - where it is pointing again so from this
1651:41 - hopefully you can understand that
1651:42 - references are not left assignable you
1651:46 - can't store thanks that are not left
1651:48 - assignable in an array
1651:51 - because an array is designed to modify
1651:54 - the data of what is stored inside so if
1651:57 - we set up an array like this
1651:59 - the compiler thinks that at some later
1652:01 - point you will want to assign
1652:04 - other data to what is already stored in
1652:06 - this array and there is a hard
1652:08 - requirement on the data you store in
1652:10 - your collections for the type of that
1652:13 - data at least to be left assignable
1652:16 - and references are not left assignable
1652:18 - so we can't store them in a collection
1652:21 - like this if we're trying to do this
1652:22 - we're going to get a compiler error but
1652:25 - again some of you are going to say what
1652:26 - if we store in pointers well this is
1652:28 - going to work this is the basic working
1652:31 - principle of polymorphism
1652:33 - going through base pointers to manage
1652:36 - derived objects this is going to use
1652:39 - polymorphism and here we will get the
1652:42 - most basic draw method called
1652:44 - so if our object is a circle we will
1652:46 - call the draw method on the circle
1652:49 - object if it is a novel we're going to
1652:51 - call the draw method for the over part
1652:54 - of our object here this is even going to
1652:57 - work if we go through smart pointers so
1653:00 - if we do something like this and store
1653:03 - in smart pointers and create our smart
1653:06 - pointers on the fly in our initializer
1653:08 - here this is going to work because
1653:10 - really a smart pointer is a wrapper on
1653:13 - top of the regular roll pointer in c
1653:16 - plus plus so again the message here is
1653:18 - that you need to be careful on what you
1653:21 - store in your collections if it is a raw
1653:24 - piece of ghana your data is going to be
1653:26 - sliced off if you store derived objects
1653:29 - in a collection that is designed to
1653:32 - store
1653:33 - base class data if you store any
1653:36 - references that's not even going to
1653:38 - compile but if you're storing any kind
1653:40 - of pointer row or smart this is going to
1653:43 - work because polymorphism was designed
1653:46 - in the first place to work with base
1653:48 - pointers that are managing derived
1653:50 - objects this is really cool and i want
1653:52 - you to be aware of this now that you
1653:55 - know this we're going to head over to
1653:56 - visual studio code and play with this a
1653:58 - little more here we are in our working
1654:01 - folder the current project is
1654:03 - polymorphic objects stored in
1654:05 - collections we are going to reuse the
1654:07 - code from the last lecture because we
1654:10 - need our inheritance hierarchy here and
1654:13 - this is going to serve us just well
1654:15 - we're going to copy this
1654:17 - and we are going to head over in our
1654:20 - current project and put in our code and
1654:22 - then we're going to open this in visual
1654:24 - studio code pretty quick let's do this
1654:26 - this is going to give us our code and we
1654:28 - have our shape class which is really
1654:30 - what we already know we have our oval
1654:32 - class
1654:33 - and we have our circle class take a good
1654:36 - look at this and what we want to see is
1654:39 - what happens
1654:40 - if we use different kinds of setups to
1654:44 - store objects of this inheritance
1654:47 - hierarchy in a collection like an array
1654:49 - let's go back to our main cpp file and
1654:52 - we are going to take out what we have in
1654:54 - here we're going to set up what we're
1654:56 - going to be using in this lecture we are
1654:59 - going to set up a bunch of objects that
1655:00 - we're going to be using here basically a
1655:02 - bunch of circles and ovals we can close
1655:05 - the left sidebar here and have some more
1655:08 - breathing room after this we're going to
1655:10 - set up an array which is going to store
1655:12 - copies of this object in this array here
1655:16 - which is called shapes one and after
1655:18 - this we're going to try and loop through
1655:20 - this array and try to do things with it
1655:23 - for example we can say for shape and we
1655:26 - may want to call the draw method on our
1655:30 - copy here so for example we can say s
1655:33 - and say draw going to see what happens
1655:35 - here and
1655:36 - let's say references because we don't
1655:39 - want copies in our
1655:41 - range based for loop here so this is
1655:43 - going to avoid copies we do in this loop
1655:46 - and we're going to be directly
1655:48 - referencing whatever we have in this
1655:50 - array here
1655:51 - now what do you expect to get we have
1655:53 - derived objects in this array
1655:56 - and with the setup we have here because
1655:59 - we are using virtual functions
1656:01 - one would expect to get
1656:04 - polymorphic behavior so here we would
1656:06 - expect to get the
1656:08 - joe versions in circle and oval to be
1656:11 - called but that's not what is going to
1656:13 - happen we're going to see that we're
1656:14 - going to be calling shape versions of
1656:16 - our draw methods let's try and build and
1656:19 - show you this we're going to world with
1656:21 - gcc our favorite compiler the build is
1656:24 - going to go through we can kill this and
1656:26 - bring up a powershell window to allow us
1656:29 - to run our program we're going to say
1656:31 - rooster here and you're going to see
1656:33 - that we are drawing circle one over one
1656:36 - circle two over two circle three oval
1656:38 - three but we are calling the shape
1656:41 - versions of our draw method
1656:44 - and the reason is we are slicing off
1656:47 - derived class information in our objects
1656:50 - the moment we try to make a copy and
1656:53 - copy in a spot that is designed to store
1656:56 - objects of the base class so this is
1657:00 - basically what we saw in the last
1657:01 - lecture
1657:02 - on the slicing but it is disguised
1657:05 - because we are storing data in an array
1657:08 - and when you store data in an array like
1657:11 - this you're going to be making copies
1657:13 - and storing copies in your array and in
1657:16 - any copy you make you're going to be
1657:18 - basically slicing off oval and circle
1657:20 - information and only storing in shape
1657:23 - information for our objects here this is
1657:26 - what the compiler is going to do and
1657:28 - that really try and prove this we can
1657:30 - try and print the size of these objects
1657:34 - and see the sizes of these objects in
1657:36 - this array here when we loop so for
1657:39 - example we can say stdc out size of
1657:43 - circle one do we have circle one yes we
1657:47 - do so we're going to say size of circle
1657:49 - one here
1657:50 - and we're going to put its size
1657:52 - information out here to be seen by
1657:55 - everybody we're going to say size of
1657:57 - circle one and we're going to print it
1657:59 - out and we are also going to print the
1658:01 - size of whatever iteration we are at in
1658:04 - our loop here that's the first thing
1658:06 - we're going to prep and we're going to
1658:08 - say size of object and we're going to
1658:10 - say size of s this is going to do
1658:13 - and we're going to loop and see if the
1658:15 - information we have on the outside is
1658:17 - the same as we have on the outside again
1658:20 - we are printing this information on the
1658:22 - direct object
1658:24 - which is really not yet in our array and
1658:28 - in fact we can
1658:29 - bring this in front of our array to make
1658:32 - this super clear and in our loop we are
1658:35 - printing information on a copy that we
1658:38 - have in our array because this is the
1658:41 - real deal we have in our array because
1658:44 - this is a reference hopefully this is
1658:45 - going to make sense and prove to you
1658:48 - that we are going to be working with
1658:51 - derived objects and the data is going to
1658:53 - be sliced off if we copy the data in our
1658:57 - array here this is what i want you to
1658:58 - see so we're going to run this again
1659:01 - we're going to pass this through gcc the
1659:03 - build is going to be good we're going to
1659:04 - clear
1659:06 - and run rooster
1659:07 - now let's look at what we have here size
1659:10 - of circle 1 is 56 but you're going to
1659:12 - see that the size for all our objects in
1659:16 - our array
1659:17 - has shrinked to 40 because derived class
1659:20 - information has been sliced off the
1659:23 - moment we copied our data in our array
1659:26 - here and this is what i want you to see
1659:28 - and i think we can even see this if we
1659:30 - go through our debugger for example we
1659:33 - can put a break point here
1659:36 - and uh open our run tab and if we try to
1659:40 - run our program through the debugger the
1659:42 - build is going to be good and the binary
1659:44 - is going to be passed into our debugger
1659:47 - and we're going to hit our break point
1659:49 - in a minute so let's wait for this and
1659:52 - we have hit our break point here but
1659:54 - what we can do now
1659:56 - is look at our local variables on the
1659:59 - left let's look at our array the array
1660:01 - is called ships
1660:03 - and if we go up we're going to see our
1660:07 - ships one array
1660:09 - and we're going to see that we have five
1660:11 - indexes here because we have six
1660:13 - elements inside
1660:14 - we can expand and see what we have at
1660:17 - index zero and you're going to see that
1660:19 - we just have description data because
1660:22 - this is a shape if we go back in our
1660:24 - class we're going to see that the only
1660:26 - thing we have in our shape class is
1660:28 - really a description member variable and
1660:31 - it is what we see in our array here just
1660:34 - description information because this is
1660:36 - a shaped object and we have lost or
1660:39 - derived class information and this is
1660:41 - really cool but if we go on top and for
1660:43 - example expand circle one we're going to
1660:45 - see that we have a novel part of us and
1660:48 - we have a ship part of us but these
1660:50 - events have been stripped off in our
1660:53 - array when we slice off the data from
1660:56 - derived objects to only store shape
1660:59 - information in our array here i hope
1661:01 - this makes sense now we're going to kill
1661:04 - our debugging session because we don't
1661:06 - need this anymore and we are going to
1661:08 - comment this out and see some other
1661:10 - things so we are going to
1661:13 - comment with our data here we're going
1661:15 - to say if you store row derived objects
1661:18 - in an array which was set up to store
1661:21 - base class object the data is going to
1661:23 - be sliced off this is something i want
1661:25 - you to know but some of you are going to
1661:27 - say
1661:28 - what if we store it in references okay
1661:30 - so let's try and do that we're going to
1661:32 - set up a piece of code like this and
1661:34 - we're going to set up an array called
1661:35 - shapes2 and this array is going to be
1661:38 - basically storing references to the
1661:40 - objects we have on top here and we're
1661:43 - going to see what happens you notice
1661:44 - that we have a squiggly line already and
1661:47 - this is saying this is not going to work
1661:50 - because references can't really be
1661:52 - stored in collections
1661:54 - again as we saw in the slides the reason
1661:56 - is because
1661:58 - references are not left assignable and
1662:00 - they can't be stored in a collection
1662:03 - like an array here the basic requirement
1662:06 - on the types that you can store in your
1662:09 - array is that they have to be left
1662:11 - assignable and our references are not
1662:15 - rest assignable so this is not going to
1662:17 - compile if we try to build our program
1662:20 - we're going to see that we're going to
1662:21 - get weird compiler errors
1662:24 - and the build is going to finish with
1662:25 - errors and if we go up we're going to
1662:27 - see that declaration of shapes to us
1662:31 - array of references and this is not
1662:33 - allowed you can't have an array of
1662:35 - references in c plus plus and this is
1662:38 - the reason why so we're going to get a
1662:39 - compiler error here okay so now you know
1662:42 - this but some of you are going to say
1662:43 - what if we go through pointers well
1662:45 - that's going to work because
1662:47 - polymorphism through virtual functions
1662:50 - was basically designed to work with base
1662:53 - pointers that are managing derived
1662:55 - objects and this is what we have here so
1662:58 - if we look we're going to be getting
1663:00 - polymorphic behavior and if we call our
1663:03 - draw method on our pointer here we're
1663:05 - going to get the most specific
1663:08 - joe method called and this is what we
1663:10 - want so we're going to try and weld this
1663:13 - again and show you that this is going to
1663:14 - work the build is going to be good we
1663:16 - can clear
1663:17 - and run rooster and we're going to see
1663:20 - that we are going to be looping around
1663:22 - and if we call the draw method we're
1663:24 - going to call the overdraw method circle
1663:26 - draw method overdraw method circle draw
1663:29 - method this is basically what we want
1663:31 - and we are going through base pointers
1663:33 - to really use polymorphism here this is
1663:36 - definitely going to work if you go
1663:37 - through smart pointers so let's comment
1663:40 - this out and set up another example to
1663:42 - really drive this home you can really
1663:44 - use any kind of smart pointer you can
1663:46 - use unique pointer or shared pointers so
1663:50 - here we will just be storing in shared
1663:52 - pointers because this is easier to
1663:54 - handle and we're going to head over to
1663:56 - the top and include the memory header if
1663:58 - you remember if you want to use smart
1664:01 - pointers in c plus plus you will have to
1664:03 - include the memory header which brings
1664:05 - in the data to set up smart pointers in
1664:08 - your surplus plus code
1664:10 - so this is going to look good now and if
1664:13 - we build we're going to get the most
1664:14 - specific version of our draw method
1664:18 - called through polymorphism that is
1664:20 - using virtual functions here so let's
1664:23 - build and show you that this is going to
1664:24 - work the book is going to be good we can
1664:26 - clear
1664:28 - and run rooster and we are going to get
1664:30 - our versions of draw called the version
1664:33 - for a circle and the version for oval
1664:36 - because we are using base pointers to
1664:38 - manage derived objects here and our
1664:41 - class inheritance hierarchy is using
1664:44 - virtual functions for the draw method
1664:46 - here so this is going to work this is
1664:48 - really all i wanted you to see in this
1664:50 - lecture you should be careful if you try
1664:53 - to store
1664:54 - derived objects in an array that was
1664:58 - designed to store base class data if you
1665:01 - are using raw data you're going to get
1665:03 - slicing
1665:05 - and you really need to be aware of this
1665:07 - because you want to have derived class
1665:09 - information if you try to store any
1665:12 - references this is not even going to
1665:13 - compile because references are not left
1665:16 - assignable but this is going to work if
1665:18 - you use role pointers or smart pointers
1665:20 - because polymorphism was basically
1665:23 - designed to work with base pointers or
1665:25 - references that are managing a derived
1665:28 - object which uses polymorphism we are
1665:32 - going to stop here in this lecture the
1665:34 - next one we're going to learn about the
1665:35 - override mechanism in c plus plus go
1665:39 - ahead and finish up here and meet me
1665:41 - there in this lecture we're going to
1665:42 - learn about the override specification
1665:45 - a kind of setup you can do to avoid
1665:49 - errors in your inheritance hierarchies
1665:52 - if you use virtual functions to set up
1665:54 - polymorphic behavior for your derived
1665:58 - objects and this is something that was
1666:00 - set up in ziplus plus to avoid easy to
1666:03 - make mistakes
1666:04 - for example if you have an inheritance
1666:07 - hierarchy like this you might be meaning
1666:10 - to set up a draw overrides for what we
1666:12 - have in the base class and an override
1666:15 - is really a must specific
1666:17 - method that you have in your derived
1666:20 - class to really hide what we had in the
1666:23 - base class for example the draw method
1666:25 - novel is going to be overriding or
1666:28 - hiding what we have in shape
1666:30 - and the draw method in circle is going
1666:32 - to be overriding or hiding what we have
1666:35 - in oval this is the idea here but as you
1666:38 - set up your overrides you might make
1666:40 - mistakes for example you may mean to say
1666:42 - draw and i use a w that is in uppercase
1666:46 - and that's going to be bad because what
1666:49 - you will be putting in oval is going to
1666:51 - be a completely separate method that is
1666:54 - different from what we have on the top
1666:56 - and this is going to be really bad
1666:58 - you're not going to get polymorphic
1666:59 - behavior for the draw method in oval
1667:02 - because we are simply not overriding the
1667:05 - jaw method from shape and this is going
1667:07 - to be bad so in ziploc plus we can avoid
1667:10 - these problems by explicitly specifying
1667:14 - that the draw method we have in alpha is
1667:16 - an override and we can add this
1667:19 - specification after our method header
1667:23 - and the c plus plus compiler is going to
1667:25 - enforce that we are actually overriding
1667:28 - a method that exists in our parents
1667:31 - class which happens to be shape here if
1667:34 - we have no method called draw in the
1667:36 - base class we're going to get a compiler
1667:38 - error because we want to be basically
1667:40 - overriding any method here this is going
1667:42 - to protect us from problems if we make
1667:45 - typos in setting up our polymorphic
1667:48 - methods here this is the main thing we
1667:51 - can achieve with the override
1667:53 - specification now that you know this
1667:55 - we're going to head over to visual
1667:57 - studio code and play with us a little
1667:58 - more here we are in our working folder
1668:01 - the current project is override here
1668:04 - we're going to grab the code from the
1668:05 - last lecture because we are basically
1668:07 - going to be reusing the same code over
1668:09 - and over
1668:10 - building on top of that if we need to do
1668:13 - that so we're going to put in our code
1668:16 - and we are going to open this in visual
1668:18 - studio code by dragging and dropping
1668:19 - here this is going to give us our code
1668:22 - and we can really do whatever we want
1668:24 - with that i think we can leave in the
1668:27 - code that is using the base pointer to
1668:29 - manage our derived objects i think this
1668:32 - is going to serve us
1668:34 - well enough and we can take out
1668:36 - everything else because that's just
1668:37 - going to be confusion we don't need all
1668:40 - this here this is going to be serving us
1668:42 - well now we want to learn about the
1668:45 - override key world
1668:46 - and to learn about that we're going to
1668:49 - introduce a title on purpose here for
1668:52 - example suppose we want to set up a draw
1668:55 - override and we use
1668:57 - an uppercase letter here for the w key
1669:00 - world i don't think this is really easy
1669:02 - to spot once you've made this mistake
1669:04 - and you're not going to be getting any
1669:06 - compiler error because
1669:09 - this is something valid you can set up a
1669:11 - completely new method and call it joe
1669:14 - and this is going to work but this will
1669:16 - be very hard to spot in your program and
1669:20 - the compiler won't protect you as we
1669:22 - just said if we build our program you're
1669:24 - going to see that it is going to bulk
1669:26 - just fine so let's pass this through gcc
1669:29 - the voltage is going to be good but we
1669:31 - want to get to the behavior that we want
1669:33 - i think we can take out this sddc out
1669:36 - statement inside our for loop here and
1669:39 - we can weld again this is going to be
1669:41 - less confusing okay so the build is good
1669:44 - we can bring up our powershell window
1669:47 - and i'm going to run rooster and see
1669:49 - what happens you're going to see that
1669:51 - for a circle we're going to draw a
1669:53 - circle
1669:54 - but for oval
1669:56 - we're going to be drawing shape so what
1669:58 - is happening here we are overriding our
1670:02 - joe method in the overclass so we should
1670:04 - get polymorphic behavior because this is
1670:07 - a virtual function and it is called draw
1670:10 - exactly the same thing like we had in
1670:12 - the base class except we've made a
1670:15 - really simple typo here but it is really
1670:17 - hard to track and get hold of we have
1670:20 - named our method draw but the w is in
1670:24 - uppercase so this is a completely
1670:26 - different method than the draw method we
1670:29 - originally intended to override in our
1670:33 - base class and this is really hard to
1670:34 - follow and keep track of we can protect
1670:37 - ourselves by adding the override
1670:40 - specification so if we say override the
1670:43 - compiler is going to help out and make
1670:44 - sure that we are actually trying to
1670:47 - override the method that exists in the
1670:49 - shape class and if it doesn't exist
1670:52 - we're going to get a compiler error then
1670:54 - we're going to look at this and really
1670:55 - spot this mistake here this is what you
1670:57 - can achieve with the override keyword
1671:00 - and in fact i do recommend and advise
1671:03 - you to use this in your inheritance
1671:06 - hierarchy if you happen to be using
1671:08 - virtual functions because
1671:10 - this is going to save you a lot of time
1671:12 - if you make mistakes like this so we're
1671:14 - going to try and run this and show you
1671:16 - the compiler error we get so let's do
1671:18 - that we're going to pass this through
1671:20 - gcc the board is going to
1671:22 - fail as we see here and we're going to
1671:24 - get a compiler saying errol virtual void
1671:27 - overall joe cost marked override but
1671:30 - does not override this is super clear we
1671:33 - are saying we want to override here but
1671:36 - we're not overriding any method called
1671:39 - joe with an uppercase because we don't
1671:42 - have that in shape here this is the
1671:43 - message once we see the problem we can
1671:45 - correct it we're going to use in
1671:47 - lowercase letter for w and this is going
1671:50 - to work just fine now we're going to use
1671:52 - the same mechanism to protect ourselves
1671:55 - from ourselves in circle class so we're
1671:57 - going to override our draw method but
1671:59 - we're going to say that we want to
1672:01 - override explicitly and if we're both
1672:04 - now let's pass this through gcc this is
1672:07 - going to build successfully and if we
1672:09 - run our program we're going to get
1672:11 - polymorphic behavior let's do that you
1672:14 - see that circle draw overdraw circle
1672:16 - draw overdraw this is what we expect
1672:18 - this is really cool this is really all i
1672:20 - had to share in this lecture i hope you
1672:22 - found it interesting use the override
1672:25 - keyword in your inheritance hierarchy
1672:27 - because that's going to protect you from
1672:29 - easy to make typos that are really going
1672:32 - to give you a hard time otherwise we are
1672:35 - going to stop here in this lecture in
1672:37 - the next one we're going to explore the
1672:38 - concepts of overriding and hiding in
1672:42 - detail
1672:43 - go ahead and finish up here and meet me
1672:45 - there in this lecture we're going to
1672:47 - zoom in on overloading overriding and
1672:50 - hiding we have seen that overriding is a
1672:53 - mechanism we have in c plus plus to be
1672:55 - able to set up
1672:57 - most specific versions of our virtual
1673:00 - methods in derived classes so for
1673:03 - example the draw method we have in oval
1673:05 - is overriding or eclipsing the one we
1673:08 - have in shape and the draw method in
1673:11 - circle is overriding
1673:13 - or hiding or eclipsing the one we have
1673:17 - in awful this is the concept here but
1673:20 - what happens if we introduce the concept
1673:23 - of overloading and mix that up with
1673:26 - overriding as we have seen so far so
1673:28 - suppose we do something like this this
1673:30 - is our shape class it is going to have
1673:33 - two versions of the draw method we have
1673:36 - one that takes one parameter for example
1673:38 - this could be the color that we want to
1673:41 - draw our shape with and another one is
1673:43 - not going to take any parameter and
1673:45 - these are two overloads of our virtual
1673:49 - method here so what is going to happen
1673:51 - in our derived classes that are going to
1673:54 - inherit this virtual method so let's
1673:56 - look at an example here we have a simple
1673:58 - example that is setting up objects of
1674:01 - our shapes we have a shape object we
1674:03 - have a novel object and we have a circle
1674:05 - object here if we call the draw method
1674:08 - on our most derived class which is
1674:10 - circle we're going to see that this is
1674:12 - going to work we can draw without a
1674:14 - parameter and we can draw with one
1674:16 - parameter which is going to be our color
1674:19 - depth this is going to work just fine we
1674:21 - will be reusing
1674:23 - our inherited method from the shape
1674:25 - class and this is really cool but what
1674:28 - happens if you override this method in
1674:31 - our overclass suppose we hijack the
1674:34 - inheritance process and set up another
1674:36 - draw method in our overclass and we only
1674:40 - override the overload that doesn't take
1674:44 - any parameter we can do something like
1674:45 - this but the moment you do this this is
1674:48 - going to only override this method and
1674:51 - it is going to hide all the other draw
1674:53 - methods that we had in our base class
1674:57 - which is shaped here and this is
1674:59 - something i want you to know so once you
1675:01 - override a single overload of your
1675:04 - virtual functions
1675:06 - all the other overloads are going to be
1675:08 - hidden and they won't be usable anymore
1675:11 - by downstream inheritance classes if you
1675:14 - want all the overloads to be available
1675:17 - to downstream inheritance
1675:19 - classes you have no choice but to
1675:21 - explicitly override each of them and
1675:24 - that's how it's going to work so if we
1675:27 - look at the example here we're going to
1675:28 - see that the draw call without a
1675:31 - parameter is going to work because this
1675:33 - is overridden in our oval class but if
1675:37 - we call the one which takes a parameter
1675:39 - this is going to be hidden at the oval
1675:42 - level and we want to have access to that
1675:44 - in circle and if we try to call this
1675:46 - we're going to get a compiler error
1675:48 - again the message is if you override one
1675:52 - overload of your virtual functions in
1675:56 - the base class all the other ones are
1675:58 - going to be hidden and you have no
1676:00 - choice but to explicitly override them
1676:03 - for them to be available and usable in
1676:06 - downstream classes this is the message i
1676:08 - wanted to convey here okay so now we
1676:10 - know this but what if we set up another
1676:13 - overload
1676:15 - downstream for example what if we go in
1676:17 - our oval class and set up another
1676:20 - overload which is going to have two
1676:22 - parameters for example we might have the
1676:24 - color depth and the color here that we
1676:27 - want to draw with okay so one thing you
1676:29 - should know is that this this method is
1676:31 - not going to participate in shape
1676:33 - polymorphism and what i mean is that if
1676:37 - we go through a base pointer or
1676:38 - reference to manage derived objects we
1676:41 - can't really call this method with shape
1676:43 - polymorphism so if we go through our
1676:46 - shape pointer or reference we want to be
1676:48 - really able to call this method if we
1676:50 - try to call it we will get a compiler
1676:52 - error the reason is this method is not
1676:55 - known
1676:56 - to the shape class that's why it's not
1676:58 - going to participate in shape
1677:00 - polymorphism the only methods that are
1677:03 - going to participate in shape
1677:05 - polymorphism are the methods that are
1677:07 - declared in the base class and they are
1677:10 - virtual this is the condition here and
1677:12 - if you violate this condition in any way
1677:15 - shape polymorphism or base class
1677:17 - polymorphism in this case is not going
1677:19 - to work and you will get a compiler
1677:21 - error so if you try to do something like
1677:23 - this and you want to call your draw
1677:25 - method with two parameters you're going
1677:27 - to get a bunch of compiler errors and
1677:29 - this is not going to work another thing
1677:31 - i want you to see is that if you assign
1677:33 - a derived object to a base object
1677:36 - your derived virtual functions are going
1677:40 - to be wiped out as part of the slicing
1677:43 - that we have learned about already so
1677:46 - the circle port is going to be wiped out
1677:49 - the oval part is going to be sliced off
1677:51 - and the draw method is going to go with
1677:54 - our oval part and we will only be left
1677:56 - with the shareport and if we try to call
1677:59 - this method here we will get a compiler
1678:01 - error because it's no longer available
1678:03 - it's been sliced off this is really what
1678:05 - i want you to see here now that we know
1678:07 - this we're going to head over to visual
1678:09 - studio code and play with this a little
1678:11 - more here we are in our working folder
1678:13 - the current project is overloading
1678:16 - overriding and hiding we want to explore
1678:18 - these concepts in a little more detail
1678:21 - we're going to grab the code from the
1678:22 - last lecture because that's going to be
1678:24 - a good starting point we're going to
1678:26 - take out the binary we don't want that
1678:28 - and we're going to copy and we're going
1678:30 - to put that in our current project here
1678:32 - this is going to do and we are going to
1678:34 - open this in visual studio code pretty
1678:36 - quick by dragging and dropping here and
1678:39 - we're going to see that we have a bunch
1678:41 - of
1678:42 - virtual functions here who just have the
1678:44 - draw version but we can set up an
1678:47 - overload of this draw method here this
1678:49 - is what we want to do so i am going to
1678:51 - go below here and set up an overload of
1678:54 - this method this is going to be taking
1678:55 - the color depth as a parameter and we
1678:59 - want to see how usable this is
1679:01 - downstream so we're going to go down in
1679:04 - the main cpp function
1679:06 - and take out what we don't need here we
1679:09 - really need a bunch of objects we can
1679:12 - set up circle one and over one and we
1679:15 - will see that we can call this method
1679:17 - we're going to say circle one draw
1679:19 - without a parameter and we're going to
1679:20 - say circle one draw and pass and 44 as
1679:24 - our parameter and let's go back and make
1679:26 - sure that we have our overload and this
1679:30 - is going to be taking the color depth
1679:32 - and let's try and build our program
1679:34 - because we have a squiggly line here
1679:37 - let's see if it is just a visual studio
1679:39 - code playing games with us we're going
1679:41 - to pass this through gcc and we will
1679:43 - have a compiler error here so what is
1679:45 - going on candidate virtual draw cost
1679:49 - let's go up and see what kind of problem
1679:51 - we have here ah this is the concept we
1679:54 - just talked about in the slides we are
1679:57 - setting up our overloads here but this
1680:00 - is being eclipsed by the overloads that
1680:03 - we are setting up in oval you see we
1680:05 - have a draw override and this is also
1680:07 - being eclipsed by the override we have
1680:10 - in our circle class here if we want the
1680:14 - two overloads we have from shape to be
1680:16 - available we can comment out the
1680:18 - overrides we have both in circle and
1680:20 - oval let's do that and that's going to
1680:23 - be available and usable so let's do that
1680:25 - this is a really good learning
1680:26 - opportunity and now if we go in main cpp
1680:30 - we're going to see that this is going to
1680:31 - become available so we can upload this
1680:34 - with gcc again to bring visual studio
1680:37 - code up to date and you see the build is
1680:40 - good and our methods are usable even
1680:43 - from derived classes so for example we
1680:46 - can also set up a novel object let's say
1680:49 - oval one and say draw this is going to
1680:51 - work if we say ovo one draw and pass in
1680:54 - a parameter let's put in 54 for example
1680:57 - this is going to do you're going to see
1680:59 - that this is going to be accepted by
1681:01 - visual studio code and if we weld and
1681:05 - run this program it is going to build it
1681:07 - is going to be calling the inherited
1681:09 - functions in oval and
1681:12 - circle here the boat is good we can kill
1681:15 - our terminal here and bring up a
1681:17 - powershell window we can use to run our
1681:19 - program we're going to see that we call
1681:21 - shape draw and shape draw because these
1681:24 - are inherited functions from
1681:27 - the shape class that's why we are saying
1681:29 - shape draw here and we're going to be
1681:31 - drawing a oval and a drawing with a
1681:34 - color depth we're going to be drawing
1681:36 - the circle and drawing with the color
1681:38 - depth here this is the message i want to
1681:40 - convey but the moment we override these
1681:42 - methods in any downstream class for
1681:45 - example if we go in our over class and
1681:48 - and comment out the override for the
1681:51 - draw method notice that we are just
1681:53 - overriding a single overload again if we
1681:56 - go back to our shape class we have an
1681:59 - overload that doesn't take any parameter
1682:01 - we also have an overload which is going
1682:03 - to take one parameter in oval we are
1682:05 - just going to override the overload that
1682:09 - doesn't take any parameter but this is
1682:11 - going to hide all the other overloads we
1682:13 - had for the draw method here and this is
1682:17 - the only overload that is going to be
1682:19 - available
1682:20 - in downstream classes so if we go back
1682:23 - in main we're going to see that the one
1682:24 - with a parameter is not going to work
1682:26 - and we're going to get a bunch of
1682:27 - compiler errors this is going to be the
1682:30 - case even in circle if we
1682:32 - uncomment this guy the others are going
1682:35 - to be eclipsed again the other one we
1682:37 - have is just the one with one parameter
1682:40 - but this is going to stay true even if
1682:42 - you have a hundred overloads all the
1682:44 - others are not going to be available if
1682:46 - you happen to only override one of the
1682:49 - overloads in other words
1682:51 - the other overloads are going to be
1682:53 - hidden by this one overall ride that you
1682:57 - are putting in your inheritance
1682:59 - hierarchy you should really know this if
1683:01 - you want this guide to be available in
1683:03 - downstream classes for example you can
1683:06 - also override that in derived classes
1683:09 - this is an option we can go in oval and
1683:12 - put in another overload for this this is
1683:14 - going to bring this back in scope so we
1683:17 - can say overdraw here with the color
1683:21 - depth i don't think we copied the right
1683:23 - thing we can grab this and go in oval
1683:25 - and put this in place this is going to
1683:28 - do we're going to say oval drawing and
1683:31 - we can go in circle and also put this
1683:33 - end this is an option and we're going to
1683:36 - say circle drawing and now you see that
1683:39 - the squiggly lines in main go away
1683:41 - because we have overridden all the
1683:44 - overloads okay if we build and run our
1683:47 - program we're going to see that this is
1683:48 - going to work as we expect the world is
1683:50 - going to be good and we can clear
1683:53 - and run rooster we're going to see that
1683:55 - overdraw called overdraw called we are
1683:58 - calling our derived overrides and this
1684:00 - is really cool this is what we want here
1684:03 - let's take this back because we don't
1684:05 - want these
1684:06 - overridden in our inherited classes so
1684:09 - we're going to take this out in oval
1684:12 - and we're going to take this out in
1684:14 - circle and i want you to see that shaped
1684:17 - polymorphism is not going to work if you
1684:20 - override your methods at a downstream
1684:23 - level so what we are going to do we are
1684:25 - going to go at the oval level and set up
1684:28 - another overload for the joe method here
1684:31 - but this draw method is not going to
1684:33 - participate in shape polymorphism
1684:36 - because it is really declared at the
1684:38 - oval level and any base pointer we have
1684:41 - or any shape pointer we have is not
1684:44 - going to have any knowledge of this
1684:46 - overload that we are about to set up
1684:48 - here this is what i want you to know
1684:50 - okay so we are going to go in our oval
1684:52 - class and set up that overload we can
1684:54 - set that up here it is going to be taken
1684:58 - two parameters one is going to be the
1685:00 - color depth the other is going to be the
1685:02 - color and we don't want to pass a string
1685:05 - by a value like this we can use std
1685:07 - string view and we can include that if
1685:10 - we need to but it looks like visual
1685:12 - studio code has got this from something
1685:15 - else we have included before but we can
1685:17 - include that explicitly to avoid
1685:19 - problems so let's do that we're going to
1685:21 - say stream view here and now we want to
1685:24 - see that this method is not going to
1685:26 - participate in shape polymorphism even
1685:29 - if it is a virtual functions the reason
1685:31 - is this is not going to be known by your
1685:34 - shape pointers because it is not
1685:36 - declared at the sherpa level here i
1685:38 - really want you to know this we're going
1685:40 - to take out everything we had here and
1685:42 - we can set up a shape pointer we're
1685:44 - going to say shape and say ship ptr and
1685:47 - we're going to set up a derived object
1685:49 - here we can say new and serious circle
1685:52 - and what do we need to build the circle
1685:54 - object we need the radius and the
1685:56 - description so we're going to put that
1685:58 - in place here the radius is going to be
1686:01 - something like 10 why not and the
1686:03 - description is going to be circle one
1686:05 - how creative and we want to see if our
1686:08 - method is available through polymorphism
1686:10 - and it is not going to be available
1686:12 - because the method was not declared at
1686:15 - the shape level so if we do shape ptr
1686:18 - and say draw and we have a method which
1686:20 - is going to take two parameters at the
1686:23 - oval level we have the color depth and
1686:26 - the color
1686:27 - so for example if we go in main and say
1686:30 - the color depth is 45.21
1686:34 - not let's say this is something that
1686:35 - makes sense or let's use
1686:37 - 45 because this is an integer parameter
1686:40 - and we're going to pass in a string
1686:42 - let's say red you're going to see that
1686:44 - this is not going to compile
1686:46 - because the draw method with two
1686:48 - parameters is not known at the shape
1686:51 - level this is the message i want to
1686:53 - convey here so if you want your method
1686:56 - to be usable with polymorphism the
1686:58 - method has to show up at the top level
1687:02 - this is what i want you to see here if
1687:04 - we're trying to build this we're going
1687:05 - to get a compiler error and you need to
1687:07 - be aware of this but know that even if
1687:11 - this is not working with shape
1687:12 - polymorphism this can work with oval
1687:15 - polymorphism and this is an idea i am
1687:18 - going to explore in the next lecture
1687:20 - where we learn about the fact that polar
1687:23 - morphism can be set up at different
1687:26 - levels so we are going to stop here in
1687:28 - this lecture and explore that idea in
1687:30 - detail in the next lecture so go ahead
1687:33 - and finish up here and meet me there in
1687:35 - this lecture we're going to explore the
1687:37 - idea that we can do
1687:40 - polymorphism at different levels in our
1687:43 - inheritance hierarchy
1687:45 - suppose we have a hierarchy like we see
1687:48 - here the top level class is animal and
1687:50 - we can derive from animal and create a
1687:53 - feline animal we can derive from feline
1687:56 - and create a dog animal we can derive
1687:59 - from feline create a cat animal we can
1688:02 - also do it the other way and create a
1688:04 - bird which is also an animal a bird is
1688:07 - going to have its own methods and member
1688:09 - variables that make it a bird we can
1688:12 - derive from a bird create a pigeon and
1688:15 - we can derive from a bird and create a
1688:17 - crowd
1688:18 - and we can do all these things that
1688:20 - these animals do
1688:22 - so the idea i want to expose here is
1688:24 - that polymorphism
1688:26 - doesn't have to always only work on the
1688:29 - top level class if you have an
1688:31 - inheritance hierarchy like this if you
1688:34 - want you can declare a virtual method at
1688:37 - the feline level and make sure that
1688:39 - method is also available in deriving
1688:42 - class and you can set up feline
1688:44 - polymorphism if that makes sense for
1688:46 - your application following the same idea
1688:49 - you can also set up a virtual method in
1688:51 - the bird class and you can have that
1688:54 - method overridden in downstream
1688:56 - inheritance classes like pigeon and crow
1688:59 - and you can set up bird polymorphism in
1689:02 - your c plus plus program if that makes
1689:04 - sense of course you can still use animal
1689:07 - polymorphism if you want to do that and
1689:09 - that's going to work as well this is the
1689:12 - idea we're going to explore here okay so
1689:14 - with that inheritance hierarchy in mind
1689:17 - we can create animal polymorphism and
1689:20 - animal polymorphism is just going
1689:22 - through the animal base pointer and
1689:25 - using that to manage derived objects for
1689:28 - example here we have a dog we have a cat
1689:30 - we have a pigeon we have a crow we can
1689:32 - do animal polymorphism and storing any
1689:35 - kind of animal we have here you see we
1689:37 - are putting in a dog we are putting in a
1689:39 - cat we are putting in a pigeon and we
1689:41 - are putting in a crow
1689:42 - and if we do animal polymorphism and
1689:45 - call the breathe method which exists in
1689:48 - any kind of animal we have in our
1689:49 - program this is going to call the most
1689:52 - specific breathe method on each animal
1689:55 - and this is going to work really well
1689:56 - this is going to do animal polymorphism
1689:59 - following the same idea we can also do
1690:01 - feline polymorphism and in this case
1690:04 - feline is going to be acting as our base
1690:06 - pointer so again we have our dog we have
1690:09 - our cat we have our pigeon if we do
1690:11 - feline polymorphism we will have to put
1690:14 - in all kinds of crazy felines we have in
1690:17 - our program for example we can put in
1690:19 - dog and cat and this is going to work if
1690:21 - you do fill out a polymorphism like we
1690:23 - are doing here and put in an animal this
1690:26 - is not going to work because the animal
1690:29 - top level class is probably not going to
1690:32 - override the
1690:34 - virtual method we are interested in here
1690:37 - for example here we are calling the run
1690:39 - method and the run method is not set up
1690:41 - at the animal level let's go back and
1690:43 - look at our inheritance hierarchy here
1690:46 - you see this is our animal class our
1690:49 - virtual method is going to be breathed
1690:51 - because any kind of animal we have is
1690:53 - going to need to breathe but the run
1690:55 - method is set up at the feline level so
1690:59 - if we try and store an an animal in a
1691:02 - setup that uses filing polymorphism the
1691:06 - run method is not going to be available
1691:08 - and we're going to get a compiler error
1691:09 - so i want you to know this but we will
1691:11 - also see this in a minute when we hit
1691:13 - visual studio code to really play with
1691:15 - us okay we can also do bird polymorphism
1691:18 - and here you see we have two objects one
1691:20 - is a pigeon the other is a crow
1691:23 - and we're going to do bird polymorphism
1691:25 - here and what that means is that we will
1691:28 - use a bird pointer to manage all kinds
1691:31 - of crazy birds in our c plus plus
1691:33 - program for example we can use that to
1691:35 - manage a pigeon we can use that to
1691:37 - manage a crow and if we loop through our
1691:40 - birds and call the fly method the most
1691:43 - specific fly method is going to be
1691:45 - called in this case at the first
1691:47 - iteration we're going to call the fly
1691:49 - method on our pigeon object at the
1691:52 - second iteration we're going to call the
1691:53 - fly method on our crawl object here and
1691:57 - this is going to work now that you know
1691:59 - this we're going to head over to visual
1692:01 - studio code and play with this a little
1692:02 - more here we are in our working folder
1692:06 - the current project is polymorphism at
1692:08 - different levels we're going to grab our
1692:11 - template files let's grab it all we're
1692:13 - going to copy this and put this in our
1692:16 - current project
1692:17 - and we're going to open this little guy
1692:19 - in visual studio code like we always do
1692:22 - and before we open this up i am going to
1692:24 - put in the classes i have lying around
1692:27 - on my drive and these are going to be
1692:29 - the classes making up our inheritance
1692:32 - hierarchy here to make things go faster
1692:36 - if you want you can grab these classes
1692:38 - from the attached resource section on
1692:40 - this lecture you're going to find all
1692:42 - these files you can download them and
1692:44 - put them in your project and use that as
1692:46 - a starting point because you don't
1692:48 - really want to be creating all these
1692:50 - classes this is going to just waste your
1692:52 - time the basic idea i wanted to expose
1692:55 - here is doing polymorphism at different
1692:58 - levels so we're going to open this up in
1693:00 - visual studio code by dragging and
1693:02 - dropping here this is going to give us
1693:04 - our good starting point you see we have
1693:06 - a bunch of classes in here but all these
1693:09 - classes are really trying to set up the
1693:11 - inheritance hierarchy we have here the
1693:14 - top class is going to be the animal
1693:15 - class
1693:16 - we can derive from animal and create a
1693:19 - filler in a class
1693:20 - and we can derive from animal and also
1693:23 - create a bird class we can derive from
1693:26 - feline and create a dark we can derive
1693:28 - from feline and create a cat
1693:30 - and we can also derive from bird create
1693:32 - a pigeon we can also derive from bird
1693:34 - and create a crowd class and at each
1693:38 - level we're going to have a virtual
1693:39 - method that we set up
1693:41 - that other deriving classes can call
1693:45 - through polymorphism for example if we
1693:47 - do animal polymorphism we will get the
1693:49 - correct breathe method called regardless
1693:52 - of the actual object we are managing
1693:55 - with our animal pointer
1693:57 - if we do feline polymorphism we can
1694:00 - manage our objects through feline
1694:02 - pointers but we will get the correct run
1694:05 - method called regardless of which kind
1694:07 - of object we are calling this method on
1694:10 - so if we call the run method on a base
1694:13 - pointer managing a dog object we will
1694:15 - get the run method called on the dog
1694:18 - object this is what we mean here okay so
1694:20 - we have our classes here let's take a
1694:22 - closer look at our animal class it is
1694:25 - our top level class and it is going to
1694:27 - have a virtual method which is called
1694:30 - breathe it is caused because it is not
1694:32 - modifying our class here notice that we
1694:35 - don't have a virtual destructor because
1694:37 - i wanted to keep this simple but in your
1694:40 - practical object you should make your
1694:42 - destructors virtual if you happen to
1694:45 - have a virtual function in your class
1694:47 - here so for example we can even do that
1694:49 - let's make this virtual this is not
1694:51 - going to cost us anything
1694:53 - and
1694:54 - this is going to be our top class we
1694:56 - cannot look at the implementation file
1694:59 - it is not going to do anything special
1695:01 - it is just going to forward whatever
1695:03 - parameter we pass and use that to
1695:05 - initialize our member variable i think
1695:07 - we can also go in and change our
1695:10 - parameter to a string view so we can do
1695:13 - that hdd string view let's go in the cpp
1695:16 - file and also change that pretty quick
1695:18 - we're going to say std string view here
1695:21 - and this is our animal class we're going
1695:23 - to go in our feline class because that's
1695:26 - the deriving class
1695:28 - feline is going to be inheriting from
1695:30 - animal publicly just as we see here
1695:34 - we're not going to really do anything
1695:35 - special we're going to set up a member
1695:37 - variable called fur style
1695:39 - and we're going to forward the data from
1695:41 - our constructor and use that to
1695:43 - initialize stuff in our class here our
1695:46 - parameters are also going to be passed
1695:48 - as std string view types so let's do
1695:51 - that here and this is in place we also
1695:54 - have a virtual method which is called
1695:57 - run and inside we are just printing
1696:00 - which kind of object we have
1696:02 - and uh giving a hint on the method that
1696:05 - is being called here this is what we
1696:06 - just do here and we don't intend to
1696:09 - create feline objects directly that's
1696:12 - why we're not setting up any overrides
1696:15 - of the top that's why we are not setting
1696:18 - up any direct specific
1696:20 - overrides for these methods but we will
1696:22 - do that in downstream classes for
1696:24 - example dog and cat because that's going
1696:26 - to make sense there let's go in the cpp
1696:28 - file for feline and also change things a
1696:31 - little bit we're going to use std string
1696:33 - view parameters let's do that for the
1696:35 - second parameter as well and this is our
1696:38 - filling class so we can go in and look
1696:41 - at our dog class let's see if we can
1696:43 - find it and i don't think we made our
1696:46 - destructor in feline a virtual so let's
1696:48 - do that and look at our delta class
1696:51 - pretty quick here we have our dog it's
1696:53 - going to have no member variable at all
1696:56 - and it will just forward this data to
1696:59 - upstream classes but we can override our
1697:02 - breathe method we get from the animal
1697:05 - class we can do that and we are going to
1697:08 - say we can grab this entire thing and
1697:11 - we're going to go in dark we can do that
1697:13 - if we want we're going to put this
1697:14 - method down below here and we're going
1697:16 - to say breathe we're going to say that
1697:18 - this is overriding what we have on top
1697:21 - and we're going to say dog breathe
1697:23 - called this is going to do and we also
1697:26 - need to change our parameters to hdd
1697:29 - strength view let's do that this is
1697:32 - going to make things work better because
1697:34 - we will avoid unnecessary copies and we
1697:37 - will be able to pass string literals as
1697:40 - parameters to this constructor here this
1697:42 - is what we want to achieve with us we
1697:44 - can hit the cpp file for a dog class and
1697:47 - we're going to
1697:48 - change the parameters again std string
1697:51 - view and we're going to say std string
1697:54 - view as well here and we're going to go
1697:55 - to the header file again and make sure
1697:58 - we have a virtual destructor here
1698:00 - because this is good practice if you are
1698:02 - using virtual functions like we are
1698:04 - doing here we can grab our breathe
1698:06 - method and hop over to our cat class
1698:09 - again remember the inheritance hierarchy
1698:12 - we are going after is what we have here
1698:15 - so if you are confused please come back
1698:17 - and look at this you're going to really
1698:18 - understand what we are doing here we're
1698:20 - going to go to the dog class and make
1698:22 - sure it is working as we want so we just
1698:25 - did the dog class and we just made sure
1698:28 - it works like we want now we're going to
1698:30 - hop over to cat and make sure it is now
1698:32 - we're going to hop over to the cat class
1698:34 - and make sure it is overriding the brief
1698:37 - method to make sure the correct method
1698:40 - is called okay so let's do that we're
1698:42 - going to hop over to our cat class it is
1698:44 - going to
1698:46 - have its own meow method but it can also
1698:49 - override the breathe method we get from
1698:52 - the animal class so let's do that we can
1698:54 - grab this
1698:55 - and we can go to our cat class let's do
1698:58 - that we're going to put in our virtual
1699:00 - method and we're going to say cat
1699:02 - breathe and this is really all we also
1699:05 - need to set up our parameters correctly
1699:08 - using std string view let's do this std
1699:11 - string view and this is really all we
1699:14 - need to do here we can also make our
1699:16 - destructor virtual because this is good
1699:18 - practice we hop over in the cpp file and
1699:21 - change our parameters to be of type std
1699:24 - string view let's do this and this is
1699:27 - done we can really work with this
1699:28 - inheritance hierarchy here we're going
1699:31 - to also go pretty fast and work on the
1699:34 - other side of our inheritance hierarchy
1699:36 - we're going to work on birds let's look
1699:39 - at the bird class it is going to inherit
1699:41 - from animal it is not going to do
1699:44 - anything special really but we just want
1699:45 - to change the type of our parameters to
1699:48 - std string view and i'm going to do that
1699:50 - on the second parameter and we are going
1699:53 - to hop over in the cpp file and change
1699:55 - these things here let's do that we're
1699:57 - going to say std string view and do the
1700:00 - same thing here std string view and bird
1700:04 - is done we can grab our breathe method
1700:06 - for example let's go back to the top and
1700:09 - grab that from our animal class and
1700:12 - we're going to hop over to one kind of
1700:14 - bird we have in our program we can look
1700:16 - at
1700:17 - pigeon for example the last class here
1700:19 - we're going to override the breathe
1700:21 - method and i'm going to say pigeon
1700:24 - breathe and we are going to change the
1700:26 - type of our parameters here to std
1700:28 - string view and i'm going to do the same
1700:30 - here and let's hop over to the cpp file
1700:34 - and change the type of our parameter
1700:36 - let's do that for the second parameter
1700:38 - here this is done let's look at the
1700:41 - second kind of bird we have i think we
1700:44 - have the crow class we also want to
1700:48 - override the breathe method we're going
1700:50 - to say crow breathe and we can go up and
1700:54 - change our parameter to be of type std
1700:57 - string view and we're going to do that
1700:59 - here again if you are not interested in
1701:02 - these changes you can just grab the code
1701:04 - and you're going to have all these
1701:06 - classes ready for use i just wanted to
1701:08 - correct this little problem i had in my
1701:10 - classes on my drive because this is not
1701:13 - good to design in modern c plus plus we
1701:15 - wanted to do things proper because we
1701:17 - are really learning about modern c plus
1701:19 - plus here let's hop over to the cpp file
1701:22 - and finish this up we're going to change
1701:24 - the type to hdd stream view and uh let's
1701:28 - use view correctly and we're going to
1701:30 - say std string view on the second
1701:32 - parameter and this is done now we have
1701:35 - our inheritance hierarchy and we're
1701:37 - going to start by looking at animal
1701:40 - polymorphism again we just set up this
1701:42 - inheritance hierarchy now we are going
1701:45 - to try and do animal polymorphism okay
1701:48 - so now we're going to hop over to the
1701:50 - main cpp file and we are going to clean
1701:53 - it up a little bit remove whatever it is
1701:55 - we don't need we are going to put in our
1701:58 - includes we're going to include all of
1702:00 - the fans in our file here animal feline
1702:04 - dog cat bird pigeon and crow we're going
1702:06 - to include all this and we just want to
1702:09 - play with animal polymorphism here we
1702:12 - are going to set up a bunch of objects
1702:14 - and we're going to put in dog cat pigeon
1702:17 - and crow all kinds of crazy animals we
1702:19 - can create in our c plus plus program
1702:21 - and we're going to put them in an array
1702:24 - that is storing animal pointer and this
1702:27 - animal pointer is going to
1702:29 - enable polymorphism for our objects that
1702:32 - we have in here remember animal sets up
1702:35 - a virtual method called draw if we go
1702:38 - back we're going to find that and we
1702:40 - made sure to override this method in all
1702:43 - kinds of crazy animals we can create for
1702:45 - example in our cat we have a breathe
1702:47 - method overridden in our dog class we
1702:50 - have the breathe method overridden and
1702:53 - what we want to achieve in our main cpp
1702:56 - file let's go there if i can find it we
1702:59 - want to achieve a setup so that if we
1703:02 - call the breathe method we're going to
1703:04 - call the most specific breathe method on
1703:06 - our animal pointer here even if we are
1703:09 - calling that method on a base pointer
1703:11 - this is what we want to achieve this is
1703:13 - going to be animal polymorphism because
1703:16 - the base pointer is of animal type this
1703:19 - is what we mean here let's try and build
1703:21 - this program so if we look and call the
1703:23 - breathe method the correct breathe
1703:25 - method is going to be called and what we
1703:27 - expect for the first object which is a
1703:29 - dark object we're going to get the dark
1703:31 - breathe method called for the second
1703:34 - iteration the category breathe method is
1703:36 - going to be called for the third
1703:38 - for the third iteration the pigeon
1703:41 - breath method is going to be called for
1703:43 - the last iteration the
1703:45 - crow breathe method is going to be
1703:47 - called this is what we expect to see
1703:49 - if we run this program here so let's do
1703:52 - this we're going to pass this through
1703:53 - gcc our favorite compiler we can use any
1703:57 - compiler we want but gcc is going to do
1703:59 - in this case okay the build is good we
1704:02 - can bring up a powershell window to play
1704:04 - with and we're going to run rooster our
1704:06 - program and if we run this you're going
1704:09 - to see that in our loop the first
1704:11 - iteration is going to call dog breathe
1704:13 - because the first object is a dog the
1704:16 - second iteration is going to call cat
1704:18 - breathe because the second object is a
1704:19 - cat
1704:20 - the third iteration is going to call
1704:22 - pigeon breathe because the third object
1704:24 - is a pigeon and the last iteration is
1704:26 - going to call crow breathe because the
1704:29 - last object is a crow and notice that we
1704:31 - are calling the breathe method through a
1704:34 - base animal pointer and this is what
1704:36 - polymorphism is all about and what we
1704:39 - are doing here is animal polymorphism
1704:41 - but this is not what we are really after
1704:44 - in this lecture we want to see that we
1704:46 - can also do
1704:48 - feline and
1704:50 - bird polymorphism in our inheritance
1704:52 - hierarchy so we're going to put in a
1704:55 - separator let's do sddc out and put in a
1704:58 - bunch of dashes here or hyphens some
1705:00 - people call them like that doesn't
1705:02 - really matter and we're going to play
1705:05 - with feline polymorphism let's do this
1705:08 - we are going to go down and put in a
1705:10 - simple piece of coat that we're going to
1705:12 - be using to play with things here and
1705:15 - we're going to set up a bunch of objects
1705:16 - we have a dog we have a cat we have a
1705:18 - pigeon and we are going to use a feline
1705:22 - pointer to manage feline derived objects
1705:26 - for example we're going to use this
1705:27 - pointer to manage a dog and a cat but
1705:30 - one thing i want you to see is that if
1705:31 - you put in a pigeon for example this is
1705:34 - not going to work because a pigeon is
1705:36 - not a feline so the compiler is going to
1705:39 - give you a compiler error let's try and
1705:41 - do that we're going to try and put in
1705:43 - pigeon here pigeon 2 you can select this
1705:46 - and if we do that you're going to see
1705:47 - that we get a squeaky line this is the
1705:50 - sign that this is going to go wrong
1705:51 - because
1705:53 - we are storing in felines and the pigeon
1705:55 - is really not a feline even by our
1705:58 - inheritance hierarchy so the compiler is
1706:01 - going to give us a compiler error let's
1706:02 - try and weld to show you the compiler
1706:04 - error okay the world finished with
1706:07 - errors and if we go and we're going to
1706:09 - find that cannot convert pigeon to feed
1706:12 - line pointer so this is the error here
1706:14 - you can't do something like this even if
1706:16 - you create an animal object let's say
1706:19 - that we're going to go in and create
1706:21 - animal and we're going to say animal one
1706:23 - we can do that and we're going to pass
1706:25 - in the description i think we can do
1706:27 - that we can do something like this and
1706:30 - if we try and pass in the address of
1706:32 - animal one let's do that this is also
1706:34 - going to give us a compiler error
1706:36 - because animal is not a feline again if
1706:40 - you get confused come back and look at
1706:42 - our inheritance hierarchy here
1706:45 - what we are setting up in our code we
1706:47 - are using feline polymorphism but we
1706:50 - want to store an animal in a raid that
1706:53 - is storing felines and this is going to
1706:56 - be a problem because the compiler isn't
1706:59 - really going to be able to process this
1707:01 - our base pointer is a feline and we
1707:03 - should really be able to only store in
1707:06 - derived types from feline but we are
1707:09 - putting in a superclass or a parent
1707:11 - class of feline
1707:13 - which will not be able to have these
1707:16 - specializations that feline is doing so
1707:19 - the compiler is really saying this is
1707:20 - crazy i can't do this i am going to
1707:22 - throw a compiler error this is the
1707:24 - behavior we get here okay so this is
1707:26 - going to give us a compiler error and
1707:28 - let's run and see that we're going to
1707:30 - use gcc the book is going to finish with
1707:32 - an error and we are going to see that we
1707:34 - have an invalid conversion from animal
1707:37 - pointer to filament pointer this is what
1707:39 - we want to do here we want to convert an
1707:41 - animal pointer and store that in a slot
1707:45 - that is only supposed to store feline
1707:48 - pointers so this is not going to work
1707:50 - but if you do everything right and only
1707:52 - put in
1707:54 - derived types of feline you're going to
1707:56 - get the correct length to work and let's
1707:59 - look at our dog class let's open it
1708:02 - again we're going to look at dog and
1708:04 - we're going to have a run method but we
1708:07 - don't have that set up for our dog class
1708:10 - but we can do that pretty quick let's
1708:12 - look at cat and see if we have a run
1708:14 - method we don't but we can set that up
1708:16 - let's go to feline and copy our virtual
1708:19 - function we can do that
1708:21 - and we are going to go in dog
1708:24 - and set up another virtual method which
1708:26 - is going to be
1708:28 - run and this is going to be an override
1708:30 - of what we have in our inheritance
1708:33 - hierarchy so this is an override method
1708:35 - we are also going to do the same but
1708:38 - before we go let's say that this is the
1708:40 - dog class we are doing thanks from
1708:42 - we are going to grab this method again
1708:44 - and go in cat because that's another
1708:46 - feline we have in our program we can do
1708:49 - something like this and we're going to
1708:51 - say cat here
1708:53 - okay so now let's come back to maine
1708:56 - and we're going to weld again we're
1708:58 - going to pass this through gcc and we
1709:00 - still have a pigeon in here so this is
1709:03 - not good let's check this out
1709:05 - make sure that we only have a few lines
1709:07 - in this array here let's build again
1709:10 - okay you see the bolt is good
1709:12 - we can clear
1709:14 - and run rooster we're going to have our
1709:16 - separator here and you're going to see
1709:18 - that we are calling our dog method at
1709:20 - the first iteration because the first
1709:22 - object is a dog and we are calling a cat
1709:26 - running method because the second object
1709:28 - is a cat and this is filing polymorphism
1709:32 - in action hopefully this proves to you
1709:34 - that we can do polymorphism at different
1709:37 - levels depending on what we want to
1709:39 - achieve in our c plus plus program to
1709:42 - close off this lecture we are also going
1709:44 - to set up bird polymorphism let's do
1709:47 - that we're going to put in a separator
1709:49 - and we're going to say vertical demod
1709:51 - present and we are going to put in a
1709:53 - bunch of objects and set up a base
1709:56 - pointer
1709:57 - array which is going to be a bird
1709:59 - pointer array in this case and we're
1710:01 - going to be storing in derived objects
1710:03 - of the base pointer type so we are going
1710:06 - to be storing any derived objects of
1710:08 - bird and we have a pigeon and a crow and
1710:11 - this is the setup we want here now let's
1710:13 - go and look at the setup we have in our
1710:17 - pigeon for example we don't have a fly
1710:19 - method we just have a cool method
1710:21 - because the pigeon coos
1710:23 - if we go in our crow we're going to see
1710:26 - that we don't have
1710:27 - fly method we're just having the cow
1710:30 - method because the crowd calls
1710:32 - but if we call our fly method because we
1710:36 - don't have this method overridden in any
1710:38 - downstream classes of bird
1710:41 - we will get the
1710:42 - base
1710:43 - version of the fly method called so we
1710:46 - will get this method here
1710:48 - called i want you to see this let's hop
1710:50 - over to the main cpp file and make sure
1710:52 - we have the correct setup looks like
1710:54 - this is what we want we're going to
1710:56 - build this with gcc the book is going to
1710:59 - be good as we see here and we're going
1711:01 - to run now we're going to see bird fly
1711:04 - bird fly for pigeon one and crow one
1711:07 - but this is not using any derived method
1711:11 - that we have in our crow
1711:14 - and a pigeon class if you want you can
1711:16 - also override the
1711:18 - fly method and you're going to get that
1711:20 - called let's actually do that because
1711:22 - i'd like to show you things directly so
1711:25 - that you can really see with your own
1711:26 - eyes so we're going to go in bird and
1711:29 - grab the fly method and we're going to
1711:31 - override this in pigeon we can do that
1711:34 - and we're going to override here and we
1711:37 - are going to say pigeon here and we can
1711:40 - grab this and i put this method also in
1711:43 - the crowd class can do that and we're
1711:46 - going to say crow here now if we run
1711:49 - this program
1711:51 - using what we have in the main cpp file
1711:53 - for the first iteration we're going to
1711:55 - call the fly method on the pigeon object
1711:57 - because we have the fly method
1711:59 - overwritten at the pigeon level
1712:02 - as we see here this is right here
1712:03 - beneath our eyes and we're going to see
1712:05 - this in action if we run this program
1712:08 - here the same is going to happen for the
1712:10 - crow object here let's build with gcc to
1712:13 - really prove this the builder is going
1712:15 - to go through we can clear and run
1712:17 - rooster and we're going to see pigeon
1712:18 - fly crowd fly this is proving what we
1712:21 - set up in this lecture here this is
1712:23 - really all i had to share i hope you
1712:25 - found this interesting the main message
1712:27 - is that you can set up polymorphism at
1712:30 - different levels in your inheritance
1712:32 - hierarchy depending on what you want to
1712:35 - achieve in your c plus plus program we
1712:37 - saw that we could do the usual thing and
1712:39 - use the top level class
1712:41 - as the driver for our polymorphism and
1712:44 - we did animal polymorphism here but
1712:47 - nothing prevents you from doing feline
1712:49 - polymorphism or bird polymorphism as we
1712:52 - saw in this lecture we are going to stop
1712:55 - here in this one in the next one we're
1712:56 - going to see how we can do polymorphism
1712:59 - with static members
1713:01 - go ahead and finish up here and make me
1713:03 - there in this lecture we're going to
1713:05 - explore how inheritance and polymorphism
1713:08 - play out with static members that we
1713:11 - have in our classes and we're going to
1713:14 - be using this inheritance hierarchy here
1713:17 - our base class is going to be shape
1713:18 - we're going to inherit from that and
1713:21 - create an ellipse class let's look at
1713:23 - some code here so we're going to set up
1713:25 - our base class as shape as we said and
1713:28 - we're going to have one member variable
1713:31 - which is going to be our description
1713:33 - here we're going to have a constructor
1713:35 - and a destructor
1713:36 - and we're going to have a default
1713:37 - constructor which is really not
1713:39 - important here but notice that we have a
1713:41 - static member which is called m count
1713:45 - and if you remember a static member
1713:47 - variable
1713:48 - is a kind of variable which is
1713:50 - associated with the type itself it's not
1713:53 - associated with any object that you
1713:56 - create if you forgot this please go back
1713:58 - to our chapter on classes or user
1714:01 - defined types you're going to learn all
1714:03 - about static variables here we are just
1714:05 - exploring how they play out with
1714:08 - inheritance and polymorphism now we have
1714:11 - a shape class if we inherit from it and
1714:13 - create an ellipse class for example
1714:16 - we're going to have all the data that
1714:18 - was public in our base class to be
1714:21 - public in this class as well so by that
1714:23 - logic we are also going to get this
1714:25 - static variable inherited and we're
1714:27 - going to be able to access it from
1714:30 - ellipse objects let's try and use this
1714:32 - in code here to really drive the point
1714:34 - home here we are creating a batch of
1714:37 - shape objects here is our first shape we
1714:39 - print our static variable through this
1714:42 - syntax here because it is public we can
1714:44 - do this we're going to get a one because
1714:46 - we just have one shape here we create a
1714:48 - second shape and we print the count
1714:50 - we're going to get two because we just
1714:52 - have two shapes in here we create our
1714:55 - third shape and we try and print the
1714:57 - count we're going to get three and if
1714:59 - you wonder how we are incrementing this
1715:01 - static variable we may do this in our
1715:04 - constructor we're going to see how this
1715:05 - works exactly once we hit visual studio
1715:07 - code in a minute but note that every
1715:09 - time we create an object we're going to
1715:11 - be incrementing our static variable
1715:13 - that's why we see one two three as we
1715:16 - created these objects here this is the
1715:18 - logic now we have three shapes here we
1715:21 - go down and create a new object which is
1715:23 - of ellipse type if we print the shape
1715:26 - count we're going to get four because an
1715:28 - ellipse is a shape and ellipse is
1715:31 - inheriting the static variable from
1715:33 - shape so we're going to get a 4 printed
1715:35 - out here but if we also print ellipse
1715:39 - count we're going to get a 4
1715:41 - even if we really just have one ellipse
1715:44 - so the static variable from shape is
1715:46 - being inherited and used in our ellipse
1715:49 - class and this may not be
1715:52 - what we want so
1715:53 - the problem here is that the static
1715:55 - variable we are using in shape and
1715:57 - ellipse are the same because the one we
1716:00 - have in ellipse was inherited from shape
1716:03 - that's why we have these results here
1716:05 - but sometimes we just want to have
1716:08 - ellipse count to b1 here because in
1716:11 - reality we really have one ellipse so
1716:13 - how do we do that to get that behavior
1716:16 - you can also set up another static
1716:18 - variable named exactly the same way at
1716:20 - the ellipse level and you can do that
1716:23 - like this you can also override the gate
1716:25 - count method to return the current count
1716:28 - in ellipse this is going to work through
1716:30 - polymorphism because the getcount method
1716:32 - is a virtual function
1716:34 - if you call this method through a
1716:36 - basepointer you will get the correct one
1716:38 - called which is going to be the most
1716:40 - specific one through polymorphism but
1716:43 - what we want to see is how
1716:45 - things are going to work now that we
1716:47 - have a static variable which is named
1716:50 - exactly the same as the one we have in
1716:53 - our base class here the one in shape is
1716:56 - exactly named m count it is a static
1716:58 - variable of type and the one we have in
1717:01 - ellipse is also the same it is a static
1717:04 - variable called m count of type and but
1717:07 - now
1717:08 - ellipse is going to maintain its own
1717:10 - static variable and shape is going to
1717:12 - maintain its own static variable now we
1717:15 - are going to get this kind of behavior
1717:17 - we are going to see that if we try and
1717:20 - print the count of shapes we have we're
1717:22 - going to get a four here but now if we
1717:24 - try and print the count from ellipse
1717:27 - we're going to get a one because we
1717:28 - already have one ellipse and this is
1717:31 - working because ellipse is going to
1717:33 - maintain its own
1717:35 - static variable and this is going to
1717:37 - give you this behavior if it is what we
1717:39 - are after in our c plus plus program now
1717:42 - we can also go on and create a bunch of
1717:44 - other objects here we are going to store
1717:46 - them in this array which is going to be
1717:48 - storing shared pointers to shape
1717:51 - and we're going to store in derived
1717:53 - objects this is the syntax we can use to
1717:55 - do this and at the moment we do this
1717:58 - we're going to get six shapes because
1718:01 - in total we already have six shapes but
1718:03 - three of those shapes are going to be
1718:05 - ellipses and if we try to print the
1718:07 - ellipse count we're going to see that we
1718:09 - have three ellipses in our c plus plus
1718:12 - program and this is going to do
1718:14 - what we want another thing you could do
1718:16 - is also do shape polymorphism and call
1718:20 - the gatecount method and you're going to
1718:22 - get the correct getcount method and
1718:24 - print the most specific account if we
1718:27 - are calling that method on an ellipse
1718:29 - object for example we're going to print
1718:31 - three if we call that on a shape object
1718:33 - we're going to get sex and that's the
1718:35 - behavior we could achieve with
1718:37 - polymorphism with static member
1718:39 - variables and i really want you to be
1718:41 - aware of this now that you know this
1718:43 - we're going to head over to visual
1718:44 - studio code and play with us a little
1718:46 - more here we are in our working folder
1718:49 - the current project is inheritance and
1718:52 - polymorphism with static members we're
1718:54 - going to grab our template files and put
1718:57 - them in place and i am going to grab our
1719:00 - classes from my drive and use this as
1719:03 - the starting point again if you don't
1719:05 - want to type or create these classes you
1719:08 - can use the files provided in the
1719:10 - resource section of this lecture you can
1719:12 - download them and use them directly
1719:14 - without having to create them because we
1719:16 - are really interested in how static
1719:18 - members behave with our inheritance
1719:22 - hierarchy which happens to be setting up
1719:24 - polymorphism this is what we want to
1719:26 - learn about here i am going to open this
1719:28 - up in visual studio code and we're going
1719:30 - to take a good look at our classes the
1719:32 - base class is going to be shape which is
1719:34 - what we have here it's going to have a
1719:37 - virtual method which is get count here
1719:39 - and we have a static member which is of
1719:42 - type and
1719:44 - i am going to change my parameter here
1719:46 - to bsdd string view
1719:48 - because that's what we should do in
1719:50 - modern c plus plus let's look at the cpp
1719:52 - file for this and we're going to fix
1719:55 - this a little bit and we're going to hop
1719:57 - over back to the header file and look at
1719:59 - what we have we have a virtual method
1720:01 - which is going to return this count here
1720:03 - it is a const method because it's really
1720:05 - not going to modify it's just going to
1720:07 - return a copy of the count member
1720:09 - variable we have here
1720:10 - and this is a static member variable
1720:12 - notice that it is not in line so we will
1720:16 - need to define this in the cpp file
1720:18 - somewhere because this is a declaration
1720:21 - we need to put in a definition which is
1720:24 - what we have in our cpp file here
1720:26 - because we are doing thanks in the older
1720:28 - c plus plus way we are going to
1720:31 - increment our account member variable in
1720:34 - our constructor and this is going to
1720:36 - achieve the behavior we really want to
1720:39 - have the m count member variable which
1720:41 - is static incremented each time we'll
1720:43 - create a shape object here let's go back
1720:46 - and look at our destructor and make sure
1720:49 - that it is virtual because we have
1720:51 - virtual functions in this class and this
1720:53 - is the setup we have let's look at
1720:55 - ellipse and we're going to take out this
1720:58 - static member variable because
1721:00 - we don't want to set it up as of now we
1721:03 - will enable it in a minute let's make
1721:05 - sure we remove this
1721:07 - and
1721:08 - let's remove this because i don't want
1721:10 - this and now we can try to create
1721:13 - objects of our classes and see how these
1721:16 - guys play out we can also go in ellipse
1721:19 - and make sure the constructor is taken
1721:22 - std string views where we are needing
1721:25 - strings you can do that and hop over to
1721:28 - the cpp file and do that std string view
1721:31 - i think this is going to make a visual
1721:33 - studio code happy by now
1721:35 - we can hop over to the main cpp file and
1721:37 - clean it up a little bit and we are
1721:40 - going to
1721:42 - include ellipse and in our main function
1721:45 - we're going to create a bunch of objects
1721:47 - let's close the left sidebar here
1721:49 - because we don't really need that
1721:51 - anymore we're going to grab a shape
1721:53 - object and we're going to print the
1721:54 - shape count we expect to get a one
1721:56 - because we just have one shape at this
1721:59 - moment we're going to create a second
1722:01 - shape here and if we print the count
1722:03 - we're going to get two because we have
1722:05 - two shapes this is what we expect we
1722:07 - create another shape which is going to
1722:09 - be shape three here we print the count
1722:11 - we're going to get a three but the
1722:12 - problem is going to come when we create
1722:14 - an ellipse here if we create an ellipse
1722:17 - and print the count we're going to get a
1722:18 - four because we have four shapes in our
1722:21 - c plus plus program but if we print the
1722:23 - ellipse count here we expect to get a
1722:26 - one but that's not what we're going to
1722:28 - get we're going to get a 4 because the m
1722:30 - count variable in ellipse is inherited
1722:34 - from our shape class so it is going to
1722:36 - be the same thing we have in shape here
1722:38 - because if you go back you're going to
1722:39 - see that at this point ellipse doesn't
1722:42 - have a static variable m count of its
1722:45 - own so it's going to use the one it is
1722:47 - inheritance from the shape class this is
1722:50 - the behavior we're going to get here and
1722:52 - i want you to be aware of this if this
1722:54 - is what you want this is fine but in
1722:56 - most cases you will want this to be
1722:58 - different because you want very clear
1723:01 - information about how many objects of
1723:04 - each type you have created in your
1723:05 - z-plus plus program if it is just shaped
1723:08 - this is going to be really vague because
1723:10 - you want to know if it is an ellipse if
1723:12 - it is a rectangle if it is a triangle
1723:14 - this is not going to be super clear so
1723:16 - let's weld and really show you the
1723:18 - problem here we're going to pass this
1723:19 - through gcc our favorite compiler we can
1723:22 - also bring up the left sidebar no
1723:24 - problem here and we're going to bring up
1723:26 - a terminal window or a powershell window
1723:28 - i can say
1723:30 - we're going to clear
1723:31 - and run rooster you're going to see that
1723:33 - the shape count is going to be one two
1723:36 - three
1723:37 - and we have a five here
1723:39 - because we are also incrementing the m
1723:42 - count variable in our derived class so
1723:44 - we are incrementing twice if we create
1723:47 - an ellipse object let's show you this in
1723:50 - ellipse cpp we are incrementing the m
1723:52 - count member variable but in the base
1723:55 - class we are also implementing that in
1723:58 - the cpp file that's what we have here
1724:00 - and notice that the derived class is
1724:03 - also calling the base class
1724:06 - through our initializer lust here so
1724:08 - this is the behavior we have we
1724:10 - shouldn't be incrementing this because
1724:13 - ellipse doesn't have its own static
1724:15 - variable as of now now we're going to
1724:18 - build and really solve this problem now
1724:20 - you see the kinds of problems you can
1724:22 - run into if you have a static variable
1724:24 - that is named exactly the same way and
1724:27 - you have an inheritance hierarchy
1724:29 - really weird problems can pop up and you
1724:31 - need to be aware of this let's build and
1724:34 - see that the problem actually
1724:36 - disappeared okay the bolt is good we can
1724:38 - clear
1724:39 - and run rooster we're going to see that
1724:41 - now this is what we expect one two three
1724:43 - because we have three shapes created up
1724:46 - to this point here if we create an
1724:48 - ellipse that's going to be another shape
1724:50 - if we get the shape count we're going to
1724:51 - get a 4 but ellipse count is also giving
1724:54 - us a 4 because ellipse doesn't have its
1724:57 - own static variable to solve this
1724:59 - problem we can go to ellipse and set up
1725:01 - our own member variable at the ellipse
1725:03 - level so we can enable this and
1725:06 - uncomment it we're going to go to the
1725:08 - cpp file and make sure we are
1725:10 - incrementing to get the correct count
1725:12 - incremented here i think this is all we
1725:15 - need to do we are also going to
1725:17 - initialize the static variable we have
1725:19 - at the ellipse level this is going to do
1725:22 - what we want and we can build again now
1725:24 - we're going to get the behavior we want
1725:27 - because at this point we are going to
1725:29 - print a one
1725:30 - for the ellipse count and this really
1725:32 - makes sense because we have one ellipse
1725:35 - even if we have four shapes in total so
1725:38 - this is the design i think
1725:40 - makes more sense in our c plus plus
1725:43 - program here we are going to build this
1725:46 - again and pass this through gcc the
1725:48 - builder is going to be good we can clear
1725:51 - and run rooster now we're going to see
1725:52 - that we have four shapes and one ellipse
1725:55 - this is what we want now that we have
1725:57 - this we can really do all kinds of crazy
1725:59 - things hopefully you can see that the
1726:01 - static variable is working exactly as we
1726:04 - want we can print the ellipse count we
1726:06 - can print the shape count if that's what
1726:08 - we want in our c plus plus program but
1726:11 - we can also do shape
1726:12 - polymorphism and get the correct get
1726:15 - count method called in our c plus first
1726:18 - program for example if we call the
1726:20 - getcount method on the basepointer that
1726:23 - is managing a shape we're going to get
1726:25 - this one called if we have a best
1726:27 - pointer that is managing an ellipse
1726:29 - we're going to get to this one called
1726:30 - this is going to be super cool let's go
1726:33 - up in our program and set this up we're
1726:35 - going to do this on the fly let's say
1726:37 - shape polymorphism and we're going to
1726:40 - say shift pointer and it is going to be
1726:42 - an array let's say shapes this is going
1726:45 - to do and it is going to be just an
1726:46 - array and we're going to initialize this
1726:48 - and store in a bunch of objects let's
1726:51 - put in a closing brace here let's go up
1726:54 - and see what we have for example we have
1726:56 - shape one and ellipse one we can use
1726:59 - these we're going to put in the address
1727:00 - of shape one and we're going to put in
1727:02 - the address of ellipse one this is going
1727:04 - to do
1727:05 - and we can loop through these guys and
1727:07 - call the get count method so let's do
1727:09 - this we're going to say for auto s
1727:12 - and let's do a reference because we
1727:14 - don't want copies and we're going to say
1727:17 - in shapes and we're going to call the
1727:19 - gatecount method we're going to say s
1727:21 - and say getcount this is going to
1727:24 - give us the count and we can print this
1727:26 - out if we want we can say sddc out and
1727:29 - count and we're going to
1727:31 - put a new line character here to
1727:33 - separate these guys
1727:35 - and we can
1727:37 - put a separator here we can copy what we
1727:39 - just used in our c plus plus program
1727:41 - here just to make sure this is super
1727:43 - clear when we print things on the
1727:46 - terminal here we're going to build our
1727:47 - program and see if it actually works the
1727:51 - body is going to be good we can clear
1727:52 - and run rooster we're going to see that
1727:55 - the count is going to be 4 for the first
1727:57 - iteration because we're going to be
1727:59 - calling the get count method from
1728:01 - shape because that's our base pointer so
1728:04 - this is what we're going to get we're
1728:06 - going to print the m count member
1728:08 - variable from the base class that's why
1728:10 - we have a four but on the second
1728:13 - iteration the object is ellipse and we
1728:16 - are using polymorphism because we are
1728:18 - going through a base pointer and this
1728:20 - base pointer happens to support the
1728:23 - virtual method get count we will get the
1728:25 - most specific one called on the current
1728:28 - object that our base pointer is managing
1728:31 - here and this happens to be an ellipse
1728:33 - so we're going to call the ellipse
1728:35 - version of our virtual function here and
1728:37 - we will get a one because we really have
1728:40 - one ellipse in our c plus plus program
1728:42 - this is what we see here this is really
1728:44 - all i wanted you to see in this lecture
1728:47 - how you can use
1728:48 - static member variables with inheritance
1728:50 - and polymorphism and you need to be
1728:53 - aware of these little things that can
1728:55 - really be confusing especially for
1728:57 - beginners we are going to stop here in
1728:59 - this lecture the next one we're going to
1729:01 - learn about the final specification we
1729:04 - can use in our inheritance hierarchy go
1729:07 - ahead and finish up here and meet me
1729:09 - there
1729:11 - go ahead and finish up here and meet me
1729:13 - there in this lecture we're going to
1729:14 - learn about the final specifier used in
1729:18 - inheritance hierarchies this is going to
1729:21 - allow you to do one of two things you
1729:24 - will either be able to restrict how you
1729:26 - override methods in the derived classes
1729:30 - or you can restrict how you can derive
1729:32 - from base classes i know this is in the
1729:35 - air but we're going to look at a few
1729:37 - examples to really drive this home
1729:39 - suppose we have an inheritance hierarchy
1729:41 - like we see here the top class is animal
1729:43 - we can derive from this and have feline
1729:45 - you can have bird as a derived class
1729:47 - feline can be inherited to have a dog
1729:50 - and cat and you can derive from cat for
1729:52 - example to have wild cat and bulldog
1729:55 - from dog you can do all these things
1729:57 - here and this is inheritance hierarchy
1729:59 - we're going to be using to learn about
1730:01 - these things now here is a possible
1730:04 - implementation for the dog class which
1730:06 - is going to be inherited from feline
1730:08 - publicly as we see here but take a look
1730:11 - at the run method we are setting up in
1730:13 - dag we are appending a final specifier
1730:17 - and what this is going to mean is that
1730:20 - no downstream inheritance class will be
1730:23 - able to override the random method
1730:26 - further this is what we can achieve so
1730:28 - if we don't want our derived classes to
1730:30 - override our
1730:32 - virtual method we can mark that method
1730:35 - as final in our class and we are
1730:37 - basically saying i am going to put in my
1730:40 - implementation but i don't want any
1730:42 - deriving downstream class to override
1730:46 - this method further if they do that they
1730:48 - are going to get a compiler error and
1730:50 - this is something we can achieve using
1730:52 - the final specifier in our inheritance
1730:55 - hierarchy again in this case we are
1730:57 - using this to restrict
1731:00 - how people can override our own virtual
1731:04 - method in downstream classes or i
1731:06 - shouldn't really say our own method
1731:08 - because it may be coming from upstream
1731:11 - but you are restricting people from
1731:13 - overriding that method further in
1731:16 - downstream classes here okay so this is
1731:18 - the first use we have for the final
1731:21 - specifier but we can also restrict
1731:24 - people from inheriting altogether so
1731:27 - here we have a simple example to drive
1731:29 - this home we have our cat class it is
1731:32 - going to be inheriting from feline but
1731:34 - we are marking our cat class as final
1731:37 - and what this is going to mean if
1731:40 - anybody tries to inherit or derive from
1731:43 - cat in any way they are going to get a
1731:45 - compiler error and this is what we can
1731:47 - achieve with the final specifier again
1731:50 - there are two things you can restrict
1731:52 - how people override your virtual methods
1731:55 - if you want to restrict that from the
1731:58 - current class you can mark your virtual
1732:00 - method as final you can also restrict
1732:03 - how people inherit all together from
1732:05 - your class and if you want that behavior
1732:07 - you can mark your class as final using
1732:11 - the syntax we just saw in the slides
1732:13 - here okay now that you know these things
1732:15 - let's look at a few things that may be
1732:17 - interesting for example here is a simple
1732:20 - fact that you can create a class right
1732:22 - away in market as final and when you do
1732:25 - this nobody will be able to ever inherit
1732:28 - from this class in your program and if
1732:30 - we do this we will get a compiler error
1732:33 - for example this is one thing i find
1732:35 - interesting and i really wanted you to
1732:37 - know this another thing is that it is
1732:40 - possible to introduce useless virtual
1732:42 - methods in your inheritance hierarchy
1732:45 - for example if our cat class is marked
1732:48 - as final what this means is that nobody
1732:50 - will ever be able to inherit from this
1732:53 - class but we are going further in
1732:55 - setting up a virtual method which is
1732:57 - meant to be inherited or overwritten in
1733:00 - downstream classes but how do we get a
1733:02 - downstream class if we can't inherit
1733:05 - from the cat class which is marked final
1733:07 - so so we have conflicting ideas here on
1733:10 - one hand we are saying we can never
1733:12 - inherit from this grant class but on the
1733:15 - other hand we are setting up a method
1733:17 - that is meant to be used or specialized
1733:20 - in derived classes so this is something
1733:22 - that is interesting this code is going
1733:24 - to compile and i think maybe in future
1733:27 - standards of c plus plus they are going
1733:29 - to fix this problem and maybe give you a
1733:31 - compiler error if you try to do
1733:33 - something like this but at this point
1733:35 - you're not going to get a compiler error
1733:37 - this is just going to be valid c plus
1733:39 - plus syntax even if this is really weird
1733:41 - we have conflicting ideas here okay one
1733:44 - thing you should know though is that we
1733:47 - can override in a final class and this
1733:49 - is going to make sense because for
1733:50 - example the run method is coming from
1733:53 - the feline class
1733:55 - and here we are just specializing that
1733:57 - so we are marking that as an override
1734:00 - here even if this is the final class so
1734:03 - be careful this is valid c plus plus
1734:05 - syntax this is going to work just fine
1734:07 - another thing you can do which is pretty
1734:09 - useless in your c plus plus program is
1734:11 - to introduce a virtual method and mark
1734:14 - it as final right away so again this is
1734:18 - really weird we have two ideas that are
1734:21 - conflicting the virtual keyword means
1734:24 - that we want this to be visualized in
1734:27 - the downstream classes but again we are
1734:29 - saying this method is final so no
1734:32 - downstream class will override this if
1734:34 - they try to do that they are going to
1734:36 - get a compiler error so this is again a
1734:38 - bunch of conflicting ideas c plus plus
1734:40 - is going to allow this syntax this is
1734:42 - not going to give you a compiler error
1734:44 - but this is weird and you need to be
1734:46 - aware of this okay now that you know
1734:48 - these ideas we're going to head over to
1734:50 - visual studio code and play with the
1734:53 - final specifier in our inheritance
1734:55 - hierarchy we will be setting up this
1734:57 - kind of inheritance hierarchy and we
1735:00 - will set up a bunch of virtual methods
1735:02 - and mark them as final i think we will
1735:04 - do that in the dog class and we will
1735:07 - mark a bunch of classes as final and see
1735:10 - that if we inherit from them we're going
1735:12 - to get a bunch of compiler errors so
1735:14 - let's do this here we are in our working
1735:17 - folder the current project is final and
1735:21 - we are going to bring in our template
1735:23 - files pretty quick we're going to use
1735:24 - this as our starting point we're going
1735:27 - to put that in place
1735:29 - and i am going to put in a bunch of
1735:31 - classes i have lying around on my system
1735:34 - because i don't want to set up these
1735:36 - classes that would be a waste of your
1735:38 - time just know that we are trying to set
1735:40 - up this kind of inheritance hierarchy
1735:43 - animal is going to be our top dog or
1735:45 - animal is going to be our top class and
1735:47 - we will be inheriting from this creating
1735:50 - an inheritance hierarchy we can play
1735:52 - with in our code here okay so we are
1735:55 - going to open this up in visual studio
1735:57 - code so let's do that by dragging and
1735:59 - dropping here this is going to give us
1736:01 - all these crazy classes we have
1736:04 - the top class is going to be animal and
1736:06 - it is going to be defining the features
1736:08 - any kind of animal we support you know c
1736:10 - plus plus program is going to have for
1736:12 - example any kind of animal will need to
1736:14 - breathe and we will set up this virtual
1736:17 - method here
1736:19 - and we will be inheriting from this
1736:21 - animal class to create a feline class
1736:24 - and a bird class this is something we
1736:26 - did in a few previous lectures and we
1736:28 - are just reusing this inheritance
1736:30 - hierarchy here let's look at the feline
1736:32 - class the filament class is going to set
1736:34 - up a virtual method which is called run
1736:36 - and the method is going to be overridden
1736:39 - in the dog for example
1736:41 - we can override the run method but
1736:43 - notice that we are marking that as final
1736:47 - okay so look at this the method is final
1736:50 - and what this means is that
1736:52 - no downstream classes inheriting from
1736:55 - doug will ever be able to specialize or
1736:58 - override this method further if they try
1737:01 - to do that they will get a compiler
1737:03 - error notice that this may be our method
1737:05 - or it may be a method coming from
1737:08 - upstream classes in this case the run
1737:10 - method was introduced at the feline
1737:13 - level you see it was introduced here and
1737:16 - doug happens to be overriding this
1737:18 - method here that's why we have the
1737:21 - override key world but
1737:23 - at the same time we are going to mark it
1737:25 - as final
1737:26 - and prohibit or prevent
1737:29 - downstream classes from overriding this
1737:31 - method further if we look at our bulldog
1737:35 - class we're going to find the class to
1737:37 - inherit from dark we have our run method
1737:42 - here it is commented out at this moment
1737:44 - i just want you to see that our code is
1737:46 - just going to compile if we compile it
1737:48 - now
1737:50 - let's do this we're going to pass this
1737:51 - through gcc okay you see the bolt is
1737:54 - good and we have generated our binary
1737:56 - which is really not doing anything
1737:57 - because our main function is just some
1738:00 - dummy code we have here to make sure it
1738:02 - works with c plus plus 20 but what i
1738:05 - want you to see
1738:06 - is that if you go in bulldog let's go in
1738:09 - our bulldog class and uncomment
1738:12 - this class here or this virtual method
1738:15 - we're going to see that we're going to
1738:16 - get a compiler error we have a squiggly
1738:18 - line meaning that we did something wrong
1738:21 - and well let's look at the problems tab
1738:23 - from visual studio code here cannot
1738:26 - override find a function dog run this is
1738:29 - a final method from
1738:31 - the dog class if we try to override it
1738:33 - further we will get a compiler error
1738:36 - this is something we can achieve by
1738:38 - marking our virtual method as final as
1738:41 - we are doing here now if we try to build
1738:44 - this program we're going to get a
1738:46 - compiler error let's pass this through
1738:48 - gcc and let you see this okay you see we
1738:51 - get a compiler error and uh the error is
1738:54 - that we are overriding let's go up and
1738:57 - see the error here error and on line 12
1739:02 - in bulldog h we see that we are
1739:05 - overriding a final method virtual
1739:08 - void bulldog is a final function and we
1739:11 - are overriding this and this is going to
1739:14 - give us a compiler error this is the
1739:15 - behavior we get so the message here is
1739:17 - that you can go in your inheritance
1739:19 - hierarchy at any level and mark a
1739:22 - virtual method as final and prevent
1739:25 - download stream classes from
1739:27 - specializing or overriding that method
1739:30 - further and if they do that they will
1739:32 - get a compiler error this is something
1739:34 - we can achieve in our c plus plus
1739:36 - program another thing you can do with
1739:38 - the final specifier is that you can
1739:40 - prevent people from inheriting from your
1739:43 - class altogether let's go to our cat
1739:47 - class i think that's the example that
1739:49 - sets that up we have a cat class it is
1739:52 - going to be inheriting from feline but
1739:54 - the class is marked as final
1739:57 - now what this is going to do
1739:59 - it's going to throw a compiler error
1740:01 - anytime somebody tries to derive or
1740:04 - inherit from this class here so if
1740:06 - somebody tries to inherit from cat as we
1740:09 - are doing here create a wildcat from a
1740:11 - cat we are going to get a compiler error
1740:13 - because we can't inherit from cat
1740:16 - altogether it is a final class at this
1740:18 - moment okay so let's look at our wildcat
1740:22 - class it is going to try
1740:24 - and
1740:25 - derive from cat we can do something like
1740:29 - this we can remove our comments here and
1740:31 - if we try to do this we will get a
1740:33 - compiler arrow let's look at the cpp
1740:35 - file and see what we have it has nothing
1740:37 - special but if we try to do that and
1740:39 - inherit from cat we will get a compiler
1740:42 - error because the cat class is final and
1740:45 - you cannot derive from it if you do that
1740:47 - you will get a compiler error because
1740:49 - the cat class is final this is what i
1740:52 - want you to see here let's try and build
1740:54 - our program again we're going to pass
1740:55 - this through gcc and we will see our
1740:58 - compiler error okay the world is
1741:00 - finished with errors if we go up we will
1741:03 - see that we cannot derive from a final
1741:06 - base class if we do that we will get a
1741:08 - compiler error and this is what i want
1741:10 - you to see here okay now that we notice
1741:12 - we're going to take this back
1741:14 - and take out the compiler error here
1741:17 - because we want our code to compile
1741:19 - we're going to make sure it is compiling
1741:21 - fine okay now the code is compiling
1741:23 - because we are no longer trying to
1741:25 - inherit from cat and i want you to now
1741:29 - see a few interesting facts about the
1741:32 - final specifier when it works together
1741:35 - with virtual functions let's go to the
1741:37 - main cpp file and show you the first
1741:40 - fact and that's that you can create a
1741:42 - class right away and mark that as vinyl
1741:45 - as you create it as we do here if you do
1741:48 - that this class is going to not be
1741:50 - inheritable and if you try to inherit
1741:52 - from it you will get a compiler error
1741:54 - let's take out everything we have here
1741:56 - and just say hello in our main function
1741:59 - this is going to do just to have
1742:00 - something this is going to give us a
1742:02 - compiler error because we can't inherit
1742:04 - from a final class let's build and show
1742:07 - you the compiler error this is going to
1742:09 - go through gcc and the world is going to
1742:12 - finish with errors and that we have our
1742:14 - message here and we don't have the error
1742:18 - we expected because we forgot to put our
1742:21 - closing semicolon on our class
1742:23 - definition here but we can build again
1742:25 - and get our error okay the world is
1742:28 - finished with errors
1742:29 - and the error is going to be that we
1742:32 - cannot derive from a final class this is
1742:34 - what we expect here let's comment this
1742:36 - out because i just wanted you to see
1742:38 - this fact another interesting thing c
1742:41 - plus plus allows you to do
1742:44 - is to set up a new virtual method in a
1742:47 - final class let's first build and make
1742:50 - sure the compiler error here goes away
1742:52 - and i am going to show you that okay the
1742:54 - build is good let's go back in our final
1742:57 - class which is the cat class
1742:59 - if i remember correctly this is a final
1743:02 - class we can't derive from this class
1743:04 - but we can set up a virtual method for
1743:06 - example
1743:07 - the virtual method here called meow is
1743:10 - useless
1743:12 - why is it useless it is a virtual and
1743:14 - marking it virtual means that
1743:16 - you at least want people inheriting from
1743:19 - this class to inherit it and use it or
1743:21 - even better you want them to have the
1743:23 - ability to specialize
1743:25 - or override this method and make it to
1743:27 - do more specialized things but you can't
1743:30 - really do that because you can't derive
1743:32 - from this class all together so this is
1743:35 - something that c plus plus allows us to
1743:37 - do but this is a useless method which
1743:39 - will never be used in any way so this is
1743:42 - something i want you to be aware of but
1743:43 - this is going to compile again let's
1743:45 - pass this through gcc you're going to
1743:47 - see that this is going to compile and
1743:49 - work even if this method is really
1743:51 - useless i want you to be aware of this
1743:53 - okay so the build is good here okay so
1743:55 - this is our interesting fact number two
1743:58 - okay even if this method is useless
1744:01 - it is possible to specialize a method
1744:05 - coming from upstream classes from your
1744:07 - final class for example in feline we
1744:10 - have
1744:11 - a method called run which was introduced
1744:14 - there i think we can override this
1744:17 - method in our final class which is the
1744:19 - cat class here so this method is going
1744:21 - to be useless because it will be
1744:24 - specializing what we get from our
1744:26 - upstream class this is going to work
1744:28 - okay so since we are looking at a few
1744:31 - useless things you can do with final
1744:33 - combined with the
1744:35 - virtual mechanisms in c plus plus i want
1744:38 - you to see that it is possible to set up
1744:40 - a virtual method and mark it as a final
1744:44 - in the same declaration and we're going
1744:46 - to go to the bird class and really show
1744:48 - you that for example
1744:49 - we have a virtual method which is called
1744:52 - fly but this is marked final the moment
1744:55 - we declare it and this is going to be
1744:57 - contradicted for example the virtual
1744:59 - keyword means that people downstream
1745:02 - will be able to specialize this or
1745:04 - inherit this but at the same time we are
1745:07 - marking this guy as final so we are
1745:09 - saying nobody downstream will be able to
1745:12 - override this method if they do that
1745:14 - they will get a compiler error now which
1745:17 - one is going to win virtual or final
1745:19 - final is going to win because if you try
1745:21 - to override this method in downstream
1745:24 - classes you will get a compiler error
1745:26 - let's go down and look at one bird we
1745:29 - might have in our program for example we
1745:31 - might have a pigeon let's grab this
1745:34 - method and try to override it you're
1745:35 - going to see that we get a compiler
1745:37 - error we're going to go in pidgin and
1745:39 - put in the fly method and uh for example
1745:41 - we're going to say pigeon fly here and
1745:44 - we're going to say override we are
1745:46 - trying to override this method but we're
1745:48 - going to get a compiler error you see we
1745:49 - have a squiggly line because this is a
1745:51 - final method and we are trying to
1745:53 - override this in a downstream class
1745:57 - and this class is a downstream class
1746:00 - from bird and in bird we map this method
1746:03 - as final so this is not going to work
1746:05 - even if this is virtual you want to be
1746:07 - able to really use the virtual mechanism
1746:10 - because this is final if we try to
1746:12 - inherit from this if we try to override
1746:15 - this like we are doing in pigeon here we
1746:17 - will get the compiler error let's try
1746:19 - and build our program and we will see
1746:21 - that we get our trusty compiler error
1746:24 - the bullet is going to finish with
1746:25 - errors and if we go up we're going to
1746:28 - find our error we're going to say
1746:30 - virtual function fly overriding final
1746:33 - function we are overriding a final
1746:36 - virtual method and this is going to give
1746:39 - us a compiler error we can't do this
1746:40 - this is something you can do in your c
1746:42 - plus plus program so this is really
1746:44 - confusing because in bird the virtual
1746:47 - keyword suggests that you can really
1746:49 - specialize this in downstream class but
1746:52 - this is contradictant and c plus plus
1746:54 - allows you to do this you need to be
1746:55 - aware of this again if we don't override
1746:58 - this and leave this in the code is going
1747:00 - to compile but in my opinion this is
1747:02 - really confusing and you need to be
1747:05 - aware of this that's the whole point of
1747:06 - this lecture here let's make sure the
1747:08 - code is building and this is really all
1747:10 - i had to share in this lecture
1747:13 - introducing the final keyword to you you
1747:15 - can use it to restrict how people
1747:17 - override your virtual function or you
1747:20 - can use it to restrict
1747:22 - people from inheriting from your class
1747:25 - altogether and use these things if they
1747:28 - make sense for whatever application you
1747:30 - are designing with c plus plus we are
1747:33 - going to stop here in this lecture and
1747:35 - the next one i am going to show you a
1747:37 - secret you probably didn't know so go
1747:39 - ahead and finish up here and meet me
1747:42 - there in this lecture we're going to
1747:43 - explore how virtual functions or
1747:46 - polymorphism plays with default
1747:48 - arguments and when we say default
1747:51 - arguments we mean a setup like this we
1747:53 - have a virtual function here which is
1747:55 - called add it is going to return double
1747:58 - and it has
1747:59 - default parameters here for a and b and
1748:02 - the value is five here in our derived
1748:05 - class we also have the same function we
1748:07 - are overriding that and we have a
1748:10 - different set of values acting as our
1748:13 - default parameter here we are using 10
1748:15 - for a and b here and we want to see how
1748:19 - this plays with polymorphism now please
1748:21 - note that with polymorphism if we go
1748:24 - through a base pointer to manage a
1748:26 - derived class object what we want is to
1748:29 - call the most specific implementation of
1748:32 - the virtual function here for example if
1748:34 - we have a base pointer managing a
1748:37 - derived object and we call the add
1748:40 - method from a base pointer we will get
1748:43 - the most specific method here called
1748:46 - but what you get with these default
1748:48 - arguments is that the compiler is going
1748:51 - to use static binding to decide which
1748:54 - default parameters to pass to your
1748:56 - function so even if you will get this
1748:58 - method here called the compiler will
1749:01 - still use the default arguments we have
1749:04 - in our base class so we will call this
1749:06 - method here but we will use the default
1749:09 - arguments coming from the base class and
1749:11 - this is the behavior you need to be
1749:13 - aware of okay so another way to put this
1749:15 - is that default arguments are handled at
1749:18 - compile time the compiler is going to
1749:21 - wire these things at compile time where
1749:23 - you are building your application
1749:25 - and the virtual functions are called at
1749:28 - run time with polymorphism so if you use
1749:31 - default arguments with virtual functions
1749:33 - you might get weird results with
1749:35 - polymorphism because the default
1749:38 - arguments you will be using are going to
1749:40 - be decided by static binding but the
1749:43 - actual function that you get called is
1749:45 - going to be decided by dynamic binding
1749:48 - so we will call the virtual function in
1749:50 - our derived class but we will be using
1749:53 - the default arguments from the base
1749:55 - class this is the behavior we'll get you
1749:57 - need to be aware of this and make sure
1749:59 - this is what you desire my personal
1750:02 - preference is to not use default
1750:04 - parameters or default arguments with
1750:06 - virtual functions because this is really
1750:08 - going to make my code hard to follow and
1750:10 - hard to understand especially for other
1750:13 - developers that might have to work on my
1750:15 - code base in the future okay here is a
1750:17 - simple example we have a base pointer
1750:20 - which is going to be managing a derived
1750:22 - object and we will call the add function
1750:25 - here what do we expect to get well
1750:27 - because we have polymorphism here we
1750:29 - will call the most specific add function
1750:32 - here and that's going to be the add
1750:34 - function from our derived class
1750:37 - but the default argument we pass are not
1750:40 - going to be decided by the derived class
1750:42 - the default arguments are going to be
1750:44 - plugged in at compile time using static
1750:47 - binding so because the base pointer is a
1750:49 - base object we will be using the default
1750:52 - arguments from the base implementation
1750:54 - of the add method so we will just plug
1750:56 - in five and five so we will add five to
1750:59 - five and add a two that's why we get a
1751:02 - 12 right here
1751:04 - and if we go through these references we
1751:06 - will get the same result because this is
1751:09 - going to enable or trigger polymorphic
1751:12 - behavior in our c-plus programs if we go
1751:15 - through direct objects we will be doing
1751:18 - static binding and we will use the
1751:21 - default arguments or device parameters
1751:23 - from our derived object and remember
1751:25 - that we use the value of 10 in there so
1751:27 - we are going to add 10 to 10 and add a 2
1751:30 - and we are going to get a 22 as you see
1751:32 - here through static binding if we do
1751:35 - slicing by assigning a derived object to
1751:38 - a base object the derived information is
1751:41 - going to be sliced off and if we add we
1751:44 - will use the default parameters from the
1751:46 - base class and we will use the
1751:48 - implementation in the base class so if
1751:51 - we come back to our code here we will
1751:53 - use the default arguments from the base
1751:55 - class and that's a five and a five we're
1751:57 - going to add them up because the body is
1751:59 - going to be from the base class remember
1752:02 - the derived information has been
1752:04 - completely sliced off so we are going to
1752:07 - add a five and a five and a one and
1752:09 - we're going to get 11 printed out if we
1752:11 - do slicing and that's the result we get
1752:14 - right here as a closing note before we
1752:16 - head over to visual studio code again
1752:19 - default arguments with virtual functions
1752:21 - can be very confusing they are best
1752:23 - avoided because they really are going to
1752:25 - give a hard time to anybody that is
1752:28 - going to be working on your code in the
1752:30 - future now that you know this we're
1752:31 - going to head over to visual studio code
1752:33 - and play with this a little more here we
1752:35 - are in our working folder the current
1752:38 - project is virtual functions with
1752:40 - default arguments we're going to grab
1752:42 - the code from our template project we're
1752:45 - going to copy this and put this in the
1752:47 - current project and i am going to grab
1752:49 - my classes base and derived that we are
1752:52 - going to be using here if you don't want
1752:54 - to type along you can grab the source
1752:56 - code from the resource section of the
1752:59 - course
1753:00 - if you don't want to type all these
1753:01 - classes or create them you can grab the
1753:04 - source code from the resource section on
1753:07 - this lecture you're going to download
1753:08 - this and use this you don't have to
1753:10 - waste time typing these things because
1753:12 - many of these things are already
1753:15 - familiar to you we're going to open this
1753:17 - in visual studio code and we're going to
1753:19 - have our classes here we have a base
1753:21 - class which is going to have a virtual
1753:23 - function
1753:24 - with
1753:25 - a pair of default arguments here we are
1753:28 - using 5 5 in our ad
1753:31 - virtual function here
1753:33 - and if we go and derived it is going to
1753:35 - derive publicly from base and it is
1753:38 - going to override our
1753:40 - virtual function here but notice that it
1753:42 - is going to set up its own
1753:45 - default parameters so if we do
1753:47 - polymorphism
1753:49 - and use the base pointer to call the add
1753:51 - method here we will get the most
1753:53 - specific or the most specialized version
1753:56 - of the add method called and this is
1753:58 - going to call this body here
1754:01 - but the parameters are going to be
1754:03 - decided by static binding so because we
1754:06 - will be going through a base pointer we
1754:08 - will use the default arguments from the
1754:11 - base class that's going to be five five
1754:13 - and we're going to play with this and
1754:15 - see what this is going to give us in the
1754:17 - main cpp file here let's clean up a
1754:19 - little bit we're going to remove
1754:21 - whatever we don't need here
1754:23 - and we are going to include our derived
1754:25 - class we can do that we are going to put
1754:28 - in our code to really play with us let's
1754:30 - remove these spaces because we don't
1754:32 - need them we are going to go through a
1754:34 - base pointer to manage a derived object
1754:37 - and this is a setup we can use to put
1754:39 - things in place here we are going to
1754:41 - call the add method notice that we are
1754:44 - not passing in any parameter because we
1754:46 - are going through a base pointer and the
1754:48 - add method is virtual
1754:51 - polymorphism will kick in and we will
1754:53 - get the derived version
1754:55 - of our add function code so we will call
1754:59 - this add function here but
1755:02 - be careful because we want to be using
1755:04 - these default parameters here if we did
1755:06 - we would add a 10 to a 10 and get to 22
1755:10 - in our main function here but that's not
1755:12 - going to be the case the compiler is
1755:14 - going to use static binding to decide
1755:17 - which default parameters to use either
1755:20 - those in the base class or those in the
1755:22 - derived class and notice that if we
1755:24 - hover over this add function you see
1755:26 - that the compiler has plugged down those
1755:29 - from the base class and that's what the
1755:31 - compiler is going to do so it is going
1755:32 - to add a five to a five and it is going
1755:35 - to add two to that i think that's what
1755:37 - we are doing in our derived version and
1755:40 - we are going to get to 12 printed out
1755:43 - let's build and see if this is actually
1755:45 - the case we're going to pass this
1755:46 - through gcc
1755:48 - and that's the compiler that is our
1755:51 - favorite now the book is going to be
1755:53 - good we can close this and bring up a
1755:55 - powershell window and if we run rooster
1755:58 - we're going to see that the arrived ad
1756:00 - was called and the result was 12 here
1756:03 - this is what we get again
1756:05 - the compiler is going to call the most
1756:08 - specialized virtual function override
1756:11 - here but it is going to use the default
1756:14 - parameters from the base class you
1756:16 - should really note this and this can
1756:18 - really be confusing especially if you
1756:20 - are a beginner to polymorphism if we go
1756:24 - through a base reference we will also
1756:27 - get polymorphic behavior
1756:29 - so if we have a derived object and we
1756:31 - set up a reference to that which is of
1756:34 - type base and we go through that base
1756:36 - reference and called the add method we
1756:38 - will get the most specialized add
1756:40 - version called so that's going to be
1756:42 - derived and but we will use the default
1756:46 - parameters from the base class because
1756:48 - which default arguments we use is
1756:50 - decided by using static binding that's
1756:54 - what we get here and official studio
1756:56 - code is really helpful here because if
1756:58 - we hover over the add function we're
1757:00 - going to see which default parameters
1757:02 - were plugged in by the compiler and you
1757:04 - see that they are those from the base
1757:06 - class so we are again going to add five
1757:09 - to a five and we are going to add a two
1757:11 - and we will get 12 printed out here if
1757:14 - we boil and run we're going to see that
1757:16 - this is the case the build is good we
1757:18 - can clear
1757:20 - and run rooster we're going to see that
1757:21 - with a base reference we're also going
1757:23 - to get a 12. we will get the most
1757:26 - specific
1757:28 - implementation of the add method called
1757:31 - but we will plug in the default
1757:33 - parameters from the base class i really
1757:35 - wanted this to be super clear if you set
1757:38 - up things in a way that you are going to
1757:40 - get static binding then if you are going
1757:43 - through a base object you will call the
1757:45 - base version of the add method and you
1757:48 - will use the default parameters from the
1757:50 - base class if you happen to be
1757:52 - manipulating a derived object you will
1757:54 - use the information in the derived class
1757:57 - the derived version of the add method is
1757:59 - going to be called and we are going to
1758:01 - use the default argument from the
1758:03 - derived class so if we set up another
1758:06 - example here we can set up a base object
1758:09 - for example we're going to say base and
1758:11 - say base
1758:13 - 3 we can do that and we try to call the
1758:16 - add method we can say base 3 and say add
1758:19 - we can try and store this in our
1758:21 - research variable and we can print this
1758:23 - out we're going to say sdbcl row
1758:26 - research we can say something like this
1758:28 - and we're going to print out the result
1758:30 - here if we build and run we're going to
1758:32 - see that this is going to call
1758:34 - the base version of the add method and
1758:36 - it is going to use the default
1758:38 - parameters from the base if we go back
1758:40 - to base we're going to see that we are
1758:42 - going to add a 5 to a 5 and we will get
1758:46 - 11 because we will plug in a 1 and
1758:49 - return the result here let's build and
1758:51 - run and see that this is actually the
1758:53 - case so this is going to be completely
1758:55 - doing static binding let's clear and run
1758:58 - you see that the world is good we're
1759:00 - going to run restaurant and we will get
1759:02 - 11 printed out here hopefully you can
1759:04 - see this if you assign a derived object
1759:07 - to
1759:08 - a base object you will get slicing
1759:11 - let's see that we can actually do this
1759:14 - but before we do that i also want you to
1759:16 - see that you can also do
1759:19 - row direct objects of derived classes if
1759:22 - you do this you will
1759:24 - get the information from the derived
1759:26 - class we will use the body from the
1759:28 - derived class and we will use the
1759:30 - default parameters from the derived
1759:32 - class so we will take 10 and add a 10
1759:35 - and we will add the 2 to that and we
1759:37 - will get a 22 printed out i think we can
1759:40 - do this
1759:42 - so
1759:43 - let's put in a separator because that's
1759:45 - going to make it easier to follow these
1759:47 - lengths and we're going to build with
1759:50 - the gcc the both is going to be good
1759:52 - hopefully
1759:53 - the bulk is good we can clear
1759:56 - and run rooster and we're going to see
1759:58 - that we get a 22 here if we assign a
1760:01 - derived object to a base object directly
1760:04 - by doing something like this event we
1760:06 - don't need this guy here
1760:09 - we can remove this we have a base object
1760:12 - that we are setting up here and we are
1760:15 - assigning a derived object to this base
1760:17 - object here
1760:18 - if we call the add method we will get
1760:21 - the version from the base class because
1760:24 - mind your steps this is going to slice
1760:26 - off all the derived information because
1760:29 - we are not going through any kind of
1760:31 - base or reference so this is going to
1760:32 - slice off all the information we have in
1760:35 - the derived
1760:37 - object here and we will be left with the
1760:39 - base information and if we call the add
1760:42 - function here you see that we are using
1760:44 - the default parameters from the base
1760:46 - class and we will use the body of the
1760:49 - base class implementation here so we
1760:51 - will add a 5 to a 5 and we will add 1 to
1760:54 - that and we will get 11 printed out as
1760:57 - we see here let's build and actually
1760:59 - prove this we're going to pass this
1761:01 - through gcc the world is going to be
1761:02 - good we can clear and run rooster and we
1761:05 - are going to see that the result is
1761:07 - irreverent if we do row object
1761:11 - assignment here this is really all i
1761:12 - wanted you to see in this lecture that
1761:15 - you should really be careful if you are
1761:17 - using virtual functions
1761:19 - mixed up with default arguments the
1761:22 - compiler is not going to do dynamic
1761:24 - binding on the default parameters it is
1761:26 - going to decide which default parameters
1761:29 - to plug in at compile time using static
1761:32 - binding so the compiler is basically
1761:34 - going to look at the type of the pointer
1761:36 - or object that you have and it is going
1761:39 - to use that to decide which default
1761:41 - parameters to plug in so at this example
1761:44 - here for example at line 7 it is going
1761:46 - to see what kind of pointer do i have i
1761:49 - have a base pointer so i am going to use
1761:50 - the default parameters from the base
1761:53 - implementation and if you hover over
1761:55 - here you're going to see that it is
1761:56 - going to plug in a 5 and a 5. even if we
1761:59 - are using the most specialized add
1762:01 - version in our inheritance hierarchy the
1762:04 - compiler is going to still use the
1762:06 - default argument from the base
1762:08 - implementation down here on line 16 the
1762:11 - compiler is going to say which kind of
1762:13 - reference do i have it's going to say
1762:15 - base because that's what we have here so
1762:17 - it is going to use the default
1762:18 - parameters from base and that's what it
1762:21 - is going to plug in here 5 and 5 and
1762:23 - we're going to get this result here
1762:25 - down here on line 25 the compiler is
1762:28 - going to see which kind of object do i
1762:30 - have here this three is a base so i am
1762:32 - going to use the default parameters from
1762:35 - base
1762:36 - down below on line 31 the compiler is
1762:39 - going to look and see
1762:40 - which kind of object do i have here the
1762:42 - object is derived so i will plug in the
1762:45 - default parameters for it derived again
1762:48 - this is really what the compiler is
1762:49 - going to do with default parameters the
1762:52 - compiler is never going to do dynamic
1762:54 - binding and this is going to make your
1762:56 - code really confusing again my advice is
1763:00 - to avoid default arguments or devote
1763:03 - parameters if you are using polymorphism
1763:06 - in your inheritance hierarchy we are
1763:09 - going to stop here in this lecture and
1763:11 - the next one we're going to learn about
1763:13 - virtual destructors
1763:15 - go ahead and finish up here and meet me
1763:17 - there in this lecture we are going to
1763:19 - explore virtual destructors and these
1763:23 - are destructor methods you might want to
1763:25 - be called
1763:27 - using dynamic binding or polymorphic
1763:30 - behavior
1763:31 - we are going to be using this
1763:33 - inheritance hierarchy to play with
1763:34 - thanks so the animal class is going to
1763:36 - be our base class we are going to derive
1763:38 - from that publicly and have a feline
1763:41 - class and we are going to derive from
1763:43 - feline and have a dog class this is the
1763:46 - setup we are going to be using here
1763:49 - now let's look at some code we are going
1763:51 - to set up our animal class like there's
1763:53 - nothing really special here notice that
1763:56 - the destructor is a regular destructor
1763:58 - we have
1763:59 - we will derive from animal and create a
1764:03 - feline class which is going to set up
1764:05 - its own virtual function which is going
1764:07 - to be run if you want you can override
1764:10 - the breathe method but we don't want to
1764:12 - do that here because we just want to
1764:14 - focus
1764:15 - on the destructors here and the order in
1764:18 - which they are going to be called we are
1764:20 - going to derive from feline and set up a
1764:23 - dog class and this dog class is going to
1764:26 - set up its own virtual function and
1764:29 - notice that it has a destructor which is
1764:31 - really a regular destructor now once we
1764:33 - have this inheritance hierarchy set up
1764:36 - we might want to do something like this
1764:38 - we can create a dark object
1764:40 - and when it is time for this object to
1764:43 - be destroyed i want you to focus on the
1764:46 - order in which the destructors are going
1764:48 - to be called we have seen this before
1764:50 - the destructors are going to be called
1764:53 - from the specialized to the most base
1764:56 - implementation of the destructor so the
1764:58 - destructor for doug will be called first
1765:01 - then we will call the destructor for
1765:03 - feline then we will call the destructor
1765:05 - for animal now a problem is going to pop
1765:08 - up if we are using a base pointer to
1765:11 - manage a derived object with polymorphic
1765:14 - behavior that we might want for our
1765:16 - inheritance hierarchy here so we are
1765:18 - going to use an animal pointer to manage
1765:21 - a dark object like this and when it is
1765:23 - time to release the memory for this
1765:25 - object
1765:26 - we may be tempted to call the delete
1765:29 - operator on our animal pointer here but
1765:33 - this is only going to call the
1765:34 - destructor
1765:36 - for the base class and hopefully you can
1765:38 - see the problem here because our
1765:41 - destructors are not virtual the compiler
1765:44 - is going to use static binding to decide
1765:46 - which destructor to call so it is going
1765:48 - to look at the type of a pointer it is
1765:50 - going to see that it is an animal
1765:52 - pointer and it is going to decide to
1765:54 - call the destructor for animal here
1765:56 - that's why we get this reserve we are
1765:59 - managing an object which is not just an
1766:01 - animal it has derived information in it
1766:04 - but we are only calling the destructor
1766:06 - for the base part of this stun so any
1766:09 - piece of dynamic memory we might have
1766:11 - allocated in the constructors for feline
1766:14 - or dog is going to be leaked out because
1766:17 - remember even if this is a dark object
1766:20 - it is made up of base parts the
1766:22 - foundation for this is going to be
1766:24 - animal and on top of that we are going
1766:26 - to build a feline level and on top of
1766:29 - that we are going to build a dog level
1766:31 - in this case only the destructor for dog
1766:34 - is going to be called and any dynamic
1766:37 - memory that might have been allocated at
1766:40 - the feline and dog level is going to be
1766:43 - leaked out and this is something we
1766:45 - don't want you really need to keep your
1766:47 - eye out on this and this is something
1766:49 - really bad you really need to keep your
1766:51 - eye out for this so this is really a big
1766:53 - problem and to solve it we need the
1766:55 - destructors to be called using
1766:58 - polymorphism and you can set that up by
1767:01 - marking your destructors as a virtual if
1767:04 - you do this the compiler will know
1767:06 - that if you are going through a base
1767:08 - pointer to manage a derived object when
1767:11 - the time comes for the memory to be
1767:13 - released and you release the memory
1767:15 - through a base pointer the compiler is
1767:17 - going to call the most specific
1767:19 - destructor it can find and this is going
1767:22 - to solve our problem then we will reuse
1767:24 - the order we are familiar with the most
1767:27 - derived destructor will be called and it
1767:29 - will call its best destructor and that's
1767:32 - going to happen until we hit the most
1767:34 - base class in our inheritance hierarchy
1767:36 - and the memory is going to be released
1767:38 - exactly as we would want now that you
1767:40 - know this we're going to head over to
1767:42 - visual studio code and play with us a
1767:43 - little more here we are in our working
1767:46 - folder we are going to learn about
1767:48 - virtual destructors and before we do
1767:50 - that we're going to grab our template
1767:52 - files and put them in place let's do
1767:55 - that and i am going to put in the
1767:57 - classes that make up our inheritance
1767:59 - hierarchy our most based class is going
1768:02 - to be base our most based class is going
1768:04 - to be animal after that we're going to
1768:06 - derive we are going to derive from that
1768:08 - and create the feline class and we are
1768:11 - going to derive from feline and create a
1768:13 - dog class here this is the inheritance
1768:16 - hierarchy we talked about in our slides
1768:18 - okay we are going to open this up in
1768:20 - visual studio code and this is going to
1768:22 - give us our classes here and we are
1768:25 - going to remove these virtual keywords
1768:27 - because we want to see
1768:29 - what would happen if you don't mark your
1768:31 - destructors as a virtual we're going to
1768:34 - do that for feline we're going to do
1768:36 - that for doug let's remove the virtual
1768:38 - keyword here we're going to remove that
1768:40 - and we're going to remove that for the
1768:42 - animal class and we want to see the
1768:44 - implementations for our destructors for
1768:47 - animal we are just going to say that the
1768:49 - destructor for animal was called for
1768:52 - feline we're going to say the same thing
1768:53 - feline destructor called for doubt we're
1768:56 - going to say the same thing we're going
1768:57 - to say destructor for dog called here
1769:00 - we are using strengths as our parameters
1769:04 - here so i think it is a good idea to
1769:07 - change these guys to use string view i
1769:09 - am going to do that
1769:10 - and come back when this is done
1769:12 - okay this is done all our parameters are
1769:15 - of std string view type and now that we
1769:18 - have this inheritance hierarchy let's
1769:20 - make sure none of the destructors is
1769:23 - virtual this is the case here we can
1769:26 - head over to the main cpp file and use
1769:29 - this inheritance hierarchy here we're
1769:31 - going to crack it open and remove
1769:34 - whatever we don't need here
1769:36 - we are going to include our dog class
1769:40 - which is going to implicitly include or
1769:42 - its parent classes so we're going to
1769:44 - include dog.h here and we are going to
1769:47 - create a row.object by default here
1769:50 - we're going to say dog and let's say dog
1769:52 - one we can do that and we might not even
1769:55 - give it any parameter this is going to
1769:57 - call the default constructor and if we
1769:59 - go to doug we're going to see that it is
1770:01 - possible to specify information here
1770:04 - first style description but we're going
1770:06 - to ignore this and we just want to see
1770:09 - which order in which the destructors are
1770:12 - called let's build and run this program
1770:15 - we're going to pass this through gcc the
1770:17 - book is going to be good if we clear
1770:19 - let's bring up a powershell window to do
1770:21 - that we're going to clear
1770:23 - and run rooster you're going to see that
1770:26 - dog destructor was called feline
1770:28 - destructor was called animal destructor
1770:30 - was called and this is really cool this
1770:32 - is the order we expect by default but if
1770:36 - we don't do something like this and say
1770:38 - animal pointer and say p animal to mean
1770:41 - a pointer to animal and we say new dog
1770:44 - we're going to allocate a dog on the
1770:46 - heap and we're going to manage that
1770:48 - using a base pointer and if we try to
1770:53 - release the memory here let's do that
1770:54 - we're going to say delete p animal let's
1770:57 - see which destructor gets called here
1771:00 - because notice we are using a base
1771:02 - pointer to manage a must specific object
1771:06 - here which is a derived class of dog
1771:08 - indirectly and we will see that we don't
1771:11 - get the destructors called in the order
1771:14 - that we expect let's build and run this
1771:16 - program to really see this we're going
1771:18 - to use gcc to build it
1771:21 - the world is going to be good as you see
1771:23 - here we're going to clear
1771:25 - and run rooster now you see that only
1771:28 - the destructor for animal is called even
1771:31 - if we are really managing a dog object
1771:34 - for things to work really well we would
1771:36 - expect the destructor for duck to be
1771:38 - called and then the destructor for a
1771:40 - feline and then the destructor for
1771:42 - animal to release or the memory that
1771:45 - might have been allocated by these
1771:48 - parent classes for our dog class if you
1771:51 - go back in the cpp file for example for
1771:53 - each of these classes you're going to
1771:55 - see that the compiler is going to be
1771:57 - calling
1771:58 - each base class of the current level
1772:00 - that we are at in doug cpp we are going
1772:02 - to call the constructor for feline the
1772:05 - constructor for feline is going to be
1772:07 - called if it is doing any dynamic memory
1772:09 - allocation we need to release this
1772:11 - memory constructor for feline is also
1772:13 - going to call the constructor for animal
1772:15 - and if animal is doing any dynamic
1772:18 - memory allocation this is going to need
1772:19 - to be called but notice that we are just
1772:22 - colon the destructor for animal and if
1772:25 - we only call this destructor all of the
1772:27 - memory that was allocated by the filing
1772:29 - constructor is going to be leaked out
1772:31 - because only the animal destructor is
1772:33 - going to be called hopefully you can see
1772:35 - the problem here but this is not the
1772:37 - only problem the c plus plus standard
1772:39 - says that if you do something like we
1772:42 - are doing here and call a destructor
1772:45 - using a pointer to the base class but
1772:47 - that pointer happens to be managing a
1772:49 - derived object this is going to give you
1772:52 - undefined behavior so you're not
1772:54 - guaranteed to get to the same behavior
1772:56 - on different compilers on different
1772:58 - operating systems so this is something
1773:00 - really bad we want all the destructors
1773:02 - in our inheritance hierarchy to be
1773:05 - called to properly release the memory
1773:08 - that would potentially be dynamically
1773:10 - allocated by each level in our
1773:12 - constructor calls the fix for this is
1773:14 - really simple all you have to do is mark
1773:17 - your destructors as virtual and the
1773:20 - compiler will call the most specific
1773:23 - destructor
1773:24 - for your classes so all we need to do is
1773:27 - go in and mark these guys as virtual so
1773:29 - we're going to do that the base class
1773:31 - destructor is going to be marked as
1773:33 - virtual we're going to go to feline and
1773:35 - do the same thing we're going to mark
1773:37 - that as virtual and we're going to go to
1773:39 - dog
1773:40 - and mark its destructor as virtual we're
1773:43 - going to do something like this and now
1773:45 - notice we don't need to change any other
1773:48 - thing if we build our program we're
1773:49 - going to pass it through gcc it is going
1773:52 - to do exactly what we want because
1773:54 - now the compiler will resolve the calls
1773:57 - to the destructors polymorphically
1774:00 - because we are going through a base
1774:01 - pointer the compiler will call the most
1774:03 - specific implementation for this
1774:05 - structure because we are going through a
1774:07 - base pointer to call the destructor here
1774:10 - the compiler will call
1774:12 - the most specialized destructor we can
1774:15 - find and it is going to find the
1774:16 - destructor for duck which is going to be
1774:19 - the most specialized destructor we can
1774:21 - find in our inheritance hierarchy it is
1774:24 - going to call the dog destructor that's
1774:26 - going to go the destructor for feline in
1774:29 - turn and then that's going to call the
1774:32 - destructor for animal and our memory is
1774:34 - going to be released properly that's
1774:36 - what we're going to see here let's make
1774:38 - sure we weld this again because i'm not
1774:40 - sure if i actually built this the body
1774:43 - is going to be good anyway so we're
1774:45 - going to clear and run rooster now you
1774:48 - see that the duct destructor is called
1774:49 - the vlan destructor is called the animal
1774:51 - destructor is gold and everything is
1774:53 - just going to fall in place so my advice
1774:56 - if you are using virtual functions in
1774:58 - your inheritance hierarchy make sure you
1775:01 - also mark your destructors as virtual
1775:04 - this is going to save you future
1775:06 - headaches you might come in contact with
1775:09 - if you are using a base pointer to
1775:11 - manage a derived object and you are
1775:13 - doing some kind of dynamic memory
1775:15 - allocations in your constructors that's
1775:18 - going to release the memory properly if
1775:20 - you are releasing the memory through a
1775:23 - base pointer like we are doing on line 8
1775:26 - here this is really all i had to share
1775:28 - in this lecture i hope you found it
1775:29 - interesting we are going to stop here in
1775:31 - this one in the next one we're going to
1775:33 - learn about dynamic casts
1775:36 - go ahead and finish up here and meet me
1775:38 - there in this lecture we're going to
1775:40 - learn about dynamic casts and the
1775:43 - dynamic casts are a facility we have in
1775:45 - c plus plus
1775:47 - to do downstream transformations
1775:50 - between our polymorphic types
1775:54 - so if we have a base planer for example
1775:56 - we can transform it to a derived type
1775:59 - and be able to use it like we use any
1776:01 - row object for example if we do this
1776:04 - kind of transformation we will be able
1776:06 - to call non-polymorphic functions and
1776:09 - this may come in handy sometimes
1776:12 - this is the hierarchy we will be using
1776:14 - our top class will be animal here we
1776:17 - will derive from this and create our
1776:19 - feline class and we will be live from
1776:21 - feline and create our dog class here if
1776:25 - we have a base pointer pointing to a
1776:27 - dark object for example the most
1776:29 - specialized class we can have in our
1776:32 - inheritance hierarchy sometimes we might
1776:35 - want to transform from this base pointer
1776:39 - to the most derived object here and get
1776:42 - to the direct most derived object that
1776:45 - we can really call anything on if you
1776:47 - remember with a base planer like animal
1776:50 - here the only thing we can do is really
1776:52 - call
1776:53 - polymorphic or virtual functions but
1776:56 - sometimes we want to do much more than
1776:58 - this for example if we want to call
1777:01 - non-polymorphic functions this is not
1777:03 - going to work because the best pointer
1777:04 - has no knowledge of those functions so
1777:07 - if we need to do that explicitly
1777:09 - transforming from a base pointer to a
1777:12 - derived pointer is going to give us that
1777:14 - capability if the actual object we are
1777:17 - pointing at happens to have that method
1777:20 - okay so this is what we are after in
1777:22 - this lecture we want to be able to
1777:24 - transform from a base class pointer
1777:27 - or reference to a derived class pointer
1777:30 - or reference at runtime another way you
1777:32 - can text this is to think of the base
1777:34 - class pointer or reference as input and
1777:37 - we want to get a derived class pointer
1777:40 - or reference as output in our c plus
1777:43 - plus program and the main benefit of
1777:45 - this is to be able to call
1777:47 - non-polymorphic methods on derived
1777:50 - pointers or references this is going to
1777:52 - be super cool in some cases okay so
1777:55 - let's look at our inheritance hierarchy
1777:58 - here the top class is going to be animal
1778:00 - as you see here it's going to have a
1778:02 - single virtual method it's going to also
1778:04 - have a virtual disruptor because we know
1778:06 - how to do this now we can derive from
1778:09 - this and create our filling class which
1778:11 - is going to be
1778:12 - inheriting publicly it's going to have
1778:15 - its own run method and it's going to
1778:17 - declare its own other method which is
1778:19 - not virtual we can also derive from
1778:22 - feline and create a dog class this is
1778:25 - how we do this and we're going to set up
1778:27 - our own virtual method in dog which is
1778:29 - going to be bark and we can really do
1778:31 - anything we want with this inheritance
1778:34 - hierarchy okay what we're going to be
1778:35 - using as input is a base class pointer
1778:38 - or a base class reference and we set
1778:40 - them up here this is our base pointer
1778:43 - this is our base reference and we want
1778:45 - to go from these and create a derived
1778:48 - class pointer or reference that we can
1778:51 - use to even call
1778:52 - non-polymorphic functions and we can
1778:55 - achieve that using dynamic casts here
1778:58 - we're going to show you how you can cast
1778:59 - pointers again our animal base pointer
1779:02 - is going to act as our input and the
1779:06 - output is going to be what we want to
1779:08 - get out of this transformation
1779:11 - and all we do is say dynamic cast we
1779:13 - specify a pair of angle brackets inside
1779:17 - we're going to specify the output we
1779:18 - want to get and this is usually going to
1779:21 - be a derived class pointer so the base
1779:24 - class pointer is going to be within this
1779:25 - parenthesis and and it's going to be our
1779:28 - output and this is going to do the
1779:29 - transformation and it's going to give us
1779:31 - a result that we're going to be storing
1779:34 - in our feline pointer here and if this
1779:37 - succeeds we will have a valid feline
1779:41 - pointer here and we can use it to call
1779:44 - non-polymorphic or non-virtual functions
1779:47 - like we are doing here and this is super
1779:49 - cool another thing you can do with this
1779:51 - is use the result of this transformation
1779:53 - in a pointer check for example we can
1779:56 - check and see if this pointer is not a
1779:58 - null pointer if it's not a null pointer
1780:01 - we can call our non-polymorphic function
1780:03 - to it the result was successful but if
1780:06 - it's no pointer we're going to fail and
1780:08 - fall down here and we can say that we
1780:11 - couldn't cast to a feeling pointer and
1780:14 - some of you might ask
1780:16 - how can this transformation fail well if
1780:19 - we go back to our code here we have an
1780:22 - animal base pointer which is really
1780:25 - pointing to a feline object in memory
1780:28 - if we try and cast this animal pointer
1780:31 - to dog
1780:32 - suppose we want to do this kind of
1780:34 - transformation try to think about this
1780:37 - this is not going to work because we
1780:38 - really have no dog information in this
1780:41 - villain object and if we try to cast
1780:43 - this to dog the compiler will really
1780:45 - have no way to do this and the
1780:47 - transformation through dynamic cast will
1780:50 - fail and we will say the message here
1780:53 - meaning that we couldn't do the
1780:55 - transformation the user asked for so
1780:58 - here we can do the transformation and
1781:00 - transform from a base pointer to a
1781:02 - derived pointer but we can also
1781:04 - transform to a derived reference and i
1781:07 - am going to show you the syntax to do
1781:09 - that and it is super simple we say
1781:11 - dynamic cast and we specify our input
1781:14 - reference
1781:15 - notice that this is a reference you have
1781:17 - to put it it's not a pointer and you
1781:20 - specify the output within this angle
1781:23 - brackets here once you do this the
1781:26 - output of this is going to be a derived
1781:28 - reference and we're going to store this
1781:30 - in our feline reference here once we do
1781:33 - this transformation and the
1781:35 - transformation is successful we're going
1781:36 - to be able to call our non-polymorphic
1781:39 - function this is going to work but with
1781:41 - references we don't have the luxury to
1781:43 - do something like a pointer check
1781:45 - because there is no such thing as a null
1781:47 - reference a reference is always pointing
1781:50 - to something
1781:51 - and if the transformation fails we will
1781:54 - have some kind of invalid reference and
1781:56 - if this fails it is probably going to
1781:58 - blow up and give us undefined behavior
1782:01 - so you don't really want to do this i
1782:03 - usually don't recommend
1782:06 - doing this kind of transformation with
1782:08 - references unless you know
1782:10 - that the transformation is possible
1782:12 - beforehand what i usually recommend is
1782:15 - to
1782:16 - pass through pointers and it is even
1782:18 - possible to transform a base reference
1782:21 - into a derived pointer and the syntax to
1782:24 - do that is what you see here okay and uh
1782:27 - once we do a transformation to a pointer
1782:30 - if the transformation is successful
1782:32 - we're going to have a valid pointer in
1782:34 - here if the transformation fails we're
1782:36 - going to have a null pointer and the
1782:38 - check is going to draw us here and we're
1782:40 - going to print this message to say that
1782:43 - we can't do the transformation here okay
1782:45 - again the cast may fail if it fails
1782:48 - while we are trying to transform it to a
1782:50 - dog pointer we are going to fall down
1782:52 - here and say that the cast failed we can
1782:55 - also do the same thing through
1782:56 - references for example if we want to
1782:59 - transform this base reference to a
1783:01 - derived pointer
1783:02 - and this fails we're going to follow
1783:04 - here because of the check we are doing
1783:06 - here we can do something like this to
1783:08 - make our code much safer to work with
1783:11 - and another thing i should really point
1783:13 - out is that in practice
1783:15 - casting like this is usually done in
1783:17 - functions where you are passing a base
1783:20 - pointer or a base reference as a
1783:22 - parameter and in this function you
1783:25 - somehow need to call a non-polymorphic
1783:28 - function so you might do something like
1783:30 - this and take the pointer and turn that
1783:32 - into a derived pointer and if the
1783:34 - transformation is successful you're
1783:36 - going to call your method and if the
1783:37 - check fails you're going to follow here
1783:39 - and print an error message you can do
1783:42 - something like this with pointers and we
1783:44 - can do exactly the same thing with
1783:46 - references but here because we want to
1783:48 - do this check we're going to transform
1783:51 - our base reference into a derived
1783:53 - pointer and call our method on the
1783:55 - derived pointer instead this is going to
1783:58 - give us the ability to do this kind of
1784:00 - check to make our code much safer to
1784:03 - work with a word of caution here
1784:05 - overusing down casting is a sign of bad
1784:08 - design if you find yourself doing this
1784:10 - kind of thing a lot to call
1784:12 - non-polymorphic function that's maybe a
1784:15 - sign that you should make that
1784:16 - non-polymorphic function
1784:18 - polymorphic because that's going to save
1784:21 - you from doing this kind of
1784:22 - transformations a lot just make sure you
1784:24 - don't overuse this and do it in a few
1784:27 - cases where you really need to do this
1784:30 - kind of thing now that you know this
1784:31 - we're going to head over to visual
1784:33 - studio code and play with us a little
1784:34 - more here we are in our working folder
1784:37 - the current project is dynamic casts
1784:40 - we're going to grab our template files
1784:43 - and we're going to put them in place
1784:44 - let's do that and we are going to grab
1784:46 - the files that make up our inheritance
1784:49 - hierarchy we're going to put those in we
1784:51 - have animal dog and feline and this is
1784:54 - going to make up our inheritance
1784:56 - hierarchy here once we have this in
1784:59 - place we can open this up in visual
1785:00 - studio code by dragging and dropping
1785:02 - here and this is going to give us our
1785:04 - files okay we have our files in here we
1785:07 - can open up the animal class which is
1785:10 - our base class we can see that it is
1785:12 - really simple it's just going to have
1785:14 - one virtual method which is brief it's
1785:16 - going to have a single member variable
1785:18 - which is description here we can derive
1785:20 - from this and create our feline class
1785:22 - which is going to inherit publicly from
1785:24 - animal feline is going to set up its own
1785:28 - method which is non-virtual
1785:30 - and we will have a virtual method called
1785:32 - run we can override in downstream
1785:34 - classes if we want to do that and let's
1785:37 - look at the implementation for feline
1785:39 - cpp if you want to do that you can take
1785:41 - a look it's just going to forward the
1785:43 - construction to the base class to build
1785:46 - the base part of us
1785:48 - let's look at dog dog is going to
1785:50 - inherit from feline and it is going to
1785:52 - set up a simple virtual function called
1785:55 - work and it's going to have a virtual
1785:56 - destructor now we know that we should
1785:58 - really put in
1785:59 - virtual disruptors if we happen to even
1786:02 - have a single virtual method in our
1786:04 - inheritance hierarchy because that's
1786:06 - going to make events easier now we want
1786:09 - to go to the main cpp file and play with
1786:12 - dynamic casts we're going to remove
1786:14 - whatever it is we don't need here and
1786:17 - that we can include our most derived
1786:19 - class let's include doug here this is
1786:22 - going to implicitly include
1786:24 - both feline and animal because this
1786:27 - header is going to include its parent
1786:30 - and its parent is going to include its
1786:32 - own parent this is the logic here we are
1786:34 - going to start out by using a simple
1786:37 - example here and show you that you can't
1786:39 - really call non-polymorphic functions
1786:42 - from a base pointer that is managing the
1786:45 - derived object and here we have an
1786:48 - animal pointer it is a base pointer and
1786:51 - it is managing a real feline object in
1786:54 - memory but if we try and call a
1786:57 - non-virtual function through this base
1786:59 - pointer this is going to blow up this is
1787:01 - not going to work because
1787:04 - we can't really call a non-polymorphic
1787:06 - function through a base pointer because
1787:08 - that's not a virtual function the
1787:10 - requirement to be able to do this is for
1787:12 - the function to be virtual and do some
1787:15 - feeling thingy is not a virtual function
1787:18 - that we know at the base level so this
1787:20 - is not going to work by default and if
1787:22 - we're trying to build code like this
1787:24 - this is going to give us a compiler
1787:26 - error let's pass this through gcc we're
1787:28 - going to do that we are going to finish
1787:31 - the world with errors and if we go up
1787:33 - we're going to find that class animal
1787:35 - has no member name to do some feline
1787:38 - thingy so this is the compiler error
1787:39 - here this is not going to work if we
1787:42 - need to do something like this one
1787:44 - solution might be to do dynamic casts
1787:47 - that we are learning about in this
1787:48 - lecture here and the syntax is
1787:51 - ridiculously simple so we can go down
1787:53 - here and put in a simple separator to be
1787:56 - able to follow this lens on our
1787:58 - powershell window you can do this if you
1788:00 - want and we're going to do our dynamic
1788:03 - cast for example if we wanted to do a
1788:06 - transformation and transform this to a
1788:09 - dark object this would give us a problem
1788:12 - and let's try and look at this again we
1788:14 - have a feline object here and we are
1788:16 - managing this through a base pointer and
1788:19 - what we want to do is to take this space
1788:21 - pointer and turn it into
1788:23 - a dog object if you look at this
1788:26 - remember that we don't really have any
1788:28 - dog information in our feline object
1788:30 - this is going to just go up to the level
1788:32 - of feline but we want to transform this
1788:35 - to a dog to make this super clear let's
1788:37 - look at our inheritance hierarchy again
1788:40 - what we have is a feline object and the
1788:43 - information we have really goes up to
1788:45 - this level
1788:46 - and we are managing our feeling object
1788:48 - through a base pointer this is the setup
1788:50 - we have but we want to do the
1788:52 - transformation and turn this base
1788:54 - pointer into a dog object and this is
1788:57 - going to blow up especially if we have
1789:00 - any dog specific member variables this
1789:02 - is going to blow up this is not going to
1789:04 - work if we try to access dog information
1789:06 - through
1789:07 - what we get through the transformation
1789:09 - to animal to dog we're going to get a
1789:11 - crush because we have no such
1789:13 - information and we're going to look at a
1789:15 - simple example to really drive this home
1789:17 - so what we're going to do is go back to
1789:19 - our dog class and we're going to put in
1789:21 - a sample member variable we're going to
1789:23 - make it private and for example we can
1789:26 - make this a member variable to keep
1789:28 - track of the speed for the dock we can
1789:30 - do this and we're going to initialize
1789:32 - this to 0 by default and we're going to
1789:34 - set up a function which is going to
1789:36 - print some dog information let's go back
1789:39 - to feline and copy the do some feline
1789:42 - thingy method and we're going to do some
1789:44 - dog thingy that's what we're going to do
1789:47 - here i am going to put in this method
1789:48 - and adapt it a little bit we're going to
1789:51 - do some dog thingy and we're going to
1789:53 - account for that in the body but we also
1789:56 - want to print the speed for this dog
1789:58 - here so we're going to say speed and
1790:00 - we're going to print this out suppose we
1790:03 - have this kind of setup in our
1790:05 - inheritance hierarchy here a dark object
1790:07 - has some doubt specific information it
1790:10 - has an additional member variable which
1790:12 - is m speed here we won't worry about
1790:14 - initializing this from the constructor
1790:16 - you can do that if you want all we
1790:17 - really want is to add some extra data at
1790:21 - the dog level and we're going to see
1790:23 - that if we try to transform to doug this
1790:25 - is going to give us a few problems so
1790:27 - what we want is to turn this animal base
1790:30 - pointer into a dark object let's do this
1790:33 - we're going to
1790:34 - change this to dog and the result object
1790:37 - we get is going to be a dog pointer and
1790:39 - we want to call the do
1790:41 - some dog thingy
1790:43 - method on the pointer we get as a result
1790:46 - of this transformation here let's see
1790:48 - what happens you're going to see that
1790:50 - this is not going to give us any
1790:51 - indication that we are doing something
1790:53 - wrong but if the transformation here
1790:56 - fails this is going to silently fail and
1790:59 - store junk data in our feline pointer
1791:01 - here and here we're going to try and
1791:04 - call a method that is going to possibly
1791:07 - use some dog stuff on the feline object
1791:10 - this is going to blow up again we don't
1791:12 - have dog information in this feline
1791:14 - object and the do some dog thinking
1791:16 - method is going to try and print the
1791:18 - speed of the dog that we don't really
1791:21 - have we don't have any dog information
1791:23 - so we have no business accessing dog
1791:26 - information from this object to start
1791:28 - with so this is going to blow up and
1791:30 - it's probably going to give us a crash
1791:32 - let's try and build and see what happens
1791:34 - we're going to pass this through gcc
1791:35 - like we always do the boat is going to
1791:37 - go through you see that this is going to
1791:40 - even blow up at run time when users are
1791:43 - actually using your application this is
1791:45 - super dangerous we're going to run this
1791:48 - and see what happens you see doing some
1791:50 - dug thingy and it's going to try and
1791:51 - print the speed the compiler is really
1791:54 - trying its best but this is really going
1791:56 - to fail and we are crashing our program
1791:59 - if you go down here and say done to make
1792:02 - sure we know when the program is done
1792:05 - and we try and run our program again
1792:07 - let's pass this through gcc to take into
1792:09 - account this thing we have on line 20.
1792:11 - the book is going to be good you're
1792:12 - going to see that the computer is going
1792:14 - to try and really run this but it's
1792:16 - going to see that it doesn't really have
1792:18 - any dog information and the computer is
1792:20 - not going to succeed because we are
1792:22 - trying to access this dub specific
1792:24 - information really on a feline object so
1792:27 - we are going to get a crash again the
1792:29 - message
1792:30 - is that this dynamic casts can fail
1792:33 - and we need a better way to do some kind
1792:35 - of checks before we call our methods
1792:38 - here and we can do this by just using
1792:41 - the pointer we get from this
1792:43 - transformation here so we can say if
1792:45 - feline pointer and check and see if we
1792:48 - have some valid data in this villain
1792:50 - pointer and if that's the case we're
1792:52 - going to do whatever we want to do with
1792:54 - this pointer here okay so this is
1792:57 - something we can do
1792:58 - and if the transformation fails we're
1793:01 - going to fall in this else block and we
1793:03 - can put some nice message here instead
1793:05 - of letting the user crash at runtime
1793:08 - this is much better in my opinion so
1793:11 - we're going to say couldn't do the
1793:13 - transformation from animal pointer to
1793:16 - dog pointer because we really have no
1793:18 - dog information and this base pointer
1793:20 - that we have here this is something we
1793:22 - can do so we're going to say sddc out
1793:24 - i'm going to say stdendl here and we're
1793:27 - going to see what happens let's build
1793:30 - hopefully we're not going to get the
1793:31 - crash because we are doing something
1793:33 - smarter now we are checking to see
1793:35 - if we have any dog information in this
1793:37 - pointer before we call some doubt
1793:40 - specific method on this pointer here
1793:42 - this is the beauty of this we're going
1793:44 - to clear and run rooster now you see
1793:47 - couldn't do the transformation from
1793:49 - animal to dog and our program is no
1793:52 - longer crashing it is ending properly
1793:54 - and this is much better this is what you
1793:56 - should aim for so again the
1793:59 - transformations here may fail
1794:01 - but
1794:02 - if we turn this back to doing v-line
1794:04 - transformation let's do feline pointer
1794:07 - we're going to change this to fill in
1794:08 - pointer again and we're going to do some
1794:11 - feline thing now we're going to bolt
1794:13 - again and this is true
1794:15 - we're going to bolt again and this is
1794:16 - going to build successfully and it is
1794:18 - going to probably do some filament
1794:20 - thingy the build is good we can clear
1794:23 - and run rooster this is going to work
1794:25 - just fine and our program is going to
1794:27 - end properly so here we just saw that we
1794:30 - could do a transformation from a base
1794:32 - pointer to a derived pointer and this is
1794:35 - going to work just fine we can also do
1794:37 - the transformation for references let's
1794:40 - say that here and we're going to go down
1794:42 - and put in a simple example to drive
1794:44 - this home we're going to have a feline
1794:46 - object we're going to set up a reference
1794:48 - to it and if we try and call a
1794:51 - non-virtual method on this base
1794:52 - reference this is going to blow up
1794:55 - because
1794:56 - the base class has no information about
1794:58 - this non-virtual method that we declare
1795:01 - at the feline level this is going to
1795:03 - blow up if we try to build our program
1795:05 - we're going to see that we get a
1795:06 - compiler error saying no such method
1795:09 - as
1795:10 - do some feeling thing we're going to see
1795:12 - that here no member named
1795:15 - this way at the animal level
1795:18 - this is the compiler error we get if we
1795:20 - try to call a non-virtual method through
1795:24 - a base reference that we have here this
1795:26 - is not going to work but we can also do
1795:29 - a dynamic cast and transform from a base
1795:32 - reference to
1795:33 - a derived reference and the syntax to do
1795:35 - that is really here we're going to set
1795:38 - up a
1795:39 - derived reference in this case it's
1795:41 - going to be a feedline reference we're
1795:43 - going to initialize this with a dynamic
1795:45 - cast transformation and the result of
1795:47 - the cast is going to be used to
1795:49 - initialize this reference here and we're
1795:51 - going to be taking
1795:53 - a base reference and turning that into a
1795:56 - derived reference here this is the
1795:58 - syntax the output you desire is going to
1796:00 - be within this angle brackets and the
1796:03 - input is going to be through this
1796:05 - parenthesis here if this succeeds we
1796:07 - will be able to call our method here and
1796:10 - this is going to work just fine let's
1796:12 - try this out
1796:13 - we are going to put in a separator to be
1796:16 - able to follow these things let's put
1796:18 - that at line 24 here this is going to do
1796:22 - and we're going to try and build our
1796:24 - program we're going to pass this through
1796:26 - gcc the boat is good we can clear and
1796:29 - run rooster now we're going to see that
1796:31 - we are doing some filling thingy through
1796:34 - a reference and this is super cool we
1796:36 - can do this you can do this kind of
1796:38 - transformation here and at the end you
1796:40 - see that we are calling our destructors
1796:43 - on our objects and this is a good
1796:45 - reminder that we didn't properly release
1796:48 - the memory on this animal pointer that
1796:50 - we had
1796:51 - so we are going to go down at the end of
1796:54 - the program and release that memory this
1796:56 - is good practice and hopefully you can
1796:58 - see how easy it is to forget to release
1797:02 - some memory that you allocate for
1797:04 - with the new operator this is a good
1797:06 - learning experience here but this is a
1797:08 - good learning experience here but we're
1797:10 - going to fix this problem we're going to
1797:12 - say animal one and we're going to
1797:13 - release the memory now if we run the
1797:16 - program we're going to see that we are
1797:18 - releasing two objects when the program
1797:21 - ends we're going to clear and run
1797:23 - rooster and the destructor is going to
1797:25 - be called two times once for this guy
1797:28 - and a second for this guy this is what
1797:30 - we want and you see that because we have
1797:33 - virtual destructors in our classes we
1797:36 - are destroying at each level so here we
1797:39 - are destroying at the feline level and
1797:41 - we are destroying at the animal level
1797:43 - and this is going to properly release
1797:46 - the memory from our inheritance
1797:48 - hierarchy here so now you know that you
1797:50 - can do a transformation of references
1797:52 - using dynamic casts
1797:54 - but with dynamic cast we have no way to
1797:57 - check and see if the transformation was
1798:00 - successful again if we try to turn this
1798:03 - into a dark reference we can do that and
1798:05 - we're going to say dog reference here
1798:07 - and we will try and call the do some
1798:10 - duck thingy method this is not going to
1798:13 - give us an indication of a problem but
1798:14 - this is going to crash at runtime
1798:17 - because we don't really have any dog
1798:18 - information in our
1798:20 - original feline object here so if you
1798:23 - try and transform this reference into a
1798:25 - dog reference this is obviously not
1798:28 - going to work because we have no dog
1798:29 - information in this to start with let's
1798:32 - boil and show you the problem the book
1798:34 - is going to be good so we can clear
1798:37 - and run rooster you're going to see that
1798:39 - we are going to terminate our program
1798:41 - with the band cast and this is going to
1798:44 - crush you see that we don't get to the
1798:46 - point where we print done and we are not
1798:48 - even going to get a chance to release
1798:50 - the memory that we have allocated in
1798:52 - this main function hopefully you can see
1798:54 - that this is really bad so with
1798:56 - references we have no way
1798:59 - to check and see if the transformation
1799:01 - was successful and this is a limitation
1799:04 - that's why in most cases i usually do my
1799:07 - transformations through pointers and
1799:10 - there is a way you can even turn this
1799:12 - base reference into a base pointer and i
1799:14 - am going to show you how you can do that
1799:16 - so we are going to go down here and try
1799:19 - to change things a little bit we are
1799:21 - going to say doing proper checks with
1799:23 - references and we're going to put in a
1799:25 - piece of code to play with us and what
1799:28 - we're going to do we're going to take
1799:29 - the
1799:30 - base reference and turn that into a base
1799:33 - pointer this is the syntax here again
1799:35 - the input is the base reference but the
1799:38 - output we desire is a base pointer and
1799:40 - this is possible in c plus plus this is
1799:43 - going to work just fine now we are going
1799:45 - to go on top and comment this
1799:47 - problematic transformation we just tried
1799:49 - to do and we're going to try and build
1799:51 - and see if this is actually working
1799:53 - if this transformation succeeds we're
1799:56 - going to do some villain thingy if it
1799:58 - fails we're going to say couldn't cast
1800:00 - to feline reference and we're going to
1800:02 - say that we are sorry this is a good
1800:04 - output message if we get something wrong
1800:06 - we're going to build this with gcc and
1800:08 - see if this actually works the world is
1800:11 - good we can clear
1800:12 - and run rooster you see that this is
1800:15 - working just fine we're going to hit the
1800:17 - end of the program and we are going to
1800:19 - destroy our objects here this is super
1800:21 - cool
1800:22 - but
1800:23 - if we try and do the transformation and
1800:25 - transform it to a dark object even if we
1800:27 - know that we don't have any dog
1800:29 - information in this object that we are
1800:32 - referencing to start with we hope that
1800:34 - we're going to get a good message and
1800:37 - the program is going to end properly
1800:39 - we're not going to get a crush so let's
1800:41 - make sure we are transforming to dog
1800:43 - here we're going to pass a dog pointer
1800:45 - as our output and we're going to store
1800:47 - this as a dog pointer even if the name
1800:49 - is still vlan pointer hopefully this is
1800:52 - not going to confuse you even if this is
1800:54 - named feline pointer it is a dot pointer
1800:56 - here because we just want to see
1800:59 - if we get the error message that we have
1801:01 - here so we are turning this reference
1801:03 - into a pointer and the benefit of this
1801:06 - is that a pointer can store
1801:09 - null pointers and we can use this to our
1801:12 - advantage to check and see if the
1801:14 - transformation here was successful if it
1801:16 - was successful we will call some dog
1801:19 - thank method let's say that here and if
1801:22 - this fails we're going to say that we
1801:23 - couldn't transform to doug and this is
1801:26 - going to give us a nice message and our
1801:28 - program is not going to crash we're
1801:30 - going to build this again with gcc what
1801:33 - is going to be good as you see here
1801:35 - we're going to clear and run rooster now
1801:37 - you see that we are saying we couldn't
1801:39 - catch the dog reference and our program
1801:41 - is not crashing so if you have a
1801:44 - reference to start with and you want to
1801:46 - do some proper checks after you do the
1801:48 - transformation to a derived pointer or a
1801:51 - derived reference this is the best of
1801:53 - both worlds you can do something like
1801:55 - this and your program is going to be
1801:57 - much safer the last thing i want you to
1801:59 - see is that these kinds of dynamic casts
1802:02 - are really useful if you are passing
1802:05 - base pointer or base references into
1802:07 - functions and here i am going to put in
1802:10 - a bunch of functions the first one is
1802:12 - going to take a base pointer the second
1802:14 - one is going to take a base reference
1802:16 - and it is going to say do something with
1802:18 - animal pointer and do something with
1802:20 - animal reference and inside we're going
1802:22 - to do our thing here we're going to take
1802:24 - the animal pointer turn that into a
1802:25 - feline pointer and we're going to do our
1802:27 - proper check and we're going to do some
1802:29 - feline thingy if the transformation was
1802:31 - successful we can do something like this
1802:33 - we can also do exactly the same thing
1802:36 - with references we're going to take our
1802:37 - input reference we're going to turn that
1802:39 - into a derived object and we can call
1802:42 - our method on this pointer and we're
1802:44 - going to do proper chats because we have
1802:46 - a pointer which has a concept of node
1802:49 - pointer that we get if the
1802:51 - transformation here fails this is the
1802:53 - setup we can use in our c plus programs
1802:56 - and we can use these methods to get
1802:58 - derived pointers that we can call even
1803:00 - non-polymorphic functions on and this is
1803:02 - going to work really well so we can go
1803:05 - down and comment out everything i guess
1803:08 - to make this super easy to follow but i
1803:11 - don't think we need to comment out
1803:12 - everything we can just comment out what
1803:14 - we just did here and we're going to be
1803:16 - reusing the reference we have here and
1803:19 - the pointer we have all the way to the
1803:21 - top so we're going to go down and put in
1803:23 - a separator here we can do that and
1803:25 - because of this separator i don't think
1803:27 - we even need to comment things out we
1803:30 - can remove our comment and leave the
1803:31 - code in because i want you to see that
1803:34 - super easily and we're going to call our
1803:36 - functions here we're going to say do
1803:37 - something with animal pointer and we're
1803:40 - going to pass an animal one which is a
1803:42 - pointer and we're going to say do
1803:43 - something with animal ref
1803:46 - we can do something like this and we're
1803:48 - going to pass an animal
1803:50 - ref we have this reference here and we
1803:52 - can do something like this you're going
1803:54 - to see that this is not going to give us
1803:56 - any kind of problem and it is going to
1803:58 - work just fine that's world we're going
1804:00 - to pass this through gcc the photo is
1804:02 - going to be good we can clear and run
1804:04 - rooster and down here you see that in
1804:06 - function taking base pointer doing some
1804:08 - feline thingy in function taking some
1804:11 - biz reference doing some feeling thingy
1804:13 - and this is working really fine this is
1804:15 - what we want in our c plus plus programs
1804:18 - this is really all i wanted you to see
1804:20 - in this lecture hopefully you didn't
1804:22 - find it confusing again the message is
1804:24 - that you can do dynamic casts to
1804:27 - transform from a base pointer to a
1804:29 - derived pointer or to transform from a
1804:32 - base reference to a derived reference as
1804:35 - we did
1804:36 - right here but transforming to a derived
1804:39 - reference has a drawback in that you
1804:42 - don't have a way to check and see
1804:45 - if the transformation was successful so
1804:47 - if you want to be able to do chats you
1804:49 - can do something like this and turn a
1804:51 - base reference into a derived pointer
1804:53 - and then we can check and see if the
1804:55 - pointer is not a node pointer if it's a
1804:58 - no pointer we will know that the
1804:59 - transformation failed and we will print
1805:01 - a good error message if the
1805:03 - transformation was successful we will
1805:05 - have a valid pointer in here and we will
1805:07 - call our derived non-polymorphic method
1805:10 - on our pointer this is going to work
1805:13 - really fine the last thing i want you to
1805:14 - see before we wrap up this lecture is
1805:17 - that dynamic casts are only going to
1805:20 - work with polymorphic inheritance
1805:23 - hierarchies so for example if we try and
1805:26 - turn a double into a string obviously
1805:29 - that's not going to work with the
1805:31 - dynamic cast but let's try and do that
1805:33 - to really show you that this is going to
1805:34 - give us a problem we're going to say
1805:36 - sddc out and we're going to put in a
1805:38 - separator here and we're going to set up
1805:40 - two variables one is going to be a net
1805:42 - for example and we're going to say data
1805:44 - we're going to put in a 45 and if we do
1805:47 - a dynamic cast to an sdd string for
1805:50 - example that's not going to work we're
1805:52 - going to say std string yana str meaning
1805:56 - that this is a string we're going to say
1805:58 - dynamic cast let's say we want to turn
1806:00 - this into an sdd string for example and
1806:03 - the input is going to be our data if
1806:05 - you're trying to do something like this
1806:06 - this is going to blow up you see that
1806:08 - even visual studio code is giving us a
1806:10 - squiggly line so this is not going to
1806:12 - work just make sure you use dynamic cast
1806:16 - in an inheritance hierarchy that
1806:19 - supports virtual functions this is the
1806:22 - design purpose for the dynamic cast if
1806:25 - you use this outside this context you're
1806:28 - going to get undefined behavior or even
1806:30 - compiler errors if you are lucky let's
1806:33 - try and weld and show you this we're
1806:34 - going to pass this through gcc and we're
1806:36 - probably going to get an error saying
1806:38 - that we can't transform from an integer
1806:41 - to a string for example let's go here
1806:43 - cannot dynamic cast so basically it is
1806:46 - saying dynamic casts are meant to work
1806:49 - only with pointers or references but
1806:52 - even then let's see if we can transform
1806:55 - from an end pointer to a string pointer
1806:58 - let's try and do that let's say we want
1807:01 - to turn the address of data or let's set
1807:04 - up a pointer to be explicit we're going
1807:06 - to say data ptr and we're going to
1807:09 - initialize this with the address of data
1807:11 - we can do something like this and we're
1807:13 - going to cast data ptr to an std
1807:17 - strength pointer let's see if we can do
1807:18 - this because it is meant to cast
1807:21 - between pointers and references but you
1807:23 - see that this is even not going to work
1807:26 - so you shouldn't really do something
1807:28 - like this if your input and output are
1807:31 - not part of the same polymorphic
1807:33 - inheritance hierarchy again dynamic
1807:36 - casts are meant to cast
1807:38 - from base information to derived
1807:40 - information and the input and output
1807:43 - must be part of the same polymorphic
1807:46 - inheritance hierarchy this is the
1807:49 - information i am trying to convey here
1807:51 - so this is bad don't do something like
1807:53 - this if you do this you're going to get
1807:55 - undefined behavior or you're even going
1807:57 - to get a bunch of compiler errors if you
1807:59 - are lucky this is really all we set up
1808:01 - to do in this lecture showing you that
1808:03 - you can use dynamic casts we are going
1808:06 - to stop here in this lecture the next
1808:08 - one we're going to show you what happens
1808:10 - if you try to call a polymorphic
1808:12 - function from a destructor
1808:15 - go ahead and finish up here and meet me
1808:17 - there in this lecture i am going to give
1808:19 - you a warning and that is to never call
1808:23 - virtual functions from constructors or
1808:26 - destructors i am going to repeat this
1808:29 - never never call virtual or polymorphic
1808:32 - functions either from constructors or
1808:34 - destructors and we're going to explore
1808:36 - why we're going to be using this
1808:38 - inheritance hierarchy we're going to
1808:39 - have a base class called base how
1808:42 - creative we're going to inherit from
1808:44 - base and create derived which is our
1808:47 - inherited class and we're going to be
1808:49 - using this to explore why we can't call
1808:51 - virtual functions from constructors and
1808:54 - destructors
1808:55 - this is what our code is going to look
1808:57 - like the base class is going to have a
1809:00 - protected member variable it's going to
1809:02 - have a bunch of virtual functions
1809:04 - we will have a virtual function to set
1809:07 - things up and it is just going to set
1809:09 - the value of our member variable to 10
1809:11 - and we're going to have a virtual
1809:13 - function called cleanup which is going
1809:15 - to maybe do some cleanup we're going to
1809:17 - see how this works out we also have a
1809:20 - method to get the value but i don't
1809:22 - think we will use this but you can keep
1809:24 - this and if you want notice that we are
1809:26 - trying to call the setup method from the
1809:29 - constructor
1809:30 - and you see that we have a comment that
1809:32 - says that this is going to do static
1809:34 - binding but we're going to see why in a
1809:36 - minute so this is our base class we can
1809:38 - derive from this class and create our
1809:41 - derived class we're going to inherit
1809:42 - publicly
1809:44 - and we are going to override the methods
1809:46 - we have in the base class we're going to
1809:49 - override the setup method as you see
1809:51 - here we're going to override the cleanup
1809:52 - method and
1809:54 - our destructor is also going to be
1809:56 - virtual because we are good c plus plus
1809:58 - citizens and this is the setup we have
1810:01 - once you have your inheritance hierarchy
1810:03 - set up you're going to do something like
1810:05 - this because you want polymorphic
1810:07 - behavior you're going to set up the base
1810:09 - pointer and you're going to use that to
1810:11 - manage a derived object and you can do
1810:13 - something like this now
1810:16 - considering this statement here i want
1810:18 - you to think about the order in which
1810:20 - constructors and destructors are going
1810:22 - to be called we have touched on this
1810:25 - subject before and we are going to
1810:27 - revisit this because it is really
1810:29 - important
1810:30 - in terms of calling virtual functions in
1810:33 - destructors and destructors
1810:35 - so when we do something like this the
1810:37 - base part of this object is going to be
1810:40 - wealth first so we are going to call the
1810:42 - base constructor first we're going to
1810:44 - set up the best part of us after that
1810:46 - we're going to set up the derived part
1810:48 - of us and we're going to call the
1810:50 - derived constructor
1810:52 - and after the derived part of us is set
1810:54 - up we can use our object like we do
1810:57 - always so we're going to use our object
1810:59 - to do whatever it is we want to do when
1811:02 - the time comes for this object to be
1811:04 - destroyed we're going to destroy the
1811:07 - derived part first
1811:09 - and then we're going to destroy the base
1811:11 - part first
1811:13 - now that we have considered this order
1811:15 - try to think about the setup when we
1811:17 - call a virtual function
1811:20 - from a constructor that's what we're
1811:21 - going to look at first the best
1811:23 - constructor is going to be called but
1811:25 - notice that by the time we call the base
1811:27 - constructor the derived part of us won't
1811:30 - be set up yet so if we try to call a
1811:33 - virtual function in the base constructor
1811:36 - there won't be a derived part to call
1811:39 - the most specialized method for so the
1811:42 - compiler will notice that we don't have
1811:44 - a derived part yet we will be at this
1811:47 - stage building the base part and if we
1811:49 - call a virtual polymorphic function we
1811:52 - want the most specific parts to be
1811:54 - called which should live in the derived
1811:56 - part but we haven't done the derived
1811:58 - part yet we are still building the base
1812:01 - part of us so the compiler is going to
1812:03 - notice that we don't have a derived part
1812:05 - and it is going to call the base version
1812:07 - of our virtual function that's why we
1812:09 - said that if you call a virtual function
1812:11 - from a constructor or a destructor
1812:13 - you're going to get static binding
1812:15 - results if you call a virtual function
1812:17 - you want the most specific version
1812:19 - called but we don't have that yet in the
1812:22 - base part because the derived part
1812:24 - haven't been set up that's why we get
1812:26 - static binding results i hope this makes
1812:29 - sense and we're going to get to the same
1812:30 - result if you try to call a virtual
1812:32 - function from a destructor if we get to
1812:35 - the point where our object needs to be
1812:37 - destroyed the derived part is going to
1812:39 - be wiped out first we're going to be
1812:41 - left with the base destructor and when
1812:43 - we hit this base destructor and call a
1812:46 - virtual function
1812:47 - that would mean to call the most
1812:49 - specialized
1812:50 - version of that method but the derived
1812:54 - part of our object has been already
1812:56 - wiped down so this is no longer existent
1812:59 - and we are trying to call the method on
1813:00 - this so the compiler is going to do the
1813:02 - next best thing it can do it is going to
1813:04 - call the best version of our virtual
1813:06 - function and again we are going to get
1813:08 - static binding results that's why it
1813:11 - isn't really wise to call a virtual
1813:13 - function either from a constructor or a
1813:16 - destructor now some of you must be
1813:18 - asking what if i really need to do setup
1813:20 - and clean up in the way that we set up
1813:22 - these things in our classes what if this
1813:25 - method is really useful maybe it is
1813:27 - setting up things we're going to be
1813:28 - using in our application we really need
1813:30 - this and the most logical point to call
1813:33 - this is the base constructor well you
1813:35 - shouldn't really put these in a
1813:36 - constructor what you could do
1813:39 - is maybe call this virtual method on
1813:42 - your object directly when the object has
1813:45 - finished being a constructor that's
1813:47 - going to be a better place to do this
1813:49 - because if you put that in a constructor
1813:52 - or a destructor you're not going to get
1813:54 - dynamic binding results and that's going
1813:56 - to be really bad so to sum up calling a
1813:59 - virtual function
1814:01 - from a constructor or a destructor want
1814:03 - to give you polymorphic or dynamic
1814:05 - binding results the call will never go
1814:08 - to a more derived class than the
1814:10 - currently executing constructor or
1814:12 - disruptor
1814:13 - and we will get static binding results
1814:15 - this is the idea i want to convey here
1814:18 - and as a guideline you should never call
1814:21 - virtual functions or polymorphic
1814:23 - functions from constructors or
1814:26 - disruptors if you really need this the
1814:28 - next best thing you can do is to call
1814:31 - your virtual functions directly on your
1814:33 - object after the object has been
1814:36 - properly
1814:37 - set up we can do something like this and
1814:39 - call our setup method and then we can
1814:41 - call cleanup when we think that we need
1814:43 - to clean up and you call cleanup after
1814:46 - you construct the object and you call
1814:48 - delete after you clean up your object
1814:50 - this is going to do whatever it is you
1814:52 - want to do with your polymorphic
1814:54 - functions and the calls to these virtual
1814:57 - functions want to be leaving inside a
1814:59 - constructor or a disruptor and this is
1815:01 - going to work really well now that you
1815:03 - know this we're going to head over to
1815:04 - visual studio code and play with us a
1815:06 - little more here we are in our working
1815:08 - folder the current project is
1815:10 - polymorphic functions and the structures
1815:13 - we should really say with constructors
1815:15 - and instructors but this is going to do
1815:17 - we're going to grab our template files
1815:20 - and we're going to put them in place and
1815:22 - we are going to open this little guy in
1815:24 - visual studio code by dragging and
1815:26 - dropping here this is going to give us
1815:28 - our main cpp file we can clean up a
1815:30 - little bit remove whatever it is we
1815:32 - don't need and i am just going to put in
1815:35 - my classes i am going to do that in the
1815:37 - main cpp file because that's going to be
1815:40 - much easier to follow we have our base
1815:42 - class it is going to have a single
1815:44 - member variable called m value and we
1815:47 - will have a virtual destructor
1815:50 - we will have a bunch of virtual
1815:52 - functions one is going to be setup which
1815:54 - is going to set our value the other is
1815:56 - going to be cleanup which is going to be
1815:58 - doing some cleanup here we will also
1816:00 - have a getvalue method which will get
1816:03 - this value and print it out if we want
1816:05 - but it is really not that useful here we
1816:08 - will also create a derived class which
1816:10 - is going to inherit publicly from base
1816:12 - it is not going to have its own member
1816:14 - variable all it's going to do is set up
1816:17 - a bunch of overrides for
1816:19 - the virtual functions we have in the
1816:21 - base class we're going to override setup
1816:23 - and in derived we're going to set our
1816:25 - value to 100 and we're going to clean up
1816:28 - and put a message that we are cleaning
1816:30 - up here once we have this set up we can
1816:32 - head over in the main function and set
1816:34 - up a base pointer which is going to be
1816:36 - managing a derived object a classic
1816:39 - setup for polymorphic behavior so we're
1816:41 - going to say base and i'm going to say p
1816:44 - bass and we're going to say equals new
1816:46 - derived this is going to give us our
1816:48 - object which is managed by a base
1816:51 - pointer and one thing i didn't show you
1816:53 - is that we are calling the setup virtual
1816:55 - function
1816:56 - from the base constructor this is what
1817:00 - we want to see we want to see what is
1817:01 - happening here now if we call this setup
1817:04 - function
1817:05 - we would expect polymorphism to kick in
1817:08 - because this is a virtual function
1817:10 - if the derived part is available we will
1817:12 - call the most specific setup function
1817:15 - and that would set up the value to be
1817:18 - 100 here if we get the value that's what
1817:21 - we would get let's see what we get here
1817:23 - if we try to get the
1817:25 - value that we have in this object here
1817:27 - so we will get auto value and we're
1817:30 - going to say p base get value we have
1817:33 - this function here and we will try to
1817:35 - print this out okay this is something we
1817:37 - can do in our c plus bus program and
1817:40 - we're going to see the value we get
1817:41 - because we are calling this virtual
1817:43 - function we expect polymorphism to kick
1817:45 - in and if polymorphism kicks in we're
1817:48 - going to call the most specialized
1817:50 - version of our virtual function here
1817:52 - that would be the override we have in
1817:54 - derived and that would give us 100. so
1817:57 - one would get to get 100 printed out
1817:59 - here but let's see what we get we're
1818:01 - going to run this through gcc our
1818:04 - favorite compiler the builder is going
1818:05 - to be good we can clear or bring up a
1818:08 - powershell window we're going to clear
1818:10 - now and run rooster we're going to see
1818:13 - that the base constructor is going to be
1818:14 - called base setup was called you see we
1818:17 - called the base version of this and the
1818:19 - derived constructor will be called and
1818:22 - we're going to see that the value
1818:24 - doesn't exist oh we didn't put the value
1818:26 - out let's do that my bad here we're
1818:29 - going to build again we're going to use
1818:31 - gcc to build and the world is good we
1818:33 - can clear and run rooster now we see
1818:36 - that the base setup method was called
1818:38 - and set the value to b10 and we are
1818:41 - really getting static binding results
1818:43 - because we are calling the setup
1818:46 - method from the base class and the base
1818:48 - version is being called so this is
1818:50 - classic static binding behavior but we
1818:54 - want polymorphic behavior to be working
1818:56 - here but we just saw the reason why this
1819:00 - is in the slides by the time we call
1819:02 - this virtual function we haven't set up
1819:05 - the derived part of us yet
1819:07 - and we have no way to call this virtual
1819:11 - function which lives in the derived part
1819:13 - of us so the compiler is going to do the
1819:16 - next best thing it can do it's going to
1819:18 - call the best version of this method and
1819:20 - we are going to get static binding
1819:22 - results and we are going to get the same
1819:24 - results if we try to call a virtual
1819:27 - function from the destructor for example
1819:30 - if we go in our destructor here
1819:33 - let's see if we can find it we're going
1819:35 - to go in our instructor here and say
1819:36 - this and say cleanup can do something
1819:39 - like this and you're going to see that
1819:41 - the cleanup version we call is the base
1819:43 - version of cleanup
1819:45 - and we don't really want to do something
1819:47 - like this we want the most derived
1819:49 - cleanup version to be called but we
1819:51 - won't get that because by the moment we
1819:54 - call this virtual function from our base
1819:57 - class
1819:58 - the derived part will already have been
1820:00 - wiped out so it won't be available and
1820:03 - the compiler will do the next best thing
1820:06 - it can do it is going to call the best
1820:08 - version of our cleanup function here i
1820:10 - hope this makes sense
1820:12 - again to really drive this home i
1820:14 - realize this can be confusing to many
1820:17 - people especially beginners if we are
1820:19 - calling a virtual function from a
1820:21 - constructor we will call that virtual
1820:23 - function when we hit the base
1820:25 - constructor but by the time we hit the
1820:27 - base constructor the derived part of us
1820:29 - hasn't been constructed yet so if we try
1820:32 - to call a polymorphic function needing
1820:34 - to hold the derived implementation that
1820:37 - won't be available and the compiler will
1820:39 - do the next best thing it can do it is
1820:42 - going to call the base version the same
1820:43 - phenomenon is going to happen in the
1820:45 - destructor when we are done using our
1820:48 - object we will destroy the derived part
1820:50 - information first and when we hit the
1820:53 - base destructor and call a virtual
1820:55 - function there won't be a most
1820:57 - specialized version of the virtual
1820:59 - function because the derived part has
1821:02 - been already destroyed and it doesn't
1821:04 - exist anymore so if we call a virtual
1821:06 - function from the base destructor we
1821:08 - will get the best version called and
1821:10 - this will give us static binding
1821:13 - behavior this is what we are
1821:15 - experiencing here okay so let's try and
1821:17 - run this program and see what we get we
1821:20 - will print out value here which is going
1821:22 - to give us static binding results but we
1821:25 - want to see which version of cleanup is
1821:28 - called this is what we want to see here
1821:30 - we're going to run the task to build
1821:32 - with gcc the world is going to be good
1821:34 - as usual we're going to clear and run
1821:36 - rooster and i'm going to see base
1821:38 - constructor called derived constructor
1821:40 - called and we're going to have a value
1821:42 - which is a junk value because we never
1821:44 - initialize this value but we don't see
1821:46 - our destructure is called what is going
1821:49 - on here
1821:50 - let's investigate this a little more the
1821:53 - reason is we are not explicitly
1821:55 - releasing this memory here through the
1821:57 - base pointer let's do that we're going
1821:59 - to delete p base here and we're going to
1822:02 - run again we're going to weld with gcc
1822:05 - now our destructors should be called
1822:07 - we're going to run rooster and we are
1822:09 - going to see that the base cleanup
1822:11 - version was called and again this is
1822:13 - giving us static binding results you
1822:16 - don't want something like this so if you
1822:18 - want to
1822:19 - get to this behavior i would advise not
1822:22 - to call the cleanup or setup functions
1822:24 - inside constructors or destructors and
1822:27 - that's the guideline i gave in the
1822:28 - slides you should really never call
1822:30 - virtual functions either from
1822:32 - constructors or disruptors especially if
1822:35 - you are doing this from a parent class
1822:38 - hoping to get the most specific virtual
1822:41 - function called through polymorphism if
1822:44 - you want to do that the best thing you
1822:46 - can do is to call the cleanup functions
1822:49 - and
1822:50 - is to call the setup and cleanup
1822:52 - functions after your object has been
1822:54 - properly constructed or before your
1822:57 - object gets to be destroyed so what you
1823:00 - can do here is call the setup method on
1823:03 - the pbes pointer here let's do that and
1823:06 - we're going to call setup this is going
1823:08 - to call our virtual function and we are
1823:10 - going to get polymorphic behavior this
1823:13 - is going to print a 100 as we expect
1823:15 - because it will call
1823:17 - the derived version of setup here and
1823:20 - before we delete our object we will need
1823:24 - to call the cleanup function if we need
1823:26 - to do some custom cleanup here so i'm
1823:28 - going to say
1823:29 - base and call the cleanup function and
1823:32 - this is going to give us the behavior we
1823:35 - want we're going to build our program
1823:37 - pass this through gcc the both is going
1823:40 - to be good we can clear
1823:42 - and run rooster and we are going to see
1823:44 - that this constructor was called derived
1823:47 - constructor was called we will call the
1823:49 - derived version of setup our value will
1823:51 - be 100 and when we get to release or
1823:54 - clean up our memory the derived version
1823:57 - of cleanup will be called and then we
1823:59 - will destroy the derived part of us and
1824:01 - then we will destroy the base part of us
1824:04 - this is going to work in line with the
1824:07 - behavior we are familiar with with
1824:09 - polymorphism and this is really cool so
1824:11 - this is what you should do you should
1824:13 - never call virtual functions from
1824:16 - distractors and constructors because
1824:18 - that's going to give you static binding
1824:20 - results and what you want in this case
1824:22 - is really
1824:23 - dynamic binding behavior this is really
1824:26 - all i have to share in this lecture i
1824:28 - hope you found it interesting we are
1824:30 - going to stop here in this one the next
1824:32 - one we're going to learn about the type
1824:34 - id operator that can come in handy
1824:37 - especially if you want to debug
1824:40 - polymorphic code in your c plus plus
1824:42 - program go ahead and finish up here and
1824:45 - meet me there in this lecture we're
1824:47 - going to learn about pure virtual
1824:48 - functions and abstract classes and pure
1824:52 - virtual functions are a mechanism we
1824:54 - have in c plus plus
1824:56 - to mean that the method isn't meant to
1824:59 - be implemented
1825:01 - in the base class
1825:03 - here we have a simple inheritance
1825:05 - hierarchy to try and drive this home the
1825:08 - base class is shape and we are deriving
1825:11 - from this class to create a circle class
1825:13 - and on the other side we are deriving to
1825:16 - create a rectangle class if we look in
1825:18 - the shape class we have two virtual
1825:20 - methods one is going to be used to
1825:22 - compute the perimeter of the shape
1825:24 - the other is going to be used to compute
1825:26 - the surface of the shape but if we go
1825:28 - down in our inheritance classes we're
1825:30 - going to see that we have the same
1825:32 - methods these are going to be overrides
1825:34 - of what we have in the base class
1825:37 - but the special thing about this
1825:39 - inheritance hierarchy
1825:41 - is that we don't have implementations
1825:43 - for these methods in the base class here
1825:46 - and this is by design if you think about
1825:48 - it this is an abstract shape we don't
1825:51 - know if it's a rectangle we don't know
1825:52 - if it's a circle we don't know if it is
1825:54 - a triangle so we don't really have
1825:57 - concrete information we can use
1825:59 - to properly compute its perimeter and
1826:02 - its surface so it makes sense to really
1826:04 - leave in the declaration for these
1826:07 - methods but leave the implementation
1826:10 - details to inheriting classes because
1826:13 - these classes are going to have concrete
1826:15 - information we can use to reliably
1826:17 - compute the perimeter and the surface
1826:19 - and we can get this information here
1826:22 - so in c plus plus we mean this kind of
1826:24 - design by setting up these methods as
1826:27 - pure virtual functions
1826:29 - and what this is going to tell the
1826:30 - compiler is these methods are not meant
1826:33 - to be implemented in the base class they
1826:36 - are meant to be
1826:37 - overridden and implemented by
1826:39 - inheritance classes and another side
1826:42 - effect of this is that the compiler is
1826:45 - going to prevent you from creating
1826:47 - objects of this class because it really
1826:50 - doesn't make sense to create an object
1826:52 - of shaping your design
1826:54 - if you want to be able to compute its
1826:56 - perimeter if you want to be able to
1826:57 - compute its surface so why bother
1826:59 - creating an object that you won't really
1827:02 - be using in your c plus plus program the
1827:04 - meaning for this base class is just to
1827:06 - be a an idea or a representation of a
1827:10 - shape without really going into the
1827:12 - concrete implementation of how that
1827:14 - shape really works
1827:16 - hopefully this makes sense so let's see
1827:18 - how we can do this in code here we have
1827:21 - a simple class which is going to be our
1827:23 - shape class we are going to have two
1827:26 - virtual functions we're going to have
1827:28 - the perimeter function we're going to
1827:30 - have the surface function these are
1827:31 - going to be virtual functions or virtual
1827:33 - member functions i should say but we are
1827:36 - going to make them
1827:38 - pure virtual functions by using the
1827:41 - syntax you see here so we're going to
1827:43 - prepare an echo zero and this is going
1827:46 - to tell the compiler that these are pure
1827:48 - virtual functions once you set up these
1827:51 - functions a few things are going to
1827:52 - happen in your class this class is going
1827:55 - to become an abstract class in that
1827:58 - you want to be able to create objects of
1828:00 - this class anymore if you try to do that
1828:02 - you will get a compiler error another
1828:04 - thing is that you don't need to put in
1828:07 - implementations for these methods
1828:09 - because you marked them as pure virtual
1828:12 - and what this means is that the
1828:14 - implementations will be put in by
1828:17 - inheriting downstream classes because
1828:20 - they will have concrete information to
1828:22 - compute the perimeter or the surface as
1828:25 - we have here so we don't need to bother
1828:27 - with definitions for these functions
1828:29 - here if you even try to put in a
1828:31 - definition here you're going to get a
1828:32 - compiler error because this is a virtual
1828:35 - function we have no business putting an
1828:37 - implementation in the base class here
1828:39 - these are meant to be implemented by
1828:42 - downstream inheritance classes okay once
1828:44 - we have our ship class and our
1828:47 - inheritance hierarchy we can try to run
1828:49 - this in our code for example if we try
1828:52 - and create a shape object we're going to
1828:54 - get a compiler error because shape is an
1828:56 - abstract class so we can't create
1828:58 - objects of it and i don't think i made
1829:01 - this super clear once you set up at
1829:03 - least one pure virtual function in your
1829:06 - class the class is automatically going
1829:09 - to become an abstract class and what
1829:12 - that means is that you want to be able
1829:14 - to create objects of this class so this
1829:16 - is an abstract class we have here and if
1829:19 - we try to create an object of it as we
1829:22 - are doing on this line here this is
1829:24 - going to give us a compiler error but we
1829:27 - can still use a base pointer to manage a
1829:30 - derived object
1829:32 - a common setup we do with polymorphism
1829:34 - so for example here we can set up a
1829:36 - shape pointer and use this to manage a
1829:38 - rectangle object if we call the surface
1829:41 - member function on our base pointer this
1829:44 - is going to do a polymorphic call and we
1829:46 - will get the surface of the rectangle
1829:49 - and we're going to print this out here
1829:50 - you're going to see that this is going
1829:52 - to work we can also use the base pointer
1829:54 - to manage a circle object as we see here
1829:56 - if we call the surface method this is
1829:58 - going to do polymorphism and it is going
1830:00 - to call the surface version of the
1830:03 - circle class and we can see it printed
1830:05 - out here this is the design we can
1830:07 - achieve even if shape is an abstract
1830:10 - class we can't create direct objects of
1830:12 - shape as we are doing here but we can
1830:15 - use a base pointer or a shape pointer to
1830:18 - manage derived object through
1830:21 - polymorphism and you need to be aware of
1830:23 - this okay now that you have an idea
1830:26 - about what a pure virtual function is
1830:28 - and what an abstract class is
1830:31 - let's see a few ideas you need to keep
1830:33 - in mind if your class has at least one
1830:36 - pure virtual function it will become an
1830:39 - abstract class you already know this you
1830:41 - can't create objects of an abstract
1830:43 - class if you try to do that you will get
1830:45 - a compiler error another thing i don't
1830:47 - think amid super clear is that derived
1830:50 - classes from an abstract class must
1830:53 - explicitly override all the pure virtual
1830:56 - functions from the base class
1830:59 - if you leave in any
1831:01 - pure virtual class that you don't put in
1831:03 - an implementation in for your derived
1831:06 - class is also going to become an
1831:08 - abstract class and you want to be able
1831:10 - to create objects of that you need to
1831:12 - keep this in mind another thing you
1831:13 - can't do you can't call the pure virtual
1831:16 - functions
1831:17 - from the constructor of the abstract
1831:20 - class if you do this you're going to get
1831:22 - a compiler error because we don't have
1831:24 - implementations for these things so this
1831:26 - is not going to work the constructor of
1831:28 - our abstract class is used by deriving
1831:31 - classes to build the base part of our
1831:34 - derived objects but they are not meant
1831:37 - to be used from the outside because we
1831:39 - can't really create an object of an
1831:41 - abstract class so now that you notice
1831:43 - we're going to head over to visual
1831:45 - studio code and play with this a little
1831:47 - more here we are in our working folder
1831:50 - the current project is pure virtual
1831:52 - functions and abstract classes we are
1831:55 - going to grab our template files and put
1831:58 - them in place and we're going to paste
1832:00 - them in this project here and we are
1832:03 - going to grab the files that make up our
1832:05 - inheritance hierarchy you are going to
1832:07 - get these files from the resource
1832:09 - section of the course if you want you
1832:11 - can download them and use them like i am
1832:13 - using them here or even better you can
1832:16 - type the code and see how these things
1832:19 - really work that's the best way to learn
1832:21 - i do recommend that but we want to save
1832:23 - on time here so i am just going to reuse
1832:25 - these glasses that i have lying on my
1832:28 - drive i am going to open this in visual
1832:30 - studio code by dragging and dropping
1832:32 - here we have our shape class here this
1832:35 - is going to be our base class you're
1832:38 - going to see that we have our member
1832:40 - variable which is going to be the
1832:42 - description for our shape we have a
1832:45 - bunch of constructors here but the most
1832:47 - important thing here is that we have a
1832:50 - bunch of pure virtual functions here and
1832:53 - if you go in the cpp file you're going
1832:54 - to see that we don't have
1832:56 - implementations then for the perimeter
1832:58 - and surface functions these are pure
1833:01 - virtual functions and we have no
1833:03 - business putting in an implementation in
1833:05 - the base class once we have these
1833:08 - virtual functions in and mark them as
1833:11 - pure virtual functions by prepending n
1833:14 - equals zero here this class here is
1833:16 - going to become an abstract class and
1833:19 - what that means is that we can't create
1833:21 - objects of this class it is meant ready
1833:24 - to be inherited from and downstream
1833:28 - inheritance classes are going to be
1833:30 - forced to
1833:32 - override these methods here otherwise
1833:34 - they are themselves going to become
1833:36 - abstract classes we're going to have a
1833:38 - chance to look at this here we also have
1833:40 - our rectangle class which is going to be
1833:42 - inheriting from shape it is going to
1833:44 - override our two methods we're going to
1833:47 - override the perimeter function we're
1833:49 - going to override the surface function
1833:50 - for rectangle the perimeter is computed
1833:53 - this way we're going to multiply
1833:55 - the width by two and the height by two
1833:58 - and we're going to add these two things
1834:00 - up we're going to compute the surface by
1834:02 - multiplying width and height and this is
1834:04 - going to give us the data we want we can
1834:06 - look at circle it is going to also
1834:08 - inherit from shape and it is going to
1834:10 - override our methods here if we want we
1834:13 - can even put in a radius and a variable
1834:16 - to keep track of pi we can do this you
1834:19 - can really do this however you want this
1834:21 - is just going to allow us to compute the
1834:23 - surface relatively easily in this class
1834:26 - here let's look at the implementation
1834:28 - nothing special here this is just going
1834:30 - to forward the construction of the base
1834:32 - part of us to the
1834:34 - base constructor and this is going to do
1834:36 - whatever it is we want to do here let's
1834:38 - head over to the main cpp file and
1834:40 - actually use these things
1834:43 - we are going to include circle and
1834:46 - rectangle let's do that circle dot h and
1834:49 - we're going to put in rectangle that h
1834:51 - and we're going to first try and create
1834:54 - a shape object let's do that we're going
1834:56 - to say shape and say shape pointer and
1834:59 - this is going to be new shape we can use
1835:02 - a default constructor and if we do
1835:04 - something like this you're going to see
1835:05 - that we're going to have a compiler
1835:07 - error here we have a squiggly line but
1835:10 - if we bring up a terminal window and
1835:12 - look at the problems tab we're going to
1835:15 - see that object of abstract class type
1835:18 - shape is not allowed so shape is an
1835:20 - abstract class now
1835:22 - and why is it an abstract class because
1835:25 - we have an at least one pure virtual
1835:28 - function here we actually have two and
1835:30 - this is going to make our shape class an
1835:32 - abstract class what that means is that
1835:35 - we can't create objects of this class
1835:37 - and if we do that we're going to get a
1835:39 - compiler error let's try and build this
1835:41 - program we're going to pass this through
1835:43 - gcc our favorite compiler we are going
1835:46 - to see that the bolt is going to fail
1835:48 - we're going to have a bunch of errors if
1835:50 - we go up and look at the error we have
1835:53 - invalid new expression of abstract class
1835:56 - type shape
1835:58 - so we can't really create an object of
1836:00 - this let's go down and see what these
1836:03 - errors are saying note because the
1836:05 - following virtual functions are pure
1836:07 - within shape and they are going to try
1836:10 - and really be helpful in the errors that
1836:12 - they give here and all they are saying
1836:15 - is that we can't create objects of this
1836:17 - class because we have pure virtual
1836:19 - functions inside okay now you know this
1836:22 - if a class is abstract you can't create
1836:24 - objects of that class but you can still
1836:27 - use a base pointer to manage derived
1836:29 - objects of that class so let's comment
1836:32 - this out because this is going to make
1836:35 - our code not compile and we're going to
1836:37 - say that this is going to give us a
1836:39 - compiler error and we're going to try
1836:41 - and use the base pointer to manage a
1836:43 - rectangle object we can do this so we're
1836:46 - going to set up a shape pointer and it
1836:48 - is going to be managing the memory of a
1836:50 - rectangle object we're going to go
1836:52 - through the base pointer and call the
1836:54 - surface method and this is going to call
1836:56 - the implementation in rectangle because
1836:59 - our base pointer is really managing the
1837:01 - rectangle object if you want you can
1837:03 - even use the type id operator to print
1837:06 - the dynamic type of this shape rect
1837:08 - pointer you're going to see that it is
1837:10 - managing a rectangle you can actually do
1837:12 - this because we learned about that in
1837:13 - the last lecture so let's practice that
1837:15 - we're going to say dynamic type of shape
1837:18 - wrap and we're going to say type id and
1837:21 - we're going to de-reference the pointer
1837:23 - we're going to say shipwrecked and we're
1837:25 - going to print the name of this and
1837:27 - we're going to see it print out on our
1837:29 - powershell window and after this we are
1837:31 - going to print the surface that we got
1837:33 - from this call here and we're going to
1837:36 - see what this gives us let's try and
1837:39 - build this program we're going to pass
1837:40 - it through gcc our favorite compiler the
1837:43 - bullet is going to be good we're going
1837:45 - to clear and run rooster we're going to
1837:47 - see that the dynamic type is rectangle
1837:50 - you can see that right here so the base
1837:52 - pointer is really managing a rectangle
1837:54 - object and this is what we have here and
1837:57 - if we call the surface method we will be
1837:59 - calling the method on the dynamic type
1838:03 - so we will be calling this surface
1838:04 - method on the rectangle class and we
1838:07 - will be
1838:08 - using the implementation we have here so
1838:11 - the surface function that is going to be
1838:13 - called is what we have on line 20 in
1838:16 - rectangle here and this is going to just
1838:18 - be a multiplication of width and height
1838:21 - and we're going to get 100 here because
1838:24 - our width and height happen to be
1838:26 - 10 and 10 so multiplying this is going
1838:28 - to give us 100 as we see here this is
1838:31 - really cool this is what we expect we
1838:33 - can even use our base pointer to manage
1838:36 - a circle object so let's do that we're
1838:38 - going to put in a separator to be able
1838:40 - to follow this easily and our output so
1838:43 - let's say stdndl here and we're going to
1838:46 - put in the code so we're going to set up
1838:48 - a base pointer which is really going to
1838:50 - be managing a circle object here and we
1838:53 - will call our surface method this is
1838:55 - going to call this method
1838:57 - polymorphically because surface is a
1838:59 - virtual function
1839:00 - so we will get polymorphism here and we
1839:03 - will call the surface method on the
1839:05 - circle object which is really our
1839:07 - dynamic type if we print this out we're
1839:09 - going to see the surface printed out but
1839:12 - if we want we can even print the dynamic
1839:14 - type of our
1839:16 - base pointer here so we're going to do
1839:18 - the same thing we did for rectangle we
1839:20 - can use our type id operator to print
1839:23 - the dynamic type of shape circle and
1839:26 - we're going to say shape circle here and
1839:28 - this is going to do what we want let's
1839:31 - look at this we're going to be printing
1839:32 - the surface here this is exactly what we
1839:35 - want so let's build and run we're going
1839:37 - to pass this through gcc the bolt is
1839:40 - going to go through as you see here if
1839:41 - we clear
1839:42 - and run rooster we're going to see that
1839:45 - the dynamic type is now a circle so the
1839:47 - base pointer or the shape pointer we
1839:50 - have here is really managing
1839:52 - a circle object polymorphically so if we
1839:55 - call a virtual function on this base
1839:57 - pointer it is going to call
1839:59 - the most
1840:01 - specific implementation of the surface
1840:03 - object we have and that happens to be
1840:05 - for this circle object here this is what
1840:08 - i mean
1840:08 - if we compute the surface we're going to
1840:10 - see that it is going to be using the
1840:12 - data we have here and we will get this
1840:14 - number as our surface if you plug this
1840:17 - in you're going to see that this is
1840:18 - really right so this is really all i had
1840:21 - to share in this lecture we can set up
1840:23 - pure virtual functions in a base class
1840:26 - and what that's going to do it is going
1840:28 - to make our class an abstract class but
1840:31 - we want also be able to put in
1840:33 - implementations for these
1840:35 - methods anymore in the base class
1840:37 - because they are meant to be
1840:39 - overwritten and implemented by
1840:41 - downstream inheritance classes so if you
1840:44 - go in here and try to put in an
1840:46 - implementation we will probably get a
1840:49 - compiler error because this is not
1840:50 - allowed you see we have a problem here
1840:53 - if we try to build we will get a weird
1840:55 - compiler error let's make sure we see
1840:57 - the compiler error so world finished
1840:59 - with errors and we are going to see
1841:02 - what's the problem here let's go up and
1841:05 - see
1841:06 - pure specifier on function definition so
1841:09 - this is not allowed so we are really
1841:12 - conflicting ourselves here we are
1841:15 - marking this function as a pure virtual
1841:18 - function
1841:19 - and what that means and a pure virtual
1841:22 - functions isn't meant to have a
1841:24 - definition but we are also putting in a
1841:26 - definition here so the compiler is going
1841:28 - to be confused this is not something we
1841:29 - should be doing another thing i want to
1841:32 - point out before we wrap up this lecture
1841:34 - is that
1841:35 - downstream inheriting classes are forced
1841:39 - to override and implement all the pure
1841:42 - virtual functions from the class that
1841:44 - they inherit from if they don't do that
1841:47 - they are themselves going to become
1841:49 - abstract and we want to be able to
1841:51 - create objects of them so let's try and
1841:54 - for example comment out the surface
1841:56 - implementation here and that's going to
1841:58 - make our circle class an abstract class
1842:02 - and if we try to create an object with
1842:03 - circle we will get a compiler error
1842:06 - because now circle is an abstract class
1842:08 - let's try and build and show you the
1842:10 - compiler error and this can really be
1842:12 - confusing if you are a beginner on this
1842:15 - you will be wondering why you can't
1842:17 - create objects of your class even if you
1842:20 - didn't really explicitly put in any pure
1842:23 - virtual function the reason is we are
1842:26 - inheriting from an abstract class that
1842:29 - has two pure virtual functions but we
1842:32 - are only overriding one pure virtual
1842:35 - function we need to override all of them
1842:38 - otherwise our class is also going to be
1842:40 - an abstract class let's look at the
1842:42 - compiler error we are getting here let's
1842:44 - go up and see if we can find it we are
1842:47 - going to say in function in main
1842:49 - evaluate new expression of abstract
1842:52 - class type circle we are trying to
1842:55 - create an object from an abstract class
1842:58 - this is the error we have here and you
1843:00 - should really note this
1843:01 - so let's go back and make sure we are
1843:04 - overriding all these stunts because we
1843:06 - need to do that to be able to create
1843:08 - objects of a circle and now this is
1843:11 - going to work exactly as it should let's
1843:14 - build and make sure of that the bullet
1843:16 - is going to be good we are fine this is
1843:18 - working exactly as we want this is
1843:20 - really all i wanted you to see in this
1843:22 - lecture i hope you found it interesting
1843:24 - we are going to stop here in this one
1843:27 - the next one we're going to learn about
1843:28 - interfaces in c plus plus and they are
1843:31 - going to be reusing the knowledge we
1843:33 - learned about in this lecture go ahead
1843:35 - and finish up here and meet me there in
1843:37 - this lecture we're going to see that we
1843:39 - can model interfaces in c plus plus
1843:43 - using abstract classes
1843:45 - and now there's a lot of things that
1843:47 - might not make sense in what i just said
1843:50 - so let's break this apart an interface
1843:52 - can be thought of as an abstract class
1843:55 - with only pure virtual functions and no
1843:59 - member variable so if you have a setup
1844:02 - like that you can call that thing an
1844:03 - interface let's look at a simple example
1844:06 - here here we have a simple class called
1844:08 - stream insertable you see that it
1844:10 - doesn't have any member variable it only
1844:12 - has a pure virtual function here and a
1844:16 - helper function that we could set up to
1844:18 - help us do a few things the only
1844:20 - specification to make this an interface
1844:23 - is to have in only pure virtual
1844:26 - functions and no member variables if you
1844:29 - have in a member variable this is going
1844:31 - to stop becoming an interface in c plus
1844:33 - plus okay so you can think of an
1844:35 - interface as an abstract class
1844:38 - with at least one pure virtual function
1844:40 - and no member variable that's going to
1844:43 - make it an interface down here you see
1844:45 - that an interface can be thought of as a
1844:48 - specification of something that will be
1844:51 - fully implemented in a derived class
1844:54 - but the specification itself is going to
1844:56 - reside in the abstract class another way
1844:59 - to think about an interface is to treat
1845:02 - an interface as a thing
1845:05 - you can attach to your types to give
1845:07 - them superpowers for example this stream
1845:10 - insertable interface
1845:12 - has a single job and that's going to
1845:14 - allow our types to insert data into
1845:17 - output streams like sddc out this is the
1845:20 - only thing this interface is going to
1845:22 - add to our times so we can take this
1845:25 - interface and attach that to a point
1845:27 - class for example and we will
1845:29 - automatically be able to print point
1845:31 - objects to the output stream and we want
1845:34 - to need to overload the stream output
1845:37 - operator in the point class we can do
1845:39 - the same thing to our bird class we can
1845:41 - do the same thing to our dog class and
1845:44 - we will be able to print these things
1845:46 - without having to overload the stream
1845:48 - output operator hopefully you can see
1845:50 - how powerful this is if we manage to set
1845:53 - up this kind of relationship between our
1845:55 - type and our interfaces so again an
1845:58 - interface is something you can attach to
1846:00 - your types to give them powers or
1846:03 - features that they originally didn't
1846:05 - have and that's going to save you from
1846:07 - having to implement these features
1846:10 - separately in each class for real time
1846:12 - so this is a huge time saver now you
1846:14 - must be asking how do i take my
1846:16 - interface and attach it to my type well
1846:19 - the way c plus plus does this you have
1846:22 - to inherit from the interface from your
1846:25 - type to attach the interface to your
1846:28 - type so for example if we wanted to
1846:30 - attach this interface to our point class
1846:32 - what we would do is something like this
1846:34 - we would set up our point class
1846:37 - and inherit from our interface which is
1846:40 - stream insertable the moment we do this
1846:42 - our point is going to be able to print
1846:44 - thanks to the console through the stream
1846:47 - output operator but hopefully you can
1846:49 - see that something is missing how does
1846:52 - our point class know how to print stuff
1846:55 - if we go up and look at our stream
1846:57 - insertable interface we're going to see
1846:59 - that it is declaring a stream output
1847:02 - operator it is this thing that is used
1847:05 - to print data to the output stream you
1847:07 - see this is a regular output stream
1847:09 - operator we will be printing to sddo
1847:12 - stream and the object is named out here
1847:16 - and we will be printing whatever operand
1847:18 - that is passed as a second parameter
1847:20 - here but the catches
1847:22 - we will need to set up a virtual
1847:24 - function
1847:25 - that will need to be implemented by
1847:28 - whoever inherits from our interface here
1847:31 - and this is going to be super powerful
1847:34 - we are going to take over the job to
1847:36 - print to the output stream but we will
1847:38 - let inheriting download classes to
1847:42 - specify what we print and they are going
1847:44 - to specify that in this virtual method
1847:47 - let's look at our point class again and
1847:49 - really put the puzzles together here and
1847:52 - understand how this works okay this is
1847:55 - our point class and it is going to be
1847:57 - inheriting from our interface and it is
1848:00 - going to implement our virtual function
1848:02 - here we are going to set it up here and
1848:04 - we are going to mark it as an override
1848:07 - because it is overriding a method that
1848:09 - comes from our stream insertable
1848:11 - interface here and it is going to
1848:13 - specify which data we print to the
1848:16 - output stream and how the data is going
1848:18 - to be printed out you can specify
1848:20 - these things here we're going to format
1848:22 - the data in a point and we're going to
1848:24 - be using these square brackets to put mx
1848:27 - and my here and notice that this is an
1848:30 - override so the inheritance class has
1848:33 - all the information we need to put in
1848:36 - our output stream operator and we will
1848:38 - do that through our stream insert
1848:40 - override here now let's go back to our
1848:43 - stream insertable interface to see how
1848:46 - our output stream operator actually
1848:48 - works what we have here is what would be
1848:51 - a header and this is going to just put
1848:53 - in a declaration for this but we can
1848:55 - even look at its implementation the
1848:58 - implementation for our output stream
1849:00 - operator may look something like this we
1849:02 - are going to pass in the first operand
1849:04 - and the second operand here but notice
1849:06 - what we are doing here we are going to
1849:09 - call
1849:10 - the stream insert virtual function on
1849:13 - our operand here and this is going to
1849:16 - call
1849:17 - the most specific implementation we can
1849:20 - find for the stream insert if we are
1849:22 - trying to print a circle for example
1849:24 - this is going to call the stream insert
1849:27 - override on a circle object if we are
1849:30 - trying to print a point this is going to
1849:32 - call this method on our point object and
1849:35 - this is going to use polymorphism
1849:37 - because our second operand here is pass
1849:40 - by reference hopefully you can see how
1849:42 - this is super powerful i know this is
1849:44 - convoluted because we are jumping around
1849:46 - trying to explain this but i couldn't
1849:49 - really come up with an easier way to put
1849:51 - this we have to try this encode to
1849:54 - really see the power of this but this is
1849:57 - really the power of interfaces we can
1849:59 - design our features and wrap them in an
1850:02 - interface and we can really attach that
1850:04 - interface to any type we have in our c
1850:06 - plus plus program and that type is going
1850:09 - to automatically inherit the features
1850:11 - that we have set up in our interface for
1850:14 - example now that we have attached this
1850:16 - interface to our point here we can print
1850:19 - our points on the output stream and this
1850:21 - is going to work automatically you see
1850:23 - that we don't need to set up an output
1850:25 - stream operator on our class altogether
1850:28 - we can even go further and attach this
1850:30 - interface to a full inheritance
1850:33 - hierarchy for example if we have our
1850:35 - base class to be animal and we inherit
1850:38 - from this class to create all kinds of
1850:40 - crazy classes we can go on and attach
1850:43 - our interface to the base class here and
1850:46 - this is going to make all our classes in
1850:49 - our inheritance hierarchy have the
1850:52 - features that the interface has brought
1850:54 - to the base class so for example we can
1850:57 - attach our interface to the animal class
1850:59 - by inheriting from stream insertable
1851:02 - here and this is going to give our
1851:05 - animal the powers to be printed out to
1851:08 - output streams and this is going to be
1851:10 - powered by the virtual function that we
1851:13 - are overriding here you see
1851:15 - we are going to specify which data to
1851:18 - print in our animal class and how the
1851:20 - data is going to be printed out here and
1851:22 - we can do that in this override and this
1851:24 - is super powerful once we do this we're
1851:27 - going to go to each class in our
1851:28 - inheritance hierarchy and implement the
1851:31 - stream insert
1851:33 - override because if we don't do that
1851:35 - this class is also going to become an
1851:37 - abstract class because it is inheriting
1851:40 - from a class that has a pure virtual
1851:42 - function remember if you inherit from a
1851:45 - class that has at least one pure virtual
1851:48 - function you will be forced to implement
1851:51 - all the pure virtual functions that come
1851:54 - from your parent class if you don't do
1851:55 - that you are going to become an abstract
1851:58 - class yourself and we don't really want
1852:00 - that that's why we are overriding the
1852:02 - stream insert override here and with
1852:05 - this we are going to specify which
1852:07 - information to print from our object
1852:09 - here and here we are going to put out
1852:11 - the description and the wing color and
1852:14 - this is the format we specify here and
1852:16 - this method is going to be called by our
1852:18 - output stream operator which is coming
1852:21 - from our stream insertable interface
1852:24 - hopefully you can see how this is super
1852:26 - powerful okay now that you know this
1852:28 - we're going to head over to visual
1852:29 - studio code and play with us a little
1852:31 - more here we are in our working folder
1852:34 - the current project is abstract classes
1852:36 - as interfaces we're going to grab our
1852:39 - template files and put the data in place
1852:42 - and i'm going to copy this and put that
1852:45 - in here
1852:46 - we are going to put in the files we're
1852:48 - going to be using in our inheritance
1852:50 - hierarchy you see we have our animal
1852:52 - hierarchy here you can grab these files
1852:55 - from the resource section of this
1852:58 - lecture and you can reuse them like we
1853:00 - are using here or if you want you can
1853:02 - even type this but i don't really
1853:04 - recommend this because this is too much
1853:05 - typing we just want to learn about
1853:07 - interfaces here and that's what you
1853:10 - should focus on so we're going to open
1853:11 - this up in videos video code and this is
1853:14 - going to give us all the files we need
1853:16 - we're going to look at the top class and
1853:18 - we will see that it is inheriting from
1853:21 - our stream insertable interface so let's
1853:24 - look at our stream insertable interface
1853:27 - because this is the focus of this
1853:29 - lecture here so it is a regular class as
1853:32 - you see here it is class stream
1853:33 - insertable we're going to set up an
1853:35 - output stream operator and it is really
1853:38 - like any other output stream operator
1853:40 - you have seen we're going to pass the
1853:42 - second operand by reference
1853:44 - and we are going to specify our pure
1853:47 - virtual function which is going to be
1853:49 - implemented by downstream inheriting
1853:52 - classes from this class here and this is
1853:54 - going to set up polymorphism and what
1853:57 - this will do
1853:58 - is if we call this method on our second
1854:02 - operand here we are going to call this
1854:04 - method polymorphically so if you are
1854:06 - trying to print a point we are going to
1854:08 - call this method on a point object and
1854:10 - we will print it out exactly how the
1854:12 - point wants to be printed if we are
1854:15 - printing a circle we will call this
1854:17 - stream insert method on the circle and
1854:20 - we will print a circle exactly how a
1854:22 - circle wants to be printed out let's
1854:25 - look at the implementation and it is
1854:27 - nothing really complicated we're going
1854:29 - to specify our output stream object as
1854:32 - the first parameter here and the second
1854:34 - parameter is what we want to print out
1854:37 - we will pass this by reference and this
1854:39 - is going to allow us to do polymorphism
1854:41 - remember that stream insertable is
1854:43 - really going to become our top base
1854:45 - class so we will basically be setting up
1854:48 - stream insertable polymorphism here you
1854:51 - need to keep this in mind we are going
1854:53 - to call our stream insert method on our
1854:56 - operand and we're going to pass the
1854:58 - stream output we want to print on and
1855:00 - we're going to return this output stream
1855:02 - to really make this behave
1855:05 - like a regular output stream operator to
1855:08 - allow output chaining in our operator
1855:11 - here once we have this stream insertable
1855:14 - interface we can really use it however
1855:16 - we want let's head over to the main cpp
1855:19 - file and try to play with us so what we
1855:22 - are going to do is crack this open and
1855:25 - we are going to remove whatever it is we
1855:27 - don't need we are going to include our
1855:30 - interface so we're going to include
1855:32 - stream insertable let's do that
1855:35 - insertable.h i think this is the name
1855:37 - and we're going to set up a point class
1855:39 - which we wish to be printed out on the
1855:42 - output stream notice that we want to
1855:44 - inherit from stream insertable and what
1855:47 - this is really doing is attaching the
1855:50 - interface to the point class here and
1855:52 - because this stream insertable
1855:55 - interface has a pure virtual function
1855:58 - we need to
1856:00 - override this pure virtual function here
1856:02 - if we don't we want to be able to create
1856:04 - objects of our point here let's go down
1856:07 - and show you that we're going to get
1856:08 - that problem if we don't do that we're
1856:11 - going to say point
1856:12 - and say p1 and for example put in 10 and
1856:15 - 20
1856:16 - we will have a compiler error because
1856:19 - now the point class is an abstract class
1856:22 - because it is inherited from a class
1856:24 - that has a pure virtual function and it
1856:27 - is not overriding that pure virtual
1856:29 - function
1856:30 - so in other words this class still has a
1856:34 - non-implemented pure virtual function
1856:37 - that's why it is
1856:38 - an abstract class and we can't create an
1856:41 - object of it if we're trying to run this
1856:43 - code we're going to pass this through
1856:45 - gcc we will get a compiler okay we have
1856:48 - a compiler error here and we need to fix
1856:50 - this all we need to do is to implement
1856:52 - the interface that comes from our stream
1856:55 - insertable interface here so we can grab
1856:58 - our pure virtual function and implement
1857:01 - it in our main cpp file for the point
1857:05 - class we're going to put it in here and
1857:07 - we will remove the pure virtual function
1857:10 - specifier here and we will put in an
1857:12 - implementation we want to specify that
1857:15 - this is an override of a method that is
1857:17 - coming from our upstream parent class
1857:21 - and we are going to head over in the
1857:23 - body of our function and put in the
1857:25 - information we want to put out
1857:27 - this is a point object so we just want
1857:29 - to print the m x coordinate and the m y
1857:33 - coordinate here and this is the format
1857:36 - that we want and at this moment the job
1857:39 - of this function is really done
1857:41 - and it will be picked up polymorphically
1857:44 - if somebody tries to call this on a
1857:46 - point object through polymorphism and
1857:49 - this is going to work now that we have
1857:50 - this point we can try and build and make
1857:53 - sure this is working let's make sure we
1857:55 - don't have the compiler error anymore
1857:57 - the world finished successfully so we
1857:59 - are cool here but what we want to see is
1858:02 - that we are able to print
1858:04 - point objects because that's the whole
1858:06 - point of attaching this interface to our
1858:09 - point class here so what we are going to
1858:11 - do is print this out we're going to say
1858:13 - sddc out we're going to say p1 and we're
1858:15 - going to say p1 here this is how we
1858:18 - would use our output stream operator you
1858:21 - see we don't have a compiler error this
1858:22 - is really magic some of you are going to
1858:25 - ask how is this even working somebody is
1858:27 - going to look at your class they are
1858:28 - going to look you don't have an output
1858:30 - stream operator but you can print your
1858:32 - objects so how is this working well this
1858:35 - is working through the magic of
1858:37 - interfaces we are attaching this
1858:40 - interface to our point class and this is
1858:43 - going to give our class the powers that
1858:45 - come from this interface and one of
1858:47 - those powers is to use the output stream
1858:50 - operator we get from this interface we
1858:52 - can use that directly and what this is
1858:54 - going to do let's look at the
1858:56 - implementation of this interface this is
1858:58 - going to just call the stream insert
1859:01 - virtual method on the object that we
1859:04 - pass as a second parameter in this
1859:07 - operator here and the second parameter
1859:09 - happens to be the point that we are
1859:11 - printing here so what this is really
1859:13 - going to do
1859:15 - is something like this we're going to
1859:17 - try and figure out what the compiler is
1859:19 - going to try and do we are going to say
1859:22 - p1 and we're going to say operator
1859:25 - stream output and we're going to say
1859:27 - stdc out that's the stream we want to be
1859:30 - printing to
1859:32 - and the point we want to print is p1
1859:34 - this is basically what the compiler is
1859:36 - going to do and it is going to print our
1859:38 - thumb and this method is available in
1859:41 - our stream insertable header and it is a
1859:43 - friend of our interface that's why we
1859:46 - are able to do something like this
1859:49 - accessing the data from our interface
1859:51 - let's build and actually show you that
1859:52 - this is going to work we're going to
1859:54 - pass this through our gcc compiler the
1859:57 - build is going to be good so we can
1859:58 - clear not clear we're going to control z
1860:01 - on this and we're going to bring up a
1860:03 - powershell window and we're going to
1860:05 - clear this time and run rooster you see
1860:07 - that we are creating our point here and
1860:09 - this is really cool we can even
1860:10 - uncomment this and we're going to use
1860:13 - sddc out because the compiler is going
1860:15 - to take this and turn that into this and
1860:18 - we have the ability to have code that is
1860:21 - much more readable by c plus plus
1860:23 - developers out there we're going to
1860:25 - build and run this again the build is
1860:27 - going to be good we can clear and run
1860:30 - rooster and this is going to print our
1860:32 - point here this is really cool but this
1860:34 - is not the end of our store we can even
1860:37 - print an entire inheritance hierarchy
1860:40 - look at what we did at our animal class
1860:43 - here we attached this interface to our
1860:47 - animal class and the moment we do that
1860:49 - we need to override the pure virtual
1860:52 - function
1860:53 - that comes with this interface and
1860:55 - that's what we did down here we have
1860:57 - overwritten the stream insert
1861:00 - virtual function
1861:02 - and in the body we're going to specify
1861:04 - which data we want to print and how to
1861:06 - print that data that's the whole point
1861:08 - of this override we are doing here we
1861:11 - are going to do the same thing in each
1861:14 - inheritance class from animal for
1861:16 - example if we go to feline we're going
1861:18 - to do exactly the same thing we are
1861:20 - going to inherit from animal and this
1861:23 - will indirectly inherit from our
1861:25 - interface so
1861:26 - we need to override
1861:28 - the pure virtual function that comes
1861:31 - with that interface and we do that here
1861:33 - we're going to specify which data we
1861:35 - want to print in this case we're going
1861:36 - to put the description out and the first
1861:39 - style and we are going to specify the
1861:42 - format in which we want the data to be
1861:44 - printed out again that's the whole point
1861:46 - of overriding this virtual function here
1861:49 - we're going to do the same thing on each
1861:51 - inheritance class in our inheritance
1861:53 - hierarchy for example we did the exact
1861:55 - same thing for doug
1861:57 - we did the exact same thing for a cat
1862:00 - and we're going to do the same thing on
1862:02 - our bird classes that's exactly what we
1862:05 - do here specify which data to print out
1862:08 - and how the data is going to be printed
1862:10 - out and this stream insert override is
1862:13 - going to be picked up by our interface
1862:16 - when we get to call the output stream
1862:19 - operator here notice that we are calling
1862:22 - this thing polymorphically we are
1862:24 - calling our stream insert
1862:27 - method on a reference that we pass here
1862:30 - and this is going to resolve this using
1862:32 - dynamic binding this is going to work
1862:34 - really well now that we have this setup
1862:37 - we can head over to the main cpp file
1862:39 - and really do all kinds of crazy things
1862:42 - let's put in a separator here and we are
1862:44 - going to
1862:46 - play with us we are going to include the
1862:49 - classes we need to set up our animals
1862:52 - and we are going to put them in here we
1862:54 - have animal feline dog cat bird pigeon
1862:56 - and crow the moment we do this we don't
1862:59 - need to put in this stream insertable
1863:01 - because it is coming in directly from
1863:02 - this but we don't need to worry about
1863:04 - this because we have include guards in
1863:07 - but we are going to be using smart
1863:09 - pointers so let's include the memory
1863:12 - header and we can set up an animal and
1863:14 - try to print it out we will be using
1863:16 - polymorphism so we will go through a
1863:18 - base pointer to animal and use that to
1863:22 - manage a dog object here we are just
1863:24 - going to pass in the data and we will
1863:26 - try to print this animal out notice that
1863:29 - we are going through a base pointer
1863:31 - calling the output stream operator so
1863:34 - this is going to resolve
1863:35 - the call to stream insert
1863:37 - polymorphically and it is going to print
1863:40 - this information at the dog level and
1863:42 - what i mean by that is that if we go in
1863:45 - dog we're going to find our stream
1863:47 - insert that's going to print this
1863:49 - information here
1863:50 - like we want to print a dog and this is
1863:52 - super powerful hopefully you can see how
1863:55 - cool this is we're going to try and
1863:57 - build this program we're going to pass
1863:59 - this through gcc the boat is going to be
1864:01 - good we can clear and run rooster we're
1864:03 - going to see that we print this as a dog
1864:06 - even if we used a base pointer to try
1864:08 - and print this out how cool is this we
1864:11 - can even use this to set up a bird and
1864:14 - print it out we're going to set up a
1864:16 - base pointer that is going to be
1864:18 - managing a bird you can see that we are
1864:20 - using a unique pointer here you can
1864:21 - really use any kind of smart pointer you
1864:23 - want we're going to print this out and
1864:25 - this will be printed out like a bird
1864:28 - wants to be printed out and that's going
1864:30 - to be using
1864:31 - the override from our bird class and
1864:34 - that's going to say bird is going to put
1864:36 - out the description it's going to put
1864:38 - out the wing color and this is really
1864:39 - going to work really well we're going to
1864:42 - pass this through gcc again the world is
1864:44 - going to be good we can clear and run
1864:46 - rooster you see that we are printing out
1864:48 - bird here and this is using polymorphism
1864:51 - combined with interfaces and this can
1864:54 - come in handy if this helps your
1864:57 - application depending on what you want
1864:59 - to achieve with zipclose plus we can
1865:02 - even put our animal data in an array and
1865:05 - try to print that out so we're going to
1865:07 - put out a separator to be able to follow
1865:10 - this nicely in our output terminal this
1865:13 - is going to do and we're going to go
1865:15 - down and put in the code to play with us
1865:17 - we're going to share an array of shared
1865:20 - pointers this is how we do this and
1865:22 - we're going to initialize this with all
1865:24 - kinds of crazy animals we're going to
1865:26 - put in a dog we're going to put in a cat
1865:28 - we're going to put in a crow and a
1865:29 - pigeon and we will be managing this
1865:32 - through base pointers notice that this
1865:34 - is an array of base pointers
1865:37 - and we're going to be calling the output
1865:39 - stream operator polymorphically so for
1865:42 - the first element here we will print a
1865:44 - dog how a dog wants to be printed out so
1865:47 - we will be using the stream insert
1865:49 - override from the dog class if we go
1865:51 - there we're going to see that we're
1865:53 - going to prefix our data with dog if we
1865:56 - hit the second element we're going to
1865:57 - print this like a cat wants to be
1865:59 - printed down the third element is going
1866:01 - to be printed out as a crow the fourth
1866:04 - element is going to be printed out as a
1866:06 - pigeon and this is going to fall in and
1866:08 - work
1866:08 - right away down here you see that we are
1866:11 - looping calling our output stream
1866:13 - operator and this is going to work
1866:14 - really well let's try and build this
1866:17 - program we're going to pass this through
1866:18 - gcc the build is going to be good so we
1866:21 - can clear and run rooster and you're
1866:23 - going to see that we are printing our
1866:25 - information here the first thing is a
1866:27 - dog the second thing is a cat the third
1866:30 - thing is a crew the fourth fan is a
1866:32 - pigeon and this is working really well
1866:34 - hopefully you can see how interfaces can
1866:37 - be powerful in your c plus plus design
1866:40 - use this if it makes sense for whatever
1866:42 - application you are designing with z
1866:44 - plus plus my main goal here is to
1866:46 - introduce you to the idea of interfaces
1866:50 - and how powerful they can be again an
1866:52 - interface is something you can attach to
1866:54 - your type in c plus plus
1866:56 - and at the moment you attach that
1866:58 - interface to your type your type is
1867:00 - going to have the powers that come with
1867:02 - that interface and all you need to do in
1867:05 - your deriving classes is to implement
1867:08 - the virtual functions that come with
1867:10 - that interface and the interface will
1867:12 - pick them up and use them to do whatever
1867:14 - it is you want to do
1867:16 - polymorphically and that's going to be
1867:18 - really cool we are going to stop here in
1867:21 - this lecture this one we're going to try
1867:23 - and recap what we saw in this chapter
1867:26 - go ahead and finish up here and meet me
1867:28 - there