00:00 - What's up code squad. My name is Kyla gang. 
And today in this video I prepared 12 beginner  
00:07 - Python projects. And I'm going to walk you guys 
through the implementations for all of them. Now,  
00:13 - a couple of notes before we begin, here's a 
list of all the projects. These projects are in  
00:18 - order from what I consider to be the easiest, 
most beginner friendly to the most complex.  
00:24 - They'll range from madlibs, which is a string 
concatenation to an unbeatable, tic tac toe AI  
00:30 - to photo editing in Python. In addition, you might 
see me make a few mistakes run into a few bugs  
00:38 - during these tutorials. The reason why I decided 
to leave these in there is because I think it's a  
00:42 - very important skill to know how to go back and 
fix your mistakes. Because everybody inevitably  
00:48 - makes mistakes. And I thought it would be 
really good for you guys to see some of my logic  
00:54 - when I go back, and I fix them. And of 
course, if you guys are interested in more,  
00:58 - be sure to subscribe to my YouTube channel, Kylie 
Yang for coding projects, and just fun computer  
01:04 - science related topics. Follow me on Twitch Kyle 
Yang for live streams of unedited coding sessions  
01:11 - and follow me on instagram and twitter at 
Kylie Whiting. Okay, so let's get started.  
01:22 - In a traditional Madlib, you would have a bunch of 
blanks in a paragraph. And you would have somebody  
01:27 - fill out those blanks and then read the paragraph 
out loud with the words that they chose in those  
01:33 - blanks. So we're going to recreate this project 
in Python using string concatenation. So let's  
01:41 - talk a little bit about string concatenation. 
In other words, how do you put strings together.  
01:47 - So suppose we want to create a string that says 
subscribe to blank, and this blank is going  
01:53 - to be a YouTuber. So we can create a variable 
YouTuber, and this is going to be some string.  
02:00 - So there are a few ways to create the 
string that says subscribe to the YouTuber.  
02:06 - One way to do it is we can have the string 
subscribe to, and then we can concatenate it  
02:11 - with youtuber by just adding a plus sign. The 
second way is to have a string subscribe to  
02:18 - and then have these curly braces. And what we 
can do is we can call string dot format YouTuber,  
02:25 - and what this is going to do, it's going to put 
the YouTuber, whatever the value of youtuber is  
02:29 - into where the curly braces are in that string. 
And now the third method, and what I think is the  
02:36 - most straightforward is called an F string. And 
an F string, we can define this f string by just  
02:44 - prepending an F in front of the string. And then 
we can say subscribe to and then the curly braces.  
02:50 - And then directly in the curly braces, we can 
add the variable name YouTuber. So with an  
02:56 - empty string, let's try running this real fast 
just to check that there are like no errors,  
02:59 - and they all turn out to be the same thing. 
So let's open terminal and run the script.  
03:05 - So here we see subscribe to blank, three times. 
No errors. Okay, everything looks good. So now  
03:12 - let's try with the YouTuber actually filled 
out to some string. Let's just try Kylie Yang.  
03:18 - So let's run this again. And you'll see that 
now all three of these print statements,  
03:24 - say subscribe to Kylie Yang. And so for the 
sake of this Madlib, we're going to use the  
03:31 - last one the F string just because I think that's 
the cleanest way to express string concatenation.  
03:42 - Okay, so starting this Madlib. So first we're just 
going to assign Madlib variable equals and then an  
03:48 - F string. So let's say computer programming 
is so blank or blank is some adjective. And  
03:56 - now we have to define this variable adjective. 
So we can say adjective equals input. So here,  
04:02 - we're going to get a user input. 
And let's do adjective as a prompt.  
04:10 - It makes me so excited all the time. Because 
I love to blank. Let's make that a verb.  
04:22 - And this break right here, this is just saying, 
This is telling Python Hey, this string has gone  
04:28 - on to the next line. That's all that little 
slash there is. Stay hydrated and verb to  
04:36 - like you are and let's make this a famous person. 
exclamation mark. Okay, so let's just use that  
04:44 - example right there. And now Don't forget to 
define these variables verb one verb two and  
04:49 - famous person. So up here we're gonna say verb one 
equals input. And the prompt is just going to be  
04:55 - verb because all we want is a user to input some 
verb. And now verb two is going to be the same.  
04:59 - thing, but instead verb to will be the name of 
the variable. And then famous person, again equals  
05:06 - input. So we're getting user input. And we're 
gonna say famous person as a prompt. Okay, so I  
05:13 - actually have to remove the space. And then at the 
end, we have to print the Madlib to show the user.  
05:23 - So that's it though. Now we can run this 
code. Alright, so adjective let's do amazing  
05:30 - verb. How about skydive, and then 
another verb jump, and a famous person?  
05:40 - Captain America Okay, so our Madlib is computer 
programming is so amazing. It makes me so excited  
05:49 - all the time. Because I love to skydive, stay 
hydrated and jump like you are Captain America.  
05:58 - And so yeah, there you have it. That's Madlib in 
Python. Alright, so if you guys actually download  
06:05 - my code, which is linked somewhere below, you'll 
notice that there's a file called random Mad  
06:11 - libs.py. What this is going to do is it'll choose 
one of these four madlibs that I prepared, and  
06:17 - it'll let you play that game. Alright, adjective 
pretty, another adjective soft, another adjective.  
06:30 - Pretty glow bursts suddenly, across the 
enchanted sky above them as an edge of  
06:35 - dazzling sun appeared over the sill of the 
nearest mass, the light hit both of their hand  
06:42 - at the same time. So that Voldemort's was suddenly  
06:46 - a flaming water bottle. What did I just 
read? Anyways, there's a Madlib for you.  
06:57 - First, I'm going to teach you guys how 
to implement a guessing game where the  
07:00 - computer has a secret number. And we are trying 
to guess that secret number. So the first step  
07:07 - is actually having the computer generate a secret 
number for us to guess. And in order to do that,  
07:12 - we're going to import random. Whenever we 
call import random, it actually goes to this  
07:17 - package that comes with Python. And it says, 
Hey, all of these functions that are here,  
07:23 - like make these accessible in our scripts, 
so that we can call these functions.  
07:28 - So for example, in order to get a random number, 
something like random dot Rand int might be very  
07:34 - applicable because it returns a random integer n, 
such that A is less than or equal to n less than  
07:40 - or equal to b. So a and b are the parameters of 
this function. And we need to pass in arguments.  
07:45 - I'm going to define a function and I'm going 
to define this function. Let's say, guess,  
07:51 - I'm going to make x a parameter so that we can 
pass that into this random get number function.  
07:59 - So first, we need to get the random number.  
08:02 - And our random number. Well, we're going to use 
random dot and then Rand int, which is exactly  
08:08 - what we saw down here. Let's make it between one 
and x. Okay, so now, basically, what this is going  
08:16 - to return is a random number for us to guess. 
Okay, what's our second step here? Our second step  
08:21 - is, once the computer has a random number, we 
need to guess right, we need to guess in Terminal  
08:27 - and input what our guess of the number is, and 
the computer will tell us whether it's too high,  
08:32 - too low. Or if we've guessed the number 
correctly, I need to keep looping until  
08:37 - I get the right answer, right. So that sounds 
like a job for loops. And basically, since we  
08:43 - don't have a predefined universe to iterate over, 
we're going to use a while loop. So let's insert  
08:50 - while in there. And now in this while 
loop, we need an expression here, right?  
08:57 - And now for this expression, when do we want to 
stop this loop, we want to stop it when our guests  
09:03 - number equals the random number. So that means our 
expression should be something along the lines of  
09:11 - guess does not equal random number, then we 
want to iterate over some things. Now we need  
09:18 - to actually define this guest. And we're not going 
to make a guess up here because we're just trying  
09:22 - to initialize the variable tell Python that this 
variable exists. So we can go back and change it  
09:27 - later. So after a random number, I'm going to 
say guests equals zero, right? Because we don't  
09:34 - want our guests to ever accidentally equal that 
random number. and here if guess is zero, well,  
09:40 - random numbers random dot Rand int between one 
and x. And that means that it will never be zero.  
09:48 - So while the guests tonight equal the random 
number, we're going to get the users guests. So  
09:54 - guests equals input guests a number and we can 
even get little fancier here, between one. And  
10:05 - so let's use an F string. And we can do x. Let's 
just see what that looks like real fast. Let's  
10:15 - call our function guests at the bottom of our 
script. And then let's just print our guests.  
10:22 - Let's see what happened when we run this. Alright, 
so if we run this, pick guess a number between one  
10:28 - and 10. Let's do five. Okay, so we've printed the 
number, right? And I'm just going to cast this as  
10:35 - integer because I want my guesses to be integers. 
So what do we have? so far? The computer has said,  
10:42 - okay, I've gotten a random number. And now we've 
set up this loop where I can keep guessing until I  
10:49 - guess, the right number. But that's no fun, right? 
We kind of want the computer to give us some  
10:54 - feedback, give us some clues into what's right 
and what's wrong. So that means that I'm going  
11:00 - to use some if statements and these statements 
are going to tell me Hey, you're kind of high,  
11:04 - kind of low, or, oh, maybe you've gotten it. 
Alright, so let's add these if statements in  
11:09 - so if our guests is less than our random number, 
then we can print. Sorry, guests again, too low.  
11:22 - All right, but then elsif, our guests is greater 
than our random number, then we can print  
11:29 - sorry, guests again, too high. And then if it's 
not less than if it's greater than that means it's  
11:37 - just right. It's in that Goldilocks zone, right? 
And that means that you have guessed the jackpot,  
11:44 - you have guessed that random number. And so 
what do we do that? Well, we actually don't  
11:50 - have to do anything. Because remember this loop. 
While the guest does not equal the random number,  
11:57 - it does all of this. But as soon as your guest 
equals a random number. So once you've input this  
12:02 - guest, we don't hit any of these if statements. 
So then we come back to while the guests is not  
12:07 - equal to number, but now your guests equals 
the random number. So it actually breaks out  
12:12 - of this loop. Meaning that at the very end, I can 
print. Yay, congrats. You have guessed the number.  
12:22 - And you know what we can even just 
tossing a random number in there.  
12:28 - So let's use our F string again. Yay, congrats. 
You have guessed the number random number  
12:38 - correctly. Alright, are we ready 
to play? So if we go to terminal?  
12:46 - Let's run our script. Okay, it gets a number 
between one and 10. I'm going to do four.  
12:54 - Okay, it was too high. So maybe two to low. 
Alright, so that means if four is too high, if two  
13:01 - is too low, it has to be three, right? Wow, look 
at that. I've guessed the number three correctly.  
13:18 - Alright, so we talked about earlier how the 
computer is guessing our number. But we can  
13:23 - also do the complete inverse of that function, we 
can come up with a secret number and we can have  
13:28 - the computer try to guess it. So now I'm going 
to create a new function called computer guests.  
13:35 - effects. Great, right. And in this function, 
let's think about what we actually have to do.  
13:41 - So I have a secret number. And I'm not going to 
tell the computer what the secret number is right?  
13:45 - That basically means the computer has a range of 
numbers to work with a minimum and a maximum a  
13:51 - low and a high. Okay, so that means let's set the 
low and the high initially because we know what  
13:58 - that is without even having to loop over anything. 
So I'm going to say low, the lower bound is one,  
14:04 - and the high is x. Because we do have that entire 
range between one and x to work with initially  
14:12 - until the user can provide some feedback, we 
need to be able to tell the computer if it's too  
14:16 - high or too low, or if they've guessed correctly, 
which means that let's initialize a feedback  
14:22 - variable. Alright, feedback. And at first, there 
aren't any guesses, nothing's too high, nothing's  
14:29 - too low. So just like how we initialize guests to 
be zero, let's initialize this to an empty string.  
14:35 - And now basically, we want to loop over 
this feedback expression. So while this  
14:40 - feedback expression does not equal what we're 
going to make it represent when it's correct,  
14:45 - let's do c because C for correct. So 
while this feedback does not equal C,  
14:55 - Well, the first thing I need the computer to do is 
to get a new number. So I'm going to make guessed  
15:00 - random, I'm going to use random dot random again. 
And this time we're going between low and high.  
15:08 - Now we don't want it to always be between one 
and x, right? Because we want to be able to kind  
15:13 - of change these bounds according to the user's 
feedback, because you know that if something is  
15:18 - too high, then anything above that we can kind 
of stop considering. And then if it's too low,  
15:23 - anything below that we can stop considering. 
So that's why I'm passing in these low and high  
15:27 - values into this random so that we can get a new 
number between the bounds that we know has to be  
15:33 - correct. Okay, so we have a guest. And now we're 
trying to ask the user for feedback, hey, is our  
15:40 - guest right? Or is it wrong. So here, I'm going to 
do feedback equals, and let's say user input is.  
15:53 - So I'm going to use an F string again. So 
I can put this variable inside my string  
15:57 - is guess, too high. And let's make that Ah, okay, 
too low, that's going to be L, or correct. And  
16:09 - that, of course, is C, the user is going to input 
h, l, or C, I have these uppercase letters here,  
16:16 - this lowercase up here, I'm just going to make 
this input lowercase. So adding that dot lower  
16:22 - at the end is going to take whatever this string 
is from the input, and just lowercase it. So H,  
16:28 - L and C are all lowercase. If we try to compare 
capitalized letter to its lowercase letter, it  
16:33 - actually does not come out to be equal. So that's 
why I'm adding this lower in there. Let's look at  
16:38 - our different cases again. So if feedback is H, 
so basically, we're saying okay, if it's too high,  
16:46 - then that means we want to adjust our upper bound 
is a very guess, is too high. Like, you know, if  
16:52 - we're guessing out of 10, and we guess eight, the 
other person says, Oh, that's too high, that means  
16:56 - out nine and 10 cannot be the numbers, that would 
mean that we need to adjust our upper bound, our  
17:01 - upper bound is actually going to be what we just 
guessed, minus one. Because for example, if we get  
17:09 - eight, then we know it's between one and seven 
if eight is too high. And now if the feedback  
17:14 - is L, we know that our low bound has to be guess, 
plus one, right? Because it can't be that low  
17:22 - number. And of course, we can make that an LS LS 
makes it a little bit cleaner, because feedback  
17:28 - can only be h, or it can be L, like it can't be 
both of them. And of course, if it's correct,  
17:34 - we don't have to have an if statement for that. 
Because our while loop kind of takes care of that.  
17:39 - So at the very end, of course, when we 
exit our while loop, that means that  
17:44 - the computer has guessed our number correctly. 
Print, yay, the computer, guess your number.  
17:55 - Let's put the number in there correctly. And 
so I'm going to put a guess, in this f string,  
18:04 - because so that means that outside of this 
for loop, this variable guess is actually  
18:08 - the last thing that the computer had guessed. 
Which means that you know, if it's correct,  
18:12 - then that is our secret number. All right. So 
basically, one other thing that I've noticed  
18:18 - is random dot Rand and will actually throw 
an error if low and high are the same number.  
18:25 - So we can do a couple of things, we could 
theoretically put this statement up here that  
18:32 - prevents this loop from continuing if low equals 
high, because if low and high are the same number,  
18:37 - that means that you've narrowed it down, 
right? If you're saying eight is too low,  
18:40 - and your new low is nine, and then you're saying 
10 is too high, so then your new highs nine,  
18:45 - well, that means that the computer has actually 
narrowed down the number to nine. But if we break  
18:51 - too early, so if we're saying and low does not 
equal high, then we don't actually iterate over  
18:55 - this loop. When our low is nine or higher is nine, 
right? We just break and we say, Oh, the computer,  
19:00 - yes, your number correctly. But the thing is, we 
actually want the user to say that the computer  
19:06 - has chosen it correctly. So that's why we can't 
actually have that statement in there. Instead,  
19:11 - what we want is we want to say if low does not 
equal high, then our guests is a random number  
19:17 - between low and high. Otherwise, so this means 
if low does equal high, otherwise, our guests is  
19:25 - equal to one of them. So let's just say whoa, I 
mean, it doesn't really matter. This could also  
19:29 - be high, because low is equal to high. Alright, 
so then our feedback actually puts this number  
19:36 - into here and it prompts the user to say, hey, 
that's, that's right. So then at the very end,  
19:42 - we're saying okay, the computer guessed your 
number guess correctly. All right, let's try this.  
19:49 - file. Oh, shoot, and you can, let's say 
our new secret number is six. So that's  
19:56 - too low. Seven. Oh, that's too high. 
Six. Okay, that's correct. Yay.  
20:03 - And you know, we can even 
play this with like 1000.  
20:07 - Alright, so for our secret number, let's actually 
do the price of aetherium, which is approximately  
20:12 - 392. Okay, so Python three main.pi 640, that's 
too high to blow, too high, too low, too high.  
20:27 - Close, we're getting closer, oh 393, that's 
a little bit too high, too low 392. What  
20:36 - the computer guess our number correctly, look 
at that the computer has guessed our number  
20:40 - correctly. Alright, so that's it, just using some 
functions and some while loops through, we're  
20:45 - actually able to get our computer to guess our 
random number. And for us to be able to guess  
20:51 - our computer's random number. So now when we're 
bored, we can play this guessing game. Whoo.  
21:16 - So the next beginner project idea is rock 
paper scissors. This one's super simple,  
21:20 - but it's a step up from the previous one. 
Here, we're going to be using random. So we  
21:24 - definitely want to import random, and we're 
going to be using a function. So basically,  
21:29 - we want some user input, right, because 
we want to play against the computer.  
21:33 - So the user is going to put an input, let's use 
our for rock, p for paper, or s for scissors.  
21:43 - And then the computer is also going to choose. And 
here we're going to do random choice because we  
21:49 - have our three different choices, our P and S. So 
now the computer is going to randomly choose one  
21:55 - of these choices. Once we know the user's choice 
and the computers choice, we can come up with some  
21:59 - rules in order to determine who wins. So the first 
rule is if the user and the computer have both the  
22:05 - same choice, then it's a tie. In this game, 
we know that rock beats scissors, scissors,  
22:12 - beats paper, and paper beats rock. So let's 
define a helper function is when to see who wins.  
22:18 - And here I'm going to say player versus opponent. 
And this will return true if the player wins.  
22:26 - And now we're just going to use 
this little rule that we had.  
22:30 - See, so if the player is rock, and the 
opponent is scissors, or if the player  
22:42 - is scissors, and the opponent, paper, or 
so now we have three conditions, right?  
22:49 - Or the player is paper. And the opponent is rock 
that we know that the player has won. So we're  
22:57 - going to return true. So now we're going to ask 
up here if the user has one, so is when user or  
23:03 - computer so the computer is opponent and the user 
is a player, then return you one, actually, we're  
23:09 - going to return, it's a tie up here. And then 
otherwise, we're just going to return you lost,  
23:15 - because if the computer one that we lost, here, 
you'll notice that I don't have an if statement  
23:20 - before this last return. And the reason for that 
is because if you've already passed these two  
23:25 - cases, and after each of these cases, the function 
ends right here, or in this case, if you one,  
23:31 - then it ends right here. The only way that we can 
ever reach this line is if we didn't go through  
23:36 - any of these, which is the same, it just saves 
you an extra line of code instead of saying else,  
23:42 - or instead of saying if is when computer comma 
user, because the only way we get to this line  
23:49 - is if this is true, so we don't even need 
that line. So here we're going to print play.  
23:57 - And here I'm actually going to add a 
line break and say, what's your choice?  
24:07 - Now let's see what this looks like. What's your 
choice are for Rock Paper Paper, Esther scissors.  
24:15 - Think I'm gonna go with scissors. 
Oh, I lost play. Rock I won.  
24:37 - So the first thing that we have to do for hanging 
man is we have to choose a random English word.  
24:42 - So I actually went on Stack Overflow, and I 
found this very relevant question how to pick  
24:47 - a random English word from a list. And if you 
scroll down a little bit, there's this like JSON  
24:53 - file that's linked. So I'm just going to click on 
that. And when I open it, there's all of this text  
25:01 - And basically what this is, is it's just a very 
long list of words that we can use for hang man.  
25:10 - So I can copy and paste this entire list of 
English words into a Python file. And I can  
25:16 - assign it to the variable words, which we can use 
in our hangman game later. So now I can open a  
25:22 - hang in file. And I know that I want to be able to 
choose randomly from this word list. So I'm going  
25:28 - to import random. And then also, I know that I 
want the word list that I just made. And I called  
25:36 - my file words that py. So in my hangman file, I'm 
going to say from words, which is words.py import  
25:44 - words. And that second words is just this 
variable words. So now if I print out words  
25:50 - in my hangman file, I would be able to get that 
entire list of words that I just copy and pasted.  
25:58 - So the first step in actually getting 
our computer to play Hey, man with us  
26:02 - is the computer has to figure out a word for us 
to guess. So we just got this entire list of words  
26:09 - into this Python file. And now we just 
have to randomly select a word from it.  
26:14 - But you'll notice if you look through this word 
list that some of them actually have spaces,  
26:18 - and dashes in the middle of the word, which we 
can't exactly guess in Python, or in hangman.  
26:25 - So we actually have to keep choosing a word until 
we get a valid word that we can guess and hang in.  
26:33 - So in order to do that, I'm going to define 
a function called get valid word. And I'm  
26:39 - going to pass it a list of words. So the first 
thing I'm going to do is assign, you know the  
26:44 - word to random dot choice words. And what random 
choices it takes in a list and it randomly chooses  
26:53 - something from that list. So I'm just going to 
get a random word from this list. And I'm going to  
26:58 - make a while loop saying while dash or space is 
in this word, keep choosing the word. So what this  
27:07 - while loop does is, as long as the statement is 
true, it just keeps iterating back and forth until  
27:13 - it's not true anymore, which means that when 
it stops iterating, we'll get a word that  
27:18 - doesn't have a space or a dash in it. And then 
finally, we're just going to return that word,  
27:23 - we need to be able to keep track of which letters 
we've guessed and which letters in the word we've  
27:28 - correctly guessed, we also need a way to keep 
track of what is a valid letter, and what is  
27:34 - it. So now we're going to set that up, I'm going 
to have word letters a variable that saves all  
27:40 - the letters in a word as a set. And this will 
use as a way of keeping track of what's already  
27:46 - been guessed in the word. And then I'm going to 
have an alphabet. And basically, I'm just going  
27:52 - to import this already predetermine list of like 
uppercase characters in the English dictionary.  
28:02 - And then I'm going to have an empty set called 
newsletters, which I will use in order to keep  
28:07 - track of what the user has guessed. Alright, 
so now we're going to get some user input.  
28:15 - So basically, what we can do is we can just 
ask for user input and Python directly.  
28:21 - And if we run this in Terminal, then the 
user can type in, you know, a character.  
28:26 - And we can use that as input. So we're going 
to save that as a letter. And I'm just going  
28:32 - to uppercase this because I'm just going to 
do everything in uppercase. A lowercase a and  
28:37 - Python is different than an uppercase A. So if you 
try to test equality between those two strings,  
28:43 - it actually won't be equal. So I'm just 
going to do everything in uppercase.  
28:49 - And basically, if I'm going to, I'm 
going to say, Okay, if this is already,  
28:55 - if this is a valid character in the alphabet 
that I haven't used yet, that I'm going to  
29:02 - add this to my use letters set. And then, if 
the letter that I just guessed is in the word,  
29:11 - then I'm going to remove that letter from word 
letters. So every single time I guess correctly,  
29:18 - then this word letters, we're just keeping track 
of all the letters in a word, decreases in size.  
29:26 - And then if this user letter that the user just 
entered his and use letters, then that means  
29:34 - that they've already used it before, and it's 
an invalid guess. So I'm just going to print  
29:38 - something saying, You literally just guessed that 
word for that letter. Otherwise, that means that  
29:46 - you know, they typed in something that's not in 
the alphabet, and it's not in the newsletters  
29:50 - that they've already guessed. So that just means 
that they've typed it in a wrong character. And  
29:55 - we're going to print an error message saying 
you didn't type in about Out character.  
30:05 - So now that we can get the user input, we want the 
user to be able to keep guessing until they get  
30:10 - the word. So in this case, we're going to be using 
a loop. And loops are basically just a way to,  
30:18 - you know, loop around your code and iterate. So, 
in this specific case, I want to use a while loop,  
30:24 - because I want the user to just to keep 
guessing until they actually guessed the word.  
30:30 - And because every single time we're removing a 
letter from word letters, which is a set of the  
30:37 - letters in the word that we haven't seen yet, 
I'm just going to keep decrementing that so  
30:43 - the condition that I have to satisfy for when the 
user gets all the letters in the word is when the  
30:49 - length of word letters is actually equal to zero. 
So while the length of word letters is greater  
30:56 - than zero, I'm going to keep iterating through 
this input until they guess all the letters.  
31:04 - So my while condition is going to be while the 
length of word letters is greater than zero,  
31:11 - iterate. So let's just add that in there. 
So before we can actually play this game  
31:16 - of paying man, we need two things that we 
need to tell the user. So the first thing is  
31:21 - what letters they've already used, so that they 
can keep track of what they've already guessed.  
31:26 - So we're just going to have a simple print 
statement. And then we're going to, say,  
31:31 - space dot join us letters. And what the start 
join does is it turns this list into, or iterable,  
31:40 - into a string, separated by whatever the 
string is before the dot join. So in this case,  
31:48 - each of these letters will be in 
a string separated by a space.  
31:52 - The second thing that we need to do is we need 
to tell the user what the current word is,  
31:59 - but with dashes where the characters that they 
haven't guessed are. So in this case, I'm going to  
32:06 - first create a list where every single letter 
that they've guessed, is shown, and where all  
32:14 - the letters that they haven't guessed, are just 
dashes. And then I'm going to take that list. And  
32:20 - I'm going to join it with a space just like above 
so that we can create a string using that list.  
32:46 - In that game, I literally could have 
guessed as many times as I wanted to.  
32:50 - So let's make this a little bit more fun. 
Let's introduce the concept of lives and to  
32:56 - hang and because usually and hang man, you 
can only guess until the guy's dead, right.  
33:02 - So let's say that live, let's say you get six 
lives. So the first thing we have to do is,  
33:10 - if the user has a letter in Word letters, 
then you want to remove the letter.  
33:16 - But if they don't, then that's when you want to 
take away a life. So with my logs variable, which  
33:23 - is set to six at the beginning, I'm just going to 
subtract one there, and I'm going to tell the user  
33:28 - that your letter, user letter is not in the 
word. And then everything else should stay  
33:34 - the same. Now at the very beginning, I'm going 
to say where the, where I show the user the  
33:41 - letters that they've already used, I'm gonna, I'm 
just going to tell them, you have x lives left.  
33:47 - And then you know, they can guess the letter. 
And right now our while loop condition is set to  
33:54 - as long as they still have to guess more 
letters in the word they keep playing. But  
34:00 - now we have another condition, right, we have 
the condition of lives. So as long as either a  
34:07 - they haven't won yet, which is when the length 
of the word letters is greater than zero, or B,  
34:14 - when they haven't died yet. So up here, we're 
going to add another condition in this while loop,  
34:20 - we're going to say while the like the word letters 
is greater than zero, and lives greater than zero,  
34:28 - then we want them to be able to guess this means 
that as soon as they either when, when they,  
34:35 - when they've guess all the letters, then they 
exit this while loop or when they've died when  
34:41 - lives equals zero, they exit this while loop. So 
at the very end, right now we're telling them that  
34:48 - they've guessed the word correctly. But now that's 
not the condition anymore for this while loop.  
34:55 - We also have an aspect of lives. So if 
the lie equals zero, then they actually  
35:02 - died. So we say sorry, you died, the word was 
blank. Otherwise, in this LC ms, we can say,  
35:09 - yeah, you guess the word. So now let's try again 
paying man with all these different components.  
35:55 - Now we're going to create a command line version 
of tic tac toe with various types of players. So  
36:01 - either a human can play, or the computer can play. 
So humans can play as a computer, humans can play  
36:07 - against each other, or the computer can even play 
against the computer. Let's get started, we're  
36:13 - going to split up our player and our game into two 
separate classes. So that when we actually play,  
36:18 - we can create a game and then we can tell the 
game, hey, this is my x player, and this is  
36:22 - my o player. So the first thing we're going to do 
is create a file player.py. And up here, I'm just  
36:30 - going to tell you guys right away, we're probably 
going to need math and random, so I'm just going  
36:34 - to import them right now. We're going to have a 
bass player class and in this class, we're going  
36:41 - to initialize it with the letter that the player 
is going to represent. And this is either x,  
36:48 - or Oh, so that's cross are not in official like to 
Tac Toe terms. So self dot letter is going to be  
36:55 - letter. And we want all players to be able to get 
their next move. So here, I'm going to say define,  
37:02 - get move, self comma game. And I'm just going to 
pass because while this is our bass player class,  
37:10 - and on top of that, we're going to build a random 
computer player. And we're going to build a human  
37:16 - player here, we're going to use inheritance in 
order to create a random computer player and a  
37:22 - human computer player that builds on top of this 
bass player object. And so in our initialization,  
37:28 - we have to initialize the superclass. So we're 
going to say super dot init letter. And what  
37:34 - that's going to do is it's going to call this 
initialization and the superclass, which is  
37:38 - the player and define get move. So in our 
get move function, let's hold off on this for  
37:48 - now. Same thing for the human player. In this 
human player, our superclass is still player,  
37:55 - we're going to initialize the same way that we did 
the random computer player, and then we're going  
37:59 - to find get move, and again, self comma game. And 
let's also come back to this, let's first go and  
38:07 - define the game to see exactly what we're dealing 
with when we pass in the game. Let's create  
38:13 - another file. Let's call this one game.py. So in 
game.pi, we're going to find class tic tac toe.  
38:23 - And so in this class, what are we going to need, 
we're going to need a board, right? Because our  
38:28 - tic tac toe, it's a three by three board. Let's 
create that board. For our board, let's just use  
38:35 - a list of length nine, that'll represent the 
three by three board. And what we can do is we  
38:40 - can assign an index in this length nine list to 
each of the spaces. And then that will represent  
38:46 - our board. What I'm also going to do is I'm 
going to have this variable self current winner  
38:53 - that will keep track of whether or not there is 
a current winner in this game. And if there is,  
38:58 - Who is it? Well, let's first of all be able to 
print the board, right, we're going to want to  
39:04 - see like what's in this board. So for each row, 
and here, let's split this up into the rows.  
39:13 - So self dot board, this is indexing into our 
length nine list, and then this i times three.  
39:22 - So we're doing i in range three, right? So this 
i times three to i plus one times three. So  
39:28 - basically that's saying like which group of three 
spaces are we choosing? Is it the first one second  
39:33 - one or third one, and that that represents the 
row indices 012. That's the first row indices 345.  
39:40 - That's the second row and then 678, that's the 
third row. For each row. What we're going to do  
39:46 - is we're going to print and these are just going 
to be some separators. So let's add these and then  
39:53 - dot join row is just saying like join them in a 
string where the separator is this vertical line.  
40:01 - So you guys don't have to worry too much about 
print board because I don't think it actually  
40:05 - like, contributes much to the logic of the game. 
It's just how do you print this? Okay, and then  
40:12 - here for print board numbers, well, this is static 
method because it's, it doesn't relate to any  
40:18 - specific board, we don't have to pass in a self. 
What this means is, we're just going to print out  
40:24 - which numbers correspond to which spot. And so 
for example, here, you can see it's 012, etc. And  
40:31 - so our number board is going to be string, and 
then whatever is for each eye in range. Again,  
40:40 - this is a row, right? This number board might seem 
kind of scary. But if we think about this for Jane  
40:47 - range three, so that's J equals 012. Here, this 
range is j times three, and then j plus one times  
40:55 - three. So this is the exact same range that we 
saw up here for each row. So what this is saying  
41:00 - is, essentially, just give me what indices 
are in the rows for each of the rows, this  
41:06 - is going to come out to like 012, that's one sub 
array, and then 345, that's another sub array, and  
41:13 - then 678, we're going to concatenate the strings 
the same way that we did above in print board.  
41:25 - Okay, so now let's actually dig a little deeper 
into the logic of the game. Given this board,  
41:31 - we're representing the empty spaces with 
the space, we're going to need to know  
41:35 - what are the available moves 
after you make a move, right,  
41:39 - so we're going to return a list and this is going 
to be a list of indices. So let's actually expand  
41:43 - this out. And then I'm going to show you guys 
how to do the list comprehension for it. Let's  
41:47 - initialize moves to an empty list. And then let's 
say for icon x, and enumerate self dot board,  
41:54 - enumerate is going to essentially create a 
list and assign tuples that have the index  
42:00 - comma the value at that index. So here we have 
zero comma x, one comma x and then two comma Oh,  
42:08 - in the support loop, we're going 
through each of these tuples.  
42:11 - And we're assigning the first item in the tuple to 
I The second item to x. so we can say if x equals  
42:19 - Actually, let's call this spot, because that might 
be a little bit more intuitive if spot equals  
42:25 - space. And we know that this is an empty space. 
And we know this isn't available to move. So we're  
42:30 - going to append that index, because we want to 
know which spaces are available, we're going to  
42:35 - append the index of that spot to moves. And they 
at the end, we're going to return moves. Another  
42:41 - way to write this is a list comprehension. And 
that would look something like this, I for icom  
42:46 - a spot in enumerate self dot board, if spot equals 
space. So this is essentially just condensing this  
42:57 - entire for loop into a single line. It's saying 
for icom a spot and in numerating, the board,  
43:03 - if the spot is space, then put AI into this list, 
and then we're going to return the entire list.  
43:10 - Easy little one liner makes the code clean. Okay, 
so now that we have that function, let's define  
43:16 - get move for our players. So the square that we're 
going to choose for the random computer player,  
43:22 - while we're literally going to just choose 
a random spot on the board that's empty.  
43:26 - So let's just do random dot choice, which 
is going to choose one thing in a list at  
43:32 - random. And we're going to pass in game, 
which is our board, game dot available  
43:38 - moves. Again, it's just going to get a random 
valid spot. Okay, so the human player, we want  
43:45 - the human to be able to choose a spot based on 
some input that we pass in through terminal,  
43:51 - we want the user to keep iterating until they 
achieve a valid square. Initially, we're gonna  
43:55 - say valid square equals false. And then the value 
is not because the user has an input value yet,  
44:01 - let's say while not valid square, so while valid 
square is false, r square is going to be input  
44:09 - and then self dot letter. So x or o player 
turn, because we want the user to actually  
44:18 - look at Terminal and not get confused by whose 
turn it is. And input move zero through nine.  
44:26 - So what we're going to do is we're going to 
incorporate a series of checks to make sure that  
44:31 - this is actually a valid number that we can put 
in. So here we're going to wrap it in a trench.  
44:37 - So for the tribe, we're going to say 
value. So this Val equals int of square,  
44:43 - remember square is this input that the user has 
been put, if we can't cast this to an integer if  
44:48 - we can't cast this to a number, so if they input 
like XYZ for square, it's going to raise an error  
44:55 - when you try to cast it to an integer and then 
the second part If the value that they give you  
45:01 - is not in gamed out available moves in the list of 
available moves, then we can raise a value error.  
45:08 - And so essentially, if either one of these 
things goes wrong, then we know it's not valid,  
45:14 - right? If we pass both of those, and we can say 
valid square equals true, because it's valid, then  
45:19 - we're going to catch this value error. And we're 
going to say, print invalid square, try again.  
45:26 - And so this is going to repeat the loop, we're 
going to get the input for the square again,  
45:29 - and we're going to repeat this checker. At the 
very end, once we've gotten a valid square,  
45:35 - we're going to return that value at the end. So 
it's going to be the human players. Next move.  
45:40 - Okay, so we have our player. So let's now 
continue working on our game. So that we  
45:44 - can start playing a game of tic tac toe, we have 
part of a representation of a tic tac toe board.  
45:52 - Let's, in order to get the rest of the 
functions that we need, let's define a  
45:56 - function called play outside of this class, where 
we're passing in a game, an X player, an O player,  
46:04 - and I'm going to pass in this extra variable print 
game that's just going to be set to true or false.  
46:09 - And if it's true, it'll print out all the steps. 
So this is like if you want to play against it.  
46:14 - But later on, if we want the computer to play 
against itself, or like a bunch of iterations,  
46:18 - we don't need to see the computer print out every 
single game. So then we can toggle that to false.  
46:23 - If we're printing the game, then we're gonna say 
game dot print board numbers, right, because then  
46:28 - we can see which numbers correspond to which spot 
and the starting letter, let's just assign that x.  
46:36 - I don't know if that's like, what two tackle 
actually starts with, but we're just gonna say x.  
46:41 - Alright, so now while the game still has 
empty squares, so while the game is still  
46:46 - like incomplete, we're just going to keep 
iterating, right, and we don't have to worry  
46:49 - about the winner. Because the output of this 
play, let's just return the winner, we don't  
46:54 - have to worry about continuing this loop, because 
we'll break out of it with that return statement.  
46:59 - So in order to check whether the game still has 
empty squares, let's create a function within the  
47:04 - class called empty squares, pass in self. And what 
we're going to do is we're going to check if there  
47:10 - are any empty squares on the board. So we can 
just say return space in self dot board. And space  
47:17 - and self dot board will become a Boolean, empty 
squares will just return a Boolean of whether or  
47:22 - not there are empty spaces in the board. And we 
might need to know the number of empty squares.  
47:28 - So I'm just gonna say okay, we can 
return the length of available moves,  
47:33 - which will return this list. And so we 
can just count how many empty spots there  
47:37 - are. We could also say self dot board count, 
because this is a list, self dot board count,  
47:45 - and then just space. So that will count 
the number of spaces in the board.  
47:51 - All right, so while they're empty squares, 
we want to get the move from the appropriate  
47:55 - player. So if the letter equals O, then 
we're going to ask the player to get move.  
48:01 - And if not, oh, that means it's x, then we're 
going to ask the x player to get the move.  
48:10 - Alright, let's define a function 
to actually make a move.  
48:13 - Now that we've gotten the player to get 
their next move, we go back up to our game.  
48:22 - And we say define make move. When we make a 
move, we need information about what square  
48:28 - the user wants their move to be at. And then 
what letter the player is. So we know like  
48:33 - what to assign that square, if the move is valid, 
then we make the move, and then we return true.  
48:39 - If it's not a valid move, then we return false. 
Nothing should ever be an invalid move. But just  
48:44 - in case if self dot boards square is empty, so 
if this This means if at that space on the board,  
48:52 - nothing's there yet, then we assign that letter 
to that given square, and we return true. If  
48:58 - that doesn't pass, then we return false. 
Okay, so let's put this into our play loop.  
49:08 - So if game dot make move, so if this is valid, if 
we want to print the game, we're going to print  
49:15 - letter make some move to square, blank, and 
some square let's make an F string there.  
49:24 - And we're gonna say game dot print board, because 
we want to see a new representation of the board,  
49:30 - where this spot has now been claimed by this user. 
And here, this is just an empty line that we're  
49:36 - going to print. Okay. After we made our move, we 
need to alternate letters. So here we're going to  
49:45 - assign letter equal to O if the old letter was x, 
otherwise we assigned it to x. And this basically  
49:54 - a different way to rewrite this would just be if 
letter equals x, then the new letter is though  
49:59 - otherwise the newletter is x. That's exactly what 
we're doing here. We're just switching players.  
50:05 - Okay, but wait, we don't, we're not actually 
checking anywhere if anybody wants. So what if  
50:10 - we want, if you think about it, the only time that 
you should win a game is like right after you make  
50:16 - a move, right? If you won, if you want a game, you 
should win on that move. So we're going to go back  
50:22 - to make move. And after we've placed the letter 
on that board, we can toggle current winner  
50:30 - to the winner if there is one. So let's make 
another function that will check for the winner.  
50:35 - So after we've made this move, if self dot winner, 
and then we're going to pass in our last move,  
50:42 - because that's the one that's going to be 
our winning move, right? If self dot winner  
50:46 - then we can assign current winner equal to that 
letter. Welcome back to The winner function. But  
50:57 - suppose that we have this checker. So then after 
making this move, if we have a current winner,  
51:04 - we can check for the current winner before we 
switch letters. And if there is a current winners,  
51:08 - which means, which means that if current winner 
is not set to none anymore, then a letter has one,  
51:14 - and we can end the game because then we 
can just return the winner of the game.  
51:26 - So in this game, we're going to 
return the winner if there is one,  
51:29 - and if there isn't, then we're going to 
return none. So that means none as a tie.  
51:33 - And we're going to return the letter of 
the winner. So here if game current winner,  
51:40 - well, it was letter, turn, so we can just 
return letter, the letter that gave us the win.  
51:46 - Okay, so then also, let's just add in the 
non for a tie right now. So at the bottom,  
51:51 - we can say if print game, then after this while 
loop is over, we can just print, it's a tie.  
52:03 - All right, now we got to go back and actually 
create this function that'll check for a winner,  
52:09 - right? So we can define winner and 
then input the square and the letter.  
52:16 - And we know that in tic tac toe, we're a 
winner if there's three in a row, anywhere,  
52:22 - but we have to check all the possibilities, 
whether that's in the row, column or the diagonal.  
52:29 - Alright, so first, let's check the row. So 
the row index, which row it's at is going to  
52:34 - be whatever square that you give it, divided by 
three, and then rounded down, right, so that's  
52:41 - what this right here is. So that double dash is 
just saying how many times three go into square  
52:47 - row is going to be self dot board. And here we're 
going to see this indexing again. But this is  
52:53 - essentially saying, given the row index, get the 
row. So here rows is going to be a list of the  
53:00 - items in the row that we've selected. And we can 
say, if all. So this is going to be all is saying  
53:08 - like if everything in this list is true, then 
this comes out to true otherwise, it comes out  
53:12 - to false. So for all and then, within this list, 
we're gonna do another list comprehension. So for  
53:18 - every spot on the row, we're checking whether or 
not that spot equals the letter, because that's  
53:23 - how we're checking for three in a row. So if, and 
then if all the things in this row are equal to  
53:32 - that letter, so that means that we have three 
in a row in this row, then we can return true.  
53:39 - If not, then we keep going right. So then let's 
check the column next. And we're going to use  
53:44 - very similar logic. So the column index is okay 
divided by three and then take the leftover,  
53:50 - so that's going to tell us which column we were 
in the columns is going to be the self dot board.  
53:57 - And here we're going to do another little indexing 
trick. But if we take the column index, and then  
54:03 - for every single row, so 
that's I, for every single row,  
54:07 - if we add the column index, and we essentially 
get every single value in that column, right,  
54:13 - and we're going to put that in a list, and that's 
going to be our column. So here column is just  
54:18 - going to get everything in the column where 
we just move to. And again, just like above,  
54:25 - we're going to use this if all checker and instead 
of row we're just going to replace it with column.  
54:29 - So if everything in the column is equal to the 
letter, then we return true. Okay, so now finally,  
54:37 - if that doesn't come out to true, we're going to 
check our diagonals. Intuitively, we can kind of  
54:43 - see that the only way to win a diagonal is if 
you placed a move that was along a diagonal  
54:49 - here, we're going to check if the square that we 
had just moved to is actually an even number 02468  
55:00 - These are the only moves possible because these 
are the only these are the diagonal spaces.  
55:04 - So if we assigned 012 to the top row 345678, it's 
pretty easy to see that the top left is zero,  
55:12 - the middle is four, and the bottom right is 
eight. And then the other diagonal would be two,  
55:18 - four, and six. So that's why here we're 
checking if the squares are visible by two.  
55:24 - So that that's basically saying it's even, then 
this diagonal one, we're gonna say four is 048.  
55:32 - So this is the top left to bottom right diagonal. 
So we're going to put the things in the board that  
55:39 - correspond to 04, and eight into this diagonal 
one. And the same thing for diagonal two,  
55:45 - but instead, it's two, four, and six. So this 
is the top right to the bottom, left, diagonal.  
55:54 - And once again, we're going to use this if 
checker and say if every single spot equals  
56:00 - a letter in the diagonal, so diagonal one, 
return true. And again, for this diagonal to,  
56:08 - if every single spot equals a letter in 
diagonal two, we're going to return true.  
56:13 - And at the very end, if all these checks fail, 
then we don't have a winner. So we return false.  
56:24 - So yeah, that's our Tic Tac Toe game right there. 
And so now let's actually play this game. So if  
56:29 - name equals main, if name equals main, first, 
we're going to make the x player equal to human  
56:35 - player and assign it the letter X. So actually, 
at the very top, we have to go back and we have to  
56:40 - import human player and random computer player 
from our player file. Otherwise, this game.py file  
56:47 - has no idea what's in player.pi. But if we add in 
this like, import at the top, that we actually got  
56:53 - our human player, and we get our random computer 
player. So for our x player, we're going to create  
56:58 - a human player, and we're gonna initialize 
it with the letter x. And then our o player,  
57:04 - we're going to make that our random computer 
player and assign that an O. And then our game  
57:11 - is going to be tic tac toe, let's just 
call that T. And then we're going to say t  
57:15 - equals an instance of tic tac toe. And we're going 
to play tic tac toe. So this is a game x player,  
57:22 - a player and then we're going to set 
print game equal to true right here.  
57:32 - Alright, so let's pull up a terminal and 
let's play a game. So Python three game.pi.  
57:38 - Alright, so first, I want to move to 
four, because I want to be in the middle.  
57:44 - Okay, it's saying it's a tie. That's weird. But 
oh, makes a move to square seven. Let's try to  
57:50 - go fix this. It's a tie. So if we go back 
into our loop, we actually see that print,  
57:55 - it's a tie is still within this while loop. 
And that's not right, what we need to do is  
58:01 - actually on indented to make it fall outside 
the while loop. So it's only after there are  
58:06 - no more available spots, which means that there 
is a tie Are we going to print, it's a tie.  
58:13 - First, we're going to go again, square four. 
Oh is making a move to square five. Okay,  
58:19 - so I actually don't like how as 
soon as I said, Okay, go to for  
58:23 - the computers like print out its move immediately. 
So what I'm going to do is during this while loop,  
58:28 - so for every single iteration that we switch 
on and off, I'm going to add in a tiny pause.  
58:34 - And I can do that by calling time dot sleep. And 
let's just say 0.8, that's 0.8 seconds. And at the  
58:41 - very top, we have to import time in order to make 
this work. So here, we're going to do a little  
58:49 - tiny break to make things a little bit easier 
to read essentially. And let's try rings again.  
59:00 - So we make us move to square four. l makes a move 
to square six. And let's try the top left. So  
59:08 - 00 goes to three and we want 
that bottom right. So let's do  
59:15 - 908 we actually have to fix that text too, though. 
Okay, so we see that we win though. Alright,  
59:26 - let's go back into the code. 
And it should actually be  
59:30 - in a player dot pie here. We're just going to edit 
this. It's actually zero to eight. Okay, save it.  
59:36 - So we were able to actually detect that it was 
an invalid square and that we had to try again.  
59:41 - So yeah, that is our bare bones 
Tic Tac Toe implementation.  
60:02 - Alright, so we created a game 
of tic tac toe in Python.  
60:06 - And we created a human player and 
we created a random computer player.  
60:11 - But can we do better? Can we make it so that 
the computer literally never loses? Maybe ties,  
60:18 - but never loses? And the answer is yes. So 
let's take a look at how we're going to do that.  
60:29 - minimax is a decision making algorithm built off 
of a Maximizer and minimizer concept. Basically,  
60:37 - you're trying to maximize your win while your 
opponent is trying to minimize their loss.  
60:42 - Now, in a game of tic tac toe, we can step through 
each state, and see how minimax might help us win  
60:49 - and become victorious. In mini Max, we are trying 
to find the best move to make, we can determine  
60:56 - this by trying out all the moves, and figuring 
out which one is most optimal. There's something  
61:02 - called a utility function, which is basically a 
measurement of how valuable the final result in  
61:08 - that tree is. Now let's take a look at an example 
using a partially completed game of tic tac toe.  
61:15 - So in this current board, it's X's turn. And 
obviously, the goal is to maximize x since we  
61:22 - want to win. So the first step is to put down 
an X in every single possible potential move.  
61:29 - You'll notice that in the middle, we actually 
won the game because we formed three in a row.  
61:35 - Now let's talk about this utility 
function for a little bit.  
61:38 - Since we want to win, we want our utility to be 
positive, since this is a positive value to us.  
61:45 - Now, in addition, I have this factor of three, 
because I want to win in as little steps as  
61:51 - possible. So how I got this number is I took 
the remaining squares on the board and added  
61:57 - one so that if you did win, you still ended up 
with a positive value and not zero. And then I  
62:03 - multiplied it by either plus one or minus one, 
depending on who the winner was. So for example,  
62:09 - if Oh had actually won in this situation, with two 
squares left, then I would have done negative one,  
62:16 - times two plus one, three, which is negative 
three. So moving on from there, we want to map  
62:22 - out all the possible scenarios of gameplay. 
So continuing this tree, we have this layer,  
62:30 - and then this layer until the board is filled, or 
until somebody has won. Now let's add the utility  
62:37 - function for all of these. Since Oh, one on 
the left, we're going to do negative one,  
62:44 - times one plus one, since there's one 
square left, which gives us negative two.  
62:51 - In the second one, nobody wins, and 
it's a draw, so the value is just zero.  
62:57 - Now on the right, the first one, we went again, 
but in this case, we don't have any empty squares.  
63:05 - So we're just going to multiply one by one. 
And then on the right, on the far right,  
63:13 - it's a draw again, so we have a value of 
zero. Now that we have these utility values,  
63:18 - we can propagate them back up to 
find the most optimal path to take.  
63:23 - So at the very bottom level, we have a Maximizer 
function, because it's X's turn, there's actually  
63:29 - no decision to be made in the bottom row, 
because there's only one option one path to take.  
63:36 - In the second row, it's his turn, and we assume 
that Oh, we'll be taking their most optimal path,  
63:42 - which means that we want to minimize the value 
that o has. And in this case, on the left hand  
63:51 - side, it's between negative two and zero. 
And since negative two is less than zero,  
63:56 - the left gets assign a value or utility value 
of negative two, the middle is still three  
64:02 - because there's no additional options after 
that. And on the far right, we're choosing  
64:08 - between one and zero. And since zero is less 
than one, the far right has a utility of zero.  
64:15 - And the next stage, it's back to X's turn, and 
we want to maximize x between negative two,  
64:22 - three and zero. Obviously three is a maximum, 
so we would choose that middle path. So now we  
64:28 - know what the most optimal solution is in order 
to win in the least number of steps possible.  
64:37 - Alright, so for our implementation, we are 
going to create a genius computer player.  
64:45 - And this of course, is going to take 
player as a superclass once again,  
64:50 - and here we're going to initialize it the 
same way we initialize our other two players.  
64:55 - So in our unbeatable computer player, we also 
want to get money. And get move is where all  
65:01 - the magic is gonna happen. At the very beginning, 
if all the spaces are available, let's just say,  
65:08 - grab a random spot and just go there. So 
we're just randomly going to choose one.  
65:13 - Otherwise. Alright, so now we're going to get 
the square based off of the minimax algorithm  
65:20 - that we described. So because of the nature of the 
algorithm and how it's recursive, we're going to  
65:26 - define a function minimax, outside of our get move 
function, but we're going to call that from here.  
65:33 - So self dot minimax. And we're going to need to 
pass in the game and the letter of the player. So  
65:38 - we know that we can win enough the other player. 
So at the very end, we return the square that  
65:44 - was returned from our algorithm. And now let's 
define the algorithm here. So define minimax,  
65:50 - and then self commerce date, comma, player. 
So the reason why I wanted to call the state  
65:57 - and not game was because at every single 
iteration of minimax, we pass in a representation,  
66:04 - a screenshot of the game in that state. So I'm 
just calling it state, it's just a variable name,  
66:10 - you could call it s, you could call it game, you 
call it whatever, I'm going to call it state,  
66:14 - because in my head, we're passing in states, 
we're passing in screenshots of the game.  
66:21 - Alright, so the max player is going to 
be yourself because you want to maximize  
66:26 - your score. So it's going to be self dot 
letter. And then other player is going to be  
66:32 - other players. So whatever the letter is not. So 
first, we want to check if the previous move is  
66:38 - opener. Alright, so when we have recursion, we 
always need a base case. And this base case is,  
66:44 - well, at the very end of things. Where 
are we at. So here, we want to see,  
66:50 - you know, was there a winner in any of the states 
that we've passed in, so we know that in our game,  
66:55 - we have a current winner. So if the current 
winner is equal to whatever other player is,  
67:03 - then we should return the position. And the score 
these we need to keep track of both of these  
67:08 - things for the algorithm to work. So we're going 
to turn this into a dictionary, so the position is  
67:13 - none. And the score well, so this is the formula 
that I was talking about earlier, we're going to  
67:20 - multiply one times the State DOT number of empty 
squares, because we want to maximize the number of  
67:27 - empty squares, we want to get to a win as soon as 
possible. plus one, if the other player is the max  
67:34 - player, right? Otherwise, we're going to do the 
exact same thing, but multiplied by negative one.  
67:45 - So LS negative one and then State 
DOT number of empty squares,  
67:49 - and then plus one. Okay, so if there's no 
winner, but if there are empty squares,  
67:55 - well, that means that nobody's won. So our score 
is going to be neutral, it's going to be zero.  
68:00 - And the position again, will be none, because we 
didn't move anywhere. Alright, so these are our  
68:07 - base cases. Alright, so now here, we're going to 
get into the algorithm. So if the player is a max  
68:12 - player, then we're going to initialize a variable 
best, and this is going to be a dictionary, that's  
68:19 - going to save the best position to move and the 
best score. And because this player is going to  
68:26 - be the max player yourself, you want to maximize 
that every single time step. So you're comparing  
68:32 - every single score to the score, and you're trying 
to increment it. So that means that we want to  
68:38 - initialize it to the lowest possible score. So at 
least one iteration will beat that score. If we  
68:44 - initialize it to negative infinity, anything 
that's defined is going to beat that score.  
68:49 - If the player is not the max player, then we want 
the position to still be initialized to none.  
68:54 - But the score we want to initialize infinity, 
because we're trying to minimize at every single  
68:59 - point. So we're trying to decrease that. So we 
have to initialize to like the highest possible  
69:03 - value. So for every single possible move in the 
available moves, we're going to do a few things.  
69:09 - So the first step is we're going to make 
a move, and we're going to try that spot.  
69:16 - So in step two, we're going to recurse using 
many Mac's to simulate a game after making  
69:21 - that move. So what happens, like from there on 
if we make that move? Alright, so step three,  
69:27 - we're going to have to undo that move so that 
we can try the next one in a future iteration,  
69:31 - right. The fourth and final step is 
we need to update the dictionaries,  
69:36 - if necessary. So if your score from that possible 
move, actually beats the current best score,  
69:43 - then we want to replace that dictionary with 
whatever we get from that possible move. Alright,  
69:49 - so let's get into implementing these. So for step 
one, we want to call our State DOT make move,  
69:57 - and this is going to be whatever possible And the 
player that's making that move. So player, right,  
70:03 - and then our simulated score is going to be, well, 
we just made that move. So now we're going to pass  
70:10 - the new state into mini max again. And so here, 
I'm going to call self dot mini max state comma,  
70:18 - and then we're going to alternate players. 
So it's going to be the other player.  
70:22 - Step three, we undo the move. So at that possible 
move on the board, we reset it to an empty space.  
70:29 - And then we set the state current winner back 
to none. So this is undoing whatever move that  
70:35 - we just did, and the simulated score. Okay, so 
remember that at the very end, we return this  
70:41 - position and then not right, so we actually 
have to set what position we just moved to.  
70:47 - So here, our simulated score position actually 
equals the possible move that we've just passed  
70:54 - in. Otherwise, this would kind of get messed up 
from like the recursion part. Alright, so now in  
70:59 - our fourth and final step, we say if the player 
is the max player, if the sim score is actually  
71:06 - greater than our best score, then we replace this 
best dictionary with the sim score dictionary.  
71:16 - Otherwise, this means that your players 
actually the mid player and your sim score,  
71:20 - if it's less than your best score, we again 
replace our best dictionary with the same  
71:24 - score because we've successfully gotten a lower 
score. And so what we're doing is we're trying to  
71:30 - maximize the max player, but minimize the 
other player. And at the very, very end,  
71:35 - after we've tried every single possible step, 
then our best score, this best dictionary  
71:41 - will contain the best next possible move, and 
the best score that can arise from it right,  
71:47 - it ends up returning a dictionary of the position 
and the score. So in order to use that in our get  
71:53 - move for our genius computer player, 
we have to actually index for position,  
71:58 - and then that'll return the square the 
position where we're actually going to go.  
72:04 - Oh, actually, this should be class. Sorry, 
that was a little mistake from my end.  
72:13 - All right. And now instead 
of random computer player,  
72:19 - let's try playing against the genius computer 
player. And we have to of course, import that.  
72:26 - Let's start a game, we're going to go to the 
middle square, so for and we get this air.  
72:34 - So let's go back to our code. And where do we 
call that? Where does this air coming from?  
72:41 - So we actually said we're missing 
an ASP right here. small mistake.  
72:44 - So let's try rewriting this after we fix 
that. So four, they go to zero, let's go to  
72:52 - the bottom left looks pretty good. And that 
is square six. So let's go to square six.  
73:02 - All right, they go to square two. So we 
got a block, we got to go to square one,  
73:06 - they kind of forced our hand one. Alright, they go 
to seven. So this, this is going to be a tie game,  
73:14 - right? So no matter where we go, I mean, yeah, 
it's a tie. Right? Let's try again. And I'm going  
73:23 - to show you how this algorithm is actually going 
to make a move cleverly, to a spot where, like,  
73:30 - it'll win. So it's, I'm just going to show 
you, it's going to go there in the middle.  
73:35 - So let's go to the left and see what happens. 
So that's where six, the algorithm knows,  
73:40 - to take that bottom spot to win. And here, what 
we actually can do is, we can set this genius  
73:48 - computer player to play against a random computer 
player. And what I'm going to do is actually  
73:55 - print turn print game to false. And make this 
play a bunch of times. So we're gonna keep track  
74:00 - of number of x wins, oh wins, and ties. And then 
we're gonna say like, let's run this 1000 times.  
74:07 - Remember that play passes back whoever wins, 
right? Alright, so I'm actually going to put  
74:14 - this time dot sleep in print game, otherwise, 
it's going to be kind of it's going to slow  
74:18 - it down unnecessarily. So at the very end, our 
result is going to be whatever place that data  
74:24 - because that's the winner. So if the result 
is x, then we're going to increment x wins  
74:30 - plus equals one. If the result is Oh, then 
we're going to increment o wins by one.  
74:41 - And then now if it's none, so that means x doesn't 
win or doesn't win the we're going to increment  
74:46 - ties by one and then at the very end, we're gonna 
print like who won what, right so after 1000  
74:52 - iterations, we see x wins. x wins. We see oh wins. 
Oh wins. And then we see ties number of ties.  
75:07 - Alright, let's try running this 1000 times. 
This actually takes a while to run. So let's do  
75:18 - a little bit of magic called video editing. And 
bam, we see that after 1000 iterations, we see  
75:26 - 0x, one 793, a wins, and 207 ties. And you 
can run this with the human with the random  
75:35 - computer player as x or Oh, but if you're 
playing against a genius computer player,  
75:40 - you will realize that it never loses. It 
only wins and it only ties but it never  
75:47 - loses. You can run this with like a 
million iterations and it will not lose.  
75:55 - Before we implement binary search, let's actually 
understand what binary search is binary search  
76:00 - algorithm is a divide and conquer algorithm, 
which actually helps you search an ordered list  
76:07 - faster than just scanning every single element 
and asking, Hey, is it Is this it? Is this it.  
76:14 - And what I mean by dividing conquer is that 
binary search essentially works like this. So  
76:19 - assume that we have some list of ordered elements 
from least to greatest. And we're trying to see  
76:24 - if this target is in the list, and if it is, then 
return the index of where it is. So essentially,  
76:30 - we're searching this list for this target. So what 
we can do in binary search is we can go to that  
76:36 - middle element of this list, and we can ask, Hey, 
is the target equal less than or greater than this  
76:42 - middle element? If it's equal to then Well, we've 
found it right. But if it's less than one, then we  
76:49 - know that it actually has to be on the left side 
of that element. And we can completely disregard  
76:55 - searching anything greater than that element, 
so we can completely disregard the right hand  
76:59 - side of that list. And now vice versa, 
if it's greater than that middle element,  
77:04 - then we only have to search the right half 
of the list. And now, again, we can reiterate  
77:11 - on that one section. So we divide and then we 
conquer that one section. So in that left side,  
77:17 - let's say that our target is smaller than so let's 
say Our target is seven, and seven is less than  
77:24 - 15. So on that left hand side, what we can do 
is we can redo the exact same thing, take the  
77:29 - middle of that left hand side, our target is less 
than, greater than or equal to if it's equal to,  
77:36 - we're done, we found it. If it's less 
than, again, we look at the left hand side,  
77:40 - if it's greater than that, we look at the right 
hand side. But up to that middle point where we've  
77:45 - already checked these, we're limiting ourselves 
to that left hand side of the array. Let's say  
77:50 - that our target is actually greater than this next 
middle. And so then we look again on that right  
77:55 - hand side of the array. And you can imagine how, 
with a really, really big array, we keep dividing  
78:00 - in half every single time, because eventually, 
it'll either be the midpoint of a bigger array,  
78:06 - or we'll come down to like a sub array of like 
size one. And then we found our element there.  
78:13 - So in this project, I'm actually going to prove 
that binary search is faster than naive searching  
78:18 - by naive search, I just mean, you're iterating 
through the entire list. And you're asking, Hey,  
78:23 - does this value cool our target? What about here, 
here, here, here, here, and so on. And so you're  
78:29 - basically asking every single element 
until you hit whatever your target is.  
78:33 - So now you've searched we're scanning the entire 
list asking if it's equal to the target. If it is,  
78:38 - then we return the index. If not, then we return 
negative one. So let's define naive search, we're  
78:44 - going to give it a list L and a target. So for 
i in range, length l. So for every single index,  
78:51 - if l at that index is a target, 
then we return that index.  
78:56 - Otherwise, we've gone through the entire 
list, nothing's there, we return negative one.  
79:03 - For example, our l could be one 310 
12, right? And if 10 is our target,  
79:08 - then we're saying okay, for the first 
I, so if I will zero or element numbers,  
79:15 - one that does not equal the target, keep going. 
So then three, the three equal target, no,  
79:20 - keep going. Alright, so now we're at index two. 
Okay, well, 10 equals the target. So we return  
79:27 - to and if it's not in there, then we end 
up returning negative one at the very end.  
79:35 - Okay, so then binary search uses again, 
divide and conquer. So we will leverage  
79:41 - the fact that our list is sorted 
in order to make our search faster.  
79:46 - So let's define binary search and then 
give it again a list L and a target.  
79:55 - Alright, so here I'm going to provide 
another example and I'm actually To add  
80:00 - one more element in here, so it's one longer 
than our previous example. So 135 1012. And  
80:06 - let's say we're searching for 10. Again. And so 
here, we're just saying, okay, it should return  
80:12 - three, index three, because 10 is at index 
three. So the first thing that we have to  
80:16 - do is we have to find our midpoint. So our 
midpoint is going to be the length of this list,  
80:22 - and then divided by two, but rounded down and this 
double dash here, this means this means how many  
80:31 - times to go into length, right, so that's going to 
give us approximately the index of the midpoint.  
80:38 - So now, if l at this midpoint, so this list 
at the midpoint is equal to the target,  
80:44 - then we can return that midpoint 
right there, because that's our index.  
80:48 - Now, if the target is less than the value at that 
midpoint, so our targets 10, our values five,  
80:55 - so this is comparing 10, less than five, right? 
Which is not true. But if it were, again, this is  
81:01 - saying like chop off half of the list, and iterate 
over only one section of it. So we're going to  
81:08 - recurse. So we're going to use binary search 
again, on that one section that we're given,  
81:13 - which here would be one comma three, if this value 
if this statement had been true. So again, we're  
81:20 - gonna have to pass in some list, and I'm just 
gonna leave this as l For now, we have to divide  
81:25 - it, we're not dividing anything right now. But 
I'll get back to it. So then in the L statement,  
81:31 - well, this means that the target has to be 
greater than whatever values at that midpoint,  
81:35 - so we only check what's to the right of it. Right. 
So then we do another binary search. All right,  
81:43 - now these two, I told you guys, I would get back 
to the fact that we're going to divide it in a  
81:48 - bit. And what we can do is, we could theoretically 
say, okay, actually just pass in that half of the  
81:56 - array, so we could index L, so that it's the 
left or right hand side, but then we just have  
82:00 - to add the index back in another way is that we 
can add in low and high into our binary search,  
82:08 - and these are going to be the lowest indices 
to the highest indices that we search.  
82:13 - And then here, when we recurse, we can say the low 
is equal to the current low, but the new high is  
82:20 - going to be the midpoint minus one. And then for 
the other side, we can say the low is now going to  
82:28 - be, well, the next one after the midpoint, all the 
way until whatever the original high value was,  
82:34 - and again, low and higher indices. So these are 
all the indices in our list that we can check. And  
82:39 - these are just bounds on the indices. Alright, so 
first, if low is none, then let's set low to zero  
82:45 - because we want low to be the lowest possible 
index that we can check. And then high if high  
82:51 - is none, high is going to be the highest possible 
index that we can check, which is length L minus  
82:56 - one. All right, and then for our midpoint, instead 
of just the length of L, we're going to change  
83:02 - this to low plus high because remember, this 
is the lowest indicee plus the highest indicee.  
83:06 - So the average of those two would be whatever 
index is in the middle. So that's our midpoint.  
83:11 - How do we know that our targets not even 
in the list, what we can do is we can say,  
83:16 - All right down here every single time Our 
target is to the left of the midpoint,  
83:21 - we're actually subtracting one from the high. And 
then every single time Our target is to the right  
83:26 - of the midpoint, we're adding one to the midpoint 
for the low. So if the high bound is ever less  
83:33 - than the low bound, that should never happen, 
theoretically, if this were iterated properly,  
83:38 - the only time is when it can't find it, though the 
target is not in the list, then we return negative  
83:45 - one. So that's our case of you know, it's it's 
not in this list. Alright, so if name equals main,  
83:56 - then let's create a list 135 1012. Let's 
make the target equal to 10. And then let's  
84:03 - print naive search of this list and then the 
target. And then also binary search for that.  
84:13 - Alright, opening terminal. Let's run the script.  
84:18 - And we see both of them return three. All right, 
now let's do a little bit of timing analysis to  
84:24 - show you guys that it actually works to not check 
the entire list. Alright, so let's set legs to  
84:32 - 10,000. And so here we're going to just build a 
random sorted list of life 10,000. Let's say the  
84:38 - values in our sorted list, let's initialize it to 
a set first. And then while the length of the set  
84:44 - is less than length, well, we're going to add some 
random integer. And just to have bounds on this,  
84:51 - let's do something like negative three times the 
length of the list and then all the way till three  
84:57 - times the length of the list. So that gives us 
a range of like Negative 30,000 to 30,000 for  
85:03 - our algorithm to just choose a random 
number and add it into this list.  
85:08 - Alright, so then after this is 
done, then we're going to say,  
85:12 - okay, make the sorted list into a list, and 
then sorted. So that's what sorted is. So and  
85:18 - then we're going to reassign this to the variable 
sorted list. And then we're going to import time,  
85:23 - because well, we're gonna want to time 
how long it takes for each of those.  
85:30 - And how we're gonna do that is we're gonna say, 
okay, start equals time, that time, so that gets a  
85:34 - time right now. And then we're going to call naive 
search on the sorted list, and get some target.  
85:42 - And let's actually say, let's iterate 
through every single item in this list,  
85:48 - and try to find that item in the list. So 
for target in the sorted list, so that means  
85:55 - we're going through the inherits word list 
and making everything the target, and then  
85:58 - running naive search on that one target. So we're 
basically running naive search 10,000 times here.  
86:05 - And the end time is going to be again 
time dot time, at that spot. And so  
86:12 - then the knife search time is actually 
just the end time minus the start time.  
86:20 - And so we can actually do this per 
iteration if we divide it by length. So  
86:26 - for each iteration, on average, it's going to be 
n minus start, and then divide that by length,  
86:31 - number of seconds. And again, we're gonna 
do the exact same thing for binary search,  
86:36 - but make it binary search. So let's run that.  
86:44 - Okay, we see that naive search takes approximately 
like point 443, like millisecond, so that's  
86:53 - 443 microseconds, whereas binary search, I 
mean, it takes 6.8 microseconds. So let's  
87:01 - compare that that's like 6.8, compared to 400, 
something for a nice search. So yeah, basically,  
87:09 - if you ever have to search a sorted list, never 
search every single item. I'm going to show you  
87:19 - guys how to build a command line version of 
Minesweeper that looks something like this.  
87:38 - We're going to be using recursion and classes 
to build our game. Now, before we get started,  
87:43 - I just want to say that I'm building a very 
bare bones command line version of this game,  
87:50 - because I believe that when you're learning 
how to code, if you actually want to learn how  
87:55 - to translate your ideas and algorithms into 
Python, the bulk of that is going to be in  
88:01 - actually implementing the game, not figuring out 
how the UI works. I think that the UI while it's  
88:07 - important, it is somewhat secondary, to actually 
learning the coding process and the algorithmic  
88:14 - process that's involved with building these games. 
Let's start off by defining the play function.  
88:20 - So here, our goal of this function is to play 
the game. So we're going to find play pass in a  
88:25 - dimension size, which is going to be the size of 
the board, and the number of bombs on the board.  
88:33 - Alright, so in step one, we're going to create 
the board and plant the bonds. In step two,  
88:38 - we're going to show the user the board and ask 
them where they want to go. And now step three,  
88:44 - well, if the location is a bomb, then we show 
the game over message because they just dug  
88:50 - where there was a bomb and but if the location 
is not a bomb, then we dig recursively until  
88:57 - each square is at least next to a bomb, right? So 
you think about how Minesweeper works if you dig  
89:02 - somewhere, and it's empty, and everything around 
it is empty, then you keep digging until you get  
89:07 - to a number and that number represents that that 
square is next to a bomb. And then in step four,  
89:15 - we repeat steps two and three until there are 
no more places to dig. And then we've achieved  
89:22 - victory. Alright, so right now we're just going to 
say path because we'll get back to this function.  
89:33 - Okay, so let's take advantage of our 
object oriented programming tools that  
89:37 - we have in Python. And let's create a board 
object to represent the Minesweeper game.  
89:44 - So this is where we can say, create a new object, 
or dig here, or render this game for this object.  
89:52 - Let's define a class called board. And here we're 
going to initialize it with the dimension size,  
89:59 - and the number of boards. So let's keep track 
of these parameters because they're going to  
90:04 - be helpful later on. So let's assign self doubt, 
dimension, size, dim size to the dimension size  
90:11 - that was passed in. And then self dot number of 
bombs to the number of bombs that will pass in.  
90:17 - And then we're going to create the board. But 
let's get back to that. And at the very end,  
90:24 - we're going to initialize a set to keep track of 
which locations we've uncovered which locations  
90:30 - we've dug in where the user has gone. So self dot 
dog is going to be an empty set. Okay, and then  
90:37 - let's create the board. So let's actually use a 
helper function. So self dot board equals self  
90:44 - dot make new boards. And here we're going 
to plant the bombs to. So let's define that.  
90:51 - Alright, so we're going to find, make 
new board, pass and self. And basically,  
90:57 - this is going to construct a new board based 
on the dimension size and the number of bombs  
91:02 - that we pass in. And there are a bunch of 
different representations that we can use,  
91:06 - that can be like a list of lists where each 
sub list is just a row of this board. So here,  
91:11 - we're going to generate a new board, this board 
is going to equal it's going to be none and  
91:16 - then repeat that dimension size number of times, 
because that's how long we want this list to be.  
91:22 - And then we're going to have dimension size 
number of these lists so that we can get  
91:27 - a square board. And so this creates an array that 
looks something like this, it's just going to  
91:32 - be a board where it's non non non non non etc, 
for whatever dimension size that we define it.  
91:39 - So then next, we have to plant the bonds. So here, 
we're going to say bombs planted equals zero,  
91:44 - we're just going to use a while loop. And we can 
say, while bonds planted is less than cell phone  
91:51 - number bombs, we can pick a random location 
for the bomb, right, so let's actually go up  
91:56 - here and let's import random. And now for 
the location, we're going to do random dot  
92:04 - Rand int, and somewhere between zero and CELTA 
dimension, size squared minus one. So you can  
92:10 - think about this logic as like, we're literally 
assigning a number from zero, you know, to the  
92:15 - number of spots on the board, and we're assigning 
each spot on the board its own unique ID. And  
92:20 - then this random dot Rand n is returning a random 
integer n, such a is between the bound A and B. So  
92:28 - a would be zero, B would be the largest ID in that 
list. And then here, we want to actually get the  
92:35 - row and the column of that ID that we've chosen 
from this random selector. So we're going to do  
92:43 - the location and then this double slash self 
dot dem size. And what this is going to do,  
92:49 - it's going to say, how many times is my dimension 
size, go into whatever location that I've chosen,  
92:54 - that's going to be the row that we're indexing in. 
And then now, once we have the row, how do we know  
93:00 - which column we have to divide by the dimension 
size, and then whatever index is leftover,  
93:07 - that's going to be how far into that list, we 
have to index in order to find the column. So  
93:13 - once we have the row index and the column index, 
we can index into the board. And then we can say,  
93:19 - if board and then row column, we're going to 
index into that specific row column location  
93:25 - on the board, if it equals a bomb, so the stars 
what we're going to use to represent the bombs,  
93:30 - then this means that we've actually planted 
a bomb there already. So we're not going to  
93:34 - increase bombs planted, right? Instead, we're 
just going to keep going. And this is actually  
93:40 - the reason why I'm using a while loop and not a 
for loop. Because in a for loop, you know, every  
93:45 - single time we skip, we're like continue, we're 
still counting that as an iteration. But here,  
93:52 - I only want to increment when I actually get 
something that's not a bomb yet. And then I plant  
93:58 - the bomb. So yeah, that's why I'm using a counter. 
And that's why I'm saying, hey, check it, this is  
94:03 - a bomb, if it is keep going. If not, then we're 
actually going to plant the bomb. And then we're  
94:08 - going to increment this counter bombs planted. And 
at the very end, I'm going to return the board.  
94:19 - Alright, so that is making our new board 
we're going to plant the bombs right there.  
94:23 - Alright, so what other information is useful? 
Well, we want to know, at each spot on this board,  
94:31 - how many bonds are around that spot that's going 
to help us when we choose where to actually  
94:36 - dig right when the user input something, well, how 
do we know where you know whether or not we should  
94:43 - keep digging around it? And yes, we can implement 
a check at each point where we say like, oh,  
94:49 - if we did here, we're going to check all its 
neighbors and we're going to dig again and,  
94:53 - you know, so on. But we can also just assign 
values to every single space on the board that  
94:59 - represents How many bonds are in the neighboring 
spaces. So let's call that assign values to board.  
95:06 - So here let's define assign 
values to board and pass in self.  
95:16 - Alright, so now that we have the bombs planted, 
we're assigning a number zero through eight  
95:20 - for all the empty spaces that don't have 
bombs. And this is basically representing  
95:24 - how many neighboring bombs are 
there, we can pre compute these,  
95:28 - and it'll save some effort checking what's 
around that square later on. Basically,  
95:34 - we want to check every row and every column. 
So for our end range, self dot dimension, size,  
95:40 - for C and range self that dimension size, this is 
going to be the row index and the column index.  
95:46 - So if the item at the board, so if, at those 
indices on the board, it's a bomb, we're going to  
95:53 - continue, right, because we don't want to actually 
override any of the bombs that we've planted.  
96:00 - But if it's not, then we pass this if statement, 
and then we say, okay, for this location on the  
96:06 - board, let's create a new function called get num 
neighboring bonds, pass in the row index and the  
96:13 - column index. And then this function is going to 
give us the number of bombs that is surrounding  
96:19 - that row, comma, column. Alright, so let's define 
this define get number of neighboring bombs, we're  
96:25 - passing in the row and the column. Like if you're 
confused of why I have our comma see up top,  
96:32 - and then row comma call, these are just variable 
names, you just have to make sure that they match  
96:37 - where you're actually calling them. So 
for example, when I call the function,  
96:41 - I'm passing it r comma C, because I've defined 
R, and I've defined C in my for loop. So those  
96:46 - are variables that I've defined. And now 
when I create this new function, I can  
96:51 - call the parameters that get passed in whatever I 
want, right. And so here, the R would correspond  
96:57 - to the row and the C would correspond to the 
column. So now let's iterate through each of the  
97:04 - neighboring positions and sum up the number of 
bombs. So here, I've kind of imported a list  
97:11 - of all the neighboring positions, you can see 
that top left is row minus one column minus one,  
97:17 - and middle is row minus one column, you know, and 
so on. And so we're going to check all of these,  
97:23 - and we have to make sure that we don't go out 
of bounds. So that's just a little reminder.  
97:28 - Okay, so first, we're going to initialize 
the number of neighboring bombs. So just to  
97:31 - a variable set to zero, this 
is going to be our counter.  
97:35 - And then we're gonna say for our in range row 
minus one row plus one. And then keep in mind  
97:40 - that due to the nature of the range function in 
Python, we have to add a plus one to the end.  
97:46 - And then same thing for the column for C and 
range column minus one column, plus one plus one.  
97:56 - That should be plus. Alright, so basically, what 
we're doing here is for the current row that we're  
98:02 - at, we're checking below and above. And then for 
the current column, we're checking to the left and  
98:08 - to the right. And so when we sum up all these 
combinations, we get every little piece of the  
98:12 - three by three grid. And then we can say, if 
r equals the current row that we've passed in,  
98:18 - and if sequels called the column that we've 
passed in, this is basically saying, like this  
98:23 - is our original location, we don't actually have 
to check this. So we continue. But if it's not,  
98:30 - if self dot board at RC equal to star, so that 
means that there is a bomb at that location,  
98:36 - that means that we have a neighboring bomb, right, 
and so we can increment number of neighboring  
98:41 - bombs by one. And then at the very end, after 
we've gone through all the neighbors, we're just  
98:45 - going to return the total number of neighboring 
bombs. Now we have to go back up here and we have  
98:50 - to make sure that we don't actually go out of 
bounds, right, because row What if rho is zero,  
98:55 - what if we're checking the first row row minus one 
is going to be negative one that's out of balance.  
99:00 - Here, we're gonna add a max statement just to make 
sure that you know row minus one, if it ever goes  
99:04 - past negative one, we're going to take zero every 
single time we go below that zero bound. And then  
99:10 - for the upper bound, we're going to do the same 
thing. We're in take the men of rho plus one, and  
99:14 - then self dot dimension size, minus one because 
that is the maximum index that we can go, right.  
99:24 - And then of course, we're gonna use the exact 
same logic for the columns, just like this.  
99:37 - solve some spacing stuff. And so yeah, now 
we've got our bounds checking a we can return  
99:42 - the number of neighboring bonds. Alright, 
let's go back to our play function now.  
99:49 - So step one is creating the board and planning 
the bonds. So what we can do is we can say the  
99:54 - board equals an instance of this board 
class, and then we're going to pass in  
99:59 - the dimension size. And the number of bombs 
that we've passed into this play function.  
100:04 - And this is going to automatically, you know, 
go through that initialization function. And  
100:09 - it's going to initialize the board and plant the 
bombs and create an empty set for dog, and so on.  
100:15 - Alright, so now part two, we're going to show 
the use of the board and ask where they want  
100:20 - to dig. And then we're gonna check if the 
location is a bomb is not a bomb, we're going  
100:25 - to dig recursively. So let's actually go back 
and let's implement some of these functions,  
100:30 - so that we have them, you know, handy when 
we need them. So let's define a function  
100:35 - called dig within the board class. And we 
can dig at a certain row and column index.  
100:42 - So we're digging at whatever 
location the user has specified.  
100:45 - And let's return true if it's a successful dig. 
And then a false. If we've actually dug a bomb,  
100:51 - it's game over and we've lost. So there are a few 
scenarios here, right either, you know, we can dig  
100:57 - somewhere and we hit a bomb, and then it's game 
over, we can dig out a location with neighboring  
101:02 - bombs. And then you know, we finish the day 
because we've uncovered a number that's not zero.  
101:10 - But we might also be digging at a spot where 
there are no neighboring bonds. And in that case,  
101:15 - we want to dig its neighbors until we actually 
get somewhere where there are neighboring bombs.  
101:22 - So the first thing that we want to do when 
we dig at a row, comma column, is we want  
101:26 - to add a tuple to self dot dug to make sure that 
we're keeping track of where we've actually dug.  
101:35 - And then we're going to check the 
board at that row and column. So  
101:39 - in our first scenario, if it's a bomb, 
we return false if there's a bomb dog.  
101:44 - Now, if we check that space, and you know, it's a 
number that's greater than zero, that means that  
101:50 - we've dug out a location with neighboring bombs. 
And we finish the dig. So we just return true  
101:56 - because we did not take a bomb. So now if at that 
row and column on the board, it's not a bomb,  
102:02 - it's not a number greater than zero, it 
means that that spot is equal to zero,  
102:07 - right? So here, we're going to use the same 
logic from get number of neighboring bombs,  
102:12 - where we're checking for the neighbors. And let's 
paste that down here. So here, we're gonna check  
102:18 - R and C for all the neighbors. And so if r comma C 
is in self dot dog, then we continue, because this  
102:27 - is basically saying, you know, don't dig where 
you've already dug. That's pointless, right?  
102:33 - But after that, if it's not, then we dig at 
that location. So we pass in our commissie  
102:41 - into this dig function again. And 
we continue through all of this,  
102:45 - there shouldn't be a way where we ever get to a 
bomb, right? Because we should always be stopping  
102:51 - at some square right before a bomb. So at 
the very end, we're going to return true.  
103:00 - So I'm just going to add one more thing to this 
Minesweeper game. This underscore underscore  
103:07 - string underscore, underscore. And so this is a 
magic function, where if you call print on this  
103:14 - board, it's going to you know, it's going 
to print out whatever the string function  
103:18 - returns. And so here, what we're going to want to 
do is we're going to want to return a string that  
103:23 - shows a board to the player. And I'm going to go 
over part of this function, but part of it was  
103:28 - kind of just like, like, if you inspect the code, 
you'll be able to tell what we're kind of doing.  
103:35 - Okay, so first, we're going to create a new array 
that represents what the user should see. So let's  
103:41 - call this visible board. So visible board is 
going to be well, first, let's just create an  
103:47 - empty board, just as we did above, so that's going 
to be our listing list. And it's going to be a sub  
103:52 - list of size, dimension size. And we're gonna 
have dimension size number of those lists. So  
103:58 - now for every single row, and for every single 
column, we're gonna use this for loop again.  
104:06 - If that row, comma column isn't self dot 
dog, that means a user has dog at that spot.  
104:11 - So visible board at that row, and that column is 
going to be whatever the actual board value is.  
104:19 - But if it's not dug already, then this is 
actually just going to be a space because  
104:24 - the user shouldn't be able to see what's at 
that location yet, they haven't dug there.  
104:31 - And we're going to put this entire board 
representation in a string. Now what you  
104:36 - can do is you can just honestly return like a 
string dot join, and then just this visible board.  
104:43 - In this code, I'm going to make it a little bit 
cleaner. And this is all that this stuff here  
104:50 - is doing. It's just some formatting code. 
You can look through it if you want, but  
104:54 - I'm just telling you right now, that it's just 
completely formatting to make it look prettier  
105:00 - and to make it print out nice. And honestly, I 
believe that knowing how to implement Minesweeper  
105:07 - is a lot more important to learn than learning how 
to print out a representation of the game. Okay,  
105:13 - so now if we look at steps two, three, and four, 
well, step four is basically repeating steps two,  
105:18 - and three, until there are no more places to dig. 
So that kind of sounds like a while loop to me,  
105:23 - right. And here, what we're going 
to do is we're going to say, well,  
105:28 - while the length of bore dug, so all the places 
that you've dug, remember that this is a set,  
105:34 - so there are no duplicates, while the length of 
the set is less than the board at dimension size,  
105:40 - squared, because that's how many spaces total 
there are on the board minus number of bombs, then  
105:48 - we're gonna allow the user to play because it 
means that they still have empty spaces on the  
105:51 - board where they can dig that are not bombs. 
So the first thing we're going to do is we're  
105:55 - going to print the board. And we're gonna 
ask the user, where would you like to dig?  
106:00 - And we're going to input this as row comma 
call. So something like zero comma three.  
106:08 - And now, here, I'm going to use a regex split. So 
that's what our e dot split is. It's saying input,  
106:17 - where would you like to dig, this is going to 
return a string, and we're going to split that  
106:21 - string by this regex. And so this comma is 
going to say, okay, detect any commas. And  
106:26 - then this parentheses slash slash s, well, this is 
saying any whitespace, so any spaces that you see,  
106:33 - and the star at the end is going to say, zero 
or more of those. So essentially, this is saying  
106:39 - match any part of this string that matches, you 
know, just a comma, or a comma space, or a comma  
106:45 - space space, whatever the user types, we're going 
to split that. So then we can handle something  
106:52 - like zero comma 00, comma space zero, or zero 
comma spaces to space zero, right. And here we  
107:00 - have the import party. So let's go back to the top 
and import our E so that we can split our string.  
107:09 - Okay, so now that we've split our input, we now 
know what row and column the user is trying to  
107:14 - dig. So we can assign row and column to the user 
input at zero and the user input at negative one.  
107:21 - The reason why we use negative one is sometimes 
it's ru dot split has some fluff on the inside  
107:26 - of this list. And so if we know the row and 
the column are at the beginning and the end,  
107:31 - then why not just take the first 
and the last item in this list,  
107:35 - and I'm going to use it, because 
we want these to be integers.  
107:39 - So now let's do some bounds checking if rho 
is either less than zero or greater than board  
107:45 - dimension size, or if column is less than zero 
greater than or equal to the dimension size,  
107:51 - we're out of bounds. So here, we're going to print 
invalid location, try again. And we're going to  
107:56 - continue so that we repeat this loop over again, 
until the user inputs A valid row and column.  
108:04 - But if the user did input something valid, 
then we did get that location. So we can call  
108:09 - board dot dig at row, comma call. And so now we've 
already implemented this part. So we don't have to  
108:16 - actually worry about the mechanisms of actually 
digging. We know that war dot dig is going to  
108:22 - return true if we've dug successfully and false If 
not, and so we can assign a variable called Safe,  
108:29 - whether or not our dig was safe. So whether 
or not we've uncovered a bomb or not, right.  
108:34 - So at the very beginning, we're actually going to 
say, safe is true, because at the very beginning,  
108:39 - we haven't done anything, you know, 
we're safe, we have all of our lives.  
108:44 - And so, if not safe anymore, well, this means 
that we've dunk a bomb. And that's bad. We're  
108:53 - gonna call break, because this means Game Over, 
we shouldn't be continuing this loop anymore,  
108:57 - we shouldn't be allowing the user to dig. So we're 
going to break out of that while loop. And now,  
109:04 - at the very end, there's two ways to exit this 
while loop right? Either you've won and there's  
109:09 - no more spaces on the board where you can dig, 
or you've dug a bomb. Nothing safe anymore.  
109:16 - And yeah, rip. So let's check which one. 
If we're still safe, this means that we've  
109:24 - just run out of spaces today, we've dug 
every single possible spot to dig. And so  
109:30 - we've actually won let's print. Congratulations, 
you are victorious. Alright, but on the other  
109:39 - hand, if we're not safe, that means that we've 
dug a bomb, and we can print. Sorry, game over.  
109:50 - and here we can actually reveal the whole board.  
109:53 - So we're gonna assign board dog to every single 
possible value of our commissie on this board.  
110:05 - So this double for loop in this list 
comprehension here is just saying,  
110:09 - take every single possible r comma c value of 
this board and put it in this list, the very end,  
110:14 - we're going to print the board. And so this 
is going to reveal every single possible spot.  
110:19 - Now let's call the play function 
to actually play the game.  
110:22 - And we're going to put this in a name equals main 
if statement, because this is just good practice.  
110:28 - It's basically saying like if you have a massive 
project, but you only want to run this file,  
110:33 - the stuff underneath name equals main will only 
run if you type in Python, three minesweeper.pi.  
110:39 - If you have a bunch of imports from bunch 
of other files, it's not going to run any  
110:43 - of the code under name equals main in those files, 
you're only running what's under name equals main  
110:48 - in that one file. Alright, so let's play the game. 
First, let's stay get, I don't know 00. So here,  
110:56 - you see that we've dug at 00. It was zero. So that 
means that you know, there were no bombs nearby.  
111:02 - And so we kept digging until you know, there 
were some bombs nearby. So for our next spot,  
111:06 - let's just do four comma six. And then let's try 
that bottom right corner. So nine, comma nine.  
111:12 - And you'll see that this actually dug a lot. So it 
recursively dug everything that you see that zero,  
111:21 - it dug until it hits some spot that was 
not zero. And if we look at this spot,  
111:27 - right here, three comma seven. Well, this 
is actually, you know, very clearly a bomb,  
111:33 - right? So let's dig there on purpose. So we get 
through seven, and it says sorry, game over.  
111:41 - And it actually reveals that yes, this was a 
bomb. And this was the entire map of our game  
111:48 - to begin with. There you have it, a 
command line version of Minesweeper.  
111:57 - next project is a Sudoku solver. In this tutorial, 
you'll be able to see how we can use recursion to  
112:03 - solve any valid Sudoku puzzle. Okay, so the first 
thing that we want to do is we want to define our  
112:08 - function solve Sudoku, and we want to pass in 
our puzzle. Basically, this function is going  
112:14 - to solve Sudoku using a backtracking technique. 
So our puzzle that we pass in is a list of lists  
112:22 - where each enter list is actually a row in the 
Sudoku puzzle. So basically, this represents the  
112:27 - nine by nine puzzle. And we're turning whether 
or not the solution exists. But in this code,  
112:33 - remember how lists are mutable. So we're actually 
mutating this puzzle to be the solution if the  
112:40 - solution exists. So the first step is I'm actually 
going to see where on the puzzle I can go. So as a  
112:48 - human, when we're playing Sudoku, we typically 
go from where we have the most information,  
112:52 - whether it's the column that's most filled out, 
or the row or the little tiny three by three box.  
112:57 - But because we have a computer, we don't have 
to do that, what we can do is we can assign a  
113:01 - number to any open space on the board. And then 
we can try essentially every single combination,  
113:08 - as long as it's valid. And when we see that it's 
not valid, we can actually go back and say, oh,  
113:14 - let's not try three. Let's try four instead. 
And if you think about the entire puzzle,  
113:20 - you can essentially come up with 
like, every single combination, oh,  
113:24 - it doesn't work from there. Okay, well, 
let's take a step back and try all the  
113:28 - combinations there. If none of those 
work, then we take another step back,  
113:32 - and try all the combinations there, and so on. And 
our computers actually powerful enough to do that.  
113:37 - So that's the technique that we're going to use 
here. So our first step is actually to choose  
113:43 - somewhere on the board. To make a guess, in order 
to do this, I'm going to create a helper function  
113:49 - called Find Next empty and pass in the puzzle. 
So I can find the open spaces on the board.  
113:56 - So here, I'm going to define Find Next 
empty passing puzzle. And essentially,  
114:00 - this function is going to find the next row 
column on the puzzle that's not filled yet. And  
114:06 - in our puzzle, we're representing any open spaces 
with negative one. So we basically want to return  
114:11 - the next space, that equals negative one. So we're 
going to return the index of the row. So that's  
114:17 - if this is a list of lists, the first index that 
we return is the location in that first list  
114:23 - that are empty spaces that the second value 
that we're returning is within that row,  
114:29 - which index is it app. And then of course, 
there might be a situation where our entire  
114:35 - board is filled, and there's no empty spaces left. 
In that case, we're going to return a tuple non  
114:41 - common none. So keep in mind that we're actually 
zero indexing. So we're starting from zero  
114:47 - and our last index is eight. So essentially, what 
I can do is I can just go in order, I can say,  
114:54 - hey, check each row and then check each column. 
And whatever the first empty space, you get I'm  
115:00 - just going to return the row comma column value of 
that. So here I can do for each row in range nine,  
115:06 - so I'm iterating through my nine rows. And then 
I can say for that row for each column value  
115:14 - in range nine, so that's my zero through eight. 
If the puzzle and then here's how we index,  
115:19 - we pick out the row. And then within that row, we 
use C to index again and get the column. So here,  
115:25 - this double indexing basically is returning the 
item in the arthro and the C's column. And then  
115:32 - if that equals negative one, then basically 
return that Farsi. Otherwise, we return  
115:38 - non common none. If we've iterated through this 
entire puzzle, and nothing equals negative one,  
115:44 - then that means that there's no spaces in the 
puzzle left, so we can return non common none.  
115:53 - Okay, so then the second step from there is, 
well, if there's no word left, we're going to  
115:59 - be implementing some validation checks of like 
whether our guests is actually valid or not. And  
116:04 - so if we filled out this entire puzzle, then that 
means we're actually done. So here, I'm gonna say  
116:10 - if rho is none, so remember that above, we return 
non common none. And then that first none gets  
116:17 - assigned to grow, the second none gets assigned 
to call, and so we only have to check one of them.  
116:21 - Now, if row is none, then we can return true 
because we've actually solved our puzzle.  
116:29 - But if we haven't, then we can keep 
going. Alright, step two, is basically  
116:36 - if there's a place to put our guests, then 
we want to come up with a guest between one  
116:43 - and nine. And we want to actually try all of 
them until we find a combination that works.  
116:48 - So I'm going to say for gas in range one comma 10.  
116:58 - We start the next step, step three, 
which is checking if this is a valid gas.  
117:05 - Okay, so here I'm going to use 
another helper function is valid.  
117:09 - And I'm going to pass in the puzzle, guess, 
row and column because those, those are the  
117:14 - key pieces of information that we need. In 
order to determine whether or not this guess  
117:20 - at this row and column is valid in our puzzle. 
So those are the four parameters that we need.  
117:26 - And here I'm going to define the function 
is valid. And this basically figures out  
117:30 - whether the guess at that row or column of the 
puzzle is valid. And so if there's no conflicts,  
117:38 - then we consider it valid. And then we 
return true. We returned false if it's not.  
117:45 - So now we have to follow Sudoku rules. If our 
guests equals anything that exists in that row,  
117:51 - or the column already, or even the little three by 
three matrix that it's in, then it's not valid. So  
117:58 - let's actually start with the row because that was 
the easy one, right? Every single list within our  
118:02 - puzzle represents a row. So if we have the row 
index, then we can just say that the row values  
118:08 - are equal to the puzzle index at the row. So if 
our guess is in row values, then we can return  
118:14 - false. All right, now the columns, the columns 
are a little bit trickier because we actually vary  
118:21 - which row we're indexing into, but we index at the 
same spot within each row. So what we can do is we  
118:28 - can create a new list called column values. And 
we can say, for each row, I can say for iron rage  
118:36 - nine, so that will go through all the rows, I'm 
going to append the value at puzzle at the I throw  
118:44 - at the call column. And so another way to write 
this actually is using a list comprehension. Ryan  
118:50 - say take puzzle and then index into I and then 
within that row index into call, and then do that  
118:57 - for i in range nine. And then that's essentially 
going to build the exact same list. So then,  
119:05 - if the guess is in those values, then we return 
false because it means that it's in our column.  
119:12 - And then now this little three by three square 
matrix. So this parts a little bit trickier,  
119:17 - because we actually have to figure out where in 
the three by three grid we are. And so to do this,  
119:23 - what we're going to do is we're going to find the 
starting index of the row of that three by three  
119:29 - matrix, and then we're going to find the starting 
column index of that three by three matrix.  
119:35 - And then we're going to say for each row 
for each of the columns within that three,  
119:40 - we're going to iterate. So what we can do in 
order to find this is actually take the row  
119:49 - index and divide it by three, but throw away the 
remainder. What is like, for example, if I have  
119:58 - one divided by three, that comes out 2.333. So the 
base, or whatever you want to call it is zero. And  
120:05 - then five divided by three, well, the remainder 
is two, but three goes into five one time.  
120:09 - So I'm going to return one. So that I can take 
that and I can figure out if it's in the first  
120:14 - set of three rows, the second set of three 
rows, or the third set of three rows. And  
120:19 - then of course, in order to get like the actual 
index of that, I have to multiply that value by  
120:24 - three. And then it's the exact same logic 
for the columns. So when I get row start,  
120:30 - I'm trying to get the start value of these chunks, 
right. But then when I'm getting the column,  
120:35 - I'm getting the start value of these chunks, 
maybe it's the other way around on YouTube.  
120:41 - When I have both of the starts, I can 
say, Hey, now we're going to iterate  
120:45 - through this. So I can say for our end range, 
row, start comma, row start plus three, because  
120:51 - we want to iterate through the three rows for C 
and range call start to call start plus three,  
120:57 - because we want to iterate through three columns, 
if the value of the puzzle equals our guess,  
121:04 - so that means our guess is already in this three 
by three matrix. So we just have to return false.  
121:10 - And now at the very end, if we've passed all these 
checks that we haven't returned false yet, that  
121:15 - means that while it is valid, and we can return 
true. Alright, so let's close those functions.  
121:26 - Okay, now back to our code. So if is valid is 
true, then we want to actually place that guess,  
121:36 - on the puzzle at that row, comma column. So what 
we can do is we can say puzzle index at the row  
121:44 - index at the column is now equal to our guests. 
So we're actually mutating this puzzle array.  
121:53 - So now in step four, we're going 
to recursively call our function.  
121:56 - Because if I guess one number, then that number 
is actually mutated in my list of lists. And I  
122:02 - can pass that in as my puzzle. And then the 
next value becomes mutated, and then so on,  
122:09 - until we reach the very end. So that's 
essentially what we're doing here.  
122:14 - We're just solving this entire thing with this new 
guests in our array. So if that comes out as true,  
122:20 - then we know that we've actually solved 
our Sudoku puzzle so we can return true.  
122:29 - But of course, there's also the case where, 
where this is valid check might not be valid.  
122:35 - And there's also this case of well, what if we 
didn't solve the Sudoku when we pride that guests  
122:42 - in the row and column. So then, in this case, 
we actually need to backtrack, we need to say,  
122:51 - hey, so this guess was wrong. Let's reset it and 
move on to the next guess. So here, I'm going to  
122:57 - say puzzle row call equals negative one, because 
we didn't successfully place anything there.  
123:04 - So we're essentially just resetting the value at 
this row and column. And now you can imagine this  
123:11 - for loop is going to go over, you know, all the 
possible values 123456789 for every single empty  
123:17 - spot along this entire puzzle, right. So that 
means we're literally trying every single possible  
123:23 - combination for the Sudoku. So in our last step, 
if we've tried every single combination possible,  
123:30 - and none of them work, then that means 
that we actually can't find a solution.  
123:35 - So this puzzle is unsolvable. And 
then we're going to return false.  
123:43 - Alright, so let's actually test this to prove that 
it works. Okay. So Python three sudoku.pi, we see  
123:50 - that it comes out as true. And this is our board. 
So let's try resizing this to see if we can like,  
123:57 - actually view this as a board. Okay, 
there we go. Let's do a couple of checks,  
124:00 - just to make sure that like, our solution is 
actually true. So in this first box up here,  
124:06 - let's do 123456789. Alright, and then this column, 
you have 123456789 in this row, 123456789. Okay,  
124:21 - so that's pretty convincing that like, this 
is actually a good solution. Okay, so a couple  
124:27 - of notes about my implementation. recursion is 
confusing recursion kind of makes your brain hurt.  
124:34 - I think it might be better understood this 
way. Think about solve Sudoku as a black box,  
124:40 - it should be able to mutate the input puzzle, 
so that it's a solution if it's a valid input  
124:47 - puzzle. Now, if it's not a valid input puzzle, 
well, then it should be able to identify that  
124:53 - because we've tried every single combination 
for that puzzle. So when we make a new guess  
124:59 - we can pass This new guests as a puzzle into 
our solve Sudoku function. And if it's solvable,  
125:05 - then we know that our guests was the correct 
guests. And we've actually reached a solution.  
125:10 - Now, if it's not solvable, well, then we know that 
that guests that we passed in, it's not a solvable  
125:16 - Sudoku solution. So we can say, okay, that wasn't 
the right guess. So now let's move on to the next  
125:22 - one. And this is how we kind of go through this 
entire puzzle, and mutate the Sudoku array that  
125:28 - we originally passed in to be the correct answer. 
I hope that clears things up for you guys.  
125:37 - This next project is going to deal with editing 
images in Python, I've prepared some starter code,  
125:44 - if you go to this link down below the one that's 
for pi Photoshop, you can click this download  
125:51 - code, you can either download the zip file, or you 
can get clone it if you know how to do that. And  
125:57 - let's take a look at what's in this code. So here 
I've prepared for you a lake and a city image. And  
126:05 - so we're going to actually be editing these images 
and doing like, cool things on those using Python.  
126:13 - So in the png.py file, this is some code 
that Johan Rochelle put together. And I just  
126:23 - copy and pasted this from online. Essentially, 
what it is, is it's a PNG reader and a writer.  
126:30 - And what that means is while the writer is a PNG 
encoder in Python, and then the reader is a PNG  
126:37 - decoder in Python. So it takes a PNG image, and 
it decodes it into like a Python array. And vice  
126:45 - versa. For the writer, it takes a Python array, 
and it writes it to a PNG file. Pretty cool.  
126:52 - Alright, so now in this image class, this is some 
code that I've prepared for you. And we can see in  
126:59 - this initialization, you can either initialize 
it with x pixels, y pixels and num channels.  
127:06 - And that will initialize to an empty array 
of zeros. Or you can import a file and this  
127:11 - image will represent whatever file that you've 
imported. So here we have the input path and  
127:16 - the output path. These are just the folders 
for the inputs and the outputs. And here we  
127:23 - have a checker to see if the user is actually 
passing x pixels, y pixels, and num channels.  
127:30 - So if it has, we assign those values, and then 
we create an empty array essentially, by the way,  
127:36 - number of channels just means like, for example, 
typically, when we work with images, we work with  
127:42 - RGB channels, so that's red, green, and blue. And 
so that's three channels. That's what we're going  
127:48 - to be using today. And then x pixels and y pixels 
will describe the size, the actual physical size  
127:54 - of the image. So here, we're initializing 
these to all zero. And this is going to be  
127:59 - a NumPy array of the size, x pixels, y pixels, 
num channels. So you can think of this command as  
128:06 - kind of just creating a three dimensional matrix 
with dimensions x pixels, y pixels, num channels,  
128:12 - and it's initialized to all zero. That's 
essentially what self dot array is initialized to  
128:17 - when you pass in x pixels, wide pixels and 
num channels. So if there is a file name,  
128:24 - then we actually read that image from this helper 
function, read image and set that to the array.  
128:30 - And then x pixels, y pixels and num channels will 
set to that array dot shape. At the very end,  
128:36 - we're going to add this elf statement. Because if 
the user hasn't passed in X, Y and num channels,  
128:43 - or if they haven't passed in file name, then we're 
actually going to raise a value error saying you  
128:47 - have to input one of those options. Okay, so let's 
go over the read image function. So read image,  
128:54 - you have to pass in a filename. And this gamma, 
you don't have to worry too much about that. It's  
128:59 - just a way to encode and decode it so that your 
operations are not exactly linear. And so here,  
129:06 - I'm using PNG reader, this is from the PNG 
file, and I'm passing in the file name, I'm  
129:11 - going to read it as a float. And then here, we're 
just going to do a bunch of like resizing things.  
129:18 - I mean, I've given you guys these functions for 
a reason. It's because I don't think that they're  
129:22 - critical in understanding how the actual photo 
manipulation works. So then in this right image,  
129:29 - so this function call will write 
whatever this image represents  
129:34 - to a PNG file, and we're clipping it to between 
zero and one. The reason for that is because  
129:42 - when we transform it back into the alpha file, 
we're going to scale everything from zero to 255.  
129:49 - And so we're going to do a little bit of reshaping 
and write it out to the output file using the PNG  
129:56 - writer. And we're going to resize this array 
because we did a little bit of Free shaping,  
130:00 - but we want to keep it in the same representation, 
right, we don't want to actually mutate our  
130:05 - representation of the array. So down here, we're 
just going to do a quick test to see that this,  
130:12 - like import and export works. So we're going 
to call image equals image dot file name. And  
130:19 - let's use the lake. And all we're going to do 
is we're going to right to the output file,  
130:24 - we're going to right image test dot png. And 
what we should see is that test dot png should  
130:29 - be identical to Lake dot png, because we haven't 
manipulated the array at all. So let's try that.  
130:42 - Okay, so test dot png, this is the same image. And 
so where the bulk of our code is going to be is in  
130:51 - this transform.py file, we're going to implement a 
couple of things here, the first thing that we're  
130:57 - going to implement is adjust brightness. 
So how do we adjust the brightness here?  
131:04 - Basically, when we adjust the brightness, we 
want to scale each value of the pixel by some  
131:08 - amount. factor that's a value greater than zero is 
basically how would you want to brighten or darken  
131:14 - the image by if the factor is less than one, then 
we're darkening. And if it's greater than one,  
131:19 - then we're brightening. So first, we have 
to figure out how big exactly this image is,  
131:25 - so that we can iterate through each pixel. And so 
first, we get image dot array dot shape, because  
131:31 - remember that we've stored our values 
in self dot array for that image.  
131:39 - Alright, so basically, we're getting the x y 
pixels, and then we're getting the channels. Okay,  
131:49 - and then basically, we're going to make 
an empty image so that we don't actually  
131:53 - mutate this one that we're passing in. So this 
new image is going to be x pixels equals x pixels,  
132:01 - y pixels equals y pixels. And then num channels 
equals num channels. So it's going to be the exact  
132:09 - same size of the array that we pass in. But now 
we're just going to be mutating this new image,  
132:15 - so that we don't change the original one. This 
is maybe the most intuitive way to do this,  
132:20 - it's non vectorize. If you don't know what that 
means, don't worry about it, I'll show you in a  
132:24 - bit. But essentially, we're going to iterate for 
every single pixel and x pixels for every single  
132:30 - y pixel. And then for every single value of the 
channel. So literally, you can imagine this 3d  
132:36 - matrix and you're iterating through each 
individual value. And then for that value,  
132:43 - well, we have to adjust the brightness 
by some factor. So we're going to say  
132:48 - new image. And we're going to take the array, 
and then we're going to index into whatever  
132:52 - position that we're currently at. So x, y c. So 
at index x, y c, we're going to set this equal  
133:01 - to our original image that array at 
x, y, z, so that corresponding pixel  
133:07 - and then multiply that by the factor that 
the user has input. And then at the very end,  
133:13 - we're just going to return the new image. So let's 
actually try this first, see that it works. Here  
133:20 - at the very bottom, I've provided already a little 
bit of code that tells you, alright, load the lake  
133:26 - and load the city. So let's lighten the lake 
for example. So let's say Brian m equals adjust  
133:35 - brightness lake and then some factor greater 
than one. So let's just do 1.7. And then we're  
133:41 - going to write this image to brightened dot png. 
So let's try that. So Python three transform.pi,  
133:50 - and we get this image that's slightly brighter, 
we can compare this to the lake. If we move  
133:56 - these side by side, you'll notice that 
the brain one is like slightly brighter.  
134:04 - So let's actually try also 
darkening so dark and image equals  
134:08 - adjust brightness. And then let's make the 
factor 0.3. And let's save this as darkened.  
134:20 - And now running that again. Right, we get the 
darkened image here. So we can tell that this  
134:28 - is darkened from our original image. And 
let's compare these side by side again.  
134:36 - Right so the darkened image does look darker.  
134:40 - Okay, so I mentioned earlier that this is a non 
vectorized way to do it. And this is because  
134:47 - this is the most intuitive like this is behind 
the scenes if you are brightening or darkening  
134:52 - something you have to adjust every single 
pixel value and increase or decrease it.  
134:58 - Alright, so one faster way to do it. Is the 
vectorized version. So we said before that these  
135:03 - are NumPy arrays, but the strength of this such 
array is that, okay, it's NumPy. But I've always  
135:10 - read it as not B. But basically, the strength 
of this array is that you can vectorize these  
135:18 - operations. So if you want to add a constant, 
if you want to multiply by some scaling factor,  
135:22 - you can directly just call that array, and then 
times that factor, it's significantly faster than  
135:28 - iterating through using a for loop. And we can 
see that this does the exact same thing if we  
135:33 - just let it run on the darkened image. So let's 
do dark in image two. Let's call the Transform.  
135:41 - Alright, we get this darker image two. And this 
looks the exact same as our darkened image.  
135:50 - Let's move on. Okay, we're going to adjust the 
contrast now. So when we adjust the contrast,  
135:57 - we're going to be doing the same thing where we 
want to create a new image copies so that we can  
136:02 - put new values in without modifying the original 
image. We're going to be repeating this for x,  
136:09 - y, and z thing because even if you can vectorize 
things, I like this way of just showing you guys  
136:16 - what's actually going on. Here, we're going 
to index at x, y, z, that position again in  
136:23 - the array of the new image. So what adjust 
contrast does is it adjust the contrast  
136:29 - by increasing the difference from the user defined 
midpoint by some amount, factor. So essentially,  
136:37 - if your point is above the factor, then you 
take that difference, you scale it by factor,  
136:42 - and then you add back whatever the midpoint was. 
Same thing for the other side. So basically,  
136:46 - what you're doing is given this midpoint, 
you're making the difference from the midpoint  
136:51 - greater. So we're going to take the image 
array, and we're going to take the value at  
136:55 - x comma y comma z, subtract out the midpoint, 
and then scale that by the factor factor.  
137:04 - And then we're going to add the midpoint back in.  
137:09 - Alright, and then of course, we return that 
new image. And just to show you guys what the  
137:13 - vectorized version would look like, it's just new 
image dot array equals the image dot array minus  
137:20 - mid, which is a constant. So it's taking that 
entire array, subtracting this made from every  
137:24 - single value in that array, scaling that entire 
array by factor, and then adding back a constant  
137:32 - mid. So it's literally taking every single item 
in that array and adding the midpoint back in.  
137:41 - Alright, so now let's try adjusting the contrast 
of this like image. So let's do increase contrast  
137:49 - equals adjust contrast Lake two, because remember, 
the the higher the scaling is, the more contrast  
137:56 - we have, right. And let's do the mid points 0.5, 
because we're working on a scale of zero to one  
138:03 - for these images. And now we're going to write the 
image, let's call it increase contrast that PNG.  
138:08 - And I'm going to do the same thing, 
but let's decrease the contrast now.  
138:17 - So I'm just going to do the same 
thing except instead of two,  
138:20 - I'm going to pass in scaling factor 0.5. 
And here, let's just call this decrease  
138:24 - contrast. And we're going to write this to 
decreased contrast dot png. Let's run this.  
138:37 - Okay, so let's compare these. So this is our 
original, and then this is a decreased contrast.  
138:44 - So you can see that it's significantly grayer. 
And this gray just means that the contrast has  
138:50 - decreased. And everything's closer to being the 
same color, which just happens to be great. And  
138:55 - now this is the increased contrast, you can tell 
that like, I mean, the contrast has really been  
139:00 - increased, the colors are a lot more drastic in 
this one, right. Okay, so the next thing that  
139:07 - we're going to implement is a blur for the image. 
So in the blur, we pass in a kernel size. And this  
139:16 - kernel size just means how wide Do you want this 
blur to be? Because essentially, what we're doing  
139:21 - when we're blurring is we're taking that pixel and 
averaging it with its surrounding pixels. And so  
139:27 - if the kernel size is for example three, then that 
just means we're taking a pixel and we're applying  
139:34 - this kernel around it, so it should be taking the 
left and the right neighbors and top and bottom,  
139:41 - the four diagonal corners. For example, a kernel 
size of 15 would take the seven to the left,  
139:47 - the seven to the right, and the seven to the 
top and bottom and everything in that square.  
139:53 - Alright, so once again, we are going to create 
a new image to make a copy to and We're just  
140:01 - going to use a naive implementation of iterating 
through each neighbor and then taking the average  
140:06 - at the end, there is a faster way to do it. But 
this again is more straightforward to understand,  
140:13 - it's more straightforward to figure out what 
we're doing, the faster way to do it would be  
140:17 - to incorporate some sort of, like memorization, 
which means so for example, what we would do is we  
140:24 - would move like along the x axis, and every single 
time instead of resetting every single neighbor,  
140:30 - we just get rid of one column, and then we add 
in the next column, and so on. And that would  
140:34 - decrease the number of operations that we actually 
need. But, again, this is more straightforward. So  
140:40 - we're going to use this way for now. First, we're 
going to create a variable total equals zero. And  
140:45 - this is going to keep track of what the total of 
all the summations of the surrounding pixels are.  
140:52 - And, of course, we need to know how many neighbors 
we actually have to go for. So we're going to find  
140:58 - neighbor range as how many times does to 
go into the kernel. So how many neighbors  
141:04 - to one side do we need to look at 
essentially, is what this represents.  
141:09 - And here, we're going to say, for each exci in 
the range, x minus neighbour range to x plus  
141:19 - neighbor range. And remember that we 
have to add this plus one, because range  
141:26 - goes from the lowest to the highest minus 
one, right? That's just how Python works.  
141:32 - It doesn't include the end of the range. So you 
may think that this is all good to go. But what if  
141:40 - x minus a neighbor range is actually less than 
zero, then it would go out of bounds. So here,  
141:46 - we're going to add a little bit of bounds 
checking. So we're gonna say take the max  
141:50 - of x minus neighbor range, or zero. So for 
example, if x minus a range is negative,  
141:54 - then we would say, okay, no, cut it off at 
zero. And same thing for x plus neighbor range,  
142:00 - we want this to be the minimum of the maximum 
value that we can take, which would be x pixels  
142:06 - minus one. And the reason why we do minus 
one is because x pixels is the length right,  
142:11 - and we have to subtract the one because that's the 
highest possible value that we can actually index  
142:16 - into. Remember that Python, we do zero indexing. 
So then again, we're going to do the same thing  
142:23 - for the Y neighbors. And we're going to 
keep these bounds because they are the same,  
142:27 - but instead of x pixels, we do y pixels. And then 
we do y plus the neighbor range, every single time  
142:33 - we go through a new neighbor, we want to add 
that value from the past an image to our total.  
142:39 - And then at the very end, we can say our new 
image at that specific index is equal to the total  
142:48 - and then divided by the total size of the 
kernel. So how many things did you just sum over,  
142:53 - we have essentially a box of size nine, right 
nine elements in that box. So we have to square  
143:00 - our curl size, and then divide our 
total by that. And so that just gives  
143:05 - us the average value over that pixel at its 
neighbors. And then we return this new image.  
143:12 - Okay, so I'm actually going to run 
this blur on the city because the city,  
143:18 - it has more lines in it, it's 
more obvious if it's blurred.  
143:22 - So let's do a blur with size three, blur 
three equals blur city, comma three,  
143:26 - and then we're going to write image and call it 
blur k three. And now I'm going to do the same  
143:31 - thing with a kernel size of 15. Just so that 
I can show you guys the difference between  
143:35 - using a kernel size three, four blur, and using 
a kernel size 15 for a blur. So let's run that.  
143:48 - Okay, so our blur of three is done. And 
you can see that it looks slightly blurred.  
143:55 - When you compare it to the original, so our 
blur, we know that our blur is doing the job,  
144:01 - and it's still running for the 15. Again, 
this is not the fastest way to do it.  
144:05 - And the higher your kernel sizes, the slower 
the more this is going to make a difference.  
144:10 - It looks like our 15 is now done. Okay, so let's 
open that. And now we see that this is like  
144:18 - noticeably much more blurred than our original. 
And the reason is literally just because we've  
144:24 - taken more pixels into account when we've 
created this average for that one new pixel spot.  
144:34 - Okay, so actually this blur 
that we've implemented above,  
144:38 - we've actually implemented 
applying a kernel to an image.  
144:42 - And so what that means is we're taking a matrix 
and we're applying it to every single pixel, and  
144:47 - summing up whatever values in that matrix times 
whatever value is at the corresponding pixel.  
144:53 - So in this blur above, it's a kernel of size n by 
n. And each value is actually one over n squared.  
145:03 - All right, let's see how we can create a function 
apply kernel. So we can take in any kernel,  
145:09 - and we can apply it to our image. So we're going 
to assume that the kernel is square, first thing  
145:15 - that we're going to do is we are going to, again, 
paste the code that we had above. And here, our  
145:22 - kernel size is slightly different, because we're 
not passing that in. Instead, we have a 2d NumPy  
145:29 - NumPy, 2d NumPy array that represents a kernel 
that will use the kernel size is just one  
145:36 - dimension of the kernel 2d array. So we can just 
say kernel dot shape, zero, we're going to keep  
145:44 - this iteration through the neighbor range. And 
so here, we need to actually find what value of  
145:50 - the kernel corresponds to that pixel that we're 
at. So x k is actually whatever exci we're at,  
145:57 - which is representing you know, x 
minus that neighbor range, right?  
146:01 - So we're actually going to add that neighbor 
range back in and subtract x. And you'll see  
146:06 - that what this does, is essentially, it's 
centered around x y, right? So at x, y,  
146:12 - that would be the center of the entire kernel. But 
now we're trying to shift the zero, for example,  
146:18 - up to the top left corner. So that's, that's that 
those are the operations that we're doing here.  
146:23 - If you draw it out, it makes a lot more sense. 
All right, and then for why we're doing by I,  
146:29 - plus a neighbor range, and then subtracting y from 
it. Okay, so then the value at the kernel would be  
146:39 - Colonel and then index at x k, and YK. And 
we add to our total, this variable total,  
146:47 - we add the image at that index x i y, I see. But 
then we multiply it by the kernel value from our  
146:58 - kernel. And so then the new image, that array 
is x, y, z, and that is equal to whatever the  
147:05 - sum of all of these are. And then of course, 
we're going to return the new image. So let us  
147:20 - so I'm going to, so I'm going to show this 
to you guys, on an edge detection kernel.  
147:25 - It's called the sobelle. kernel. So in the 
x direction, it's going to be this array  
147:32 - 121000, negative one, negative two, negative one, 
and this y kernel will be the same, except there  
147:40 - will be some values or switch. So I can write this 
in a 3d format that's a little bit easier to see.  
147:47 - And so we're applying this over every single 
pixel in our image. And now here's the y's.  
147:55 - Alright, so you see, these are almost the same 
thing, right? Let's apply this kernel to the city.  
148:03 - So let's call that civil x apply kernel city. 
And then so we'll x kernel. And then we're  
148:09 - going to write this to edge x dot png, we're 
going to do the exact same thing for the Y  
148:15 - kernel. And now you'll see why I called 
these x and y. So let's run this.  
148:24 - We go here, and we look at the city on 
one side. And now let's look at this  
148:32 - edge x. So you can see that this edge x 
really like I mean, look at that horizontal  
148:40 - line right there. It's an X edge detection 
filter. And now let's take a look at edge y.  
148:48 - So you can see how this one really highlights 
the Y edges, right, the edges in the y direction.  
148:56 - It would be really cool if we could just put 
these together and create an edge detection  
149:01 - filter. And that's exactly what we're going to do. 
Next, we're going to combine these make an edge  
149:05 - detection filter for our image. So here, we're 
going to combine images, image one and image two.  
149:13 - So one thing here is the size of image one and the 
size of image two have to be the exact same thing,  
149:17 - the arrays have to be the exact same 
dimensions. And we're going to again,  
149:24 - copy this shape and create a new image. And 
we don't need any of that kernel stuff. But  
149:30 - basically what we're going to do is we're going 
to take the value from image one, square it  
149:36 - the value from image to square it, add these two 
together and then take the square root of the sum.  
149:42 - We have x y and C and index at the new image 
is going to be it's going to be whatever is at  
149:50 - that index in image one squared plus whatever 
is at that index and image two squared and then  
149:57 - the entire quantity, square root it So this to 
the power of one half is just square root. And  
150:08 - at the end, we're going to return a new image. 
And up here we are getting an error because this  
150:14 - should actually be a image one or image two, it 
doesn't matter, they should be the same shape,  
150:18 - right? We said that, like when we 
defined the function, let's try it on  
150:24 - sobelle, x and y. So uncomment some of this 
stuff. And at the very end, we're going to do  
150:33 - soble x, y equals combine images, so about 
x, and Sobell y. And so then symbol x y  
150:44 - dot right image, and let's call this edge 
x, y dot png already. So let's run this.  
151:03 - So let's set all of these next to each other. 
So on the bottom right, we have the original  
151:08 - image, then we have the x and the y filters. And 
now check this out. So this is the images combined  
151:16 - the filters combined. And you can see that this 
is a pretty cool edge detection filter. And let me  
151:23 - try to actually like zoom in, make this a bigger 
image. So this is our image. And check that out.  
151:30 - I mean, you see all the edges in the image, 
basically. Pretty cool. Look at that skyline.  
151:39 - And so yeah, using all of these 
techniques, you could literally  
151:43 - implement Photoshop, in Python. Pretty cool.  
151:51 - So the last project I have 
for you guys is what I call  
151:54 - graph composer. And it's kind of like an 
introduction to AI. The idea of graph composer  
152:01 - is derived from a Markov chain. And so in a Markov 
chain, you have a node that represents a value,  
152:07 - and it has an arrow pointing to maybe 
another node that represents another value.  
152:12 - And that one might be pointing to another 
node, which might point back to the first one,  
152:16 - and so on. So you kind of create this entire 
network of nodes and directed edges with weights.  
152:23 - In our graph composer, what we're going to do 
is we're going to take the text file, and we're  
152:27 - going to transform every single word in that text 
file to a node, and then we're going to connect it  
152:33 - to whatever words follow that specific word. So 
here's a little snippet about how these Markov  
152:40 - chain graph models actually work. Given a text, 
I can generate a graph from the text where all  
152:47 - of the words are represented by vertices, and then 
there's a directed edge from each word to the word  
152:53 - that follows in the text. Now the weight of the 
edge would just be the number of times that the  
152:58 - new word follows the word that you just connected 
it to. So let's take an example sentence,  
153:04 - how about I am subscribed to y cubed, and I 
am loving it. so here we can take the letter I  
153:12 - and we can make it a vertex. And now we can 
connect an edge with wait one 2am because an  
153:19 - follows I one time so far, and then subscribed, we 
are connecting subscribe to an with the directed  
153:25 - edge of wait one, two, y cubed. And Okay, so 
now things get a little bit interesting because  
153:33 - after this last, and it goes back to I, we already 
have a vertex representing the word eye on our  
153:39 - graph. And so and is going to connect directly 
to that vertex that's already in the graph,  
153:45 - okay, but then we have another occurrence of I 
Am. So instead of creating another vertex for AM,  
153:51 - we're going to increase the value the 
weight of that edge that's currently  
153:56 - there. So instead of one, we're turning 
that into two, and then we can continue on  
154:02 - so am is already connected to subscribed. But now 
loving also follows AM. So we're going to create a  
154:09 - new vertex for the word loving and assign that 
a new edge with weight one, and then of course  
154:16 - it and now it gets connected to loving. So this 
would be the graph that represents the sentence.  
154:24 - I am subscribed to y cube, and I am loving it. So 
with all the songs of an artist that I've chosen,  
154:31 - I have basically created this like huge graph of 
all the words as vertices and edges connecting  
154:38 - them to the words that follow. Okay, so now in 
order to generate my poetry, I can randomly choose  
154:45 - a starting word by randomly choosing a starting 
vertex, and then I can traverse the graph based  
154:51 - on the edges. So these edges are kind of rules for 
which word you can go to next you can only follow  
154:58 - the arrows So here's an example. What I mean 
by that, let's take the graph that we just saw.  
155:03 - And let's say that our starting word is y. So 
I've got y, there's only one arrow out and to  
155:09 - cube. So my generating is going to be y cubed. And 
because and is the only word that follows cubed.  
155:16 - And then of course, I because is the only thing 
that follows. And, and then Am I right. So y  
155:23 - cubed, and I am well, now we have two arrows 
out of and we have an arrow to subscribe, and  
155:29 - an arrow to loving, we can actually choose either 
of these paths. And in my script, I've left that  
155:36 - up to randomness. So that's where these weights 
come into play these edge weights come into play,  
155:40 - the higher weighted an edge is, the more likely 
that path will get chosen. And this is how I can  
155:46 - generate these sentences all stitched together, 
I'm going to show you guys how to actually  
155:51 - implement this in Python. First thing that we're 
going to do is we're going to go to this code  
155:55 - that I've already prepared for you. What you can 
do here is you can download the code over here,  
156:01 - you can download the zip file, or if you know how 
to get clone. Go ahead and do that. Let's take a  
156:06 - look at what's actually in these files. Here. I 
have two empty files compose up hi and graph.py.  
156:13 - Under songs I have, well I have a bunch of text 
files that represent song lyrics. And we'll get  
156:19 - to those a little bit later. But basically, 
we can generate lyrics using our little Markov  
156:24 - chain model. I also have under texts, this 
Harry Potter Sorcerer's Stone text file,  
156:30 - and so we'll be able to see how we can actually 
generate some text based off of Harry Potter as  
156:35 - well. And in lyrics.py, you guys don't really 
have to worry about this. This is just a scraper  
156:41 - that, you know, you input some songs and then the 
artists name and it'll scrape lyrics genius. For  
156:48 - those lyrics. Basically, it'll download this exe 
and save it in the files that you guys saw before.  
156:54 - So graph.pi and compose up higher fd, because 
while those are the things that I'm going to  
156:58 - show you guys how to implement. Let's start with 
graph.pi. Also, guys, just letting you know that  
157:05 - in this tutorial, I will make mistakes. I wanted 
to show you guys this because I wanted to let you  
157:10 - know that it is very, very normal to have bugs 
in your code. It's very normal to make mistakes.  
157:16 - And the important part is to actually know 
how to fix them. So just keep that in mind  
157:21 - while you're watching this tutorial. Okay, so in 
graph dot pie, this is where we're actually going  
157:27 - to have our Markov chain representation. And, 
you know, we know that in this Markov chain,  
157:32 - we're probably going to need randomness. So let's 
import random right, now, we're going to define  
157:37 - the graph in terms of vertices, naturally, let's 
create a class called vertex. First thing that  
157:42 - we're going to do, we're going to initialize 
it, so define a knit, and we pass in a value.  
157:47 - Now this value is going to represent our word 
from the text here, we can set self dot value  
157:53 - equals value. So whatever the vertex value is, 
that's just going to be the value, that's going  
157:57 - to be the word that it represents. And here, I'm 
going to have a dictionary called adjacent. And  
158:03 - what this adjacent dictionary is going to do, it's 
going to keep track of you know which vertices  
158:09 - are connected to this vertex. And so those are 
going to be our keys. And then the value of that  
158:16 - node is going to be our weight, the weight of the 
edge from our current vertex to the adjacent one,  
158:22 - let's create a function called add edge 
to. And so we have to pass in a vertex,  
158:27 - because we need to know which vertex we're drawing 
the edge to. And let's create a weight of zero,  
158:33 - we can allow the user to manipulate the 
weight, so let's pass in the weight.  
158:37 - But you know, we can set it to zero initially, 
just in case you don't want to pass it anything  
158:41 - right, what we're going to do is we're going 
to put this vertex in the adjacent dictionary,  
158:45 - and the value is again going to be the weight. 
So this is all we have to do. Every single time  
158:51 - we're parsing our text, whenever we see a word, 
go to another word that's already in its adjacent,  
158:58 - what we want to do is we want to increment that 
edge, right? So here, we pass in the vertex. And  
159:05 - then we can say self, adjacent and vertex equals 
self dot adjacent, get vertex, comma zeros. And  
159:13 - so this doc yet is just saying, if this vertex 
is a key that's currently in self dot adjacent,  
159:19 - we're going to get the value of that vertex. 
If it's if it doesn't exist, then we're just  
159:24 - going to default make it zero, and then we add 
one. And so this add edge two is basically adding  
159:32 - an edge to the vertex that we're inputting with 
some weight. Whereas this increment edge, we're  
159:38 - incrementing, the weight of the edge from 
our current vertex to whatever vertex that we  
159:43 - give it. Alright, now that we have a bit of our 
vertex representation, we can put this together  
159:50 - in a graph. So let's create another class called 
graph. And we're going to of course initialize  
159:56 - this and we're just going to initialize this to 
an empty dictionary. Have vertices. And the reason  
160:01 - why we do that is so that whenever we encounter a 
new word, we can look it up in this dictionary and  
160:08 - then get the vertex object from this dictionary. 
So this is going to be a string to vertex mapping.  
160:16 - Alright, so let's define a 
function get vertex values.  
160:21 - And this is basically saying like what are the 
values of all the vertices. In other words,  
160:27 - let's just return all the possible words that we 
have in the graph. So what we can do is we can  
160:32 - return the set of self dot vertices, keys, and 
this is just going to return all the words that  
160:37 - we've encountered so far. And then we can create a 
function to add a vertex into our graph. So like,  
160:44 - for example, whenever we encounter a new word, we 
want to add a vertex. So when we create a vertex,  
160:49 - we of course have to pass in a value, that's going 
to be the word that it represents. We're going to  
160:54 - do self dot vertices value, equal old vertex of 
that value. So we create a new vertex object. And  
161:01 - we're putting it in this string to vertex mapping. 
And of course, we want to define get vertex,  
161:09 - because sometimes we'll just have a word and we 
want to get the vertex object that it represents.  
161:15 - So if we pass in the text, the word value, 
Well, okay, we want to return self dot vertices,  
161:21 - and then whatever is that that value, right, 
because in this dictionary, we're mapping it to  
161:26 - the vertex and returning that object. But what if 
the value isn't actually in the graph. So in that  
161:33 - case, what we want to do is we want to actually 
add it in because if we're asking get vertex of  
161:38 - that value, well, it doesn't hurt to ever add 
it. So if the value is not in self dot vertices,  
161:45 - we're going to add, we're going to 
call self dot add vertex, that value,  
161:50 - we're just going to create 
a new vertex for that value.  
161:54 - And then of course, return it afterwards. And the 
most powerful part of this Markov chain is that  
161:58 - when you're at a node, you can say, Okay, get next 
word, but based on these weight mappings, here,  
162:05 - we can create a function called get next word, 
and pass in the current vertex. And what it's  
162:10 - going to do, it's going to first find whatever 
vertex object corresponds to that current vertex.  
162:18 - So we can say self dot vertices, and 
then the current vertex dot value.  
162:22 - And now let's create a function called Next 
word, under this first text object. And what  
162:27 - we're going to do is we're going to randomly 
select a Next word, but based on weights.  
162:35 - Alright, so if we actually go to look at the 
random documentation, we see that there is this  
162:41 - function called random dot choices where 
you pass in a list, give it some weights,  
162:46 - and it will actually choose randomly, but based on 
the weights, so we're going to use that idea here.  
162:53 - Let's return random dot choices and pass in self. 
Okay, but then how do we know what do we even pass  
163:02 - in? Right? Let's introduce this concept of 
a probability map, we're going to map each  
163:08 - word to its probability, but put them in separate 
lists. Alright, in this function for each vertex,  
163:13 - comma weight, and self dot adjacent dot 
items, remember that self dot adjacent  
163:18 - is a dictionary that has each vertex and 
then maps it to the corresponding weight.  
163:23 - Let's create two new lists to keep track of 
the neighbors, and then the neighbor weights.  
163:30 - And so here, for every single vertex, 
comma weight, what we're going to do is  
163:34 - we're going to append the vertex to self dot 
neighbors. But we're gonna append the weight  
163:41 - to self dot neighbor weights. And so then we 
can easily pass these into random dot choices.  
163:47 - So here, we can do random dot choices, self 
dot neighbors, self dot neighbor weights.  
163:57 - All right, we actually see that random dot choices 
returns a list. So we'll have to index and get  
164:03 - you know, there's it's a list of size one, but 
we still have to get the first item in the list.  
164:08 - So we have to index zero. Now we can get our 
next word. But where are we generating these  
164:14 - probability maps. Under graph, we can create a 
function called generate probability mappings.  
164:22 - That'll get all the probability mappings of 
every single vertex. Here, we're going to say,  
164:27 - for every vertex in self dot vertices dot values. 
Well, what we're going to do is we're going to  
164:34 - call that vertex and we're going to say, Hey, 
get the probability map. And so then as soon  
164:39 - as we call that function, every single vertex 
will be initialized with the probability map.  
164:45 - And that is our graph representation. So now let's 
move over to compose that pie. Let's think about  
164:50 - what we actually need to do here. Well, we need to 
get the words from the text right and we need to  
164:56 - create a graph where the values of the vertices in 
that Graph are those words. And then for X number  
165:03 - of words that's defined by the user, we need to 
get the next word. And then we'll just show those  
165:08 - results to the user. So let's put all of these 
inside a main function. Let's start with step one,  
165:16 - getting the word from the text, we can create a 
function called get word from text, very original,  
165:23 - and pass in the path to whatever text that we're 
trying to get the words from, we can use this  
165:28 - command with open text path, comm R. R stands for 
read as F. Well, we can read everything in that  
165:38 - text, if we call F dot read and assign that to a 
variable text. So this is going to be a string.  
165:44 - And now what we want to do is we kind of 
want to split across all the whitespace  
165:49 - and then join it with one single whitespace. 
So what this is going to do is like,  
165:53 - if there's like multiple lines, like, you 
know, indents, whatever, it just creates, like,  
166:00 - it gets rid of all those and 
replaces it with the single space.  
166:05 - So text, that split is going to split all of that,  
166:08 - you know, whitespace, whatever it is, tabs, 
spaces, enters and replace it with a space.  
166:18 - So for example, text that looks like this would 
become text that looks like this with only spaces.  
166:28 - Right? And then what we're going to do 
is we're going to lowercase everything,  
166:32 - because it's easier to compare everything 
when it's lowercase. And then now,  
166:37 - let's not try to deal with punctuation because 
stuff can get a little bit complex, right?  
166:41 - There are cases where you might want to add 
a period, but it's not actually the end of  
166:46 - the sentence might be an abbreviation. Like, for 
example, Mr. Brightside, but Mr is not actually  
166:54 - the end of the sentence. So what we're going to 
do here is we're just going to remove all the  
166:59 - punctuation. And we can do that by calling string 
dot make trans that's make translation string,  
167:06 - we can import string, that's the Python package, 
string dot punctuation is just going to be you  
167:10 - know, any of the punctuation that you can see in a 
string. And what we're going to do is replace that  
167:15 - with empty strings. So here's something like, 
Hello, it's me might become Hello, it's me.  
167:24 - And then, of course, we want to split all 
the words. And we're going to do that by just  
167:30 - splitting on spaces again. So we can call text dot 
split, then we're just going to return the list of  
167:36 - words. So return words. So under step one, we can 
say words equals, get words from text, and then  
167:44 - pass in the path to for example, let's use Harry 
Potter. So text slash HP Sorcerer's Stone, that's  
167:50 - the name of the text file dot txt. That's step one 
right there. Now the next thing we want to do is  
167:57 - make a graph using those words. So let's define 
a function, make graph and pass in the words.  
168:03 - Here, we have to import the graph and 
the vertex from this graph.pi file.  
168:07 - So up here from graph, import graph, comma vertex, 
and then G, let's assign this to a new graph.  
168:16 - And for each word, in words, we're going to check 
that the word is in the graph. And if it's not,  
168:24 - then we add it. And so when we're going through 
this word list, if we come across a new word,  
168:29 - then we want to check the previous word, if it 
exists, which it should unless you're like the  
168:34 - very first word in the full paragraph. So if 
there was a previous word, then we add an edge  
168:39 - if it didn't already exist in the graph. 
Otherwise, we increment the weight of the  
168:44 - existing edge by one. And then we set our 
word to the previous word, and we iterate.  
168:56 - So now remember that like, in order to get 
the next word, we have to set the probability  
169:00 - mappings. And so this is a great place to do 
it right before we return the graph object  
169:06 - in our make graph function. So let's start 
in this implementation. For word in words,  
169:12 - we're going to check that the word is in the 
graph. And if not, then we're going to add it.  
169:19 - So let's drag graph.pi over here, so 
we can look at both simultaneously.  
169:27 - Okay, so you'll see that in get vertex, we 
actually add the vertex already. So all we  
169:32 - need to do is we can say word vertex equals graph 
dot get vertex and then that word, if there was a  
169:40 - previous word, then we add an edge if it doesn't 
exist in the graph, otherwise, increment the  
169:45 - weight by one. So here let's actually create 
a previous word variable and assign it to non  
169:50 - because at the very beginning, there is a previous 
word. Here we're going to check the previous word  
169:56 - then previous word dot increment edge, word. 
vertex, right, because what this is going to do,  
170:02 - it's going to increment that edge between 
the previous word and the word vertex by one.  
170:10 - And here the increment edge already does 
that for you. Because we've implemented  
170:14 - that in our vertex already. Now here, all 
we have to do a set previous word equal to  
170:20 - whatever this word is. So that in our next 
iteration, we have access to the previous word.  
170:25 - And we keep doing that for all words. And at the 
very end, we can say g dot generate probability  
170:30 - mappings generate all the probability mappings 
and then return that graph. Alright, so step two,  
170:39 - G equals make graph. And then we pass in the 
words that we got from get words from text.  
170:45 - Now step three, we want to get the next word 
for X number of words as defined by the user.  
170:52 - Let's create a function compose, given a 
graph and given the words and some length,  
170:59 - let's just say 50. For now, we're going to 
create a composition. And this is at first  
171:04 - going to be an empty list every single time that 
we generate a new word, we're just going to put  
171:09 - it into this list composition. And what we can 
say is that we'll look we have the words list,  
171:15 - let's just get some random word from this words 
list. And, you know, grab that vertex from G. And  
171:21 - this is where we're starting. So for however 
many iterations in the length that the user  
171:28 - has defined, we're just going to iterate and 
we're going to keep getting the next word right  
171:32 - here, we can say composition dot append, and 
then this word, which is the word vertex,  
171:39 - we're going to append the value of that vertex, 
because remember, we can't actually append  
171:43 - the vertex and have that legible, we have to 
append what word that vertex corresponds to.  
171:48 - And then now our next word is going to be g 
dot get next word, given the current word.  
171:56 - So here, we can say word 
equals g dot get next word,  
171:59 - and word. And what we're going to do is replace 
this word variable and keep getting the next one.  
172:04 - At the very end, we're just 
going to return our composition.  
172:10 - Right. Now down here in our main function, 
again, we can say our composition equals compose,  
172:16 - we can pass in G, we can pass in words. And 
then we can pass in some parameter length  
172:22 - override that we can say 100. for the heck 
of it, we don't want to just return a list,  
172:27 - let's actually return a string. So we can join 
this list of words by a space. And so this is  
172:33 - going to return a string where all the words 
and composition are just separated by a space.  
172:39 - So now let's run this function and generate.  
172:45 - Okay, and because we're returning this 
competition, we're not printing it.  
172:48 - Let's print whatever Maine returns. And 
that's how we're going to see our composition.  
172:58 - Alrighty, so first, we can try running. And look 
at that random is not defined. I forgot to define  
173:04 - that. So I go back up here, and I'm going to 
import random. Save that and run it again.  
173:14 - Alright, so now, none type has no attribute 
value. So this means that this word, dot value,  
173:24 - word is somehow none. So how in the world do we 
fix that? To let's go back into our graph code.  
173:33 - And take a look at what's going on. It could 
be g doc at vertex or G dot get next word,  
173:38 - one of those is probably returning 
none. So let's open graph.pi.  
173:47 - And if we look at, get next word, okay, here, 
we're calling Next word, but Oh, look, we're  
173:53 - never actually returning a value. And so that's 
our bug. Let's add a return statement there.  
173:59 - And let's try running this again. And there we 
go. It worked. Let's read this. This is built  
174:07 - off of our Harry Potter text. Do you are 
some interesting so unfair that strangers?  
174:15 - They were going to let her to squeeze 
him? I want to look at it had one who  
174:22 - has always Maroon tailcoats orange eyes away. 
Just hope of his last look back to her. Anyone  
174:30 - else is very well, no answer. Professor Clairol 
had been a bundle of white a Clearfield Harry Ron.  
174:43 - Alright, so this is kind of cool. But clearly 
this, you know, it's some gibberish. And the  
174:50 - reason for that is just because our implementation 
of simply a Markov chain is not very intelligent,  
174:57 - right? We're kind of just randomly choosing given 
this word Pick a next word. One way that we could  
175:03 - make it better and more slightly like English, 
is instead of saying like, hate this word,  
175:09 - maybe choose like the previous like three words, 
right and then pick the next word based off of the  
175:15 - previous three words, and so on just so that it 
has some sort of memory, so it doesn't jump around  
175:20 - as much. But now, maybe you're interested in Can 
we do this with the songs that I have in here,  
175:27 - and I'm going to show you exactly how to 
implement that. We can edit a couple of things,  
175:32 - but keep most of the logic the same. If we go 
into like one, I'm Billy Eilish song, for example,  
175:38 - you'll see that we have this like chorus verse 
thing in brackets. And that's obviously not like  
175:44 - part of the song. So we're going to remove like 
the bracket and the text inside of it. We can  
175:52 - do that with a regex again. So what we're going 
to do is we're going to say, hey, substitute,  
175:59 - and then this funky expression, which I'm going 
to explain just a bit, but substitute that with  
176:06 - a space anywhere in the text, it's saying this 
is a left bracket, this is a right bracket,  
176:11 - and here, this dot plus, so the dot means any 
character, and plus means one or more. So this  
176:18 - means if there's one or more characters inside 
the brackets, then replace any version of that  
176:23 - with the space in the text. And so here, 
in order to use this, we have to import  
176:28 - our UI. And let's reformat some of this stuff, 
okay. And so the rest of this should be the same,  
176:35 - because we still want to get rid of whitespace, 
we still want to get rid of punctuation.  
176:39 - But instead of just, you know, one file name, 
we actually have multiple, right in this folder.  
176:47 - And one way that we can like just have Python 
read that folder, rather than having to type out  
176:52 - every single file name. If we import LS, and we 
go down here, we can actually walk through this  
177:01 - folder and find all the file names within 
that folder. So let's do that right here.  
177:09 - Okay, so for song file, in here, we're going to 
use Oh s dot list, Dir. So that's list directory,  
177:19 - songs, and then we're gonna pass in an artist 
name. Okay, so here, we're gonna use f string,  
177:26 - passing the artist. And then in Maine, 
we're gonna pass in the artist. So what  
177:32 - this is going to do is, if you pass in this artist 
name to align with that file name, for example,  
177:38 - Billy underscore Eilish, then, we're going to 
list every single file that's under that folder.  
177:45 - And here, you know, for Green Day, you have 
all these for Linkin Park, you have all these,  
177:52 - and so on. Alright, so after I get all the song 
files, I can now call get word from text and pass  
177:59 - in this path songs, dash artists dash, 
and then whatever the song file is.  
178:07 - So here, I'm going to put that in here song file.  
178:11 - So this is just going to get every single 
song file and like, go through and get the  
178:16 - words from that. And up here, I'm going 
to define words equals an empty list.  
178:25 - And then every single time we get a song's 
words, we're just going to add that to the words  
178:30 - list. So we can extend by whatever 
song words is. And so now down here,  
178:37 - we want to input the artist. So let's 
input Taylor Swift. Let's try running this.  
178:45 - Okay, so we're getting an error. And usually I 
would just Google this error. Honestly, this isn't  
178:50 - one that I'm super familiar with. Let's actually 
print what the song files are. So we can figure  
178:55 - out which one it failed at. And so here, if we run 
this, we actually see that it failed at this file  
179:01 - called dot d s store. And so this is just some 
cash that's stored under this directory. It's not  
179:07 - actually a song file itself. And so we can just 
say, like, if this equals dot d s store, then  
179:14 - continue because we're just going to keep going 
the loop. And so if we run composer.pi again,  
179:20 - look, there's our Taylor Swift masterpiece. 
I remember thinking, are we in red, because  
179:26 - they're you breathless, huh? Or it's time you need 
to calm down. You're sorry for it used to hit you,  
179:34 - again, even if it's such a chance to paper 
airplanes flying flying, and I've never  
179:39 - looked back together, who, etc. Again, this 
is kind of gibberish. We could make it more  
179:48 - intelligent. But for now, as a beginner project, 
this is pretty cool. you're generating paragraphs  
179:54 - based off of some vocabulary that you're 
inputting through songs. or Harry Potter, etc.  
180:03 - If you enjoy this video be sure to subscribe to 
my channel follow me on instagram and twitter  
180:09 - at Kylie y Yang if you guys are interested in 
live coding sessions, where you know they're not  
180:15 - pre planned like these tutorials, you should 
definitely follow me on Twitch. Kylie Yang.  
180:21 - Alright, hope to see you guys around. I hope you 
guys enjoyed my videos. And yeah see you later