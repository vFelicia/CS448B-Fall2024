00:16 - SPEAKER 1: All right,
welcome to GD 50, lecture 7.
00:19 - This week we'll be talking about one
of my favorite franchises of all time,
00:22 - a core part of my childhood--
00:24 - Pokemon as shown by the Poke
Ball on the screen there.
00:27 - So back in 1997 I think
it was, the first Pokemon
00:32 - game was released, Red and Blue.
00:34 - I believe it was released a
year earlier in Japan where it
00:36 - was released as Red, Blue, and Green.
00:39 - And the overall goal of the
game was fairly straightforward.
00:42 - You were a Pokemon trainer.
00:43 - Your goal was to go out into
the world and try and capture
00:47 - any number of 151 different
types of these creatures called
00:51 - Pokemon that were based on a whole
bunch of different types of creatures.
00:56 - Shown in the screenshot here, there's
a Weepinbell fighting and Geodude.
01:00 - A Geodude was a rock type,
Weepinbeel was a grass type.
01:03 - You had different types of Pokemon.
01:05 - When they fight each other, some
types were better than other types,
01:08 - like this sort of very large rock,
paper, scissors relationship.
01:12 - And it was just a very
addicting formula.
01:14 - You'd have a team of these creatures
that you had caught and raised
01:17 - and battled, and you'd
fight other trainers.
01:20 - And the awesome part of
this was you could go
01:23 - and you could actually
fight your friends,
01:25 - or trade Pokemon with your
friends that they had caught.
01:28 - And you would often share
stories back and forth
01:30 - about the different rare creatures
that you would have encountered,
01:32 - and all sorts of things.
01:34 - You'd have a customized party
that was sort of a part of you.
01:37 - And so this is Pokemon Red.
01:38 - The series has evolved over time.
01:40 - This is a screenshot of Gold and Silver,
which was released a couple of years
01:43 - afterwards for the Gameboy Color.
01:45 - Again, this was released
for the regular Gameboy.
01:48 - Gold and Silver introduced a bunch
of new features including breeding,
01:51 - and a day, night cycle,
and a lot of other things
01:53 - that became part of the core series.
01:55 - Here is Ruby and Sapphire, which
was for the Gameboy Advance
01:58 - and got a significant graphical
update, but the core formula
02:01 - stayed much the same.
02:03 - Here is Diamond and Pearl,
which is for the DS, which
02:08 - it made use of two screens, as
seen on the top and bottom there.
02:11 - Here is Black and White,
which was another step forward
02:14 - in that it introduced three dimensional
graphics for the over world,
02:18 - so you could actually see some sort of
3D for the first time in the franchise.
02:21 - And then more recently, we've seen
for the 3DS, games like X and Y,
02:26 - which is shown here, and
Omega Sapphire, Alpha Ruby--
02:29 - Alpha Sapphire and Omega
Ruby, and Moon and Sun.
02:33 - And so this is a great
illustration of why
02:37 - the RPG genre of video
games, role playing game,
02:41 - even though it's sort of its
own unique take on the formula.
02:44 - But it allows us to, we can sort
of dissect this and take a look
02:47 - at what makes an RPG and what
makes a Pokemon game altogether
02:51 - for a nice cool demonstration.
02:52 - So today, we'll be talking
about a few new things.
02:54 - We'll be doing things a lot
differently in this lecture example
02:58 - relative to other examples, because
we're transitioning away from the state
03:03 - machine and talking about a construct
called the state stack, which
03:07 - is effectively a more advanced
version of the state machine.
03:10 - Whereas before, we had a state machine
that was in one state at a time,
03:15 - whereby we could be in the play
state or the start state or what
03:19 - not, we can now actually
have multiple states
03:22 - that exist in parallel that are on a
stack of data structure, which you've
03:25 - seen in CS 50 if you've
taken, where we can have,
03:29 - for example, the field state, the
play state at the very bottom,
03:32 - which is always there, and then
we can push states onto the stack
03:36 - as we need to for
example, a dialog state
03:39 - so that we can actually
display some dialog,
03:41 - some text to the screen without
getting rid of the play state
03:44 - that we had there before.
03:46 - It allows us to render multiple
things at the same time,
03:50 - and then also return
back to prior states,
03:52 - rather than completely
create new states every time
03:55 - we want to make a transition.
03:57 - We'll be talking about
turn based systems.
03:58 - So an RPGs like Pokemon
and others, there
04:02 - are often battle
systems that are usually
04:06 - turn based in this particular genre
where you're fighting-- you have
04:09 - one team or one character fighting
against against one other team or one
04:11 - other character, and you take
turns fighting each other.
04:13 - And you have an indefinite amount
of time to make your decision
04:16 - and then form some sort
of strategy as to how
04:18 - you want to approach the problem.
04:20 - We'll be taking a look at a very
primitive turn based system,
04:23 - but a fully functional one today.
04:26 - Another huge aspect of this genre
is graphical user interfaces or GUIs
04:32 - as they're shortened.
04:33 - Things like panels, and scroll
bars, and text boxes, and menus, all
04:37 - sorts of these things that allow us
to get a more visual sort of look
04:42 - at our data, and allow us to navigate
a much more complex game ecosystem more
04:46 - efficiently.
04:47 - And to tie it all together,
RPG mechanics at large,
04:50 - we'll be looking at things
like leveling up and experience
04:53 - and how to calculate the damage that
one party does to the other party
04:57 - throughout the course of a battle.
04:59 - And so it will be a fairly
complicated set of examples,
05:04 - but fairly illustrative
of the genre as a whole.
05:08 - So I'd like to demonstrate sort of
the example that I put together.
05:11 - If I could get a volunteer from the
audience to come up and take a look.
05:15 - Tony that'd be awesome,
thank you so much.
05:18 - So this is my simple but fully featured,
more or less, demonstration of Pokemon.
05:23 - So if you want to enter or return.
05:27 - So this is a--
05:29 - so here we have a--
05:30 - we can see right off the bat, we
have a text box and a play state
05:35 - like we did before.
05:36 - So this text box is actually a state
that's layered above the place.
05:41 - So you can see it has some instructions
about, if you want to press P,
05:43 - you can heal your Pokemon.
05:45 - You can press Enter to dismiss.
05:46 - So if you go ahead and
press Enter, you'll
05:47 - be able to actually move around now.
05:49 - And so something to note is
before, input was actually
05:52 - halted while the dialogue was on the
top of the screen for the play state.
05:57 - You're actually not allowed to
access or update this bottom state,
06:01 - because the state stack is only
allowing input to the top state.
06:05 - And so I have limited the
play here just to this box,
06:09 - but if we walk in the tall
grass down here, in Pokemon,
06:13 - in order to actually
initiate an encounter
06:15 - with another Pokemon or another
wild Pokemon, you walk in the grass.
06:19 - So here we've walked in the grass.
06:20 - There's a random chance for this
to happen, there's a 1 in 10 chance
06:25 - basically.
06:26 - So it's saying that a
wild Bamboon appeared.
06:28 - So a wild creature appeared.
06:29 - He's level 5, we're level 5,
should be a fairly even battle.
06:32 - So you can press Enter,
and it will say go
06:34 - the name of your Pokemon, which
is an Aardart in this case,
06:37 - and it's randomly
allocated at the moment.
06:39 - So go ahead and press
Enter one more time.
06:41 - Now we can see on the bottom
right, we have a menu.
06:43 - So we can fight or we can
run, so those two choices.
06:46 - So we can go ahead and fight.
06:47 - So we fight, whichever
Pokemon has the higher
06:49 - speed will go first and do damage.
06:51 - We obviously, do a lot more damage,
but he's a little bit faster,
06:55 - so he's going to go first.
06:56 - So we fight one more time.
07:00 - We should be able to knock him out.
07:03 - So as soon as we do, we get a victory
message, we get a victory song.
07:06 - If we press Enter, we'll
actually get some experience
07:08 - for defeating that enemy.
07:10 - So we've got quite a bit of
experience, we got 65 XP.
07:12 - In that bottom bar, we can see
we have all these GUI elements,
07:15 - we've got a panel here, we have
text boxes, we have progress bars,
07:19 - all these pieces are coming together to
give us sort of this turn based system.
07:24 - And so after this, we may
level up just to demonstrate
07:27 - leveling, which is part of the
RPG mechanic side of this game.
07:31 - So we have to press this one more time.
07:34 - We did, perfectly.
07:35 - So they leveled up.
07:36 - And so now we're level 6, so we can see
the 6 changed above our progress bars.
07:44 - So now will be a little
bit stronger every time.
07:46 - And the stats aren't shown here, it's
actually a part of the assignment
07:49 - is to create a menu that will
actually show you how you leveled up,
07:52 - what stats actually increased.
07:54 - But underneath the
hood, behind the scenes,
07:57 - you actually are getting stat increases.
07:59 - And so here we can see that if we
our HP goes all the way down to zero,
08:03 - we faint.
08:04 - And when we faint, the screen
instead of fading to white
08:06 - will actually fade to black
to illustrate the difference
08:09 - between the two transitions.
08:11 - And so that we can keep
playing indefinitely,
08:13 - the game will restore your
Pokemon back to full health.
08:16 - And so this will go on forever.
08:18 - This is effectively what
the simulator is, it's just
08:20 - a simple series of infinite battles.
08:22 - There are random Pokemon in the grass.
08:24 - There's five total that you can fight.
08:27 - But all the core pieces of
what make the game are here.
08:30 - So actually, let's
illustrate running too
08:31 - if you wouldn't mind, just so that
we can see if there is a difference.
08:34 - So we can actually flee, and then
battle we'll get cut short there.
08:37 - We won't get any XP, we
won't faint, but we still
08:39 - get taken back to the play state.
08:41 - So that's all for the Pokemon demo.
08:43 - Thanks so much Tony for
coming up to demo it.
08:45 - Well, there's a lot of pieces
involved here, but as we will see,
08:53 - once we have a lot of these sort
of foundational pieces implemented,
08:56 - it's not too difficult to start
layering more and more of these
09:00 - onto the game to make it even more rich.
09:02 - In fact, the assignment is to--
09:05 - and we'll see this at the end,
I'll recap this at the end--
09:08 - but the assignments goal is
for you to implement a menu--
09:12 - similar to the menu that we saw
where fight and run were shown--
09:16 - that will show you what your current
stat is for each of your stats,
09:19 - there's attack, defense,
speed, and your HP.
09:22 - It will show you what your stat
is before leveling, the amount
09:25 - that it will increase by,
and then the final amount,
09:28 - which is sort of similar to how
the actual Pokemon games work,
09:31 - so you can see rather than just seeing,
oh I increased my level from 5 to 6,
09:35 - 6 to 7, you can see, oh, my
strength increased from 12 to 14.
09:38 - I'm a little bit stronger, I'm going
to do more damage on the next play
09:41 - through.
09:43 - So our goal here, we're going to take
a look at the field state, the play
09:47 - state, and the battle state.
09:49 - And there's a common dichotomy
in most of these sorts of games,
09:53 - be it Final Fantasy, or
Dragon Quest, or Pokemon
09:55 - where there is a field,
where you are walking around,
09:58 - you're character interacting with a game
world with NPCs, going through towns,
10:02 - and what have you.
10:03 - And then a battle mode,
sort of a battle state
10:05 - where you're actually fighting
against some sort of enemy,
10:08 - or a series of enemies, a
party or a single creature.
10:11 - And so we've implemented simple
versions of both of these to illustrate
10:14 - and also the transitions between them.
10:17 - Before we start, I want to
make another sort of plug
10:21 - for this howtomakeanrpg.com, this book,
I actually learned a lot from this
10:26 - and about using LUA in the
context of game development.
10:28 - And I pitched this I think in
one of the earlier lectures,
10:30 - but if you want a deeper dive
into a lot of these constructs,
10:34 - and to sort of get a sense for how you
might do something like cut scenes,
10:38 - or more complicated battle
layouts, and a lot more like--
10:42 - it goes into a lot of detail
about a lot of awesome things,
10:44 - definitely check it out.
10:45 - It's not free, but if you're
interested in this genre, which I am,
10:49 - it's definitely worthwhile.
10:50 - Here's what the sprite sheets
look like that we'll be
10:53 - using for this sort of demonstration.
10:55 - The Pokemon aside, which
are individual textures.
10:58 - Here we're using a simple
sprite sheet, which
11:00 - just has a bunch of tiles,
most of which we did not use.
11:03 - Note that the bush, the tall grass
is not on any sort of background.
11:08 - And therefore, we need
to layer, basically
11:13 - have two separate tile maps as opposed
to one, which we didn't do last time.
11:17 - And we were reusing the sprite sheet
that we used in the Zelda lecture.
11:22 - Before, we used it for all the
enemies, the skeletons, ghosts,
11:24 - and slimes, et cetera.
11:26 - But now we're actually using it
for the PCs that it contains.
11:28 - Specifically, just the male NPC
here, which is our main character.
11:34 - The foundational class that
we're using in this lecture
11:37 - that sort of everything else
revolves around and makes this work
11:42 - is the state stack.
11:44 - And so before, what we had
was a state machine, right,
11:49 - where we were in one state at a time.
11:51 - So you can almost think of
it like, we have a box here,
11:55 - and it just has one socket.
11:57 - And then we're always
looking at this one socket,
11:59 - whether it's the play
state, or the battle state,
12:02 - or a transition of some kind.
12:05 - And now we're transitioning
into the idea of, instead,
12:08 - of just one state that we can only
see at once, we'll make it a stack.
12:14 - And so what we can do with this
is, rather than just having one,
12:18 - we can therefore render multiple
states at a time, right?
12:22 - So let's say this is like the
field, right, or the play state.
12:27 - And then maybe this is like a
dialogue, or something, right?
12:31 - Like we saw before in the
field, we had a text box.
12:34 - We can actually layer
things on top of each other.
12:37 - And then maybe this is like a
fade out, right, or a fade in.
12:42 - So we start with the play state
maybe, and we're walking around,
12:45 - and we interact with in NPC.
12:47 - Rather than transition the
play state to a dialog state,
12:50 - which would, in our previous model,
completely eliminate the play state,
12:55 - because there's only one state
that could be active at a time.
12:58 - Now we just render, however many
states we have in our stack,
13:02 - we just render them sequentially based
on the order that they were popped in.
13:05 - We would rendered this first, we
basically render from the bottom up.
13:09 - Render the play state, then
the dialogue, then the fade in.
13:12 - And this will have the effect of doing
a whole bunch of different things, which
13:15 - we'll see in the distro.
13:17 - But we only really ever need
to update one state at a time,
13:21 - right, because if we have the play
state active and the dialog state active
13:26 - and the fade in state active,
in this order, as a stack,
13:29 - right, we were pushing the operation
for pushing for getting something
13:33 - onto the stack is called
a push, and getting it off
13:36 - is called a pop if unfamiliar.
13:38 - If we're pushing all of these
states on, then usually,
13:41 - we only need to update
whatever's on top, right?
13:44 - If there's no fade in
for example, and we only
13:46 - have a dialog state active,
or a dialogue and a place
13:49 - state in that order top
to bottom, then we usually
13:53 - don't want him update what's
going on in the play state.
13:55 - We're only concerned with the
dialogue that's taking place.
13:58 - We only want that to take input.
14:00 - And when we press Spacebar,
Enter, or whatever
14:02 - button clears that dialog
state, we pop it off, right,
14:06 - and then we're back to the play state.
14:08 - Then we're just updating the play state.
14:10 - And so being able to update
just what's on top while
14:14 - being able to render
everything that's on bottom.
14:16 - And this doesn't hold true
for all game formulas,
14:18 - there's certainly some games where you
can have a dialogue and a play state
14:22 - both get updated, but that's still
using a state stack of sorts,
14:28 - you're just then updating
things in a top down way.
14:31 - But this allows us to do all
kinds of things like transitions,
14:35 - and preserving-- like for example,
the fact that we have a play state
14:38 - and we can pop a battle
state on top of that,
14:40 - where we don't see the
play state underneath it,
14:43 - we only see the battle state,
and that's all updating.
14:45 - But it is we pop the
battle state off, we're
14:47 - right back where we just
were in the play state.
14:49 - It's preserved its state, for lack
of a better word, from before.
14:53 - And this is something that this
model affords us comfortably.
14:58 - And so that's sort of the
foundational class that's
15:01 - implemented in this
distro, which will allow
15:03 - us to do all kinds of awesome things.
15:06 - So let's go ahead and take a
look at what that looks like.
15:09 - I have state stack open here.
15:11 - So state stack has just
a set of states here.
15:18 - And then whenever we
want to insert a state,
15:20 - it's going to be at the
end of the state stack.
15:23 - So it's going to be whatever the last--
15:25 - so if we're looking at it as
a series of states in a table,
15:28 - it'll be whatever the last
index is in the table.
15:31 - That will be our, the top of our stack.
15:35 - And you can implement this either
way in reverse if you wanted to.
15:38 - It's just easier, because you can just
do a simple table.remove to get rid
15:44 - of the--
15:48 - table.remove on that table
to get rid of the last state
15:52 - without having to shift back everything.
15:54 - So if we did it starting at index one,
you'd have to shift everything back.
15:57 - And it would also be a little bit
weird, because you would start at one,
16:00 - and then things would go left.
16:03 - But basically, in order to
update whatever our end state is,
16:07 - we just do at #self.states, which will
be however large our state stack is,
16:13 - we just call update on that state.
16:16 - And then process AI is here,
although we're not using it.
16:19 - But if you had AI, it
would be the same thing
16:21 - as basically an update for artificial
intelligence for your state.
16:26 - Rather than rendering
just one state at a time,
16:29 - we iterate through
all of our states here
16:32 - using ipairs, which will
iterate through them numerically
16:35 - starting at one going to the end.
16:38 - So we call for istate, and
ipairs of self.state, render it,
16:41 - so that will render everything
back to front, or bottom to top,
16:47 - and allow us to get
this layered look where
16:49 - we have a play state going
on underneath for example,
16:51 - and then a dialogue on top.
16:54 - Or we have a battle state
going at the very top,
16:56 - and maybe that battle state
itself pushes a dialogue
16:59 - state to the top of the stack,
or a bunch of other states,
17:02 - a transition, whatever you would like.
17:05 - To clear it, we just reset
the table to an empty table.
17:08 - To push a state, we just do an
insert on that state, and then
17:12 - we call enter on that state.
17:14 - As we did before, sort of similarly with
state machine, when we changed a state,
17:19 - we would call enter on it
and exit, but now we're
17:21 - just calling enter when we push.
17:23 - And then to pop, all we do
is call exit on whatever
17:26 - the last state is in our
state stack, and then just
17:30 - call table.remove on self.states.
17:32 - And by default, when you call
table.remove on a table, just a table
17:36 - with no other arguments,
it'll remove whatever
17:40 - the last index is of that table.
17:43 - Does that makes sense?
17:44 - Anybody have any questions as
to how the state stack works?
17:49 - All right, awesome.
17:51 - So let's take a look
then at the start state.
17:56 - So this is the start date.
18:03 - Fairly simple, we just have
a couple of text labels,
18:06 - and then we have just a randomly
assigned sprite going left to right.
18:10 - How do we think we're
achieving the movement?
18:14 - Yep, timer.tween, and
then we're just drawing
18:17 - an ellipse, right, pretty simple.
18:19 - And then when we press
Enter, note the transition.
18:24 - Notice that there's a fade to
white, and then fade to transparent.
18:31 - And so if we recall from when we looked
at match three, how do we do this,
18:34 - do we remember?
18:36 - AUDIENCE: [INAUDIBLE]
18:42 - SPEAKER 1: Exactly, and the
rectangle was stored where?
18:50 - Sorry, to repeat for the
camera, we had a rectangle
18:52 - that filled the entire screen, and we
just tween the transparency for it,
18:56 - which is true.
18:57 - The rectangle there
before though was stored
19:01 - in whatever state was active at the
time, which was like the start date,
19:04 - or the I think begin
game state was the name.
19:08 - The actual state that wasn't
necessarily relevant at the transition.
19:13 - But using a state stack, we can
actually decouple this idea.
19:18 - We can take the concept of a
transition, and because imagine
19:21 - if we wanted to make a transition
between every single state
19:24 - that existed in our game, right?
19:25 - If we wanted to transition
from the battle to the field,
19:28 - or the field to the battle, or whatever
else we might want, like the start
19:33 - to the field, we would need a
rectangle in every single one
19:36 - of those that has an opacity
that we're keeping track of.
19:39 - And that's not necessarily germane
to the purpose of that state, right?
19:44 - So because we now have a
state stack, we can actually
19:47 - abstract out this idea of a transition,
and turn it into its own state.
19:52 - We can have a transition state.
19:56 - And recall that since we're
just layering everything
19:59 - [? off ?] all these states, and
we're rendering them sequentially,
20:03 - having a state that possesses it's
own for example, opacity rectangle,
20:07 - we can just layer that, push that
onto the stack, and render that,
20:12 - and it'll give us the illusion
of having this transition.
20:16 - But we don't need to actually
have it be part of the state
20:19 - that we're trying to
transition out of and into.
20:21 - Does that make sense?
20:23 - So let's take a look,
for example, at the--
20:27 - let's take a look at
the start state first,
20:29 - just so we can see where that
actually gets kicked off.
20:32 - So the start state, we kick off
some music, we have a sprite,
20:36 - and a sprite x and y.
20:37 - These are values that are relevant to
the sprite that's moving, actually,
20:40 - we only have one sprite
ever moving left to right.
20:43 - It just gets teleported to
the right edge of the screen
20:45 - as soon as it gets taken to one edge.
20:47 - So we only have one sprite, one x and y.
20:51 - And then every three
seconds as we see here,
20:53 - we have a callback function that will
tween the sprites x to negative 64
20:59 - over 0.2 seconds, so really quickly.
21:03 - And then on finish,
teleport it to the right.
21:06 - And then do the same
exact thing, but tween it
21:08 - to the center over 0.2 seconds.
21:11 - And then as soon as we press
Enter or Return, note this here,
21:18 - we have gStateStack, not
a gStateMachine anymore,
21:22 - and we're pushing on
to it a fade in state,
21:27 - which takes an RGB, a duration,
and a callback function.
21:32 - Now if you look at
main.lua, this is relevant,
21:38 - because now we no longer
have a state machine, right?
21:42 - We previously had a global
state machine, gStateMachine.
21:45 - We would give it a list of indexes
into functions, anonymous functions.
21:49 - Those would return the
instantiation of a state.
21:53 - And then when we called
change, the state machine will
21:55 - index into its list of states,
and call that anonymous function,
22:00 - which would have the result of
changing the state to some state
22:04 - that we've implemented
as a class, right?
22:07 - Now we just create a
state stack and we just
22:09 - push a new start state onto the class.
22:14 - And so what this will do is
effectively the same thing, only now
22:18 - we can layer things onto the
start state, right, or play state,
22:23 - or whatever we want to, and we're
not going to ever get rid of it.
22:25 - I mean, we can get rid of
it, but we don't have to.
22:28 - For the play state, especially, we
want that to pretty much never get
22:32 - popped off the stack,
because that's going
22:35 - to preserve all of our information.
22:36 - We're going to default back to that to
store all of our character information,
22:40 - our Pokemon information,
whatever else we might
22:43 - want to add onto this shell
of a game in inventory,
22:46 - et cetera, a world state at large.
22:49 - We want to preserve that and keep that
consistent across all of our battle
22:53 - states and so forth.
22:54 - And the battle states will just
pull information from that world,
22:58 - from that play state, and
construct a battle as needed.
23:01 - Does that makes sense?
23:04 - OK, so here we're effectively, the
only real changes we've made to main
23:08 - are no longer a state machine,
now we have a state stack,
23:11 - going to push start
state, that start state
23:14 - has some behavior just like any other
state that we've implemented before.
23:22 - And what I was about to get into before
was here on line 36 of the start state,
23:29 - we're pushing another
state onto the stack.
23:32 - So there's already a start state, and
it's from within the start state itself
23:36 - actually.
23:40 - We're going to take that stack,
which is just one level deep,
23:42 - and then we're going to
make it two levels deep now.
23:44 - So now we're going to
add a fade in state.
23:46 - And the fade in state as we
can see, takes in an RGB.
23:49 - Does anybody have a guess as to
what the RGB is relevant for?
23:55 - AUDIENCE: [INAUDIBLE]
23:58 - SPEAKER 1: To whether you want
to fade in black or white?
24:00 - Yes, any color.
24:02 - We can make this, we can make it
a fade to red if we wanted to,
24:04 - or fade to blue.
24:06 - But we don't have to create two
separate classes for a fade in white,
24:10 - fade in black, fade out
black, fade out white.
24:13 - We can just give it a color.
24:16 - And then I mean, we could even
go a level further with this,
24:20 - and make it take in an opacity as well,
so that we don't need a fade in state,
24:23 - or a fade out state, we just
need a fade state, right?
24:26 - And the fade state will
determine, based on whatever
24:30 - last opacity parameter we give it,
the right way to fade in and out.
24:37 - But in this case, the difference
between the fade in state
24:40 - and the fade out state is one knows
to go to 0, one knows to go to 255.
24:44 - That's really the only key difference.
24:46 - And then this 1, the duration, right,
we need to tell it how long to fade.
24:51 - And then this last bit
here is a function.
24:55 - We're giving it an anonymous
function, this is a callback function,
24:59 - because the fade in state by
nature is an asynchronous state.
25:06 - It does its behavior over time.
25:08 - So we need a way, we
need to tell it, OK,
25:10 - when you finished doing what
you're doing, call this bit of code
25:14 - here, so that we can do
something not immediately,
25:19 - we can sort of defer its
execution till later.
25:22 - And this is something that we'll
see common throughout this lecture,
25:26 - because we have this implemented
also in like dialogue for example,
25:29 - because we don't know when the user is
going to press Spacebar on the dialog
25:34 - state and clear the window.
25:36 - But what if we want that window,
the clearing of that dialog
25:39 - to trigger some sort of event, right?
25:41 - For example, if they press Enter
when they're in the battle,
25:44 - we want it to go to the next action.
25:46 - We don't necessarily know
when it's going to happen,
25:48 - so we'll just pass in an anonymous
function to that dialogue state
25:54 - that the class will call whenever the
close function is called on that dialog
25:59 - state.
26:00 - It says, when closed, execute
this anonymous function.
26:03 - And then that anonymous function
can do whatever you want to do.
26:06 - It could pop another other
several states onto the stack.
26:09 - But this is what allows us to
chain asynchronous behavior.
26:12 - That's the key here.
26:15 - So this anonymous function-- so
we'll take a look now actually
26:18 - at the fade in state, just so
we can see what this looks like.
26:23 - So we see here, fade in state,
right, takes in the color.
26:26 - We saw before, that will
be the color we fade to.
26:30 - The length of time that it'll take us
to actually perform the transition.
26:34 - And what are we using for the transition
do we think, timer.tween, right?
26:46 - So most everything
that we'll do actually
26:51 - throughout the course of this lecture
that has asynchronous behavior,
26:55 - we can implement it with
timer, which is nice.
26:57 - It allows us to fairly
succinctly and declaratively tell
27:01 - right out what exactly we
want to have happen over time.
27:04 - In this case, we're going to
tween over the course of time
27:07 - the opacity of our self to 255.
27:11 - So the fade in is going to fade
into the full color of whatever we
27:15 - have given it.
27:16 - So it's going to go from 0, which
is shown here by default, to 255.
27:22 - And then as soon as
we finish that tween,
27:27 - that is when we pop the fade in state.
27:32 - We're going to pop ourselves off
the state effectively, off the stack
27:35 - effectively.
27:37 - And then here, we're
calling on fade complete.
27:41 - And that's where the
anonymous function is.
27:43 - On fade complete is passed in here.
27:45 - So by putting that function into the
finish function of the tween operation,
27:52 - we've allowed ourselves to defer that
function that we've written up in the--
27:58 - it's in the start state.
28:01 - We defer the execution of this function
until after that tween operation
28:04 - takes place.
28:05 - Does that make sense?
28:08 - OK, awesome.
28:09 - And that's effectively what it is.
28:11 - And that's a common theme that we'll see
if you're looking through the distro,
28:13 - you'll see it in a lot of places.
28:15 - Anonymous functions
or callback functions
28:17 - rather being passed into things
like the dialogs, and the fades,
28:24 - and a few other places.
28:26 - In the take turns state
for example, there's
28:28 - a function that takes in at
a callback function as well.
28:30 - And that's effectively how you can
chain asynchronous behavior that
28:38 - executes over time, rather
than it being blocking.
28:41 - Does anybody have any questions so
far as to how this works, at all?
28:47 - All right, so when the fade is done--
28:51 - we're still the start state here--
28:54 - at this point, the fade is done, we're
executing this anonymous function.
28:58 - We're going to pop the start state
off of the stack in this case.
29:09 - And then we're going to push a--
29:12 - we're going to do two pushes here.
29:15 - One is to push a play state, which
recall is where the NPC [INAUDIBLE]
29:20 - character walking around.
29:23 - And another one is to
push a dialogue state.
29:27 - And so what this will have the
effect of doing is rather than us
29:29 - immediately going into the play
state and being able to walk around,
29:33 - we're actually put
right into a world where
29:35 - there is a message waiting
for us that we have
29:37 - to press Enter on in order to continue.
29:40 - And when we press Enter, because
we're pushing the play state first,
29:45 - and then the dialogue
state, the dialogue state
29:47 - is at the top of the stack,
right, because things
29:49 - get pushed onto like a stack of plates.
29:53 - You put a play state plate on the
bottom and then another plate on top,
29:56 - and that plate is the
dialogue state in this case.
30:00 - And you can only interact with the top--
30:02 - we're only updating the top
plate at once in this model.
30:06 - We could obviously make
a more complicated state
30:08 - stack that allows us to have several
layers of states being updated at once,
30:14 - but for simplicity, we only opted to
allow the top layer to be updated.
30:19 - The dialog state is going
to be the active state,
30:21 - it's going to be receiving input.
30:23 - All of them are going
to be rendered, so we're
30:25 - going to render things
from the bottom up.
30:27 - We're going to render
the play state, then
30:28 - we're going to render the dialog
state, but the dialog state's
30:31 - going to be active.
30:31 - We're only going to be able to
press anything on that state.
30:35 - And then lastly, actually,
even beyond the dialogue state,
30:40 - we're pushing another state,
we're pushing a fade out state.
30:43 - And in this case, it's the
opposite of the fade in state,
30:47 - it just takes in an RGB, and
we'll go from 255 opacity
30:51 - to zero opacity in that case.
30:54 - And so what that allows us
to do for playing right,
31:00 - we're here in the start
state, pressing Enter.
31:03 - That's our fade in state was there.
31:06 - And then we pushed to the play state
and the dialogue state and the fade
31:11 - out state at once, so
you would almost think
31:15 - that we push a fade in
and then the fade out,
31:18 - but we have to lay that
foundation before we
31:21 - put the fade out state
on top of the stack,
31:24 - right, because the top
layer gets updated.
31:27 - So we have to push the fade out
state on top of all of those.
31:30 - That will get updated,
that will fade out,
31:32 - and then we're back to the
two states that we push
31:34 - before we pushed the fadeout state.
31:36 - Does that make since?
31:39 - OK.
31:40 - Does anybody have any questions
as to how that sort of flow works?
31:44 - Cool.
31:47 - All right, so that's
the gist behind, I mean,
31:49 - that's essentially the core
of what we're doing today
31:54 - is the state stack
pushing multiple states.
31:56 - And then just figuring
out the right order
31:58 - the need to push them in to get the
desired appearance that you want,
32:02 - right?
32:03 - We push the fade out state
while we're in the start state,
32:07 - or fade in state rather.
32:08 - That will take us to
white, and then like sort
32:10 - of, almost like underneath the-- behind
the curtain, we're popping everything,
32:17 - and then we're adding the play,
dialogue, and then another fade out
32:20 - state.
32:21 - And so you sort of have to balance the
order that you put things in in order
32:25 - to achieve the desired results.
32:26 - It may not necessarily be
exactly as you intuitively
32:28 - think until you think about just
how we're updating and rendering
32:32 - things on a stack.
32:34 - And so that's the ultimate hurdle I
think in really getting comfortable
32:38 - with the distro, but once you've gotten
that, everything else sort of falls
32:41 - into place.
32:42 - That and the sort of abundance of
asynchronous functions, as we'll
32:46 - see pretty shortly when we look
at GUIs, and how we've implemented
32:49 - a lot of basic GUI functionality.
32:51 - A lot of that is very,
very call back driven,
32:54 - just because of the nature of it
being based on user input, right?
32:58 - You don't know when the
user's going to do any input,
33:00 - so defer whatever happens
with that GUI code
33:04 - with the triggers involved
when the user presses Spacebar,
33:08 - Enter, and then call that function that
you've passed into that GUI widget.
33:13 - All right, so we've taken
a look at the state stack.
33:17 - We've taken a look at the
start state, the fade in state,
33:20 - let's take a look now at the play state.
33:25 - So the play state--
33:26 - a lot of this is actually
very similar to what
33:28 - we did back with Zelda, which is a
very similar type of game top down.
33:35 - View, the only difference really
with that was RPGs of this nature--
33:40 - Final Fantasy, Pokemon,
Dragon Quest, they're
33:42 - tile based to the degree of even
your movement is tile based.
33:47 - And so we've striven to
implement that with this lecture.
33:51 - So when we move our
player, our character,
33:57 - it doesn't have free motion like
we did with Zelda for example.
34:02 - So I'll demonstrate this.
34:03 - So I can go to the field state
here, the play state, sorry.
34:07 - And then when I move,
if I press right, he
34:09 - moves in that direction at
a perfect grid interval.
34:13 - So if I move up, I'm taking
my hand instantly away,
34:16 - he's going to keep moving, and he's
going to stick hard set to this grid.
34:20 - And that's just a sort of trend
that these games have implemented.
34:25 - It allows you to stay perfectly
aligned with the grid, and helps you
34:29 - I guess certain game--
34:30 - I don't think it's strictly
necessary for probably
34:33 - most of the games that
choose to implement this.
34:37 - I think it was a symptom of tile
based games from the NES and Gameboy
34:41 - era being easier to
design and implement,
34:47 - because they're very tile based systems.
34:51 - But I mean, even as an aesthetic
choice, I suppose it makes sense,
34:55 - because everything
aligns very perfectly.
34:57 - So that's the core difference really
with the field state in this game.
35:00 - So how can we go about implementing a
grid aligned movement system like this
35:09 - with our player relative to how
we did it in Zelda for example?
35:16 - How do we think-- sure yeah?
35:18 - AUDIENCE: So we don't x and y's,
we just have the tile positions.
35:23 - SPEAKER 1: So you don't have x and
y's, we just have the tile positions.
35:26 - Close, I would say it's more
focused on the tile positions,
35:30 - but you still do need an x
and a y, because you still
35:33 - need to draw that sprite
at that exact position.
35:37 - Right, yes Tony?
35:38 - AUDIENCE: Well, when you need
to move the sprite, instead
35:42 - of moving at every update, you tween
it between the two tile locations.
35:47 - SPEAKER 1: Exactly, so
rather than moving the sprite
35:51 - at exact pixel positions per update, you
tween the sprite when you receive input
35:57 - to a specific location.
35:59 - And then we actually stop
input at that point as well.
36:02 - There's no use for us having any input
when we're not exactly at a given tile,
36:08 - so we disable input while
he's walking effectively.
36:12 - And so this is implemented, if we're
looking at the distro in the entity
36:16 - class, there is a--
36:19 - I believe it's in here--
36:24 - maybe player, hold on.
36:32 - Oh sorry, no it's entity
walk state, not the entity.
36:35 - Entity is just a container for
the information that's relevant.
36:38 - So here in the entity walk
state, we have attempt move.
36:42 - And so what attempt
move does is essentially
36:45 - it looks to make sure that we're
within the bounds of the map, right?
36:49 - And then if we are--
36:51 - every entity in this game now has a
map y and x, and a regular y and x.
36:56 - And so the regular y and
x, we still need in order
36:59 - to draw our sprite at a
specific location on the map.
37:01 - We still need to draw it going between
240 something and 230 something, right?
37:09 - But we need a map x and a
map y to basically say, OK,
37:12 - the sprite should be at
this position on the map.
37:15 - And then we'll just tween it
between that position times 16,
37:19 - and it's the position
plus or minus x or y
37:22 - times 16, which will give us
the exact x and y value that we
37:26 - need to draw it onto the map.
37:27 - And so that's what we're doing here.
37:28 - So were going to call
attempt move on input.
37:32 - So anytime we do any input--
37:34 - and this is done in the player
like idle, or player, yeah, player
37:39 - idle class--
37:41 - player idle state.
37:43 - We change the animation
to write animation.
37:46 - And then we get it's
current map x and y.
37:48 - And then based on whatever
direction the player is looking,
37:51 - or the entity is looking, we could use
this for an NPC class, or the like.
37:56 - We just modify our 2x and 2y.
37:59 - So to 2x and 2y is going to be the value
that we're tweening towards times 16,
38:04 - right?
38:05 - And so if we're trying to go
outside the map boundaries,
38:10 - just changing us back to
idle won't let us do that.
38:13 - Otherwise, set our map y and map
x to that position immediately,
38:19 - right, because that's just a
minus or plus one operation.
38:22 - And then over the course of 0.5
seconds, actually tween to that value.
38:28 - And we can see here, we're
tweening to the tile size,
38:30 - and actually to the tile size minus
self.entity.height divided by 2.
38:35 - Do we know why that is?
38:40 - We do that, because if we're looking
at the field, we can see here,
38:45 - notice that we're not perfectly
lined up with the grass, right?
38:48 - It's kind of like
we're halfway above it,
38:50 - because it looks just a little
bit more natural this way,
38:53 - this is how most sort of games look.
38:54 - And if you're in a game
like this and you're
38:56 - like walking up against
a wall for example,
38:58 - this will allow you to
sort of look as if you're
39:00 - up against the wall
rather than sort of being
39:03 - at the edge of where the bottom of the
wall is, and kind of looks unnatural.
39:06 - Hence why we minus 1/2
our height right there.
39:12 - And then when we're
finished, we actually
39:15 - test to see whether we're still
pressing a key, and if we are,
39:18 - then change our state
to walk again, which
39:20 - we'll just repeat this process depending
on which direction we're looking at.
39:24 - And that's effectively it.
39:25 - And that's what allows us to
get this grid based movement.
39:28 - Any questions as to how this works?
39:33 - Cool.
39:37 - Let's take a look then at the
play state, let's go back to it.
39:43 - So we have a level, the
level contains our entity,
39:46 - and it can contain all of
our entities, and whatever
39:49 - objects you want it to contain.
39:53 - In this case, when we're
in the play state as well,
39:55 - we're going to check
to see if we press P,
39:57 - because that's recall, where
we can heal our Pokemon,
39:59 - just a little game hack just to
make demoing it a little bit easier.
40:05 - But if we press P, we play
the heal sound, we take our--
40:11 - and we'll look a little bit more detail
as to this, all this in a little bit.
40:16 - But self.level.player.pa
rty.pokemon@index1.currenthp
40:24 - equals
self.level.player.party.pokemon@1.hp.
40:29 - So the difference is current HP
is whatever you currently have,
40:32 - you could have taken damage.
40:33 - HP is whatever your max HP is.
40:35 - And this is like in a
nutshell how you get
40:38 - like stat changes in games and
RPGs, and health and mp differences.
40:44 - You've got to keep track of a max and a
current value for all of those things,
40:48 - and then depending on whether
you're buffed or debugged,
40:50 - or whether you have taken damage
or not, or used spells or not,
40:54 - you can have an accurate
reflection of where
40:56 - your character is and then
always return back to that state
41:01 - whenever you need to.
41:03 - The interesting thing here, the
slightly more complicated thing
41:06 - is when we press P, we want
to show a dialog that says,
41:10 - and I'll demonstrate this,
we want to show a dialog just
41:13 - like this one that says, we press P,
your Pokemon has been healed, right?
41:18 - Now I can't move.
41:19 - I'm pressing the arrow keys.
41:20 - I can't move my character at
all, because this dialog state--
41:23 - we're in a new state, well, we've
pushed a new state onto the state stack.
41:28 - And that's the dialog state
here, which has taken a value.
41:32 - And because it's the top layer of
the stack, it can't get updated,
41:37 - or it's being updated, and we
can't update the play state, right,
41:40 - based on how we've modeled our state
stacks operation, or how it works.
41:44 - And then as soon as I press
Enter, it gets popped off,
41:47 - we've just popped it off.
41:49 - Now the place states at
the top, I can move again.
41:51 - So that's what's going on.
41:52 - So the dialog state then is actually
very similar in a sense, to the fade
42:02 - in and fade out state in that, notice
that it takes an anonymous function.
42:06 - When does this anonymous
function get called?
42:09 - Do we know?
42:12 - At the end of what?
42:16 - AUDIENCE: [INAUDIBLE]
42:18 - SPEAKER 1: Yeah, well, when the
user closes the dialog box, correct.
42:24 - So let's take a look at
the dialog state then.
42:27 - And we can see, it's actually
pretty simple, it's pretty small.
42:32 - We have a text that it
takes and a callback, right?
42:36 - The text is used here.
42:39 - We instantiate, and this we'll see in
detail when we start looking at GUIs,
42:42 - and all the widgets
they've implemented here.
42:45 - This text box gets put at a hard coded
position, and it receives this text.
42:52 - And then we set our self.callback
to that callback function.
42:56 - If we have closed the
text box, meaning, we're
43:00 - looking to see at
self.textbox.isClosed, which
43:03 - is a function of the text box class.
43:07 - If it's closed, then execute
self.callback, and then pop
43:12 - this dialog state of the stack, right?
43:15 - So it's similar in a sense,
to the fade in and fade out,
43:19 - and then it takes anonymous function.
43:21 - The only difference is
in how it gets executed.
43:23 - With the fade in state,
the anonymous function
43:25 - was called at the end of
the finish function, which
43:28 - is part of the tween object.
43:30 - In this case, we're executing the
callback function explicitly when
43:33 - we've closed the text box.
43:35 - So we're waiting for user input versus
waiting for some asynchronous operation
43:40 - to finish.
43:42 - And then of course, we
call text box render,
43:45 - and then we'll see all of these methods
shortly as part of these widgets,
43:49 - but at a glance, this is all that's
really happening with the dialog state.
43:52 - Very simple, using the
same pattern that we've
43:55 - seen of deferring future
behavior to anonymous functions.
44:01 - Any questions as to how this
works, or anything so far?
44:07 - Cool.
44:09 - All right, let's take a
look back at the play state,
44:11 - I believe we're getting close to
being finished with the play state.
44:14 - Yes, so everything, that's basically
what the play state is in this game.
44:18 - And then a lot of what's going on
takes place in a level as well.
44:22 - So in a nutshell, we have
two maps, two layers, right,
44:29 - because the grass in the tile sheet
is its own sort of [? alphaed ?]
44:32 - out object, it's got
transparency around it.
44:36 - We keep a layer of the base, a
layer of the grass underneath,
44:40 - and then a separate
layer for the tall grass.
44:43 - And then we can just
look and to see when
44:45 - we're walking in the player walk state
when we've walked over tall grass.
44:51 - And then what do we need to do
to start a random encounter?
45:01 - Yes?
45:01 - AUDIENCE: [INAUDIBLE]
45:04 - SPEAKER 1: Yes, how do
we initiated though?
45:07 - That what are we looking for?
45:08 - We do push a battle state as
soon as we've triggered one,
45:11 - but how do we trigger one?
45:12 - What are we looking for?
45:13 - AUDIENCE: [INAUDIBLE]
player is in the grass.
45:17 - I don't know if it's on
moving to a new grass,
45:20 - or if it's time spent in the grass.
45:22 - Yeah, we do a random chance
whenever the players on grass.
45:25 - And it's whenever they start to walk
and there on grass in this case.
45:29 - But you can do it either
way, you can do it
45:31 - when they're leaving the
grass, walking into the grass.
45:33 - In this case, it's whenever
you press the button,
45:35 - and they happen to be on grass,
it'll do a random chance, one in 10.
45:38 - And if it's equal to 1, 10%
chance it'll trigger an encounter.
45:43 - So that's the gist behind
triggering a random encounter,
45:46 - and a lot of these games really--
45:48 - some games do it differently.
45:49 - They'll sometimes make it more
likely the more steps you've taken,
45:52 - they'll like sort of keep a counter
to say, oh, I've taken 100 steps,
45:55 - it should be a lot more likely now.
45:57 - Some games will just be completely
random, 1 in 10, 1 in 5,
46:01 - depending on how the developers
decided to implement their game.
46:05 - The former is a bit more robust.
46:08 - But for simplicity, we just
chose, math.random10 equals 1.
46:14 - So yeah, we create the tile maps
here, pretty straightforward.
46:19 - And then the actual random encountering
takes place in the player walk state.
46:26 - So here we have check for encounter.
46:29 - And so what this does is whenever
we enter the walk state, which
46:33 - is we press the button
to enter, or to walk,
46:37 - this entire function
gets called, because we
46:40 - do the transition to the player
walk state in the state machine.
46:43 - All of the entities are still
using just a regular state machine
46:45 - not a state stack.
46:46 - Wasn't necessary for this
demonstration, though I'm sure
46:49 - there are some used cases for
using a state stack for an entity.
46:52 - In this case, we're just
using a regular state machine.
46:55 - So when we change to the walk state,
we are calling enter as we've seen.
46:59 - And then we call self,
checkForEncounter.
47:02 - And so self, checkForEncounter
will set a flag
47:07 - if we have not started an encounter
basically and will allow us to move.
47:14 - And if we have checked
for an encounter, it will,
47:17 - or if we have triggered an encounter,
it will push in checkForEncounter,
47:21 - it'll actually push a
battle state onto the stack.
47:26 - So checkForEncounter just
basically does what we said before.
47:30 - If the grass layer,
because we have two layers,
47:34 - right, we have the base
layer and the grass layer.
47:37 - So if the layer at yx where yx
is are entities map x and map y.
47:43 - If the ID of that is
equal to tall grass,
47:46 - and we have just a global
constant table called
47:50 - Tile IDs, which has all these IDs.
47:52 - And math.random10 is equal to 1,
OK, change the entity state to idle,
47:57 - so don't let them keep walking.
48:00 - Pause the field music
rather than stopping,
48:02 - so that way when we come back to
the field later and we press play,
48:06 - it will be at the exact
point that it was before.
48:09 - Triggered the battle music, and then,
we've seen this already, fade in state,
48:14 - push to the stack, right?
48:16 - So over one second, we're
going to fade to white.
48:19 - So this will have the effect
of the music starting,
48:22 - but we're fading to
white right away, which
48:23 - is very sort of similar
to how most RPGs do it.
48:27 - And then we have our
callback function, which
48:29 - will execute as soon as the
fade in state's done, right?
48:32 - In this case, push to battle state.
48:35 - Battle state takes an
entity, and the entity
48:37 - has all of our Pokemon
information, that's
48:39 - why we're passing that
into the battle state.
48:41 - So the battle state can say,
oh, what Pokemon do you have?
48:44 - OK, I'll be able to look at your
party and say, OK, your first Pokemon
48:49 - is this, send him out to
battle, et cetera, right?
48:52 - And then lastly, push a
fade out state, right,
48:56 - because now we've got the battle
state on top of the play state,
49:02 - but we want to fade into it, right?
49:05 - So we're going to fade, we're going
to put the battle state first,
49:08 - and then because we're
using a stack, we're
49:10 - going to put the fate out state on top
of that, and then fade out to that,
49:14 - pop that off the stack.
49:15 - And then we have our battle
state that we just pushed, right?
49:19 - And then self.encounterFound
get's set here.
49:21 - And that's creating an
encounter, checking randomly,
49:25 - pushing the right things
under the stack, battle state,
49:27 - fade state, fade in, fade out.
49:30 - And then you're set to go.
49:32 - So that's effectively what the--
49:35 - it's known in RPGs as the field
versus the battle or encounter state.
49:41 - Even though we're calling it play
state here, we've left the field,
49:44 - we've gone into the
battle at this point.
49:46 - And so now we've seen
basically everything
49:48 - that the field has to offer us.
49:51 - And we've covered everything
that's relevant there.
49:54 - So we're going to take a break
now for five to 10 minutes,
49:59 - and then when we get
back from the break,
50:01 - we'll talk about GUI
elements, panels, text boxes,
50:04 - and then we'll dive into the sort
of mechanics of the battle state.
50:09 - All right, welcome back
to lecture 7, Pokemon.
50:12 - So before the break, we
talked about the play state,
50:14 - we talked about the states
stack more importantly,
50:17 - and then we talked about how
a anonymous functions are
50:20 - sort of the backbone to how we
get a lot of this asynchronous
50:25 - and deferred behavior for our
game, which is very common in RPGs,
50:29 - and I mean, a lot of genres, a lot
of complicated genres of this sort.
50:34 - Another big key part of games
like this are the graphical user
50:39 - interfaces, or GUIs as
they're shortened to.
50:42 - Things like panels on the
screen, things like labels--
50:46 - text labels that move around, things
like lists, text boxes, scroll bars,
50:53 - and you can get a lot crazier with it.
50:56 - In this particular lecture, we'll be
talking mostly about panels, labels,
51:03 - text boxes, and scroll bars--
51:05 - progress bars rather, not scroll bars.
51:08 - But the sort of the
first I think corner--
51:12 - or the first sort of
like keystone GUI widget
51:17 - that we should take into
consideration is the panel.
51:21 - So a panel is [INAUDIBLE].
51:33 - So if we look at this in a game--
51:41 - just pretend this is a panel I guess.
51:44 - So this is effectively
all a panel is, right?
51:47 - It's just sort of a rectangle.
51:49 - It allows us to-- if you're
looking at most user interfaces,
51:54 - like text boxes on your screen,
or if you're on Facebook
51:56 - and you're looking at almost
anything, like your little message
52:00 - window, a lot of those things at
the very core, the very bottom,
52:03 - the foundational part is just a panel.
52:05 - So any guesses to how in Love2D,
we can make a simple panel?
52:11 - AUDIENCE: Two rectangles
of different colors.
52:12 - SPEAKER 1: Two rectangles
of different colors,
52:14 - that's exactly what we end up doing.
52:16 - So that's effectively
how we can make a panel.
52:18 - There's another way of making a panel,
which we won't do in this lecture,
52:24 - but it's called--
52:26 - we use as a construct
called a nine patch.
52:30 - So a nine patch is--
52:37 - imagine taking this little image
here, and it's of some arbitrary size,
52:41 - but it's very small.
52:42 - And this is very similar
to how a lot of games
52:44 - implemented their panels
or their graphical user
52:48 - interfaces back in the 80s and 90s, I
mean, to a lot of games till this day.
52:52 - But back when hardware was
fundamentally tile based,
52:58 - you could take a image like this,
split it up into nine pieces--
53:06 - nine patch is where the
terminology comes from.
53:11 - And sort of similar to how we actually
constructed the Zelda dungeon, recall,
53:15 - where you have corner pieces, and then
a top, bottom, right, and left side.
53:20 - You just layer this,
one of each of these,
53:24 - first off, right, of the corner pieces.
53:28 - And then however many you
need of these on the sides
53:33 - to create this rectangle, right?
53:36 - So imagine we've created--
53:39 - these are all, if we can visualize
these as being a bunch of tiles, right?
53:52 - So just imagine that we've
taken these corner pieces,
53:55 - these are the corner pieces,
we've taken one of each of those.
53:58 - And then we take these side pieces,
and we just like draw a bunch of them
54:02 - like that.
54:04 - And then we take this
centerpiece, and then we
54:06 - can either layer it, or tile it a
bunch of times, or just stretch it.
54:11 - And stretching it has a bunch of nice
bonuses associated with it depending
54:15 - on how you've set your filter mode,
love.graphics.setdefaultfilter,
54:18 - if you set it to
bilinear versus nearest,
54:21 - you can actually get a nice gradient.
54:23 - And if you set it to nearest,
you get a nice pixelated look.
54:26 - But you'll see this often, and
Unity has nice support for this.
54:29 - Take an image that has maybe
more complicated than you could
54:32 - get with just two rectangles, right?
54:34 - Something that actually has a design
and maybe a gradient color, and actually
54:37 - layer--
54:40 - I mean, create a arbitrarily
sized text box to fit your needs.
54:46 - And if these aren't even increments
or whatever your tile size
54:49 - is on your 9 patch, you could just scale
the top, bottom, left, and right side
54:53 - as well just to keep it
scaled, the centerpiece.
54:56 - So does that makes sense.
54:58 - So this is common, we won't
be using that in our lecture,
55:01 - but it's a very, very common piece to a
lot of graphical user interface design.
55:06 - In a lot of games, you'll see it a lot
if you get more into game development,
55:09 - so it's definitely worth talking about.
55:12 - Another piece that we'll be talking
about today is the text box.
55:17 - So I mean, what's a guess
as to what the text box,
55:20 - how we can implement a text box, and
how we will implement a text box?
55:27 - So what foundational
piece can we start with?
55:33 - We already have-- yeah?
55:35 - AUDIENCE: You just
put use the love print
55:37 - to the screen over one of those boxes.
55:40 - SPEAKER 1: So use the love print to the
screen over one of the boxes, exactly.
55:43 - Yep.
55:44 - So maintain a list of
text items, right, text.
55:49 - And then just draw them inside
a panel, and there's a text box.
55:57 - You've taken two ideas, and
sort of mix them together.
56:00 - A selection is kind of the same thing.
56:03 - It's a the only difference
being that with a selection--
56:07 - so a selection is another
thing if we think about,
56:10 - for example a menu where we
have fight, and like run,
56:15 - and it may be in a more fleshed out
game, we have like an item thing,
56:20 - right?
56:21 - So that's a menu effectively.
56:25 - It is very similar to what
we get with a text box,
56:28 - but it's got a set of ingredients
here, fight, item, run,
56:32 - which they aren't set to wrap, they're
not one like contiguous set of text.
56:40 - It's just a bunch of items.
56:42 - And then nice thing about
a selection is that you can
56:45 - have a cursor on your selection, right?
56:49 - And then what do we need to
associate with like, for example,
56:53 - if we want this to
actually do something,
56:54 - and if we think about what
we've been doing so far,
56:57 - how do we go about
implementing functionality
56:59 - with a selection like this?
57:00 - Like what needs to get associated with
each of those entries in our selection?
57:08 - Callback function, right?
57:09 - Just as we've done with everything else.
57:11 - If you have a fight item here, each
of these, if we think of the selection
57:15 - as being just this part
of what we're looking at,
57:19 - right, because this background part is
just a panel, we don't care about that.
57:22 - We care about the
selection at the moment.
57:24 - The selection is the items
and the arrow, right?
57:27 - When as we'll see in the
assignment, your goal will actually
57:30 - be to take selection and get
rid of the arrow functionality,
57:33 - because for the
assignment, you don't need
57:36 - or want to have a selection
active, a cursor active.
57:40 - You just want a list of things.
57:43 - But based on what the cursor is pointing
at and when we press Enter or whatnot,
57:52 - we should index into
the selection, and then
57:55 - execute a callback that's
associated with each of these items.
57:59 - And that's how we can get
behavior out of the selection,
58:02 - rather than just being a list of
things that we render to the screen.
58:05 - If we have fight, and we
click Enter, a callback
58:08 - is set to maybe push a
state onto the stack that
58:12 - will trigger an interaction between
the two entities on the screen, right?
58:15 - The first one will
attack the second one,
58:17 - the second one will
attack the first one.
58:18 - And that's sort of its own asynchronous
set of states that do its own thing,
58:21 - but it's kicked off via
an anonymous function
58:24 - that we've associated with
each of these things, right?
58:27 - An item pushes another state, which is
like an item mini state, where then you
58:32 - open up a brand new set of menus that
you can look through all your items,
58:36 - and each of those items has a
callback associated with it, right?
58:40 - Your potion has a callback
associated with it
58:42 - that says, when I click on
this, either by default,
58:45 - just restore the HP
of my active Pokemon,
58:48 - or let me choose who to restore.
58:50 - So therefore, push another state,
which is like a select Pokemon
58:53 - screen with its own set of callbacks
associated with each of those.
58:58 - It's just in order to get all of
this sort of complicated behavior
59:01 - that you need to, it's really
ultimately just pushing states
59:04 - and adding callback functions to
all of these different options
59:07 - that you can select.
59:09 - And then run, push a fade
state, and then pop this state,
59:13 - and then push a fade out state.
59:14 - And that's really all we're doing.
59:16 - And so this look at all
of these GUI widgets
59:20 - here is just sort of a conceptual look,
but we'll take a look very shortly
59:24 - at some actual implementation.
59:25 - The last one that I want to
look at is the progress bar.
59:34 - So a progress bar for
example, the HP that we've
59:37 - seen in the actual battle where when
we take damage, it goes from right to
59:45 - left.
59:46 - Any guesses as to how we've
implemented a progress bar?
59:48 - Yes, Tony?
59:48 - AUDIENCE: Once again, two rectangles.
59:50 - SPEAKER 1: Two rectangles, yes, exactly.
59:52 - One, and then the nice thing
about rectangles in Love2D
59:55 - is you can set the edges on
them to be rounded or not
60:00 - via an optional parameter.
60:02 - So without anything more
complicated than a rectangle
60:05 - we can just create these sort
of almost ellipsoid progress
60:09 - bars, very simple progress bars.
60:11 - Ones the red, right, the
red that's the background.
60:14 - And then ones the outline, the black.
60:15 - And one is set to fill
with the first parameter,
60:18 - one's set to line with
the first parameter.
60:21 - Now how do we go about
animating whether or not,
60:24 - how do we animate the decreasing
amount of health when we take damage?
60:29 - Yes?
60:29 - AUDIENCE: Between the width.
60:31 - SPEAKER 1: Between the width, exactly.
60:33 - And what are we tweening it by?
60:34 - How are we tweening it?
60:36 - How would we calculate how
much we need to tween it?
60:38 - AUDIENCE: Well, you could just have
your width equal your health remaining.
60:44 - SPEAKER 1: If your width is set
to equal your health remaining,
60:47 - then your health is maybe 10.
60:49 - And you want your health
bar to be like 100 pixels
60:52 - long, how is that going to work though?
60:54 - AUDIENCE: Multiply it.
60:55 - SPEAKER 1: You could
multiply it, but if you
60:57 - know the width that you want
your progress bar to be,
61:01 - you can just multiply the
width by the ratio of the max
61:05 - value of your HP, or sorry, the ratio
of your current HP over your max HP,
61:12 - right?
61:12 - So if you're missing-- if you have
50 HP, and you're missing 5 HP,
61:16 - your ratio is 45 over 50.
61:18 - And if you multiply that by your width,
you get the exact amount of width
61:22 - that you need regardless of how
wide you want the bar to be,
61:26 - if you want to be 1,000 pixels,
if you want it to be 50 pixels,
61:29 - as long as you multiply current health
over max health times the width,
61:35 - you'll get that ratio no matter what.
61:37 - Does that makes sense?
61:38 - Cool.
61:39 - So that's a look at all the GUI widgets
that we're looking at, how they sort
61:43 - relate to what we're doing.
61:46 - We'll take a look at
their implementation here.
61:48 - So I'm going to go ahead
and open up the panel.
61:51 - And I'm going to move
a little bit quickly
61:52 - so we can get into sort of
the meat of the battle here.
61:57 - The panel is as we've said before
just two rectangles, right?
62:03 - It takes in an xy within a height.
62:06 - And then we would just
draw two rectangles.
62:08 - One is larger than the other.
62:09 - The bottom rectangle is slightly
larger than the top rectangle.
62:12 - So the first rectangle gets
drawn and it's whitish.
62:16 - And then-- oh, I'm
sorry, sorry about that.
62:21 - We have a xy within a height.
62:23 - And then we're drawing two
rectangles to the screen.
62:26 - We have the background
rectangle, which is drawn first,
62:29 - which is going to be the full xy
width and height of the panel.
62:32 - And then we're going to draw that
at a white color, and then draw--
62:36 - in the context of this game-- we're
drawing everything at the same color,
62:39 - but we can change the color.
62:40 - If we wanted to parameterize
it, we could do that.
62:42 - We could set, we could have a color
option here in the constructor.
62:46 - We're not doing that, we're just
drawing everything the same color.
62:49 - But that's how you would
get like customized menus,
62:51 - some RPGs let you do that.
62:54 - And then what we're doing here is we're
just within a small slightly smaller
62:57 - boundary.
62:58 - So just two pixels
smaller on the x and y.
63:02 - Where you are going to
draw the second rectangle,
63:04 - which is a kind of dark shade of gray.
63:06 - And that is a panel,
that is all panel is.
63:09 - And then we could just
have a function called
63:11 - toggle, which sets it to
visible or not visible.
63:14 - And if it's visible, get rid of it,
or if it's visible, sorry, draw it.
63:19 - Otherwise, don't draw anything
when it gets rendered.
63:21 - So that's a panel in a nutshell.
63:23 - Any questions?
63:26 - Cool.
63:26 - So the next thing that we
should look at is the text box.
63:32 - So a text box--
63:33 - so the text box is a little bit
more complicated than a panel.
63:37 - A text box in a nutshell needs to
take in some arbitrary body of text,
63:41 - and it needs to chop it up based
on how wide your text box is.
63:45 - And if it surpasses the
height of your text box,
63:49 - right, ideally, you should page your
text so that you can press Space bar,
63:54 - Enter and go through pages of text
until you've exhausted all of your text.
64:00 - And you press Enter one last time,
and you get rid of that text box.
64:06 - And so we have a panel here, which
we have an xy width and height
64:11 - in our constructor for the text box.
64:12 - And we have our text as well.
64:14 - And then we have a font if
we want to explicitly decide
64:16 - what font we want to use.
64:19 - In this case, or at
large, we're going to say
64:25 - that we instantiate a panel at xy
width and height, nothing too fancy.
64:30 - And then the fancyish part, the
slightly more complicated part
64:35 - is here on line 20
where we say, underscore
64:38 - self.textChucks gets self.font,
getWrap, self.text, self.width minus 12.
64:46 - So anybody know what this function
does or want to take a guess?
64:55 - Yes?
64:55 - AUDIENCE: Is that the page
thing you were talking about?
64:58 - SPEAKER 1: Exactly, it's
the paging of the text.
65:01 - Is the chunking of the text rather.
65:02 - Not the paging of the text, so much
as is the chunking of the text, which
65:07 - we will use to page the text.
65:08 - So we take some you know
arbitrarily large body of text,
65:12 - it can be as large as we
want it to be, and given--
65:16 - this is actually a function
of to Love2D font object.
65:20 - So this is given to us from Love2D.
65:23 - Get wrap will return two
values, the second of which
65:26 - is all of the pieces of text that
the main big body is divided into
65:32 - based on the width.
65:33 - So this self.width of
minus 12, that's how wide
65:37 - it's going to divide our
text into chunks of up to,
65:39 - it could be slightly smaller
than, because it divides it
65:42 - based on the word.
65:44 - But no piece of text will ever
exceed self.width minus 12 width.
65:51 - And this will allow us to then render
several lines of text within our text
65:57 - box, and they will never
exceed the boundary, right?
66:01 - And so the paging functionality
is actually in next chunks.
66:05 - So we call self next here at
the end of [? knitt ?] function.
66:09 - And then self next basically checks to
see, OK, are we at the end of the text?
66:13 - If we are, then we're not
going to display any text,
66:16 - and we're going to close the window.
66:18 - We're going to close the panel.
66:20 - But if we are not at the end of the
text, like we still get text left,
66:24 - what we want to do is new table.
66:26 - And then we're going to,
up to three iterations,
66:30 - we keep track of where we
are in our chunks, right?
66:33 - We get self.text chunks equal
to all of those chunks, right.
66:36 - And that could be an arbitrary number.
66:38 - It can be only one chunk, there
could be like 30 chunks, right?
66:41 - We need a counter to
keep track of where we
66:43 - are in terms of like based
on what page we're on, right,
66:47 - and however many lines we
rendered to the screen thus far.
66:51 - So starting at I, and
I get's chunk counter,
66:55 - and chunk counter will
get incremented by three
66:57 - every time we call next
chunks, which is every page.
67:00 - We could have easily just
called this next page as well.
67:04 - It's going to insert
into that chunks table
67:05 - that we just created,
self.textChucks at i.
67:08 - And once we've reached
the number of chunks total
67:12 - that we returned from get wrap,
we're going to flag end of text
67:16 - as being true, and then
we're going to return it.
67:19 - And so what this will
do is, eventually, we're
67:22 - going to be equal to the number of
chunks that we got from font get wrap,
67:26 - right?
67:28 - And once we are, that
will signal with next
67:31 - that it's time to close the
text box, because end of text
67:34 - will have been set to true at the
end of that last chunking process.
67:38 - And then we can see here,
when we update text box,
67:41 - and that whenever it's
on the top of the stack,
67:43 - remember, we're looking for
a Space or an Enter press,
67:47 - and then we just call self next.
67:48 - And that will have the effect of
eventually closing our text box.
67:53 - And then is closed recall, we
looked at that earlier, we checked
67:56 - to see it is the text box closed?
67:59 - And that's just a flag that we set here.
68:01 - And then for rendering purposes,
we render the panel first.
68:06 - And then for each of our displaying
chunks, so we only have up to three
68:10 - displaying chunks at one time, which
gets set by the next chunks function.
68:16 - We just print that to the screen
using i as a multiplier on our y.
68:22 - And so that will render up two or
three lines, i, i plus 1, i plus 2.
68:29 - Any questions as to
how the text box works?
68:34 - It's a little more work
than the panel for sure,
68:36 - but it's fairly straightforward.
68:38 - We're just keeping a list
of a bunch of text things,
68:40 - and then we're just chunking
them based on how wide the text
68:46 - box is, the dimensions thereof.
68:50 - And then let's take one
look at this selection.
68:53 - So a selection is basically, a list
of text items with a cursor, right?
69:01 - And as I said before when we were
looking at the screen over there,
69:04 - each of those text items has a
text value and a callback function.
69:08 - And the callback function
is what allows us
69:10 - to assign behavior to this selection
object beyond just displaying things,
69:16 - right?
69:16 - Because when you have a menu,
when you have a selection
69:18 - and you select something, you
want behavior to happen, right?
69:22 - So each of these items indef.items will
expect to have a callback function.
69:29 - And then here, when we update
the selection, what we're doing
69:32 - is we're updating whatever our
current selection is, which is just
69:35 - a number between 1 and the number of
items in that selection making sure
69:38 - that if we're at one and we go minus
one, that we go back to the bottom.
69:42 - And if we're at the bottom
when we press, and we go up,
69:45 - we go back to the top.
69:47 - And we play sounds,
cutesy, things like that.
69:51 - And then for each--
69:52 - and for our selection here,
from one to number of items,
69:56 - we calculate how much
padding that we need.
69:58 - And we draw the cursor
at our current selection,
70:01 - and then we draw each item based
on i and whatever our gap width is
70:06 - of our panel, which we assign it to.
70:08 - So we divide our panel up,
and then basically just
70:11 - keep track of where
current y is and draw
70:14 - the actual selection
and the cursor if that's
70:17 - the current selection to the screen.
70:21 - Any questions as to how a
selection sort of works?
70:29 - Notice here, if we press Return,
if our selection is being updated,
70:35 - self.items at
self.currentSelection.onSelect.
70:40 - So it's expected that that item will
have an onSelect function, which
70:44 - is that callback function.
70:47 - OK, and lastly, we'll
take a look at the menu.
70:50 - And then we'll finally
take a look at the battle,
70:52 - which is where sort of everything kind
of comes together with all of this.
70:55 - And that'll be it.
70:56 - And then we'll talk
about the assignment.
70:59 - So the menu is a panel
and a selection together.
71:01 - That's the gist behind what
a menu is in this game.
71:05 - You can define a menu
to be a lot of things,
71:07 - and you can get a lot more complicated
with a menu, but in this example,
71:11 - in this implementation, we're
just saying a menu is a selection
71:15 - and a panel put together as one item.
71:17 - And we've seen it in the game,
[? if we're ?] going to run it.
71:24 - That's just a text box.
71:26 - Going to look for a battle.
71:32 - OK, so here's a battle.
71:33 - That's just an empty panel
at the bottom, regular panel,
71:35 - but now it's a text box.
71:36 - We push the text box onto the stack.
71:38 - Push another text box onto the stack.
71:40 - And so this is a menu right here.
71:42 - Notice that there is
a cursor and there's
71:45 - a selection embedded within a panel.
71:47 - And each of those items,
the fight and the run,
71:50 - those have a callback
associated with them.
71:54 - The purpose of the fight callback
is to trigger a new state
71:56 - where the two Pokemon asynchronously
attack each other, in chain behavior
72:02 - one after the other.
72:03 - And then run pushes a dialogue,
then pushes a fade state,
72:07 - then pops both of them, and
then pushes a fade out state
72:11 - and puts us back to the play state.
72:13 - So that's effectively
what's going on and that's
72:15 - an example of what the menu looked like.
72:18 - And so a menu, just a selection
with a panel put together.
72:21 - When we draw the menu, we draw
the panel and then the selection.
72:26 - And then when we update the menu,
we only update the selection,
72:29 - because that's all we care about.
72:32 - And that's basically it.
72:34 - And so the menu itself
will get a def, that def
72:37 - should have items, that items
will get passed to the selection.
72:44 - That's pretty much, that's it for the--
72:46 - oh, progress bar as well.
72:47 - We'll look at progress bars when
we get to the actual battle state.
72:51 - So now, let's take a look at a few
of the classes and data structures
72:55 - that are pertinent to
the Pokemon themselves.
72:57 - So if you look at party
as are first class, very
73:00 - simple class, literally just this--
73:03 - self.pokemon is def.pokemon is
just a container at this point.
73:07 - You can take this--
73:09 - I mean, even in I think
a fully fleshed game,
73:12 - you wouldn't really need
much more than just this.
73:15 - But if you needed to expand
upon this idea at all
73:18 - and you know preserve metadata
that exists for the party,
73:21 - this would be a perfect way to do it.
73:24 - The actual pokemon class itself is
not a whole lot more than effectively
73:31 - a bunch of stats.
73:33 - And that's a lot of what an RPG is.
73:36 - This genre is-- it's
mostly just numbers.
73:38 - You're just comparing
numbers against numbers
73:40 - and then adding a roll of the dice.
73:42 - That's effectively, that's what
Dungeons & Dragons, a lot of it is.
73:46 - And that's-- yes?
73:47 - AUDIENCE: Would it make
more sense to store
73:49 - just delta per level and your initial
one, so you can have fewer variables?
73:57 - SPEAKER 1: Say it one more time.
73:58 - AUDIENCE: Wouldn't it
make more sense, instead
74:00 - of storing your HP and
everything for each level
74:03 - to store your initial
stats in each area,
74:06 - and how much you would go up per level.
74:09 - SPEAKER 1: Would it make more sense
to store the amount that you go up
74:14 - per level for your Pokemon?
74:16 - Yes, that is what we're doing.
74:19 - So we have a base--
74:20 - so here's how the split works for
the stats in this case, right?
74:24 - We have base HP, base attack,
base defense, and base speed.
74:28 - A level 1 Pokemon
has-- a level 0 Pokemon
74:31 - has these stats of this species, right?
74:35 - Every Bamboon or whatever
Pokemon that we choose
74:39 - will have whatever we've
allocated it to be it's base HP,
74:42 - base, attack, base defense, base speed.
74:45 - And then the thing about Pokemon
and I mean, a lot of RPGs
74:50 - will sort of do this
thing, but we need some way
74:52 - of leveling up the Pokemon in an
necessarily non-deterministic way.
74:58 - Like two Piggies that level up may
not have the same stats, right?
75:02 - One might have slightly
higher attack than the other,
75:04 - one might have slightly
higher defense than the other.
75:07 - We do this using what's called an IV,
and that's what Pokemon itself does.
75:11 - And it's short for individual
value, this is sort of
75:13 - like the DNA of your Pokemon, right?
75:16 - So this HP IV is separate from your
base attack, base speed, base et cetera.
75:23 - And this basically, it gets compared
against a dice roll every time
75:26 - you level up three times.
75:31 - And this is how I've programmed
it, it's not necessarily
75:34 - how Pokemon itself does it, but
you will roll a dice six times,
75:38 - or three times, one through
six like a normal die.
75:42 - And you'll look to see if that roll
is greater than your IV, right?
75:49 - Or it'll check to see whether your IV
is less than or equal to that dice roll.
75:55 - And if it is--
75:57 - or sorry, if it's greater than
or equal to that dice roll.
76:00 - And if it is, it will increment that
stat by 1 for those three dice rolls.
76:06 - So you can get up to three more,
or you can increase the stat
76:11 - by up to three times per level.
76:14 - But you can only have an IV up to five.
76:16 - So you're rolling against a six, and
you will occasionally not roll a 6.
76:23 - It checks to see
whether or not the IV is
76:27 - greater than or equal to the dice roll.
76:29 - And if it's not greater than or
equal to the dice roll in the event
76:32 - that it is a six, or if
the IV is up to a four
76:36 - for example, which means a
five or six will go against it,
76:39 - then it will not get a stat increase.
76:41 - And this is a sort of simple way of
implementing this DNA based system.
76:44 - It's randomized, but
it's a weighted, right?
76:47 - If you have a higher IV,
you have a higher likelihood
76:50 - of being greater than or
equal to the dice roll.
76:53 - And so that's how we
implement stat increases.
76:55 - And then we need a way of keeping
track of what our stats are,
77:03 - like our actual stats.
77:04 - So our actual HP, our actual
attack, our actual defense,
77:07 - and actual speed that's been
calculated level by level,
77:10 - we need a way to keep track of that.
77:11 - We need level, we need
our current XP, and then
77:14 - we need our-- and the
amount of XP to gain
77:15 - a level, which will get higher and
higher per level, as you can see here,
77:19 - because it takes in the
self.level times self.level.
77:24 - And then it multiplies
that by five times 0.75.
77:28 - And then your current HP.
77:32 - So we're really not storing
our value level by level,
77:38 - we need the base because we
need to know what our base was.
77:42 - I mean, we could effectively
globally reference these variables,
77:46 - but it's minor efficiency
gains at that point.
77:49 - But we need the IVs and we need the--
77:52 - I mean, we need a reference to the IVs,
we need a reference to the base HP,
77:56 - and we need to keep track of
whatever our actual stats are,
78:01 - and then our current HP
always, because our current HP
78:04 - can differ from our actual HP.
78:07 - And in the actual game, you
can have your attack, defense,
78:10 - and speed also vary match
by match, because you
78:13 - have moves that lower your
speed, lower your attack,
78:17 - lower your defense, et cetera.
78:19 - In this case, we haven't
implemented that,
78:21 - so we don't have a current
attack, current defense.
78:23 - But in a more complete implementation,
you would have that sort of thing.
78:26 - Does that sort of answer your question?
78:28 - Is that in the right vain?
78:29 - OK.
78:32 - And so here's the level up code.
78:35 - So like I said, three
dice rolls, one to three.
78:38 - If six is less than or equal to our IV,
so it could be a six, in which case,
78:43 - it would be greater than what
are max IV could possibly be.
78:47 - IVs range from one to five, but if
it's less than or equal to that IV,
78:52 - then we're going to consider
that a stat increase.
78:54 - It's a weighted odd to determine
whether or not we get a stat boost.
79:03 - And it does this for every stat, and
then it returns all of the increases.
79:07 - And this is relevant, this line
95 for a return HP increase,
79:11 - return attack increase,
defense increase.
79:13 - This will be relevant for
assignment 7, because your goal is
79:16 - to take these increases and actually
display them to this user in the battle
79:20 - state when he gets a victory,
or he or she gets a victory
79:23 - and has gained a level.
79:25 - You will display a menu with a
selection that has all of these things,
79:29 - and you'll need this value.
79:30 - So it returns these values here, and
you'll be calling this function any way
79:36 - from your battle state stats level up.
79:39 - Or we'll be calling level up rather,
which returns self stats level up.
79:45 - And that's all a Pokemon is.
79:47 - It's effectively mostly
a data structure.
79:50 - And we use this in our battles to
throw dice effectively back and forth,
79:57 - and have a victor and a loser, and
then gain XP and gain levels that way.
80:05 - So any questions as to how a
Pokemon object class works?
80:12 - Cool.
80:13 - We'll take a quick look at what
the actual definitions look like,
80:16 - which you can probably take a guess.
80:18 - It's very simple, just key names.
80:20 - And then we have the actual
name, we have the sprite names,
80:24 - we have the HP, attack, defense--
80:26 - all the things that get
put into the actual object,
80:29 - they need a reference
to in the definitions.
80:31 - And so Pokemon ultimately
are just this, they're
80:34 - just data, right, which is what we
talked about in a prior lecture, data
80:37 - driven design.
80:38 - The more you can take
all of your Pokemon
80:40 - and make them into, or
anything, Pokemon or any object,
80:44 - and turn it into an easy to
write data structure like this,
80:47 - the easier it is for you to add more.
80:49 - We could easily add, it wouldn't
take too long to create 150 of these.
80:53 - I mean, they wouldn't
be all that interesting,
80:55 - because we don't have
moves implemented yet.
80:58 - But in an ideal world, we'd find
a way to also model moves as data,
81:03 - and therefore, you can just link
moves to your data structure,
81:07 - to your Pokemon object like this.
81:09 - Yes Tony, did you have a question?
81:10 - AUDIENCE: Well, I just wanted
to mention that the paradox
81:13 - games are very good about that.
81:15 - [INAUDIBLE]
81:16 - SPEAKER 1: Oh, like Crusader Kings?
81:18 - AUDIENCE: Yeah.
81:21 - SPEAKER 1: The comment was Paradox Games
are very good about data driven design.
81:25 - I'm assuming you've dug
through their files?
81:28 - AUDIENCE: To some extent,
and also it's just
81:30 - if you play their games for awhile,
it's everywhere, like to the extent
81:33 - that sometimes on the Wiki,
they put the source code up.
81:36 - SPEAKER 1: Oh, yeah.
81:37 - Yeah, no, it's just good game design.
81:40 - Ultimately, if you want to--
81:41 - and their games are large,
they have a lot of content.
81:44 - If you want to have a lot
of content in your game,
81:46 - you need to find a way to take
the burden off the programmer
81:49 - and put it onto the
designer, or at least make
81:51 - it easier for the programmer,
because making source code
81:53 - and debugging source code all day long,
especially for very complicated things
81:56 - is not easy.
81:57 - And it's ultimately not a
desired thing to do, right?
82:01 - It's a lot easier for me to whip up
a new creature in 10 lines of code
82:04 - here and feel good about it than hard
coding a lot of these sort of things,
82:10 - right?
82:11 - So shifting as much of it to data as you
possibly can should be your end goal.
82:17 - So that's what Pokemon defs look like.
82:19 - Before we get into the
actual battle, we want
82:21 - to take a look at what
a battle sprite is.
82:23 - So a battle sprite is what was
rendering onto the screen, right?
82:27 - So we take a look here.
82:29 - That's not a battle sprite,
but almost a battle sprite.
82:33 - That was just a texture.
82:35 - So if we get into a
battle, slowly but surely.
82:43 - All right, so these are battle sprites,
and they don't look much different
82:46 - than a regular sprite,
and they're not that much
82:48 - different than a regular sprite.
82:50 - But they have some functionality that's
important, mainly that functionality
82:55 - where one is flashing, and then
one was being opaque, right?
83:01 - So in order to do both of those things,
we need to store some sort of data
83:07 - within our sprite, right?
83:09 - Yes?
83:10 - AUDIENCE: Zelda for the
invulnerability flashing.
83:14 - SPEAKER 1: Yes, exactly.
83:15 - For what we used in Zelda for
the invulnerability flashing.
83:18 - For the enemy, or I should say, for
whoever is getting attacked, yes.
83:24 - They are getting an opacity flag stored.
83:28 - They have an opacity flag stored in
their object that we can tween, right,
83:32 - we can tween on and off
over the course of time.
83:34 - That's what we did with the entity
in Zelda when it took damage.
83:38 - And we set it to invulnerable,
and while it was invulnerable,
83:40 - it was flashing on and off.
83:42 - But we can't necessarily do that with
the sprite that's blinking white,
83:47 - because there's not really
a like white flag, right?
83:52 - We can't make something
completely white with just a flag.
83:55 - That's something that we actually
need to use a shader for.
83:59 - And so a shader, and we're not going
to get into too much detail about this,
84:03 - shaders are pretty complex,
a little arcane at first.
84:07 - But what they are is effectively
a little program that
84:10 - runs on your graphics card, and that
looks at when you're drawing something,
84:13 - it looks at every pixel depending
on what kind of shader you're doing.
84:16 - But for the sake of this demonstration,
we'll look at every pixel
84:19 - that you're drawing to the screen,
and perform some sort of function
84:23 - on that pixel, and produce
a new value, right?
84:27 - And this is how you get a lot of
really crazy awesome things to happen,
84:31 - but it can be pretty insane.
84:34 - Shader Toy, I think is the website
that has a ton of really cool--
84:39 - I'm not going to pull it up now, just
'cause I don't remember the name,
84:42 - I believe it's shader toy.
84:44 - There's a website where people post
all the shaders that they've written,
84:47 - and you can see a lot of
really crazy stuff, things
84:49 - that you would never imagined were
possible with just code like this
84:53 - effectively, looking
at positions of pixels
84:56 - and [? pictures ?] on
the screen and whatnot.
84:58 - But effectively what this does, this is
a white shader, the goal of this shader
85:05 - is to just turn a
sprite completely white.
85:07 - That's all the goal of this shader is.
85:10 - So it gets a float called white
factor, which [? you'd ?] say here.
85:14 - And then white factor
effectively is just
85:17 - going to be summed onto
whatever the RGB is
85:20 - of that pixel, whatever pixel that
we're drawing when the shader is active.
85:25 - What that has the effect of doing
is, white factor, if it's equal to 1.
85:29 - Here's the thing about shaders
and a lot of this stuff,
85:32 - a lot of the data
structures within shaders
85:35 - are based on floats that
are from zero to one.
85:37 - So if we assign the RGB of something
to a vec 3 that's 1, which is 111,
85:43 - that's going to be 255, 255, 255.
85:46 - Therefore, that pixels RGB
is white, pure white, right?
85:50 - And so what we're doing here is on
our battle sprite, self.blinking
85:58 - and one or zero, remember, that's
the LUA [? turnerri ?] operations.
86:01 - So we're saying, if self.blinking
is true, one else zero.
86:07 - So send our shader white factor based
on whatever value self.blinking is.
86:15 - And so that will have the effect of
the shader getting a one or a zero,
86:19 - and adding a one or a zero
to the RGB of that sprite.
86:22 - And if blinking is set
to true, the sprite's
86:25 - going to basically be drawn
every pixel at 255, 255, 255.
86:29 - Otherwise, it'll get drawn with
whatever that image's pixel value is
86:33 - at that position.
86:35 - Does that makes sense?
86:37 - OK.
86:37 - The syntax is a little
bit weird, but that's
86:39 - what's happening here in this shader.
86:42 - And there's a link here
where I found the shader,
86:44 - but it's a very simple,
very simple shader,
86:47 - probably like one of the
simplest shaders you could write.
86:50 - But it's a great example of what you
can do with a shader, and pretty simply.
86:55 - And it's nice, because you can take
like texture coordinates and do math
86:59 - based on that, or pixel coordinates
and do math based on that.
87:02 - You can pass in like a sine
function for example, in your file,
87:04 - and have that sine function perform work
on like RG or B value of your sprite
87:09 - and do all kinds of cool stuff.
87:10 - It's really neat, like the possibilities
are limitless with shaders.
87:14 - But that's how we get
it to blink, because you
87:16 - can't do that outside of this--
87:18 - I mean, there's probably some weird
way could get it to work as well,
87:21 - but this is probably the simplest way
we can get our sprites blinking white.
87:28 - And so self.blinking just gets
a timer.every0.1 or whatever.
87:36 - We'll actually see that
in the attack state.
87:41 - But that'll flick to self.blinking
between true and false.
87:45 - It'll negate itself over and over again.
87:49 - All right, so that's the battle sprite.
87:51 - Last thing we'll look at is another
extremely simple class, opponent.
87:56 - All the opponent is is it
has a party, that's it.
87:59 - But in a fully fleshed
game, your opponent
88:01 - might have a like trainer sprite.
88:03 - A message that it
says, like a full party
88:06 - of Pokemon, a gold value that
will give you when you defeat it,
88:08 - all kinds of things.
88:09 - But it's here just as
a simple illustration.
88:12 - Yeah?
88:12 - AUDIENCE: [INAUDIBLE] put
a method for on defeat
88:14 - if you want to maybe
have it kind of collapse
88:17 - the room or something like that.
88:19 - That would be another
thing that you could do.
88:21 - SPEAKER 1: Oh, a method?
88:22 - Yeah, we can associate a method
with an opponent called on defeat,
88:26 - or whatnot that will do arbitrary
things, collapse the room,
88:29 - or otherwise.
88:30 - Yes, absolutely.
88:31 - Or even push a new state,
like to like teleport
88:34 - us to a new location in the world map.
88:36 - Maybe we like cleared
the elite four and we
88:38 - want to get teleported to
like the end credits, exactly.
88:42 - Limitless possibility.
88:45 - So let's go ahead and take a look now
while we have just like 20 more minutes
88:48 - or so left.
88:49 - We'll take a look at the battle
state, because the battle
88:51 - state and the states that they're in
are probably the more complicated side
88:56 - of how this works.
88:59 - So a battle state, we have a player, we
have a bottom panel, the bottom panel
89:03 - for when we start the
state just for that part,
89:05 - but otherwise, we're always
pushing things onto it.
89:08 - Whether we've started the battle or
not, because when we are fading in--
89:14 - sorry, yeah.
89:16 - Because when we initialize this state,
we also push a fadeout state onto it.
89:28 - But we don't want to trigger
the tween of the Pokemon sliding
89:32 - from left to right until
after that state gets popped.
89:35 - So we have a flag here, which will get
set to true on the very first update
89:38 - iteration.
89:39 - And then when that
gets set to true, we'll
89:41 - actually tween the Pokemon
going left to right,
89:44 - and kick off all the other
sort of asynchronous processes
89:46 - that exist thereafter.
89:50 - But let's look at the battle one more
time just to see what's going on.
89:56 - So I'm going to walk
until I get into a battle.
89:58 - OK, we got a battle.
89:59 - So notice here, the fade
in happens as soon as the--
90:05 - the slide in happens as soon
as the fade starts, right,
90:08 - as soon as the fade
finishes, I should say.
90:10 - We get a message popped
onto the screen, right?
90:12 - It says a wild X appears.
90:14 - Right, that's the enemy Pokemon.
90:16 - We hit Enter.
90:17 - Turn this down a little bit.
90:19 - We hit Enter, and then we pop another--
90:21 - push another state onto the stack,
another battle message, which
90:24 - is very similar to a dialog state.
90:26 - Says go our Pokemon.
90:30 - And then we push a menu
onto the screen, right?
90:34 - We've got a menu that says,
fight or run, a selection.
90:37 - It's a menu, which has a selection.
90:39 - And then now, this is the
top of the stack, right?
90:42 - So it's the only thing getting input.
90:44 - Everything else is rendering beneath
it, but nothing's getting input.
90:48 - So we have the option
to either fight or run.
90:49 - Let's say we fight.
90:51 - We fight, we got a new state
now, we're in an attack state.
90:55 - Several things just happened.
90:57 - So what happens as soon as
we kick off the attack state?
91:01 - Yeah?
91:02 - AUDIENCE: You get a text
box saying, x attacked y.
91:04 - SPEAKER 1: Yep, so the
first thing we have happened
91:06 - is, a text box that
says, x attacked y, where
91:10 - it could be either us or
the opponent, because it's
91:12 - based on whoever has the higher speed.
91:14 - And then what happens next?
91:16 - AUDIENCE: [INAUDIBLE].
91:17 - SPEAKER 1: Well, it does.
91:19 - So let's take a look at
it right now and tell
91:21 - me what exactly happens as
soon as the text box pops up.
91:27 - So what were the pieces
that happened there?
91:30 - AUDIENCE: Flash.
91:31 - SPEAKER 1: OK, so the
attacker flashes white,
91:34 - right, which is the
shader that we looked at.
91:36 - That's the shader blinking on and off.
91:38 - There's some timer that says,
every 0.1 seconds, blink on or off.
91:41 - And then what happens?
91:43 - AUDIENCE: Then the damage
is dealt. [INAUDIBLE]..
91:46 - SPEAKER 1: Well, damage is dealt,
yes, but what happens visually as soon
91:50 - as the white blinks?
91:53 - AUDIENCE: The other one blinks.
91:54 - SPEAKER 1: The other one blinks.
91:56 - What's the other one blinking?
91:59 - AUDIENCE: I'm not sure.
92:00 - SPEAKER 1: So it's opacity, right?
92:02 - So remember, we're doing the exact
same thing we just did with that white,
92:05 - with the blinking, but we're
tweening every 0.1 seconds
92:08 - the opacity of the defending Pokemon.
92:11 - And then we take damage.
92:13 - Then what happens when we take damage?
92:15 - AUDIENCE: The reverse basically.
92:17 - SPEAKER 1: Well, what gets animated
when the thing takes damage?
92:20 - We've animated the blinking,
we've animated the opacity.
92:22 - AUDIENCE: [INAUDIBLE].
92:24 - SPEAKER 1: The health bar drops, right?
92:26 - So we're chaining
several things together.
92:28 - We're chaining-- first, we're doing
them every 0.1 seconds for six times,
92:32 - blink white.
92:34 - Then blink the other
thing opacity, right?
92:37 - And we're playing sound
effects at the same time too,
92:40 - we're playing a sound effect for the
attack, sound effect for the hit.
92:43 - And then once that's finished,
tween the health bar, right?
92:46 - So we've modified the health
of the defending Pokemon.
92:51 - And then what happens after the first
one, after that process is finished.
92:57 - AUDIENCE: Repeat for the other side?
92:59 - SPEAKER 1: Exactly, repeat the exact
same thing, but for the other side.
93:04 - But what are we doing in
between each of those?
93:06 - We have to do something.
93:07 - AUDIENCE: Checking if somebody dies.
93:08 - SPEAKER 1: Checking if
somebody dies, exactly.
93:10 - And if somebody dies--
93:12 - let's say we die, what happens?
93:14 - AUDIENCE: [INAUDIBLE].
93:16 - SPEAKER 1: Well, we yeah, we
go back to the play state.
93:19 - We fade out to black, and then
we go back to the play state.
93:22 - What happens if we knock out the enemy?
93:24 - AUDIENCE: Go to this screen.
93:25 - SPEAKER 1: Exactly, and
what happens on this screen?
93:28 - So what's the first thing that happens?
93:29 - Well, so recall, what happened
when the Pokemon died?
93:32 - What happened?
93:32 - AUDIENCE: It fell off
its platform thing.
93:34 - SPEAKER 1: Exactly, so that's a tween
probably, right, on his y value.
93:39 - Then what happens?
93:40 - AUDIENCE: [INAUDIBLE].
93:42 - SPEAKER 1: Exactly, we've pushed a
battle message state onto the screen.
93:46 - And then what happens
when we press Enter?
93:48 - AUDIENCE: [INAUDIBLE].
93:50 - SPEAKER 1: What just
happened right there?
93:52 - AUDIENCE: [INAUDIBLE]
text box that says,
93:53 - you earned whatever experience points.
93:55 - Then you get your XP goes up.
93:57 - And presumably, it
checks if you leveled up.
93:59 - SPEAKER 1: Yes, correct.
94:00 - AUDIENCE: [INAUDIBLE] to level up.
94:03 - SPEAKER 1: Exactly, so
when push a dialogue
94:05 - to the screen that says you've earned
x experience points, the XP bar tweens,
94:09 - right?
94:10 - We've gone up to however our ratio
of current XP to next level XP is.
94:15 - We animate our text bar that
way, or progress bar that way.
94:19 - Then we push a fade in
state, right, to white.
94:23 - And then we have to pop
everything off the stack,
94:27 - and then push a fade out
state to the top of the stack,
94:32 - and then we're back to the play state.
94:34 - But if we do level up, we need to play
the right music, play the right sound,
94:41 - and then part of the assignment will
be actually, in that exact function,
94:45 - you're going to need to add
some behavior that will do what?
94:48 - AUDIENCE: [INAUDIBLE]
display the change basically,
94:50 - and what the new one will be.
94:51 - SPEAKER 1: Yes, and what
are we going to need to do.
94:53 - What will we need to do in order to?
94:55 - AUDIENCE: [? Explain, ?]
what was it called?
94:57 - The selection box, but without
the selection part basically.
95:00 - SPEAKER 1: Yes, so once we've
taken-- once we've leveled up
95:03 - and we're in that victory state
of the battle state, right,
95:07 - we need to push a new state,
a new menu state, which
95:13 - has all of those stats and the
amount that they've increased.
95:17 - And then when we press
Enter, presumably, we
95:19 - should pop that off, and then pop
everything else back to the play state,
95:24 - and then do the fade in as normal.
95:26 - And that is the battle
state in a nutshell,
95:29 - a lot of pieces that sort of are waiting
on each other and input and stuff
95:32 - like that.
95:33 - But fairly easy to understand, just
because a lot of it is very simple
95:37 - things that are just chained
together over and over
95:40 - again to produce this sort
of interesting behavior.
95:45 - So here we have sprites,
recall the sprites are what
95:47 - we're going to need to animate those.
95:49 - We have health bars, which
are progress bars, which
95:52 - are just two rectangles that are--
95:55 - ones a line, a black line, and ones
a fill that fills beneath the line,
95:59 - so that we get a sense of
how much is missing, right?
96:06 - We get the width, the height, a color.
96:08 - We can give our progress
bar any color we want to,
96:10 - which is how we get the difference
between, say, a health bar and an XP
96:13 - bar.
96:14 - We just make one red and one blue, and
we draw them in different spots, right,
96:17 - but they're both equally progress bars.
96:20 - And then they get a value.
96:21 - Their value is whatever sort of
determines how much of the rectangle
96:28 - is scaled.
96:29 - And the max is how much that
should be divided by in order
96:33 - to produce a ratio for the total width--
96:36 - a scaler for the total
width, which will allow us
96:38 - to get the sense of an amount missing.
96:43 - And then a player circle
x, opponent circle
96:45 - x for the ellipses, just the graphical
details for the actual Pokemon,
96:51 - so that we can get their stats, so that
we can actually do dice rolls, or not
96:54 - really dice rolls in this case,
but so that we can add or subtract
96:58 - HP based on attack and defense.
97:03 - And so here was the update,
so trigger slide in.
97:06 - So what trigger slide in
does, is a one second tween,
97:09 - which you talked about, right?
97:10 - The Pokemon going left to right,
or left to right, right to left.
97:14 - There x values, just
tweening in over one second.
97:18 - As soon as that's finished, we're
going to trigger starting dialogue.
97:22 - So the starting dialogue is push a
battle message state onto the stack.
97:26 - The battle message state is just like a
dialogue state in that it gets a string
97:30 - here, so a wild something appears.
97:33 - It gets a callback function for
once we press Enter on that.
97:36 - And the callback function is itself
another push of a battle message state
97:41 - that says, go, and then our Pokemon.
97:43 - So notice that we're referencing the
self.opponent.party.pokemon there,
97:47 - and self.player.party.pokemon
there to get the actual name.
97:52 - And then once we've popped that off,
then we push a battle menu state here,
97:59 - right?
98:00 - So let's take a look at
the battle menu state.
98:02 - So this is interesting, because
this is where we actually define
98:06 - the behavior for our menu works, right?
98:08 - Recall, we need something to tells
us what happens when we press Fight,
98:12 - and what happens when we click Run.
98:13 - So when we click Fight,
notice here items,
98:16 - right, self.battlemenu gets
menu, and menu expects items.
98:20 - This items key, this table gets fed
right into the selection, right?
98:30 - And the selection, it
expects remember, a text,
98:33 - because it has to know what
to render at that index.
98:36 - And then an on select function.
98:37 - And that on select
function is the callback
98:39 - that gets executed when you press
Enter at that particular location
98:42 - in the menu.
98:43 - In this case, fight, what that does is
it pops this battle menu state where
98:48 - we no longer need the menu, so pop it.
98:51 - And then push a new take turn state.
98:54 - And then take turn state in this game is
the Pokemon fighting each other, that's
98:58 - what the take turn state is.
99:00 - And it could have been called
fight state, for example,
99:03 - but take turn state is
a little more versatile.
99:05 - If we wanted to maybe make,
maybe one Pokemon wants to run,
99:07 - the enemy wants to run and
we want to fight, right?
99:10 - But you can't always run,
so they should try to run,
99:13 - and then we can still fight them.
99:15 - Or they can use an item, or
we can use an item, right?
99:18 - There's a lot of different
things you can do.
99:20 - Or we want to throw a Poke
ball at them, and if we fail,
99:24 - then they should fight us, right?
99:25 - Take turn is just a
general purpose state
99:27 - that we could repurpose
for whatever use we
99:31 - want to with any interaction
between us and the opponent,
99:35 - whether it's fighting, running away,
or using items, catching them, any
99:38 - of these combinations of things.
99:39 - But in this case, for the sake
of this example, for simplicity,
99:43 - we've only implemented fighting.
99:44 - The we and the opponent fight each
other during this state, which
99:49 - is, one attacks the other,
and then we check for deaths
99:51 - in between both of those.
99:52 - And then go to victory or feinting
depending on which of those holds true,
99:57 - if either.
100:00 - Running is slightly different.
100:01 - So if we run, I've programmed it to be
100%, it will 100% of the time work.
100:07 - In Pokemon, you actually
have a chance to run
100:10 - based on what the delta is
between you and your enemy.
100:12 - So if they're stronger than you, you
actually aren't guaranteed to run away.
100:16 - So what we do here in my implementation
is, we just pop the battle menu,
100:23 - so it's gone.
100:24 - And then we push, you fled successfully
to the screen, this battle message.
100:30 - But there's a difference here versus the
other battle messages that we've shown.
100:36 - I mean, it's not really different,
but it's something to keep in mind.
100:40 - So I'm going to get into a battle.
100:45 - And so first of all, with that message
that you just saw on the screen,
100:48 - I had to actually press Enter, right?
100:50 - I discarded it explicitly
by pressing Enter.
100:56 - And that holds true
also for these messages.
100:58 - It won't do anything
until I press Enter.
101:00 - So I press Enter, and then I press
Enter, and it does it's thing.
101:03 - But notice the difference
between when I hit Run.
101:06 - I'm going to hit Run, I fled,
and it does it on its own.
101:10 - It's not waiting for input, right?
101:14 - So how have we implemented that?
101:19 - Yeah?
101:20 - AUDIENCE: Using timer,
you'd automatically
101:24 - do it the same way you would afterwards,
instead of waiting for you input,
101:29 - you just wait for the timer to end.
101:31 - SPEAKER 1: Exactly, so we use a timer,
and then when the timer is finished,
101:34 - we pop the battle message just like we
would have popped it by pressing Enter.
101:40 - This false flag is what
allows us to do that.
101:43 - We press false and false
is, can we input or not?
101:46 - And we can't.
101:47 - So actually, if we didn't do
any timer thing after this,
101:51 - and we just did that false flag, the
battle message would be there forever,
101:54 - and we could never get rid of it, ever.
101:56 - It would get stuck forever.
101:58 - So we got to be responsible and
say, OK, we're going to put a timer,
102:03 - we're going to call timer.after
0.5 seconds immediately after that.
102:08 - We're going to push a fade in state.
102:11 - And then we're going to do these two pop
operations here as soon as that fade in
102:15 - happens.
102:16 - This first pop will pop the
message, right, this message here
102:19 - that we didn't pop through input.
102:22 - So this is actually garbage
collecting, in a sense, for us.
102:26 - It's discarding the message that
we couldn't discard automatically.
102:31 - And then we're going to pop
the battle state, right?
102:33 - So running will push the battle
message, trigger a timer tween
102:38 - for our timer.after five seconds,
sorry, push a fade in state.
102:44 - And then after the fade in states
done, then pop both of those states.
102:48 - The message and the battle state
take us back to the play state.
102:53 - And that's where we'll be
as soon as that's all done.
102:56 - And that's all that's in
the battle menu state.
103:00 - Any questions as to how the battle menu
works, the difference between fight
103:04 - and run and sort of how those operate?
103:08 - OK.
103:09 - So let's take a look
then at the take turn
103:13 - state, which is the last piece
and the largest piece I would say.
103:19 - This is the most relevant
to the assignment.
103:24 - So we maintain a reference to which
Pokemon is first or second to go,
103:28 - which sprite is first or second
to go, and which progress bar is
103:31 - first or second to go up here.
103:33 - And we do that, like I
said, based on speed.
103:36 - So whichever Pokemon is
faster, and we could have also
103:40 - made this a little bit shorter, just
by keeping the sprites and the progress
103:45 - bars as members of the
Pokemon object, or the class,
103:49 - but since they're kind of
separated, like we don't necessarily
103:53 - want a Pokemon to have a reference
to it's progress bar at all times,
103:56 - or I mean, you could.
103:58 - There's nothing preventing
you from doing it.
103:59 - It would only serve the purpose
of shortening this code here.
104:04 - But we need to keep a reference to
this so that we can call attack here,
104:10 - which is this large bit of
code twice, without needing
104:16 - to duplicate all of that code twice.
104:18 - Does that makes sense?
104:21 - So Tony, did you have a question?
104:22 - AUDIENCE: Well, I was just
thinking, you could probably
104:24 - put that into a helper
function where you just
104:26 - change the order you pass it in.
104:29 - SPEAKER 1: Sorry?
104:30 - Say it again.
104:30 - AUDIENCE: I just kind of feel like,
I guess you could take the code,
104:33 - and you could avoid
duplicating that I guess.
104:36 - 'Cause it's just reversed, so
what you could do is you could--
104:40 - if you passed into a helper
function, which you would just,
104:44 - instead of passing it first--
104:48 - instead of passing it, opponent
Pokemon, player Pokemon,
104:50 - you would pass it, player
Pokemon, opponent Pokemon.
104:53 - And that would probably work I think.
104:55 - SPEAKER 1: Well, you also have
to take into consideration--
104:57 - so the comment was, you could pass in
the player Pokemon and the opponent
105:04 - Pokemon into a function, and then
you reverse them in that function,
105:08 - I'm assuming, have reverence
them and reverse them.
105:10 - But the sprites are
decoupled from the Pokemon,
105:13 - and the progress bars are also
decoupled from the Pokemon.
105:17 - So we could shorten this by making
these four things here fields
105:27 - of the Pokemon objects,
but they're not strictly
105:31 - pertinent to the operation
of the Pokemon object.
105:34 - And it sort of kind of makes
the Pokemon objects a little
105:39 - too, not basically abstract
or lightweight enough,
105:43 - and it only serves the
purpose of this point,
105:45 - of just shortening this bit of code.
105:47 - There's probably a more elegant
way to do it, but it's hard to say.
105:53 - If this code were to get larger, maybe.
105:56 - But the gist of this
is basically to have
105:58 - a pointer to whatever Pokemon, progress
bars, and sprites should operate first
106:04 - in the attack versus what
should operate second.
106:06 - And then the two will trade blows in
order based on who's first and who
106:10 - second.
106:12 - So when we enter the
take turn state, we're
106:14 - going to trigger that attack, here this
function attack, which we'll take in
106:18 - first, second, first, second,
first, second for the Pokemon
106:22 - sprite and progress bars.
106:24 - And then anonymous function,
which get's executed as
106:27 - soon as the attack is finished, right?
106:31 - So this is a code that will pop a
message that gets pushed in attack,
106:35 - and then this is where we
actually check deaths, right?
106:39 - And it will determine whether we go
to victory or faint screen or not.
106:42 - If not, and we return if so.
106:44 - If not, we're going to do
another attack, but see,
106:47 - everything is reversed now.
106:48 - Now it's second, first,
second, first, second, first.
106:53 - So we have the same
function, self attack,
106:55 - which just takes in the attacker.
106:57 - And it's effectively, attacker,
defender, attacker, defender, attacker,
107:00 - defender for the Pokemon
sprites and progress bars.
107:05 - And so the attack function
here first pushes a--
107:09 - well, OK.
107:10 - What does the attack--
107:11 - let's go over it one more time.
107:12 - What do we think the attack
function does in order.
107:18 - We covered them just
a moment ago, but what
107:20 - was the order that happens when
something attacks another thing?
107:24 - Yeah?
107:25 - AUDIENCE: The attacker blinks white.
107:27 - SPEAKER 1: Attacker blinks white.
107:28 - AUDIENCE: Then the
defender blinks opacity.
107:33 - SPEAKER 1: The defender
toggles it's opacity.
107:36 - AUDIENCE: And the health bar shrinks.
107:38 - SPEAKER 1: Health bar shrinks.
107:42 - Exactly, and then that's
basically it for attack, right?
107:45 - Blink, play a sound, blink,
play a sound, shrink the bar,
107:49 - and also we're doing damage
in that function as well.
107:52 - We actually have to change
the status of the Pokemon.
107:59 - So this is effectively
where it starts, right?
108:02 - We place a battle message
state onto the stack that says,
108:05 - the attacker name attacks
the defender name.
108:10 - Notice that it gets false
just like the run message
108:15 - did, because we're not
accepting input here.
108:17 - But it's up to us actually, it done
up here at line 42 of the enter state.
108:25 - But we're going to after 0.5
seconds, play the attack animation.
108:32 - So power up sound every 0.1 second.
108:36 - We're going to member the
blinking flag on the sprite,
108:39 - we're going to toggle it by
setting it not to itself.
108:42 - So if something is not itself, if
it's a truthy value, it becomes falsy,
108:46 - if it's falsy, it becomes truthy.
108:48 - So basically, toggling
between true and false.
108:51 - Limit of six, right,
because remember, every will
108:53 - do something every amount
of time indefinitely,
108:56 - unless you pass in a limit of some
value, in this case, a limit of six.
109:00 - So we're saying, only execute this code
six times, only blink six times, right,
109:04 - only toggle six times,
blink three times, right,
109:07 - because it has to go on and off.
109:09 - And then as soon as those
six iterations are completed,
109:12 - we call the finished function
on that timer object,
109:16 - which takes an honest function.
109:18 - As soon as that happens, we
do the opacity bit, right?
109:22 - We blinked the attackers, so now
we've got to blink the defender.
109:25 - So we play the hit sound.
109:27 - We do the exact same thing that we
just did for the blinking, only now,
109:32 - every 0.1 second, we are setting
its opacity to either 64 or 255,
109:37 - depending on what the value
of its opacity is, right?
109:40 - So we are toggling between 64 and 255.
109:43 - Limit of six, take a
function, calculate damage,
109:47 - which we've just very simply done it,
attack minus defense, right, up to 1
109:53 - though.
109:53 - So if the defense is actually
higher than the attack,
109:55 - which will still do at least one damage.
109:58 - And then over 0.5 seconds,
we take the defenders bar,
110:03 - and we tween the value equal to
their current HP minus damage, right?
110:08 - And then that will set in the bar, in
the progress bar, it'll set its value.
110:15 - And even though the progress
bar is behind state wise,
110:21 - right, it's on the bottom of the stack,
because it's on the battle state.
110:24 - And we're in currently
the take turn state,
110:27 - but because we're still manipulating
the values of that state,
110:30 - and we're rendering every state,
we're actually still manipulating
110:33 - that state regardless of the fact
that it's not on the top of the stack.
110:37 - So that allows us to shrink that
Pokemon's progress bar regardless of it
110:43 - being on the top of the stock or not.
110:45 - Then once that's finished,
once the tween is finished,
110:47 - actually set the current
HP to that amount,
110:49 - because we're only tweening the
progress bar's value, which is
110:52 - independent from the Pokemon's value.
110:55 - And then that's the end of the attack.
110:56 - The attack is completely
finished at that point.
110:59 - So any questions as to
how the attack works?
111:02 - Just a chain of tweens basically.
111:06 - So we do an attack, then check
deaths is the next function.
111:10 - And we're almost finished, I'm going to
kind of go quickly here, it's at 7:30.
111:14 - Check deaths is the player Pokemon
current HP less and equal to 0,
111:18 - or is the opponent Pokemon
current HP less and equal to zero.
111:21 - If the former's true, we need to
faint, and if the latter is true,
111:24 - we need to go to victory.
111:25 - So faint is effectively a battle state,
right, when it says, you fainted.
111:32 - And then what?
111:33 - Remember what happens when we faint?
111:36 - AUDIENCE: [INAUDIBLE] text
box, and then it leaves.
111:41 - SPEAKER 1: It leaves,
do you remember how
111:44 - it leaves as it differs from
like running away, for example?
111:46 - AUDIENCE: [INAUDIBLE].
111:48 - SPEAKER 1: Well, beyond
that, aesthetically,
111:50 - do you remember how it's different?
111:52 - AUDIENCE: [INAUDIBLE]
differently to black, I think.
111:55 - SPEAKER 1: It does.
111:55 - It fades to black instead.
111:57 - So that's how we can
differentiate when we're fainting
111:59 - versus when we're running away.
112:00 - And so that's what we're doing here.
112:02 - Notice that the fade in state
RGB is zero, all of those.
112:06 - So it's going to fade in to 000255,
as opposed to 255, 255, 255, 255.
112:12 - So it's going to be a black
fade in versus a white fade in.
112:17 - And then once we've--
112:18 - this it just sort of a
thing that I implemented so
112:20 - that we can keep playing indefinitely.
112:21 - But once that's finished, restore
the player Pokemon to full health,
112:25 - resume all the field music stuff.
112:27 - And then once we've pushed
a fade out state, 000,
112:31 - and then we've gone back
to the field, let's push.
112:34 - Notice that here it takes a function,
right, after the fade out state's done.
112:38 - Once the fade out is finished-- so as
soon as we're back to the play state,
112:42 - push a dialogue state
that says, your Pokemon
112:44 - has been fully restored, try again.
112:47 - Which will take the context,
and we'll [INAUDIBLE]
112:49 - to press Enter to get past it.
112:51 - That's fainting.
112:54 - Victory is a little bit more robust.
112:58 - So victory is-- do you remember
what happen when we get a victory?
113:06 - AUDIENCE: Well, it has to
check leveling up as well.
113:11 - It says, you've defeated your
opponent, then your XP bar increases.
113:17 - Then if you've leveled up, it
tells you that you leveled up,
113:20 - and then it leaves.
113:21 - SPEAKER 1: So it tells you you defeated
your opponent, XP bar increases,
113:27 - checks for a level up, and then leaves.
113:30 - After displaying the level
up message or not, it leaves.
113:35 - It pops everything back to
the play state, exactly.
113:39 - So remember, the very
first thing that happens
113:42 - though, the opponent sprite gets
tweened over the course of 0.2 seconds,
113:46 - it's y value to virtual
height, which means,
113:49 - all the way to the bottom
of the screen, right?
113:50 - The typical defeated your opponent
from Pokemon sort of animation.
113:56 - Once that's finished,
play victory music,
113:58 - push a battle message state
that says, victory, right?
114:01 - Once that's popped of the
stack, calculate the XP,
114:04 - which is, I just chose arbitrarily
sum all the IVs of that Pokemon times
114:09 - it's level, and that's the XP you got.
114:12 - Push a state that says,
you earned x XP, right?
114:18 - It's false, so that means
it doesn't take input.
114:21 - So that means it's up to us in
order to pop that off the stack.
114:24 - So after 1.5 seconds, we play a sound,
and then we tween that XP bar going up,
114:29 - right?
114:31 - So that's what's going on here,
self.battleState.playerxpbar,
114:34 - we're tweening of the
math.men, of the XP plus XP,
114:40 - or XP to level, because if we don't, it
could go past the edge of the XP bar,
114:45 - because we could go over
our XP to level, right?
114:49 - Let's say we have 10 XP till we
gain a level, we could gain 20 XP.
114:52 - We'd be 10 XP overboard.
114:53 - So we don't want to tween our XP
bar past the edge of the XP bar,
114:58 - it would be a graphical glitch.
115:00 - So a math.men our XP plus
XP, and our XP to level,
115:05 - which will take the
lesser of the two values.
115:08 - Once that's done, it's tweened,
we're going to pop the message off,
115:12 - and then we're going to
actually add the XP, level up.
115:15 - So this is where we level up if
the XP is greater than XP to level.
115:19 - Play a sound, set the XP to the
current XP minus our 2 level XP,
115:26 - which will mean that we'll
have some carry over, right?
115:30 - And then actually call
the level up function.
115:32 - Now here is where--
115:35 - oh, and also after that,
congratulations, you've leveled up.
115:37 - Fadeout white, which is
just a white fade out here.
115:40 - I used it twice, so I
made a function for it.
115:43 - Just pushes a fade in state.
115:46 - Stop the victory music, play the field
music, pop, push a fade out state.
115:50 - So either way, when we've got a victory,
we're going to push a fade out white,
115:56 - or we're going to call
fade out white, correct?
115:58 - So push a battle message
state, and then as soon
116:02 - as we press Enter, because we
leveled up, fade out to white.
116:06 - And if we didn't level up,
but we still got to victory,
116:08 - we still need to fade out white.
116:10 - And so this is where your
assignment is, assignment 7.
116:13 - Assignments 7 is, notice that we
have self.playerPokemon level up.
116:17 - The key thing that we are
going to need to do here
116:19 - is add a menu that shows
us how we leveled up.
116:23 - And if you recall, playerPokemon
level up returns all the stats
116:27 - that you've increased this level.
116:29 - So you can show a menu that just
says, your HP plus that amount, right?
116:34 - You're going to get all four values.
116:36 - It's going to explode to
all four of those values.
116:38 - And then you're going
to create a new battle--
116:42 - or not new battle menu, but a
new menu of whatever you want,
116:46 - but probably on the right side of
some vertical height for items.
116:51 - The only difference
here, the only key thing
116:53 - that you're going to
take into consideration
116:55 - is, and I'll go back to the
slides, because we're actually
116:59 - done at this point going over the code.
117:01 - But the selection items, you won't
be able to actually select anything,
117:07 - it's just going to be purely visual.
117:09 - So you're going to need to edit
selection to have the option
117:12 - to not have a cursor.
117:13 - And this is detailed in the
spec, which was actually
117:15 - released before lecture today.
117:17 - So you can take a look at that.
117:18 - But you'll need to make
a change to selection.
117:21 - But all the pieces are there.
117:23 - It should be a fairly
easy assignment as long
117:24 - as you understand how the
states work, how the menu works,
117:28 - and how to create a menu
based on those values,
117:33 - and how to actually get
the values from level up.
117:35 - So some missing features that we didn't
talk about, which we didn't implement
117:38 - are, for example, the
detailed level of screen,
117:41 - which is your assignment,
monster catching, right?
117:45 - We only have a party of one Pokemon
throughout this whole entire thing,
117:49 - but one of the arguably main appeals of
the game is to be able to catch more.
117:53 - So that would be something to add, to
prioritize probably adding to the game.
117:57 - A field menu so can actually look
at all the Pokemon you've caught.
118:00 - That would be nice, so you can
actually see how much HP they have.
118:04 - In item inventory, because the
game, the regular games have items.
118:07 - You can use potions, you
can find gold nuggets
118:10 - that you sell for a ton of money.
118:12 - Different abilities, currently we only
have basically one fight operation,
118:15 - which is like a tackle.
118:16 - And the game itself,
the regular game has
118:19 - like over 100 different moves
that have elemental attributes,
118:22 - and do different things,
and cause status effects,
118:25 - buff you or your opponent.
118:27 - So adding those is
appealing, and maybe being
118:30 - able to represent them
as data is nice to.
118:33 - Trainers that you can encounter in
the game that have their own preset
118:36 - or randomized Pokemon for to fight.
118:38 - Monster evolution, because that's
like one of the funnest things
118:41 - is taking a really weak
Pokemon, and like raising
118:43 - it to become really strong, and
evolving it at a certain level.
118:46 - Towns, routes, other levels
beyond just our basic square area.
118:52 - Monster breeding, which is
introduced in the second series,
118:55 - so that you can take two
Pokemon and have a chance
118:58 - to get an egg with really good stats
or a really rare Pokemon from it.
119:02 - And then like a day night cycle maybe
where different Pokemon come out
119:04 - at different times of the day.
119:06 - So you are incentivize to
play at different times
119:11 - of the day for that purpose.
119:14 - But that was it for Pokemon.
119:16 - Next week we'll actually
be diving into Unity.
119:19 - So we're actually done with
LOVE 2D, which is a lot of fun,
119:23 - but now we'll be going
into how to make 3D games.
119:26 - So this is a screenshot from the
game we'll be making next week,
119:28 - which is a 3D sort of side scrolling
Flappy Bird esque helicopter
119:32 - game based on a famous web
game called Helicopter Game.
119:38 - And it was sort of one of the
early ancestors to Flappy Bird.
119:44 - On the Wikipedia page, it
actually says that too.
119:46 - I remember playing, it was back in like
2007, or 2006, or something like that.
119:51 - But your goal in this game-- this
is a modified version of that--
119:54 - your goal is your-- everything is 3D,
but it's a side scrolling perspective.
119:58 - So this is called 2.5D for that reason.
120:01 - You're controlling a helicopter,
you're the purple helicopter.
120:04 - And your goal is to in an
infinitely scrolling world.
120:07 - So we'll revisit infinite scrolling,
but in 3D, avoid skyscrapers.
120:11 - So you can see there is a green
skyscraper, crudely modeled.
120:15 - Collect coins, so you can see
there's a coin there, it's a 3D coin,
120:18 - it will always be spinning.
120:20 - Your coins are up at the top right.
120:22 - You'll see a background
that's infinitely scrolling.
120:24 - And then you'll have
jets that will randomly
120:26 - fly above you to sort of give you
another sort of layer or dimension
120:31 - of obstacles to watch out for.
120:32 - And this will teach us a lot of
the basics of how unity works,
120:36 - so we can start getting into even more
interesting things like a first person
120:41 - like sort of core exploration game.
120:43 - And then lastly, when we end
the semester with Portal,
120:45 - we'll look at a couple
of fancy things there.
120:48 - But that was it for Pokemon.
120:49 - Thanks for coming, and
I'll see you guys next
120:51 - time.