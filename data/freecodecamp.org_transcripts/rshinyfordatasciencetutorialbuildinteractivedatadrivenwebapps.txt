00:00 - Learn to use R to build an interactive data 
driven application with the R shiny package.  
00:06 - Dr. Chanin Nantasenamat, also known as the 
Data Professor, teaches this course. Besides  
00:11 - teaching on his YouTube channel, he is also a 
university professor. You probably know that the  
00:16 - our programming language can help you to perform 
statistical analysis. But did you know that you  
00:22 - could use our to build an interactive data driven 
web application. In this course on Free Code Camp,  
00:29 - you will be learning about how you could use 
the our shiny package to build an interactive  
00:35 - and data driven web application that will 
range from a simple application that allows  
00:41 - you to print user inputs, web applications that 
will allow you to display data visualization,  
00:48 - as well as web application that will allow you 
to make predictions from machine learning models.  
00:54 - Finally, you'll be learning how to deploy 
the web applications that you have created  
00:58 - to the cloud by means of the Heroku platform. 
All codes that are used in this tutorial will  
01:05 - be provided in the video description. 
And without further ado, let's dive in.  
01:15 - Before we begin, let's cover the basics of what 
is a shiny package. so shiny is an art package  
01:21 - that allows you to build an interactive web 
application, there are several extension packages  
01:28 - that will allow you to extend the function of 
shiny, including shiny themes, shiny dashboard,  
01:34 - shiny j, s and several others. And 
once you develop your web app in shiny,  
01:40 - then you want to deploy it. So you have two 
options, you want to deploy it on your own server,  
01:46 - for example, using a service like Digital Ocean 
or to a shiny apps.io. There are lots of example  
01:54 - codes that can get you started. And 
this is available in the shiny gallery.  
01:58 - So the links are in the slides. Okay, so 
what we will learn today, first of all,  
02:02 - we will learn about the structure of a shiny 
web application. And then we're going to have  
02:07 - a look at some of the examples of the shiny web 
application. And finally, we will show you step  
02:12 - by step how you can build your interactive web 
application. So let's have a look at the structure  
02:17 - of a shiny web application. So essentially, a 
shiny web app comprises of three components.  
02:23 - So the first component is the user interface, 
which is housed within a file called UI dot r.  
02:30 - And the second is the server function, which 
will perform the processing of the data,  
02:35 - which is housed in the file called server dot r. 
And then the shiny app function will fuse the UI  
02:42 - and server components together. So the UI is the 
front end that accepts the user input values,  
02:48 - the server is the back end that processes these 
input values to finally produce output results  
02:55 - that are displayed on the website. Okay, so 
you see that input data will flow into the user  
03:00 - interface, which is the website that you see. And 
then you will enter data into the text box, and  
03:06 - then the data will be submitted to the server, the 
server processes the information, and then it will  
03:11 - produce the result. And the result is displayed on 
the websites. Okay, and then the user will see the  
03:17 - results. Okay, so let's have a look at some of the 
shiny web applications. So let's go to this link.  
03:25 - Okay, so this is the gallery available from 
SHINee. And you can see that there are a lot  
03:31 - of examples. So there are the integration of 
maps, right insights, shiny application, and  
03:37 - also interactive scatter plots. You can also embed 
Google charts as well, you could perform k means  
03:45 - clustering, you could create some bar charts using 
available data set from the data set package.  
03:52 - And then you could also create a word cloud, okay, 
and there are several others. And then there are  
03:57 - witches like buttons, tables, slider, input, 
slider, K, downloading files, uploading files,  
04:06 - subsetting, data set and all that. Okay, so 
there are several examples on how you can  
04:11 - develop custom shiny web apps. So why 
don't we click on one, the first one, okay,  
04:16 - so this map is interactive. If we click on it, 
we can zoom in. Right, so you click on the color,  
04:31 - and then it will update the map based on 
your input are also Data Explorer. So it's an  
04:38 - interactive table. You can also sort the data as 
well, okay. Or how about a word cloud generator.  
04:50 - Can you could play around with the 
input parameters, minimum frequency  
04:54 - of each word. For example, if it's 25, 
it means that the current word like love  
04:59 - has to Be present at least 25 times. So 26 
times in order for it to be counted here,  
05:04 - how many words are we limiting to be displayed 
here? Okay, and these accept input from the  
05:11 - books of our choice A Midsummer's night dream, 
The Merchant of Venice or Romeo and Juliet,  
05:21 - we have to click on the Change button. k.  
05:32 - k means clustering, using the iris dataset, 
right. Okay. Okay, and then the next one is to  
05:41 - have a look at some of the web applications coming 
out of my own research lab. So let's have a look.  
05:47 - Let's go to code stop bio slash osfp. So as I'm 
a bioinformatics researcher, and data scientist,  
05:54 - so what we do in our lab is we try to apply 
machine learning in order to make sense of  
06:00 - biological data and chemical data as well. 
And so the objective of this web server is  
06:06 - to take as input the protein sequence, and then 
we will predict whether the protein sequence is an  
06:13 - oligomer or a monomer. Okay, so let's click on the 
Insert example data, and then the input will be a  
06:20 - fast a format of the protein sequence. So the 
first line which contains the greater than symbol,  
06:27 - followed by the name of the protein is given here. 
So we see that the first protein is a monomer.  
06:33 - And the second protein is a tetra mer. And let's 
click on the submit button to make the prediction.  
06:40 - Okay, and so we see that the prediction is 
correct on both occasion, because the first  
06:45 - one is a monomer. And it predicts it to be 
a monomer. And the second one is a tetramer.  
06:50 - And it predicts it to be an ollie Gomer. Okay, 
so this is the interface of the prediction web  
06:56 - server. And if we click on the other buttons, it 
will look like any other ordinary website. Okay,  
07:01 - so these are description on how to use the web 
server. And they are written in markdown case.  
07:10 - So this shiny app can also embed markdown inside 
as well. Okay, so we also provide the data set for  
07:17 - download as well. And we host it on the GitHub. 
And if you're interested in reading this paper,  
07:23 - you can click on the link. Okay, so this is 
the paper that we published back in 2016,  
07:28 - in the Journal of Chem informatics. 
Okay, so let's go back to the slide.  
07:37 - And let's get started. We're creating 
our own web app using SHINee. So what  
07:42 - you want to do now is fire up your our 
studio or our studio cloud K. And so  
07:49 - the code that will be used today is available 
on the data Professor GitHub. So if you go to  
07:55 - github.com, slash data professor, 
okay, and then you click on code,  
08:01 - and then find SHINee slash 001 first app. And then 
you want to click on App dot r. And then you want  
08:12 - to right click on the raw button right here. 
And then you want to click on the safelink s,  
08:20 - and then select a suitable position 
where you want to save the file.  
08:24 - And because I already have it, I will just 
click on Cancel, but if you don't have it yet,  
08:29 - click on the Save button. Okay, so let's open up 
the app dot our file right inside the our studio.  
08:36 - Okay, so before we begin a credit to Winston 
Chang for developing this template by which  
08:42 - we greatly modified and simplified to make this 
app dot our file. So if you want to check out the  
08:49 - full version, go ahead here, links are provided 
here. Okay, so in this simplification, we're going  
08:54 - to start with the baby steps. So this web app is 
an interactive web application whereby it will  
09:01 - accept input values in the form of text, primarily 
the given name and surname. So let's have a look.  
09:08 - Okay, so the app will accept input which has the 
given name and the surname Okay, so let's go ahead  
09:14 - and type the given name john and insert name is 
still okay, and so the name john doe will appear  
09:20 - in the output here and the name of the app this 
my first app, you can also modify this to your  
09:25 - own liking, okay, and in this example, we have 
three navigation bar so we intentionally left  
09:30 - it blank here, according to the original template 
by Winston Chang. Okay, so the code that we have  
09:35 - is located on the nav bar dot one so a point in 
notice that you can also create several web apps  
09:41 - inside different navigation bar. Let's say that 
you want to modify the name like let's say given  
09:46 - name is Jennifer. So then you'll see that the 
name is automatically updated. So notice that  
09:51 - there is no Submit button and whenever you type in 
an updated name, it will automatically update the  
09:59 - results. So in our they implement reactive, let's 
have a look shiny, reactive, reactive expressions,  
10:10 - reactivity and overview, okay, so it's based 
on the principles of reactive programming,  
10:15 - which is used by the shiny package. 
So we're not going to go into detail.  
10:19 - But if you're interested, I can also 
provide the links in the file as well.  
10:28 - concepts about reactive 
programming used by SHINee.  
10:35 - Okay, so I'm going to provide 
the link for you, here.  
10:50 - Okay, so a moment ago, we have taken a look 
at how the web application will look like,  
10:55 - which is the end outcome of this code. So let's 
look under the hood, what does the code looks  
11:00 - like? Okay, so in the slides, I've shown to 
you that it comprises of three components.  
11:06 - So let's have a look. So the first 
component is the UI is right here.  
11:11 - So it's on line 19, until lines 43k, lines 
19 until lines 43. This is the UI or the user  
11:21 - interface, and then a lines 47 until 52 is the 
server component. So you're going to notice that  
11:27 - we're not doing anything much here. We're just 
displaying the results. And so the code is very  
11:32 - concise. And the third component is the shiny app 
function. So this thing will piece together the UI  
11:39 - and the server. So it's essentially just saying 
that, okay, this part here is the UI. This part  
11:44 - here is the server and fused in both to create 
a shiny app object. Okay, so that's all there  
11:50 - is to it at the conceptual level. So let's have a 
look at the components inside the UI object. Okay,  
11:58 - so here is using inside the fluid page tag, it's 
using the theme argument, and it's telling that we  
12:06 - want to use the C raelian. theme. Okay. And the 
C rolling theme is the blue theme that you've  
12:11 - seen a moment ago. Let's say I want to change 
it to United. And I can click on the reload,  
12:18 - or I need to save it first. And then I'll click 
on the reload, and then it changes to the United  
12:26 - Can I want to change to say Yeti, save it, 
and then it becomes the Yeti theme. So maybe  
12:33 - you're wondering, what's the available options for 
you. So if you search for shiny themes in Google  
12:40 - key, the first results and just click on it. 
So here, this is how a civilian looks like,  
12:46 - if you like that you could type in zulian there's 
Cosmo Cyborg darkly, paper, lumen journal, flatly  
12:56 - readable? sandstone, simplex, slate, Space Lab, 
superhero, united and Yeti. Let's try superhero.  
13:15 - Okay, so it's john doe. Okay. There you go.  
13:27 - By just default back to civilian. So let's 
envisage the code as modular components. So you're  
13:34 - going to see that inside the UI, you're going to 
have a fluid page, you can within this fluid page,  
13:40 - you're going to define the theme. And inside 
the fluid page, aside from the theme, you're  
13:44 - going to have a navigation bar page, right? So 
the navigation bar page is right here. It's this  
13:50 - bar. And so the name of the app is my first app. 
So this is the name of the navigation bar page.  
13:56 - Inside the nav bar page, there is the tab panel. 
Okay, so tab panel comprises of nav bar, one nav,  
14:03 - bar, two nav, bar, three can inside and out 
more. One, you have the sidebar panel right here  
14:09 - to the left, right, you have here sidebar panel, 
and your sidebar panel contains tag h3, h3 is the  
14:17 - heading third level heading input. And then text 
input is the given name. And the text input is the  
14:24 - type of input. So if you change this to something 
else, it will look differently here. And there  
14:29 - are a lot of widgets, okay, so you can find what 
you want. You can shop for what widget you like,  
14:34 - and then just replace it right here in the code. 
Okay, so the given name is right here, displayed  
14:39 - here. And then this thing here is the default 
value. So let's say that I could type in john doe,  
14:44 - and let's save it and reload the app. So you see 
that john doe will automatically by default appear  
14:50 - in the text box, okay, but I can also leave it 
blank as well. Right. So this is the contents  
14:56 - of the sidebar panel. So the sidebar panel will 
accept The input right and then the main panel is  
15:02 - right here where we see header one output one john 
doe, which is the result. So in main panel one,  
15:08 - right Heather one is inside the h1. So h1 is the 
tag, which is the biggest tag available. And h4 is  
15:15 - a smaller tag, right? So we have in order of from 
big to small, we have h1 and h2 h3, h4, right. So  
15:23 - for the input here, we use h3, if we change it to 
h1, it will be bigger. It'll be the same size as  
15:29 - the header one here, but it's too big. So I'm 
going to change it to just h3 we couldn't even  
15:36 - make this a stream as well. Right, so you've got a 
little bit bigger for the output one here. Right,  
15:44 - so you can play around with changing the options 
here. Okay, and so verbatim text output is simply  
15:50 - a text box that will return the output value. So 
it's just a simple text box, and then the nav bar  
15:58 - to nav bar three, as we have previously mentioned, 
it is intentionally left blank. Okay, so there's,  
16:04 - that's all there is to the UI. But the confusing 
part is how does UI and server interact? How  
16:11 - do they send information back and forth? Right? 
How does UI send the input value to the server?  
16:17 - And how does the server accept the input value? 
Okay, let's have a look right here. So notice that  
16:22 - the text box has this thing called text one. txt 
one right in the given name, okay. And a surname  
16:29 - is txt two, okay. Now, this stat make a note of 
that, how about I put it in the comments t x T one  
16:39 - and T x T two, okay, and make a note of this to 
t x t out. txt or UT okay. So, these two will be  
16:49 - sent to, to the server TFT to will also be sent to 
the server t x t out is generated from the server.  
17:05 - Okay, so let's go back to the slides. 
Okay, why don't I create a new slide.  
17:09 - So let's duplicate this slide. So let's 
call this the first web app. And we're  
17:14 - going to modify this to reflect the contents 
of this web app. So the input data is txt one.  
17:25 - And txt to write and the output is txt 
out, right. So it will send txt one and 62  
17:34 - to the server. And so actually, the server sends 
write txt out and the TTL will be displayed.  
17:43 - displays. txt out. So here txt one 
and txt two will be sent to the server  
17:54 - txt one and txt two here is input dollar sign 
txt one and input dollar sign txt to Okay,  
18:04 - and so the question is, how does it send it as a 
txt out, it's right here output dollar sign txt  
18:11 - out, and it's going to use this function called 
render text. Okay, so there's several render  
18:16 - function like render table render text, right that 
you can modify. So you can also find out from the  
18:23 - SHINee documentation, okay, so this output txt 
out, what is essentially does is it will use the  
18:30 - paste function to combine TF T one and T two and 
separated by a MP space. And then it will produce  
18:40 - the result as the concatenated text of TF T one 
and T two inside the txt out variable. And then  
18:49 - this variable will be called from within the 
verbatim text output, and then it will display  
18:55 - the text inside the text box. That's all there is 
to this shiny web application, it will seem a bit  
19:02 - confusing, but if you get the concepts straight, 
it will be very simple. And you could create  
19:09 - any web application to your own imagination, 
you can make this web application data driven,  
19:16 - you could ask input, you could upload a file of 
the input data and then the input data will be  
19:22 - sent to the server right and then in the server, 
you could create a machine learning model and  
19:26 - then once the machine learning model is built, it 
would then relate a results back into the UI and  
19:33 - then the UI will display the predicted results. 
Okay, so this will be very powerful as a model  
19:39 - deployment approach for your machine learning 
model can there's several tips and tricks which  
19:45 - we use in our research lab, and we can share this 
in a future video. And so if you're finding value  
19:52 - out of this video, please smash the like button. 
Okay, so let me recap this process. In summary,  
19:59 - this app Our file will contain three components 
the UI component, which is the user interface,  
20:05 - it will accept input, which is the txt one and 
txt two, which corresponds to the given name and  
20:11 - the surname. And when you input the given name 
and surname, it will be sent to the server. And  
20:17 - then the paste function will combine tasty one and 
txt two and put it inside a txt out variable. And  
20:25 - then this TFT out variable is embedded inside the 
verbatim text output, which is a text box on the  
20:32 - UI. And as a result, you will see the input values 
that you typed in displayed in the text box.  
20:40 - Okay, so this first web app, which is essentially 
starting from the basics, so nothing fancy here,  
20:47 - just a simple web app where you can type in 
the name, the first name, last name, and then  
20:52 - it will display the result. Okay, so in future 
videos of this series, called the web app in our  
20:58 - we're going to have several other videos. And if 
you have ideas on what application you would like  
21:05 - us to develop, let us know. So please comment 
down below, and I'll see you in the next one.  
21:15 - Okay, so this video represents the second episode 
of the web apps in our series. In the first video,  
21:22 - we covered how you can develop your very first 
shiny web app, and the web app allows you to  
21:27 - enter the first name and last name, and the 
web app will display the output for a sample.  
21:33 - If you enter the first name as john and the 
last name as Doe, then the output panel will  
21:39 - then output john doe. So in this video, we're 
going to show you how you can develop your second  
21:45 - web app in R. And so the web app today is really 
quite simple. The web app will display a histogram  
21:52 - of the air quality data set, particularly the 
ozone levels, and the user will be able to  
21:59 - adjust the bin size, and then the histogram will 
adjust accordingly. Okay, so let's get started.  
22:06 - So what you want to do now is go to the data 
Professor GitHub, so click on the code folder,  
22:14 - and then click on the shiny folder, and then 
click on the 002 histogram. And then what you  
22:21 - want to do now is click on the app dot r, and then 
right click on the raw link, and then save link  
22:28 - as and then save it to a desired destination. 
So since I have already downloaded the file,  
22:35 - so let's open up the app dot our file. So why 
don't we go ahead and run the application.  
22:43 - So as you can see, the web app has the title 
as the ozone level and the side panel shown on  
22:50 - the left as the number of bins as a slider input 
value. So you can adjust this by sliding to the  
22:57 - left or right and then the resulting histogram 
will be updated automatically in real time.  
23:03 - So let's say that we adjusted to seven bins, 
and you will see that in the histogram,  
23:07 - there will be a total of seven bars. If 
you adjusted to 12, then the number of bins  
23:13 - or the number of bars will then be adjusted to 
12. So what is the bin and then in a histogram  
23:18 - is essentially the number of bars and each bar 
represents a range in the value for a sample  
23:24 - from the range of zero to five or zero to 10. 
And so if you adjust it to one bar, then you  
23:30 - will see only one bar here. And if you adjust to 
two bins, you will see two bars, right and etc.  
23:36 - And for a maximum of 50 bars. Okay, so let's go 
back to the code. So in this app dot our file, you  
23:43 - will see that on line number nine, it essentially 
loads the shiny library and line number 10 will  
23:49 - load the air quality data set into the memory. 
And I have already pin the UI in red here.  
23:57 - And the server in red, and the shiny app 
function in red. So as in the previous  
24:04 - video, I have already mentioned that the shiny app 
has essentially three major components consisting  
24:11 - of the UI component, which is the user interface 
and the server component that will accept the  
24:17 - input value from the UI, and it will do some 
processing as shown here. And finally it will  
24:24 - generate the output and the output will then be 
sent back to the UI for display in the main panel.  
24:33 - Okay, so let's recap that again. So this UI 
is the user interface and it will allow you  
24:40 - to specify the name of the title panel here which 
is specified as also level. So let's have a look.  
24:47 - So ozone level is specified by the title 
panel. So you can modify this name if you like.  
24:54 - Okay, so let's say you want to call it just ozone, 
and then you have to save it and then re Load the  
25:00 - app can and the app will then be called ozone. 
Okay. Okay, so this is the title panel here.  
25:06 - And the next block of code here will be the 
sidebar layout. And the sidebar layout will allow  
25:13 - you to specify the sidebar panel and inside the 
sidebar panel will then be a slider input. And the  
25:21 - slider input is essentially the number of bins, 
right number of bins in the UI, and it will have  
25:28 - an input ID of bins, which the server component 
will recognize. Okay, I'm going to show you in  
25:34 - just a moment. And so the minimum value here is 
one and the maximum value of the band is 50. And  
25:39 - the default value is 30. So you see here that the 
minimum is one, the maximum is 50. And the default  
25:45 - value is 30. So you can adjust the maximum to say 
40. And the fall, you can test it with 20. And  
25:51 - then we will save it and reload the app can and 
you're going to see that the web app automatically  
25:56 - updates to 140. And with a default of 20. Okay, 
and you when you slide it, it'll update as before.  
26:03 - So here you can see that the step size 
is one because when you slide the button,  
26:10 - it will incrementally increase by one. Let's say 
that you want to modify the step size to another  
26:16 - number. Can you do that? Yes, you can. So you 
want to specify step to be equal to let's say,  
26:26 - two. And the minimum you want, adjust it to 
zero, save it and reload the app. And here  
26:34 - now the step size becomes 2k. So 18 and then you 
move it it becomes 20 you move it it becomes 22k.  
26:42 - So you notice that I've also modified the 
minimum to be zero because if it's one then  
26:48 - a step size will be 13579. But if you make 
it into a even number, then the step size  
26:54 - will be also even number Okay, so let's have 
a look if the step size is one, it will be 135  
27:02 - right it will be 135. So I cannot select 
20. Okay, so it has to be only odd numbers.  
27:07 - So if you want it to be even number then 
you want to put the minimum to become zero.  
27:15 - Okay. So here now, you can even 
make the step size to be five.  
27:31 - Right? 05 1015 2025 30, right. Okay, so notice 
that the slider input has an input ID of bins,  
27:45 - and let's go into the server component. And let's 
find bins where spins, spins, it's right here  
27:51 - and bins is right here. Okay, so the server 
component will have two bins, the input bins, and  
27:58 - it will be the value of the argument and breaks, 
okay, so it will allow you to specify the number  
28:04 - of bins in the histogram and x will be the 
air quality data set. And then we use the  
28:11 - dollar sign to specify the column called ozone. 
Because in air quality data set, let me stop  
28:17 - the shiny app. First, let's have a look air 
quality dollar sign. And then notice that you  
28:24 - have ozone you have solar you have when you have 
temperature month. They Okay, so we specify ozone.  
28:34 - And we'll also notice that also on has some 
missing data. Right, it has some missing data  
28:42 - here showing us and a the what we're going to 
do with the missing data is to omit it from the  
28:47 - data set using the NA dot omit function and 
then save it back into the x variable. Okay,  
28:53 - and then the bins variable will then 
determine what is the minimum value of the bin  
28:59 - and what is the maximum value of the bin. 
Okay, so moving on to the next function  
29:04 - is the histogram function where x is the input 
data, which is the air quality or sown column  
29:10 - and the breaks will be equal to the number of 
bins that we specify here can so the color will  
29:16 - be discolor, which is bluish color, and the border 
will be black. So this is the blue color mentioned  
29:23 - in here and the border is black. So we see a 
black line and the x label is also on level.  
29:30 - So the x label is right here. And then the main is 
histogram of ozone level. So main is right here,  
29:36 - right? So you can just label or also the main 
text as well. So in this output dollar sign  
29:44 - dist plot, we will use the render plot and then 
this will generate an output called output dist  
29:51 - plot. And then we're going to know this. If we 
screw up to the main panel of the UI component,  
29:58 - the plot output function We'll have an output ID 
equals to this plot. Okay, so the name, this plot  
30:04 - here and this point here are the same object. 
So the server will generate this output object  
30:11 - called this plot and sends it to the UI component 
for display on the main panel. So the main panel  
30:18 - is located right here. Okay, so finally, the shiny 
app function will fuse together the UI component  
30:25 - and the server component. So you're going to see 
that the code communicates between the UI and the  
30:31 - server, right, so the UI will accept the input, 
which is the number of pins and it will send a  
30:37 - number of pins to the server component, and the 
server component will generate the histogram plot.  
30:44 - And the histogram plot will be contained 
within this output this plot and it will  
30:49 - be sent to the plot output function in the 
main panel of the UI. And so you will see  
30:55 - the resulting histogram being generated. And if 
you adjust the value of the input bin number,  
31:02 - then the plot will also update automatically 
using the reactive function of SHINee. Okay,  
31:07 - so you can customize the color 
if you like, let's make it  
31:13 - 003366. Okay, so it's dark blue? Or what if we 
just call it blue? Or how about let's use red.  
31:28 - Okay, so the plot will 
become red, if we use green.  
31:41 - So the histogram will also be green. So here, 
you can customize the color to your own liking  
31:47 - and experiment. And don't forget to upload this 
to your GitHub so that you can start building your  
31:53 - portfolio for data science projects, and then 
you're going to have several repository in your  
31:59 - GitHub in no time. Congratulations, you have 
built your second shiny web application in our  
32:10 - Okay, so this is the third episode of the web apps 
in our series. So today, we're going to build a  
32:17 - play golf web application. So probably you're 
wondering what is a play golf application. So  
32:23 - the play golf web application that we're going 
to build today is going to be based on the  
32:29 - weather data set provided by the weeka data mining 
software. So let's have a look here. So the data  
32:35 - set is a relatively small data set where it has a 
total of five variables. So four variables are the  
32:42 - outlook temperature, humidity, and when and the 
class label would be to play or not play golf,  
32:50 - which is a function of the weather and the 
condition, right, like whether it is sunny  
32:55 - weather, the temperature is high, whether the 
humidity is high, or low or medium, and whether  
33:00 - there is win or not true or false. And then the 
final decision is to either play or not play golf.  
33:07 - Okay. So before we dive into the code, let's have 
a look at how this the web application looks like.  
33:12 - Okay, so the web app looks like this. It's a very 
simple application. So the name of the web app is  
33:19 - play golf. And so here there is the input 
parameters comprising of the four variables that  
33:26 - I have mentioned. The first one is the outlook. 
And so the user can select one of three outlook,  
33:32 - whether it is sunny, whether there is overcast of 
cloud, and also whether there is rain or not. And  
33:39 - the second variable is to temperature. And so this 
is a slider input, so the user can slide the input  
33:47 - value, and then the humidity is also a slider 
input. And then windy is either a yes or a no,  
33:54 - which is a drop down menu. And then when you're 
ready to make a prediction, you just click on the  
33:59 - submit button. Okay, and here you see a prediction 
is being made. And the prediction says yes,  
34:06 - and then we also see the underlying probability 
in that the know has a 27% probability. And the  
34:13 - yes has a 73% probability. And so you could 
play around with this, right? If, for example,  
34:18 - if it is sunny, and the humidity is very high, and 
the temperature is very high, and there is when  
34:25 - should you play golf? No, right? I mean, really, 
if the temperature is high, it's very humid, and  
34:31 - it's very windy and it's sunny, right? Probably 
not. Right. Okay. What if What if the humidity is  
34:37 - low temperature is quite cool, and it's sunny, 
and it's not so windy. Would you play golf,  
34:43 - right? Yes. Right. So there's an 87 probability 
for Yes, and a 13% probability for No. Okay, so  
34:50 - this is the web app we're going to build today. So 
let's go ahead and stop the web app for a moment.  
34:57 - Okay, so what you want to do now is Go to the  
35:01 - data Professor GitHub. And then you want to 
click on the code directory, and followed by  
35:09 - clicking on the shiny directory. And finally 
clicking on the 003, play golf directory.  
35:19 - And then click on the app dot our file. Okay, 
so what you want to do is right click on the  
35:27 - raw link, and then save to file. So I'm going 
to save it into the weather folder, save it,  
35:33 - okay, it's right here, click on it, 
make sure that the app works. Okay,  
35:37 - it works. prediction has been made. Okay, cool. So 
let's just clear up this by pressing on the ctrl  
35:45 - and L button. Okay, so let's have a look under the 
hood, what does the app dot our file looks like?  
35:52 - So the first couple of lines, which is import 
libraries used by this app dot our file. So  
35:58 - this comprises of the shiny package, shiny themes 
package, the data dot table library, the our curl  
36:06 - library and the random forest library. Okay, 
so next line of code would be to create a data  
36:13 - object called weather by reading the CSV, which 
is downloaded from the data Professor GitHub  
36:19 - in the data folder. And the file is called 
weather dot weeka dot CSV panelists have a  
36:27 - look at the data set. What does it look like? 
I'll click on the line weather and then I hit on  
36:31 - the control and enter button. And then let's type 
in weather. Okay, so this is wanting me to see,  
36:37 - let's go with head and then weather. Okay, 
and so we see that there are five columns  
36:42 - outlook, temperature, humidity, windy and play. 
Right. And let's have a look at the data type  
36:49 - of the data set, we see that the outlook 
has three factor levels play has two factor  
36:55 - levels. So these are categorical label. No, 
yes. And the outlook is overcast, rainy and  
37:02 - sunny. Windy is a true and false humidity and 
temperature are integers. And so a random forest  
37:10 - model will be created by using the four variables 
comprising of Outlook temperature, humidity,  
37:17 - windy as the input variable, and the play variable 
here will be used as the output variable or the  
37:24 - variable that we want to predict. Okay, and in 
the data equals to weather, which is the weather  
37:30 - data object here. And we're going to use number of 
three to be five lines read. And because there are  
37:35 - four input variables, we're just going to use em 
try a four. Okay, so let's try building a model  
37:40 - and the model has been built. And let's apply 
the model for prediction, shall we, I mean,  
37:46 - just to test that the code is working properly. 
So let's try applying the model on the input file  
37:54 - that I have previously mentioned about. And so 
we're going to run this line and putting the data  
37:59 - into the variable called test can and we're going 
to assign the factor because if we don't do it,  
38:05 - then it'll provide an error. So before we run this 
line of code, let's just try to make a prediction  
38:11 - model. And we should be able to see a error coming 
up. Okay, so we got this error error in predict  
38:16 - random forest type of predictor in new data do 
not match. So what we notice is that if we type  
38:23 - in the str, and then we type in weather, and then 
we notice that the outlook has factors with three  
38:30 - level, but if we type in str, and then the test 
variable, notice that the outlook has a factor of  
38:37 - only one level. And this is because the input data 
has only one line of data, which is essentially  
38:43 - one row of data. And so the outlook is only sunny 
for the prediction being made has only one role.  
38:49 - And but in reality, it should have three levels of 
the factor. So we're gonna define that by telling  
38:56 - the code that there are three possible factors 
there are overcast, rainy, and sunny. So let's  
39:03 - run that line of code and then run the prediction 
again, okay, and it works. And then print outputs.  
39:08 - And here we go, we got the prediction, which 
is exactly what is going to be displayed on the  
39:14 - web application. Let me show you. Right, we make 
the prediction, and shown here. So this table you  
39:21 - see here is shown right here. So the model works, 
and let's go to the other lines of code. So the  
39:29 - next one would be the user interface. Right. As 
I mentioned in previous video, the user interface  
39:35 - represents the first component of the shiny web 
app. And this is followed by the second component,  
39:41 - which is the server and then this is followed by 
the third component, which is the fusion of the  
39:48 - user interface and the server component using 
the shiny app function. So let's talk about the  
39:54 - UI. So this UI object makes use of the fluid 
page function And we're going to use the theme  
40:01 - equals to the shiny theme united. And so 
the United theme will give the buttons  
40:07 - a red color. So if we change it to thoroughly and 
then we're going to have the thruline color theme,  
40:12 - which is a bit blue. Okay, so please refer to the 
first video of the web apps in our in order to  
40:18 - see the selection of web templates that you can 
choose from. Okay, so let's run the app again.  
40:26 - And I'm going to put the app just about right, 
right here. So the header panel is play golf.  
40:33 - And so this is right here, play golf. So if you 
want to change the name, feel free to do so.  
40:39 - And then the next one is the sidebar panel. So the 
sidebar panel will accept the input parameters is  
40:45 - located to the left, and there will be a total of 
four input. And so the first one is select input,  
40:51 - which is a drop down menu. And if you click on it, 
you get three selections, Sunny, overcast, rainy,  
40:58 - and when you hover on the drop down menu on sunny 
it will secretly under the hood, select the sunny  
41:04 - object, and if you select on the overcast also, it 
will under the hood be equivalent to the overcast  
41:11 - object. If you select on the rainy it will be 
equivalent to the rainy object and the default  
41:17 - is to select rainy, right here we'll select rainy 
as the default What if you change it to sunny  
41:26 - now let's change the value to be a high 
value, let's say like 85 and humidity to be  
41:34 - 95. And it's windy, that's true. Reload the app 
again, right. So high temperature high humidity  
41:41 - windy, Sunny, don't play golf. Okay, so here you 
can change the default value to your liking. Okay,  
41:48 - so we have mentioned about the three data 
objects four here, Sunny, overcast and  
41:54 - rainy. So keep that in mind, we're going to 
make use of data in the server function. And  
42:00 - note that when we will refer to it later on in 
the server function, it will be referred to as  
42:06 - input dollar sign outlook input dollar sign 
temperature input, dollar sign humidity and  
42:13 - input dollar sign windy. Here, why don't we just 
scroll down and have a look here input dollar sign  
42:20 - outlook input dollar sign temperature input dollar 
sign humidity input dollar sign windy, okay. And  
42:26 - then let's move back up. Notice the spelling here 
using the small letter not the Capital One. So the  
42:32 - Capital One Here are the label. So it's exactly 
what we're going to see in the web application  
42:38 - outlook with the colon is right here on the label. 
Okay, actually, you don't have to type in label  
42:42 - if you don't want to, we could just you know, 
delete it, and it will give the same results.  
42:49 - It's just implied, okay. But if you want to add 
the label argument, you could feel free to do so.  
42:57 - Right? But if you do it for one, well might 
as well do it for all. So that would actually  
43:04 - make the code looks a bit more easier to read. 
Right. So let me see here that okay, this is the  
43:09 - object name, Outlook. And the label is outlook 
with a capital O reload the app. Here you go.  
43:16 - Right, it works as usual. So here, this outlook 
here is that outlook object. And this temperature  
43:23 - here is the temperature object. And this action 
button here is the submit button. So this Submit  
43:29 - button is added in order to overcome the reactive 
function. So we're just at the familiar Submit  
43:37 - button so that users can initiate the prediction 
process when they feel ready to do so instead of  
43:43 - having the web app being reactive and making the 
prediction spontaneously upon sliding up and down  
43:49 - of the input values. Because when it's reactive, 
if you move it by one notch, and then you let go  
43:55 - of the mouse, it'll make a prediction. But for 
this one with the submit button, no prediction  
43:59 - will be made until you actually click on the 
submit button to actually this might be a good  
44:04 - thing on the server side because the server will 
work a bit less if the prediction being made is  
44:10 - made only once versus if it is in the reactive 
mode. If you slide the input value and you just  
44:17 - change your mind later on. Then prediction will 
be made at each point off the changing of the  
44:22 - input value of the slider here or even the drop 
down menu, right. But we do it once with the use  
44:28 - of the submit button. Okay, and that's it for this 
left sidebar panel. And then the main panel here  
44:36 - will display the result from the output generated 
by the server function. So we're going to talk  
44:42 - about that in just a moment. So why don't we 
note that the output being generated by the  
44:48 - server component will be called contents and 
table data. Okay. Okay, so let's hop on to the  
44:54 - server function which is the second component. So 
in this data set in Put variable it will comprise  
45:02 - of the first component is it will create a data 
frame which will accept four input values from  
45:08 - the web application compressing off the outlook 
temperature, humidity windy, which is right here  
45:15 - outlook temperature humidity windy, and then it 
will combine it with the play variable, which is  
45:21 - the fifth column of the original data set and then 
it will transpose the data set it will rotate it  
45:27 - in will transpose it and then write a input dot 
CSV file, it will read the input that CSV file  
45:33 - back in into the test variable. And then it 
will apply the factor function in order to tell  
45:40 - that the outlook has three levels. And finally, a 
prediction will be made using the model generated  
45:46 - earlier by means of the random forest and apply 
the prediction model to predict the input values  
45:53 - from the user. And once the prediction is made, it 
will be sent from here into the output dollar sign  
46:00 - table data as the function data set input right 
here. And then it's going to render the table  
46:06 - as we will see in the web application. So the 
table that is being rendered will be right here,  
46:13 - which comprises of three columns to prediction 
the know in the Yes, probability k and this status  
46:19 - output textbox is just essentially this box right 
here. So if we load the app for the first time,  
46:26 - it will just say server is ready for calculation. 
And if we click on the submit button, the text  
46:32 - will change to calculation complete and it will 
be followed by the prediction results table. Okay,  
46:39 - so note that there are two output being generated 
right here output dollar sign contents, output  
46:44 - dollar sign table data. So these two outputs will 
be sent to the UI component right here, table data  
46:51 - and contents, table data will be displayed 
as a table using the table output function.  
46:58 - And the status of the prediction whether it 
is ready for prediction or prediction has been  
47:03 - made will be displayed by the verbatim text 
output function K. And this is just a label  
47:09 - of the status output text box shown right here 
that we're going to have the H three font size,  
47:17 - I mean, if you want to change it to H to 
make it a bit bigger than you will notice  
47:22 - that the font will become bigger, right? So 
I'm just going to make it back to h3. Okay.  
47:29 - So that's all right. And then the last component 
shiny app function, which is fused the UI and the  
47:35 - server together again, you have all of this in 
121 lines of code. And so nothing fancy here,  
47:43 - just a simple web application that you 
can create using the shiny language.  
47:54 - Okay, so this video represents the fourth episode 
of the web apps in our series. And today we're  
48:01 - going to cover about how we can develop a Iris 
predictor, which is a machine learning model  
48:08 - in the background. And the web app allows the 
user to select the input values for the four  
48:14 - input parameters and press on the submit button 
and make a prediction. So without further ado,  
48:19 - let's get started. Okay, so the first thing that 
you want to do is go to the data Professor GitHub.  
48:25 - Okay, once you arrive here, you click on the code 
link, and then find SHINee, and then click on the  
48:32 - serial zero for Iris predictor. So what you want 
to do now is to download the first three files  
48:38 - comprising of the app numeric dot, our app, slider 
dot r and the model dot r, because the other three  
48:45 - files found below will be generated automatically 
when we run the code. Okay, so why don't we just  
48:50 - click on each of them manually. And then for 
each, right click on the raw button and click  
48:56 - on the Save Link As a key and then you select 
the location in your computer where you want  
49:00 - to save the files. So you do this for all three 
files, the app numeric that our apps are and the  
49:06 - model dot r. Okay, so I have already done that. 
And I will go back to the our studio application.  
49:13 - Okay, so before we begin, let's have a look 
at what the the iris predictor web application  
49:18 - that we are going to develop today looks like so 
you want to hit on the run app, you need to make  
49:23 - sure that your working directory is at the folder 
where it contains all of the necessary files to be  
49:29 - run the one that you have just downloaded. 
Okay, and once you have made sure already,  
49:33 - you want to click on the run app button. 
Alright, so this is what the app looks like.  
49:38 - And it allows you to put in the four input 
parameters. And so these are the default  
49:43 - values which you can adjust accordingly. And 
then when you click on the submit button,  
49:48 - the prediction will be made. And 
here the prediction is made to be  
49:51 - that the input parameter is predicted to be a 
Iris setosa flower and the probability of it  
49:57 - being a Irish atossa is 100% sense, okay, 
and so if you change the input parameters  
50:08 - and so the prediction will also be changed 
because the input parameter will be feed  
50:13 - into the predictive model, which is a random 
forest. And then the random forest will perform  
50:18 - the classification. And it has classified this 
input parameter as a Iris virginica with 100%  
50:25 - probability. So let's have a look under the hood, 
what does the code actually looks like? Okay,  
50:29 - so the first code that you want to open up right 
now is the model dot r. So in this tutorial,  
50:34 - we're going to pre build the random forest 
model, and then we're going to load it in,  
50:38 - right. So as you recall, in the previous videos 
of this channel, we have shown you how you can  
50:44 - deploy your predictive model into a RDS file. And 
so what you want to do is you develop the model in  
50:50 - this model, dot our file, and you save it as an 
RDS, right? So you're deploying that. And then  
50:56 - you're going to read that in here on line number 
15, you're going to read the model dot RDS n, and  
51:01 - you're going to give it a name, the name is model, 
and then we're going to use this model for making  
51:07 - the prediction. So the advantage of this is that 
the model is already built. And so there is no  
51:12 - additional workload on the shiny application. So 
it can just readily read in the model and perform  
51:18 - the classification. So this will be beneficial in 
the case in which the predictive model will take a  
51:24 - long time to build the model. Okay, so let's have 
a look at the model dot our file where we will  
51:29 - be building the model. So the first steps that we 
want to do now is to load in the libraries, which  
51:35 - will include the our curl and the random forest. 
So the our curl library will allow us to read the  
51:41 - data Professor GitHub to download the iris data 
set, and then the random forest will be used to  
51:46 - create the prediction model. And we also need the 
carrot package in order to do the data splitting.  
51:52 - Okay, so Iris here will mean that we will create 
a data object called Iris because we're going to  
51:58 - read in the CSV, which will retrieve the CSV 
file from the data Professor GitHub, and the  
52:04 - file is called Iris dot CSV, okay, and it will 
use the carrot package to perform data splitting,  
52:10 - using a ratio of 8020 to 0.8. Here is to 80% 
split, which will go into the training index, and  
52:17 - then we will subsequently use the training index 
to create a training set in which it will perform  
52:24 - slicing of the original Iris data frame, and then 
the remainder 20% will go to the testing set.  
52:31 - So what we're going to do next is we're going to 
write the training set and the testing set out  
52:35 - into the CSV files, right, because that would help 
to remedy possible shuffling of the data that will  
52:42 - go into the training set and the testing set, so 
it will allow reproducibility in the future. So in  
52:47 - the future, we can just read in the training dot 
CSV file, instead of performing the data splitting  
52:53 - again, right. So here, we're going to read in the 
training dot CSV file and give it the same name,  
52:59 - which is the train set Canada, we're going to 
delete the first column, which is the index  
53:03 - number. And then we're going to build a model and 
assign the built model into the model data object.  
53:09 - And once a model has been built, we're going to 
save it as the RDS file. So the we're going to  
53:14 - deploy the model into the RDS format. So in this 
random forest function code, we're specifying that  
53:21 - we want to predict the species of the iris flower. 
And we're going to use all four input parameters  
53:26 - and the data set, we'll be using the training 
set for making the model and then we're going  
53:31 - to assign a entry value, which is the parameter of 
the random forest to be five Heinz red, and we're  
53:37 - going to assign the M try parameter to be four, 
right, and then we're going to assign a true value  
53:43 - for the importance argument, okay, and so so while 
you want to do is you want to run all of this  
53:49 - blocks of code, so you could just Ctrl A, 
select everything and then Ctrl, enter.  
53:56 - Okay, and then the data will be read, and then 
a model will be built, and it will be saved as  
54:01 - the model dot RDS. Okay, so this 
concludes the model dot our file,  
54:06 - and then we're going to close that. And 
then we're going to open up the second file,  
54:10 - which is the app gnumeric dot r k. So let's have 
a look. The first few lines will be importing the  
54:15 - necessary libraries, which will be the shiny 
library, the data dot table, the random forest  
54:21 - package, and then we're going to read in the 
model that we have built in the previous step.  
54:26 - And we're going to assign it into a model 
object, right. And then like in previous video,  
54:30 - the shiny web application will contain three 
components. So the first component being the UI,  
54:36 - and the second component being the server. And 
the third component being the shiny app function,  
54:41 - which will essentially piece together the UI and 
the server. Okay, so let's have a look at the UI.  
54:46 - And we're going to open up the web application 
and have a look right at the same time.  
54:50 - And for readability of the code, I would just add 
additional enters to it and new line to it. So  
54:56 - that when I open up the web browser, concurrently 
The values here won't be hidden. Okay? Save it and  
55:04 - go back to the web application. Alright, so here, 
the name of this web application is called Iris  
55:10 - predictor. And so it is in the header panel here. 
So we put in the iris predictor, if you want to  
55:16 - change the name, feel free to do so right here. 
And then we're going to have the sidebar panel,  
55:20 - which is on the left, and then we're going to 
have the main bar panel, which is on the right,  
55:24 - so as always, the left or the sidebar panel will 
take in the input parameters, and then clicking  
55:31 - on the submit button, which is right here, it will 
send the input parameters to the server function,  
55:36 - and the server will use that input parameters to 
feed it in to the predictive model, which is the  
55:42 - random forest model and make a prediction. 
And once your prediction has been made,  
55:45 - the resulting output value generated will then be 
feed back into the main panel right here. And then  
55:51 - the results will be displayed in the table data, 
which is going to be occurring right below this  
55:56 - text message. So the table data will be shown 
right here, which is the prediction being made.  
56:01 - Okay, so in the input parameters, we're going to 
use the HTML tag and inside we're going to assign  
56:07 - a size of the header to be h3 right, and a name 
will be input parameters right here. So further  
56:14 - showing the versatility of the shiny application 
framework. So notice that the s and l are capital  
56:20 - letter, and this is the ID of this input parameter 
sepal length, and it is case sensitive. So we have  
56:28 - to type it in exactly S is when we're going to 
use it in the next step. So it's going to be  
56:33 - like input dollar sign, and then CBOE dot length. 
And then this will be the input parameter, which  
56:38 - the server function will be using as the data to 
be fed into the random forest model. Okay, and so  
56:45 - the label here will be sepal length. And the label 
means right here, the label and the value is the  
56:50 - default value, which is five and here is five. So 
if you change the default value to 5.1, and you  
56:55 - save it, run the app again. So you see that the 
5.1 will be updated right here in place of the  
57:01 - 5.0. Okay, so the same thing will be for the sepal 
width, petal length and petal width, right with  
57:06 - the label and with the value, which is the default 
value right here. And then the next block of code  
57:11 - here is the action button function. And this will 
be the submit button. So it will overwrite the  
57:17 - reactive function in which when there is no Submit 
button, every time we modify the numbers in here,  
57:22 - a prediction will be made. So that would put a 
heavy load onto the server, because every time  
57:28 - that you update the value here, a prediction will 
be made. So imagine that you update the values 10  
57:33 - times 20 times and 20 predictive models will be 
created. Whereas in a situation where you have  
57:38 - the submit button, you can spend all the time or 
as many times as you need to update the values,  
57:44 - right? Let's see if I went to and then I changed 
my mind, I want to have it 4.9. So do this 10  
57:49 - more times. And so the prediction model will 
not be built, right. So it's going to wait for  
57:53 - you until you click on the submit button and then 
the prediction will be made. Okay, so this will be  
57:58 - more economical on the server side. And also for 
familiarity, where we normally would click on some  
58:04 - button in order to initiate the process of the 
prediction. Okay, and then the following block of  
58:09 - code main panel will be right here. So in the tax 
label h3 status output, it will be this part. So  
58:16 - notice that this block of code is exactly the same 
as the HTML block of code. So I'm just showing you  
58:23 - the versatility of the shiny web application. 
And you could use either one, okay, but this  
58:28 - is the shiny way of doing things, right. So let 
me show you by putting it right here. And then  
58:35 - I'm going to comment that out and put in the APR 
parameters here and then replace the value inside.  
58:44 - Okay, reload the application, right, and then it 
looks exactly the same, right. So you can do it  
58:49 - both ways, right, and then the following text box 
shown here will tell you that the server is ready  
58:55 - for calculation. So this will be displayed upon 
loading of the web application. And upon clicking  
59:01 - on the submit button, the value will be changed 
to be calculation complete. Okay, so this will  
59:06 - be on the server side. So I will show you in 
just a moment. Okay, so we finished with the  
59:10 - UI component. And now let's go on to the server 
component. And so here we're going to load in the  
59:16 - function, okay, so this block of code here will 
be the input parameters, which will be obtained  
59:23 - from the UI component where the user will input 
the input parameters and click on Submit button.  
59:28 - And upon doing that, all of the input parameters 
will come in as shown in this block of code here.  
59:34 - And this block of code will essentially generate 
the input CSV file, which will be read into the  
59:39 - test object and then apply the model to 
make a prediction on this test object.  
59:45 - And once the prediction has been made, this block 
of code data set input will contain the prediction  
59:50 - and the prediction value will be inserted right 
here, right and it's going to be encapsulated by  
59:56 - a output table data variable name and then 
This thing and then the input dollar sign,  
60:02 - and then the output dollar sign table data will be 
sent to the main panel in the UI to be displayed.  
60:09 - So it's right here, right. So this one will 
come from the table data right here, table data,  
60:14 - right this highlighted in blue, and it will 
be coming from the prediction results table,  
60:20 - right, which we use the render table function 
here, and the data set input here will contain  
60:25 - the prediction which is coming out from the output 
data object. Okay, so let me go specifically line  
60:32 - by line here. So a data frame will be created, and 
then name will be the name of the Heather variable  
60:37 - name on the first row, and then the values will 
take and the input parameter value from the UI.  
60:43 - So input dollar sign, sepal length, sepal width, 
petal length, petal width will come from the  
60:48 - input text box right here 5.1 3.6 1.4 2.2. So 
these text box will be the input dollar sign,  
60:55 - sepal length, sepal width, petal length, petal 
width, okay, and then we're going to create a  
60:59 - data frame. And once we have done that, we 
will write it out as a input dot CSV file.  
61:04 - Now we're going to read it back in, and then 
we're going to put it into the test object,  
61:09 - and then we're going to create a output object 
and a data frame will be created. And we apply  
61:15 - the prediction function in order to make 
a prediction using the random forest model  
61:20 - on the input test data. And once the prediction 
has been made, we will also tell the probability  
61:27 - in three digits Okay, and once a prediction has 
been made, it will then be sent to this output  
61:33 - data object and it will print it out and it will 
be representing the data set inputs, and this  
61:39 - data set input will be inserted into the render 
table function, and a table will be generated  
61:45 - to show you the output prediction results shown 
right here. Right. Okay. So that's essentially  
61:51 - it for this Iris predictor in the numeric form. 
So let's close this and hop on to the next one.  
61:59 - Okay, so now we're going to proceed with the app 
slider version. And before doing so you want to  
62:05 - clean the workspace environment. So click on the 
broom button. And then after you have done that,  
62:09 - then you want to click on the app, slider 
dot r and then Ctrl, a, and then Ctrl, enter.  
62:17 - Right, and then the web app will be loaded. So 
you see that now instead of a tap spots where  
62:22 - we put in the numerical value, you're going 
to have a slider, right and then you click on  
62:26 - the input parameter by sliding here, and then 
after you're satisfied with the input values,  
62:34 - then you will click on the submit button, and 
then the prediction will be made. And as always,  
62:38 - it looks exactly the same, but the only difference 
is the input parameters will have the slider bar  
62:44 - instead of the textbox. Okay, so let's have a 
look under the hood. So what new code did we  
62:49 - add to this file, so we've added line 1718, and 
19. And then we've also added two new arguments,  
62:58 - which is the minimum and the maximum argument 
into each of the inputs. And we also change the  
63:04 - name from numeric input into slider input. 
And that's essentially it, we just change  
63:10 - a couple of lines of code and the web app will 
look like this. Instead of a numeric text box,  
63:15 - we're going to have a slider bar. So the value 
of the minimum here will be taken as the minimum  
63:22 - function and then the train set dollar sign simple 
link, right. So I don't have to manually put in  
63:27 - the minimum value or maximum value, but I will 
do this programmatically. So I'm going to use  
63:32 - the minimum function and inside the minimum 
function as the argument, I'm going to say,  
63:37 - Okay, I want to have the train set object. And I 
want to have the simple link column. And I want  
63:43 - to know what is the minimum value, right, it's 
going to be like this. So let me close this,  
63:47 - and I'm going to read in the file. So let me 
show you how it looks like. And if I run the  
63:54 - train set, it will look like this. And then 
I'm going to run this line and then notice that  
64:02 - the first column will be gone, right, I don't 
want the index to be shown. So I just deleted out.  
64:07 - And then when I say train set dollar sign 
sepal length, where they get will be this,  
64:13 - so it's going to be the values of only the first 
column. And upon adding the minimum function  
64:20 - in front, I'm going to get the minimum value. And 
if I use the maximum function, I'm going to get  
64:28 - the maximum value of this column. So the minimum 
is 4.3. And the maximum is 7.9. So instead of  
64:34 - putting in the values manually, 4.3 7.9, I'm going 
to do it programmatically, and it's going to be  
64:40 - so much easier, right? And then I just put it 
in right here. And that's all for modifying the  
64:46 - code and everything else works exactly the same. 
And you get a new feel to the web application  
64:52 - and it's not that difficult. Okay, So play around 
and let me know what kind of web application you  
64:58 - want to be made and Or the input data that 
you want me to use for making the web app.  
65:06 - Okay, so today represents the fifth episode 
of the web apps in our series. And today we're  
65:13 - going to cover about how you can develop a BMI 
calculator. So if you're wondering what is a BMI,  
65:21 - so essentially, BMI stands for body mass index, 
and it is computed by dividing the weight in  
65:29 - kilograms by the heights in square meters. So for 
example, if you weighed 70 kilograms and you are  
65:36 - 170 centimeters tall, then you would first have to 
convert the height to a meter. So 170 centimeters  
65:45 - would then become 1.7 meters. And according 
to the equation, you would take your weight,  
65:51 - which is 70 kilograms divided by 1.7 meter 
squared, okay, so let me calculate that. So 1.7  
66:02 - times 1.7, would be 2.89. And if I weighed 70 
kilograms, divide that by the squared heights,  
66:19 - then my BMI would be 24.2. Okay, so let's have a 
look at the scale of the BMI in adults. So if you  
66:28 - have a BMI below 18.5, then it would mean that you 
are underweight. If you have a BMI in the range  
66:36 - of 18.5 and 24.9, then it means that you have a 
healthy weight. And if your BMI is between 25 to  
66:46 - 29.9, it means that you are overweight. And if you 
have a BMI of greater than 30, then you are obese.  
66:55 - Okay, so in the previous example, a BMI of 24.2 
would mean that the weight is a healthy weight.  
67:04 - So without further ado, let's get started in 
developing our BMI web application. So you  
67:10 - want to go first to the GitHub of the data 
professor. And so click on the code folder,  
67:21 - find shiny and click on the shiny folder. 
And then find the 005 that BMI click on that.  
67:33 - And then you want to download both the 
about.md and the app dot r into your computer.  
67:40 - So why don't we do that, right, right 
click on the raw to save link as because  
67:47 - we're going to download it into a BMI folder. We 
save it there. And then download the second file,  
67:58 - right click on the raw link, safely add as save 
it to the folder BMI. Okay, and now we have  
68:11 - to upload the folder. Okay, there you have it, 
you have two files at that R and about.md. So  
68:18 - let's have a quick look at what this file look 
like. So as you show the app dot r is the art  
68:24 - code comprising of the three major components, the 
UI, the user interface, number two is the server.  
68:31 - And number three is the signing out function which 
fuses both the UI and the server function. And in  
68:37 - the second file, you have the about.md. So this is 
written in the markdown language. And it's going  
68:45 - to be used by the app dot our file. So we're going 
to see that in just a moment. So before we dive  
68:53 - deep into the our code, let's have a look what the 
web application looks like. Click on the run app.  
69:04 - Okay, so this is a simple web application where 
you can put in your input height and your weight,  
69:12 - so the height will be in centimeters and the 
weight will be in kilograms. So the minimum  
69:18 - value here is 40 for the heights, and 250 for the 
maximum value, and for the weight, the minimum  
69:26 - value is 20. And the maximum value is 100. So 
please note that this BMI calculator is developed  
69:33 - for adults and it's not suitable for children. 
If you want to develop a BMI for children, then  
69:40 - we will have to refer to this second link here. 
Okay, so as you notice that when they click on  
69:45 - the about link on the navigation bar, it shows 
the information in the About page. So originally,  
69:53 - the code was written here in markdown language and 
here in the website. It displays it as a Normal  
70:00 - webpage. So here you can add boldness to the 
text, you can add superscript make it stand out  
70:08 - as an equation, you could add italic font, right. 
So all of this is within the markdown language,  
70:15 - right? For example, if you for example, if you 
use two asterisks, it will mean that the tests  
70:21 - will be in bold text. So meaning that you have 
to use two asterisks before and after the test,  
70:27 - you want to meet both. And if you use the for 
hash tag, it means that you are going to use the  
70:32 - Heather level for tag, which is the h4 tag 
in HTML. And if you're using the greater than  
70:39 - symbol here, it means that it's going to display 
this light gray bar to the left. So you know that  
70:46 - it's a equation. And if you use one asterisk, then 
it means that the tax will be in Tillich form,  
70:53 - right. And here we use it for hash 
tagging in and so it becomes a header.  
70:58 - And then we make the BMI calculator in Italy 
form by using the asterisk before and after,  
71:05 - and even add the links to the website, right. 
So the taps that you want to make into a link,  
71:10 - you have to put that in bracket and immediately 
following that, you have to put in parenthesis the  
71:16 - URL of the webpage. And so this is format to like 
a normal web page. And so the web application,  
71:23 - and so the web application, it's mobile friendly, 
and you can use it on your mobile phone, okay,  
71:29 - it would look something like this on the phone. 
And if you click on it, and you get the BMI,  
71:34 - right, in my previous example, a 
height of 170 and a weight of 70,  
71:39 - you will get a BMI of 24.2 to 145. And because 
we're rounding it, and therefore we get 24.22.  
71:46 - Okay, so this web application seems simple enough, 
okay. And so let's dive deep into the code. Okay,  
71:52 - so let's have a look at the code of the app dot 
our file. So the first two lines here will be the  
72:00 - loading in of the library package of shiny and 
shiny themes. And then following that we have  
72:07 - the user interface. So inside the UI optic, it's 
going to be the fluid page function. And here,  
72:13 - we will define that we're going to use the 
shiny theme of united and first run the app and  
72:20 - have a look. So here at the nav bar page function 
shows that we're going to use the name of this  
72:26 - navigation bar to be BMI calculator. And then the 
tab panel will have the first navigation tab here  
72:34 - to be home. Okay, and inside top panel here, we're 
going to use the sidebar panel and the main panel.  
72:42 - So as usual, the sidebar panel is right here to 
the left, and to the right, in the status output,  
72:48 - we're going to have the main panel, right so the 
sidebar panel will contain the input parameters,  
72:55 - which comprises of two input parameters, the 
height and the weight, and we're using a slider  
73:01 - input, so you can slide the bar here, and then you 
get the desired value, click on the submit button,  
73:08 - and then you get the calculated BMI value. Okay, 
so the slider input here is responsible for this  
73:16 - slider button. And so the name of this slider 
input is called height here in label height.  
73:23 - And the first one will be the ID of this specific 
slider inputs. And so this slider input has an ID  
73:30 - of heights, notice the small h and then the second 
slider input has a value of weights and notice the  
73:37 - small W and so these two slider input will then 
be used in the next step, it will be used by the  
73:44 - server function as the input dollar sign 
weights and input dollar sign heights in order  
73:50 - to calculate the BMI, okay, and then the action 
button function will be the red button that you  
73:55 - click to initiate the calculation process. 
And so the main panel will have h3 tag here  
74:02 - showing the status outputs Okay, and then the 
verbatim text output will contain the contents  
74:09 - ID, which is from the output in the server 
function. And in the table output is also  
74:15 - from the output of the server function, it is 
called the table data. And this is the table  
74:21 - data containing the computed BMI value. So let 
me recap that again. So here the slider input,  
74:29 - we have to work them height and weight and so it 
will be referred to as input dollar sign heights  
74:34 - input dollar sign weights. And as the user 
slides this value, it will adjust the value  
74:41 - to the height parameter or the weight parameter 
and the input dollar sign height value and the  
74:47 - input dollar sign weight value will then go to 
the server function. I will show you right now,  
74:54 - right here. So we go to the server function in 
the equation that we're going to create puti BMI.  
75:01 - So here we're taking the input dollar sign weight, 
dividing it by the in parenthesis, the input  
75:08 - dollar sign height divided by 100, right, because 
we want to convert the centimeters to become  
75:14 - meter, so we have to divide the centimeter value 
by our friends read, and that will then make it  
75:20 - a major form. And then we're going to multiply the 
height by itself so that we get the squared height  
75:27 - value. And then we're going to divide the weight 
by the height in order to get the BMI. And we're  
75:34 - going to encapsulate the BMI value inside a data 
frame so that we can display it in the final  
75:40 - output here below in the output contents, it will 
show that the server is ready for calculation or  
75:48 - the server has already completed the calculation. 
So this will be modified by the submit button,  
75:55 - the red button that we clicked right here. So 
when we don't click the button, it will say  
76:00 - server is ready for calculation. But upon clicking 
on the red button, the BMI will be calculated.  
76:06 - And then in this text box, the text will change 
to calculation complete kn in the following output  
76:13 - results here is called the output dollar sign 
table data. And inside here, we're going to  
76:19 - use the render table function. So the results 
from the data set input will be the computed  
76:24 - BMI value right here in the print BMI. So let 
me recap again, let's have a look at the web  
76:31 - application again. So this web application will 
take two input parameters, the height and weight,  
76:38 - and they are in the centimeter unit and the 
height and the weight will be referred to as  
76:43 - input dollar sign heights and input dollar sign 
weights. And upon clicking on the red button,  
76:50 - it will be sent to the server function into this 
BMI calculator function. So it will then take the  
76:58 - input weights and the input height and perform 
the calculation and return the BMI value. And  
77:04 - then we put the BMI value into a data frame. And 
then we print it out and the results of the BMI  
77:10 - is printing out is part of the data set input 
variable. And that is called within the render  
77:16 - table function of the output dollar sign table 
data and the output dollar sign table data  
77:22 - will go to the main panel right here in the 
main panel to be displayed in the table output.  
77:30 - And it looks like this right here. So you see 
that it's called BMI and then we have to BMI  
77:36 - value right beneath it, right. And that's all 
there is to building this BMI web application.  
77:42 - So you can play around with this code. And you can 
change the default value, for example, the height,  
77:48 - you can make it 180 and the value of 
the weight, you could make it say 75,  
77:54 - right and then run the code again. So the default 
value then becomes updated to be 180 and 75.  
78:00 - So let's say that you want to update the 
maximum value to be 300, minimum value to  
78:04 - be 50. And the weight, you want to update 
it to say 30. And the maximum would be 120.  
78:15 - And then we load the application and here you 
see the minimum values and maximum values are  
78:20 - updated accordingly. So you see here, 
if the weight is maintained the same and  
78:25 - the height increases, then the BMI becomes less. 
But if the height decreases, then the BMI is high,  
78:33 - right because of the equation 
of the BMI, whereby the  
78:37 - weight is divided by the height squared, okay, 
and so you can play around existing values,  
78:43 - playing around with the template. So let's say 
you want to change the United theme to become a  
78:48 - Boolean. Save it, reload the app, and 
here you go, you get a different colored  
78:55 - web application. Right. So the types of theme 
could be obtained by looking at the websites.  
79:04 - You can Google that Google for shiny themes, 
click on the click on the art studio.github.io  
79:12 - slash shiny themes. So I'll provide the link in 
the description down below. So check that out.  
79:22 - In this video, I'm going to show you how 
you could deploy a shiny web application.  
79:27 - And without further ado, we're starting right 
now. Okay, so the first thing that you want  
79:31 - to do is head over to the GitHub of the data 
professor. And you want to click on repositories,  
79:40 - then find and click on the iris, our Heroku.  
79:47 - And so all of the files that are needed to deploy 
your app is found here. So feel free to clone this  
79:53 - to your own GitHub or also you could download the 
entire folder content here by clicking on the code  
80:00 - and then download zip file. So let's have a 
look here. So you're gonna see that we have  
80:05 - the UI dot r, which is the user interface. And we 
also have server dot r, which is the server side  
80:13 - component of the web app. So essentially, the our 
shiny web app will be comprised of two components,  
80:19 - the user interface and the server component. And 
then we're going to have the training data set  
80:24 - and the testing data set as the CSV file. And the 
actual model will be contained within the model  
80:31 - dot RDS. And so the machine learning model is 
saved as the model dot RDS. And it will be loaded  
80:38 - into the web application when we run it. And then 
there are two additional r files. Let's have a  
80:44 - look. So the first one is in that dot r. And so 
let's have a look here. So it will allow us to  
80:51 - install the necessary libraries. So we're going to 
install the random forest and the data dot table.  
80:59 - And the run dot r will allow us to run the R 
shiny and assign the proper ports. Okay. And  
81:06 - so that's all there is to having the necessary 
components for deploying your our shiny web  
81:12 - application. So let's head over to Hiroko. And 
so you want to click on new create new app.  
81:20 - And then you want to give the app a 
name. So let me call it VP, Iris, our  
81:27 - create app. And then I want to connect to GitHub. 
And I'll find Iris or he Roku. So for your case,  
81:38 - you want to find your own GitHub and you want 
to find your own RSR he Roku and then connect.  
81:48 - And then this is very important, because you 
want to click on settings. And in order to have  
81:55 - the support for our, you're going to need to add 
the custom build pack. And so you want to click on  
82:02 - the Add build pack. And you're going to notice 
that there are some officially supported build  
82:09 - packs. So by default, you're going to have Python, 
right, and you're going to have others like PHP,  
82:14 - Ruby, Java, node j s. And so for our we're going 
to use a third party. And the third party link to  
82:22 - the build pack for R is given here. So I'm going 
to provide you this link in the description of  
82:28 - this video. So you want to copy that and then put 
it here as well. And then click on save changes.  
82:34 - And then you're going to see that it has been 
added successfully here. Now you want to head  
82:39 - back to deploy, scroll down and you want to 
click on deploy branch in the manual deploy.  
82:49 - So at this point, you want to take a break, grab a 
cup of coffee and wait for the web app to deploy.  
82:58 - So we're gonna see the log 
of what is happening here.  
83:01 - So initially, it is installing version 3.6, 
point three here. And it is downloading  
83:06 - the bill pack directly from Amazon Web 
Service, and also having shiny as well.  
83:16 - Right, so it's installing 
the data dot table library.  
83:21 - And right now it's building the environment.  
83:27 - So this web application has already been built 
in a previous video. So the link to that video  
83:34 - will be provided in the description down below. 
And in the meantime, maybe I could show you that  
83:46 - shiny and it is number four Iris predictor.  
83:53 - And so you're going to notice that we've been 
using the testing and training and for the app,  
84:00 - we divided the components of UI and 
server into these separate files.  
84:10 - Okay, and so it's compressing the environment 
from 499 megabytes to 121 megabytes.  
84:21 - Although the our packages occupies 121 megabytes, 
okay, so it has compressed it down to 152.  
84:31 - And it is deploying the web application 
to dp that's Iris dash r dot e Roku  
84:37 - app.com. And so in just a moment, you're going 
to see a link to view the deployed websites.  
84:46 - Okay, finished. And so it says that your app 
was successfully deployed. Let's click on it.  
84:54 - Alright, so it says here that server is ready 
for a calculation. Let's submit All right,  
85:01 - so predictions seems to work and it is predicted 
to be setosa with the probability of 100%.  
85:13 - k this predicted to be pseudoscience. Well,  
85:19 - same thing she told us and now 
it was predicted to be virginica.  
85:33 - 100% virginica. Thank you for watching 
until the end of this video, and I hope  
85:38 - that this video was helpful to you. And for 
more tutorials in data science, Bioinformatics,  
85:44 - as well as Python and our coding tutorials, please 
check out my YouTube channel at the data professor  
85:50 - and also my new and second YouTube channel 
decoding professor. And you can also find  
85:55 - me on the medium platform where I blog about 
data science as well as doing Python tutorials.  
86:01 - And last but not least, I would like to thank 
Free Code Camp for this awesome collaboration.  
86:06 - And please don't forget to smash the like button, 
subscribe if you haven't already. And until next  
86:10 - time, the best way to learn data science is to 
do data science, and please enjoy the journey.