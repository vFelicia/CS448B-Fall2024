00:03 - Hey programmers, I'm Alvin l come to our course
on dynamic programming. So dynamic programming
00:08 - is one of my most favorite topics to teach.
But unfortunately, I feel like dynamic programming
00:12 - also has a reputation for being a very difficult
topic. That being said, I think dynamic programming
00:18 - can be very intuitive. If we actually take
a nice gradual progression through the material,
00:23 - right? A lot of students have this habit of
just trying to attempt a pretty hard dynamic
00:28 - programming problems, without going through
the necessary steps of really understanding
00:32 - the material, right? It goes without saying,
if you want to do well on those data structure
00:35 - and algorithm interviews, you definitely need
to know dynamic programming. So I hope to
00:39 - give you all the background knowledge, you
need to really crush those types of problems.
00:43 - Now, that being said, What problems are we
going to solve throughout the course? Here
00:47 - are a few examples. So one question I can
ask you is to calculate the fourth number
00:50 - on the Fibonacci sequence seems like a very
easy problem, can also ask you to count the
00:54 - number of different ways to move through a
six by nine grid, or something different,
00:58 - like given a set of coins? How can we make
27 cents in the least number of coins? A final
01:03 - example would be given a set of substrings?
What are the possible ways to construct a
01:08 - string potent pot? And all of these questions
really fall under the umbrella of dynamic
01:14 - programming. And this is really why I think
the topic has such a bad reputation or being
01:18 - very difficult, because the problems ranged
so much, right? It looks like these problems
01:23 - are totally different. And there may not be
any underlying mechanics that we can use to
01:28 - tackle all of them. But the short answer is,
we really can if we have the correct way of
01:32 - thinking about these problems. That being
said, let's go over the overall format of
01:37 - this course, in this course, I think our key
to victory is going to be to really visualize
01:41 - all of these algorithms, right? So we're going
to spend a lot of time drawing things on the
01:45 - whiteboard, as well as visualizing things
with animations. To me all the heavy lifting
01:50 - on an algorithm interview is really done when
you come up with that picture, right? When
01:54 - you describe that process, and then translating
it into some code is really the easy part.
01:58 - Right? The hard part is designing the algorithm
in the first place, right? So we're going
02:02 - to draw out of things to make sure we understand
the structure of the problem, as well as coming
02:07 - up with a solution. And then once we're really
happy with that pen and paper process, then
02:11 - we'll hop into my editor, and we'll solve
it in some code, we'll probably have to go
02:16 - back and forth, until we end up with an algorithm
that runs in an efficient amount of time,
02:21 - right. So it goes without saying, we're also
going to analyze the time and space complexity
02:25 - of all of our solutions. I'll be writing my
code in JavaScript, but you'll find it very
02:29 - easy to translate our solutions into the language
of your choice. So in this course, on dynamic
02:34 - programming, we're going to divide the material
into two main parts. Part one is going to
02:38 - be about memoization. And then Part two is
going to be about tabulation. And don't sweat
02:43 - it if you have no idea what those two terms
refer to, don't worry, we'll reach all of
02:47 - that material step by step together, I think
you're going to realize if we actually learn
02:52 - these things in all very logical progression,
we're almost like discovering these algorithms.
02:56 - And I don't just have to tell us what the
algorithms are. So in terms of prerequisites,
03:00 - I won't assume you know anything about dynamic
programming, but I will assume that you understand
03:05 - a little basic recursion, as well as some
basics of complexity analysis, right. So you're
03:10 - sort of familiar with big O notation. And
I'm sure that we'll be able to review some
03:14 - of that notation as we move along. So I think
with all that out of the way, and no further
03:20 - ado, let's hop into the course. Alright, so
where should we start? Well, I want us to
03:25 - really ease into this new topic. And so what
we'll do is we'll start by attacking a problem
03:29 - that you probably seen in the past that is
I want to solve a Fibonacci problem. And so
03:33 - for us, we'll have a particular phrasing of
the Fibonacci problem. What I want to do is
03:38 - write a function fib of n that takes in a
number as an argument, and I need to return
03:41 - the nth number of the Fibonacci sequence.
And just to review, how does the sequence
03:46 - work? Well, the first and second number of
the sequence is just one. And then at any
03:50 - point in time to generate the next number
of the sequence, you can just sum the previous
03:53 - two. So for example, these are the first few
numbers of the Fibonacci sequence, right starts
03:59 - 112358, and so on. What I'm saying is your
number needs to take in like a position of
04:03 - the sequence. In other words, if I asked you
for the seventh Fibonacci number, you need
04:07 - to return the answer 13, right? Because the
seventh bonacci number is 13. And how do we
04:12 - actually calculate that 13? Well, logically,
it's just a sum of the previous two elements,
04:17 - that is five plus eight gives me the 13. So
very, very classic function here. And to really
04:23 - get us going for what we do later on in the
lesson, I'm going to require us to solve this
04:27 - one recursively, right, it's really going
to be at the heart of a topic for today. Why
04:30 - don't we kick things off by quickly implementing
the classic recursive implementation of a
04:36 - Fibonacci function, probably in this function
a few times in your programming career, usually
04:40 - one of the earliest examples of recursion
that we face. So we'll just lay out the classical
04:45 - notation here. So I want to take in a number
and and I want to return the number of the
04:49 - Fibonacci sequence. Like we expect, the base
case is just about, you know, the first two
04:53 - numbers of the sequence. In other words, if
I'm given some n, that's less than or equal
04:57 - to two, then what I should do is just returned
one. And I'm reading this because hey, the
05:02 - first two numbers of Fibonacci sequence are
exactly one. But in the recursive case, in
05:07 - general, what I can do is just return the
sum of the Fibonacci number right before the
05:12 - one I'm asking for, as well as the Fibonacci
number two before the one I'm asking for,
05:16 - right? Again, the kind of baked in recursive
nature Fibonacci is to calculate some Fibonacci
05:22 - number, you can take the sum of the previous
two numbers in the sequence right. Now, of
05:26 - course, we should test our code for some correctness,
what I'll do is call a few examples of this
05:31 - fib function. So I'll try fib of six, seven,
and eight. And I shouldn't get the answers
05:37 - of 813 and 21, respectively, right. So let's
give this a go. I'll run this in some JavaScript.
05:44 - There we have it right. 813 and 21. So this
is a very, very classic implementation of
05:49 - Fibonacci, you've probably seen this many
times before. And we did solve it recursively.
05:53 - And really, what I want to do is give some
a larger number to this fib function. So what
05:57 - if I asked for, let's say, I don't know, the
15th Fibonacci numbers seems like something
06:02 - reasonable to ask for. So if I give this code
a shot, it looks like the first three calls
06:07 - of bonacci do work fine, right, I get 813
and 21. But the fourth call is actually still
06:13 - running, right, my program actually hasn't
finished. And this is a big issue with this
06:17 - type of implementation with Fibonacci. So
obviously, this Fibonacci function needs some
06:21 - work. Let's go ahead and head to the drawing
board. Alright, so it's apparent that our
06:25 - Fibonacci function is correct. And that returns
a proper result. However, if we give it a
06:30 - large enough value of n, it's pretty slow.
That is our function has correctness but lacks
06:35 - some efficiency. In the long run, we definitely
want to improve this implementation of a recursive
06:39 - Fibonacci. But to do that, it's really important
that we identify exactly where there's even
06:43 - room for improvement. And to do that, I think
we should draw some things. This is something
06:47 - I think students actually need to work on.
Students have this habit of trying to like
06:51 - picture everything in their mind. And that
works for some easier problems. However, when
06:55 - we want to tackle more complex problems, if
we just try to capture all this information,
06:59 - just mentally without drawing it on, like
pen and paper, or marker and whiteboard, or
07:03 - chalk and chalkboard, you're going to really
lose track of the finer details in these structures.
07:08 - So I want us to be very, very methodical,
and we're going to draw really how you should
07:11 - visualize a problem like Fibonacci. And so
over to my drawing, let's say that I wanted
07:16 - to trace through what happens when we call
a fib with the number seven. That is I'm asking
07:20 - for the seventh number in the Fibonacci sequence,
I know that in the long run, I should get
07:24 - back to 13. Right. 13 is the seventh number
in the sequence. So I'll keep that goal in
07:29 - mind. But over to my drawing, let's say I
called fib of seven, I'll denote that by really
07:34 - drawing a circle with my value for n inside.
So I think about this call to fib of seven,
07:40 - what is it going to do? Well, I know that
seven is not the base case, right? Seven is
07:43 - not less than or equal to two. So this call
is going to branch out into some more recursive
07:48 - calls. In particular, on its left hand side,
I'm going to call n minus one, which is six.
07:52 - On the right hand side, I'm going to do n
minus two, which is five.
07:56 - And at this point, I carry over the same logic
for the other nodes have the structure, right,
08:01 - if I look at the six node, if I'm routed right
there, then that will have a left child of
08:05 - minus one, so five, it will also have a right
child of minus two. So four, you can start
08:10 - to see a pattern where really this recursive
structure just visualizes as a tree, which
08:15 - is really neat. I hop over to this five node,
it will have some children, right, minus one
08:20 - on slept minus two on its right. And we will
actually just continue this process for most
08:24 - of these nodes. But let's say we pause right
here. So you'll notice that these notes that
08:29 - have pointed to in red, they're actually the
base case, right? For those nodes, I have
08:34 - values of two or one. And I know that those
function calls will return immediately. More
08:39 - importantly, that means they don't branch
into any further calls. So I don't want to
08:43 - start flushing out the tree of those nodes.
Instead, I look at things that are not the
08:47 - base case, right? That is these nodes in yellow.
So I'll continue to flush out this tree, but
08:52 - not branch out further for the base cases.
08:58 - So at this point, I built out my entire tree,
and I stopped fleshing out the tree whenever
09:02 - we had a base case scenario. So this is actually
the full recursive tree. Remember that the
09:07 - numbers inside of the nodes here represent
the end that we passed in. That being said,
09:12 - if we have this visualization, how does this
tree really calculate the Fibonacci answer?
09:17 - Right, so let's start to break it down over
here. Let's say I looked at some note, in
09:21 - particular, this base case note of two, right?
I know that this note is a base case, so it's
09:25 - going to return the value of one according
to my base case, when we say return, that
09:29 - really just means return to your caller right
return to your parent. So this note of two
09:34 - is going to return one to its parent of three.
In the same way, this node on the right hand
09:39 - side of one is also a base case, two will
return one, both of those values that are
09:44 - returning, they go back to the parent of three,
and three is actually going to add those two
09:48 - values up. One plus one is two. And this makes
a lot of sense because we know that the third
09:53 - Fibonacci number is two. So we can continue
this process. Okay, this node over here. This
09:59 - is also a base case. So it returns one. And
now the parent node of four is going to sum
10:04 - up both of its children values. Two plus one
is three. And that makes sense in itself,
10:09 - because the fourth Fibonacci number is three.
So you probably got the picture. Now let's
10:14 - speed things up. For all of these base cases,
I know that they're going to return one to
10:18 - their parent. And for all parent nodes that
have both of their children ready, that is
10:22 - both of their children returned, they're just
going to add up those values. And this process
10:27 - just continues all the way up the tree, right?
Just adding our left and right children. To
10:33 - get the answer that we should return the very
top of our tree at the root of our tree, we
10:37 - get the final result of 13, which makes a
lot of sense, because at the start, we said
10:41 - that, hey, the seventh Fibonacci number is
indeed 13. So now that we have a robust understanding
10:46 - of how to visualize this fib function, what
do we actually know about its speed? What
10:50 - do we know about time complexity. And so you
may have heard offhand people mentioned that
10:54 - a classic recursive implementation of fib
is going to be two to the n in time complexity.
10:59 - And that is the case however, you really understand
the reason why. So hidden in this picture
11:04 - is the reason why Fibonacci for us is going
to be two to the n in terms of its time complexity.
11:09 - However, something that's kind of unfortunate
about this drawing is it's asymmetric. And
11:13 - that's, I think, a big reason why students
have a really hard time convincing themselves
11:17 - that a function like this has a two to the
n power time complexity. So here's what we'll
11:21 - do, why don't we warm up and kind of go through
some basic understanding of time complexity?
11:25 - And I promise we'll answer that Fibonacci
question. So let's do a little warm up. Let's
11:30 - say that I gave you this foo function, notice
that it's different from our fib function,
11:34 - right? It's similar in that recursive, this
function is kind of arbitrary, it actually
11:38 - doesn't calculate or solve any particular
problem. So if I wanted to visualize how this
11:43 - foo function behaves, let's draw it out. Let's
say I initially call it the top level foo
11:48 - of five. I know five is not a base case. So
it's going to call upon n minus one, or it's
11:52 - going to call upon for four calls three, three
calls to two calls one, and then here, we've
11:58 - actually bottomed out at a base case. If you
look at the number of calls I made, I basically
12:02 - made exactly five function calls. Which makes
sense, because in terms of our base case,
12:07 - where do we stop once we hit a number less
than or equal to one and every recursive step,
12:11 - we just subtract one from our current value
of n. So overall, I have five calls here.
12:16 - But if I generalize that, for any arbitrary
input, I know that in the long run, I'm going
12:20 - to have about n different function calls recursively.
And so for that reason, the time complexity
12:25 - of this is really just O of n time, right?
I have to evaluate O of n different function
12:29 - calls. While we're at it, why don't we take
a look at the space complexity? Well, you
12:33 - may have heard in past that when we analyze
the space complexity of our recursive functions,
12:37 - we should include any of the additional stack
space that our function calls take up right,
12:41 - when we make a recursive call, we add that
to the call stack, and those must be tracked
12:46 - by our computer. And so since we have about
five or n different function calls added to
12:51 - the stack, before we hit our base case, you
can see that the space complexity of this
12:55 - code is also O of n space, overall, we're
looking at O of n time and open space for
12:59 - this function. Pretty straightforward stuff,
right? Let's look at another more involved
13:04 - function. So let's say I gave you now this
bar function, it's another arbitrary function,
13:09 - it's very, very similar to foo, what you should
notice is, the only difference is when we
13:13 - make a recursive call, we do an n minus two
instead of an n minus one. So how does that
13:18 - actually change the time complexity of this
function? So let's say I wanted to trace through
13:22 - this and I made a top level call to bar of
six, I know six is gonna call upon four four
13:27 - is gonna call upon to, to call zero and zero
actually hits a base case. So this is very
13:32 - similar to our last example, except we kind
of see that from one call to the next, we
13:36 - kind of take a bigger step in time, right.
And so in a way, we can say that we're moving
13:41 - twice as far upon every recursive call. And
this would actually half the number of recursive
13:45 - calls we need overall. So I guess we might
be tempted to say that the time complexity
13:49 - of this one is N over two time, but a keen
observer would note that according to our
13:54 - bego, you know, understanding, we can remove
any multiplicative constants when we have
13:58 - a time complexity, so N over two is the same
as one half times n. So this simplifies nicely,
14:03 - it's just an O of n time complexity. Using
the same exact argument, we can also say that
14:08 - the space complexity from the stack is also
open space. All right, so let's take a lay
14:14 - of the land, I showed you two functions that
are very similar, they really only differ
14:17 - in how they made their recursive calls, right?
One did minus one, the other did minus two.
14:22 - But in the grand scheme of things, we saw
that they had an identical complexity class,
14:25 - right? We have O of n time and O of n space
for both of these functions. So after these
14:30 - two examples, you may be able to see the reason
I wanted to bring them up, right, maybe you're
14:33 - actually ready to make the logical leap and
make some conclusion about our classic Fibonacci
14:38 - recursive function. That being said, I don't
want to skip any steps. I want to be super
14:42 - methodical, I think, if we pay the cost of
understanding fib right now, and I mean, truly,
14:47 - like Absolutely. Understanding fib. It's really
going to pay off later on in the lesson when
14:50 - I slam me with some much harder problems.
So let's be nice and methodical over here.
14:55 - Let's take a look at some other functions.
Let's say I gave you this did function now.
14:59 - very particular Right, we'll pay it no mind.
What do we notice about this did function?
15:03 - Well, it has two recursive calls now right
inside of every single call. And they both
15:08 - do an n minus one. How should we visualize
this one? Well, it's kind of similar to I
15:12 - guess, our initial fib drawing and shape,
where if we start with some initial call,
15:15 - let's say five, five is going to branch to
exactly two children, right? Because five
15:19 - is not yet the base case. And for this did
function, it does a minus one on its left,
15:23 - and also it's a right child, right. So the
next level is just for next levels, just threes
15:28 - than twos, then just ones which would actually
hit our base case over here. This is a really
15:33 - nice, like, beautifully symmetric tree, right?
Okay, so this is a visualization for our dib
15:38 - function. But what does it tell us about the
time complexity of it? Something you'll hear
15:42 - me say a lot in this lesson is when we tackle
a quote, unquote, new problem, or a new pattern
15:46 - we're really trying to do is just leverage
our past experience, right? So when I look
15:49 - at this tree structure, I'm trying to notice
anything familiar, right? Is there some strand
15:54 - over here that I can grasp that to really
feel comfortable and kind of extend my previous
15:59 - learnings, right? Where can I find our base
inside of this drawing? Boop, right here.
16:05 - So if I look at this path, I've highlighted
in yellow, it's really just the path starting
16:09 - at the root node going down to some base case
here, I just designated the leftmost path.
16:14 - And what's really nice about this structure
is just referring to the notes in yellow.
16:18 - It's a linear structure that we saw before,
right? If I start at the root, it just goes
16:21 - 5432. And one. And so I know that in general,
based on my initial input of n, like the length
16:27 - of this path that has a number of nodes highlighted
in yellow, there's going to be about n different
16:32 - nodes. If I kind of adapt that language for
like the tree, I can also say that the height
16:37 - of this tree is n. So the height of a tree
is really just the distance from the root
16:42 - node all the way to the far this leaf, in
this case, that just means the distance from
16:46 - our top level called Five, all the way down
to a base case, which is going to be exactly
16:50 - five here. Something you may also hear in
passing is we can say that the number of levels
16:55 - in this tree is also n, this term is pretty
straightforward, right? When we say the number
17:00 - of levels, a level is just a collection of
nodes that are the same distance away from
17:05 - the root. So for example, here in yellow,
I have highlighted level zero, this is level
17:09 - one, this is level two, this is level three,
and so on. But if I rewind things a bit, I
17:14 - look at the very, very top level, there's
one node here, on the next level, there's
17:18 - two nodes. On the next level, there's four
nodes, then eight nodes, then 16 nodes, see
17:24 - the pattern?
17:27 - So let's try to generalize that. So I know
no matter what, whenever we call some top
17:31 - level argument for dib, we know that we're
going to have one node at the top level. But
17:36 - to get the number of nodes on the next level,
we'll just multiply that by two. And the level
17:40 - after that would also multiply by two and
multiply to again further levels after that.
17:44 - And I do this a total of n different times,
right? Because I know that the height of the
17:49 - tree, or the number of levels in this tree
is exactly n. And so what conclusion Can we
17:54 - make over here, we're basically saying that
to get the total number of nodes, or the total
17:58 - number of calls a recursive function would
make, you would just take the number two,
18:03 - and multiply it by itself about n times over.
And that is really the definition of an exponent,
18:08 - right? This is the same as two to the nth
power. So we can say that this tree structure,
18:13 - this recursive function has a two to the N,
time complexity. Awesome. So we identified
18:18 - this dip function is having a two to the n
time complexity. But what do we know about
18:22 - the space complexity over here, I think a
common mistake I've seen people make is kind
18:26 - of automatically assumed that the space complexity
of a recursive function will be the same as
18:30 - the time complexity. And that might be a reasonable
trap to fall into, because we know that in
18:35 - the long run, we're gonna have to evaluate
two to the n function calls. And so I guess
18:39 - that means you have to put two to the n function
calls on the stack. But there's actually some
18:42 - nuance to this, the time complexity of this
is not the same as space complexity. So let's
18:47 - jump in. Let's say that we made our top level
call to dibba five, we know that that is added
18:51 - to the stack in the same way five calls for
so it's that the stack, we add a stack frame
18:55 - for every call that we make down until just
the base case, right. So at this point, I
19:00 - reached a scenario where I have a base case,
and I'd have about five stack frames on my
19:04 - call stack. And the important insight is when
we actually hit this base case that I have
19:08 - highlighted the left one over here, it actually
will return when something returns when a
19:12 - function returns, its stack frame is actually
removed or popped from the stack. And at this
19:18 - point, only after I have returned from that
left one, what I actually add the right one
19:22 - to the stack to be explored. And this process
continues. Notice that any point in time the
19:27 - most number of stack frames that we use up,
it's exactly five, right, it's not as if we
19:32 - throw all of these function calls on the stack
at once. And because we have such a nice tree
19:37 - visual, we know that the number of stack frames
that we're ever going to use is really just
19:42 - the height of the tree, right, so the height
of the tree is n like we said before, that
19:45 - means our maximum stack depth is also n. So
we have in space complexity coming from the
19:51 - call stack. So overall, for a dip function,
we're looking at two to the n time complexity,
19:55 - but only and space complexity. Alright, so
let's look at one more function. See, I gave
20:00 - you this very similar lib function. Notice
that in its recursive calls, it does an n
20:04 - minus two. So by now you should be able to
visualize what structure like this would look
20:09 - like, say we initially called lib with a value
of eight, what would the full tree look like?
20:14 - Well, it would just look like this. Notice
that it's still a tree, right where every
20:18 - node branches to two children. But this time,
we go by twos, right, so if I look for some
20:23 - familiar ground here, I've noticed that from
one node to the next, I do one minus two.
20:27 - And this occurs all the way down to a base
case. So we already know that, hey, we can
20:31 - identify this tree as having a height of about
N over two. So I guess that means that the
20:37 - time complexity is going to be two to the
N over two power, right, because from one
20:41 - level of the tree to the next, we double the
number of nodes. So that's that two times
20:45 - two times two repeating pattern for the number
of levels and our number of levels is N over
20:49 - two, right? However, we can actually simplify
this time complexity, you can take that n
20:54 - over to in the exponent and simplify that
to just an N. So overall, we're looking at
20:57 - a two to the n time complexity. And using
our same arguments from last time, we know
21:01 - that the space complexity for this from the
stack is also going to be N over two, which
21:05 - simplifies nicely to N space complexity. So
we see that overall for our loop function,
21:10 - we're looking at a two to the n time, but
no space complexity.
21:13 - Alright, so now it's time to look at the big
picture, we looked at two toy functions of
21:18 - dibben lib. And we saw that the only difference
in how they made the recursive calls, right
21:23 - did did a minus one and lived in a minus two.
And we saw that despite their differences,
21:27 - both functions had an exponential two to the
n time complexity, and a linear and space
21:31 - complexity. That being said, Where does our
original Fibonacci function fit in this picture?
21:38 - Well, you can imagine that kind of falls right
in between, we know that for our fib function,
21:43 - it has two recursive calls for the first recursive
call, it makes it does n minus one like did
21:48 - did. But its second recursive call this n
minus two like lib. So in a sense, it's kind
21:53 - of like smack in the middle, right? If you
let me abuse the notation a little bit, and
21:56 - just talking about the time complexity, we
can kind of say that the complexity of fib
22:00 - is somewhere between dibben lib, but we've
already plugged in some values, right? You
22:04 - know, that, hey, the lower bound that as Deb
has to to the end, and the upper bound, that
22:08 - is lib has to at the end as well. So that
means that our fib function must have exactly
22:13 - two to the n time complexity as well, right?
All three of these functions have an exponential
22:18 - time complexity. Awesome. So that was a really
complete analysis of why we have this fib
22:22 - function, it's evident that it has a two to
the n time complexity and an N space complexity.
22:28 - Right now, the bottleneck that we're experiencing
is, of course, the time complexity, right
22:32 - two to the n overall, is not undesirable complexity.
But do we really have a nice feel for what
22:38 - this really implies? So let's take a look
at this to to the end. So what's the implication
22:43 - of this? Well, you could kind of imagine that,
hey, if I asked for the 50th Fibonacci number,
22:47 - that would take you know, roughly two to the
fifth power number of steps. And so if you
22:52 - punch this exponent into a calculator, you're
gonna end up with a result like this, this
22:56 - is roughly a 16 digit number. So you should
have a vi for you know, this being a very,
23:01 - very, very large quantity. But I think that,
you know, to really understand the gravity
23:06 - of what we're really saying here, if we expand
this number, that quantity is exactly this.
23:12 - That's over one quadrillion 125 trillion,
which is really, really interesting, right?
23:18 - Because we just asked our Fibonacci function
for just you know, something relatively modest,
23:22 - right, the 50th Fibonacci number, and it's
gonna take quite literally a quadrillion steps
23:27 - to do that. And of course, we can probably
do better. So let's work on making this faster.
23:32 - So if I recognize that the bottleneck for
this fib function is the time complexity,
23:35 - I know that that comes from the number of
recursive calls that I make. So what I want
23:39 - to do is look for any patterns that I see
in the recursive nature of this problem, let's
23:43 - see a quick snapshot of what the recursion
for fib of seven would look like, we know
23:47 - that it looks like this tree just like we
saw before. So take a moment, look at this
23:52 - tree, do you notice any interesting patterns
within it?
23:54 - Well, one thing that I noticed is I can see
this subtree rooted at three, there, I have
24:00 - two on the left and one on the right. And
if I look at that subtree, I can actually
24:04 - see it in many different places in this tree,
right? This subtree rooted at three appears
24:09 - in a bunch of different places, it's very
duplicate. In a similar way, I can look at
24:13 - other sub trees, let's say I root myself at
four, and see that duplicate four sub tree
24:18 - all over the place. And it's even carries
over for larger values of n like fib of five.
24:24 - So I see that this tree has a lot of duplicate
sub trees, right? And I want to now draw a
24:28 - connection between this diagram and what happens
in my code. I know that if I route myself
24:32 - in any of these sub trees of five, I know
that each sub tree is trying to answer the
24:36 - question. Hey, what's the fifth Fibonacci
number? I know that the Fibonacci number never
24:41 - changes, right? If I calculate it once on
the left hand side, then the answer I should
24:45 - get back on the right hand side shouldn't
differ at all. And so what I want to do is
24:49 - possibly reuse these calculations right? If
I calculate the Fibonacci number over here,
24:55 - then I should just store that because later
on it might be useful when need to recalculate
24:59 - it over here. I would basically get rid of
a lot of the tree, I wouldn't have to travel
25:03 - down this entire recursive tree rooted at
five. This pattern of overlapping subproblems
25:08 - is known as dynamic programming. And so for
us dynamic program is going to be any instance
25:14 - where we have some larger problem, in this
case, Fibonacci. And we can decompose it into
25:18 - smaller instances of the same problem, we
also have an overlapping structure. So for
25:23 - us, right, now, I see that I have to calculate
now let's say fib of five, twice over to calculate
25:28 - the larger a fib of seven a solution. And
something we're going to be doing a lot in
25:32 - this lesson is really trying to visualize
problems in terms of like their recursive
25:36 - nature. So we're going to be drawing a lot
of trees. And what I'm always going to do
25:40 - is try to really recognize, hey, what pattern
in this tree is duplicate, right? If I do
25:45 - some duplicate work, if I do some duplicate
drawing that I know I can optimize that out
25:48 - later on. But that being said, let's go ahead
and get to the punch line on this fib function
25:53 - and work on optimizing this solution. Alright,
now let me discuss the plan, I think we're
25:59 - ready to actually implement some code that
will actually carry that plan out. Here I
26:03 - have our classic bonacci implementation, this
was the one that we ran earlier. And it's
26:06 - definitely too slow, right has an exponential
time complexity. So I know that overall, when
26:11 - I want to do is kind of capture a duplicate
subproblems, I want to store any results that
26:16 - I get that way, if I have to recalculate those
subproblems. Later on, I can just use my stored
26:20 - data. And so the trick here, it's a very common
programming pattern, we're going to implement
26:24 - some memorization. memorization is actually
one of the overarching strategies we can use
26:29 - to solve any dynamic programming problems.
And so just look at the name like why is it
26:34 - called memoization? Well, this refers to like,
memo, right? So if I have like a memo, and
26:38 - let's say, like real life, it's really just
like a reminder for myself. So using memoization,
26:42 - I'm looking to do is store some duplicate
subproblems. That way, I can just get those
26:47 - results later on. I think a really neat way
to implement memorization in JavaScript, as
26:52 - well as many languages is to use some sort
of a fast access data structure usually be
26:56 - like your hash map equivalent in the programming
language of your choice. For us, that'll be
27:01 - a JavaScript object. And so our plan is to
use some JavaScript object. And so what do
27:06 - I want the keys to be, so the keys in the
object are going to be the argument to our
27:12 - function, right. And then the value will be
the return value, that we have a nice napping
27:20 - for a argument to the function that is a function
call, as well as its return value, right.
27:26 - And so what I can do for my existing function
is, I kind of just bake in some optional arguments.
27:31 - So my favorite strategy is to do this, and
assign a memo to be an empty object. So if
27:36 - you're unfamiliar with this syntax, in JavaScript,
it's pretty useful. What I'm saying is, if
27:40 - I were to call our fib function, and not pass
in a second argument, by default, it will
27:46 - create this memo, as containing a new JavaScript
object that is empty, of course, right? So
27:52 - it's gonna be useful that way, whoever is
actually testing, my code doesn't have to
27:55 - deal with setting up any memo object. So well,
I prefer this strategy over here. And what
28:00 - I want to do is treat it as if that, hey,
this memo is going to store n as the key and
28:06 - values are going to be just the return values
for this function. So what we're going to
28:10 - see us doing a lot in this lesson is at the
start, we're going to first check for existence
28:15 - inside of our memo. So let's say that we're
somewhere in the middle of recursion, the
28:20 - first thing I should do is kind of add an
additional base case and say, Hey, is my current
28:24 - argument n inside of the memo, and if it is,
then I can just get the stored value from
28:30 - that memo. And I'm done. So I'm going to do
an early return here, I'm going to return
28:34 - the value that corresponds to that memos key,
right, I'm just using the original argument
28:39 - and as a key in my memo, and this condition
is really just some classic JavaScript syntax,
28:44 - I'm just checking if some key is inside of
a JavaScript object. So
28:48 - really quick, maybe just to warm us up, if
you haven't seen that syntax before. So let's
28:52 - say I had some object and had some properties
inside and we had a name of Alvin, that's
28:59 - me, then it had a favorite color of like gray.
And what I can do is check for an existence
29:06 - of a key in that object. So JavaScript keys
are mostly strings, right? So I can check
29:11 - Hey, his name in the object. That's true,
is the fav color in the object, make sure
29:18 - I spell it right. That is also true, I can
check for a key that's not there, like I don't
29:23 - know, his location and the object that is
false. And so here, I'm just using that same
29:28 - pattern, but for and right, which is going
to be a number, technically, it'd be converted
29:32 - into a string key, which would still totally
work here. Awesome. So I have my memo fetching
29:38 - logic, right? I check, Hey, is this argument
in the memo, but if it's not, I'm gonna have
29:42 - to actually manually do the calculation, which
is okay, because I know I need to do a subtree
29:46 - at least once. So what I'll do is I'm going
to take the exact return value, right, so
29:50 - this is my return value in the original brute
force. What I want to do is actually store
29:55 - that entire result inside of my memo and the
key is course and write, the key you use to
30:02 - access is always just what your argument is.
And I want to complete the original return.
30:06 - So I can just go ahead and return what I just
put in that memo. So I'm not really changing
30:13 - any return values, or I'm returning exactly
the expression that I returned before. But
30:17 - now I'm actually also saving that value inside
of the memo object. What I want to do is make
30:24 - sure that all of these recursive function
calls are accessing the same memo. So what
30:28 - I'll do is I'll pass in that object to both
of these calls are really important pattern
30:33 - here is, I know that I only receive a new
top level metal object, whenever I make a
30:39 - top level call, that's a fit, right, because
I'm not passing in a second argument over
30:42 - here. However, if I look at my recursive calls,
I do pass in explicit second arguments. And
30:49 - so they're actually going to receive the same
memo object, and it would be like passed by
30:53 - reference, right, because when you pass a
JavaScript object to a function, you actually
30:56 - receive kind of that exact object, right,
you don't receive a copy of it, which is really
31:01 - neat. So basically, I'm giving my function
calls a way to sort of communicate to each
31:06 - other, they all have some sort of global information
to reference across all the recursive trees.
31:11 - So this is looking good. Again, I just want
to emphasize I only added a new argument over
31:16 - here, I added a new base case on line five,
then I added my memo storing logic on line
31:21 - seven, but I didn't change any of the functional
logic here. Let's go ahead and run these test
31:26 - cases. And we'll see how our code is doing
now. So moment of truth, I'm going to run
31:32 - this file.
31:34 - And notice how blazing fast our program was,
I still get the results of 813 and 21. And
31:39 - the 50th Fibonacci number is indeed have this
very large number. And it basically executed
31:44 - almost instantly. So let's go ahead and head
back to the drawing board. And really understand
31:49 - you know, what happens when we execute this
sort of code. Alright, so it looks like we
31:54 - implemented the improved version of Fibonacci
by memorizing it. And it's clear by running
31:58 - the program that we definitely had an impact
on the time complexity. However, I really
32:03 - don't want us to understand you know how the
structure of the recursion tree changes, once
32:07 - we implemented this memoized version of the
code. So let's say I want to step through
32:10 - an example of Fibonacci. And let's say I pass
in a number six. So really, what I'm looking
32:15 - for here is to get back eight, because the
six number of the bonacci sequence is indeed
32:19 - eight. So we know that we're going to have
a tree that looks like this, right? This is
32:23 - a tree that would really be the full recursive
nature. So this is how the tree would look
32:27 - like if I did not optimize it. And what impact
do we have by actually adding this memo object?
32:32 - Alright, so let's start tracing through this,
I know that when I call fib of six at the
32:36 - top level, an important thing to know is I'm
not going to pass in some memo object. So
32:41 - by default, my code says it will initialize
it to an empty object. And the really important
32:45 - aspect of this is I'm going to create a new
object just for the top level call. But then
32:50 - that same object is going to be passed down
to my recursive calls, right noticing line
32:54 - five. And so I'm going to travel down my left
hand path, right, six calls five, five calls
32:59 - for four calls three, and three calls to,
and right now I've hit a base case. So I know
33:04 - that this note of two is going to return one.
So that's kind of business as usual, right?
33:09 - In the same way, now I need to evaluate this
other note of one, which is also base case,
33:13 - it also returns one. And at this point, my
parent of three is actually ready to compute
33:17 - the sum of its children, right. So one plus
one just gives me two. So I just add up those
33:22 - values. And now three is returning two. However,
looking at line five of my code, not only
33:29 - is this node going to return to to its parent,
it's also going to store it in the memo object,
33:34 - right? So the key insight is, at this point,
I would add a key to my memo of three, whose
33:41 - value is to basically in my memo, I kind of
read as if I'm saying, hey, the third Fibonacci
33:46 - number is two, right? That in itself is logical.
So I can just continue this pattern right?
33:51 - Now I start to evaluate what happens when
I'm at this note of t, which is also a base
33:55 - case, it returns one. Now my call to four
is ready to compute, right? It's going to
33:59 - take the sum of its both children. So it's
going to do two plus one gives me three. But
34:04 - of course, it's also going to store that inside
of the memo, right? It's going to cash that
34:08 - result out to be used later on. So that means
I make the N my key and I make the return
34:14 - value, the value, right, so I'm going to have
four points to three inside of my mental object.
34:20 - And now here's the beauty of this memoized
solution. At this point, I need to compute
34:25 - what happens for fib of three. However, this
is actually going to hit one of the new base
34:30 - cases I added, right? I know that three is
in the memo object looking at line two of
34:35 - my code, right? It's in the memo object. And
so I just immediately return the stored value.
34:41 - And so this call to fib of three is just going
to return the stored value of two. And if
34:46 - I do that, I won't have to travel down the
full, you know, recursive subtree rooted at
34:51 - three, right? I don't need to travel to these
nodes at all. So I already used some stored
34:56 - value in my memo. At this point five is ready
to return right five will take The summer
35:00 - both with children, three plus two is five.
And it's going to store that in the memo,
35:04 - right? The fifth Fibonacci number happens
to be five. And now the same thing happens
35:08 - for six is right child. So I have to evaluate
this node now. So what is the fourth of bonacci
35:13 - number up, that's actually stored directly
inside of my memo. So this actually early
35:19 - returns the stored value of three, right.
And again, the key insight is, it will return
35:24 - that stored memo value without having to travel
through that full subtree. And at this point,
35:29 - I can return for fib of six, so I do five
plus three, that gives me eight, this would
35:34 - actually technically be stored in my memo
as well. So I have the six of bonacci number
35:37 - as eight and very happy, right? The answer
is eight.
35:42 - So it's evident that by memorizing our Fibonacci
function, we definitely cut down on the number
35:47 - of recursive calls, we want to visualize that
we ended up with this kind of structure. Here
35:52 - in light blue, I have a circle the nodes that
we technically didn't need to do the full
35:57 - recursion at, right? So these nodes of two,
three and four, for this small example of
36:01 - my initial fib of six, I was able to kind
of fetch a value from my memo and kind of
36:07 - forego traveling down the recursive subtree.
So what do we actually know about the time
36:12 - complexity of this function now? Well, I think
it's really important that we always try to
36:17 - generalize things. So we just stepped through
a relatively small example of fib of six.
36:21 - But how does this sort of scale? So this is
the same tree? Let's see, I kind of tidy it
36:25 - up a little bit. So I know that in general,
fib of six kind of has this structure. So
36:30 - I want you to take a moment, look at this.
And in your brain picture, what fib of seven
36:35 - would look like if I memorize with with seven,
what would its sub trees look like? Well,
36:40 - it really just looked like this. Notice if
I route myself at the seven node, its left
36:45 - child is still six, right minus one. Its right,
Charles, still five minus two. So this still
36:50 - obeys the laws of Fibonacci. If I asked for
fib of eight memoized, the structure would
36:55 - be like this. And nine would look like this.
See the pattern looks like at this point,
37:00 - we're just growing this like memoized chain
in a linear kind of way. If you're not convinced
37:05 - by you know, that just like structural argument,
let's say we were a little more methodical,
37:09 - we know that in this drawing, there is some
common ground, right? Again, like I always
37:14 - say, when you tackle these new problems, or
new patterns, try to find some familiar territory,
37:19 - right? Where can I recognize stuff I've seen
previously. So I look at this chain, I go
37:23 - 98765432, right. So this goes all the way
down in a very, very, very linear fashion,
37:32 - right, just counting down. So I know that
if I just look at this highlighted chain in
37:36 - yellow, that's definitely just an notes, right,
where n is my initial top level call. So I
37:41 - know that what I have highlighted in yellow
is just a linear chain right there exactly
37:44 - n nodes. But I haven't accounted for everything
in this picture, right, some of the nodes
37:48 - are still in white, meaning I need to kind
of work them into my description of what the
37:52 - shape of this tree is, well, I know that each
of those white nodes is actually connected
37:56 - to some of the nodes, I've colored in yellow,
they're kind of paired off in a way, right?
38:00 - For every node in my ello chain, it has exactly
kind of one partner node one right hand node
38:05 - on its right hand edge. And overall, if I
have n pairs, that means I have to end things
38:11 - overall, right? There are two things in a
pair. So overall, the number of nodes is roughly
38:15 - two n. And I know that that can actually be
simplified, right? The time complexity here
38:19 - would be two n, which just simplifies to n
time complexity. And using the same arguments
38:23 - we did for our space complexity, we know that
the space is going to be n as well. And this
38:28 - is pretty powerful stuff. by memorizing our
fib function, we brought it down from an exponential
38:33 - time complexity to just a linear time complexity.
Pretty cool stuff, right? All right, I think
38:40 - we're ready to graduate from Fibonacci. And
what we'll do is work on a more involved problem,
38:44 - this one has more of a narrative to it. So
say that you're a traveler on a two dimensional
38:48 - grid, you begin in the top left corner, and
your goal is to travel to the bottom right
38:51 - corner of that grid. And the rule is you can
only move down or to the right, that means
38:55 - you can't move up or to the left, and you
definitely can't move to AGL. That being said,
39:00 - In how many ways can you travel to the goal?
That is how many ways can you travel to the
39:03 - bottom rate if you had a grid of dimensions,
m by n. So the first thing I recognize here
39:08 - is looks like the grid, maybe a rectangle,
not necessarily a square, right. And overall,
39:13 - what we want to do is implement a function
that calculates this that is our function
39:17 - is to take the dimensions of the grid. And
so before we hop into sketching the strategy
39:22 - for this one, I think it's really important
that we make sure that we actually understand
39:25 - what this question is asking. So let's say
they asked us to calculate grid traveller
39:29 - of two comma three, that means they're asking
us in how many ways can you travel from the
39:34 - top left to the bottom right, of a two by
three grid? I will tell you right now that
39:38 - the answer here should be three. Right? So
there are three ways to do that. And in particular,
39:42 - you can imagine that we had, you know, a two
by three grid, so that means two rows, as
39:46 - well as three columns. And we start in the
top left, and our end goal is in the bottom
39:51 - right. And so why do we say that there are
three ways to get from the top left to the
39:55 - bottom right? Well, they told us in the problem
that we can only either take a right move
39:59 - or a down To move, so one of the ways would
be going right right down, right, that would
40:03 - bring us from the start to the end. And it
would kind of look like this. In a similar
40:07 - way, another path we can take is doing a write
down, right? It would kind of look like this.
40:13 - And the only other way would be going down,
right, right, which would look like this path.
40:18 - And that's why we say there are only three
unique ways to travel not through a two by
40:21 - three grid.
40:22 - All right, so that's just one example of how
we might call a grid traveler, I think what's
40:27 - really important to notice is try to also
frame the problem as if you were given some
40:31 - relatively small inputs, but I think they're
really important case to think about is, what
40:35 - happens if they give us like, basically, the
smallest valid grid we can have that is a
40:39 - one by one grid. This one is kind of trivially
simple, right? A one by one grid only has
40:45 - one unique way to travel from the start to
the end. And it's kind of concise in that
40:50 - if you had a one by one grid, there's really
only one position, right? So that means that
40:54 - the start is really the same as the end, and
kind of you already have the problem solved
40:59 - out the gate, because to travel from the start
to the end, you kind of just do nothing, right?
41:04 - So the logic here is in a one by one grid,
there's only one way to travel from the start
41:09 - to the end, you're kind of already there.
So you don't need to take any moves. Something
41:13 - else we might think about is what happens
when one of our dimensions is zero. So let's
41:17 - say someone asked us to calculate grid traveller
of zero comma one, this is a kind of strange
41:22 - question to ask because for one, if there
are zero rows and one column, that kind of
41:27 - means that the grid is empty. So I would consider
that as there being zero waste to travel through
41:32 - that grid because the grid is sort of invalid
in a way. In a similar way, if I asked you
41:36 - for traveling through a one by zero grid,
there's still no grid to be found here. Right?
41:41 - So it should also return zero. And likewise,
when either of the dimensions is zero, the
41:47 - answer should just be zero, right? If one
of your dimensions is empty, then there really
41:51 - is no grid.
41:54 - So maybe you're catching on into why I brought
up those trivially small grid examples, right?
41:58 - Those kind of sound like base cases, which
we can use to reconstruct a larger answer.
42:02 - But let's stay grounded and look at another
grid. So let's say I asked you to calculate
42:07 - grid traveler of three comma three, right?
So I want the answer for a three by three
42:10 - grid. Well, how can we reason that one out?
At this point, what I'm looking to do is sort
42:15 - of frame the problem in a way where I can
decrease the problem size, usually by mutating
42:21 - the arguments to my function call. So let's
imagine this three by three grid, as always,
42:26 - I want to move from the top left to the bottom,
right. So I begin at this position, let's
42:30 - say, and so I know that overall, I have this
top level problem of saying, how many ways
42:35 - can I travel through this entire three by
three grid, let's say I took one of the moves,
42:40 - right, I can move either right or downward.
Let's say I made the decision to move downward.
42:44 - Well, if I move downward, then I would appear
here now, I know in the future, I can only
42:48 - move to the right or downward. So now it's
as if my playable area has been reduced to
42:53 - just this shaded region. And if I look at
what I've actually done to this problem, I'm
42:58 - still sort of in the top left corner of some
grid, where now I'm really trying to answer
43:04 - the question, hey, and how many ways can I
travel through this two by three grid. And
43:10 - this is a really important way that we're
shrinking the problem size, right, I had a
43:14 - three by three grid initially. Now I have
a two by three grid. And this is really like
43:19 - the relative grid from my current position,
we'll say, spanning all the way to the end
43:24 - position. So if you look at this coordinate
of like two comma three, technically, that
43:28 - is like not the coordinate of the person within
the larger grid. This is really the size of
43:33 - the rectangle that the person is trying to
cover now. Right. So in a similar way, let's
43:39 - say that, hey, I want it to move to the right
now. Well, that would also shrink the grid
43:42 - along a different dimension. So I'd appear
over here. And now I have a two by two grid
43:47 - that I'm trying to solve. And if I keep following
this pattern, we're gonna keep shrinking on
43:51 - the problem size over here. Now, I'm asking
for a grid traveller of one by two. And finally,
43:56 - if I take a right move over here, I'm asking
for grid traveller of one by one, which I
44:00 - know is one of those sort of base case scenarios
that I had previously. So that's going to
44:04 - be really useful when we actually implement
this in some code. And so the key insight
44:08 - here is when we make a move through the grid,
that is when we go right or downward, are
44:13 - basically shrinking the effective size of
the playable area, right, our grid gets smaller
44:17 - along one of its dimensions. Awesome. So I
think now we're able to see that, hey, this
44:22 - grid traveler problem definitely has some
overlapping subproblems. Right. Let's say
44:27 - I tried to take more of like a programmatic
approach, something that we'll be doing a
44:30 - ton, like, basically, for every problem in
this lesson is whenever we have a problem
44:35 - that we kind of know is going to be recursive.
The move is to really structure it like a
44:40 - tree, right? I want to really visualize this
because I know that if I had a tree structure
44:44 - on pen and paper, I can implement that with
just some recursive code using some JavaScript,
44:48 - right. So let's say that I wanted to take
more of a tree based visual understanding
44:52 - now a grid traveller of two comma three. So
I know that usually the way we do this is
44:58 - we encode nodes of the tree Using the arguments
to this function right? Now I have two arguments
45:03 - where I have the number of rows and number
of columns. Whereas before for something simple
45:06 - like Fibonacci, I only had a single argument.
So in the long run, I know that the answer
45:11 - I should get back is three. So just keep that
goal in mind. Let's start to flesh out this
45:15 - diagram. So I'm going to start with that top
level, column two comma three. And now I think
45:19 - about how this node can transition to other
nodes, right? How does the State of my game
45:24 - actually change? Well, I know there are really
two options I can take right? You can either
45:29 - have one child going downward, or another
child going the right word, right? Those are
45:33 - the two options based on the gameplay here.
And so if I go down, how does that change
45:39 - of the number I put in the node? That is,
how does it change the dimensions of the playable
45:44 - grid area? Well, if I go downward, then I'm
reducing the number of rows by one. So that
45:49 - means my left child is just one comma three.
Now, if I had moved to the right, that would
45:54 - mean I'm reducing the number of columns by
one. So my right child is just two comma two.
45:59 - Notice that from parent to child, all I'm
doing is reducing a one of the dimensions
46:03 - by one, right, that means you're either going
downward or going to the right, and I can
46:07 - just carry over this pattern recursively,
right. So let's say I'm fleshing out this
46:11 - node now, five, mat one comma three, then
its children would be just 03. And one, two.
46:16 - And a similar way. If I wrote myself at two,
two, then I have children of one, two, and
46:22 - two, one. But now let's notice something important.
Here. I've kind of spotted a node where I
46:27 - have zero comma three, remember what we trace
through in terms of the visual drawing? What
46:32 - is this? No trying to answer? Well, let's
notice saying in how many ways can you travel
46:37 - through a zero by three grid, but if you have
zero rows, and there's really no grid to be
46:42 - dealt with. And so I think for this note of
zero comma three, or really any node that
46:47 - contains zero, we don't need to actually flesh
out its children. So instead, I'll work on
46:52 - recursively, drawing out these other nodes.
So we'll carry over this pattern. At this
46:57 - point, we've actually hit I think all of our
base scenarios, right. So if I look at these
47:02 - notes, that have one comma one that was exactly
like the affirmative base case, meaning that
47:08 - I know, trivially I can solve the one by one
grid. In other words, these function calls
47:14 - are going to return one, right, in a one by
one grid, there's exactly one way to travel
47:20 - from start to end, right, you kind of just
do nothing. And on the flip side of that,
47:23 - for all those notes that contain a zero, they're
also a base case. But they're kind of like
47:27 - the negative base case, meaning that there
is no way to actually travel from start to
47:32 - end. So for all of these notes containing
zero, they should return zero to their parent,
47:36 - right? There are zero ways to travel through
that grid. At this point, I just sum up these
47:40 - values at the parent node, right? So I just
left these and then I add them together. And
47:45 - I forget what these things are saying, right?
If I look at like the node one comma two,
47:49 - above, it is one meaning there is one way
to travel through a one by two grid, right?
47:54 - You kind of just move rightward. And so I
carry this pattern over, I keep adding the
47:59 - children nodes at their parents. And this
carries up all the way to the root node. And
48:04 - what do I know, there are three ways to travel
through a two by three grid. So although there's
48:09 - like a narrative, and there's some, you know,
cute story behind this problem, it's really
48:13 - just a spin off of Fibonacci. And that's going
to be the case with many of these dynamic
48:17 - programming problems. So we've confirmed that
there are three ways to travel through a two
48:22 - by three grid. And there's also some other
information encoded in this tree. I know that
48:27 - whenever I took like a left hand edge in this
tree that I presented the choice of going
48:31 - downward. And whenever I took a right hand
edge in this tree, that represented the decision
48:36 - of moving rightward. And so if I have that
pattern in mind, that not only have I been
48:43 - able to count the number of ways that I can
win the game, but I also know exactly which
48:48 - combination of moves lead to a solution. One
of the ways to win this game is to go down,
48:52 - right, right. Another way is to go right down,
right, and the final ways to go right right
48:58 - down. So we can glean a lot of information
just from the same tree structure. Cool. So
49:03 - I think that's enough drawing for now let's
go ahead and implement this in some code.
49:07 - Alright, programmers, here we are back in
my text editor. Let's go ahead and implement
49:12 - this grid traveler function. So you want to
go with that recursive strategy. So I'll start
49:16 - by just laying down my base cases, I already
refer to the fact that hey, one of our base
49:20 - cases is we have a one by one grid, just go
ahead and return to zero, right? So that's
49:24 - really easy to do. So I'll check Hey, if m
is one, and n is one, then the answer is just
49:31 - trivially one. Right? Then along with that,
I also have the base case when I had like
49:35 - an invalid grid. That means if either of my
dimensions is zero, so I'm using an order
49:41 - here, right? If either dimension is zero,
then your grid is empty, which means there's
49:45 - definitely no way to travel from top left
to bottom right of that grid. Cool. Then my
49:51 - recursive scenario is very straightforward.
All I need to do is get the sum between me
49:56 - going downward and me going rightward, right.
So if I go Down number n is the number of
50:02 - rows, if I go down that I'm decreasing the
number of rows affected rows, that is by one,
50:06 - but I keep the same number of columns. And
then in a very symmetric way, if I move to
50:11 - the right, that means I still have the same
number of rows. So I keep him, but I decrease
50:16 - n, right, I have one less column. So this
code is looking pretty sharp, really just
50:21 - some reminiscent Fibonacci style code. Let's
go ahead and give this a run. So I'm running
50:25 - a few examples over here. And these are the
expected results. In some comments, we'll
50:31 - go ahead and bang this one out, grid traveller.
Cool. So I get the first four results. 1336
50:37 - looks like it's working just like a charm.
However, for this last example of an 18 by
50:42 - 18 grid, looks like my programs hang right
now, it's actually a little too slow to calculate
50:49 - an 18 by 18 grid, so you probably see where
this one's heading. Let's go ahead back to
50:53 - the drawing board and really understand a
why this code is fairly slow. Alright, so
50:59 - here we are back in the drawing board, because
it looks like we hit a wall when it came to
51:02 - our recursive implementation of grid traveller.
That being said, I think implementing the
51:06 - brute force solution here is actually a really
logical first step. And now we can just focus
51:11 - in on where there is room for improvement.
So our first question is, you know, what is
51:15 - the actual time complexity of this implementation?
Well, I know when I call a grid traveller
51:19 - of two, three, the full tree would explore
is this right. And like we said, in our Fibonacci,
51:25 - to understand the time complexity here, it's
really about to understand the number of function
51:30 - calls we make, which is really the number
of nodes in this tree. And of course, I want
51:33 - to generalize my understanding for any large
inputs. So I know that this tree sort of looks,
51:39 - you know binary in a way, meaning that a node
can branch to up to two children, which makes
51:43 - sense, because from one position of the grid,
I have two choices to make, right, I either
51:47 - go down or I go to the right. But that being
said, I need to realize what the height of
51:52 - this tree is. And this one's pretty interesting,
because out the gate, we actually have two
51:57 - input arguments to our function, I'm given
two numbers, m and n. And since this function
52:02 - contains two inputs, it shouldn't be the case
that our final complexity analysis actually
52:06 - describes it in terms of those two number
inputs. So what I'll do is try to recognize
52:11 - the height of this tree. And so I'll just
choose some path from the root to the leaf.
52:16 - And kind of in the recursive sense, that means
I take some path from my top level call all
52:21 - the way down to the base case, and preferably
the far this base case. So I know my base
52:26 - cases are either when one of my arguments
turns to zero, or when both of my arguments
52:31 - turn to one. And I think in general, the farther
base case would be a scenario where both of
52:36 - my arguments are one. So here I have a path
highlighted that ends in a one one. And in
52:41 - general, I know from one node to the next,
what I do is either decrease the M by one,
52:48 - or I decrease the n by one, it's never the
case that I can decrease both of the numbers
52:52 - by one, because that would kind of entail
that you're moving diagonally across the grid,
52:56 - which is not allowed in the gameplay. So if
I can either subtract one from em, or subtract
53:01 - one from n, and overall a path from my initial
input down to a space, like one one is going
53:07 - to have a distance of n plus m, we basically
had to subtract, you know, n and m from your
53:13 - initial node to reach that bottom level of
one comma one, that kind of tells me the number
53:18 - of levels in this tree, right using the same
arguments as before, it's still the case that
53:22 - most of this tree is going to be binary, meaning
that a node branches to two children. And
53:28 - so I have that two times two times two pattern
for the number of levels in this tree are
53:32 - saying that they're n plus m levels. So really,
the time complexity is two to the n plus m
53:38 - power, right. So still some sort of exponential,
that was just sort of the multi variable exponential,
53:43 - because I have two variables of m and n.
53:47 - And likewise, for the space complexity, you
know, the space complexity, in general for
53:50 - recursive code is just going to be the height
of the tree, the height of the tree gives
53:54 - us the maximum stack depth of the recursion.
In this case, it'll just be the number of
53:58 - levels still, which is n plus m. Cool. So
obviously, the limiting factor here seems
54:03 - to be that time complexity of two to the n
plus m time. Alright, so you probably anticipated
54:09 - the time complexity of this one being exponential.
That being said, I think it's really important
54:13 - to still have a nice argument to you know,
say what the time complexity is. That way,
54:17 - you can get a massive buy in from your interviewer
right. So don't skip the steps of trying to
54:21 - draw it out and actually defend your reason
for why the time complexity is exponential.
54:26 - But let's try to improve this now. Is there
any room to actually improve the runtime of
54:31 - this function? Well, here's that same drawing,
right? Just sort of cleaned up. So I have
54:34 - grid traveller of two comma three, and this
would be the full tree. We sort of already
54:38 - know now that I have this recursive tree structure.
What I could possibly do is notice any duplicate
54:44 - work, right? Is there some work I can prevent
myself from doing here. So take a moment and
54:48 - really remind yourself of the actions we took
in the Fibonacci problem. And see if there's
54:52 - any patterns in this tree, probably from the
gate, you notice that? Oh, I have some duplicate
54:57 - sub trees right? Have one comma two. So in
these the two highlighted sub trees in blue,
55:03 - that's sort of asking the question, hey, what
is the total number of ways I can travel through
55:09 - a one by two grid? That being said, I think
there's even more sub trees that correspond
55:14 - to that particular problem. What if you look
at this far right subtree of two comma one,
55:19 - if you really, really think about it, asking
the number of ways to travel through a one
55:24 - by two grid is the same as the number of ways
to travel through a two by one grid, you're
55:29 - just flipping the rows and the columns, but
the total number of ways should be exactly
55:33 - the same. So that's actually a pretty interesting
way you can optimize this solution. So I can
55:38 - still memorize it. That is I have these duplicate
sub problems. But possibly a really cool insight
55:43 - we can make in this problem is, you can also
sort of flip of the arguments. In other words,
55:48 - if someone asked you, for grid traveler have
a comma b, then that would be the same answer
55:53 - for a grid traveler of B, comma a, write the
order of the arguments technically doesn't
55:58 - matter here, until we can totally encode that
in our memo object. That being said, punchline
56:04 - here is, we better memorize this one. So I
think let's hop to it. All right, here we
56:09 - are back in my text editor. And hopefully,
that diagram of how we can improve the time
56:13 - complexity for this one, make some sense,
let me go ahead and kill this program still
56:17 - running. And my computer's fan is actually
going crazy. Now it's running the entire time.
56:22 - Let's go ahead and memorize this one to the
beauty of you know, solving these dynamic
56:26 - programming like problems is if we have the
initial strategy of implementing, like the
56:30 - brute force recursion, and we wrote like a
very well formed recursion, meaning that I
56:35 - actually use return values, and I reconstruct
the sub solutions all the way up to the tippy
56:40 - top. Because I have a really nice recursion
here. memoization is a very like formulaic
56:46 - pattern. So it's going to be almost the same
strategy, we did have Fibonacci, even other
56:50 - problems that we do in this lesson. So we're
going to bake in my default mental as an empty
56:54 - object. And then along with that, I'm going
to add my memo checking logic. So I know we're
56:59 - here in general, and to check, hey, are the
arguments in the memo, right, I need to key
57:07 - into my memory object using all of the arguments.
Now I have two arguments. And since both of
57:12 - the arguments combined, sort of dictate the
output, I need a key that sort of contains
57:17 - both of those in JavaScript keys are either
strings or symbols. So for us right now, really,
57:22 - strings is the most relevant one. So what
I'll do is I'll concatenate both of these
57:25 - integers together. That way, I have a string
which I can key into the object with. And
57:31 - we'll all definitely want to do is also maybe
separate them with a comma, let's say, so
57:36 - I'll say like key equals m plus a comma, plus,
and, and the reason that you probably want
57:43 - like some sort of separator between these
two arguments in your key is to make sure
57:49 - the numbers don't get misinterpreted. So I've
actually ran into this issue in the past,
57:54 - can you imagine like, if I had a scenario
where, let's say m,
57:58 - was 42. And then we'll say n was a number
three. So what I don't want to do is just
58:08 - make my key, something like four to three,
because this isn't going to uniquely identify
58:15 - the exact input argument, right? Because if
this was just my key, then I guess I have
58:21 - the same key for a totally separate set of
arguments. If I gave you four and 23, right,
58:28 - both of these combinations of very different
arguments would lead to the same key, they
58:33 - would collide at the same key. So instead,
I'll prefer to put a comma between them right
58:37 - now I know without a doubt that this key corresponds
to four comma 23. Right. So that's why I put
58:43 - a separator between them. And depending on
the language that you know, you're choosing
58:46 - for interviews, you can find a very similar
construct. Cool. So now I'll go ahead and
58:50 - check, hey, if my key is in demo, then I have
the Result Cache already. So I could just
58:59 - return net cash value. So return memo at key.
And then what I want to do is look for my
59:05 - old return value, right? So here's where I
actually do the manual recursive calculation.
59:09 - Before I return that I want to store it in
my memo, using the same key and then return
59:16 - that thing, I just put in the memo just completing
the old return logic. Cool. So you've seen
59:22 - this pattern before, I just want to emphasize
a few things. Now it's the second time we're
59:25 - seeing it. memoization, for me, at least,
is a very, very formulaic thing, right? So
59:30 - I always take the exact expression that I
returned previously, and I put that entire
59:34 - thing in the memo object, right? Notice that
my key encodes the arguments for this function,
59:41 - right? Mnn. Something that I've seen students
do in the past is do like very heavy handed
59:46 - logic, where they try to, you know, check
if the child call is in the memo. In other
59:53 - words, don't write any pre emptive logic where
you check Hey, if you know m minus one And
60:02 - so if you like concatenate those two things
together, don't check if like your child's
60:05 - key is in the memo, right? So imagine like,
this was my key right now. Right? don't check
60:12 - if that is in a memo. When you write logic
like that, it ends up being very, very duplicate
60:17 - and a little harder to debug, right? Instead
of writing your function as if it's, you know,
60:23 - reasoning for its children calls, you know
that once you actually evaluate those child
60:27 - calls, they're going to cache themselves,
right, they're eventually going to check this
60:31 - if statement anyway, alright, so don't do
any like the look before you leap logic, just
60:36 - make the recursive call. That way, every recursive
call doesn't like self service, right? So
60:41 - I prefer this way implemented. And with that,
let's go ahead and run this code. So I'll
60:46 - give this a shot grid tremor, I still have
that 18 by 18 grid, which took quite long
60:51 - last time didn't actually finish while I was
waiting. Looks like I'm still hanging here,
60:56 - because I'm actually missing a little bit
in my code. So take a moment, see if you can
60:59 - spot it, I forgot one really important thing.
So I have the logic of checking if my key
61:04 - exists in the memo. And I also have a logic
of storing something in my memo if the key
61:07 - doesn't exist, but what I failed to do was
actually passed down the memo object to all
61:12 - of the recursive calls, I want to pass it
down over here. Remember, the trick is only
61:18 - top level when someone calls like two comma
three for grid traveller, then we're going
61:22 - to initialize a brand new empty object, which
will be shared for the rest of the recursion,
61:27 - because it's passed down by reference at this
point. So that's a common mistake.
61:31 - Let's go ahead and run this now. Nice. And
there we have it. Look how quick our last
61:36 - execution was over here now is the expected
answer for an 18 by 18. grid. Cool. So here's
61:42 - what we'll do, it's evident that we definitely
set up the execution of this one, let's head
61:46 - back to the drawing board to wrap up this
problem and really see how we cut down the
61:51 - complexity here. All right, so it looks like
we definitely improved the runtime of our
61:55 - function. But I want to really understand
you know, what the big O complexity of our
61:59 - improved function is now. So sort of a way
we constructively argue for what the new time
62:05 - complexity is, is to think about where the
values of the nodes that will actually have
62:10 - to travel through. So let's say I looked at
this example, I wanted to find the number
62:14 - of voice a traveled through a four by three
grid, I know in general, there would be a
62:17 - top level node, of course, four comma three.
But in general, that refers to m n, right?
62:22 - So I'm trying to think in a very general way
right now. And so I know when it comes to
62:28 - the other nodes of this tree, they're all
going to sort of at most be four comma three,
62:35 - but then probably be less than that, right?
They have like a range of values for the nodes.
62:40 - It's not as if to solve grid traveler, four,
three, I would have to solve 530, right, that
62:45 - would be a larger grid. That doesn't make
sense here, right? I'm shrinking the subproblems,
62:49 - only in this rendition of grid traveler. And
so if I think about some possible values here,
62:54 - I know that if M is for top level, then all
of the values for m in the rest of the tree
63:00 - would be from zero all the way up to and including
four, right, it's never going to be bigger
63:04 - than four. In a similar way, since n is three
here, the only possible values for n in the
63:09 - rest of my tree are zero through three. Right?
So roughly Mele, we're a little off by one
63:15 - here, because I have to include zero, because
we know that that's a base case, in our edition
63:18 - of this problem. That being said, there are
roughly n choices for the first number, node,
63:22 - and n choices for the second number in the
node. And along with that, we know that we're
63:27 - not gonna have to travel through many duplicate
sub trees, because we memorize them away.
63:32 - And so I think what I can say here is the
total number of nodes you can possibly have
63:36 - is m times n, and I'll be the number of like
distinct nodes, right? Because I have m choices
63:41 - for the first number in the node and n choices
for the second number. I know that I'm going
63:46 - to really minimize any duplicate exploration
through the memo object. So the really the
63:51 - implication here is we started out with our
brute force recursive implementation, which
63:56 - looked like it was exponential in the time,
right, it was two to the n plus m time. And
64:00 - then by memorizing this function, we were
able to bring it down to n m times n, time
64:04 - complexity, which is much faster. Notice that
the space complexity stays here, which is
64:09 - really fine, because n plus m is some sort
of a multi linear function. Cool. So there,
64:13 - we have our nice optimal solution for this
grid traveler problem. So key thing I want
64:19 - you to take away from this one is, although
the initial narrative and the problem made
64:23 - it seem, you know, pretty specific, and pretty
different from a previous dynamic programming
64:28 - problem, like Fibonacci, was really the same
sort of story, the most important thing that
64:32 - we're going to sort of leverage throughout
in this lesson that we leverage twice already
64:36 - is try to think about your recursive functions
in terms of a tree, right, I get the most
64:41 - information out of the tree. And then from
there, I can use that tree to not only implement
64:45 - a brute force, but to also recognize, hey,
where can I optimize this brute force, that
64:49 - way you can reach for the optimal solution.
64:51 - Alright, so we've gone over two different
problems together, and hopefully we're starting
64:56 - to notice how we tackled them in similar ways.
I think it's about Tammy gave herself some
65:01 - guidelines for solving dynamic programming
problems using a memoization strategy. So
65:06 - we'll call this our memorization recipe. And
there are three different ways you can go
65:10 - about learning this topic of memorization.
And you might have different recommendations.
65:13 - This is just my particular recommendation.
So I think the most important thing to establish
65:18 - if you want to, you know, solve some dynamic
programming problem using memoization, is
65:23 - to stick to to like high level steps, we definitely
need to at first just have a solution that's
65:29 - recursive. So just make it work could be slow,
that's okay. And after that, we make it efficient.
65:33 - I think this is where a lot of students sort
of try to take on too much at once. They try
65:37 - to just solve it quickly all in one go. Right?
To me, it should be a very separate process,
65:44 - right? First, I look for correctness in my
solution. And then once I have correctness,
65:48 - then I look for efficiency in my solution.
So when we go through step one, if I just
65:52 - want to get a working solution, then I have
to start visualizing these problems as trees
65:57 - in dynamic programming problems, the gist
of them are that we have some large problem
66:03 - that I can break down into smaller instances
of the same problem. So when I visualize it
66:07 - as a tree, what I'm looking to do is figure
out all right, in the nodes of the tree, that
66:12 - should represent a problem. And when I draw
an edge between nodes, that should be shrinking
66:17 - the size of the problem. And depending on
you know how your problem is stated, you'll
66:22 - have to figure out that logic, right? In the
case of our Fibonacci, it was as simple as
66:26 - we know, we can decrement our values of n.
But in the case of our grid traveler, what
66:32 - we had to do was travel rightward or downward.
And once we do that, you want to implement
66:37 - that tree using recursion. What's great about
a tree is it's already a recursive structure.
66:42 - Right? So how do you start to translate that
kind of tree visualization to some recursive
66:46 - code? Well, you think about the leaves of
that tree as your base case, right? Lately,
66:52 - for us, it's been about some small numbers,
right? So like a grid of size one, or it could
66:57 - also be in the case of Fibonacci, just our
initial seed values of n equals one, and n
67:02 - equals two. Now, once you have that baseline
recursion, that's going to be your brute force
67:07 - solution. And so you'll want to test it. To
me this testing step is really important,
67:12 - right? So if you pass inputs into your brute
force recursion, it should give correct answers.
67:18 - Although possibly for large inputs, it may
take a long time, right? To me, there's a
67:22 - big difference between code that is slow,
and code that is wrong, right. So here, we
67:27 - should give back valid results, although maybe
our code is a little slow. Once we have our
67:32 - working brute force solution, making it efficient
using memorization is a very, very canned
67:37 - scenario. All we do is start by adding a memo
object into the mix. So this memo object needs
67:42 - to have keys which represent arguments to
our function. And the values of that object
67:47 - represent the return values for those function
calls. We know that in our functions, a unique
67:53 - set of arguments should give me a particular
result. So we're just having that sort of
67:58 - mapping inside of an object, you need to make
sure that this object is shared among all
68:03 - of your recursive calls. One way you can do
that is to pass them along as arguments. And
68:08 - lately, I've been doing that by giving myself
a default empty object at the top of each
68:13 - of my recursive calls right through my top
level call. And once we do that, we need to
68:18 - add a new base case into our code. So I'm
not going to remove any of the old base cases,
68:25 - from my brute force solution to me, I'm just
adding a new base case that captures the memo.
68:30 - In other words, if my arguments are in the
memo object as a key, then I'll return the
68:35 - stored value, I refer to that as like my memo
fetching logic, right? Looking up some stored
68:41 - value in my memo. And beyond that, the only
thing we need to do is implement our memo
68:46 - storing logic. And it's as simple as going
to exactly where we had our return values
68:52 - in our function. And then we just make sure
that we add those return values into our memo
68:57 - object before returning, right, so I always
look to the exact return expression, and just
69:03 - write some code around it, right storing that
result into another mental object before I
69:08 - return it, right? Step two is actually very,
very easy to implement, meaning it's very
69:14 - easy to memorize a brute force solution, it's
really coming up with the brute force in the
69:18 - first place, that kind of feels more difficult.
So as you're learning and practicing memorization
69:23 - for these dynamic programming problems, I
highly, highly recommend you stay very methodical,
69:29 - and follow these steps, right? Don't try to
efficiently implement an algorithm from the
69:34 - get go get a brute force working solution
with recursion, and then implement it using
69:40 - memoization. Afterwards, right. And as you
get more practice with this technique, soon,
69:44 - you'll be able to do everything all in one
swoop, but I don't recommend that until you've
69:49 - definitely finished this course.
69:51 - So we'll be sure to follow these rules for
falling problems. Alright, so I think it's
69:58 - tempting increase a difficulty and we're going
to know Their dynamic programming problem.
70:01 - So let's work on this can some function, what
I need to do here is take in a target some
70:06 - as an argument, as well as an array of numbers
by function needs to return a Boolean. So
70:10 - true or false, indicating whether or not it
is possible to generate the target some using
70:14 - some numbers from the array. And along with
that, we have some constraints here, we can
70:18 - totally use an element of the array as many
times as we want. And we can also assume that
70:22 - all input numbers, so the target sum as well
as the numbers of the array are non negative.
70:27 - So let's try to understand what this question
is asking. Let's say I gave you this example
70:31 - case. So it looks like our targets, I'm a
seven, and the array of numbers is 534, and
70:36 - seven, here, the response should be true because
it is possible to generate seven, by adding
70:41 - some amount of numbers from the array, one
way you can generate seven is by just doing
70:46 - three plus four, another way would actually
be to just take the loan seven, because seven
70:51 - is actually a member of the array. So it's
definitely possible to generate seven using,
70:56 - you know, some amount of numbers from the
array. So that's why we return true. Let's
71:00 - see, I gave you another example. Let's say
I gave you a target sum of seven again, but
71:04 - I gave you a different array of just two and
four, this is actually going to return false,
71:08 - because there is no possible way that combinations
of two and four can actually sum to seven.
71:14 - Cool. So that's really what the question is
asking. Now let's try to think about how we
71:17 - can frame this problem of recursively. Right?
Hopefully, you've already gathered in your
71:21 - mind. If we have a smaller amount of targets
some, then they'll tend to be a smaller, easier
71:27 - problem than a larger number for targets.
All right, so let's start to think about the
71:32 - recursive structure. For the first example,
we know in the long run, we should be able
71:36 - to derive the answer true from the string
that we make. So like, we always say, we should
71:41 - encode the arguments to our function into
the nodes of our drawing. That being said,
71:47 - since in the problem, they told us that we
can reuse an element of the numbers array
71:51 - as many times as we need, I'm just going to
omit that from the node drunk, because basically,
71:55 - every node every function call is going to
receive the same array. So I'll just list
71:59 - the target sum in every node. So I start with
seven, and I have to think about how I can
72:04 - transition to other nodes, right? How can
I shrink the size of this problem? Well, I
72:10 - know that I only have, you know, four options
I can take right have an option for every
72:14 - element of the array. So basically, if I'm
at this seven node top level, I can branch
72:19 - to some children, and sort of the rule for
my transition is you can either take a five,
72:23 - take a three, take a four, take a seven. And
if I actually take you know those elements
72:28 - as a choice, they are going to decrease my
current target sum. In other words, seven
72:34 - minus five is two, seven minus three is four,
seven minus four is three. And of course,
72:39 - seven minus seven is zero. So notice, we have
a very particular rule from traveling from
72:44 - a parent node to some child, I can just carry
over this pattern. However, we have to watch
72:49 - out right, so let's say I tried to flesh out
this note where my target sum is two, if I
72:53 - look at the options I have, right, I still
have the options of 534, and seven, however,
72:58 - none of them are really compatible with this
target sum of two, right, what I don't want
73:02 - to do is take any of these choices, because
that would kind of give me a negative target
73:08 - sum. So I can't really flesh out this note
two anymore. That is there are no valid options
73:12 - for this node. However, some of these other
nodes like this for to have valid options.
73:17 - So what I can do is take a three or take a
four, and of course, I get a one and zero
73:21 - respectively. And I'll also do this for the
three over here, right? For this three node,
73:26 - I can only take a minus three as a choice.
Cool. If I look at all of the nodes that I
73:32 - have, now, I like the leaf level, it looks
like they all sort of bottom out at a base
73:36 - case, that is there is no further choices
we can take. And I also noticed that some
73:41 - of my nodes have a zero in them, if I look
at the notes that have a zero in them, they
73:46 - actually are a really nice base case, because
I basically have found that I can generate
73:51 - to the original target sum right away, you
can kind of understand the base case, when
73:55 - the target sum is zero is you can always generate
a sum of zero by taking no elements from the
74:02 - array, right? So these zero nodes are trivially
solved. And to me, they should return a true
74:07 - backup to their parent, right. And it's sort
of on the flip side for all of my nodes that
74:13 - are not zero. And they also can't break down
into any further nodes. Those return false,
74:18 - right? Because they kind of have a leftover.
And I know there are no possible options I
74:22 - can take to reduce that further. So all of
these other nodes should return false to their
74:26 - parent. And remember what this question is
asking, right? It's really asking, Hey, is
74:31 - it possible at all to generate the original
target sum? And so the logic is when these
74:36 - values these Boolean values return to their
parent, the parent should just check if at
74:41 - least one of them is true. And if at least
one of them is true, then that parent should
74:45 - also return true. And if I look at this for
note, have a tree above it, and that sort
74:51 - of answers the question, Hey, can I generate
a sum of four using elements of the array
74:57 - and you totally can because if you look at
the elements of the array, there is exactly
75:01 - one for so I can just take that into my son.
So I'll be sure to bubble up, you know all
75:05 - these Boolean values to their parent. And
again at the parent will just make sure that
75:10 - at least one of the values that gets back
is true. And so if at least one of them is
75:15 - true, then the parent itself will also return
true. So very reminiscent of some like Fibonacci
75:21 - bubbling up pattern as well as our grid traveller,
except now we're kind of adapting this for
75:26 - some boolean data, but it's really the same
structural understanding I have. Cool. So
75:31 - that was an example where we said true, right,
there is a way to generate the sum. Let's
75:37 - look at another example. Right? How do we
know the flip side. So if we have this example,
75:41 - right, seven, and an array of two, four, in
the long run, that's gonna return false, right,
75:45 - there's no possible way you can generate that
target sum of seven. So the tree for this
75:49 - example would look like this. So this is a
full tree. Notice that all of the leaves get
75:54 - as low as one, but they can't be broken down
any further. Like we just said, in our last
75:58 - sketch all of these ones, since they can't
be broken down any further, and they haven't
76:03 - reached zero, they're going to return a false
up to the parent. And I know that if I bubble
76:08 - up all these false values, of course, a top
level call will also return false. Right?
76:13 - So it looks like a key insight we have for
this problem is, if we find at least, you
76:18 - know, one base case that returns true, I know
that I can sort of stop early and just return
76:23 - true all the way up to my parent, because
they're not really asking like, how many ways
76:27 - can you generate the target sum? They're just
asking, Hey, yes or no, can you generate the
76:32 - target sum at all. So that's gonna be a really
nice way to implement this code. I think we're
76:37 - ready to jump right into the code. So let's
do it. Okay, so let's go ahead and implement
76:42 - this can sum function. So since we're going
to solve it recursively, I think a good starting
76:47 - place, as always, is to maybe handle some
of the base cases. So when we drew up the
76:51 - tree, I noticed that one of our base cases
was when the target sum reaches the value
76:57 - zero, right? If our target sum is zero, then
we have like, basically trivially solved the
77:01 - problem, because you can definitely always
generate the target sum of zero by taking
77:06 - no numbers from the array, right? So I'm going
to return true. If ever I reach a zero, then
77:11 - Apart from that, I think let's go ahead and
work on the recursive scenario. So I know
77:16 - that I need to establish some logic where
I make a recursive call or a branch for every
77:21 - element of the numbers array. So what I'll
do is I'll iterate through that array of numbers.
77:26 - So I'll use some for let of syntax we'll say
let num of the numbers, right. So if you're
77:32 - unfamiliar with the syntax, all it does is
iterate through every element of the array.
77:35 - So for example, let's say I just called the
first example for can sum of seven, and an
77:41 - array of two, three, if I just console dot
log, the num, I'm just going to see the elements
77:47 - printed out of two, three, right, so let's
give this a quick spot check. Nice, so just
77:51 - iterating through every number of the array,
no tricks here. But now that I have that number,
77:56 - I need the branching logic. So remember, the
logic we use for transitioning from one node
78:01 - of the tree to the next, what we did was subtract
our current choice of number from the target
78:07 - sum, and they basically gave us like the new
target sum. So I'm going to express that and
78:11 - maybe some variable, so I'll say, Alright,
I'm going to generate the remainder by calculating
78:16 - the difference between the target sum and
the number, right, so I'm just subtracting
78:21 - the number from my target sum, that gives
me my new remainder, which becomes a target
78:25 - sum. Right? So at this point, I think I need
to call recursively on can some of our pass
78:30 - in this remaining quantity?
78:33 - It doesn't need a second argument, still,
I'm still gonna pass in the same exact numbers
78:37 - array. So I'll still pass in numbers unchanged.
I think that you know, the fact that we pass
78:43 - in the same exact numbers, right, it's pretty
consistent with the way they stated the problem,
78:46 - because we can totally reuse the numbers of
the array as many times as we like. Cool.
78:52 - So now that I'm using our function, again,
I'm making the recursive call, I want to think
78:56 - about what this call will return. I know at
any point in time, my can sum function is
79:01 - going to return Boolean. And what's great
about boolean data is there's only two possibilities,
79:05 - right, either true or false. So I think, based
on what we said about the tree was, if this
79:11 - call, if that returns true, then I can just
ultimately respond with a true right now.
79:17 - So I'll write it like this. So this is saying,
All right, if we figure out that it is possible
79:25 - to generate the remainder now using numbers
of the array, then I can return true for this
79:30 - larger problem of target some, right? So if
I find at least one way that works out, then
79:36 - I'm going to do an early return true. And
the really important pattern here is we don't
79:41 - want to write the LS and then return false.
Instead, we'll want to return false after
79:46 - the for loop. And so here's the reason why
you want to return false after the for loop.
79:50 - I only know that after I attempted you know
all possibilities and I found that none of
79:55 - them worked out Can I actually say that it
is impossible to generate the target some
79:59 - Right, so I need to make sure that this for
loop tries all possibilities of number. Before
80:05 - I can say false, the target sum cannot be
generated. That being said, there's one thing
80:10 - we should add to our code. So if you look
at line six, all right, I'm subtracting our
80:14 - choice of num from the target sum. And that
means that sometimes the remainder might become
80:19 - negative. So remembering our tree structure,
we made sure to sort of return a false whenever
80:24 - we had a sum note, I didn't do any branching.
To kind of account for that I can kind of
80:30 - bake that into another base case. But this
time, make sure it doesn't return true. So
80:34 - I'll say, you know, if my target sum is negative,
if it's less than zero, then you've gone too
80:40 - far. And you can just return false. Here,
it's safe to just automatically return false
80:46 - if your target sum hits something less than
zero, because you've gone too far. And there's
80:51 - really nothing else you can add from the numbers
array to ever fix that negative target sum.
80:56 - Remember, they told us in the problem, that
your numbers are always going to be provided
81:00 - as positive numbers or just zero, right? So
let's go ahead and give this a go. So I'll
81:07 - try all of these examples. And we'll see what
we get. So I expect a true true false, true,
81:16 - false. Cool, so looks like a few of them are
working right, it looks like the first four
81:20 - are working totally fine. But looks like on
that last example, my program still running.
81:27 - And if you notice, I chose a pretty large
value for em. So kind of like we expect this
81:33 - solution has correctness. But it possibly
lacks some efficiency, it looks like it just
81:37 - finished, the definitely took way too long.
And so it's a very interesting example of
81:42 - a slow input to can some, because for one,
the length of the array is pretty sure I only
81:48 - gave two elements here. But it seems like
this number as a target sum really affected
81:54 - the runtime. So we'll do, let's head back
to the drawing board, and talk about the complexity
81:59 - of this baseline solution. Alright, so we
implemented the brute force for our khamsum.
82:05 - But obviously, now we want to make it a little
faster. But before we kind of just jump into
82:08 - memorizing the solution, let's at least describe
the complexity of our current brute force.
82:13 - So let's try to visualize this example. So
I have a target sum of eight. And my choices
82:18 - for my numbers are two, three and five. In
the long run, they should return true, the
82:22 - visual for the full tree would look something
like this, notice that it's fairly large tree
82:27 - of forbs and relatively small inputs, right,
I only have a target sum of eight, and only
82:31 - three choices. So let's try to describe the
complexity of this, I'll sort of generalize
82:35 - the shape of it, get rid of those numbers.
So this is the overall shape of the tree.
82:40 - And I know I want to describe my complexity
in terms of the input to my function, this
82:44 - function has two inputs to the right, I'll
say that M is the size of the target sum,
82:48 - and n is the length of the array I'm given,
I know that both of these arguments definitely
82:53 - have an effect on the dimensions of this tree.
So like we did in all of our other examples,
82:57 - I'll start by maybe analyzing the height of
this tree, that is a what would be the maximal
83:03 - distance from the top level call to a base
case, or in the structure of the tree, what
83:08 - is the maximal distance from the root of the
tree to the farthest
83:11 - leaf. So if you sort of imagine that, we have
m as the root of the tree, imagine that along
83:18 - the left hand path, we just did a minus one
all the way down, right? So we kept taking
83:22 - a minus one, right? In the worst case, maybe
there's a minus one present in our a numbers
83:27 - array. In the worst case, the distance from
the root to a base case would be exactly m,
83:32 - because you have to subtract one m times,
right. So I can basically say that the height
83:36 - of this tree is M. And it kind of like we
said in our other problems, that means that
83:40 - the number of levels is m right. So now that
I've identified the height of this tree, the
83:45 - move is now to identify the branching factor.
That is, how does the number of nodes change
83:51 - from one level to the next. Remember that
initially, we described this particular tree
83:55 - example is having numbers array length of
three. And you'll notice that the maximum
83:59 - branching factor is exactly three or in general,
N, right? because n is the length of the array.
84:06 - So for example, if I had three numbers in
the array, then a node would have at most
84:11 - three children, right? Cuz you have three
options to take. We've seen this pattern before
84:15 - I have n levels, and from one level to the
next, I would multiply the number of nodes
84:20 - by n, right? This is the same thing as saying,
Hey, we take n and multiply it by itself,
84:26 - m times. And this would definitely give us
an exponential complexity, right in particular,
84:31 - and to the M time complexity, like we always
say another great thing about this type of
84:35 - diagram is we can also derive the space complexity,
right? So what would be the space used by
84:40 - the call stack, it would really just be the
height of the tree, which we already described
84:44 - as M. So overall, our brute force is looking
at an end to the M time complexity, and M
84:50 - space complexity. So now that we actually
have you know those concrete numbers for our
84:56 - complexity, let's go ahead and focus on how
you can truly improve this So here's again,
85:01 - the drawing for this particular example. It's
a fairly large one. And typically, you know,
85:05 - when you're trying to notice where there is
room to be optimized, you might have to give
85:08 - yourself a sufficiently large example to see
these scenarios. So in this example, I do
85:14 - have overlapping subproblems. And in the context
of my tree, that means I have duplicate sub
85:18 - trees. So I can look at possibly this subtree
rooted at three, notice that the root of that
85:24 - subtree is trying to answer the question,
Hey, can I generate a target sum of three
85:30 - using the array? And of course, once you find
that answer, that answer is never going to
85:34 - change for your target sum of three, right?
So I know that all three of these sub trees
85:38 - are trying to ask the same problem. And so
what I'll do is I'll just cache those results
85:44 - in my memo object like we always do. Let's
go ahead and work on that. All right, welcome
85:50 - back to my code editor. And same stuff, different
days. Let's go ahead and minimalize. This
85:56 - can sum function, right. Once we've established
the brute force through the recursion, then
86:01 - memorization is pretty formulaic. Right? Alright.
So we'll start by just baking in our memo
86:05 - object like we usually do. So if someone calls
our function without a third argument that
86:09 - is like a top level call, we'll be sure to
give them a new object. And I'll, before I
86:16 - forget, be sure to pass down this memo object,
I'm going to make sure that every top level
86:20 - call and it's recursive tree shares the same
memo object. But now I need to figure out
86:25 - what what should I use to key into the memo
object. So here I have two arguments of my
86:30 - original function are I have targets summon
numbers, what I want to do is try to notice,
86:35 - you know, which of these arguments is actually
going to directly impact the return value.
86:40 - So I know that through the recursive calls
like this call over here, the numbers argument
86:46 - doesn't change. And so if it doesn't change,
then right now, it doesn't really affect other
86:50 - return value. So I'd be okay to just use the
target sum as the key into this memo. So we'll
86:58 - go ahead and do that. So I'll check if my
target sum is in the memo, that I've seen
87:04 - that sub problem before, so I can just return
the stored value. Cool. And now I have my,
87:11 - you know, memo fetching logic. But now I need
to actually store things in the memo. And
87:17 - the trick is, what I want to do is look at
all of the return values that were not base
87:22 - cases, and I need to now store them in my
memo. So I have to return values here, right,
87:27 - these two lines, lines, 10 and 14. And so
I need to store data into the memo for both
87:32 - of those lines, it's as simple as quite literally
going into your memo using your key, so target
87:39 - some, and then assigning the value we just
returned.
87:41 - So I'll just write it like this. And this
is going to be sort of a hard and fast rule,
87:47 - you can always use our for a memorizing a
brute force recursive function, right. So
87:53 - I'm just going to take exactly the lines or
the expressions that I returned in the recursive
87:57 - scenarios. And now just store them in the
memo. Cool. So let's go ahead and give this
88:03 - a shot, this code is looking pretty good.
And remember before this last call with an
88:08 - input of target, some 300 took notice will
be long. But I think now when I give this
88:13 - a shot, right, it finishes really quick. So
this is going to be a nice optimized solution
88:19 - for cancer. Really, most of the work of this
problem was done in the brute force. And then
88:23 - afterwards, it's really just a minor adjustment
to make it efficient. So to wrap up this problem,
88:28 - let's go ahead back to the drawing board and
talk about the improved complexity. So we
88:34 - definitely memorize the heck out of that code.
But let's recap by just understanding what
88:38 - the new complexity is. So again, we're saying
that M is the target sum, and n is the length
88:43 - of the array. Initially, we said that our
brute force solution had an end to the M time
88:47 - complexity, which is exponential. And actually,
once we memorized it, we really cut down on
88:52 - that complexity, we brought it down to n m
times n type complexity. And so here we say
88:57 - that the memo is complexity is now m times
n, because of the memo object, right? We know
89:02 - that the value of the nodes in the tree are
just going to be values up to m or their m
89:07 - different possible values we can have in a
node. However, it now since we are able to
89:12 - cache values or cache results inside of the
memo object, I'm never gonna have to re explore
89:18 - a subtree before M. That being said, I select
the branch and times for each of those nodes,
89:24 - right. So overall, I have m times n nodes.
89:30 - So hopefully that can some problem made some
sense, because we want to do now is actually
89:33 - carryover a lot of that knowledge to solve
this new Howsam problem. So this problem is
89:38 - very similar, it still asks us to take in
some target some an array of numbers, but
89:42 - this time around, we want to do is return
an array containing a combination that adds
89:46 - up to exactly the target sum. And if there's
not any combination that actually leads to
89:50 - the target some, then I should just return
null. Along with that, if there are many possible
89:55 - combinations that can reach the target some
that that can return any of those. So you
89:59 - probably Already recognizing that this house
some problem is very similar in logical structure
90:03 - to the can some problem right? instead of
returning a Boolean instead now I want to
90:08 - return exactly the combination of elements
of the numbers array that leads to my target
90:14 - sum, so it's a little more involved. That
being said, let's take a look at some examples
90:18 - to make sure we're on the same page. So let's
say someone asked us to calculate how some
90:21 - and our target was seven, and our array of
numbers are 534, and seven. So there are actually
90:27 - a few different combinations that can give
you your target sum of seven. One way would
90:31 - be to take three plus four, that's one possible
answer, another possible answer would just
90:35 - be returning an array of seven. So no matter
which combination array you return, it'll
90:39 - be considered correct in either scenario.
Let's say I gave you another example, where
90:43 - your target sum was eight, and your choice
of numbers were two, three and five. One possible
90:48 - solution for a combination is two plus two
plus two plus two, right? So I returned that
90:53 - in an array, another combination would be
just three plus five, notice that no matter
90:57 - what we're always looking to get back in array,
if it is possible that our target sum can
91:03 - be generated. But let's look at the flip side.
Let's say that we were given this input, so
91:07 - I have a target sum of seven, and my array
of numbers is just two and four, the first
91:11 - thing we notice is it is not possible to actually
generate the target sum of seven. Like they
91:16 - said, the problem in this scenario, what you
want to do is return Nome sort of symbolize
91:20 - that, hey, it's not possible to generate any
combination that leads to the target sum.
91:24 - All right, I think it's important that we
think about one more scenario. So let's say
91:29 - that I was given a target sum of zero. And
we were given really any array of numbers.
91:33 - In this case, I just gave us one, two, and
three, we already know that in our previous
91:37 - problem, we had to return a Boolean result,
we use the target sum of zero as a base case.
91:41 - And so what I want to think about now is how
is the target sum of zero just trivially solved?
91:46 - Well, if I want to know the combination that
sums to zero, and that's really just the empty
91:52 - combination, right. So I think the logical
result here is to return an empty array, when
91:57 - your target sum is zero. Remember that an
array represents a combination. And if I have
92:01 - an empty array, that means I take no elements
into my combination, right? If I summed up
92:06 - all the elements in that empty array, it would
indeed have a sum of zero. So that's going
92:09 - to be a really important facet that we need
to encode into our logical tree that we draw
92:13 - next, as well as our code, right. So let's
take a look at how we can structure the tree
92:17 - and try to take a step toward really understanding
how we can implement it in some code. So let's
92:23 - say we're stepping through this particular
example of target sum of seven, as well as
92:26 - an array of 534, and seven. So the full tree
and really the same tree that we drew last
92:31 - time would look something like this. from
the get go, I see that I have some scenarios
92:36 - or some nodes where I reach zero, which means
that it's definitely possible to generate
92:41 - the target sum. That being said, How can I
get back a valid result, right, so I need
92:46 - to return an array. So you sort of reframe
this problem in that, all right, all of these
92:51 - base cases that have a target sum of zero,
they are trivially solved because they are
92:55 - combination would just be the empty array.
Right. So for now, I'll just kind of trace
93:00 - through how one of these base cases would
return. So I know that this particular zero
93:04 - is going to return an empty array. And like
we always say, when it returns, it's really
93:08 - returning that information to its parent,
right. So this array sort of bubbles up to
93:12 - its parent. And now what I want to do is actually
manipulate this return value, I want to add
93:17 - something to it. So I want to really put the
number that brought me to that zero in the
93:23 - first place. And that would really be the
choice of four. So notice along the edge,
93:26 - I have them labeled with a minus four, meaning
that, hey, I took a choice of four. And I
93:31 - want to actually add that choice into the
current array. So I'll just really push it
93:35 - into the right, of course, I actually don't
need a negative sign that was just for the
93:38 - sake of understanding the math here. But now
that my call to how some of four is returning
93:44 - an array of four, that array bubbles up to
its parent. And of course, now I need to push
93:50 - that edge that I took, which would be that
three, so that three gets pushed to the rear
93:54 - as well. And if I look at what I'm seeing
right now, it looks like above the seven,
93:58 - we have an array of four, three, which makes
sense, because you can totally generate a
94:03 - target sum of seven by doing four plus three,
awesome. So four comma three would be a valid
94:08 - answer in this particular problem. But like
they said, you could return really any valid
94:13 - combination if one exists. So let's say we
retrace through this far right base case,
94:18 - we know that this zero is going to return
an empty array, that empty array will be returned
94:22 - to the parent. But we also have to add the
value according to the edge, right? So I would
94:28 - press seven in this array. And that makes
sense because I could generate the target
94:32 - sum of seven by just summing up a loan seven.
So that's still good to go. So I'm feeling
94:37 - pretty good about how we can return a valid
combination if one exists about let's say,
94:42 - there are some options that we take that don't
work out. So for example, let's say we explored
94:47 - this node first, right? This was the first
base case we had and logically in the space
94:51 - of our code, it really would be right. So
I know that this node can't really branch
94:56 - out any further. So it's sort of a dead end.
This is a node that should work Turn no meaning
95:01 - that, hey, there is no way I can generate
a target sum of two using elements in the
95:07 - array. Or if you look at the elements of the
array, they're all too big, right? So I know
95:11 - that this base case is going to return null.
But along with that, if you look at the next
95:15 - base case, we would hit it would be this one,
which also returns Now, if you look at the
95:20 - next base case, to the right, that's actually
an affirmative one that should return an empty
95:23 - array. So it's kind of reasoned out how these
return values should be considered at their
95:27 - parents. So I know that both of these values,
but to the left of the node four would return,
95:33 - right, so it kind of bubbles up a little bit.
But for the array on the right hand side,
95:37 - I would also have to push the edge that I
took, which was a four in this scenario. So
95:42 - now I'm sort of comparing you know, the nollan,
this four, or really, I'm comparing all of
95:47 - the branches that I take from a node. And
if at least one of the branches gives me back
95:53 - an array that I know that it's possible, right?
So basically, in this scenario, the array
95:58 - of four actually wins out over the null, right,
I know it's possible to generate a four. And
96:03 - I'll just continue this process, right, now
I can return these two values to its parent.
96:07 - So let's I'm considering them at seven. In
the same way, I would have to add the edge
96:12 - I took, which would be a three on this array.
And then from there, I know the array would
96:16 - always override the null, right? So I could
just ultimately return this four comma three.
96:22 - And a really nice pattern in this code is,
as soon as we find a winning path through
96:27 - the tree, or that is we find a combination
that creates a target sum, we can actually
96:32 - return early because we don't need to really
travel through the rest of this tree. We don't
96:35 - need to explore any other options because
they're happy with at least one combination.
96:39 - Right? Awesome. So again, to recap, the punchline
is for this tree, I have the information for
96:46 - a combination, encoded as a path through edges
of this tree, right, so I've looked at this
96:51 - path I have highlighted in yellow, I see that
I took a three followed by four. And that
96:55 - eventually led to a zero. So I know that one
valid combination would be four comma three.
96:59 - All right, at this point, I'm feeling pretty
good. Let's go ahead and work on the code
97:03 - for this now. All right, here we are back
in my code editor, let's work on solving the
97:08 - house implementation. So the codes going to
be pretty similar to the cancer problem, it's
97:13 - the really the whole point, we're just kind
of going to finesse the return date over here,
97:17 - we're gonna have a very similar base case,
like we said, in the tree diagram, whenever
97:20 - we have a target sum, that's zero, we have
trivially solved the problem, because I could
97:24 - just return an empty array. And a similar
way, what we can do is also have a separate
97:29 - base case, if our target sum ever reaches
a negative quantity, then I'll just return
97:34 - null. That's because it's never possible to
generate a negative target sum, right? Remember,
97:38 - in this problem, the array of numbers is only
going to be positive ones. Cool. We ended
97:44 - up writing very similar base cases for our
last problem, except now instead of returning
97:49 - true, we return an empty array. And instead
of returning false, we return nil. Nice. So
97:53 - let's go ahead and get the branching logic.
Right, how do I want to make my recursive
97:57 - calls, I'm going to need to make a recursive
call for every element of the numbers array.
98:03 - So I'll say, let num of numbers, we'll just
iterate through every number of this array.
98:09 - And I'll go ahead and do the same logic as
last time. So I'll subtract the number from
98:13 - my target sum, they'll give me my remainder,
right? So remainder equals target sum minus
98:17 - mine number. Cool. So this remainder is now
what I want to find the combination for, right?
98:23 - So here, I would make my recursive call. So
how some pass in the remainder. And the second
98:29 - argument will stay exactly the same. I'm going
to pass along the same exact numbers array.
98:33 - I don't need to remove anything from the numbers,
right? Because they tell us in the problem
98:37 - that we can reuse the elements
98:39 - however we see fit, right. Cool. So now I
need to really think about what type how some
98:44 - returns. So this problem is interesting, because
we basically have two different types, right,
98:47 - we could get back in array of some elements,
if it is possible to generate the remainder,
98:53 - or we can get back know, when it's not possible
to generate the remainder. I think no matter
98:58 - what I get back, I'm just going to save into
a variable. So I'll say console, this is the
99:03 - result for the remainder. I'll call it remainder
result. Cool. So I know that in the context
99:09 - of like how I thought about this logic in
terms of the tree, I wanted to basically do
99:14 - an early return if I found a valid combination.
And so I'll go ahead and check you know, if
99:21 - the remainder result is not No. So the implication
if I enter this if statement, that means that
99:27 - it is possible to generate the remainder.
And so what I can do is just return early
99:33 - and I can return of basically almost the same
remainder is also the same array. However,
99:39 - I need to make sure I include the element
that I took recall from the diagram, whenever
99:44 - we had a recursive call that returned in array,
the parent had to also add the number that
99:51 - it took transition to that recursive call
in the first place, right. So in the context
99:55 - of the tree, I had to put the labels of the
edges into the array here. means I have to
100:00 - put the num into this array. So some syntax
I can use for that. So use some spread operator.
100:06 - So I can copy all the elements of the remainder
result into this new array. But I'll also
100:12 - add on the number I just took, right. So all
I'm doing in this return line is, I'm returning
100:17 - basically the same array that I get back from
my recursive call, with the number added to
100:22 - the end of it. Let's say you're unfamiliar
with this syntax, I can preview it really
100:26 - quick. It's pretty neat. Let's hop into the,
you know, repple. So let's say I had some
100:30 - array, let's say it was this array of just
a, b, c, sort of an isolated example, you
100:37 - can use the spread operator, which is the
three dots here to like unpack an array. And
100:41 - you can sort of say like, new array equals
bracket. So this gives me a new literal array,
100:47 - I can spread out the elements of the old R,
right? So if I do that, the new array just
100:52 - has all of those same elements, vi, capitalize
that and properly, cool, we can extend that
100:58 - syntax, right. So I still have that array
of ABC. Let's say I had another variable,
101:03 - we'll call it other array, what I can do is
create a new literal array, copy all the elements
101:09 - from our using the spread operator. And then
I can comma, separate any additional things
101:14 - I want to add while I'm here. So let's say
I added a z. So if I look at my other array,
101:19 - now, it contains ABC, and also this new element
z. So it's all I'm doing on this slide, right?
101:24 - I'm returning the same combination, that my
recursive call gives back with the number
101:30 - that I took are added to the end of it. Cool.
So what's really nice about this code is it's
101:35 - very reminiscent to our previous code, because
we have an early return. So if I find at least
101:39 - one way, to generate the target sum, I can
just go ahead and return that first way that
101:44 - I found, right, they say we can return any
valid combination here. But let's say this
101:48 - for loop finished, and we never found a valid
way to generate the target sum, then after
101:53 - the for loop, you can just return null, because
it's not possible not to generate the target
101:59 - sum, apparently. Cool. So this code is looking
pretty good. I think let's let's give it a
102:05 - shot. It goes without saying no, sometimes
the remainder right will become negative.
102:10 - But we already handled that with this nice
base case, right. So let's test this code.
102:16 - So I already have some example outputs over
here. So looks like our first few examples
102:23 - are working. Obviously, our last one seems
to take quite a long time. So I'll just kill
102:28 - this program early. But before we talk about
how to optimize for this larger example over
102:32 - here, if you look at these other examples,
what I can see is this array of 322 does add
102:39 - to seven. So that's looking good. This array
of four, three, also adds to seven. So that's
102:45 - good. We already saw that this example of
seven and two for now, that's your return
102:49 - No, because it's not possible generate that
sum. And it looks like the array for the eight
102:54 - example is also good to go. So notice here,
there are also some other arrays that we could
102:59 - have returned and would still be considered
valid output, the exact combinations that
103:03 - we get back are really just dictated by the
order that we happen to iterate in the array.
103:07 - So for example, let's say I switch things
around here, like I did 352, it's really the
103:12 - same array, just in a different order, we'll
probably get a different answer for that particular
103:17 - one, right? So I'll run this now, notice I
get 233. But either case, that still sums
103:22 - to eight, so we're
103:23 - totally good to go. Awesome. They bring this
back to the original code. And yeah, it seems
103:28 - that now the limiting factor seems to be the
speed of our solution, right? We've been here
103:34 - before. And so let's go ahead and talk about
the complexity of it. So we know that the
103:40 - time complexity for this is almost identical
to what we did in the cancer problem, which
103:44 - is conveniently over here. But sort of refresh.
By now you recognize that all right, the time
103:51 - complexity should be described in terms of
like the recursive tree, let's let's lay down
103:55 - the foundation. And we already know that M,
we're going to call the target sum. And let's
104:00 - also say that n is the numbers dot length.
Cool. And so if I think about the number of
104:07 - recursive calls that I'm going to make, it's
really the same as last time, right? So I'm
104:11 - going to say that, hey, the time of this function
seems to be Oh, and I have an exponential,
104:19 - the base of the exponent is the branching
factor, which is the length of the array.
104:23 - And then the depth of the tree would be the
exponent, which is just m, right. So this
104:29 - was the same time complexity as last time
for a brute force writes M to the M power.
104:33 - However, it looks like we have some additional
time that we consume in this function really
104:39 - coming from this expression, right. So if
I look at line nine, in particular, this line
104:45 - creates a copy of an array. So that will actually
take sort of a linear number of steps to copy
104:51 - over every element of an array right. So I
will have to consider the cost of this operation.
104:56 - It sort of under the hood like iterates through
the remaining result, I know that the maximal
105:03 - length of the remainder result I can get back
will be at most m, right? Remember that remainder
105:08 - result in the worst case is going to be in
array, the longest that array could be is
105:13 - exactly the target sum, right? Imagine that
we had the most simple, you know, sort of
105:17 - a combination to generate the target sum.
If it was just a bunch of ones, right, my
105:22 - target sum was 50. And I had an array filled
with one, then I can just do one plus one
105:28 - plus one plus 150 times to generate the target
sum. So in the worst case, this copying operation
105:34 - will take m steps, I need to do that for every
recursive call. And so if I have this many
105:41 - number of recursive calls, in addition to
that, I do an M operation, you just multiply
105:46 - that M, right. So the time complexity for
this brute force so far, is n to the n power
105:52 - times M. Really, the thing we want to optimize
away is this exponential part, right? So I
105:57 - really want to focus in on that. But while
we're here, let's go ahead and talk about
105:59 - the space of this brute force. So the space,
there are things to consider the terms of
106:05 - the stack space, it's going to be the same
as last time, so it's going to be o of m.
106:09 - But think about any other space I use up I
guess you should also consider the array that
106:15 - you return back, whoever we know that we're
going to return back like the first array
106:20 - that we find all the way back up to the top
level call. And the combined length of all
106:25 - of those arrays that we return is really just
going to be in worst case, M. Right. So I
106:31 - would still say that the space complexity
for this function is just m right now. Cool.
106:37 - Obviously, let's work on optimizing this time
complexity. So this was the brute force. So
106:42 - brute force. And you guessed it, and there
is definitely some people get some problems
106:47 - in this brute force. So we'll just memorize
it away. So very formulaic stuff, most of
106:53 - the work is always the brute force. So I'll
start with my empty mental object. And like
106:58 - we always say, we'll use the target sum as
our key. So if I've seen the target sum before,
107:02 - that is if it's in the memo, then I'll return
what I have stored in the Mo. And at this
107:10 - point, what I want to do is make sure I pass
along the same memo object to all of the recursive
107:14 - calls. That way, they can benefit from any
information or any sub problems that I worked
107:18 - on over here, right in this stack frame. Cool.
At this point, I need to make sure that I
107:23 - take all of the return lines that I had before,
and I store them in the memo, right? So the
107:30 - trick here is I can say, memo of target. So
I'm going to save that array. So notice that
107:37 - now the values in the array, or sorry, the
values in the memo object are going to be
107:43 - arrays, because that's the return value of
this. It's either going to be an array or
107:46 - not right? So I'm just going to complete this
return value by returning what I just put
107:50 - in the memo.
107:53 - And in a similar way, I also want to memorize
this late return. So we'll also be memo of
107:59 - target sum equals No, I can just still return
No. Cool. So with that change, right, it's
108:08 - very, very straightforward change. Let's see
how this does. Now. I know that for this last
108:14 - example of how some 300, it is not possible
to generate the sum of 300 using just sevens
108:19 - and fourteens. So should we get an all for
that one. So let's give that a shot. Nice.
108:24 - And there, we have a really quick running
a know of that very last example. So we definitely
108:29 - had an effect on the runtime here. Let's talk
about how we changed up the complexity of
108:35 - this code. So that was a brute force. Let's
talk about the memoized version. So it's good
108:42 - with the time over here. So we know that in
terms of the time complexity from the number
108:47 - of recursive calls that we make, it's the
same story as our last problem, right? We
108:51 - just have to consider any other time operations,
which would still be this array copying. So
108:57 - but in just terms of the recursive calls that
we make, it's going to be n times m, recursive
109:03 - calls. And then in each recursive call, I
need to do this copying pattern, right copying
109:08 - over the contents of an array, and the array
will be at most m elements long. Alright,
109:13 - so if I have this many recursive calls, and
each recursive call needs to make an M length
109:19 - operation, now I just multiplied by another
m term. So right now this looks like n times
109:24 - m times m, which is the same as n times m
squared. And I'll talk about the space complexity.
109:32 - So the space complexity will be at least as
big as our brute force, so it's going to be
109:38 - at least o of M, above, now we have to consider
all the space we use up in the memo object.
109:45 - So I think about the keys of this memo object,
the keys are just going to be all unique values
109:51 - of target sum, right? Because I just literally
use target sum as a key on all these lines,
109:56 - right? But then everything about the value
or the values are going to be Pretty chunky
110:00 - now, because sometimes of value but in the
object is going to be an array. And I already
110:07 - said that the maximal length of any of these
arrays that I returned is going to be of length
110:11 - M. Right. So to me, it's now the case that
your space complexity comes from mostly your
110:16 - mental object, which is going to be of size,
m times m, right, because you have m keys.
110:23 - And each key has a value, which is, at worst
going to be an array of M elements. So it's
110:28 - m times m, which is m squared. Cool. Notice
that we definitely cut down on the brute force
110:36 - implementation, especially in terms of the
time complexity, obviously, there was a little
110:40 - trade off that we made here. But now we're
able to run our house and function in a reasonable
110:45 - amount of time. So to wrap up this problem,
let's go ahead and hop back into the drawing
110:50 - board. Alright, now that we coded the house
and prom, let's wrap it up by actually analyzing
110:54 - the complexity of it. So recall that for our
house, some problem, we have multiple arguments,
110:59 - right, so I need to describe them. So I'll
say that m is my target sum, and n is the
111:03 - length of the array. Remember that the array
contains the choices we can take. And our
111:07 - baseline solution, that is our brute force
recursion had an exponential time complexity,
111:11 - right? It was kind of in the form of n to
the n power times M. And after we actually
111:17 - optimize it using the memorization strategy,
we actually reduced it from exponential down
111:22 - to a polynomial time complexity. In particular,
our new time complexity was n times m squared.
111:28 - So really important fact about our memoized
have complexities, it is no longer exponential.
111:33 - Please recall that when we have m squared,
that is not exponential, because the exponent
111:38 - is a constant number. Cool. If I look at the
the space complexity for this, I had to actually
111:44 - pay a little more cost in terms of the space
because of the memoized object. But that space
111:50 - complexity we use up is still not exponential,
right? Still a polynomial or quadratic complexity.
111:56 - So I'm still satisfied with it overall. So
we definitely prefer this memo is complexity
112:00 - over the brute force. All right, that was
the how some problem but now let's go over
112:05 - one more variation of it.
112:08 - In this problem, I'll still give you a target
sum as well as an array of numbers to choose
112:12 - from. But this time, what you want to do is
return an array containing the shortest combination
112:17 - of numbers, that adds up to the target sum.
And along with that, if there's any ties for
112:21 - the shortest combination, you can return any
of those shortest ones. So from this description,
112:26 - you probably recognize that this is similar
to our last few problems. But now they're
112:30 - asking for a little bit of an optimization,
right? So I want the shortest sums, that means
112:34 - an array containing the least amount of numbers,
but it still adds up to the target sum. So
112:39 - we're really just going to add on top of our
previous understanding, let's take a look
112:42 - at a few examples. So let's say I gave you
this example. So here, my target is seven,
112:47 - and the numbers I choose from are 534, and
seven. So there are a few different ways you
112:51 - can generate your target of seven, one way
would be to do three plus four, that's one
112:56 - combination. But another way would be just
take the seven because notice that seven is
112:59 - actually a member of the array. And here I
want to choose the smallest array, which would
113:04 - be just the lone seven. So that would be the
expected result for this one. In a similar
113:10 - way, let's see, I gave you a target sum of
eight. And your choice of numbers were two,
113:13 - three and five, there are plenty of ways to
generate eight, you can do two plus two plus
113:17 - two plus two, or you can do two plus three
plus three, or you can just do it three plus
113:22 - five. And here, I want to return always the
shortest combination, which would be the three
113:27 - plus five. So that would be the result over
here. Cool. So we definitely have some awareness
113:32 - that Alright, this problem is similar in structure
to our previous one where I need to sort of
113:36 - generate a way to make the target sum. But
now I want to really specify the shortest
113:42 - array, right? So let's try to visualize this
as a tree. Like always, let's say we're stepping
113:48 - through this example, with the target sum
of eight. So we know that the full tree would
113:51 - look like this. And we've seen this tree before.
But now what we're trying to do is come up
113:55 - with a different process for the value your
return, right, it's no longer going to be
113:59 - valid to just return the first way that I
find to generate the target sum. Now I want
114:04 - the best way. So let's start coming up with
the strategy for this. At this point, we know
114:08 - that we can definitely implement some logic
in our code where we return an array up our
114:12 - recursive calls, we did that in the last problem.
So here, we'll sort of use some abstraction
114:16 - to assume some return values. So let's say
that I'm bringing this problem down, my top
114:21 - level problem asked me what's the best way
to generate eight. But I see that along that
114:25 - path, I have to find the sub solution for
the best way to generate six. So let's say
114:31 - we're rooted at this subtree. And we know
that there are a few ways we can make six,
114:36 - right? If I look at this subtree rooted at
six, there are two zero base cases downward,
114:40 - right? So if I look at the first one, I get
this path, I know that my sub tree over here
114:46 - will be able to know that all right, one way
to generate six would be two plus two plus
114:51 - two, right? We kind of implemented that logic
in the last problem. But now what I also want
114:56 - to do is consider any other paths in case
they end up being shorter. Obviously, I know
115:00 - That this path of three 300 return upward.
And now I have to kind of make the decision,
115:05 - you know, between these two options for generating
six, I should just prefer the shorter one.
115:10 - So that means it's sort of two to two versus
three, three. And obviously, the three, three
115:15 - wins because the array length is shorter.
And if I pause right here, and I looked at
115:18 - what the diagram is saying, it does make sense
that above the six, we have three comma three,
115:23 - because that is the shortest way we can ever
make a six, right, just three plus three.
115:28 - But now I can return this sub array to my
parent. But if I do that, I should also include
115:33 - the value of the edge along that path, right?
So I also included the two over here. Now
115:39 - this makes sense, because one way I can generate
eight is three plus three plus two, right?
115:44 - But we know that's not the optimal way. Let's
say we step through this a little further,
115:48 - let's say we took the same sort of process
for this other child of five. So I know that
115:53 - to generate five, there are three options
according to the subject, right? Because I
115:57 - see three different leaves that are have zero
inside of them. And so I know that for these
116:02 - paths, they would work out through their own
sub arrays. And here, I really just want to
116:08 - choose the shortest one, right? So obviously,
the lone five wins out over here. So that'd
116:13 - be returned all the way up to that five node.
But then that five node will return it to
116:18 - its parent, then, of course, I need to include
the edge that connects the eight to the five,
116:23 - right? How did I transition to that five in
the first place, so I go ahead and just add
116:27 - it in. And now the root node over here has
a decision to make, which one does it prefer
116:30 - between 332 or five, three, it'll just choose
a shorter one. So the five three should win
116:36 - out over here. And I just need to continue
this process for any other branches in my
116:42 - tree, right? I can't return early and this
type of problem because I need to find the
116:46 - optimal way. And I can't be sure until I've
tried every possibility.
116:51 - Cool. So
116:52 - it looks like our overall logic is we want
to explore and find any ways to generate our
116:57 - target sum. But then when we find a way that's
shorter than our currently tracked way, we
117:03 - can just replace it, I'll continue that process
through the entire tree. If I checked every
117:07 - possibility and keep replacing what I consider
the shortest. By the end of us exploring every
117:12 - branch, we would have the absolute shortest.
Alright, I think we're ready to hop into the
117:16 - code. Alright, programmers, welcome back to
my text editor. Let's work on coding this
117:21 - one out. So here I have some initial examples
that we'll use to test our best sum function.
117:26 - I noticed for this last one, right, I get
my initial target sum of 100. And the best
117:30 - way to do that is obviously just take a bunch
of 20 fives, right for 20 fives. What else
117:35 - I want to bring our attention to is this third
example over here. So my target sum is eight.
117:39 - And my choice of numbers are one, four, and
five. The optimal answer here is four and
117:43 - four, right? That is the shortest way to generate
at a common mistake I see a lot of students
117:46 - make is sort of assume that the best way to
generate a target sum always involves taking
117:52 - the largest choice of number as many times
as we can, right? That is not true. If you
117:57 - took a five in your your sum, then you would
have to take three ones in the long run, which
118:02 - is not going to work out to the shortest answer,
right. So it's not the case that just taking
118:07 - the biggest choice of number always yields
the target sum in the shortest amount of numbers
118:12 - overall. So don't fall into that trap. Which
means that we have to do the full tree exploration,
118:16 - right, we have to do that in exhaustive sort
of search using our recursive code. So let's
118:21 - start with that base case, like we always
do. So bring this a few times, but still right
118:25 - here. So if the target sum is zero, then I
have trivially solved the problem. So I can
118:30 - just return an empty array, right? That is
the exact single combination and the shortest
118:34 - combination that can generate the target some
cool along with that, let's handle that scenario,
118:40 - if our target sum goes too far downwards,
if it's less than zero, so if the target sum
118:44 - is less than zero, I'll just return null,
meaning that it's not possible to generate
118:48 - that target sum. And now we'll use our branching
logic. So I'm going to iterate through all
118:53 - choice of numbers will say for let num in
numbers. And like we always do, I'll go ahead
118:59 - and create my remainder, which I know would
be the difference between my target sum, and
119:05 - that choice of number. Right? So what I'm
doing is I'm choosing the number that decreases
119:09 - my target sum. At this point, I would make
my recursive call right with that remainder,
119:14 - passing in the same numbers array. But now
I have to do some thinking, I know that all
119:18 - right, best sum is either going to return
to me a combination or an array, or it's going
119:23 - to return null, so I'm gonna have to kind
of differentiate between the two. So over
119:28 - here, maybe I'll just save this as a result.
I'll call this my remainder. Let's say combination.
119:38 - And if this remainder combination is not null,
then it can do some other logic, right? So
119:42 - I'll say if the remainder combination is not
equal to No, then do stuff. So if I enter
119:49 - this if statement, then that means it is possible
to generate the remainder. And exactly what
119:56 - remainder combination is, is an array containing
the short This way, I can generate the remainder.
120:02 - Cool. So if I enter this if statement, then
I also have a way to generate the full targets,
120:07 - right, I can just take the remainder combination,
copy the elements over from it like we did
120:12 - last time. And also add on the choice of number
I just took, right. So this would be now a
120:18 - complete combination for target sum. So I'll
just say that as a regular combination. Cool.
120:26 - So so far, this is very reminiscent to our
last one. And we need to work in some more
120:31 - logic relevant for this problem, that is a
very, very important characteristic that we
120:35 - needed to implement in the tree was, I need
to sort of choose the shortest combination,
120:41 - RAMs, I'm going to need to work in that logic.
So here's what we can do, I know that I need
120:46 - to compare basically, all of my branches together,
all of my recursive calls together, and pick
120:52 - out the shortest combination. So I know that
this for loop is a piece of code that sort
120:57 - of iterates and attempts, all of my branches.
And so outside of the for loop, I'm going
121:02 - to need some outer variable, I'll call it
my shortest combination. And over time, I'll
121:08 - just keep updating this variable if I find
a combination shorter than my current shortest
121:13 - combination, right? So I'm gonna initialize
this to null.
121:17 - And the reason is, imagine that we set up
this shortest combination of variables, no.
121:23 - And then we iterate through the for loop.
And there isn't even any way to generate the
121:28 - target sum. So this for a loop finishes, and
shortest combination would still be no. And
121:34 - that'd be great to return, right? Because
in this problem, they said, if it's still
121:38 - not possible to generate the target sum at
all, you should still return null. So this
121:42 - is a good initial default value for shortest
combination. But now I need to do my update
121:48 - logic. So here on line 11, I've actually created
a combination, that gives me the target sum.
121:53 - But now I need to check, right, so I'll say,
if the combination is shorter, then the current
122:01 - shortest that I need to update it. So let's
translate that into some code. Just use an
122:07 - if statement. And I'll start by checking if
the combination I currently have, which is
122:11 - an array, right? I check if that is less than
in length, then the shortest combination variable.
122:20 - And really, it looks like shores combination,
it starts as null. So I need to fix this code
122:24 - a little bit. But if I update it with a valid
combination, then it's going to be an array,
122:29 - right? So I'm really checking the length of
the arrays here.
122:33 - So
122:34 - what I want to do is assign my shortest combination
with the combination that is now shorter,
122:40 - good. So this means the shorter combination
wins out and gets to stay, right. If I look
122:45 - at this code, it needs a little bit of work,
because the first time I find some combination,
122:50 - I know that I be comparing that array length
to no dot length, right? Because shortest
122:56 - combination starts as null. And I can't do
null dot length in JavaScript. So I'll need
123:00 - like a nice or clause here. So I'll say, if
it is the case that your shortest combination
123:06 - is equal to No, then you can go ahead and
replace it. Cool. So this sort of check over
123:13 - here is going to make sure that I automatically
replace this null value with the first valid
123:19 - combination. Even if right now it may not
be the shortest, right later on, I'll compare
123:25 - that combination I have stored to some possibly
shorter combinations. Cool. So this code is
123:30 - looking pretty good. Let's go ahead and give
it a little test run. Nice. Notice that and
123:36 - on occasions where we call besam, with a remainder
that is negative because remember, sometimes
123:41 - we subtract a number that is maybe too large,
that's okay. Because that will actually bottom
123:45 - out at a base case and return null, which
we sort of check for explicitly in this if
123:50 - statement. Cool. So let's give us code a run
node best some. So I get an error over here
123:57 - looks like I get maximum call stack size exceeded,
which means that we didn't really hit our
124:02 - base case. So there's some work to be done
here. So let's take a look at this code. So
124:07 - if I take a look at this code, it's a very,
very small typo. It's kind of unfortunate
124:11 - that it breaks the entire code. But really,
I messed up when I iterated in the for loop
124:16 - over here. So here I wrote for letting them
in numbers, that would actually give me the
124:23 - indices of the array. So they'd be like 0123.
Whereas I want the elements of the array,
124:28 - right? So instead of in any of over here,
so that's on me. So with that small change.
124:33 - Let's give it a run now. Yeah, it looks like
we're passing these first three examples,
124:39 - we have 735, and four, four, notice that the
order among the elements in the combination
124:44 - doesn't really matter too much. But looks
like we're definitely a little too slow on
124:48 - this last example, over here, right? So obviously,
we know the move is to memorize this because
124:55 - we have the brute force recursion. But before
we do that, let's just talk about the complexity
124:59 - of This. So this code is going to be very
similar in complexity to our last how sum
125:04 - function, sort of compare the two, it's almost
the same code, right? But do these side by
125:10 - side, right, these two functions look very,
very similar. So we know in the long run,
125:14 - we probably have the same or close to the
same complexity. Let's be methodical. So we
125:19 - know that over here, we always like to say
that M is the target sum. And we'll also go
125:25 - ahead and say that n is the numbers dot length.
So we just did the brute force. And our brute
125:33 - force shouldn't be the same story as last
time. So talk about the time. So the time
125:38 - of the brute force is going to be some sort
of exponential, right? If you remember that
125:42 - tree drawing, in general, the exponential
number of nodes in a tree will be the branching
125:48 - factor to the height power. So not the branching
factor here is n, right? I branch for every
125:54 - choice of number, and then the height of the
tree would just be the target sum. So that's
125:58 - n to the M.
126:00 - But along with that, we also have some additional
operations, right? If I look at this for loop,
126:05 - so this for loop gives me the branching factor,
right. But then I also do this operation on
126:11 - line 11, which is copying over the array of
remainder combination. And that array in the
126:16 - worst case will be of length m, right? The
largest sort of combination, give me back
126:22 - is a combination that is just filled with
a bunch of ones, right? If my target sum was
126:26 - 50, the longest combination possible would
be a bunch of ones, so 50 ones in an array.
126:31 - So what I'll do is, I'll say that for each
of these n to the M power calls, you also
126:37 - have to do a linear operation in M, right?
So like before, it's n to the m times m. Cool.
126:43 - And then the space complexity is sort of interesting
in this one, because we're maintaining some
126:48 - values. So look at this. So I talked about
the space complexity, just from the stack
126:53 - space, it would just be the heights of like
the recursion. In other words, it would be
126:57 - m over here, right? So I know it's going to
be at least M. So I'll jot that down. But
127:02 - then we have also like this variable on line
five, right? So I know that over time, I'm
127:08 - going to be storing an array inside of this
variable. And this array is going to be in
127:12 - the worst case, m in length, right? So what
I'm saying is, every recursive call would
127:17 - have to have its own shortest combination
variable, right? If the shortest combination
127:22 - variable is going to be an array of length
m, that means I have an array of length m,
127:26 - for every recursive call right? Before I bought
them out, at like my final base case. And
127:31 - so also, the space complexity here is m times
m, which we know is the same thing as m squared,
127:37 - right? And sort of the reasoning is, your
maximal stack depth is still m like last time,
127:42 - however, now you need to have those stack
frames, you need to store in array, right
127:47 - as you recurse. Nice. So really, the limiting
factor for us right now is going to be the
127:52 - time complexity, which is exponential. And
so like we always say, let's go ahead and
127:56 - memorize this. So memorization pretty trivial
right now, right? You've done it many times.
128:02 - So I'll just begun my initially empty memo
object. And I'll check, you know, if my target
128:07 - sum is in the memo, then I should actually
return the stored value. So return memo at
128:13 - Target sum. So now that I have my memo checking
logic, what I also want to do is add the memo
128:18 - storing logic, right. So I need to just go
to my return value and store it in the memo
128:23 - before I return it. Notice that the return
value right now, it's no longer inside of
128:27 - the for loop, right in the last problem, it
was in the for loop, because I can return
128:29 - early. But this time, we're going to return
at the very end, so I'll replace it over here.
128:34 - So I'll say, for here, the memo at Target
sum should be stored with the shortest combination,
128:41 - I can still return the shortest combination.
And before I forget, let me go ahead and pass
128:46 - down the same memo object by reference. Alright,
nothing too much to that. Let's go ahead and
128:53 - try this last example. Now. Give it a shot.
Awesome. And there we have it. We have 425
128:58 - in this last example. And that is the best
way to generate a 100 is pretty evident that
129:04 - we cut down on the runtime. So let's talk
about the memoized complexity embolized. And
129:10 - so the time is obviously much faster should
not be exponential. But if I take a lay of
129:16 - the land, I know that now that every target
sum is going to be a key of the memo object.
129:22 - And target some is really just a number, right?
So if my target time is 50, then I basically
129:27 - have 50 different keys I can never store in
the memo object. So if I have m different
129:32 - keys in my memo object, I know that I won't
be exploring any full duplicate sub trees
129:37 - for each of those keys. However, I will slap
the branch for every number in the array,
129:43 - right? So overall, I'm looking at an m times
n. So so far, I have m times n, but I have
129:50 - some additional work from this array, right?
So notice that the n over here that comes
129:56 - from this for loop, I'm iterating through
numbers, but then the additional M comes from
130:00 - copying over this array, which would be linear.
So it would be m times n times M. And I can
130:07 - just kind of squish these two M's together.
So it kind of boils down to m squared, times
130:13 - n, which is really the same thing as last
time. And our space complexity would also
130:17 - be the same as it was last time, which was
just m squared, mostly coming from the memo,
130:23 - right? And the logic is, your memo keys have
m possibilities. But for each of those keys,
130:30 - their value can be an array of length m, right?
So just m times m, or m squared. Awesome.
130:36 - So looking at this code, you probably, you
know, feeling that Oh, my gosh, like this
130:40 - best some problem is pretty complex. And I
think it you know, to be honest, it is, however,
130:45 - what I really want us to focus in on is this,
like progression we took, right, I think that
130:50 - everyone could tackle this best some problem,
if they warmed up and really understood simpler
130:55 - problems like can some and how some
130:58 - write the code is very, very similar. So to
wrap things up, I will let's do some closing
131:03 - words on the drawing board. So in its best
some problem, right, we had two inputs, we
131:07 - had m as our targets, and also say that n
is the length of the array. So the brute force
131:12 - that we initially implemented it with just
some recursion was exponential in time. And
131:16 - after we optimized it, we brought it down
to just a polynomial time complexity. And
131:21 - notice that between our brute force and our
memulai solution, they actually have the same
131:25 - space complexity. So we definitely prefer
this memoized version. So hope you enjoy this
131:31 - series of problems. That is we worked on the
can some how some and best some problems,
131:36 - they all had the common frame of us having
some target some that we need to generate
131:40 - with some options given in an array. And in
particular, if you look at the can some problem
131:44 - it asks us what that task of generating target
some Can you do it? So yes or no? The house
131:49 - and problem. So is how will you do it? So
what are the exact combination of elements
131:53 - that you'll use? And finally, the best son
was the hardest version? And it asked, What
131:57 - is the best way to do it in terms of the least
number of elements of the array? So there
132:02 - definitely is a logical progression to these
problems. And in particular, they kind of
132:06 - capture a different variation of a dynamic
programming problem for our can some problem,
132:11 - right, we had to return Boolean there. That's
a type of decision problem, right? Yes or
132:15 - no? Can you accomplish this task? Is it possible?
Along with that the house some problem was
132:19 - a combinatoric problem, right? We want to
know the exact combination that works out.
132:23 - And the best some problem was a variation
of an optimization problem, right? I want
132:27 - the shortest way to generate the target. So
we saw that these three problem types definitely
132:31 - have some common ground, but they also have
some nuance, depending on exactly the question
132:36 - we're trying to answer. These all fall under
the umbrella of dynamic programming. That
132:40 - being said, dynamic programming problems aren't
just limited to number inputs. All right,
132:44 - I think it's time to work on another prompt,
let's say I gave you this, what I want to
132:49 - do is write a function called can construct
that takes in some target string, as well
132:53 - as an array of words in a word bank. My goal
is to return a Boolean indicating whether
132:58 - or not I can make the target by concatenate
together elements of the word bank. And along
133:03 - with that, we can reuse as many elements as
the word bank as we see fit. Alright, notice
133:08 - that in this problem, we're looking for a
Boolean response to start, right. So just
133:11 - yes or no. Is it possible to generate the
target? So let's take a look at an example
133:16 - here. Let's say I gave you this. So my target
is abcdef. And I have a nice long array of
133:22 - some words. And so I'm basically asking, Can
you construct abcdef, using elements of the
133:29 - array. So if I kind of take a look at the
array, there is exactly just one way to generate
133:34 - the target string, which are just B, A, B,
C plus D, F. So the answer here is true, because
133:40 - there is at least one way to make the target,
right. Let's take a look at the opposite example.
133:46 - So let's say I had this word of skateboard.
And I gave you all of these words in an array.
133:50 - So take a moment to kind of look this one
over. And you tell me write Is it possible
133:54 - to generate skateboard here?
133:58 - And the answer here is no. Right? It is not
possible to generate skateboard using this
134:03 - array of words. So we should return false,
we can get pretty close to making skateboard.
134:07 - But we can never build the full string. Alright,
so here are a few ways that we can attempt
134:11 - but they don't work out in the long run, right?
This is one series we can take, but we kind
134:15 - of get stuck, as well as this. And also this
way, right? Point being there are zero ways
134:21 - we can ever generate skateboard. So we should
return false over here. Awesome. So I think
134:27 - let's look at one more example. We should
already have the vibe that in general, it's
134:30 - easier to create a shorter string than a longer
string, right? To create a longer string,
134:36 - you're probably going to need to use more
elements. So if I have that kind of framing
134:40 - in mind, that I know that possibly the easiest
string to create would be the empty string,
134:45 - right? So let's say your target was the empty
string and I gave you you know, some kind
134:49 - of random array of words, really, the array
of words doesn't really matter here. I think
134:53 - no matter what they should return true. Because
to generate the empty string, you can just
134:58 - take no zero elements. From the array, and
that kind of line of thinking is going to
135:03 - help us really start to solve this problem.
So we'll kind of take this example, in stride,
135:08 - what we want to do is return true if our target
is empty, and that takes place no matter what
135:13 - array of words we're given, right? Cool, more
or less, that kind of sounds like a base case,
135:18 - right? But let's go ahead and start to kind
of define some process we can take to explore
135:24 - all of the options, right? So I want to really
visualize this in a well ordered way. And
135:28 - that really means a tree. Right? So let's
say we're going to trace through this example
135:32 - visually. So my target is abcdef. We already
said that, in the long run, we should return
135:37 - or conclude a true about this input, right?
So we'll just start with the input argument
135:43 - that is the target string as the root of this
tree. And this is sort of a scenario where
135:48 - like, Alright, I have two inputs, how do I
know which one to really encode in my drawing?
135:52 - Well, it's about what will actually change.
I know from like, one instance of like this
135:57 - problem to the next, the array of words, I
can actually reuse as many times as I need.
136:03 - So it's not like I'm taking out elements from
the array. So with that in mind, I think it's
136:07 - better or more reasonable to encode the actual
target string into the nodes of this picture.
136:11 - Because I'm gonna start with this original
target string of my route. Now I have to think
136:16 - about how I transition to the children of
this right, so what moves do I take that hopefully
136:21 - shrink the target string, right, I know I
need to shrink the target string, because
136:25 - I already have the base case of the empty
string in mind. So I need to get closer and
136:29 - closer to a length of zero. We'll talk about
one transition we can make. So I know that
136:35 - I need to sort of use the array of words as
I transition. And so let's say I took a B
136:41 - as a choice right now, if I take a B, then
I guess I could remove, you know, that sequence
136:46 - of characters from my parent node. So if I
take a B out of abcdef, then the resulting
136:53 - child is just C, D, F. Cool. So notice that
as we transition from one node to the next,
136:59 - looks like we're taking out that substring.
In a similar way, I have another substring,
137:04 - that I can take out for my word bank, and
that would be ABC, and that would yield in
137:08 - the child d f. And then I can do this for
some other string inside of the word bank.
137:14 - And the really important thing to know is,
there's a correct logic to doing this. And
137:18 - it's also a common trap I see a lot of students
fall into when it comes to this logic. So
137:23 - right now I'll talk about like the common
mistake. So it would be ill advised to sort
137:28 - of take out the CD from our root node, if
you took out C, D, then the resulting note
137:34 - would be a, b, f. And so what we're doing
right now is if we took out C, D, you're taking
137:39 - out something in the middle. And if you take
out something in the middle, that means that
137:43 - your resulting string actually creates a new
adjacent sequence of characters. In other
137:48 - words, I know that this is kind of suspicious,
because look at this little run of characters,
137:53 - A, B, E, those are now like adjacent next
to each other. Whereas in the original string
137:58 - of abcdef, A, B, he was not present, right.
So if I kind of take out strings in the middle,
138:04 - then I'll have this sort of mistake of creating
new adjacencies. Right. And that would actually
138:10 - impact the moves I take later on. So I don't
want to do that, right. So the move here is
138:15 - to not take out any characters from the middle
of the string. So what would be the correct
138:20 - way of doing it? Well, if you look at our
two nodes that we already branched into, a
138:26 - common factor for them is the fact that we
actually took a prefix out of our original
138:31 - root node, that is a B as a prefix, and so
is ABC or recall that a prefix is just a string,
138:38 - that kind of begins some other larger string.
So if I want to transition to a third node
138:43 - over here, there's only one more prefix I
can take. And that would just be ABCD. Right?
138:49 - If I take that prefix out, then my resulting
child is just E, F. And so the overall logic
138:54 - that we want to use when we build this tree
is to only branch to children if we have a
138:58 - matching prefix in the word bank. And of course,
the child would be the resulting string after
139:05 - we remove that prefix. So let's keep it rolling.
And we'll apply this logic again and again,
139:10 - recursively. So let's say I'm rooted at this
CDF node, I'll look inside of the word bank
139:15 - and notice any prefixes that actually match
here, I think there's only one and that would
139:19 - just be CD. If I took out the prefix CD, then
my result is E, F. In a similar way, I can
139:25 - do that for d f, I find that d f is actually
contained in the word bang. So it's technically
139:31 - also a prefix. If I took the prefix def out
of that node, then my result would be empty,
139:37 - which is pretty good. At this point, I look
at some other nodes like this EF and they
139:43 - have no matching prefixes inside of the word
bank. So they sort of bought them out in some
139:48 - sort of base case. In the long run. If I can
break down EF any further than I know that
139:53 - it's not possible to construct EF so that
can technically return a false to the parent.
139:59 - Mr way, if I ever run into the empty string,
that means the job is done. And I can just
140:03 - return true, right? Something we said earlier
was, whenever we want to generate the empty
140:08 - string, it is always possible no matter what.
And now this pattern should feel a little
140:13 - familiar, right? All I have to do now is kind
of bubble up these Boolean values to the parent.
140:18 - And overall, if one of my children return
true, then I myself will return true, right?
140:23 - So I'll bubble this up a little bit, bubble
up all the way to the top. So our root note
140:27 - chooses basically the true value among these
three values it gets from each of its branches.
140:32 - And so the ultimate answer here is just true,
right. And it is possible to generate abcdef
140:38 - using words of this array. So you're probably
having deja vu right now, right? We almost
140:42 - use the same exact logic for the previous
some problem. However, all we did was adjust
140:47 - how we transition from one note to the next,
really making a compatible for this string
140:52 - data. But we're going to carry over a lot
of knowledge, right? It's really important
140:56 - that we understand like the general like knowledge
of dynamic programming and recursive understanding,
141:01 - we can apply that under any circumstances.
That being said, let's look at one more example.
141:05 - What I want to do is see an example where
this should return false. So let's say I gave
141:09 - you that skateboard example from before. In
the long run, this is going to return false.
141:13 - If I tried to break down skateboard, I would
always try to transition using any matching
141:19 - prefixes from the array. There are two prefixes
at the start that match, and that would be
141:23 - SCA and SK, and those would give me t board
and eight board, respectively. And now at
141:29 - this point, if I route myself at the keyboard
node, I can only take the T, resulting eboard.
141:35 - In a similar way, if I am at the eight board
node, then I can only transition using the
141:40 - eight. And I'm left over with board. At this
point, if I look at eboard, that node over
141:47 - there actually hits a dead end, right, there's
nothing I can actually take out of Eve or
141:51 - there's no matching prefix, because I basically
need something that starts with E, but no
141:56 - words of the word bank start with E. So I
guess we have to focus our effort elsewhere.
142:00 - Looking at this board, I can take either a
Bo or a Bo AR, and I'm left with art and D
142:07 - respectively. And unfortunately, those two
nodes at the leaf level also bottom out, right,
142:12 - I can't transition further and take out any
prefixes from those strings. So I know that
142:18 - those will have to return false. And if all
of these leaf nodes return false, then my
142:23 - ultimate note at the top that is a skateboard
node at the root, that's going to just return
142:27 - a false as well. So it's pretty clear to me
that the overall logic we want is if we get
142:32 - back a single true, then we can just return
true all the way up to the call stack. But
142:37 - if everything is false, then we'll just go
ahead and return a false. With that, I think
142:41 - we're ready to code this one out.
142:43 - All right, let's
142:44 - go ahead and code this one up. So here I have
some initial examples we can use to test our
142:49 - code for correctness. Looking at the last
example, over here, it's a fairly long one.
142:53 - And notice that the target incident F, whereas
no words of the word bank have an F in it.
142:59 - So we know that that should result in a false.
So let's go ahead and lay down the base case
143:03 - for this. Like we said, a reasonable base
case is to check if your target is empty,
143:09 - right. If you have the empty string, then
you can already construct the empty string
143:13 - by taking no words from the word bank. So
you can just return true over here. And now
143:19 - I need to make my recursive call in a way
where my target string gets progressively
143:23 - smaller and smaller toward this empty string.
And so I know that based on the tree I drew,
143:29 - I need to make a choice based on the words
in the word bang. So I'm going to iterate
143:33 - through all of the words. So I'll say for
let word of word bank. So I'm iterating through
143:39 - every element of the word bank. And now that
I have the word element, as I think about
143:45 - when it's okay, to make the recursive call
using that word, and we spoke about this,
143:51 - we pointed out that we need to make sure that
the word is a prefix of the target. So I can
143:56 - do that, I can just check if the target dot
index of word equals zero. So index elf will
144:05 - just give me the index where I can find some
substring inside of a larger string. If the
144:11 - index i get back is zero, that means that
the word starts at index zero of the target.
144:15 - So if you're unfamiliar with this method in
JavaScript really quick, let's say I did potato
144:22 - dot index of pot, that will tell me the index
where I can find it, which happens to be at
144:28 - index zero. But if I looked for tayto, I would
get the index of the T, the first t rather
144:34 - in potato. So this is a really nice way I
can use to check if some substring is a prefix
144:40 - of another string, right, the index should
be zero within it. So a way interpret this
144:44 - if statement is if I have a prefix, then I
can sort of use it to shrink the target. So
144:51 - I'll create another variable here. I'll call
it like the suffix so that's like the string
144:54 - after I remove the prefix. What I can do is
slice my target string. Except to target that
145:01 - slice. And what I want to do is start picking
up characters. After the length of the words
145:07 - I can say word dot length over here. So it's
kind of reasoned out what this logic is doing.
145:15 - So we'll trace through this, let's say that
I don't know my word. So I'll open up the
145:20 - note repple. Let's say my word was the string
pot. And we'll also say that my current target
145:27 - is potato. So I know when I do target dot
index of word, that is going to get back zero.
145:35 - So this if statement would be true. And then
what I do is target dot slice of word, dot
145:42 - length. So we're dot length is just the length
of the prefix I took, right? So it would be
145:47 - three over here, providing the target that
slice starting at index three, that would
145:53 - give me everything after the prefix, right?
So I basically have removed pots, and got
145:57 - eight. Oh, cool. So when you use slice, if
you pass in a single argument, that's going
146:02 - to be the starting position of what you start
grabbing characters, and you'll go all the
146:07 - way through the end. Cool. And that's the
logic I definitely want here. So back to the
146:12 - code. Now that I have the suffix, I want to
make my recursive call on that suffix. So
146:17 - basically asking, Hey, is it possible? Can
I construct the suffix now? And I'll pass
146:22 - along the same choice of word bank. Nice.
So here's where I should think recursively.
146:29 - So I'm focused in on what type of data do
I get back from can construct I know I get
146:33 - back a Boolean, right? True or false, it tells
me whether or not the suffix can be made.
146:38 - And I want to check, you know, if this call
returns true, maybe I'll be explicit here.
146:43 - So if the recursive call is true, then I know
that the original target can also be made.
146:50 - So what I'll do is return true early here.
Cool, I know that if the suffix could be made,
146:58 - and the word that I use to generate the suffix
is also in the word bank, then the entire
147:03 - target must also be able to be made. Nice
to hear I have my nice early return true.
147:09 - Like you expect, where should I return false,
it should be after the for loop, right? Only
147:13 - after I've tried every possible choice of
the word and none of them worked out, then
147:19 - can I say, No, the target cannot be created.
So I want to do a late return false over here.
147:25 - So this code is looking pretty sharp, I think
let's go ahead and test these examples. So
147:33 - I should get true false true, and then false
for the last one, give this a go.
147:40 - So I get true, false true. And it looks like
the last example over here is taking quite
147:46 - some time to finish. So I think our code has
correctness. But it's not efficient enough
147:51 - to you know, reasonably run this last example.
So I'm going to kill this program. If you
147:56 - take a look at the example I pass it for this
last one, it does sort of describe the worst
148:01 - case here. For one, we know that the answer
is going to be false. So you will have to
148:04 - do a full exploration of the tree, meaning
you can't do any early return trues, right.
148:11 - And because of like the length of the string,
and also the length of the word bank, I have
148:16 - a very big tree, right? Notice that there's
going to be a lot of prefixes at work here,
148:22 - right? every element of this array is actually
a prefix that could be found over here. And
148:27 - that happens again and again. So I'll tell
you what, let's go ahead to the drawing board.
148:31 - And we'll try to visualize what the exact
complexity of this function is.
148:37 - Alright, so we implemented looks like the
brute force for this solution. Let's talk
148:42 - about how we might want to optimize it, I
think any conversation of optimization should
148:46 - begin with actually understanding what the
current complexity is. So let's say I gave
148:51 - us this kind of large example to sort of visualize
with, so my target string is enter a potent
148:56 - pot, and I gave you a pretty diverse array
of words in the word bank. So I'll just go
149:00 - ahead and kind of give us though the full
tree in what it would look like, would be
149:04 - this pretty long tree, right, so I follow
the same logic that we did in our earlier
149:08 - examples. notice a few things. There are some
occasions where I transition using a single
149:14 - character prefix, which is totally fine. And
that kind of tends to feel like the worst
149:19 - case scenario, right? If you take single characters
out of your target string over time, then
149:23 - you're going to have a very, very tall tree
height, or you're gonna have to take many,
149:28 - many steps. So that kind of reminds us of
a worst case scenario, like we saw when we
149:32 - ran the code. But that being said, we want
to generalize this understanding right for
149:38 - basically some generic size of our input.
So let's say we kind of just looked at this
149:42 - tree in terms of its overall shape, and then
we'll kind of generalize it. So to me, this
149:47 - tree has this sort of basic structure. And
let me start by defining the terms I'll use
149:52 - to describe the complexity right. So I'll
say that M is the target string length, and
149:57 - n is the number of words in the word bang.
Right, so I'm really trying to use a different
150:02 - variable for each of my inputs, because I
have the vibe that both of them contribute
150:06 - to my complexity, possibly in different ways.
So you've seen, you know, us analyze trees
150:12 - before in terms of like their structure, right,
we're visualizing as a call tree, I know that
150:16 - the time complexity would be the number of
nodes in the call tree, right. And so let's
150:21 - start with some familiar territory, I kind
of already know that I need to realize the
150:24 - height of this tree, the height of this tree
is going to be m, right? Remember that m is
150:31 - our target string. And so imagine, in the
worst case that we took, or we had to take
150:37 - a bunch of single character, choice of words
to construct our target string, that means
150:42 - that the number of things I would have to
take all the way from the root to a base case,
150:47 - or the root to the leaf would be exactly M.
Right? If I had to take a bunch of single
150:51 - characters, so we can be confident that the
height of this tree would be m. So I talked
150:55 - about the height. Now I need to realize the
branching factor, that is from one level of
151:00 - the tree to the next, how does a number of
nodes change in the worst case? Well, I know
151:05 - that the branching factor is dictated by how
many words I have in the word bank. And so
151:10 - that would be some relation on n. So I know
at the root level, I have about one node.
151:15 - But then in the worst case, to get to the
next level, I will multiply by n, right? Imagine
151:20 - that, basically, almost every element of the
word bank was a matching prefix, right? So
151:25 - you'd multiply by n. And let's say that carried
over further, let's say almost every word
151:30 - of the word bank was still a prefix of those
resulting nodes, I would keep multiplying
151:34 - by n. And I would do this overall m times,
right. So we already know that this is going
151:40 - to be exponential, I need to multiply n by
itself, m times over. And so this would give
151:45 - me an N to the M, time complexity. In general,
if you visualize your recursion using a nice
151:51 - call tree like this, then the overall time
complexity is going to be the branching factor
151:58 - to the height power. So we have a branching
factor of n and a height of m. That being
152:04 - said, this will just really consider the number
of calls that we make, I want to be super
152:09 - sure and make sure we didn't do any other
kind of performance or costly operations inside
152:14 - of our code. So here's our code, same code
as we did before, if you look at this code,
152:21 - some things I need to consider are probably
line six, right? If I look at line six, that
152:26 - was where I did a target that slice that's
like copying over a part of the target string.
152:32 - And to do that operation, I would actually
have to iterate through the target string.
152:36 - Right? So that would actually contribute to
my complexity here. So in the worst case,
152:41 - would I be slicing? Well, if I'm slicing a
target string, that would have like a maximum
152:45 - length of M, right. And so in every call to
can construct, I'm going to have to do an
152:50 - additional m operation, if I have n to the
M calls, then I can just multiply an additional
152:55 - M over here, right. So I, I added some additional
term into our complexity, just multiplying
153:00 - by M. Cool. And so overall, if you look at
that time complexity, it was already exponential
153:05 - so that multiplication by m, doesn't really
make it that much slower, it's really the
153:10 - N to the M, that makes it unbearably slow
in the first place. So that was the time complexity.
153:16 - Now let's look at the space complexity. So
if we just refer to the space complexity,
153:20 - due to the call stack, it looks like it's
going to be the height of this tree, right?
153:24 - Like we always say, the height of the tree
would mean the maximum number of stack frames,
153:29 - we would need on the call stack before we
bought them out at the base case, right? Because
153:33 - when we return from a call, we would actually
remove something from the call stack, right?
153:38 - The height of this tree is definitely just
M. So we'll say the space from the call stack
153:42 - is just o of m. But again, we should also
you know, look at our code and see if we created
153:47 - any other like growing structures. So we look
at the code right now, I see that on line
153:52 - six, and kind of talking about that slice
statement. Again, the slice returns you a
153:57 - new string, right. And that new string is
going to tend to be of length M. So on every
154:04 - call to can construct, I'm creating a new
string, I actually need to maintain it through
154:08 - the recursion, right, because I actually slice
before I return out on line eight. So because
154:14 - of that, I know that each of my M stack frames
will have to store a string of length M. So
154:21 - that just means m times m in my space complexity,
which is really just m squared. Cool, which
154:27 - isn't too bad of really a space complexity
overall. Alright, so it looks like our final
154:32 - complexity for our brute force solution is
exponential in time. And it looks like quadratic
154:37 - in space. So obviously, let's work on improving
the time complexity over here. And so hopefully,
154:43 - you're seeing where this is heading. Let's
say we jump back into my entropion pot example.
154:48 - So this was a huge tree. Take a moment look
at this tree, and where can we actually optimize
154:53 - some work away?
154:55 - To we're trying to do is notice any overlapping
some problems In the context of our tree,
155:01 - that means I'm looking for any duplicate sub
trees. And I see duplicate sub trees right
155:06 - here, right? They follow the same structure
all the way down even to their base cases.
155:11 - So I've looked at the sub trees, they're really
trying to solve the same problem, right? That
155:15 - is they're both trying to figure out, can
we construct the string and teapot, right?
155:20 - And if I saw that once, on the left hand side,
the answer is going to be the same on the
155:23 - right hand side. So I can just store that
information in a memo, right? So the trick
155:27 - is here to of course, memorize it using our
classic strategy. So let's hop to it. All
155:33 - right, here we are back in my code editor.
Let's go ahead and just memorize this one.
155:38 - So I'll create my memo object. And here, I'll
prefer to use the target as the key to my
155:45 - memo, I know from one call to the next, the
word bank doesn't change, right? So I don't
155:51 - need to actually make it a part of the key
for my memo object. So I'll just check, hey,
155:55 - if my target is in the memo, then what I'll
do is return the stored value of that target.
156:04 - Cool. While I'm here, let me also squish this
down to a one liner. So I have the memo checking
156:10 - logic. Now I need to make sure I pass down
that memo to all of my recursive calls. And
156:16 - then I need to actually store data in the
memo. And the rule is wherever you have your
156:20 - recursive returns. Now, you should also store
that return value in your memo before you
156:26 - actually complete the return. Right. So for
both of these lines, I'll make sure I store
156:30 - them in the memo. So it's a memo at Target
equals that. But I still want to return that
156:37 - same value. So we'll return true and return
false over here. Again, notice that I'm using
156:43 - my exact argument targets, right? I don't
need to write any memorization logic about
156:48 - the suffix, right? Imagine if we made the
call to can construct suffix becomes that
156:55 - frames target. So the memos ation would still
work properly. Right? So that looks pretty
156:59 - good. And it wasn't that much code, right?
memoization is always this slightly extra
157:03 - layer, we add on top of our brute force solution.
So let's try this now can't construct. Nice.
157:10 - And there we have that last example finishing
fairly quickly, or we do get the correct answer
157:14 - of false over here. Alright, so here's what
we'll do, we're going to head back to the
157:20 - drawing board. And of course, we'll come up
with the final complexity analysis for this
157:25 - function. Some classic memorization, right?
Let's take a lay of the land over here. So
157:32 - we wrapped up this can construct problem,
let's describe its final optimized complexity.
157:37 - So again, like before, we'll say M is the
target length, and n is the number of words
157:41 - in the word bank, our original brute force
had an exponential time complexity, right,
157:45 - and that was n to the m times m. And when
we memorize our solution, we actually improved
157:49 - it from exponential. So now, the time complexity
of our solution is n times m squared, right.
157:55 - And the reasoning is, now we don't have to
fully explore any duplicate subtree, every
157:59 - time we run into it, instead, we just store
the results in the memo. And we can just kind
158:03 - of short circuit and fetch the stored result
in the memo. Notice that I have an M squared,
158:08 - right in the memo, I have complexity, that
second m really comes from the fact that we
158:13 - still have to do the slice, we have to pay
for that cost. So although we added an additional
158:17 - object in our memo II solution, our space
complexity would remain in the polynomial
158:22 - class. So overall, we definitely prefer this
second solution, because we remove some exponential,
158:27 - you know, complexity. So now it is reasonable
to actually run this in an amount of time.
158:32 - I think that wraps up this can construct problem.
Now let's work on the counting version of
158:37 - this problem. In particular, I want to work
on count construct. So we have the same set
158:42 - up here, I want to take in still a target
string and also an array of words in a word
158:45 - bank. But this time I want to return a number,
I want to return the total number of ways
158:50 - that the target can be made using words of
the word bank. And like before, we can reuse
158:54 - elements of the word bank as many times as
we want. So notice that this question asked
158:59 - us to do something slightly different, we
don't want just true or false. If it's possible,
159:03 - we want the exact number of ways that we could
construct the target string. So let's take
159:08 - a look at some examples. And also, you know,
take a high level view of the strategy here.
159:13 - So let's say I gave you this string of abcdef.
And this array of words, this particular example
159:18 - we saw before, and it is possible, and there's
actually one exact way we can generate abcdef.
159:23 - So we can construct the tree in the same way
we did before. And we end up with this. However,
159:28 - this time around, we want to choose a different
value to return for our base cases, as well
159:33 - as changing the logic for reconstructing our
sub solutions, right? And so if I look at
159:38 - the base cases here,
159:39 - I wanted to kind of just adapt the return
value for this new type of data that I need
159:43 - to return which is number. So I think the
move is for these scenarios where we can't
159:48 - break down our current target any further.
That's your return zero, right? Yeah, f can't
159:54 - be broken down because it doesn't have any
more matching prefixes from the array. So
159:58 - that means there are zero ways to breakdown
F. And so we should return zero in those scenarios.
160:03 - And then when we have the empty string we
know was successful. So we could always, you
160:08 - know, create the empty string. And so that
should return one. And we've seen this logic
160:12 - before in problems like Fibonacci, as well
as our grid traveller problem, we just want
160:16 - to bubble up these values to their parents,
and make sure every parent will add up all
160:21 - the numbers that come back from their children.
So it just bubbles up like this. And top level
160:25 - we do zero plus one plus zero, which means
that we can generate abcdef in exactly one
160:31 - way. And if you look at the way that actually
is symbolized inside the tree, it's exactly
160:37 - the path from this root node all the way down
to that lone base case that returned an empty
160:42 - string, right, ABC plus d f. Let's take a
look at another example. So here I have the
160:49 - target string purple, and I have some other
characters and words inside of the array.
160:54 - So take a moment to look at the input here
and predict what number they should return.
161:01 - So the answer here is two, right, there are
two ways to create purple. So if you construct
161:09 - the tree, we know we start with the initial
unknown of purple. And then we have about
161:13 - three prefixes that match here. And those
yield some children, we can follow the same
161:17 - pattern recursively down the tree. So the
full tree really looks like this, notice that
161:22 - I have a two base cases that actually end
up as the empty string. So I know those are
161:28 - going to turn one up to their parent. And
on the right hand side, I have a loan II that
161:32 - can't be broken down any further that returns
zero. And like always, right, I just bubble
161:36 - up these values, until at the parent, I actually
do one plus one plus zero, which gives me
161:40 - two. All right, there are two distinct ways
to create purple using this choice of word
161:45 - bank. All right, I think I'm feeling pretty
good about jumping into the code for this
161:49 - one, it's really just a small variation of
the last problem we did. So let's hop right
161:54 - in. Alright, programmers back in the code
editor, let's go ahead and bang this one out.
161:58 - So I already have some examples that show
us what numbers we should return for this
162:02 - count construct, right. So I have some examples
here. I'm gonna say even have that big example,
162:07 - with our large inputs, we know that that will
probably need to be optimized, let's lay the
162:11 - foundation with a brute force. So we'll start
with the same base case, as always, right.
162:14 - So if the target is the empty string, then
we have truly solved the problem. Meaning
162:19 - that there is definitely one way to generate
the empty string, right, just take no elements
162:24 - from the word bank. Along with that, I need
to make my recursive call. So the usual structure,
162:29 - right, I want to iterate through every choice
of word. So for let word of word bank. And
162:34 - then for every word of that word bank, I need
to check if it's a prefix. So we've done this
162:40 - before, if the target dot index of word bank,
or rather index of word, if that is equal
162:48 - to zero, then it must be a prefix. And if
it's a prefix, and I can go ahead and take
162:54 - like the rest of the word that is the suffix
and call recursively on it. So I'll do this
162:59 - in line now say, count construct, and I'm
going to pass in the rest of the word, which
163:05 - would be target dot slice, and then I'll slice
starting at word dot length. So this means
163:11 - that the slice contains everything after the
word or everything after the prefix. And so
163:19 - Also be sure to pass into the second argument,
the same word bank. Nice. And now I need to
163:25 - think about what calc construct returns. So
it's returning a number now, right? So in
163:30 - particular, this will be the will say, num
ways. I'll say no more ways for the rest,
163:38 - maybe a little wordy of a variable name, but
I think it does describe how exactly what
163:43 - this returns here, right. So this is a number
of ways that you can generate the suffix with
163:47 - like the rest of the target. What I want to
do is keep a running total. So outside this
163:52 - for loop, I need a way to add everything that
the for loop iterates through right, so I'll
163:57 - create a total count over here. So I'll say
let, I'll say total count. And I'll start
164:03 - it as zero. And now inside of my for loop,
whenever I get the number of ways to create
164:09 - the rest of the string, I'll go ahead and
just add that into my total count. So it's
164:14 - as simple as total count plus equals the number
of ways to generate the rest of the string
164:20 - right after I've removed the word. And after
I take the total through the entire for loop,
164:26 - and I can just return the total count. Something
really great about this, this programming
164:31 - pattern is let's say that none of the choice
of words were a valid prefix. So that means
164:38 - I finished this for loop. And this if statement
is never true. If this if statement is never
164:42 - true, that I never add anything into the total
count. So if I return total count afterwards,
164:47 - I return a still zero, which makes sense because
apparently there are zero ways to make the
164:52 - target right have no initial step to take
in the word bank. So let's go ahead and test
164:58 - this one out. So looks like we should get
to 104, and then also a zero at the end. Let's
165:06 - give that a go.
165:09 - So 2104. And it looks like the last example
is just a little slow for us. So you already
165:15 - know where this one is heading. Let me tell
the program, let's just go ahead and just
165:19 - memorize this one off the bat, right? Hopefully,
I think through all of these examples, you're
165:25 - feeling really good about memorization. And
it's apparent that we basically have drilled
165:29 - into our minds already. So if the target is
in the memo, and just return the stored value
165:35 - memo at Target. And then I'll need to adjust
my return value, right. So where I return
165:41 - over here is I'll store that total account
as the value corresponds to the target. And
165:48 - let's not forget to also pass in the memo
to our recursive calls, right? So memo goes
165:53 - right here. Nice. So let's give that a run
again. I expect a zero for that last answer,
166:00 - right. So looks like I have an error over
here. And of course, I forgot to actually
166:05 - replace my return value. So I can still return
the total counts. And addition to that, I'm
166:09 - actually adding it into my memo. So let's
try that now. Yeah, these answers look correct,
166:15 - right, I got zero for the last one, notice
that the last one is not possible, because
166:18 - it ends in an F and all my words only contain
E's. Nice. And if you look at this code, it's
166:25 - a pretty similar to our previous problem of
can construct if I kind of split these can
166:32 - construct basically has the same shape. Really,
the only difference is this number variable
166:38 - that I add into, and of course, the return
values. So we do expect the complexities to
166:42 - be the same for these two functions. Let's
wrap this one up on the drawing board. Let's
166:48 - look at the complexity of this. As always,
for this calc construct problem, our M is
166:52 - going to be the length of a target string,
and our n is going to be the length of the
166:55 - array, right? So that means a number of elements
in that array. Our brute force is the same
167:00 - as it was in the can construct problem, right,
so it's still exponential. And using memoization.
167:05 - We just brought that down from an exponential
to a polynomial time complexity, and the space
167:10 - complexity remain the same. Really, there
is no additional cost that we pay in our implementation
167:15 - for this counting version of the problem,
right. The only difference is now we're maintaining
167:19 - a number that we just add to, you know, on
every iteration of that for loop. But that
167:23 - doesn't really affect the runtime or the space
complexity at all. So I think this wraps up
167:28 - this count construct problem.
167:31 - Now I want to do one more variation of the
string problem. So what I want to do is write
167:35 - a function called all construct that has the
same setup, right, so I'm going to take in
167:38 - a target string, as well as an array of words
in a word bank. But this time, what I want
167:42 - to do is return all of the ways that the target
can constructed by concatenating elements
167:47 - inside of that word bank. And that means I
should return a two dimensional array, a single
167:52 - element of that 2d array is going to represent
one of the combinations that can construct
167:57 - the target, right, and I want to return all
of the ways within a 2d array. And as always,
168:01 - we can reuse elements of the word bank as
many times as we need. So let's make sure
168:05 - we understand this question by looking at
some examples and their output. So here's
168:09 - an example using purple. And it's the one
we've seen before in the last problem. The
168:13 - last problem I had us return to because there
were two ways to create purple. But now I
168:17 - don't want the number, I want the exact ways
that actually create purple, that means you
168:22 - need to return a two dimensional array, the
outer array, or the outer set of brackets
168:26 - represents the collection of all combinations.
Whereas a set of inner brackets or a sub array
168:31 - represents one of the combinations that creates
purple. Let's take a look at another example.
168:36 - Let's say I gave you abcdef. And I gave you
this long array of word bank, notice that
168:41 - I actually added some elements inside of this
word bank array. It's a little more complex
168:45 - of in our previous examples. Because of this,
there are actually many ways you can create
168:49 - abcdef. And this contains all of them, right?
So there are four ways to create our target
168:54 - string. And again, notice that each sub array
represents one of those combinations of words
168:59 - in the word bank that creates the target.
Cool. So now that we kind of understand like
169:04 - the shape of this problem in terms of the
data we should return, let's take a look at
169:08 - some base scenarios. So let's say I gave you
this example. Right? So I have a target of
169:14 - Hello. And my words in the word bank are just
Cat Dog and mouse. Obviously, you know, that
169:19 - is not possible to generate Hello. So there
are really zero ways to create this. How should
169:24 - we actually return an answer here? Well, I
think it'd be reasonable to return an empty
169:29 - array. Remember that we're saying the outer
array in this context represents the collection
169:34 - of all of the combinations that can create
Hello, since there are zero ways to create
169:38 - Hello, that means that our collection is empty,
right? This has a length of zero meaning there
169:43 - are zero ways to create Hello. Now let's say
we had another base scenario. Let's say we
169:48 - have to generate the empty string using the
same array of word bank. And that scenario,
169:52 - I think it's reasonable to return an array
containing an empty array. And again, the
169:58 - reason is if it is possible to To create the
target string, then we need to return a 2d
170:02 - array, right where the outer array represents
the collection. And if there's one sub array
170:07 - inside of that outer array, that means there's
one way to create the empty string. And what
170:10 - does that one way? Well, it's to take no elements
from the word bang. So I think this is going
170:15 - to be consistent logic, this is going to be
a really important way to think about this
170:19 - problem. That is, when we're given a target
that cannot be constructed using the word
170:22 - bank, we should return an empty array, right,
a one dimensional empty array, because there
170:27 - are zero ways to create it. On the flip side,
if I've ever given the empty string, we know
170:31 - that it's always possible. And so we should
return like a two dimensional empty array.
170:36 - Cool. So with that, let's look at some tree
examples. Now, let's say I have this large
170:40 - example from before, we know that the overall
tree like we've always know created would
170:45 - look something like this. Obviously, now we're
just reframing this problem in the return
170:50 - values that we do for our base cases. So you
notice that there are four base cases here
170:55 - that kind of reach the empty string. And I
know that those represent the four ways to
171:00 - create abcdef. And now I have to adjust the
return values here. So I'm already saying
171:05 - that if I have the empty string, then that
should return an empty 2d array. So it looks
171:10 - something like this, right? And how I actually
reconstruct the entire solution from these
171:17 - very small sub solutions. So let's just stay
focused on the left subtree. Right now, I
171:22 - know that these arrays are going to return
back to their parents. And when I do that,
171:26 - I also need to make sure that I include the
edge that I actually use to transition to
171:31 - the child. In other words, I'm going to be
sure to push the label for the edge into each
171:36 - of those sub arrays. So the key insight is
this, right? I'm just pushing those edges
171:41 - into their sub arrays. And from here, I continue
the pattern up a little further, right. So
171:45 - I know that these arrays return their parent
over here, and I still, you know, push the
171:51 - edges that I took to get to those children.
So on the left, I'm going to put CD in the
171:55 - front, and on the right, I'm going to put
C in the front, resulting in this. And then
172:00 - at this point, notice that this node rooted
at C D E F, that is actually going to receive
172:05 - both of these collections, right? And what
should this note do? Well, it really needs
172:11 - to just combine a both of these arrays. Recall
that, you know, we technically receive a two
172:17 - dimensional arrays, which means that a sub
array represents one of the ways to create
172:23 - the actual target. So if I just concatenate
these two, two dimensional arrays, that yields
172:29 - this construct, if I do a quick spot check,
I'll see if this is compatible with what the
172:34 - question is asking, right? This is a two dimensional
array. And I know there are actually two ways
172:39 - that we can create CDF, if I look at what
this is saying, The first way is to do C,
172:43 - D plus F. And the other ways to do c plus
d f. And so this cell problem is correct in
172:49 - itself. So I'm going to use the same exact
logic to trace through the right hand side,
172:54 - I know that these cases return to their parent.
And the parent is responsible for adding the
172:59 - edge to each of those sub arrays like this.
Now, I'm just gonna reorganize everything
173:04 - at the top just to give us some more room.
And maybe I'll even spread out these brackets
173:07 - to make a look more symmetric. But I'm not
done here, I still need to consume each of
173:12 - the edges at the very top of the tree. So
if I look at my left hand set of arrays, I
173:18 - know that those need to receive AB. In other
words, they need to have a B place at the
173:22 - front of each of those. So I'll just do that,
right. In the same way, all of the arrays
173:27 - in the middle, which is really just a one
sub array, need to add ABC to the front of
173:32 - them, like this. And finally, same thing on
the right hand side with ABCD. Cool. Now if
173:38 - I look at what I have, these represent the
four ways that we can actually create our
173:43 - original target string. But at this point,
the root node just needs to concatenate each
173:47 - of these two dimensional arrays together.
So it really just combines them into a single
173:53 - 2d array like this. And if I do a quick sanity
check, I know that each of these sub arrays
174:00 - represents one of the paths that I can take
to a base case down my tree, which is exactly
174:05 - what we intended at the start. So this type
of recursion is definitely more complex than
174:10 - the previous examples. But hopefully, you
can recognize what's similar to our last examples,
174:14 - right? Let's do one more together, though,
let's go back to this purple example of the
174:18 - full tree would look like this. And we'll
trace through this. So on the left hand side,
174:23 - we're going to start with a 2d empty array,
right, because that's the base case for the
174:27 - empty string. Meaning that hey, it is possible
to create the empty string in one way, and
174:32 - that is to just take nothing. So I do the
same logic as our last example, meaning I
174:37 - returned to my parent, but I'm being sure
to also include the value of the edge, right.
174:42 - And so the key insight here is, I'm being
sure to add the edge label and not the actual
174:47 - node label here. The note and the edge happened
to have the same thing le, but I'm really
174:52 - looking forward to adding the edge right?
So I add Ellie over here. And likewise, this
174:58 - returns to its parent even further, and so
Add that last edge of perp. Cool. Now I need
175:03 - to do everything for this middle path. And
so what I'll do is return the empty 2d array
175:08 - at the very bottom. And this really bubbles
up all the way to the top. And we just accumulate
175:13 - every edge label as we go, right. So it sort
of looks like this.
175:20 - And what's really interesting about this a
right hand path, this is actually a base case,
175:26 - that doesn't work out, meaning we kind of
hit a dead end at EA. And what we said in
175:31 - our initial examples was, whenever we have
a target string, that cannot be created at
175:37 - all using words of the word bank, then we're
going to return a one dimensional empty array.
175:42 - And that actually works out in our favor,
because if we return this empty array to our
175:46 - parents, our parent is going to try to add
the edge into every element of this empty
175:52 - array. But if there are no elements in this
array, and it's going to add nothing. In other
175:56 - words, this one dimensional empty array really
just bubbles up to the very top. And like
176:02 - always, if I just concatenate all three of
these arrays together, I actually end up with
176:07 - my final answer, notice that when I concatenate
an empty array to the rest of these, I will
176:13 - actually contribute nothing to my file answer,
which makes sense because there are no paths
176:17 - that work out on that right hand side. So
our final answer is just this. Like, we know
176:22 - both of those sub arrays represent the two
different ways that we can create purple.
176:26 - All right, I'm feeling pretty good about this
process. Now, let's go ahead and code it up.
176:30 - Alright, programmers back in the code editor,
another problem, another solution. So let's
176:35 - start by laying out the base case over here.
Now, like we said, we'll say if the target
176:40 - is the empty string, then we want to return
a two dimensional empty array, right? Every
176:47 - single sub array here represents the one way
you can create the empty string by taking
176:51 - nothing right I take no words of the word
bank. Nice. And then besides that, we need
176:55 - to make our recursive logic. So that's going
to be very similar to what we've always done
176:59 - for this style of problem. So I'm going to
iterate through every word of the word bank.
177:03 - So I'll say let word of word bank word bank.
And I need to still check if there's a prefix,
177:10 - right? If this word is a prefix, so if target
dot index of word, if that index is zero,
177:18 - then I know that it must be a prefix, so I
can continue some code inside. Nice. And so
177:24 - what I'll do is I'll go ahead and create an
extra variable just to store the target after
177:29 - I remove the word which would give me like
the suffix so I'll say const suffix equals,
177:34 - and I'll say target dot slice of word dot
length. So you've seen this pattern before.
177:40 - But just to refresh, this just gives us everything
after the word. So basically, once you move
177:46 - the word, what is the remainder of the string
all the way to the end. And now that I have
177:50 - this suffix actually wants to call my function
recursively on that remainder, right? Just
177:56 - like this, I'll pass along the same word bank.
Cool. And now here's where things get a little
178:03 - intense, right? So we've been doing a lot
of problems, you know, using this recursive
178:07 - structure, and then we memorize it in the
long run, I think the most important thing
178:10 - to do is when you make your recursive call,
you really just assume that your function
178:15 - works, right. So I think about what type I
should get back from all construct. So I know
178:20 - that all constructs and give me back an array,
right, it's gonna give me back an array containing
178:24 - all of the ways to make the suffix. If there
are no ways to make the suffix, then it's
178:28 - going to give me like an empty array, right.
And so I'm going to assume that here, so I'll
178:33 - create a variable. And I'll call it, let's
say, the suffix waise. And the reason I'm
178:38 - naming it like this is, I really want us to,
in our head, think about the return value
178:43 - from this as an array of all the ways to build
the suffix. Cool. So that's going to be a
178:49 - two dimensional array, right? There are many
ways to do it. Nice. So if this gives me all
178:55 - the ways to make the suffix, how can I get
all the ways to make the original target like
179:01 - in this current stack frame? Well, what I
need to do is really just take each of those
179:06 - suffix ways, and add my word to the front
of it, right? I used this word to even create
179:14 - the suffix in the first place. So what I can
do is, I'm going to say my target ways. Right?
179:21 - So now I want to relate how the suffix ways
can be used to build my original target, right?
179:26 - All I need to do is really iterate over every
sub array over here and add my word to the
179:34 - front of it. Right, that's exactly the process
we took in the tree diagram, right? So I can
179:39 - use some nice JavaScript methods here. If
I just wanted to basically manipulate every
179:44 - element of the array, I can do a map here.
So I'll say suffix, ways dot map. And I know
179:50 - that a single element there's going to be
one way he'll say, singular. And then what
179:55 - I want to do is just take that same way, copy
it over, meaning I just spread It's elements.
180:00 - But I'm also going to put the word that I
took in the front, we've seen this syntax
180:07 - before, although maybe this like map method
is maybe new free, maybe you're not super
180:12 - familiar with JavaScript. I think that's fair
game. So let's hop into the node repple. Just
180:16 - to demo this, let's say I had some array,
I'll just make this array 1234. So there's
180:22 - my array. What I can do in general is use
array dot map. And map is a function and you
180:27 - should pass in a callback. So that means another
function. And what I'll do is this callbacks
180:33 - gonna take in every element, and it's gonna
be an arrow function, what's going to return
180:38 - is really just how I want to modify the elements,
let's say I wanted to multiply every element
180:43 - by two, right, the return value of this callback
function is going to become a new element
180:50 - of the new array. So notice, I get back 2468,
my original array was 1234. And I get back
180:56 - a new array using map. And so essentially,
what I'm doing in this example, on line eight,
181:02 - in my actual code, I'm just taking every sub
array and just inserting my word at the front
181:07 - of every sub array. So an example that speaks
closer to our exact code would might look
181:12 - something like this, like suffix ways. And
it's going to be a 2d array. So I'll make
181:17 - a sub array, and we just an array of some
strings kind of arbitrary right now. So I'll
181:20 - say x, y, and then z. And then the second
sub array will be maybe I don't know, like,
181:27 - a x and then a yz. Right, so that's my original
array. And what I want to do is, if I say
181:34 - suffix ways dot map, and let's say for every
way, that is every sub array, I just want
181:42 - to copy over that way by spreading out. And
then I'll just go ahead and put I don't know,
181:47 - like an A at the front, just like this. So
notice what I get back, I basically have every
181:51 - sub array from before, except now I have a
as the first elements of both of those. Cool.
181:57 - So that's all I'm doing in this particular
chunk of code. Awesome. So we'll leave the
182:02 - node repple. Back to our running solution.
And now that I have the target ways, that's
182:08 - good. It's basically just like a piece of
the answer I need. However, it now this is
182:13 - really only going to give me all of the ways
to make a target that use this word that I'm
182:18 - currently like on in my iteration. However,
I know that this for loop gives me multiple
182:24 - branches, right, it's going to use all of
the words that are possible to create the
182:28 - target. So I need to kind of gather them all
together. So I'll create a variable on the
182:32 - outside, I'll call it result mailstore. Everything
right? So across all of these iterations,
182:39 - I just want to add the target ways into the
results, I'm going to do result dot push target
182:45 - ways, and I need to actually spread this out
that way, I don't nest things too deeply.
182:51 - Right? Remember that this is a one dimensional
array, right now, target ways would be two
182:56 - dimensional, I don't want to just push target
ways into result. Otherwise, I'd get like
183:00 - a three dimensional array. So I'm going to
be sure to spread out target ways, right.
183:05 - So with that, let's actually go ahead and
give this run I think all I need to do now
183:10 - is after my for loop, right, after I'm done
getting all the ways, then I can just return
183:15 - the results of Mr. Just work recursively.
183:20 - So let's just try maybe the first example
for now and see how we do. So I should get,
183:25 - you know, a two dimensional array where I
have two ways to make purple. Right? let's
183:28 - give that a go all construct. Nice, and that's
looking pretty good. That is a correct answer.
183:36 - Let's try these other ones. Now while we're
here. So we should get a nice, large array
183:40 - for that second example. Nice, here it is.
And then the third example, skateboard should
183:46 - return just an empty array, because it's not
possible. And it looks like that last example
183:49 - is also not possible. So we do get an empty
array. And if you kind of notice, to get that
183:54 - last answer, like we did in our other examples,
it does noticeably take us some amounts of
183:59 - time. But before we get to that, let's take
a look at this code, make sure we really understand
184:03 - it. So the biggest logical leap we made here
was really, you know, assuming that we get
184:08 - back valid data from line nine, right? And
then it's all about how we can, you know,
184:14 - adjust that sub result to get our full answer,
right. So if I get all the ways to make the
184:20 - suffix, and for each of those ways, I can
just add my word in front of them. And that
184:25 - would give me all the ways to make my target.
Right. And I need to continue that process
184:29 - for every choice of word, which is why I'm
maintaining this like a massive results variable
184:35 - outside of the for just pushing all the ways
into this result over time. And maybe just
184:40 - to be super clear, you're not familiar with
like this push method, especially when you
184:44 - use the spread operator with it as well and
really easily step through that. So in isolation,
184:50 - right, this is just using push and spread
in general, if I had some, let's say, array,
184:56 - and let's say it was just an array of just
some elements 1234 Then I had another array,
185:02 - I'll call it just numbs, let's say in nums,
I had elements of seven and eight. So here's
185:10 - my original array. And here's my nums. And
if I did array dot push nums, you're actually
185:18 - going to force some nesting in this array.
So array dot push returns the new length.
185:24 - But it also actually manipulates or mutates,
the argument you call it on. So if I look
185:28 - at the array, now, notice that it actually
has another array nested inside. That's because
185:34 - I literally just pushed the entire nums. If
you wanted to do something a little different,
185:38 - what you can say is array dot push, and you
spread out nums, what's going to do is comma
185:44 - separates the seven and eight, basically removing
the outer brackets from it. So have a look
185:49 - at this. Now, look at the array. Notice that
with that second push, now I just added a
185:55 - seven and eight without those additional brackets.
So that's all I'm doing over here. Like I
185:58 - said, I don't want to add another level of
nesting to the result array, right, it should
186:02 - just always remain at most a two dimensional
array. Cool. But overall looks like we have
186:10 - solved this one. And let's kind of talk about
if there is even a way to make this faster.
186:15 - This is kind of an interesting problem. So
this is looking pretty good. So earlier, when
186:21 - we were on the drawing board, we said that,
alright, because of what they're asking in
186:25 - this problem, it is basically going to require
a full exploration, right? If I want you to
186:31 - return every possible way, to make the target
string, you'll just have to kind of do all
186:37 - the work of creating all of those sub arrays,
right, so we can't really avoid that stuff
186:42 - over here. If you think about this example,
unlike 3334, this is actually not the worst
186:48 - worst case anymore. All right, here, we know
that eventually we're going to return just
186:53 - an empty array, because we can never generate
the final z in this example. However, if I
187:00 - remove the Z, then the result will be a very,
very massive 2d array, because there are a
187:05 - bunch of ways to actually make this target
string. Right. So we've kind of changed the
187:11 - direction of what it means to be like worst.
On this example, let's say we brought this
187:16 - to use the Z. If you really cared about optimizing,
like this particular scenario, you would find
187:23 - some benefit to like memorizing it, although
it wouldn't really affect the worst case,
187:27 - because the worst case is actually where you
return a two dimensional array and not just
187:31 - an empty array. So maybe just because it's
good practice, well memorize this. But when
187:37 - we go to the drawing board, we'll see that
this actually doesn't affect the true a bigger
187:41 - worst case. But if you just want to optimize
it slightly, let's say we baked in our memo
187:46 - over here, then we check, you know, if our
target is in the memo, and if it is, then
187:52 - we return the memo, add the target, we'll
be sure to pass along that memo to our recursive
187:57 - calls. And then we just need to make sure
that for our return value on line 16, we actually
188:02 - store that inside of our demo
188:06 - using the target as a key, and then we still
complete the return by returning result like
188:10 - we once did. Cool. So let's run this now.
And I would agree that the last example now
188:18 - runs faster. But it is not the worst case
is a really important thing to understand
188:23 - here. Right? The worst case is when you actually
have to create a massive sub array, right.
188:29 - And so let's head to the drawing board and
see our final conclusion about the complexity
188:34 - here. Like we usually do, well define m to
be the length of the target string, and n
188:39 - will be the number of words in the word bank.
We know that this problem asks us to return
188:43 - an array containing every combination that
generates the target string. And to come up
188:49 - with that answer, we have to visualize it
like a tree sort of like this. In our previous
188:53 - drawing, we saw how each leaf of this tree
represents one way we could create the target
188:59 - string. In other words, if we can figure out
the total number of leaves in a tree like
189:03 - this, then we will basically have the number
that represents how many different ways or
189:08 - how many sub arrays we have to generate in
this problem. We already know that based on
189:13 - our process, we described that there are dimensions
to this tree, we know that the height of this
189:18 - tree is going to be m and we know that from
one level to the next, we really just multiply
189:22 - the number of nodes by n. And that means at
the base of this tree, we would have entity
189:27 - m number of nodes, right, so we have n to
the M leaves, which means that we have n to
189:32 - the M different combinations that generate
the target string. And if we have to represent
189:38 - each of these entity m combinations, then
we definitely need n to the M sub arrays in
189:43 - our output. And so what we're saying here
is no matter what clever implementation we
189:47 - create, we really have to return a result
that is exponential in size. And that's really
189:53 - going to drive the complexity of this one.
You can't do any better than exponential over
189:58 - here. And its overall will say at the time.
complexity of this is n to the M or just exponential.
190:02 - If you want to split hairs here, you can really
multiplied by some additional factors of m.
190:06 - However, the exponential nature of this alone
really gives us the overall complexity, right,
190:12 - because once something is exponential, there's
really no coming back from that. And in a
190:16 - different vein, we can say that this space
complexity for this is O of M, like we usually
190:20 - say, it's really just the height of the recursion
tree. And an example like this, where output
190:25 - is very large, we usually don't include the
size of the output of the size of the result
190:31 - into our space complexity, which case obviously,
would also be exponential in space, because
190:35 - the result is exponential. Right. So here,
we'll just refer to the additional space we
190:41 - use for the call stack, which would be o of
M, right, any solution you come up with for
190:46 - this problem would be just about this fast.
Alright, and there, we have our all construct
190:51 - problem.
190:54 - So at this point, we've gone over many dynamic
programming problems, and we use that memoization
190:58 - strategy to work out a solution for all of
them. However, memoization is only one of
191:03 - the ways we can actually implement a dynamic
programming solution. Right now I want to
191:07 - revisit all of those problems, but this time
use a different lens of understanding. As
191:11 - always, I want us to ease into things. So
we'll warm up with this fib function, this
191:15 - is the same problem as last time. In other
words, I want us to return the F number of
191:18 - the Fibonacci sequence. Here, I'll say that
the zeroeth number of the sequence is zero.
191:22 - And the first number of the sequence is one,
you might notice that this time around, I'm
191:27 - saying that the zeroeth number is zero and
the first number is one. Whereas in the first
191:30 - time we did this, we said the first number
is one and the second number is one However,
191:34 - no matter how you start the sequence, they
will both actually give you the same series
191:37 - of numbers. In other words, down below here,
I have some examples for n as well as what
191:41 - the output for our fib function should be.
In other words, if I asked you for the six
191:46 - Fibonacci number, the answer there is eight,
like we always expect, alright, let's get
191:50 - into the heart of this strategy, right? What
does tabulation even mean? Well, it's all
191:54 - about building a table. So what we'll do now
is step through a tabulated strategy for calculating
191:59 - fib of six. I know that in the long run, I
ought to return the final answer of eight,
192:03 - right? So I hope that I get the answer right
by the end of this little trace. So with tabulation
192:08 - we're choosing to do is really think about
this dynamic programming problem, still in
192:12 - terms of subproblems. But instead of doing
it recursively, we do it iteratively by building
192:18 - a table, really just an array, and I'm going
to begin it with roughly the size of the input.
192:22 - In other words, if my input here is the number
six, then I basically want an array of length
192:28 - six, notice that if I want the indices of
this array, it's kind of line up perfectly
192:32 - with the original input number. And I'm going
to have to actually add an extra position.
192:37 - In other words, this array spans indices zero
through six, which kind of means that there
192:41 - actually are seven different elements here,
right, the length of this array is seven.
192:46 - So something very common that I see when students
try to implement a tabulated strategy is they
192:50 - kind of overlook this off by one nature, right?
So technically, I'm creating an array that
192:55 - has one greater length than my number input.
But any case, if this is my array, what do
193:01 - I want it to represent? Well, in the long
run, I want to actually fill out this array
193:06 - in a way where each subproblem corresponds
to an elements of this array. So here's how
193:11 - I'm going to begin this table. The move here
is to actually initialize every position of
193:16 - this table with zero. And the reason for me
initializing zero everywhere in this array
193:20 - is the fact that I know Fibonacci requires
me to take a sum, right, and zero is a really
193:25 - great starting value when I need to calculate
a running sum, right. But along with that,
193:29 - I need to be sure to seed the starting values
within this table. In other words, if I look
193:34 - at the zero position of this table, it already
has a zero, which makes sense because the
193:38 - zero number on the Fibonacci sequence is zero.
But what I should also do is make index one
193:44 - contain a value of one. And that kind of entails
that, hey, the first Fibonacci number is indeed
193:50 - one. And now at this point, once I've seeded
those initial values, now I can actually run
193:55 - the general algorithm to fill out this table.
So now it's just a matter of iterating through
194:01 - this table, so I'm going to start you know,
at the very first position of the table, probably
194:04 - just with a regular for loop. And what I need
to do is really remember the definition of
194:09 - Fibonacci, right. So if I have this number,
currently in the array zero, that's a zero
194:13 - Fibonacci number, what I can do is just add
this current number that I have kind of pointed
194:19 - to in yellow to the next two positions. And
the reasoning there is a Fibonacci number
194:24 - is used to contribute to the sum of for the
next two Fibonacci numbers. So I'm going to
194:29 - do is take the zero and add it to the next
two positions, obviously, since it's zero,
194:33 - actually don't change the values of those
next two positions. It's nothing really is
194:37 - calculated on that first iteration. But any
case I can continue on to the next iteration,
194:42 - so my current position is always in yellow,
and the next few positions are pointed to
194:46 - in blue. At this point, my current position
says one is what I should do is take one and
194:51 - add it to both of my next positions. So that
means two and three are indices two and three
194:56 - are contained both a one and a one which so
far, make some sense because at least for
195:01 - the to the second number of the Fibonacci
sequence is indeed one, I can do the same
195:07 - thing, right, my current position contains
a one. So I'll add that one into my next two
195:12 - positions. Keep doing this, I add two to my
next two positions, at three to my next two
195:19 - positions.
195:21 - And at this point, I sort of reached the end
of my array. So I know that I probably shouldn't
195:25 - step out of bounds. So really just want to
look one position ahead over here. And at
195:29 - this point, I just add five into my next position,
which actually works out to an eight being
195:34 - stored in index six of this array. Which makes
sense because logically, the six number of
195:40 - the Fibonacci sequence is a just like we intended.
That's all there is to tabulating Fibonacci,
195:46 - the most apparent difference from our previous
like recursive strategy was, this is not recursive,
195:51 - right? This really just requires us to iterate
through an array. So to fully iterative process.
195:55 - And at this point, the actual complexity of
this is really straightforward to kind of
196:00 - foresee, we know that we're just going to
iterate through an array of size n, that must
196:05 - mean that our time complexity is just n. In
the same way, the only space we use is really
196:10 - just the space of the array, which I know
is still going to be sighs and as well. So
196:15 - overall, we're looking at a linear solution
for fib. So before we hop into the code, for
196:19 - this one, I just want to draw a really important
connection. So although at face value, this
196:23 - iterative strategy looks very different from
the recursive solution, a lot of the logic
196:28 - really carries over, I'm still using my overlapping
subproblems to solve this one. So for example,
196:35 - I know that every index of this array really
corresponds to some number input for fib of
196:41 - n, right? So I can kind of visualize it like
this, right? Like we said, the six of bonacci
196:47 - number is eight. So I'm just going to choose
a position of this table, let's say I looked
196:50 - at fib of six. So I know that to calculate
fib of six, what I did was really add the
196:56 - previous two numbers into this position, right.
And if you kind of see that the shape of this,
197:02 - I kind of dropped the table, and even just
ignore the rest of the subproblems. This is
197:07 - basically just a tree that can kind of shift
things around. And it really looks like this.
197:12 - So overall, you're looking at really the same
relationship for calculating Fibonacci. It's
197:17 - just encoded in a table instead of the recursive
tree. But overall, if you understand, you
197:23 - know, the recursive solution, you should still
find, you know, some comfort inside of this
197:27 - iterative solution. But I think at this point,
let's hop into the code for this one. Alright,
197:32 - programmers, let's go ahead and translate
that strategy into some code. So I'll start
197:37 - by creating a table, which really just means
creating an array, we'll call this table.
197:42 - And I need this array to have certain dimensions
that are roughly the size of n. So to do that,
197:48 - in JavaScript, I can say array and call a
static method and pass in my desired size.
197:54 - So here, I want to say n plus one. For the
reason we did in the sketch, right, I need
197:59 - to make sure that the last index of this array
is exactly n, I have to do a plus one here,
198:05 - because of course, indices start at zero.
Cool, that should give me an array of that
198:11 - n plus one size. And then at this point, what
I want to do is assign particular values into
198:17 - this table. So let's just say I console dot
log, what this table looks like, I'll just
198:22 - run this first example of fib of six. So I'll
give this a go. So notice that the array that
198:29 - prints out is this, it says like seven empty
items, which means that the elements are undefined
198:35 - right now, according to our strategy, but
we should do is assign these all to zero.
198:40 - So what I can do is, after I initialize the
array over here, I can fill it up with all
198:46 - zeros using the dot fill method, right? It's
an array instance method. So with that change,
198:51 - now I should have a seven zeros inside of
this array. Cool, so it's looking pretty good.
198:57 - At this point, I also need to fill up a particular
value inside of the table, I really need to
199:03 - make sure that the index one contains a value
of one, right so I can say table at index
199:08 - one equals one. So we're seeding index one
with a value of one to symbolize that the
199:14 - first bonacci number is one, remember that
we kind of have like two base scenarios. In
199:19 - Fibonacci, let's just console that log with
this table looks like now to make sure it's
199:22 - in the correct state before we actually iterate
through it. Cool. So this is a good starting
199:27 - point for our table. So at this point, what
I want to do is iterate through the table.
199:32 - So use a regular for loop for that. We're
gonna need access to the indices. So I'll
199:35 - say let i equals zero. And I'll go up to and
including, and basically give me iterations
199:42 - through the entire table. And I'll do i plus
plus, I'm going to hit every position. Cool.
199:47 - According to what we did in our strategy.
What I should do is look at the next two positions
199:54 - after I right, so I'll say as I'm gonna look
ahead and table and I'll look at positions
200:00 - I plus one, and also i plus two, right? Of
course, right now I'm currently situated at
200:07 - position I. And what I did was I added into
those two neighboring positions, I added my
200:14 - current value in the table. So what I'll say
is, in my next position i plus one, I'm going
200:20 - to increment it by exactly what table I says,
right? So I'm incrementing, my next position
200:27 - by the value in my current position. And the
same will hold true for the next position
200:32 - two spaces away, right, so they both get plus
equals table. I
200:37 - know nice. So this is looking pretty good.
After we're done doing this process for the
200:43 - entire table, where we're just going left
to right, filling in our next two neighboring
200:47 - positions, what we'll do is just return our
answer, which should be table at position
200:53 - n, right? To finish this off, I just want
to return the table at index n, because the
200:57 - elements of this array correspond to the Fibonacci
number, right? And the index is sort of the
201:03 - input to my function. So let's try these examples.
We'll give them all ago.
201:09 - Cool. So I get 813 21. In this very large
number, this actually looks correct. Nice.
201:16 - This is a fair implementation of Fibonacci.
Notice that because we're already using an
201:22 - iterative strategy, we already satisfy a decent
complexity for even this, this last example
201:27 - over here, we already mentioned the time and
space complexity of this strategy, right,
201:32 - it gives us a linear time and space. However,
you may already have in your head that we
201:36 - could actually optimize a little more here
and just use a constant amount of space. However,
201:41 - if you want to kind of subscribe to just a
generic tabulation strategy that I know is
201:45 - going to be useful in most problems, I will
kind of stick to this overarching pattern
201:50 - right of initializing our table upfront, that
is roughly the size of the input, and then
201:55 - iterating through that table. Of course, you
can probably finesse this fib function to
202:00 - only track two variables represent your last
Fibonacci number, as well as your last last
202:07 - Fibonacci number. But I'll leave that to you
because it's not really a classic tabulation,
202:10 - which is a topic want to drill into our heads
right now. Let's head back to the drawing
202:15 - board and do another problem. All right, now
let's revisit that grid traveller problem
202:20 - using tabulation. So like before, we're going
to have a 2d grid, and we start in the top
202:24 - left corner. And our goal is to go to the
bottom right corner, we only have two possible
202:29 - moves at any point in time that is to move
down or to the right. And how many ways can
202:33 - we actually travel to the goal, if we had
a grid of dimensions, m by n. And we want
202:39 - to write our function to actually calculate
this. So let's trace through how you can build
202:42 - a table for this one, let's say we're going
through grid traveller of a three by three
202:47 - grid, that means that our output should be
six in the long run. So like before, our first
202:52 - step in this tabulation recipe, is to create
a table that is roughly the size of the input.
202:59 - And so here I have two inputs, and they really
represent the number of rows and number of
203:02 - columns. So I can create a 2d array to correspond
to that. Like before, if I want the indices
203:08 - to match up here, I'm going to have to make
sure that this two dimensional array has dimensions
203:13 - four by four, right? If I give it a four by
four array, that means that the bottom right
203:19 - index is really three comma three, which works
out nicely, very similar to what we did in
203:23 - that last fib problem. Cool. So I established
the dimensions for my table. Now I have to
203:29 - figure out what should I actually begin my
table with, right? What are the good seed
203:34 - values to use here? Well, I know this is a
counting problem, right? Because they're asking
203:38 - me to count the number of ways to travel through
this grid. For these counting problems. Good
203:42 - initial value to choose is usually zero. So
I'm going to put zero everywhere in this grid.
203:47 - But at that point, I may need to seed another
value in other position in this table, if
203:53 - you recall our previous discussion about this
grid traveler problem, we said that it's a
203:57 - really important case that all right grid
traveler have a one by one should return one
204:02 - right there is one way to travel the gray
one by one grid. And so I'll go ahead and
204:07 - actually take that information and encode
it into my table. So I'll make index one one,
204:13 - actually contain the elements of one. And
I should give me a nice starting point for
204:17 - this algorithm. So at this point, what we
want to do is iterate through this table and
204:22 - come up with some logic that combines the
values in this table, right, basically combining
204:28 - different subproblems to solve my larger problem
at hand. So let's just begin in the top left
204:33 - corner of this grid. In the long run, we can
really implement this kind of iterative pattern
204:37 - through a grid using just some nested for
loops, right. And the key insight is I know
204:42 - if I'm at this position, if I see zero at
indices, zero comma zero, that means in a
204:49 - zero by zero grid, there's zero ways to move
through it, which makes sense, right? Because
204:54 - if any of your dimensions contains zero, then
that must mean that your grid is empty, right?
204:58 - So the game isn't even valid. But if we want
to have some consistent logic, the move is
205:03 - to use your current position highlighted in
yellow right now and add it to your neighbors,
205:08 - right, according to the game, I can only move
to the right or downward. So technically,
205:12 - what I'm doing right now is I'm taking my
current positions element, and adding it to
205:17 - my down neighbor and my right neighbor. Obviously,
if I just have a zero in my current position,
205:22 - then really no arithmetic takes place. But
let's go ahead and do these iterations just
205:27 - to make sure we have consistent logic, right,
so they keep adding these zeros to their right
205:31 - and down neighbors, nothing changes for now,
until I get to the next row, right, this first
205:37 - iteration, next row, still just add zero to
its down and write. But once I'm at this point,
205:42 - I'm going to take this one, I'm going to add
it to my right and down neighbor. So that
205:47 - means they both turn into a one, I keep following
this pattern, right, both of my neighbors
205:52 - turn into a one. And obviously, whenever I
kind of reached like the bounds of my grid,
205:56 - I need to probably make sure that I don't
do any illegal Array Operations. But that's
206:01 - really an implementation detail for the code.
So on to our next row, we contribute zero
206:06 - to both of our neighbors. Here, we contribute
one to both of our neighbors.
206:11 - Now we contribute to to both of our neighbors.
And here we contribute three to both of our
206:17 - neighbors. And finally, things get interesting
in the very, very last row, I contribute zero
206:22 - to my neighbors, I contribute one to my neighbor,
I contribute three to my neighbor. And at
206:27 - this point, we've kind of finished iterating
through the entire grid. And if you look at
206:31 - this position, it contains a six symbolizing
that, hey, how can you actually travel through
206:36 - a three by three grid? Well, there are actually
six different ways you could do that. So before
206:40 - we jump into the code for this one, you can
probably already foresee the complexity of
206:44 - this. So we know that the complexity is really
driven by the dimensions of this table, I
206:50 - know that this table is going to have m rows
and n columns. So if I need to iterate through
206:55 - this table, it's just going to take m times
n time. And along with that, what is the space
207:01 - that we need? Well, it's really just a space
for this 2d array, which is, of course, still
207:05 - m by n. So overall have m times n time and
space. Let's jump into the code for this one.
207:10 - Now. All right back into the code editor.
Let's work on implementing this grid traveller
207:15 - tabulation strategy. So we'll start by initializing
our table, which is going to be a little more
207:20 - complex here compared to our last function,
because it needs to be a 2d array. So what
207:25 - I'll do is I'll start by creating, let's say,
the correct number of rows. So that will be
207:29 - as simple as calling array. And I want really
dimensions m plus one, again, I have to adjust
207:36 - for that off by one error, because I want
the max index in this table to actually be
207:41 - exactly right. And I know indices start at
zero, so I'm going to up it by one over here.
207:45 - Cool. So I'll give me the correct number of
rows. And I want to make sure that the elements
207:54 - inside of this array are also other sub arrays.
So a trick I can do for that is we're going
207:59 - to fill this is kind of just a very particular
JavaScript pattern, I'm going to call fill
208:04 - on this array I just created. And afterwards,
I'm able to map over it. Cool. So maybe I'll
208:10 - spread this out like this.
208:13 - And when I map over this array, what I want
to do is make sure that every element of the
208:19 - array is going to be a new array like this,
this time of dimensions n plus one though,
208:25 - so I have roughly m rows and n columns. So
let's go ahead and just see what the shape
208:31 - of this is. When I print out, let's say the
three by two example. So we'll go ahead and
208:36 - run this code. So notice that if I look at
the arrays I printed out here, it looks like
208:41 - I have a four by three array, which makes
sense because again, I increase my initial
208:46 - dimensions by one that looks good to go. However,
what we'll want to do is really understand
208:53 - how what this map is useful for. So a very
common mistake that you might be tempted to
208:58 - do is Can't I just, you know, skip this map
part, and then do the fill with the array
209:07 - of n plus one. So that will look like it gives
you the same thing. So I'll run that code.
209:13 - But if you write it this way, what you're
doing is you're filling the entire outer array
209:16 - with a single array instance multiple times,
right? So the shortcoming of this code is
209:21 - let's say I kind of change only one position
of the table, let's say I just made an X kind
209:26 - of arbitrarily, that would actually look like
it changed many positions of the grid, right.
209:33 - And that's because this is technically just
one array that's inserted multiple times into
209:39 - the outer array, whereas I need a really unique
array references. So that's how we need the
209:44 - map pattern here. I know every time we evaluate
the callback function to map, it's actually
209:49 - going to execute this entire function, which
means it's going to give us a new inner array
209:54 - instance. Right. So if I use this map pattern
I run again, this is really the intended behavior,
210:00 - right? I have a unique array as a sub arrays
here. And so let's take out this expert. But
210:06 - that being said, Now that I have the correct
shape of my table, I need to insert some good
210:12 - starting values, right? So what are the seed
values here, while we're calling in our strategy,
210:17 - we said that basically the entire table could
contain mostly zeros. So maybe I'll bake that
210:24 - right into this line. So after I make a new
sub array, I'll be sure to fill it with some
210:32 - zeros. So if I run that, now, I should have
a nice table, because that's looking pretty
210:37 - good. At this point, I also need to see another
value, right? We talked about it in that we
210:43 - should see table at position one, one with
exactly one, this is sort of like our base
210:49 - case, when we have a one by one grid, there's
definitely only one way to travel through
210:54 - it. So now we have the elements of one in
position. One, one. Nice. So at this point,
211:00 - now I need to iterate through my table and
fill in other positions. So I'm going to use
211:05 - just nested loops for this. So I'll say let's
i equal zero. And I want to make sure that
211:11 - I goes up to and including m right, basically
the dimensions of the table, and I'll do i
211:16 - plus plus. And very similar for my inner loop
being sure this time to reference j and j
211:23 - is gonna go up to n this time, because we'll
just have classic nested loops just iterating
211:29 - through this two dimensional array, right?
So as I'm iterating through the table, what
211:34 - was the logic we trace through in our drawing?
Well, I what I needed to do was take my current
211:39 - element that I'm at, so maybe I'll call it,
let's say, my current. So my current element
211:46 - would be at table ij. So I need to take this
current element, and I need to add it into
211:53 - my right neighbor, and my down neighbor, right.
So if my row is I and my columns j, that just
212:00 - means I do some arithmetic on i and j. Right.
So if I want to increment my, let's say, right
212:05 - neighbor, what I can say is, look at table,
a position i, j plus one, that'd be directly
212:12 - to my right. And I'm going to increase it
by whatever this current is, if I want to
212:17 - look at my down neighbor, and that'd be i
plus one, but I keep j the same. Cool. So
212:24 - this will add to my two neighbors that are
to the right of me and below me. And at this
212:29 - point, what we have to be aware of is like
what happens at our edges of this table, we
212:34 - know that if we're already at like the last
position of a row, if I do j plus one, I'm
212:40 - gonna go out of bounds. And so to make sure
I don't step out of bounds on these increment
212:44 - expressions, I'll need some conditional logic.
So I'll say if the right position is inbound,
212:50 - so if j plus one is less than or equal to
n, then I'll go ahead and increment to the
212:56 - end should be okay. And likewise, if i plus
one is less than or equal to m, then I'll
213:03 - also increment right? Notice that when I checked
my like j value, that should be using n, right,
213:10 - because that's the number of columns and then
I is a number of rows. So it should use M.
213:13 - Cool. So what I have so far as I'm iterating
through every position of my table, and I'm
213:20 - going to take the elements at my current position,
and I'm going to add it into my right neighbor,
213:26 - as well as my down neighbor, about only if
they actually exist. Cool. So once I'm done
213:33 - filling up the table, then my final answer
should just be at position m, and right just
213:39 - the very bottom right corner here. So let's
give this code a run. So I should get 1336.
213:46 - And then there's a very large number, or run
grid traveller.
213:52 - Nice and looks like this solution is totally
working. And we are already satisfying our
213:57 - the last example here, right? If you tabulate
off the bat, you will have a pretty quick
214:01 - solution. And we already traced through the
complexity for this. So take a moment to you
214:07 - know, look at this code, let it sink in, or
really try to understand how we took that
214:11 - whiteboard strategy and implemented it in
some code, right? We do have to do some like
214:15 - kind of fine implementation details, especially
with the bounds checking here. But I think
214:20 - the most important logic, it's about how our
current position of the table contributes
214:25 - to our immediate neighbors to the right and
downward. With that, I think let's head back
214:30 - into the drawing board. Alright, now that
we've seen tabulation in two different problems,
214:35 - hopefully we're noticing some patterns right?
Let's give ourselves some rules we can follow
214:39 - to tackle any dynamic programming problem
using a general tabulation strategy. With
214:45 - this tabulation recipe, it's going to be pretty
different compared to our memoization recipe
214:50 - in that there aren't two main steps when I
talked about memorization I said, make sure
214:56 - you implement the brute force first, and then
add the memorization app. Towards. Whereas
215:01 - if you just try to tabulate a problem, you're
really going to have the most efficient version
215:05 - of your solution all in one swoop. And so
what is our first step for tabulation? Well,
215:11 - of course, you have to visualize it as a table.
And that really begins with a conversation
215:16 - of what you'd like the size or dimensions
of the table V, that should definitely be
215:22 - correlated based on the size of the input.
So in the case of fibonacci of n, we made
215:28 - our table roughly, you know, n elements long,
sometimes you definitely have to watch out
215:32 - for like an off by one scenario, which we've
been seeing lately. In the case of our grid
215:36 - traveler problem, we saw that because our,
you know, problem represents a grid, we had
215:42 - to create a two dimensional table at that.
So figure out the size of your table based
215:48 - on the inputs to the problem. Cool. And once
we do that, we need to initialize some values
215:55 - within the table. To me, this is always about
choosing compatible types. In other words,
216:01 - if your problem asks you to return a number,
then it'd be wise to initialize the values
216:07 - of your table with numbers right? On the flip
side of that, if I was asked to return a Boolean
216:12 - in a problem, Na, consider initializing true
or false within the table. Cool. And once
216:18 - I have all of the kind of generic values filled
up in the table, then I choose my very important
216:24 - seed value, right? I know that this seed value
should capture the scenario, where I have
216:30 - a trivially small instance of the input where
I automatically know the answer, right. So
216:36 - in the case of our classic Fibonacci, that
means I just seed the N one and the N two
216:42 - values of my table with one and one respectively.
And in the case of our grid traveller, we
216:47 - were sure to capture the scenario where we
had a one by one grid, so you're gonna need
216:53 - to see those values, because that's the basis
upon which we fill the rest of the table.
216:58 - And then we have the hard part, which is really
iterating through the table. And you have
217:02 - to come up with some logic, right, as you
iterate through the table, you have to design
217:07 - some logic that fills further positions of
the table based on the current position. And
217:13 - you really have to, you know, look to the
problem to figure out what the logic is. In
217:17 - the case of Fibonacci, it's as simple as if
I'm at some position of the table, I look
217:21 - one space ahead and two spaces ahead, very
reminiscent of the pattern Fibonacci, in the
217:26 - case of our grid traveler problem was about
looking the unit to the right or the unit
217:30 - downward, effectively shrinking the size of
our grid. So it's really up to you to figure
217:36 - out the logic, look for it language in the
problem. What I always do is focus on what
217:42 - options I have at any point in the problem,
right? My options are Do I go rightward? Or
217:47 - do I go downward in that grid traveler and
problem. So we'll stick to these rules as
217:51 - we tackle our a tabulation problems, and we'll
utilize them right now.
217:59 - Okay, so let's work on tabulating our can
some problem now. So recall that in this problem
218:06 - we want to do is take in a target sum as an
argument, as well as an array of numbers.
218:10 - And we want to return a Boolean indicating
whether or not we could generate the target
218:14 - sum. By adding numbers in the array, we can
reuse an element of the array as many times
218:19 - as we want, we can also assume that all the
input numbers over here are non negative.
218:24 - So we've solved this problem before, right?
recursively using memoization. But now we
218:28 - want to use a tabulation point of view. So
let's come up with the strategy here. So let's
218:33 - say I gave you this input of seven and an
array of 534. In the long run, the answer
218:38 - is true because it is possible to generate
seven, right, you can either do a three plus
218:42 - four or a four plus three, and that would
give you your original target. So you know
218:47 - that in the first step for tabulation, all
we need to do is create a table. But I guess
218:50 - the question here is, what size table do I
create, I have two inputs, I have the target
218:55 - as well as the array of numbers, which of
those actually contribute to my initial table.
219:01 - And so the key insight is to think about,
you know, what's going to change throughout
219:04 - the problem. In other words, if we can reuse
the numbers of the array as many times as
219:09 - we need, then it's not like we're shrinking
the size of that array. However, if we think
219:13 - about the target number of the target, some
that were given, we do have a goal of actually
219:17 - reaching that target. So now we're going to
increase to it over time. And so I'm going
219:23 - to use that as a basis for my table. That
is, I want to create an array that is roughly
219:28 - the size of my target sum. So because the
target sum is seven, I want to make sure that
219:33 - the indices lined up perfectly. So I'll actually
have to create an array with length eight.
219:39 - And in general, I just be creating an array
of length target sum plus one, because we
219:44 - have that classic off by one error over here.
Alright, now that we have the correct size
219:48 - of table, what do I actually want to store
inside? That is what should the eventual elements
219:53 - of this array be? So a really nice rule of
thumb you can use for that is to just recognize
219:58 - what type your answer should be. In the long
run, right, so here, they're asking for a
220:02 - Boolean answer. So that really tells me that
I should probably put some boolean data as
220:06 - the elements of this array. So I'm going to
start by initializing every element of this
220:10 - array with a false value. And the reasoning
is right now we're kind of assuming before
220:15 - we check anything, that none of these target
sums are actually possible to be generated.
220:21 - Cool. But neither think about any particular
seed values, I need something inherent to
220:27 - this can some problem is we treat the target
sum of zero very special, right sort of the
220:32 - base that we use. In other words, someone
gave me a target of zero, I know that that
220:36 - is always possible, no matter what elements
I have in the array, because to generate zero,
220:41 - I can just take no elements of the array.
So that's going to be a really important seed
220:45 - value here. So I'm going to populate index
zero with the element. True. Cool. So now
220:51 - that we have some good seed value, now we
want to think about how we can flesh out the
220:55 - other elements of this array, sort of in a
linear fashion, right? So I'm gonna have to
221:00 - iterate through this table. So let's just
start at the very first index. So right now
221:05 - I'm looking at index zero. And if I'm situated
in any position of this array, then the value
221:12 - I'm currently looking at, should basically
say, you know, is it possible to generate
221:16 - that index amount? In other words, since I
have a true at index zero, then I know that
221:21 - it is possible to generate zero using the
coins of the array. But now that I'm at this
221:26 - position, how can I actually transition into
the further positions of this table. And so
221:31 - what I want to do now is consider the possible
numbers that I can take into my sum. So I'm
221:36 - going to start by looking at this first element
of five. I know that if it's possible to generate
221:41 - zero, then if I also have a five in the array,
then it's also possible to generate five in
221:46 - the context of my array, that means I should
look about five spaces ahead from my current
221:51 - position. So I look at this spot, right, exactly
five indices ahead. And right, now I should
221:57 - actually replace this false value that's stored
at index five, with a true and again, the
222:03 - reasoning is, if it's possible to generate
my current amount, right, right, I have a
222:07 - true in the zero, it's possible to generate
my current amount, and I could take a five,
222:13 - that means that the position of five steps
later should also be true, right. And I want
222:18 - to actually continue this process for the
other values in my numbers array. So I'm just
222:22 - going to look at the next element of three,
that's basically telling me that, hey, the
222:27 - next spot three places away should also become
a true, so I'll just go ahead and make that
222:31 - a true. And finally, likewise, for the last
element of four, right, the element four spaces
222:36 - ahead, should also be turned to true.
222:39 - Cool. And at this point, I think I finished
like my very, very first iteration, that is
222:44 - when my current is at index zero. And at this
point, I just want to keep iterating through
222:49 - the array, so I'm just gonna shift my point
of view, or one space to the right. So now
222:53 - I'm looking at my current as index one. And
what does that over here, my current element
222:59 - is actually false. So what that means is,
it is not possible to generate one using the
223:05 - numbers of the array, which logically makes
sense, right, I only have five, three and
223:09 - four. So there's no way you can ever give
me back a one, right. So if I have a false
223:14 - value at my current position, then I should
not modify like my further values by looking
223:19 - ahead. So notice that if I look at my edge
for five, look, five spaces ahead, I am not
223:25 - going to make that a true because my current
position is not true, right. So I'm going
223:29 - to keep iterating. Same thing happens when
I'm at index two, because the current value
223:33 - is false, there's nothing to be done here,
things get really more interesting on this
223:37 - iteration right? at index three as my current,
then I see a true at this position. So that
223:43 - means I need to look ahead to my future positions,
and actually assign them to be true. Obviously,
223:48 - you'll notice over here, if I look five positions
ahead, when I'm currently at index three,
223:53 - then that would actually be out of bounds.
So I don't need to look that far ahead. So
223:56 - we'll kind of drop that connection. But at
this point, I should make the space three
224:01 - positions ahead truth, that's almost a space
for positions ahead. So that means that indices
224:06 - six and seven are set to true, right? I keep
doing this process all the way through the
224:12 - entire table. Notice that as I keep iterating
toward the right, these forward looking references
224:18 - kind of stopped being useful because it goes
out of bounds. But the point is, by the end
224:23 - of all of these iterations, I do have a true
stored at index seven, which means that it
224:28 - is possible not to generate a quantity of
seven. And if I do a quick spot check, and
224:32 - I look at just my entire table right now,
it has very consistent data. In other words,
224:37 - if I notice where all of the true values are
right there at 03456, and seven, that means
224:42 - that all of those quantities for target are
actually possible, right? On the flip side,
224:47 - if I look at the only elements and indices
that are false, like one and two, that makes
224:52 - sense, because those are the only quantities
that are not possible or you can't possibly
224:55 - generate a one and two, using a five, three
and four as your option. Adding up, right?
225:01 - So we know by the end of this algorithm, the
element that is stored at the last position
225:06 - of our table would be the final answer, right?
So if it's true, then it's possible if it's
225:10 - false, it is definitely not possible. All
right, so let's wrap up this sketch by actually
225:16 - talking about the complexity of this, as always,
we'll define our terms. So we'll say that
225:20 - n is going to be the target sum, which is
just a number. And the flip side of that will
225:24 - say that n is going to be the length of the
numbers array. And we already have the vibe
225:29 - that, hey, both of these terms definitely
affect our complexity, right? If you give
225:34 - me a larger target sum, that's probably a
harder thing to calculate. In the same way,
225:38 - if you give me more numbers to choose from,
it's even harder to calculate, right. And
225:43 - we can recognize that the algorithm just has
us flesh out this table. And I know that the
225:47 - table is of size m, so we're going to have
at least M. However, as I iterate through
225:52 - every position of the table, what I had to
do was actually look ahead in the table for
225:58 - every single element of the numbers array.
So I know that that's going to be accomplished
226:03 - basically, using some nested loops, where
I'm going to have a loop to iterate through
226:07 - just the table, and then a nested loop to
iterate through every number of the numbers
226:12 - array. So overall, I'm looking at N, N times
N, time complexity. And along with that, where
226:17 - does this space here? Well, the space is really
just the exact size of this table, which is
226:21 - based solely on M. So I have just m space
overall. Nice. So this is already looking
226:27 - like an efficient implementation, especially
because we're not dabbling with any exponential
226:31 - complexity over here. I think let's work on
the code now. So here we are back in the code
226:36 - editor, let's start like we usually do by
creating our table. So I'll store this table,
226:43 - and like we discussed in our drawing, we need
to make it roughly the size of our target
226:46 - sum. So I'll create an array, I need to make
sure that the indices lineup directly or at
226:50 - one index, that is exactly the target sum.
So I'm going to initialize it to target sum
226:55 - plus one, right. So that means if I pass in
target sum is seven, when I create an array
227:00 - of length eight, which means that its very
last index is seven, which is perfect. Cool.
227:05 - And while we're here, we'll go ahead and actually
initialize this array with all false values.
227:12 - So I'll do that. I need to make sure that
I seed index zero with a true symbolizing
227:18 - that the target sum is zero, it's always possible
to be made, even before I look at, you know
227:23 - what's in the numbers array. So I'll just
go ahead and say, table at index zero is equal
227:28 - to true.
227:29 - So let's just console dot log, what this table
looks like so far. And I'll just run, let's
227:35 - say the second example here. So I should see
my array of length beat, up need to go into
227:43 - this tabulation folder. Now I'm going to run
this guy. Cool. So it looks like a good table,
227:49 - right? eight elements. And I do have a true
at index zero. Nice. So at this point, now
227:55 - I want to actually lay out the core algorithm
by iterating through the table, somebody who's
228:01 - a regular for loop here, let's say let i equals
zero, go up to I can even include if I wanted
228:09 - to, up to an including the table dot length
is you could also say a target some here some
228:16 - thing based on target some I'll do i plus
plus. And here I'm going to choose to iterate
228:21 - using, you know the manual index, because
I know I have to do some arithmetic to look
228:25 - ahead on the array. But as I iterate through
every element of the array, I want to actually
228:33 - check you know if this position is true, so
I'll check if table at index AI is true. Cool,
228:41 - they know inside of this if statement, I need
to basically jump ahead or look ahead, based
228:47 - on what's in my numbers array. But I only
need to do that if my current position is
228:52 - true, right, I only got to look ahead, if
it's even possible to get to this current
228:56 - amount, right, the current amount I'm sort
of tracing through would be at index i. So
229:02 - at this point inside of my if statement, what
I want to do is now look ahead for each a
229:06 - number of this array, so a nested loop here.
And I just want to look at the elements of
229:11 - this array. So I'll say for, let's say, let
num of numbers. So I'm grabbing each element
229:18 - this time. And now for this number element,
I want to look that many spaces ahead. So
229:25 - I want to look at basically table at index
i plus the number. Cool. So imagine that I'm
229:31 - on like the first iteration of this, I know
is going to be zero. So that's the very, very
229:35 - first index of my table. And if my num is
five, then I'm going to do zero plus five
229:40 - looking five spaces ahead right just like
we did in our trace. And for this position,
229:45 - that is like five spaces ahead. I want to
assign it to be true, basically saying that,
229:51 - hey, if my current position is reachable,
and I can take a step of exactly numb then
229:57 - that must mean position. I plus numb is also
reachable write that entire for loop goes
230:03 - inside of this if statement, right? So this
code is looking pretty good. So far, I think
230:09 - the last thing we need is just to return our
final answer. After we're done iterating through
230:14 - the table. So here I'll just return table
at index targets. Cool. So let's, let's go
230:24 - ahead and run these examples. Maybe we'll
have to debug some stuff. Looks like I have
230:29 - a probably an infinite loop. Yeah, my program
crashed with some massive error. So let's
230:34 - debug this one together. There's something
that I'm not considering in my code. But we
230:39 - did consider when we drew it out. So something
that is probably breaking right now is having
230:45 - to do with like the bounds checking. Something
that's kind of unfortunate in JavaScript is
230:50 - this characteristic, this may have different
behavior, depending on the programming language
230:54 - that you're following along in. But I know
in JavaScript, I had some array, let's say,
230:59 - array, and I set it equal to just a handful
of elements, let's say a, b, and c, if you
231:05 - actually do like array, at some out of bounds
index, like index, I don't know 10. And I
231:10 - assign it like x, that will actually change
like the effective length of this array. So
231:17 - if I take a look at what happens here, so
I'm just running this kind of offhand example,
231:22 - when we run this, notice that we have about
seven empty items before we have the X. Basically,
231:28 - when you do this type of weird assignment
in JavaScript, it's going to like lengthen
231:32 - your array. That way, it makes sure that this
Hey, new element of x is placed at exactly
231:38 - index 10. And so why is that relevant? Well,
in my code, here, I don't really check if
231:43 - I'm out of bounds, right, and I just assign
to something that's potentially outside of
231:47 - the current length of my array of my table,
rather. And if I do that, then this condition
231:53 - is a little suspicious, right? Because if
I do this assignment on line nine to an out
231:57 - of bounds position, then the length will get
longer. And that's sort of like a circular
232:02 - argument, right? I keep iterating, only to
make more stuff out of bounds, only to lengthen
232:07 - the table even more. So that's why I ended
up with like an infinite loop over here. One
232:11 - way I can fix that is to just maybe limit
this, so I won't make a table outline that's
232:17 - a little too dynamic. I know, I can basically
stop once I reach the targets. So that might
232:23 - actually be the better move over here. Pretty,
pretty fair bug though.
232:28 - With that, let's go ahead and run this code
again. give that a shot. Here we see true
232:35 - true, false, true and false. And that is the
correct answer over here. Nice. So here's
232:41 - a nice tabulated solution for our khamsum
problem. And we already spoke about this code
232:46 - having n m times n, time complexity. Now it's
really obvious, right? Because I can see how
232:51 - these exact the loops. And our space complexity
is simply based off of M right. Cool. With
232:58 - that, let's head back into the drawing board
for another problem. All right, now let's
233:04 - work on the house some variation of this problem.
So like before, I'm gonna take in the target
233:08 - some as well as an array of numbers. But this
time around, what I want to do is return an
233:12 - array containing a combination of elements
that actually adds up to the target sum. Right?
233:17 - So here, I want to return exactly one way
if it's possible. And along with that, let's
233:22 - say that it's actually not possible to return
the target sum, then I should just return
233:25 - the null value. And if it's the case that
there are actual multiple combinations that
233:29 - can generate the target sum, I can return
any one of those. So we expect the strategy
233:34 - for this one to be very similar to our last
problem. However, we will need some nuanced
233:39 - logic to return the array now, right? Because
I don't want just boolean data once return
233:43 - an array. So let's sketch this one out. Let's
see I'm stepping through this example. Or
233:47 - my target is seven and my array is 534. For
this input, a reasonable answer to return
233:52 - would be an array of three comma four, right?
Because I can add three plus four to get seven.
233:57 - You can also I guess, switch around the order
of these elements. So if you also returned
234:00 - four comma three, I think that would also
be a valid answer. Point being, I just want
234:04 - to return at least one way that can generate
the target. So we know we want to solve this
234:09 - one with tabulation. And so we'll just follow
our recipe right? And I need to construct
234:13 - an initialize some table, we already know
that the size of this table is going to be
234:17 - based on the target sum, so roughly seven
elements. But we of course, have that classic
234:22 - off by one nature, right? Because I want the
last index of this table to align with the
234:27 - actual number argument. And in general, I'm
going to initialize this array with a length
234:31 - that is target sum plus one. Cool. So now
that I have the correct shape of table, what
234:37 - do I actually have to initialize as elements
inside of this table? Previously, like the
234:42 - Boolean version of this problem, we initialized
everything as false, right. And the reasoning
234:46 - there was, before we actually try all the
possibilities, we're going to just assume
234:51 - that it's not possible to generate every quantity.
We just want to adapt that for this new type
234:56 - of problem. They tell us that if it's not
possible to generate
234:59 - amounts, then we should just return null.
So I think null is actually a great initial
235:04 - value to just put everywhere in your table.
So at the start, we're going to assume that
235:09 - none of the values or none of the amounts
are actually possible to be generated. No
235:14 - is sort of the analog for false in this rendition.
Cool. So now that I have most of the values
235:19 - added to the table, now I need to figure out
what's the appropriate seed value, I need
235:24 - some actual data to begin and get the ball
rolling on this one. So like we expect, it's
235:29 - about having an amount of zero, right, no
matter what if you're given an amount, or
235:33 - a target sum of zero, and no matter what array
of numbers are given, you can always actually
235:38 - generate that quantity of zero, by just returning
the empty array, right, you can take zero
235:42 - elements from the numbers array, and there
you have an array whose sum is zero. So of
235:48 - course, that means at index zero of our array,
we're going to initialize it with just an
235:51 - empty array. And at this point, what we want
to do is, of course, iterate through our table
235:55 - and come up with some logic we can use to
fill out further positions to the table based
236:00 - on our current position. So let's say we begin
at index zero. So here I am. And I have to
236:06 - figure out which further positions of the
table should I be looking at, we've seen this
236:11 - pattern before, I should just base that off
of what I have as options in my numbers array.
236:15 - So look at my first number of five, that means
I could look exactly five spaces ahead in
236:21 - the table at this position. And so if I know
that my current position is possible, but
236:26 - I see that I have an array and my current
position, I know it's possible. If this current
236:31 - position is possible, then a position exactly
five steps later would also be possible, right.
236:37 - And so what I'll do is I'm just going to copy
my current value into my further value. In
236:44 - other words, I want to put an empty array
at position five, right. However, I also have
236:49 - to include the number that I'm using right
now, right, I took a five to actually get
236:54 - to this position in the first place. So I'm
also going to add a five into that array.
237:00 - Cool. If I do a quick spot check, this is
a reasonable thing to do. Because if I look
237:04 - at the state of that index five, it contains
an array of five, meaning that hey, you can
237:09 - return a sum of five by just taking a single
five. And with this, I want to do the same
237:14 - logic for the other numbers of the numbers
array, right. So if I have the three, I'll
237:18 - look three positions ahead of my current place.
And I'll also start by copying over the array
237:25 - at my current position. So I copy over the
empty array. And after I copy that array,
237:29 - I actually want to populate it with the number
that I took to get to the spot in the first
237:33 - place. So I just go ahead and put a three
in that array. And the same thing happens
237:37 - for before.
237:38 - So if you go to the next iteration, you see
that our current element is null, that means
237:46 - that the amount, right in other words, our
index amount, is actually not possible, it's
237:50 - not reachable, meaning we can't get an amount
of one by adding up any numbers of the given
237:55 - array. So what I should not do is actually
manipulate any further values from this position.
238:03 - So I just continue these base iterations.
Same thing happens when I'm at index two,
238:08 - things get more interesting when I'm at index
three, right, I see that the element here
238:11 - is not null. So it is possible to generate
three. And so what I want to do is go ahead
238:16 - and look at my my forward values, and for
copy my current array over. So I know I don't
238:22 - need to look five spaces ahead, because that
would be out of bounds. So I'm going to look
238:26 - at the position exactly three spaces ahead
in the table and copy over my current array
238:31 - like this, what I also need to do is make
sure that I include the number that I'm using
238:36 - right now, which is three, right, because
I'm looking three spaces ahead. So I end up
238:40 - with three comma three, at index six of my
table, which is reasonable, right, I also
238:45 - want to do something very similar for the
position four spaces ahead. So I'm going to
238:49 - copy over my current array, but then also
include the four that I'm using up right now.
238:54 - So now have three four over here. Cool. At
this point, you can kind of see where this
238:59 - is heading right, I've actually already populated
index seven of my table, and three comma four
239:05 - is exactly a one way we could create the seven.
So we could stop here. However, let's say
239:11 - that you continued the algorithm. So in the
next iteration, I know that this space for
239:16 - the indices ahead would be out of bounds,
so I don't need to look there. But according
239:20 - to our general logic, I would actually manipulate
the spot of the table three moves ahead, right.
239:27 - And so what I'll do is if I, you know, follow
the same exact logic, I'm being consistent,
239:30 - not really changing any of the rules here,
I would copy over my current array into that
239:36 - position. So I basically overwrite index seven,
with just an array of four. But then at this
239:41 - point, I would also be sure to include the
number that I'm using right now, which is
239:44 - three, right, because I'm looking three spaces
ahead. So I end up with four comma three,
239:49 - which happens to be like another way I can
generate these seven. So it doesn't matter
239:53 - if you actually continued this algorithm,
right? So if I continued on basically just
239:57 - keep iterating until I hit the very And and
what do I know the element at index seven
240:03 - is exactly an array of four, three. Cool.
So the point is you actually don't have to
240:08 - like exit early. As you iterate through the
table, you'll be okay to just finish all of
240:12 - your iterations. And you'd still have a valid
answer, right? Because in this problem, they
240:17 - just want any way to actually make the target.
And if I take a quick look at my table, I
240:23 - think all of the stored values here make some
logical sense. For example, if I look at index
240:27 - two, there's a null, meaning that it's not
possible to make a two by using elements of
240:32 - the array. In a similar way, if I look at
index four, there's a sub array of four, meaning
240:36 - you can just take one four, to make a some
before. Similarly, you can take two threes
240:41 - to make a sum of six. And of course, you can
make a seven by doing four and three. So now
240:47 - that we have a plan of attack, let's look
at the complexity for this. So of course,
240:52 - the M will represent the target sum, and our
n represent the length of the numbers array.
240:57 - So if we begin with just the time complexity,
we know that we're going to at least iterate
241:01 - through the table and the tables of size m,
right. So I have at least an M in my time
241:06 - complexity. But for every space in the table,
or in every iteration of that loop, I need
241:13 - to also iterate through all of the numbers
in my number input array. And so I can multiply
241:18 - by n over here. Nice. But at this point, now,
let's say that I actually need to take a valid
241:25 - step here, then what I also did was copy over
the array at my current position into that
241:31 - forward looking position, I know that a sub
array will be at most of length m, remember
241:36 - that m is our target amount, the worst possible
or largest way we can generate the target
241:41 - sum would be to have an array of exactly m
ones, right. And so we'll say that in the
241:47 - worst case, we have to copy over an array
of an additional length m, that means our
241:51 - time is really m squared times. And now let's
come up with the space complexity for this,
241:57 - we know that the initial size of the table
is definitely based on M. However, in the
242:02 - long run, we could be storing a sub arrays
as elements. So this is going to actually
242:05 - be a 2d table. In a sense, I know that the
size of any particular sub array here is also
242:13 - going to be m for the same reason we just
said, and so we'd have a m squared space complexity.
242:19 - So overall, we're pretty satisfied with the
complexity of this. Because it's polynomial,
242:23 - right? It's not an exponential quantity. So
it should run in a reasonable amount of time.
242:27 - All right, I think we're ready to hop into
the code for this one.
242:32 - Alright, programmers back in my trusty editor,
go ahead and tabulate this one out. So we'll
242:37 - need to create the table to begin, right.
So I'll create my table, and it should have
242:41 - roughly targets some positions in it, really,
I need to increase it by one. So I'll say
242:45 - array, and I'll pass in target sum plus one,
that way the final index aligns, I'm going
242:51 - to go ahead and fill this table up with all
of those nulls. Right, exactly what we did
242:56 - in our drawing. What I also need to be sure
to do is make sure we populate index zero
243:01 - of our table with an empty array serves as
sort of like a base case, in that we know
243:08 - that the target sum of zero can always be
generated, right, you can generate the target
243:13 - sum of zero by taking no elements from the
numbers array, right? If you took the sum
243:16 - of this array, it would be zero. Nice. This
point, we need to iterate through our table.
243:21 - So you've seen this code before. I equals
zero, go up to and I won't mess this up this
243:28 - time, I go up to an including target some
I'll do i plus plus. So so far, very similar
243:34 - in shape to our last problem. Now that I'm
iterating through every element of the table,
243:39 - I need to add some conditional logic. If you
remember, from my drawing, we only did like
243:43 - the heavy logic when our current position
was not null, right? Because if it is no,
243:49 - you can't even reach this current position
in the first place. So I'm going to check
243:53 - if my current amount is attainable. In other
words, if table at index i, which is my current
243:58 - amount, if that is not know, if it's not know
that I can generate amount I goal. So if I
244:06 - can generate amounts i that i know some other
things could also be generated. That is, I
244:12 - want to look forward in my table for every
number in the numbers array. So I'll say let
244:18 - num of numbers, so I'm getting the elements
of the numbers, right? And I need to look
244:24 - that number of positions ahead right. So if
I'm at i right now, that means that a forward
244:30 - looking position would be at Table A plus
num. Cool, and I need to assign something
244:36 - over here. So I'm going to do is start by
copying over the sub array at position I at
244:43 - my current position, right. I know that if
table I is not know the only possibility that
244:49 - it could be is an array, right can be array
of zero elements are going to be an array
244:53 - of many elements. So no matter what that array
looks like, I'm just gonna copy over that
244:57 - array. So I'm going to spread out all of the
elements table I. And so far like this logic
245:03 - is looking pretty good because I'm basing
my assignment on table i plus num off of table
245:09 - I, right. But in addition to that, I also
need to include this choice of num. So I'm
245:14 - just going to add that into this new array
as well using some syntax that we've seen
245:19 - previously in the course. Right. So I'm just
copying over all the elements of the sub array
245:23 - at table I, and adding on an addition to that
my current number. Nice. So this code is looking
245:31 - pretty good. I think at this point, all we
need to do is let all these iterations finish,
245:35 - and then wrap up by returning the last entry
of the table, or really the table at index
245:42 - target some cool, so not that much different
from our last piece of code. Let's give this
245:50 - a shot. So I'll run how some and here I have
a few diverse examples. And notice that some
245:55 - of them should return null because they're
not possible. If we check these 32243, no
246:00 - bunch of twos and another No, nice, it looks
like this code is totally working. Notice
246:05 - that we already have a very efficient algorithm
kind of off the bat kind of comes free with
246:10 - tabulation, we definitely have m iterations
in this for loop, we have n iterations on
246:15 - the inner loop. But then we also have to consider
this copying over logic, right copying over
246:20 - an array will be at most m. So it's m times
n times M, which is just m squared n, exactly
246:27 - how we spoke about it before. It's something
I really want to emphasize is, you know, in
246:31 - isolation, if someone just asked you to solve
like this house on problem, I don't think
246:35 - it's an easy problem. However, it probably
feels almost trivial, especially since we
246:40 - just did cancer, right? There's a really,
really straightforward progression to these
246:45 - problems. If you compare the house some and
can some functions, they're very, very similar,
246:49 - right, really just changing the type that
we store inside of our table, as well as the
246:55 - assignment that we do when we transition into
our further elements of that table. Really
247:00 - just adjusting that logic for the data type
that they're asking us for. Right? I had like
247:05 - some array answers here. And here, I have
some Boolean answers. All right, so we're
247:10 - smashing through all of these tabulation exercises,
let's do one more variation of this target
247:15 - some problem, that way, we'll have a little
bit of an increase in the difficulty,
247:24 - it's time to revisit the best sum problem.
So we're going to take in again, the target
247:28 - sum as well as an array of numbers. But this
time we want to do is return an array containing
247:32 - the shortest combination, that adds up to
the target sum. And if we have any ties for
247:37 - the shortest combination, we can return any
one of those shortest. So you take a look
247:41 - at an example kind of like we did before,
we have eight and an array of 235, there are
247:46 - a few different combinations, I can yield
eight, right, I can do two plus two plus two
247:51 - plus two, or I can do two plus three plus
three, or I can do three plus five. And among
247:56 - these options, the shortest one is obviously
the three plus five. So that should be the
248:00 - return value over here. Obviously, if you
returned five comma three, that would also
248:04 - be a valid answer. Nice. So let's start tackling
this with our classic tabulation recipe. So
248:10 - we need to decide on the size of our table,
like we usually say it's going to be based
248:14 - on the target sum and not so much the length
of the numbers array. And like we've been
248:19 - saying recently, it would be nice if the last
index of a table aligns with the original
248:23 - target. So although the last index of this
table is eight, that doesn't mean that its
248:27 - length would be nine, right? Let's start by
setting the proper values here. I always want
248:33 - to begin my my value seed with the type that's
kind of relevant to this problem. In other
248:38 - words, they want us to always return an array
if there is at least one valid way to generate
248:43 - the sum. And I know that trivially if I wanted
to calculate the best sum for zero, no matter
248:49 - what array of numbers, I'm given the answer,
there's always an empty array. So I'm going
248:53 - to be sure to store that value at index zero
of my table. And now for the rest of the values
248:59 - in the array, I can't be sure if I can generate
them yet. So I'm going to initialize them
249:03 - as null just like our last problem. At this
point, we can begin our general algorithm
249:09 - by iterating through the table. And so what
I'll do now is look ahead for my current position
249:13 - based on the numbers of the numbers array.
So I'm gonna look two spaces ahead. Right
249:18 - now I see that there's a no inside of that
position, which means I haven't quite found
249:22 - a way to create two, but I'm actually finding
a way right now, right, I can copy over the
249:26 - array from my current position. But I also
need to populate it with how far I'm looking
249:31 - ahead by so just to inside, and do this for
the other numbers of the numbers array. So
249:36 - something similar happens for three, as well
as for the five. Notice that since I just
249:41 - began the algorithm, this is a really the
first time I'm finding any solution for these
249:46 - further values. And so let's keep these iterations
going. I'm going to shift my frame of reference
249:51 - by one since my current position, good things
and all that kind of entails that one is unreachable,
249:57 - right have no way to generate a sum of one
it's actually don't do any logic from this
250:02 - current position. So we move ahead to do,
since I do have a non null value, right, I
250:08 - have an array over here, that means I should
look ahead to my future values. So I start
250:12 - by looking two spaces ahead, I see that at
index four, there's a null, which means that
250:17 - I actually need to replace that now. Alright,
I'm going to copy over my current array. But
250:22 - then I also add the value for how far I'm
looking ahead by. So now I have two comma
250:27 - two inside of that index of four. So now I
look ahead three spaces, which means I'm analyzing
250:33 - index five, I'll notice that index five already
has an array there. And if I actually continue
250:39 - my sort of standard process, I would consider
this array, I would copy over my current array
250:44 - in yellow, which is an array of two, then
I would also add the element I'm looking ahead
250:48 - by which is three. And technically two comma
three is one of the ways I can generate five.
250:53 - But it's definitely not the shortest way right,
I can basically compare the length of these
250:57 - arrays, and notice that the original array
of just five is definitely shorter, so that
251:02 - one should get the stay in this spot. Cool,
I'll do something similar for five spaces,
251:07 - I see five spaces ahead for my current position
yellow, there's a no right at index seven,
251:12 - which means that I can just go ahead and put
this new array inside, so I copy over the
251:16 - array of two, then I add the five, right,
because that's how far I'm looking ahead.
251:21 - I keep this process rolling, I'm going to
modify two spaces ahead.
251:28 - Notice that this sub array I'm considering
would still be longer than what's already
251:32 - stored at index five. So I actually don't
use the three comma to write the five gets
251:37 - the same. Now I look three spaces ahead. And
this would actually be the first time I found
251:42 - at least a way to generate six. So I copy
over my current array, and also add my lookahead
251:47 - value. And now if I look five spaces ahead,
there's a Knoll currently in that index eight,
251:52 - which means that I'm actually finding the
first way to generate eight, so I copy over
251:56 - my array of three, and then I add my five
for my look ahead. Cool. At this point, we've
252:02 - actually already found a way to generate eight.
And you can probably foresee that this would
252:06 - be the shortest way in the long run. However,
if we kind of continued this algorithm, there
252:10 - would actually be nothing wrong with continuing
it right, it's not like we're ever going to
252:14 - put something longer in that spot. So if we
continue our algorithm as normal, if I look
252:19 - two spaces ahead for my current position,
that would mean I'm considering two comma
252:24 - two comma two, to my array of three, three,
and obviously, I just maintain the shorter
252:28 - one, so the three comma three gets to stay.
If I look three spots ahead, then I would
252:32 - be comparing two comma two comma three to
a two, five. And of course, the two, five
252:36 - is shorter, so it gets to stay. And this process
really just continues for the rest of the
252:42 - array.
252:54 - By the end of this algorithm, we do have the
correct sub array stored at index eight. So
253:00 - before we jump into the code, let's look at
the complexity of this one. So we'll say that
253:03 - MSR target's m, and n is the length of the
numbers array. And so we know that in terms
253:08 - of the time complexity, it's going to be the
same as last time, right? Still m squared
253:12 - times n, we don't really add any additional
like costly logic, all we're really adding
253:18 - into the mix is just some conditional logic,
which I know is just a very simple if statement.
253:22 - So that's not going to add any additional
time. And the same way, our space complexity
253:26 - is still m squared, right, because I have
a table of size m. But I know every element
253:31 - of that table could be an array, really just
a two dimensional array. I think with that,
253:36 - let's hop into the code for this. Back in
the editor, let's go ahead and code this one
253:41 - out. So we'll start by creating our table.
And I'll make this table have roughly size
253:48 - of targets. But really target some plus one
that way the final index aligns. And when
253:53 - I actually initialize this table, I want to
actually make sure I have no values inside.
253:58 - So by default, all elements will be no basically
symbolizing that, hey, these quantities cannot
254:06 - be generated yet, we have to actually prove
that there is some combination that can make
254:09 - them. But the really important seed value
is to make sure that index zero is an empty
254:14 - array, right? Basically, the one guaranteed
way I can make zero is by adding no numbers
254:21 - of the array. This point I need to iterate
through every index of my table we always
254:27 - do. I'll go up to the end including why not
the target some nice and as I iterate through
254:36 - every position of the table, I only need to
do the heavy logic if my current position
254:41 - is not no, right. So if my table and my current
position so table I that is not no then I
254:51 - need to do some additional logic. So just
to review, why do I need to only do the logic
254:56 - if my current position is not know? Well,
let's say that it wasn't All right, if my
255:00 - current position is null, then I don't need
to bother considering any further moves from
255:05 - this position if this position isn't reachable
in the first place, right? So only if I have
255:10 - a non null position, then I'll actually iterate
through my options in the numbers array, or
255:16 - I'll consider possible moves. So let's say
let num of numbers. And as I iterate through
255:23 - these additional numbers, and then I need
to actually look ahead in the table basically
255:28 - by that number amount. So I need to write
some logic about table at index i plus num,
255:33 - right, just looking forward in the table.
And we know based on our previous problem,
255:38 - it can some we ended up doing this logic,
we just replaced that position with a new
255:43 - array, where we took all the elements from
our current position, so table I, we spread
255:48 - out that array. Then we added additionally,
this current number that we're using, right,
255:53 - so we have to actually add that into our move
list. Cool. However, now we want to actually
255:59 - add some like, min value logic, I want to
prefer to always keep the combination array
256:06 - that is shorter, right, I want the best way,
not just anyway. And so I think the move is
256:10 - or refactor this code a little bit. I'm going
to actually do this step, maybe separately
256:17 - above. So I'm going to save this to a variable.
And I'll call this my say, combination. This
256:24 - is like my candidate combination, I'm not
sure if this one is actually the shortest
256:28 - right now. And so if I do the assignment over
here, then I'll just use combination. But
256:34 - I only want to do this assignment on line
nine, if a condition is met, right, so what
256:38 - I want to express is, like, if this current
combination is shorter, than what is already
256:49 - stored, right, I only get to replace something
if it's shorter. That's pretty straightforward
256:55 - to express and an if statement, right? So
I want to check, hey, if. And my condition
257:00 - needs to be if the thing already there. So
if the element at index i plus num. If that
257:08 - thing is actually bigger than my current combination,
so combination, not length, and I also need
257:16 - to be sure to do that element dot length,
right? If my combination is shorter than my
257:21 - current thing being stored in at that future
position, then I'll go ahead and replace it.
257:26 - Nice. So this code is looking pretty good.
There's one thing that's kind of missing,
257:32 - but I think we'll just run it and we'll kind
of debug it together. So let's say at the
257:35 - end, I return my table at index Parkinson.
Cool. So compared to our last code, we only
257:43 - added this conditional logic. So if I run
this, something's gonna go awry. And kind
257:49 - of foresee
257:50 - it's very an error. And the error message
is pretty on the nose over here, it's saying,
257:56 - alright, cannot read property length of null.
Right. So it's really about, particularly
258:01 - this expression. So we know that our initial
state of the table has a bunch of null values.
258:08 - So when I look ahead to a future value, and
for the first time, I actually have a way
258:12 - to make it, then I'm going to check the element,
which is no dot length, or I cannot do null
258:17 - dot length. Right. And so I need a way to
kind of get around that. If ever, I have like
258:22 - a null value in my table, then I can just
go ahead and do the assignment, right, because
258:27 - I found at least one way to make that. So
what I'll say is I can put an order here.
258:33 - So I can still do the assignment will say
not table, i plus in JavaScript knows a falsie
258:44 - value. So let's say table at index i plus
num is no. So this expression is no which
258:50 - is really false. So if I say not false and
evaluates to true, so I'll go ahead and still
258:55 - assign that combination to that position,
even if it isn't all, another great reason
258:59 - for using this syntaxes. We know toward like
the tail end of our algorithm, we're going
259:03 - to potentially look out of bounds, which means
that these elements could be undefined and
259:09 - undefined is also a falsie value. Right? So
here I'm saying not false, which triggers
259:15 - as true, which means I would still correctly
assign those positions. Right. The important
259:21 - thing is I need to be sure to not do this
expression. When the element is null or undefined.
259:28 - You can't say no dot length, and you also
can't say undefined, not length. So this expression
259:33 - will guard against that. So with that change,
let's go ahead and run this. Cool. So 73544
259:43 - and a bunch of 20 fives nice, especially looking
at that last example, like 20 fives is obviously
259:49 - the best way to make 100. And just to be super
Sure, should be no different if I even switched
259:56 - around the order of these sort of ways. So
what I put like, one, five in two. That should
260:04 - still give me a bunch of 20 fives, right?
Because it's really looking for the best way
260:08 - to generate each some, which would mean the
smallest summary. So there we have it a pretty
260:13 - interesting tabulation a problem. However,
I do want us to recognize how similar it is
260:18 - to our last how some problem, right? So here,
I have best some on the left and how some
260:23 - on the right, notice how similar the code
is. Really, the only difference is this if
260:28 - statement, right? For the best some problem,
I just added this conditional logic. And all
260:33 - this does is prefer to keep the shorter combinations
over the longer combinations, right, because
260:39 - that's what I want to return in the long run.
Whereas in houssam, we don't really have any
260:43 - preference in either direction. Awesome. So
let's go ahead and go back to the drawing
260:47 - board, I think we'll kind of switch things
up. Let's switch gears a little bit and revisit
260:53 - those string problems with tabulation. Let's
begin with that can construct problem. So
260:57 - we're going to take in a target string as
well as an array of words in a word bank.
261:01 - And this version of the problem and I want
to do is return a Boolean, right, true or
261:04 - false, indicating whether or not I can make
the target by concatenating, any number of
261:09 - elements from the word bank array, and I can
reuse elements in the word bank as many times
261:13 - as I want. So we've seen this problem before.
But just to refresh, let's take a look at
261:17 - an example. So let's say my target was abcdef.
And I gave you this array of some different
261:23 - substrings. In this particular scenario, it
is possible to create abcdef using members
261:29 - of the array. So the answer here is true.
And one way you can actually create your target
261:33 - string is by just doing ABC plus the fright.
Alright, let's start to apply our tabulation
261:39 - to this one. So I'm going to create a table
and you probably already recognize that, why
261:44 - I want to base the size of this table off
of the target string, right, because that's
261:48 - really where I have some problems, I'm going
to be decreasing the size of my target, or
261:53 - in other words, building up to my original
target over time. And so I know that I'm going
261:58 - to make it about the target string and not
the array of words, because I'm never going
262:02 - to remove a word out of the word bank. So
I'm gonna start with this table. And here
262:07 - the sizing is is kind of particular, because
we need a way to have this table or represent
262:14 - information of a string, right. Whereas before
with our number problems, it's very straightforward
262:19 - to just use the index as the actual number.
So we're going to use a little clever have
262:25 - an encoding here. And so what you'll notice
is here, I created an array of size seven,
262:30 - right, table dot length is seven right now.
And in general, you'll want to size your table
262:35 - by doing target dot length plus one. So we
still have that sort of off by one scenario,
262:39 - that's kind of a very characteristic of these
tabulation problems.
262:44 - And so what will this table represent? Well,
if I just think of the characters of my original
262:50 - target string, I know they have corresponding
indices sort of like this, you're probably
262:55 - wondering, then what's the point of having
that extra spot at the very end of the array,
263:00 - right? What I need to store index six, if
it has no corresponding character. And the
263:06 - reasoning is, we need a way to actually represent
information about the empty string. And so
263:11 - here's the pattern we're going to use. If
I look at index zero of this table, then I'm
263:16 - actually making a statement about the empty
string. So pretend that if you look at a spots
263:22 - of this table, depending on what that index
is, you're considering the substring, that
263:27 - starts at index zero, and goes up to but not
including your current position. So we'll
263:32 - see how this scales over the rest of the indices
here. So imagine that now is at index one,
263:38 - I'm looking at index one, and you're really
just looking at the A string, for at index
263:44 - two, then you're looking at a B, if you're
at index three, then you're looking at ABC,
263:48 - for index four, then you're going A through
D, if you're at index five, you're looking
263:52 - at A through E. And so the really key insight
here is if I'm looking at index five of my
263:57 - table, it means I'm making some logical statement
about the substring starting from index zero
264:04 - going up to but not including index five,
right? So if I wanted to make a statement
264:08 - about the entire target string, then I should
actually look at index six, right? Because
264:14 - imagine you start your substring at index
zero always, and you go up to but not including
264:19 - your current index. And again, the whole reason
for this is I need a way to actually make
264:25 - a statement about the empty string.
264:27 - And so speaking of the empty string, let's
go ahead and talk about our C values. We know
264:33 - that a really core you know pattern in this
can construct problem is to use the fact that
264:38 - hey, if your target string was empty, no matter
what array of words you were given in your
264:42 - word bank, that is always possible. So it's
always true. And so that means at index zero
264:48 - of my table, I can go ahead and seed a boolean
value. How do I know what type to even store
264:54 - as the elements of my table? Well, if the
problem is asking me to return a Boolean,
264:59 - then it's probably a good To actually just
begin with some boolean data in your table.
265:03 - So if index zero is going to start as true,
I'm going to initialize the rest to be false,
265:07 - right. So I'm going to consider all of these
other sub strings or prefixes as not possible
265:12 - until I prove them otherwise. Alright, so
let's begin our general algorithm. So we'll
265:17 - begin like we always do by just iterating,
from left to right through our table. And
265:21 - just we have some notation to make it easier
to kind of translate the information in a
265:25 - table to the statement it makes about our
target string, I'm going to have the characters
265:29 - up top, and I'm going to like them up based
on the substrings that we're really considering
265:33 - here. So if I begin at index zero, like we
said before, that means I'm making a statement
265:38 - about the empty string, right, I see a true
inside of this position, which entails that
265:44 - the empty string can be constructed using
the word bank. Cool. At this point, I have
265:49 - to figure out how I can look ahead to my further
values in the table. And I know that I can
265:54 - do that based on the choice of words in the
word bank. So let's look at one of our words
266:00 - like a B. So something great about this option
of a B is it actually is something that begins
266:06 - from my current position, right. In other
words, if you look at my current position
266:10 - in yellow, the characters below it start with
a and follows with me. So taking an AB right
266:15 - now would be a totally legal move, right those
characters align. And so what I'll do is,
266:20 - I'll go ahead and look two characters ahead,
by look two characters ahead in my table,
266:26 - that just means look two indices ahead. So
now I know that this position of the table
266:30 - is actually reachable by just taking a B.
So I put a true here. And now at this point,
266:35 - I would do this same logic for the other words
that have their characters aligned. In other
266:40 - words, ABC is also some matching word. So
I'll go ahead and make that a true. And ABCD
266:46 - would be the only other one that actually
aligned its characters. So I'll make that
266:49 - one true. Again, how do I know to actually
put this information in the table, it's really
266:54 - just the length of the word right, my current
position right now is at index zero. And I'm
267:00 - looking at a word that is four characters
long. So that means I just look for characters
267:04 - ahead to store my Boolean. Cool at this point,
I'm actually done looking at all the words
267:09 - for this current position. So now I can move
my current ahead one. So now I'm at this position.
267:15 - And so what you'll notice is in this current
position at index one, we have the value of
267:20 - f, which means that it's false, right? It
is not possible to actually generate in a
267:25 - write, there's no way you can ever just give
me back an A, because all of your substrings
267:31 - in the word bank are too long, right? So I
don't actually need to do any of my heavy
267:35 - logic from this position. However, on the
next iteration, when I have something that's
267:40 - true, then I need to do my heavy logic. And
if I do a quick spot check, I have a true
267:45 - stored in this position to write if I'm looking
at the value stored at index two, that means
267:50 - I'm making some statement about indices zero
up to but not including tomb. So really just
267:55 - the substring AB. And I know that if it's
true, that means it's possible. And looking
268:00 - at the elements of the array, it's definitely
possible, right? You just took a beat even
268:03 - get to this position. But I need to look ahead.
So I'm going to look at any words of the word
268:09 - bank that match starting from my current position.
Really, the only option here is CD, right.
268:16 - So if you look at my going characters, right
now, that means I can take this CD. And so
268:21 - what I'll do is I'll look two characters ahead
and place a value at that position. That's
268:26 - true. But the value stored at this position
of the table is already true. So nothing really
268:30 - changes here. And there are no other words
of the word bank that actually begin with
268:34 - a C. So I'm actually done with this pass.
So now I move my current again. And I look
268:40 - for any matching words that begin with like
a D, and potentially other characters after
268:45 - that, really, the only one here that works
out is D, F. And so looking at my going characters,
268:50 - now I'm basically considering this chunk,
right ABC followed by TF. So I'm going to
268:56 - look three positions ahead, because the word
I'm considering right now is three characters,
269:00 - right def is just three characters. If I do
that, I'd be looking at this position. And
269:06 - I'd be making this one a true now basically
saying that it is possible to construct abcdef
269:13 - colon at this point, I would do the same thing
for the rest of the table, we know that nothing
269:17 - else is really going to change within this
table.
269:20 - And so by the end of the algorithm, we have
a true start at index six, which means that
269:26 - our entire string is possible to be constructed.
Right? And so if we do a quick sanity check,
269:31 - if I look at the table at index six, that
means I'm making some statement about the
269:36 - substring that starts at zero and goes up
to but not including index six, which would
269:40 - really be the entire A through F. I know that
it's true. So that substring is possible to
269:47 - be generated, right, which was our final answer
fairly elsewhere. Like maybe at index five,
269:52 - there's a false here, which means that I'm
making some statement about indices zero through
269:58 - four, right, so ABS C, D E. And since there's
a false at this position, that means that
270:03 - it's not possible to generate this string.
And looking at just the elements of the word
270:08 - bank, it's definitely not possible to ever
get a, b, c, d, e. Cool. So the data within
270:13 - our table a does look consistent with that,
let's actually talk about the complexity.
270:19 - So we know that m is going to be our target
string, whereas n is going to be the number
270:23 - of words in the word bank. And so we just
consider the time complexity right now, we
270:28 - know that we're at least iterating through
every element of our table, and our table
270:32 - was roughly size M, right? However, once we
were at some current position of a table,
270:39 - we had to look ahead based on all of the words
in the word bank. And so that would be an
270:44 - N operation for every iteration of m. And
even still, as always, considering the words
270:50 - coming from my current position. And to make
sure that their characters aligned, right,
270:54 - I can't just take arbitrary words, from the
word bank, I have to choose the ones that
270:58 - have their characters matching right now,
I know that the maximum length of any word
271:03 - or the maximal length of a match, I would
have to do would basically just be in terms
271:07 - of M, so give me an additional m term. So
overall, I'm looking at m squared n for the
271:12 - time complexity of this one. And besides that,
we already know that the space complexity
271:18 - comes from the table, which is just a array
of Boolean, so just m space overall. And so
271:24 - from a bird's eye view, it looks like this
strategy would be an efficient one, right,
271:27 - we have a polynomial time complexity, but
more importantly, a non exponential complexity.
271:32 - So let's code this one up now. Alright, let's
code up this can construct problem. So we'll
271:37 - start by creating our table. And so we'll
say create a new array of size target dot
271:43 - length, plus one just like we spoke about
in our drawing, then from there, I need to
271:48 - give some initial values to my table. So I'm
going to go ahead and fill this one up with
271:53 - all falses. So we're going to assume that
every like prefix of our target cannot be
271:59 - constructed until we prove it otherwise, then
I need to actually also initialize table index
272:04 - zero to be true, symbolizing that the empty
string can always be generated, right? Then
272:10 - from there, I need to iterate through every
index of my table. So I'll say i equals zero,
272:15 - just go up to the entire table. And here just
to be safe, I'll say is less than or equal
272:20 - to target dot length. Nice. And as we iterate,
we actually need to check our current positions
272:30 - value. Recall that in our strategy, we said
we only need to do like the heavy logic, if
272:35 - our current position is reachable, so our
current position should be true. So I'm gonna
272:39 - go ahead and check Hey, if my table at index
i is true, then I'll do some additional logic.
272:50 - If I enter this if statement that I need to
consider any further choice of words I can
272:55 - use to progress to other spots in the array,
right? So over here in this if statement,
273:00 - I want to iterate through every word of the
word bank, right? So I'll say four letter
273:05 - word of word bank. Nice. And so what I want
to do, as I iterate through all my possible
273:14 - words is I need to make sure that these words
I iterate through actually match their characters
273:21 - to my current spot that I'm at. In other words,
if I am at my very first index of a over here,
273:29 - then when I iterate through all the options
of words, I need to make sure that I only
273:33 - use a valid words that match like a, b, or
ABC, or ABCD. Right? There's no point of me
273:39 - trying to use def right now. Right? I need
to actually kind of narrow down my words,
273:45 - based on whether or not they match characters,
right. So to do that, I can check pay if.
273:52 - And what I want to express is, you know, if
the word matches the characters, starting
273:59 - at position, I
274:00 - position I goal, it's not going to translate
that into some code. Well, checking if a string
274:08 - matches to something straightforward, just
about using equality, right? But I have to
274:12 - figure out how can I look at the correct you
know, substring of characters within my original
274:17 - target, right? It's pretty straightforward.
All I need to do is say target dot slice.
274:23 - I'm going to slice starting at index i. And
how far do I want to go? I basically want
274:29 - to go like the length of my word. So the move
here is to say go from I up to i plus word
274:38 - dot length. And so let's kind of break down
this logic. So what it's trying to do is check
274:44 - if your word matches your characters starting
at position I. So let's check an easiest scenario.
274:49 - Let's say that my current position is zero,
right? So right now is zero. That means I'm
274:54 - at this position like this ABCD f example.
Let's say right now that my word is ABC. So
275:00 - if I look at this slice, it's going to slice
starting at index zero, up to and not including
275:06 - zero plus three, right, the length of my word
is three, zero plus three is just three, that
275:11 - would actually look at this run of ABC. Good.
And let's say we were somewhere further in
275:17 - the string. Let's say we were actually at
this D character over here. And so if I'm
275:22 - at this D character, that means my value for
AI is going to be three Wragge, oh 0123. And
275:30 - the current word I'm considering, let's say
is this def, the length of this word is three.
275:35 - So this ending index is going to be three
plus three, which is six. And so I would actually
275:39 - slice starting at this character, three, going
all the way through the end, right? 345. And
275:45 - I always exclude the ending index of six here.
So this logic is good, right? All it does
275:50 - is check if my current word matches the characters
starting at index i, goal. So if I enter this
275:57 - if statement, then I have a successful word.
So I should actually set a true in that forward
276:02 - looking position. So I can just set table.
And when I look ahead, how far do I need to
276:08 - look? Well, you need to look exactly this
far ahead, right, i plus word dot length,
276:13 - matching me we're at index zero of our target
string. If I take ABC, then I end up word
276:19 - dot length characters later, three characters
later in this example, right. So I'm saying
276:23 - table of i plus word dot length, that should
be set to true. Cool, notice how similar This
276:29 - is to our previous number, like our target
some problems, except now we have to adapt
276:34 - this four string data. So now I jump ahead
based on the length of the word I'm choosing.
276:39 - So this code is looking pretty good. Let's
go ahead and do our final return value. So
276:46 - I want to return the table at Target dot length,
right? Basically, if I'm at the last position,
276:53 - or at Target length, a position of my table,
that means I have the information for the
276:58 - entire target range starting at index zero
all the way through the end of the target.
277:05 - So here are some examples. Let's give this
a run. So I get true, false, true, false.
277:11 - Nice, and there we have a nice working solution.
So take a moment to let this code sink. And
277:17 - really the most tedious logic here is probably
this particular slice. So really try to make
277:24 - sure you kind of understand how this comment
is implemented using this code. If you remember
277:31 - our previous recursive immobilization strategy
for this problem, we needed to actually have
277:35 - logic to make sure our prefixes match. This
is sort of the analog for that, right. So
277:40 - we already spoke about the time complexity
for this one, but it's already in plain sight,
277:44 - right, we have m iterations here, we have
n iterations here. And then the additional
277:49 - work we do is this slice, right, I'm slicing
from my target, which is also M. So overall,
277:54 - I have m times n times m, or m squared, N.
And of course, the table just takes up definitely
278:00 - m space. Cool. So with that, let's head back
into the drawing board. All right, now let's
278:08 - revisit the count construct problem. So we're
still going to take in a target string as
278:12 - well as an array of words in a word bank.
And this time, we want to return a number,
278:15 - right, we want to turn the number of ways
that the target can be created by concatenating
278:19 - elements of that word bank, we can reuse elements
of the word bank as many times as we want.
278:25 - So let's take a look at an example of this.
So let's say I had this input, so I have the
278:29 - target of purple, and I have an array with
some substrings. The return value here should
278:33 - be two because they are exactly two ways to
create purple. You can do perp plus le, or
278:38 - you can do p plus u r plus p plus le ran,
those are two distinct ways. So notice in
278:43 - this problem, we really just want to return
to the numbers. So we'll just keep that in
278:46 - mind. So let's follow that classic tabulation
recipe, we'll initialize our table with roughly
278:52 - the size of the input that changes, which
is really going to be the target string, right,
278:56 - we want to actually use overlapping subproblems
on the target string.
279:01 - And like we always say, we're going to have
a little off by one scenario here. Although
279:04 - the number of characters in my purple string
is six, I want to initialize a table of length
279:10 - seven. In general, you want to make sure your
table has target dot length plus one a number
279:15 - of elements inside. That way, I have a way
to represent the empty string, just like our
279:20 - last tabulation. And so we'll start by thinking
about what are some proper seed values for
279:25 - this problem. I know that when I have an empty
string, empty target strings, my input, no
279:31 - matter what array I'm given, you can always
generate the empty string right by taking
279:34 - no elements of the word bank. So the answer
for the target string should be one, right,
279:38 - there's one way to make the target string
and that is to concatenate nothing together.
279:43 - So I'm going to store the value of one at
index zero of my table. Now I have to decide
279:48 - how to initialize the other values in my table.
Well, I know that it should be number data,
279:53 - right? It's really important that you try
your best to make your table contain a consistent
279:57 - data type. If I remember my similar counting
problems like Fibonacci, or even the grid
280:02 - traveller of the move here is actually start
those other spots in the array at zero, basically
280:08 - saying, you know, at the start, I have zero
ways to generate these different prefixes
280:12 - of purple. And then as to actually find distinct
ways, I'll go ahead and increment those spots
280:17 - in the table. But we'll get to that. So we'll
iterate through our table from left to right,
280:22 - of course, beginning at index zero of the
table. And as we do this, I'll also up top
280:28 - show the characters that we're considering
within our table. Remember, the really important
280:33 - pattern here is when I'm at some position
of my table, that means I'm encoding some
280:39 - information about the substring that starts
index zero, up to but not including my current
280:45 - index, right. So if I have some information
stored at index zero, that information is
280:49 - about the empty string. From my current position.
Now I need to consider any words of the word
280:54 - bank that I can take right now to give me
another spot within the table. In other words,
280:59 - since I'm at index zero, I need words that
start with P. So let's say we looked at this
281:03 - first word of perp. And so if I looked at
that word, and I took it, that would bring
281:07 - me a somewhere else within the table, right
have to look forward like we usually do. So
281:12 - they'll end up at this position index four.
Again, notice that we have the kind of off
281:16 - by one scenario here. So although I'm going
to write information into index four, that
281:22 - informations about the substring, that spans
from zero, up through index three, right,
281:27 - and what I need to do now is take my current
value in yellow, actually add that into my
281:32 - future position. So I just add one into the
zero. And now index four contains a one, right
281:38 - basically saying that so far, we found a one
way to construct the string perp. And then
281:44 - from there, I look at any other words that
the word bank that match right, so I'll just
281:48 - look at the next word of P. Again, just moving
left to right through our word bank, right
281:51 - now, I'm still at my current position. And
what I do if I use this P is I only look one
281:56 - character ahead, right, because p dot length
is only one. What I do in this future position
282:02 - is of course, just take my current value in
yellow, and I added into this position, so
282:08 - zero plus one is just a one. There is one
more word I can use right now from my current
282:14 - position, that's purple without the E. And
if I look at that corresponding position,
282:18 - they'll bring me all the way over here. And
again, I add the one into that position. Nice,
282:23 - I think that ends are a very first pass. And
now we move our current position to the right.
282:29 - So now my current is at index one. So now
I need to consider words of the word bank
282:33 - that begin with a you and kind of match characters
throughout. The only option here is really
282:38 - just you are in the word bank, if I took a
u r, that would bring me two characters ahead,
282:43 - right, so bring me over here, what I should
do like always, is just take my current value
282:47 - and add it into that position. Now I have
a one over here. There are actually no other
282:52 - words of the word bank that match from my
current location. So I can just move ahead
282:56 - to the next spot in the table. If we're at
index two, it looks like we need something
283:01 - that starts with an R, there's actually no
words of the word bank that we can use from
283:05 - this position. And what we also notice is
there's also a zero at this opposition. So
283:10 - this won't really do anything in our table
anyway. So we can progress just the next spot
283:13 - in the table. Here's where things start to
get interesting, right? So right now my current
283:19 - is at index three. So I need to grab words
from the word bank that start with P and potentially
283:25 - have an L enemy. So what I can do here is
just take this loan p, which will bring me
283:31 - one character ahead. If I look one character
ahead, what I do now is I take my current
283:36 - value, right circled in yellow, and I add
it into my look at value. So I increment that
283:42 - to two now. Nice. And then from there, I need
to continue on my logic by just moving rightward
283:48 - in my table, right shift my current point
of view.
283:53 - At this point, what I do is I again, look
at any words that start with an le, and there's
283:57 - really only one that matches perfectly, I
look two characters head because the length
284:01 - of Le is two. And what I do is I take my current
value in yellow, and add it into that position,
284:06 - right, my logic throughout this entire algorithm
is very consistent. And there we have a two
284:11 - in the last spot, you can probably already
foresee that we have our final answer. But
284:15 - if we continue the algorithm as normal, or
really, we've noticed that if we move to the
284:18 - next position, there's no word of the word
that starts with E. So I don't do anything
284:22 - here. And once we hit the very end, we're
actually done with our algorithm. Right? And
284:27 - we see that, hey, we have a two in the last
spot a retailer which is consistent with our
284:32 - expected answer. Something I think is really
important to do is not only recognize that
284:37 - our final answer is in the last position of
the table, but really any element of this
284:42 - table should make some logical statement about
our target string, right? So let's say I look
284:47 - at index for over here. I see that there's
a two in that spot in the array. So what does
284:53 - that really saying? Well, if I am looking
at the value stored at index four, that means
284:58 - I'm considering the substring That starts
at zero and goes up to including four. So
285:03 - that really means I'm looking at purp, right.
And if there's a two inside of the spot in
285:08 - the array, that means that there are apparently
two ways to create perp. And if I do a quick
285:13 - check in my word bank, that's exactly true,
right, you can just take the straight up perk,
285:16 - because that's actually a literal word of
your word bank. Or you can do p plus u r plus
285:21 - P. Cool. That's some consistent information.
And then from there, if I actually consider
285:27 - now what I can do from that position at index
four, well, you could have taken an le, that's
285:32 - basically what we did when we traced through
the algorithm. If you take an le, what are
285:37 - you really doing? Why is that value in the
index six, also two? Well, for one, Ellie
285:42 - has a length of two. So that's why I'm looking
just two spaces ahead in my table. And if
285:48 - I think about what like logical operation
I'm doing, if I were to take an L e, and add
285:53 - it to all of the ways that I have in blue
Rhino, then I would end up with all of the
285:58 - ways to generate purple right in my last spot,
literally just taking the Le as an additional
286:04 - move, right? Pretty elegant logic. Let's talk
about the time complexity for this though.
286:10 - So we know that, hey, r m is going to be the
target and n is going to be the number of
286:14 - words in the word bank, this is really going
to be about the same complexity as our last
286:18 - rendition, right? You can't construct. So
we're gonna have m squared times n time, right,
286:24 - we definitely have m time for just iterating
through every spot of the array. And we also
286:30 - have an additional n, because we have to actually
look forward for every element of the word
286:35 - bank. And so where does that final m come
from? Like we've been saying lately, it comes
286:39 - from actually performing the match of the
check for matching characters. In a similar
286:44 - way, the space complexity is just going to
be m, really just based off of the size of
286:49 - the table, we're only ever storing just some
numbers within this table. So our space just
286:55 - stays at linear o of M space. All right, I'm
feeling good about this plan, time to code
287:00 - it up. Alright, let's code this one out. Let's
start by creating my table, it's gonna begin
287:07 - as an array with roughly target length, size,
really target length plus one, that way the
287:14 - index aligns, right, I'm going to fill this
entire table with zeros for now, because I
287:18 - know in the long run, I'm going to add into
it. So zero is a great starting value. That
287:23 - being said, I have a really important c value,
I need to make sure that my table at index
287:27 - zero actually starts as one, right, because
there is one way to make the empty string
287:33 - right. Now from here, I can start my core
algorithm by just iterating through every
287:37 - position of the table. So set i equal to zero,
go up to an including target dot length, and
287:45 - hit every index, right. And so what I'll do
is iterate through every word of the word
287:50 - bank. So let's word of word bank.
287:55 - And as I iterate through every word, I need
to check if the word matches my current location
288:01 - right there has aligning characters. So you've
seen this pattern before, I'll check if target
288:06 - that slice I'm gonna slice some characters
out of my target. Starting index i right,
288:10 - this is my current position, I need to look
at the next couple of characters based on
288:14 - the length of my word, I'm going to slice
i to i plus word dot length. goal. So my current
288:23 - position is I, this will give me the next
word dot length number of characters starting
288:28 - at position, I will check if that little segment
is equal to the word I'm considering right
288:33 - now. And if it is equal, then I have a word
that I can actually take, I can modify some
288:38 - further position of the table. In particular,
what I should do is need to modify my table
288:45 - at index i plus word dot length. So I'm looking
to head remember that our current position
288:50 - is I so I'm looking ahead in the table based
on my current words length, what I want to
288:55 - do is actually increase that by some value,
want to increase it by the number stored in
289:01 - my current position, right? That's what we
did at every point of the algorithm. Nice.
289:06 - A common mistake that I see students make
is, usually they have a tendency to just increment
289:10 - by one here, right? That's not the move Do
you want to do is increment by exactly the
289:16 - number that's in your current position, right.
Now, at this point, I think all we need to
289:21 - do is just return our final answer, which
like we always know, is basically table at
289:26 - Target dot length. Cool, so I have some examples
below. With their expected results, let's
289:33 - give this a shot count construct. So I get
to 104 and zero, that's that we have a fairly
289:39 - large example, which should return zero, you
can't possibly generate this final f here,
289:45 - because your word bank only contains a bunch
of E's, and it ran fairly quick. So this solution
289:50 - is looking pretty good. Notice how small of
a variation it is from our last problem. Hopefully
289:56 - you're really feeling the progression. So
let's kind of quickly just take a look at
290:00 - That that was our can construct problem. So
let me split these guys. Very, very trivial
290:09 - difference, right, instead of assigning a
true value. Now I actually just increment
290:14 - because I have numbers within my table. That
was short and sweet. Let's head back into
290:20 - the drawing board. Let's do one more problem
together, let's revisit that all construct
290:27 - problem. So we're still taking in our target
string, as well as an array of words in a
290:30 - word bank. But this time, you want to return
all of the ways that you could construct the
290:34 - target by concatenating elements of the word
bank. So here, you need to return a 2d array,
290:39 - that means a single element of the array represents
a one combination that makes it a target.
290:44 - And like usual, we can reuse elements of the
word bank as many times as we see fit. So
290:48 - we take a look at an example, let's say I
gave you the target of abcdef, I gave you
290:53 - this array of words, you actually have many
ways to create the target string, there are
290:58 - four ways over here. So each sub array represents
one combination, where if you concatenate
291:04 - it together, you get the target. And so notice
that I want to return every single combination
291:10 - as an element of the outer array over here,
right. So if there are many ways to create
291:14 - something, then I want to return a 2d array.
That being said, there are a few examples
291:19 - that we should keep really in mind having
to do with our seed values that we kind of
291:23 - foresee. Right. So let's say I gave you this
example, where your target is the empty string,
291:27 - and I gave you just some words in the word
bank. The point is, since your target string
291:31 - is empty, your result should really be a 2d,
empty array. So recall that the outer array
291:38 - here represents like the collection of multiple
combinations. And here, there's only one combination
291:44 - that makes the empty string, right, so the
inner array represents like that empty combination,
291:49 - we take no words of the word bank. And this
is a reasonable thing to do, because they'll
291:54 - take give you this example, if your target
was birds, and I gave you an array of cat
291:58 - and dog, then the result, there should be
just a one dimensional empty array, right?
292:03 - The array over here represents the collection
of combinations. And there are no elements
292:08 - here, right? There are no combinations at
every yield of birds. So we'll keep those
292:13 - sort of seed value base case scenarios in
mind. So let's trace through this example
292:19 - of abcdef. I'll start by initializing our
table, we're gonna need a lot of room in this
292:25 - one. And so we know that the size of this
table is going to be based on the target string,
292:29 - right, just like we usually do. And then we
have to figure out what our seed values are,
292:33 - we kind of just spoke about them, we know
that if I have the empty string, then I need
292:38 - to have a 2d empty array. And so we'll initialize
that in our table,
292:44 - I know we're going to need a lot of room.
So I'm going to spread out these outer brackets.
292:48 - Now for all of the other elements of our table,
we want to make them just one dimensional
292:53 - empty arrays. And here's the reason why I
write for these further values in the table,
293:00 - I have to actually check for ways to generate
them. So for now, there are no ways that I
293:05 - found right, that's why I just have an array
with zero combinations inside, except for
293:11 - index zero, right? index zero has one combination
inside, that happens to be the empty combination.
293:16 - Cool. So let's start with our general algorithm.
A lot of this logic will feel very similar
293:22 - to our last few problems. Now we're just adjusting
it have to generate these combinations, right.
293:28 - So we know that we're going to try to visualize
how we look at our string in terms of some
293:32 - prefixes, right. I know that if I'm highlighting
some spot in my table, then that grabs the
293:37 - prefix or an index zero all the way up to
midnight, including my current index of the
293:42 - table. And I'll light up those characters
at the top over here. So what I need to do
293:46 - now is since I'm currently at index zero of
my table, I consider words of my word bank
293:51 - that have matching characters from this position.
So I can look at this a B First, if I took
293:56 - this A B move, then I should look two characters
ahead, right, because a B has a length of
294:01 - two. So that brings me to this position in
light blue. And what I should do is take all
294:05 - of the combinations in my current location
in yellow, and actually copy them over into
294:10 - this future position. But when I do that,
I also need to be sure to include in those
294:16 - combinations, the move of the word I just
took, right, so that would just be adding
294:21 - an AB inside. Right. So again, kind of repeating
that step, I copy over the contents of my
294:27 - current position in yellow. But then I have
to make sure I add my word that I'm consuming
294:32 - right now into each of those combinations
I just added. Cool. And now we would actually
294:38 - keep our current position here because there
are still some other words of the word bank
294:42 - that have matching characters, right, I can
take an ABC from this position, and something
294:47 - very similar happens write a copy over my
current array. And then I go ahead and add
294:52 - ABC to it. This happens one more time for
ABCD
294:56 - Awesome. At this point, I've considered all
of the words that match from this current
295:06 - position. So I can move forward a little bit.
At this point, though, I need something that
295:11 - starts with A, B, right? Because my current
position has to be on it. And I actually don't
295:17 - find any words of the word bank, that kind
of match from this position. So I actually
295:22 - moved my current once more. What about this
position, I have to consider words of the
295:27 - word bank that have a seat, right, and there
are a few that can use here, I can use CD,
295:31 - right. And if I do that, I look two characters
ahead or two indices ahead for my current
295:37 - position. So I'm looking at this index. So
if I look at index four, I have a really interesting
295:42 - situation, right? I already have a some combination
stored inside of index four. And that represents
295:48 - one way we could make ABCD, right by just
taking that loanword ABCD. But what I can
295:53 - also do is, I should take all of the combinations
from my current position and just add them
295:58 - into that index for right, so I'm taking the
A B from index two, just adding it to index
296:04 - four. But then I also need to add to that
new combination of the word I'm using right
296:09 - now, which was CD. Cool. And then from here,
you already noticed that, hey, there are so
296:15 - far, two ways to create ABCD, you can just
take that loan word ABCD. Or you can do a
296:20 - B plus CD. So this logic is taking some some
nice shape here. For my current position,
296:25 - there's actually one more word that matches,
it's really just a single character see, so
296:29 - like I do, I look one character head or one
index head in my table just next door, and
296:34 - I copy over the combinations from my current
location in yellow. But then I also append
296:40 - the word I'm consuming, which is just an additional
C, right. So so far, I have two ways to make
296:45 - ABC. At this point, I can progress my current
spot and table. And I look for any matching
296:53 - words that start with a D, right? So that
would be the D f over here. d f has a length
296:58 - of three. So I look three spots ahead in my
table. And I need to add some information
297:02 - here, I copy over my current combinations
in yellow. And then I have to append at the
297:08 - end of all of them the D F word that I'm using
right now. So it looks like this. At this
297:15 - point, I can iterate my current position.
So now I'm at index four as my current. And
297:19 - I look at any words that start with any, and
there's actually just one over here just as
297:23 - EF. And so I look to character's head or to
indices ahead for my current position. And
297:28 - again, this is a scenario where I need to
append new combinations to this existing list,
297:33 - right. So if I look at my current position
at index four in yellow, I'm going to take
297:37 - all of those combinations and copy them over
into my light blue position at index six.
297:43 - And then from there, I also need to make sure
that I append to them the word I'm using right
297:48 - now, which is an E, F. So those two combinations
also get an F at the end of them. Nice. At
297:54 - this point, you see our final results at the
last spot on the table, we continue the general
297:59 - algorithm, we would just move our current
position to index five, which is actually
298:03 - a no words of x star with an F over here.
So nothing happens on this iteration. And
298:09 - there we have our algorithm, right, that index
six of the table contains all of those four
298:14 - ways we described how we can use to create
our original target string, take a moment
298:19 - to look at this table. And notice how every
position of the table should make some logical
298:24 - statement about the target string. Right,
I can see that if I chose some position, let's
298:31 - say index three, that's giving me some information
about the substring ABC, right, that prefix
298:37 - of my original target. And what saying is,
there are two ways to make ABC, you can just
298:41 - take ABC, that's actually a word of my word
bank. Or you can do a B plus C, right? That's
298:46 - the only other way that applies for all positions
within my table. If I look somewhere else,
298:53 - like at index five, that means I'm reading
some information about A through E. And if
298:59 - there's no combinations at this position,
means there's no way you can ever generate
299:03 - ABCDE. And if you take a quick glance at the
words in the word bank, that is correct, you
299:08 - can't possibly just generate ABCD. Overall,
the information in our table and our logic
299:14 - that we did was very consistent. Before we
hop into the code for this one, let's do the
299:19 - analysis. So we know that m is going to be
the length of our target string. And we'll
299:24 - define n to be the number of words in the
word bank. So like we described, when we did
299:28 - the memorization and recursive solution for
this problem, we really can't do better than
299:33 - a sort of brute force, right? Because they're
asking us to return literally every single
299:39 - way to generate our target string here. So
really, the time complexity is going to be
299:45 - the shape of an exponential, right, so about
n to the M, again, it will have some extra
299:50 - like multiplication terms of M
299:52 - in it. But overall, we're looking at an exponential
time complexity. And what's the reason behind
299:58 - that? Well, we know there's going to be an
exponent The number of actual combinations
300:02 - that we need to return. And I have to actually
construct all of those combinations piece
300:07 - by piece. And so I'm looking at at least exponential
time. And really, once something gets exponential,
300:13 - that's really the limiting factor, right.
And similarly, we can say that the space complexity
300:19 - for this is also going to be exponential.
Again, roughly, we know that we're going to
300:23 - have at least m space just from the straightforward
sides of the table. But notice that every
300:29 - element of the table itself is going to be
a 2d array. So in a sense, we're really dealing
300:35 - with like a 3d table in this instance. And
so we know that at any particular position
300:41 - of our table, we're going to have potentially
an exponential number of things, right, if
300:46 - you consider the very last spot in our table,
just the last spot that already has an exponential
300:52 - number of combinations inside of it, but then
I would actually have that throughout my entire
300:57 - table, so it'd be really a little more than
just n to the M. But overall, I'll say it's
301:03 - roughly exponential complexity. And you can't
really do any better here, right, especially
301:07 - in terms of the time, I'm really asking you
to just do this in a brute force way, I think
301:12 - we'll actually be able to see that once we
create the solution. Let's hop into it. Alright,
301:19 - for one last time, let's solve this all construct
problem. So I'll begin by creating my table.
301:23 - By now we're tabulation masters, this is very,
very formulaic. Create my table with roughly
301:30 - target size really target dot length plus
one. And here, I need to initialize the elements
301:36 - of my table as arrays. So here, I need to
be very particular and make sure I get a unique
301:40 - array in every spot of the array. So I'm going
to do a fill using this index before, then
301:45 - I'll map over it that way I can generate a
new array for every element here. Cool, let
301:50 - me just style this up. And so this should
give me an array as every element of my table,
301:55 - right? Notice that the elements right now
are just one dimensional empty arrays, right?
302:00 - These arrays represent the collection of combinations.
At the start, they're empty, meaning that
302:05 - I have no combinations for most of these elements,
except for one, right, we already spoke about
302:11 - table at index zero, right? That should be
a 2d, empty array. And the reason was, still,
302:18 - the outer array here represents the collection
of combinations. For the empty string, there
302:22 - is one combination that you can use to make
it right, that is the empty combination, where
302:26 - you take no words to the word bank. Cool.
So now I can begin my general algorithm by
302:31 - just iterating through my target, and you've
done this many times before. So I'm iterating
302:35 - through my table. And what I'll also do is
look at all of the words, right, so in every
302:40 - iteration, I'm going to consider some words
of the word bank. So I'll say that word of
302:44 - word bank. And like before I send you to check
that, alright, these words better have matching
302:51 - characters based on my current position. So
I'll use that classic logic, right, seen it
302:55 - many times by now. And I'll slice a segment
out of my target string, I'll say target dot
303:00 - slice starting index i, and grabbing the next
word, dot length, number of characters. Cool.
303:08 - I'm going to compare that chunk to the current
word that I'm iterating through. Nice. So
303:14 - using this statement, I'm sort of filtering
down all the words, and only going to do some
303:18 - logic on the words that match based on my
current position. Nice. And so we've seen
303:24 - you know, this nested for loop an if statement
before, right, we're now we're adding our
303:28 - new logic within this if statement. Cool,
all I need to do is really understand what
303:34 - types of data I'm dealing with here. All right,
so let's say I just wrote this expression
303:38 - table at index i, well, that's going to do
is just reference my current spot in the table.
303:44 - And if I think about what data it's going
to be, it's definitely gonna be an array,
303:47 - right? It's either going to be like an empty
array, meaning there are no ways to make this
303:52 - current target. Or it could be a multi dimensional
array, where every sub array represents one
303:57 - way I can make the current target. So if this
is all of the combinations that generate my
304:02 - current, then what I'll do is I'm going to
map over them. Remember, in our drawing, what
304:07 - we did was kind of copy over all of our current
combinations. But then make sure we also add
304:13 - our word that we're using right now to the
end of each of those combinations. So that's
304:17 - what I'm doing right here, and a map over
every summary. And what I'll do is, I'll just
304:25 - copy over the elements of that summary using
that spread syntax that we've seen before.
304:29 - And then also be sure to add on at the end
my word. Nice. And then that will give me
304:35 - let's say, our new combinations. So I'll just
say that to a variable maybe. So new combinations
304:42 - is going to be a 2d array, right where every
sub array represents some combination.
304:46 - And I want to take these combinations and
add them into that further spots inside of
304:52 - my table. So I know I need to kind of look
at in my table. So I can look at table at
304:57 - index i plus word dot length. I know that
all positions of the table are going to be
305:02 - arrays, right? So this is going to be an array,
there's going to be some data that might already
305:06 - exist at this position, right? So what I don't
want to do is just assign you combinations,
305:12 - because then that would overwrite any previous
existing combinations that I already found
305:17 - for this position. Instead, I need to make
sure that I just add these new combinations
305:22 - to that list, right. So what I'll do here
is I'll push to that array, I'll push all
305:27 - of the elements of my new combinations right
here, I can spread this out, I want to spread
305:32 - it out. That way, I don't add any additional
nesting over here, right. So this is looking
305:36 - pretty good. I think let's go ahead and return
the table at Target dot length. Here, I have
305:45 - some examples down below. Let's give this
a shot. Nice. And these answers look correct.
305:53 - Right, notice that these last two examples
should return empty arrays because they are
305:58 - impossible to generate. Cool, let's hover
over this code for a moment. Probably the
306:03 - most tedious logic here would be these two
lines, right? Really try to understand how
306:09 - like these two lines translate into the logic
we did in our drawing. So let's break down
306:14 - these lines again, right? line 11 is going
to take all of the combinations in my current
306:21 - position in my drawing that was like my yellow
box. And it's going to add our current word
306:26 - to each of those combinations. And then we're
going to take each of those new arrays and
306:31 - add them to the list add our further position,
right being sure not to overwrite, we already
306:38 - spoke about the complexity of this one, it's
definitely going to be exponential, probably
306:41 - a little more than exponential. Right? If
you imagine all the work we have to do using
306:46 - these maps and like spreading, we have to
actually construct our result array, which
306:52 - is going to contain an exponential number
of things. Right? So when I look at this last
306:57 - example, let's say that I made it a little
longer, right? So let's say actually pull
307:02 - up the size of that input. It's going to be
very, very slow might even crash, but let's
307:08 - just do it. So let's say I had a bunch of
A's here, just for fun. So if we try this
307:14 - example. Yeah, it looks like our program still
crashes, right? This is going to return a
307:21 - really, really a massive array probably can't
even fit into memory over here, right? So
307:27 - we'll get like a stack size exceeded, even
though this isn't even recursive, right? Just
307:31 - calling functions way too much over here.
So no matter what we do, we really expect
307:37 - this problem to sort of demand an exponential
solution. With that, let's head back into
307:42 - the drawing board where you can wrap up this
course.
307:45 - Alright, programmers, by now we solve many
different dynamic programming problems together.
307:48 - And I want to leave us with some final advice.
So whenever you're starting to attack any
307:52 - dynamic programming problem, start by really
taking a moment and noticing any overlapping
307:57 - subproblems. And then from there really focus
on like the input to the problem, in particular
308:03 - its type. And from there, you shouldn't be
able to recognize what is the trivial smallest
308:07 - input? So in our string problems, usually
that means the empty string in our array problems,
308:12 - it's the empty array, or in our number problems,
it's usually a number like zero or one, right?
308:17 - Is there some input wherever you don't really
have to do any extra work to know the answer?
308:21 - The answer just sort of is what it is. Once
you recognize this trivial scenario, or the
308:26 - base case, really, then you'll want to realize
how you can relate this base case toward your
308:32 - larger inputs. And then you have two options,
right? You can either think recursively, and
308:36 - use memorization, or you can think more iteratively
and build a table using our tabulation formula.
308:42 - I think as you practice dynamic programming
problems, I would actually always solve problems
308:47 - in two ways, one using memoization and one
using tabulation. And of course, from that
308:52 - point on, it's okay, if you have like a favorite
strategy. For me, personally, that's memorization.
308:57 - But that being said, it really helps to have
options when you're in an interview. And once
309:01 - you've made that decision on, you know which
route you're going to take, definitely, you
309:04 - know, slow it down and draw a strategy first.
This is I think, the most important thing
309:09 - about just data structures and algorithms
in general. Usually, when we draw our pseudocode,
309:14 - or draw our process on the whiteboard, we
can recognize all of these edge scenarios.
309:19 - And it's much harder to do when we just write
like the code out of the gate. And so I promise
309:24 - if you slow it down and take a moment to draw
a visual, you're gonna find your work a lot
309:29 - more productive, as well as more intuitive
when you explain it to someone else. And of
309:33 - course, through all of that, you're gonna
have a lot more fun, you know, dealing with
309:36 - these quite hard topics. Alright, programmers,
that's all I got for this course. Hopefully,
309:41 - you had fun, you know, learning this new topic.
I definitely had fun teaching it to all of
309:44 - you. So what you want to do now is head down
to the links in description and head to coder
309:49 - byte comm where you can actually practice
this new topic. Thanks for watching, and I'll
309:54 - see you in the next one.