00:02 - hey guys and welcome back to a new
00:04 - tutorial series so essentially this is
00:06 - online game development with python
00:08 - which means we're going to be using
00:09 - sockets and networking to connect what's
00:11 - known as a client and a server or
00:13 - multiple clients to a server where they
00:15 - can send and share information and
00:17 - therefore we can create an online game
00:20 - so we're going to start off with just
00:21 - the absolute basics and just get shapes
00:23 - for example like if i move a shape on my
00:25 - computer
00:27 - it moves a shape on your computer like
00:28 - if you're the other client and then
00:30 - we'll start getting into some more
00:31 - advanced stuff where we create a
00:32 - legitimate game and start sending mass
00:35 - amounts of information to the server and
00:37 - back to the client so we'll start uh
00:39 - really simply by just getting everything
00:40 - working on our local network and then
00:42 - once it's working on our local network
00:43 - we'll deploy that to an external server
00:46 - which will allow us to play from
00:47 - anywhere in the world not just against
00:49 - people on our local network
00:54 - okay so what i'm showing you right now
00:56 - is actually an online game that i
00:58 - created with python pie game and
01:00 - networking and this is similar to
01:01 - something we're going to make obviously
01:02 - not as advanced
01:04 - but it works on the same principles so
01:06 - essentially i have what is known as two
01:08 - clients now if you don't know the way
01:10 - that any online game works is we have
01:13 - multiple clients connecting to one main
01:16 - location which is known as a server now
01:18 - right here on my screen we have two
01:20 - clients so this client on the left that
01:21 - my mouse is kind of going over that has
01:23 - this red highlight like where the rook
01:25 - is or where i just am about to move this
01:27 - knight is client one and then this black
01:29 - one over here so like ui block uh where
01:32 - i just moved this pawn is client two now
01:35 - you can see in the background i have
01:36 - this command line thing going and it's
01:38 - sending and receiving information and
01:40 - this is essentially how a online game
01:42 - works and you might see uh whenever you
01:44 - guys play an online game it says waiting
01:46 - for server or connecting to server and
01:48 - that's because it's doing exactly that
01:50 - it's waiting to get a connection to the
01:51 - server and then grab information from
01:53 - that so that's the way that we're gonna
01:56 - be doing things is using a client and
01:58 - server now i'm not gonna be using any
01:59 - frameworks that are pre-created like uh
02:02 - i know there's like twisted and some
02:03 - other frameworks for python the only
02:05 - module we're gonna be using that's
02:06 - external as pie game and that's just to
02:08 - create some very basic graphics
02:10 - okay so let's close this i just want to
02:12 - give you guys an example of what an
02:13 - online game looks like and you can see
02:15 - when i was moving something on one
02:16 - client it would move it on the other
02:18 - so let's close that up
02:20 - and let's actually get started with the
02:21 - tutorial
02:22 - no it did not mean to open that
02:24 - so i'm gonna be working with pycharm uh
02:27 - for this tutorial now if you don't know
02:28 - what pycharm is it's an ide
02:31 - uh to download it all you have to do is
02:33 - just go to the internet
02:34 - type pycharm
02:36 - and you can go here and click download
02:40 - whenever it loads up
02:42 - now if you guys don't want to use
02:43 - pycharm that's absolutely fine you can
02:45 - do everything using the standard editor
02:47 - like idl you could use
02:49 - you adam use whatever you want
02:50 - but if you want to follow exactly with
02:52 - the tutorial i'm going to be using
02:53 - pycharm
02:54 - now the next thing we're going to need
02:56 - um
02:57 - other than ide i guess you don't need
02:58 - pycharm is we're going to have to
03:00 - install pygame
03:01 - now for 90 of you the way that you're
03:03 - going to be able to install pi game just
03:05 - by going to command prompt
03:07 - loading it up like this and just typing
03:09 - pip
03:10 - install
03:11 - pi game and then hitting enter
03:14 - now
03:15 - if this doesn't work for you i'll put a
03:17 - card in the top right hand corner of the
03:18 - screen right now which tells you where
03:20 - you can go to install pi game and i have
03:23 - a video explaining you exactly how to do
03:25 - this and if this command doesn't work
03:26 - for you you can follow that video and
03:27 - i'll explain to you how to do that so
03:29 - once we have pie game then we're ready
03:31 - to actually start writing a bit of code
03:33 - so while i launch up pycharm right here
03:35 - and create a new project
03:37 - let me just tell you about i don't know
03:39 - some of the things we'll be going
03:40 - through in this tutorial series so
03:42 - obviously we're going to be working on
03:43 - coding both a client and a server and
03:45 - i'm going to explain obviously exactly
03:47 - how those things work
03:49 - and how we can create them and then what
03:51 - we're going to be doing is we're going
03:52 - to be dealing with a bit of
03:53 - server like administration if you want
03:55 - to say that so actually
03:58 - deploying things to an external server
04:00 - um distilling in pen installing
04:02 - dependencies uh working with like a
04:04 - linux server to deploy our game to and
04:07 - that will be at the end of the series
04:08 - that we do that right now we're just
04:10 - gonna be working with what's known as
04:11 - localhost which means that we're going
04:13 - to be doing it on our own network so
04:15 - right now the games that we create are
04:16 - only going to work on our uh what do you
04:19 - call it against people that are on our
04:20 - wi-fi or on the same network as us and
04:23 - then later it'll work against anyone in
04:25 - the world that has that client
04:26 - downloaded okay so let's just create a
04:28 - new project here my new project i'm just
04:30 - going to say is tutorial i would say
04:33 - network tutorial 1 or something
04:37 - and just as a
04:39 - what do you call it here just letting
04:41 - you guys know i did actually mess up my
04:43 - thumb a little bit it's kind of swollen
04:45 - so if my typing is not the best that is
04:48 - actually my excuse for that so now that
04:50 - i've got a new project open i'm just
04:51 - going to create a new python file let's
04:52 - just call this tutorial one actually
04:55 - let's call this client okay
04:57 - and just save that as okay because
04:58 - that's all we're gonna be coding in this
05:00 - video is just a very basic client
05:02 - uh okay so now we've got client so what
05:05 - i'm gonna start off by doing is creating
05:06 - a configuration for my client and keep
05:08 - in mind if you guys are using something
05:09 - else you don't have to worry about what
05:11 - i'm doing with this pie chart specifics
05:13 - this is just the way you have to set up
05:14 - a project in uh pie chart
05:17 - so i'm just gonna set a client i'm gonna
05:19 - go to script path network game client
05:22 - okay
05:23 - apply okay
05:24 - now quick side note all the code that
05:26 - i'm about to write is available on my
05:27 - website techwithtim.net usually i have
05:30 - as well as that a text-based tutorial
05:32 - version i'm not sure if i'm going to be
05:33 - able to write the text-based tutorial
05:34 - while
05:36 - this first tutorial is out but you will
05:38 - see it on there at some point import
05:39 - tutorial import pi game
05:41 - uh but yeah all the code will be
05:43 - available in there in case you guys
05:44 - missed something or something's not
05:45 - working so we're going to start by
05:46 - importing pi game and make sure that
05:48 - that's working once that's working we're
05:50 - going to create a window so to do that
05:51 - we'll just say win equals pi game
05:54 - uh dot display
05:57 - dot update
05:59 - all right what am i saying pie game dot
06:00 - display dot
06:01 - set underscore cap set underscore mode
06:05 - wow a bit tired today guys and then in
06:07 - here we're just going to type width
06:09 - and height and then we're going to
06:11 - create these variables
06:12 - so we'll say width equals 500
06:16 - height equals 500 okay so there we go
06:19 - with height win and now we're just going
06:21 - to set up a few global variables that
06:22 - we're going to have to use after we
06:23 - create a caption so let's just say hi
06:25 - game
06:27 - dot display
06:28 - dot set underscore caption
06:31 - and then here we'll just give it a
06:32 - caption let's just say clients okay
06:36 - all right so now let's set up a global
06:39 - variable that we're going to use and
06:40 - what we're going to do for this global
06:41 - variable is it's going to hold
06:43 - the current like clients we're going to
06:44 - say like client
06:46 - number and we'll just start by making
06:49 - that zero but we're going to increment
06:51 - that based on like once we connect to
06:52 - the server which we'll do later okay so
06:54 - now that we've done that uh there's a
06:56 - few basic things this is what we always
06:57 - do for like a pie game project or
06:59 - whatnot just going to define
07:01 - redraw
07:02 - window okay and in here all we're going
07:04 - to do is just pi game
07:06 - dot display dot update like that
07:09 - and we'll also fill the display before
07:11 - we do that oops didn't mean to do that
07:14 - uh with win dot fill
07:16 - uh and we'll just pick a color in this
07:18 - case i want to do whites which is 255
07:20 - 255 255.
07:23 - okay now yeah i just realized this is
07:25 - actually gonna be a lot harder to type
07:26 - than i thought because my thumb so just
07:27 - excuse me guys if i'm making a few
07:29 - mistakes here
07:30 - okay so we got our redraw window now and
07:33 - what we can do next is we can um
07:36 - code our main loop so i'm going to say
07:38 - define main
07:39 - and then here i'm just going to create a
07:41 - game loop and this is going to run
07:42 - continuously while our program is going
07:44 - and it's just gonna be what's checking
07:46 - for collision checking for events can
07:48 - constantly asking the server for
07:49 - information and you guys will see how
07:50 - this works in later videos more so we're
07:52 - gonna say run equals true and here we'll
07:54 - say well run and we'll just set up some
07:57 - very basic things that we always do for
07:58 - pi games so for event in
08:01 - pie game dot
08:03 - event dot get okay and then all we're
08:06 - going to do is say if event dot type
08:08 - equals equals
08:10 - pie game dot quit with all capitals then
08:13 - we will simply do pie game dot quit like
08:16 - that i don't need a semicolon i guess we
08:18 - can say run equals false as well
08:23 - okay uh for events that looks good and
08:25 - then what else we'll do in here is we'll
08:27 - just call that redraw window function so
08:29 - redraw window like that
08:31 - now what i'm thinking we should do next
08:33 - is probably set up a class for our
08:36 - character okay now our character is
08:38 - going to be just the only object we're
08:39 - working with right now and it's just
08:41 - going to represent like a rectangle that
08:42 - moves like left down up right around our
08:45 - screen and i guess we'll do that all in
08:46 - this video moving that character around
08:48 - and then we'll connect it to uh
08:50 - the server in the next one so let's
08:52 - create a class and we'll do that up here
08:54 - and we'll say class player
08:56 - uh like that okay so i'll give it a knit
08:58 - function and if you guys don't know much
09:00 - about object oriented program and
09:01 - programming and you want to learn i do
09:03 - have a tutorial series on my channel um
09:05 - that i would recommend you go through if
09:06 - you don't understand a lot of the stuff
09:07 - that i'm doing right now okay so x y
09:10 - with heights will be what we get in here
09:12 - and this is just going to represent
09:14 - actually let's give it a color as well
09:15 - because that'll be good to have x y with
09:18 - height color and yeah this will just
09:20 - represent kind of our player and what
09:23 - variables they're going to have so we'll
09:25 - pass these values in when we create a
09:26 - new player so self dot y equals y this
09:29 - is very straightforward self.width
09:31 - equals width and self.height
09:35 - equals height and finally self.color
09:38 - equals color so these are just our
09:40 - initialization here uh this is what
09:42 - we're going to use when we're drawing
09:43 - the character when we're checking for a
09:44 - collision or stuff like that
09:46 - and what i'm also going to do to save us
09:48 - a bit of time in the future i'm going to
09:49 - say self.rect equals and then in here
09:52 - let's do this okay so x y
09:55 - width
09:56 - height like that okay and this will just
09:58 - make it a bit faster when we're trying
10:00 - to draw our character
10:01 - so the next thing we're going to need is
10:03 - define draw
10:04 - now in the draw method here we're going
10:06 - to take a window so we'll call that win
10:08 - and all we're going to do is just draw a
10:11 - rectangle that represents our character
10:13 - onto the screen
10:14 - and obviously be the appropriate color
10:16 - so to do that all we have to do is just
10:18 - say win
10:19 - dot
10:20 - oh no we don't have to do that we have
10:22 - to do pi game
10:24 - dot draw
10:25 - dot rect standing for rectangle we have
10:28 - to first give the window so we'll give
10:29 - win we need the color so we'll do
10:31 - self.color and then we need a rect which
10:33 - will be self.wrecked okay and that's
10:35 - actually all we need to do to draw the
10:37 - rectangle to the screen
10:39 - now we need one more method we're going
10:41 - to use and it's going to be called move
10:43 - and
10:44 - move actually i believe yeah we don't
10:46 - need to do anything else in there
10:48 - right now uh as a argument sorry
10:50 - so for move what this is gonna do is
10:52 - it's essentially just gonna check um
10:54 - what do you call it if they press like
10:56 - left key right key what not how can we
10:58 - move them around the screen so the way
10:59 - that we can do this really basically
11:01 - essentially is just do pie game
11:04 - dot
11:05 - uh what do you call it dot keys
11:07 - dog get underscore
11:09 - pressed i believe that's it it might be
11:11 - key
11:13 - might be keys we'll see we'll see which
11:14 - one works so this is essentially going
11:16 - to give us a list of all of the keys
11:18 - actually a dictionary of all the keys
11:20 - and essentially each key is going to
11:22 - have a value of either 0 or 1. now if 1
11:26 - is true that means we're currently
11:27 - pressing the key if zero is uh there
11:30 - then it means we're not pressing the key
11:32 - so the way that this is useful as
11:33 - opposed to doing what we could sometimes
11:35 - do which is just check for events in
11:36 - here is if you're pressing more than one
11:38 - key at once it'll allow you to move like
11:40 - diagonally or whatnot okay so what we
11:42 - can do in here now is we can just check
11:44 - if certain keys are pressed and then
11:46 - change the x and y values accordingly so
11:48 - we'll say if um what do you call it oh i
11:50 - guess we should probably put this in a
11:51 - variable let's just say keys equals pi
11:53 - game dot
11:54 - maybe i feel like it's key we're going
11:56 - to go key for right now pie game dot key
11:58 - don't get underscore so we'll say if
11:59 - keys and then pie game dot k underscore
12:03 - left standing for our left arrow key and
12:05 - that's all we need to do for that one
12:06 - and then we'll say if
12:09 - keys and then hi game dot k
12:13 - underscore
12:15 - is this should this be all capitals i
12:16 - think it should be okay underscore right
12:19 - and then the next one
12:22 - if keys
12:24 - pi game dot k underscore up
12:28 - and then our last one obviously is down
12:30 - and then we'll change our values
12:32 - accordingly inside of these if
12:33 - statements so pi game dot okay
12:35 - underscore down
12:37 - okay so left right up down so if we
12:40 - press the left arrow key obviously what
12:41 - we have to do is subtract from our x
12:43 - value so do that we'll just say self.x
12:45 - minus equals self.l now
12:48 - val is something we need to define so
12:50 - let's do that up here self.bell equals
12:52 - and let's do a value of like three for
12:55 - right now
12:56 - okay so if we're going right we need to
12:58 - add to our x so we'll do this very
13:00 - similar so self.x plus
13:02 - plus equals
13:04 - self.vel
13:07 - okay if i could type that correctly and
13:08 - then to go up we're going to subtract
13:10 - from our y value so self.y minus equals
13:13 - self.l
13:15 - and to go down we'll do self.y plus
13:17 - equals self.bell and that's the way the
13:20 - coordinate system works in pi game our
13:21 - coordinates actually at the top left
13:23 - hand of our player or our screen so if
13:25 - we want to go down we have to add to it
13:27 - and then left and right is the same in
13:28 - terms of subtracting and adding okay so
13:30 - that should successfully move our player
13:33 - we can add like a jump and stuff in here
13:35 - at another time but for right now that's
13:36 - all we need i'm trying to think of
13:38 - anything else that we could do right now
13:40 - um we should probably create a player
13:42 - object and draw that to the screen just
13:43 - to make sure everything's working
13:45 - so to do that let's create a player um
13:48 - should we do it up here let's do it
13:49 - right above our main loop here okay
13:51 - so we're just going to say
13:53 - or actually we'll do it inside the main
13:54 - loop this will work better
13:56 - we'll say uh p standing for player just
13:58 - equals player and then we'll give it
14:00 - some value using x y with height color
14:02 - so for x y we'll just start him at like
14:04 - 50 50.
14:06 - and then for our width let's just do 100
14:08 - by 100 so he's nice and big and we can
14:10 - see him and then we'll do a color of
14:11 - green
14:12 - so that would be
14:14 - red green blue like that so 255 for
14:18 - green
14:19 - and then what we're going to do actually
14:21 - is we're going to type
14:24 - in here insert in redraw window we're
14:25 - just going to pass p
14:27 - to our uh redraw window so we can draw
14:30 - him and before we do that we'll call p
14:32 - dot move and what this will do is move
14:34 - our character based on what keys we're
14:36 - pressing
14:37 - so inside redraw window let's add a
14:39 - player um
14:41 - what he called
14:43 - argument attribute whatever you want to
14:44 - call that um sorry parameter that's the
14:47 - correct name and then we'll just say
14:48 - player.draw like that and we'll pass win
14:52 - in here
14:53 - which probably should be passed in here
14:55 - as well because we do use win quite a
14:57 - bit so let's do p
14:59 - let's do win and then p
15:03 - okay so let's run this now and see if i
15:05 - made any mistakes i likely did
15:08 - process finished oh we're never calling
15:10 - the main function so let's call this
15:12 - main function from down here so we're
15:14 - actually executing that code that we
15:15 - wrote
15:16 - and there we go so now we have a little
15:18 - green square and you can see
15:21 - interesting it's not working for me to
15:22 - move this around
15:24 - so let's check this one more time p dot
15:28 - move what is move doing get pressed
15:31 - let's just add i want to add something
15:32 - here and make sure this is working so
15:34 - let's we're gonna say clock
15:35 - equals pi game
15:38 - dot time dot clock okay and then in here
15:42 - we're just gonna do clock
15:44 - dot tick
15:45 - uh and we'll do 60 fps i just want to
15:47 - see if this is working if not i do know
15:49 - how to fix this um okay so we're not
15:51 - able to actually move this
15:53 - oh i know why
15:55 - so very interesting we are not updating
15:57 - this rect but we are updating um
16:00 - what do you call it like up down left
16:02 - right so at the bottom here all we're
16:03 - going to do is just
16:04 - redefine our erect by doing
16:06 - self.x self.y
16:10 - self.width and self.height now i'll
16:13 - really quickly explain why this error
16:15 - was happening essentially we're defining
16:16 - rect up here based on the input
16:19 - parameters when we're creating our
16:20 - player so that means we're always just
16:22 - constantly drawing our rectangle in the
16:24 - same position because we're never
16:26 - updating this rect variable we're only
16:28 - updating like x y with height right so
16:30 - we just have to redefine a rect variable
16:32 - every single time that we're moving
16:33 - which is fine and we can do that so now
16:35 - let's see and we can move our green
16:37 - square around the screen i actually
16:39 - quite like the speed this movement um so
16:41 - yeah so essentially in the next video
16:43 - what we're going to be doing is i'm
16:44 - wrapping it up here is we'll add
16:47 - a little bit more to this client and
16:49 - then we'll start working with sockets so
16:51 - we can connect this up to a server and
16:53 - we'll start talking about all the
16:54 - networking aspecting then
16:58 - so in this tutorial we're going to be
17:00 - working on coding the server and then in
17:02 - the next video we're going to be
17:03 - connecting this client that we made in
17:05 - the last one to that server and then
17:07 - sending information to and from the
17:09 - server uh so let's get started and let's
17:11 - create a new file that is going to be
17:13 - our server file
17:15 - so i'll just call this one
17:17 - server.py
17:19 - and then in here we're just gonna have
17:20 - to import a few things and i'll talk
17:22 - about exactly what they're gonna do for
17:23 - us once we start using them so let's
17:25 - start by importing sockets
17:28 - or socket
17:29 - then we can import
17:31 - underscore thread
17:33 - and we'll also import os
17:38 - okay
17:39 - so actually not os sorry sys that's all
17:41 - we need for that so what we're going to
17:43 - be doing like i've talked about is we're
17:45 - going to be using sockets and threading
17:48 - to handle connections to our server and
17:50 - essentially what that means is we're
17:51 - going to set up a socket and it's going
17:53 - to allow for connections to come into
17:55 - our server on a certain port
17:57 - so we're going to start by just defining
18:00 - a server
18:01 - which is going to be a string and port
18:04 - which is going to be a number
18:06 - now for ports
18:08 - you guys probably know what
18:10 - ports are you might have heard them
18:12 - before for example like a common port
18:13 - you would use on
18:15 - uh or common port that is used like on
18:17 - your router would be port 80 and that is
18:19 - for http connections there's also a port
18:22 - like 443 there's there's tons of other
18:24 - ports that have
18:26 - distinct uses but there's also a ton of
18:29 - ports that don't have any uses and that
18:30 - are just left open for programs like
18:32 - this or for different things to be used
18:34 - for so what port i'm gonna use which is
18:36 - typically open um it depends on like
18:38 - what router you're using and your
18:40 - internet connection but typically a port
18:41 - that's open is five five five five um so
18:44 - we're gonna use this port to connect to
18:46 - and from and it's just a safe port to
18:48 - use as opposed to trying to use another
18:50 - number uh that we might not know if it's
18:52 - being used for something else or not
18:54 - okay so once we've done that we've
18:55 - created a server and created a port what
18:57 - we're going to do is we're going to set
18:58 - up what's known as a socket okay and
19:00 - we'll talk about exactly how this works
19:02 - in a second
19:03 - but we're just going to say s equals
19:04 - socket
19:06 - dot socket
19:07 - and then here we're going to type
19:08 - something that's probably going to mean
19:09 - nothing to you but i'll talk about what
19:11 - it means so we'll say socket equals af
19:13 - uh underscore inet okay and then socket
19:16 - dot sock stream like that all right now
19:20 - these are just the types of connection
19:22 - so since we're going to be connecting to
19:24 - a ipv4 address which again we're going
19:27 - to keep talking about all this stuff as
19:28 - we go through in case you guys are
19:29 - unfamiliar with networks uh this is the
19:31 - type we're going to have to use and
19:32 - sockstream just i believe represents um
19:35 - like how this server string comes in i
19:38 - could be wrong on that but um this is
19:40 - the type we're gonna use and for any
19:42 - kind of applications like this this will
19:43 - be what you use for your
19:45 - socket okay so we're just initializing
19:47 - that and now the next thing to do is to
19:49 - bind our server and our port to the
19:51 - socket so to do this we need to do a try
19:53 - and accept and the reason we do this is
19:56 - because like i talked about we don't
19:57 - know if this is actually going to work
19:59 - initially doing it there could be in
20:01 - some instance this port is already being
20:03 - used for something and if that's
20:04 - happening that means that this is going
20:06 - to fail so we need to try and accept
20:08 - this so it will accept uh
20:10 - what do you call it
20:12 - uh error as e so we say socket dot
20:16 - error as e and we'll just print that out
20:19 - to the screen just so we know why we're
20:20 - not working there uh otherwise what
20:23 - we'll do is we'll say s dot bind and
20:25 - then here we're going to put
20:27 - server comma port okay so we'll bind to
20:30 - whatever i p address we'll put in here
20:33 - to this given port okay so i hope
20:35 - everything's making sense so far
20:37 - essentially what we're doing when we do
20:38 - sockets is we're setting up
20:41 - a connection or we're using a port on
20:43 - our server on our network it's going to
20:46 - look for certain connections
20:48 - and then we'll be doing this on the
20:50 - client side as well will be binding or
20:52 - not i don't know if it'd be binding
20:53 - we'll just be connecting to a certain
20:55 - server and a port
20:57 - and then since we're connecting to that
20:58 - this server script that we're going to
21:00 - have running we'll see that connection
21:02 - and handle it in some way
21:03 - okay so now that we've done that i'm
21:05 - trying to think what else we have to do
21:06 - okay so what we're going to start by
21:07 - doing is we're going to start listening
21:09 - for connections
21:10 - so we're going to do s dot listen
21:12 - now s dot listen essentially just opens
21:14 - up the port so now we can start
21:16 - connecting to it and having multiple
21:18 - clients connecting and whatnot
21:20 - so in here this actually takes one
21:22 - argument now it's optional and if you
21:24 - leave it blank it means it'll allow for
21:27 - unlimited connections to happen now
21:30 - depending on what kind of program you're
21:31 - writing
21:32 - is what you're going to do for this now
21:34 - for me i only want two people to be able
21:36 - to connect to my uh what do you call it
21:40 - yeah to my server so we're just gonna do
21:41 - s dot listen to now this might actually
21:43 - be one because it might be like zero one
21:45 - but i think two may be the correct thing
21:47 - so do s dot listen for now uh and then
21:49 - what we're gonna do is we're gonna print
21:51 - after we listen uh we'll just say
21:53 - waiting
21:54 - for uh connection
21:56 - and we'll say
21:57 - server started or something like that
21:59 - because once we get to this point
22:01 - we are running the server and everything
22:03 - actually is working like we're listening
22:06 - for connection we're ready to go
22:08 - okay so the next thing we're going to do
22:09 - is we're going to define something known
22:12 - as a threaded function okay and we'll
22:14 - i'll talk about again what this means um
22:17 - but let's just do threaded uh
22:20 - threaded underscore client for now and
22:22 - i'm just putting you don't actually have
22:23 - to name it this you can name it whatever
22:24 - you want i'm just putting threaded here
22:26 - just so we know this is threaded and
22:28 - then it's going to take one argument
22:29 - which is just going to be conn which
22:30 - stands for connection and let's just
22:32 - pass in there for right now
22:34 - so the way that threading works
22:37 - actually let's
22:38 - let's do the threading and then i'll
22:40 - talk about how it works because it'll
22:40 - probably make a bit more sense so let's
22:42 - do a while true down here okay so once
22:44 - we set up
22:46 - our server our port we bind it doing
22:48 - here we're starting to listen waiting
22:50 - for connection starting the server then
22:52 - what we're going to do is we'll be get
22:53 - put into this while loop and what this
22:55 - while loop will do is we'll continuously
22:56 - look for connections okay because right
22:59 - here we're just listening uh like once
23:00 - right to see if anything's on that
23:02 - server report but down here we want to
23:04 - continually try to grab connection let's
23:06 - see if something's connected and if it
23:08 - does then we want to print something to
23:10 - the screen or we want to send
23:11 - information or we want to start a new
23:12 - thread which we'll talk about in a
23:14 - second so in here what we're going to do
23:15 - is we're going to say connection
23:17 - uh which co n and then adr
23:20 - equals and then s dot and then we'll say
23:22 - accept
23:24 - and what s dot accept is going to do is
23:26 - it's going to well accept any incoming
23:28 - connections and then it's going to store
23:30 - the connection and the address and the
23:33 - connection is by the way an object
23:34 - representing like what's connected the
23:36 - address is going to be an ip address in
23:38 - these variables okay
23:40 - so if we get a connection what we'll do
23:43 - is we'll say print
23:47 - connected to
23:48 - okay
23:49 - and then atr and this is just going to
23:51 - show us what ip address is actually
23:53 - connecting
23:54 - so we can have a look at that and then
23:55 - what we're going to do is we're going to
23:56 - do start underscore new underscore
23:59 - thread
24:00 - and then in here
24:01 - we're going to do
24:03 - uh what was that name of the function
24:04 - that we had
24:06 - was threaded client
24:09 - okay and i believe we do comma and then
24:13 - in brackets here we do con like that
24:16 - okay so start new thread
24:18 - is there a reason that's not working um
24:20 - give me a sec guys i want to see why oh
24:22 - that's why so up here instead of saying
24:25 - import thread we're going to say from
24:27 - underscore thread
24:29 - import star
24:31 - okay and that's just going to make it so
24:32 - we can just do this start new thread
24:33 - thing and you know what i don't know if
24:34 - we're going to need this sys but let's
24:36 - just leave it there for now
24:38 - okay so let's talk about what threading
24:39 - is going to do
24:40 - so essentially the way that you guys are
24:42 - used to programs working i'm assuming
24:44 - unless
24:45 - you have some familiarity with threading
24:47 - is that say we're in this while loop
24:49 - right and we were to call the function
24:51 - threaded client
24:52 - well before we continue going with this
24:54 - while loop we would have to wait until
24:56 - this function was done running in other
24:58 - words we return back from this function
25:00 - some value or for example like he does
25:03 - like x equals five we would have to wait
25:06 - for this x equals five to execute and
25:08 - then it would come back in this while
25:09 - loop and keep going
25:11 - now we don't want that to happen because
25:13 - we're going to be having multiple
25:15 - connections going at once so what we
25:17 - want to do is we want to
25:19 - start what's called a thread and a
25:20 - thread is just another process that's
25:22 - running in the background so that just
25:24 - means when we do start new thread and we
25:26 - do threaded client
25:27 - it's going to run this function but it's
25:30 - not going to need this function to
25:31 - finish executing before it continues the
25:33 - while loop so this is going to be
25:35 - running in the background as like
25:37 - process 2 while process 1 is still
25:40 - running and still going so that means
25:42 - say we connect to 100 different things
25:44 - we're going to have a hundred different
25:46 - functions running so 100 different
25:47 - threaded clients
25:49 - on the stack or like keep going and then
25:51 - what we're going to have is this while
25:52 - loop still continuing to go what did i
25:54 - just do i'm still continuing to run to
25:57 - look for another possible connection you
25:59 - guys will see
26:00 - more how this works but essentially just
26:02 - means this will run in the background
26:04 - and we don't have to wait for it to
26:05 - finish executing before we can accept
26:08 - another connection that's the basic kind
26:10 - of way to that works
26:12 - so now let's start working with threaded
26:14 - client and then we will uh test the
26:16 - server out and see if it's working and
26:17 - then obviously in the next video we're
26:19 - going to connect to it and do all the
26:20 - connection stuff okay
26:21 - so in here uh threaded client
26:24 - so what should happen
26:26 - when we connect to uh a client well
26:28 - we're gonna have to do a while open here
26:30 - so we're gonna say wow true
26:33 - because we want this to continually run
26:35 - while our client is still connected okay
26:38 - now what we're also going to do is we're
26:40 - just going to say reply equals blank
26:42 - like that and i'm just copying from my
26:44 - other screen because
26:45 - this one is a bit finicky i don't want
26:46 - to mess it up we're going to put a try
26:48 - in here and what we're going to say is
26:50 - we're going to try to receive some kind
26:51 - of data from our
26:54 - connection okay from whoever is
26:55 - connected we want to receive some kind
26:56 - of data so what we'll do is we'll say i
26:59 - believe it's
27:00 - uh s con dot receive
27:04 - that might be right yeah i think that's
27:05 - right and then here we're going to put
27:07 - the amount of bits okay
27:08 - now if you guys know anything about
27:10 - computing you know like how what bits
27:12 - represents but essentially this is the
27:14 - amount of information we're trying to
27:16 - receive
27:17 - now if you're getting an error when say
27:20 - you'd like do this and you connect up
27:22 - and you get some area that says
27:24 - um what do you call it
27:26 - like object was truance or like uh you
27:29 - you're getting any errors just increase
27:30 - this size okay and you can just do that
27:32 - by like putting this like times eight or
27:34 - something just note that the larger this
27:36 - size is
27:38 - the longer it's going to take to receive
27:40 - information and that's obviously because
27:41 - the more information you're getting the
27:43 - longer it takes to send that over the
27:44 - server so 2048 bits is not a lot it
27:47 - doesn't take very long it happens almost
27:49 - instantly but if you bump this number up
27:51 - to a ton
27:52 - then it will take uh longer to do that
27:54 - okay
27:55 - so data and we're gonna say reply equals
27:58 - and then we're gonna say data dot i
28:00 - think it's actually string string.decode
28:04 - let's see this oh data.decode because
28:06 - it'll be in that that kind of object for
28:08 - that data.decode and then here we're
28:10 - going to do utf
28:12 - comma 8. now the reason we have to do
28:14 - this is because whenever we're sending
28:16 - information over a like client server
28:18 - system we have to encode the information
28:20 - and you'll see that in the next step
28:22 - that we're going to encode information
28:23 - before we send it back to the client but
28:25 - that means that we're receiving
28:27 - encoded information so to actually be
28:30 - able to read it like as a human readable
28:31 - string we need to decode it first
28:34 - so it's really easy to do that we just
28:35 - do decode and we're just giving the
28:36 - format which is utf-8 okay so reply
28:39 - equals that and then we're going to say
28:40 - it's going to say if not data
28:43 - we're going to print
28:46 - disconnected okay and then we're going
28:48 - to break
28:49 - and this just means if we try to get
28:52 - some information from the uh what do you
28:55 - call it the client but we're not getting
28:57 - anything we're going to disconnect and
28:59 - we're going to break and that likely
29:00 - means that we've well disconnected from
29:03 - the client or the client's left or
29:04 - something like that so instead of
29:05 - continuing to run this while loop and
29:07 - trying to get information from a client
29:09 - that's disconnected we're going to break
29:11 - this is just kind of a fail-safe to make
29:12 - sure we don't get into any infinite
29:14 - loops and it's also going to show us
29:16 - if we're running into any issues with
29:18 - like receiving the data and decoding it
29:20 - which we'll talk about later okay so
29:22 - otherwise so if we are getting
29:23 - information all we're going to do is
29:26 - we're going to print uh received
29:29 - is that how you spell received maybe uh
29:31 - and then we're going to put
29:33 - what do you call it
29:34 - reply okay
29:36 - i didn't mean to do that
29:38 - let me see if i'm spelling this right
29:39 - i'm not okay received reply so this just
29:41 - means we received from the client uh
29:43 - this reply let's print it to the screen
29:44 - see what it looks like and then we're
29:46 - gonna print
29:48 - sending
29:50 - uh colon
29:52 - and we'll just print reply okay and then
29:54 - we'll talk about this again in a second
29:56 - why does this keep happening okay reply
29:58 - next now after this uh if not data
30:02 - breakout what we'll do down here is
30:03 - we're going to say con dot send all
30:06 - and we're going to send
30:08 - str dot encode
30:11 - reply
30:12 - now again remember that since we're
30:14 - sending information over the server we
30:16 - have to encode our information so all
30:18 - this is going to do is just encode our
30:20 - string reply into a bytes object so that
30:23 - means when we read it in from the client
30:24 - side again we'll have to decode that
30:26 - information
30:27 - it's kind of annoying but i mean it's a
30:29 - security thing right so now we're just
30:31 - going to accept uh i guess
30:34 - what kind of error would it even be i
30:35 - don't even know if there's gonna be any
30:36 - errors if we run into anything let's
30:38 - just break uh just to make sure that
30:39 - we're not you know getting in that
30:40 - infinite loop or we're not gonna
30:43 - ruin the program by doing that
30:45 - okay so this is actually about it for
30:47 - our server uh let's see how much time
30:49 - we're at 13 minutes okay so now what we
30:51 - need to do is figure out what the server
30:52 - number is and then we can actually test
30:54 - it and see if this is working
30:56 - uh so what we're going to do now is
30:58 - we're going to find the server number
30:59 - now to do this we're going to be doing
31:01 - this over uh localhost okay that means
31:03 - that our we're only gonna be able to
31:05 - connect over our local network
31:07 - meaning that like anything on our wi-fi
31:10 - network um that can see each other
31:12 - that'll work fine but as soon as we go
31:14 - outside that network it won't work so
31:16 - we're gonna be using what's known as
31:18 - local ip addresses so to find the local
31:20 - ip address of the machine you're
31:22 - currently on you're going to go to
31:22 - command prompt in the bottom left
31:25 - and then you're just going to type ip
31:27 - config okay
31:29 - now
31:30 - some of you guys are probably freaking
31:31 - out because you can see my ip address
31:32 - right now this is a local ip address and
31:35 - that means that it is locally assigned
31:38 - to my network no one outside of my
31:40 - network can see this ip address or
31:42 - companion or can ddos it or anything
31:44 - like that okay so it's perfectly fine if
31:45 - you guys see this address or if other
31:46 - people know what this local address is
31:48 - okay just as a note
31:51 - so what we're going to do is we're going
31:52 - to take this ipv4 address so just copy
31:54 - that and we're going to paste that
31:56 - inside of the string here okay so
31:58 - 10.11.250
32:00 - is mine now yours likely is like
32:04 - 192.168.something okay
32:06 - but since i'm on like a massive network
32:08 - usually they use 10.10 like as the
32:10 - default gateway which is what they're
32:11 - using so my p address starts with a 10
32:14 - yours likely starts with 192.168.1
32:18 - or dot like 5 or something like that and
32:20 - then the rest of it okay
32:21 - so that's the address we're going to use
32:23 - and this is going to be our server
32:24 - address so whatever machine that you're
32:27 - going to be running the server script on
32:29 - that's the address you want so say you
32:30 - want to run this server on your laptop
32:32 - and you want to run clients on like your
32:34 - pc
32:35 - and your mac or something like that then
32:37 - you want to make sure you get the ip
32:39 - address from your laptop and you're
32:41 - putting it in that script okay and we'll
32:42 - talk about more of this in the next
32:44 - video when we actually connect to it
32:46 - okay so now that we've done this i
32:47 - probably made a mistake but let's
32:48 - actually just create a configuration
32:50 - quickly for server uh and run this and
32:52 - just see if we're getting any errors as
32:54 - of now now it is worth noting that we're
32:57 - not going to be able to connect anything
32:58 - yet um
33:00 - so there's not really going to be much
33:01 - we can see or really do
33:03 - but for now let's just test this out so
33:06 - let's have server let's run this and you
33:08 - can see he's waiting for a connection
33:09 - server started so that's actually good
33:11 - if you're getting this string of text
33:14 - everything is currently working uh in
33:16 - the next video we'll probably have to
33:17 - debug a little bit once we start
33:19 - connecting to this but for now that is
33:20 - the main server script now i'll briefly
33:23 - just talk about before i end this video
33:25 - how it's going to work in terms of
33:26 - running the server script and running
33:28 - the client script
33:29 - the server script always has to be
33:31 - running okay so whenever you're trying
33:32 - to connect you have to have first run
33:34 - the server script and then you can run
33:36 - multiple client scripts from wherever on
33:39 - the network you want now the server
33:41 - script has to be running on the machine
33:43 - that the ip address is like this little
33:45 - string here okay it has to be running on
33:46 - that machine
33:48 - and you can run a client script on the
33:51 - same machine that the server script's
33:53 - running and you can run multiple client
33:54 - scripts on the same machine so like for
33:56 - example what i'm going to do to test
33:57 - this in the next video is i'm going to
33:59 - run the server and then i'm going to run
34:01 - two clients on uh this machine and we'll
34:03 - see that it like is moving back and
34:05 - forth for them
34:08 - so what we're going to be doing in this
34:10 - video is we're going to be coding the uh
34:12 - kind of client side of this so
34:13 - connecting to the server i know we
34:16 - already coded a client but we're going
34:18 - to code like the network aspect of the
34:20 - client so that it can connect to the
34:21 - server it's not as much code it's a bit
34:24 - more straightforward and then we're just
34:25 - gonna test out sending very basic
34:27 - information to the server and hopefully
34:30 - getting some back see if that's working
34:32 - okay and then in the next video we're
34:33 - going to be connecting this so like the
34:35 - little user interface we created with
34:37 - moving that block around in the first
34:38 - video we're going to be connecting that
34:40 - um so that we can have multiple clients
34:43 - running and we can see like different
34:44 - blocks moving on each screen okay so
34:46 - that will involve a bit more work um
34:48 - hopefully by video five we'll have like
34:50 - a fully working kind of game that's
34:52 - working over the network okay that's the
34:54 - goal so within this video i just want to
34:56 - start by saying on this server class
34:58 - here or sorry server file i did actually
35:00 - forget two lines of code in the last
35:01 - video so after this accept break in
35:04 - threaded client just need to add this
35:06 - print loss connection and then
35:07 - connection.close all this is doing is
35:09 - once we break out of this threaded
35:11 - client we're just letting the we're just
35:13 - gonna print this to the console so we
35:14 - can see what it looks like and then
35:16 - we're going to close that connection um
35:18 - so that we can possibly reopen it in the
35:20 - future okay
35:21 - really straightforward that's all you
35:22 - got to add so just make sure you add
35:23 - that before moving on okay so next what
35:26 - we're going to do is we're going to
35:27 - create a new file
35:28 - and i'm going to call this network okay
35:30 - now you don't have to put what i'm going
35:32 - to in a new file it's just a lot easier
35:34 - so that's why i'm going to do that so
35:35 - let's do network and in here we're going
35:37 - to import socket now what i'm going to
35:39 - do is i'm just going to code a class
35:40 - that is going to be responsible for
35:42 - connecting to our server this just makes
35:44 - it like so i can reuse this class in the
35:46 - future and you guys could reuse this
35:47 - class in the future
35:49 - and it's just a bit cleaner and nicer
35:50 - and that's why i like to do things
35:52 - so i'm going to say class network
35:54 - again call this whatever you want and in
35:56 - here we're just going to set an
35:57 - initialization function uh we'll take
36:00 - actually is network do we need anything
36:02 - in network uh no i think we'll just
36:04 - leave like that so we're going to say
36:05 - self.client equals
36:08 - socket dot socket it's going to be the
36:10 - exact same arguments as last time so
36:12 - let's say socket.ifnet
36:15 - i think is that what it is if underscore
36:17 - net uh af underscore inet
36:20 - okay and then we'll do
36:22 - socket dot sock stream like that okay
36:26 - now we're gonna define the server and
36:27 - the port again so self.server equals uh
36:31 - self.port
36:32 - equals five five five five now for the
36:35 - server this again this number has to be
36:37 - the same as the one you used in the
36:39 - server uh what do you call it the server
36:41 - file here so
36:43 - no matter what like no matter where you
36:45 - actually are um like what client you're
36:47 - using this number is gonna stay the same
36:49 - because this is the server you're
36:50 - connecting to it's not the client's
36:52 - address we don't actually have to define
36:54 - the client's address anywhere it'll
36:55 - automatically get that for us
36:57 - okay so what we're going to do now
36:59 - we have client server port
37:02 - we need to do this self.adddr
37:05 - equals and then we're going to say
37:07 - server so
37:08 - self.server
37:11 - and then self.port in here okay and then
37:15 - self dot
37:17 - what do you call it self.id is going to
37:19 - be equal to
37:21 - self.connect okay
37:23 - uh now
37:24 - you guys actually let's just do
37:26 - self.connect for right now and we'll
37:27 - talk about why i was going to add this
37:28 - id later once we add that functionality
37:31 - to the server okay essentially i wanted
37:33 - to have an id that was returned here or
37:35 - like that was stored in this network
37:37 - object just because we are gonna have to
37:39 - like be sending an id to each of our
37:41 - clients so they know if they're like
37:42 - player one or player two but we'll do
37:44 - that later um because we don't really we
37:46 - can't really do that yet
37:48 - okay so we've called this connect method
37:49 - so we need to write that now so let's
37:51 - say define connect
37:53 - okay and in here i believe we should
37:55 - probably be given actually it's probably
37:58 - fine just use self right now and what we
37:59 - can do is use
38:01 - self.client.connect okay and then here
38:03 - we do self.addr
38:06 - now we're going to throw this in a try
38:08 - uh and accept just in case you know this
38:10 - isn't working so we'll say try say
38:13 - accept uh and this is gonna do socket
38:15 - error um
38:17 - let's say accept and we'll just pass
38:19 - right there okay just in case this
38:21 - doesn't work so we'll try this we'll try
38:23 - to connect accept pass
38:25 - now once we actually connect what we're
38:28 - going to do is we're going to return
38:31 - i'm just looking at my other screen
38:32 - right now self.client.receive
38:34 - and then we'll do 2048
38:37 - dot decode
38:39 - okay so what this is going to do
38:41 - i'll talk about this because it might be
38:42 - a little bit confusing is when we
38:44 - connect
38:45 - we want to actually send some kind of
38:47 - information immediately back to the
38:49 - object that connected to us so like for
38:51 - example it's going to ah i didn't mean
38:52 - to close that
38:54 - let's go into server here
38:55 - and you can see when we initially
38:57 - connect
38:59 - we're not sending any information until
39:01 - we receive something now that's fine but
39:04 - when we connect
39:06 - we should really send some kind of like
39:08 - validation token or like id back to our
39:12 - network object or back to our client so
39:14 - what i'm going to do in here i'm going
39:15 - to say con
39:16 - dot send okay
39:18 - and then in here what we're going to
39:20 - type is
39:22 - let's see what should we really type
39:23 - here um
39:25 - str dot in code and then here we'll just
39:28 - say
39:30 - connected like that okay uh just so we
39:32 - know that we did indeed connect
39:34 - so that means if we set this equal to a
39:36 - value so self dot i don't know
39:39 - let's say id equals self.connect
39:42 - what'll happen is when we connect we'll
39:44 - return that string connected
39:48 - so this will get connected and since
39:49 - it's encoded we need to decode it
39:51 - obviously
39:52 - so if we want to print actually in here
39:55 - self.id it should say like connected
39:57 - okay
39:58 - let's see if that works
40:00 - okay so now that we actually have that
40:03 - um
40:04 - let's see if we can connect to the
40:06 - server and then we'll deal with sending
40:08 - information from the client to the
40:09 - server as opposed to just getting it
40:11 - from the server okay i know it's a bit
40:12 - confusing right now i'm just trying to
40:13 - figure out the best way to do this um so
40:16 - let's try this okay so we're gonna say n
40:17 - equals network we'll just type this at
40:20 - the bottom of the script uh we won't do
40:22 - this after we'll delete this just for
40:23 - testing purposes and then we're just
40:25 - going to say
40:26 - actually that's probably all we need to
40:27 - do because it'll just print our id
40:30 - okay so let's create a configuration for
40:32 - network
40:33 - so new configuration
40:38 - type network in here and then select
40:40 - that path
40:42 - and then let's test if this is working
40:44 - so remember what i said when we're going
40:46 - to connect right
40:47 - to our server what we have to do is
40:49 - first run that server script so let's
40:51 - run the server script here waiting for
40:53 - connection server started okay let's run
40:54 - this network script now
40:56 - uh invalid argument was supplied s dot
40:58 - listen to
41:01 - okay so i had a quick look here i
41:03 - realized the mistake was i was actually
41:04 - running this server two times so
41:06 - obviously that's not gonna work for us
41:07 - so we can put two back in this listen
41:09 - i'm not sure if you guys we'll see if i
41:11 - left that in the video or not uh but
41:13 - let's go to network and we also need to
41:15 - change this to af
41:17 - instead of if i don't know why i typed
41:19 - if i literally said af when i was typing
41:21 - it but that's fine uh and we have server
41:23 - i'm actually running it right now so
41:25 - make sure you guys run that and then
41:26 - let's run network and see if this works
41:27 - okay sweet so i know it doesn't seem
41:30 - like much but you can check here if we
41:32 - go to server
41:33 - it says connected to
41:35 - and then gives us that address
41:36 - and it's also printing out some other
41:38 - thing that i honestly don't know what
41:39 - that means and then saying disconnected
41:41 - and lost connection
41:43 - sweet that's actually really good
41:45 - and that means that we're everything is
41:47 - working and you can also see that we
41:49 - have connected being printed here
41:51 - so that means when we connect to the
41:53 - server we're actually getting the value
41:54 - that it's sending so
41:56 - we're getting this uh connected
41:58 - and we're printing it out uh decoding it
42:00 - all fine so that's really awesome so now
42:02 - the only next step is to actually send
42:04 - information to the server and keep like
42:06 - a loop going like sending receiving
42:07 - setting receiving setting receiving now
42:09 - let's actually just test um
42:11 - if i run this again
42:13 - uh you can see again obviously it's
42:15 - working again so this is the server just
42:16 - continually is running i don't actually
42:18 - have to stop this unless i want to make
42:20 - modifications to it so let's just keep
42:22 - that running for now
42:24 - and let's add something to our network
42:26 - class
42:27 - so in our network class we're going to
42:28 - define a method that's going to be sent
42:30 - now this method is going to be very
42:31 - useful later on because it's going to
42:33 - save us a lot of time so in sand we're
42:35 - just going to take a
42:37 - string which is going to be data okay
42:39 - and all we're going to do in here is
42:40 - we're going to try to
42:43 - dot client
42:44 - dot send and i'm gonna say data
42:47 - str actually dot encode
42:50 - data
42:51 - and then we're gonna get a reply from
42:52 - that server so we're gonna say return so
42:54 - exact same thing that we're doing here
42:57 - client i receive
42:59 - uh 2048.2 code and we'll accept
43:02 - and i believe this is a socket error
43:04 - yeah it is socket dot
43:05 - error as e
43:07 - and just print e
43:08 - so if we get into some error where you
43:10 - know either we're sending or we're
43:12 - receiving it's not working let's just
43:14 - print that arrow up to the screen so we
43:15 - have a look at what that really means so
43:18 - now let's do a test
43:20 - and try to send information to the
43:22 - server and then get something back okay
43:24 - now the information that we're getting
43:25 - back
43:27 - should just be the same information
43:28 - because that's what we have in server
43:30 - we're just going to send exactly what we
43:32 - got right back right so um it doesn't
43:35 - make sense right now to do that but
43:36 - we'll talk about like what we can what
43:38 - valid information we can send how to
43:40 - send receive information in the next
43:41 - video when we connect up the client uh
43:43 - to
43:44 - the thing okay so what we're going to do
43:46 - is we're going to say n dot send and
43:48 - we'll print n dot send okay
43:51 - and we'll print n.11 again and let's
43:53 - just send like a few bits of information
43:55 - and see if everything is indeed working
43:58 - okay so n.send
44:00 - and then in here let's just type hello
44:03 - and we'll type
44:04 - working okay
44:06 - and see if this works so we have
44:08 - actually we should have yes server is
44:10 - working let's run our client
44:12 - and you can see we get connected hello
44:14 - working and if we come here it says
44:16 - received hello sending hello received
44:18 - working sending working so it's awesome
44:21 - um that means
44:22 - our network class is working sending
44:24 - information receiving information is
44:26 - working
44:27 - server is working
44:29 - and now the only thing that's left to do
44:30 - essentially
44:31 - is to connect that up to this
44:34 - so use this network class in some
44:36 - meaningful way here and then to actually
44:38 - store information on the server and then
44:41 - send that information to multiple
44:42 - clients which we'll be doing in future
44:44 - videos
44:47 - what we're going to be doing is we're
44:49 - going to be hooking up our graphical
44:50 - client to our server so we can send
44:53 - information back and forth and ideally
44:55 - at the end of this video what we're
44:56 - going to have is we're going to have two
44:58 - rectangles on each client so we'll have
45:00 - like two clients running and when you
45:02 - move the rectangle on one client it
45:04 - moves on the other and vice versa okay
45:06 - so you guys will get the idea when we go
45:08 - through but there's a little bit of work
45:09 - we have to do and we're gonna be
45:10 - modifying a few things within a lot of
45:12 - the files we've already created so just
45:14 - make sure you guys are paying attention
45:15 - and again if anything is going wrong
45:17 - feel free to download all the code off
45:18 - of techwithtim.net uh it'll be available
45:21 - there and it'll be exactly the same code
45:23 - that i'm writing right now okay uh so
45:25 - first thing we're gonna do is in this
45:27 - network class we're just gonna delete a
45:28 - few things so this testing stuff we
45:30 - don't need anymore this print statement
45:32 - for the self.id we don't need that
45:35 - and we're actually going to change this
45:36 - self.id to be self.pause okay
45:39 - and you guys will see why we're doing
45:40 - that in a second
45:42 - and we're going to add one quick method
45:43 - in here and we're just going to say
45:44 - define get pause okay and all we're
45:47 - going to do here is just return
45:49 - self.pause all right and again we'll
45:52 - you'll see why we're doing that but i
45:53 - just don't have to come back to this
45:54 - network class so we'll do that right now
45:56 - okay so from inside our client now what
45:59 - we're going to do is we're going to
46:00 - import this network class because we're
46:01 - going to use it in here so we're going
46:02 - to say from
46:04 - network
46:05 - import
46:07 - network
46:08 - and then in our main
46:10 - function down here what we're going to
46:12 - do is actually above player we're going
46:15 - to say n equals network okay like that
46:19 - and then what we're going to do is we're
46:21 - going to say start pause
46:23 - equals n dot get pause
46:26 - so essentially why i'm doing this is
46:28 - because when we first connect to our
46:31 - server what i want to happen is i want
46:33 - it to return to each of our clients the
46:35 - starting position of their character
46:38 - right or of their cube okay because it's
46:39 - going to depend where they're starting
46:41 - based on if they're player one or if
46:42 - they're player two so then on the client
46:44 - side what we're gonna do is when we
46:46 - initially connect to the server which is
46:47 - what we're doing when we create this
46:49 - network object we're connecting to the
46:51 - server we're gonna get that starting
46:53 - position and then for creating our own
46:55 - player we're going to use that starting
46:57 - position to determine like where we're
46:59 - starting so the position is going to
47:00 - come in as a tuple all right and we'll
47:02 - be coding all this on the server side in
47:03 - a second but it's easier just to go
47:05 - through each file rather than going back
47:06 - and forth it's going to come through as
47:08 - a tuple that looks something like this
47:09 - it'll be like 50 100 okay
47:11 - um so what we're going to do is we're
47:14 - going to read this tuple in because it's
47:15 - actually going to come in as a string
47:16 - like
47:17 - you'll see how it comes in we're going
47:19 - to get the two aspects of it's like the
47:21 - x value and the y value and then we're
47:23 - going to use that inside of this player
47:25 - initialization to like set the initial
47:28 - position
47:29 - so that reminds me what we're going to
47:31 - be doing when we're sending information
47:32 - to the server is we're going to send it
47:35 - using string data right and that's what
47:36 - we're doing in the last video is we were
47:38 - sending everything with strings so we
47:39 - were sending like hello and then we were
47:40 - decoding it and encoding it now this is
47:43 - not the only way we can send information
47:45 - we can actually send information with
47:47 - objects and i'm going to show you the
47:49 - advantage of doing that in the next
47:50 - video but for now we're just going to
47:51 - send strings so since we're going to be
47:53 - sending strings the strings that i want
47:55 - to send are positions okay i want to
47:58 - from each client send the current
48:00 - client's position to the server the
48:02 - server is going to get that position
48:04 - update it on the server side
48:06 - and then send the other client's
48:08 - position back to um the client you guys
48:11 - will see how it works in a second
48:13 - actually
48:14 - let's see if i can do a quick drawing to
48:15 - illustrate this because it'll make
48:16 - things a bit easier okay let's
48:18 - i don't know why i had this let's delete
48:20 - that
48:21 - okay so let's do a quick drawing so
48:22 - we're gonna have is we're gonna have
48:23 - client one
48:25 - and excuse me because i'm drawing this
48:26 - with a mouse and client two okay so it's
48:27 - gonna be one
48:29 - and this is gonna be two all right this
48:31 - will do it as a red box is gonna be our
48:33 - server and on the server what we're
48:35 - going to do is we're going to store
48:36 - positions so it's like one has position
48:38 - like one
48:40 - two okay sorry this is hard with the
48:41 - most guys and then
48:43 - client two will have position like three
48:46 - and one okay so it's going to store
48:48 - these positions so what's going to
48:49 - happen is when we initially connect
48:52 - client 1 is going to go to the server
48:53 - it's going to connect to it and then
48:55 - it's going to be sent back the starting
48:57 - position for the client okay so it's
48:59 - going to be said okay so you're client
49:01 - one so that means you're gonna start at
49:02 - position one two client two it's gonna
49:04 - connect
49:05 - it's gonna say okay we're client two so
49:07 - i need to send client two's position so
49:09 - let's send that back all right
49:11 - now let's say we've already connected
49:12 - client one's there clients two is there
49:14 - and we've set their starting positions
49:15 - what we're going to do next is now we're
49:18 - going to continually call to the client
49:20 - and update the position so what we're
49:22 - going to do is say let's it's say we're
49:23 - working with client one okay
49:25 - what it's going to do is it's going to
49:26 - send its position to the server so it's
49:28 - going to say let's just say pause okay
49:31 - it's sending its current position let's
49:33 - say that position is like four
49:35 - uh five sorry this is really hard with a
49:37 - mouse okay four or five what's going to
49:39 - happen here is we're going to say okay
49:41 - so you're updating your position so then
49:43 - it's going to go in here it's going to
49:44 - say okay client 1 will update your
49:46 - position to be 4
49:48 - 5 like that okay and then what it's
49:50 - going to do is instead of sending back
49:52 - the same position because we already
49:53 - know what the position is it's going to
49:55 - send back the position of client 2. so
49:57 - it's gonna send three one and then on
49:59 - here we can draw that client so that it
50:02 - looks like um it's moving right so we're
50:04 - getting we're sending our information
50:06 - and then in return we're receiving the
50:07 - other client's information now the same
50:09 - thing works here with client two so if
50:10 - client two connects right and it's
50:12 - sending information it's gonna send its
50:14 - position let's say it sends the position
50:16 - one
50:17 - three okay that's its updated position
50:19 - so this is gonna change to be one
50:22 - and three and then what's gonna happen
50:24 - is it's gonna say okay well we don't
50:25 - need clients two's position we need
50:26 - clients one so what's client one
50:28 - position well that is
50:30 - four or five so let's send four five
50:33 - over to client two and then on client
50:35 - two we can draw four five so you'll see
50:38 - they'll simultaneously be moving i hope
50:40 - that makes sense i just want to draw it
50:41 - out for you so you guys know what i'm
50:42 - about to do in this video
50:44 - okay
50:45 - perfect now the only thing is we need to
50:47 - send these positions as strings so we're
50:50 - actually going to have to implement two
50:51 - helper methods so that we can convert
50:53 - those positions which are going to be
50:54 - tuples into strings and then we can also
50:58 - read the string into a tuple so what
51:00 - we're going to do is we're going to say
51:00 - define and i want to remember what i
51:03 - call this one we'll say this one is read
51:04 - underscore position which means we're
51:06 - going to take a string value and we're
51:08 - just going to read the string in so
51:09 - we'll say str equals str.split
51:12 - and we'll split it at a comma okay and
51:14 - you guys will see
51:15 - how this works in a second
51:17 - and then what we're going to do is we're
51:18 - simply going to return
51:20 - the end of string zero so str
51:24 - zero okay comma
51:26 - int
51:27 - of str
51:29 - one
51:30 - so what we're gonna do is we're gonna
51:31 - take a string in that looks something
51:32 - like this it'll be like 45 comma 67 okay
51:36 - in
51:36 - in string value 45 67 we're going to
51:39 - split it which means we're going to get
51:40 - a list that has the string 45 and the
51:42 - string 67 and then we're just going to
51:44 - convert those to ins and return them as
51:47 - a tuple so now we get that converted to
51:49 - something that looks like this
51:50 - which is useful information that we can
51:52 - actually use okay so that's what read
51:54 - pause is going to do but we need to make
51:55 - one more which is going to convert that
51:57 - position into a string
51:59 - so we're going to say
52:00 - make underscore position
52:02 - and in here what we're going to have is
52:04 - we're going to take a tuple so let's say
52:06 - top standing for tuple and what we'll do
52:08 - here is we'll say um
52:10 - let's see here return
52:13 - top
52:15 - actually sdr
52:17 - of top zero
52:21 - and then we're gonna add that comma in
52:23 - so sorry i'm butchering my typing right
52:24 - now comma plus str of top one
52:29 - and i hope that makes sense how we do
52:31 - that so that's returning the string
52:32 - value so we're reading pause and making
52:34 - pause
52:36 - and that's all we need to do for those
52:37 - helper functions
52:39 - okay so that means though
52:41 - that when we get the position initially
52:42 - from our server it's going to come in in
52:44 - that string value right it's going to
52:45 - look like 45 67. so we need to convert
52:48 - that
52:49 - so what we'll do is we'll say
52:51 - read pause
52:52 - and we'll just put that around n dot get
52:54 - pause because it's going to return to us
52:55 - that string position so we'll read it in
52:57 - and now what we're going to do is for
52:58 - our player we're going to say start
53:00 - pause zero
53:02 - and
53:04 - start pause one okay
53:06 - and what this is going to do is just set
53:08 - it to the initial start position we're
53:09 - going to code all the server stuff after
53:10 - it'll start making a lot more sense okay
53:13 - now what we also need to do
53:15 - is we need to create a second player
53:17 - because we're going to have to draw the
53:18 - first player and the second player on
53:20 - the screen right so we're going to say
53:21 - p2 equals and we're literally just going
53:23 - to copy this
53:25 - except for start position we're just
53:27 - going to put it as zero zero for right
53:29 - now and we'll update that in a second
53:30 - okay
53:31 - so we have p
53:32 - p2 um
53:34 - and for now
53:36 - that's what we'll do actually let's we
53:38 - can continue working in here so that we
53:40 - don't have to do anything else in here
53:41 - after we'll just code the server side so
53:43 - what we'll do now is we're going to send
53:45 - our current position to the server right
53:47 - that's like the algorithm we've
53:48 - developed essentially we are when we
53:50 - connect we're going to get the starting
53:51 - position we're going to set that
53:52 - starting position
53:54 - and then every time after that so like
53:56 - every time the frame updates we're going
53:58 - to send our position and then get the
54:00 - other person's position so we're going
54:01 - to say is we're going to say um p to
54:04 - pause is going to be equal to n dot send
54:07 - okay and we're going gonna send make
54:10 - position of and then what we're gonna
54:12 - have to do in here is it's a little
54:13 - sketchy but we're gonna do
54:14 - p
54:15 - dot x p dot y
54:18 - now right because that's the position of
54:20 - our player the x and y coordinate we're
54:22 - putting it in tuple form we're sending
54:24 - it to the function make position which
54:25 - is going to turn into a string and then
54:27 - we're sending it to the server right
54:29 - okay awesome so i think that makes sense
54:31 - and then what we're going to do simply
54:32 - is for p2 we're going to update is its
54:36 - position so we'll say p2 dot x is going
54:38 - to be equal to uh actually
54:40 - n2 dot send but we're gonna have to put
54:42 - around here sorry is
54:44 - make pause read pause because right it's
54:46 - coming in as a string so we need to
54:48 - convert this into our actual position so
54:50 - f p two pause is going to be p2 position
54:53 - 0
54:54 - and then p2 dot y is going to be equal
54:56 - to p2
54:58 - p2 pause 1. okay
55:00 - now the only thing that's left to do
55:02 - here is
55:03 - what do you call it draw p2 and update
55:06 - p2's rectangle so what we're going to do
55:08 - now is in the redraw window down here
55:09 - we're going to put p2 we're going to go
55:11 - to redraw window we're going to say
55:13 - player 2 here and then we're going to do
55:15 - player 2 dot draw
55:18 - window because again it's going to be a
55:20 - player object so that'll be fine
55:22 - and then last thing to do is just update
55:24 - the rectangle so what i'm going to do is
55:25 - i'm going to say p2 dot update and we're
55:28 - going to go to player object now we're
55:30 - just going to add this one function that
55:32 - is
55:33 - update
55:34 - and then
55:36 - so you see i just made like self direct
55:38 - equals x y with height and then in here
55:40 - i'm just going to say self
55:42 - dot
55:43 - update
55:45 - like this okay
55:46 - so i know this might be getting a bit
55:48 - confusing but we're almost finished
55:49 - let's go ahead and do the server side
55:50 - and then we'll recap through everything
55:51 - what we've done explain things i kind of
55:53 - have to get this content out uh okay so
55:55 - define update so what we're doing again
55:57 - here is before we just had this line of
55:59 - code here um so we're just replacing
56:01 - that with an update method uh that's
56:03 - pretty straightforward i hope that makes
56:04 - sense to you guys and that's just again
56:05 - so when we change the x and we change
56:07 - the y value of p2 directly then we are
56:10 - updating the rectangle so when we draw
56:11 - it to the screen it's in the correct
56:13 - position okay so i believe that's all i
56:15 - have to do for the client side so now
56:17 - it's time to go to the server side and
56:19 - the server side is pretty
56:19 - straightforward
56:21 - now the server needs to keep track of
56:23 - the positions right it needs to hold
56:25 - player 1's position and players 2
56:26 - position
56:28 - consistently so we can decide if we want
56:30 - to store that let's say like on a hard
56:32 - drive or if we wanted to store that in
56:33 - memory now in our case it's not a lot of
56:35 - information so we're just going to store
56:36 - it in the memory of the server right so
56:38 - what we'll do for that is we're going to
56:40 - create a list and we're going to say
56:41 - pause equals and just a blank list and
56:44 - this list is going to hold the positions
56:46 - of our players
56:47 - now actually that reminds me we're going
56:49 - to put two tuples in here
56:51 - and these are going to represent sorry
56:52 - the starting positions of our players so
56:54 - we'll start with zero zero
56:56 - and like a hundred a hundred so player
56:58 - one will start at zero zero player two
56:59 - will start at a hundred hundred okay and
57:01 - that's all we're going to do for that
57:02 - little list there
57:04 - and then what we're gonna do down here
57:06 - uh well this while loop is
57:08 - we're gonna keep track of how many
57:09 - players have connected in our case we
57:11 - only want two to connect right
57:13 - and then we need to keep track of well
57:15 - those players so we're going to say i
57:17 - said current player equals 0.
57:21 - now this is because when we connect
57:23 - we're going to add 1 to this so that
57:25 - when we go back into this function it'll
57:26 - be you guys will see how it works but
57:28 - essentially
57:30 - every time we create a new connection so
57:32 - every time this we accept a new
57:34 - connection we're gonna add one to our
57:36 - current player so we'll actually do it
57:37 - at the bottom of the while loop we'll
57:38 - say current player plus equals one this
57:40 - is just to keep track of which player
57:42 - we're using so that we know what
57:44 - position to update what position to send
57:46 - to that player based on the connection
57:48 - right okay so keep track of current
57:50 - player and now what we're going to do is
57:52 - when we start this new thread so this
57:54 - threaded client we're also going to pass
57:56 - another argument
57:57 - which is going to be the current player
57:59 - so instead of just passing connection
58:01 - we're also going to pass player in here
58:03 - okay uh current player
58:07 - like that okay because that's going to
58:08 - be important information to know
58:10 - all right so we're actually almost
58:12 - finished we just got to update a few
58:13 - things so let's actually grab
58:16 - these two methods from our
58:19 - client class or client file and throw
58:22 - them onto server here so we're just
58:23 - going to put them right above position
58:24 - because we're going to need to use them
58:26 - read pause and make pause so now when we
58:29 - initially connect to our player right
58:31 - this is what happens when we initially
58:33 - connect the first thing that's sent is
58:35 - this encoded message that is connected
58:38 - now in our case what we want to send is
58:40 - we want to send the starting position so
58:42 - how do we do that well we know what
58:44 - player we are we're either player zero
58:46 - or either player one right because we
58:48 - only have two players when we start with
58:50 - player zero after player zero connects
58:52 - then we do player one right so what
58:55 - we'll do is we're gonna send
58:56 - pause
58:58 - player
58:59 - now
59:00 - that won't work because it's just a
59:02 - tuple right we need to first convert
59:04 - that to a string and then encode that
59:06 - string and send it so let's actually go
59:08 - back here i want to keep this string
59:09 - down in code so string.encode and we'll
59:11 - say make underscore or pause and then
59:15 - we'll just put pause
59:17 - player in here and what that'll do is
59:19 - it'll convert it into a string for us
59:21 - and then it'll send that uh to the
59:24 - player for us right and then they'll
59:25 - read that string in convert it to
59:27 - position and update the position
59:28 - accordingly okay making sense hope so
59:31 - okay so that's how that works for player
59:34 - now the only thing we need to change now
59:36 - is what information we are sending um
59:39 - every time this loop is running right
59:40 - every time we receive something from the
59:42 - player we want to send back the other
59:44 - player's position so to do that what
59:46 - we're going to do is we're going to say
59:47 - con.receive.decode
59:50 - so we'll get rid of this for now and
59:52 - then what we're going to say is we're
59:54 - going to turn this data into
59:56 - like readable a readable tuple right
59:59 - so to do that uh we're going to use the
60:02 - read position method that we've already
60:04 - created or function so say read pause
60:06 - con.receive
60:08 - and we'll turn that into from that
60:10 - string like this right or whatever it
60:12 - was like 45 67 we'll turn that into
60:15 - something that looks like this
60:16 - so that we can actually use it okay so
60:18 - now that we have that it's turned into
60:20 - that what we're going to do is we're
60:21 - going to update our current player's
60:23 - position so we're going to say pause
60:25 - player
60:26 - equals data right because this is the
60:28 - position they sent to us so let's update
60:30 - it on the server uh so yeah so it's
60:32 - updated information
60:34 - okay sweet so we've done that now all
60:36 - that's left to do is send the other
60:38 - player's position back to
60:40 - our client so to do that what we can do
60:42 - is simply say
60:45 - reply
60:46 - equals and we're just going to say
60:48 - pause
60:49 - or actually
60:50 - uh let's not do it up here let's do it
60:52 - down here okay we're going to say
60:54 - if player equals equals one so if we're
60:57 - player one we're gonna send player zero
60:59 - position right so we'll say reply equals
61:01 - and then pause
61:03 - player
61:05 - uh or not pause not not player zero
61:08 - sorry and then else we're going to send
61:10 - so we'll say reply equals pause one okay
61:15 - so if we're player one we send player
61:16 - zero position if we're player zero we
61:18 - send players one position right like i
61:19 - was talking about with that little
61:20 - algorithm we're going to use okay and
61:22 - then instead of saying received and
61:25 - sending actually yeah we can say
61:27 - received reply sending reply or we'll
61:28 - say received data
61:30 - sending reply that should work fine
61:33 - okay uh now what we'll do is we're gonna
61:35 - send all the reply but the thing is our
61:38 - reply we need to first convert into a
61:40 - string so to do that we're going to say
61:41 - make underscore pause
61:43 - right that function we've already
61:45 - created and then that should actually be
61:48 - about it now i'm probably made a mistake
61:51 - or two here but let's just test this out
61:52 - and see if everything's working so let's
61:54 - start by running the server
61:56 - and then let's run two clients and see
61:58 - if we can connect if there's any errors
62:00 - okay so we've connected with client one
62:02 - let's run client two
62:05 - and let's see what happens so i'm on
62:07 - client one right now
62:08 - you can see that when i move my green
62:09 - square it moves on the other client okay
62:12 - let's go to the other one
62:14 - and would you look at this when i move
62:15 - it on here it moves on the other client
62:17 - so we have successfully set up and
62:20 - connected our two clients together now
62:21 - the only thing i want to change quickly
62:23 - is just the color of these so that we
62:24 - know
62:25 - who is who like which square am i um so
62:28 - to do this we're just simply going to go
62:30 - we'll actually close the server class
62:32 - otherwise you're going to run into an
62:33 - issue or server instance whatever it is
62:35 - go to client
62:36 - and instead of having the same color
62:38 - here we're just going to change this to
62:40 - be 255 for player 2.
62:42 - and i want to show you what happens
62:44 - because some of you are probably going
62:45 - to be confused with what's about to
62:46 - happen here but it's kind of interesting
62:47 - so let's run server let's run client one
62:50 - let's run client two
62:52 - now notice
62:53 - that these colors are inverted
62:55 - now can anyone think of why that might
62:57 - be
62:58 - so green right is gonna be
63:01 - your current player so right now i'm on
63:02 - here i'm on this where my mouse is and
63:04 - i'm moving the green square that's near
63:06 - the middle of the screen okay but notice
63:08 - on the other screen it's moving the red
63:10 - square that's because on your client
63:13 - it's unique to you so on your client you
63:15 - are green and red is the other person
63:18 - meanwhile if i go to this client and i
63:19 - start moving see green is me and red is
63:22 - the other guy right and he's not
63:24 - currently moving now if i wanted to move
63:26 - these at the same time i would just have
63:28 - to be running these on different
63:29 - computers or i would have to change like
63:30 - the arrow keys to move them and that's
63:33 - just because obviously right like if i'm
63:34 - pressing the arrow keys on here it's not
63:36 - going to work on this client but if i
63:37 - were to load up my laptop and try doing
63:39 - it on there
63:40 - this would work fine as well
63:44 - there's quite a few issues that we may
63:46 - run into
63:48 - when we're doing this so i've set this
63:50 - up essentially to be kind of like an
63:51 - example program or like an example
63:53 - problem um to give you guys an idea of
63:55 - the way we go about doing things in
63:57 - terms of server and network but
64:00 - it's really not ideal the way that we've
64:02 - coded things so far
64:03 - now i did plan this for uh to do what
64:05 - we're about to do but essentially i'm
64:07 - going to redo
64:09 - what we've just done
64:11 - in a much more elegant and nicer way
64:13 - that's going to allow for a better
64:15 - scalability of this program okay so what
64:18 - we're going to do is i'm going to redo
64:19 - it here i'm going to show you how we can
64:21 - actually send physical oh not physical
64:23 - but like send objects
64:25 - to the server and from the server back
64:27 - to the client rather than just string
64:28 - data and then in the next videos we're
64:31 - actually going to scrap all this code
64:33 - that we've written and we're going to
64:34 - start from fresh and code like a
64:36 - networking game it's going to be a lot
64:38 - more complex than just a few squares
64:40 - moving around the screen so that's my
64:41 - plan for this series let me know what
64:43 - you guys think of that i know it might
64:44 - be a little bit frustrating to get rid
64:45 - of this code but now that we understand
64:47 - how a lot of this works it's going to be
64:48 - really fast to rewrite it in a much more
64:50 - elegant way
64:52 - so uh what i need to first start by
64:54 - doing
64:55 - is just taking this player class okay
64:57 - and i'm just going to copy it into its
64:58 - own file so really straightforward i'm
65:00 - just going to go to new python file i'm
65:02 - going to call this player with a
65:03 - lowercase
65:05 - and then just copy that player class in
65:06 - there and just import
65:09 - pie game up here okay
65:11 - import pi game now i'm just going to go
65:13 - back into client we can delete this
65:15 - player class now and what i'm going to
65:17 - do really basically is just from player
65:19 - import
65:21 - player like that okay
65:23 - and that's the first step
65:25 - now remember i said we're going to send
65:27 - objects so that actually means that
65:29 - we're not going to need this read pause
65:31 - and make pause thing and it's kind of
65:33 - annoying how we've had to well take that
65:35 - tuple object decompose it turn it into
65:38 - integers and then change object
65:40 - properties
65:41 - and then when we want to send something
65:42 - we got to put it into a string and we
65:44 - got to send it in just a pain and we
65:45 - don't want to have to do that especially
65:47 - when we're sending tons of different
65:48 - bits of information not just that same
65:50 - positional data right so we'll get
65:53 - actually going to delete this we can
65:54 - delete this client number i don't know
65:55 - why i have that there um and we're going
65:57 - to start just making some modifications
65:59 - in terms of sending data and receiving
66:01 - data so we'll start on the client side
66:03 - and then we'll go over the network uh
66:05 - the server side and fix some of that so
66:07 - wherever we see like read pause and make
66:08 - pause we can just get rid of that for
66:10 - right now um we don't actually need any
66:12 - of that we're not going to need this
66:15 - p2.x stuff uh we don't need p2.update
66:18 - we'll we'll get rid of all this for
66:20 - right now and you know actually let's
66:21 - get rid of start position
66:22 - let's get rid of p and let's get rid of
66:24 - p2 and we're going to recode all this
66:26 - okay
66:28 - so
66:28 - actually um p2p that can stay there p
66:32 - dot move is fine okay so we got rid of
66:33 - all that and you can see we've just
66:35 - cleaned up this file bit and we'll start
66:36 - working with some more stuff in a second
66:38 - now what i want to do actually is go to
66:40 - this network file that we have
66:42 - and we're going to start making some
66:43 - modifications in here as well so what
66:45 - we're going to be doing is we're going
66:46 - to be sending objects so that means
66:48 - we're going to send like an instance of
66:49 - the player class
66:51 - and that's actually what we're going to
66:52 - be sending instance of a player class to
66:54 - our server as opposed to sending like
66:56 - string data and then updating the object
66:59 - on or then updating the string data on
67:01 - the server and then sending it back and
67:02 - then updating the object it's just a lot
67:04 - of work it's a lot easier just to send
67:06 - the actual object so we can do that
67:08 - using something called pickle okay
67:10 - now it's a weird module name but it
67:12 - comes default with python and this
67:14 - allows us to do something that's called
67:15 - serialize objects and that just means we
67:18 - turn it into byte information which is
67:20 - like all the zeros and ones send it over
67:22 - the uh what do you call it send it over
67:24 - the network and then we can decompose
67:27 - that turn it back into an object and use
67:29 - that it's really easy to do that so what
67:31 - we're going to do here is we're going to
67:33 - modify a few things in our
67:35 - network class so first thing instead of
67:37 - having self.pause we're going to say
67:39 - self dot
67:41 - p okay
67:42 - it's gonna be equal to self.connect
67:44 - instead of saying get
67:45 - position we'll just do get p
67:47 - and then we'll return self.p okay and
67:49 - that's all we need to modify for that
67:51 - but now in the connect in the send we're
67:54 - gonna change a few things as well
67:56 - so
67:57 - since we're going to be getting object
67:59 - data
68:00 - what we have to do in the connect is we
68:01 - have to decompose that object data so to
68:03 - do that you do pickle
68:05 - dot loads okay now what this stands for
68:08 - is a sense for load byte data okay and
68:11 - we'll we'll talk more about this as we
68:12 - keep going through but that's
68:13 - essentially what it means and same thing
68:15 - here in send
68:17 - instead of encoding this data
68:19 - what we're going to do and i guess
68:20 - decoding as well is we're going to um
68:23 - dump it into a pickle object and then
68:25 - send it
68:26 - so to do that we're going to just say
68:29 - pickle
68:30 - uh is that a pickle yeah dot
68:32 - dot dumps
68:34 - like that and we'll just put data in
68:35 - there okay
68:36 - and then when we receive we'll do the
68:38 - same thing as before we'll say
68:41 - pickle
68:42 - dot loads and then we'll load that in
68:45 - so now essentially what we're doing is
68:47 - we're going to be receiving an object
68:49 - decomposing that object getting the
68:51 - actual object not the bytes form of it
68:54 - and then we're sending it we're gonna
68:55 - first like what do you call it encrypt
68:57 - it like send it into that byte
68:59 - information and then on the server side
69:01 - we'll decompose that as well okay so
69:02 - we'll we'll go through that but that's
69:04 - all we need for the network side so now
69:06 - let's go to server and start making some
69:08 - modifications so same thing here we no
69:10 - longer need this read pause and make
69:12 - pause functions we're not going to be
69:13 - using those
69:14 - and we don't need this pause list either
69:16 - we're going to change this actually to
69:17 - be players
69:19 - and it's going to be equal to
69:21 - two new players so notice that we're
69:23 - going to actually store
69:25 - the player object
69:27 - on the server as opposed to on the
69:29 - client side and this is not only like
69:31 - safer because it means that the player
69:33 - technically can't really mess with the
69:34 - player objects they can only like do
69:36 - commands to update them um
69:39 - but it's also just like it's gonna be a
69:40 - lot easier you guys will see how it
69:41 - works we're gonna say player and we'll
69:43 - do another instance of player and in
69:45 - here what we're gonna do is we're just
69:46 - gonna create two new players so we're
69:48 - gonna say zero zero fifty fifty and
69:51 - we'll give it a color in this case the
69:53 - first color will be red so we'll say
69:56 - red green blue like that and for the
69:57 - other player we'll start about a hundred
69:59 - a hundred like before we'll do fifty 50
70:02 - and then we'll make his color uh blue
70:04 - why not so do that okay
70:07 - so now you notice that we're getting a
70:08 - little error for player here just
70:10 - because we forgot to import it so to say
70:12 - from player
70:14 - import player like that
70:16 - uh and that's why i made this new file
70:18 - by the way just so that we'd be able to
70:19 - see it from the server side and the
70:21 - client side as well
70:22 - and then wherever we're doing this like
70:24 - send encoding stuff we're going to
70:26 - change this so let's do that now
70:28 - actually so instead of con.send instead
70:31 - of encoding some string information
70:32 - we're just going to send the player
70:34 - object so what we'll do is we'll say
70:37 - players
70:39 - like this
70:41 - and then player
70:42 - right so exact same kind of concept as
70:44 - before
70:45 - in that we're going to send the initial
70:47 - like starting position of the player or
70:49 - like the but in this case we're just
70:51 - setting the initial player object which
70:53 - means any information that's stored in
70:54 - that player will be given to the client
70:56 - as opposed to just the position okay
71:00 - so next what we'll do is instead of
71:01 - saying data equals read pause and
71:03 - decoding we're going to get rid of
71:05 - this.d code and we're going to put
71:08 - pickle
71:09 - dot
71:10 - loads okay and actually when i'm sending
71:13 - this player object my bad here guys we
71:15 - gotta do pickle
71:17 - dot dumps okay
71:20 - and then we're just gonna have to import
71:22 - pickle up here so import
71:24 - pick all right sweet okay so pickled out
71:27 - loads pickle.dumps and that is obviously
71:29 - instead of pause player equals data
71:31 - we're going to say player
71:33 - players player equals data
71:36 - and again same concept as before what's
71:38 - going to happen is the what he called
71:40 - the client is going to send us a player
71:42 - object we're going to replace the
71:44 - existing player object with that new
71:46 - player object and then we're going to
71:48 - send back the other player objects like
71:50 - the other clients okay
71:51 - so now what we're going to do is just
71:53 - change these pauses to be player or
71:56 - players
71:58 - like that okay
71:59 - same thing here players
72:02 - and then when we send it back what we'll
72:04 - do is we'll just turn it into a object
72:08 - right so we'll just do that pickle.dumps
72:10 - and send it back so say
72:12 - pickle.dumps
72:14 - reply like that and that should actually
72:17 - be about it so let's go back oh sorry
72:19 - there's something we need to do in
72:20 - client um so now what we're going to do
72:23 - is essentially we've set up our network
72:25 - class so that we're going to be able to
72:26 - send that object data
72:28 - we've set up the server so we're going
72:30 - to be able to receive that
72:32 - object data
72:33 - we're going to modify the objects we're
72:35 - storing in the list here and then we're
72:37 - going to send back the other ones to the
72:38 - other client
72:40 - so in clients all we have to do now
72:42 - is set up player 1 and player 2 and then
72:44 - send that data so really straightforward
72:46 - it's very similar to before what we're
72:47 - going to do first of all we're going to
72:49 - say p1 or actually just p i guess is
72:51 - equal to
72:52 - n dot get p
72:55 - okay because in the network class
72:57 - remember what we're doing is when we
72:59 - initially connect so let's go back to
73:00 - server we're just going to send the
73:03 - initial player object which is going to
73:04 - be whatever player it is so 0 or 1. so
73:07 - let's just say that this client's player
73:09 - object
73:10 - is going to be n dot get p okay and then
73:13 - we'll say
73:14 - actually i think that's all we have to
73:15 - do for yeah that is all we have to do
73:16 - for that inside this while loop now what
73:19 - we're going to do is every frame we're
73:20 - going to send this player object
73:23 - which will be updating with p dot move
73:25 - and we'll just get the reply and say
73:27 - that that's p2 so we're going to do is
73:29 - going to say p2 equals and then in this
73:32 - case we'll just say p
73:34 - dot or not p n dot send
73:38 - p
73:39 - and that's all we have to do and notice
73:40 - here that we don't have to do with all
73:42 - this like make
73:43 - what he called make pause read pause all
73:45 - that stuff
73:46 - and i believe this should be working if
73:48 - i didn't make any mistakes let's cross
73:50 - the fingers and let's try this out uh
73:52 - waiting for connection let's go to
73:54 - client one run that okay and client two
73:58 - running that
73:59 - and now notice that these rectangles are
74:01 - the same color
74:03 - and watch what happens if i move this
74:04 - red one see how it's red on the other
74:07 - screen as well now that already shows us
74:09 - one of the advantages of doing it this
74:11 - way is that we can store information
74:13 - like color as well not just position and
74:15 - if we wanted to store maybe like there
74:16 - was a text attribute on each of these
74:18 - players we could store that as well if
74:20 - we wanted to store more information in
74:22 - the player like a health or something
74:23 - like that it'd be a lot easier to do
74:25 - that by just sending the actual player
74:27 - object that has like an unlimited amount
74:29 - of attributes rather than just sending
74:31 - that little tuple that has like five six
74:33 - right which is the position so the
74:35 - reason i went through the trouble of
74:36 - showing you the other way is to show you
74:38 - the massive advantage of doing it this
74:40 - way and just to give you kind of
74:41 - perspective if you're making something
74:43 - really simple and you don't use any
74:44 - objects that's how you can do it with
74:46 - string data but i think this way is a
74:48 - lot easier and we've just cleaned up
74:50 - quite a bit of code we've gotten rid of
74:51 - a bunch of functions and moving forward
74:53 - this is going to make things a lot
74:54 - easier for us
74:58 - i'm pretty much going to be gutting
75:00 - everything we already did we'll keep a
75:02 - little bit of it but we're just going to
75:03 - really add to a bunch of that and just
75:06 - yeah we're going to be gutting most of
75:07 - it
75:08 - and we're actually going gonna be
75:09 - working to create online rock paper
75:11 - scissors now i know this sounds like
75:12 - kind of a lame game but let me show you
75:14 - because it's actually pretty complex and
75:16 - if you can understand how to make this
75:19 - game then you're gonna be able to
75:20 - understand how to make any other kind of
75:22 - online game because the principles are
75:23 - the same in terms of sending information
75:25 - waiting for players to go and there's a
75:27 - lot of different things that you might
75:28 - not think about that we actually have to
75:30 - do to code something like online rock
75:32 - paper scissors
75:34 - okay so let's this is client number one
75:36 - i'm just running another pie game window
75:38 - or pie charm window with the server
75:40 - running on it you can see obviously it's
75:41 - been oversized but it says waiting for
75:43 - player okay so i'm going to launch
75:45 - another client and then
75:46 - excuse me you can see when i launch that
75:49 - it loads both of them up into the game
75:51 - and it says your move opponents you
75:52 - remove opponents and currently it's
75:54 - waiting so i believe this one's player
75:56 - two and this one's player one so if i
75:57 - make a move here on uh let's say rock
76:00 - it'll lock in my move it says your move
76:02 - is rock and then over here it says
76:05 - obviously the opponent's move is locked
76:06 - in because it's
76:08 - like looking for this guy's move and now
76:09 - if he makes a move like let's say
76:11 - scissors
76:12 - then it says you win you lost and then
76:14 - it just resets and you can keep playing
76:16 - games now i'm also going to be adding
76:18 - more to this this is just like the beta
76:20 - version i'm going to have wins ties and
76:22 - losses keeping track in the top hand
76:24 - corner and when you load in you're going
76:26 - to be brought to a menu screen which
76:28 - will allow you to like start a new game
76:30 - or to leave or
76:31 - we'll add that later as we go but this
76:33 - is the main functioning game and you can
76:35 - see obviously it's working well tie game
76:38 - and it restarts this also allows for
76:40 - unlimited amount of clients to play so
76:42 - for example if i launch another two
76:43 - windows you can see these guys now have
76:45 - their own game going
76:47 - it's kind of difficult because i can't
76:48 - really get four on the screen but
76:50 - anyways if i go like scissors
76:52 - paper that works independently of these
76:54 - games and these games can kind of play
76:56 - at their own time which is really
76:58 - interesting and really cool and if you
77:00 - disconnect one of them it automatically
77:02 - disconnects the pair and that's just
77:04 - because uh obviously you can't play
77:06 - against no one right so yeah
77:08 - okay sweet so that's that um let's start
77:11 - getting into the code okay so first
77:13 - thing we're gonna do is we're actually
77:14 - going to code a a game class okay and
77:17 - this is just going to be responsible for
77:19 - holding all the information for our game
77:20 - that we need so for example did player 1
77:22 - go yet did player 2 go yet what move did
77:25 - player 1 make what move did player 2
77:27 - make are both of them connected to the
77:28 - server information like that and you
77:31 - guys will see how much information we
77:32 - actually need it's also going to store
77:34 - things like keeping track of who won or
77:36 - who lost
77:37 - how many ties how many wins so that's
77:39 - what we're going to do with this game
77:40 - class so let's start making it so class
77:43 - game i'm doing this in its own file by
77:45 - the way um
77:46 - just called game you are going to need
77:48 - it in its own file because it's going to
77:49 - have to be accessed by both the client
77:51 - and the server okay we're going to
77:52 - define our initialization uh in here
77:55 - we're going to take id i'm going to say
77:57 - self dot p1
77:59 - went equals false
78:02 - self dot p2 went
78:05 - equals false and obviously you guys know
78:07 - what this is going to do it's just going
78:08 - to stand for if player 1 has made a move
78:10 - or not if player 2 has made a move we're
78:12 - going to do self.ready
78:13 - equals false if i could type that
78:16 - correctly
78:17 - we're also going to add self.id so
78:19 - self.id equals id and this is going to
78:22 - stand for the current game's id so each
78:24 - game we create is going to have its own
78:25 - unique numeric id so that we can
78:27 - determine who's like what clients are a
78:30 - part of what game and whatnot we're
78:32 - going to do self.moves equals and then
78:34 - we'll just do none
78:36 - and not in here because currently the
78:38 - moves are none
78:39 - but we'll just store two positions so we
78:40 - can change that we'll say self dot wins
78:42 - equals and then zero zero obviously this
78:46 - one is going to stand for player one
78:47 - this one's gonna stand for player two
78:49 - and we'll say self.ties equals zero
78:52 - that's all we need for the init so the
78:54 - next one is going to say get underscore
78:56 - player underscore move
78:59 - now what this is going to do is exactly
79:01 - what it says is just going to get i
79:02 - don't know how i added that there you're
79:04 - just going to get the player move that
79:05 - we asked for so we're going to take p
79:07 - which is going to be either 0 or 1 and
79:09 - we're going to do is simply return
79:12 - self dot moves
79:15 - and p
79:16 - and just to remind ourselves we'll say
79:18 - that p
79:19 - is in the range of
79:21 - zero and one so we're only going to take
79:23 - value zero or one and then we're going
79:24 - to return uh a move so let's say move
79:27 - here okay
79:28 - and that's just to remind ourselves that
79:30 - we have to pass zero one obviously zero
79:32 - is going to represent player one and one
79:34 - is gonna represent player two okay next
79:36 - one play so this one's a bit more
79:37 - complicated not crazy we're going to
79:39 - take play we're going to take a player
79:42 - and we're going to take a move and what
79:43 - this is going to do is it's simply going
79:44 - to update our moves list with that
79:47 - player's move pretty straightforward so
79:49 - what we're going to do here is we're
79:51 - just going to say if player equals
79:54 - equals 0
79:56 - then what we'll do is we'll say
79:57 - self.moves
79:59 - 0 equals move um
80:03 - oh actually you know what let's do
80:06 - this sorry i'm just looking at my other
80:07 - screen right now we'll say self.moves
80:09 - player equals move but now what we have
80:12 - to do is based on the player we have to
80:13 - update if p1 went or p2 went okay so
80:16 - what we'll do in here is if it's player
80:17 - one obviously we'll do
80:20 - p1 went um equals true
80:23 - i'm gonna need to self before that
80:25 - and then we'll call we'll just do a
80:27 - little else here because it's not player
80:28 - zero it must be player one so we'll say
80:30 - self.p2 want
80:32 - if i could spell went equals true
80:35 - so that'll just keep track of if we've
80:37 - gone or not
80:38 - sweet next method this one's really easy
80:40 - it's going to be called connected and
80:42 - this is going to tell us if the two
80:44 - players are currently connected to the
80:46 - game
80:47 - if they are it will allow us to load in
80:49 - and that's how we can determine whether
80:51 - we should show waiting for player or not
80:52 - on the screen right so we'll say
80:55 - return self.ready and that's just going
80:58 - to tell us obviously if we're ready and
80:59 - that will be updated from the server
81:01 - side which we'll do later
81:02 - next method define
81:04 - both
81:05 - went this is just simply going to return
81:08 - if both of our players went so to do
81:10 - that we're just going to say self.p1
81:13 - and
81:14 - why can i not spell that word and
81:16 - itself.p2
81:18 - went like that okay
81:21 - next one is winner this one is a bit
81:23 - more complicated but it's just going to
81:24 - keep track of where it's actually going
81:26 - to tell us who's won the game so if we
81:29 - call this method we're assuming that
81:30 - both players have gone
81:32 - we're going to check their moves
81:34 - excuse me against one another and see if
81:36 - they want so we're actually going to
81:38 - have to check nine possible cases
81:39 - because there's three moves each player
81:41 - could do three times three nine
81:43 - so what we'll start by doing is we'll
81:45 - just say p1 equals self.moves
81:50 - zero
81:51 - dot upper
81:53 - and then zero
81:55 - the reason we're doing this is because
81:57 - we just want to get the first letter of
81:58 - the move because the move is going to be
82:00 - stored as rock paper or scissors the
82:02 - string and it's just going to be easier
82:04 - for us to type out
82:05 - for example r or s or
82:08 - what do you call or p to check the moves
82:10 - as opposed to having to check the entire
82:12 - word so we're just going to get that
82:13 - first letter by doing move zero we're
82:15 - going to upper it and then we're going
82:16 - to take that first letter we're going to
82:18 - do the exact same thing for p2 except
82:20 - obviously we're going to need um
82:22 - oh i don't know what i did there we're
82:24 - going to need
82:25 - moves1.upper
82:27 - and now we can start checking to see
82:29 - who's won so we're going to say to start
82:31 - winner is equal to negative 1. now
82:33 - that's because there could be no winner
82:35 - there could be a tie so if it's tied
82:37 - we're gonna say negative one if
82:39 - player one is the winner it's gonna be
82:41 - zero
82:42 - if player two is the winner it's gonna
82:43 - be one
82:44 - okay so we're gonna do is we're gonna
82:45 - say p1
82:47 - equals equals
82:48 - r
82:49 - and
82:50 - p2 equals equals
82:53 - scissors what we'll do is we'll say
82:54 - winner equals zero because player 1 won
82:57 - that we'll say l if
82:58 - p1 equals equals
83:01 - s
83:02 - and p2 equals equals
83:05 - r
83:06 - then we'll say winner
83:08 - equals
83:09 - one i believe
83:11 - do another lf and i know this is tedious
83:12 - but this is the way you have to check
83:14 - for rock paper scissors i don't think
83:15 - there's an easier way to do it if you
83:16 - know an easier way let me know and p2
83:19 - equals equals
83:21 - r and if you guys don't want to type
83:22 - this you can always copy it from my
83:23 - website techwithtim.net okay so say
83:26 - winner
83:27 - equals
83:28 - paper beats rocks that'll be winner
83:30 - equals one or zero sorry
83:32 - we'll say lf p1
83:34 - equals equals r
83:36 - and p2 equals equals
83:38 - p
83:39 - then winner
83:41 - equals one and we've just got two last
83:43 - ones to check here so we'll say l if p1
83:46 - equals equals uh s
83:48 - and p2 equals equals
83:51 - r
83:53 - and then p2 is the winner so winner
83:55 - equals one
83:57 - i believe that's oh sorry i'm going to
83:59 - mess this up this should be
84:00 - p think so p rock rock paper scissors
84:04 - paper yeah winner equals
84:06 - zero um okay l if p one equals equals
84:10 - paper
84:11 - and p two equals equals
84:14 - scissors then
84:16 - winner equals one and i believe that
84:18 - should be correct one two three four
84:20 - five six okay sweet and then the other
84:22 - cases are if it's a tie so if none of
84:24 - this is the case then they must have
84:26 - tied and then all we're going to do is
84:27 - simply return
84:28 - winner like that
84:30 - okay and one very last method then we're
84:33 - actually done with this class we can
84:34 - move to something else is define reset
84:37 - went and all this is going to do is say
84:39 - self. p1 went
84:42 - equals false
84:43 - and self.p2 went
84:46 - equals false pretty straightforward and
84:49 - this is the game class i know i kind of
84:50 - sped through this but it's pretty
84:52 - trivial how this works uh we just need
84:53 - to get this out of the way so we can
84:54 - start coding some other stuff
84:56 - okay sweet so we've done this class um
84:59 - next thing i think we want to work on is
85:01 - network so
85:02 - network actually you guys are going to
85:04 - have to modify yours to look like mine
85:07 - now get p
85:08 - and uh what do you call it
85:10 - so this first half so init and get p are
85:12 - going to be the same as what we had
85:13 - previously the only thing that's changed
85:15 - is connect and this send
85:18 - so in connect instead of um what do you
85:21 - call it like unpickling an object so
85:23 - like pickle dot loads
85:25 - what we're simply doing is we're going
85:27 - to just connect to the client like we
85:28 - did before but instead of unpickling it
85:30 - we're just going to decode it
85:32 - so we're going to say
85:32 - self.client.receive2048.decode
85:36 - would return that value
85:38 - and that's because when we initially
85:39 - connect to the server what we're going
85:41 - to get from the server is our player
85:42 - number which means we're either player 0
85:44 - or player 1. now that's important
85:46 - because that's going to determine where
85:48 - on the screen we're drawing certain
85:50 - things and how we're sending information
85:51 - back to the server and updating player
85:53 - one or player two right because
85:55 - technically each player thinks that
85:57 - they're player one but each one needs to
85:59 - be assigned either a zero or one by the
86:01 - computer so we know where to store
86:03 - information right
86:05 - okay so that's how we modify that just
86:06 - do decode instead of pickling i'm
86:08 - sending i believe is the same except
86:11 - what we're going to do is instead of
86:13 - pickling an object to send we're simply
86:15 - going to send a string and we're going
86:17 - to load an object so that means we're
86:19 - going to send string data to the server
86:21 - and we're going to receive back object
86:23 - data so when we receive something we
86:25 - have to pickle that loads it in but when
86:27 - we're sending it we just have to encode
86:28 - the string okay so just make sure it
86:30 - looks like this i don't think i need to
86:32 - go through this we've already done this
86:33 - for the past two three videos
86:35 - and that's the network class so game and
86:37 - network are done
86:38 - the next things to do are server and
86:40 - client
86:41 - now server and client are a bit more
86:43 - complicated so inside of server
86:47 - i guess we could do this first because
86:48 - it doesn't really depend on the client
86:50 - to work where the client kind of depends
86:52 - on the server
86:53 - we're gonna change a bunch of things so
86:55 - this is what mine looks like now i've
86:57 - kind of gutted the entire threaded
86:58 - client i got rid of most of the stuff
87:01 - like most of the other stuff i just left
87:03 - this beginning thing so that the server
87:05 - ip the port um the socket connecting
87:08 - listening waiting for connection so by
87:11 - the way some of you were saying you're
87:12 - having issues with f s dot listen you
87:14 - can just make this zero it doesn't
87:16 - really matter what's in here
87:18 - and some of you were saying like you're
87:19 - having issues just you can just delete
87:21 - it and type it in again and apparently
87:23 - that works that's what someone said so
87:25 - i don't know don't ask me about that but
87:27 - if you're running into issues do that
87:29 - okay so what we're gonna do now
87:31 - is we want to make it so you can have
87:32 - unlimited connections at once now that
87:35 - means we're going to have to have
87:36 - unlimited games running at the same time
87:39 - so before what we were doing when we had
87:40 - those players moving around the screen
87:42 - we were just storing like player 1
87:44 - player 2 and we just had a list that had
87:45 - two entries
87:47 - that's how we were doing that what we're
87:49 - going to do now is we're going to have a
87:50 - list that contains a bunch of different
87:52 - games and those games actually are sorry
87:54 - it's going to be a dictionary those
87:56 - games will be accessed by their id
87:59 - and you guys will see how this works um
88:00 - it's a bit complicated but just follow
88:03 - along um and yeah so i gotta just open
88:05 - up my other file so i don't make any
88:06 - mistakes here okay so what we're gonna
88:08 - do is we're gonna do uh
88:10 - connected equals set we're gonna define
88:13 - some variables we'll talk about what
88:14 - these do
88:15 - games equals a blank dictionary and id
88:18 - count equals zero
88:20 - so the reason we're adding these is
88:22 - games this dictionary is going to store
88:24 - our games so it's going to have an id as
88:26 - a key and the game as like a game object
88:29 - like this okay
88:31 - as the value
88:32 - this connected is just going to store
88:34 - the ip addresses of the connected
88:36 - clients we're storing in a set just so
88:38 - it's easier to access later i don't
88:40 - actually know if we use this we might um
88:44 - but we'll see okay id count obviously is
88:46 - just going to keep track of our current
88:48 - id
88:48 - so that means what game we should
88:50 - recreate so we don't override games and
88:53 - say like two games have the same id
88:54 - because obviously we can't have that
88:56 - happening
88:57 - okay so that's fine for that we're not
88:58 - going to deal with anything threaded
89:00 - client right now we're going to go down
89:02 - to our while loop and this is where
89:04 - we're going to create new games based on
89:05 - new people joining or possibly delete
89:08 - games actually we'll delete games from
89:09 - threaded client so we're going to do
89:11 - right now is when someone connects this
89:13 - this runs right and we run a new so like
89:15 - once we accept a connection everything
89:17 - after this runs so what we're going to
89:19 - do is we're going to say id count
89:21 - plus equals 1.
89:22 - if you notice me looking away i'm just
89:24 - looking at my other screen to make sure
89:25 - i don't make any mistakes on this now
89:27 - what id count plus equals one is going
89:28 - to do obviously is it's going to keep
89:30 - track of how many people are connected
89:31 - to the
89:32 - um the server at once because obviously
89:35 - right like once this happens we accept
89:37 - then we go down the while loop we start
89:39 - a new thread and then we wait for
89:41 - another connection so we're just going
89:42 - to keep track of that what we're going
89:44 - to do is we're going to say p equals 0
89:45 - just standing for the current player
89:47 - we're going to say game id
89:49 - equals and this is going to be weird but
89:51 - just follow along with me
89:52 - uh we call it id count
89:55 - minus one integer division two
89:58 - now what this is going to do is
90:00 - essentially every two people that
90:02 - connect to the server we're gonna
90:04 - increment game id by one
90:06 - and what game id is going to be or
90:09 - we'll say it's yeah we'll add it by one
90:11 - what game id is going to do is keep
90:13 - track of what id our game is going to be
90:15 - so like for example if we have 10 people
90:17 - connected to the server we're going to
90:18 - have five games right
90:20 - so that's what this line of code is
90:21 - doing for us it's keeping track of how
90:23 - many games or if we need to add a new
90:25 - game
90:26 - because obviously if we have like six
90:27 - people connected all of them are gonna
90:29 - be playing each other a seventh person
90:31 - connects well it doesn't have a game to
90:33 - join we have to create a new game for it
90:35 - to join
90:36 - hopefully that makes sense okay so what
90:38 - we'll do next we'll say if id count
90:40 - modulus 2
90:42 - equals equals one
90:43 - and what this is going to stand for is
90:45 - if you're going to be player 1 or player
90:47 - two and if this happens is actually we
90:49 - need to create a new game because this
90:51 - means that we don't have a pair for our
90:54 - new player so for example like say this
90:57 - number is three that means two people
90:58 - are already playing so that's one person
91:00 - just connected so we need to create a
91:02 - new game that's what this modulus 2 is
91:03 - getting
91:04 - okay so to do that we're going to say
91:06 - games
91:08 - game id
91:10 - equals
91:12 - game
91:14 - game id okay and i believe this actually
91:16 - has to be capital
91:18 - so obviously uh sorry at the beginning
91:20 - of this i forgot to mention i imported
91:21 - game so from game import game that is
91:24 - important
91:25 - and yeah essentially what we're doing is
91:27 - we're just going to
91:29 - say that
91:31 - game id which is that key in our
91:33 - dictionary is now equal to a new game so
91:35 - we can access that and add players to it
91:36 - and whatnot
91:38 - sweet so that works let's actually print
91:40 - out a message here and just say
91:42 - creating a new game
91:44 - dot dot just so that in our server we
91:47 - get some kind of output and we can have
91:48 - a look at that if something's going
91:50 - wrong so otherwise
91:52 - if there we don't need to create a new
91:53 - game meaning we have let's say three
91:55 - people are connected so that
91:57 - second game already exists and another
91:59 - person connects well that person has to
92:01 - be a part of this new game so what we're
92:03 - going to do then is we're going to say
92:05 - games
92:06 - game id
92:08 - dot ready equals true now what this
92:11 - means is that the second player
92:12 - connected so there's two players now
92:14 - connected to our game so now we can say
92:16 - that that game is ready to start playing
92:18 - because both the players are connected
92:19 - so that means that they can we'll
92:20 - obviously play against each other right
92:22 - so that's what we'll do we'll set that
92:23 - dot ready equal to true
92:25 - and obviously we're storing all the
92:27 - games on the server side as opposed to
92:29 - on the client side and then what we're
92:30 - going to say is we're going to say p
92:31 - equals one and what this means is player
92:34 - equals one and you'll see why we need to
92:36 - do this in a second
92:37 - okay so now we're gonna do start new
92:39 - thread now notice and start new thread i
92:41 - added two new uh parameters p and game
92:44 - id so this means the current player so
92:47 - it's either player zero or player one
92:49 - and the game id and game id is going to
92:51 - stand for which game in this game's
92:53 - dictionary are we playing
92:56 - in this threaded client like which one
92:57 - of our clients that's connected here uh
93:00 - is playing which game that's why we need
93:01 - that so let's pass that information so
93:04 - we're gonna pass p which is either gonna
93:06 - be zero or one like we have there and
93:08 - we're going to pass game id
93:11 - and then we'll have that up here and
93:12 - just remember that threaded client one
93:15 - of these functions is continuously
93:16 - running
93:17 - for every single one of our clients so
93:20 - if we have a hundred clients we have a
93:21 - hundred different functions of this
93:23 - running in the background at the same
93:24 - time okay
93:26 - awesome so that's how that's working
93:28 - inside our threaded client now
93:33 - excuse me i try to take a break there
93:35 - inside of our threaded client we now
93:37 - need to add some things so the first
93:39 - thing we're going to add is
93:41 - id count we're going to global id count
93:43 - because
93:44 - if someone leaves our game or
93:46 - disconnects we're going to need to
93:47 - subtract from that so we can keep track
93:49 - of accordingly like
93:51 - how many people are connected how many
93:53 - games are running and all that stuff
93:54 - okay
93:55 - now the first thing we're gonna do
93:58 - when someone connects to our uh what he
94:00 - called our server is we're gonna send
94:02 - them what player they are remember what
94:04 - i was saying in this game class
94:06 - or in this network class story then when
94:07 - we connect we're initially just going to
94:09 - decode a string that's either going to
94:11 - be 0 or 1 to tell us what player we are
94:14 - okay so what we're going to do is we're
94:16 - going to send con.send
94:18 - str dot in code
94:21 - p
94:22 - and i believe this should be actually
94:23 - string p
94:25 - like that so that we know for player 0
94:27 - or if we're player 1
94:29 - that's the first step next we're going
94:30 - to say reply equals a blank string i'm
94:33 - going to say wow true
94:34 - and this is where we're going to start
94:35 - doing some more serious stuff in here
94:38 - so the way that it's going to work in
94:39 - terms of sending string data from our
94:41 - client to our server is we're going to
94:43 - send
94:44 - one of three different options
94:47 - we're going to send get we're going to
94:49 - send reset or we're going to send a move
94:52 - and the move is going to be like rock
94:54 - paper or scissors
94:56 - so if we send get what that means is we
94:59 - want to get the game from the server so
95:02 - we're going to send that every frame
95:03 - we're going to send get that string get
95:05 - and then the server is going to look and
95:07 - it's going to say okay what are you
95:08 - sending you're sending get all right
95:09 - we'll send you back the game
95:11 - that's how that's going to work
95:13 - another option is reset
95:15 - reset means reset the game the game has
95:18 - finished both players played reset and
95:20 - that's going to be sent from the client
95:22 - side because the client knows when we
95:24 - want to reset right
95:26 - the last one is a move same thing when
95:29 - the client makes a move so like rock
95:31 - paper scissors if they are allowed to
95:33 - make that move which we'll check on the
95:35 - client side we'll send that move to the
95:37 - server the server will update the game
95:39 - accordingly and then it will send back
95:41 - the game to the
95:43 - client and that's how that's going to
95:44 - work sweet so what we'll do now is we're
95:46 - going to say well true i'm going to say
95:48 - data equals con
95:50 - dot
95:51 - receive and then we're going to say 4096
95:54 - in here instead of 2048 which we're
95:56 - using before dot d code
95:58 - the reason we're doing this is just in
96:00 - case uh we're setting too much
96:02 - information that is more than 2048 bits
96:05 - we want to just double this number so we
96:07 - can get more
96:08 - if you run into any issues that say like
96:10 - pickle data was truanced or like ran out
96:13 - of input just increase this number okay
96:15 - you can literally just do multiply by
96:16 - two in here and that should hopefully
96:18 - fix the error if it doesn't work you can
96:20 - like multiply by four multiply it by
96:21 - eight um and that should hopefully fix
96:24 - your error for you
96:25 - okay so now what we're going to say is
96:26 - we're going to say if
96:28 - game id
96:29 - in games
96:31 - now i'll talk about why we're doing this
96:32 - in a second but we're going to say
96:33 - they're going to say game equals
96:36 - games
96:38 - game id so essentially every time we run
96:41 - this while loop we're gonna check if the
96:43 - game still exists
96:45 - and that's what we're doing right so in
96:46 - this games dictionary we're seeing if
96:48 - this game id which is the key to access
96:50 - the game is still there
96:52 - now why would we check that well if one
96:55 - of our clients disconnects from the game
96:57 - we're actually going to delete that game
96:59 - from the uh what do you call it the
97:01 - games thing
97:03 - now what that's doing for us excuse me
97:06 - is not only
97:08 - like keeping track of our memory which
97:10 - means that we're not going to just
97:11 - continually keep creating games so like
97:13 - say our server ran for weeks and we
97:15 - never deleted any games then we'd
97:17 - probably run run out of memory on our
97:18 - computer right if we're playing a lot of
97:20 - games
97:21 - but it's also going to tell the other
97:22 - client that was connected to that game
97:24 - that
97:25 - hey this game no longer exists that
97:27 - means the other person must have
97:28 - disconnected from it so we have to do
97:30 - something accordingly go back to the
97:32 - menu screen right do something like that
97:34 - okay so that's we'll do there
97:36 - and then we're going to say in here is
97:38 - going to say if not data we're going to
97:40 - break this similar to before so i'll go
97:42 - through it a bit quicker
97:44 - we're going to say else and now we're
97:45 - going to check the three different
97:47 - things that could have been sent right
97:48 - so we've received the data so we're
97:50 - going to check if we got reset get or if
97:52 - we got a move so first thing we'll check
97:53 - we'll say if data equals equals reset
97:57 - okay
97:58 - and we're going to say if data does not
98:01 - equal
98:02 - get
98:04 - and then else
98:05 - sorry this should be an l if i left out
98:07 - it does not equal yet else we'll do
98:09 - something else uh
98:10 - actually do we need an else
98:12 - no we don't need else
98:14 - okay so if data equals reset what we're
98:17 - going to do is we're going to say game
98:18 - dot reset
98:20 - right because we already have the game
98:22 - and if we look in here what reset's
98:23 - doing is essentially it's resetting both
98:26 - players once we can play another game
98:28 - really straightforward for that next one
98:30 - if data equals get what we're going to
98:33 - do is say game
98:35 - or if data does not equal get sorry so
98:37 - if it didn't equal re reset and it does
98:40 - not equal get well then it must be a
98:42 - move so it means we're either getting
98:43 - rock paper scissors so we're going to
98:45 - send that move to the game to update it
98:48 - so to do that we're going to say
98:49 - game.play and then we're going to do the
98:51 - current player number which is p and
98:54 - then the move and the move is going to
98:55 - be whatever this data is right so it
98:58 - would be data
98:59 - okay and then otherwise so i guess after
99:02 - that um what should we do here we'll say
99:06 - reply equals game and now what we're
99:08 - going to do is we're going to do con dot
99:10 - send all i'm going to say pickle dot
99:13 - dumps
99:15 - uh and not doubt sorry reply okay and
99:18 - what this is going to do let me just
99:19 - make sure i didn't run into any errors
99:21 - here is simply going to package up our
99:24 - game into that nice um sendable form
99:27 - we're going to send it over to our
99:28 - clients client's going to receive it
99:30 - unpickle it and then use it to obviously
99:33 - make moves and do different things and
99:35 - draw it to the screen and all that okay
99:37 - all right so i think that makes sense we
99:39 - can go through it really quickly uh what
99:41 - time are we at 25 minutes all right
99:43 - so we'll go through really quickly
99:45 - essentially what's happening when you
99:46 - connect we're going to check if we have
99:48 - an even amount of players or an odd
99:50 - amount of players if it's an odd amount
99:52 - of players when you connect that means
99:53 - we need to create a new game so we
99:55 - create a new game if it's not that means
99:57 - we need to assign you to a game so what
99:59 - we're going to do is make the current
100:01 - game that only has one player in it
100:03 - ready we're going to assign you to that
100:05 - and start a new thread when we start the
100:06 - new thread what's going to happen is
100:08 - we're going to send to the client what
100:10 - player they are either player 0 or
100:11 - player 1
100:12 - and then
100:13 - what we're going to do is we're going to
100:15 - constantly receive string data from the
100:17 - client
100:18 - if the game still exists then what we'll
100:20 - do is we'll check if they're sending us
100:22 - reset get or remove if they're sending
100:25 - us a move we'll make that move they're
100:26 - sending us reset we'll apply that reset
100:28 - to the game and then we're just going to
100:29 - constantly send back to them the game
100:31 - object and now what we need to do is
100:33 - just really quickly add some else
100:34 - statements in here so that if some of
100:36 - this stuff doesn't happen we have like a
100:38 - catch for it okay
100:40 - so what we'll do here is we're just
100:41 - going to simply say else break okay
100:44 - that should be lined up here and we're
100:46 - just going to add a try and accept up
100:49 - here so we're going to say try and we're
100:50 - going to indent all this by just
100:52 - highlighting and pressing tab i'm going
100:54 - to say
100:55 - accept
100:56 - and then pass
100:58 - i think that's yeah no not passer accept
101:00 - and then break just in case you know
101:02 - something goes wrong with this data dot
101:03 - receive we want to make sure the server
101:05 - keeps running so we have that try and
101:06 - accept and then underneath this accept
101:09 - in line with the main function
101:10 - indentation
101:12 - what we'll do is if we break out of this
101:13 - while loop we need to close the game and
101:16 - delete it so to do that
101:19 - is actually we're going to print uh some
101:22 - on my wrong file here we're going to
101:23 - print
101:25 - lost connection
101:28 - and then we're going to print
101:31 - what do you call it
101:32 - closing game
101:34 - okay and actually we can print that game
101:36 - id too if we want to see what game id
101:37 - we're closing so we'll say lost
101:38 - connection
101:39 - closing game game id okay and then we're
101:42 - going to try to
101:44 - delete games
101:48 - game id
101:50 - otherwise
101:52 - we will accept
101:54 - and pass
101:56 - okay and then underneath here last thing
101:58 - we're going to do is say id count minus
102:00 - equals 1
102:01 - and we're going to say connection dot
102:04 - close
102:05 - now that i actually think about it we
102:06 - should probably put this closing game
102:08 - only in this try after we delete
102:11 - just so that we don't we only close the
102:13 - game once we don't say we're closing the
102:14 - game twice
102:15 - okay
102:16 - so what we're doing down here
102:17 - essentially is if we break out of this
102:19 - while loop so for example if the game no
102:21 - longer exists uh we're gonna break if
102:24 - something goes wrong with this getting
102:25 - data so like the player disconnected
102:27 - we're gonna break we're gonna say lost
102:28 - connection
102:29 - we're gonna try to delete that game the
102:31 - reason we have this try here is because
102:33 - if both players disconnect at the same
102:34 - time one player will delete the game
102:36 - before the other so if we try to delete
102:38 - a key that doesn't exist we're gonna run
102:39 - into an issue so we try that
102:42 - if that works
102:43 - we will say print closing game and then
102:45 - we'll say that game id otherwise we're
102:47 - going to pass we're going to subtract
102:48 - from the id count and we're going to
102:50 - close the connection
102:51 - sweet so we're rolling we're going
102:53 - pretty fast here now all we got to do is
102:55 - code the client
102:56 - now this is probably the most amount of
102:58 - code i think it's about 100 lines it
102:59 - just is a lot of drawing stuff okay
103:02 - so i'm going to take a break we'll be
103:03 - back in one second and we're going to
103:04 - code the client
103:07 - all right so i'm back now and we've got
103:09 - about 150 lines to write for this file
103:12 - it's pretty tedious because a lot of the
103:14 - stuff is to do with the drawing like we
103:16 - need those buttons to be working we need
103:18 - um like all that text to be showing up
103:20 - so that's like 90 or not 90 but like 70
103:24 - percent of the code we're about to write
103:25 - it's just going to be cosmetic stuff um
103:28 - but i mean what do you want me to tell
103:29 - you that's what we need to do if we're
103:30 - going to make an online graphical game
103:32 - right so uh let's start by just coding a
103:34 - class and this is going to be a button
103:36 - class uh just that when we have those
103:38 - three buttons you know it just makes
103:40 - things easier
103:41 - so we're gonna do our init
103:43 - uh what do we need in the init i'm gonna
103:44 - go for
103:46 - uh text
103:49 - sorry i'm coding in the wrong file text
103:52 - x y and color and we're just going to
103:54 - say that the width and the height will
103:55 - be uniform in here and we'll just make
103:57 - it the same for all of our buttons so
103:58 - we're going to say self dot text equals
104:00 - text
104:02 - self dot x equals x
104:04 - uh
104:05 - self.y equals y
104:09 - and self.color equals color
104:12 - okay sweet we'll also add a width and a
104:14 - height here so we'll say self.width
104:16 - equals 150
104:17 - self.height equals 100 and feel free to
104:20 - play with these numbers that's just what
104:21 - i decided by the way guys um just really
104:24 - want to say this i'm not focusing on how
104:26 - good this game looks i know it looks
104:28 - like crap but you guys i know can go
104:30 - through and tweak the colors and tweak
104:31 - the positions and all that
104:33 - i just didn't want to focus on that
104:34 - because i want to get the hard stuff out
104:35 - of the way in the tutorial okay so let's
104:37 - do a draw method in here pretty
104:39 - straightforward we're just gonna do
104:40 - pygame
104:41 - dot draw
104:43 - dot rect and then for the rectangle
104:45 - we're gonna take window which is that
104:47 - parameter for the draw and then we're
104:48 - going to do
104:50 - what should we do color so self dot
104:53 - self.color and then we're going to need
104:55 - that rectangle position which is going
104:56 - to be self.x
104:58 - self.y
104:59 - self.width
105:02 - and self dot height like that
105:05 - okay and then i guess let's see if
105:07 - there's anything else we need to add to
105:08 - that no that's fine we're going to
105:10 - define a font so we actually need to
105:12 - make sure we just add this at the top pi
105:14 - game.font.net okay make sure you guys
105:16 - add that
105:17 - and we're going to do
105:18 - font equals hi game
105:21 - dot font dot s
105:24 - sys font should help if you spell font
105:27 - correctly and then here you're gonna
105:29 - pick your favorite fonts
105:30 - i like comic sans i'm gonna make this
105:34 - how big should this be uh let's make it
105:36 - 40
105:37 - and then what we're going to do is we're
105:38 - going to render some fonts so we're
105:39 - going to say text equals font.render and
105:43 - we're gonna put self.text we're gonna do
105:45 - one and we're gonna do the color which
105:47 - will be i guess in this case
105:49 - black or white
105:51 - 255 255 255. okay next we're going to
105:54 - draw this on the screen now we want this
105:56 - to be centered on the button so i'm
105:57 - going to do some like i don't know
105:58 - decently complicated math uh it's not
106:01 - really that crazy but we're going to
106:02 - just say win.blit text and then we're
106:05 - going to say
106:06 - self.x
106:07 - minus
106:09 - uh is it minus
106:11 - no it's plus self.x plus in brackets and
106:14 - we're going to round in these brackets i
106:16 - know this is confusing we're going to do
106:17 - self.width over 2
106:19 - minus round
106:21 - and we're going to say text dot get
106:23 - underscore width
106:25 - over two
106:26 - now what this is doing essentially is
106:28 - we're starting at our x position
106:30 - but obviously we want our text to be
106:32 - centered so
106:34 - to center our text we need to know not
106:35 - only the width of the
106:37 - like container of the button but the
106:39 - width of our text so we're going to get
106:40 - the width of our text our of our button
106:43 - we're going to subtract that from the
106:45 - width of
106:47 - what do you call it our
106:48 - text
106:50 - so that way it should add like 20 or 30
106:52 - pixels from the left side so our text is
106:54 - centered okay for the y we'll do a
106:57 - similar thing so inside make sure you
106:59 - don't mess up these brackets inside here
107:01 - we're just going to actually copy this
107:03 - and we're going to paste it right after
107:04 - a comma
107:05 - and we're simply going to say dot y
107:08 - plus round self.height
107:11 - okay plus text dot get underscore height
107:15 - or minus text again height over two and
107:18 - that should center our button um yeah
107:21 - okay next we're going to say define
107:24 - click we're going to add a position here
107:26 - this is just going to tell us if we
107:28 - clicked on the button or not so it's a
107:29 - really basic uh if statement here so
107:31 - we're just going to say x1
107:33 - equals pause 0 and y one
107:37 - equals pause one
107:39 - now what we're gonna say is gonna say if
107:41 - self.x
107:42 - is less than or equal to x1 less than or
107:45 - equal to self.x plus self.width
107:48 - and self dot
107:51 - y
107:52 - is less than or equal to
107:55 - y one less than or equal to self.y
107:58 - plus self.height i believe that's
108:01 - correct let me just check this
108:04 - uh
108:05 - yep that's correct then what we'll
108:06 - simply do is we'll return true
108:09 - indicating that we did press the button
108:10 - otherwise we will return false
108:13 - now i know i'm speeding through this but
108:14 - it just because it's really basic pi
108:16 - game stuff and we're doing online games
108:18 - so make sure i change that
108:20 - so i don't want to focus too much on the
108:21 - cosmetics but essentially what this is
108:22 - doing is it's checking if the coordinate
108:25 - which we're going to pass in here which
108:26 - is going to be a tuple of x and y of our
108:28 - mouse position is actually in the button
108:31 - and the way we're doing that is we're
108:33 - saying we go on the x right we check if
108:35 - it's greater than the x we check if it's
108:37 - less than the x plus the width so like
108:40 - if it's in between the little box and
108:42 - then for the y value we do the same
108:43 - thing but we're checking vertically to
108:45 - see if it's in that box if you don't
108:46 - understand that i have pie game
108:48 - tutorials where i go through like
108:49 - collision and how all that works
108:51 - i'm not really going to talk about that
108:52 - right now
108:53 - okay sweet so we've got that working now
108:55 - what we're going to do is actually let's
108:57 - see what i want to code now
109:02 - let's code the main function and then
109:04 - we'll get into redraw window so the
109:05 - first thing we're going to do is we're
109:06 - going to define those three buttons that
109:08 - we're going to have at the bottom of our
109:09 - screen so rock paper scissors
109:11 - do that we're going to say buttons
109:12 - equals and we're just gonna make three
109:14 - buttons first button will be rock so
109:16 - we're gonna say rock we're gonna start
109:18 - it at 50
109:19 - 500 and then we're just gonna go and
109:21 - give it a color of zero zero zero
109:24 - okay we're gonna create another button
109:26 - we'll say button
109:28 - and then we'll say
109:30 - scissors
109:31 - we'll give it a
109:33 - let me just check here 250 as an x
109:38 - 250 is an x 500 as y and for the color
109:42 - for that i got to check what color i
109:43 - made this
109:44 - i believe
109:46 - that i made that
109:48 - ah red okay so 255 0 0
109:52 - and then one more button
109:54 - can anyone guess what this one is going
109:56 - to be it's going to be paper
109:58 - we're going to put this at a position of
110:02 - 450
110:03 - so if we can go here 450
110:06 - 500
110:07 - and we will simply make it blue or green
110:10 - sorry zero two fifty five zero so red
110:13 - green blue
110:15 - okay sweet so that should be it for our
110:17 - buttons
110:18 - um and now we'll get into the main
110:20 - function and start coding some stuff the
110:22 - first thing we're gonna need to do is
110:23 - going to need to say run
110:25 - is equal to false or
110:27 - is equal to true i always do that we're
110:29 - going to say clock equals pi game dot
110:32 - time
110:34 - dot clock
110:35 - capital c here my bad
110:38 - okay
110:39 - next we're going to say n equals
110:42 - network
110:43 - right because we're importing network up
110:45 - here we're going to do a very similar
110:46 - thing to what we did before in all the
110:48 - previous tutorials where we just connect
110:50 - initially by doing that initialization
110:52 - and then we're gonna say
110:53 - p equals
110:55 - actually player equals n dot
110:58 - get p right and you should already have
111:00 - that method um it's just returning
111:03 - that uh like connect what we connected
111:05 - to right so when we connect we get the
111:07 - player number which is either zero or
111:08 - one so we need that now it reminds me
111:11 - it's going to be a number so we got to
111:12 - put an inch around this so that we can
111:14 - compare it with other integers
111:16 - okay
111:17 - and last we're going to just print just
111:20 - so we have this you are player
111:24 - player now this just indicates to us
111:26 - like when we initially run if we know
111:27 - we're zero or one just to make sure
111:29 - everything's working fine now we're
111:30 - gonna make a while loop we're gonna say
111:32 - it's our main game loop we're going to
111:34 - say wow run
111:35 - and then in here we're going to do clock
111:37 - dot tick 60
111:39 - very similar to what we've done before
111:40 - guys i'm going to start adding some new
111:42 - stuff in a second okay so now that we've
111:43 - done this
111:45 - it's time to
111:46 - start actually connecting and asking the
111:49 - server for information
111:50 - so what we should be doing here is every
111:52 - frame we should be asking the server to
111:54 - send us the game especially at the
111:56 - beginning of this loop because right now
111:57 - we haven't actually created a game class
112:00 - right we need to get that from the
112:02 - server so we're connected now we know
112:04 - what player we are so now what we can do
112:06 - is we can try to get that from the
112:08 - server so to do that we're going to say
112:09 - game equals n dot send
112:13 - get
112:14 - and that's literally as easy as it is we
112:16 - just need to do an accept
112:17 - and then we'll just uh we call it we'll
112:19 - say run equals false and we'll say print
112:25 - couldn't get game
112:27 - okay
112:28 - and the reason we're doing this and
112:30 - we're going to break as well
112:31 - is because
112:33 - when we if we send this and we don't get
112:35 - a response from the server that means
112:37 - the game doesn't exist and what what if
112:40 - that happens well then what we should do
112:42 - is we should exit out of this game
112:44 - we should print saying we couldn't get
112:46 - the game
112:47 - and then we should try to reconnect or
112:49 - start a new game with someone else so
112:51 - this main function is going to be like
112:53 - the actual game running but once we
112:55 - exited this main function we're going to
112:56 - go to a main menu and the main menu will
112:58 - allow us to
113:00 - choose like who we want to play against
113:03 - and a bunch of other stuff as well okay
113:04 - you guys will see that later
113:06 - okay so that's how we do that
113:07 - next what we're going to do
113:09 - is we're going to say if game dot both
113:13 - went
113:14 - now what we're going to do here is if
113:15 - both players went
113:17 - well
113:18 - we're not waiting for anything now we
113:20 - need to see which one won so what we're
113:22 - going to do here is we're going to check
113:23 - which player won and we're going to
113:24 - display that message accordingly on the
113:26 - screen so what we're going to do
113:28 - initially is we're going to redraw the
113:29 - window the reason we do this right away
113:31 - is because we want to make sure that if
113:33 - both players went we're updating um
113:36 - the window and on the window it'll check
113:38 - like if both players have gone like in
113:40 - this redraw window and it'll draw the
113:42 - player moves for us so you guys will see
113:44 - how that works in a second we're going
113:45 - to do a delay we're going to do pie
113:46 - game.time.delay
113:49 - 200 and now what we're going to do is
113:51 - we're going to try
113:53 - game uh sorry game equals adam.send
113:57 - reset
113:58 - now why we're doing this obviously is
114:00 - because
114:01 - well if both players went
114:03 - we need to tell the server
114:05 - to reset um those player moves right so
114:08 - inside a game if we call reset went
114:10 - we're just going to reset it so that we
114:12 - were able to play the next round after
114:14 - okay
114:15 - we're going to accept
114:17 - except
114:19 - of course i can't spell that we're gonna
114:21 - say run equals false we're gonna do the
114:23 - same thing as before we're gonna print
114:24 - couldn't get game
114:28 - couldn't
114:29 - get game and then we're gonna break okay
114:33 - now under this so after we send that
114:36 - reset now what we want to do is we want
114:38 - to display a message on the screen
114:40 - indicating whether player one one or
114:42 - player two one or like if you won or if
114:43 - the other player won so the way we're
114:45 - going to do this and it's actually a
114:46 - decent amount of lines is because we
114:48 - have to like render font and then we got
114:50 - to determine where we're going to draw
114:51 - the font and what's going to be on the
114:52 - font so we're first going to start by
114:54 - defining a font so we'll say font equals
114:56 - pie game
114:58 - dot font dot
115:00 - sys font okay in here we'll say comic
115:04 - sans
115:06 - font size let's go 90 for this one
115:08 - now we're going to say if
115:11 - game dot winner and remember if we go to
115:13 - game winner is going to respond to us
115:15 - with either a zero a one or a negative
115:17 - one so you have to check if winner is
115:20 - one and player so whatever our current
115:23 - player is one then we're going to say u1
115:25 - if winner is one but the current player
115:27 - zero we're going to say you lost right
115:29 - so that's how we can check this
115:31 - so to do that we're going to say if
115:32 - game.winner equals equals one and player
115:35 - equals equals one and remember we got
115:37 - that player from the server so we know
115:39 - if we're either player zero or player
115:40 - one on the client side
115:43 - and
115:44 - uh
115:45 - is actually do i need an and uh oh sorry
115:47 - or that's what we need to do
115:49 - or
115:51 - game dot winner
115:53 - equals equals zero and player equals
115:56 - equals zero so essentially what we're
115:58 - going to do here is we're going to check
115:59 - if this player won so we know what
116:02 - player we are and we know what player
116:04 - won so if that coincide like what player
116:07 - we are and the player that won then
116:09 - we'll print out and we'll say or we'll
116:10 - put on the screen u1 right telling that
116:13 - client they want so we'll say text
116:15 - equals
116:16 - font.render
116:18 - and then here we simply say uh u
116:22 - 1
116:23 - exclamation point and then we can just
116:24 - do one and then a color and obviously
116:26 - color we just do like red like that okay
116:28 - on the screen
116:30 - okay so else
116:32 - actually l if
116:33 - and now we're going to check if they
116:34 - lost
116:36 - well actually i think we could do this
116:37 - easier we're going to say l if
116:41 - dot winner equals equals negative one
116:44 - so if it if we tied what we'll do here
116:47 - is we'll say text equals
116:49 - font.render and we'll just say tie game
116:53 - exclamation point
116:55 - one again we'll put that in red
116:58 - okay and now else so if we didn't win
117:01 - and we didn't tie we must have lost so
117:03 - we can literally just copy this and
117:04 - we'll just say you lost
117:06 - as the text okay so you lost
117:11 - dot dot
117:12 - sweet and now what we're going to do is
117:14 - just render that font put it on the
117:15 - screen
117:16 - so or not render it just put on the
117:18 - screen so we'll say win.blit
117:20 - uh text
117:22 - and now we're going to do the exact same
117:23 - thing that we did before uh to get it in
117:25 - the middle of the screen just be a
117:26 - little bit easier so we're just gonna
117:28 - say i believe do i need another bracket
117:30 - so i don't think so we'll say width over
117:31 - two and that's the width of the actual
117:33 - screen
117:34 - minus text dot get underscore
117:37 - width
117:39 - we need those brackets over two we're
117:41 - gonna do comma and now we'll just do the
117:43 - same thing with height so we'll say
117:44 - height
117:45 - over two minus
117:47 - text dot get
117:49 - underscore height over to okay so that's
117:52 - going to put it in the middle of the
117:53 - screen we're going to update the display
117:55 - highgame.display.update
117:58 - and we're going to delay so pygame dot
118:03 - time dot delay and i'm going to put 2000
118:05 - for two seconds
118:07 - you guys can put whatever you want in
118:08 - here okay so let's break this down
118:09 - really quickly
118:11 - if both players went that means now we
118:13 - get to check who won so what we're going
118:15 - to do is we're going to redraw the
118:16 - window we're going to what do you call
118:18 - it
118:19 - apply a small delay of 0.2 seconds just
118:21 - so that we can see what both players did
118:24 - before it immediately pops up who won
118:25 - and who lost so actually let's make this
118:27 - delay half a second
118:30 - we're going to send to the server reset
118:31 - so we're going to reset both players
118:33 - once so the next time that we start
118:34 - playing we can both players are allowed
118:36 - to move we're going to say run equals
118:38 - false if this doesn't happen if this
118:40 - doesn't work we're going to prank
118:41 - couldn't get a game we're going to break
118:43 - now otherwise
118:45 - so like if this worked we sent the game
118:47 - we're going to create a font we're going
118:48 - to check who won so either we won we
118:50 - tied it we lost we're going to display
118:52 - that to the screen we're in delay for
118:54 - two seconds and then we're going to play
118:55 - the game again after
118:56 - okay awesome
118:58 - so we're almost done we're just going to
119:00 - add this pretty actually complex for
119:02 - loop in here
119:03 - so we're going to do now is we're going
119:04 - to say for
119:06 - event
119:07 - in pygame.event
119:09 - dot get very standard for pygmy you've
119:12 - probably seen this before i'm going to
119:13 - say if event dot type equals equals
119:17 - pi game
119:19 - dot quit
119:20 - then what we're going to do is going to
119:21 - say
119:22 - run equals false
119:24 - and we're going to say pi game dot quit
119:28 - so this just means that they hit that
119:29 - little x button at the top of the corner
119:30 - now we're going to check if they
119:32 - actually press their mouse button down
119:33 - so this is how we're going to check if
119:35 - they pressed a button that's what we're
119:36 - going to do now let's say if event
119:39 - dot type equals equals pi game
119:42 - dot mouse button
119:46 - down
119:47 - then what we'll do is we'll get the
119:48 - mouse position to do that we're gonna
119:50 - say if
119:51 - we're gonna say pygame.pause uh
119:53 - pygame.mouse
119:56 - dot get underscore pause so what we're
119:58 - doing here is we're checking if they
119:59 - press right middle or left mouse button
120:01 - if they do let's get the mouse position
120:05 - now for every single button we're gonna
120:07 - check if we click that button if we did
120:09 - we're gonna do something accordingly
120:10 - okay so we're gonna do now i'm going to
120:11 - say 4 button
120:12 - in btns
120:15 - remember we defined buttons up here
120:18 - then what we're going to say is
120:20 - if btn
120:22 - dot click
120:23 - pause
120:25 - now if they did click the position
120:27 - there's a few things we need to check oh
120:29 - and elsa when you check this sorry
120:31 - and game dot
120:33 - connected
120:34 - sorry so what this game.connected is
120:35 - doing is just making sure that it's not
120:37 - going to let us press like rock paper
120:39 - scissors unless we both players are on
120:42 - so that's just so that we don't run into
120:43 - an issue where we can make a move before
120:45 - the other player
120:46 - connects okay so just add this and
120:48 - game.connected
120:49 - what we'll do now is we're going to
120:51 - check what our current player is because
120:53 - this is going to determine
120:54 - how we send a move so we're going to do
120:56 - now is going to say if player equals
120:58 - equal zero
121:00 - if not
121:01 - game dot
121:03 - what do you call it p1 went
121:06 - then we'll do something
121:08 - otherwise so we'll just put uh else here
121:11 - and we'll check if not
121:13 - p2
121:15 - game.p21
121:18 - okay so what we're doing now and i
121:20 - haven't coded the rest of it yet is
121:22 - we're just going to check if we press
121:24 - one of the buttons so remember we have
121:26 - that click method in our button that
121:27 - tells us if we clicked on it
121:30 - so if we do click on it
121:31 - and we're connected to the game what
121:33 - we're going to do is we're going to
121:34 - check if our current player is 0 or 1.
121:36 - now what we're doing is if we're player
121:38 - 0 well we're going to check if player 0
121:40 - has gone yet if they've gone obviously
121:42 - we're not going to let them make a move
121:43 - right because they've already made that
121:45 - move they can't change their move once
121:46 - they made it
121:48 - same thing with player 2. so if we're
121:49 - not player zero we're player one clearly
121:51 - so that means we're going to check if
121:52 - player two is gone yet and if they
121:54 - haven't gone we'll allow them to move
121:56 - okay so what we'll do in here now is
121:58 - we're gonna make a move now to make a
121:59 - move remember we just need to send to
122:00 - the network our move so we're just gonna
122:02 - say n.send or to the server sorry and
122:04 - all we're going to do is we're just
122:05 - going to send the text of the button
122:08 - now the text of the button will be
122:10 - rock paper or scissors right and that's
122:12 - precisely the move that we're going to
122:13 - make depending on what button we're
122:15 - clicking so it's a really nice dynamic
122:16 - way to do that
122:18 - now
122:19 - once we've done that right so if we go
122:21 - to server
122:23 - what happens here is if we send that
122:25 - we're going to play that move and we're
122:26 - going to update it on the game so that
122:29 - the other client when it gets that game
122:31 - board again we'll have that updated move
122:33 - you guys will see how this works in a
122:34 - second
122:35 - okay
122:36 - so that's working well now all we need
122:38 - to do is just add
122:40 - in line with this right here we're gonna
122:42 - say redraw window we're gonna give it
122:44 - win we're going to give it
122:46 - what else do i need to give it game
122:48 - and p
122:50 - which stands for current player
122:52 - and that's actually it
122:54 - for and make sure you just call our
122:55 - calling main down here at the end of
122:57 - client that's actually it for this main
122:59 - function so now all we need to do is do
123:00 - redraw window and we're really close to
123:02 - done so we got another like 20 lines and
123:05 - then once we do that we're actually
123:06 - finished this game
123:08 - and then we can start testing it out and
123:09 - talking about some more things we can
123:11 - add to it okay
123:13 - so what we're going to do now
123:15 - is yeah this is actually quite a bit of
123:16 - work is we're going to draw all the
123:18 - stuff on the screen now so we've done
123:20 - all the logic aspect of it down here in
123:21 - this main function now we need to draw
123:24 - everything so it's more tedious and it
123:25 - is difficult but we're just going to
123:27 - first start by checking if not
123:29 - game.connected
123:31 - now this just means if we have not yet
123:33 - had the other player connect then all
123:35 - we're going to do is we're just going to
123:36 - print on the screen waiting for player
123:37 - and we're not going to show anything
123:38 - else so to do that we're going to say
123:40 - font equals pie game
123:43 - dot font
123:45 - dot sys font name obviously is comic
123:48 - sans
123:49 - and then the
123:51 - how big should it be let's make it 80
123:54 - okay and then we're going to say text
123:56 - equals font
123:57 - dot render in here we're going to say
124:00 - waiting for player
124:02 - dot dot
124:03 - one color let's do nice red
124:06 - and let's actually add true here for
124:08 - bold okay okay so we're going to blit
124:10 - this on the screen
124:12 - so to do this we'll say win dot
124:15 - blitz
124:16 - and we're going to do again that same i
124:17 - know a tedious thing to get in the
124:18 - middle of the screen so we're just going
124:20 - to say with over 2
124:22 - minus text dot get underscore width
124:27 - and then we're going to say height over
124:29 - two minus
124:30 - text dot get underscore height
124:33 - uh and actually we need to make sure
124:34 - we're dividing both the width and the
124:36 - height by two so let's do that
124:38 - okay
124:39 - that's it for that now else so this
124:41 - means if we actually are connected both
124:44 - players are in now it's time to start
124:45 - drawing the real stuff on the screen
124:47 - so we need to draw that what was it so
124:50 - actually let me pop up client for you
124:51 - guys so you can see what it looks like
124:53 - uh let's run the server
124:55 - rotten client client
124:58 - right so if we want to see the client
124:59 - what we should do is we need to draw
125:02 - this this this this and then the three
125:04 - buttons
125:05 - okay so we're gonna have to do these
125:06 - four texts and the thing is
125:08 - these texts need to change um on like
125:11 - they're gonna be different depending on
125:12 - what player is looking at it right so
125:14 - for example
125:15 - here it's showing us what our move is
125:16 - but notice it just says locked in for
125:18 - opponents it doesn't tell us what our
125:20 - move is
125:21 - and what the other players move is right
125:22 - so we need to do that as well
125:24 - okay so to do that
125:26 - uh let's
125:27 - start um we're going to make another
125:29 - font i'm going to say font
125:32 - equals pi game
125:34 - dot font dot sys font
125:38 - comic sans
125:39 - size of this font let's make it 60
125:43 - and then what we're going to do is going
125:44 - to say text equals
125:46 - font dot render
125:48 - and
125:49 - we're going to do
125:51 - your move so we're going to start by
125:53 - just doing your move and like opponent
125:54 - move because those aren't going to
125:55 - change they're going to stay the same no
125:56 - matter what and for that we're going to
125:58 - do one and the color i had there was
126:00 - like a nice cyan i think right so we'll
126:02 - do this um feel free to change the color
126:04 - i know it probably doesn't look the best
126:06 - and let's just split this at a static
126:07 - position on the screen so we'll say text
126:10 - and let's go 80
126:12 - 200.
126:13 - okay
126:14 - all right next so actually still in this
126:17 - else statement we're going to copy this
126:19 - um just
126:20 - sorry
126:21 - what am i doing just this text and this
126:24 - win part
126:25 - and we're going to put it down here and
126:26 - say your move we're going to say
126:28 - opponent
126:30 - move is that how you spell that
126:33 - uh let's change that to opponents and
126:35 - actually let's just get rid of moves to
126:36 - be too big opponents and same color
126:38 - except we're just going to change the x
126:40 - value so that we draw it at
126:43 - what do you call it 380 like that okay
126:46 - so that's it for your move and opponents
126:48 - next what we need to do
126:50 - is bit more complicated because now we
126:52 - have to draw what the actual moves are
126:54 - so remember we're obviously we don't
126:56 - want to show the other player
126:58 - what
126:59 - one of the players moves is unless both
127:01 - of them have gone it's like we want to
127:02 - know what our move is but we can't know
127:04 - what the other players move is until
127:05 - we've both made a move so to do this
127:08 - what we're going to do
127:09 - we're going to start by just getting
127:10 - both player moves so we're gonna say
127:12 - game
127:13 - dot get underscore player
127:15 - underscore move
127:17 - we're gonna get move zero and we'll
127:18 - actually we'll
127:20 - copy this and just do move two and
127:22 - change this to one
127:24 - so we'll start by getting the moves
127:27 - and then now we're going to check if we
127:28 - should show those moves if we should
127:30 - show waiting or if we should show locked
127:32 - in okay so to do this we're going to say
127:33 - if
127:34 - game dot both went
127:37 - okay
127:38 - like that what we're gonna say is gonna
127:40 - say text one equals font
127:42 - dot render and we're just gonna use the
127:44 - same font as before
127:45 - and what it's gonna be is
127:48 - move one
127:49 - comma one comma and we'll make this
127:52 - black so zero
127:54 - okay and we'll copy this
127:56 - and we'll do the same thing except text
127:58 - two is going to be equal to move to
128:00 - so essentially this is saying if both of
128:02 - the players have gone well we can show
128:04 - their moves because they both made them
128:05 - so let's do that and it's just rendering
128:07 - that font and we'll display the font
128:09 - after uh you'll see how it works so now
128:11 - otherwise if both players have not gone
128:13 - what we need to do is we need to
128:15 - actually let me just check something for
128:16 - a second is we need to determine if
128:19 - we're going to show locked in meaning
128:20 - the other player actually has gone but
128:22 - we're not going to show their move or if
128:23 - we're going to show waiting which means
128:24 - the other player hasn't gone so to do
128:26 - this we're going to say if
128:28 - game dot p1 went
128:31 - and
128:32 - p equals equal zero so this is saying
128:35 - if uh we have gone
128:37 - and it's our current uh like we are the
128:40 - player we're player one so player one is
128:41 - gone and we are player one what we're
128:43 - going to do is we're gonna say text one
128:45 - equals font
128:47 - dot render
128:48 - move one which is the move we've done
128:50 - which is fine if we see that and then
128:52 - we're gonna say one
128:53 - and color zero zero zero
128:55 - okay l if
128:58 - game dot p2 went
129:01 - and
129:02 - uh is this one it is actually sorry
129:05 - game.p1 went you guys will see this
129:08 - works in a second
129:09 - what we're going to say i'm going to say
129:11 - text 2 equals the same thing
129:14 - now this might be confusing but
129:15 - essentially what this is doing is it's
129:16 - saying if player 1 is gone and we are
129:19 - player 1
129:20 - we're gonna say uh
129:22 - if i spell render correctly render
129:25 - like that
129:27 - render sorry i got interrupter there
129:29 - okay so if player one is gone and we are
129:31 - player one then we wanna show underneath
129:33 - like your move what our move is
129:36 - otherwise what we wanna show
129:38 - is we wanna show that uh like locked in
129:41 - so we're gonna change this to locked in
129:43 - underneath opponent's move because it
129:44 - means player 1 went but it's not us so
129:47 - it's not our move so that means we want
129:49 - to show it under opponent's move so
129:50 - you'll see how this works we're going to
129:51 - say
129:52 - locked in like that okay
129:55 - all right now we're just going to do
129:57 - else so this actually just stands for if
130:00 - game.p1 hasn't like if they haven't
130:03 - moved yet we're just going to say text 2
130:06 - equals waiting
130:08 - so we'll say
130:10 - waiting
130:14 - i believe that's correct um actually
130:18 - sorry these all need to be text one my
130:20 - bad okay
130:22 - all right i know this is confusing but
130:23 - we'll go through it after all right so
130:25 - we're gonna actually copy this and we're
130:26 - just going to change everything to two
130:28 - so this is going to be p2 this is going
130:31 - to be one
130:32 - this is going to be 2 it's going to be 2
130:34 - and it's going to be 2 and this is going
130:36 - to be 2 as well and let me just make
130:37 - sure that i did that correctly i believe
130:40 - i did okay sweet and now we are going to
130:44 - actually show these we're going to split
130:45 - these on the screen we're actually
130:46 - really close to finish guys
130:48 - so to do this we're going to say if p
130:51 - equals equals one so if we're player one
130:53 - what we'll do is say win.blitz and we'll
130:56 - say text 2 and then where we're going to
130:58 - show it we're going to show it at 100
131:00 - and 350.
131:02 - okay
131:03 - now we'll copy this so ctrl d and we'll
131:06 - blit 1
131:07 - except instead of 100 we're going to
131:09 - change this to 400
131:10 - now we're just going to put an else so
131:12 - if we're not player 1 clearly we must be
131:14 - player 0. so we're just going to reverse
131:17 - these player 1 player 2.
131:19 - now the reason we're doing this
131:21 - is because this is going to be
131:23 - where like player 1 and player 2's moves
131:25 - are shown on the screen so we want it to
131:27 - make so that for each of our clients
131:29 - rather than saying like player 1 player
131:31 - 2 and having one of the clients have
131:33 - their move on the right side and one of
131:34 - them have it on the left side we want it
131:36 - to be the same for each client
131:38 - you guys will see how this works when we
131:39 - actually run the thing so let's actually
131:41 - just uh
131:42 - let's add in drawing the buttons so to
131:44 - draw the buttons we could
131:46 - uh we could draw them in this else
131:48 - statement actually that might be better
131:49 - yeah let's do it inside of this this
131:51 - else okay so we're gonna say for
131:54 - vtn
131:55 - in
131:56 - buttons we're just gonna say btn.draw
131:59 - and give it a win and i think that's
132:01 - actually all we need to do and lastly
132:03 - we're just gonna update the display so
132:05 - pygame
132:06 - dot display
132:07 - dot update
132:09 - now assuming i didn't make any critical
132:11 - errors
132:12 - this should actually be working so i
132:14 - know this has been a lot of code and a
132:15 - lot of writing but i think i've kept it
132:17 - to just about an hour now actually
132:19 - and that's actually pretty decent time
132:20 - for creating a game like this so you
132:22 - guys will see how this works out okay so
132:24 - let's try running our server and see if
132:27 - we get any errors first of all okay
132:28 - server waiting for connection server
132:30 - started good sign so far okay clients
132:33 - let's try running a client so i'm going
132:34 - to client
132:36 - oh name p is not defined win game p ah
132:39 - okay so what we're going to do for
132:41 - client this is a really easy fix just
132:42 - change this to player
132:44 - and i might have to change
132:47 - oh yeah up here when i do redraw game
132:48 - window as well you gotta do win
132:50 - um game
132:52 - and player okay so fix that all right
132:54 - client run
132:56 - waiting for player all right good sign
132:58 - let's run another one
133:00 - and would you look at that okay they
133:01 - both launch in now so you saw that
133:03 - waiting for players showed up but as
133:04 - soon as we were ready
133:06 - now both of them are showing up okay so
133:08 - this should be player one this should be
133:10 - player zero or player uh player one
133:13 - player two right okay so let's try this
133:15 - now rock ah ran out of input self.client
133:18 - i received 2048. okay so let's just have
133:20 - a quick look at why this might be
133:24 - ah so i think i might have fine found
133:26 - the issue i'm actually i don't know if
133:27 - this is the issue exactly but we do need
133:29 - to fix this
133:30 - where i do game dot reset
133:32 - inside of server here it actually needs
133:34 - to be reset went uh because that's what
133:36 - i called it inside here reset went so we
133:38 - just gotta make sure we do that
133:39 - okay guys so really silly error here
133:41 - actually um the issue was on the server
133:44 - side here i'm calling play right like
133:46 - game.play and so actually i need to get
133:49 - rid of this i was just printing out the
133:50 - exception so i can see what it was
133:52 - but essentially play doesn't actually
133:54 - exist because i misspelt something on
133:56 - game i misspelt it i misspelled player
133:59 - it should be play so that was the issue
134:01 - i was running into um it just it was
134:03 - very difficult to see because it was
134:04 - just accepting it and not like
134:07 - not printing anything out just
134:08 - continuing to run the server so i
134:09 - couldn't find it but essentially if we
134:11 - run the server and run the two clients
134:13 - now
134:15 - we should have everything working i
134:16 - haven't actually tested it so let's pray
134:18 - if i go paper
134:20 - sweet so it goes paper here we're not
134:21 - getting locked in over here so that
134:23 - might be an issue but let's see if we
134:24 - make something here then since you lost
134:27 - and you won
134:28 - okay so we have a slight issue but it's
134:30 - pretty easy fix let's just go up to uh
134:32 - client just look through we're just
134:34 - probably messing something up in the
134:35 - drawing code here
134:37 - so oh
134:38 - that would make sense well we're not
134:40 - actually end up drawing
134:41 - yeah so this if p equals equals one this
134:44 - just needs to tap back one um one
134:46 - indentation level
134:48 - and now we should have everything
134:49 - actually working fine so let's
134:51 - try this now client
134:53 - client
134:55 - and let's go rock
134:58 - okay so that works but it's not doing
135:00 - the locked in for some reason so let's
135:02 - check this this locked in portion i just
135:04 - did close that server
135:06 - and make sure that this is actually
135:08 - working
135:09 - uh so that needs to be p2 went
135:12 - and
135:13 - well if this one should be working that
135:14 - was what's confusing
135:16 - okay so actually so that one just need
135:18 - to be p2 when game.p2 went um let's
135:22 - try this server
135:24 - and let's go client
135:26 - and let's run it again
135:29 - and go scissors locked in sweet so
135:31 - that's actually working and the game is
135:33 - pretty well finished all we got to do is
135:34 - add a menu screen then we're gonna be
135:35 - done so now let's go scissors
135:37 - this is a scissors
135:38 - scissors
135:40 - that's not correct we gotta fix that as
135:42 - well okay
135:44 - i thought i had everything working guys
135:46 - i really thought so
135:48 - ah okay so i actually i do i do know the
135:50 - issue it was it's pretty straightforward
135:52 - so in main here when we check the uh
135:55 - let's see here the winners where do we
135:57 - check winners
135:58 - if it equals equals one because equals
136:00 - negative one um ah okay so game.winner
136:04 - needs brackets
136:06 - of course it does
136:08 - so we need to add that so obviously just
136:10 - some silly areas guys so servers running
136:12 - right now let's run these clients see if
136:15 - everything is indeed working as as
136:17 - it's supposed to be now okay so let's
136:19 - try this paper blocked in scissors
136:22 - you lost you won yay okay everything's
136:24 - working okay paper paper tie game sweet
136:28 - okay so you guys can obviously mess
136:29 - around with the timing you can see how
136:31 - this is working so the only last thing
136:33 - to do now is watch this if i disconnect
136:36 - it disconnects both of them so what
136:37 - we're going to want to do now if that
136:39 - happens is instead of
136:41 - just completely like exiting the game
136:43 - we're going to want to bring them to a
136:44 - menu screen where they can just click to
136:46 - reconnect and this is a really this
136:48 - actually really easy to do um so what
136:50 - we're going to do is we're just going to
136:51 - define another function
136:53 - i'm going to call this menu underscore
136:55 - screen okay and in here all we're going
136:57 - to do is have a really basic while loop
136:59 - that just checks if you click something
137:01 - and all it's going to do there is click
137:02 - the uh run that main function so we're
137:04 - going to say run equals true
137:07 - we're going to say well run
137:09 - okay and then in here we're going to say
137:11 - for event in high game
137:16 - dot event dot get and then obviously
137:18 - we're going to check if they click exit
137:20 - so if event dot type because it goes pi
137:22 - game dot quit
137:24 - then we will do is just do pi game don't
137:26 - quit
137:27 - run equals false
137:29 - otherwise if they click any key so we'll
137:31 - say if event
137:33 - dot type equals equals pi game
137:36 - dot and we'll just say
137:38 - mouse button down so i should just get
137:39 - it they'll click the mouse button
137:41 - then what we'll do is we'll simply say
137:44 - run equals false
137:46 - and at the bottom of run equals false
137:48 - what we're going to do is we're just
137:48 - going to call main
137:50 - so all this is going to do and we'll
137:51 - call menu underscore screen here
137:55 - so we'll say while true
137:56 - um
137:58 - comma
137:59 - menu screen
138:00 - okay and i'll go through this in a
138:02 - second we'll say while true menu screen
138:04 - okay so we're going to do
138:06 - is in menu screen
138:08 - if they click something we're going to
138:09 - call the main function
138:11 - which is simply going to
138:13 - uh what do you call it do
138:15 - all of this stuff in here and then if
138:18 - they exit out of the main function so if
138:20 - you say like run equals false
138:22 - because they disconnected it'll just
138:23 - rerun the menu screen which means that
138:26 - they'll be prompted to reconnect to new
138:28 - game
138:29 - awesome
138:30 - what we'll do in here is add a clock as
138:31 - well this will say clock
138:34 - equals pi game
138:36 - dot time dot clock
138:38 - give it a tick so
138:40 - clock dot tick 60
138:43 - uh we'll do we'll just draw something in
138:45 - here we don't need to use
138:46 - the redraw window function uh we'll just
138:48 - do font equals
138:51 - pie game dot font
138:54 - dot
138:55 - sys font
138:57 - in here we'll go comic sans
139:00 - we'll go 60 and then we're just going to
139:02 - render some text we'll say text equals
139:05 - font.render
139:07 - in here we'll simply say click to
139:09 - connect
139:10 - or click to play
139:12 - exclamation point
139:13 - one some nice red text
139:16 - and we can just continually actually we
139:18 - can just window fill um so wind.fill
139:22 - and we'll just fill it with white 0 0 0
139:24 - or
139:25 - what am i saying gray actually 128 128
139:29 - and we should just where is win do i
139:31 - define it up here somewhere yes i do so
139:33 - that's sweet winds up there
139:35 - so what we could do is just fill the
139:36 - window
139:38 - run into this while loop
139:39 - put some text on the screen
139:41 - we may actually have to fill this every
139:43 - frame
139:45 - let's
139:46 - get rid of one of those brackets i
139:47 - created so let's fill this every frame
139:49 - actually okay so we'll fill it
139:51 - we will blit this font so let's say
139:54 - wind.blit
139:56 - text
139:57 - and you know what for right now i don't
139:58 - want to deal we'll just do it statically
140:00 - we'll just do like 150 so it's not at
140:03 - the top of the screen actually let's go
140:04 - 100 200
140:06 - okay and go pi game
140:08 - dot display.update
140:11 - like that
140:12 - then if they click something what should
140:14 - happen is it should break this loop
140:16 - they should be brought to the main thing
140:20 - and yeah that should hopefully be
140:21 - working for us so let's try this
140:23 - client
140:24 - click to play okay a little a little
140:27 - sketchy on the click to play but let's
140:28 - see if we click to play okay waiting for
140:30 - player so this is actually what i wanted
140:32 - so it says waiting for player we're
140:33 - gonna wait for someone else to connect
140:35 - okay boom connected sweet so now we're
140:37 - ready so let's just run a game let's go
140:39 - rock scissors
140:40 - now let's just see what happens if we
140:42 - click x
140:43 - this one goes to the menu screen where
140:45 - it says click to play and it can be
140:47 - what he called play against someone else
140:49 - right and that's exactly what we wanted
140:51 - we may also want to add like a back
140:52 - button to go back but i'll leave that to
140:54 - you guys so guys i'm going to leave the
140:55 - tutorial here if you guys have any
140:57 - questions or run into any bugs or
140:59 - anything please let me know this is by
141:01 - no means like a full complete game
141:03 - there's still obviously a lot of things
141:04 - that could be added to this and i might
141:05 - continue this series later but i think
141:07 - for now that's probably enough i hope
141:09 - that you guys learned how to make an
141:11 - online game i find this stuff really
141:13 - freaking cool and really interesting how
141:15 - you can have like a ton of different
141:16 - clients connecting together and that
141:18 - being said i'll see you guys in another
141:19 - video