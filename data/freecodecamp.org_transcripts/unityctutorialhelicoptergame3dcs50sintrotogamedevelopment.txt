00:00 - [MUSIC PLAYING]
00:16 - COLTON OGDEN: All right.
00:17 - Welcome back to GD50.
00:18 - This is Lecture 8.
00:19 - Today we're going to be
diving into the world of Unity
00:22 - for the first time,
which I'm excited about.
00:25 - Going to be a whirlwind tour, but
I'll try to cover as much as possible.
00:28 - Transitioning away from 2D and away
from Lua and LOVE 2D into 3D and C#
00:34 - in the context of Unity.
00:35 - Today we'll be talking
about Helicopter Game 3D.
00:37 - So Helicopter Game is a 2D game
that was really famous in the 2000s.
00:42 - It was a web game.
00:44 - I was sponsored on a bunch of websites.
00:46 - Addictinggames.com
still has it on there,
00:48 - and a few other websites have it.
00:49 - It was a flash game.
00:50 - But I remember playing it a lot.
00:52 - It was the old precursor
to Flappy Bird, which
00:54 - was mentioned on the Wikipedia page.
00:56 - There's a reference to it there.
00:58 - And this is what the
game play looked like.
00:59 - It was very similar to Flappy
Bird-- a little bit different
01:01 - in that, instead of trying to
avoid pipes, you're in a cave,
01:04 - and you're trying to avoid the
ceiling and the ground of the level.
01:08 - And there were these little obstacles
that would spawn in the middle,
01:10 - as well.
01:10 - So you'd have to navigate that.
01:11 - But it was the same exact mechanic--
the sort of like, click to go up.
01:15 - And then, when you didn't
click, your helicopter
01:17 - would just sink down via gravity.
01:20 - Today we'll be talking about a bunch
of brand new topics, things like Unity,
01:25 - first and foremost-- the ecosystem
with which we'll be doing
01:28 - a lot of the things we'll be doing.
01:29 - C# is the primary
language we'll be using.
01:32 - So we're going to take a step away
from dynamic languages and move towards
01:36 - statically-typed languages--
01:38 - languages like C#, and
Java, and the like.
01:40 - Blender is a program we'll
look at briefly today,
01:42 - just because, in the
context of 3D development,
01:45 - you're going to want to have a tool
that will let you create models.
01:48 - And so the 3D software that I like
to advocate for the most, especially
01:51 - for folks that are just starting
out, is Blender, because it's free,
01:53 - and open source, and it
has much the same feature
01:56 - set as any commercial software,
like 3D Studio Max, and Cinema 4D,
02:00 - and the like.
02:01 - We'll talk about what components
are-- entities and components, how
02:04 - they relate in this model that Unity
has adopted for all of its programming.
02:08 - Components are little pieces
of behavior that you can then
02:11 - combine to form a whole, that will then
drive the behavior of whatever object
02:16 - in your scene you want,
rather than having
02:18 - to customize its behavior via a long
chain of inheritance and instantiation.
02:23 - Colliders and triggers
are important in 3D--
02:26 - and 2D.
02:27 - But today we'll be
talking about colliders
02:29 - and triggers-- things
like the helicopter
02:30 - colliding with coins, and buildings,
and other planes that are flying.
02:34 - Each of those has to have a collider.
02:37 - And certain things have to be
considered triggers in order to trigger
02:40 - certain behavior with other entities.
02:43 - Prefabs and spawning-- prefabs
is a huge concept in Unity.
02:46 - So prefabs are basically
prefabricated objects
02:48 - that you can customize as you want
to-- lay them out in the editor,
02:52 - rather than having to
necessarily code all the details.
02:55 - And then you can instantiate
them in the actual scene,
02:58 - via code programmatically, in a way
that fits the model you're striving for.
03:02 - Texture scrolling is something
we'll look at briefly, because it's
03:05 - the way that we accomplish the infinite
scrolling aesthetic or behavior.
03:09 - And we'll look at how we can
do that in a different way
03:12 - than we've done before,
using u-v coordinates,
03:14 - and specifically looking
at materials, and modifying
03:17 - certain attributes of those materials.
03:20 - And lastly, to tie everything
together as we've done before,
03:23 - we'll look at audio-- things like
audio listeners and audio sources--
03:26 - what the difference is
between them, and how
03:28 - to add them easily to our game project.
03:30 - But first, a demo-- if
there would be anybody
03:32 - willing to come up and take a look
and play the 3D helicopter game that I
03:35 - put together, that would be awesome.
03:37 - Anybody?
03:40 - Steven?
03:41 - Awesome.
03:42 - Thank you so much.
03:44 - Let me go ahead and actually get it--
03:46 - so I've pre-built it.
03:48 - So let me go ahead and.
03:52 - So the nice thing about Unity is,
it exports to multiple platforms.
03:55 - And right out of the
gate, you can get just a--
03:57 - I didn't put an icon for it.
03:59 - But you can create just a
native application very easily.
04:02 - And so whenever you're
ready, go ahead and hit Play,
04:05 - and Up and Down will
move your helicopter.
04:12 - So this is the 3D helicopter game.
04:14 - And I don't think we have sound
live, but there should be audio.
04:18 - Oh, I might have actually-- here we go.
04:20 - [MUSIC PLAYING]
04:21 - There we go.
04:22 - That was my bad.
04:23 - So there is music playing.
04:24 - There's sound effects.
04:25 - So notice that we have a 3D model.
04:27 - This is what's called a 2.5D game.
04:30 - So even though everything is in 3D--
04:33 - the models and so forth--
04:34 - the actual axes upon which
we're bound are just two.
04:38 - We're just bound to, I
believe, the x and the y.
04:40 - Could be the z and the x.
04:41 - I don't recall offhand.
04:42 - But we're bound to just
simply two axes of movement.
04:45 - But all the models, as
we can see by the camera,
04:48 - are in 3D, including our helicopter.
04:50 - So we have a few things going on.
04:51 - We have skyscrapers
that are scrolling by.
04:54 - We have coins that are also going by
at the same speed as the skyscrapers.
04:58 - We have a background that
is infinitely scrolling.
05:02 - We have, of course, our helicopter
which has a rotating set of blades.
05:07 - And when we collide with a coin,
notice that we get a little--
05:10 - it might be hard to see in house,
but we have a little particle
05:13 - effect that plays.
05:15 - There's airplanes that
are flying up top,
05:17 - so we're instantiating those,
as well, to fly past us
05:20 - to provide another layer of obstacle.
05:22 - And if we collide with an airplane,
notice that we get de-spawned,
05:26 - and then we trigger another particle
effect to imitate an explosion.
05:29 - And then, notice we also have
a couple of other elements.
05:32 - We have a GUI.
05:32 - We have two GUI elements-- a
coin total at the top right,
05:36 - and then a game over here in
the middle of the screen, which
05:38 - only shows up once we have died.
05:41 - And the explosive behavior-- if you
want to collide with a building,
05:45 - you'll see that.
05:46 - It also triggers when you
collide with a building.
05:48 - So there's two things looking for these
explosions-- the airplanes up top,
05:52 - and the buildings below.
05:53 - Those are our two obstacles.
05:55 - But when they collide with the coins,
we should increment our coin total,
05:59 - and then display a
different particle effect.
06:01 - And then this goes on ad infinitum.
06:02 - You can press Space to restart.
06:04 - So we have keyboard input
that's based on what
06:06 - we press, different things happen.
06:09 - And so that's effectively the
demo that I've put together today.
06:11 - So thanks, Steven.
06:12 - I appreciate you coming up to demo it.
06:17 - So that's the 3D helicopter game.
06:19 - It's got most of the same mechanics
as the web version from before--
06:24 - I would say, maybe even more features
just to illustrate a few new concepts.
06:29 - But that's effectively what
we're going with today.
06:31 - We're just a pretty simple, Flappy
Bird esque differently-themed game,
06:37 - based on the same principles.
06:38 - Fly forever, avoid obstacles.
06:40 - And in this case, even
get little collectibles.
06:43 - And so notice that there are
also effectively two states
06:46 - in our game, which are just the playing
state, and then the game over state.
06:50 - The two are almost effectively the same.
06:52 - The only real difference is that one
doesn't have the helicopter present,
06:56 - and displays a different GUI
element in the middle of the screen.
07:00 - If you haven't downloaded Unity
already, there's two links here.
07:02 - So the top link is just
the catchall download link.
07:06 - And then the second
link is the beta link.
07:08 - So we're actually using
the beta in this course,
07:10 - because Unity has started
transitioning away
07:12 - from a numerical system
for their releases,
07:15 - and is now going yearly
with their releases.
07:17 - So the last long-term release
candidate was 2017's version.
07:22 - But now that we're almost
halfway through 2018,
07:25 - the newest beta is the 2018 version.
07:27 - It has a bunch of new features.
07:28 - So go ahead and check that out.
07:30 - And everything's been well
tested, and runs very well--
07:33 - very smoothly on Windows and Mac--
07:36 - with the new beta.
07:37 - So what is Unity?
07:40 - The difference between what we've done
so far and what we're doing today is,
07:43 - now we're actually using a
full-fledged game engine--
07:46 - this system.
07:47 - It's got a built in editor
and all this awesome, cool
07:49 - functionality that we really
didn't get with Love2D before.
07:52 - What we were doing before
was using a framework,
07:54 - and just implementing
everything purely in code.
07:56 - And as we'll see today, everything
that you want to do that's customizable
08:00 - effectively is--
08:01 - or can be-- done via code.
08:03 - But there are a lot of more
efficient and more user-friendly
08:06 - ways to accomplish the same
thing, which we'll take a look at.
08:09 - So Unity has a tremendous
market share right now.
08:12 - I forget.
08:13 - I think in 2016 it had like 43% of
all games released were done in Unity.
08:19 - I don't know what the
current numbers are.
08:21 - I couldn't find them.
08:22 - But there are other engines
that are also very well used--
08:25 - Unreal being among them.
08:26 - And Unreal actually may
have more market share now,
08:28 - because of games like
Fortnite, and because it's
08:30 - been improved a lot over the last couple
of years, and really marketed well.
08:35 - But Godot, CryEngine-- there
are a lot of game engines
08:38 - that are similar to
this that provide you
08:39 - this all-encompassing way of
dealing with your game scene
08:42 - and with all your game data.
08:44 - But Unity is a very easy engine
to start getting used to,
08:48 - and cranking things out,
and being productive with,
08:51 - without the tremendous
learning curve that some
08:54 - of the other engines
like Unreal might have.
08:56 - Unreal does have a more
user-friendly way of doing things.
08:58 - But if you want to get down into
the nitty gritty with Unreal,
09:02 - you're coding in semi-arcane C++.
09:05 - So for folks who aren't used to it and
aren't used to 3D game development,
09:08 - it can be kind of a
large board to get onto.
09:11 - The nice thing about
Unity, aside from the fact
09:13 - that it's fairly easy to get
started with, is that it's free.
09:16 - And you can use it completely
with all of its features
09:19 - until you start making over $100,000 in
gross revenue releasing Unity products.
09:26 - And then there are other tiers.
09:27 - The next tier above that is
if you start making $200,000,
09:30 - and you get new features
with these other tiers.
09:33 - But if you want to just
start up a new company,
09:35 - and use Unity, and take
something to market--
09:38 - completely free to do so.
09:39 - And once you get over $100,000,
that's a good problem to have.
09:41 - It's not necessarily
too much to ask to start
09:44 - paying Unity to use it
as a means of getting
09:48 - onto the market in the first place.
09:49 - And especially in mobile and VR,
Unity's sort of like the forefront.
09:55 - It's got even higher percentage.
09:56 - It's like 60-something or
70% market share on mobile.
10:00 - And then VR-- from the beginning,
it's marketed itself very strongly
10:05 - towards the use of VR.
10:06 - And we'll actually use
VR in the next lecture.
10:10 - And the way in which we will accomplish
all of the programmatic aspect
10:14 - of this-- getting things
actually implemented in code--
10:17 - is via C#, which is very different
than what we've used so far,
10:20 - which we've used Lua, which is
a dynamic scripting language,
10:23 - very much like JavaScript.
10:25 - So C# is very similar to Java, in
which things actually have types.
10:30 - And so here's a couple of screenshots
of what the Unity editor looks like.
10:34 - So the nice thing about the
Unity editor, actually--
10:36 - which we can see right
off the gate here--
10:38 - is that it's very customizable.
10:40 - So on the top, that's the default view.
10:43 - You have a bottom panel that
shows you all your resources,
10:46 - all your assets, things like
scripts, and shaders, and models,
10:49 - and textures, and sounds.
10:50 - You have a nice file browser there
on the left-hand side, which allows
10:53 - you to easily navigate your project.
10:55 - You don't have to go looking through
your Windows or Mac computer, using
10:58 - your finder, or whatnot,
or your File Explorer,
11:00 - and actually look
through all your files.
11:02 - You get a nice view there,
so that you stay integrated
11:05 - within the Unity ecosystem right there.
11:08 - On the right-hand side, you can see
all the behavior for whatever objects
11:11 - you might have in your scene.
11:12 - You get a nice big scene view.
11:14 - So rather than having to
run your game live, and look
11:17 - at the behavior that
way, you can actually
11:19 - see in advance what your
scene looks like, and analyze
11:22 - your game objects that
way, and their appearances,
11:25 - and whatever you want to do with them.
11:27 - And lay them out
perfectly, rather than have
11:29 - to programmatically figure things out.
11:31 - And on the left-hand
side there, you can see
11:33 - a full list of all the game objects.
11:35 - And then on the bottom
right screen shot,
11:36 - you can see that the editor
is heavily customizable.
11:39 - So you can lay things
out however you want
11:41 - to to fit your style of development.
11:43 - I often like to have a panel on
top, which shows me my scene view,
11:47 - but then have a panel right below
that, that shows me the game view.
11:50 - So if I'm actually running a
game and seeing it happen live,
11:54 - I can also see it in the scene,
and rotate around in this god mode
11:58 - that you can get in a lot of games.
12:00 - And actually analyze
and see things that way,
12:03 - and analyze their
behavior frame by frame,
12:05 - even if I want to, in a way
that's not possible with however
12:08 - I might have coded the camera
in the actual game itself.
12:13 - So C#.
12:14 - So has anybody in here
used a static language,
12:17 - or is familiar with
statically-typed languages
12:19 - versus dynamically-typed languages?
12:21 - [INAUDIBLE], Steven.
12:23 - So what languages have you guys
used, just out of curiosity?
12:27 - Steven.
12:28 - STEVEN: Java, C, C++.
12:29 - COLTON OGDEN: Java, C, C++.
12:30 - Donny?
12:31 - DONNY: [INAUDIBLE]
12:31 - COLTON OGDEN: C and C++.
12:32 - OK.
12:32 - So to you guys, this
will be pretty similar.
12:35 - So C# is very similar to Java.
12:38 - Almost looks identical at first glance.
12:40 - There are some features
that are different.
12:42 - But it was Microsoft's
initiative to compete with Java.
12:49 - It's a Microsoft language,
first and foremost.
12:51 - But there are ways to run
C# code on other platforms,
12:55 - primarily with the use
of what's called Mono.
12:57 - So Mono is an open source implementation
of what's called the CLR--
13:01 - the common language runtime--
13:03 - which is how Microsoft allows several
of its languages, like F#, and C#,
13:09 - and Visual C++, Visual Basic.
13:12 - They all compile to this
intermediary format,
13:15 - like how Java compiles to bytecode.
13:17 - And you can run any of
those languages' code--
13:21 - their version of the
bytecode-- with the CLR.
13:24 - Mono-- what Mono is,
and what Unity relies on
13:27 - to allow its use across
multiple operating systems,
13:30 - is a CLR that's not
just Windows specific.
13:33 - It actually runs on Mac and
on Linux machines, as well.
13:37 - And you'll actually see evidence of
its existence via the nomenclature used
13:43 - for Mono behavior.
13:45 - So within Unity, there's
this thing called a Mono
13:47 - behavior, which we'll take a look at.
13:49 - From the beginning, actually, Unity
was developed for Mac platforms
13:53 - exclusively.
13:54 - But in 2012 or 2011 they ended up making
it usable across all major desktop
14:00 - operating systems.
14:02 - But C#-- suffice to
say, very similar Java.
14:04 - We'll look at its syntax.
14:05 - But it's different from Lua in
that, with Lua, you could just say,
14:09 - oh, x equals 10, or object
equals-- and then create
14:14 - a table with whatever you want.
14:16 - C# is a lot less flexible in this sense,
in that you have to actually tell it
14:20 - in advance what each data type
is that you're trying to make.
14:23 - So you can't just create
a table or a integer.
14:26 - You actually have to say, int
my_int, or x equals, and then 10,
14:31 - and then semi-colon.
14:33 - So there's also more
syntax to be conscious of.
14:37 - And so really quickly, I can show
you just what some C# looks like.
14:41 - We'll take a look at
this again going forward.
14:43 - But as you can see here, we have public.
14:46 - So that's another thing about C#.
14:49 - In Java, if you're
familiar with Java, they're
14:51 - object-oriented programming languages.
14:54 - And as such, there are objects
that are public and private,
14:59 - and you have access specifiers for
different variables and classes
15:04 - that will tell other variables
and classes whether or not
15:06 - they can communicate effectively.
15:08 - So public class just means effectively
anybody can see this class.
15:12 - Other classes can see this.
15:15 - But then you have--
15:17 - see if I have one of these
that has a private variable.
15:21 - I know there's at least one.
15:22 - Here we go.
15:23 - So private, Text, text
here, for example.
15:25 - So first of all, notice that
these are variable declarations
15:27 - like we've seen before.
15:29 - We're saying, this is a
variable that I'm going to use.
15:32 - In this case, public
GameObject helicopter.
15:34 - So I'm just defining it.
15:36 - Or I'm declaring it.
15:37 - I'm not defining it.
15:38 - It doesn't equal anything yet.
15:40 - But I'm saying, this is
going to exist, right?
15:43 - You can say equals something, and
then define it on the same line.
15:50 - But in this case, we are just declaring
in advance what different variables
15:55 - we're going to need later on.
15:57 - Like for example, here.
15:58 - We see, in our start method.
16:00 - And we'll go over what all these
methods are and how they're relevant.
16:03 - But we can see here, text equals--
16:05 - and then we're calling some
function called GetComponent.
16:08 - And then we have some
funky syntax here--
16:10 - less than, Text, greater than--
16:12 - and then function call syntax--
16:15 - two parentheses.
16:16 - So we can see that
there's a lot more syntax.
16:19 - But all of the same
principles still hold true.
16:22 - It's still much the same way
to think about programming.
16:25 - It's just, there's a little
bit more to stay conscious of.
16:28 - And we trade off this
dynamism for more performance.
16:32 - So that's ultimately what it comes down
to-- static versus dynamic languages,
16:35 - you're trading flexibility
for performance, in this case.
16:39 - Though C# obviously is
a lot faster than Lua.
16:42 - We can do a lot more with it.
16:44 - And actually, Unity isn't
itself programmed in C#.
16:47 - Unity itself is programmed in C++.
16:50 - But it allows us to program any
behavior that we want to with C#.
16:58 - All right.
16:58 - So that's a look at C# so we can see
also what I was alluding to up here.
17:04 - We have our private, public,
and we do things with them.
17:08 - And then, depending on what
we've declared public or private,
17:12 - these things also
transfer into the editor.
17:14 - We'll see how all of
that comes together soon.
17:16 - But suffice to say, that's a
look at C#-- what it looks like.
17:19 - And we'll use it, and we'll
get comfortable with it.
17:21 - But it's a little bit different
than what we've done thus far.
17:25 - Away from programming, we'll a
very brief look at what Blender is.
17:29 - So I have it installed here.
17:31 - And this isn't required for the course.
17:33 - I will provide you with all
the models and all the assets
17:36 - that you need to get working.
17:39 - But this is what Blender is.
17:40 - So Blender almost looks, at first
glance, very similar to Unity.
17:46 - The big difference is, this
is meant to create new assets.
17:50 - And technically, Blender does
have a built-in game engine,
17:53 - but it's not used for
that purpose very much.
17:55 - But the sole purpose that we
would be using it in this course
18:00 - would be just to create new 3D models.
18:01 - So as you can see here, I can click on
these vertices, and move them around.
18:06 - And I'm not a guru by any stretch of the
imagination when it comes to Blender.
18:12 - But the helicopter, and
jet, and skyscrapers,
18:15 - and those kind of simple models,
I made all of those in Blender.
18:18 - And those are bundled
with the project, if you
18:21 - want to take a look at
how those are implemented.
18:23 - And you can download Blender at the--
18:25 - I forget what the exact
link is, actually.
18:27 - Let's take a look.
18:28 - Blender dot org.
18:33 - And then, if we just go
down here, download Blender,
18:36 - 2.79 looks like the most recent version.
18:39 - Blender 2.8-- I guess
it's in development.
18:42 - But there's nothing concrete
about that on the front page.
18:45 - But yeah.
18:45 - If you want to model 3D
assets, and you're curious,
18:48 - and you want a free piece
of really awesome software,
18:51 - can't recommend Blender enough.
18:53 - But like I said, I'm going to spend
too much time on it, because it's not
18:57 - something that will actually
be required in the course
18:59 - to implement 3D models,
to create 3D models,
19:02 - since I'll be providing all of that to
you in the project in the GitHub repo.
19:07 - And so here is a screenshot
of basically what we just saw.
19:10 - So the fundamental part of Unity.
19:13 - So first of all, let's take
a look at the Unity editor.
19:17 - So we can see here much of
what we saw in the screenshots.
19:20 - But here, I am live
looking at my scene, right?
19:24 - I have a helicopter.
19:25 - I have this background back here.
19:27 - I have a camera--
19:28 - that's right here.
19:30 - You can see that it's a camera, because
it's got the little camera icon.
19:32 - But it's effectively just
an invisible game object.
19:34 - It's not actually going to be
rendered to the screen ever.
19:38 - And notice that there are no
skyscrapers, no coins, no jets,
19:42 - or anything like that.
19:43 - Those are all instantiated dynamically.
19:45 - But this is the beginning of our scene.
19:47 - And it's all laid out in advance.
19:48 - And we can see here with
this camera preview--
19:50 - which is kind of hard to see
because it's really small--
19:53 - but here's a larger view
of what it looks like.
19:56 - And then we've got a GUI element
here, we've got coins here.
19:59 - We have our helicopter.
20:00 - But all of this is a marked
difference from what we've gotten
20:04 - used to, which is, program
everything, and sort of load it,
20:07 - and, oh, did I put this
in the right position?
20:09 - No.
20:09 - I didn't.
20:10 - So I got to.
20:10 - If I wanted to come
over here and just move
20:13 - the helicopter a little bit which--
20:15 - like that.
20:16 - Whoops.
20:17 - I just triggered it.
20:17 - If you click on
something, by the way, it
20:20 - will play any particle systems
that are associated with it.
20:23 - So you can actually get a
preview for those, as well.
20:25 - But I can easily just move
it here, to the right,
20:27 - or to the left, before
the game actually starts.
20:30 - And if I click on the
camera, we can see it there.
20:33 - It's a little bit shifted to the left,
as opposed to what it was before.
20:37 - But if I just press Command-Z couple
of times, take it back to normal.
20:41 - So game object is an important concept.
20:44 - So a game object is basically
everything in Unity.
20:49 - So the camera is a game object.
20:51 - The helicopter, which is
right here, is a game object.
20:54 - Everything, by the way, that you
want to see in your scene in Unity
20:57 - is on this left-hand
hierarchy right here.
20:59 - So helicopter, the game object.
21:02 - There's got to be a light
source in a 3D scene in order
21:05 - for you to actually see things.
21:06 - So directional light--
that's a game object.
21:09 - Background skyscraper spawner--
we don't see it anywhere.
21:12 - But that's also a game object.
21:13 - It's just an invisible one.
21:15 - A coin spawner.
21:17 - There's something called a canvas,
which if we double-click that,
21:20 - we can see we have this obscenely
large GUI here that, paradoxically,
21:26 - isn't on top of our scene.
21:29 - Unity does a very interesting
thing with all of its GUI elements,
21:33 - in that it basically maps
the canvas to one pixel
21:40 - being equal to one Unity unit, which
is usually equivalent to a meter.
21:44 - And it draws this in a
different draw call than it
21:48 - draws all of the actual 3D stuff--
21:52 - all the stuff that's down here,
basically-- in World Space.
21:55 - So when you create a canvas
and you see it's gigantic,
21:59 - that's just Unity's way of doing GUI.
22:01 - It's strange.
22:03 - But apparently they do it
for performance reasons,
22:05 - because they don't have to calculate
like fractional points of where
22:08 - the UI is supposed to be in World
Space, which can get really small.
22:13 - But the canvas is a game object.
22:18 - Notice that helicopter has children.
22:21 - It's got blades, a body, and then a
blades collider, which actually could
22:24 - have been part of the blades object.
22:26 - Canvas itself has two children--
coin text and game over.
22:30 - And those are the text on the top
right, and "game over" in the center.
22:34 - So those are just two
text objects, which
22:38 - are labels, that we can just populate
with whatever text data we want.
22:43 - The event system is an object.
22:45 - That just gets added to your scene
automatically when you add a canvas.
22:49 - Airplane spawner, explosion
particles, and explosion sound.
22:52 - So we have all these different objects.
22:54 - They're all part of our scene,
and they all do different things.
22:58 - But at the core, they're
just game objects.
23:00 - That's the core-- like the bottom type.
23:03 - Yes?
23:04 - AUDIENCE: So I would imagine
you're not actually using
23:07 - a helicopter [INAUDIBLE].
23:11 - COLTON OGDEN: Correct.
23:12 - AUDIENCE: So should you
actually reset the position
23:16 - of the background [INAUDIBLE]?
23:20 - COLTON OGDEN: So the question
was, since we are maintaining
23:25 - a consistent position with the--
23:28 - I'm going to try and
scroll in, there we go.
23:30 - The nice about Unity 2
is, if you right click,
23:32 - you can use W-A-S-D to
move around the scene,
23:34 - which is super easy and convenient.
23:37 - But the helicopter
here stays in one spot.
23:40 - And the camera always
stays in one spot forever.
23:43 - So do we move the
background image, like we
23:50 - do in our Love2D
implementation of Flappy Bird,
23:54 - where we reset its position?
23:55 - And the answer is--
23:57 - I will play it right now in scene
view, and let you decide for yourself.
24:03 - So let's go to Window.
24:04 - I'm gonna go to Layouts.
24:06 - So I like the two by
three, like I said before,
24:08 - so you can see the scene and the
game running live at the same time.
24:14 - I'm going to move my camera
in the scene so that I'm
24:16 - looking at this from back here.
24:21 - And then I'm going to play the game.
24:26 - [MUSIC PLAYING]
24:29 - But so.
24:32 - Here's where we-- I'm just
going to hold it still.
24:37 - So what do we think is happening?
24:40 - Does it look like our thing is moving?
24:42 - Or is it staying still?
24:46 - It is staying still.
24:48 - Any guesses as to how
we're achieving this?
24:52 - Changing the texture.
24:54 - We are scrolling its texture.
24:58 - So when you take a texture
and apply it to a 3D surface,
25:01 - you map the texture coordinates to
the 3D coordinates of the object
25:08 - that you want to render.
25:09 - It's called UV Mapping.
25:11 - They call it UV, because usually,
when you're dealing with 3D objects,
25:14 - you have your x, y, z.
25:15 - And then you want to think of your
texture separately from the 3D objects.
25:18 - So you use u, v instead of x, y,
since you already have x, y, z
25:21 - allocated for your 3D object.
25:27 - Basically, there's an
offset part of the texture--
25:32 - the material that holds the texture--
25:34 - there's an offset field that
will reposition the UV mapping
25:39 - of that texture onto the 3D surface.
25:43 - And when you offset it, it will
just sort of wrap itself around,
25:47 - if that makes any sense.
25:49 - So what we do is we--
25:51 - and I can actually show you
in the code where this is.
25:53 - This is going to be mentioned
at the end of the lecture.
25:55 - But we have the scrolling
background component here.
26:01 - And there's this thing on each
material called a texture offset,
26:06 - which basically shifts the UV mapping
of your texture to your 3D object.
26:10 - And so, by setting that texture
offset to some value offset,
26:14 - which is very similar to
what we've done before.
26:17 - Notice that offset is just
scroll speed times time--
26:21 - Time.time, in this case.
26:23 - And I don't mean to overwhelm with,
necessarily, all the details here.
26:26 - But the bigger picture is
that we're taking time--
26:29 - the amount of time since the
beginning of the game is started--
26:33 - and we have some scroll speed
that we've pre-determined.
26:36 - And we can just scroll
the texture offset here.
26:40 - We're just placing it here at the x.
26:41 - So this new Vector2, offset 0--
26:44 - just think of these two as an x and y--
26:46 - a vector 2, vector 3.
26:47 - Vectors are just
combinations of numbers.
26:50 - So 1, 2, 3, 4-- however many you want.
26:52 - A Vector 2 offset in 0.
26:55 - So we don't want to
scroll on the y-axis.
26:57 - We just want to scroll left to right.
26:59 - So we're going to apply no
texture offset to our y-axis,
27:03 - but we want to apply a
texture offset to our x-axis.
27:06 - So that's what their offset there is.
27:09 - And I included it also here--
27:11 - notice there's a Bump
Map texture offset.
27:13 - There's no Bump Map
actually on our texture.
27:16 - So a Bump Map is effectively--
27:17 - I can maybe find a good
Google image for it,
27:21 - if you're not familiar with a Bump Map.
27:25 - Let me go in here.
27:30 - I'm going to hope that there's no shady
images on Google Images, but a Bump
27:35 - Map--
27:37 - can we see it?
27:37 - Well, it's kind of hard to tell.
27:41 - But in a lot of 3D games, you'll
see like bumpiness and shininess
27:46 - on surfaces.
27:47 - And that's accomplished the majority
of the time using Bump Mapping.
27:51 - Because obviously, if you were to model
every single tiny little bump or model
27:55 - in a surface, it would get extremely
difficult to render large objects.
27:59 - Because you're looking at
thousands of polygons for a surface
28:02 - that was actually this
detailed in a game.
28:06 - So what you do is, you take
what's called a Bump Map,
28:09 - and the Bump Map gets--
28:11 - during lighting, it will effectively
skew the surface normals of a 3D mesh.
28:18 - So effectively, it will pretend as if
your 3D mesh has a bunch of bumps in it
28:23 - for the lighting.
28:26 - Only for the lighting.
28:27 - And so when it gets lit, and it gets
shaded, it looks as if it's bumpy,
28:32 - but you're still dealing with
a completely flat, completely
28:35 - simple cubic mesh in this case,
or whatever mesh you want.
28:39 - And so the long story
short, here, if you
28:43 - wanted to include a Bump Map on
whatever surface you want to scroll,
28:45 - or if you want to edit
the Bump Map, this
28:47 - is here just because you can also
manipulate the Bump Map texture offset.
28:52 - It's an included field in a material.
28:58 - So any questions as to
how this works at large?
29:02 - We still have a lot to cover before
we go into a lot of the specifics.
29:06 - But conceptually, do we
understand how this sort of works?
29:11 - OK?
29:12 - Cool.
29:12 - So let's go back to the slides.
29:18 - Right.
29:18 - So we were talking about game objects.
29:20 - So all of those things that we
saw before were just game objects.
29:25 - So let's go back to the default layout,
and then we can look back at our scene.
29:32 - So this is our scene.
29:33 - All of those things were
all of our game objects.
29:36 - Those are ultimately containers.
29:38 - I talked about this in a prior lecture.
29:39 - But this is the beginning of an entity
component system, in which case,
29:43 - these game objects are our entities.
29:45 - They are the entity class--
29:47 - container class-- for
what drives behavior.
29:50 - And the thing that allows us to
actually get interesting behavior out
29:55 - of this sort of abstraction
is the use of components.
29:59 - And we'll talk about that.
30:01 - So components are all of the
things on the right-hand side,
30:05 - by default of the Unity editor.
30:07 - So if we're looking at
our camera, for example,
30:09 - and we take a look at all
these things on the right,
30:12 - we can see that we have
something called a transform,
30:14 - we have something called a camera.
30:16 - A GUI layer deprecated,
so that's by default.
30:19 - It was imported from a
prior version of Unity,
30:21 - so you could actually delete this.
30:23 - A flare layer, which we're not using.
30:26 - An audio listener-- I believe that
comes with all cameras by default,
30:29 - though, in case you do want to use it.
30:30 - An audio listener and an audio source.
30:33 - So all of these different
pieces are components.
30:37 - They are what drive the
behavior of this game object.
30:40 - We can create just a brand
new, empty game object-- oops,
30:43 - I created it as a child.
30:45 - We can create a brand new,
empty game object here.
30:48 - It's just a game object in our scene.
30:51 - And it's right where our mouse is.
30:55 - Well, it's right here.
30:56 - And it does nothing.
30:59 - It has one component.
31:01 - And that component is the transform.
31:03 - Anybody guess what a transform is?
31:08 - Yeah.
31:09 - AUDIENCE: Is that position,
rotation, scale, et cetera?
31:11 - COLTON OGDEN: Yes.
31:12 - It is the position, rotation,
and scale of a game object.
31:16 - Something that was before
put into six fields--
31:20 - or in this case, nine
fields, potentially, or maybe
31:22 - three fields with children, is now
an object that we can modify at will.
31:29 - Well, it's a component
that we can modify at will.
31:32 - So if I do this-- notice,
I'm just scrolling the x.
31:36 - It's just moving that transform, which
is just the position of that object.
31:40 - And Unity knows to look at
the transform component,
31:44 - and render our object based
upon where its transform lies,
31:47 - rather than us having to manually
set all these things, which we still
31:51 - can do in the code.
31:52 - We can just modify them
in the Unity editor
31:55 - directly via a graphical interface.
31:57 - It's just an interesting,
helpful layer of abstraction.
32:01 - So a transform is a component--
a camera, in this case.
32:05 - It's just a component.
32:06 - We can attach this to anything we
want to, and it becomes a camera.
32:09 - And then we can set it to be
either the default camera or not.
32:13 - The camera has a bunch
of different things.
32:15 - And I can't claim to know all
of the fields of every object
32:18 - in Unity, because there's just
a tremendous number of things.
32:21 - But clear flags,
background, culling mask--
32:24 - all these things that are relevant
to how the camera does its job--
32:29 - they are all things that
we have complete access
32:31 - to here in the Unity editor.
32:32 - We don't even need to touch code,
really, for a lot of things.
32:36 - An interesting fun thing
we can take a look at
32:38 - is if we go to Layouts-- go back to two
by three, and take a look at our game
32:43 - again.
32:44 - So we have our camera currently
looking at the screen here.
32:51 - It's just always in one spot.
32:52 - And it has a way of
projecting the scene.
32:55 - It can do one of two things.
32:57 - It can be perspective projection
or orthographic projection.
33:03 - Does anybody know what the difference
is between the two, at least visually?
33:08 - So perspective
projection-- what that does
33:11 - is it models how real cameras, real
lenses, the human eye, et cetera,
33:15 - behave in real life.
33:17 - Things distort a little bit.
33:19 - And so you see things, depending
on where you're looking at them,
33:22 - they look wider or skewed, and
not completely geometrical,
33:27 - like you would if you were just to
draw them at a certain distance.
33:31 - Things have vanishing points, et cetera.
33:34 - Orthographic-- things
look a lot different.
33:36 - So notice instantly, so we
can see here, perspective
33:40 - doesn't really change a whole
lot visually with our helicopter.
33:44 - Things do change a little
bit with the background,
33:46 - because the view angle is
different between the two--
33:50 - the perspective and the
orthographic camera.
33:52 - But if we make this a little bit larger.
33:55 - So I'm going to increase
the size like that.
34:02 - And I play.
34:05 - One thing we'll notice--
34:06 - what's the first thing
that folks are noticing?
34:10 - You can actually see the difference
between the top and the bottom.
34:14 - Whoop.
34:16 - How, in particular, I'll put your
attention towards the buildings.
34:20 - How do the buildings differ?
34:22 - AUDIENCE: You can't see the side.
34:23 - COLTON OGDEN: You can't
see the side anymore.
34:27 - The lens sort of curves a bit.
34:30 - And so I'm not entirely familiar
with all the math involved.
34:34 - But at the end of the day, what it boils
down to is, with a perspective camera,
34:38 - you can actually gauge
things as distance
34:40 - relative to each other
a little bit better.
34:42 - With a orthographic camera,
everything is completely flat,
34:45 - and no matter how far
away from you it is
34:47 - on the access that's completely
perpendicular to you,
34:51 - it's going to look the exact same.
34:53 - So these buildings are always going to
look the exact same, no matter how far
34:55 - away they are, no matter
which position they are.
34:57 - Because everything is just
looked at completely flat.
35:00 - And the view matrix is
calculated in a different way.
35:06 - And so, just with a
simple button, you can
35:09 - change how your game looks completely.
35:12 - You've probably seen a lot of games.
35:13 - I believe Crossy Road does everything
with a orthographic camera,
35:17 - versus a perspective camera.
35:18 - It has a very distinctive
look, especially
35:21 - once you skew things a little bit.
35:23 - But that's just one thing
that you can change just
35:26 - without having to touch
a single line of code--
35:28 - how your game looks via just
the camera's implementation.
35:32 - Let's take things back to how it was.
35:36 - And there's a lot of things
like the field of view.
35:38 - So if you want to see
more of the game world.
35:40 - So things like in Quake
and other shooters,
35:42 - you can change this view,
usually in your menu settings,
35:46 - just so you can see more around you.
35:49 - And it looks a little like
a fisheye lens a little bit,
35:51 - depending on how you do it.
35:52 - And that's just more distortion
of the perspective projection.
35:58 - Yeah.
35:59 - All of these things, they all have--
36:00 - I don't know necessarily what
every single one of them does,
36:03 - just because there's
just a lot involved.
36:05 - And generally, you don't have
to mess with it too much.
36:07 - It just ultimately depends on what you
are trying to accomplish in your game.
36:11 - And you'll end up finding
specific areas of the editor
36:14 - and specific areas of the
code base and documentation
36:16 - that you dive deeply into.
36:18 - But this essentially is what a
component affords you the ability to do.
36:23 - When you create a component and
you attach it to a game object,
36:26 - you can easily not only
combine different things
36:29 - to create this emergent new
behavior and combination
36:33 - of behaviors for your game objects.
36:36 - But Unity allows you, via different
ways of programming the components,
36:40 - to modify them, depending on how
customizable you want them to be,
36:45 - in the editor itself.
36:46 - So you don't have to
touch any of this in code.
36:49 - You can just go into
the editor and quickly
36:51 - whip things up because of the way that
you've modeled all your components.
36:55 - And so we see other things
like the audio listener.
36:58 - An audio listener is something that
will literally listen for audio,
37:01 - and play it back like a
microphone to the game player.
37:04 - And then an audio source is
an actual source of audio.
37:07 - And so it will play that
audio at the location
37:09 - of whatever that game object is.
37:11 - So we've combined all these things.
37:13 - So now we have a camera that
is projecting everything
37:17 - with perspective projection.
37:19 - And it's an audio listener, so it's
going to listen for audio in our scene.
37:24 - And it's also going to play an
audio source and listen to itself.
37:29 - And that's just the beginning.
37:30 - We have a whole bunch
of other components
37:32 - here, which we can take a
look just really quickly.
37:35 - So the directional light
has a light component.
37:39 - And so a light, you can
do all kinds of things.
37:41 - You can make a spotlight,
directional light, point light.
37:44 - All these look a little bit differently.
37:46 - You can make it have a specific color.
37:48 - So maybe if you wanted a really dark
scene, you could have a dark light.
37:53 - Or you could even emulate dawn
or dusk with an orange light.
37:57 - That's sort of how you'd
go about doing that.
38:01 - You can bake your lighting, which
means that you just pre-compute it,
38:04 - so that you don't have
to render it in real time
38:06 - when you actually play it on hardware.
38:07 - A lot of different things,
a lot of different settings.
38:09 - We don't have time necessarily
to go into all of them.
38:11 - But looking through
all of these, you can
38:13 - see all these game objects are just
combinations of these components.
38:17 - And those combinations of components
are responsible for the behavior
38:24 - that we get in our game.
38:25 - That's the ultimate essence of what
Unity is, and how it does what it does.
38:29 - And to illustrate the difference,
we've talked about this before.
38:32 - This is an inheritance
chain, where Monster
38:35 - inherits from Creature, which then goes
to Goblin, Goblin Chief, Elite Goblin
38:38 - Chief.
38:39 - In Unity, you could
create a game object,
38:42 - and then give it a creature component,
a goblin component, a patrol component--
38:47 - right?
38:47 - So maybe you want
different things to patrol.
38:52 - In Unity, it would be
kind of complicated.
38:53 - But you could create
basically a pathway,
38:57 - and then have your entity follow
that pathway at a specific time.
39:02 - And then, depending on
how you've programmed it,
39:04 - you could specify all these different
characteristics in the editor.
39:07 - So you could just say
on the editor, OK, I
39:09 - want you to go patrol from
this range to this range.
39:12 - And I want you to do it with this
length of time, pause for this long--
39:15 - right?
39:16 - And then you can give that
to anything in your scene.
39:18 - You could make a camera
patrol if you wanted to,
39:21 - and then have that be demo code
for the beginning of your game.
39:24 - The flexibility is just insane.
39:26 - Elite component.
39:27 - Right?
39:27 - If you want, maybe, certain enemies
or certain objects, if they're elite,
39:31 - maybe they shine bright.
39:32 - And maybe they drop more
experience or something.
39:34 - A chief component maybe has better
weaponry than a non-chief component.
39:38 - And then a toxic component, maybe,
is an enemy that, when it dies,
39:41 - it sprays toxic gas or toxic
liquid all over the place.
39:46 - But the flexibility is there.
39:48 - You can ascribe any component to any
object to get any sort of behavior
39:52 - that you want to.
39:53 - It's on you, of course, to implement
all these components, right?
39:56 - You're not going to
get all these for free.
39:57 - You're going to get a lot for free.
39:59 - Unity gives you a ton of
components-- really good components.
40:04 - But you're ultimately going to
need to program your game logic.
40:07 - And so you'll have to implement
all these things-- elite,
40:10 - goblin, what it means
to be all these things.
40:12 - But thankfully, it's
not terribly painful.
40:15 - The way at which we go about doing
all of this-- and by the way,
40:19 - are there any questions so far
as to how Unity's model works,
40:23 - the difference between
composition versus inheritance,
40:25 - anything we've talked about this far?
40:28 - All right.
40:30 - The way at which we actually go
about making our own components,
40:35 - which is probably what you'll
spend the most of your time doing,
40:38 - at least in the beginning, when
you're bootstrapping your game,
40:41 - is programming what's
called a MonoBehaviour.
40:45 - And so we talked about Mono before.
40:48 - So Mono is the open source
implementation of the CLR.
40:52 - And MonoBehaviour, I imagine--
40:54 - I tried to look this up and
see where it derives from.
40:56 - I imagine it's because it was originally
a Mac exclusive project, Unity.
41:03 - And so because everything
was implemented in Mono,
41:05 - and because this is way it's scripted,
MonoBehaviour became the name.
41:11 - But a MonoBehaviour is
what a component is.
41:14 - They are effectively one and the same.
41:16 - The difference being
that a MonoBehaviour
41:18 - is how it's illustrated in code.
41:19 - In C#, if you want to program something
to be a component that you can then
41:23 - attach to a game object, it needs
to be inherited from MonoBehaviour.
41:31 - So if we go to coin spawner, here.
41:37 - And you can see the difference
between what's built in to Unity
41:40 - and what's your own via--
41:42 - it'll say script here.
41:44 - So in this case, I have a
coin spawner object, right?
41:46 - It's just an empty object, at
least in terms of what it displays.
41:51 - It's got a transform,
which is irrelevant.
41:53 - It could be literally
anywhere in our entire scene.
41:56 - The only difference between
this and the empty game
42:00 - object that we saw before is
that it has a coin spawner.
42:04 - And this coin spawner
has this thing here.
42:10 - All components that you add would
have this script field here,
42:14 - just to show you that
that's the script that it's
42:17 - getting it's code behavior from.
42:19 - But also, we have this field here
called prefabs, which has a size of 1.
42:25 - And it's actually calculated
based on how many elements
42:29 - the list that it's responsible for has.
42:32 - And we have one element,
as it says, here.
42:35 - And it's got a coin
pre-fab, which is here.
42:38 - And notice that I clicked on it.
42:40 - It took me right to it in my assets.
42:42 - And so prefabs and all of that--
what that means and how to get
42:45 - that all working--
we'll talk about that.
42:47 - But a coin spawner script
has to exist in our code base
42:54 - before we can actually add it
to any game objects, right?
42:58 - So in my project I do have--
43:02 - usually, you have assets, a folder
called Assets in your Unity Project.
43:06 - And then I typically
create a Resources folder.
43:09 - It's not mandatory that you do so,
but just for organization, I'll
43:12 - create a Resources.
43:14 - And then I'll have a bunch of folders
for all sorts of different things
43:17 - like we've done before.
43:18 - Where in the Love2D project,
at the parent level,
43:21 - you have like a Fonts, a Music or
Sounds, and then a source directory.
43:27 - In this case we have
Fonts, Materials, Models,
43:30 - all the different assets that
we will need in our game,
43:33 - but also a Scripts folder.
43:35 - And all the C# scripts here that we'll
use amongst all of our components--
43:41 - all of our game objects.
43:43 - And so you could easily
just go to any of these,
43:46 - rather than have to go into your
operating system, open up a new window,
43:50 - and find your file, and
navigate through all the files
43:53 - that Unity generates for you,
which can be kind of a pain.
43:56 - You can just double-click on
a coin script, for example.
43:59 - And it'll open in your default editor.
44:02 - And so one thing that
I'll just mention here
44:06 - is, if you go to your
Unity preferences--
44:08 - on Mac, it's Unity
and then Preferences--
44:11 - you can go to External Tools.
44:12 - So by default, starting in 2018,
Unity is transitioning away
44:15 - from its prior IDE, which was called
MonoDevelop, which was a good IDE.
44:19 - There's transitioning away
from that, and they're
44:21 - making it focused on Visual
Studio as the default IDE.
44:26 - I don't use Visual Studio.
44:28 - I like VS Code.
44:29 - So what I did was-- and
what you can do is--
44:33 - you can choose your
external script editor here,
44:35 - if you prefer a different
script editor-- like Atom,
44:37 - or VS Code, or Sublime Text.
44:40 - And then just browse for
it on your file system,
44:42 - whether you're on a Windows,
Linux, or Mac machine.
44:44 - And then you can easily just
choose which file you want.
44:47 - In this case, I chose VS Code.
44:48 - And so that effect that
that has is, whenever
44:50 - I double-click on a
script within Unity, it
44:53 - will actually open
the IDE or text editor
44:56 - that I have assigned to
it in Unity's preferences.
45:00 - And so here is the Coin component
that I have created for this example.
45:08 - And notice that every component,
first of all, is a class.
45:13 - And actually, everything effectively
in C#, just as in Java, is a class.
45:20 - It's a public class.
45:21 - And notice that I call it Coin, and I
got this colon, and then MonoBehaviour.
45:26 - So this colon-- anybody know, anybody
take a guess what the colon means?
45:30 - Tony?
45:31 - TONY: Extends.
45:31 - COLTON OGDEN: Extends, yes.
45:32 - Extends or inherits from MonoBehaviour.
45:36 - So anytime you have a
component that you want
45:38 - to create, you want to add it to Unity,
and allow you to see it in the editor,
45:41 - and allow you to actually
drive behavior of an object,
45:45 - you need to inherit from MonoBehaviour.
45:47 - Like it says here on my VS Code, since
I have the extension for OmniSharp,
45:52 - it will actually tell me,
MonoBehaviour is the base class
45:55 - from which every Unity script derives.
45:59 - There's a couple of things here.
46:00 - So notice that we have a few methods.
46:03 - So void Start, void Update,
and void OnTriggerEnter.
46:10 - So anybody take a guess as to what--
46:12 - ignoring OnTriggerEnter--
does anybody have
46:14 - a guess as to what Start and Update do?
46:16 - Yeah.
46:17 - AUDIENCE: Could it be just like that
and [INAUDIBLE] update [INAUDIBLE]??
46:21 - COLTON OGDEN: Sorry,
say it one more time.
46:22 - AUDIENCE: Would it just [INAUDIBLE]
an update or [INAUDIBLE]??
46:24 - COLTON OGDEN: Exactly.
46:25 - It would be just like we did
before when we created objects
46:29 - in our Love2D projects, where we had an
init function assigned to every class,
46:35 - and an update function
assigned to every class.
46:37 - And we would call those ourselves.
46:39 - Every MonoBehaviour can
have a Start method.
46:44 - In this case, it's empty,
because every time you
46:46 - create a new script by the Unity editor,
it will automatically-- first of all,
46:50 - it will automatically create
a brand new file for you.
46:53 - So let's just say I want
to create a new script.
46:55 - So if I'm in the Unity editor,
and I go to my assets--
46:58 - I right-click Create.
47:00 - And then I want to
create a new C# script.
47:03 - It'll create it there.
47:04 - I can say, maybe I want this to be--
47:06 - I don't know-- Test Component, right?
47:11 - So this should have the effect
of, when I open it in my VS Code,
47:15 - this Test Component-- this
was auto generated for us.
47:18 - We didn't have to write
any of this boilerplate.
47:20 - But every script that
you create, by default,
47:26 - is a MonoBehaviour, which it
strictly does not have to be.
47:29 - You could create a class of your own,
that maybe you call behind the scenes,
47:34 - or maybe it just represents a
data structure or something.
47:36 - But by default, anytime you
create a new script in Unity,
47:39 - it'll save you the hassle of
typing out all this stuff by hand.
47:43 - And it'll give you an empty Start
method and an empty Update method.
47:48 - And so, like Tony said, the Start
method gets called as soon as the object
47:53 - that it's assigned to gets instantiated.
47:55 - Well, as soon as this component
gets instantiated, rather.
47:59 - Which often is the case
that it gets instantiated
48:03 - at the same time as a game object.
48:05 - Not always.
48:06 - You can create game
components on the fly.
48:10 - But this Start method will get called.
48:12 - Anything that you put in here
will get called right away.
48:14 - And then this Update method,
Unity will-- every frame,
48:17 - go through every component
on every live game object--
48:20 - and will call the code that's
contained within this Update function.
48:26 - And you don't have to call
this anywhere yourself.
48:28 - Just by assigning this component
to a game object in your scene,
48:34 - you get the update, and start,
and all this other functionality
48:38 - given to you for free.
48:40 - And MonoBehaviours are
actually much more complex
48:43 - than just Start and Update.
48:48 - So if you go to MonoBehaviour
here, we can see that--
48:56 - by the way, I want to shout
out Unity's documentation.
48:59 - Unity has amazing documentation--
49:01 - docs.unity3d.com.
49:02 - You will go through
pretty much everything
49:05 - you possibly could ever want with every
object implemented in Unity, in quite
49:10 - a good detail, with a lot of examples.
49:12 - But here we can see,
just in the description,
49:14 - it will tell us, the MonoBehaviour will
get start, update, fixed update, late
49:23 - update, on GUI-- all of these
functions called for us, assuming
49:26 - that they're implemented.
49:27 - And you don't have to implement
them if you don't want to.
49:30 - If they're not implemented,
they just won't happen.
49:32 - If there's no start
method, then that means
49:34 - there's no start logic
for this component.
49:35 - So it doesn't need to execute.
49:37 - If there's no update, maybe it just
needs to start at the very beginning,
49:39 - but never update after that,
don't implement update.
49:41 - And update will not be called.
49:44 - All of these are optional.
49:46 - That's just a small
chunk of MonoBehaviour,
49:48 - though, because you also have messages.
49:51 - So messages are functions
that you override.
49:56 - As you can see, there's
a whole lot of them.
49:59 - And all of these messages get called,
depending on certain things that
50:02 - happen in the game scene.
50:04 - So OnTriggerEnter, for example, if our
object is a trigger, and we enter it,
50:12 - then the behavior will get
called in that function, which
50:15 - will allow us to do things like--
if our helicopter enters a building,
50:20 - we can call that
helicopter's explode method,
50:22 - which is literally what we do in this
project, thanks to this function.
50:26 - And all we really need to do is
just a couple of lines of code.
50:29 - It's very simple.
50:31 - OnPostRender, OnPreRender--
all these different things
50:34 - are called at different times.
50:35 - You can look into all of these, if
you want to, just by clicking on them
50:38 - and looking at their documentation.
50:41 - LateUpdate is called after all
update functions have been called.
50:44 - This can be relevant for
certain physics calculations.
50:49 - But there's a whole lot of
different things you can do.
50:53 - You don't necessarily need to
do a lot of things yourself,
50:56 - if Unity provides you with
the function that gives you
50:59 - the effect that you're looking for.
51:00 - And so if you're curious, MonoBehaviour,
and then the docs at large.
51:03 - This is just all the documentation--
just an insane amount of documentation.
51:07 - And that's just in the classes.
51:09 - There's all these other
little side areas, as well.
51:14 - And so that's sort of
what MonoBehaviour is.
51:17 - It's a component.
51:18 - It gets a lot of these
functions called for you.
51:20 - You don't have to implement them.
51:21 - But if you do, you get a lot of
functionality for free, basically.
51:26 - Any questions as to what a MonoBehaviour
is, how it works, and so forth?
51:30 - Or any of the syntax we've seen thus
far for creating a MonoBehaviour?
51:37 - All right.
51:38 - And so, here in our coin, for example,
which we were looking at before,
51:42 - notice that I'm referencing
something called a transform.
51:45 - Transform.position.x is less than
negative 25, destroy a game object.
51:51 - If this is the coin, what do we
think that this is accomplishing?
51:57 - AUDIENCE: It goes off
the screen [INAUDIBLE]??
51:59 - COLTON OGDEN: Yep.
52:00 - So the transform,
recall, was our component
52:06 - that encapsulates our
rotation, scale, and position.
52:09 - So we can just say, if
transform.position.x is less
52:13 - than negative 25, destroy game object.
52:17 - Because we're spawning
the coins dynamically.
52:19 - When they get off screen-- just like
we did with the pipes, if you remember.
52:22 - And I had a screenshot,
actually, in that slide
52:23 - that showcased what that looked like.
52:25 - We can see that exact thing live here.
52:29 - If I go to Layouts, two by three,
and we play the game again,
52:33 - and then I'll just die at some point.
52:37 - But if we do this, we're
seeing our scene live.
52:42 - So we're following this-- yep.
52:43 - See how the coin-- as soon as
the building, and the plane,
52:46 - and the coins all get to this point--
52:48 - this is negative 25 in
Unity units, not in pixels.
52:53 - Everything in Unity is based on
Unity units, which, by default,
52:56 - 1 is equal to one meter, as opposed to--
we've been thus far using just pixels.
53:02 - But pixels aren't viable in 3D.
53:07 - [MUSIC PLAYING]
53:10 - But that's effectively
what that component does.
53:12 - It's checking, in our Update
function-- void Update--
53:16 - if transform.position.x
less than negative 25.
53:20 - And notice that we don't actually
have to declare transform
53:23 - anywhere, which is interesting.
53:26 - That's because MonoBehaviour,
by default, gives you
53:28 - access to its game objects
transform just by default.
53:32 - That's just something you get for free.
53:35 - And then, notice gameObject-- we also
haven't declared gameObject anywhere.
53:39 - Because by default, we
have access to gameObject.
53:42 - It's the game object that
this script belongs to.
53:46 - That this component belongs to.
53:48 - AUDIENCE: [INAUDIBLE]
53:50 - COLTON OGDEN: This would be the actual--
53:54 - so the interesting
thing about the classes
53:57 - is, you don't have to
explicitly say this.
54:00 - Because if you had int myNumber equals
10, and you just say, myNumber--
54:08 - the difference between Lua
and C# and Java is that,
54:12 - it will already know what
myNumber is, this is myNumber.
54:16 - It will know its this objects.
54:17 - AUDIENCE: Yeah.
54:18 - COLTON OGDEN: You don't have to do that.
54:23 - Sort of a nice little thing to
save you a little bit of time.
54:26 - Because you could then just
say, myNumber plus equals 10.
54:30 - Another nice thing about C#, by the
way, which we didn't get in Lua--
54:33 - you can do compound
assignment operators.
54:36 - So you can do plus equals,
minus equals, times equals.
54:38 - That's one of my little
pet peeves I have with--
54:40 - oh.
54:41 - And notice that also, the nice
thing about the fact that I
54:43 - have OmniSharp-- it'll underline.
54:45 - And this is just a trait
of most IDEs, honestly.
54:48 - So you get this with a lot of places.
54:50 - But it'll tell you myNumber is not
assigned, with the underlining,
54:55 - and also just by hovering over it.
54:57 - The named myNumber does not
exist in the current context.
55:00 - But I can just say, int myNumber.
55:03 - And then it's gone.
55:05 - A little bit more that
we have to worry about,
55:07 - and a little bit less that
we have to worry about.
55:09 - A little give and take.
55:12 - But still, I think, overall, C# is
going to be a lot more syntax-heavy.
55:16 - You do have to worry about things
like braces, and semi-colons,
55:19 - and putting everything in a boilerplate.
55:23 - And then, obviously, type declaration,
and return type declaration.
55:26 - It can be a little bit more than
we've gotten used to so far.
55:29 - But it's honestly not too bad,
just given that you can use IDEs.
55:34 - First of all, the fact that you're
statically typing everything,
55:37 - you can detect a lot
more errors in advance.
55:40 - If you're trying to do
something with some type
55:42 - that you're not supposed to
do, like some function accepts
55:45 - some object of some type, but
you're passing in some other object,
55:48 - you'll catch that in advance.
55:50 - And so that's a really nice thing.
55:53 - But yeah.
55:54 - It is a give and take.
55:57 - And also, IDEs will
give you, like I said,
56:00 - a lot of the functionality-- a
lot of the autocomplete-- that
56:03 - makes a lot of this more sustainable.
56:05 - And it's not to say, of course, that
Lua and Love2D don't have their own IDE.
56:08 - Like ZeroBrane Studio is
popular, from what I understand.
56:11 - Haven't used it yet.
56:12 - But particularly when you venture into
Java, and C#, and compiled languages,
56:16 - static languages-- having those
features does save you a lot more time,
56:20 - relatively speaking, than when
you're in a dynamic language.
56:25 - So that's what MonoBehaviours are.
56:28 - Every component of our game
effectively has-- like the helicopter
56:32 - has its own script, a Heli Controller.
56:35 - The coin has its own script-- the
Coin Spawner, the Skyscraper Spawner,
56:38 - the Skyscraper--
56:39 - they all have their own scripts
that drive their game behavior.
56:42 - But they also have scripts and
components that are part of Unity core,
56:46 - as well.
56:48 - Including Colliders and Triggers.
56:50 - So if I'm looking in Unity--
56:52 - so I'm going to go to--
56:54 - and this will actually be the last
thing we look at before we take a break.
56:57 - But if I'm in Unity, and I'm going
to go back to my default layout,
57:03 - just because it's a
little cramped on a 720p.
57:06 - Go to my helicopter.
57:09 - Helicopter's got a
couple of pieces to it.
57:11 - So let's actually go to
where I can see it here.
57:15 - So one of the awesome
things I love about Unity
57:17 - is, it gives you a lot of this editor
magic-- this editor sort of sugar.
57:23 - It shows you visually where a lot of
the things are in your game world.
57:27 - So the green rectangles-- anybody
know what those are, or can guess?
57:31 - AUDIENCE: Hit boxes?
57:32 - COLTON OGDEN: Yep.
57:33 - Hit boxes.
57:34 - Exactly.
57:36 - These are colliders.
57:38 - So the blades-- it
doesn't have a collider.
57:41 - That blades collider
is actually separate.
57:44 - The box collider here is
this collider right here.
57:50 - And so a collider is
literally just something
57:53 - that collides with something else.
57:54 - And you can set it to
be a trigger or not.
57:56 - If it's a trigger, then it actually
won't trigger the OnTriggerCallback
58:02 - function that we briefly saw earlier.
58:07 - So the things that you
want to activate triggers,
58:10 - you should make those not triggers.
58:12 - And then triggers, all you have to do is
just click this little Trigger button.
58:15 - So what a trigger is is just a
region that you've determined--
58:19 - or some object that you've
determined-- should cause behavior
58:22 - when it gets triggered.
58:23 - So in this case, I've assigned--
58:30 - actually, I'll just play it.
58:33 - But the airplane has a trigger, right?
58:44 - All of these things have colliders,
whether they're triggers or not.
58:48 - The helicopter-- its
blades and its body--
58:51 - there are two colliders, two boxes.
58:55 - The coins all have colliders.
58:57 - The skyscrapers will have colliders,
and the airplanes have colliders.
59:00 - The difference is that-- oh, and
by the way, another cool thing.
59:06 - It's easy to get very
sidetracked, just because there's
59:08 - so many cool things to talk about.
59:10 - You can pause the game
while it's running.
59:12 - So it's paused right now, but it's
in the exact state that I left it.
59:17 - So there's three coins there.
59:18 - I got my helicopter there.
59:20 - I can freely go about the scene.
59:21 - I can analyze things.
59:23 - I can actually modify this in real time.
59:26 - So I can change its
rotation, if I want to.
59:30 - Probably don't want to do that.
59:32 - But I could if I want to.
59:33 - I can change its position, right?
59:35 - So I can move it left
to right, like that.
59:37 - And notice that I actually
have just the body selected,
59:39 - so the blades are kind of separate.
59:42 - I don't even know what
kind of crazy stuff
59:43 - would happen if I just messed
with this and just let it run.
59:45 - I haven't tested it that crazily.
59:47 - But you are allowed to step through.
59:49 - Oh, OK.
59:49 - It looks like they both just go.
59:51 - Oh, yeah, because they're
parented to the helicopter object.
59:54 - So they're both going to align.
59:56 - They're going to move
at the exact same rate,
59:58 - regardless of how far apart they are.
60:02 - The individual objects.
60:03 - But you can just step through your
game's execution frame by frame,
60:08 - and get a sense of--
60:09 - if you're trying to pinpoint
a bug, maybe, that's
60:11 - position-based or
something that's tricky
60:13 - and you just haven't been able
to find exactly what's going on.
60:19 - You can look through
your whole scene and all
60:21 - of the fields of every
object in step time,
60:26 - just by stepping through--
this button here--
60:28 - assuming that you're in pause mode.
60:29 - And then just looking at all the
components here on the right side.
60:32 - Because those will all still update.
60:34 - All these fields will
update any time you perform
60:37 - any changes in the actual scene.
60:40 - So super helpful for debugging.
60:42 - I know I've used it a bunch.
60:44 - And then if I start
again, or if I stop it,
60:46 - the nice thing is, any
of the changes that you
60:49 - make while it's running
to your object, they
60:51 - don't get applied when you
actually go back to the game.
60:54 - So notice that I messed with the
two pieces, I separated them.
60:59 - And then I stopped the game.
61:00 - It ended up going right back to
where it was in the very beginning.
61:04 - So all this gets just basically
saved like a snapshot.
61:06 - You can do whatever you want during
your game, and then come back to it,
61:10 - and it will all get reverted
back to where it was.
61:12 - Yeah.
61:12 - TONY: So [INAUDIBLE] if
you hit single player,
61:15 - and I kept making changes while
I'm not involved [INAUDIBLE]..
61:20 - COLTON OGDEN: Yes.
61:20 - So, yeah.
61:21 - Tony just basically echoed
what I just said, which was,
61:24 - if you make changes in your
game while it's running,
61:27 - and you're trying to maybe tweak them
such that it's perfect when you're
61:31 - actually done, they don't get saved.
61:32 - So you have to actually make a conscious
effort to remember what you've done,
61:36 - how you've changed different fields,
to fix any bugs, if they do exist.
61:40 - But it is something that can be
disheartening or frustrating, if you
61:45 - finally fix something, and then
you forget what it is you changed.
61:48 - And then you have to mess
with it a whole bunch.
61:50 - So remember all the changes
you make, if they're
61:52 - pertinent to your
actual game's execution
61:53 - and the debugging of your game.
61:58 - And then there's also a
console, as well, which is nice.
62:02 - If you want to output things
like JavaScript style on the web,
62:08 - you can do console.log.
62:09 - You can do the same thing with
a debug call here in Unity.
62:13 - I don't have any of those
calls in the actual game.
62:16 - But it is something that
we'll look at going forward.
62:19 - And it is something
that can be very helpful
62:21 - if you want to measure something
or output something that you can't
62:24 - necessarily look at in the inspector.
62:26 - In the case of this game, most of
anything that we want to take a look at
62:29 - is visible in the inspector.
62:30 - But if you have an algorithm, maybe
you have a generator that's not visual,
62:36 - like a level generator.
62:37 - And you want to make sure that the
data structure representing your level
62:41 - is generating things properly, you can
output everything maybe via hashmarks
62:44 - or something in your
console, and actually
62:46 - see it that way when
you're running the code,
62:48 - rather than having to run the actual
game and look through it that way.
62:52 - Some things just are hard
to model in the editor,
62:55 - and still need console output.
62:57 - So the console is there to help you.
62:59 - And so debug.log is the
function, I believe,
63:02 - that you need to see all that stuff.
63:07 - Right.
63:07 - Colliders and triggers.
63:08 - So we had a little bit
of a tangent there,
63:10 - but the helicopter is comprised
of these three things.
63:14 - But the blades collider
should have ultimately
63:16 - been merged with the blades object here.
63:18 - But we can think of it as
the blades and the body.
63:21 - The reason they're separated-- well,
there's two reasons they're separated.
63:26 - One core reason they're separated
is they're just different sizes.
63:30 - So the blades are longer than the body.
63:32 - And so we have, for that
reason, two separate colliders.
63:35 - So we're looking at the helicopter here.
63:38 - We can see that the
collider for the blades
63:42 - extends a little bit
farther than the body.
63:44 - We don't want to create a box
collider for the entire helicopter,
63:48 - because a box collider right
that goes out here, for example,
63:52 - might not be super fair
if we're just coming right
63:54 - over a building, and our body--
63:59 - maybe the building's right
here, and we just miss it.
64:01 - We don't want that to be collided with.
64:03 - So sometimes you'll need
to combine colliders
64:05 - to accomplish the collision
detection behavior you're looking at.
64:09 - The nice thing about box
colliders, which we're using here,
64:11 - is that they're not very expensive,
because they're just boxes.
64:14 - It's easy to compute 3D box collision
with other things that are 3D boxes.
64:19 - And that's actually a
topic in its own is,
64:23 - taking a complicated model or
object, and then breaking it down,
64:27 - not in terms of what it looks
like to be collided with,
64:29 - but how you can simplify the
collision detection of something,
64:32 - like a character, by just modeling its
arms, its body, its legs, as cylinders
64:38 - or boxes, rather than
complicated geometry.
64:42 - You usually don't want to do peer
geometry collision for anything,
64:45 - because that gets really expensive.
64:48 - You want to try and aim for simple
shapes to be your colliders.
64:52 - And Unity gives you a
lot of simple shapes
64:54 - by default. If you look at, for
example, in our helicopter--
64:59 - if you wanted to add a
component-- which, by the way,
65:01 - you can easily do here, just
in the component inspector.
65:05 - If you're looking at the bottom right,
there's an Add Component button.
65:08 - So you can add any of the
components that you've written,
65:12 - and also all the components
that Unity gives you by default.
65:15 - So if we look at it by
collider, we can see
65:16 - there's a lot of different colliders
that Unity gives us for free.
65:19 - Polygon collider, mesh collider,
box collider, capsule collider.
65:25 - I try and strive for
boxes as much as I can.
65:28 - Spheres aren't bad.
65:29 - Spheres are usually fairly
easy to calculate, as well.
65:31 - But boxes are the easiest.
65:33 - Capsules are pretty easy, too.
65:35 - A lot of players will be capsule
colliders, because characters usually
65:39 - have rounded heads.
65:40 - So emulating the collision for their
head with a capsule makes more sense.
65:45 - And we'll look at that, actually,
next week, when we use a first-person
65:48 - component that we can get for free.
65:49 - The default collider
for it is a capsule.
65:55 - But the blades and the body
both have their own collider.
66:02 - They're not triggers.
66:04 - But if we look at our prefabs--
66:08 - which we'll take a look at
what a prefab is shortly--
66:10 - a skyscraper has a box collider which
is a trigger, as we can see here.
66:16 - And the coin is a trigger.
66:18 - And the airplane is a trigger.
66:20 - So these things all trigger, except
other colliders that aren't triggers.
66:27 - And if it detects a collision with
a collider that's not a trigger,
66:30 - it will call the
OnTriggerEnter function,
66:33 - which we saw is something that
you can get with MonoBehaviour.
66:36 - Yeah.
66:37 - AUDIENCE: Could you have two values
if you want to call the special
66:41 - function two at the same time,
you'd have the regular [INAUDIBLE]..
66:44 - Is there an easier way to do that?
66:47 - COLTON OGDEN: Can you give
me a specific example?
66:49 - AUDIENCE: Well, if I want to
have a pinball game or something,
66:53 - I'd want to model functioning
when my ball hits something.
66:58 - But at the same time, I just
don't it to bounce off of stuff.
67:01 - COLTON OGDEN: Oh, yeah.
67:02 - AUDIENCE: So you could do that?
67:03 - COLTON OGDEN: So the question was, can
I implement such that, for example,
67:09 - in a pinball game, if I have a
ball that collides with something
67:12 - and causes a trigger to occur, but
also have it bounce off of something.
67:15 - And you would do that with a rigid body.
67:17 - So you give it a rigid body.
67:19 - In this case, I actually gave
a rigid body to the helicopter
67:23 - because the original goal of mine was
to have it be affected by gravity.
67:26 - But it turned out that I actually liked
it a little bit better without gravity.
67:29 - So this rigid body isn't
strictly necessary.
67:32 - But it has a gravity
component that you can
67:34 - assign to it that will actually,
then, calculate gravity, and pull it
67:39 - down wherever-- you have a
global gravity definition that's
67:44 - in your Unity settings that
will affect it that way.
67:47 - And so what you would do is, you
would give your ball a rigid body.
67:51 - And other things that you want
it to bounce off of those,
67:53 - those also have rigid bodies.
67:55 - And they can be kinematic
or not, basically,
67:59 - which we talked about before.
68:00 - Kinematic can move, but not
be affected by other objects.
68:05 - And so the object that's a trigger, you
still trigger code, it does something.
68:10 - So your pinball machine, when
it collides with something,
68:12 - and it triggers that thing,
it'll still trigger that code.
68:17 - So whether that's increment
your score, or cause something
68:19 - to flash, a part of it will
flash, or play a sound,
68:22 - it'll do that in your OnTriggerEnter.
68:23 - But your rigid body will
also perform its work,
68:26 - and bounce off of whatever it--
68:28 - assuming that you don't destroy it
with that OnTriggerEnter function,
68:32 - it will bounce off of that
surface, and behave in the way
68:35 - that you are alluding to.
68:37 - Does that make sense?
68:40 - All right.
68:41 - Cool.
68:44 - So all these things have triggers.
68:47 - The IsTrigger flag--
68:49 - I mean, that's as easy
as we need it to be.
68:51 - So you just give a box collider.
68:52 - And the nice thing
about box collider, too,
68:54 - is if your mesh is a box,
or square, or rectangular,
69:00 - it will usually just fit it perfectly to
whatever you're trying to assign it to.
69:04 - So in this case, I remember adding the
box colliders for these skyscrapers.
69:07 - It just-- because they're
all rectangular, or cubical--
69:12 - I don't know.
69:12 - What's the rectangular 3D?
69:14 - I forget the term.
69:15 - What is it?
69:16 - AUDIENCE: Rectangular prism.
69:17 - COLTON OGDEN: Rectangular prism, yes.
69:19 - Because they're all rectangular
prisms, the box collector fits them.
69:23 - It'll scale the right way.
69:25 - When you have differently
weird shaped objects,
69:27 - it'll just basically
be as big as it needs
69:30 - to be to completely encapsulate it.
69:32 - But like I said before, because the
helicopter has got some weird geometry,
69:37 - if we were to do that, it would by
default just be this entire box here,
69:41 - because this is the farthest it
goes out on this particular axis.
69:45 - So we want to combine meshes
to produce the collision
69:50 - behavior that we're looking for.
69:52 - And the trigger enter bit is relevant
because, if your game object is
70:02 - a trigger, then once we
collide with that object,
70:09 - we want-- and by default,
when you do OnTriggerEnter,
70:11 - it will look for the
collider on this object.
70:15 - It's going to take in a
collider other, right?
70:18 - And what that is is the
other collider-- the thing
70:21 - that's colliding with this
object, with this coin.
70:24 - So the helicopter, because it's
the only other object in our scene
70:27 - that has a non-trigger collider.
70:31 - OnTriggerEnter-- this is
going to be a helicopter.
70:33 - We can just say other.transform.parent,
because our helicopter has children,
70:38 - which have the actual colliders, and
a parent has the helicopter controller
70:42 - component.
70:43 - We're going to GetComponent
the HeliController.
70:47 - So we're going to go through
our that objects, that other
70:50 - that collided with us.
70:51 - We're going to get its transform parent.
70:54 - We're going to do GetComponent, which
is a function that will just look
70:57 - through all of its list of components.
70:59 - We specify which component we
want using this identifier here.
71:03 - So of class HeliController.
71:06 - And these angle brackets are
the generic type specifier
71:16 - syntax, which basically looks for it.
71:17 - You could pass in any
type here, effectively,
71:20 - and GetComponent will look
at whatever type is in here,
71:23 - and get the component of
that type, specifically.
71:25 - So you do have some sort
of type flexibility in C#,
71:29 - but you have to go the
extra mile and specify it,
71:32 - and implement functions that
take generic arguments like this.
71:35 - Which is similar to Java, and C++, and
other languages that do it that way.
71:41 - And then once we've gotten that
component of type HeliController,
71:45 - with this function call,
we execute PickupCoin,
71:50 - which is a function that's
part of the HeliController.
71:53 - Any guesses as to what PickupCoin does?
71:59 - AUDIENCE: [INAUDIBLE]
72:00 - COLTON OGDEN: Sorry?
72:01 - AUDIENCE: Increments the coin counter
and tells the coin to disappear.
72:04 - COLTON OGDEN: Increments the coin
counter, calls the coin to disappear.
72:06 - Well, it actually doesn't call the coin
to disappear, because we do that here.
72:09 - AUDIENCE: Oh.
72:10 - COLTON OGDEN: Destroy game object--
72:13 - game object is going to be this
coin that's executing this function.
72:17 - There's one more thing, too.
72:18 - Do you remember what happens
when we pick up a coin?
72:21 - Exactly.
72:21 - The particle effect.
72:22 - It triggers a particle effect.
72:23 - We can go to the HeliController
class and take a look at that.
72:28 - PickupCoin.
72:31 - Here, coinTotal plus equals 1.
72:33 - GetComponent AudioSource.
72:37 - Play.
72:38 - So it's a little bit weird.
72:39 - So with audio source, you can
have multiple audio files.
72:44 - So GetComponents AudioSource
is what we need to actually get
72:48 - the audio attached to this object.
72:49 - And at index 0--
72:51 - because there's only going to
be one audio source anyway.
72:54 - And then we just call Play, so
that'll play the coin sound.
72:58 - And then GetComponent,
because there's only
73:00 - going to be one particle system
associated with this helicopter object.
73:04 - We're going to get the
particle system object.
73:06 - And then we're just going to call Play
on that, which will actually trigger
73:09 - an emission one time of its particles.
73:14 - That's in a nutshell what
colliders and triggers are.
73:18 - It's a lot of syntax at once,
because Unity is really big.
73:22 - But it's pretty simple.
73:25 - Just make sure that you give the
right shapes to your objects.
73:27 - Make the right things
triggers that you want
73:29 - to cause behavior to happen when
non-trigger things touch them.
73:34 - And then implement OnTriggerEnter
with the behavior-- the game logic--
73:38 - that you need.
73:39 - In the case of the skyscraper, for
example, if we look at the skyscraper.
73:43 - So I have a skyscraper component here.
73:45 - And then if I OnTriggerEnter
here, it effectively
73:49 - does the same thing
that the airplane does,
73:53 - which is just go through the others,
transform parent game object,
74:00 - HeliController, and then call Explode.
74:03 - And so Explode-- similar
thing to what PickupCoin does,
74:06 - and it triggers a particle effect.
74:08 - But it also destroys the helicopter,
and it tweaks the Game Over text
74:14 - to turn on at that point.
74:16 - So any questions as to how triggers
work, or any of the syntax we've
74:20 - talked about thus far?
74:21 - I know that it's a lot.
74:24 - It's kind of a fast tour.
74:25 - But moving right along.
74:30 - All right.
74:30 - Oh, and here's a screenshot I took
just to illustrate the green lines--
74:34 - the box-- and then the orange is
the actual mesh of the helicopter.
74:40 - So we're going take a break.
74:41 - And then when we get back,
we're gonna talk about prefabs
74:44 - and spawning them, and
dive a little bit deeper
74:47 - into some of the other
parts of the project.
74:49 - All right.
74:50 - Welcome back to GD50 Lecture 8.
74:52 - This is Helicopter Game 3D.
74:53 - So before the break, we were talking
about colliders and triggers,
74:57 - and also just getting our hands used to
using MonoBehaviours, and the editor,
75:01 - and all sorts of things.
75:03 - But we haven't really
taken a look at prefabs,
75:05 - which is a major part of this game.
75:08 - So the coins, the
skyscrapers, the airplanes--
75:12 - those are all prefabricated
assets that we have gotten
75:16 - ready for spawning into our scene.
75:19 - And we're going to take a look
at how that actually works.
75:22 - So here's a list of--
75:24 - in our editor view-- all the
different prefabs that we have.
75:27 - So we can see airplane,
blades, and body are prefabs.
75:31 - The coin, all the skyscrapers.
75:33 - There are three different
kinds of skyscrapers.
75:35 - And then the helicopter.
75:37 - The helicopter itself we're
not using as a prefab,
75:39 - because I've already
created it in the scene,
75:40 - and it never gets
instantiated dynamically.
75:42 - But we could easily make
it so, because I have
75:45 - created a prefab with the helicopter.
75:49 - So when we're looking
at the scene here, we
75:53 - notice that we have just the
helicopter, and we have the background.
75:57 - But there's no skyscrapers, there's
no coins, and there's no airplanes.
76:01 - Well, we do have our skyscraper spawner,
the coin spawner, and the airplane
76:07 - spawner.
76:07 - And the three of those are
just empty game objects,
76:10 - but they have associated with
them these spawner scripts.
76:13 - And the spawner scripts,
we've written ourself.
76:16 - And then, once we've written them,
we just simply add component here,
76:19 - and then chosen the appropriate spawner.
76:22 - And so what those do--
76:24 - if we look in our code actually, and
we go, for example, to the airplane
76:28 - spawner, we have a Start method.
76:33 - We have an Update method.
76:34 - Notice that the Update method
doesn't do anything, paradoxically,
76:38 - because the airplane spawner
is running over time.
76:42 - We are spawning airplanes over time.
76:45 - But the way that we do things
over time asynchronously in Unity
76:48 - is a little bit different than
anything that we've done so far.
76:51 - So this Start method here,
we see that we're calling
76:54 - this function called StartCoroutine.
76:57 - And that function takes in a
function called SpawnAirplanes.
77:01 - And so at a high level, a
coroutine is effectively a function
77:06 - that yields control
every time it's called.
77:09 - So it'll run, and then, rather than
go through its entire body of code,
77:15 - and then end or return some value,
and have that just be the end of it,
77:19 - it'll actually yield, when
you use the keyword Yield.
77:25 - And depending on what
you've done with that Yield,
77:30 - it'll pause for some length of time, or
do something for some length of time,
77:34 - rather than end that function call.
77:37 - So this SpawnAirplanes function here--
77:39 - notice that it has a while true.
77:41 - And so while true is not usually
something that you want in a game,
77:45 - because that's just going
to lock your game forever.
77:49 - But in the case of a coroutine,
a coroutine is going to run,
77:54 - but then it's going
to yield control back
77:56 - to whatever called it
for some length of time,
77:58 - or depending on how we've programmed it.
78:00 - In this case, you can see here--
78:02 - yield return new WaitForSeconds
Random.Range 3, 10.
78:07 - Does anybody have an
idea of what that does?
78:10 - Yeah.
78:10 - AUDIENCE: The logic [INAUDIBLE]
waits for between 3 and 10 seconds,
78:15 - and continues.
78:16 - COLTON OGDEN: It does.
78:19 - It yields for 3 to 10 seconds,
and then continues its execution.
78:22 - That's exactly right.
78:23 - Did you have a question?
78:24 - AUDIENCE: I was thinking, why do you
have three different skyscrapers set
78:27 - up?
78:28 - Couldn't you just have one
skyscraper and change [INAUDIBLE]??
78:32 - COLTON OGDEN: You could do that.
78:33 - Yeah.
78:34 - I guess for the sake of
demonstrating prefabs.
78:36 - And also, it's a little bit
complex more complicated to get
78:38 - into dynamic material setting,
and changing materials in code.
78:42 - But yeah.
78:43 - You could effectively just create
one skyscraper with one base color,
78:50 - and then dynamically
change its material.
78:56 - But also to illustrate having
multiple different prefabs
78:59 - assigned to an object, that
you can then choose at random
79:02 - to generate in the game scene.
79:03 - They might not
necessarily be skyscrapers
79:05 - that will have the exact same color.
79:07 - It could be a goblin, or a
orc, or a troll, or something.
79:12 - And they're all different
prefabs that we've created.
79:15 - But you can put them in a list,
and then dynamically choose
79:18 - which one we want at random.
79:20 - So a few different reasons.
79:21 - But yeah.
79:21 - In a situation where everything
is just effectively differentiated
79:25 - by a single color and
a material change, you
79:26 - could dynamically swap that as needed.
79:33 - This code routine that we've
started-- this function that
79:36 - effectively can pause itself, even
though it's being called while true
79:42 - is in play.
79:45 - It yields control with
this Yield keyword.
79:47 - And what it does is, it allows us to
call something over and over again,
79:51 - but then pause for some length of time.
79:53 - Right?
79:53 - We don't have to maintain a
counter for spawn time in here.
79:57 - Which we could do.
79:57 - We could do float spawn
time equals 0, right?
80:01 - And then float spawn
increment equals like 1,000.
80:06 - And then while spawn time is
less than spawn increment--
80:13 - we could say in Update,
if spawn increment.
80:16 - Or we would do spawn time plus
equals time.delta time first,
80:20 - to get the length of time that's
passed since the last frame.
80:22 - And then we would say,
if spawn time is greater
80:26 - than spawn increment,
instantiate a new airplane.
80:32 - And then set spawn time back to 0.
80:37 - And then just rinse and repeat
this over and over again.
80:40 - But coroutines take out
this need, much like timer
80:44 - did, for having anything that you
keep track of with a specific timer.
80:49 - You can do a whole bunch of
different things with coroutines.
80:51 - One of them, in this
case that we're doing,
80:53 - is just pausing for some
length of time to do something.
80:57 - In this case, we want
to wait for some time
81:00 - in between each
instantiation of an airplane.
81:07 - So we'll just yield
control back to our game,
81:10 - because we want to break
out of this while true.
81:12 - But we don't want to break out of it and
completely break out of this function.
81:16 - We want this to keep
going over and over again.
81:19 - So we see here, this
Instantiate function is
81:23 - where the actual instantiation happens.
81:25 - And Instantiate takes in a prefab--
81:29 - so a game object.
81:30 - So in this case, we have
a prefabs list here.
81:35 - GameObject public, GameObject
array called prefabs.
81:39 - So this can take in any number
of prefabs that we want it to.
81:44 - We're going to return a
range between 0 and length.
81:48 - And then also, we want it to spawn.
81:52 - We give it a position
that we want to spawn in.
81:54 - So Instantiate-- it takes in an
object, it takes in a position,
81:58 - and it takes in a rotation.
81:59 - In this case, we want to
give it this position.
82:02 - So it's a Vector3--
82:03 - it's an x, y, and a z--
82:05 - at 26.
82:06 - So off the right edge
of the screen 7 to 10.
82:09 - So within a range of
verticality up towards the top.
82:14 - And then at 11 on the z-axis, which
is aligned with our helicopter
82:17 - and the skyscrapers.
82:21 - And then this Quaternion.Euler--
82:25 - so 3D rotation, the math
behind it is pretty complex.
82:30 - And I don't know it well at all.
82:32 - But Quaternion.Euler allows
us to think in degrees,
82:35 - and actually perform a 3D rotation
on something fairly easily.
82:40 - So if you want to rotate
something in 3D, Quaternion.Euler.
82:43 - Negative 90 degrees on the,
I believe it's z, x, y.
82:46 - In this case, the way that the
default rotation of the airplane is,
82:50 - we want to set it to
negative 90, negative 90, 0.
82:54 - You could also set up
your prefab in a way such
82:58 - that you don't need to pass this in.
83:00 - You could do Quaternion.Identity
in that case.
83:03 - But this is just to illustrate how,
if you want to rotate something
83:06 - in code, how you would do it.
83:07 - So Quaternion.Euler is the way
that you rotate something in 3D.
83:13 - So Instantiate-- global
function that you
83:15 - can call anywhere you want
to, as long as you just
83:18 - give it a actual object or prefab
that it knows how to instantiate.
83:23 - And then WaitForSeconds--
another global object,
83:25 - which is a asynchronous
object that will allow
83:28 - us to yield for this length of time.
83:31 - You pass in the length of time here.
83:33 - It takes it in seconds,
because WaitForSeconds.
83:35 - And then, as soon as this
length of time has passed,
83:39 - it's going to come back up here
into this while true instruction,
83:42 - and then instantiate again.
83:44 - We don't have to keep track of a time
or anything-- any weird boilerplate.
83:47 - We just have to call
StartCoroutine here.
83:51 - And notice that we explicitly have to
call StartCoroutine routine in order
83:54 - to trigger a coroutine function.
83:58 - And to do that, it returns
what's called an IEnumerator.
84:02 - And so a lot of these details,
you don't need to necessarily know
84:05 - the low-level details of.
84:06 - I certainly don't know all the
low-level details of everything
84:10 - that happens in Unity.
84:11 - But just know if you want
asynchronous behavior,
84:13 - your function needs to
return an IEnumerator,
84:15 - which C# knows is a generator
function which will yield control
84:22 - at predetermined times.
84:24 - And it will manage it for you.
84:27 - And to trigger it, you
need to StartCoroutine,
84:29 - which is a function that
Unity has defined for you.
84:33 - So any questions as to how this
works at a high level, at least?
84:38 - AUDIENCE: I'm a little confused
on the syntax for Yield.
84:40 - Does the Yield return--
84:42 - COLTON OGDEN: Yes.
84:44 - Yield takes in something, and you get a
new to instantiate a new WaitForSecond.
84:51 - It's just the way the syntax
is for yielding an object.
84:56 - Yield--
84:56 - AUDIENCE: What is it returning back?
84:58 - COLTON OGDEN: It's returning
this to the Yield instruction.
85:00 - And the Yield instruction
is then yielding that.
85:05 - It is a little bit weird, though.
85:06 - But you only really have to--
85:09 - this is a common
pattern that you'll see.
85:11 - And so you'll just get used to it.
85:16 - And honestly, this is probably one of
the more syntactically difficult things
85:20 - about Unity.
85:20 - So I mean, as soon as
you understand this,
85:22 - pretty much anything else is
fairly easy at that point.
85:25 - I would say this is one
of the weirder sides.
85:28 - Because in Lua, and Love2D, and
those kinds of environments,
85:32 - it's a little bit easier to do this
sort of thing with as much syntax.
85:37 - C#, being a statically-typed
environment, to get the same behavior,
85:42 - you have to go a little bit further.
85:46 - Do things their way.
85:48 - But that's getting asynchronous
behavior to work in C#.
85:54 - And in Unity, typically, in order
to avoid messy state management,
86:01 - you will use coroutines,
which are IEnumerators, often
86:06 - with the WaitForSeconds object.
86:09 - And just make sure to trigger
them with StartCoroutine.
86:14 - And then call that function
as if it were an object.
86:17 - Just like that.
86:20 - And the behavior for the airplane
spawner, the coin spawner,
86:25 - and so forth, they're
all fairly similar.
86:27 - So StartCoroutine SpawnCoins.
86:31 - And then while true.
86:32 - So coins-- this row just spawns a
random number of coins vertically.
86:36 - So you can have one, or you
can maybe have a couple.
86:40 - And then for each of
those, instantiate them
86:42 - at a random position on the y-axis.
86:46 - Here, random negative 10 to 10.
86:49 - In this case, Quaternion.Identity,
because we don't want
86:52 - to rotate them any differently than they
already are, which I alluded to before.
86:58 - So Quaternion.Identity just means
no rotation applied to the object.
87:01 - So whatever its base
rotation is as a prefab.
87:05 - So it'll be whatever it is
when you see it in the editor,
87:08 - and when you create a new one, that's
going to be its default rotation.
87:12 - So basically the equivalent of,
don't rotate this by anything.
87:18 - And then, same as we saw before,
yields a new WaitForSeconds.
87:25 - In this case, 1 to 5, so a little bit
more frequently than the airplane,
87:29 - on average.
87:30 - More coins.
87:31 - As the airplane, I believe, was 3
to 10, so every 3 to 10 seconds.
87:37 - And that's basically that.
87:39 - And then we StartCoroutine, just like
we did before with the airplane spawner.
87:44 - And then lastly, the skyscraper spawner.
87:47 - In this case, we only
have one coin prefab,
87:52 - we only have one airplane prefab,
but we have three skyscraper prefabs.
87:57 - And so the actual Random.Range
here comes into play,
88:01 - because that's how we get the different
color skyscrapers spawning at random.
88:05 - And like I said before,
this can be extrapolated
88:07 - to whatever sort of game
environment you want,
88:09 - where you have multiple
types of objects that
88:11 - are more complicated
than just a color swap,
88:13 - and you want to choose them at random.
88:17 - We're doing all the same
things that we did before.
88:20 - And also, here, we can see
that they have a random chance
88:25 - 1 in 4, so a 25% chance
of increasing the speed.
88:30 - So skyscraper spawner actually has--
and this is relevant to the assignment--
88:35 - skyscraper spawner has a float called
speed here, which is, by default, 10.
88:41 - And this drives the scroll speed
of the skyscrapers, the coins,
88:46 - and the airplanes.
88:48 - And so when we call it static,
do we know what that means?
88:53 - Yeah?
88:53 - AUDIENCE: Well, it's the same for
all [INAUDIBLE] objects [INAUDIBLE]..
89:00 - COLTON OGDEN: Yes.
89:01 - So no matter how many
skyscraper spawners we create,
89:07 - they're all going to
share this field speed,
89:10 - and it's always going to be equal to
the same amount across all instances.
89:13 - So static means that
it's part of the class.
89:15 - It belongs to the
SkyscraperSpawner class.
89:18 - It does not belong to a
SkyscraperSpawner object.
89:21 - And so we don't ever really want to
change that ourselves in this game.
89:26 - But the airplane, for example,
notice that in our Update function
89:32 - here, if the transform.position.x
is less than negative 25,
89:37 - we should destroy the airplane.
89:38 - So when it goes off screen,
we should destroy it.
89:41 - But if not, then we want
to translate this object
89:47 - on the x-axis by negative
SkyscraperSpawner.speed times 2 times
89:52 - Time.deltaTime.
89:54 - So we're translating it
on the x-axis, and we're
89:57 - using the SkyscraperSpawner.speed
as our core multiplier.
90:00 - And then if we look at coin--
90:03 - same thing.
90:08 - I should ask, what is
one design consideration
90:11 - if we're looking at this--
90:12 - all these components?
90:13 - And let's say we're trying
to get as decoupled as we
90:17 - can, and well-engineered as we can.
90:19 - What is a consideration that we
can, noticing that, for example,
90:23 - this exists in coin, and
this exists in airplane?
90:33 - AUDIENCE: What's the question again?
90:35 - COLTON OGDEN: So how could
we better engineer this?
90:37 - Notice that we have--
90:39 - and taking into consideration
this component model in Unity--
90:43 - what could we do with,
for example, this?
90:45 - AUDIENCE: So that Unity
better [INAUDIBLE]..
90:50 - COLTON OGDEN: Well, I'm thinking that,
because the airplane and the coin--
90:53 - well, first of all, it
wouldn't belong in the spawner,
90:55 - because the spawner's
job is to spawn coins.
90:58 - But the coins and the airplanes--
they have their behavior, right?
91:00 - They have their update behavior.
91:03 - But they're all doing kind of the same
thing, which is scrolling to the left,
91:06 - and then de-spawning at negative 25.
91:09 - So a design consideration here would
be, maybe we have a scroll component,
91:13 - right?
91:15 - Or a scroll and destroy component.
91:17 - Or just a scroll component
with an optional destroy flag.
91:20 - And then we just put this on anything
that we want to automatically scroll
91:23 - to the left screen and
de-spawn, rather than having
91:25 - to code this in every single class.
91:28 - So if you're ever looking
through your code,
91:30 - and you're seeing, for example, this and
this being the exact same, especially
91:39 - in Unity, because of how
flexible components are,
91:42 - try and think about how you can
make it into its own component.
91:46 - AUDIENCE: So where would you
put the coins [INAUDIBLE]??
91:48 - COLTON OGDEN: You make it yourself.
91:50 - So if we went into here, into
our Scripts thing, and just
91:53 - made a new script.
91:56 - And then we called it Scrollable.
91:59 - And then we double-click it,
it'll open up in our editor
92:02 - that we've chosen in our preferences.
92:04 - By default, it's going be Visual
Studio with the newer versions.
92:07 - But now we have a new
scrollable behavior.
92:09 - And then all we need to do--
92:10 - we would say, oops--
92:12 - not that.
92:13 - If-- once again, I can't type.
92:17 - Transform.position.x is
less than negative 25,
92:23 - destroy game object, right?
92:25 - And so this is the exact same thing as
all that behavior that we saw before.
92:30 - So now we can take all
of that out of coin--
92:35 - we can take this out, and we
can take this out here, and then
92:38 - just add to the airplane
and to the coin prefabs,
92:42 - we'd just add this
new Scrollable prefab,
92:44 - and it'll take care of that for us.
92:45 - Yeah.
92:46 - AUDIENCE: How would you add that?
92:48 - COLTON OGDEN: So if we're
going back to Unity--
92:50 - so the question is, how would you
add the component to the prefab?
92:54 - So in our prefabs, note that
we have airplane, we have coin,
92:57 - and we have all the skyscrapers.
92:58 - So these are all prefabs.
93:00 - Oh, and I haven't actually
detailed how to create
93:02 - a prefab, which I apologize for.
93:04 - So a prefab-- all you need to do
is create an object in your scene.
93:08 - For example, I did it
with this helicopter.
93:10 - So I'm going to delete the helicopter,
because this is just the helicopter
93:13 - prefab.
93:14 - It's not going to actually delete
the helicopter from our scene.
93:17 - But if I take this helicopter
here, and then I drag it in here,
93:24 - notice that now we have a prefab here.
93:29 - We could take this helicopter out,
and just add a new one right there.
93:33 - So now I have two helicopters.
93:36 - That's all a prefab is.
93:37 - It's just something that
you've made in your scene
93:40 - that you want to replicate or duplicate
in the future, ideally through code.
93:44 - And notice it's showing
here in our hierarchy view.
93:50 - But obviously you don't want that.
93:53 - But that's how you create a
prefab is, you find something
93:57 - that you've configured in your
game scene, and then in your code,
94:01 - you're allowed to then
instantiate that prefab,
94:04 - assuming that you've made that
prefab a member of whatever class
94:10 - instantiates it.
94:11 - So in this case, the airplane spawner.
94:13 - So notice that we call Instantiate
here, like we saw, before on line 24.
94:18 - But it's looking at prefabs.
94:21 - It's a list, and it's looking
at a random range between 0
94:24 - and the length of the prefabs.
94:27 - You have to declare a public
GameObject list prefabs here.
94:31 - And then, once we do that, and we
go to our airplane spawner here,
94:35 - notice that we have
this prefabs list here.
94:38 - So we actually get a editor view
of that code, that data structure.
94:44 - And we can just add
prefabs that we want to.
94:48 - And if we change the size to 2,
then we can add a second prefab.
94:54 - Or if we make the size 10, then we
can put 10 different airplanes there.
94:59 - But we only have one airplane that I
modeled, so I was going to make it 1.
95:02 - But this is the same thing.
95:05 - This GameObject list
is that same list, only
95:08 - that's the view we have
of it in the editor.
95:10 - And it's just a different
way of looking at the data.
95:13 - And that's the nice thing about
Unity is that, if you make
95:16 - any of your fields public, like this.
95:19 - If I did public int someNumber, right?
95:24 - And I save that, and I go
back here, my airplane spawner
95:27 - should get a someNumber right here.
95:32 - And then I can just set
someNumber to whatever I want.
95:34 - It doesn't do anything right
now, because someNumber
95:36 - doesn't affect the script.
95:37 - But this is a nice way to take the
burden from you out of the code.
95:44 - You're not experimenting with code.
95:46 - You're not tweaking some
variable in your script.
95:49 - SomeNumber 10, run me,
OK-- someNumber 12, run it.
95:52 - You can just assign it here
in your actual editor view,
95:56 - and then just tweak it as you want.
95:58 - So I can just scroll through it.
95:59 - I can start the game and
I can pause the game.
96:03 - AUDIENCE: So is it that
you just make it public?
96:05 - COLTON OGDEN: You have
to make it public.
96:06 - Exactly.
96:07 - AUDIENCE: Oh, then that shows in.
96:08 - COLTON OGDEN: Yep.
96:09 - And so I can just do this.
96:10 - And then I should be able to--
96:11 - I can just change this
now, if I wanted to, to 67.
96:14 - And so if that actually had some
sort of effect on my game world--
96:18 - if my game relied on that
number being meaningful--
96:21 - this would update the scene.
96:22 - And so you can make whatever--
you can debug this way,
96:25 - or you can customize your
components more this way.
96:29 - But it's just a tremendous
amount of flexibility.
96:33 - And so that's how we're instantiating
this from this list of prefabs.
96:37 - It's a list of game objects.
96:39 - We've made it explicit to Unity.
96:42 - The editor's going to know,
OK, these are game objects.
96:45 - And so prefabs are game objects.
96:47 - So we can just put any
of these into this field
96:51 - here, this element 0 field, or
however many fields we have.
96:55 - And it will, in the code,
randomly choose one of those,
96:59 - and then instantiate it.
97:01 - So any questions as to how
prefabs work, or instantiation,
97:04 - or anything like that?
97:07 - OK.
97:11 - AUDIENCE: Does each prefab
have a unique number or not?
97:14 - COLTON OGDEN: Does each
prefab have a unique number?
97:16 - Not a unique number.
97:18 - They just are all assets
in your folder here.
97:21 - They have some kind of identifier
to Unity that's hidden from you.
97:26 - It might be visible
from you if you look.
97:28 - They might have some sort of generated
ID or something like that, so
97:31 - that it knows, underneath the scenes.
97:33 - But it's not something that you
worry about in your actual code.
97:38 - We've created a list here that's just--
97:41 - it will expect some number.
97:43 - It doesn't know how many.
97:44 - And then, in the editor, you
can actually tell it how many.
97:50 - Because every list that
you make visible in
97:55 - the editor will have this size field.
97:58 - And that's just part of
the editor's abstraction.
98:00 - The editor has abstractions
for a lot of different objects.
98:04 - You can create a lot of different
objects in your MonoBehaviours,
98:07 - and make them public, and Unity
will have a different view for them.
98:12 - Things like color pickers,
and stuff like that.
98:14 - I don't know the exact object offhand,
but if you make a public color
98:17 - picker in your MonoBehaviour
or something like that,
98:20 - you'll actually get a color picker
here that you can choose a color for,
98:23 - which is pretty awesome.
98:24 - And there's a lot of
different customized views.
98:30 - I think, actually, the directional
light might be an example.
98:33 - See this color here?
98:34 - This is somewhere in code.
98:37 - There's a public color something.
98:40 - And then in the editor, when
you're actually editing it,
98:42 - you can choose the color.
98:43 - And Unity gives you the option
to make it wherever you want.
98:46 - And notice it's actually
affecting the background there.
98:50 - One of the really big
strengths of Unity,
98:52 - and a reason to really make
your components customizable,
98:56 - is this one-to-one mapping
between your data, your code,
99:01 - and your editor view of the data.
99:05 - Take the burden away
from you programming it,
99:07 - which you're more prone
to make mistakes, too,
99:10 - and also waste a lot of time.
99:12 - And then just be able to modify.
99:14 - How much faster is it
for me to just say,
99:16 - I want this red color, rather
than color.r equals something,
99:20 - and then color.g equals something,
color.b equals something.
99:23 - And then assign it that way.
99:24 - So that's just a simple
example to illustrate it.
99:26 - But there's a tremendous
amount of potential involved
99:29 - in making your components customizable.
99:33 - And so that's what I did here.
99:34 - Because I wanted the skyscraper spawner
to spawn not just one skyscraper
99:43 - but several skyscrapers, I
created this public prefabs list,
99:48 - that I can then populate
from Unity here.
99:50 - And say, OK, this object,
this object, and this object.
99:53 - Put that into the skyscraper
spawner here, in these slots.
99:56 - And then my code knows to instantiate
it, randomly picking one of those.
100:02 - Yeah.
100:02 - AUDIENCE: In the example
earlier, how would you
100:04 - actually go about making something
scrollable now that you've made that?
100:09 - Would you just add
component to the coin?
100:12 - COLTON OGDEN: How would you go about
making something scrollable now that
100:15 - you've--
100:15 - AUDIENCE: You declared that
Scrollable class, right?
100:18 - COLTON OGDEN: Oh, yeah.
100:19 - So I have a Scrollable script here.
100:24 - Oh, do you mean the infinite scrolling
background, or the scrollable object?
100:28 - AUDIENCE: The one where you define it as
being destroyed when it's [INAUDIBLE]..
100:31 - COLTON OGDEN: Oh, yeah.
100:32 - So in order to do that-- so we've
made the Scrollable script here.
100:35 - So you would just go to--
in this case, since we're
100:38 - instantiating all of the coins, and
skyscrapers, and airplanes as prefabs,
100:42 - you actually edit the prefab itself.
100:44 - So I'd go to this coin prefab.
100:46 - I'd add component here at the bottom.
100:48 - And I would add Scrollable
there, which is a script.
100:51 - And you can tell it's yours,
because it says script there.
100:54 - Just like coin here is a script,
and rotate script is a script.
100:57 - That's actually an old script
that I didn't use anymore,
101:01 - because I just made it
part of the coin itself.
101:05 - But this is another part of what
makes the coin class, by the way,
101:08 - is this transform.rotate x,
y, and z, either relative
101:14 - to itself or to the world space.
101:16 - In this case, it shows the
world space, because I want
101:18 - it to rotate on the world's y-axis.
101:20 - But if you rotate an object,
its own x, y, z still exist.
101:24 - And so you can have something
rotate about its own x, y,
101:26 - and z, regardless of its
rotation in the world.
101:29 - And so I want the coin to always rotate.
101:31 - So 5 degrees on the y-axis here.
101:35 - So this is another part that you could
take and make it its own script--
101:40 - just a rotatable script.
101:42 - Auto rotate script.
101:43 - And then just make these public fields,
like public x, public y, public z.
101:47 - And then you could change
those in the editor,
101:49 - and then actually customize your objects
without having to go into the code
101:54 - itself.
101:56 - AUDIENCE: So you don't have to do
any collisions, actually, yourself.
102:00 - You just click the button and
type in the Collide function.
102:04 - COLTON OGDEN: Yeah.
102:04 - You don't have to do any
of the collision yourself,
102:06 - because Unity comes with
a 3D physics engine.
102:09 - You have to tell it what to
do when the collisions happen.
102:12 - But you don't have to actually code
the 3D physics engine yourself, which
102:16 - is a tremendous amount of work.
102:19 - One of the big selling
points, definitely,
102:21 - for doing any 3D things in Unity.
102:23 - I mean, a lot of engines now
have 3D engines for free.
102:26 - There was a time when
it was less prevalent.
102:29 - AUDIENCE: How would you
know what you collided with?
102:31 - COLTON OGDEN: Because there
is a collider that it gets.
102:38 - Where is it again?
102:39 - Is it the skyscraper, for example?
102:41 - So every skyscraper, when
it collides with something,
102:43 - this OnTriggerEnter gets
passed in this collider other.
102:47 - And so that's going to be the
object that you collided with.
102:53 - You can assign a name to an object, and
then get its name, as well, in code,
102:56 - if you needed to do that.
102:58 - In this case, we wanted to know
whether it's the helicopter or not.
103:01 - So we got the HeliController from it.
103:04 - But in our game, it's
kind of a special case,
103:06 - because there's only
one type of object that
103:08 - has a collider that's a non-trigger,
and that's the helicopter.
103:11 - So we can assume that this exists
when we do get a collision.
103:15 - But otherwise, we probably want to
say, get component of HeliController,
103:20 - and then test it for equal to null.
103:22 - And if it's equal to null, then
we want to not do something.
103:26 - If we tried to call
explode on a null object,
103:29 - that's going to be a
null pointer exception.
103:31 - And then you're going
to crash your game.
103:33 - But in this case, we're
guaranteed for that not to happen.
103:36 - Because, like I said,
the only collider that
103:38 - can collide with this that's not a
trigger is the helicopter object.
103:42 - So does that makes sense?
103:45 - AUDIENCE: Sounds like a physics
problem with an exploding element.
103:48 - COLTON OGDEN: Oh, yeah.
103:49 - Yeah.
103:50 - That's all too real.
103:55 - In this case, though, all explode is
is, thankfully, just destroy game object
103:59 - and then start a particle effect.
104:00 - So any more questions
as to how instantiation,
104:04 - prefabs, using the Unity editor,
interacting with your model
104:08 - behaviors, public variables?
104:10 - Yeah.
104:11 - AUDIENCE: You get processes, you
first enter the data in that to there,
104:15 - and then it runs the
code to load the data,
104:19 - or can you also put
value data in the editor?
104:23 - COLTON OGDEN: You cannot define--
104:24 - so the question is, do you first
create the data in the editor,
104:27 - and then the code, and then
tie them together that way?
104:31 - In order to get a new component, you
will have to create the class first--
104:34 - the model behavior that you want--
104:37 - and give it the public fields that it
needs for the editor to actually read.
104:41 - So the editor reads your script,
looks through all the public fields,
104:45 - and then will create the necessary
GUI elements in the editor
104:47 - to interact with the code.
104:50 - But this needs to exist.
104:51 - All this code needs to exist.
104:52 - Anything that has these public variables
that you want accessible in the editor
104:56 - needs to exist in code
first, and then you
104:59 - have the power to use it in the editor.
105:00 - And then it's customizable
at that point.
105:04 - Any more questions?
105:08 - All right.
105:09 - So that's the prefabs.
105:11 - So we looked at texture
scrolling before.
105:13 - And we're going to go kind
of quickly through this.
105:15 - But all texture showing
was, if we recall,
105:18 - was I have a scrolling
background class here.
105:21 - It's got a scroll speed.
105:22 - So if we wanted to, since it's
public, we can edit it in the editor
105:25 - and make it faster or slower.
105:29 - But if we maintain a
reference to our renderer.
105:31 - Every object has a renderer-- mesh
renderer, typically, for 3D objects.
105:35 - And the renderer has a
material associated with it.
105:39 - Everything in Unity has a material.
105:43 - And material doesn't
necessarily have a texture.
105:45 - But in this case, our
background does have a texture,
105:48 - and it's going to be
called MainTex by default.
105:51 - That's the main texture, if
we want to assign a texture
105:53 - to see visually on a material.
105:55 - So material can just be a
color often, but it can also
105:59 - be a color and also a texture.
106:02 - So in this case, the
background is a texture.
106:04 - It does have a texture assigned to it.
106:05 - And notice that if we
go to the background,
106:09 - and then here is where
we actually create.
106:13 - So this is a material here.
106:15 - It's got a shader.
106:16 - So we're not going to talk too
much about what shaders are.
106:19 - We've talked about them briefly.
106:20 - In Unity, you can go quite
a bit farther with them.
106:24 - Well, technically speaking, I guess
you could go equally far with Love2D--
106:28 - 2D shaders and 3D shaders, at least
in vertex and fragment shaders.
106:34 - But for all intents
and purposes, we're not
106:37 - going to go into detail
on shaders today.
106:40 - But they're very similar.
106:42 - In this case, every material
has a shader in Unity,
106:47 - in order for it to render.
106:48 - Because anything that renders
needs to be shaded in Unity.
106:52 - But notice that here we have a texture.
106:54 - So this is that main texture
thing that we saw before.
106:57 - And then this is the bump map here.
106:58 - We don't have a bump map,
because our texture isn't bumpy.
107:01 - It doesn't have any contour
detail or anything like that.
107:04 - But you can just select a texture here.
107:06 - So I could give it that
texture if I wanted to.
107:08 - Or I have another
couple of textures here.
107:13 - This texture here.
107:14 - It doesn't matter which texture you
choose, but you can choose a texture.
107:18 - And then that material will
then, it will calculate,
107:21 - based on the mesh, how to
draw that texture best to it.
107:25 - And you can set every material's
texture offset via its SetTextureOffset
107:32 - function on the x and the y-axis.
107:34 - And that'll shift it,
effectively accomplishing
107:38 - what a scrolling background needs.
107:41 - It'll draw it, and then it'll basically
wrap around to the other side.
107:44 - So that's how we get the
infinite scrolling texture.
107:48 - We just set its texture offset.
107:51 - We specific call SetTextureOffset
on the main texture,
107:54 - and then we pass in a Vector 2.
107:55 - So just two numbers--
107:57 - offset and 0.
107:58 - Because we don't want to touch the
y-axis, so it was 0, and then offset
108:01 - is just some value that
increases over time.
108:04 - And then Time.time, recall--
108:06 - time since the beginning
of the game has started.
108:08 - Time.delta time-- time
since the last frame.
108:11 - And so we can just do one calculation
in here and update every time,
108:15 - and then multiply it
times scroll speed to get
108:17 - the scroll amount that we want here.
108:19 - And I've set it to 0.1 just
for a semi-slow effect.
108:23 - But in the editor, if we look at our
scrolling background, which is here.
108:32 - And then I've made it public, so
I could just easily make this 1.
108:36 - And I don't know how fast it's
going to be, but 10 times faster.
108:39 - So probably pretty fast.
108:41 - Yep.
108:42 - So it's hauling.
108:45 - But yeah.
108:45 - All that is is a shifting how it
maps the texture onto the 3D surface.
108:50 - And this 3D surface, to
be clear, is just a plane.
108:53 - So just a plane.
108:55 - And notice that it doesn't
get rendered from the back.
108:57 - So anything which is a polygon
has one side that gets shaded
109:02 - and one side that does not get shaded.
109:05 - So if you see invisibility on one
side, and not invisibility on one side,
109:09 - that's not a bug.
109:10 - That's a feature.
109:12 - That's the texture
scrolling side of things.
109:14 - Anybody have any questions
as to how that works?
109:18 - We won't really need it
for much going forward.
109:20 - It's not part of the assignment.
109:22 - But it ties in to what
we've done before.
109:24 - So I thought it would
be interesting to cover.
109:27 - Last thing we'll look at is audio.
109:28 - Audio is pretty easy.
109:30 - All you need in Unity to do audio is
an audio source and an audio listener.
109:37 - So a source plays audio.
109:39 - So James, if you are an audio
source, I'd be an audio listener.
109:44 - And I'm listening for
audio and playing it back
109:46 - to the speakers when I hear any sort
of source of audio in the game world.
109:52 - So you can have infinite audio sources,
but ideally one audio listener.
109:56 - And it's usually whatever main
camera that you're drawing with.
110:02 - And then sounds in Unity
can be either 2D or 3D.
110:05 - In this case, all the sounds that
I've put into this game are 2D.
110:10 - And that's just this spatial blend here.
110:12 - Notice that there's a 2D to 3D slide.
110:15 - And so that'll calculate,
based on where the sound is,
110:17 - how it sounds in the game space.
110:19 - And it's based on how far away it
is, and what side of you it is.
110:23 - And so the main camera has the
audio source for the music.
110:27 - And so it just starts
the music right away.
110:29 - Notice that we didn't
have to code any of this.
110:31 - I just attached an audio
source to the camera.
110:34 - And then there's a Play On Awake
checkbox, and a Loop checkbox.
110:38 - So normally we've done like--
110:40 - at the start of our game code,
set looping to true, and then
110:43 - play the source.
110:44 - In this case, we'd have to
do none of those things.
110:46 - This is just given to
us by Unity by default.
110:49 - AUDIENCE: You put the
audio on the camera?
110:51 - COLTON OGDEN: Yep.
110:51 - AUDIENCE: You could put it on anything.
110:53 - COLTON OGDEN: You could put
it on anything you want to.
110:54 - AUDIENCE: The sound is
relative to that object.
110:56 - COLTON OGDEN: The sound is
relative to that object, yeah.
111:01 - That's audio.
111:01 - It's pretty simple.
111:03 - I mean, it's an art form
when it comes to how
111:05 - you want to position
things in your game world,
111:06 - and how you want them
to sound, and whatnot.
111:09 - And you can get more
complicated with it.
111:10 - But that's how you would do
basic 2D, in this case, audio.
111:14 - But you could easily
also do 3D audio just
111:16 - by making this set to 0 from 0 to 1.
111:19 - And you can make it
more or less 3D, too.
111:21 - If it's not all the way to
1, it'll somewhat be 2D.
111:24 - So you'll hear some of it no matter
what, and some of it will be 3D.
111:27 - And then setting it to
1, it'll be purely 3D.
111:29 - So if it gets far enough away,
you won't hear it at all.
111:35 - The explosion sound, as
well, gets triggered.
111:40 - And so this happens in the--
111:41 - I forget exactly offhand
where it gets triggered.
111:49 - I believe it's in the
HelicopterExplode function?
111:55 - Oh, yes.
112:01 - I created an object in the scene that
has an audio source for the explosion
112:04 - sound.
112:05 - And because I made this public,
I can just put it on this object.
112:08 - And so there's a reference to
that audio source at all times.
112:12 - And so I trigger explosionSound.play
whenever we call this Explode method
112:16 - on the HeliController.
112:17 - For the reason that I didn't put it
on this object, because we destroy
112:20 - this object as soon as
we get into a collision.
112:24 - And so I didn't want to
put the explosion sound
112:27 - audio source on this object, because
it would get destroyed in there.
112:30 - It would not play audio, effectively,
as soon as we destroy it.
112:33 - So we have to have it
somewhere else on the scene.
112:35 - I could have also just made the
object invisible, but I didn't.
112:40 - I destroyed it.
112:44 - And so, yeah.
112:46 - That's this explosion sound object
which, if we look at the helicopter,
112:51 - in the HeliController, which
is all the way down here.
112:57 - Notice that it has a reference
to an explosion particle
113:01 - system and an explosion sound.
113:03 - And we just have to click and drag the
object effectively from here to here
113:08 - to pair the two of them.
113:09 - And then the script
that this is referring
113:11 - to will always have a reference
to those, as long as these
113:14 - are set to something.
113:15 - And notice that we also have
coin total we've made public.
113:18 - So I guess I could experiment with it.
113:19 - And then speed-- we made this public
so that you can make the helicopter
113:22 - faster, if you wanted to, or slower.
113:25 - And so you'll find it often useful
to make a lot of these fields public
113:30 - just for you to experiment with.
113:32 - And then there's never
really harm in doing so,
113:34 - because folks aren't going to be able
to actually see this in the editor
113:39 - when they download your game.
113:40 - So make as much public as you
want for debugging purposes,
113:43 - and just have fun with it.
113:46 - But that's audio.
113:46 - Audio sources produce the sound.
113:48 - Audio listeners listen to the sound.
113:50 - And actually make it go
through your computer speakers
113:53 - or whatever your
default audio system is.
113:57 - And here's just a showcase
of the two on the camera.
114:01 - And that's audio.
114:03 - So any questions as to how
the audio works at all?
114:08 - All right.
114:09 - A couple of last things
before we close out here.
114:11 - So the Asset Store is probably one
of the biggest things about Unity
114:14 - that sells it.
114:16 - So oftentimes, it's a lot
easier just to get something,
114:20 - whether it's a library, if you're
programming, or something else,
114:23 - get something that's
implemented for you,
114:25 - so that you don't have
to implement it yourself.
114:29 - In this case, there's an RPG
Systems for Rapid Development
114:32 - something, Visual Scripting
system, looks similar to Unreal.
114:36 - There's a ton of things in the Asset
Store-- models, scripts, audio, editor
114:43 - tool kits.
114:44 - A lot of cool things.
114:45 - A lot of it's free, if
you want to experiment.
114:48 - So a lot of the assets that I got
to mess with in this game here
114:52 - are free, like the coin and some of
the other stuff that's bundled with it.
114:56 - There's a lot of really cool
things and really cool systems
114:58 - to help you for $10 or $20.
115:00 - You can spend a little
bit of money, and then
115:02 - get like 25% of your
game done right away.
115:06 - And then you can actually
get closer to shipping it.
115:08 - So I think it's hugely valuable
to be looking at the Asset Store
115:12 - and thinking about how you
can save your time that way,
115:15 - if you're trying to actually
ship a game and get to market.
115:18 - So definitely look
through the Asset Store.
115:21 - See if there's anything that
will make your life easier
115:24 - when it comes to developing games.
115:25 - Because I know that I've used it several
times, and I rarely regret doing so.
115:30 - So Assignment 8 is going
to be pretty simple.
115:35 - So for the second part,
there's a bug in the game
115:39 - where, if you die over and over
again, the scroll speed never resets.
115:45 - So it is keeping faster, and faster,
and faster, and faster forever.
115:48 - But it's a one line fix.
115:50 - And I want you guys to find where
to fix it, given that we know,
115:54 - given what we've seen today.
115:55 - And there's a hint here
about static variables.
115:57 - So it will also be detailed
in the spec as well.
116:01 - But this is an easy part.
116:03 - This part's fairly easy,
too, because all it really is
116:05 - is taking the kind of the
same stuff we've looked at--
116:08 - the coin generator and coins--
116:10 - and then making gems that spawn in
addition to the coins at a rarer rate.
116:16 - And these gems should
be worth five coins.
116:19 - And so when you collide with the
gems, just add 5 to the coin total.
116:22 - And if you collide with a
coin, add 1 to the coin total.
116:25 - And that's basically
it for Assignment 8.
116:27 - So next time, we're going to dive
into first-person games in Unity.
116:31 - So we'll look at some of the
features that we get for free.
116:35 - We're going to implement a simple
maze-like game where you can navigate.
116:39 - And it will be dark and
kind of scary, similar
116:41 - to a game called Dreadhalls,
which is a mobile VR game.
116:43 - And we'll actually test out Unity's VR,
and try and get a VR headset in here
116:48 - so people can check that out.
116:51 - Cool.
116:51 - Thanks a lot.
116:52 - I'll see you guys next time.