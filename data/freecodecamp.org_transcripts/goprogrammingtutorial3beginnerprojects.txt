00:00 - improve your go programming skills by
00:02 - developing three different projects in
00:04 - this go course experience developer Akil
00:07 - Sharma will teach you how to build a
00:09 - website Health Checker a program to
00:11 - encrypt text and a program to encrypt
00:14 - files hey guys in this video we're
00:17 - building three awesome projects with
00:19 - goang now these are beginner friendly
00:21 - projects and awesome additions to your
00:23 - portfolio in case you're applying for a
00:25 - goang job in the first project we're
00:27 - going to be building a goang health
00:30 - Checker where we'll check the health of
00:31 - a website so you'll just have to enter
00:33 - the domain name of a website and you'll
00:35 - come to know if it's live or it's down
00:37 - the second project is about encrypting
00:39 - files so we'll start with the PNG file
00:41 - and we'll encrypt it we'll try to access
00:43 - it without the password and then we'll
00:45 - access it with the password to see how
00:47 - encryption works the third project is
00:49 - about encrypting a string with goang so
00:52 - all these three projects you learn quite
00:53 - a bit a lot of goang so if you have
00:55 - basic goang skills you'll be able to
00:57 - refine your skills and build on top of
00:59 - that not knowledge so let's get started
01:02 - hey guys welcome back in today's video
01:05 - we're building a very simple project
01:07 - we're going to build a goang project
01:09 - which checks if a website is running or
01:12 - it's down and accordingly we'll show the
01:14 - appropriate message in the terminal
01:16 - saying the website is up or running or
01:19 - it's down or not running right and
01:22 - you'll find these kind of projects uh
01:24 - very easily on Google if you go and if
01:26 - you check if the is the website on there
01:28 - many projects like these and they
01:30 - basically run it free of cost but then
01:32 - they show ads so if you want to do that
01:34 - you can do that as well but it's just a
01:36 - great project to build and to basically
01:39 - practice your goang skills right uh now
01:42 - this project is going to be a part of
01:44 - the uh goang playlist goang Project
01:47 - Playlist so in my YouTube If you go to
01:50 - the playlist there's a goang playlist it
01:53 - right now it has 46 projects so I have
01:55 - called it the 46 killer goang projects
01:57 - playlist but then the number keeps Chang
01:59 - changing so once I put this video it'll
02:01 - be like 47 goang projects right so
02:05 - depending on when you watch this video
02:07 - the number would have changed but then
02:09 - you know it's important to know that
02:10 - that playlist exists and you can and
02:13 - what I'm trying to do is I'm trying to
02:14 - arrange those projects in the increasing
02:16 - level of difficulty and this project
02:18 - since it's very small and very simple
02:20 - we'll place it towards the beginning of
02:23 - that playlist even though I'm releasing
02:25 - it quite at the end but I'm going to
02:27 - actually position it towards the
02:29 - beginning of of the playlist okay so
02:31 - with that out of the way we can get
02:33 - started I'll show you a couple of
02:35 - diagrams just to help you visualize what
02:37 - your building uh and then we'll just go
02:40 - ahead and build it all right now just
02:42 - before we get started I just want to
02:44 - tell you that a very common name for
02:45 - this project that we're building is
02:47 - called the health Checker right so for
02:49 - any project that you're building you
02:50 - might also want to create a health
02:53 - Checker microservice in case you don't
02:55 - want to launch this as your own project
02:57 - on the internet completely fine uh but
03:00 - you can but usually when people build
03:02 - let's say a project and then they
03:03 - usually build a microservice which
03:04 - checks health of their own
03:06 - project so with with the project that we
03:09 - building you could do that like check
03:10 - the health of your own project or you
03:11 - could check the health of any website
03:13 - that's up or down you can check that
03:15 - state status of that website all right
03:18 - now we can get started so now I think
03:21 - you can see my
03:22 - screen here uh we've just represented
03:25 - what we'll be doing in our code so we'll
03:28 - have a main.go file which will have the
03:30 - main function and all we doing is
03:33 - importing the CLI package so it could be
03:35 - any CLI package like you could be using
03:37 - something like uh Cobra or something
03:39 - like that but I'll be using something
03:40 - very small and basic in this project
03:42 - because this project is small right and
03:45 - um we'll be passing two things we'll be
03:48 - making use of two things one is Flags so
03:50 - we'll set two flags which is the domain
03:51 - and the port and the action for the CLI
03:55 - tool tool would be to call the check
03:57 - function okay the check function is is
03:59 - going to be defined in a file called
04:01 - check. go it's going to accept
04:03 - destination and Port because that's what
04:04 - we'll send from here to this function
04:06 - destination and port and the whole
04:09 - business logic here or the Crux of the
04:11 - entire program is the dial timeout
04:13 - function this function you get in this
04:16 - package called net the net package very
04:18 - popular package to work with uh web web
04:20 - related things in goang right so we'll
04:22 - use D dial time out package and finally
04:26 - we will return the status of the website
04:28 - whether it's up or down so that's the
04:31 - entire business logic here in the in the
04:33 - project so now let's go ahead create a
04:36 - new project and get
04:37 - started all right so now we'll start
04:40 - building our project everything that
04:42 - I'll be showing you in this video is
04:44 - already there in my GitHub account so
04:47 - make sure you check out Akil Sharma 90
04:48 - which is my username on GitHub all the
04:51 - projects are there check out the code in
04:53 - case you get stuck somewhere we just
04:55 - create a new directory called go health
04:59 - check
05:00 - YT so we'll CD into
05:03 - it and what we'll do is we will um go
05:08 - mod in
05:09 - it and I'll just give it my
05:14 - username go health check right okay so
05:20 - now you can see the go mod file already
05:22 - has been created and we will just open
05:26 - up our vs fold and check out that yeah
05:29 - everything looks all right now I have
05:31 - decided upon the uh package that I'll be
05:35 - using it's CLI version two and I found
05:39 - it on this uh project on this profile
05:42 - called yourf This is a common package
05:44 - it's very very light so if you're not
05:47 - building something huge like a proper CI
05:49 - tool I recommend using something like
05:51 - this something very light like this
05:53 - there thousands of packages like these
05:54 - by the way but if you're building
05:56 - something serious then obviously Cobra
05:58 - CLI is is the way to go anyways now
06:01 - we'll create two files as you know one
06:03 - is the main.go
06:04 - file and the other is our check. go file
06:08 - okay in the main. go
06:10 - file we will do the regular stuff
06:14 - package name import the import
06:17 - statements and all of that and in the
06:19 - import I want to put this package so
06:22 - that it's clear that we're going to use
06:26 - it and then you have your fun
06:29 - main that's how you start that's the
06:33 - most important part in your main main.
06:35 - go file obviously and I'm going to go
06:38 - ahead and create an uh create app which
06:41 - is basically C.A right CLI being the
06:44 - package that I'm
06:46 - using and this helps to create a
06:48 - complete CLI tool where I can give it a
06:50 - name I can show how the tool is used I
06:53 - can give in the flags we've already
06:55 - talked about the flags and I can talk
06:57 - about the action it's supposed to have
06:59 - happen when
07:01 - the you know the right commands are or
07:06 - the right yeah the right commands are
07:08 - given what's the action that's supposed
07:10 - to
07:11 - happen all
07:15 - right
07:16 - [Music]
07:20 - so yeah now for for the name what we'll
07:24 - say is we'll say let's call
07:26 - it health checker
07:30 - and the usage let's usage basically
07:32 - basic text of how this product is going
07:34 - to be useful say tiny
07:36 - tool that
07:40 - checks whether a
07:42 - website is running or it's
07:47 - down and then there are the flags so CLI
07:51 - do
07:58 - flag
08:06 - okay and here you have the name which is
08:13 - domain
08:17 - aliases
08:18 - [Music]
08:20 - string
08:22 - D and the usage which is the this is
08:26 - where you'll enter the domain name like
08:27 - for example google.com that's the domain
08:29 - name to check whether it's up or down so
08:32 - that's domain and it's obviously it's
08:34 - required so we say required is true
08:36 - without this there's no point of the app
08:38 - if if you don't have this
08:40 - right all right so uh in the flags
08:43 - there's one more flag that we going to
08:45 - have which is the c. string flag it's
08:49 - going to be name will
08:51 - be
08:53 - Port Al
08:57 - s's string
09:02 - B
09:04 - Visage port number to
09:09 - check and
09:12 - required
09:17 - false
09:19 - right now for the
09:25 - action you're going to have c.
09:28 - context
09:35 - and we might return an
09:38 - error and let's define the port which is
09:41 - C do
09:44 - string and the
09:46 - port and if c.
09:49 - string and
09:52 - Port is null which is
09:55 - empty then the port will be 80 right so
09:58 - what's happening here which is standard
10:00 - basically whenever you check anything
10:02 - you're checking on Port 80 which is like
10:03 - the most common Port right where the uh
10:06 - the hand check would happen anyways but
10:09 - let's say um you but you can you can say
10:13 - any port you can mention any port here
10:15 - but if you have not mentioned any port
10:17 - here the default Port which is 80 which
10:20 - is the one that that's always checked
10:21 - that's the one that will be um set right
10:26 - for the port variable and then you have
10:30 - status is equal to check so this is the
10:32 - check function I was talking about which
10:34 - which we will create in the other file
10:36 - called the check.of file and you are
10:38 - checking the domain and the port so we
10:41 - sending two things to the check function
10:43 - which is domain and the port which is
10:44 - what I had shown you in the
10:45 - diagram
10:48 - and we're going to print the
10:51 - status and return ma for the error if
10:55 - everything go
10:58 - well here we'll say
11:02 - error equal to app.
11:07 - run okay so you say app which you just
11:11 - created the whole app using the CLI uh
11:14 - package and you're going to say app.run
11:16 - passing in the OS arguments and you're
11:19 - also handling the error so if there is
11:22 - an error you can do something about it
11:24 - if the error is not equal to n that
11:26 - means the error is there it's say log
11:28 - dot fatal and you'll print out the
11:34 - error all
11:37 - right and now we can work on the other
11:42 - file which is check. go so now we're
11:45 - going to go ahead and create the check.
11:47 - go file before that what I'll do is I'll
11:51 - just say go mod Ty just to create the go
11:55 - s
11:56 - file there seems to be some problem
11:58 - we'll fix fix it no
12:00 - problem so right now let's just create
12:02 - the check. go file okay so say package
12:05 - main also this part of package main only
12:09 - not creating a separate
12:11 - package and
12:14 - here uh there are a few more packages
12:17 - that I've used actually like fmt and all
12:20 - those and somehow they've not come up so
12:23 - usually when I save the files they come
12:25 - up like my plugins are not working I
12:27 - think right now I'll just copy and paste
12:29 - them on my own
12:31 - anyways all right so here also I'll need
12:34 - some packages I'll just say fmt time and
12:38 - net the most important one obviously
12:40 - here is the net package you know that
12:42 - because the net package has the um dial
12:47 - timeout function that we'll use to
12:49 - actually check the status of the website
12:51 - so we'll say fun
12:53 - check
12:56 - destination it's a string and Port which
12:59 - is a string and return the string string
13:03 - being the status so we return the status
13:05 - from the check
13:08 - function so here we'll say
13:14 - address equal
13:16 - to
13:18 - destination
13:23 - Plus Port right destination being the
13:26 - domain name and Port being the port that
13:28 - you pass in or or
13:31 - even um Port 80 which is the default
13:36 - right so we'll say for the duration
13:39 - of 5
13:43 - Seconds is a time
13:46 - out so within 5 seconds if you get a
13:49 - response back from the website that
13:51 - means the website is on otherwise it's
13:56 - not okay this is the main part which is
13:59 - we're using the net package and the dial
14:02 - timeout
14:05 - function we need to send in the address
14:08 - which is basically the destination the
14:09 - port both combined with the timeout
14:12 - which is 5 seconds in our
14:14 - case and let's create a variable called
14:18 - status which is the one that we're going
14:19 - to return from this
14:21 - function and here this error that we
14:24 - have which
14:25 - is we're checking we'll have to now
14:27 - check for that error so we'll say if
14:29 - error is not equal to nil means there is
14:33 - some error then we'll say status would
14:35 - be fmt dot Sprint
14:42 - F
14:44 - down website is not reachable so to
14:47 - print out the name of the website star V
14:49 - sorry percentage V is unreachable the
14:52 - website is not
14:54 - reachable and you
14:56 - can print out the error for percentage
15:02 - three and here the actual variables
15:05 - which is destination
15:09 - and the error all
15:12 - right
15:14 - else we will say status we FMP do
15:21 - printf and we
15:24 - say
15:27 - up
15:29 - percentage V
15:32 - that's the basically
15:35 - the website is
15:39 - reachable and then we'll print out
15:43 - from which address we
15:47 - tried
15:49 - to which
15:53 - address that means the
15:57 - destination comma
16:00 - [Music]
16:04 - connection
16:07 - dot local address right so your
16:10 - connection variable will have a copy of
16:13 - local address the address at your end
16:15 - which is making the conect the the
16:17 - request and the remote address basically
16:19 - the website and the port that you had
16:23 - mentioned just above and
16:27 - finally when your the status okay so all
16:32 - okay here I
16:35 - think to get rid of the error just
16:38 - remove this quickly and let goang do it
16:42 - for you so just say go mod tid it'll get
16:46 - all the
16:49 - packages right that you're supposed to
16:52 - have and it'll also generate the go. sum
16:54 - file for you here in the main. go file
16:56 - there's an issue because there's a small
16:58 - spelling mistake it should have been
17:02 - adss and uh but I see one more error so
17:06 - me quickly
17:08 - check yeah the other thing is that
17:11 - there's another spelling mistake here
17:12 - it's
17:14 - CLI all right so
17:17 - hopefully everything should be fine now
17:19 - but I still see one more
17:22 - error all right
17:25 - so uh yeah that's one more issue which
17:29 - is spelling of name is wrong I'll just
17:32 - save it everything seems fine now to
17:37 - me uh here so by flag you know what you
17:42 - mean by flag is that when we run this uh
17:46 - tool now we'll have
17:49 - to pass the flag so let me actually show
17:53 - you how to do it so we'll say go run do
17:57 - minus minus domain which which is the
17:58 - flag now in our case and it could be
18:01 - tel.com
18:02 - so it's saying it's reachable right so
18:05 - if you
18:07 - say
18:11 - google.com
18:14 - and
18:16 - amazon.com yeah so all the websites are
18:19 - up at the moment all of them are
18:20 - reachable all right so that was our
18:24 - simple yet effective tool that we've
18:27 - built
18:29 - and we've done we've done quite a bit in
18:32 - this
18:33 - tutorial uh it's a very very tiny tool
18:36 - but then a lot of Concepts have been
18:38 - used here so I hope you've learned quite
18:41 - a bit thank you so much for watching do
18:42 - make sure you watch all the other
18:44 - projects in this series because there so
18:46 - much to learn right and thank you so
18:49 - much for watching and do subscribe hey
18:52 - hey hey in today's video we are
18:54 - encrypting files with goang so in my
18:57 - root directory of this project I have
19:00 - the img.png file which I'm going to now
19:04 - encrypt so as you can see I can I can
19:06 - see the file now right but if I encrypt
19:08 - it so I'll say go
19:10 - run
19:13 - encrypt uh and I'll say img.png which is
19:16 - the name of the file I want to encrypt
19:18 - and I'll enter some password it'll
19:20 - confirm the password and it'll encrypt
19:21 - it for me and say it'll say file
19:24 - successfully protected and now as you
19:26 - can see I can't see it anymore I can't
19:29 - see the file anymore but now if I go and
19:32 - if I just decrypt the same
19:34 - file it will ask me to enter the
19:37 - password it will say file successfully
19:38 - decrypted and now again sorry now again
19:42 - I can see the image awesome
19:46 - right so how is this happening so let me
19:50 - let me take you through it so in the
19:52 - beginning what will happen is we will
19:55 - accept the um r arguments from user
19:59 - which is uh the basically the file the
20:03 - path to the file or the file name we'll
20:05 - validate if the file even exists or not
20:07 - and we'll also ask the user for the
20:09 - password and we'll validate the password
20:12 - in the sense if both the passwords match
20:13 - this is for the encryption part right
20:15 - we'll check if both the passwords match
20:17 - password one and password two then we'll
20:20 - encrypt the file and then for decrypt
20:22 - we'll again check the password after
20:24 - getting the password we check the
20:25 - password okay so it's really
20:27 - straightforward for for from a 10,000 ft
20:29 - perspective this is what's happening
20:30 - just getting arguments from the user
20:32 - validating the file getting the password
20:34 - from the user and cing the file by
20:36 - validating the password and then
20:37 - decrypting the file with the same
20:39 - password that's what's happening but if
20:41 - you look uh more if you look a bit
20:43 - deeper then you have two parts
20:46 - encryption and decryption in the
20:47 - encryption part uh we follow multiple
20:50 - steps so we first check for the source
20:52 - file we open that source file the one
20:54 - with the plain text which was our
20:56 - img.png and and then we'll re read that
20:59 - plain text now it could be the data from
21:01 - the PNG or it could be a text file right
21:03 - whatever it is it's basically plain data
21:05 - from the source file then we'll create
21:08 - an empty uh variable called a nuns this
21:10 - will be 12 bits or 12 bytes in our in
21:13 - our case and we'll create we'll
21:15 - randomize it so we'll create a random
21:16 - basically 12 byte uh variable we because
21:20 - we want to use it later on so firstly
21:23 - you have the password that we'll use to
21:24 - encrypt the file right so the the
21:26 - password and then there's something
21:27 - called as the length in the sense what
21:29 - do you want to get after running a
21:31 - derivation function so we'll basically
21:33 - be running a password based derivation
21:35 - function I'll talk more about it the
21:37 - first thing you need is a password the
21:38 - next thing you need is the bip length in
21:40 - our case will be 32 then the algorithm
21:42 - with which we want to encrypt it and the
21:45 - number of iterations in our case it will
21:46 - be like some somewhere around 4,000
21:48 - iterations iterations basically make it
21:50 - more difficult for the party that wants
21:52 - to uh hack this or or break the
21:55 - encryption just makes it more difficult
21:57 - for them okay okay so uh with the
21:59 - password based key derivation function
22:01 - this is a function in which a key will
22:03 - be generated from the password so we'll
22:04 - take in the password and we'll add in a
22:06 - few different things as you can see and
22:08 - we'll get a key and this can be used as
22:11 - an encryption key or the hash value so
22:13 - we basically just hashing the password
22:14 - now this is very similar to how you um
22:18 - take the users's password you hash it
22:19 - and then you store in the database right
22:21 - because you don't want to store the
22:22 - passwords directly in the database
22:23 - because otherwise people can steal or
22:26 - get access to the database steal all the
22:27 - password right so you always hash the
22:30 - passwords with some salt and that's
22:31 - what's happening here right so uh this
22:35 - is the salt in this case the nuns so
22:38 - with the password based key dation
22:39 - function you get something called as a
22:41 - derived key now the derived key we'll
22:43 - run it past uh AES or Advanced
22:46 - encryption standard this will give us
22:48 - some solid encryption abilities after
22:51 - after getting the key from the password
22:53 - and we'll and this by by running it
22:55 - through the a a cipher we'll get
22:57 - something called as a cyer for block and
22:59 - that again we'll run from uh through
23:02 - something called as the uh galwa counter
23:05 - mode now this is spelled as g l o i s
23:08 - but I think this is like a French word
23:10 - so you say gal galwa or something like
23:12 - that I'm not French so I have no idea so
23:15 - it's the GCM I call it the GCM galwa
23:18 - cter whatever blah blah blah but GCM
23:20 - basically right and GCM gives you more
23:22 - encryption with data Integrity checks
23:24 - now GCM generates a tag which is
23:27 - appended to the C Cipher text at the end
23:29 - and this tag is used to verify the
23:30 - Integrity upon data encryption now you
23:32 - had some data you encrypted it but then
23:34 - how do you know that the data that you
23:36 - got back is actually the correct data
23:38 - and that's why we using GCM because that
23:40 - gives us the tag to verify the Integrity
23:43 - of of the data upon decryption and GCM
23:46 - uses AES so we as as you know we have
23:47 - already used AES before it uses AES to
23:49 - encrypt the plain text this operates in
23:51 - a counter mode and hence the name and
23:53 - and generates a stream of encrypted
23:56 - blocks that's what GCM does finally we
23:58 - use this uh function called AES GCM
24:01 - which AES GCM is what you get so you
24:03 - already had the AES Cipher which is the
24:05 - ciper block then you run it through GCM
24:08 - you get AES GCM and you run this
24:10 - function called AES GCM do seal this is
24:12 - the main function now this is uh just to
24:15 - use this function we had to do all of
24:17 - this basically all of this part because
24:19 - we wanted to run this function called
24:20 - the seal function and the seal function
24:22 - is what takes the plain text from our
24:24 - file from our IMG file or any other file
24:27 - and convert it into Cipher text and it
24:29 - then creates a source file for encrypted
24:31 - data and we write Cipher text to the new
24:34 - source file so the the file in our case
24:37 - Remains the Same but then again we have
24:38 - to create the source file for the
24:40 - incryptor and write the cipher text
24:41 - Cipher text is basically text that we
24:43 - can't then access right so that'll be
24:45 - written to the source file so that's the
24:47 - encryption now let's go over the
24:49 - decryption for the decryption it's very
24:51 - very similar uh we'll check for the
24:53 - encrypted file so here we were checking
24:55 - for the source file that had to be
24:57 - encrypted and now we'll be checking for
24:58 - the encrypted file because uh to our
25:00 - program we will be saying that hey this
25:02 - is the encrypted file please decrypt it
25:04 - for me so we'll check for the encrypted
25:05 - file we'll open that file we'll read the
25:07 - cipher text from the enced file right
25:11 - the text that we can't open in our IDE
25:13 - but it still can be read from our
25:14 - function now to convert the cipher text
25:17 - into uh regular plane text we have to
25:21 - again run the password based key
25:23 - activation function so we'll have to
25:25 - have the same password which we used to
25:27 - enp we you have to have the same
25:28 - password to decrypt uh decrypt it as
25:30 - well same bite length same algorithm sh
25:33 - one and the number of itation should
25:35 - also be the same and then the nuns uh as
25:38 - you remember we created a nuns here a
25:40 - randomized nuns and uh the the GCM
25:42 - basically uh appended the nuns to the
25:45 - cipher text and exactly that's what we
25:47 - want we want to get the nuns from here
25:49 - uh which will be at the end so the the
25:51 - last 12 digits of the encrypted file
25:53 - will have the nuns you want access to
25:55 - that so all of these uh five things
25:58 - we'll pass to the password based key
26:01 - derivation function we'll get the
26:02 - derived key again the same thing as
26:05 - Cipher we'll get the cipher block GCM
26:07 - you'll get a GCM now we did again we did
26:10 - all of this so this was important
26:12 - obviously you know that you have to use
26:13 - SOL to Hash the password this is perfect
26:16 - but these extra steps we only did
26:17 - because we wanted to use this aesg cm.
26:19 - openen function which takes in the
26:22 - cipher text to this function without the
26:24 - NS obviously and gets you back the plain
26:26 - text now the pl text is what you will
26:28 - write again to a file which will have
26:31 - the decrypted data or the other PL text
26:33 - and that's the one that you will write
26:35 - back to the file and that's how you'll
26:36 - be able to read the file again so that's
26:38 - what's happening in your encryption and
26:40 - decryption so in our program in the code
26:42 - what we'll need to have is we'll need to
26:44 - um do all of this like the whole entire
26:47 - Logic for the encrypt function and the
26:50 - entire Logic for the decryption function
26:51 - and I'll keep opening this diagram again
26:53 - and again in between just so that we
26:55 - able to refer it while we are writing
26:57 - the code but the program also needs to
26:59 - do all of this so we'll the way I'm
27:01 - thinking of it is that I'll need one
27:03 - file which will have the encryption
27:04 - decryption functions and I'll need one
27:06 - file which is the main.go file which
27:07 - will will have all of this thing which
27:09 - will print out stuff to the terminal and
27:11 - accept uh values from the user from the
27:13 - terminal so all of that logic I'll put
27:15 - in main.go file okay so now we can start
27:18 - writing our code now before we start
27:20 - writing our code just want to tell you
27:21 - that um on my channel this particular
27:25 - video that we creating right now will
27:27 - show up in the 48 killer goang project
27:30 - Series so this is a playlist which
27:33 - basically is uh which has 48 projects
27:35 - now but I'll add this one so it'll be 49
27:38 - projects and um this playlist right is
27:43 - in the order of difficulty so we have
27:46 - smaller uh simpler programs earlier and
27:48 - then more difficult programs later on
27:50 - this will be somewhere in the middle
27:51 - it's not or somewhere towards the end
27:53 - but not at the complete end because this
27:55 - is not very difficult to build what we
27:57 - building today today uh so um just make
28:00 - sure you you go through all the videos
28:01 - in this playlist and you build them one
28:04 - by one and once you've done that you
28:05 - will no goang better than more better
28:08 - than 90% of the people or 99% of the
28:10 - people actually out there because I mean
28:13 - uh how many people do you know who build
28:15 - like 50 50 projects with goang right not
28:18 - many so this will seriously give you an
28:20 - edge if you build all the projects in
28:22 - this playlist all
28:24 - right and and uh I also wanted to tell
28:26 - you one more thing that if you go to my
28:29 - channel uh you get access to this
28:32 - Discord link here as you can see this is
28:34 - the Discord link for this community out
28:37 - here which is uh where we discuss a lot
28:40 - of stuff around golang and we share our
28:43 - learnings what we've been learning today
28:45 - uh we have a lot of um like forums where
28:48 - we uh discuss issues uh that we that
28:51 - you're facing blah blah blah so lot lot
28:53 - of stuff here so uh a lot of cool
28:55 - discussions happening so make sure sure
28:57 - you join this because uh I mean if you
29:00 - want to learn if you want to learn goang
29:01 - this is the right place to be this is
29:03 - the right Community to be at all right
29:05 - because I'm here quite a lot as you can
29:07 - see it's always open on my browser these
29:09 - days so I'm always there replying to
29:11 - messages all right so uh I have now
29:14 - talked through all the things that I
29:15 - wanted to talk through so now is the
29:18 - time to start building the project what
29:22 - I'll now do is I'll create a
29:25 - new uh directory
29:28 - called go file
29:32 - encryption by the way this program this
29:35 - project already exists on my GitHub so
29:38 - in case uh you are are already following
29:43 - me on GitHub uh you will see this
29:45 - program there the F encryption one um in
29:48 - case I don't put the link to this
29:50 - project in my description of this video
29:53 - please know that my GitHub is Akil
29:55 - Sharma 90 ail s RMA 90 the project is
29:59 - there in case you get stuck somewhere um
30:02 - you can access the code you can look at
30:04 - the code and build along with me all
30:06 - right so here I will CD into it I will
30:09 - CD into go file encryption and we will
30:13 - say go mod in
30:15 - it
30:17 - github.com
30:20 - sharma9
30:22 - SL code file
30:26 - encryption
30:28 - this creates a um go. mod file for us
30:32 - which will have the list of all our
30:33 - dependencies and I'll just go ahead and
30:36 - open this up in my code
30:41 - infl here I'll just create a um main.go
30:46 - file and I'll create a folder for file
30:53 - Crypt and there will be a file called
31:00 - filecrypt okay now I told you that I'll
31:04 - divide the logic into two different
31:05 - parts one will be the uh interfacing
31:08 - with the user part and the other will be
31:10 - the actual encryption and decryption so
31:14 - let's talk about the part where we'll
31:17 - accept user values so we first start
31:20 - with sorry package main not M we start
31:24 - with package main all right and there
31:27 - will obviously be Funk main which is
31:30 - from so main is the most important file
31:32 - main. go is the most important file
31:33 - which is obviously the main package
31:35 - again and then it has the main function
31:37 - which is where the uh program begins
31:39 - from or Origins everything starts from
31:41 - here and then this is why from this
31:43 - function we have to call all the other
31:44 - functions this is like the root or the
31:46 - source of everything then there will be
31:48 - an import statement here and I'll import
31:51 - multiple um packages in a while so
31:56 - firstly I want to check if the length of
32:00 - the arguments now to to work with
32:02 - arguments to print out messages to the
32:04 - CLI we could use something like Cobra
32:07 - which is a CLI tool and I have and I
32:09 - already have uh projects with that I
32:13 - think uh that's very commonly used in
32:16 - goang as you know Cobra uh we're not
32:19 - using it here because we have like very
32:20 - few operations and we can do that uh on
32:22 - our own we don't need to import a
32:25 - complete Library just to print out stuff
32:27 - to the terminal and to work with some
32:29 - arguments right and uh here we're just
32:32 - checking of the length of the arguments
32:35 - is less than two if it is less than two
32:37 - then we'll print
32:41 - help and print help will basically print
32:44 - out uh so there's a function called
32:46 - print help it's print help which
32:50 - basically tells the user and how to
32:52 - actually use this uh project so if he's
32:56 - not if the user user is not uh entering
32:58 - let's say encrypt or decrypt and the
33:00 - name of the file that means it doesn't
33:02 - know how to use this function right so
33:03 - you'll just print help out in that
33:10 - scenario and the other thing is function
33:14 - equal to OS do ARS
33:19 - one and we'll
33:22 - switch
33:24 - function so what do you want to do so do
33:26 - you want
33:30 - help if you want help we'll just print
33:32 - help we'll just call the print help
33:33 - function if you want to
33:39 - encrypt we will call the encrypt handle
33:44 - function if you want to
33:49 - decrypt you will call the
33:53 - decrypt handle
33:55 - function and then there is
34:00 - a
34:02 - default which
34:06 - is run
34:10 - encrypt to encrypt a file and TP to TP
34:17 - right just telling the user that hey
34:20 - please run encrypt to encrypt the file
34:22 - and decrypt to decrypt the
34:25 - file okay
34:27 - so that is our main function now as you
34:30 - know we're calling three functions from
34:31 - the main function which is the print
34:32 - help encrypt handle and decrypt handle
34:33 - so we're going to call we create all
34:35 - those
34:36 - functions uh so we have the we'll have
34:40 - the
34:42 - encrypt handle
34:45 - function and we have
34:48 - the
34:50 - decrypt hand
34:55 - function
34:58 - there are three more functions that
34:59 - we'll need in the encrypt handle there
35:01 - is the um get
35:07 - password to get the password from the
35:09 - user and then we have the
35:12 - validate
35:15 - uh so we have the get password function
35:18 - we have the validate file and validate
35:21 - password
35:23 - functions so let me create
35:25 - those
35:39 - password and
35:41 - frun
35:45 - validate validate
35:50 - file okay so and the print help print
35:52 - help is going to be very straightforward
35:54 - so I'll just go ahead and copy and paste
35:56 - actually don't have to write this whole
35:58 - thing on your own so this is basically
35:59 - saying file encryption simple file
36:01 - encryption for your day-to-day needs uh
36:04 - which is the name of the program and
36:05 - then what it does and then showing you
36:07 - usage that you can go run and uh when we
36:12 - say dot basically means it runs all the
36:14 - files in uh at the root which is our
36:16 - main.go and also our file. cp. go uh
36:20 - folder package and it'll basically uh
36:23 - you want to pass the path to your file
36:25 - in our case we'll just say img.png which
36:27 - will be a file that I'll copy and paste
36:29 - here you can copy and paste any file
36:31 - here I'm just using this apple file here
36:34 - and then you have the commands the
36:36 - commands like encrypt decrypt and help
36:38 - you'll have three commands encrypt will
36:39 - encrypt a file with a given password
36:41 - decrypt tries to decp a file using a
36:43 - password and help which displays the
36:45 - help text which is uh this particular
36:49 - function gets called
36:51 - there now for the encrypt handle which
36:54 - is the most important one uh sorry the
36:57 - encrypt and decrypt actually are both uh
36:59 - really important because that's the
37:00 - logic main logic so here we'll check if
37:03 - OS do if
37:05 - the length of os. ARS is less than three
37:11 - that means uh you have written you have
37:14 - written that uh you want to run the
37:19 - program and you want to encrypt but
37:22 - you've not passed
37:24 - the uh
37:27 - the pass the file right so it's argument
37:30 - sesson three then you will print
37:34 - Ln you will print
37:37 - out missing the part to
37:44 - five for more info
37:48 - run
37:53 - um so encrypt we say from the help
37:56 - command
37:57 - all right and
38:00 - os. exit
38:07 - Z if everything is all right then what
38:10 - you want to do is you want to get the
38:13 - arguments or which is basically the uh
38:16 - arguments at the second index which is
38:18 - the third
38:20 - argument uh which in our case is the
38:22 - part of the file you want to get it in
38:24 - this variable called file and you want
38:26 - to Val validate so if not validate
38:30 - file and you pass the file
38:33 - there and we'll just
38:37 - Panic file not
38:43 - found so what happens in the validate
38:46 - file function and this gets called it
38:48 - basically it takes in the file which is
38:51 - string and it passes back Boolean which
38:55 - is that's how we checking it it here you
38:56 - know true or false this exclamation
38:59 - helps us check that so if it's not uh
39:02 - valid then we say file not found okay
39:05 - and how does it return the Boolean it's
39:07 - basically using the os. stat function on
39:11 - the
39:14 - file and saying
39:18 - if ederal
39:21 - to OS do is
39:24 - not exist
39:28 - return false if it doesn't exist return
39:31 - false if it exists return
39:34 - true that's how we're checking for it
39:36 - out here so for the encrypt part we have
39:40 - checked
39:41 - um the validity of the file and not
39:44 - found now the next step is to ask for
39:46 - the password so we'll say password is
39:49 - equal to
39:51 - get password right so we already have
39:54 - the get password function so what is do
39:56 - it do it
39:59 - Returns the
40:01 - password which is a slice of
40:05 - bites and how does it accept the
40:07 - password it says first it prints out
40:11 - enter
40:14 - password then it's going to use the
40:16 - terminal terminal package to
40:19 - read the
40:22 - password and going to capture that
40:25 - in the
40:27 - password
40:35 - variable so when you if you remember
40:38 - when we were encrypting the file we
40:39 - didn't only just accept the password we
40:41 - also asked the user for the confirm
40:44 - password as in confirm this password so
40:46 - you want to print that out as well so
40:48 - you're going to
40:53 - say
40:55 - sln
41:00 - confirm
41:04 - password and we want to
41:07 - again read the
41:09 - password okay and this will be password
41:18 - to and here is where we will validate if
41:21 - the password one and password two are
41:23 - the same they're matching so we'll say
41:26 - if not
41:27 - validate password which will will pass
41:31 - password one and password two basically
41:34 - this function the validate password
41:36 - function should return back to us a
41:38 - Boolean and here we say fmt do
41:44 - print
41:51 - passwords do not match pleas try again
41:59 - turn get password if the password don't
42:02 - match we want this function the get
42:04 - password function to be called again and
42:06 - again Ask the pass uh the user password
42:08 - so if everything went well we just want
42:09 - to return the password from here which
42:12 - is a slice of bites okay now in the
42:14 - validate password function let's come
42:16 - here so it's going to accept something
42:19 - called as password one which is a slice
42:23 - of bites and password two which is again
42:28 - a slash of ptes return back a
42:33 - bilion and in here you want to check if
42:37 - the bytes are equal if everything is
42:40 - equal in password one and password
42:45 - two it's not equal
42:48 - return false if it's equal return
42:55 - true that that's our return uh validate
42:58 - password function which got called here
43:00 - and we'll go back now to our encrypt
43:02 - handle so after
43:04 - calling the uh the get password
43:09 - function we
43:12 - will say fmt do print Len and inform the
43:16 - user that hey we've started
43:19 - encrypting the file so we say
43:24 - encrypting and we'll use the file Crypt
43:27 - package the file Crypt package is our
43:29 - own we'll create the file Crypt package
43:31 - out here so we say file Crypt do encrypt
43:34 - because we'll have the encrypt function
43:36 - we'll pass it the file and the password
43:39 - and we'll print out FM do print Len
43:42 - you'll
43:45 - say file
43:49 - success
43:51 - detected so that's our encrypt handy
43:54 - function now in the decrypt handle
43:59 - function we will again check the same
44:02 - thing which is this like has he given us
44:06 - the file uh the part of the file if not
44:09 - we want to exit and we want to then
44:13 - validate the file
44:17 - again and we want to ask the user for
44:20 - this password so we say do
44:25 - print enter
44:31 - password and we want to say
44:43 - password terminal. read
44:49 - password and after taking the password
44:52 - we'll just print out instead of
44:54 - encrypting we'll just print out
44:59 - decrypting and instead of encrypt file
45:04 - the uh function encrypt function we'll
45:06 - just call the decrypt function passing
45:09 - the file and password and here instead
45:12 - of protected we'll just say
45:16 - decrypted so we have the encrypt handle
45:19 - and decrypt handle functions perfect
45:20 - clearly get password validate password
45:23 - validate file and CP handle print help
45:26 - and name now in the import statement we
45:29 - should have
45:32 - um all
45:35 - the
45:38 - files which file Crypt is my own package
45:41 - which I'll get from here the xterm
45:44 - package is the one that we're using here
45:47 - term uh the one that we're getting to to
45:49 - using to read the password and then we
45:51 - have byes fmtn okay so that's how it is
45:54 - now I can already see some issues and
45:56 - errors and some of them should go away
45:58 - once I've completed my file crypt.of
46:00 - file but then there will be many others
46:03 - that we fixed not a
46:05 - problem and now let's go ahead and start
46:08 - working on our file crypt.of file so
46:10 - starting with the filecrypt
46:13 - Dogo this package is going to be called
46:19 - filecrypt and we'll import some packages
46:22 - of
46:22 - course then we have two functions one is
46:25 - the encrypt function as you
46:28 - know and the other is going to the
46:31 - decrypt
46:39 - function
46:40 - okay because from here we are calling
46:44 - the encrypt and the decrypt
46:50 - functions so in the encrypt handle and
46:52 - decrypt handle respectively you call the
46:55 - encrypt function from file Crypt and the
46:58 - decrypt function from filecrypt those
47:00 - are the ones that we working on at the
47:02 - moment so in the E encrypt function you
47:04 - take in the source which is string and
47:08 - the password which
47:10 - is
47:13 - bite it's a slice of
47:17 - bytes
47:20 - okay so now this uh Source in our case
47:24 - is the file
47:26 - right because if you check here we're
47:28 - sending the file and the password so
47:30 - file and the password right so for the
47:32 - file we want to
47:34 - check if the
47:38 - file let me actually open up the browser
47:42 - and show you the diagram again and we'll
47:45 - follow the exact same
47:49 - steps so here it is we'll check for the
47:53 - source open the source file read read PL
47:56 - text from the source file create an
47:58 - empty nuns randomize nuns Let's do let's
48:01 - do those
48:04 - steps so first is os. stat
48:08 - then the
48:14 - source. is not
48:18 - exist and if it doesn't exist we are
48:21 - just going to return an
48:23 - [Music]
48:24 - error
48:30 - so first we checked for the
48:33 - file now we'll open up that file so
48:36 - we'll say os.
48:38 - open
48:41 - source and we'll capture that or store
48:44 - that in source
48:48 - file and if error is not equal to
48:52 - n
48:54 - panic
49:04 - errors at the end of this program when
49:06 - this function stops running we want to
49:08 - also close that source file so that's
49:11 - why we'll say differ Source file.
49:14 - flows now we'll read all the plain
49:18 - text from the source file so to read the
49:21 - pl text from the source file we'll use
49:22 - io. read all and source
49:27 - file what you get back is plain
49:35 - text and now we'll handle the error also
49:38 - error is not equal to
49:40 - n
49:46 - banic now the password that you have you
49:48 - want to store it in a variable because
49:50 - we want to work with it so we'll say key
49:51 - is equal to
49:54 - password and and now we'll create an
49:56 - empty nuns this is an empty nuns make
49:59 - and it's a slice of bite and of 12
50:03 - so it's going to look something like
50:05 - this it'll be 0 comma 0 comma 0 right 0
50:09 - 0 0 till 12 so 12 different values all
50:13 - of them zero that's what you create with
50:15 - this now and now we will randomize the
50:17 - nuns okay so we have created the empty
50:20 - DS now we'll randomize it we'll put
50:22 - random values in it and the way to do
50:24 - that is we'll
50:28 - say IO do
50:33 - read full random.
50:38 - reader so fill it with random values and
50:42 - error is not equal to
50:47 - nil Panic error
50:52 - dot
50:54 - awesome what's the next step now so on
50:57 - my screen the next step is we pass all
51:01 - these values to create into the password
51:03 - based deration key derivation function
51:06 - okay so the password based key
51:08 - derivation function is available to us
51:11 - in a package of the same name P key PB
51:14 - KD F2 and that function we pass the key
51:18 - the nuns 4096 as the number of
51:21 - iterations 32 as a length and sha 1. new
51:25 - as the
51:26 - algorithm so if you look here we passing
51:29 - the password to encrypt the file the
51:31 - nuns the number of iterations sha one
51:34 - and the B length which is 32 in our case
51:36 - and this is the number of
51:38 - vibrations what you get back from his
51:40 - this is called as the derived key DK so
51:44 - we just in short it's
51:46 - DK this package that we're getting
51:49 - everything from
51:54 - is
51:58 - is this package pbkdf2
52:06 - so now we have the derived key now we
52:09 - will
52:13 - create we
52:15 - will run it past by the advanced
52:18 - encryption standard so we'll say a. new
52:21 - Cipher
52:23 - DK and we'll get the
52:30 - block and we'll handle the error
52:33 - also so let say if error is not equal to
52:40 - n
52:44 - Panic
52:46 - error okay so we have this now the
52:49 - cipher block and now we want to use the
52:53 - galwa whatever ever it is you know GCM
52:56 - I'll call it GCM so it's the new GCM
52:59 - function so I'll say cipher. new GCM
53:03 - function and I'll pass in the block and
53:06 - what you get back is AES
53:14 - GCM if error is not equal to nil Panic
53:17 - error dot
53:24 - error
53:28 - okay so as as you know we did all these
53:31 - steps to to be able to run the seal
53:34 - function here which is what creates the
53:36 - which is is what converts the pain text
53:37 - to Cipher text so coming back here let
53:41 - us use the AES
53:45 - GCM do seal
53:47 - [Music]
53:49 - function this is what's going to take
53:51 - the plain text for
53:53 - us and
53:55 - send back the cipher
54:00 - text and
54:03 - you uh append the
54:06 - nuns so there is one thing that I have
54:09 - not drawn here but I have actually
54:10 - talked about it here is that we add the
54:13 - 12 by nuns at the end of the encrypted
54:16 - file so we want to do that now we want
54:18 - to append
54:20 - the nuns to the cipher
54:24 - text
54:28 - and store that in the cipher text
54:31 - itself so now we have the complete cyer
54:34 - text now we want to create a
54:41 - file source file for the encrypt data
54:43 - and want to write the data to the source
54:46 - file so what you'll do now is we'll call
54:49 - it the destination
54:52 - file.
54:54 - create create that
54:58 - file handle the error also here
55:04 - panic and at the end of this function
55:07 - when this function uh has done
55:10 - processing you want to close this file
55:13 - as
55:15 - well so you have created the file now
55:17 - you just want to write Cipher text into
55:19 - that file so write the cipher text into
55:22 - the file but this is the de file you'll
55:25 - say destination file. light and you
55:31 - will get the error if
55:34 - any if error is not equal to
55:41 - n
55:44 - Panic
55:45 - error
55:47 - okay so this was our encrypt function so
55:50 - far so good and as soon as I uh hit uh
55:54 - save it got me all the packages that I
55:58 - needed and now we want to work for the
56:01 - decrypt uh function the decrypt function
56:05 - is very similar it takes in
56:08 - the the the the path of the file and the
56:12 - password with the help of which we
56:14 - will decrypt
56:19 - this and first things first you want to
56:22 - check if the file that to be decrypted
56:25 - the the request that's coming for
56:27 - decryption if the file even exists or
56:28 - not so do the same thing
56:31 - .at
56:33 - Source this do is not
56:38 - exist error and here you
56:44 - will this is the error you're handling
56:46 - here and you're just saying
56:50 - Panic error okay and actually some of
56:54 - the part from here is going to be
56:56 - similar so I will just um copy this
57:01 - part all of this part till here I'll
57:05 - just copy
57:07 - it uh once
57:09 - again after
57:14 - this so here you will have uh SRC file
57:18 - where you'll open that source file and
57:22 - at the end you will close it also and
57:24 - here instead of plain text you'll just
57:26 - have Cipher text because that's what is
57:29 - in the file now because you have already
57:32 - encrypted the file and you're passing
57:33 - the encrypted file to this decrypt
57:35 - function and that's why whatever is
57:36 - there in the file is now Cipher text so
57:39 - we have done in the decryption part we
57:41 - we're done with this check for the
57:42 - encrypted file open the encryp file and
57:44 - read the text Cipher text from the
57:45 - encrypted
57:46 - file all of this is
57:50 - done okay so the password that you will
57:53 - receive in this function will again be
57:55 - stored in the variable key then we'll
57:58 - have a variable called salt which will
57:59 - basically have Cipher text and length of
58:03 - Cypher so without
58:05 - the last
58:09 - 12 okay
58:15 - and x dot and code to
58:20 - string the salt which is basically the
58:22 - nuns the last 12 is the nuns right
58:25 - you'll have it inall in Sal and we will
58:28 - use the hex package to decode this
58:39 - string and we'll store that in Str
58:47 - [Music]
58:49 - Str sorry this will be NS
58:53 - now
59:14 - okay okay so what do you pass again in
59:16 - that function the password based key
59:19 - derivation function for decryption you
59:21 - pass the same password to to that will
59:24 - be used to decrypt the bite length 32
59:26 - chart 1 iterations 4096 and the NS that
59:29 - we got from the last 12 uh digits of the
59:32 - cipher
59:35 - text and the same thing you do here you
59:37 - say new Cipher
59:41 - sorry new yeah a. new Cipher and you
59:45 - pass the derivation key derivative key
59:48 - and you'll again get the
59:52 - block and again you can have handle the
59:55 - error if error not error not equal to
60:00 - nil and then you want to pass that block
60:03 - to uh the
60:06 - cipher AES Cipher so what I'll do is
60:15 - I'll yeah we've already done that and
60:17 - now we want to pass it through the
60:22 - CGM GCM sorry
60:29 - yeah so the same thing that we done
60:32 - there we're doing it here and now
60:34 - there's only one little difference uh
60:36 - which is that instead of using the as
60:39 - GCM
60:40 - do
60:42 - um seal function we'll just use
60:48 - a
60:51 - GCM do open
60:53 - function so here we'll have the nuns the
60:56 - cipher
60:57 - text which
61:01 - is everything apart from those
61:05 - last um
61:16 - 12 and what you get back from this is
61:18 - the plain
61:20 - text okay so what you're seeing now is
61:23 - uh step by step we're just looking at
61:25 - the
61:26 - diagram and we are uh converting the
61:29 - diagram into code okay so our flowchart
61:33 - into
61:35 - code again let's handle the error
61:39 - here and then we'll again create the
61:45 - file like we did last time the
61:46 - destination
61:48 - file so I'll copy and paste that part
61:52 - Here and Now we will write plain text to
61:56 - this file so instead here we wrote the
61:57 - cipher text to the file and now we will
62:00 - write the plain text which we have
62:05 - received to the file so here what was
62:08 - happening in the encrypt function what
62:10 - was happening is that you ran that
62:12 - function called uh the seal function
62:15 - which gave you the cipher text to run
62:17 - the seal function as GCM seal function
62:19 - you had to uh do all of these steps
62:21 - which is get the plain text and then
62:24 - create your nuns have your password
62:26 - ready uh create a derived key with PB
62:29 - kdf function use Advanced encription
62:32 - standard new Cipher create a block
62:34 - Cipher block pass the cipher block uh
62:36 - with GCM and get AES GCM and then you
62:39 - were able to call the seal function to
62:41 - get the cipher text with all those
62:42 - values here exactly the same things you
62:46 - just had to call the as GCM do open
62:48 - function because this will give us the
62:50 - plain text from the cipher text Cipher
62:52 - text is everything apart from those 12
62:54 - last digits which actually was the nuns
62:57 - in our case for nuns right the salt
63:00 - which we can convert into nuns here and
63:03 - uh then finally just like we did in the
63:05 - encryption file we created a file and
63:07 - then we wrote plain text back into that
63:09 - file and now when we open up this file
63:11 - we'll be able to access it right so as
63:14 - you can see I have a lot of errors and
63:16 - I'm not at all scared because now when I
63:18 - go ahead and run this program uh I
63:23 - will come to know what the issues are so
63:26 - I'll say go
63:28 - run
63:31 - encrypt
63:34 - PNG and here I see all of these issues
63:37 - it says uh file Crypt to add file Crypt
63:41 - and yeah so xterm and file CPT are not
63:44 - there that means I need to say go mod
63:47 - tidy so first I'll get these
63:53 - packages
64:00 - let's I can see some issue there but
64:02 - let's see if it still
64:04 - works yeah still the same issues I'm
64:07 - getting so let's try to fix
64:09 - it now one issue out here obviously is
64:13 - this part which is I've copied the link
64:16 - from my previous project now this is
64:19 - obviously my GitHub and this should be
64:21 - the name of the project right and I'm
64:23 - and I'm calling file Crypt package but
64:25 - the name of the project is wrong that I
64:27 - have to go and get from go mod so the
64:29 - name of the project is actually go file
64:30 - encryption in this case and I have to go
64:32 - ahead and get it here and this issue
64:35 - will go away uh now what we'll do is
64:38 - we'll
64:39 - again go and
64:42 - run go run
64:45 - encrypt IMG or PNG and now we'll get a
64:48 - list of issues okay so now uh on line 68
64:52 - file Crypt line 68 file
64:56 - Crypt as I can see it's should have been
65:00 - error okay now let me check out line um
65:05 - 83 line 83 key is not used yes because I
65:08 - was supposed to use key here by mistake
65:10 - I've written name and here also I can
65:13 - see one more issue it's key should have
65:17 - been key right uh now the other thing I
65:19 - can
65:21 - see is um
65:24 - 88 which is undefined yeah it's the same
65:27 - thing this one the issue 988 all right
65:30 - so that's solved but now I can still see
65:33 - four issues in main. go so what we'll do
65:37 - is we'll go ahead and run this
65:39 - again uh
65:41 - here now we can see some issues from
65:43 - main.go file and the um first one is on
65:51 - 50 okay
65:55 - and then online
66:01 - 66 and then on line
66:06 - 87
66:09 - print line uh
66:14 - 102 right so what I'm trying to show you
66:17 - here is with if you're working with
66:18 - Technologies like goang and rust you
66:21 - don't have to worry at all about making
66:23 - mistakes the code so don't depend too
66:26 - much on extensions right so many people
66:28 - would tell you get extensions that help
66:30 - you uh not make any mistakes in the code
66:33 - while writing the code uh for spelling
66:35 - and for for uh you know goang so don't I
66:39 - would suggest don't don't depend too
66:41 - much on that as you can see I I wrote
66:42 - everything
66:43 - myself and uh I just depended on the on
66:47 - the goang compiler to tell me the issues
66:49 - and I just solve them one by one so just
66:52 - just depend on Goan compiler because
66:54 - when you're in an interview when you're
66:56 - giving the interview for some company uh
66:58 - you're not sure what kind of environment
67:00 - you'll get to write the code with mostly
67:02 - it's an online environment right and you
67:03 - have somebody on a call you have an
67:05 - online environment and you have to write
67:06 - the code in that online environment that
67:08 - won't have the extensions that you want
67:10 - and that you work with so it's highly
67:12 - recommended that you don't depend on
67:13 - extensions I've had many of my friends
67:16 - get into a lot of trouble because of
67:17 - that um but but know how to work with
67:21 - the goang compiler a lot like get very
67:24 - very good at debugging code okay so uh
67:28 - now things should work so it says ask me
67:32 - to enter the
67:33 - password and I will enter the password
67:36 - it will ask me to confirm the password
67:38 - I'll confirm the password it say file
67:40 - successfully protected try to open up
67:41 - the file I'm not able to okay and now
67:44 - what I'll do is I'll just run this um
67:47 - again with instead of encrypt it be
67:50 - decrypt and I'll just enter the password
67:53 - I had Ed earlier and now as you can see
67:55 - I can check out the file I can look at
67:58 - the file okay so this was our project
68:01 - everything works perfectly fine thank
68:03 - you so much for watching uh this I would
68:06 - say is is an intermediate level project
68:08 - it's not very Advanced it's not very
68:10 - simple uh like it's not a beginner level
68:12 - project probably and it's not an
68:14 - advanced project also somewhere uh in
68:17 - the middle but I hope you learned a lot
68:19 - thank you so much for watching if you
68:21 - haven't subscribed to this channel make
68:22 - sure you subscribe I'll come up with
68:24 - awesome content like this in the future
68:26 - thank you so much we're building
68:28 - something really interesting in today's
68:29 - video what we'll do is we'll just take
68:31 - some plain text encrypt it we'll get the
68:34 - encrypted text we'll then run it through
68:37 - a decryption function and then we'll get
68:39 - the decrypted text so it's quite
68:43 - straightforward it's something we
68:44 - haven't done before on this channel
68:46 - right it's uh working with encryption
68:49 - algorithms so we using a very simple
68:51 - encryption algorithm called the C are
68:54 - Cipher in this project and let me give
68:56 - you a quick demo on how this works so if
69:00 - I run go run main.
69:03 - go my plain text that I had given to the
69:06 - program was hello world and I get the
69:08 - encrypted text which is c z g g jrj mg Y
69:14 - and when we decrypt it again we get
69:16 - Hello World back right and in the
69:18 - program itself you can uh give it some
69:21 - text that it will encrypt and decrypt
69:23 - you can also build a CLI on top of it to
69:26 - accept the text from the user I haven't
69:29 - done that because in this project I want
69:31 - us to focus only on the encryption and
69:32 - decryption part we don't want to focus
69:34 - on the CLI part because I've already
69:36 - done that in many other projects okay so
69:40 - how this is working is we first take
69:43 - some text hello world right and by the
69:46 - way uh this is very quick visual
69:49 - programming visual planning that we'll
69:50 - do before we actually start programming
69:52 - so that we know exactly where we going
69:54 - and this is just a quick demo to show
69:55 - you how and uh how we're going to build
69:58 - it and what exactly uh is it that we're
70:00 - doing so we have our text hello world
70:02 - that you saw in the demo and we give
70:04 - this a key five so this key can change
70:07 - could be seven could be 10 whatever but
70:09 - in my case I'd given it the key five
70:11 - okay and I'll I'll tell you what that
70:13 - key
70:14 - means so with Caesar Cipher what what
70:16 - what happens is you pass in let's say
70:19 - all the uh alphabets so in my case in my
70:23 - program I had passed it all the
70:24 - alphabets you can also pass in numbers
70:28 - to this program and you can also give it
70:30 - special characters and what we want to
70:32 - do is with CES Cipher we want to replace
70:34 - uh this text with some
70:37 - other uh alphabets from the alphabets
70:40 - that we we have given it right so this
70:42 - one is going to be called as the
70:44 - original
70:46 - text because from this we will
70:50 - select uh some
70:52 - other
70:54 - characters that will basically replace
70:56 - this text of powers right so in the in
70:57 - the end you get something like this is
70:59 - CZ e jrj mg Y which is the encrypted
71:03 - text which nobody can understand but
71:04 - when you decrypt it the person who's
71:06 - supposed to uh receive this will get
71:09 - Hello World back
71:10 - okay and by the way uh in the beginning
71:13 - of computation this is how many
71:15 - encryption algorithms worked and now you
71:17 - have obviously much more advanced
71:19 - algorithms and that's what you see when
71:21 - you see WhatsApp saying it's end to end
71:24 - encrypted they're basically encrypting
71:25 - all the text that you're sending and
71:27 - you're getting back uh the user is
71:29 - getting back the actual text but then
71:31 - there's some encryption happening in
71:32 - between so that nobody can intercept
71:34 - those messages and read the meaning or
71:36 - read those messages basically so um the
71:40 - way this is working is first we'll take
71:42 - 26 which is the length of all of these
71:46 - uh all of the basically characters that
71:48 - we have sent the original text length is
71:51 - 26 and then we'll subtract the key which
71:54 - is five from that okay and then we'll
71:57 - create two different uh versions of this
72:00 - original text one is from 0 to 21
72:02 - because if you subtract 26 from 25 you
72:05 - get the number 21 so from 0 to 21 you'll
72:08 - separate that into a different bucket
72:11 - and from 21 to 26 you'll separate that
72:13 - into a different bucket right and then
72:14 - what you do is you attach this in front
72:16 - of uh this part right so the one from 21
72:20 - to 26 you attach that in front of this
72:23 - these remaining uh digits or the
72:25 - remaining uh alphabets or letters and
72:28 - you get something like this this is
72:30 - something called as the hash
72:34 - text hash text and essentially what you
72:37 - have to do now is you have to take H and
72:40 - find a uh corresponding or an equivalent
72:46 - um letter from here that will basically
72:47 - replace H okay so how do you do that
72:50 - first what you do is you find the index
72:52 - of H in the the original letters so you
72:54 - go to the original letters which is the
72:56 - original text and you find the index of
72:58 - H so it's a b c d e f g h this H this is
73:01 - H here it's the number is seven so
73:03 - that's the index of H in original
73:05 - letters which is seven and then you
73:07 - apply this formula this formula
73:08 - basically gives you the uh this this
73:12 - formula will give you the result of the
73:14 - index of the uh the
73:17 - corresponding uh alphabet that you have
73:19 - to pick up from this particular text the
73:22 - hash textt right so so you get i'll
73:24 - repeat again you get the
73:27 - um the position or the index of uh that
73:31 - number that you want to encrypt from the
73:33 - original text and then you run a formula
73:35 - and you get this is the main formula for
73:37 - cyer Cipher uh Cipher algorithm and then
73:40 - you get the position or the index of the
73:44 - uh alphabet in the hash text and that's
73:46 - the one that you want to replace this
73:48 - with so uh in the hash text right so
73:51 - firstly let's run the formula so the
73:53 - formula basically says the position in
73:55 - the original uh text of H which is 7
73:59 - plus the length of the original letters
74:00 - which is 26 and uh modulus with the
74:04 - length of the original letters which is
74:06 - again 26 and the answer that you get
74:08 - here is basically uh 7even so uh in in
74:12 - our case uh the index of H and original
74:15 - letter of seven and the index of uh uh
74:19 - the the index from the formula that we
74:21 - got by running the formula is again 7 so
74:23 - we have to look for the seventh alphabet
74:26 - in the hash text so it's like 1 2 3 4 5
74:29 - 6 and then 7 7 is B in our case right as
74:32 - you can see B so we replace H by B and
74:36 - similarly you can run e which is hello
74:38 - world right that's the text we want to
74:40 - encrypt so e you take e and then you do
74:42 - the same same thing and what you get is
74:45 - e will be replaced by Z right so Z is
74:48 - and how that happens is because in the
74:50 - original text uh e is the fifth digit
74:53 - right so when you when you run this
74:54 - formula again you'll get five here and
74:57 - when you uh go to the fifth digit here 1
75:00 - 2 3 4 5 Z is the fifth one so that's why
75:03 - you say five and now you don't even have
75:05 - to run the formula you can just get all
75:07 - the other digits very easily because L
75:09 - is the 12th right so if you go to the
75:11 - original text so L is the 12th so it's 1
75:14 - 2 3 4 5 6 7 8 9 10 11 12 L is the 12th
75:19 - and that's why in the hash text also you
75:20 - will also look at the 12th uh alphabet
75:23 - or the 12th letter so it's 5 6 7 8 9 10
75:27 - 11 12 which is in our case it's G so
75:30 - that's why both the L's have been shown
75:32 - as G out here okay then you can get the
75:35 - others also really easily and this is
75:38 - how basically this entire um algorithm
75:41 - is working now this is very predictable
75:43 - like uh if you give this to somebody and
75:45 - they figure out uh like the
75:47 - corresponding of H and E for example in
75:50 - this they can easily figure out all the
75:52 - other letters and this is a very very
75:54 - simple uh encryption to break it doesn't
75:58 - take a lot of brains to uh to break this
76:00 - encryption so that's why this is like
76:02 - the simplest simplest encryption uh that
76:03 - I wanted to show you and then you've
76:05 - seen my other videos on on the
76:06 - blockchains and how we've used Shard 256
76:09 - right to encrypt and they those uh more
76:13 - advanced algorithms have more advanced
76:15 - properties you have the Avalanche effect
76:17 - and you have uh uh what's the other term
76:20 - I'm forgetting the term it's basically
76:22 - but but the property is that
76:24 - no particular letter corresponds to
76:26 - another letter another letter right so
76:28 - that property is called something I'm
76:29 - forgetting the name right now but the
76:31 - Avalanche effect again is that if you
76:33 - change one thing in that encryption
76:35 - everything uh the complete uh signature
76:38 - changes so you have those Advanced
76:40 - properties that you get with Advanced
76:41 - algorithms you you don't have any
76:43 - properties with this is like very
76:44 - straightforward uh this this has existed
76:47 - from the time of Caesar I think that's
76:48 - why it's called Caesar Cipher it's like
76:50 - Way Beyond way before um
76:53 - the the invention of computers but it's
76:56 - a great algorithm to know it's it's
76:57 - great to get started with it encryption
76:59 - and it's a great project to build with
77:00 - goang because we'll work with uh this
77:04 - this little algorithm but we'll also get
77:06 - to apply our goang Concepts and that's
77:08 - what what will make us a better goang
77:10 - developer okay so with this out of the
77:12 - way let's get started now before we get
77:14 - started I just want to tell you that
77:16 - this particular uh video will be part of
77:19 - the 47 killer goang projects CD so I
77:22 - have this playlist on my uh channnel it
77:25 - has 47 projects in goang so in case you
77:28 - didn't know that you want to check you
77:29 - might want to check them out uh so this
77:31 - 47 will now become 48 because this video
77:33 - will will be there in that and what I'm
77:35 - trying to do is I'm trying to arrange
77:36 - these videos in the level of difficulty
77:39 - where some some of them I've not still
77:40 - not arranged them in the right order but
77:42 - I will do that and then eventually they
77:44 - will be in the right order of difficulty
77:45 - and you want to start from the beginning
77:47 - and start building projects uh one by
77:48 - one all right that's how you want to go
77:50 - about these now the next thing I want to
77:52 - tell you is is that we have this Discord
77:54 - server for my YouTube and everyone is
77:57 - allowed here and we discuss really
77:59 - awesome stuff uh like you know what
78:01 - we're learning today and we're having a
78:03 - lot of discussions so like let's say if
78:04 - you have any goang issues you can come
78:06 - here and post the issues um and we we're
78:11 - discussing about any issues about goang
78:13 - you know I I help quite a bit on this
78:15 - community so if you if you want you can
78:16 - join it all you have to do is the the
78:18 - link I think is out here so you have to
78:20 - just go here and this is I think the
78:23 - link for joining the community if you're
78:25 - not able to join it let me know I'll uh
78:28 - I'll make sure I'll send the new link
78:30 - with you okay so that's one more thing I
78:33 - want to share with you and the code for
78:36 - this particular project and all the
78:37 - other projects is on my GitHub so in
78:39 - case I don't share my GitHub link with
78:40 - you you have to know it's Akil Sharma 90
78:42 - on GitHub and you'll find almost all of
78:44 - the projects here this is the one that
78:45 - we're building today sorry not this one
78:47 - this is the one that we're building
78:48 - today simple encryption decryption with
78:50 - goang using Cesar Cipher right so the
78:52 - code is already there uh all you have to
78:54 - do is just come here and uh in case you
78:56 - get stuck you just have to refer to that
78:58 - code all right so everything is uh clear
79:00 - now now what we have to do is we have to
79:06 - um I will
79:08 - just go back to my
79:13 - um the the place where I keep all my
79:15 - goang projects and I will just create a
79:17 - new directory I'll just say go um
79:21 - encryption YT
79:24 - okay and I
79:26 - will CD into it and here we will go mod
79:32 - in
79:32 - it and I'll just github.com
79:36 - [Music]
79:38 - ail Sharma
79:40 - 90
79:42 - SLO
79:44 - encryption
79:46 - y so what this does for for us is it
79:48 - creates a go. mod file which will have
79:50 - the list of all the modules that we use
79:53 - in this particular project we're not
79:55 - using uh any third party modules I think
79:59 - mostly so you don't need to worry too
80:01 - much about it but still we'll just have
80:03 - it uh in any case here I'll just create
80:05 - the main.go
80:07 - file and this is a very small
80:09 - straightforward project there's not a
80:11 - lot of uh Engineering in this but uh
80:14 - it's it's small and straightforward like
80:16 - I said and uh it's a great project to
80:18 - build like great uh beginner level
80:21 - project to build so in my main go file
80:23 - I'll just say package main which is the
80:25 - first thing you write anyways in your
80:27 - main. go file and then I'll have some
80:31 - import related stuff right so I'll have
80:34 - I'll just write import here and
80:36 - accordingly I'll import the stuff that I
80:37 - want to import I'll have uh the main
80:41 - function obviously Funk
80:44 - Main and here is where I will Define my
80:48 - plain
80:50 - text which in my case is hello world you
80:55 - can change it
80:56 - also and then I'm going to print it out
80:59 - I'm going to print out the plain text as
81:01 - it happened in our demo also right same
81:04 - way plain text and we print we print out
81:07 - plain text then we have our
81:11 - encrypted text which is uh what we're
81:15 - going to get when we call our encrypt
81:17 - function that we will create now so
81:18 - we'll create an encrypt function it will
81:20 - take in the key in my case will be five
81:23 - and the plain text right so this means
81:26 - that here up here somewhere will be our
81:29 - encrypt function so it'll say funk
81:32 - encrypt and it will take the key which
81:34 - is the integer and the plain text sorry
81:39 - PL text which will be string and this
81:42 - will return to us the result which will
81:45 - be the string the encrypted text
81:47 - obviously right and then obviously uh
81:50 - apart from the encryption function if we
81:51 - have an inun function we also need the
81:53 - decryption function this will again take
81:56 - in the key the
82:00 - encrypted text
82:03 - and it's going to return back to result
82:06 - which is the string so once you've
82:08 - encrypted it you have this uh in this
82:11 - variable called encrypted and we will
82:15 - print it out first so we say I can do a
82:19 - print
82:20 - Len and encrypted text will be
82:26 - encrypted and then we have decrypted is
82:30 - equal
82:32 - topt five
82:35 - comma
82:41 - um and then we'll print it
82:48 - out
82:51 - decrypted
82:53 - come on
82:55 - decrypt so to the decrypted decrypt
82:58 - function you are passing the key and the
82:59 - encrypted text and you'll get that in
83:01 - the decrypted uh variable and then we'll
83:04 - just print that out so that's it that's
83:06 - all our Funk name is doing okay at the
83:10 - top I will say my
83:14 - original letter will have all the 26 a b
83:18 - c d e f g h j k l m n p q r s t u v x y
83:26 - z
83:29 - okay so original will have all of this
83:32 - original letter basically
83:34 - means this the original text this has
83:37 - all of the uh letters this is the plain
83:40 - text and this is the key five which
83:41 - we've passed okay now we want the hash
83:44 - text so for the hash text we need
83:47 - another function let's call
83:48 - it frun hash letter
83:55 - function takes in the key takes in the
83:59 - uh original letter it'll take in the
84:01 - original letter and we'll say result and
84:06 - string okay now here the first function
84:10 - that's called is the encrypt function so
84:12 - we'll start building upon the encrypt
84:18 - function so as you remember in the
84:20 - encryption part the first thing we do is
84:22 - is we first want this right and then
84:26 - we'll find the index of H the first
84:28 - letter we'll start we'll start letter by
84:30 - letter the first letter which is H we'll
84:32 - find the position of H in the original
84:34 - text but we also want this right you
84:37 - want the hash text because after we run
84:39 - our formula we want to find the uh that
84:42 - particular index what's the value at
84:44 - that index in our hash
84:47 - text so that's why we need this also
84:49 - first so well we'll call the hash letter
84:53 - function so we'll say
84:54 - hash letter function we'll pass it the
84:59 - key and the original letter original
85:02 - letter being
85:03 - this we'll just pass it
85:08 - there and to start with we'll say V hash
85:12 - string isal to empty now hash string is
85:16 - what you want to return from here so
85:18 - there this result that we sending back
85:19 - is the hash string and one by one you
85:22 - will keep adding to this uh empty string
85:25 - some values so for example for H the
85:28 - first value in our case as you saw here
85:31 - uh we'll get C right so whatever we get
85:33 - here C and z and G so one by when we'll
85:36 - keep adding values to it we'll run
85:38 - things through a loop and we'll keep
85:40 - appending things to this hash string uh
85:43 - and that's why first we'll start with
85:44 - this being empty and then we will run
85:49 - um actually at the end here we will will
85:52 - have this function called strings. map
85:55 - and we say find one comma plane text so
86:01 - strings. map what this does is it takes
86:03 - in uh the plane text
86:07 - okay in our case the plain text is
86:09 - actually hello world so it takes in
86:11 - hello world and one by one it'll send it
86:14 - and call this function called find one
86:16 - so it'll take uh H first and then e e
86:19 - next L lse we'll take all these things
86:21 - one by one strings. and then call the
86:23 - find one uh you know function so what is
86:29 - find one so find
86:32 - one is equal to a function it's a
86:37 - function which takes in r as a rune and
86:41 - returns a rune now what does that mean
86:44 - so
86:45 - Rune help so runes basically help you um
86:49 - with unicodes so what we're saying here
86:51 - is that um a run represents a single uni
86:54 - code character okay so for example a the
86:58 - value of a is 65 so you get the ask2
87:00 - value and now you can uh work with the
87:04 - letters in a much more flexible way so
87:06 - you get separation between all these
87:08 - letters so for example A B C D E F
87:11 - because you're sending them one by one
87:12 - but then with run you're able to work
87:14 - with them in like much more easily uh
87:17 - because
87:19 - here what we have not covered is is that
87:23 - the runes that you'll
87:25 - get here also you'll use Rune to be able
87:29 - to work with that so we'll be using run
87:31 - basically all throughout to be able to
87:34 - uh iterate over all these letters and
87:36 - work with those letters uh and then
87:38 - perform operations on that so it'll take
87:41 - in our run so for each uh letter like H
87:47 - we take each letter from the pr text
87:50 - which is like the hello world right so H
87:52 - we take that and we send it to find one
87:55 - and then what the find one function is
87:56 - doing is it's taking in that H and
87:59 - returning us to us the equivalent letter
88:02 - uh in the in the encrypted text so in
88:04 - our case it will be C now how do we get
88:07 - from H to C let's take a
88:10 - look so uh first I think I'll just build
88:13 - the hash letter function because
88:14 - otherwise there will be just confusions
88:15 - because you know I wanted to explain the
88:17 - Run Part before we wrote Rune here
88:20 - because we using it in the hash function
88:22 - so I didn't do that uh my bad but I
88:25 - think I'll just build this function
88:26 - before we work more on the encrypt
88:27 - function so that it just makes more
88:30 - sense so this hash letter function right
88:33 - all it's supposed to do is it's supposed
88:34 - to um take in this key and then divide
88:39 - this into from a to Zu and from V to Z
88:42 - divide uh the original text into these
88:45 - two parts and then also put this in
88:47 - front of this and then return that part
88:49 - that's so we want to return the hash
88:51 - text from this function so we'll say
88:53 - last
88:55 - letter key equal to
89:00 - string
89:01 - runes length of letter letter being
89:06 - original letter in our case so from here
89:07 - to here the length is obviously 26 so
89:10 - we'll say length of letter minus key to
89:14 - length of letter so this is Runes
89:18 - of 21 is to 26 so from 21 to 26 what are
89:23 - the things which is in our case v sorry
89:27 - 2126 v
89:29 - w now x y z so these five things will
89:35 - basically come in the last letter key
89:38 - and then we'll say the left over letters
89:41 - left left
89:44 - over letters letter is equal
89:50 - to
89:52 - string
89:58 - runes and
90:02 - zero length of
90:06 - letter
90:10 - minus okay so 0 to 21 so this is length
90:14 - of letter which is 26 minus ke which is
90:17 - key is 5 so it becomes 21 so 0 to 21
90:20 - will come in
90:22 - uh one place like I said and 21 to 26
90:25 - will come in another place so this has 0
90:27 - to 21 and this has 21 to 26 so last
90:30 - letter three and the left over letters
90:32 - now all we have to do is we have to
90:35 - return I told you right we'll return
90:39 - This plus this so we'll return the uh
90:42 - last
90:43 - letter and followed by the leftover
90:46 - letters so let's do that so we'll say
90:49 - FMP
90:50 - Dot
90:52 - Sprint
90:55 - F here let's say percentage s and
90:58 - percentage
91:04 - s comma last
91:07 - letter two comma left
91:12 - over
91:14 - letters so we able to return what we
91:17 - promised from this function which is the
91:18 - string which is the hashed uh
91:23 - the hash text from this
91:25 - function so in the encrypt function we
91:27 - were now in the find one function and
91:31 - here we will first start with the
91:36 - positional strings. index why the
91:39 - position uh if you remember I had told
91:43 - you that what we'll do is we'll find the
91:45 - index of H or the position of H and the
91:47 - original letters That's How we'll get
91:48 - seven right so this is the original text
91:51 - and we have to Now find the index of H
91:53 - there since strings. index and the
91:56 - original letter comma string and that
92:00 - there will be uh
92:02 - run
92:05 - R and now we'll get the position of that
92:07 - letter now uh if what if the original
92:10 - text that we passed original letter text
92:12 - that we passed somehow we forgot to
92:15 - write there was a type of we forgot to
92:16 - write H
92:17 - there right then Position will basically
92:21 - become min-1 and that's what we want to
92:23 - check for so we want to check if
92:24 - position is not equal to minus1 that
92:26 - means the letter that you want to
92:28 - encrypt is actually existing in the
92:30 - original letter you want to find the
92:32 - position if it's not equal to minus one
92:34 - then we can do something about it
92:35 - otherwise it's a problem right other you
92:38 - just want to return the same thing
92:40 - return
92:41 - R um and finally from here we want to
92:45 - return the hashed string as you know
92:49 - hash string which is now empty we want
92:50 - want to fill it up so if everything is
92:52 - all right and it's not uh minus one then
92:54 - we'll say
92:57 - letter
92:59 - position is equal
93:02 - to position plus
93:10 - length original
93:13 - letter percentage length of orig
93:19 - letter and hash
93:22 - string
93:25 - Hash Hash
93:27 - string plus
93:30 - string hash
93:33 - letter letter position okay so what's
93:35 - happening here
93:36 - is we first find the position and then
93:40 - we uh run our modulus function so if you
93:42 - remember I told you the function or the
93:44 - formula looks something like this where
93:46 - we add the position plus the length of
93:49 - the original letters and we mod we run
93:51 - mod modul which is length of position
93:53 - dat so in our case be 7 + 26 modulus of
93:56 - 26 you get 7 right so that's what we're
94:00 - doing here so you get the letter of the
94:02 - position uh which is seven and now the
94:04 - next step would be to look for that uh
94:06 - letter which is at the seventh position
94:08 - in the hashed text and that's what we're
94:10 - doing
94:11 - so we're looking in the hash letter that
94:14 - we have hash letter hash text we passing
94:18 - this letter position and getting that
94:20 - particular value converting into string
94:22 - and adding that to Hash string so each
94:25 - each of these values from the plain text
94:28 - one by one because of the help of
94:30 - strings. map one by one we'll take it
94:32 - like H and e and l and O and then we'll
94:35 - pass it to find one find one is
94:37 - accepting it as a rune and also
94:38 - returning a rune in our case and then
94:41 - it's
94:43 - um adding everything to hashed string
94:46 - that's what's happening adding
94:48 - everything to Hash
94:50 - string finally we'll have as string that
94:53 - that's what we'll return from this
94:54 - function okay now the decrypt function
94:57 - is going to be the exact opposite of
94:59 - this the decrypt function is going to
95:01 - basically um have
95:05 - same method which is calling the hash
95:08 - letter
95:09 - function and we'll capture that value in
95:14 - a variable
95:17 - called hash letter so the hash function
95:20 - will pass the key and the original
95:24 - letter and again you'll start with the
95:28 - hash string which is
95:31 - entty so with the with the
95:34 - decryption we have to uh find
95:39 - again you know that value in the
95:45 - um in the hash letter index so let's so
95:48 - this is what we'll start with okay in
95:49 - the beginning and we we'll find the
95:53 - value of let's say
95:56 - C so in in the in the encryption we
95:59 - started with the original text now we'll
96:00 - start with the hash text so let me write
96:04 - it here this is
96:07 - decryption
96:12 - sorry you start with the hash text and
96:16 - you see that the uh hge right is of
96:20 - particular value
96:23 - and
96:27 - um and this is the original text
96:31 - here yeah so like I was saying this will
96:34 - happen before so we'll first check the
96:37 - value of that uh you know letter here
96:41 - let's say in our case C right so we'll
96:43 - notice the value is 5 6 7 uh 8 1 2 3 4 5
96:48 - 6 7 8 so this will be eight in our case
96:50 - right and then then that eight we have
96:52 - to find in the uh in the hashed text
96:56 - sorry the sorry in the in the original
96:59 - text so the original text is different
97:01 - right
97:03 - it's so decryption will exactly be the
97:06 - opposite of encryption so an encryption
97:09 - we first found the position of the value
97:11 - in the original text and then found an
97:13 - equivalent in the hash text and
97:15 - decryption will be completely opposite
97:17 - we'll first find the position of that
97:19 - particular um
97:21 - so C for example we'll first find the
97:24 - value of that letter in our hash text in
97:27 - this case C and then with that position
97:29 - we'll run that formula again and we'll
97:32 - get some value and then that value we
97:33 - have to pick from the original text and
97:35 - that's how we'll get back uh hello world
97:38 - from this text so that's the entire
97:42 - method that we have to follow now okay
97:44 - so let's do that so for encryption for
97:46 - decryption we say hash string is
97:49 - completely empty and then we say find
97:51 - find
97:52 - one and who's going to call find one
97:55 - um out here we'll just say strings.
97:59 - maap find one comma encrypted
98:04 - text and
98:07 - return hash Str right so the other thing
98:11 - that's changing here is that with uh
98:13 - with encrypt we sent the plain text to
98:15 - our find one but in decryption uh we're
98:17 - passing the encrypted text to our find
98:19 - one function and then find the F final
98:21 - function we'll say funk R Rune and Rune
98:26 - okay so that that was one change which
98:27 - is passing plain text versus passing
98:28 - enry text the other change which I was
98:30 - showing you in the diagram was that we
98:33 - will find the position of the uh of the
98:39 - the the word in this hashed letters so
98:43 - earlier we found it in the original
98:44 - letters right the first position now
98:46 - we'll find it in the hash letter and
98:48 - we'll say
98:50 - string
98:51 - run
99:04 - R and again we'll check for the same
99:06 - thing position uh is not equal to minus
99:10 - one check for the same
99:14 - thing from here we'll go
99:17 - R yeah this if you remember we checking
99:20 - because that that uh particular value
99:22 - that's coming in here needs to be there
99:24 - in the hashed text right so not the
99:26 - original letter in this case is the hash
99:28 - letter so it has to be there in the hash
99:29 - letter the position otherwise will be
99:31 - one minus one so only if it's not minus
99:33 - one we can uh proceed and this is how
99:36 - we'll proceed so we'll say
99:38 - letter
99:39 - [Music]
99:40 - position equal to You'll again apply the
99:44 - formula plus length of original
99:50 - letter
99:53 - percentage length
99:55 - of original
99:58 - letter which is mod modular and then
100:02 - origal letter and we'll say hashed
100:05 - string equal to Hash
100:08 - string plus string and original
100:14 - letter letter
100:17 - sorry letter
100:19 - position
100:32 - forgot the return are
100:36 - here
100:39 - okay right so uh main main differences
100:42 - in decrypt and encrypt is like I said
100:44 - we're passing the encrypted text here
100:46 - we're passing the plane text there and
100:49 - here we check cheing for the position in
100:52 - the hash letter hash letter being this
100:55 - one and here uh in the encryption we
100:58 - were checking for the letter position
101:00 - the original original text original
101:02 - letter here for finding the letter
101:04 - position formula we again we use the
101:06 - length of original letter only that's
101:08 - not that's not different that's the same
101:09 - thing and finding the hash string
101:13 - finally at the end we found here from
101:16 - the the hash letter we found the
101:18 - equivalent text and now to Crypt it back
101:21 - we finding it from the original letter
101:23 - the equivalent uh you know letter so
101:26 - here we'll get the back to decrypt
101:28 - decrypted
101:31 - text now uh I don't see any issues and
101:35 - or any errors here in the in the code so
101:37 - what I'll do is I'll just go here and
101:39 - I'll just say go run main. for so if
101:42 - there are any errors we'll get them here
101:44 - but there were not any errors luckily so
101:46 - we had our PL text we got the encrypted
101:49 - text and we got the decrypted text okay
101:51 - so I'll just quickly go over it again in
101:53 - case you missed anything uh we started
101:56 - with our plain
101:57 - text we uh got the encrypted
102:00 - text which is this we sent it to the
102:03 - decryption function got the decrypted
102:04 - text started with Hello World text we
102:06 - want to replace each single letter uh
102:09 - with with different alphabet the key
102:13 - that we passed was five and the original
102:14 - text we pass was this so this can have
102:16 - numbers this can have small characters
102:18 - also this can have special characters
102:20 - also
102:21 - and when we pass the key as five we run
102:24 - this through the original text through a
102:26 - hash hash function which basically
102:29 - subtracts five from the length of the
102:31 - original text so we get 21 so we divide
102:34 - the original text into two different
102:35 - parts one is from 0 to 21 and from 21 to
102:37 - 26 then we pass the hash text back so
102:40 - which is this uh before the uh before
102:43 - this text and we pass this back to the
102:46 - function in the encryption function the
102:48 - first thing we do is we find the index
102:50 - of the first letter which is H in the
102:54 - original uh text so in this case we get
102:57 - seven now we run our formula which is
102:59 - position plus length of original letters
103:02 - percentage or modul length of original
103:04 - letters and then we get again uh 7even
103:07 - and we find seven in the hashed text
103:11 - because we want to convert from original
103:12 - to the hash or the enry encrypted we'll
103:15 - find an or uh like a like a
103:17 - corresponding uh digit or letter from
103:20 - here
103:21 - and B so we found that H is equal to B
103:25 - Because B is on the seventh position
103:27 - after we ran this formula and that's how
103:29 - from Hello World we actually got this in
103:31 - this description it works the completely
103:33 - opposite because you find the position
103:35 - of
103:36 - C
103:39 - in first in the hash text and then we
103:43 - get that position and then we basically
103:45 - run it through the formula and then we
103:47 - get the original uh text
103:51 - sorry and and yeah and we get the
103:52 - position in the original text of that
103:54 - corresponding letter in this case it
103:56 - will be H now guys uh there's one thing
103:59 - that I have uh you know made a small
104:02 - mistake in right and I want you to to uh
104:05 - find that out in case you haven't
104:07 - figured out in the whole program one
104:10 - thing that I've been missing or and
104:11 - messing up with uh just so so that you
104:14 - know uh in case youve understood it
104:16 - please let me know where I've made that
104:18 - mistake uh there'll be basically ensure
104:21 - so if you if you go through the video
104:23 - again look for the mistake things will
104:25 - become much clearer to you and you'll be
104:27 - able to um completely understand this
104:30 - concept right so let me know if you
104:33 - found that
104:35 - mistake uh I'm going to tell you the
104:37 - answer anyways if if in case if you have
104:39 - not found it so the mistake is that the
104:42 - value uh the actual position of H is not
104:45 - seven it's 1 2 3 4 5 6 7 8 it's actually
104:49 - eight not seven
104:51 - so that's why you have to write here
104:53 - eight and you have to write
104:55 - here8 you have to write here
104:58 - eight then have write here
105:02 - 8 and should have in C right H should be
105:05 - equal to C and not
105:08 - b and that's how you get C right here
105:11 - right so I made that
105:13 - mistake um and now you can actually go
105:16 - and run the actual values and you'll see
105:18 - everything is consistent all right so
105:20 - that's
105:21 - perfect I hope you were paying attention
105:23 - now when you looked at the mistake uh
105:26 - everything will make
105:28 - sense right so
105:32 - um so what I want you to do is I want
105:34 - you to uh run through uh the entire code
105:38 - once again and run through those values
105:40 - once again so that you basically
105:42 - internalize whatever I've taught you uh
105:45 - try try to put different values here
105:47 - like smaller text and then special text
105:49 - characters all of that try and and see
105:53 - uh how that works and thank you so much
105:55 - for watching this video uh I hope you
105:58 - will join our community on Discord where
106:00 - we'll get to hang out and you'll watch
106:03 - all the other videos in this
106:06 - um in the uh in the in the goang
106:08 - playlist all right so thank you so much
106:10 - and I'll see you in the next video