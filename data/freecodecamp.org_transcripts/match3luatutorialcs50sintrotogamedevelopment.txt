00:00 - [MUSIC PLAYING]
00:16 - SPEAKER 1: Hello.
00:17 - Welcome to lecture three of GD50.
00:19 - Today, we're going be talking about
Match 3, as shown by the little cubes
00:24 - here on the slide.
00:27 - Match 3 originated a
little earlier than 2001,
00:29 - but the first big game
that came out that was
00:32 - a sort of genre staple of Match 3 was
Bejeweled, shown here on the screen.
00:39 - This is a more modern
incarnation of Bejeweled,
00:41 - but it came out originally in 2001.
00:43 - It was actually a web browser game,
and the formula is very simple.
00:46 - The premise is you have a grid of
different colored or shaped items,
00:52 - usually pretty small, like
eight by eight, or so.
00:54 - And your goal is just to simply, like
the name says, match three or more
00:57 - of them in a row.
00:59 - If you do, you get a
certain number of points.
01:02 - Matching usually more than three
gives you more points, or a bonus.
01:05 - And whenever you match three, the
blocks will disappear from the grid,
01:10 - and they'll be replaced by more blocks.
01:12 - And the ones that you made
holes for, the blocks above them
01:15 - will come down via gravity.
01:17 - This is a more modern
incarnation of the formula.
01:19 - This is Candy Crush, which
I think most people know.
01:22 - It was a very big hit on mobile devices,
and otherwise around 2013, 2012,
01:28 - and that's probably the most recent
big Match 3 style game that's come out,
01:32 - but there are a lot
of other takes on it--
01:34 - different versions that try to
add new features, and stuff.
01:36 - This is the game that we'll be putting
together today, and I'll show you how,
01:40 - and we'll be covering a
few other things as well.
01:42 - So the topics today,
we'll be covering, first
01:45 - of all, a fundamental concept in dynamic
languages, a lot of dynamic languages,
01:49 - and also Lua.
01:50 - It's called anonymous
functions, which are functions
01:52 - that are first class, meaning
that they operate as data types,
01:56 - and so we can do some
fancy stuff with those.
01:58 - Tweening, which means
just taking one thing,
02:00 - and interpolating its value
between two values from 1,
02:04 - to a destination value over time, which
is a very important thing in games.
02:08 - You can do things like move objects.
02:09 - We can also tween their opacity.
02:11 - Just sort of asynchronous behavior,
and asynchronous variable manipulation.
02:16 - Timers, very important.
02:17 - We can time something to
happen at certain intervals,
02:20 - or after a certain
length of time has passed
02:22 - to get us past the idea of
storing different timed variables,
02:27 - or different counters, and break
away, and keep timer objects that
02:30 - will take care of this for us.
02:32 - We'll see how we do that
with a specific library.
02:34 - And then we'll get to the actual details
of Match 3, and how to solve matches,
02:39 - and how to account for that.
02:41 - Fill in the grid, account for
when we actually solve a match,
02:45 - and repopulate it once we've done so.
02:46 - We'll talk about how to
do this procedurally.
02:49 - It's very simple compared to, I think,
Breakout's more procedural layout
02:53 - system, but it's still randomisation,
and we'll talk about that.
02:58 - And then last, if we have time,
we'll talk about sprite art,
03:00 - and palettes, which is a big fundamental
thing when you're doing 2D game
03:04 - development, and something that
this, and Breakout's sprite sheet
03:09 - took advantage of was the idea of using,
on purpose, a restricted set of colors,
03:14 - a palette for creating
your 2D art, and there
03:16 - are a lot of really cool, and
impressive things we can do with that.
03:20 - But first, I'd like to actually show
what we'll be running today in class.
03:25 - So I'm going to come
here into my directory.
03:28 - Make sure I'm in the
right place, which I am.
03:30 - So this is part of the
distribution code, which is online.
03:33 - So there's a Match 3 directory.
03:36 - And would anybody like
to come demo it in class?
03:42 - All right, [? Tony. ?] Come on up.
03:45 - All right, so whenever you're ready,
go ahead, and just hit Return here.
03:51 - [GAME MUSIC PLAYING]
03:52 - All right, and so this is my
implementation of Match 3.
03:55 - It uses a different set of tiles.
03:58 - We have things that
are moving over time.
04:02 - It's arrow key based.
04:07 - So if you press Enter on any tile,
you can flip it with another tile.
04:10 - It doesn't have to be
a match, in this case.
04:12 - So you can-- yeah.
04:16 - Yeah, you kind of got an unlucky board.
04:17 - There, at the very bottom,
I see there's a few that--
04:19 - some brown ones you can match together.
04:22 - So once you match them together,
the tiles come down to repopulate.
04:26 - You get new tiles up top.
04:30 - And so notice, we have a
timer on the left as well.
04:32 - It's something that's counting down.
04:33 - We'll see how this is actually done with
the library we'll be using, as opposed
04:37 - to managing a counter variable
keeping track of it over time.
04:47 - A lot of games will actually implement
it so you have to-- you can only,
04:50 - and this will be part of
the assignment, actually,
04:52 - where you can only move a
tile if it creates a match.
04:56 - In this case, there's a--
04:57 - and we can see the timer counting
down, and then once you-- yeah,
05:00 - if you don't get past the
goal, there's a game over.
05:03 - But thanks, [? Tony. ?] I appreciate it.
05:04 - AUDIENCE: No problem.
05:05 - SPEAKER 1: So that's
the game in a nutshell.
05:07 - And another thing I
want to point out to is
05:09 - the transition, the white
transitions, and then the level text.
05:13 - Those are all done with
timers that we'll be using,
05:16 - and tweens, which we'll
be covering in class here
05:18 - as some of our early examples.
05:20 - But there's a lot of stuff that
we haven't touched on, but also
05:23 - a lot that we have.
05:24 - It uses sprites, and a sprite sheet,
and we've done that thing before.
05:29 - We chop up a sprite sheet, and then
take out the whatever individual quads
05:32 - you need, and draw them to the screen.
05:34 - Here's what our goal is, which is
we have a title screen with Match 3,
05:38 - start, and quit game in this case.
05:40 - A little bit simpler.
05:40 - No high scores this time just
because we've already covered that,
05:43 - but we also have a level screen.
05:45 - It tells us what level we're
on before we can actually play,
05:48 - and there will be a transition
box with text in it.
05:51 - It'll come down, stop,
and then come down again.
05:54 - So almost like chain behavior, which
we'll see how we implement that too.
05:59 - And then lastly, on the bottom
there is our main game screen,
06:03 - where we have a level, a
score, and then a goal.
06:05 - If you get the goal amount of
points before the timer runs out,
06:10 - then you go to level 2,
and level 3, and level 4,
06:12 - and the score increases by a
multiplied factor each time.
06:16 - So the first thing I'd like
to start talking about today
06:18 - is how we actually get timer behavior
using something a little bit more
06:22 - than just keeping track of
some variable that we set to 0,
06:25 - and then adding dt to it every update.
06:28 - There's a better way to do
that, but first, why don't we
06:31 - go ahead, and look at timer0.
06:33 - And so what I'm going to do is
go into the timer0 directory.
06:37 - I'm going run it, and we can see
here, in the middle of the screen,
06:40 - just a very simple--
06:41 - just a label that just says
timer, and then x seconds,
06:44 - where obviously the x is
incrementing over time every second.
06:49 - So a crude way, what would be
an easy way to implement this?
06:56 - AUDIENCE: Do you like [INAUDIBLE] random
in Flappy Bird [INAUDIBLE] randomizer
07:00 - [INAUDIBLE] if you just keep
track of your delta prime
07:04 - and add it to some variable outside
[INAUDIBLE] you do something else?
07:11 - You could even just display
the variable [INAUDIBLE]..
07:16 - SPEAKER 1: Yes.
07:16 - So the response was keep some variable
that you modify with dt in update,
07:23 - or display the variable.
07:25 - Yeah, that's definitely a way.
07:26 - Did you have--
07:26 - AUDIENCE: Yeah, I was just going
to say, keep a float variable,
07:29 - and constantly add a dt
to it, and display it,
07:32 - but display the truncated version.
07:33 - SPEAKER 1: Yeah.
07:34 - So keep a float variable, but just
truncate the delta time off of it.
07:39 - You could do that, definitely.
07:41 - We'll take a look here as
to actually how I did do it.
07:44 - It's very similar to that.
07:45 - This is the wrong directory, though.
07:47 - So it's in timer0 in main.
07:50 - So we do have a variable.
07:51 - So the current second here, which we
are going to keep track of 0, 1, 2.
07:57 - Lua doesn't really have the
notion of truncate a float
08:02 - because when you take a
number that's floating point,
08:04 - and you make it into
a string, you actually
08:06 - have to do string
substitution on it where
08:08 - you use a function called g sub
to take off the last part manually
08:14 - because it doesn't really
differentiate between ints and floats.
08:16 - It just has a number data type.
08:19 - But we can do this by
just keeping track of
08:22 - whether or not we've passed
a certain length of time
08:24 - because we know dt is
given to us in seconds.
08:27 - We can just add to our variable,
and then every time we've
08:32 - gone over 1, because it gives us--
08:34 - it gives you usually like .013, whatever
1/60 or approximately 1/60 of a second
08:39 - is.
08:40 - Once our timer-- we're going to
keep a timer variable-- equals 1,
08:44 - we'll just increment
current second by 1,
08:47 - and then we'll set that
timer back to 0, and then
08:49 - we'll just repeat over, and over again.
08:51 - We'll actually use modulus so in
case we go slightly over 1 second,
08:54 - we can account for that.
08:56 - We do that here.
08:57 - So second timer gets second
timer plus delta time,
08:59 - and then if it's greater than 1.
09:01 - So if a full second has elapsed,
just increment current second,
09:04 - and then modulo a second timer by 1.
09:07 - And Lua is a little different
in that most languages only let
09:10 - you modulo something if it's an integer,
but since there is no differentiation,
09:13 - you can actually modulo
floats, and you'll
09:15 - get the floating point value leftover.
09:17 - And so that's the basic
way of actually doing that,
09:21 - but there's a couple of
things wrong with it.
09:22 - So does anybody want to suggest what
is potentially bad or unscalable
09:26 - about this kind of approach?
09:32 - Well, I'll show you
timer1 so we can maybe
09:34 - get a sense of how this could kind
of get out of hand pretty quickly.
09:40 - So let's say-- first, I'll run timer1.
09:42 - So let's go into timer1 here, and
notice now we have five labels.
09:49 - They're running at different intervals.
09:51 - The first timer, it's
incrementing every 1 second,
09:55 - the second timer is
incrementing every 4 seconds,
09:58 - the third one is incrementing every 4
seconds, and then so on, 3, and then 2.
10:03 - So if we wanted to do the same
approach that we just did,
10:08 - this is what we would do.
10:09 - We have five variables, five timers.
10:12 - Because we want to keep
track of whether or not
10:14 - something's gone over
more than just one second,
10:17 - it's not super easy to just
put this all in a table,
10:19 - and iterate over it, and use
your iteration logic to do that.
10:22 - We actually, because they're in some
sort of random, who knows what order,
10:27 - timer2 takes 2 seconds, OK, timer3 takes
4 seconds, timer4 takes 3, and then 2,
10:33 - you have to unmanageably keep all
of this in separate variables.
10:37 - [? Yes, Tony ?]
10:37 - AUDIENCE: Couldn't you just use one
second timer, or even one variable,
10:41 - and then just in the display [INAUDIBLE]
10:46 - SPEAKER 1: You could.
10:47 - Yeah, in this case, you could.
10:49 - Again, Lua's display, it's a
little bit funky when you--
10:54 - you have to do g sub, and
some weird string stuff,
10:56 - but yes, you could do that.
10:57 - AUDIENCE: Couldn't you just do modulo
1, and then take that value as a string?
11:01 - Is that the equivalent of truncating?
11:04 - SPEAKER 1: Modulo 1 would still
give you the floating point value
11:07 - because there's only one number type.
11:09 - So if we modulo 1.00157
by 1, we'd get 0.00157.
11:14 - AUDIENCE: Oh.
11:16 - OK.
11:17 - If you subtracted from that
value, from I don't know.
11:21 - So it's a value minus the
value of modulo 1, I guess.
11:24 - SPEAKER 1: So yeah.
11:25 - It was proposed that we've
used modulo, and we could.
11:29 - In short, we could, but
what if we're not just
11:33 - printing a value to the screen.
11:34 - What if we have 10 different things,
like 10 different creatures that
11:38 - are all doing different
things over time,
11:40 - and we don't necessarily want to
have to keep a timer for each,
11:43 - and every one of those things.
11:44 - In a simple example like this,
yeah, there's probably a--
11:47 - on purpose, it's also a
little bit convoluted just
11:49 - to illustrate the problem.
11:50 - But yes, there are shortcuts for
this, but the fundamental problem
11:54 - is how can we get rid of having
five different timers for something?
12:00 - And by the way, I'll
go to the next slide.
12:02 - Timer0, the simple way.
12:03 - Timer1, the ugly way.
12:05 - Timer2 is the clean way that
I found using this ecosystem.
12:10 - There's a wonderful library, and
you could implement this yourself.
12:14 - The fundamental idea
is have a global timer
12:17 - object that then manages all
of these different things going
12:20 - on using the power of what I alluded
to earlier, anonymous functions,
12:25 - and I'll show you how that works.
12:27 - So in main.lua of timer2,
we have a set of intervals.
12:32 - We have a set of counters.
12:36 - And then what we're doing here is
we're just saying for i gets 1 to 5,
12:42 - we're calling a function
call timer.every.
12:45 - So if you're familiar with
JavaScript programming,
12:47 - there's a set interval
function which lets
12:49 - you do something every length of time.
12:52 - So first of all, timer
is just a library.
12:54 - We've just required it here.
12:55 - It's part of the knife
ecosystem, and then
13:01 - here, we have a couple of functions,
timer.every, and timer.after
13:04 - that we'll use.
13:06 - Well, basically, what
it does is you give it
13:09 - a length of time-- timer.every seconds.
13:12 - It's in seconds, and you can
give it fractional seconds.
13:14 - You're passing in just a function
here, just an anonymous function.
13:17 - It doesn't have a name, but because
Lua, and a lot of dynamic languages
13:21 - treat functions as first
class citizens, as it
13:24 - called, because they are data types,
you can just pass them into functions.
13:30 - This allows us to do behavior
like this that would otherwise
13:33 - be a little bit tricky to do.
13:34 - We can just say after
this block of time,
13:37 - assuming we've built some structure
that is probably just storing
13:41 - a table with a bunch of things
that have a length of time in them,
13:45 - just call this block of code later.
13:47 - It's called a callback function.
13:49 - We're just going to call it back,
and then we're just going to do this.
13:52 - We're going to say counters
i gets counters i plus 1.
13:55 - So we have all of these intervals,
and all of these counters.
13:59 - So it will just, basically,
manage that for us,
14:01 - and now we don't have five variables.
14:04 - You do have to set whatever
you want those to be.
14:07 - That's your that's your
primitive at this point.
14:09 - You just need the lengths of
time, depending on your problem.
14:14 - In this case, that's all we need.
14:15 - You might need more than that, depending
on what you want to do with timer.
14:18 - But in this case, we just want
to increment in value over time.
14:20 - So keep counters, and then just
keep track of the intervals,
14:23 - and then our code's gone from
I don't know how many lines.
14:26 - It was a lot larger--
14:27 - I think was 96 lines, down
to 98 lines, down to 70,
14:35 - and this is incredibly scalable.
14:37 - If we wanted to add another
one that's 8 for example,
14:41 - we just need to add 8, and then that.
14:44 - I guess I'd have to do this as well.
14:48 - I gets 5 to 6, and then you want
to-- the computer that requires me
14:54 - to off my user so I can make changes.
14:58 - We'll just real quickly
see if I didn't mess up.
15:05 - And so yeah, basically we're
deferring everything to timer now.
15:08 - We get the exact same behavior,
but a much smaller length of code.
15:12 - And the nice thing is
it's very declarative.
15:14 - We can just say OK, every something
seconds, I want this chunk of behavior
15:18 - to happen.
15:18 - I don't have to see OK, I've got
timers up here, I've got counters here.
15:22 - OK, down in my draw function,
OK, I've got to draw all these.
15:25 - It's iterative, and it's declarative,
and that's the ultimate goal.
15:30 - And here, at the very
bottom, it did actually work.
15:32 - Now it's working every eight
seconds, which is nice.
15:34 - One, two, there we go.
15:37 - Super easy to extend.
15:39 - We're going to be using it
a lot in this problem set,
15:42 - and also in future lectures just
because it's a lot easier than keeping
15:46 - track of a bunch of counter variables.
15:50 - And there's another function
that we're seeing here--
15:52 - timer.after because sometimes you just
want to wait a certain length of time.
15:56 - Maybe you have every 1 second for
5 seconds you want a bomb to tick,
16:00 - and then after 5 seconds,
you want it to blow up,
16:03 - and you could also model that with
another function that we'll see soon,
16:06 - but these are probably the
two core time-based functions.
16:12 - And you can go here to this URL
able to see the knife library.
16:15 - There's a bunch of modules
that are really nice.
16:17 - We just happen to be
using timer, and it's
16:20 - tween, and every after functions
primarily in this problem.
16:24 - But we'll use another one called the
event in the Zelda [? p-set, ?] where
16:28 - we actually look at how to dispatch
events, and triggers, and stuff,
16:31 - and to prevent us from
checking every frame.
16:33 - Oh, what do we have to do?
16:34 - If some wall is broken,
this frame, then do this.
16:38 - We can just dispatch an
event that we blow up a wall.
16:40 - We'll get to that.
16:42 - Any questions at all about how those
two models differ, and how they work?
16:49 - OK, cool.
16:51 - So the next thing I want to look at--
so we can tie that back into also,
16:56 - real quick, if we want.
16:58 - Match 3-- whoops, and then
there's a timer that's
17:02 - manipulating the text on the screen.
17:06 - All of those letters in the-- this is
in the start state of the game code.
17:12 - All of those letters have a
color associated with them,
17:14 - but they're on a timer so that
after every 0.075 seconds,
17:17 - they'll go to another
color, and to another color.
17:20 - And so we don't have to
keep track of every letter's
17:22 - individual color, and a timer for it.
17:24 - We can just change them all.
17:27 - If we start the game, something
else that's on a timer, the timer,
17:33 - actually, there, which is
just decrementing some value.
17:36 - Every one second, decrement
timer by 1, and that's it,
17:39 - and we don't have to keep any-- we don't
have to say anything more than just
17:42 - that, and that's what's really nice
about using that kind of model.
17:47 - So another thing that you probably
also noticed, and I'll run it again,
17:51 - is this fade out, and fade
in, and also that animation.
17:55 - Those are things that
are happening over time.
17:57 - We don't actually-- we can
just sort of manipulate them.
18:01 - We can keep track of some
sort of counter for it.
18:03 - We can also just say over this length of
time, change this value to this value,
18:07 - and that's a much easier way
to model the problem mentally.
18:11 - And so we'll illustrate that.
18:14 - First, I'm going to go to tween0.
18:16 - So tween0 is the simple
way to do something.
18:19 - So I'm going to illustrate tweening
here with Flappy Bird just going
18:23 - left to right.
18:24 - So up there, that's what happens when
you print out the number, by the way,
18:29 - just by default.
18:29 - And so if you wanted to
truncate it, yeah, you
18:32 - could just g sub the first two, I
guess, depending on how large it is,
18:37 - and that would have the effect of
displaying it as just an integer.
18:40 - But we can see that over
two seconds, we've had--
18:44 - and there's a little bit of
overlap just because delta time can
18:47 - go a little bit over two seconds when
you're adding to it because it just
18:51 - adds whatever length of time as a
float has elapsed since the last frame.
18:55 - In this case, we're just adding it
until it's greater than or equal to 2.
18:58 - So in this case, we went 0.01 over
2 by the time that actually ended.
19:02 - Some iterations will be less than that.
19:03 - So this one will be--
19:06 - yeah, see, that one was less than 2.01.
19:08 - It just depends on your
computer, and your specs.
19:11 - But Flappy Bird starts on the very left.
19:13 - So he's got an x-coordinate,
and then at the very end,
19:16 - he's got another x-coordinate.
19:17 - So the simple solution is what?
19:28 - We know that we want this
to elapse over two seconds.
19:32 - So what we can do is I'm
going to pull up tween0.
19:42 - And MOVE_DURATION here, it's
a constant of 2 seconds just
19:44 - for the sake of this example.
19:46 - A sprite here, just a simple image.
19:48 - I'm putting everything in one code file
this time, as opposed to breaking it
19:53 - out into subclasses just for simplicity
because these are such small examples.
19:57 - But we're setting it's x and y.
19:59 - Oh, and this is another
Lua trick, by the way.
20:01 - You can assign two variables to
two values using a comma here.
20:05 - So flappyX comma flappyY gets
0, and then VIRTUAL_HEIGHT
20:08 - divided by 2 minus 8.
20:10 - Setting this x to 0, we have a
timer here, and then it's end x.
20:15 - So we want it to end at
the end of the screen.
20:17 - So we're going to say virtual
width minus his width, an then
20:20 - the usual boilerplate for
getting a project set to go.
20:24 - If it's less than the move duration--
so if timer is 0 going up to 2,
20:30 - but it's not quite 2 yet, we're going to
add dt to it, and then we're going to,
20:37 - basically, assign it to
either the lowest of end x,
20:43 - so it will never go higher than end
x, or end x times the ratio of timer
20:49 - over move duration.
20:51 - So timer over move duration,
if it's less than 2,
20:54 - that's going to be some value,
some fractional amount less than 1.
20:59 - So it's going to
basically just scale it,
21:01 - depending on how far we've
moved the timer between 0 and 2.
21:07 - So just a scaling operation.
21:09 - This happens to only work in the context
of moving something from left to right,
21:13 - or from 0 to something else, but it's
a crude, basic way of illustrating
21:18 - a very basic tween operation.
21:20 - That's what it essentially is.
21:21 - It's a multiplier of some ratio
of how much time has passed,
21:25 - versus how much time we're
actually looking to elapse.
21:28 - And that has the effect,
once again, of just--
21:31 - it's scaling the ratio because
it's timer over moved duration.
21:35 - It's something over 2, but
it's not quite 2 over 2.
21:38 - Until it gets 2 over 2, and it's 1,
then end x times 1 is going to be end x.
21:42 - But before that, it's going to be some
fraction of end x between 0 and end x.
21:47 - So it has the effect of giving us a very
basic tween, but it's a little bit--
21:51 - we have a little bit to manage here.
21:54 - It doesn't really feel super clean.
21:56 - Do you guys have any questions
about how this works?
22:00 - OK.
22:01 - So we're going to go here.
22:04 - So first of all, any thoughts about
how that might not be super scalable,
22:11 - looking back at the last example?
22:17 - AUDIENCE: I guess like
the situation before,
22:20 - getting a lot of objects
moving on the screen.
22:22 - SPEAKER 1: Yeah, and what if your index
is different for every single one?
22:25 - Then you have kind of a mess.
22:28 - What if we had something like this?
22:34 - You don't want to keep
track of an end to x.
22:39 - They all happened to
have the same end x,
22:41 - but notice they're moving
at different rates.
22:43 - They're all moving at some
sort of random amount.
22:47 - AUDIENCE: How many are there?
22:48 - SPEAKER 1: There's 1,000.
22:52 - We could go crazier if we wanted.
22:54 - This is a fun thing to
do, is stress testing.
22:58 - So if I go to tween1, and I
go to main, timer max is 10.
23:04 - So we're saying that the
longest possible time
23:06 - any bird can take to get from left
to right is going be 10 seconds.
23:11 - So right here, we're using
a table based approach here.
23:14 - We're actually keeping track of
1,000 birds, and we're saying,
23:17 - OK, here's an empty
table from 1 to 1,000.
23:20 - Add a new bird, and in this case, we're
not adding a bird object, or anything.
23:23 - It's just a table.
23:24 - They all start x equals 0, left side.
23:26 - Their y is random.
23:28 - So they can be anywhere between the
top and the bottom of the screen.
23:31 - So VIRTUAL_HEIGHT minus 24.
23:32 - 24 happens to be the
height of the sprite,
23:34 - and I should have probably put
Flappy sprite get height right there.
23:37 - And then rate, they're all
going to have their own rate.
23:40 - So rate gets math.random.
23:41 - Math.random without a
value passed into it
23:44 - gives you a fractional value
between 0 and 0.999999.
23:52 - What this has the effect of doing
is math.random with just two values,
23:55 - if you pass in 10 and 50, it's
going to give you 10 to 50,
23:58 - but they're always going
to be integer values.
24:00 - You can't say like 10.0 and
50.0, and assume that it
24:03 - will know what you're talking about.
24:05 - It's just going to be integers.
24:06 - So if you give it one
value, it will know.
24:08 - OK, you're asking me for a
float between 0 and 0.999999.
24:13 - That's going to act as the
fractional part of whatever value we
24:16 - might want to generate using a
math.random with a value passed in.
24:20 - So here, we're saying OK,
math.random, TIMER_MAX minus 1.
24:24 - So TIMER_MAX is 9.
24:26 - So our TIMER_MAX is 10, sorry.
24:29 - So if we subtract 1 from
that, this is math.random 10.
24:33 - So we're going to get a
value between 1 and 9.
24:37 - So TIMER_MAX minus 1 is 9.
24:38 - Sorry if I said 10.
24:39 - TIMER_MAX is 10, TIMER_MAX
minus 1 is 9, but we're
24:43 - adding math.random,
some fractional amount.
24:46 - So whatever value we choose between 1--
24:49 - actually between--
yeah, between 1 and 9,
24:53 - it's going to be that
value, point something.
24:58 - So this is how you get random--
24:59 - basically, at the end
of the day, this is
25:01 - how you get random floating
point numbers in Lua and Love2D.
25:07 - Does that make sense?
25:08 - Do you guys have questions about that?
25:09 - AUDIENCE: So your final rate
could be anywhere from 0 to--
25:12 - SPEAKER 1: Final rate is going to be
anywhere from 1-- in this case from,
25:15 - 1 to 9.999999.
25:19 - If we wanted it to be
0, we could do that,
25:22 - and that'll give us the effect of taking
whatever we get, and subtracting 1.
25:26 - So now it will be
between 0 and 8.999999.
25:32 - And if we did this--
25:35 - AUDIENCE: Couldn't each
math.random end up at 0?
25:39 - SPEAKER 1: No, because math.random,
if you pass in a value,
25:43 - it'll always do from 1 to some value.
25:46 - The question was will math.random
give you 0 if you pass in a value?
25:50 - And math.random, by default, gives
you between 1 and something else.
25:54 - And so that's why we do this.
25:57 - That's not why we do this.
25:58 - We do this to add the fractional
part so that we can get
26:00 - fractional floats between some value.
26:04 - But yeah, if you wanted it to be
between 0, and something else,
26:07 - you would just subtract
1 from the final result
26:09 - because we know that we're always
going to get from 1 to some value.
26:12 - If you minus from 1, you
will never go below 0.
26:15 - It will always be 0 to something
else, and then in that case,
26:17 - we probably would just
take off the minus 1
26:19 - from TIMER_MAX so that it will be
between 0 and 9.999999 in this case.
26:26 - But as a design decision, I
made it so that we would always
26:29 - have at least a rate
of 1 because then it
26:31 - could get really, really slow if it's
like 0.005 or something like that.
26:36 - You wouldn't want that.
26:37 - It would take ages.
26:42 - OK, so we have a timer.
26:45 - We're not using knife.timer
in this case yet.
26:50 - Basically, in update, we're just saying
as long as timer max is less than--
26:53 - timer is less than timer max.
26:55 - This update logic will only run as
long as we haven't gone over timer max.
27:00 - Increment it, and then for
each bird, basically, we're
27:04 - doing the same thing that we
did before, except we're using
27:06 - that bird's rate as the scale factor.
27:09 - Yeah, the denominator
of that ratio, and that
27:13 - will have the effect of
multiplying all of those birds
27:16 - individually, based on
their own rate, rather than
27:19 - some global rate, if that makes sense.
27:23 - And then here, we're just drawing
all of them at their own x and y.
27:27 - And just again, we're just
storing birds are just
27:30 - a table with a few
variables in this case.
27:32 - Just a very simple shell,
and it has the effect of--
27:36 - oh, and one thing I wanted
to do is just add a 0 there.
27:41 - I've got to do this every
time because I didn't
27:43 - set my permissions appropriately.
27:45 - But now there's going
to be 10,000 birds.
27:47 - So let's see how this looks.
27:50 - So it looks pretty similar, actually,
but it's a little more condensed now.
27:53 - I don't notice a frame rate drop.
27:55 - If we wanted, we could go down to
love.draw, and love.graphics.printf
28:04 - at FPS, and then to string,
love.timer.getFPS, and then
28:15 - let's set it to 4, and then
VIRTUAL_HEIGHT minus 16,
28:24 - and then got to do this again.
28:26 - This should have the effect
of giving us our frame rate.
28:28 - So we can really stress test
this, and see what the--
28:34 - oh.
28:35 - I made a mistake.
28:36 - OK, let's see.
28:37 - What did I do?
28:38 - Push.start.
28:40 - I'm guessing I missed a--
28:42 - yeah, I missed a--
28:46 - do that, and then that,
and then save it again.
28:51 - Sorry about that.
28:52 - There won't be too many of
these edits, but I figured
28:54 - this would be fun to illustrate.
28:56 - So now, this should work.
29:01 - Printf, so we have that.
29:05 - Oh, right, and then it
just needs to be print.
29:08 - It doesn't need to be printf.
29:10 - Got to save again.
29:12 - Sorry.
29:14 - This will be worth it, I hope.
29:18 - There we go, 5160.
29:20 - OK, it takes a couple of seconds.
29:21 - It has to interpolate between
the last couple of times
29:24 - that it's pulled for frames,
and when you start up,
29:26 - it doesn't have the data it needs.
29:28 - So 10,000, easy.
29:31 - Let's do like a million.
29:34 - So we have 10,000, 100,000, a million.
29:39 - I really got to change
those permissions.
29:41 - Getting good at practicing
my password, though.
29:44 - Going to go ahead, and do that.
29:46 - Ooh.
29:48 - Oh, my laptop is suffering.
29:50 - Oh man, but they're all moving
independent of frame rate.
29:53 - This is just a testament to
how powerful delta time is.
29:56 - They all move there after 10 seconds.
29:59 - We've got to 10.6 seconds,
which is not good.
30:01 - That means that's how long
passed between the last frame,
30:04 - but my laptop clearly can not handle
a million birds on the screen,
30:08 - but it can handle 10,000,
or maybe even 100,000.
30:12 - And that's just a fun way--
30:13 - a fun thing to do.
30:15 - In general, when you want
to stress test your game,
30:18 - just put the frames per
second on, and just go nuts.
30:21 - Just add a lot of stuff.
30:22 - Just see what your computer
is capable of because you
30:25 - can find new, fun things that
way, I guess, and maybe just
30:29 - see how good your code is too.
30:32 - So tween0, simple way.
30:35 - We have just variables, and one counter.
30:38 - No tables or anything.
30:40 - Tween2 is a good way for
if we have a lot of things
30:43 - that we want to manipulate over time.
30:45 - But what if now we want
some of them to change
30:49 - their opacity over time or something?
30:52 - It starts to get a little
bit more complicated.
30:55 - And this is, by the way, I should've
put this earlier in the code,
30:57 - but this is the knife library
is responsible for timer,
31:03 - and a lot of other things
that we'll be looking at,
31:05 - and it's got a bunch of
modules here listed--
31:07 - behavior for state
machines, which is like what
31:09 - we've been doing for state machines,
but they have their own version of it.
31:13 - Knife.bind, so you can pre-bind
arguments to functions,
31:16 - and create subfunction.
31:18 - It's called currying, but create
subfunctions of other functions
31:20 - that have pre-determined variables.
31:23 - Knife.chain, we'll see, actually,
how that can be used coming up later.
31:28 - Convoke is for coroutines.
31:30 - We'll see coroutines in
the context of Unity,
31:32 - but basically, they're functions
that can pause their state for later.
31:36 - Knife.event we'll use
in two weeks for Zelda,
31:41 - maybe even next week if I
can fit it in for Mario.
31:44 - Memoize is for memoization.
31:46 - It's like a dynamic
programming related thing.
31:49 - Serialized system.
31:51 - System is going to be useful to know
about in context of Unity as well.
31:55 - Unity uses an entity component
system for much of its structure.
31:59 - Knife.test, and then
lastly, knife.timer,
32:01 - which is what we'll end up using, and
this is probably my favorite library
32:05 - that exists in the Love2D ecosystem.
32:09 - And so with that said,
we'll look at tween2 now.
32:12 - I'm going to go here into tween2, and so
now we have not just movement, but also
32:22 - their opacity.
32:23 - They all start at
different opacity levels,
32:26 - and we want to not only
change their movement
32:30 - over time, but also the opacity.
32:34 - So it would get a little
bit trickier if we decided
32:39 - to do that with our current situation.
32:40 - Totally doable, but how would we
go about changing, just right now,
32:47 - their opacity just as is?
32:50 - How do you change a spite's opacity?
32:54 - AUDIENCE: The variable and
the graphics [INAUDIBLE]
33:01 - SPEAKER 1: Is it a variable--
can you say that one more time?
33:04 - AUDIENCE: I forget the
exact function name,
33:06 - but it's like love.graphics
to put an image on the screen.
33:13 - SPEAKER 1: The love.graphics.draw.
33:15 - AUDIENCE: Wasn't there
an argument in that?
33:18 - SPEAKER 1: So it's actually not
an argument to that function.
33:22 - So I'll show you now.
33:24 - So in order to draw something
at some different opacity,
33:27 - it's actually love.graphics.setcolor,
and we do that here.
33:33 - So recall that Love2D is a state
machine, and how it draws things.
33:38 - You can basically set
a color onto anything
33:41 - that you draw, whether it's
a font, an image, or a shape.
33:47 - And if you just pass in
255, 255, 255, that's white.
33:53 - And then if you give
it an opacity, which
33:55 - is the fourth parameter, which
is the alpha component of that,
33:58 - then that's how transparent it will be.
34:00 - And so we could have done
this with other colors too.
34:03 - We could have done this with
like if we wanted to tint it red,
34:06 - and also have it be sort of transparent.
34:07 - We could do that if we just
did 25500 bird.opacity.
34:12 - But if you just want to manipulate
opacity independent of--
34:14 - or its transparency or its
alpha independent of its color,
34:18 - and keep it the same exact
color, you just do it white.
34:21 - If you did it black,
nothing would show up.
34:25 - Is that true, actually?
34:26 - Let me verify that.
34:29 - Pretty sure that's right,
but I could be wrong.
34:38 - I'm right, thankfully.
34:40 - OK.
34:41 - That or they're just black, and
there's a black background too.
34:44 - Do you have a question, [? Tony? ?]
34:46 - AUDIENCE: No.
34:46 - SPEAKER 1: Oh, OK.
34:49 - So we'll take it on faith
that that is correct.
34:58 - And back to the gist of this example.
35:06 - We have TIMER_MAX again.
35:07 - Actually, we really
haven't changed much.
35:10 - What we have changed is
we still have our birds.
35:14 - We need to keep track of their
x, of their y, of their rate.
35:18 - Well, not necessarily their rate.
35:19 - Oh, well, their rate, yeah,
because we're actually
35:21 - going to loop over each
of these, and then create
35:24 - a timer between operations for them.
35:26 - And their opacity.
35:28 - Oh right, they start
with an opacity of 0,
35:29 - and faded to 55, regardless of their--
35:38 - their opacity changes at the
same rate as their x does.
35:43 - So the farther away,
the longer they take,
35:44 - the slower they fade to fully
opaque, and we see this here.
35:49 - So for k bird and pairs of birds.
35:51 - So for every bird, we're just going to
set a tween, and then this is tween.
35:55 - So timer.tween is I think I
have a slide on it here, right?
36:00 - A super cool useful function,
super easy to use too, it
36:05 - takes iteration just like timer.every,
timer.after, and it takes a definition.
36:10 - So in this case, it doesn't
take an anonymous function
36:13 - like the other ones did
because we're not really
36:15 - saying I want to do some
sort of undefined behavior
36:19 - over the course of this operation.
36:20 - What I want to do is
just change some values.
36:23 - I want to interpolate them.
36:25 - So what we're going to do is just
pass in a-- this is the syntax for it.
36:31 - We pass in square brackets, the
actual thing that we want to change.
36:35 - In this case, I want to change bird.
36:37 - I want bird to change
in some way, and then
36:41 - what I want it's values to
change toward are these.
36:44 - I want it's x to change to end x,
and I want it's opacity to go to 255.
36:50 - And I wanted to do it over
bird.rate, and so this bird.rate,
36:54 - every bird is storing it.
36:55 - So for birds that got
a rate of 2, then it's
36:57 - x is going to go to end x
over the course of 2 seconds,
37:01 - and it's opacity is going to go to
255 over the course of 2 seconds.
37:06 - And you can put as many things
as you want, and as many--
37:10 - you can put as many variables
here, and as many entities.
37:15 - Entities being anything
that you want to change that
37:17 - has a field, any table-based
or class-based structure.
37:21 - You can pass any of those in here,
and just tween them all at the same--
37:25 - if they all have the same rate, and
then just get that operation that way.
37:29 - And so that has the effect here
of all we need to do is just add--
37:33 - it's like two lines of code, but
now we've easily changed it so
37:36 - that we can just tween
two things at once,
37:40 - and that's the power of
timer.tween, and we'll see that.
37:42 - So back to, actually, Match 3,
if we want to look at that again.
37:49 - This is a tween, that's a tween,
that's a tween, and that's a tween.
37:54 - So the white, the foreground
there, is just a rectangle
37:59 - that fills the whole screen.
38:01 - It's just a white rectangle.
38:03 - I have it set to timer.tween
opacity from 0 to 255.
38:08 - Before that gets called, if we go from
the start to the begin game state,
38:13 - and then if we go from at the
beginning of the game state,
38:18 - before the level text comes
down, it's going from 255 to 0.
38:23 - So it's just the reverse of that is
the tween, and then all it's doing
38:26 - is just drawing a
rectangle to the screen.
38:28 - But that's how you get a
very simple transition.
38:32 - Same thing for fade to black.
38:33 - If you want to fade the
whole screen to black,
38:35 - just draw a rectangle
the size of the screen,
38:37 - and then just tween its opacity
from 0 to 255, and then vise versa.
38:42 - That's how you get a simple transition.
38:44 - It can be any color you want.
38:45 - It can be a red transition.
38:48 - And then the level text, that's
just a tween on the y, right?
38:54 - And then I just have some rectangle,
love.graphics.rectangle with text,
38:59 - and it just says timer.tween to like
VIRTUAL_HEIGHT divided by 2 minus 8,
39:04 - and then timer.after1.
39:08 - So we can actually pull
this up if we want.
39:10 - We can see how this works.
39:14 - Today's going to be a little
wider on the main distro code
39:17 - just because a lot of
this is more conceptual.
39:20 - But in the begin game state--
well, actually, in the start state
39:27 - is when we go.
39:29 - So these colors, and letter table, and
stuff that's all for the Match 3 text,
39:33 - if you're curious.
39:34 - So these are all back to what I said
earlier about the beginning screen
39:37 - having Match 3 with the different
colors going on a timer.
39:41 - These are just tables of colors.
39:43 - So notice this is RGBA, and
then I'm just performing
39:47 - a shuffle on them every 0.075 seconds.
39:49 - So 2 will get 1, and vise versa.
39:52 - It'll all go down, and then 6 will
come up here to 1 every 0.75 seconds.
39:58 - And then M gets mapped to this
one, A gets mapped to this one,
40:01 - T to this one, C, H, 3, and that's it.
40:05 - That's done here at line
44 of the start state.
40:09 - But what I was going to show you
was the tween for the transitions.
40:16 - So here in start state, in
the update function says,
40:21 - it says if we press Enter,
and our current menu item
40:24 - is 1, meaning that we're on start
game, not quit game, timer.tween here.
40:29 - And notice that we have a finish
function, which will show--
40:33 - I'm actually going to show you in the
next couple of examples, the chain
40:37 - examples.
40:38 - But finish is just a
function that you can
40:40 - run after any timer that just
says, hey, when this is finished,
40:43 - run this block of code, and notice
that takes anonymous function here,
40:47 - just like that.
40:48 - So we can say OK, tween, over
the course of one second,
40:52 - notice we're passing self into here
because we want to manipulate ourself.
40:55 - We have a value that
we want to manipulate.
40:57 - So self.transitionAlpha.
40:59 - So we're saying I want to
take my transition alpha,
41:02 - and I want it to go to 255, and we set
it to 0 by default. So at the very top,
41:07 - here, at line 60, transition alpha
is just our white rectangle that
41:13 - fills the screen.
41:14 - I'm just saying set it to 0
so we don't see it at all.
41:17 - It's going to be invisible.
41:18 - It's still there no matter what.
41:20 - It's hidden, but after
we press Enter, tween
41:23 - it to 255 over the course of 1
second, and then when that's finished,
41:27 - notice this is familiar, right?
41:29 - gStateMachine change begin game.
41:31 - We're going to go with the
begin game state after that.
41:33 - Our passing level gets 1.
41:35 - We're starting the game, and then
we're going to remove this color.
41:38 - Remove that timer from
the-- this is actually
41:41 - unnecessary in this circumstance,
but you can remove timers from timer.
41:47 - If you have something going constantly--
41:49 - in this case, the color timer, and
let's say we move from this state
41:53 - to the next state, the next state
doesn't have all those colors,
41:55 - right, the Match 3 colors.
41:58 - So we don't need to keep--
because timer is a global object,
42:01 - it's going to keep updating
over, and over again.
42:05 - We don't need certain timers
to exist indefinitely.
42:07 - We can just remove this one
because it's not relevant anymore.
42:11 - But this is all it takes just to give
us a simple transition from one screen
42:14 - to another.
42:15 - Just give this transition alpha 255
down in the actual render function.
42:23 - Where is it?
42:24 - It is right here.
42:31 - So right here.
42:34 - Draw our transition rect.
42:35 - It's going to be drawn last so that it
draws over everything when we finally
42:39 - do get a transition, but
self.transitionAlpha,
42:42 - and that's all we really need.
42:44 - We need to keep the
variable, and then whenever
42:45 - we want to perform like some
sort of operation over time,
42:48 - just use timer.tween.
42:49 - It's that easy.
42:51 - But that was a little bit of a--
42:52 - it was a relevant tangent.
42:54 - We would have talked about it
anyway, but that's the first use case
42:59 - that I think of in this project,
and then also the label.
43:03 - I'll show you the label in a little bit.
43:05 - But I think before we do that,
let's talk about chaining.
43:08 - So you guys have probably
played a lot of games
43:12 - where maybe there's a cut scene,
and you're looking at a character,
43:15 - and they walk, and then maybe they turn,
and they walk in another direction,
43:18 - and they walk up, and
then they speak to you.
43:20 - There's a dialog box, and then maybe
they do an animation or something,
43:23 - and then maybe some other
things happen that are
43:26 - on some sort of predestined path.
43:28 - It's a very discrete path.
43:30 - It's not random.
43:32 - It's laid out in advance.
43:33 - It's a series of steps, one consecutive.
43:37 - That's the concept of chaining
things together is relevant
43:42 - when we get to sort of timing
things because when we finish timing
43:46 - something-- because usually,
a lot of those things
43:48 - happen over the course of time.
43:50 - Over the course of five seconds,
NPC1 will walk up north,
43:54 - and then they'll turn left,
and then they'll say something.
43:58 - We want to model that.
43:59 - We don't want to basically
have variables that say
44:02 - if NPC1 is at this tile, then do this.
44:07 - If NPC.dialogueOpen, then do this.
44:12 - We basically want to say
walk here, do this, do this,
44:15 - do this in a flat, easy-- or at least
semi-flat, easy sequence of steps.
44:24 - I have a few examples to illustrate
how we can do that using timer
44:27 - for some semi-basic use cases.
44:30 - So chain0 is the first one.
44:33 - So this one is just Flappy Bird.
44:34 - He's going left to right, then he goes
down, then he goes back left again,
44:38 - and then he goes up.
44:41 - What's the basic way
that we model this--
44:46 - that we implement this?
44:49 - Just off the cuff.
44:55 - AUDIENCE: We can use that
finish thing to do the--
44:58 - SPEAKER 1: We would.
45:00 - If we didn't know about finish,
how would we probably do it?
45:05 - I shouldn't have given away finish
before I got to that example.
45:08 - I kind of got ahead of myself.
45:12 - We can imagine somebody
maybe saying OK, I
45:15 - want Flappy to move left to right,
right to bottom, bottom to left,
45:19 - bottom to up.
45:21 - Maybe they're going to say
if Flappy is less than--
45:24 - or has reached first point, move left,
else if he's reached bottom or point 2,
45:31 - move down, and then move left, move up.
45:34 - And in both of those cases, they're
changing the x and y value of Flappy,
45:41 - and it's basically just a lot
of ifs, and state variables.
45:48 - I see it in a surprising amount of code.
45:50 - Just state being kept
all over the place.
45:54 - The first implementation of that that
we'll look at uses something similar.
45:58 - So in chain0, and there's only two
examples here, actually, for chain.
46:05 - But chain0, there's a movement
time, and then a timer.
46:13 - We're going to be semi-clean about it.
46:15 - We have some destinations.
46:16 - OK, so we have destination1.
46:18 - I know that I don't necessarily want to
keep track of a bunch of if statements,
46:25 - but I'm going for--
46:26 - assuming that I don't know
what timer can do for us,
46:30 - here, I'm just saying OK, I
want this first destination
46:34 - to be virtual width
minus his width, and then
46:38 - keep him at y0 So right edge of the
screen, assuming that he starts at 0,0.
46:43 - And then I want his second destination
to be that same side on the x-axis,
46:46 - but I want the y to be virtual
height minus his height.
46:49 - So go to the bottom of the screen.
46:51 - Then I want it to be 0 in his height
from the bottom of the screen,
46:54 - and then back to 0,0.
46:56 - So we have those modeled, and then I
want to keep a flag in each of those.
47:01 - I want to know whether he's
reached that state yet.
47:04 - So I'm going to iterate over
that table I just created,
47:07 - and just add a new key to
each of these called reached,
47:10 - and just set it to false.
47:11 - Just by default, he hasn't
reached all of them yet.
47:14 - And then in the update,
basically, I'm going
47:17 - to set a timer to the
min of movement time.
47:20 - So it will never go higher than movement
time, and then timer plus delta time.
47:26 - And then for every destination in
destinations, if it wasn't reached,
47:32 - then set its x and y, FlappyX and
FlappyY, which are, in this case,
47:36 - we're uncleanly using global
variables to keep track of this.
47:40 - FlappyX and FlappyY gets baseX.
47:43 - So notice another problem.
47:44 - We have to maintain where we are
relative to our next spot in order
47:49 - for this math to work because
before, we just took Flappy Birds--
47:57 - basically, the timer
divided by movement time
47:59 - was a ratio where we
scaled the end destination,
48:02 - and assigned that to Flappy,
which had the effect of moving
48:06 - Flappy left to right.
48:07 - But if we do that in the
opposite, right to left,
48:10 - the math isn't the same
because he's going backwards.
48:14 - He's getting negative
values added to his x value.
48:19 - So we need to keep track of a
base that he started at for each
48:22 - of these operations baseX, baseY.
48:25 - So at the very beginning,
baseX, baseY is 0,0.
48:28 - So it's actually going
to be much the same,
48:30 - but as soon as Flappy get to
the right edge of the screen,
48:32 - we want baseX to be the right
edge of the screen, baseY still 0,
48:36 - and then if he goes down, we want baseY
to then be bottom edge of the screen,
48:40 - baseX to be right edge, and so forth.
48:42 - So what we do is we just scale.
48:45 - We're still using a timer over
movement time as our scale factor,
48:50 - but we're adding the difference
of our destination and our base,
48:54 - and we're multiplying by
that scale factor instead.
48:58 - And so this difference, if
we add it, whether we're
49:01 - moving left, or right,
or down, or up, it's
49:05 - going to have the effect of filling
in that gap of bridging that no matter
49:09 - where we are, no matter which
direction we want to go.
49:11 - And so this is basically a fairly
complete linear interpolation
49:18 - algorithm, which is
the basis of tweening.
49:21 - Just interpolate some value
between another value.
49:26 - It's usually modeled in geometry
as the line between two segments.
49:32 - And then if timer gets
movement time, we've
49:35 - reached our destination, reset
the timer, reset or baseX and Y,
49:40 - and that has the effect of just doing
what we saw earlier, which was just
49:43 - putting him point by point.
49:47 - So any questions as to how
this interpolation-- how
49:50 - this way of modeling the problem works?
49:57 - All right, so there is a better way, a
much better way thanks to timer.finish,
50:06 - which you can apply to any timer
operation, including timer.tween.
50:11 - So we can basically say OK, once that
operation is finished, do something.
50:17 - And this is all we have to do,
we just have to say timer.tween.
50:21 - We no longer have to interpolate at all.
50:22 - That's taken care of for us by timer.
50:24 - So we're doing timer.tween
over movement time.
50:29 - Flappy, set it to-- this was before we
add all this in a destinations table
50:34 - with reached flags as well.
50:36 - Now, we just have the x and y here.
50:40 - So on the first movement, we want
his x to be right edge of the screen,
50:45 - just like before-- y get zero.
50:46 - Once that's finished, anonymous
function with another timer.tween.
50:52 - So we're saying OK,
once you're finished,
50:54 - then tween him from the top right
edge to the bottom right edge.
50:59 - So y gets VIRTUAL_HEIGHT
minus FlappySprite getHeight.
51:03 - And then once that's finished,
another anonymous function,
51:06 - another timer.tween, another
finish, another anonymous function,
51:09 - another timer.tween.
51:10 - And this is, in its own way, unscalable.
51:14 - It's nested.
51:15 - There's a term for it
called call back hell
51:17 - because you just get infinite downwards
sloping anonymous functions with all
51:22 - this behavior.
51:23 - There are ways to flatten it, and
we potentially will talk about it.
51:27 - It's part of knife.chain.
51:29 - Knife.chain has a way
to turn all of these--
51:32 - basically, it would look
something like this.
51:34 - It would be chain, and then it
would be like moveFlappy x, y.
51:38 - MoveFlappy x2-- it wouldn't be x2, y2.
51:43 - We'd actually write these out here, but
it would have the exact same effect.
51:49 - This is if you're looking to maybe
implement a cut scene system, or just
51:55 - some sort of scripting
system for your game
51:57 - that's very declarative,
and imperative in style.
52:03 - This is the holy grail of changing
behavior, and getting it to work,
52:10 - and just making it look
nice, and readable.
52:12 - Yeah?
52:13 - AUDIENCE: Well, you could also pass in--
52:16 - you could pass in a table to your
function of x's and y's [INAUDIBLE]
52:21 - simpler for [INAUDIBLE]
to chain a lot of things.
52:25 - SPEAKER 1: Yes, you could do that too.
52:27 - The response was you
could pass in a table to--
52:30 - you could iterate over a
table, and within that table,
52:33 - generate a timer.tween.
52:36 - The only issue comes about with
finish, and there is a way--
52:45 - I guess you could get a
reference back to the timer,
52:49 - and then add a finish block to it,
but then you would lose out on--
52:55 - that does work for the same
function if all you're doing
53:03 - is moving something to a bunch of
locations, it's absolutely true.
53:07 - But if we wanted Flappy say something,
and hero disappear, and then
53:19 - hero flash, it gets a little bit
trickier to do stuff like that.
53:23 - But yes, I agree.
53:23 - There are ways of modeling-- this
particular example is a little bit
53:28 - repetitive, and could be
modeled, I think, better
53:31 - with a function that takes
advantage of the fact
53:34 - that timers can be returned, and
then given new finish variables.
53:39 - I'd have to experiment with it
to see because I'm actually not
53:42 - 100% sure that you can add a finish.
53:46 - No, I think you can, actually.
53:47 - I think you can add a finish
function to a reference
53:50 - because it's just a
function on an object.
53:52 - So yeah, but independent of
that, I think the goal probably
53:58 - is one, knowing how we can now
chain behavior, and then two,
54:04 - striving towards flattening it.
54:06 - But in the purpose of this problem
set, we'll see this a couple of times,
54:10 - and it's just worlds better than before.
54:14 - What's this, 76 lines?
54:16 - And then tween1 or chain0 was 96.
54:22 - OK, so 20 lines of code.
54:25 - And also the fact that now we have
a declarative interface for modeling
54:29 - asynchronous behavior, that's
really the fundamental thing,
54:31 - is not having some value that models
your duration, or your counter,
54:37 - or whatever value, but just saying,
hey, over this length of time,
54:40 - I want you to do this.
54:41 - I want you to do this.
54:42 - I want to do this.
54:43 - I want you to do this.
54:43 - After this length of time,
I want you to do this.
54:49 - I always like to try and strive towards
making code as declarative as possible
54:53 - just so that you can
read it in the future,
54:55 - and then the people
working on your code base
54:58 - can also read it well
in the future, and I
55:01 - think timer does a pretty
awesome job of that.
55:03 - And this is just a
reference for timer finish.
55:05 - So it just takes a callback,
and then once a timer function
55:08 - tween every or after has completed,
it triggers that callback.
55:13 - So we're going to take a break for five
minutes now, and then once we get back,
55:17 - we'll talk about swapping, and some
of the algorithms we use in Match 3,
55:21 - starting with just rendering a board,
getting tiles to swap, tweening them,
55:25 - and then we'll actually look
at how we take falling tiles,
55:29 - and account for them,
and then repopulate them.
55:36 - All right, we're back.
55:37 - So recall, before break
we were looking at timer,
55:41 - and how to take code that was previously
managed by timers, and asynchronous,
55:47 - but also very stateful, and sort
of messy, and all over the place,
55:50 - and putting it into a
more declarative, clean,
55:53 - easy to express format via timer.tween,
timer.every, timer.after, timer.finish,
55:59 - timer;finish for any timer objects.
56:02 - So with all that out
of the way, now we'll
56:04 - start talking about the
actual Match 3 mechanics.
56:07 - And the very first thing
that we'll look at is swap0,
56:11 - and this is the sprite sheet for
Match 3 that's included in the distro.
56:15 - So as we can see, it's something that we
can easily chop up with generate quads,
56:20 - as we saw before.
56:21 - Just a function provided in util.lua.
56:24 - These are all 32 by 32 pixels.
56:25 - So it would be very easy just
to go through all of them,
56:27 - and basically just generate quads
with the sprite sheet 32, 32,
56:32 - and just get a table with all
of these individual things.
56:36 - But notice that they're blocked
up into patterns of colors,
56:41 - and this has actual meaning,
and value for our game
56:44 - because when something
is the same color,
56:47 - and only when something is the same
color, a tile is the same color,
56:51 - are we allowed to
trigger a match with it.
56:54 - If we get any three or four--
56:56 - anything higher than three
together in a line, vertically
56:59 - or horizontally, that's a match, and
we need to remove it from the table.
57:04 - So we need some sort of way of
identifying these tiles as being
57:07 - of some color, and then they also happen
to have a different pattern on them.
57:11 - This one's got nothing, but then an
x, and then a circle, and a square.
57:15 - So those patterns-- it's not
implemented in the distro,
57:18 - but part of the assignment.
57:19 - It's actually going
to make them relevant.
57:22 - But the part that is implemented is
the actual matching of the colors.
57:27 - And so the first thing that we'll
need to do, probably, when we actually
57:31 - get into the core code
of the distribution
57:34 - is instead of just putting them
into one table, categorizing them.
57:40 - Splitting it up into maybe one, two,
three, four, five, six, seven, eight,
57:44 - nine times two--
57:45 - 18 tables, so that we can
just say gframes at color.
57:50 - So color being one to 18, and
then get the index into that.
57:54 - So there's six within each one.
57:56 - So it'll be one to six.
57:57 - One to six will be the variety,
with one being the base variety.
58:01 - And part of the assignment
will be make sure
58:03 - that the base variety is the only
one that we start with on level one,
58:08 - but then gradually introduce
these other varieties.
58:11 - And you can put them
in whatever hierarchy
58:14 - you want to, but make them
have some sort of value
58:17 - later on top of a few other
things the assignment will cover.
58:20 - But that's the
spreadsheet in a nutshell,
58:22 - and we'll be splitting it that way.
58:23 - So 18 tables of quads, instead
of one quad of whatever
58:29 - this amount is-- eight by 16.
58:31 - Not sure how many that is
off the top of my head.
58:33 - But let's take a look at
swap0 in the distribution
58:38 - so we can get a sense
of what we need to do
58:41 - to begin implementing our Match 3 game.
58:46 - Notice we have require
util for GenerateQuads.
58:49 - We're just going to generate
for this basic example.
58:51 - We're not going to differentiate between
colors, and varieties, or anything.
58:54 - We're just going to put them all
into one quad, or one table of quads.
58:58 - So we're just going to use the
regular GenerateQuads function.
59:00 - We're not going to differentiate them.
59:03 - We're just going to use our
sprite here, our match3.png
59:05 - provided in the distro, which is
the exact same image that we just
59:08 - saw on the screen.
59:09 - I'm going to just generate them.
59:11 - They're 32 by 32--
59:12 - generate the quads for them.
59:13 - They're 32 by 32 pixels.
59:15 - I'm assigning it to a table
here called TileQuads.
59:19 - And then here, we're
calling generateBoard,
59:21 - and so generateBoard isn't all that
dissimilar to what we saw before
59:25 - with maybe the level maker in Breakout,
where we just spawn a bunch of bricks,
59:30 - or a bunch of tiles, in this case.
59:33 - Except in this case, they're
kept in a nice 2D array that's
59:37 - always going to be eight
by eight, and that's never
59:39 - going to change just by one of
the constraints of the game.
59:43 - Match 3, traditionally, is
an eight by eight grid that's
59:45 - always full of tiles of some variety.
59:48 - So local tiles, it's going
to be an empty table,
59:51 - and then we're going to do
a nested for loop here--
59:53 - y to x.
59:54 - The standard is usually
y first, and then x,
59:58 - and then we index y before x just
because the individual rows in a 2D
60:05 - array, or sprite, or table will be such
that, for example, if our table was
60:13 - equal to this-- oops, sorry.
60:15 - Syntax bug.
60:18 - If we did this, and then we have a table
here, and a table here, and a table
60:25 - here, and we had like 0, 1, 1, 1,
1, 1, 1, 1, and then 1, 1, 1, 1.
60:35 - If we index into this table--
60:37 - so table at 0, that's going
to give us another table.
60:43 - That's not going to give us--
60:45 - let's say we wanted to get
the value at table 2, 3.
60:56 - The instinct might be to think
I'm going to index at x, y
61:00 - just because x, y tends
to be more commonly seen.
61:04 - But if we did that, and
assumed that x was horizontal,
61:08 - and y is vertical in this
arrangement, which is how we have it,
61:13 - then table2 wouldn't be this value
here table2 would be this table here.
61:20 - The first value you passed into indexing
some table when it's a nested table
61:26 - is just, in fact, the
table itself, which
61:29 - is why we actually need to do--
when we want to get some value,
61:33 - we have to index at table y, x.
61:35 - So it's flipped for that reason
because x is actually going to be--
61:40 - the first index is going
to be these sub tables,
61:46 - or sub arrays if you're in C,
or Java, or something like that.
61:51 - So when you see table y, x, and
you're wondering why it's not table x,
61:54 - y, that's the reason.
61:56 - So any questions as to why
that is, or how that works?
62:01 - AUDIENCE: [INAUDIBLE]
62:05 - SPEAKER 1: In this case, I
was using zero based indexing,
62:10 - but Lua is one index.
62:11 - That was just habit.
62:15 - It was pointed out that I was using
zero based indexing in my example.
62:18 - You want to use one based indexing
when you're actually programming,
62:22 - and not zero based.
62:25 - But the same principle applies.
62:27 - Zero would be one in that case.
62:31 - In a general purpose language--
62:34 - most languages, if we were to abstract
the problem out in a C 2D array,
62:42 - or C++, or Java, zero
would be appropriate there.
62:45 - But anyways, we have a nested for loop.
62:49 - We're starting at y, and
then we're going to x,
62:51 - and then basically, that
has the effect of y,
62:55 - and then x, x, x, x,
x, y, x, x, x, x, x.
62:59 - Just insert a blank table.
63:00 - Fill it with-- we're
just using tables here.
63:05 - So we're not using any
sort of tile class,
63:07 - or board class, or anything fancy.
63:10 - We're just using raw data types here.
63:11 - So we're just saying
insert into tiles y, which
63:16 - by the way, if we're
at x equals 1, 8, here,
63:22 - and we're in any given
iteration of our outer y loop,
63:27 - tiles y will be the last
table that we just inserted--
63:30 - the last blank table on the
first iteration of this x loop.
63:35 - So basically, it's saying, in
the inner table that I just
63:39 - put into the table that's going to
represent our board, the tiles table,
63:47 - insert a new table.
63:51 - So we have a table of tables of tables.
63:55 - In the third table are the
actual tiles themselves.
63:59 - You can think of this table as being
a tile data type, more or less.
64:02 - Just implemented using a table.
64:04 - That has an x-coordinate, a
y-coordinate, and then a tile,
64:07 - and the tile is going to
be a random number that's
64:11 - going to be the index into our quads.
64:13 - So each tile holds x
and y, and then notice
64:17 - that we're multiplying
by 32 because we're
64:18 - going to use this to draw the tile, and
the tiles are 32 pixels tall by high--
64:23 - sorry, wide by tall.
64:26 - We are going to multiply
x minus 1, recall,
64:29 - because even though tables are one
indexed, coordinates are zero indexed.
64:35 - So x gets that times 32,
y gets that times 32,
64:39 - and then get a random number
between 1, and the number of quads
64:44 - in our tile quads table.
64:46 - So recall this number sign here is just
a shorthand for length of the table,
64:51 - and then we're going to return it.
64:52 - So we generated our board.
64:54 - It's a y by x grid of
table rows of little tables
65:01 - that all have an x, y, and a tile
ID, and the tile ID maps to the quads
65:05 - that we just generated.
65:09 - OK, that's it for the init function.
65:11 - Sorry, love.load in this example.
65:14 - The love.draw uses a function called
drawBoard, and we pass in 128 by 16.
65:20 - The 128 by 16 is just xy offsets.
65:23 - We're just going to draw
our board at 128, 16,
65:25 - and is it going to center our board.
65:28 - And then if we go down
to drawBoard at line 89,
65:31 - gets an offsetX, offsetY,
nested for loop again.
65:34 - We're just iterating back
over the tiles that we got,
65:37 - and recall, actually,
generateBoard returns tiles,
65:40 - and then we set board equal to
the result of generateBoard.
65:45 - So down here in line 89, again, in
drawBoard-- actually at line 95.
65:50 - Within this nested for loop, we're
going to get a tile at board y, x,
65:56 - just so we have a
shorthand reference for it.
65:58 - We don't have to say board y, x several
times, which you would have to hear.
66:01 - We're going to draw the sprite--
66:04 - the quad at tile, tile,
tile.tile, which, recall,
66:07 - is a random number
between one and whatever
66:09 - the number of quads we have
in our tile quads table.
66:13 - And then that x plus offsetX,
and the y plus the offsetY, which
66:16 - has the effect of drawing every single
tile in our grid at some given offset.
66:22 - And that has the result--
66:23 - and I probably should have
run this, actually, in advance
66:26 - just so I could illustrate it.
66:31 - But we have a simple board.
66:34 - Looks nice.
66:35 - It's colorful, but
it's very, very basic.
66:37 - Just a 2D render of our game.
66:39 - There's no behavior or anything.
66:41 - This is just how we draw the board.
66:43 - So any questions as to how just the
drawing, and the creation of the board
66:46 - work?
66:50 - OK.
66:51 - So swap1 is a little
bit more complicated.
66:56 - It builds on what we
did before, what we just
66:58 - built, which was getting the board
implemented, and drawn onto the screen.
67:02 - But there's no behavior at all.
67:03 - It's just a static--
basically, the same thing
67:05 - as drawing an image onto the screen.
67:07 - And so for that, what we want
to do is implement swapping.
67:13 - So how do we think we
can accomplish this?
67:17 - Anybody have any ideas
as to how we can swap?
67:23 - AUDIENCE: [INAUDIBLE] using tweening
to have it go in opposite directions.
67:27 - SPEAKER 1: Well, we could.
67:30 - That will have the effect of--
67:32 - the response was we could use tweeting.
67:34 - We could, and we
actually will for swap2,
67:38 - but it's going to be a little
bit more complicated than that
67:41 - because they're in a 2D array.
67:44 - So if we just tween their x, y--
67:45 - AUDIENCE: [INAUDIBLE]
67:50 - SPEAKER 1: They will be in
the same place in the array.
67:53 - But yes, ultimate--
67:54 - AUDIENCE: You could switch
the position in the array,
67:56 - and then reload the array.
67:57 - SPEAKER 1: Switch their position in
the array, and then reload the array.
68:00 - We will switch the position.
68:01 - We don't have to reload the array,
but we will switch their positions.
68:04 - That's effectively, what it is.
68:05 - Literally just take two
tiles, and swap in CS50,
68:09 - where we just take two variables,
and get a temp variable that
68:13 - points that one
variable, gets its values
68:16 - while the second variable gets the
values of that one, or vise versa,
68:22 - I think.
68:23 - This one gets this one's values,
this one gets this one's values,
68:27 - and then this one comes
down to this one, basically.
68:29 - There's the middleman that keep--
because if this one gets this one's
68:32 - values, it's going to get
overridden by this one's value.
68:35 - So there would be no reference
to it's x, y, or anything.
68:38 - So that's why you need to store this
one up here, so this one can come here,
68:42 - and this and come back down here.
68:43 - So we've done a swap, effectively.
68:45 - And there's ways in Lua to
do swaps, as we saw before,
68:47 - without even needing
a temporary variable.
68:49 - You can just do xy get some other
xy, which sort of bypasses that.
68:54 - But when you start to do four
things getting swapped at once,
68:57 - and you have four commas, it can get a
little tricky, a little bit unwieldy.
69:01 - I'm actually not 100% sure you can
unpack more than two things in Lua.
69:04 - I'll have to double check on
that, but right off the gate,
69:09 - we're seeing that double
assignment here on line 32,
69:11 - highlighted x, highlighted y gets 1, 1.
69:15 - And let me actually
run just so we can see.
69:17 - There's actually a couple of
pieces here besides just that.
69:24 - Swap1.
69:25 - So we have the board
as before, we also have
69:29 - something to show us where
to swipe because we have
69:32 - to know where we're swapping the tiles.
69:34 - In an ideal implementation, which is
an optional part of the assignment,
69:39 - you would have mouse
behavior for your game.
69:40 - So you could just click on two tiles,
or click, and drag, and swap them.
69:43 - In this case, we're not doing that.
69:45 - We're just implementing
key based behavior.
69:47 - So when I press left, right,
up, or down, I can move.
69:50 - If I press Enter on a tile, and then
move around, it's an indicator to me
69:55 - that I've selected that tile
to swap with something else
69:58 - because it needs to keep track of
OK, you want to swap this tile.
70:01 - What do you want to swap it with?
70:02 - I want to swap it with this tile.
70:04 - So they get swapped.
70:06 - I want to swap it with this tile.
70:08 - So they get swapped.
70:10 - Or this tile.
70:11 - So you can swap it with
whatever tile you want to.
70:13 - There's no constraints.
70:16 - The actual distro code implements
a constraint, and so offhand,
70:21 - what do you think a constraint would
be for making sure that we can't--
70:24 - AUDIENCE: They have to be adjacent.
70:25 - SPEAKER 1: Yeah, they
have to be adjacent.
70:27 - So what would that entail?
70:31 - AUDIENCE: That their x [INAUDIBLE]
70:34 - SPEAKER 1: Exactly.
70:35 - And the shorthand for that, really,
is if the absolute value of their x's
70:41 - minus their y's is equal to 1.
70:48 - Because if you subtract
one's x from another one's x,
70:52 - and then one's y from
another one's y, and then
70:54 - you add the differences
together, that'll
70:56 - tell you whether they're
directly adjacent to each other.
70:58 - It has to equal one.
70:59 - If equals zero, then their
x's and y's are the same.
71:02 - If equals two, then it's two
tiles away on the x-axis,
71:07 - or it's away on the x and the y, in
which case it would be diagonal to it.
71:13 - So the only way is it's
x's minus it's x's.
71:16 - Tile1.x minus tile2.x,
and tile1.y minus tile2.y,
71:21 - if they're absolute value
of their difference is one,
71:24 - then they're adjacent.
71:26 - That's in the implementation.
71:33 - So this is why we have these
variables here, highlighted tile.
71:36 - Basically we're setting a flag
saying, do we have a highlighted tile?
71:39 - If we do, we're going to perform some
drawing logic later down in the draw
71:45 - function.
71:46 - Basically, how would we draw a
highlighted tile, do you think?
71:52 - AUDIENCE: Add a rectangle
with transparency.
71:55 - SPEAKER 1: Exactly.
71:56 - So the answer was add a
rectangle with transparency.
71:58 - That's exactly what we do.
71:59 - I'm going to go down to this part here.
72:07 - So on line 173, if we
have a highlighted tile,
72:10 - and basically, this is
in the middle of a loop--
72:12 - our y, x before.
72:14 - We've put it into a draw board.
72:16 - We have the drawBoard
function, but x, y, or y, x,
72:19 - the tile is going to be whatever
tile we're currently on,
72:22 - and if we do have a highlighted
tile, and that tile's gridX--
72:27 - notice we now have a new variable called
gridX, as opposed to it's regular x
72:31 - so that we can check for these sorts of
things to see where it is in the array.
72:34 - If it's gridX is equal to whatever
we've set highlightedX to,
72:39 - and gridY is equal to highlightedY,
then love.graphics.setColor
72:45 - half transparency, and then just
draw a rectangle with this 4
72:50 - at the end of it, which actually
draws a rounded rectangle.
72:53 - If you pass in no 4, it will
just draw straight rectangle,
72:56 - but if you pass in an int at
the very end, that's how many
72:58 - rounded segments basically
that rectangle will have.
73:01 - So you can get rounded
corners on your rectangles,
73:03 - and it's good for UI
drawing, and stuff like that.
73:07 - We use it a little bit in the distro.
73:10 - So that's how you get
a highlighted tile.
73:13 - There was also a selected
tile, and a selected tile
73:15 - is just draw a rectangle, same
thing, but it's a line this time,
73:19 - and there's always going to be
a selected tile no matter what.
73:22 - So we're always going to draw it here
at the end of our render function.
73:25 - It's just 255--
73:26 - 234 for the opacity so that it's just
kind of transparent, but not super
73:30 - transparent.
73:31 - Set line width to 4 so that it's
not just a very thin rectangle.
73:37 - If you set the line width, and then you
draw a rectangle with the line format--
73:44 - the line mode of drawing, it will
use whatever the current line
73:48 - width is when drawing the rectangle.
73:50 - So we set it to 4, then draw
a line rect at selectedTile.x
73:54 - plus offsetX selectedTile.y
offsetY, and we draw it 32 by 32
73:59 - because that's the size
of a tile, and then
74:00 - we set our color-- remember to always
set your color back to 255, 255, 255,
74:05 - 255 because if you don't, and I did
this when I was debugging, actually,
74:09 - you get some fun stuff.
74:16 - Wait, was that the right one?
74:23 - Oh, I might have fixed
it up above where we--
74:27 - there was an issue.
74:28 - If you don't set, basically, your
color, and you set it to red,
74:34 - everything will draw red
after you've done something.
74:36 - So if it ever happens, remember to set
your color back to 255, 255, 255, 255,
74:42 - anytime you change the color in
some way, like I'm doing here.
74:46 - AUDIENCE: Alternatively,
you could also just
74:48 - make sure to always set the color before
you draw something. is that right?
74:50 - SPEAKER 1: Yes.
74:51 - The response was make
sure you always set
74:53 - the color before you draw something.
74:55 - I think that's what I ended
up doing in this distro, which
74:57 - is why it's not working anymore.
74:58 - I think it was--
74:59 - where was it?
75:01 - It was here, but I must have
fixed it because I accidentally
75:05 - left that out when I was debugging,
and it ended up drawing-- everything
75:08 - was red.
75:08 - So just as an aside just because
Love2D is a state machine.
75:12 - Drawing it beforehand is
definitely the safer way to go too.
75:19 - So the core of this, because we're
running a little low on time--
75:22 - the core of this overall block
of code is just the swap here.
75:28 - So if there is no highlighted
tile-- so basically,
75:30 - if we pressed Enter or Return--
75:32 - now, we have all input handling
in love.keypressed key.
75:36 - And by the way, this is
input handling to change
75:38 - the x and y of our selected tile.
75:43 - If we press Enter, and we
don't have a highlighted tile,
75:46 - then we need to have a highlighted
tile, otherwise we should swap them.
75:49 - So we get a reference to tile one and
two, we swap, we create temp variables.
75:53 - Recall, we need to have
that middle man up here that
75:55 - keeps track of this tile's information.
75:57 - So it's going to keep track
of all of tile2's information
76:00 - with tempX, tempY, tempgridX,
and tempgridY because we
76:03 - need to not only change
their x-coordinates,
76:05 - but also their grid positions.
76:08 - And then we need to
create a temp tile here.
76:16 - Basically, here's where we actually
swap their places in the board.
76:19 - So tile1.gridY, tile1.gridX gets tile2,
and then we're getting a reference
76:24 - to temp tile so that we can--
76:27 - because if we set board at
wherever tile1 is to tile2,
76:35 - we won't have anything where tile2 is.
76:37 - We need to have a temp
tile to keep track of--
76:40 - sorry, we won't have anything at
tile1 if we overwrite it with tile2.
76:46 - So we need a reference to tile1
here, so that we can put it
76:49 - into where tile2's spot is, right here.
76:52 - And then we need to do all that before
we end up swapping their coordinates
76:58 - and tile grid positions, otherwise
you get weird buggy behavior
77:01 - when you're moving the
selected tile around.
77:03 - And then we can on the highlight,
and then reset our selection
77:06 - because their selection is also going
to get changed after we do the swap.
77:10 - So we need to put it to the second tile
because it gets swapped with whatever
77:15 - tile we highlighted.
77:18 - And that's the overall gist.
77:19 - It's basically taking two
tiles, flipping the information,
77:22 - storing a middleman.
77:23 - Same thing in swap in CS50,
a little more complicated,
77:26 - though because these all have subfields
that all need to get manipulated.
77:30 - And a lot of this can actually
be done mathematically.
77:32 - You can actually have its x
and y mathematically derived
77:37 - from it's gridX and gridY.
77:38 - Just multiply by 32.
77:40 - In this case, I just kept them
as variables, and separate.
77:43 - But yeah, you could just
do that too, and that
77:47 - has the effect of swapping the
variables whenever we move them,
77:51 - and then that's the fundamental
first step in Match 3,
77:56 - is just swapping any two
tiles in a given position.
77:58 - So does that make sense altogether?
78:01 - OK.
78:03 - So this example is actually not that
much different at all from swap2.
78:11 - I'm going to show you swap 2 right now.
78:13 - So if we go to swap2, the only
change we really have made
78:19 - is that now tiles flipped instead
of instantly changing, they tween.
78:26 - And this is a piece
of cake at this point.
78:27 - We already know-- what's
the function we need to do?
78:31 - Just timer.tween.
78:32 - All we need to do is just
take the two, and then just
78:34 - tween tile1.x and tile1.y
to tile2.x, and tile2.y,
78:40 - and do the same thing in reverse.
78:41 - Tween tile2.x, and tile2.y
to tile1.x, and tile1.y.
78:46 - And so if we open up swap2, go
to main, nothing in this program
78:52 - really changes, except in
update, where we go to line 99,
78:58 - and we're just doing it here.
78:59 - Notice the definition.
79:00 - Over 0.2 seconds, it takes in
the definition table, here,
79:03 - and it's taking in two entities
because we're modifying two things.
79:06 - We're modifying tile2, and tile1.
79:08 - We're just setting x to
tile1.x, and y to tile1.y,
79:13 - and then tile1 is getting
the tempX and tempY
79:15 - because before, it was just
getting it directly from the temp,
79:18 - and now it's just tweening it over time.
79:22 - But that was before just a
bunch of tile2.x equals tile1.x,
79:26 - tile2.y equals tile2.y,
tile1.y equals tile2.y.
79:33 - That's all it is.
79:34 - That's what's really nice about it.
79:35 - Now we don't have to
really work hard at all
79:38 - to get nice, smooth
transitions in whatever we do,
79:41 - whether it's a UI, or the game.
79:43 - It's just super nice, and convenient.
79:47 - So that's all we need to do
to get basic swapping done.
79:49 - That was swap2, the tween swap.
79:51 - And so I put together a
set of slides here just
79:54 - to illustrate the algorithm that
we use to calculate the matches.
79:58 - So right now we've got
swapping in, but we
80:02 - don't know when we've gotten a match.
80:03 - So just offhand, does anybody
have any idea as to maybe
80:06 - how we can go about calculating
whether we've got any matches?
80:15 - AUDIENCE: Well, we already figured out
how to track if a thing is adjacent.
80:18 - So you, I guess, have
a table of adjacent--
80:21 - you go through [INAUDIBLE] block,
and if you have an adjacent--
80:24 - or for every adjacent block, you
check if that color equals your color.
80:29 - And if it does, you check if--
80:31 - well, then I guess you need to
figure out what direction it's in,
80:34 - and then you check,
continuing in that direction,
80:37 - if there's another of the same color.
80:40 - SPEAKER 1: So their
response was when you're
80:42 - looking at tiles, look
at all adjacent tiles,
80:46 - and if there is a color that's the same
one, then figure out its direction,
80:52 - and then move from there.
80:55 - So like a recursive style.
80:56 - I guess you could
implement it recursively.
80:59 - It probably would be a little bit
trickier to understand, and probably
81:02 - not as efficient.
81:05 - The way that we are actually
going to implement it
81:07 - is going to be a little
bit more iterative.
81:13 - So all we really need to do is check
every row, and every column one time,
81:19 - and then go basically, left to right.
81:21 - So in this case, we have to
check every row and column one
81:25 - time in this direction, and
then one time in this direction
81:27 - because we can get vertical
and horizontal matches.
81:33 - So we start off.
81:35 - Let's just arbitrarily decide we want to
start going left to right down the data
81:40 - structure.
81:41 - So we'll go, what color is this?
81:43 - That's brown.
81:44 - OK, check the next one.
81:46 - Is it the same color?
81:47 - If it is, then say OK, the number of
matching tiles that we've found so far
81:52 - is two.
81:54 - If it's greater than
three, then later on we'll
81:57 - need to add that group as a match
to our list of matches, basically.
82:03 - But if it's not, OK, then the
number matches is one again.
82:07 - So set it to one, and
then do the same thing.
82:09 - Same color?
82:10 - No.
82:10 - OK, number of matches is one.
82:12 - In this case, here we have the
number of matches is going to be two
82:16 - because this is blue, and
then we're going to go ahead,
82:19 - and then same color again.
82:20 - The number matches is three, and then
we've gotten to the end of the row.
82:25 - So we can say OK, what was
our last number of matches?
82:28 - Was it greater than or equal to three?
82:31 - If it was, add that group
of tiles to our table of
82:34 - matches if we've gotten a
match, and then move on.
82:37 - And we do that over, and over again,
and if it's in the middle of a group,
82:40 - like it is here-- so this
isn't at the end of the row.
82:43 - This is just in the middle of the row.
82:44 - What we do is number of matches one,
two, three, and then we go here,
82:49 - and it's set to one.
82:50 - Well, first of all, we
check number of matches
82:52 - when we get to a different color.
82:53 - We say, OK, this isn't the
same color as this tile.
82:56 - This is purple, and this is gray,
but number of matches is three.
83:00 - So what we do is we just add
these three tiles to our--
83:06 - we're keeping a table of matches
because we're going to go through,
83:09 - and we're going to delete all of them.
83:11 - And then, eventually, we're going
to do some tweening as well,
83:15 - but we're going to delete all of these.
83:17 - And then in order to do that,
we need to walk backwards.
83:20 - We need to say, basically,
for x gets position
83:24 - minus number of tiles in the
match, just add that to a match,
83:28 - add that to a match,
add that to a match,
83:30 - and then add the match
to our table of matches.
83:32 - And that's it for the x direction.
83:34 - And for the y direction,
it's the exact same thing.
83:36 - Going down here-- different color,
different color, different color,
83:39 - different color, and then same
color, same color, different color,
83:42 - but number of matches is three
because one, two, three, and then
83:46 - it's going to walk backwards,
up to the top, add that match,
83:50 - and then just continue down here.
83:51 - Same thing, same thing,
and then same thing there.
83:54 - This is at the end of the column.
83:56 - So it's going to get to the end.
83:57 - It's not actually going
to look for the next tile
84:00 - because there are no more
tiles, but every time
84:03 - we complete a row, or a column,
we check at the very end,
84:07 - do we have the number of matches
equal to three or greater?
84:09 - If we do, then we need
to do the same logic
84:11 - as we did before by adding that
match to our list of matches.
84:14 - So it's actually quite a simple
algorithm, and this is the set of steps
84:19 - that I just illustrated.
84:21 - We have a match found there.
84:23 - Oh, sorry. [? Tony, ?] yes?
84:24 - AUDIENCE: If you complete two
matches at once, would it see both?
84:30 - SPEAKER 1: It would.
84:31 - The question was if you complete two
matches at once, would it see both?
84:34 - Yes.
84:35 - If you complete-- and it
wouldn't if you deleted
84:39 - them as you went because let's say
you had like one, two, three here.
84:43 - I'm assuming that's what you mean,
one, two, three, one, two, three.
84:46 - If you just deleted them as you
went, then no, it wouldn't see them.
84:52 - It would go here, it would
get these three, delete them,
84:55 - and then it would just see these two.
84:57 - But because we walk
over the entire thing,
84:59 - and then we only delete matches after
all of the matches have processed,
85:03 - we're going to add this one first,
and then when we do our vertical one,
85:06 - we're also going to see this one, and
so it's going to count as two matches.
85:09 - And you could make your code a little
bit more complicated if you wanted to,
85:12 - and say if there's an
intersection between two matches,
85:14 - I want to give the player more points.
85:16 - Or I want to give him some sort
of effect like in Candy Crush,
85:20 - I think you get like
explosions, or Bejeweled,
85:22 - you get explosions if
you get like a T pattern.
85:25 - And if you get four in a row, you get
a laser or something across the screen.
85:29 - And actually, part of
assignment is clear a row.
85:32 - If you get four in a row, you
should clear that row, or call them.
85:37 - If you do that, then
yeah, you can have logic.
85:40 - But currently, all the distro does
is just this simple iteration--
85:44 - horizontally, then vertically,
and adding matches as you go.
85:46 - And actually, there is an
optimization that you can make.
85:49 - If you go here, for example,
let's say we're going here, here,
85:54 - and then we're here, and we're at a
different color than the last one.
85:59 - We can just go to the next one.
86:01 - We can just skip because we
know we only have two left.
86:05 - There's no point in looking for a
match if you're at the n minus 2
86:10 - because there's no possible
way to get a match.
86:12 - So that's just a shortcut.
86:13 - A little optimization you can make,
and that's actually in the code.
86:15 - Just break off if you're at--
86:17 - in the code, it's x or y equals 7.
86:21 - Just break out of that
for loop basically,
86:23 - and go to the next row, or column.
86:32 - Any more questions as to how that works?
86:38 - If you're actually looking in
the code, we won't go over it
86:41 - in too much detail in class.
86:44 - It's fairly straightforward,
I think, once I walk you
86:46 - through the algorithm a little bit, but
I'll point you to the relevant lines.
86:52 - It's in the play state.
86:53 - No, sorry.
86:53 - It's in the board in the
calculate matches function.
86:59 - Here, on line 50, calculate matches.
87:04 - So horizontal matches, y gets 1 to 8.
87:08 - You keep a color to match,
and basically, you just
87:10 - keep track of how many you've matched.
87:11 - Match numbers one always when
you're doing a brand new color,
87:16 - and then starting at x 2
to 8, because we already
87:18 - got the first tile, basically, if the
color is the same, increment matchNum.
87:24 - Otherwise, set our current color
to that color, the next tile.
87:29 - If we've done this, and our match
is greater than or equal to 3,
87:36 - then we found a match.
87:37 - We can add a match.
87:37 - We create a new table.
87:39 - We go backwards from where we
are with x 2 gets x minus 1,
87:43 - and then x minus matchNum.
87:44 - So it works for no matter
how long the match is,
87:46 - whether it's three, four, or five.
87:49 - And then we're subtracting
1, and then you just
87:51 - insert into that match, the
tile at that x 2 position
87:56 - because the matches are made of tiles.
87:58 - So a match is just a group
of tiles put together,
88:01 - and so you can intersect to any given
match just by comparing the tiles,
88:04 - and just seeing if they have
the same tiles, basically.
88:06 - That's how you'd get a cross match.
88:09 - And then after that's all done,
just insert into matches that match.
88:14 - Here's a little optimization.
88:15 - If x is greater than or equal to
7, and this is in part of the loop
88:19 - where we already know that we're
on a new color from the last color,
88:23 - we'll just break, and then set matchNum
to 1 if we haven't gotten to that point
88:27 - yet.
88:28 - And then this is the part of the
code that accounts for a last row--
88:33 - the row ending with a match because
we're not going to be on the next loop
88:37 - to see whether we're going
to a different color.
88:39 - We just need to check to make sure
at the end of any row iteration,
88:45 - or column iteration when we
go to the next row, or column.
88:47 - Before we go to the next
row or column, that matchNum
88:51 - is greater than or
equal to 3, and if so,
88:53 - then do the same logic
here, but start x at 8.
88:57 - And same thing for vertical matches.
88:58 - Exact same logic, just
x and y are inverted.
89:02 - And then that's it.
89:03 - And then self.matches, we keep a
reference to self.matches in the board
89:08 - so that later we can
remove them here, and I
89:12 - believe we use it for something else.
89:15 - And then we return, basically, if the
number of matches is greater than 0,
89:21 - we're going to return matches, else
we're just going to return false.
89:24 - And we can use this later.
89:26 - We can say if matches
from our play state,
89:29 - then we can call a few
other functions, and bring
89:32 - in new tiles, and stuff like that.
89:34 - But just for the sake of being
thorough as an illustration,
89:39 - this is how the algorithm works.
89:41 - In this case, actually, this was
before I made the optimization.
89:44 - We wouldn't actually do this
in this particular case.
89:47 - This would have shorted down to the
next column before it even checked this,
89:52 - but if your algorithm didn't make
that optimization, then yeah,
89:55 - I would just see two tiles there.
89:56 - Go to the next one,
nothing there, no matches.
90:00 - Same thing here.
90:02 - There is a match there,
and the match would
90:04 - be found not at the end
of the diagram here,
90:09 - it would be calculated
when it's pointed here,
90:11 - but it knows matchNum is greater
than or equal to 3 at that point.
90:17 - And it does the exact same thing here.
90:19 - We just go column wise,
and then nothing there,
90:22 - nothing there, and then
we've got one right there.
90:25 - And so the next part--
90:27 - oh, any questions on
how that works at all?
90:34 - The next part-- we have the matches now.
90:36 - We have them in tables.
90:37 - We have the tiles.
90:38 - We have references to the tiles.
90:39 - How do we remove the
tiles once we have--
90:42 - how do we get rid of them as
soon as we have the matches?
90:52 - Assuming that our board is a table, a 2D
table, and each array within there just
90:59 - has a tile object, how would we
clear the board of our tiles?
91:04 - AUDIENCE: Are you including what
you're shifting [INAUDIBLE]??
91:08 - SPEAKER 1: No, just remove
it from-- just like like.
91:11 - Just remove it from play.
91:12 - AUDIENCE: Oh.
91:15 - I guess you can [INAUDIBLE]
91:21 - SPEAKER 1: Yeah, you could.
91:22 - Yeah, with a little bit of
finagling, you could get it
91:24 - to where you could set
a tile to be invisible,
91:27 - and then you could just give
it a new tile ID, I guess,
91:31 - and then shift it up above,
and then make it come.
91:36 - Well, I don't know if
that approach necessarily
91:40 - works super well for
this because of gravity
91:42 - because the tiles have to come down.
91:44 - So then you'd have to bring the lower
ones, if they were at the bottom here.
91:48 - Those would have to come down.
91:52 - That kind of approach
would be a little tricky.
91:54 - You could make it work, I think.
91:58 - The simple approach, which
we used in this distro,
92:01 - is actually just setting them to nil
because if you set something to nil,
92:05 - it's just not going to
render, in this case.
92:07 - So we're just setting all of these
tiles that were previously there to nil.
92:10 - They're nothing at this point.
92:12 - They effectively would render like
this if you tried to render them,
92:16 - assuming that your code accounted
for it, or it didn't break.
92:20 - And then the next stage would be
the actual getting the board fixed
92:27 - because we have the tiles removed.
92:30 - So now, we have this
thing here, but there
92:34 - is a step that has to happen before
we get new tiles, and that's gravity.
92:37 - We have to actually
shift everything down.
92:40 - So how do we go about
shifting tiles down?
92:44 - So this first column, we don't
really have to do anything, right?
92:46 - This column is all set,
but what about this column?
92:49 - How would we shift?
92:49 - How would we get that tile to go down?
92:52 - AUDIENCE: [INAUDIBLE]
92:54 - SPEAKER 1: Sorry?
92:55 - AUDIENCE: Tweens again?
92:56 - SPEAKER 1: Tweens.
92:57 - Yes, we could do it with tweens,
but from a data structure
93:00 - standpoint, how would we--
93:02 - because that will just tween the
xy, but that won't necessarily
93:05 - fix-- the underlying
data structure still
93:06 - has to represent-- because we're
going to do iterations over it,
93:09 - we have to have references to
the tiles in the right spots.
93:12 - AUDIENCE: So just
shifting it was the table
93:15 - from the fourth row to the fifth row.
93:17 - SPEAKER 1: So how would you
start by getting this tile down
93:20 - to this position?
93:23 - AUDIENCE: Switching it from the
fourth row to the fifth row.
93:26 - SPEAKER 1: You would.
93:27 - How would your algorithm work step by
step to making sure that would happen?
93:36 - AUDIENCE: Is it start from the bottom,
and if that's nil, it would go up more
93:41 - SPEAKER 1: Exactly.
93:41 - That's exactly you do.
93:43 - You start from the bottom, and then
whenever we have anything that's nil,
93:49 - we need to look for the first tile above
it that's not nil, and shift it down.
93:53 - So in this case, we start from
the bottom, and we go up this way.
93:57 - Not nil, not nil, not
nil, not nil, not nil.
94:00 - So none of those are spaces in the code.
94:02 - It's called spaceY, or space and spaceY.
94:07 - So we go to the next
column over, and we only
94:09 - have to check vertically in this case.
94:11 - We don't have to do a
horizontal check for anything
94:13 - because gravity can only
follow in one direction.
94:15 - So we just go over here.
94:17 - So we're only looping through this code,
effectively, in this case, five times,
94:21 - but in our code, eight times.
94:24 - But it needs to be a while
loop rather than a for loop,
94:28 - and we'll see why in a second.
94:29 - But start here.
94:31 - We see oh, we have a space there.
94:33 - So what we need to do is say,
OK, the lowest space is here.
94:39 - So we need to look for the next
tile above it, and shift it down.
94:42 - So we keep a reference to
this, and we look up here,
94:44 - and we say oh, this is a tile.
94:46 - Perfect.
94:47 - So I'm just going to
take this tile, and I'm
94:49 - going to set that space
index to that tile,
94:52 - and then I'm going to
set this index to nil.
94:55 - And then we just have to
start again, though, from here
94:58 - because this tile is now space.
95:01 - So we have to look up here, and
say OK, so basically, our y counter
95:06 - stays at that thing, and then just goes
back up because our y counter could,
95:10 - theoretically, come all the way
up here before it finds a tile,
95:13 - and then shift it all the way down,
but we can't just-- or here, let's
95:17 - say there are two tiles right here.
95:19 - Our y counter might end up here
because these are all spaces,
95:22 - and the tile gets shifted
down here, but we can't just
95:25 - start our y counter back here
again, and go up to the next tile,
95:28 - and look for spaces because we
have all these spaces down here.
95:31 - So it's a while loop.
95:32 - So while, basically, there are
no spaces on any of these points,
95:36 - we need to make sure that
we keep lowering the tile.
95:39 - So keep a reference here, tile
here, bring it down, space here.
95:43 - So we keep a reference with space.
95:44 - We say oh, there's a space here now.
95:46 - We can look all the way up,
but there's no tiles anywhere.
95:48 - So we know that we can just move
onto the next iteration of the loop.
95:51 - We haven't found any tiles.
95:52 - We don't need to bother with it.
95:54 - Same thing here.
95:55 - We have a space reference
here, tile, found a tile,
95:59 - shift it down, space here, tile here,
shift it down, space here, tile here,
96:04 - shift it down, space, space, done,
and then we rinse, and repeat that.
96:09 - It's kind of almost like a
bubble sort type of algorithm.
96:13 - Not a sort, but it has the same sort of
look and behavior to it, more or less.
96:18 - Here's just a visual illustration of it.
96:20 - So start from the bottom, go up,
we're looking for spaces here.
96:24 - No spaces; column is perfectly stable.
96:26 - We found a space here, tile
is there, shift it down.
96:30 - Restart the loop from the tile,
space, space, space, no more spaces;
96:35 - column stable.
96:36 - Space found, tile found, shift, space
found, tile found, shift, space found,
96:42 - tile found, shift, and
so on, and so forth.
96:46 - And so that's the gist.
96:47 - Super, super basic.
96:50 - But now we actually have
to replace the tiles.
96:54 - AUDIENCE: You don't even need to check.
96:56 - Once you shift a block
down, you don't even
96:58 - need to check the space above
it, whether it's a space
97:00 - or not because you know that's
automatically a space when you just
97:02 - shifted a block, right?
97:05 - SPEAKER 1: Yeah.
97:05 - Actually, that's true.
97:06 - Yeah, I guess in that
case, you wouldn't need to.
97:10 - But we do need a reference to that
space, and keep checking above it.
97:16 - But yeah, I guess you probably
don't need, necessarily,
97:19 - to check whether it's a space or not.
97:21 - You can just assume it's a space, and
I actually think my code does that.
97:25 - I'm not 100% sure off
the top of my head.
97:28 - We can check, and see.
97:35 - I think it's down here.
97:37 - No?
97:38 - Is it?
97:42 - Oh no, it's in get falling tiles,
I think, which is on line 177.
97:48 - So for 1 to 8 in x, we keep a spaceY.
97:54 - So spaceY, we set it zero
because that's just a variable.
97:57 - We don't have a space yet.
97:58 - So just because you can't index a tile--
98:01 - you can index Lua tables by zero,
but because they're not by default,
98:04 - we're just setting the zero
as like our false space flag.
98:09 - y gets 8, starting at the bottom.
98:12 - So while y is greater than or equal
to 1, tile gets self.tiles y of x.
98:17 - In that case, it's going to
be at the eighth position.
98:21 - So space is set to false,
but space is our space
98:23 - found flag, and also whether or
not the tile that we just looked at
98:27 - was a space.
98:29 - Sorry, no, it's just our space flag.
98:32 - We check to see if there is a
tile at our current position.
98:35 - So recall, everything gets set to nil.
98:37 - So we can just say local
tile gets self.tiles y x.
98:41 - This will be nil if
there was no tile there.
98:42 - So if tile, which means if it's not
nil, if it equal something, spaceY of x
98:49 - is going to equal that tile.
98:52 - We keep a reference to spaceY,
which is our last space.
98:56 - We set tile.gridY to spaceY because
we have to reset it to gridY.
99:03 - We're going to tween it here.
99:04 - This is how we actually get
the falling, tweening behavior.
99:07 - We're going to tween it's y to
tile.gridY minus 1 times 32,
99:12 - recall, because coordinates are zero
based, but Lua tables are one indexed.
99:19 - Space is false, y is spaceY,
and then spaceY gets zero.
99:28 - Basically, we're going to start at the--
99:32 - we're going to put spaceY
to that tile, and then we're
99:37 - going to set spaceY to 0.
99:41 - I think it actually does, in this
case, it is actually checking that tile
99:46 - to make sure that it's--
99:49 - yeah, because it's just
getting set to the tile--
99:52 - spaceY being the tile that we
just replaced, and just put
99:54 - into an actual spot.
99:55 - So it does actually make the check up
above to see whether that's a space
99:58 - or not.
100:00 - Only one caveat though actually is--
100:04 - actually, no, that wouldn't be true.
100:05 - I was going to say, if you're
at the top of the screen,
100:07 - but no because there's no way we
can be at the top of the screen,
100:12 - and have-- yeah, I don't
think it would work.
100:17 - A small optimization you could make
is you just assume always a space.
100:20 - Yeah.
100:24 - That's the get falling
tiles in a nut shell,
100:26 - or at least the ones that
are falling from gravity.
100:30 - And then we also have tiles that
we want to add to replace them,
100:35 - and so we'll see that here.
100:38 - So this code.
100:39 - So what we need to do to replace--
100:44 - what do you guys think we need
to do to get replacement tiles?
100:52 - AUDIENCE: Check response, and
check if it's empty, [INAUDIBLE]
100:56 - but if it's not, then you're done.
100:58 - SPEAKER 1: Yeah, exactly.
100:59 - So the response was
check to see from the top
101:03 - if there are any tiles that
are empty, and if there are,
101:06 - then spawn some tiles, and then ideally,
tween them to their new positions.
101:11 - You can basically just assign
them to their values here.
101:15 - So what we need to do,
actually, though, is
101:17 - if we spawn a tile up here to put into
any of these positions, their gridY's
101:21 - need to be set in
advance because they're
101:23 - going to occupy that space anyway.
101:25 - Their actual y position
needs to be tweened.
101:31 - So because the x and the y are
separate from the gridY, and the gridX,
101:35 - those are just table indices,
but not their coordinates.
101:38 - We can tween those,
and it won't actually
101:40 - have any effect on the data structure.
101:41 - The data structure itself can maintain--
we can still use the data structure--
101:46 - put a tile in its right
spot in our table,
101:48 - and then give it the right gridX, and
gridY, but tween the x and y value.
101:53 - We can do whatever we want with those.
101:55 - We can make them spin
around, and stuff as long
101:58 - as the data structure
is intact, and ideally,
102:01 - as long as we can't input
while it's doing it's movement,
102:04 - and stuff like that because that
could create some visual bugs.
102:06 - And so what we do is we actually disable
input when a swap is taking place,
102:10 - and you'll see that in
the distribution code.
102:14 - But yes, count how
many spaces there are.
102:16 - Spawn four tiles, spawn
two tiles, spawn two tiles
102:19 - spawn four tiles that have already
been given their right gridX, gridY,
102:24 - and then just tween their y
to wherever it needs to go.
102:27 - It's gridY times 32--
102:30 - gridY minus 1 times 32.
102:33 - And so that's what we're doing here.
102:34 - We're just count, and then boop.
102:39 - That was my favorite part of
putting this show together.
102:43 - And so we're going to get into a couple
of minutes of talking about sprites,
102:46 - and palettes, but I
think the one thing--
102:50 - blanking for a second.
102:51 - I was going to talk
about one last thing.
102:53 - Let me see if I can
figure out what that was.
102:57 - Oh, right, so in the board--
103:02 - sorry, in the play state, I believe,
is where this is, there is a function.
103:12 - So play state has it's own
calculateMatches, basically,
103:15 - where it waits for you to--
103:17 - where once you've basically
swapped any two tiles,
103:20 - it will calculate whether
those tiles have made a match.
103:26 - And we're going to get matches
via self.board calculateMatches,
103:29 - the function that we
were looking at before.
103:31 - If there are any matches--
103:32 - well, we play a sound
effect here for every match.
103:35 - This is where you also
calculate the score.
103:37 - You just multiply the number
of tiles in a match by 50,
103:41 - and part of the assignment
will be adding some value
103:43 - to the individual
varieties of the tiles.
103:48 - Here, we tween.
103:52 - So we return also from
the board class a table
103:58 - of tweens for all of the new
tiles that we just spawned,
104:02 - and so what we're going to end up
doing is tweening all of them here.
104:07 - So notice that we're
passing in a timer.tween,
104:10 - this variable, tilesToFall.
104:11 - That's a definition file that we're
just returning from our board class.
104:15 - And so once those are all
finished, then we get new tiles,
104:21 - and then we tween here.
104:25 - I think this line is
redundant, actually.
104:28 - I think this might have
been a debugging line.
104:29 - I don't think we need this.
104:33 - No, we don't need this at all.
104:35 - So sorry.
104:36 - This is the important part.
104:39 - We're going to tween--
104:41 - wait, we do need it.
104:42 - Self.board getNewTiles.
104:45 - What am I thinking of?
104:53 - Sorry, a little bit
confused for a second.
104:55 - I thought this was an empty
function that I defined.
104:58 - Get new tiles.
104:59 - Yeah, this returns an empty table.
105:02 - But basically, the
gist of it is the play
105:06 - state, when it calls this function,
it will call itself every time.
105:15 - And I think this is actually
having the result of doing it
105:18 - instantly here because newTiles
is just an empty table.
105:20 - I think all this should be is just
this inside all of this like that.
105:28 - But that has the result
of calling itself again
105:31 - because when we get new tiles
coming from the top of the screen,
105:35 - we could potentially have a case
where we've gotten some matches,
105:40 - and it's not shown here, but new
falling tiles could give us new matches.
105:45 - So after we calculate matches, let's
say maybe this tile dropped here,
105:48 - but it was a purple, and
these two were already there.
105:51 - We've already calculated
matches, but then we
105:53 - need to do it again, and then do
it again if it keeps happening.
105:56 - And so you should be recursively
call self calculateMatches
105:59 - in that case, which will have the effect
of accomplishing that because this
106:06 - will always look for matches.
106:07 - And so when we call self
calculateMatches here, over, and over
106:11 - again, until there are no matches--
106:14 - as long as there are matches,
this should keep happening.
106:16 - You should keep getting scores, and
tiles should keep getting cleared.
106:19 - But as soon as that's
not the case anymore,
106:22 - then self.canInput equals true, and
we're not calculating matches anymore.
106:27 - We don't recursively call the
function anymore, and we're done.
106:29 - And so that's just the point
I wanted to illustrate.
106:31 - Got slightly confused by, I think,
what was a vestige of my old code.
106:34 - Maybe I was trying something,
but I think this, ultimately,
106:37 - should just be this, and I'll test
it, and make sure, and then push
106:39 - the change.
106:42 - And it doesn't need to
be over 0.25 seconds.
106:44 - It can just be instant.
106:48 - Palettes, really quickly, with
something I wanted to cover,
106:50 - which was just the idea of
taking art, and then just-- and I
106:53 - have a couple of cool examples to show.
106:55 - Just taking some sort of
picture, and then giving it--
106:58 - only using or some sort of image,
and only using 32, in this case,
107:03 - or some arbitrary number of colors.
107:05 - This is some fancy stuff that some
person named DawnBringer online did.
107:09 - He generated a very famous 32 color
palette called DawnBringer's 32 color
107:13 - palette.
107:14 - But basically, it allows--
107:16 - this is done with just 32
colors we see on the screen.
107:18 - Those are all dithered.
107:21 - Dithering is a term which means to
just draw two colors pixel by pixel,
107:27 - interleaved, so that from far away
it looks like a brand new color,
107:31 - and this is a dithering chart.
107:32 - This just shows you every
color here at the very top.
107:35 - These are all 32 colors.
107:37 - These are 32, and those are 32
intersected with each other such
107:42 - that they're just like
dot, dot, dot, dot, dot.
107:45 - Every other dot is every other color.
107:47 - And so you can do some pretty amazing
things with just a few colors.
107:49 - This is actually done with 16 colors.
107:52 - All four of those are only 16 colors.
107:56 - This is just to show you what it looks
like when you do it to an actual image.
108:00 - This is an example of what using
a color palette on an image that
108:04 - doesn't work well with it looks like.
108:05 - So this is a regular
image with I don't know
108:07 - how many colors, thousands of
millions of colors, and this
108:10 - is using DawnBringer's 32 color palette.
108:12 - So still looks very
similar to what it should.
108:15 - It's a cat, but there's a lot of weird
things going on in the background
108:19 - because taking an image with a lot of
blur, and a lot of distorted color,
108:24 - has the effect of giving you
blotchy patterns when you go down
108:28 - to a few colors.
108:30 - But this is an example of an image
that has a lot of flatter colors.
108:34 - There's still a lot of
colors in this image.
108:36 - There are some shades, and stuff like
that, but this is thousands of colors,
108:40 - and this is 32 colors.
108:42 - So clearly, if you do
it on the right thing,
108:45 - you can actually get really
good effects with it.
108:47 - And so again, not a whole lot
of difference, but this one's
108:52 - got I don't know how many
hundreds of thousands of colors,
108:54 - and this one's only got 32.
108:57 - And so how it ties back
into what we're doing
109:00 - is this is using a 32-bit color
or 32 color palette on purpose.
109:06 - This is actually DawnBringer's
32 color palette.
109:09 - Breakout used the same
palette, 32 colors,
109:12 - and a lot of our 2D future lectures
will use limited color palettes.
109:17 - If you're trying to draw sprite art, and
you want some quick, and easy ways just
109:22 - to give your work a
little bit of consistency,
109:26 - I recommend trying to pick
8, or 16, or 32 colors,
109:30 - and just adhering to using just those.
109:32 - And you'd be surprised
at how much you get out
109:35 - of it, and how much more
cohesive your work will look just
109:39 - by imposing that constraint on you.
109:41 - It's an artifact of a real world
constraint of former hardware.
109:46 - The NES only had so many colors
it could color each sprite,
109:48 - like four colors, or something that.
109:51 - And so you also get a-- if you're
going for an authentic retro look,
109:55 - it will help you in that sense.
109:56 - And then different from
palettes, but related
109:59 - is palette swapping, which is
another term you've probably heard,
110:02 - which is basically all
of these Mario sprites--
110:07 - they'll probably start with a gray
scale Mario, some like gray version
110:12 - where each of these separate
colors are mapped out
110:15 - to some table where one equals
red, two equals blue, or whatever.
110:20 - And then you can just shift
all of them, and then you
110:23 - get all of these different
nice effects, assuming
110:25 - that you've created a good palette.
110:30 - You can get a lot of
reuse, and this is actually
110:33 - how Super Mario Bros. used to
do some of its programming.
110:38 - The clouds and the bushes
were the same sprite.
110:41 - One was just colored green.
110:42 - It was palette swapped green from
the white that the cloud was colored.
110:48 - So that's the gist of Match 3.
110:51 - Assignment 3 is going to
have a few parts to it.
110:54 - So time addition on matches.
110:55 - So when you get a match, you
should get time added to the clock.
110:58 - Currently, right now,
you only get 60 seconds.
111:01 - It's a little bit hard to actually
get past level two at this point.
111:05 - So getting points for
every tile in a match.
111:08 - Make it so that level one
starts with simple flat blocks.
111:11 - So earlier, we saw the
array of tiles, and it
111:14 - was flat tiles on the first
index of every color row,
111:18 - but there were several other patterns
like x's, and circles, and triangles,
111:21 - and stuff.
111:22 - Make those worth some higher
amount of value, each one.
111:27 - Create random shiny variants of blocks
that will destroy an entire row when
111:31 - you get a match.
111:31 - So have a block.
111:32 - It should have some
field, shiny or something.
111:35 - If it's shiny, render it with
something to make it look shiny.
111:38 - You can use particle effect if you want.
111:41 - You can put a very opaque, or a very
transparent maybe yellowish or whitish
111:48 - rectangle on it to give
it a brighter look.
111:50 - And then if it's in a
match, that entire row
111:53 - should get cleared instead
of just that match.
111:58 - Only allow swapping when
it results in a match.
112:00 - This is an important thing
because right now, mathematically,
112:03 - it's actually very unlikely
that you'll get a board that
112:05 - has matches on it to begin with.
112:10 - So you're going to have to pick a
subset of tiles in your implementation,
112:16 - and actually use those instead
of just using all of them.
112:20 - Pick six tiles, which you can get
variants on, or just whatever flat
112:25 - colors, and then use only
those to spawn your board.
112:28 - Don't use all 18, or
however many there are.
112:32 - And then optional, if you're
curious, if you want, probably,
112:35 - an arguably better gaming
experience with this,
112:38 - just implement actually
playing with the mouse.
112:41 - Being able to click and drag,
or just click individual tiles.
112:44 - And to do that, you
will need to convert--
112:47 - because we use the push
library for virtual resolution,
112:49 - you'll need to convert the
window mouse coordinates
112:53 - to push coordinates so that they'll
map into the game space appropriately,
112:56 - and so you'll use a function
called push to game, where
112:58 - it takes an x and y, where the x and
the y will be your mouse coordinates.
113:03 - Next time, we're actually
going to get into a little bit
113:06 - more robust of a game,
arguably, like a Mario clone.
113:11 - This is actually where
this course started
113:14 - was I taught a seminar
on Super Mario Bros.
113:16 - We won't be using Super Mario
Bros. assets because of copyright,
113:20 - but we'll be using this tile
sheet here, which is very similar.
113:22 - It's got a nice aesthetic.
113:23 - We'll cover tile maps.
113:25 - So how to generate levels
using individual tiles.
113:27 - 2D animation, so rather
than just like static things
113:30 - that we've had going on so far, you'll
have characters that actually walk,
113:33 - and jump, and do different things.
113:35 - We'll talk about how
to actually procedure
113:36 - generate platformer levels,
which isn't terribly difficult.
113:40 - It sounds kind of difficult,
but it's actually pretty--
113:43 - for very simple stuff, it's not too bad.
113:46 - Basic platformer physics, so
hitting blocks, and jumping,
113:49 - and stuff like that.
113:49 - We've covered a lot of that with
Flappy Bird, actually, and actually,
113:54 - the bricks from Breakout kind
of tie into it a little bit.
113:57 - Hurt boxes so we can have enemies
that hurt you, and visa versa.
114:01 - And power ups so that you can change
your state in some way to make you
114:05 - larger, or invincible, or whatnot.
114:07 - That was Match 3.
114:08 - Thanks a lot, and see you next time.