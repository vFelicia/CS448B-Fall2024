00:00 - in this.net 6 course amikai will teach
00:02 - you how to build a rest api amikai is a
00:05 - software engineer at microsoft and he is
00:08 - great at breaking down complex technical
00:10 - topics in a way that's easy for
00:12 - beginners to understand hi everyone
00:14 - today we're going to be building a crud
00:16 - based rest api completely from scratch
00:19 - i'm really excited to be collaborating
00:21 - with free code camp on this video so i
00:23 - really hope you're going to like it and
00:24 - i can't wait to hear what you think okay
00:26 - so what are we building today well today
00:28 - we're going to be building the back end
00:30 - for the fictional application uber
00:32 - breakfast kind of what is this breakfast
00:34 - application well it's basically a system
00:36 - in which you can create breakfast
00:38 - and as you can see every breakfast has a
00:41 - title a description a star and end time
00:44 - some savory items over here and also
00:47 - some sweet items and because what we're
00:50 - building is a crud based rest api then
00:52 - as you would expect the actions that we
00:54 - can do
00:55 - are creating a new breakfast reading
00:58 - breakfasts
00:59 - updating a breakfast and also let's
01:01 - imagine that somewhere in our system we
01:03 - have the option to delete a breakfast as
01:05 - well okay so if this sounds intriguing
01:07 - make sure to watch until the end because
01:09 - by the end of this video you should have
01:10 - a good understanding of all the topics
01:12 - that we're going to be covering
01:14 - okay moving on to the architecture of
01:16 - the project so as you can see by the end
01:18 - of this video we're going to have two
01:20 - projects now you don't need to remember
01:22 - what this looks like but what i do want
01:23 - you to notice is that we have two
01:25 - projects one containing the definition
01:27 - of our api so this models our api
01:30 - definition and another one with the
01:32 - actual logic of our application okay
01:35 - moving on to the technologies that we're
01:37 - going to use
01:38 - so we're going to be using dot net 6 and
01:41 - we're going to use the dot net cli and
01:43 - visual studio code for everything else
01:45 - as part of this video then you will get
01:47 - familiar with some new.net cli commands
01:50 - and some pretty cool visual studio code
01:51 - extensions which hopefully you'll be
01:53 - able to take and add to your toolkit
01:55 - okay moving on to the architecture
01:58 - choices so as we said we're building a
02:00 - crud rest api this means a system in
02:03 - which you can create read update and
02:05 - delete resources so not every back-end
02:08 - system needs to follow clean
02:09 - architecture and domain-driven design
02:11 - principles especially when the
02:12 - application is small or medium it can
02:14 - add a few layers of complexity which
02:16 - aren't always worth the effort so today
02:18 - we're going to be building something
02:19 - that is suitable for small to medium
02:21 - sized applications and hopefully you'll
02:23 - be able to take what we're going to be
02:24 - building today and use it in your
02:26 - applications even if yours is completely
02:28 - different okay now even though we're
02:30 - creating a quote simple application we
02:32 - want to make sure that our application
02:34 - is resilient and it will scale well as
02:36 - our application has more and more
02:38 - features and more error flows that's why
02:40 - we're going to incorporate some
02:42 - interesting concepts from functional
02:43 - programming and also some principles
02:46 - from domain-driven design which will
02:48 - make our application more resilient and
02:51 - better organized okay lastly who am i so
02:54 - my name is amica i'm a software engineer
02:56 - at microsoft i love creating all these
02:58 - visual engineering infographics on the
03:01 - various social media platforms and i
03:03 - actually just launched a new youtube
03:05 - channel a few weeks ago in which we
03:07 - write a lot of codes we cover design
03:09 - patterns and architectures that are a
03:10 - bit more advanced than what we're going
03:12 - to be seeing today so if you like what
03:14 - you see today then feel free to follow
03:15 - me on the various social media platforms
03:17 - you might enjoy my content
03:19 - hi everyone i'm mikhail here i do have a
03:21 - quick disclaimer so i am a microsoft
03:23 - employee and these are microsoft
03:24 - technologies but i'm not talking on
03:26 - behalf of microsoft these are my
03:27 - personal opinions okay so without
03:29 - further ado let's start writing some
03:31 - code so as we said we're going to have
03:32 - two projects one that models our api
03:36 - and another one which will contain the
03:37 - actual logic of our application okay now
03:40 - if you're asking yourself why would i
03:42 - want to split my application into two
03:43 - separate projects while having your api
03:46 - definition which is a bunch of c-sharp
03:48 - classes in a separate project allows you
03:50 - to define it as a class library and then
03:52 - publish it as a nougat package then if
03:55 - your client is written in dot net then
03:57 - they can simply consume this nougat
03:59 - package instead of remodeling the api
04:02 - themselves okay now this also works well
04:04 - with versioning so as your api evolves
04:07 - and you have new versions then when you
04:08 - want to publish the v2 of your api then
04:11 - all you need to do is publish a new
04:13 - nuget package and all the client needs
04:15 - to do is simply consume the new package
04:18 - okay so let's get started the first
04:20 - thing we want to do is create a new
04:22 - solution
04:22 - so let's go ahead and create our blooper
04:24 - breakfast solution so dot new
04:27 - sln and let's give it the name uber
04:29 - breakfast
04:32 - hey as you would expect this creates the
04:33 - boober breakfast folder which inside has
04:37 - the uber breakfast solution
04:39 - now let's go ahead and create our
04:40 - projects so dot new class lib and let's
04:43 - give it a name boober breakfast
04:46 - dot contracts
04:48 - right so this is a project that models
04:50 - our api
04:52 - great now let's create
04:54 - our actual web api so dotnet new
04:57 - web api
04:58 - and let's give it the name boober
05:00 - breakfast
05:05 - okay let's try building the project so
05:06 - dot net build
05:09 - and we get a warning that says unable to
05:11 - find a project to restore now this may
05:13 - seem a bit weird because we just created
05:15 - two projects
05:16 - but when working with the.net cli then
05:19 - it's not enough to just create the
05:20 - projects because if we look at the
05:22 - solution file then we can see it's still
05:24 - empty and there are actually no projects
05:26 - defined in it so let's go ahead and add
05:29 - both of our projects to the solution
05:30 - file so dot net sln add
05:33 - and we want to add the boober breakfast
05:37 - dot contracts
05:38 - and the booby breakfast project click
05:41 - okay this adds them okay now you can
05:43 - actually do this in a shorter way so you
05:44 - can do dotnet sl and and you can specify
05:47 - over here all the projects recursively
05:50 - like so so you can go ahead and choose
05:53 - whatever is more convenient for you okay
05:55 - now that we have all of that defined
05:57 - let's go ahead and open this in visual
05:58 - studio code
06:01 - okay so we open the project in visual
06:03 - studio code and as we expect we have the
06:05 - solution that we created and the two
06:07 - projects
06:08 - if we look at the solution then after we
06:10 - added the two projects we can see that
06:12 - they're defined over here
06:14 - if we look at the two projects then over
06:16 - here this is just a class library we're
06:18 - using.net 6 and we have nullable
06:20 - reference types enabled which basically
06:23 - means if we haven't defined that an
06:24 - object can be null then it can't be null
06:28 - okay let me just close this stuff over
06:29 - here okay and over here we have the web
06:32 - api so because we created the project
06:34 - from the.net cli using the web api
06:36 - template then we get here a few things
06:38 - out of the box okay so looking at the cs
06:40 - proj okay so as we said we're using the
06:42 - dotnet sdk dot net six and also here we
06:45 - have nullable reference types enabled
06:47 - okay now the first thing i want to do is
06:49 - actually to create your new folder it's
06:51 - called docs and over here let's create a
06:53 - file
06:54 - api.markdown
06:56 - what i'm going to do is paste here the
06:58 - definition of the api that we're going
06:59 - to be building and i'm going to open it
07:01 - using the markdown preview enhanced
07:03 - extension if you aren't familiar with
07:06 - visual studio code then over here you
07:07 - have a tab in which you can search and
07:09 - install extensions for visual studio
07:11 - code so this extension is called
07:13 - markdown preview enhanced and all you
07:15 - need to do is select it click install
07:18 - and then over here
07:19 - when you right click then you'll have
07:21 - the option to open it using this
07:23 - extension
07:24 - so let me put it over here so it catches
07:26 - the entire screen and i want to open it
07:28 - side by side with our client application
07:31 - okay starting with the c of chrono then
07:35 - the way you create a breakfast is you
07:36 - basically call the breakfast endpoint
07:39 - using the http verb post and as you
07:42 - would expect what you have over here is
07:44 - basically a breakfast
07:46 - right so we have the name which
07:47 - corresponds to this the description
07:49 - which corresponds to this the start and
07:52 - end date time which corresponds to this
07:54 - over here
07:56 - then we have a list of savior items
07:58 - which is this and suite items which is
08:01 - this the only thing that's missing from
08:02 - the schema is perhaps a list of images
08:05 - but let's imagine that we're just
08:06 - building the mpp and so in a future
08:08 - iteration we'll add this feature as well
08:11 - okay if we created a dinner successfully
08:14 - then we get
08:15 - the http status code 201 created and the
08:18 - location header which gives us details
08:20 - on how to fetch the breakfast that we
08:22 - just created if we'd like and the
08:24 - response content contains all the
08:26 - details that we sent including a server
08:28 - generated id and another server
08:30 - generated property a last modified date
08:33 - time
08:34 - moving on to the r of card
08:36 - so we call this endpoint over here and
08:38 - specify the id of a breakfast that we
08:41 - want to read and to indicate that we
08:43 - want to retrieve data then we're going
08:44 - to use http get if the breakfast exists
08:47 - then we'll get http status code 200 and
08:50 - then the response will get the breakfast
08:52 - that we requested okay moving on to
08:55 - update breakfast then to update
08:57 - breakfast you would specify the idea of
08:59 - the breakfast that you want to update
09:00 - and use the http verb put and in the
09:03 - request content you would specify the
09:06 - new details if the dinner was updated
09:08 - successfully then we get 204 no content
09:11 - but if the specified id doesn't exist
09:14 - then following the rfc specification for
09:16 - put will return 201 created and the
09:19 - response will be similar to the response
09:21 - of creating a resource so even though
09:23 - this is called update this is actually
09:25 - upsert so we'll update the resource if
09:27 - it already exists or it will create a
09:29 - new resource if it doesn't exist last
09:32 - but not least we have the delete
09:34 - breakfast basically you specify the id
09:36 - of the breakfast that you want to delete
09:38 - with the http verb delete and if it was
09:41 - deleted successfully then we'll get 204
09:44 - no content so by the end of this video
09:46 - we'll create an api that behaves in the
09:48 - good flow like what we saw over here but
09:51 - don't worry we're also going to have
09:52 - error handling so if something goes
09:54 - wrong we'll return the appropriate
09:56 - response to the client
09:58 - okay so i actually want to open the api
10:00 - definition again on the right so we have
10:02 - it visible while we're modeling our api
10:04 - okay so let's start with create
10:06 - breakfast so over here in the contract
10:08 - project let's get rid of this
10:10 - auto-generated class let's create a new
10:12 - folder it's called breakfast
10:14 - and over here let's create a new file
10:16 - called create breakfast request
10:19 - and as we defined in our api so this
10:21 - will be public record
10:23 - create breakfast request
10:26 - so this will be string name
10:28 - spring description yes
10:30 - daytime
10:33 - start daytime
10:35 - yes and daytime
10:37 - then we have here a list of savory
10:40 - and a list of sweet items as well
10:44 - great moving on to the response so
10:47 - actually the response both of the create
10:49 - breakfast and the get breakfast are
10:52 - identical so let's just create a single
10:54 - file to model both of these responses
10:56 - let's call it a breakfast response
10:58 - so breakfast response
11:02 - and actually let's just copy paste this
11:04 - entire thing let's add the extra fields
11:09 - so this over here will be response
11:12 - we have here a guide
11:14 - and other than these two daytimes we
11:16 - also have here a less modified
11:19 - daytime
11:21 - right so as we said we already have this
11:23 - defined over here on the left
11:26 - now let's create the option request so
11:28 - absurd
11:29 - breakfast request
11:33 - and over here as well just copy paste
11:35 - this entire thing over here
11:39 - let's change it from create
11:41 - to
11:42 - upsert
11:44 - and
11:44 - that's it right
11:46 - right now that we have the api modeled
11:48 - in c-sharp classes let's go ahead and
11:50 - start implementing the actual logic
11:52 - okay now if you aren't familiar with web
11:54 - apis and i want you to have something to
11:56 - imagine as we were writing some of the
11:58 - code so i want you to imagine that when
11:59 - the user clicks the create new breakfast
12:01 - request with a new breakfast that he
12:03 - just defined
12:05 - then the following details are sent to
12:07 - the server to the create dinner endpoint
12:12 - and you can imagine that the request
12:13 - arrives over here at the breakfast
12:15 - controller and we'll be able to extract
12:17 - the details that were sent and
12:19 - manipulate them the way we want so in
12:21 - our case we want to store them in the
12:23 - database okay then in the response then
12:26 - whatever the breakfast controller
12:27 - returns then it'll simply be returned to
12:30 - the client and then the client can take
12:32 - the information that was returned
12:34 - and display it back to the user so back
12:37 - in our application because we created
12:39 - the web api using the command line
12:41 - interface template we get here some
12:43 - files which we don't care about so let's
12:45 - go ahead and get rid of everything that
12:46 - we aren't going to need so we can get
12:48 - rid of this weather forecast controller
12:50 - this weather forecast
12:52 - file
12:53 - and the program cs let's get rid of
12:55 - everything we aren't going to use in
12:56 - this video so we can get rid of this
12:59 - of this
13:00 - of all this
13:02 - and of this as
13:04 - well okay now if you're used to seeing
13:07 - both a program cs and a startup cs then
13:10 - what we have over here is the new
13:11 - template starting from dot net six where
13:14 - over here you have the builder variable
13:17 - which you can use for dependency
13:19 - injection and configuration and over
13:21 - here you have your app variable in which
13:23 - you can manage the request pipeline okay
13:25 - now a nice trick that i saw is creating
13:27 - here a scope and putting this inside
13:29 - like this and
13:30 - same over here
13:32 - just makes it seem a bit more organized
13:35 - okay last thing over here we can now get
13:37 - rid
13:38 - of this package reference since we
13:40 - aren't using it anymore and that's it
13:42 - okay so
13:44 - let's start defining our endpoints
13:48 - so over here let's create our
13:50 - breakfasts controller
13:53 - so this will be public class
13:55 - breakfasts
13:56 - controller which will inherit from the
13:58 - controller base this is coming from this
14:00 - namespace over here
14:05 - okay we want to add the api controller
14:08 - attribute
14:09 - this is an attribute that we get out of
14:10 - the box with asp.net
14:12 - and it does some heavy lifting for us
14:15 - okay so let's start defining our
14:16 - endpoints so let's start with a create
14:18 - breakfast request so
14:20 - http post
14:22 - and here let's specify the route so yes
14:24 - breakfast
14:26 - this will be public i action results
14:29 - create breakfast
14:31 - let's see what it's suggesting
14:33 - yes
14:34 - you know we can try to add the contract
14:36 - namespace but it's not recognized that's
14:38 - because we don't have any reference to
14:40 - the contracts project so let's go ahead
14:42 - and add this reference so dotnet add and
14:45 - then we need to tell which project so in
14:47 - our case we want the blue breakfast
14:49 - project to reference
14:51 - the contracts project
14:54 - okay this added the reference to the
14:56 - contracts project so now we should be
14:58 - able
14:59 - to add the namespace
15:01 - great and for now let's just return the
15:02 - request
15:04 - next we have our get endpoint so let's
15:06 - just copy this entire thing and paste it
15:08 - over here let's change this to http get
15:12 - over here let's add the
15:15 - yes the id
15:17 - and because we want this to be a guide
15:18 - then we can add here guide and the
15:20 - framework will enforce that this must be
15:22 - guided
15:23 - let's change this to get breakfast
15:27 - and over here we have our guide
15:31 - and for now let's simply return here the
15:32 - guide
15:35 - next we have our update breakfast
15:36 - request
15:37 - so again let's copy
15:39 - this method over here and
15:41 - paste it
15:42 - let's change http post to put
15:46 - this
15:47 - will be similar to what we have over
15:48 - here so let's simply copy and paste it
15:51 - and let's change this to
15:53 - observe breakfast
15:54 - and over here this won't be the create
15:56 - breakfast request but rather it will be
15:59 - the absurd
16:01 - breakfast request and of course we also
16:03 - want to extract the id from the route so
16:06 - id okay and lastly we have our delete
16:10 - endpoint so let's copy
16:13 - the get endpoint and paste it down here
16:18 - let's change http get
16:20 - to http delete
16:23 - let's change the name
16:25 - from
16:25 - get
16:27 - to delete
16:29 - and that's it for now
16:31 - let's close the api definition and make
16:33 - sure that this works as we expect so
16:35 - dotnet build
16:39 - create it build successfully let's go
16:40 - ahead and run the project so this will
16:41 - be.net run and here we need to specify
16:44 - which project so in our case it's the
16:46 - uber breakfast project let's click enter
16:49 - this will build and run our application
16:52 - right now to make requests i want to
16:53 - introduce another visual studio code
16:56 - extension
16:57 - so let's go back to the extensions tab
16:58 - and look over here for rest client
17:02 - okay this is the one you'll see it has
17:04 - two million downloads and a lot of love
17:06 - from the users simply click install and
17:09 - you'll be able to run http requests like
17:11 - we're going to demonstrate now
17:13 - so the way this looks is let's create
17:15 - here a new folder let's copy requests
17:18 - inside here let's create another poll
17:19 - that's called breakfast
17:21 - and in here let's create a great
17:23 - breakfast request
17:26 - okay so it's simply a file that ends
17:28 - with dot http okay and the way this
17:30 - extension works so you basically just
17:32 - write the request that you want to send
17:34 - and you can see that just writing the
17:35 - http verb already pops out this send
17:38 - request option then you simply click it
17:40 - and it sends the request for you so
17:42 - let's open our api definition again on
17:44 - the right
17:47 - and create our first request so we want
17:49 - the host slash
17:51 - breakfasts
17:53 - underneath we can define whatever
17:55 - headers that we want so in our case we
17:57 - want the content type
17:58 - application json and below our request
18:01 - body which is
18:02 - this thing over here
18:04 - okay let's try sending the request and
18:06 - making sure that the endpoint simply
18:07 - returns the request as we defined so we
18:09 - sent it and we got it as we expect
18:12 - great let's go ahead and create our
18:14 - other requests as well so over here we
18:16 - have also the get breakfast request
18:21 - the upsert
18:23 - breakfast request
18:24 - and
18:26 - lastly the delete
18:29 - breakfast request
18:31 - okay let's copy the create request to
18:33 - the upload request because they're very
18:35 - similar
18:36 - but instead of post this will be put and
18:39 - over here will have the id of the
18:41 - breakfast that we want to update so
18:43 - let's just take
18:44 - some id from over here and paste it in
18:46 - our request okay now something cool that
18:48 - you can do with this extension is create
18:50 - variables so you can say for example
18:52 - that the id is
18:54 - let's copy the
18:56 - id over here
18:58 - and paste it here
19:00 - and then we can simply replace this
19:02 - entire thing with id
19:04 - and you can see that there's even
19:05 - intellisense so you can autocomplete and
19:07 - over here you even have navigate to
19:09 - definition
19:11 - pretty cool
19:13 - okay so this is our update endpoint it
19:14 - corresponds to the definition of our api
19:17 - over here
19:18 - let's move on to the get breakfast so
19:21 - let's simply paste this over here let's
19:24 - paste the id as well actually
19:26 - and instead of put this will be get
19:29 - and the delete will be similar to this
19:31 - only we'll have here instead of get
19:35 - delete
19:36 - let's make sure our definition is
19:37 - correct so create we already tested
19:39 - let's make sure that delete works as
19:41 - well so right over here we just simply
19:43 - return the id
19:45 - forget also we return the ib and for
19:48 - upsert we should be returning the
19:49 - request
19:50 - great so now that we have everything
19:52 - wired together and we have all our
19:53 - requests defined let's go back
19:56 - to the controller and think what we want
19:58 - to do over here so let me just close all
20:00 - these windows on the right
20:02 - also let's stop the application you can
20:04 - do it by clicking ctrl c
20:07 - okay back in our controller one last
20:09 - thing that i want to do so because all
20:11 - our endpoints start with the word
20:13 - breakfast we can simply go over here and
20:15 - write real
20:17 - breakfasts
20:18 - and then we can remove
20:19 - this
20:21 - this
20:23 - this
20:24 - and
20:26 - this as well
20:27 - and because it's very common to have the
20:30 - route
20:31 - simply the name of the class without the
20:32 - word controller then the framework also
20:34 - allows us to do something like this
20:36 - where you simply write controller and
20:38 - then all the endpoints will be prefixed
20:41 - by the name of the class without the
20:43 - word controller
20:44 - okay so now let's think what we want to
20:46 - do so let's start with the create
20:48 - breakfast endpoint so as we said we have
20:50 - here the request now we don't want to
20:52 - store the request as it is in the
20:53 - database for a couple of reasons one it
20:56 - doesn't have all the properties that we
20:57 - want so for example the id property
20:59 - doesn't exist and the last modified
21:01 - property doesn't exist but also because
21:03 - we want the flexibility to be able to
21:05 - change things inside our system without
21:07 - having to change the contract that we
21:09 - have with our clients okay so what we
21:11 - want to do over here is take the request
21:13 - that we received
21:15 - converted to the internal service model
21:17 - and inside our application will only
21:19 - speak in the language of these models
21:21 - and not the language of the contracts
21:22 - then tomorrow morning we can create a
21:24 - new api version and all we need to do is
21:27 - convert the new api definition to our
21:29 - internal service language and then we
21:31 - can support multiple versions and our
21:34 - system is more flexible so
21:36 - for that let's create our internal
21:38 - breakfast representation so let's go
21:40 - ahead and create here a new folder it's
21:41 - called
21:43 - and in here let's create our breakfast
21:46 - object
21:47 - okay so this will be public class
21:49 - breakfast
21:51 - and over here let's have
21:53 - yes actually this seems right but
21:56 - because we want to make sure that this
21:58 - is always built with valid values and we
22:01 - don't want to give anyone holding the
22:03 - object the option to simply set new
22:06 - values to our properties then let's get
22:08 - rid of all the sets over here
22:11 - and let's create a constructor
22:14 - great let's just wrap the line here so
22:16 - it's visible
22:17 - okay and now not only that no one can
22:19 - change the id for example after it was
22:21 - set but also over here
22:24 - we can enforce
22:26 - whatever logic that we want so if we
22:28 - have some logic for example that the
22:30 - name of the description can be shorter
22:32 - than three characters then we can
22:34 - enforce it over here and then once it's
22:36 - created we know this value is always
22:38 - valid in whatever valid means inside our
22:41 - system
22:42 - okay so back
22:43 - in the controller
22:44 - let's map the request to this breakfast
22:47 - object so let's say over here breakfast
22:50 - equals and here let's say
22:53 - yes this thing's about right
22:55 - let's make sure that we have here
22:56 - everything that we need
22:58 - right so we take all the values and we
22:59 - generate a new id and for the last
23:01 - modified we simply pass utc now okay the
23:04 - next thing we want to do
23:06 - is is somehow yes saved to the database
23:10 - then we want to take the breakfast that
23:12 - we created and
23:13 - map it to our breakfast response
23:16 - and from here we want to return
23:18 - our response
23:20 - okay now this over here will return 200
23:23 - okay right because we're using the base
23:24 - method okay but what we actually want to
23:27 - return is 201 created so let's go ahead
23:30 - and use the created apps and as you can
23:33 - see there are a few options over here
23:34 - we're going to use this one over here
23:36 - but there are other options okay now
23:38 - this method receives three things
23:41 - first of all it receives the action in
23:44 - which the client can retrieve the
23:45 - resource so in our case it's
23:48 - the get breakfast endpoint
23:50 - then because the get breakfast endpoint
23:52 - has a parameter called id then we need
23:55 - to pass over here an object that has the
23:57 - id property
23:58 - so something like this
24:00 - yes
24:02 - and lastly the response content
24:04 - let's just add the argument names though
24:06 - it's a bit more readable
24:08 - okay so what we have at the moment is
24:10 - very common to see in controllers the
24:12 - first step is mapping the data that we
24:14 - get in the request to the language that
24:16 - our application speaks the last step is
24:19 - taking the data from our system and
24:21 - converting it back to the api definition
24:24 - and returning the appropriate response
24:26 - and over here we have the actual logic
24:28 - of our application which we're going to
24:30 - implement now okay so let me just remove
24:33 - these redundant parentheses over here
24:35 - and back in our boober brackets folder
24:38 - let's create a new folder scott services
24:41 - and over here let's create another
24:43 - folder called breakfasts and over here
24:46 - let's create the i breakfast service and
24:49 - what we'll have over here is the public
24:51 - interface
24:53 - yes i breakfast service
24:55 - let's leave only the create and again we
24:58 - only want to work with our internal
25:00 - models so over here we want our
25:03 - breakfast model and the response let's
25:05 - have this void for now
25:07 - and let's change the name of this to
25:09 - breakfast
25:10 - great now back in our controller
25:13 - let's use this interface so private
25:15 - read-only
25:17 - yes
25:19 - let's include the namespace and inject
25:21 - this
25:22 - to the constructor
25:23 - okay if you aren't familiar with
25:25 - dependency injection then we'll look
25:26 - into it in a few minutes now down here
25:29 - let's use it to actually create our
25:31 - breakfast so
25:33 - breakfast service create breakfast and
25:35 - let's pass it to breakfast
25:38 - okay now let's go ahead and implement
25:39 - this breakfast service let's create here
25:42 - a new file let's call it breakfast
25:43 - service
25:45 - and over here let's have our public
25:47 - class
25:48 - practice service
25:51 - the ibreakfast service interface
25:54 - let's go ahead and implement the
25:55 - interface
25:56 - okay now as part of this video all we'll
25:58 - do is just store it in memory but over
26:01 - here what you would actually do
26:03 - is use some repository or entity
26:05 - framework to store it in the database
26:08 - okay so what we'll have over here is
26:10 - private read-only dictionary
26:13 - where we'll map an id to a breakfast
26:15 - let's just initialize it
26:17 - then over here all we need to do is
26:19 - breakfast
26:20 - dot add
26:22 - and the idea of the breakfast is the key
26:24 - and the value is the actual breakfast
26:26 - great let's just add a new line over
26:29 - here and back in our controller
26:31 - for us to be able to test this
26:33 - end-to-end and see that this actually
26:34 - works so in the get breakfast
26:37 - let's try to retrieve the breakfast with
26:39 - a given id
26:40 - so yes something like this
26:44 - let's generate this method
26:46 - right so this generated the get
26:48 - breakfast method
26:50 - which we'll implement over here
26:52 - so implement the interface and all we
26:55 - need to do
26:57 - is simply return
26:59 - the breakfast that corresponds to the id
27:01 - that we just received
27:02 - okay now that we have this method
27:04 - implemented back in our controller let's
27:06 - map our breakfast to the breakfast
27:09 - response so
27:10 - yes
27:12 - and let's return the response from here
27:15 - okay let's run the project
27:18 - and make the create breakfast request
27:21 - and see what happens
27:23 - okay now some of you might have expected
27:25 - this failure
27:27 - so the failure we're getting is that the
27:29 - framework doesn't know what to do when
27:30 - someone requests the i breakfast service
27:33 - interface right so back in the
27:34 - controller we're trying to use the i
27:36 - breakfast service interface okay now
27:38 - what actually happens behind the scenes
27:40 - is that every time we send a request to
27:42 - the service the framework creates a new
27:44 - breakfast controller object when it
27:46 - creates the new breakfast controller
27:47 - object it also tries to create a new i
27:50 - breakfast service object and the
27:52 - framework doesn't know how to
27:53 - instantiate the interface that the
27:55 - breakfast controller is requesting so to
27:57 - fix that let's go to the program cs and
28:00 - over here define how to create the eye
28:02 - breakfast service interface so builder
28:05 - dot services dot add singleton
28:09 - yes breakfast service okay what we're
28:11 - telling the framework is that every time
28:13 - it instantiates an object that object
28:15 - requests the eye breakfast service in
28:17 - the constructor then use the breakfast
28:20 - service object as the implementation of
28:23 - this interface
28:24 - and over here we have a few options for
28:26 - the lifetime of this breakfast service
28:28 - object
28:29 - so specifying here singleton tells the
28:32 - framework the first time that someone
28:34 - requests the ibreakfast service
28:35 - interface then create a new breakfast
28:37 - service object but from now on
28:39 - throughout the lifetime of the
28:40 - application every time someone requests
28:43 - this interface always use the same
28:45 - breakfast service object that you just
28:46 - created
28:47 - another option over here is to say
28:49 - scoped
28:51 - scope says within the lifetime of a
28:53 - single request the first time someone
28:55 - requests this interface then create a
28:57 - new object but from now until we finish
29:00 - processing this request every time we
29:02 - create an object and it requests this
29:03 - interface then return the same breakfast
29:06 - service object that you created before
29:08 - okay there's also transient which as you
29:11 - would expect basically says every time
29:12 - someone requests this interface create a
29:15 - new breakfast service object
29:17 - okay now looking at our breakfast
29:18 - service object
29:20 - so because we're persisting our
29:21 - breakfast inside this dictionary over
29:23 - here we don't want this dictionary to be
29:25 - recreated every request so let's change
29:28 - this to static
29:30 - okay and over here let's change this
29:32 - back to scoped
29:34 - great let's try running our application
29:36 - again
29:36 - and see if it works now
29:38 - so we make the create breakfast request
29:41 - as we can see we get here the http
29:43 - status code 201 created
29:46 - we get the location header and we get
29:48 - the breakfast response which contains
29:51 - the server generated id and less
29:53 - modified date time
29:55 - right let's take the id
29:57 - of the breakfast that was just generated
29:59 - and let's try retrieving it over here so
30:01 - let's replace this id with the idea of
30:04 - the breakfast and make the get request
30:07 - and we can see that this works as we
30:08 - expect so we get http status scoped 200
30:11 - okay and over here again we have our
30:13 - breakfast response okay now one thing
30:15 - about the create breakfast so let's
30:17 - create another breakfast
30:19 - we said that the location header
30:21 - contains a route which we can use to
30:23 - retrieve the resource that we just
30:24 - created so let's try and using this to
30:26 - retrieve the breakfast so i'm copying it
30:29 - and pasting it
30:30 - back over here
30:32 - now if you want to send multiple
30:33 - requests from the same file then you can
30:36 - do it by typing three hashtags and you
30:38 - can see that now we can send another
30:40 - request from the same file let's use
30:42 - http get and make the request
30:46 - and we can see that it works back in our
30:48 - controller let's implement the methods
30:50 - that are still missing let's also stop
30:52 - our service
30:54 - so let's implement the update endpoint
30:57 - so over here let's create breakfast
30:59 - given the details that we have
31:02 - great so it's similar to the crate only
31:04 - that we're using the id that we got from
31:06 - the route
31:07 - then we want to use the breakfast
31:09 - service to observe the breakfast so yes
31:13 - let's generate this method
31:16 - and we want to return here no content
31:19 - now if you remember then in this
31:20 - endpoint we want to return no content
31:23 - only if the id is an id of a breakfast
31:24 - that exists in our database otherwise if
31:27 - this is a brand new id and the details
31:29 - here are valid then we want to create a
31:31 - new dinner and we want to return here a
31:33 - similar response as we're doing in the
31:35 - create endpoint so let's add here a to
31:38 - do
31:39 - return 201 if a new breakfast
31:43 - was created
31:44 - right last but not least let's delete
31:47 - the breakfast so
31:50 - breakfast service dot
31:52 - will eat breakfast and let's pass the id
31:54 - let's generate this method
31:57 - and return here
31:59 - no content
32:00 - and back in our services let's implement
32:03 - the two missing methods so implement
32:05 - interface
32:07 - delete will be simply
32:09 - remove the entry with the given id
32:12 - and for upsert they'll simply be
32:16 - breakfasts
32:17 - and add it to the dictionary
32:19 - let's make sure that this works as we
32:21 - expect so let's rerun the service
32:23 - so create created a new breakfast
32:27 - let's
32:28 - copy the id
32:29 - and paste it over here in the get
32:31 - breakfast
32:32 - let's try retrieving it and we retrieved
32:35 - it successfully let's copy the id
32:37 - to the after breakfast and over here
32:40 - let's change this
32:42 - let's make it i don't know
32:44 - vegan sunshine too
32:46 - let's make the request
32:48 - you can see we got here no content which
32:50 - means it was updated successfully
32:52 - let's try retrieving the breakfast again
32:54 - and we can see we got it with the
32:56 - updated value
32:58 - now let's copy the id and delete the
33:00 - breakfast
33:01 - and we get no content again which means
33:03 - that it deleted it successfully so now
33:05 - if we try to get the breakfast again
33:07 - what do you think will happen
33:09 - and an exception was thrown and we can
33:11 - see over here the exception that
33:12 - occurred so this is basically the
33:14 - exception to string
33:16 - here's the exception message
33:17 - and here's our stack trace
33:19 - can if we go back to the breakfast
33:21 - service implementation okay we can see
33:22 - that this happens because we're not
33:24 - accessing the dictionary safely but
33:26 - before we fix this we actually never
33:28 - want to return to the client the
33:30 - exceptions that were thrown it may
33:31 - contain sensitive information and also
33:34 - we don't want the client to see the
33:35 - stack trace and what happened inside our
33:37 - system and how it's implemented so let's
33:39 - add global error handling which
33:42 - basically means how we handle exceptions
33:44 - that are thrown in our system so back in
33:46 - the program cs
33:47 - we're going to add a middleware as
33:49 - following so use exception handler and
33:51 - over here let's specify some route
33:54 - so when i said that you can imagine the
33:56 - request simply arrives to the controller
33:58 - so basically what we have is a pipeline
34:00 - that our request goes through and if you
34:03 - aren't familiar with middleware then you
34:04 - can imagine it like a sandwich of code
34:06 - you can write code that runs before and
34:08 - after the next piece of middleware where
34:11 - somewhere down the road one of the
34:13 - middlewares actually invokes the
34:14 - controller what we did over here is
34:16 - we're using a built-in capability of the
34:18 - framework to add code that basically
34:20 - adds a try catch surrounding the
34:22 - following middlewares
34:24 - and then if an exception is thrown then
34:26 - it catches that exception it changes the
34:28 - request route to the route that we
34:30 - defined over here and it re-executes the
34:33 - request
34:34 - and what this means is that over here we
34:36 - can create a new controller and we can
34:38 - call it errors controller
34:40 - so public class
34:42 - here is controller yes let's just change
34:45 - this to controller base let's say that
34:48 - the route here is
34:50 - error
34:51 - and let's change this to problem
34:54 - and let's explain what we have over here
34:56 - so like we said it re-executes the
34:58 - request to the error route then over
35:01 - here we can have whatever error handling
35:02 - logic that we want currently all we're
35:05 - doing is using the problem method from
35:08 - the controller base which will return
35:10 - the http status code 500 internal server
35:13 - error so i want us to run the program
35:14 - and see what this looks like now
35:18 - so let's rerun it and make the get
35:20 - request again so we don't have anything
35:22 - in the database so this should throw an
35:24 - exception and we can see that we no
35:25 - longer get the exception as it was
35:27 - thrown but we get this next response
35:30 - with 500 internal server error
35:33 - and no sensitive information will return
35:35 - to our client
35:37 - okay so this brings us to the next part
35:38 - of our video which is error handling so
35:41 - there are many approaches for handling
35:42 - the error flow in our system
35:45 - what we're going to do today is use an
35:47 - approach from functional programming
35:49 - where basically what we'll do we'll say
35:51 - when you request a breakfast we'll
35:52 - either return the breakfast like you
35:54 - requested but if for some reason we
35:56 - can't do it for example the breakfast
35:58 - doesn't exist then we'll return an area
36:01 - that represents what happened okay so
36:03 - let's see what this looks like
36:05 - so first of all i want to add a new
36:07 - package to our application so dotnet add
36:10 - to
36:11 - the boober
36:12 - breakfast project
36:14 - the package okay now this package is
36:16 - called error or it's my personal
36:18 - favorite for handling this approach
36:20 - you know if you know me and you know
36:22 - this package then you know i'm not very
36:23 - objective and that's because well i
36:26 - wrote this package but
36:28 - it really gives you some functionality
36:29 - that doesn't exist in other packages so
36:32 - let's get familiar with it
36:35 - i actually made a video about the two
36:37 - main approaches for flow control so if
36:40 - you're curious to see exceptions for
36:42 - flow control against this kind of
36:44 - approach then make sure to check it out
36:46 - we look at multiple open source
36:48 - libraries and you can see what's right
36:50 - for your application okay so inside the
36:52 - blue breakfast folder let's create a new
36:54 - folder it's called service errors
36:56 - and over here let's create a new file
36:58 - let's call it
36:59 - errors.breakfast
37:01 - dot cs
37:02 - and what we'll have over here is a
37:04 - public static class
37:06 - errors and inside here a public style
37:08 - class
37:10 - breakfast
37:12 - and in here we'll define all the areas
37:14 - that we expect to have in our system
37:16 - that are related to the breakfast
37:18 - resource
37:19 - now over here an era that we're
37:20 - expecting to have is a breakfast that
37:22 - doesn't exist so let's go ahead and
37:24 - represent that error
37:26 - so public static
37:28 - error
37:29 - not found
37:31 - now if we look at this error object then
37:33 - we can see it comes from that error or
37:36 - package
37:37 - and what this is so it's a simple struct
37:40 - which has inside three things it has a
37:42 - code which is unique to the error that
37:44 - occurred
37:45 - it has a description which is a human
37:47 - readable description of what happened
37:49 - and it has an error type
37:51 - what is this error type it's a simple
37:53 - enum which has inside failure which is
37:55 - the default value and some other errors
37:58 - which are common in any system right so
38:00 - in our case we have something that
38:02 - wasn't found so let's go ahead and use
38:05 - this one
38:06 - so the way this works you can do error
38:08 - dot and over here you can use each one
38:10 - of these methods to create the
38:12 - corresponding error object plus you can
38:14 - also use some custom integer value if
38:17 - you prefer
38:18 - so in our case we want not sound
38:21 - and what you give it over here is the
38:23 - unique code so for example
38:26 - breakfast
38:27 - dot not found right so this is the code
38:31 - for the description
38:33 - let's say
38:34 - yeah something like this
38:37 - then back in our breakfast service this
38:40 - returns either an error or the breakfast
38:44 - okay now this arrow or object comes from
38:46 - the error or namespace yeah let's update
38:48 - our implementation as well and see how
38:50 - we'll use it so error or
38:53 - breakfast
38:54 - let's include the namespace
38:56 - and what we can simply do now
38:59 - try to retrieve the breakfast so try get
39:02 - value that corresponds to the id
39:05 - inside
39:06 - this variable
39:07 - if this succeeded then simply return the
39:10 - breakfast
39:11 - otherwise we want to return an error in
39:13 - our case yes exactly this let's just
39:16 - include the namespace
39:20 - and if you're asking yourself how these
39:21 - two become this arrow or object then
39:24 - inside the arrow or object you can see
39:26 - we have two implicit converters one that
39:30 - gets the value in our case the breakfast
39:32 - and converts it to an error or object
39:34 - and the other one gets an error and
39:36 - converts it to the error or object okay
39:38 - so that's how it works behind the scenes
39:41 - then back in our controller
39:43 - then when
39:45 - we're getting the breakfast this no
39:47 - longer returns breakfast but it returns
39:49 - an error
39:50 - or the breakfast
39:53 - right this is no longer a breakfast but
39:55 - it's the get breakfast result
39:58 - okay now this may contain the breakfast
40:00 - but it also may contain the error so
40:02 - over here we want to branch out
40:04 - depending on what we have so we can say
40:06 - if the get breakfast result
40:09 - is an error
40:10 - and
40:12 - yes similar to this let's accept it and
40:14 - understand why this doesn't work so back
40:16 - in the error or object this actually
40:18 - contains either the value or a list of
40:20 - errors so you're not limited to store
40:22 - only one error so back over here
40:25 - we can access it using the first error
40:28 - property
40:29 - then if the first error is not found
40:31 - then we want to return not found
40:34 - wise we know we have the breakfast in
40:36 - our hand so we can say breakfast
40:38 - equals
40:39 - yes the get breakfast result dot value
40:42 - so this will simply return the breakfast
40:44 - that we returned we can map it to the
40:46 - response and return it same as we did
40:49 - before so let's run this and make sure
40:51 - that it works
40:53 - okay so we're making a get request and
40:55 - since we don't have any object then we
40:58 - get not found
40:59 - as we want but if we first create it and
41:02 - we take
41:04 - the id and use it to retrieve then we
41:08 - see we get the response as we expect
41:10 - okay so back in the breakfast controller
41:13 - you may be looking at the method that we
41:15 - implemented and you're thinking to
41:17 - yourself that this is a much less
41:19 - readable than what we had before after
41:21 - all we can simply throw an exception
41:24 - from the breakfast service
41:25 - and catch it over here in the airs
41:27 - controller and then our controller can
41:29 - stay like it was before so you are right
41:31 - let's see how we can make this a bit
41:33 - more concise first of all let's extract
41:35 - this mapping logic to a method so
41:38 - extract method
41:40 - and let's give it the name
41:43 - map
41:44 - breakfast response
41:46 - and i want us to get familiar with the
41:47 - following capability of the error or
41:50 - object so for now let me comment out
41:52 - all these lines
41:54 - and see how we can use the match method
41:56 - so what we're able to do is say return
41:59 - get breakfast result dot match
42:02 - so as you can see the match method
42:04 - receives two functions one that will run
42:06 - if what we have is the value in our case
42:08 - the breakfast and another one that will
42:10 - run if what we have is an error so let's
42:12 - see how we can use it
42:14 - let's define the first function
42:16 - we have a breakfast if we got the
42:18 - breakfast then we simply want to map it
42:21 - using the method that we just defined so
42:23 - map breakfast response and that's it the
42:26 - breakfast
42:27 - and if we have an error so this is the
42:29 - list of errors what we can do is handle
42:32 - it over here for now let's just return
42:34 - here a problem
42:36 - and see how this behaves
42:38 - so let's run the application again
42:41 - and we try to make the get breakfast
42:43 - request then we can see that it
42:44 - correctly invoked
42:46 - the problem method
42:48 - okay so i want to go back to the
42:50 - breakfast controller so currently we're
42:52 - checking if the first error is
42:54 - specifically one of the service errors
42:56 - but actually what we can do is we can
42:58 - take the type of the error and according
43:01 - to the type return the appropriate
43:02 - response to the client so if you
43:04 - remember back over here the type of
43:06 - error error is not found so we don't
43:08 - need to do something that's very
43:09 - specific for this error but rather we
43:11 - can do something that's a bit more
43:13 - general so for that what we'll do i'll
43:15 - delete all the logic over here
43:18 - and i want us to implement our own
43:20 - problem method so for that i'm going to
43:22 - go over here and create here a new
43:24 - controller which will be the base
43:26 - controller of the other controllers
43:27 - that's called api controller
43:30 - so over here we'll have a public class
43:32 - api controller which yes we'll inherit
43:35 - from the controller base
43:39 - and as we said this will be the base
43:40 - controller for the other controllers so
43:42 - let's go ahead and start inheriting from
43:45 - the controller base over here instead
43:47 - let's inherit from the api controller
43:50 - and because these are attributes which
43:51 - we can expect on any one of our
43:53 - controllers let's move them to our base
43:56 - controller
43:57 - and over here like we said we'll have
43:58 - our own problem implementation which
44:00 - will receive a list of errors and return
44:03 - the appropriate response so the way this
44:04 - will look is protected by action
44:07 - problem which will receive the list of
44:10 - errors
44:12 - and for now let's have your something
44:14 - simple so let's say our first error
44:16 - equals
44:18 - the first error
44:20 - yes and over here we can say that the
44:23 - status quo depends on the type of the
44:25 - first error
44:26 - so we can say
44:28 - type
44:29 - which
44:31 - and over here
44:32 - yes something like this so we can say if
44:34 - it's not found then
44:36 - status codes dot not found if it's
44:40 - validation
44:41 - then we want
44:43 - 400
44:44 - otherwise let's return here internal
44:46 - server error and we also have here
44:49 - conflict so let's go ahead and use that
44:51 - as well so conflict will be
44:54 - conflict exactly
44:56 - and over here let's return a problem
44:58 - where the status code is the status code
45:00 - and the title
45:02 - is the description of the first error
45:04 - right
45:06 - as so let me just close the terminal
45:08 - okay so all we have at the moment is our
45:11 - own base controller implementation which
45:13 - the other controllers will inherit from
45:16 - and what we'll do from now on is in the
45:18 - controllers when we end up with a list
45:20 - of errors then we'll call our own
45:22 - problem method which currently all we're
45:24 - doing is taking the first error using
45:26 - the type to compute the correct status
45:28 - code and then we're using the problem
45:30 - method from the controller base to
45:33 - return the status code and the
45:34 - description of the first error okay so
45:37 - now that we have this defined
45:39 - back in the get breakfast method then
45:41 - what we can do over here is pass the
45:43 - list of errors
45:44 - to the problem method so now this
45:46 - problem method is the one that we
45:48 - implemented in our base controller and
45:51 - that's it let's make sure that this
45:52 - works so start the program run it again
45:56 - and now when we try to do it for your
45:57 - breakfast that doesn't exist then we can
46:00 - see we get here
46:01 - the description of the first error and
46:04 - we successfully converted the error type
46:06 - to the correct http status code
46:09 - great so back in the controller again
46:10 - all we're doing is calling the breakfast
46:12 - service receiving an error or the
46:15 - breakfast if it's the breakfast then
46:17 - we're mapping it to the correct response
46:19 - and returning it to the client otherwise
46:22 - we're using here our custom problem
46:23 - method which converts the list of errors
46:26 - to the appropriate response great let's
46:28 - go ahead and do the same for the rest of
46:30 - the methods in the breakfast service all
46:33 - right so this will be error or
46:36 - created this created also comes from the
46:37 - arrow or library for the observed let's
46:40 - say here or updated
46:43 - and for the delete let's say air or
46:45 - deleted
46:47 - then back in the implementation
46:51 - let's update this so this is error or
46:53 - rated this simply returns
46:57 - result.created
46:59 - again this comes from the arrow or
47:01 - library in the delete
47:03 - then it's air or
47:05 - deleted
47:07 - and let's copy this
47:08 - paste it in the delete method and change
47:10 - this
47:11 - to delete it
47:14 - and lastly we have the observed
47:18 - so we have this here or
47:22 - updated
47:25 - and we can return here
47:28 - result dot updated
47:30 - okay now one of the reasons that i
47:32 - really like this approach is because as
47:34 - the application grows and we have more
47:36 - and more errors then all the errors are
47:38 - neatly organized over here
47:40 - and over here in each method it's very
47:42 - clear to see what happens in the good
47:44 - flow and what happens in the bad flow
47:47 - here let's update the controller as well
47:50 - so over here we get
47:53 - the
47:54 - create
47:55 - breakfast result
47:57 - which is
47:58 - error or created
48:00 - first of all we can get rid of this
48:01 - entire thing
48:03 - instead use the map method that we
48:04 - created right so this will be breakfast
48:07 - and then for now we can say if great
48:10 - breakfast result is error
48:12 - then we want to return
48:14 - problem and pass the errors to the base
48:17 - controller
48:18 - otherwise we want to return the same
48:20 - response
48:22 - and then let's just move this to the
48:24 - bottom so it's more organized
48:28 - then let's start with the delete so this
48:30 - returns the
48:31 - delete
48:32 - result which is error or deleted
48:36 - then over here we can say
48:38 - yes actually
48:40 - right so if it deleted then we want to
48:42 - return no content otherwise if there's
48:44 - an error then we want to return the
48:46 - appropriate response
48:49 - and lastly the upsert so over here if
48:52 - you remember we want to return 201 if a
48:55 - new breakfast was created
48:57 - okay so it would be nice if the upper
48:58 - breakfast method could somehow tell us
49:01 - if it created a new breakfast or not so
49:04 - to do this what we can do actually is go
49:06 - over here
49:07 - and instead of returning error or
49:10 - updated which comes from the arrow or
49:12 - package we can create our own response
49:15 - model let's say something like abserted
49:19 - breakfast result
49:21 - and this could be whatever we want so
49:23 - for example public record struct
49:27 - upstarted breakfast
49:29 - and here we can have whatever extra
49:30 - details that we want so for example
49:33 - is
49:34 - newly created
49:36 - which will indicate if we created a new
49:38 - breakfast or not
49:39 - and then over here we can say
49:42 - bar is newly created
49:45 - equals yes right so if the breakfast
49:48 - dictionary doesn't contain the given id
49:50 - then we're creating a new one
49:52 - then what we still have left to do
49:54 - is update the method definition
49:56 - so this will be absurd breakfast both
49:59 - here
50:00 - and here
50:02 - then
50:04 - we can return here
50:06 - a new upstarted breakfast
50:08 - and pass it the is newly created value
50:12 - then back in the controller
50:15 - this returns the absurd result
50:21 - and over here we want to return 201 if a
50:23 - new breakfast was created
50:25 - so because we have the same thing over
50:27 - here let's extract this twee method
50:31 - let's call it something like created at
50:34 - get breakfast
50:36 - let's fix the indentation
50:38 - and move it to the bottom
50:42 - okay back in the offset method what we
50:44 - can do now
50:46 - is basically
50:47 - absolute result dot match
50:51 - yes almost
50:53 - so if it upset it then what we want to
50:55 - do is check if it was newly created
50:58 - if yes we want to return
51:00 - created at let's fix the typo
51:05 - get breakfast
51:06 - otherwise we want to turn
51:08 - no content lastly let's just align the
51:10 - variable names so this is observed
51:13 - breakfast result and over here
51:16 - it's
51:18 - delete breakfast result
51:22 - okay so that seems about right we can
51:24 - actually make the create breakfast a bit
51:26 - more concise so we can replace this
51:29 - entire thing
51:30 - with
51:32 - create breakfast results
51:35 - and we can match
51:36 - on the result
51:37 - and say if it was created
51:39 - then
51:40 - we can return the created at get
51:43 - breakfast and pass it the breakfast
51:47 - otherwise we can use the problem method
51:50 - and pass it the errors
51:52 - okay so just to recap
51:54 - all the errors that we expect in our
51:56 - system sit over here and we have them
51:59 - well defined with a unique error code
52:02 - and a descriptive description
52:04 - then in our i breakfast service then we
52:07 - define for each one of the methods that
52:09 - they can either return the expected
52:11 - result or an error now because we aren't
52:13 - really expecting any error in some of
52:16 - these methods then we could have simply
52:17 - replaced it with void but i just wanted
52:20 - to demonstrate another capability that
52:22 - might be relevant in your application
52:25 - then lastly in our controller then we
52:28 - get the response
52:29 - and we return the appropriate response
52:31 - to the client
52:32 - based on whatever result we received
52:36 - great let's run the project and make
52:37 - sure that everything still works as we
52:39 - expect
52:41 - so we create a new dinner
52:43 - we get here the response that we expect
52:46 - let's take the id
52:48 - and use it
52:49 - to retrieve it
52:52 - great this also works as we expect
52:55 - let's try updating it
52:59 - so we get no content which is good it
53:01 - means a new resource wasn't created
53:04 - let's try deleting the breakfast and we
53:07 - get no content again which means that it
53:09 - was deleted successfully so now when we
53:12 - try to get it again then we get 404 not
53:14 - found
53:15 - and if we do upsert then because it
53:17 - doesn't exist we expect it to create a
53:19 - new dinner so let's try
53:21 - and we see we didn't get no content but
53:24 - rather we got 201 created
53:26 - with a new resource and the given id
53:28 - that we specified
53:31 - great let's make sure that this was
53:32 - stored in the database so let's try to
53:33 - retrieve it and we can see that it was
53:35 - stored in our in-memory database as we
53:38 - expect
53:39 - now let's move on to the final part of
53:41 - this video which is enforcing our
53:43 - business rules on our internal service
53:45 - models so if you remember over here when
53:47 - we create the breakfast then there are
53:49 - some rules that we might want to enforce
53:51 - on the data that we're receiving so at
53:54 - the moment the client can call us with
53:55 - whatever information they want and we'll
53:57 - simply store it and also the controller
54:00 - can put whatever value they want over
54:01 - here in the last modified date time and
54:04 - will simply store it as is it would be
54:06 - nice if we can simply take the data and
54:08 - say okay here's breakfast if everything
54:10 - was valid and it adheres to the rules
54:13 - that the business defines
54:15 - otherwise here's a list of well-defined
54:17 - errors
54:19 - okay so let's see how we can do that so
54:21 - over here let's create a static factory
54:23 - method and this will look as following
54:25 - so public static this will turn an error
54:29 - or a breakfast
54:31 - and let's call this create
54:34 - let's just include the arrow or
54:36 - namespace
54:39 - okay the way this will work is that
54:40 - we'll change the constructor to private
54:43 - but we're the only ones that can call it
54:46 - over here we'll receive the various
54:48 - details so
54:50 - yes this seems right let's just inline
54:54 - this
54:56 - and now instead of enforcing our logic
54:58 - over here we can go ahead and enforce it
55:02 - over here
55:03 - so the way this could look
55:06 - so let's say for example the name needs
55:08 - to be between 3 and 50 characters and
55:11 - the description needs to be between 50
55:13 - and 150 characters okay now i'm giving
55:15 - this as an example but something you
55:17 - might actually want to do is make sure
55:19 - that the start and end time are actually
55:21 - values that make sense for a breakfast
55:24 - and the start date time is in the future
55:27 - okay so let's look at how something like
55:28 - this can be implemented so for example
55:31 - public
55:32 - constant min
55:34 - name length
55:36 - now let's have a three
55:38 - and let's have
55:39 - the max name length
55:41 - we said 50
55:44 - and let's have the same thing
55:46 - for the description so let's change name
55:48 - to description
55:52 - let's change three
55:54 - to 50
55:55 - and
55:56 - the maximum
55:58 - to 150.
56:00 - then over here on the create method then
56:01 - we can say okay if the length
56:04 - of the name
56:06 - is less than
56:08 - the
56:08 - minimum length
56:11 - or greater than
56:13 - the maximum length then over here we can
56:16 - return an error that represents that the
56:19 - name isn't valid
56:20 - so for example let me just close
56:22 - everything so it's more organized
56:24 - we can go to our service errors to the
56:25 - breakfast
56:26 - and create here
56:28 - some
56:29 - validation error
56:32 - let's call it
56:33 - invalid name
56:34 - dot
56:36 - invalid name
56:38 - and over here we can say that the
56:39 - breakfast name
56:42 - must be at least
56:46 - yes it seems
56:48 - right
56:49 - let's just update this too
56:51 - models not breakfast
56:53 - dot min name length
56:56 - both over here
56:58 - and over here
57:00 - and
57:01 - let's wrap the line
57:06 - great then over here we can simply
57:07 - return
57:08 - errors
57:09 - dot breakfast dot
57:11 - invalid name
57:14 - and we can have similar logic for that
57:17 - description
57:18 - so let's change
57:21 - name to
57:24 - description and here as well
57:29 - and let's add the appropriate
57:32 - error over here
57:34 - and
57:34 - here let's change
57:36 - everything to description as well and
57:39 - this should be also description
57:43 - and now this should work great and we
57:45 - can actually make this a bit better if
57:47 - you remember we said that internally we
57:49 - have here a list of errors so we don't
57:51 - actually have to return only one of
57:53 - these errors we can actually return all
57:55 - of them so what we can do we can create
57:58 - here
57:58 - a list of errors
58:03 - and over here
58:04 - simply edit
58:07 - like so
58:09 - and same thing over here so errors dot
58:12 - add
58:14 - and add the appropriate error
58:17 - and in the end we can yes if there are
58:19 - any errors
58:23 - then let's simply return
58:25 - the list of errors
58:28 - okay so similar to the other implicit
58:30 - converters there's also an implicit
58:31 - converter that takes a list of errors
58:34 - and returns an error or object
58:37 - okay back in the controller
58:40 - breakfast dot create
58:42 - and we no longer need to pass it this
58:44 - and this since it's generated inside
58:47 - we can call this request to breakfast
58:50 - result
58:52 - which is either the error or breakfast
58:55 - then we can say
58:57 - if this thing is an error then
58:59 - we want to return
59:02 - a problem
59:04 - otherwise we know we have a breakfast in
59:06 - our hand and we can simply extract the
59:08 - breakfast from the arrow or object and
59:11 - use it like we did before
59:13 - okay same thing over here in the upsort
59:16 - so here we would have breakfast
59:19 - dot create
59:20 - we would remove this
59:23 - but we do want the option to pass the id
59:26 - so let's create here an optional field
59:28 - with id
59:30 - and back over here let's just move the
59:32 - id
59:33 - to the end
59:35 - and same over here so this will be
59:38 - request to breakfast result
59:44 - and over here we can say
59:46 - if it's an error then return
59:49 - the errors
59:51 - otherwise let's take the breakfast and
59:53 - we continue like we did before
59:55 - then over here in the create method
59:57 - let's generate a new id only if an id
60:00 - wasn't specified
60:02 - and that's it for now so just to recap
60:04 - what we have
60:06 - we changed the constructor to be private
60:09 - so no one can create a breakfast other
60:11 - than using the create static factory
60:13 - method
60:15 - then over here we can enforce whatever
60:17 - business rules that we have that have to
60:19 - do with the breakfast object okay so
60:22 - we're encapsulating logic that has to do
60:24 - with a breakfast inside the breakfast
60:26 - object
60:28 - finally we're turning either the
60:29 - breakfast or a list of errors to the
60:32 - controller
60:33 - which it's the controller's
60:34 - responsibility to make sure that what he
60:36 - has
60:37 - is a valid value
60:39 - now back over here
60:41 - we would simply return the first error
60:43 - and that's a shame because we know we
60:45 - have here a list of errors with details
60:47 - that are very relevant to the client to
60:49 - know how to fix his request so instead
60:51 - let's check if everything that we have
60:53 - in this list of errors are validation
60:55 - errors so we can say if
60:58 - errors
61:01 - that all
61:02 - and
61:03 - the type of all of them is
61:07 - validation
61:09 - then what we want to do is we return a
61:11 - validation problem so the controller
61:13 - base has another method which is called
61:15 - validation problem
61:17 - which if we give it a model state
61:19 - dictionary we'll convert it to a
61:22 - beautiful error response which contains
61:24 - all the details so let's see what this
61:26 - looks like so we want to create here a
61:28 - model state dictionary
61:33 - and to this model state dictionary we
61:34 - want to add all the errors that occurred
61:37 - so the way we can do this
61:39 - is
61:40 - yes exactly
61:42 - right so we're simply iterating through
61:43 - the errors and adding a dictionary entry
61:46 - with the error code and the description
61:50 - and then we need to pass it to the
61:52 - validation problem method
61:54 - as so
61:55 - and that's it right so we're basically
61:58 - saying if all we have
62:00 - are validation problems then let's
62:02 - return
62:03 - bad requests with all the details
62:06 - and this will return a standard response
62:09 - otherwise let's take the first error and
62:12 - return
62:12 - the appropriate response
62:15 - you know we can actually make it a bit
62:16 - better so let's imagine that five errors
62:18 - occurred
62:19 - if even one of them is an unexpected
62:21 - error then we can't really trust any of
62:23 - the other errors so we can add
62:26 - some logic that says
62:28 - if
62:29 - there's any error
62:31 - where
62:33 - the error type
62:35 - is
62:37 - unexpected
62:38 - then we want to return
62:41 - 500 internal server error okay let's run
62:44 - our project and make sure that it
62:45 - behaves as we expect
62:47 - let's first look at the good flow so
62:49 - creating a new breakfast works as we
62:51 - expect
62:52 - let's try retrieving it
62:57 - works as we expect as well let's try
63:00 - updating something
63:02 - we get no content so let's try
63:04 - retrieving it again
63:05 - we can see that we got the updated value
63:10 - lastly let's try deleting it
63:12 - and we get no content so when we try
63:14 - getting it now then great we get not
63:17 - found if we try to upset it
63:19 - then we can see
63:21 - it was created as we expect
63:24 - now i want us to test the error flow
63:27 - let's put here some details that are
63:30 - invalid
63:32 - and try to make the request
63:34 - and we can see we got
63:36 - bed requests
63:38 - with descriptive errors of what happened
63:41 - let's just fix
63:42 - the space that we're missing so back in
63:45 - the errors
63:46 - let's add a space both here
63:48 - and here you know back in our breakfast
63:50 - controller we can actually add another
63:52 - static factory method
63:54 - which knows how to take the
63:56 - request and return the same result so
64:00 - let's see what something like this would
64:01 - look like
64:02 - so back in the breakfast object
64:04 - similar to the create gonna have here a
64:07 - public static
64:08 - error or
64:10 - breakfast
64:11 - which receives
64:13 - the
64:15 - create breakfast requests
64:18 - and simply calls the create method
64:20 - like we did in the controller
64:24 - and we can do the same thing in the
64:25 - observe method as well so over here
64:28 - let's do from
64:29 - let's replace this entire thing with the
64:32 - id
64:33 - and the request
64:35 - and let's add here another static
64:37 - factory method
64:38 - which knows how to take
64:40 - the id
64:42 - and the officer breakfast request
64:44 - and similarly
64:46 - you'll call it with the details and the
64:48 - id
64:49 - and will return
64:51 - an error or the breakfast right we can
64:54 - remove this comment
64:56 - you know if you're looking at this over
64:58 - here and you're thinking
64:59 - this is much less readable than what we
65:02 - had in the beginning and if we simply
65:04 - threw exceptions both for the breakfast
65:06 - object and for the breakfast service
65:08 - then you are right we are paying here a
65:10 - price of readability but i want you to
65:12 - remember that as the application grows
65:14 - over here we currently have one
65:16 - controller and one service but as the
65:19 - application grows we'll probably end up
65:20 - having many services many controllers
65:23 - and more logic down the road and
65:25 - throwing exceptions makes it hard to
65:27 - understand what the error flows in your
65:29 - application are and what errors can
65:31 - occur so personally even though this
65:33 - approach can take a few minutes to get
65:35 - used to
65:36 - what you gain is that you have your
65:38 - errors well-defined
65:40 - and as you're developing the application
65:42 - you're mindful of the scenarios that
65:44 - might occur okay so that's it for this
65:47 - video i really hope you had a good time
65:49 - and you have a better understanding of
65:51 - how to build a crud based rest api
65:54 - completely from scratch i cover topics
65:56 - that are a bit more advanced in my
65:58 - channel so if this wasn't freeing and
66:00 - you enjoyed it make sure to check it out
66:02 - and i'll see you in the next one