00:00 - learn the fundamentals of nestjs by
00:02 - building the back end of a Spotify clone
00:05 - nestjs is a framework for building
00:07 - efficient scalable node.js web
00:10 - applications you'll learn how to design
00:12 - a database create rest apis and deploy
00:14 - the apis to production how did Alie
00:17 - develop this
00:18 - course welcome to my course
00:22 - nestjs let's talk about what is
00:25 - nestjs nestjs is used to build server
00:29 - side application in node.js it is built
00:32 - on the top of node.js
00:34 - expressjs and
00:37 - typescript the major difference between
00:40 - nestjs and other nodejs framework is
00:44 - this framework is using
00:46 - typescript and it is using the angular
00:50 - architecture angular Concepts on the
00:54 - pack if you familiar with angular
00:57 - concept you can work with nestjs is very
01:00 - easily why they are using the angular
01:03 - concept because if you use the angular
01:08 - architecture Concept in the back end you
01:11 - can organize your project in a easy way
01:16 - the development would be
01:18 - easy the contribution for other
01:20 - developers would be easy in
01:23 - sjs look at the
01:26 - documentation you will find the
01:28 - controllers providers modules middleware
01:32 - exception filter pipes guards inter
01:35 - interceptors and custom decorators all
01:37 - of these are Concepts in
01:40 - angular why they created nests if you
01:43 - have worked with Express you don't have
01:47 - any structure like you don't have any
01:50 - best practice to organize the backend
01:53 - project so they created the structure
01:57 - architecture level they designed the
01:59 - architecture to build server side
02:02 - applications in nodejs and
02:05 - typescript under the it is using
02:08 - expressjs and
02:14 - typescript so they are just solving the
02:17 - architecture problem when you build the
02:20 - large application in nodejs we backend
02:23 - web application in
02:25 - nodejs when your code base is increasing
02:28 - day by day it's hard to follow specific
02:32 - architecture that's why they have
02:35 - created the
02:37 - nestjs if you follow the nests you will
02:39 - see hey we need a controller we need a
02:41 - provider we need modules we can break
02:44 - application into multiple modules we
02:46 - need a middleware we need exception
02:48 - filters so this is how you can architect
02:51 - your backend
02:53 - application this is exciting project I'm
02:56 - going to share you all of these Concepts
02:58 - in this course
03:02 - let's create a new project in
03:05 - njs first of all you need to install ljs
03:09 - globally on your machine I'm going to
03:11 - install nestjs CLI this this command
03:15 - will help us to generate nests
03:20 - project my CLI has installed now we need
03:25 - to create a new project you can use this
03:27 - command Nest new the name of the project
03:31 - you can choose any name
03:37 - here I just use in fundamentals dpro I'm
03:41 - going to use
03:42 - [Music]
03:45 - npm now it is going to it's going to
03:47 - install all of these packages for
03:50 - me now my project has created
03:54 - successfully so I'm going to navigate to
03:57 - my project
03:58 - directory this is end fundamentals Das
04:02 - Pro now I'm going to open that into my
04:05 - code editor I'm going to use vs
04:11 - code so when you open the package.json
04:14 - file you can run your project in
04:17 - development mode by using this command
04:21 - npm start
04:22 - Dev npm Run
04:25 - start
04:28 - D
04:31 - you can see my project has started
04:34 - successfully uh by default njs uses 3000
04:39 - Port you can verify that from the main.
04:42 - file I'm going to go to the Local Host
04:45 - call in
04:46 - 3000 let's see what will
04:52 - happen you can see Hello
04:55 - World so our project is running fine now
05:00 - in the app controller you will have a
05:02 - simple message the simple controller
05:05 - method it's a route get
05:08 - hello and you will see the hello world
05:12 - here hello world or you can say hello
05:16 - I'm learning
05:19 - nestjs I saved the application it has
05:21 - reloaded
05:23 - successfully let me send the request
05:25 - again you will see hello I'm learning
05:28 - njs
05:31 - so this is our source folder you will
05:35 - place all of your Source folder source
05:38 - code inside the source folder this is
05:40 - our main.ts file when you run this
05:44 - command npm run Start Da njs is going to
05:48 - call this bootstrap function and inside
05:52 - the bootstrap we have a factory function
05:55 - and we are initializing the app module
05:57 - this is our root module in here we have
06:00 - set the port we have the service we have
06:03 - module controller and the test file for
06:06 - a controller this is our module remember
06:09 - this is the angular structure and each
06:12 - module is consist each module consist of
06:15 - controllers services and providers you
06:19 - can import multiple modules here we have
06:23 - the
06:23 - [Music]
06:25 - service and uh you will place all of
06:28 - your spec file inside the test end to
06:30 - end test should be uh saved here and
06:34 - unit testing you unit testing files will
06:37 - be located here this is eslint RC rules
06:41 - for eslint prettier
06:44 - n if you want to customize the nest C
06:48 - nestjs project you will do inside the
06:50 - nest CLI we have package.json file we
06:54 - have TS config and TS config build this
06:57 - is used for typescript configurations
07:01 - let's talk about the concept of module
07:04 - in
07:06 - njs in njs each module is consist of
07:11 - providers controllers imports and
07:15 - exports so this is the building block of
07:18 - nestjs application you can read my notes
07:21 - I have provided you the PDF
07:24 - documentation nest in providers nestjs
07:27 - are classes that act as a Services
07:30 - factories or
07:32 - repositories if you have worked with
07:34 - angular you know the
07:37 - providers so you can encapsulate your
07:40 - business logic and it can be injected
07:43 - into controller or other
07:46 - services so controller serve as the
07:49 - function of handling HTTP request
07:52 - whenever you create a new endpoint you
07:55 - will register it inside the
07:58 - controller I'll teach you more about
08:00 - controllers in the next video Imports is
08:04 - an array specify the external modules
08:07 - needed for the current module you can
08:10 - import other module let's say you have
08:13 - break down your application e-commerce
08:16 - application into multiple modules you
08:19 - have post module you have products
08:21 - module you have ERS module you have
08:24 - users module let's say a user module can
08:29 - use
08:30 - the product module this is how you think
08:33 - in terms of modules if you want to
08:36 - export you can also export controllers
08:40 - and services from the current
08:43 - modules so each nestjs application will
08:47 - have a root module just like in angular
08:50 - root module serve as the entry point and
08:53 - is responsible for instantiating
08:55 - controllers providers and other core
08:58 - elements
09:00 - nextjs follow the module isolation
09:03 - principle ensuring that application is
09:07 - organized into distinct functional or
09:09 - feature based modules so you will have
09:12 - root module app module let me check the
09:16 - application you will have the app module
09:19 - you can see that you have Imports array
09:23 - this module has app controller and app
09:28 - service let's say we're going to build a
09:32 - back end of Spotify application we can
09:35 - divide our application into multiple
09:37 - modules you will have a root module and
09:41 - I'll have the artist which is feature
09:43 - module and we will have songs module to
09:47 - handle the songs functionality we have o
09:50 - module to handle authentication these
09:52 - three are all the feature
09:56 - modules SS modules are a functional
10:00 - organizational unit that follow the
10:03 - modularization principle it helps to do
10:07 - code free usability and separation of
10:09 - concerns principle under the hood they
10:12 - have implemented the principle design
10:15 - pattern to organize your code that's it
10:19 - let's create a new module I'm going to
10:22 - create a song
10:24 - module you can use CLI Nest G4 generate
10:29 - in the name of the module which is the
10:32 - module keyword I want to generate the SS
10:35 - module here you can provide any name I'm
10:38 - I'm interested in the songs module so
10:41 - you can see in the app. module it has
10:45 - added the entry automatically for you in
10:49 - the Imports array and you can see you
10:52 - have a songs module that's it so this
10:56 - songs module will have controllers
11:00 - providers and imports and exports
11:06 - array controllers are responsible for
11:10 - handling incoming request and sending
11:13 - response back to the client we are
11:16 - building the Spotify clone
11:18 - application let's imagine or let's say
11:21 - you want to fetch all the songs or you
11:24 - want to see all the songs of Martin gck
11:27 - artist your browser will send the find
11:31 - all songs request to the nestjs
11:34 - application inside the nestjs
11:37 - application you will have songs
11:40 - controller inside the songs controller
11:43 - you can see we have find all
11:47 - method the find all method will be
11:50 - called and this method will fetch the
11:54 - songs record from the
11:57 - database and send respon response back
12:00 - to the
12:01 - client similarly you can send the same
12:03 - request from your mobile application so
12:07 - controller will be responsible for
12:09 - handling request and sending response
12:12 - back to the
12:15 - client you can create a controller very
12:18 - easily all you need to do is
12:21 - controller
12:23 - decorator and inside The Decorator you
12:25 - can provide the prefix route prefix
12:32 - if you want to define the request
12:34 - Handler inside the controller you have
12:37 - to use the HTTP get decorator if you
12:40 - want to create the post endpoint you
12:42 - have to use the post
12:44 - decorator it's just returning a simple
12:46 - string message fetch all the songs and
12:50 - this method will be converted into this
12:51 - API
12:53 - endpoint Local Host callon 3000 /
12:58 - songs
12:59 - we are going to build these API
13:03 - endpoints to fetch all the
13:06 - songs to fetch a single song I created
13:10 - these routes to create a new song to
13:14 - update a song on the based on ID and
13:18 - delete a song on the based on
13:20 - [Music]
13:21 - ID I'm using the rest client extension
13:24 - to send the API calls it is similar to
13:28 - The Post
13:30 - men if you don't have rest client you
13:32 - can find from the vs code extensions and
13:35 - find the rest client the rest client
13:38 - package is saying You must have a file
13:40 - with
13:42 - HTTP I created the HTTP
13:48 - extension now my application is running
13:51 - at Port 3000 my development project is
13:54 - running at 30001 you should not aware
13:57 - you should not care about this project
13:59 - we are building project on Port
14:02 - 3000 if I send the request to fetch all
14:05 - the songs we don't have any rout yet it
14:08 - is giving me the warning message or
14:10 - error 44 you don't have all these end
14:13 - points I want you to accept the
14:16 - challenge and start building these end
14:21 - points we don't have any
14:24 - controller let's stop the
14:28 - application and I'm going to create a
14:30 - controller
14:40 - songs you can see that songs controller
14:43 - has created inside the songs
14:47 - folder we have spec file testing file
14:50 - and controller. TS file this is the
14:53 - controller decorator this is the
14:55 - prefix one more thing it has added the
14:58 - end entry in the controllers
15:05 - array now let's create the request
15:09 - Handler first of all I'm going to
15:11 - implement the
15:17 - get find
15:19 - all it is going to return a simple
15:24 - message find all
15:27 - songs
15:30 - let's restart or run the
15:36 - application you can see that our
15:38 - application is running
15:40 - now let's fetch all the songs I got find
15:44 - all the
15:45 - songs find all songs endpoint it means
15:49 - we successfully created the route to
15:51 - fetch all the
15:57 - songs now now I can send the
16:01 - request to fetch the songs watch all
16:04 - songs end
16:09 - point let's create a
16:13 - single
16:15 - song endp
16:18 - point you have to use the ID as a
16:21 - dynamic
16:25 - parameter I can say find
16:27 - one
16:29 - here I can
16:31 - say fetch song on the based on
16:38 - ID similarly we
16:41 - need update put for update I'm going to
16:46 - use the put HTTP
16:49 - verb
16:52 - update update song on the based on ID we
16:55 - also need
16:57 - delete
17:07 - I can get the delete from
17:10 - here let me replace the update to
17:15 - delete delete song on the based on ID
17:18 - and finally we need a post
17:21 - endpoint to create a new
17:24 - song I can say the
17:27 - post
17:31 - create create a new
17:37 - song so we created the CED API end
17:43 - points now it's time to send all the
17:47 - request it's working fine now create a
17:50 - new song endpoint update song on the
17:53 - based on ID delete song on the based on
17:57 - ID
18:02 - now you got the basic understanding of
18:04 - controller and how to create route in
18:07 - njs
18:09 - application let's talk about Services
18:12 - services are providers it means you can
18:16 - inject into another class it will be
18:20 - treated as a
18:22 - dependency we will have a
18:25 - service and the service is responsible
18:28 - for fetching data from the database and
18:32 - saving data to the
18:35 - database if you have to interact with
18:39 - database you have to write the source
18:42 - code inside the service you will create
18:44 - a method to interact with
18:46 - database we will use repositories don't
18:51 - worry and this service can be injected
18:54 - into controllers if you have multiple
18:57 - controllers into module you can inject
19:00 - the same service into that controller or
19:03 - multiple controllers you can also export
19:07 - the service from a current module and
19:10 - you can use that service into another
19:15 - module we will have the song service
19:18 - it's nothing more it's just a class and
19:21 - all you need to do is to injectable
19:23 - decorator it means you can inject as a
19:26 - dependency into another class
19:30 - this is how you will inject the service
19:33 - into controller or into a class you have
19:36 - to inject it in the Constructor it will
19:40 - be treated as a dependency for the songs
19:42 - controller now the songs controller is
19:45 - dependent on song controller is
19:48 - dependent on the song
19:56 - service let's create a new service
20:01 - I'm going to use n CLI to generate a
20:04 - service let's write the name which is
20:07 - songs it will create a class and it will
20:10 - inject into our songs
20:18 - module you can see
20:20 - that we have the song service spec file
20:24 - which is testing file and we have the
20:27 - surver
20:29 - we we have used the injectable
20:32 - decorator one more
20:34 - thing it has registered as a provider
20:38 - inside the songs module I told you
20:41 - services are provider providers could be
20:45 - factories helper
20:47 - function you will learn more about
20:50 - dependency injection in more details in
20:52 - the later
20:55 - mod so I told you service services are
20:59 - responsible to interact with database
21:03 - right now we are not going to interact
21:05 - with database we'll use the postris SQL
21:10 - postris database in the later videos for
21:14 - that here I'm going to create a local DB
21:17 - which it should be array local
21:20 - array saving saving record in the
21:25 - disk private read only songs array I'm
21:30 - going to create the empty array let's
21:32 - define a new method to create a new song
21:36 - and it is going to
21:39 - return
21:41 - let's push the song make sure you get
21:44 - the song from the create method there is
21:48 - a method push and I we need we need to
21:51 - provide a new
21:53 - song and let's create another method
21:56 - find all and and it is going to return a
22:00 - simple array this. songs and I can
22:04 - return this. songs
22:11 - array so we have created two method now
22:14 - it's time to inject this
22:17 - service into the controller I want you
22:20 - to do it accept the challenge and do
22:24 - it all right I'm going to do it for you
22:28 - song
22:35 - service now inside the create I can use
22:38 - the song service by using the this this
22:42 - do song service please create a new song
22:46 - I'm going to provide a dumy
22:48 - name Animals by
22:50 - [Music]
22:52 - Martin you can choose any name don't
22:54 - worry we will create a separate song
22:56 - model and separate interface for the
23:08 - song let's call the
23:14 - return and for the find all I am going
23:17 - to use this do song service.
23:22 - findall let's run the
23:27 - application
23:29 - our application is running let's send
23:32 - the API request to create a new
23:35 - song you can see I got a new
23:40 - song if you sent all the songs
23:43 - request I got all the songs
23:47 - let's save another
23:50 - song you can see I got five songs let's
23:55 - fetch all the songs I got all the
24:00 - songs so our service is working now in
24:03 - the real world
24:04 - application we will write the database
24:07 - code code here here save the song in the
24:15 - database and here what we will do fetch
24:18 - the
24:18 - songs from the
24:21 - DB but we will implement this feature in
24:24 - later
24:26 - videos in this video I'm going to teach
24:29 - you how to validate the request
24:33 - body when you send request to the Local
24:36 - Host call in 3000 3000 SL song we are
24:40 - trying to create a new
24:43 - song but let's say if I miss the title
24:46 - field it is going to give me the
24:48 - validation
24:49 - message the title should not be empty
24:53 - and title must be
24:55 - string let me REM know the artist
25:01 - now you can see title should not be
25:03 - empty and artist should not be empty so
25:07 - I would like to add this
25:10 - validation to our create new song API
25:15 - endpoint when you go to the
25:18 - Spotify if I click on any
25:21 - [Music]
25:23 - song this is the title of the song and
25:27 - this is the published date or release
25:30 - date and this is the duration so we're
25:33 - going to pick title duration and the
25:36 - date of the
25:37 - song let's do
25:40 - it this time I'm going to use class
25:43 - validator let's install the class
25:46 - validator
25:49 - package and we also need class
25:57 - Transformer
26:04 - you can see both packages have
26:14 - installed nexts provide validation pipe
26:19 - you can use validation pipe for specific
26:22 - controller method you can use it here or
26:24 - you can use it here it's your choice but
26:28 - but I'm going to create a global I'm
26:31 - going to register it as a global so I
26:33 - can use in any
26:36 - controller so you can call use
26:40 - method there is a method which is use
26:43 - Global
26:44 - pipes nexts already created the
26:47 - validation
26:49 - pipe you don't need to create it
26:54 - again I have imported the validation P
26:57 - from next sjs common
27:02 - package and now if you don't have dto
27:06 - which is data transfer object you have
27:09 - to specify the network data transfer
27:13 - object properties let's create a new
27:16 - song create a new file create song
27:23 - d. now we need to add decorator paste
27:27 - very
27:29 - adds let's create a new
27:33 - class and I'm going to name it to create
27:36 - song
27:39 - dto the first property is title I'm
27:43 - going to make it read
27:46 - only and we have the second property
27:49 - which is artist
27:51 - array and we have another property which
27:54 - is release
27:57 - dat
28:05 - or you can specify the type which is
28:10 - string and the type of part is it's an
28:14 - array and we have the
28:18 - DAT there is another
28:21 - property which
28:24 - is
28:27 - duration
28:30 - we need to store the duration in the
28:33 - time
28:35 - format now I'm going to use the
28:39 - decorator from class validator the type
28:42 - of title should be string and it's a
28:46 - required property so you can say it's
28:48 - not an
28:50 - empty we can follow the same stuff for
28:55 - artist not empty
28:58 - it's an
29:00 - array it's an
29:12 - array and you can say type
29:17 - string let's add decoration decorator
29:21 - for release
29:25 - date type should be string and
29:28 - class validator provides a
29:31 - decorator is date
29:40 - string now we have for if you want to
29:45 - store the time or add the validation for
29:47 - the time there is a there is a decorator
29:49 - which is military
29:52 - time and it's also required property so
29:56 - I'm going to add is not empty
30:00 - so is date string if you want to apply
30:02 - that you have to add the date in this
30:04 - format and you have to add the time in
30:07 - this
30:08 - format now we're going to apply we have
30:11 - already
30:13 - registered validation pipe here and we
30:17 - created the data transfer object which
30:19 - is create song dto now I would like to
30:23 - apply this create song dto in the create
30:27 - endpoint
30:30 - you can register it or you can apply it
30:32 - by using the body parameter please apply
30:35 - it on the request
30:37 - body and I can say create
30:41 - song create
30:43 - song dto the type is create song
30:48 - dto and this time I'm going to push
30:51 - create
30:52 - song
30:54 - dto let's try to test it out and we need
30:58 - to run the
31:13 - application so we have to send the
31:15 - request or add the Json body in the
31:24 - response let me open the rest c. HTTP
31:29 - file and we need to add the Chason body
31:32 - let's send the
31:34 - request you can see title should not be
31:37 - empty title must be string artist should
31:40 - not be empty and artist must be an array
31:43 - so validations have applied
31:47 - successfully I can say let's say lasting
31:51 - lover the
31:53 - title and we need the
31:56 - artists
31:59 - s
32:01 - let's now we're going to test it
32:03 - out so we have this
32:07 - record if you will add the date in
32:11 - different
32:13 - format you can see dat should be valid
32:17 - ISO 860 date string for date string
32:23 - format if I do in this way you will get
32:26 - the error dur must be valid
32:29 - representation of military time which is
32:31 - hours and minutes so it's working fine
32:39 - now let's talk about the
32:43 - middleware a middleware function runs
32:46 - before executing the route
32:48 - Handler inside the controller songs
32:51 - controller I have the find all route
32:54 - Handler and the create route Handler if
32:57 - you if you want to run any function
33:00 - before executing the route Handler you
33:03 - can write your code inside the
33:05 - middleware it's a
33:11 - function a browser wants to fetch the
33:14 - songs before fetching the songs would
33:17 - you like to call any method would you
33:21 - like to run your logic would you like to
33:24 - execute any type of
33:26 - code middleware can have request object
33:30 - response object and next
33:32 - function it means you can customize the
33:35 - request object if you want to add header
33:39 - if you want to log the request time you
33:41 - can do
33:45 - that a middleware can execute any type
33:48 - of
33:49 - code you can modify the request object
33:53 - if you want to add the request header
33:55 - authentication token to the request you
33:57 - can do in the
34:00 - middleware you can end the request and
34:03 - response cycle you can call the next
34:06 - middleware function by calling the next
34:11 - method we're going to build the logger
34:13 - middleware let's
34:15 - imagine you want to send request from
34:19 - your browser to
34:21 - server before executing the route
34:25 - Handler I would like to log the request
34:28 - message or the DAT
34:31 - time let's implement the logger
34:35 - middleware it's a class we're going to
34:38 - build a class based
34:40 - middleware and to create a middleware
34:44 - you need to implement the nextest
34:46 - middleware
34:48 - interface it provides a use method and
34:52 - use method will have the request
34:55 - response and the next function
35:02 - here I'm just logging the request dat
35:07 - time and at the end I'm also calling the
35:10 - next
35:12 - function it will if you will not call
35:14 - the next function it will not go to the
35:16 - next
35:19 - step one more thing middleware it's is
35:22 - like a
35:24 - dependency you can inject into module
35:29 - it will act as a
35:32 - dependency here we are injecting the
35:34 - middleware as a
35:37 - dependency to inject the middleware as a
35:40 - dependency we need to implement the nest
35:42 - module interface it will provide the
35:45 - configure method and the consumer will
35:47 - be middleware consumer and we just need
35:50 - to call the apply method from the
35:52 - consumer
35:55 - object and you need to provide the
35:57 - logger
35:59 - middleware here you need to specify
36:01 - where do you want to implement the
36:03 - logger middleware I would like to
36:05 - implement for songs
36:08 - API let's implement the locker
36:14 - middleware before creating a middleware
36:17 - I'm going to use Nest
36:21 - CLI please give me the help for nest
36:25 - generate command
36:35 - you can see that I got all the commands
36:39 - related to Nest
36:41 - generate you can generate class
36:44 - controller decorator filter
36:49 - guard middleware pipe
36:52 - provider we also have other options like
36:58 - no flat please do not create directory
37:01 - or no spec please do not create testing
37:07 - file let's create a new folder
37:13 - common I'm going to place all my middle
37:16 - Wares inside the common
37:26 - directory next generate
37:29 - Mi common
37:31 - SL
37:33 - middleware
37:35 - and the name of the middleware which is
37:38 - logger and I don't want a spec
37:42 - file please do not create the
37:52 - directory let's try with no flat and
37:55 - dash dash dry run
37:58 - let's see what will happen dry run it
38:01 - will not
38:03 - create the actual file but got the steps
38:07 - you will get the understanding how it
38:10 - will
38:20 - run it's working fine now no files
38:23 - return to dis but when you EX cute this
38:28 - code it will create the logger
38:31 - middleware file inside the middleware
38:34 - directory that looks good so I'm going
38:37 - to remove the dry run let's write the
38:47 - file
38:48 - perfect we have created the logger
38:52 - middleware you can see that it has
38:55 - already implemented the nest mid
38:57 - middleware
38:58 - interface and I got the use method with
39:02 - these three arguments request response
39:06 - and the next function here you can
39:09 - customize the request object if you want
39:11 - to add your custom logic you can do it
39:13 - here I can say request dot dot
39:17 - dot new date whatever you want to do do
39:21 - to dat
39:25 - string so we created the
39:28 - middleware
39:30 - now I told you or I taught you how to
39:34 - apply the middleware I want you to do it
39:37 - in the app
39:40 - modle we need to implement the nest
39:50 - module you can see that I got the
39:53 - configure
39:55 - method and we need to call consumer.
40:00 - apply the name of our middleware which
40:03 - is logger
40:07 - middleware and we have the four
40:10 - roots or
40:13 - routes I can say the
40:16 - songs now we need to test it out let's
40:20 - run the
40:26 - application
40:30 - my application is running now we need to
40:33 - send the API
40:37 - request if you will send the request to
40:40 - the root URL which is Local Host colum
40:43 - 3000 our middleware function will not
40:46 - run because we applied the logic to
40:48 - songs
40:51 - route fetch all the songs and I
40:56 - got the the log here request log send
41:00 - the post request I got the request log
41:02 - send the put request or send the delete
41:05 - request I got the
41:07 - log there are two other options to
41:12 - implement the or to apply logger
41:16 - middleware I can say option number
41:18 - one consumer. apply logger
41:24 - middleware for
41:26 - routes
41:30 - please run for only
41:33 - songs path
41:36 - and for only
41:39 - run request method.
41:44 - poost it could be option number
41:55 - two if you send request
41:58 - get request to fetch all the songs it
42:01 - will not run if you will send the post
42:04 - request for the songs I got the request
42:08 - if you send the put you will not see the
42:10 - request
42:11 - log another option we
42:16 - have let's do
42:18 - it
42:22 - consumer zor dot apply logger middleware
42:28 - for
42:29 - routes you just need to provide the
42:34 - controller it could be option number
42:37 - three it depends on what use case you
42:40 - like to
42:46 - use now I can fetch all the songs and I
42:49 - got the request
42:51 - log which create a new song I got the
42:55 - request
42:56 - log update a new song and I got the
42:59 - request
43:01 - log this is how you will create a
43:08 - middleware did you think about the error
43:10 - handling in
43:12 - njs if error comes from your application
43:15 - code nestjs provide builtin HTTP ex
43:23 - exception so let's say error comes
43:28 - while
43:30 - fetching the data from DB but we did we
43:35 - did not add any logic to handle the
43:37 - errors
43:39 - gracefully let's
43:42 - imagine we got the error while fetching
43:46 - the data from the
43:49 - DB error in
43:51 - DB while fetching record let's imagine
43:56 - that when error will happen nestjs will
44:01 - send this error to http exception this
44:05 - is the built-in exception in
44:14 - nestjs let me let me send the request to
44:17 - fetch all the
44:19 - songs you will see the server error with
44:23 - 500 status
44:25 - code next s has sent this message from
44:29 - HTTP
44:36 - exception but you can use the
44:40 - exception in your controller
44:44 - functions let's say I can
44:48 - say
44:49 - or did you think about how can you catch
44:54 - the
44:55 - errors you have to use the try catch
45:03 - block I can log a simple
45:07 - message I am in
45:09 - the catch
45:13 - block and this is my
45:25 - error
45:27 - let's try to fetch all the
45:30 - songs you can see that I got the error
45:36 - message I'm in the catch block and this
45:40 - is the
45:42 - error it means we successfully got
45:46 - caught the
45:47 - exception but we want to send the useful
45:51 - method in the useful status code in the
45:55 - response I can not see anything
45:59 - here for that we need to use the HTTP
46:03 - exception I can say through new HTTP
46:08 - exception it's a
46:11 - class and we need to provide the
46:16 - message can say server error or whatever
46:19 - you want to say I can say server
46:23 - error and we have to provide the status
46:26 - code
46:27 - HTTP status provides a lot of status
46:30 - codes you can use
46:34 - anything whatever you want to do for me
46:37 - server
46:38 - error internal server
46:42 - error if you want to send the message or
46:46 - cause which should be the error this
46:53 - one let's try to fetch all the songs
46:57 - you can see that I got the message
47:00 - server error with 500 status code which
47:04 - successfully caught the
47:07 - exception but if you want to use
47:09 - different error message you can do that
47:11 - you can use forbidden status
47:17 - code it will
47:20 - work let's restart the
47:24 - application now I got it
47:31 - so we have the status code 403 instead
47:34 - of
47:39 - 500 I'm going to replace forbidden to
47:42 - internal server
47:45 - error this is how you will cach the
47:48 - exception in your source
47:50 - code if error will come from this
47:54 - service this this method
47:57 - TR cach block will cat the
48:04 - eror got
48:09 - it let's talk about the pipes in
48:14 - njs there are two use cases to use the
48:17 - pipes the first one is to transform the
48:21 - value here in our example application we
48:25 - have the find one method
48:27 - we are expecting the ID as a input
48:32 - parameter by default it is going to give
48:35 - me the string so I can use the parse int
48:39 - pipe to transform the string value to
48:45 - number here you will see the type of ID
48:48 - it should be
48:50 - number another use case for pipes are to
48:54 - validate the input parameter
49:05 - in the create method we will accept the
49:08 - input argument like song title song
49:12 - artist we will validate the all the
49:16 - input arguments by using the validation
49:19 - pipe let's implement this transform
49:24 - value in our demo application
49:30 - so I'm going to remove
49:32 - it let's start it
49:40 - again it is giving me this
49:44 - response in nestjs you get you can get
49:47 - the dynamic parameter by using the ram
49:53 - decorator Ram decorator and the name of
49:57 - our argument which is
50:00 - ID I'm expecting the
50:04 - ID
50:07 - and I use the template
50:11 - string let's define the type of
50:24 - ID I'm going to send the request you can
50:27 - see the type of the ID is
50:30 - string we were expecting the number
50:35 - type but nestjs got us the string
50:41 - type you can convert this string into
50:45 - integer or the number by using the pipe
50:49 - Pars in pipe that's
50:55 - it let's send the request to fetch the
50:58 - song on the based on ID you can see I
51:02 - got the number ID number type if I
51:06 - provide the string value
51:08 - here you will get the validation error
51:11 - validation failed numeric string is
51:13 - expected bad request
51:16 - error if you want to customize the error
51:20 - message you can instantiate
51:25 - it eror status codee HTTP status dot not
51:38 - acceptable now I got not acceptable if I
51:41 - provide
51:42 - the numeric string I got the ID which is
51:46 - number type of the ID is
51:49 - number we successfully transformed the
51:53 - string value to number value in the next
51:58 - video we will implement the input
52:02 - validation using pipe we will create the
52:06 - custom validation
52:10 - pipe you have learned how to inject
52:14 - dependency by using the Constructor
52:16 - based dependency injection
52:19 - pattern we have injected the song
52:22 - service into the song
52:25 - controller what what will happen when
52:28 - songs controller will inject or
52:32 - instantiate the song service let me open
52:37 - that songs
52:39 - controller here we are injecting the
52:43 - dependency song
52:46 - service and we have provided as a
52:50 - dependency
52:54 - here this one this song
53:03 - service when Nest container instantiate
53:06 - the songs controller it first looks for
53:09 - any dependencies in our case we have the
53:13 - song
53:15 - service when it finds the song service
53:19 - dependency Nest will create the instance
53:22 - of the song service and cach it and it
53:25 - will return
53:27 - it if already created the cache then it
53:31 - will return from from the cache it will
53:34 - not create the new
53:37 - instance let's imagine you are using the
53:41 - song service inside the multiple
53:44 - controllers the first controller let's
53:47 - say we have the songs controller I'm
53:49 - using it first time
53:51 - here if I use song service inside the
53:55 - song service dos back file it would be
53:58 - treated as a second time now the second
54:02 - time it will not create any instance it
54:06 - will get the instance of the song
54:08 - service from the cache this is the
54:11 - Singleton pattern applied here next
54:15 - under the hood created a Singleton
54:19 - single instance of the song service and
54:22 - it is going to share the same same
54:24 - single instance throughout our songs
54:28 - module but you're going to learn
54:30 - multiple scope if you want to use the
54:34 - scop scope strategy if you want to
54:37 - instantiate a new instance after for
54:41 - after every incoming request you can use
54:45 - the scops but I'll talk about the scops
54:50 - later there are many techniques to use
54:52 - the providers some of them are standard
54:54 - providers value Prov providers known
54:58 - class based provider
55:00 - tokens class providers we use that class
55:05 - providers Factory providers used Factory
55:08 - providers and nonn service providers
55:11 - we're going to play around with all
55:13 - these six
55:14 - techniques let me explain with the help
55:17 - of
55:19 - examples this is the standard provider
55:21 - inside the S module we are using it as a
55:25 - standard provider but you can convert
55:28 - the above
55:29 - syntax into this one let's use
55:34 - it I need to open my
55:45 - project we need to create a new
55:50 - Branch model 3 lesson number
55:55 - one
55:56 - open the socks
55:59 - module so we are using the standard
56:02 - provider technique but you can write the
56:05 - above syntax or above
56:08 - code by using this syntax I can say this
56:12 - is
56:17 - provider just this
56:25 - it
56:28 - now we have the song service and the
56:31 - song service please use it as a class
56:36 - when you inject it into another
56:41 - class we are using inside the class in
56:44 - injecting as a
56:47 - dependency
56:48 - now you can test the
56:55 - application
56:59 - I'm going to send request to any
57:18 - URL let's create a new song artist must
57:23 - be
57:23 - [Music]
57:24 - stream this is this
57:38 - true why artist I
57:48 - think so I got the
57:53 - issue in the create song d
57:57 - I did add the H should be true I'm
58:01 - telling to class
58:03 - validator the elements of the array type
58:07 - should be string each element of the
58:10 - array should be
58:11 - [Music]
58:12 - string now it will it will be working
58:16 - fine if we have three articles or three
58:23 - artist Martin
58:29 - and
58:32 - John you can see that it's working fine
58:40 - now
58:42 - so we also tested this syntax this is
58:46 - the standard
58:48 - provider but if you like this syntax you
58:51 - can keep this syntax but I just want to
58:53 - show
58:54 - you I'm going to this out uncomment this
58:58 - one now I got the song
59:10 - service now I'm going to talk about the
59:14 - value
59:19 - providers if you want to create the
59:21 - moing service instead of the original
59:25 - service
59:27 - you can do that with the help of use
59:30 - value the use value syntax is useful for
59:34 - injecting a constant value or you want
59:38 - to put an external Library into Nest
59:40 - container or replacing a real
59:43 - implementation with more
59:46 - object we are using this
59:49 - one we are replacing a real
59:52 - implementation of song service with Mo
59:55 - object
60:00 - so when you need this use case you have
60:04 - to use the use value or if you want to
60:06 - inject a constant value you can use the
60:08 - use value or if you want to inject
60:11 - external Library into the nest container
60:14 - you can use the use
60:19 - value let's do
60:22 - [Music]
60:24 - it
60:33 - I'm going to create a mocking object
60:35 - here we have a find all method inside
60:38 - the song
60:40 - service when you open the song
60:43 - service you will see the find all
60:49 - method but we have to return the songs
60:52 - I'm not going to throw the
60:54 - arrow
61:03 - would be song
61:08 - service and use
61:10 - value which is songs moing object Mo
61:14 - song
61:16 - service that is it
61:24 - now
61:29 - now we need to test
61:30 - it I'm going to fetch all the
61:34 - songs and this time you are getting the
61:37 - response from the mo object not original
61:41 - song
61:48 - service so we have the find all method
61:52 - and it is returning this
61:54 - one if I will app add the
62:07 - artist I'm going to fetch all the songs
62:10 - from the mo service object mock
62:13 - service and you can see I got the record
62:17 - from the mock service instead of
62:19 - original song service find all
62:23 - method we have learned how to use the
62:26 - use
62:28 - value
62:31 - now if you want to inject the known
62:34 - class based provider you can do that
62:39 - let's say I want to inject an object
62:43 - with
62:45 - connection we have three
62:47 - properties connection
62:52 - string if you would like to inject any
62:55 - object object as a dependency you can do
62:58 - it well with use value I told you you
63:02 - can inject constant by using use value
63:06 - you can object an you can inject an
63:09 - object or you can inject the working
63:14 - object let's create a new file with
63:17 - connection.
63:19 - file and I'm going to specify some
63:22 - connection
63:23 - properties you have to create an new
63:27 - constant. file inside the common folder
63:30 - and I'm going to add the constants
63:33 - directory here you will have constant.
63:35 - TS
63:39 - [Music]
63:45 - file I can say
63:48 - connection. and I'm going to copy the
63:52 - code I just defined three variables and
63:55 - I have Define the type which is
63:58 - connection now I would like to register
64:02 - it as a
64:08 - provider you can register inside the
64:11 - songs module or you want to register it
64:13 - to app module it depends on you provide
64:18 - this is the name or the token
64:22 - value this is
64:24 - how I will
64:26 - inject in the class when I will inject
64:30 - in the class I'll use this token
64:33 - [Music]
64:34 - key use value let me
64:39 - provide which is
64:41 - [Music]
64:49 - connection so we have to inject it
64:54 - inside the
64:56 - song service I can use the add inject
65:02 - decorator so
65:05 - songs
65:09 - controller I think I injected inside the
65:12 - song
65:13 - service so I'm going to inject here
65:17 - inside the song
65:18 - service or let me inject in the
65:22 - Constructor
65:24 - function
65:26 - here I would like to
65:29 - inject I can
65:38 - say
65:41 - inject let's provide the
65:44 - key
65:46 - private
65:50 - connection here we need to provide the
65:53 - type I have defined the type this is the
65:58 - type so I can
66:01 - log the
66:04 - connection this.
66:08 - connection if you will not add the
66:10 - private so you can add directly without
66:14 - adding the this keyword I did not add
66:17 - the provider so I access the connection
66:21 - string without adding the
66:24 - this so let's say this is I can
66:28 - say I'm going to use the template
66:33 - string this
66:35 - is connection
66:37 - [Music]
66:47 - string when songs controller will be
66:52 - instantiated this Constructor function
66:55 - will be called so it will log this
67:00 - message you can see we have this is the
67:03 - connection string so I can get the
67:07 - connection
67:10 - string now I can see this is connection
67:12 - string and I can say the connection
67:15 - [Music]
67:18 - string or you can
67:21 - say my SQL dot
67:24 - dot col do
67:26 - dot 1 2 3 6 or maybe
67:34 - Port I created the fake or dummy
67:38 - connection
67:40 - stren you have learned how to inject the
67:44 - object as a
67:46 - provider and used it as a
67:54 - dependency
67:56 - now we're going to talk about class
67:58 - based provider we have already used the
68:01 - class based provider here this
68:06 - one not this one this one used Class so
68:11 - I'm going to
68:12 - create a
68:14 - new
68:17 - service this this will be called da
68:21 - config
68:22 - service inside the dep config service
68:25 - I'll have one property and a one
68:28 - function DB host and get DB
68:32 - host remember it's an injectable
68:38 - service so you can register it as a
68:43 - provider inside the app module by using
68:46 - the use class syntax and you have to
68:48 - provide the name of your service in our
68:51 - case we have the da config
68:54 - service and and then and then I can use
68:57 - the dev config service inside the app
69:05 - service
69:12 - so I can
69:14 - create a
69:18 - providers hold up let's
69:22 - rename
69:24 - providers let's create a new
69:27 - class def
69:29 - config
69:32 - service.ts
69:36 - and we
69:38 - have these properties we have TB host in
69:43 - the get TB
69:45 - host so let me register inside the app
69:54 - module
69:56 - we have provider and I can say please
70:01 - provide Dev
70:03 - config service in the use
70:07 - class Dev confli
70:24 - service and and now I can inject inside
70:28 - the app
70:29 - module let me inject it
70:35 - here I can say
70:38 - private
70:41 - Dev
70:43 - config
70:45 - service and I can say def config
70:51 - service and I can call the method from
70:54 - the D config let me convert into the
70:57 - template
71:01 - string da config
71:04 - service. DB
71:23 - host so
71:25 - we have to send the request to the root
71:28 - URL to test
71:31 - it
71:34 - rest let me send the
71:39 - request hello I'm learning NS
71:42 - fundamental and this is the DB host
71:44 - which is St config which is Local Host
71:47 - DB
71:54 - host
72:00 - so if you want to inject the known
72:03 - service provider like a simple
72:07 - object and you want
72:09 - to inject Dynamic
72:14 - value you have added the check or if
72:19 - condition if node development equals to
72:23 - development then you you have to inject
72:26 - the dev config otherwise you have to
72:28 - inject the pro config if if you have two
72:32 - objects and you want to inject on the
72:35 - based on condition this is the known
72:38 - service provider it means these will not
72:41 - be
72:43 - classes if you have this type of use
72:46 - case you can inject by using the use
72:49 - Factory so I'm going to
72:52 - call inside the app module let me let me
72:56 - show the
72:57 - demo I just created the two
73:01 - object and in the
73:08 - provider we have used the key which is
73:12 - config and I use the used Factory and we
73:15 - have to provide the arrow function it's
73:18 - just returning a value Dev config and
73:22 - the pro config if you want to in inject
73:25 - dependency or inject provider only based
73:28 - on condition then you can use the US
73:31 - Factory and now the same way you can
73:35 - inject config
73:38 - value in the app
73:42 - service here we have to inject
73:49 - it by using the
73:52 - inject decorator provide the key which
73:55 - is
73:57 - config in
74:00 - private
74:02 - config we have Port value and type a
74:06 - [Music]
74:08 - string and you can say Port should
74:15 - be this do config do
74:21 - Port so we have to test it to send
74:24 - request to the root
74:27 - URL now I got
74:29 - the host which is Local Host and the
74:33 - port which is
74:41 - 400 so we have to add
74:52 - 4,000 you have learned how to inject
74:56 - provider as in the standard way you have
74:59 - learned the use value you have learned
75:02 - how to add non class based provider you
75:06 - have learned how to use use class
75:09 - provider how to use the dynamic how to
75:12 - in how to register the dynamic
75:15 - provider and finally you have learned
75:18 - how to how to register known service
75:23 - providers
75:27 - the previous video you have learned
75:29 - multiple techniques to register a
75:34 - providers when you register a provider
75:37 - by default nestjs use this scope default
75:44 - it means a single instance will be
75:47 - created which is called the Singleton
75:50 - pattern and this single instance of the
75:54 - provider is is shared across the entire
75:57 - application nextest cach the instance
76:01 - when application request for the second
76:04 - time it will not create a new instance
76:07 - second time it will return from the
76:10 - cash another injection scope technique
76:14 - which is
76:15 - request a new instance of the provider
76:18 - is created exclusively for each incoming
76:23 - request and we have the third technique
76:27 - injection scope technique transient
76:30 - providers are not shared across consumer
76:34 - each consumer that inject a transer
76:36 - provider will provide a new dedicated
76:39 - instance most of the time you need
76:42 - default scope because single turn
76:45 - instance is recommended to improve the
76:47 - performance of your
76:49 - [Music]
76:51 - application when you get the instance
76:54 - from the C
76:55 - it will give you the instance in the
76:58 - more faster way instead of creating the
77:01 - complete object it just give you the
77:05 - copy of the already created
77:08 - object so you can play around with
77:10 - injection
77:11 - Scopes let's
77:13 - say if you want to use it inside the
77:16 - song service I didn't I could not find
77:19 - how to debug the dependency injection
77:23 - so you have to use
77:28 - here
77:30 - [Music]
77:31 - scope injection
77:33 - scope what we have to say
77:37 - scope scope
77:40 - to
77:45 - transient the performance of your
77:48 - application will be
77:51 - hard it will decrease the performance
77:54 - but but it depends on your use case what
77:59 - are your
78:04 - requirements similarly when every
78:07 - incoming
78:08 - request if you have use case you want to
78:12 - create a new
78:14 - instance you can use it well for the
78:17 - requesting purpose for testing
78:21 - purpose I'm going to open the songs
78:24 - controller
78:28 - and here we have to
78:33 - [Music]
78:53 - say
78:58 - it's an
79:02 - object let's import this
79:19 - scope I'm going to send the API request
79:23 - it's working fine
79:39 - one thing you did not
79:45 - notice when I will create a new song it
79:50 - should add the song in the array
79:55 - so I have created three
79:59 - objects three songs object in the songs
80:04 - array when I will send the request to
80:07 - fetch a single song or all
80:10 - songs it should give me the empty
80:13 - response because on every
80:16 - request it will delete it the complete
80:21 - data complete
80:23 - songs
80:27 - because it will also re instantiate the
80:29 - song service inside the song service we
80:32 - we have the
80:34 - are we have the songs
80:46 - are you can see I created the song now
80:50 - when I try to fix all the songs it
80:53 - should give me the first song or all
80:56 - songs you can see the empty
80:59 - response in this video I'm going to
81:02 - teach you how to add one to many or many
81:05 - to one relationship between two entities
81:10 - where a contains multiple instances of B
81:13 - entity and B entity contains only one
81:17 - instance of a
81:19 - entity we have two use
81:22 - cases we are building this Spotify
81:25 - clone if you are using or you use
81:30 - Spotify each user has its own playlist
81:34 - and each
81:35 - playlist can have multiple songs so you
81:41 - as a user can store multiple songs or
81:44 - save multiple songs in the playlist so
81:47 - there is a one to one one to many
81:49 - relationship between playlist entity and
81:52 - the songs entity see similarly we have
81:55 - each user can have multiple playlist
81:58 - many playlist can belong to a single
82:01 - user so this is also a many to one
82:05 - relationship between playlist and the
82:08 - users let's create the playlist entity
82:11 - and add
82:13 - relationship we don't have any
82:16 - playlist entity go ahead and create a
82:19 - playlist
82:23 - entity I have created a new folder
82:28 - playlist. entity. TS
82:32 - file so I'm going to copy couple of the
82:34 - code from
82:37 - my
82:45 - notes we have created the playlist
82:53 - entity
82:55 - now we have to make make a relationship
82:59 - between songs and the
83:02 - users
83:05 - similarly type orm provides one to many
83:10 - decorator and this represents the target
83:13 - entity relation entity we are making a
83:17 - relationship with song entity this
83:20 - representing the inverse side of the
83:22 - relation in the song model we have a
83:25 - playlist
83:26 - property and we have the array of the
83:30 - songs I'm going to copy this code and
83:33 - I'm going to paste it
83:36 - here we don't have song.
83:40 - playlist open the song
83:43 - entity here we can add a
83:45 - relationship but we also going to add a
83:49 - relationship between user so I'm going
83:51 - to copy this code and paste it
83:58 - here now we have to add many to one
84:02 - relationship in the song
84:07 - entity so many songs can belong to a
84:10 - playlist for each unique
84:12 - user we have to import the playlist
84:16 - import many to one
84:20 - relation and finally we have to add one
84:23 - to many relation in inside the song
84:25 - inside the users user
84:34 - entity so I'm going to copy that
84:38 - code inside the user
84:41 - model and I'm going to paste it
84:53 - here
84:58 - now everything is fine
85:00 - now I have added many to one relation in
85:04 - the song it means it will have the
85:08 - primary key of the playlist entity and
85:12 - save it as a reference key or the
85:15 - foreign
85:21 - key now we need to create the clip
85:24 - playlist
85:25 - module I also want
85:27 - [Music]
85:30 - to create a new playlist I'm going to
85:33 - create a new
85:35 - endpoint but first of but first we need
85:40 - to register our new entity I'm saying to
85:44 - type orm please convert or make relation
85:48 - between playlist and the user playlist
85:51 - and the
85:53 - song
86:05 - every everything is fine now when you go
86:07 - to the pg
86:10 - admin refresh your
86:13 - tables you will see playlist
86:18 - table this is the playlist
86:22 - table and we have the user
86:25 - ID when you open
86:29 - playlist entity we have added the many
86:33 - to one relation it means it will have
86:36 - the user ID as a foreign key and inside
86:41 - this song entity we have added many to
86:45 - one relationship as for the playlist so
86:49 - this song will have
86:52 - the primary key as a foreign key of the
86:56 - playlist entity let me show
86:59 - you inside these
87:02 - songs we have a playlist
87:12 - ID relations have created successfully
87:15 - we created one to many and many to one
87:18 - now I want to show you how can you save
87:19 - a record with relation
87:23 - entities
87:24 - go ahead and create a playlist module
87:27 - you can use with n CLI to create a
87:30 - playlist module but I'm going to use my
87:32 - not
87:33 - notes
87:36 - playlists
87:41 - module. and I'm going to paste my
87:43 - playlist module we don't have playlist
87:47 - service and we don't have playlist
87:50 - controller I can create these two files
87:57 - controller. let's
87:59 - create playlist
88:01 - dot
88:04 - service.
88:06 - file I'm going to copy
88:10 - my playlist
88:20 - service we have to import couple of tip
88:28 - dependencies inject
88:32 - dependency and we need
88:37 - playlist we need a
88:42 - user
88:43 - we we need a song that is good right
88:47 - now also need to get the
88:51 - injectable we also need to import report
88:54 - osit
88:58 - Tre I don't have any user so import the
89:04 - user we have service right now and we
89:09 - going to create
89:12 - controller
89:14 - or we can
89:16 - build create playlist
89:23 - function I'm going to create a new
89:28 - method you can see that we don't have
89:32 - create playlist
89:33 - dto we are just creating the instance of
89:37 - playlist I'm providing the name of the
89:39 - playlist when you go to the playlist
89:41 - entity you have the name
89:47 - property each playlist can have multiple
89:51 - songs so I will get IDs of the songs
89:55 - from the request
89:57 - body we are using the same logic in the
90:00 - previous video we
90:01 - used here I'm setting the relation with
90:04 - songs
90:06 - entity I am creating the playlist when
90:09 - you are when you need to create a
90:10 - playlist you have to provide the
90:13 - name and you can set the relation for
90:15 - the
90:17 - songs and you can set the
90:19 - relationship for the
90:22 - user when we will implement the
90:25 - authentication I will not find the user
90:27 - directly from the database I'll get it
90:30 - from the logged in
90:32 - user we have set the relationship with
90:35 - user and finally we are saving the
90:39 - playlist we don't have create playlist
90:42 - D go ahead and create a playlist
90:46 - D we have used that
90:49 - logic I'm going to create a new file
90:52 - playlist
90:55 - dot or you can
90:57 - say it should be new
91:01 - folder dto inside the
91:05 - dto playlist create playlist
91:08 - dto create
91:12 - playlist do
91:21 - D.S we are expecting the name type
91:25 - should be string and I'm getting the IDS
91:28 - of the song from the request body that's
91:32 - why I specified the number type the
91:34 - array of the numbers and we have the
91:37 - user it should be a number it should be
91:39 - the
91:42 - ID and finally we have to use the create
91:46 - playlist
91:47 - dto we have to import
91:52 - it and now we have to build our
91:56 - controller function and the
91:59 - endpoint do we have a controller yes we
92:02 - have a
92:04 - controller everything is good to go I've
92:06 - have specified the playlist with this
92:08 - endpoint we injected the playlist
92:11 - service we have used that logic and I'm
92:14 - returning a simple playlist in the
92:20 - response we have to register the
92:23 - playlist module inside the app module
92:26 - and it will also be treated as a feature
92:30 - module just like we did with songs
92:32 - module we have playlist
92:36 - module now I have to test the
92:40 - application you can test it by sending
92:43 - the
92:46 - request do we have a user I already
92:49 - created the user in the previous
92:52 - video I can double check check it my
92:56 - users you can see that we have three
92:59 - users I would like to save the record
93:02 - for the second user with ID number
93:06 - two rest
93:10 - client we have to create a new playlist
93:12 - I can say create new
93:15 - playlist we have to send the post
93:20 - request Local Host column 3000 playlists
93:26 - content type is equals to
93:29 - Json
93:30 - application
93:33 - Json let's provide the
93:40 - data I'm going to create a new playlist
93:43 - with Feelgood now I would like to save
93:46 - the song with ID number six do we have
93:49 - the song with ID number six let me
93:52 - double check it
94:00 - yes we have the song with ID number
94:03 - six and this is our user let's say I'm
94:06 - going to say I'm going to create with
94:08 - user ID number
94:15 - two it's not a
94:18 - valid
94:22 - request
94:29 - now it looks fine we need to add a space
94:32 - here we have a playlist feel good now
94:36 - and we have a one song with ID number
94:39 - six and we have this user so this user
94:43 - has playlist feel good now and it has
94:46 - only one
94:48 - song you can double check it from the
94:52 - playlist
94:59 - this is the playlist
95:05 - record in this video I'm going to teach
95:08 - you how to connect nestjs application
95:11 - with type orm and
95:13 - post nestjs provide multiple drivers to
95:16 - connect with database if you want to use
95:19 - mongod DB you can also do that if you
95:22 - want to use my
95:24 - if you want to use post you can do that
95:27 - in this video I'm going to implement the
95:29 - post with
95:32 - nestjs uh typ orm is a object relational
95:35 - mapper you will write the code in
95:37 - JavaScript objects and these objects or
95:40 - classes will be converted into database
95:43 - tables if you want to write SQL queries
95:46 - you don't need to write plain SQL cury
95:49 - you can write queries in the form of
95:52 - objects
95:55 - first of all you have to install a
95:56 - couple of dependencies we need nestjs
96:00 - typ orm package and post driver and type
96:05 - orm uh open the package tojson file and
96:08 - you have to install these dependencies
96:11 - I'm going to add them
96:13 - here let me install all of these
96:22 - dependencies
96:28 - we also need typing for
96:32 - nestjs we have to install this
96:38 - package I'm going to install as a def
96:45 - dependency we
96:47 - already have this package types at
96:52 - node
96:59 - we installed these packages njs type orm
97:03 - post and type
97:05 - orm so now we need to import the type
97:09 - orm module into our root module in our
97:13 - case root module is our app
97:16 - module so we have to call this method
97:20 - from type or a module and you have to
97:23 - provide the connection strings or
97:25 - connection properties like type host
97:28 - Port username password database entities
97:32 - and
97:33 - synchronize whenever you will create a
97:35 - new entity you have to register it here
97:38 - for synchronize means whenever I will
97:41 - run the application please delete the
97:43 - data from all the all the tables
97:47 - synchronize please delete everything
97:49 - from the table but do not use
97:50 - synchronize in production otherwise you
97:53 - will lose the production
97:56 - data whenever you have to create a new
97:58 - entity you have to add it here inside
98:00 - the entities array so the for root
98:03 - method Sports all the configuration
98:05 - properties exposed by the data source
98:07 - Constructor from the type or a
98:14 - package I have installed PG admin if you
98:17 - don't have you can install the post
98:19 - admin I'm using PG admin 4 you have to
98:22 - provide your password let's connect with
98:28 - server we have to create a new database
98:31 - right
98:32 - now I'm going to create a new database
98:35 - Spotify
98:40 - clone this is my
98:50 - user go to the app module
98:54 - and we have to import the type type or
98:58 - module
99:22 - here we have have to install manually
99:24 - it's not giving me
99:27 - suggestion
99:33 - from
99:34 - Nest JS type
99:38 - orm and we need to get type omm
99:44 - module so I'm going to call a method
99:47 - type orm
99:51 - module do for root with we have to
99:53 - provide the
99:56 - options database which
99:58 - is Spotify
100:01 - clone host which should be Local
100:08 - Host and we need to specify the port for
100:11 - post gr I think 4
100:15 - 5432 by
100:18 - default username for me it's postcript
100:23 - add you have to provide your password
100:26 - for me I think it's
100:31 - root I specified the database name and
100:35 - we have empty entities right now I don't
100:38 - have any
100:40 - entity and synchronize set to
100:43 - true it will create the database
100:49 - tables
100:52 - po
100:59 - it should be usern name not a
101:07 - user so how can you verify we have
101:11 - successfully connected to type
101:14 - orm you can use data source object in
101:19 - the app
101:21 - module now you can inject
101:25 - it and I can
101:27 - log let's add
101:33 - private you can log anything
101:37 - from DB name let's
101:41 - say and I can get it from the data
101:44 - source
101:47 - dot data
101:51 - source. database
101:54 - this do I have that property let me
101:57 - check
101:58 - it dat source. driver dot
102:07 - database Let's test it
102:22 - out I'm getting the
102:26 - error wrong
102:31 - driver so I think I did not provide the
102:38 - type let's add the
102:41 - type the type of the driver which is
102:52 - post
103:06 - now we have made the connection
103:08 - successfully you can see DB name which
103:11 - is Spotify
103:13 - clone you can also
103:16 - check the songs table inside the Spotify
103:20 - Let me refresh it and I would like to
103:23 - look at the
103:25 - tables we have the
103:29 - tables I don't have any song because we
103:32 - did not create any entity right
103:35 - now but we have successfully
103:38 - connected to the postris
103:42 - database in this lesson I'm going to
103:44 - teach you how to create an entity entity
103:48 - is a class that maps to database table
103:51 - or collection when us using
103:54 - mongodb you can create entity by
103:56 - defining a new class and Mark it with an
103:59 - entity
104:01 - metadata and inside the metadata you can
104:04 - provide the name of the table in our
104:08 - case I'm going to provide the songs
104:10 - table
104:11 - name an ID which is the primary
104:15 - generated column the ID will be
104:18 - generated automatically it's an auto
104:22 - increment and we have the title I use
104:24 - the column
104:26 - decorator for artist array postris also
104:31 - Sports error data type you have to
104:34 - provide the column and I'm using the V
104:37 - character you have to say this column is
104:41 - an array type you have to specify the
104:43 - array should be
104:45 - true and we have a release dat property
104:48 - or release dat field in the database
104:50 - table I'm specifying the call colum
104:53 - decorator and we have and we are seeing
104:57 - this the type of this field which is
105:00 - State we also have time type in the
105:04 - post you can say we have the duration I
105:07 - specified the date data type in the post
105:11 - Cas you can Define the time I don't want
105:13 - to save extra date field here I only
105:16 - need Time Properties time related
105:19 - metadata and lyrics lyrics could be the
105:22 - long text that that's why Post sports
105:25 - text type if you want a long if you want
105:28 - to store a string with long content or
105:31 - long long
105:34 - length entity songs which is the name of
105:37 - the
105:41 - table and you can say I spec I
105:44 - have I I have specified the description
105:47 - for each
105:51 - field
105:53 - when you will create the entity you also
105:57 - need to update the lyrics in the create
106:00 - song datto we did not we did not add
106:03 - lyrics property in the previous videos
106:06 - that's why I use the lyrics it's an
106:09 - optional property it depends on the user
106:11 - does user want to add lyrics or
106:16 - not and finally we need to register the
106:19 - entity to the app module and then you
106:22 - can can test the
106:25 - application let's try to implement
106:28 - it go ahead and create an entity I can
106:33 - say
106:34 - songs or song.
106:37 - entity songs. entity or song whatever
106:40 - you want to call let me say what I
106:46 - called song.
106:51 - entity
106:56 - dots let's specify the
107:00 - class I can say
107:06 - song I can provide the
107:11 - entity the name of the table which is
107:15 - songs now we
107:17 - need primary generated
107:20 - column ID the type should be
107:24 - number and we have the title
107:28 - field let's specify the title
107:32 - [Music]
107:36 - column
107:38 - title type should be
107:41 - string and we have another column this
107:45 - time we have the artist
107:47 - array you have to specify it as a string
107:51 - array here I I can say the V
107:58 - character V character and
108:02 - the type should be
108:05 - aray and we
108:08 - have release date duration release
108:13 - date
108:15 - let's it should be
108:19 - date release date type should be
108:24 - date and we have
108:28 - duration type should be
108:30 - time
108:32 - duration and the
108:35 - date and finally we have the
108:38 - lyrics type should be
108:44 - text
108:48 - lyrics type should be
108:51 - string
108:55 - now we need to test this
108:58 - entity you have to
109:01 - add register the entity in the song in
109:05 - the entities
109:07 - array now it should create the songs
109:10 - table for
109:15 - us let me test it out from the PG
109:18 - admin refresh the tables I got the songs
109:22 - table
109:24 - with these columns
109:28 - ID title artist release date and the
109:35 - duration we don't have any
109:42 - [Music]
109:46 - record so
109:51 - let's
109:54 - update the create song dto and I'm going
109:57 - to copy
109:59 - it and I'm going to paste it
110:03 - here create song dto let's add another
110:07 - field the optional which is
110:15 - lyrics everything is fine
110:18 - now we have tested
110:21 - it in the next video you are going to
110:25 - learn how to perform C
110:29 - operation we're going to fill these
110:32 - methods update delete find one find all
110:36 - and the create this time we going to
110:39 - fetch and save data to the
110:43 - database let's perform cred operations
110:47 - type orm Sports repository
110:50 - pattern for each entity type orm
110:53 - provides repository and this repository
110:56 - has CR features like create create
110:59 - record update record find record and
111:03 - delete record repository provides the
111:10 - method first of all you have to register
111:14 - the type or a module as a feature into
111:17 - the songs
111:21 - module
111:23 - we providing the
111:29 - entity like these entities I would like
111:32 - to use inside the songs
111:34 - module and it it will provide the
111:37 - repository songs repository here then
111:41 - you can inject the songs
111:43 - repository to use songs repository you
111:46 - need to import the type or a module into
111:49 - songs module just like we did it here
111:52 - this this module uses the four feature
111:54 - method to Define which repositories are
111:58 - registered in the current scope we only
112:01 - need song entity that's why we use the
112:03 - we have imported or added the song
112:08 - entity now we can inject the songs
112:10 - repository into the song service just
112:12 - like we did we did it as a dependency
112:15 - injection please inject the song's
112:18 - repository and the type of the entity
112:20 - which is song and you can in you can
112:23 - import repository from nestjs type or M
112:30 - package now I told you songs repository
112:33 - provides scrud method to create delete
112:38 - update here you can look at
112:42 - that create delete fetch records from
112:44 - the songs
112:46 - table let's implement this create song
112:50 - method this time we don't need to add a
112:51 - record in the local DB you're going to
112:53 - save the new song by using the song
112:56 - repository. save
112:58 - method let's Implement
113:02 - here in the songs
113:07 - module we have to
113:10 - import type orm module as a
113:17 - feature provide the song entity I would
113:21 - like to use this entity into the songs
113:24 - model in songs
113:27 - module now you you are able to inject
113:31 - songs repository into the song
113:34 - service so I want you to inject this
113:37 - songs
113:44 - repository Constructor
113:48 - pattern songs
113:51 - Repository
114:00 - repository and I can provide the song
114:02 - type which is
114:06 - entity now you have the exess of crud
114:13 - methods so song repository provides this
114:17 - safe method just like you learned here
114:20 - it provides this safe method for first
114:22 - of
114:24 - all we have to create a new
114:29 - song and it should
114:32 - return a
114:34 - promise with
114:39 - song so I just
114:43 - created should say
114:46 - create song
114:50 - dto the type should be
114:54 - create Song
114:59 - D so I just created the instance from a
115:03 - song class I specified the title I got
115:06 - the title from D I got the artist from
115:09 - dto duration lyrics and release date
115:12 - from the dto and finally you can
115:15 - call Safe method this. songs
115:20 - repository and I will would like to call
115:22 - this safe method and provide a newly
115:25 - created song and it should return the
115:28 - object get rid of the songs array I
115:30 - don't want to use
115:33 - it we also need to remove everything
115:38 - from
115:47 - here now it's time to test this G
116:04 - method make sure you have
116:11 - called
116:14 - yeah it should use the up
116:19 - expression
116:21 - here
116:48 - in the controller let's look
116:51 - at
116:52 - issue here it
116:55 - should promise and the
117:07 - song inject the
117:15 - repository inject
117:20 - repository and we we have to provide the
117:24 - entity which is
117:41 - song so everything is fine you can test
117:44 - without a sync V by default it should
117:48 - return the
117:51 - promise
118:10 - HTTP let's create a new
118:17 - song we also need
118:21 - lyrics
118:37 - I'm going to send the
118:40 - request
118:42 - amazing we have a song you can verify
118:46 - from the
118:50 - database you can see that that I got the
118:53 - first record this is the lyrics duration
118:57 - and the release
119:07 - date now it's time to implement find
119:13 - all it's easy to implement the find all
119:17 - all you need to
119:19 - do is provide the return type
119:23 - promise with song
119:26 - array return this do songs
119:30 - repository do find that's all you
119:32 - [Music]
119:33 - need
119:39 - and in the
119:45 - controller songs
119:51 - controller
119:52 - you can also add
120:01 - promise with song
120:20 - aray
120:29 - let's fetch all the songs from the DB I
120:33 - got the array right now we have only one
120:39 - record now we need to implement the find
120:42 - one find by ID you can create a new
120:45 - method inside the song
120:50 - service and it is taking the ID as a
120:54 - parameter and returning the promise with
120:57 - song you can
121:00 - use song repository. point1
121:12 - method and in the
121:16 - controller we need we need to pass the
121:20 - ID as a integer
121:22 - and return the
121:24 - song in the
121:36 - response let me open the songs
121:40 - controller we already did
121:43 - it I'm getting the
121:45 - ID all you need to
121:49 - do is return
121:53 - this. song.
121:55 - find1 here I can
121:58 - say promise with
122:09 - song Let's test it out by sending the
122:12 - request only the based on ID you can see
122:15 - I got the first record if I try to fetch
122:18 - the second record I don't have any
122:20 - record that's why I got the
122:28 - empty let's implement the remove
122:37 - method I'm going to create a new method
122:41 - inside the song
122:45 - service it's just returning
122:50 - nothing
122:53 - or you can say delete
122:57 - result you can use
123:01 - that and
123:07 - return
123:15 - here and we need
123:17 - to use this method into the songs
123:21 - control
123:24 - ER we have to call
123:27 - it this Do song service.
123:32 - remot and we have to provide the
123:35 - ID we did not pass the ID or get the ID
123:40 - as a
123:41 - Prem I'm going to use Prem
123:46 - decorator and get it here
123:50 - ID
123:57 - and it's returning
124:01 - promise with delayed
124:16 - result we need to test it out first of
124:20 - all let's create a new
124:23 - song
124:26 - to we have a
124:28 - song lasting lever
124:31 - two the ID of the song which is two now
124:35 - you can perform the delete operation I
124:37 - would like to delete this
124:40 - record so I got the delete result we
124:44 - have successfully
124:46 - deleted if I try to fetch all the
124:50 - songs
124:52 - [Music]
124:56 - no I think I deleted with ID number one
125:00 - so first record has
125:04 - deleted and we need to use the
125:09 - update let's perform the update
125:16 - record so we
125:19 - need update method I'm going to create a
125:22 - new
125:24 - method inside the song service we don't
125:26 - have update DTU data transfer object you
125:30 - need a tip you need a new data transfer
125:33 - object for update the
125:36 - record because when you update the
125:38 - record all the fields are optional but I
125:42 - can get update result from type
125:45 - orm we don't have update song dto we
125:50 - have to create it
125:53 - I'm going to create in the
125:56 - dto update
125:58 - song Das
126:07 - d. so this time we have to copy
126:11 - everything all the fields are optional
126:15 - all I did I copied the create Song D and
126:19 - put the optional for every title for
126:22 - every
126:23 - field
126:27 - is title should be optional so I can say
126:31 - instead of empty it should be
126:35 - optional it should also cre it
126:39 - here is
126:46 - optional is
126:49 - optional now it looks good
126:56 - so we have to use the updates s
127:07 - video now we need to implement the
127:10 - controller
127:11 - function songs.
127:16 - controller that we need to get the Prem
127:19 - and we need to get the
127:23 - body need to get the pram and update
127:26 - song dto and I'm going to call this do
127:30 - song service.
127:33 - update the first one is ID and the
127:36 - second argument is update song
127:44 - tto you have to import
127:47 - it the return type should be promise
127:52 - with update result that's
128:05 - it I have found the
128:08 - issue which is this space content
128:12 - type let's try to send the update
128:18 - request duration must be valid
128:25 - presentation now it looks good so you
128:29 - can double check it from the
128:32 - database this is the record with
128:36 - id2 we have successfully
128:39 - updated the
128:41 - record we have tested the
128:47 - application in the next next lesson you
128:50 - will learn how how to implement the
128:54 - pagination now we're going to implement
128:56 - the
128:57 - pagination I'm going to use external
129:00 - package to implement pagination in
129:04 - nestjs uh first of all you have to
129:06 - install this
129:20 - package
129:22 - I'm going to register it
129:26 - here and we have to install
129:40 - it and now I'm going to add a new method
129:44 - inside the song service this time I'm
129:47 - going to call it
129:49 - paginate and I'll use paginate
129:54 - method from nestjs type or M paginate
129:58 - and it will accept the pagination
130:01 - options like page metadata when you will
130:05 - fetch the record on the pation it should
130:09 - give me the items array and we have this
130:13 - metadata total items item count items
130:16 - per page total pages and current page
130:20 - these are all the options
130:22 - inside the options object and finally it
130:24 - will return the pation and we have to
130:27 - provide our model which is
130:32 - song and we have to call the page unit
130:34 - with song
130:36 - entity we have to provide the songs
130:39 - repository and the options if you need
130:41 - to add a cury builder like filtering or
130:44 - sorting you can also do
130:47 - that but here is our control rer
130:51 - function we use the Prem now we're going
130:55 - to use security decorator and it should
130:58 - name of the field which is Page you can
131:02 - add a by default default value which is
131:05 - one and I applied the pars int and I
131:10 - have added the default
131:13 - value
131:14 - and we have another field or another
131:20 - property and I'm getting it from the
131:22 - cury prams this is the limit and default
131:26 - limit which is 10 and I applyed the pars
131:29 - into pipe operator and finally it should
131:31 - return the pagination with song entity
131:34 - if limit is greater than 100 please do
131:37 - it 100 otherwise we have to specify the
131:40 - limit or tell or add the
131:43 - limit there is a page unit method we
131:46 - created inside the song service and you
131:49 - have to provide the page and the limit
131:51 - we're getting the page and limit from
131:53 - the
131:59 - cury so you have to test it by sending
132:03 - the cury parameter page which is two and
132:06 - the limit whiches to I want to see two
132:08 - records per
132:11 - page and I want to see the page number
132:16 - two if you want to add the Sorting you
132:18 - can also do that by using the query
132:20 - Builder
132:23 - please apply sorting on release date I
132:28 - want to see the latest song on the based
132:30 - on date let's implement it or you can
132:34 - Implement by your
132:36 - own first step we have to
132:40 - create a new method
132:48 - paginate and we need these
132:52 - options I can import all of these from
132:56 - the
133:05 - method so we have the pagate
133:09 - method now we have to call it inside the
133:13 - songs
133:16 - controller you can it depends on your
133:20 - use case but I I'm going to call the
133:21 - paginate method in the find
133:25 - all so I'm going to replace my find all
133:29 - method to this find
133:43 - all we also need cury
133:50 - Prem
133:54 - it's just getting the es lint warning
134:04 - messages we also need
134:07 - default value
134:12 - pipe we need pagination from
134:17 - nestjs that looks good
134:22 - we can test
134:34 - it this time I'm going to send the
134:37 - request to fetch all the
134:39 - songs it has applied the limit 10 and
134:42 - default value which is page which is one
134:46 - over the first
134:48 - page total items item count items per
134:53 - page 10 and total Pages we have one and
134:56 - current page which is one let's add
134:59 - another
135:02 - record new song
135:07 - to let's add another record new song
135:11 - 3 let's add another record new song four
135:17 - now we have four
135:19 - songs
135:21 - you can
135:27 - say I want to see the page number one
135:32 - this
135:35 - time I want to set the limit to two I
135:39 - want to see only two records per
135:43 - page we have the items array you can see
135:47 - we have only two
135:49 - records there are total two pages we are
135:53 - on the first page and items per page two
135:58 - item count two total items we have the
136:01 - four I told you if you want to add
136:04 - sorting you can also do
136:09 - that by using the query
136:14 - Builder inside the song
136:18 - service I'm going to add curil fer
136:29 - here and we have to provide cury Builder
136:33 - not songs repository we have to fix
136:38 - it cury
136:45 - Builder let's provide the cury
136:49 - Builder
137:00 - please
137:02 - create a new song
137:05 - with let's say a new Five song latest
137:19 - date it should should give this record
137:23 - first let's create it created a new
137:30 - song I got a latest song Only the based
137:35 - on release date it means it's working
137:37 - fine
137:45 - now in this video I'm going to teach you
137:48 - how to build one toone relationship
137:50 - between two
137:53 - models one to one relation where a
137:57 - entity contains only one instance of B
138:01 - and B contains only one instance of a
138:05 - let's take an example a user can become
138:07 - an artist or an artist can have only
138:11 - single user profile so there is a one
138:13 - toone relationship between user and the
138:16 - artist we don't have an artist model or
138:20 - artist
138:21 - entity first of all you got to create
138:24 - artist entity with primary
138:27 - key and then you have to create the user
138:31 - entity because we're going to make one
138:33 - to one relationship between artist and
138:35 - the
138:36 - user I'm going to have ID field or First
138:41 - Column first name column last name
138:43 - column email column and the password
138:46 - column for user
138:49 - entity now we're going to add one to one
138:52 - relationship type or provides one to one
138:55 - decorator to add relationship between
138:58 - two two
139:01 - entities uh in the first argument you
139:04 - specify the relation type I'm telling
139:07 - type orm I would like to make a
139:10 - relationship with with user
139:13 - enti this is the type of the relation
139:16 - you specify the relation entity type by
139:19 - following this syntax AR
139:22 - function and this join column will rep
139:26 - will
139:27 - create the reference key or a foreign
139:31 - key of the user entity inside the artist
139:37 - entity so we have so we will have a user
139:40 - ID as a foreign key inside the
139:43 - artist and finally you have to register
139:46 - the user and artist entity in the app
139:51 - module now we're going to implement
139:53 - these
139:56 - steps let's create the first a new
140:04 - Branch
140:06 - so I'm going to create a new artist
140:09 - entity if you like you can use CLI
140:14 - command to generate a new entity so I'm
140:19 - going to say artist do
140:22 - entity. file I'm going to copy my
140:25 - code there is nothing here you already
140:28 - learned how to create an
140:32 - entity and next we have to create a user
140:36 - model a user entity go ahead and create
140:40 - a new folder with
140:44 - user or
140:47 - users let's keep it to
140:54 - artist so I'm going to create a new
140:57 - entity user.
141:02 - entity. P the code we have ID field
141:06 - first name last name email and the
141:10 - password and now we're going to make a
141:13 - one to one relationship I would like to
141:15 - store the user ID inside the artist
141:19 - model if you want to store artist ID
141:22 - inside the user you can also do that it
141:25 - depends on your use
141:27 - case like I want to make a relationship
141:41 - here let me do it
141:44 - here we
141:46 - need one to one
141:49 - decorator
141:53 - specify the type of relationship by
141:55 - following the syntax we would like to
141:58 - make a relationship with
142:06 - user and here we will have the user and
142:11 - the user and I also need a join
142:17 - column that's it for
142:19 - now cannot find a module user. .ts
142:29 - file so we have to import it
142:35 - manually now it looks
142:39 - good and now we have to register these
142:42 - entities inside the app module we
142:46 - created couple of new
142:48 - entities please convert these entities
142:51 - into tables I can say
142:54 - artist and we have
142:59 - user our last step is to test the
143:06 - application and I have to run my PG
143:17 - admin let me connect with post this
143:19 - database
143:30 - so it has successfully let me check my
143:34 - schema which is 45
143:37 - clone I have to connect
143:41 - it inside the tables we have the artist
143:45 - and the users
143:49 - table we have have the user ID inside
143:52 - the
143:53 - artist and inside the
143:56 - users we have for columns or ID first
144:00 - name last name email and the
144:03 - password our application is running fine
144:07 - now this is how you will make one toone
144:10 - relationship between two
144:15 - entities now we're going to talk about
144:18 - how to implement many to many
144:19 - relationship
144:21 - ship many to many relationship is a
144:24 - relation where a contains multiple
144:27 - instances of B entity and B entity
144:31 - contains multiple instances of
144:38 - a let's take an example many artists can
144:42 - publish many songs and multiple artist
144:46 - can belong to one song or multiple
144:49 - artist can publish multiple
144:53 - songs we have a multiple many to many
144:58 - relationship inside the artist nestjs or
145:02 - type orm provides many to many
145:05 - decorator this will specify the target
145:07 - relation
145:09 - entity and this is the inverse side of
145:12 - the
145:14 - relationship and it will have the songs
145:19 - array and on the song we will have the
145:23 - artist array we have a many to many
145:27 - decorator the target entity in the song
145:30 - we have Target entity which is
145:33 - artist and the second argument
145:37 - specify the inverse side of the
145:40 - relationship inside the artist we have
145:44 - songs property that's why I can access
145:46 - the artist. songs and inside the
145:51 - artist entity we have song. artist
145:54 - that's why I can access the artist from
145:58 - this song entity song. artist that is
146:02 - the inverse side of the relation when
146:05 - you set the casc to
146:08 - true it means you can create or update
146:13 - the record while creating a new song or
146:17 - an artist I'll teach you the benefits of
146:20 - ask
146:21 - getting when you implement the many to
146:24 - many relationship you you need a joint
146:28 - table many to many imple uh relationship
146:31 - always work with third table which
146:35 - should be joint table and I rename it to
146:37 - songs artist and this songs artist will
146:41 - have primary key of the song and the
146:44 - primary key of the Artist as a foreign
146:49 - key
146:55 - and we also need to refactor some create
146:57 - song dto instead of using EST string EST
147:01 - string we going to we are going to get
147:04 - IDs from the request parameter IDs of
147:07 - the artist and IDs of the artist in the
147:10 - update song video and then you have to
147:13 - register the artist entity in the songs
147:17 - module that's because I want to the
147:20 - artist repository inside the songs
147:24 - modle and finally you need to refactor
147:27 - the create method we're going to get
147:30 - artist here the first
147:33 - step we are going to get this artist IDs
147:37 - from the request object or request
147:40 - parameter or the request
147:42 - body and then we will find all the
147:45 - artist only based on IDs and finally
147:48 - here we are going to set the song do
147:50 - artist equals to artist if you have set
147:54 - the casket to true just like we have
147:56 - done it done it here cascading we set to
148:00 - true now it will set the relationship
148:02 - between songs and the artist it will
148:06 - automatically create the record with
148:09 - third table which is the joint table
148:12 - here here it will create a record it
148:16 - create records in the songs artist table
148:19 - by by setting the relation with this one
148:21 - songs. song do artist should be artist
148:25 - and finally we're going to save the song
148:27 - in the using song
148:30 - repository and you can test the
148:32 - application now um let's implement it
148:40 - first so we have many to many
148:46 - relationship I'm going to add this
148:48 - relationship in inser the
148:55 - artist I'm going to do it
148:59 - here this specify the target relation
149:06 - type and we don't have we we did not
149:09 - create the song. artist inside the song
149:15 - entity now we have the songs array let's
149:18 - import many to many
149:23 - I'm also going to implement it
149:25 - here many to many
149:28 - decorator the target entity in our case
149:32 - it's an
149:34 - artist and it's going to take the
149:38 - artist let's specify the inverse side of
149:41 - the relation artist dot
149:48 - songs and we will have join
149:52 - table I'm going to name it
149:56 - to songs artist or artist song let's
150:00 - take it the songs
150:03 - artist and finally I'm going to specify
150:06 - the artist
150:18 - array
150:22 - duplicate
150:25 - identify yeah I don't need this type
150:31 - because I'm not getting the string array
150:34 - from the artist instead of I'm getting
150:36 - the array of the artist from the request
150:48 - parameter
150:53 - we added many to many relationship
150:56 - inside the song model or song
150:59 - entity and we forgot to set the
151:02 - cascading to
151:05 - True here you can do it inside
151:12 - here G SC to
151:18 - true
151:24 - now we need to refactor the create song
151:33 - dto I have to
151:36 - refactor
151:38 - from it should be
151:41 - number and the
151:44 - first argument is an
151:48 - empty and and it looks
151:53 - good similarly we have to refactor the
151:56 - update song
151:58 - dtoo it should be number array of
152:04 - numbers the first argument is
152:09 - empty looks good now we need to register
152:12 - the artist entity inside the songs
152:15 - module so we can access the artist
152:17 - repository inside the song service
152:22 - I I'm saying to type orm I would like to
152:25 - access the artist repository inside the
152:28 - songs module or the song
152:30 - service that's why I have to register it
152:35 - here and finally we need to refactor
152:39 - create
152:41 - song I can say create uh inside the song
152:47 - service so you can do it too if you want
152:51 - here we have
152:53 - to find all the
152:59 - artists on The based on
153:03 - ID then we have to set the
153:07 - relation with artist and
153:11 - songs so you can do it but first of all
153:14 - we have to
153:17 - inject the Repository which is
153:21 - artist I can say
153:24 - private artist
153:27 - repository and
153:30 - repository I can say
153:46 - artist let's get all the artist
153:55 - you have to add a Sync
153:59 - here this do song artist
154:04 - repository find by IDs I can use that
154:08 - method provide the artist ID from the
154:12 - song
154:14 - dto
154:16 - artist now I can set the relation
154:20 - with song. artist it should be artist so
154:25 - we have set the cascading it will create
154:28 - a relation many to many relation with
154:30 - songs and the
154:32 - artist now it's time to test our
154:37 - application rest
154:41 - client here we have to send the post
154:43 - instead of artist we need to send the
154:47 - IDS of the artist
154:50 - a user can become the artist so we don't
154:53 - have any record in the artist and the
154:55 - user model you have to create it
155:01 - manually so I'm going to
155:05 - refresh you can see we have the third
155:08 - table which is songs
155:10 - artsts is
155:13 - not artist we have to fix
155:18 - it
155:31 - inside
155:32 - this inside the
155:35 - songs
155:40 - entity here we have to fix
155:44 - it
155:48 - this
156:09 - I'm going to refresh the
156:12 - table get it off this table you can drop
156:17 - it delete or drop yes now we have song
156:23 - artist with song ID as a foreign key of
156:27 - the song
156:28 - model artist
156:36 - ID we don't have any user right now I
156:40 - want you to create it manually let me do
156:48 - that
156:52 - I'm going to add a new record with ID
156:56 - one it should be
156:59 - Jane or
157:09 - saga
157:11 - Saga
157:16 - gmail.com I'm going to add anything here
157:19 - pass password let's add another
157:25 - user I can say
157:29 - Jane and I can say
157:33 - do Jan at
157:38 - gmail.com password 1 2 3 4
157:41 - 5 now you can save the record so we have
157:46 - two users right now
157:50 - if you want you can also add another
157:52 - user or artist I can say
157:58 - Martin
158:01 - gar
158:03 - Martin at
158:07 - gmail.com 1 2 3 4
158:10 - 5 let me save the record so these two
158:15 - users are the artists but we need to
158:17 - make a relation inside the
158:20 - artist
158:28 - table let's add a new record with ID and
158:31 - here we have to add a artist
158:37 - ID let me double check
158:41 - it yes one and the three
158:45 - one we have to add
158:48 - another artist one the ID should be
158:52 - three so these two are the
158:57 - artist ID should be here we have to set
159:00 - the ID should be
159:04 - two now it looks
159:09 - good so what I'm saying
159:14 - that a user with ID3 is an artist a user
159:20 - with ID one is also an
159:24 - artist so one Martin and seag are an
159:28 - artist and Jane is a just a simple
159:35 - user so when you create a new record I
159:38 - can
159:39 - say let's add a
159:42 - new song so these two are all the artist
159:45 - they are going to create they have
159:48 - created a new song
159:51 - I can say you for
159:54 - me that is it right now I'm going to
159:56 - send the
159:58 - request sounds good we have a new record
160:03 - title this is the artist
160:06 - ID this is the complete
160:10 - artist so we have an art ID
160:14 - one and we
160:16 - have the relationship
160:21 - let me double check it from the artist
160:23 - and the
160:34 - songs it just created a single record it
160:39 - did not get the ID 1 and three I don't
160:43 - know what is wrong with
160:48 - it
160:59 - let's do it here one and three you for
161:03 - me
161:09 - to again I am getting the ID only
161:16 - one let's log
161:21 - the song
161:23 - d.
161:46 - artist 1 and three then what
161:51 - why 1 and three it looks
161:55 - good maybe the issue
161:58 - with
162:00 - here
162:18 - console.log
162:19 - so when you look at the artist
162:24 - record oh we have one and the
162:31 - two so one and the two instead of 1 and
162:48 - three
163:10 - let's provide the
163:13 - two you and for me
163:18 - three
163:19 - now I got the artist ID one and the
163:24 - two it will also addit a relationship
163:29 - here inside the songs and the artist I'm
163:32 - going to
163:33 - find now you can see
163:36 - that a song ID with 10 has two
163:44 - artist these two
163:47 - users user ID number three and user ID
163:49 - number
163:53 - one in this video you're going to learn
163:56 - how to implement this signup
163:59 - functionality a user can create an
164:01 - account in our application and we need
164:04 - to save the user in the
164:07 - database first of all we have to install
164:11 - dependencies I'm going to use bcrypt JS
164:15 - password bcrypt JS package to save the
164:18 - user
164:19 - password in encrypted format I don't
164:22 - want to save the password in plain text
164:25 - like 1 2 3 4 5 we have to save the
164:28 - password in encrypted format that's why
164:31 - you have to install this
164:35 - dependencies let me open my package.json
164:39 - file I'm going to add a new entry let me
164:43 - copy
164:46 - it and I'm going to paste paste it
164:50 - here we also needed to install the
164:54 - typing for
164:58 - typescript I have to add the typing in
165:01 - the dep
165:02 - dependency I'm going to put it
165:14 - here so I'm going to run npm install
165:18 - please install dependencies for
165:25 - me you can see two packages have
165:28 - installed added new two
165:35 - packages now we have to create a user
165:38 - module and the Au module we don't have a
165:42 - user module and Au module inside our
165:46 - application I'm going to use nest
165:51 - CLI to generate a new module I can say
166:09 - o we have created a new o
166:13 - module you can see
166:16 - that we also need to generate the ser
166:21 - service for
166:33 - art you can see that Au service has
166:38 - generated we also need
166:40 - controller I can say
166:47 - AU
166:54 - an au controller has created it has also
166:59 - added the entry inside the controller's
167:04 - part we have it has automatically
167:07 - imported Au module inside my app
167:16 - module here is the O module
167:21 - now we have to
167:23 - create the users module one more thing
167:27 - we did not export the odd service
167:30 - yet here I I can say I would like to
167:34 - export the Au
167:37 - service it means whenever you will
167:40 - import the Au module into another module
167:44 - like we have imported the Au module into
167:47 - app module it means
167:49 - I can inject the OD service inside the
167:52 - app
167:54 - module that is why I exported the OD
168:00 - service let's create the user
168:03 - module I'm going to create
168:05 - manually
168:07 - users. module.
168:11 - TS I paste
168:13 - it we don't have user service
168:17 - yet
168:19 - we have to create the user
168:25 - service let's use the
168:37 - nli a user service has
168:42 - created we have to import the users
168:44 - module inside the app
168:47 - module
168:50 - so we have the user service and we have
168:53 - the user
169:04 - module I've also added the type or a
169:08 - module and registered the user entity
169:11 - because I would like to use the users
169:14 - repository inside my users module I
169:17 - would like to inject the user users
169:19 - repository into the user
169:23 - service now we have to register a new
169:27 - route inside the O
169:32 - controller we're going to register the
169:35 - signup and the login route inside the O
169:41 - controller we don't have a user dto yet
169:46 - but we do not we also don't have a user
169:50 - service do create
170:00 - method I want you to create the user D
170:03 - you
170:06 - first I can say I would like to add my
170:09 - DS inside the dto
170:13 - folder
170:15 - create user. dto
170:19 - file I'm going to paste my code we are
170:23 - expecting the first name last name email
170:27 - and the
170:28 - password from Network
170:31 - request this is the network data request
170:39 - object now we got to create the create
170:42 - function inside the user service it is
170:45 - saving the user inside the database
170:50 - do we have a user
170:58 - entity now we got to do
171:00 - it inside the user
171:03 - service here we have to add the
171:07 - logic we need to inject the user
171:11 - repository I've already told you how can
171:13 - you do
171:17 - it
171:28 - I have created the create
171:32 - method what this create method is doing
171:36 - remember we have installed bcrypt JS
171:39 - package let's import it
171:47 - first
171:50 - I don't want to copy the code inside the
171:53 - Constructor
172:04 - function now it looks
172:16 - good we have to import it first create
172:20 - BPT
172:24 - package here we are just injecting the
172:27 - user
172:28 - repository we are generating Assa it is
172:32 - nothing more it's just a
172:34 - number we need a salt to encrypt the
172:37 - user password there is a hash method
172:41 - inside the bcrypt library and we are
172:43 - using this hash
172:45 - method it is going to return the promise
172:48 - first you first argument would be PL
172:51 - text password we are getting the plain
172:54 - text password from the network request
172:57 - and this is our salt and finally we are
173:01 - just saving the user depository user
173:03 - inside the
173:05 - repository and we are deleting the
173:09 - password it's an extra remove
173:13 - them I don't want to send the user
173:16 - password in the response that's why I
173:18 - have deleted deleted the user password
173:20 - and finally we are returning the user
173:22 - from the response in the in the
173:26 - response we have called the user
173:29 - service. create method here now it's
173:32 - time to test the application one more
173:35 - thing we have to refactor a little bit
173:39 - our users
173:43 - entity I'm going to make it to
173:46 - Unique should be true because because
173:48 - email should be unique for each
173:51 - user and I don't want to save the pass I
173:54 - I don't want to send the
173:56 - password in the in the
174:00 - response it is saying that when working
174:03 - with type orm there might be cases where
174:06 - you want to exclude one or multiple
174:10 - columns field from being
174:12 - selected that's why we have used the
174:14 - exlode
174:16 - now let's run our
174:22 - application and we have to save the
174:26 - user we're going to send this
174:34 - request
174:41 - HTTP we have to send request to this
174:44 - route because we created this odd /up
174:47 - route
174:49 - we have to provide first name last name
174:51 - email and the password now we're going
174:54 - to test it
175:05 - out I have caught the
175:11 - error if user service is a
175:17 - provider
175:19 - if user service is a provider it is is
175:22 - it the part of au
175:24 - module you should learn from the error
175:28 - inside the Au
175:33 - module we have to import the user module
175:36 - because I am using the user service
175:40 - inside my o
175:41 - controller or inside the a
175:45 - service let say user
176:02 - module here we are injecting the user
176:05 - service inside the O
176:13 - controller everything is good to go
176:15 - right
176:17 - now we have to test our
176:21 - application what I would like to send
176:24 - the signup
176:26 - request let's create a
176:30 - new
176:33 - account I got the error 500 internal
176:37 - error duplicate key value
176:42 - Violet unique
176:46 - key do we have a
176:49 - user inside our database can say John
176:53 - one
176:54 - two still we are getting the same value
176:59 - same
177:00 - error cury
177:02 - failed error duplicate Cube value viate
177:07 - constraint we have changed a data entity
177:11 - and the table we have
177:14 - to we have changed the database Act I
177:18 - have added two new entries unique
177:21 - constraint and the
177:23 - exclude so we need to drop our
177:29 - schema and let me do
177:35 - it I cannot
177:39 - drop we did not use
177:42 - migrations at the end of this module
177:45 - I'll show you how to use the migration
177:49 - whenever you need to update a database
177:51 - you have to create a new
177:58 - migration what I want to
178:00 - [Music]
178:09 - do I want to disconnect from the
178:14 - database Spotify
178:16 - clone now I would like to
178:29 - delete it is used by some
178:38 - other let's use
178:41 - another database I can say
178:47 - one
178:52 - I found this is the shortcut to handle
178:54 - this error because we did not use
178:57 - migration so I can say that now I got
179:01 - the data from
179:14 - scratch where application is running
179:17 - fine now
179:19 - let's sign
179:20 - up you can see that it has resolved the
179:24 - issue the issue was with database update
179:28 - I got a
179:30 - user when you go to the Spotify clone
179:33 - one get rid of this
179:35 - one Spotify clone
179:40 - one and we have to go to the
179:43 - tables inside the
179:47 - users
179:55 - we have a de
179:56 - cord email john1 12@gmail.com and this
180:00 - is the password in encrypted
180:08 - format in this lesson you are going to
180:12 - learn how to perform login request when
180:17 - user sent the login request we have to
180:21 - verify the user from our database we
180:24 - have to decrypt the user password and
180:27 - compare the user password we're going to
180:30 - implement Json web token
180:34 - authentication a user provides the
180:37 - credential like username and password to
180:39 - the
180:40 - server then our server will generate the
180:44 - Json web token and send back to the user
180:49 - it will have the header payload and
180:52 - signature don't worry I'll teach you
180:55 - everything when client reive the Json
180:58 - web
180:59 - token if you are building front-end web
181:02 - application you can save the Json web
181:05 - token in the local
181:08 - storage when user want to receive or
181:12 - user wants to receive protected rout he
181:16 - must need to provide JWT token in the
181:20 - request
181:22 - header and server will receive the JWT
181:27 - to token from the request
181:29 - header and it will verify or validate
181:33 - the token if token validated
181:36 - successfully it will allow you to access
181:38 - the protected route you will learn how
181:42 - we are going to implement Json web token
181:44 - authentication we're going to use
181:46 - passport passport
181:49 - strategy or passwort package you have to
181:52 - install these two
181:56 - packages I'm going to install it in my
182:01 - dependencies we have to run npm let
182:05 - me hold on we did not create a separate
182:12 - Branch module number
182:15 - six lesson number two
182:17 - [Music]
182:20 - now we have
182:21 - it npm
182:37 - install we have installed two
182:41 - packages the next step we have to create
182:45 - a login
182:46 - route I can create inside my o
182:49 - controller let's create a new login
182:52 - route we don't have a login D yet we
182:56 - also don't have a login function inside
182:59 - the OD service
183:02 - yet let's create a login
183:08 - function inside the OD
183:12 - service au. service here we have to
183:16 - create the log
183:18 - function and we
183:20 - also need to get user service as a
183:31 - dependency let's create a new
183:37 - method first of all we are trying to
183:39 - find the
183:42 - user on the based on
183:46 - email if user found it should give me
183:49 - this
183:53 - user let's complete this step first we
183:57 - have to find the
183:58 - user we did not create the find one
184:03 - method I can say that inside the user
184:09 - service let's create a find one
184:12 - method it is going to take the partial
184:16 - as a user
184:19 - and we're getting the email or we can
184:21 - let's try to use the login
184:24 - dto login
184:29 - dto if it did not find the user it
184:32 - should return the unauthorized access we
184:35 - have to find the user only based on
184:37 - email we don't have login dto let's
184:41 - create a login
184:45 - dto inside the AU
184:50 - dtos I can create
184:54 - login. D.S
184:57 - file so we have the login
185:06 - dto I got the
185:09 - email we also need to import login
185:16 - dto we also need to import user
185:22 - entity and it should return the user
185:26 - that's
185:28 - it now the second step is we have to
185:31 - compare the user
185:33 - password inside the OD service the
185:36 - second step we have to compare the user
185:39 - password I have to import the
185:43 - bcrypt import Star as bcrypt from bcrypt
185:50 - now I can compare the password with
185:53 - plain text password and user encrypted
185:57 - password if password
186:00 - matched then we have to return the
186:03 - user and delete the user password if
186:06 - password did not match we have to send
186:09 - unauthorized
186:10 - exception that is it right
186:16 - now
186:30 - we did not inject private Au
186:38 - service now I have called the
186:41 - dto login method and provided the login
186:46 - dto
186:49 - let's try to send the login
186:55 - request rest
186:57 - client.
187:00 - HTTP we have created a user with John
187:06 - 12 John 12 run the
187:16 - application
187:19 - let's send the API request to login
187:24 - user it should be 3,000 not a 3,000
187:31 - one we successfully got the user back in
187:35 - the response let's say I'm going to
187:37 - provide the invalid email I got error
187:41 - cannot find user if I provide the
187:44 - invalid
187:46 - password I got password did not match
187:48 - and unauthorized it's working fine
187:52 - now but our goal is to send the Json web
187:57 - token when user made successfully login
188:00 - request it should send the Json web
188:03 - token in the response in the next lesson
188:06 - I'll teach you how to create Json web
188:08 - token and how to send the Json web token
188:10 - in the
188:12 - response we have found the user on the
188:15 - based on email and we have encrypted the
188:18 - user
188:20 - password if user has logged in
188:22 - successfully we need to send the Json
188:24 - web
188:26 - token and when you will apply
188:29 - authentication on protected
188:32 - route you have to send the Json web
188:35 - token in the
188:37 - header we're going to use nestjs JWT
188:41 - package and passport JWT
188:45 - package and then we will import Port jwd
188:49 - module you have to provide a unique
188:54 - key you have learned how to create the
188:57 - login function and
189:00 - we you have to refactor it right now you
189:03 - have to send the access
189:05 - token you can create Json web token by
189:10 - using JWT
189:12 - service this is the provider you can
189:14 - inject it here as a service provider
189:19 - then I will move my constants into a
189:23 - separate file au. constants
189:25 - does and you have to register the JWT
189:29 - module and update o constant Secrets I
189:34 - also updated the expiry date of Json web
189:40 - token it will be expired after 1
189:46 - day we going to have JWT service we are
189:50 - extending it from the passport
189:54 - strategy remember I'm using the nestjs
189:57 - passport
189:58 - package and we have passport jwd
190:03 - strategy here it is just extracting the
190:07 - token from the
190:09 - header we are checking the Json web
190:12 - token expiry
190:14 - date or expiry validation or expire
190:18 - duration here you have to provide your
190:21 - secret key which we have
190:23 - saved and then finally we're going to
190:27 - have validate method it is returning the
190:29 - user ID and the
190:32 - email when you apply the
190:37 - oard oard JWT oard will call this
190:42 - validate
190:43 - function you have to register the JWT as
190:46 - a provider then this is how you will
190:50 - Implement authentication you got to
190:52 - create a guard it's like a middleware in
190:56 - expressjs if you want to implement role
190:58 - based authentication you need
191:02 - guards we have jwd odard it is extending
191:07 - oard from the
191:09 - passport if you want to add your own
191:11 - custom logic you can do it
191:13 - here this is how you will make your
191:16 - route
191:18 - protected by using the gwd O card and
191:23 - finally you have to apply you have to
191:27 - send the authentication request like
191:31 - first of all you got a
191:33 - login login route will give you the Json
191:37 - web
191:38 - token then you can access your protected
191:42 - route like this is the protected route
191:45 - profile is the protected route
191:47 - only authenticated user can access this
191:50 - profile route so you have to provide the
191:52 - validation token which is this one Json
191:55 - web token in the authorization barrier
191:58 - it's a
191:59 - scheme and it will allow you to access
192:02 - the
192:03 - route so let's implement it first first
192:06 - of all we have to install a couple of
192:12 - dependencies
192:15 - here passport
192:20 - JWT nestjs JWT and passport JWT strategy
192:25 - I also need dep dependency which is
192:28 - typing of
192:30 - typescript let's do it
192:36 - here and we have to install the
192:46 - dependencies
192:54 - these packages have
192:57 - installed now you are able to use JWT
193:01 - module let's use inside the app
193:15 - module we have to register
193:20 - it we will move this constant into
193:23 - separate file but right now I'm going to
193:26 - do it in this
193:30 - way JWT module. register and this is the
193:33 - secret
193:37 - key and finally we have to refactor our
193:41 - OD
193:46 - service
193:48 - if everything is
193:50 - fine then we can use Au or JWT
194:07 - service you have to add this return type
194:10 - return
194:16 - type
194:18 - if password mashed generate adjacent web
194:23 - token or create a pad
194:28 - object I'm going to create a payload
194:43 - object now we are just adding email
194:48 - and the user ID inside the payload and
194:52 - it is generating the Json web
194:59 - token let's create a separate file for
195:02 - the
195:03 - constants can say o/c
195:08 - constants
195:11 - do let me refactor it
195:15 - here
195:18 - one more thing you got to register the
195:20 - JWT module in the Au module instead
195:24 - of app module that was a
195:28 - mistake so this is our authentication
195:31 - [Music]
195:32 - module we have to register it
195:45 - here out constants do
195:59 - Secret and you have to
196:03 - provide sign in
196:13 - options
196:15 - options we have expiry date which is one
196:20 - day so we have registered the jwd
196:26 - module now you have to create jwd
196:31 - strategy I can
196:33 - say JWT
196:37 - strategy dos it's nothing more it's a
196:42 - service or provider you can inject
196:45 - it
196:54 - injectable export class JWT
197:01 - strategy passport strategy it is going
197:04 - to provide the
197:06 - strategy passport
197:15 - JWT
197:17 - now we have to call Super
197:22 - Constructor and you can
197:24 - extract the
197:27 - header from Au header as a barrier
197:36 - token and we have to provide the ignore
197:40 - expiration check the expiry
197:43 - date secret which is our secret key
197:47 - ke and we will have the validate
197:53 - function whenever you apply at the O
197:56 - card this validate method will be
198:15 - called
198:17 - our next step is to register GWT
198:22 - strategy in the O
198:25 - module I have to register it here JWT
198:33 - strategy now you have to create the
198:37 - guard which is
198:39 - JWT guard
198:45 - dos
198:50 - export class JWT
198:57 - guard it is also a class or service
199:01 - provider that's why I I'm using the
199:07 - injectable and we have to extend it from
199:11 - the
199:12 - passport from the odard which is from
199:16 - the the njs passport
199:26 - package make sure you say this is the
199:32 - JWT if you want to extend this JWT guard
199:36 - you can do
199:40 - this our final step is to apply the O
199:45 - card to the public public route let's
199:48 - say I want to protect this route I did
199:52 - not create it
199:54 - yet let's say get
200:02 - profile and it is going to take
200:10 - request return request.
200:15 - user
200:21 - should be
200:23 - decorator now we have
200:25 - to let's do it without
200:29 - card npm Run start
200:45 - f
200:49 - our application is running now let's
200:52 - send the login request you will receive
200:56 - the access
200:57 - token I'm going to copy
201:01 - it and I going to paste it
201:04 - here access
201:09 - token now let's access the
201:15 - profile
201:26 - slash profile because we created the
201:29 - profile route in app
201:33 - controller I'm going to send the request
201:35 - cannot access the
201:45 - profile
201:52 - I do not add the
202:06 - route I can access the profile route I
202:10 - got the 200 status
202:13 - code it means route is working fine if I
202:17 - apply the authentication
202:20 - guard I can say use roles
202:25 - or use
202:29 - roles use guards
202:32 - yep I can mention my guard which is or
202:40 - guard if you have what in Express JS
202:44 - it's nothing more it's like a
202:47 - middleware this oard function will run
202:50 - before executing the get profile
202:54 - function this function runs before
202:57 - request Handler which is get
203:05 - profile oh it should be jwd o guard jwd
203:09 - guard not and this not this one o
203:15 - card
203:23 - let's rename it to JWT o guard not a JWT
203:31 - guard JWT oard it looks
203:45 - good
203:53 - let's try to access the profile
203:56 - route status 401 which means you did not
204:01 - provide the access token please provide
204:04 - the access token if you want to access
204:07 - this private route so you can provide
204:10 - the exess token by using this format I
204:14 - pasted the
204:15 - token awesome I got the user ID and the
204:23 - email I have applied the OD card and
204:27 - this JWT
204:31 - strategy method will be called first
204:34 - they are going to run the Constructor
204:37 - and then they are going to use the
204:39 - validate
204:44 - function in this lesson I'm going to
204:46 - teach you how to implement role-based
204:49 - authentication what is role-based
204:52 - authentication if your application has
204:54 - multiple roles like artist manager user
204:59 - accountant CFO person you can have a
205:02 - different functionalities for each role
205:05 - in Spotify clone when you look at the
205:07 - Spotify clone only artist can upload a
205:11 - song If you are a user like let me show
205:16 - you you with the help of
205:17 - Spotify
205:19 - web.
205:31 - Spotify
205:32 - like if I go to my
205:38 - profile I don't have any feature to
205:41 - upload a
205:43 - song Only approved artic can upload the
205:47 - song or delete the
205:49 - song in this way you can divide your
205:52 - application into multiple
205:59 - roles we have create songs
206:03 - endpoint I would like to restrict this
206:06 - endpoint for other users only artists
206:10 - should access this create song
206:14 - endpoint we don't have artist module we
206:17 - have to create artist module then we're
206:19 - going to implement the artist module
206:21 - into import the artist module into app
206:25 - module we have to write a method find
206:30 - artist on the B on user ID then we got
206:33 - to add a logic here inside the login
206:37 - method we will save the artist ID in the
206:40 - payload object and then you have to
206:43 - create a new payload
206:44 - type and finally you need JWT artist
206:49 - card we will have a separate card for
206:54 - artist we are extending the jw2 remember
206:58 - I told you if you want to customize or
207:02 - add a logic in the guard you can do that
207:04 - it's just returning a super
207:07 - Constructor and here we are using the
207:10 - handle request method this function will
207:14 - check if you have art artist if you are
207:17 - an artist then it is going to return the
207:20 - user otherwise it will throw the
207:22 - exception we have to refactor the
207:25 - validate method in GWT strategy we need
207:28 - an artist
207:29 - ID then here you will have to apply JWT
207:35 - artist guard on the create song
207:38 - endpoint you can do that as well or you
207:41 - can follow me let me implement
207:45 - it
207:48 - let's create the artist
207:57 - module here we have the artist module it
208:00 - has already imported into my app
208:04 - module this one the artist
208:12 - module we also need R service
208:19 - next generate service and I can say
208:35 - artist you have to import type orm
208:39 - artist
208:41 - entity module. for feature because I
208:44 - would like to use
208:46 - repository here artist repository we
208:49 - have to provide the Artist as an
208:56 - entity so we have the artist
208:59 - service and we also need artist
209:03 - controller
209:06 - artist I can use a nest generate
209:10 - controller
209:15 - artist
209:17 - now we have the artist
209:24 - controller now we're going to create the
209:27 - find artist
209:30 - method I'm going to copy my
209:33 - code inside the artist
209:39 - service let's do it
209:42 - here we need to import couple of
209:45 - dependencies
209:53 - we have to find the artist on the based
209:56 - on user
210:04 - ID our next step is to refactor the
210:08 - login
210:14 - method inside the art
210:19 - service we have to add R
210:22 - service
210:44 - injected we need to add a artist
210:50 - ID inside the payload type inside the
210:55 - payload if password
210:58 - matched find if user is an
211:02 - artist then we need to add the artist ID
211:07 - into the
211:10 - payload what I can
211:14 - say because course I can save the artist
211:18 - ID in the payload
211:22 - object user do p. artist
211:28 - ID should be it is saying that you don't
211:33 - have artist ID in the
211:37 - payload you can create a payload type
211:40 - inside the types p.
211:44 - type
211:53 - I can say types.
212:03 - yes now I can access it I can Define the
212:07 - P
212:13 - type it should be user
212:28 - ID we have mentioned the artist ID is an
212:32 - optional
212:34 - property now we need to have JWT oard I
212:38 - told you how can you implement it we
212:42 - already implemented the O
212:44 - card let's say I'm going to create a new
212:49 - guard inside the
212:52 - O I can say
212:54 - artist JWT
212:59 - godts export class
213:03 - artist JWT
213:13 - guard extends o guard
213:24 - JWT it's a Pur it's a service that's why
213:29 - I have to use the injectable it's a
213:31 - service
213:44 - provider
213:46 - if I will write the can
213:49 - activate you can see that I got the code
213:53 - all I need to call the super
213:56 - Constructor super do can activate and
213:59 - provide the
214:02 - context yep everything is fine you also
214:05 - have handle
214:08 - request now you can write your logic
214:12 - here if there is an error or there is a
214:15 - no user then you have to throw the
214:18 - unauthorized
214:20 - [Music]
214:24 - exception if everything is good to go
214:27 - you have
214:30 - to return the
214:33 - user if there is an artist ID then we
214:37 - should return the
214:42 - user get rid of the extra arguments I'm
214:46 - not using
214:52 - them when you apply the artist JWT card
214:57 - it should call the handle request and it
215:00 - will extract the user and try to check
215:05 - the artist ID from the
215:08 - user if you want to log the user you can
215:11 - also do that I will show you what will
215:14 - happen inside the user
215:17 - we created the JWT AR
215:20 - card JWT o
215:23 - card jwd arst
215:27 - card then we have to refactor a little
215:30 - bit validate method in the JWT
215:35 - strategy we can add the
215:39 - artist it should be P
215:44 - type
216:11 - now it looks good we have the user ID p.
216:14 - email and p. artist
216:18 - ID and
216:20 - finally we have to apply the jwd artist
216:25 - card on your protected endpoint in our
216:30 - case we have the songs create endpoint
216:34 - we have to protect it for other
216:39 - users all you need to apply JWT artist
216:44 - card
216:47 - and inside the songs
216:51 - controller I can restrict this endpoint
216:55 - from other
216:59 - users I can say that
217:03 - jwd artist JWT
217:14 - C
217:16 - if you want to log in the request you
217:19 - can do
217:25 - that let's try to do it
217:35 - here request decorator and
217:44 - request
218:09 - I think it should be
218:13 - request it's not a requ request this
218:19 - one
218:21 - request nexts commment and then we have
218:24 - to access the
218:37 - request why it's giving me the
218:44 - error
218:55 - I have to do it
218:58 - here and
219:03 - request now it looks
219:05 - good I can log request.
219:14 - user
219:16 - let's start the
219:32 - application I got the
219:36 - error the O JWT
219:41 - strategy JWT strategy what I did wrong
219:51 - oops forgot to
219:56 - add I forgot to add closing
220:14 - parenthesis
220:17 - if you go to the artist table you will
220:19 - not see any record because we don't have
220:23 - any artist record it's an
220:27 - empty if you go to the
220:32 - users how many users we
220:36 - have I have only single user now I would
220:40 - like to make the
220:42 - artist what I can say what is wrong
220:46 - is au module is a valid njs
220:50 - module Artist Artist
220:55 - service I think we have to
220:59 - import the artist module here inside
221:03 - the are we
221:05 - using
221:07 - the rst
221:10 - service yes we are using the RT
221:13 - service that is why I need to
221:17 - import the artist
221:20 - module and inside the artist
221:24 - module I can say I have to export artist
221:30 - service I want to teach you how to
221:33 - handle errors you must know you must
221:35 - familiar with error
221:44 - handling
221:48 - our application is running
221:52 - now first of
221:56 - all we have to create a new
222:01 - artist I can say let's sign up a new
222:04 - user or I can say that sign up artist
222:09 - let's say
222:12 - that it should be let's say c
222:18 - Martin
222:25 - Garrick Martin
222:31 - Garrick we have registered a user which
222:34 - which should be which could be an artist
222:37 - so if you want to make this user Martin
222:39 - Garrick to artist you have to update it
222:42 - manually but I did not create the
222:44 - endpoint but you can do that I taught
222:46 - you how to do
222:49 - it let's first of all the ID is
222:54 - to I'm going to open all the
223:00 - artist and we have to add the
223:06 - entry this is user number two and
223:08 - finally you have to save
223:11 - it now Martin is an artist
223:16 - so I have to log in as in Martin
223:19 - gar I can say sign up artist
223:24 - or login
223:28 - artist get rid of first name and the
223:30 - last name let's send the login
223:34 - request it should be
223:36 - [Music]
223:40 - login I got the
223:44 - token
223:46 - now if you check the
223:52 - profile it should have the artist ID you
223:56 - can see that this is the artist
223:59 - ID this is the user
224:02 - ID this is the artist ID from the artist
224:06 - table this
224:10 - one so it's working fine now when you
224:14 - have to
224:16 - create I for I got I I have to get the
224:20 - token
224:21 - again let's save the
224:25 - [Music]
224:28 - token the token will be deleted after
224:30 - one day I can say that arst token
224:43 - temporary if I try to create create a
224:45 - new song it should give me the
224:48 - unauthorized because you are not an
224:50 - artist and you did not provide the
224:51 - authorization
224:53 - token
224:55 - authorization b e a
224:59 - r a r e
225:03 - r now I can say we have artist which is
225:08 - one Mart Martin Garrick has an animal
225:12 - song let's say they want to publish this
225:14 - song
225:18 - I have the
225:21 - artist now it's working fine this is the
225:26 - user ID email and the artist ID user ID
225:29 - email and the artist ID so we got this
225:33 - one artist and the ID colon
225:43 - one
225:54 - we have successfully created the
226:08 - endpoint I can say request.
226:13 - user
226:34 - let's create a new song from Martin
226:39 - Garrick say love
226:43 - again so this is the request. user user
226:47 - ID email and the artist
226:51 - ID in this lesson I'm going to teach you
226:55 - how to use or how to enable how to
226:58 - create two Factor
227:00 - authentication you're going to learn how
227:02 - to implement two Factor
227:05 - authentication if you don't know about
227:07 - two Factor authentication you can read
227:09 - this text a user enters the username and
227:13 - password on a login page page after
227:16 - successful initi initial
227:19 - authentication the system sends you the
227:22 - onetime password or onetime
227:25 - token for the verification a user may
227:28 - provide the onetime code generated by
227:31 - the authenticator
227:33 - app and send to the system then system
227:36 - validate this token if token has
227:39 - validated then you are able to
227:41 - authenticate then you are able to access
227:44 - the route
227:48 - we're going to use third party package
227:50 - to implement two Factor authentication
227:52 - Speak Easy and we need a typing first of
227:56 - all I would like to show you the demo
227:58 - how two Factor authentication works I
228:02 - already implemented in my development
228:04 - project I can show you the demo first of
228:06 - all you got to log to the user I got the
228:09 - access token we're going to create a new
228:13 - endpoint to enable the
228:16 - authentication this endpoint will enable
228:19 - the authentication for the user and it
228:22 - will create a secret key let me show you
228:26 - I'm going to provide this text I
228:29 - provided the
228:30 - token now I got this secret key and I
228:34 - got this response from the Speak Easy
228:37 - package base 32 I saved this base 32
228:41 - string to my database table for the user
228:44 - is for the user
228:46 - table a user has this
228:50 - record now I I I got this secret key if
228:55 - you have authenticator app Google
228:57 - Authenticator you
228:59 - can you can place the secret
229:04 - key I have enabled the Google Chrome
229:08 - extension I want you to do it when you
229:11 - look at Chrome Google Authenticator you
229:15 - have to enable this
229:17 - extension now I
229:20 - got this authenticator if you have
229:23 - Google Authenticator on your phone or
229:25 - you can install it all you need to do is
229:28 - to add a new app you can also generate
229:33 - the QR
229:34 - code with this OTP path Ot Ot paath OTP
229:40 - o URL you can generate QR Code by using
229:44 - this this
229:46 - URL but you can add manual entry for T
229:50 - testing Sam profile this is the same
229:53 - user the name of the user this is the
229:56 - secret key now I started getting a
230:01 - unique onetime
230:04 - password so I have to copy this
230:08 - password let me do it again it's going
230:11 - to be removed after 1 minute I copied
230:16 - it it's going to be
230:21 - removed yep now I have to provide this
230:26 - token to validate the user I have Pro
230:30 - I'm going to provide it here we also
230:33 - need to have updated token so copy this
230:41 - one
230:43 - and
230:45 - I have to validate the
230:47 - [Music]
230:50 - token yes we have to add a new token
230:55 - because it will be
230:58 - expired now you can see you are
231:02 - verified the token has
231:06 - validated now this user has enabled the
231:09 - two Factor
231:11 - authentication if you send the login
231:14 - request
231:16 - you see this message hey you have
231:18 - enabled two Factor
231:20 - authentication you can implement this
231:22 - Logic on your front end application
231:24 - please send the token at this URL please
231:30 - send the onetime password token from
231:31 - your Google Authenticator app on the
231:34 - front end side you can send request to
231:37 - this endpoint and provide the token
231:40 - that's a complete flow of two Factor
231:43 - Authentication
231:48 - let's start implementing two Factor
231:51 - authentication we have to install couple
231:54 - of
231:55 - packages we need a Speak Easy
231:58 - package we will use this package to
232:01 - generate secret key or validate the
232:04 - token onetime password we also need
232:07 - typing add it as a def
232:11 - dependency let's run npm install
232:26 - packages have installed the first step
232:30 - you have to add two new columns inside
232:34 - the user
232:35 - entity do
232:38 - entity I'm going to add them here by
232:41 - default two factor string should be null
232:47 - and it's a Boolean property by default I
232:50 - have set to default to
232:52 - false two Factor secret could be empty
232:57 - and this is the Boolean
233:01 - value when you run the
233:04 - application it should create two new
233:06 - columns for the user property for the
233:09 - user
233:13 - table
233:23 - our application is running
233:26 - now let's refresh the user
233:43 - table I have the 2 FAA secret and enable
233:47 - 2 FAA which is a Boolean
233:52 - column now we're going to create a new
233:55 - method inside the O service to enable
233:59 - the two Factor
234:00 - authentication first of all we need
234:02 - maybe we need a
234:04 - type I can add my type here enable to F
234:11 - type or you can create an interface
234:17 - we have to type and then we need a
234:21 - method you have to create a new method
234:23 - to find the user on the based on user
234:26 - ID if user has already enabled to factor
234:30 - authentication we have to return the
234:32 - secret key if user did not enable the 2
234:35 - FAA
234:36 - authentication then we have to generate
234:39 - the secret key this is we use the secret
234:41 - key and we're going to use the base 32
234:44 - secret key and finally we have to update
234:47 - the 2fa secret 2fa key for the specific
234:51 - user and then you have to write the do
234:54 - you have to return the secret key in the
234:56 - response we got to find the user if user
235:00 - already enabled the secret two Factor
235:03 - authentication we have to return the
235:05 - saved to to f secret otherwise we have
235:10 - to generate a new secret and then you
235:12 - have to set this secret for the user
235:14 - user and finally you have to update the
235:28 - user I'm going to copy the
235:32 - code let's do
235:34 - [Music]
235:37 - everything inside the OD
235:43 - service
235:46 - I have to create a new
235:48 - method import Speak
235:55 - Easy we also need to import Toof enable
236:00 - type we don't have a method find by ID
236:03 - do we have a
236:04 - method find by ID inside the user
236:07 - service
236:09 - not we have to create the find by ID
236:13 - method
236:36 - you can also do the secret key or unable
236:41 - to factor authentication here use user
236:47 - dot let me first add a new method inside
236:52 - the user
236:54 - service let's go to our next
236:58 - step user
237:03 - service here we need this
237:07 - method I'm going to copy this method now
237:11 - we have
237:12 - defin by ID
237:20 - it is going to accept the
237:23 - ID so we have to provide the user
237:37 - ID you can
237:40 - enable two Factor
237:43 - Authentication to
237:47 - true and finally you can call user. Save
237:52 - method or no we need a
237:56 - repository to save
238:00 - it we also need another method it will
238:05 - update the secret key and enable the
238:10 - authentication you can create a new
238:13 - method
238:15 - inside the user
238:17 - service let me import the update
238:22 - results we have completed the enable to
238:26 - factor
238:28 - authentication now it's time to test
238:32 - it let's create an O endpoint inside the
238:37 - O
238:43 - controller
238:51 - I I'm going to use the guard JWT o
239:01 - guard if you if you don't
239:06 - need anybody you can create it as a get
239:10 - end
239:11 - point I can say that JW the O
239:43 - card
239:57 - [Music]
240:05 - I just imported missing
240:12 - Imports
240:34 - we have a login user sign up user sign
240:37 - up artist login user here I can
240:42 - say
240:44 - enable two Factor
240:50 - authentication
240:52 - profile
240:54 - Au enable two Factor
241:01 - authentication let me double check that
241:03 - enable to fa we also need to provide the
241:07 - authorization token so we need to get
241:10 - get the
241:12 - token I got the the access
241:17 - token provide it
241:25 - here let's send the request I got the
241:28 - secret key that's
241:31 - amazing what is the name of the user
241:34 - which is
241:35 - John if you have Google Authenticator on
241:38 - your phone you can install it manually
241:42 - I'm going to add a new
241:45 - profiles which is John
241:51 - user add your secret
241:55 - key it is generating onetime password
241:59 - for 1 minute
242:01 - only we have also saved the key into the
242:06 - user users
242:11 - table let's fetch all the US
242:13 - [Music]
242:18 - users here we have the secret key and it
242:22 - has enabled two Factor
242:26 - authentication our next step is to
242:29 - validate the onetime password
242:32 - token let me open
242:38 - it we have created a new user or
242:41 - registered a new user in the Google
242:44 - authenticator it is generating onetime
242:48 - password we have to take this token or
242:52 - onetime password and try to validate
242:55 - with our
242:56 - application we're going to implement
242:58 - this logic first of all you may you may
243:01 - need another
243:04 - endpoint validate to fa we are also
243:08 - using a JWT o card we are getting the
243:11 - request here we will have a method
243:14 - validated to f a token it is going to
243:17 - provide the user ID the logged in user
243:20 - ID and we also need to get the token
243:23 - valid validate token dto we will create
243:26 - validate token
243:29 - dto I'm going to create a new
243:32 - endpoint inside the O
243:39 - controller I created the post because we
243:41 - need to get the token you can also use
243:44 - the get and get the token
243:48 - prams JWT
243:52 - oard let's create the validate token
243:59 - dto inside the
244:03 - dto I can
244:05 - have validate
244:07 - token.
244:12 - D.S
244:16 - now we have
244:21 - to create a new method to validate to fa
244:40 - token here we need to create this method
244:44 - it is going to accept the user ID the
244:46 - token the onetime password like this
244:52 - one this one this
244:55 - one and we will find the user on the
244:59 - based on
245:01 - ID and then we have
245:04 - to get this secret key which we saved
245:08 - earlier and then you have to provide the
245:10 - token and we have to mention encoding
245:13 - which is based
245:14 - 32 if token is
245:18 - verified where is
245:20 - that if token is verified then we have
245:23 - to return verified to True otherwise we
245:26 - have to return verified to false you can
245:29 - also rapar code inside the TR catch
245:34 - block I'm going to copy my complete
245:37 - code and I'm going to paste it here
245:40 - inside the OD
245:42 - service
245:45 - the code is complete
246:02 - self-explanatory now we have to test it
246:05 - we already created the
246:09 - route inside the rest
246:12 - client
246:17 - I can use
246:18 - that and I'm going to paste it
246:21 - here I can say
246:25 - validate to a
246:32 - token validate to
246:35 - fa let me double check my controller
246:38 - validate to
246:40 - fa it's a post end point
246:46 - point and we have to app content
246:52 - type application
246:56 - Json let's provide the
247:02 - token let me get the
247:05 - token John
247:11 - user amazing we got got the verifi to
247:14 - true if I provide the invalid
247:17 - token I got the verifi to
247:32 - false I got the verified false
247:35 - because because token has expired there
247:39 - is a new
247:41 - token we successfully enabled two Factor
247:45 - authentication validated with
247:47 - token you can
247:52 - add you can also add disabled
247:55 - authentication logic or you can have
247:58 - this
248:00 - feature let's implement it by creating a
248:03 - new function inside the OD
248:06 - service it's nothing more just disable
248:10 - the authentication and or set this
248:20 - value we need to have that function
248:22 - inside the user service because we have
248:25 - repository inside the user
248:30 - service I can say
248:37 - that so we have this method disabled to
248:41 - fa now it's time to create a new route
248:44 - to disable the
248:48 - authentication inside the O
248:57 - controller I'm going to create a new
248:59 - Endo
249:10 - here
249:11 - JWT o
249:26 - there is a typo here spelling issue for
249:29 - the O
249:31 - guard J WD o
249:42 - guard
250:12 - e
250:26 - everything is fixed
250:42 - now
250:44 - let's try to send disable authentication
250:50 - request inside the Au controller this is
250:53 - the get
250:55 - endpoint I can have
250:59 - that let me paste it here
251:03 - disable authentication disable to
251:09 - fa it should be disable not an enable
251:18 - so it has disabled authentication you
251:22 - can double check it by
251:25 - login I got the
251:28 - token and let me check it from my
251:34 - DB you can see that it has dis enable
251:38 - false set the
251:42 - false
251:55 - one more thing you can do if you
251:57 - disabled the authentication you can
251:59 - delete the secret key or you can use the
252:03 - existing secret key let me let me do
252:07 - it yeah we have to disable or deleted
252:11 - the
252:12 - key
252:13 - inside the
252:16 - disable validate
252:23 - token
252:27 - disabled I can
252:30 - say to FS secret to set to
252:42 - false
252:43 - or you can set the null
252:46 - value let's try to do the null
253:05 - value let's enable the authentication I
253:09 - got the
253:11 - secret double check it from the DB we
253:15 - have enabled and we have a different
253:19 - secret
253:24 - key I don't want to save the I don't
253:26 - want to change the secret
253:29 - key you should not change the secret
253:40 - key maybe it depends on your use
253:43 - case if client disabl
253:46 - this to fa maybe he has to scan the QR
253:50 - code
253:57 - again let's disable it it looks
254:04 - good we have empty to fa and it has set
254:08 - to
254:12 - false
254:24 - I also have to add this property into my
254:42 - notes
254:46 - if user has enabled to factor
254:49 - authentication we have to customize a
254:52 - little bit Logic for the login
254:55 - method we have to send the
255:00 - link to user this one validate to F
255:05 - token this
255:11 - one if user has enabled to fa and have
255:15 - the secret
255:16 - key then you have to return this
255:22 - type go to the
255:25 - login or
255:28 - service go to the login
255:33 - method here I can add a
255:37 - logic we have to add return type new
255:41 - return type
255:44 - this
255:45 - [Music]
255:59 - one let's try to access the login
256:03 - function by sending the login
256:07 - request we have enable two Factor
256:09 - authentication it should give you the
256:11 - link not an access
256:15 - token we have to log in the
256:19 - user where is the login
256:25 - user here we
256:34 - [Music]
256:41 - have
256:44 - let's double check
256:47 - it we have empty2 FAA that's why I got
256:53 - the access
256:54 - token let's enable
256:57 - it we enabled the two Factor
257:06 - authentication let's send the
257:11 - login
257:14 - now I got the link validate to fa please
257:17 - send the one onetime password or token
257:20 - from your Google Authenticator app you
257:23 - can implement this Logic on the front
257:26 - end on front end you can send the
257:28 - request to this URL and you have to
257:31 - provide the token a user user has to
257:34 - provide the
257:35 - token so we have completed the two
257:38 - Factor
257:41 - Authentication
257:45 - in this lesson you're going to learn how
257:47 - to implement API key
257:55 - authentication each user will have its
257:57 - own API Keys when he wants to access
258:01 - authenticated route or protected route
258:04 - he has to provide the API
258:09 - Keys when you need to control the number
258:12 - of calls made to your API you can check
258:15 - from your API Keys how many times API
258:19 - Keys has
258:21 - hit if you want to identify the usage
258:24 - patterns in your API traffic you can do
258:27 - with the help of API
258:30 - Keys API key authentication is typically
258:34 - used in scenarios where multiple users
258:37 - or application need to access an
258:40 - API you can read this text you can read
258:42 - the complete
258:43 - flow we're going to use this step we're
258:46 - going to generate API Keys we can create
258:49 - and store API key for each user we have
258:53 - to create an API key
258:56 - strategy strategy service just like we
258:59 - did for the JWT
259:01 - strategy and we have to register API key
259:04 - strategy in a
259:06 - module and the step number five validate
259:09 - the user by API key and apply API key
259:13 - authentication on protected route I have
259:16 - to use external package which is uu ID
259:20 - to generate API
259:22 - key and we will have API key column in
259:25 - the user
259:27 - entity and then when we have to create a
259:32 - new
259:33 - user what you have to do you got to set
259:37 - the API key which is U ID by calling
259:41 - this method it will generate a unique
259:46 - key when you send the when you create a
259:49 - new account it should give you this API
259:55 - key and Next Step you have to create API
259:59 - key
260:00 - strategy when you provide the API key it
260:04 - is going to call this method the
260:06 - validate function and inside the
260:10 - validate you have to call validate user
260:13 - by API key and you have to provide your
260:15 - API
260:16 - key if user is validated this is how you
260:20 - will provide the API key authorization
260:23 - barrier this is my API key we're going
260:26 - to use external package passport HTTP
260:29 - barrier to apply this strategy to
260:31 - validate API Keys finally you have to
260:34 - register as a provider API key strategy
260:38 - this is our method to validate the user
260:41 - on the based on API
260:43 - key if user validated with the help of
260:46 - API
260:49 - key this is our Endo here I'm I can say
260:53 - I want to access the
260:55 - profile on the based on API key or you
261:00 - can create in the O controller use guard
261:03 - o guard you have to provide the
261:06 - barrier it means I want to apply API key
261:12 - valid ation or API key authentication on
261:14 - this
261:16 - route and I don't want to set the send
261:18 - the user back password back in the
261:22 - response that's why I deleted the user
261:24 - password and you can send the message
261:27 - authenticated with API key this is the
261:31 - user this is how you will provide the
261:34 - API key when you make the authenticated
261:37 - request I want you to implement this
261:39 - complete flow if you stuck you can
261:42 - follow my
262:00 - video Let's install the package
262:11 - first
262:18 - let's run the
262:20 - application you will get the error
262:23 - because we have two to three records in
262:26 - users table but it will find null value
262:31 - for API key we did not set the
262:34 - constraint API key should be null if
262:36 - user has signed up we can have the API
262:41 - key or if if you set the null Lael to
262:43 - true you can have a separate function to
262:46 - create the API key for the user it
262:49 - depends on your use case your company or
262:51 - your business
262:53 - logic I'm expecting the null value error
262:58 - from the type
263:02 - orm we are using this
263:11 - database
263:15 - we have all the
263:16 - [Music]
263:31 - users you can see I got the eror
263:34 - relation user contains null value which
263:36 - is API
263:39 - key you can fix two or three
263:44 - ways you can set API key value manually
263:50 - but I don't have API key
263:55 - column there is a concept we didn't use
263:59 - the
264:00 - migration but I found the hack to use to
264:04 - resolve this
264:06 - issue I can say Spotify clone 2 let's
264:10 - change the database
264:14 - Run start
264:17 - there it will take some time to create
264:20 - all the
264:30 - tables database does not exist let's
264:34 - create a
264:41 - DB
264:59 - restart the
265:07 - application the application is running
265:10 - fine
265:11 - now
265:14 - [Music]
265:27 - we have this database Spotify clone
265:41 - 2
265:47 - so we have the API
265:58 - key now we need to add the API key when
266:03 - you create a new
266:08 - account I can do it inside the
266:13 - user service or odd
266:17 - service do we have the sign up function
266:19 - [Music]
266:24 - here I think inside the
266:29 - users yes we have the create
266:32 - [Music]
266:41 - function
266:44 - I have to change a little bit logic I
266:47 - did not create a new user so I'm going
266:51 - to do it
266:57 - here we have to import this
267:10 - package we are getting the
267:17 - user.
267:20 - password delete this
267:23 - one we got it we got the API
267:28 - key yeah I can say saved
267:41 - password
267:56 - I have updated user D to user password
268:01 - and we have saved the
268:03 - password and we have deleted the saved
268:06 - password now we can we have to test it
268:09 - by sending this sign up request
268:13 - open the r
268:15 - client I'm going to send the request
268:18 - sign up request sign up
268:21 - user so it has generated the API key it
268:25 - looks
268:30 - good we have encrypted password it's
268:33 - fine
268:38 - now our next step is to create API key
268:48 - [Music]
268:50 - strategy we have to install this
269:09 - package I'm going to copy the same code
269:12 - and create a new file API key strategy
269:15 - inside the
269:17 - O API Das
269:20 - key
269:22 - Dash
269:24 - strategy. DS strategy.
269:29 - DS going to copy the
269:41 - code
269:43 - we are using the passport strategy and
269:47 - we are providing this passport HTTP
269:50 - barrier OD
269:59 - strategy we have to import or
270:03 - provide API key strategy inside the O
270:09 - module register it API key
270:15 - strategy and we have to validate the
270:19 - user on the based on API
270:23 - key I can create a new
270:26 - method I also need to find user on the
270:29 - based on API key let's add a new method
270:34 - inside the user
270:38 - service now it looks good let's create a
270:42 - new controller
270:44 - function into the O
270:47 - controller it means I'm telling to a or
270:51 - nests application I would like to
270:54 - validate this route on the based
270:58 - on API
271:01 - Key njs
271:04 - password everything is good to go right
271:08 - now we have to test the application
271:12 - run the
271:13 - [Music]
271:22 - application first of all we have to
271:24 - create a new
271:26 - account I change the email John 13 we
271:30 - got the API
271:34 - key I'm going to store the API
271:38 - key key John
271:40 - 13
271:46 - now we have to provide this API key to
271:49 - access the profile
271:53 - route access
272:00 - profile we have a get end
272:04 - point get
272:09 - http or/
272:14 - profile authorization
272:18 - basic here we have to provide the API
272:21 - [Music]
272:27 - key it's not a basic we are using this
272:30 - [Music]
272:32 - scheme barrier
272:35 - scheme b e a r e
272:38 - r now I got the user back in the
272:42 - response and it has authenticated with
272:44 - API
272:53 - key in this lesson I'm going to teach
272:55 - you how to debug nestjs application
272:58 - using VSS
273:01 - code if you don't have launch. Json file
273:05 - in vs code folder you can create
273:10 - it let's create the launch. jsn file if
273:14 - you go to the
273:19 - debug I'm going to create a new folder
273:22 - vs
273:23 - code and you can have launch. Json file
273:28 - let me copy these
273:33 - configurations so I have to start the
273:37 - application in debug mode nestjs has a
273:40 - script in package Chon
273:43 - file now you can start the application
273:46 - by running npm start Run start
273:52 - debug you can see that our debugger has
273:56 - started now I want you
273:59 - to attach a process when you go to the
274:03 - debug now you have to attach
274:07 - it you can put break points let me
274:13 - to here the O
274:15 - [Music]
274:18 - controller I'm going to put
274:23 - breakpoint let's try to send the API
274:35 - request it has stopped at this break
274:37 - point so I can see what is inside the
274:40 - request
274:43 - I have request
274:45 - body request
274:47 - client request. user you can also watch
274:52 - on a specific property the request.
274:55 - user you can see that I got the API key
275:00 - email enable to fa to fa secret this is
275:04 - a great way to debug the application you
275:07 - can find errors very easily by using
275:10 - debugging if you want to debug the
275:12 - complete flow you can do that into the
275:16 - app
275:18 - strategy what I was API API key strategy
275:22 - or API
275:24 - strategy yep we have the API key
275:30 - strategy I'm going to put break point
275:33 - here let me put the break point here and
275:36 - I would like to put the break point here
275:39 - let's send the request you you can see
275:43 - that it has first called this validate
275:49 - method it is going to find the user on
275:53 - the based on API key it has found the
275:57 - user now it is going to return execute
276:01 - this line return
276:04 - user it
276:06 - has now it has added the request. user
276:11 - you have returned API user from the API
276:17 - key strategy like this one
276:21 - nestjs has
276:24 - stored user inside the request object
276:28 - like request.
276:30 - user like this
276:33 - one and finally we have deleted it you
276:37 - can step over
276:39 - it go to the next line
276:42 - if you need to step into a specific
276:45 - function you have to use this one step
276:48 - in if you want to go out from this
276:51 - function you can press step
277:01 - out in this lesson I'm going to teach
277:03 - you the concept of
277:06 - migration migrations is like a Version
277:09 - Control for your database
277:15 - you can manage your database
277:19 - changes by using migrations migration is
277:22 - a file that contains a set of
277:25 - instructions for creating modifying or
277:28 - deleting database
277:34 - tables whenever you make changes in your
277:39 - entity you have to create a new
277:42 - migration if you want to go back to the
277:45 - previous changes there is a command for
277:47 - revert you can use that
277:52 - command once you get into the
277:55 - production right now we are building our
277:58 - application in development environment
278:01 - when we push the application into
278:03 - production you will set the synchronize
278:05 - to
278:06 - false so you have to
278:10 - manually update the changes to for your
278:14 - entities that's why I have set the
278:16 - synchronized to
278:19 - false in production you will not set the
278:22 - synchronized property to
278:24 - True migration is just a file with SQL
278:27 - queries to update database and apply new
278:30 - changes to an existing
278:32 - database I got the simple definition of
278:35 - migration it's called it's like a
278:37 - Version Control for your database you
278:40 - will keep keep track of your changes
278:43 - toward your
278:45 - schema first of all you have to move
278:48 - type orm configuration into a separate
278:50 - file these are all my type type orm
278:54 - configurations now you don't need to
278:56 - write your entities
278:59 - manually when you have to create a new
279:02 - entity you add a new entry for the
279:05 - entity now you don't need
279:09 - that I have added the regular expression
279:12 - for this path we also using the
279:15 - JavaScript because we're going to use
279:17 - migration I found it's easier to work
279:20 - with JavaScript when you are working
279:22 - with with
279:24 - migrations when you build the project
279:26 - nestjs will generate the disc
279:29 - folder this disc folder I can provide
279:33 - that path this is the JS
279:35 - file we're going to provide this type of
279:38 - file I have set this synchronized to
279:40 - false
279:42 - we have created a new data
279:44 - source when you write the script to
279:48 - migrate in package or Json file you have
279:51 - to provide the data source file this
279:53 - this data source and this data source
279:56 - has a data source object this data
279:58 - source
280:01 - object step number
280:04 - two you have to refactor type or M
280:07 - config into app module you got to
280:09 - provide data source options this dat
280:11 - data source
280:13 - options and then you have to write the
280:15 - script for type or M generate run and
280:20 - revert we're going to use all these
280:22 - scripts we will add a new column in the
280:26 - user
280:28 - entity and then we will run run the
280:31 - generate the migration based on this
280:35 - column this is the name of the migration
280:38 - at user phone where we have St about the
280:42 - migration here we have specified the
280:46 - path there is a DB folder and inside the
280:49 - DB we have migrations
280:55 - directory and finally you will run the
280:58 - migration when after creating the file
281:00 - you have to run the migration if you
281:03 - want you can implement this complete
281:05 - steps or you can follow
281:10 - me
281:12 - I'm going to create a new file inside
281:14 - the DB create a new folder inside the
281:18 - root
281:19 - directory
281:21 - DB data
281:23 - source. TS I'm going to paste this
281:28 - code my database is which is Spotify
281:36 - clone Spotify clone
281:40 - 2
281:47 - so I have to delete
281:51 - everything here we have to
281:54 - provide a data source
281:57 - options this options
282:03 - object I have completed this step number
282:05 - two now we need to add couple of scripts
282:09 - there is no logic logic here
282:12 - specifically you can copy the
282:14 - scripts first of all please build the
282:18 - project generate the JavaScript files
282:24 - then and then we are using the type orm
282:28 - npx and
282:30 - dashd I'm telling to type orm I have
282:34 - stored my database configuration inside
282:38 - this
282:39 - file if if you have to go back or revert
282:43 - the changes you will run this
282:46 - command I'm going to copy this script
282:50 - and paste it here inside the
282:56 - scripts now let's try to add a new
283:05 - column user.
283:08 - entity I'm going to add a new column
283:10 - here
283:15 - here type A
283:18 - String now finally we have to run the
283:24 - migrations npm run migration generate
283:28 - I'm using this script here you are
283:33 - specifying I have I want to store
283:36 - migration in this file migrations and
283:40 - this is the name of the file it will
283:43 - also add the
283:49 - timestamp first it is going to build the
283:52 - project then it is going to execute this
284:01 - command meanwhile I have to start it
284:03 - from the scratch I don't want existing
284:08 - database so I would like to delete
284:11 - Del my
284:14 - database I'm also going to delete this
284:18 - one because we have set this
284:20 - synchronized to false we have to add
284:24 - changes manually that's why we are using
284:33 - migrations and new file has created
284:37 - inside the DB inside the
284:39 - migrations we have this file this is a
284:42 - Tim stamp and the name of the file add
284:44 - user
284:54 - phone. so we have to create a new
285:01 - database I can say Spotify
285:08 - clone now I want to
285:11 - add all this stuff
285:21 - like inside the data source Spotify
285:25 - clone let's generate the migrations I
285:29 - can say
285:31 - that my migrations you can choose any
285:36 - name or in
285:39 - it
285:41 - it is going to take all these entities
285:45 - and creating creating the SQL
285:49 - files SQL queries for all these entities
285:53 - because right now our database is
285:55 - empty
286:01 - in we don't have
286:09 - tables
286:24 - now you can see my
286:31 - migrations if you check the database you
286:33 - will not see any table because we did
286:37 - not run the migration yet now we going
286:40 - to run the
286:50 - migration npm run
286:57 - migration
287:07 - run now it is going to execute these
287:12 - queries
287:13 - these creating all the tables and all
287:17 - the
287:34 - relationships we have the
287:39 - migrations
287:49 - there is no record inside the
287:55 - migrations I'm going to
287:59 - delete this
288:01 - migrations and this migration file
288:06 - let's create it from
288:09 - scratch
288:18 - it has created all the migration now we
288:21 - have to run
288:27 - it everything is good right
288:31 - now it has executed the queries and now
288:36 - if I refresh my tables you will see all
288:40 - the tables we have songs users but if I
288:44 - go to the
288:48 - users I will have font property I don't
288:52 - want font
288:56 - property let's edit a user entity I'm
289:01 - going to remove
289:03 - phone now let's generate the
289:06 - migration I can say removed phone
289:18 - you can see that it has created the
289:21 - migration file removed phone it is going
289:24 - to drop this
289:26 - column now we need to run this
289:30 - migration to update changes in the
289:39 - database
289:41 - let's try to check the
289:43 - column there is no phone column here
289:47 - this is how the migrations
289:50 - work this lesson I'm going to teach you
289:53 - the concept of data
289:56 - seeding data seting is a process of
289:59 - populating a database with an initial
290:01 - set of
290:02 - data when you create a new
290:06 - column inside
290:09 - here
290:14 - when you create a new column in the user
290:17 - entity let's say I would like to add a
290:21 - new
290:23 - column and here I can say this is this
290:27 - could be the phone
290:30 - number
290:32 - but when you run the
290:36 - migrations the phone number will be
290:39 - empty in the
290:41 - database so you can load your initial
290:45 - data by running the
290:50 - seeds applying CED data to database
290:53 - refers to the process of inserting
290:56 - initial data into the database usually
290:59 - when the database is first created let
291:02 - me show you the demo of
291:09 - cing
291:11 - you are going to learn how to create the
291:14 - seed service and we have a seed method
291:17 - inside the seed
291:19 - service we
291:21 - are
291:22 - running type orm queries by using
291:27 - transaction here we have placed all my C
291:30 - data when my application bootstrap
291:34 - loads it will create a new user a fake
291:39 - user and it will save into the database
291:43 - and then it will create the artist and
291:47 - save artist into the user into the
291:50 - database we also have a c data for
291:53 - playlist first of all we're going to
291:55 - create a new user then we're going to
291:57 - create a new playlist and we have
291:59 - assigned a relation between playlist and
292:02 - the user so we're going to save couple
292:04 - of
292:05 - data when you run the application when
292:09 - application will be completed
292:11 - you can verify from your
292:14 - database let me show
292:27 - you in your users table you will see a
292:31 - new user will be created so these are
292:34 - all the
292:36 - users these are all the users I created
292:39 - with fake data by using the
292:42 - seaing I also have a
292:45 - playlist it is going to pick the random
292:48 - name for a
292:53 - playlist Rap
292:55 - playlist World playlist or country
292:58 - playlist I've also have a seed for
293:06 - artist you can see that now my
293:09 - application is is running
293:12 - now when you look at the
293:18 - users you will see another users couple
293:22 - of another
293:24 - users if you look at the playlist you
293:27 - will find one more
293:29 - playlist you can also look at the
293:34 - artist you will have more artist this is
293:38 - how you can increase your development
293:43 - workflow or testing
293:45 - workflow now I want you to implement it
293:48 - by looking at the documentation I
293:50 - created for
293:51 - you
293:59 - here I don't want a new
294:06 - column first of all we have to
294:09 - install another package to generate the
294:12 - fake
294:22 - data and next step we have to create a
294:26 - seeds folder inside the
294:30 - DB
294:32 - seeds I can data seed. TS
294:37 - file I have created a new file while
294:41 - here we're going
294:42 - to do initial
294:48 - seaing you can create a separate
294:50 - function for each entity like you can
294:53 - create a separate function for seed
294:56 - songs I did not create this seed songs
295:01 - method here you can create
295:05 - that if you want to look up more
295:09 - documentation of of Faker package you
295:12 - can find from your from the official
295:15 - documentation
295:18 - page it is giving me the
295:29 - error entities Source
295:32 - playlist here I can find the
295:39 - entity
295:43 - now our next step is to create a new
295:47 - seed
295:48 - module I'm going to use type orm to
295:51 - create a new seed
295:54 - module and
296:03 - then what we are doing here we are
296:05 - generating the encrypted password I use
296:09 - the same password for each user here we
296:12 - are creating the user I got uu ID from
296:16 - API key and I got repository from the
296:21 - manager we will call the seed data in
296:25 - main.ts
296:39 - file seed module has
296:43 - created we also need a seed service what
296:47 - I can do I'm going to copy this
296:52 - code and create a new service inside the
296:55 - seed
296:57 - module see do
297:00 - service if you want you can use CLI to
297:03 - generate service we also have to import
297:06 - or register as a
297:09 - provider seed
297:19 - service cannot find um oh it should be
297:24 - SE data seat should
297:27 - be I can say this seat data seat
297:37 - data and it should be gone
297:48 - we are making connection with our
297:51 - database here I got the manager from the
297:56 - quy manager and I called this C data and
297:59 - finally we are we have started the
298:01 - transaction if transaction if any query
298:05 - has failed it is going to roll back the
298:09 - transaction
298:11 - so our final step you can read this text
298:15 - if you want to learn more about what is
298:17 - cury Runner what is
298:22 - transaction here you have to boot you
298:25 - have to call the seed method here
298:31 - whenever you want to save a data in the
298:35 - database if you don't want to save a new
298:39 - fake data you can just disable these two
298:43 - lines but let me show you the demo I'm
298:46 - going to start the
298:52 - application it is going to run these
298:55 - methods seed user it is going to create
298:58 - a new fake user seed artist and Seed
299:02 - playlist let me show you the current
299:04 - look of my
299:07 - schema I'm using spotify clone on
299:13 - database Let me refresh my
299:17 - tables uh I would like to see all the
299:27 - users there is nothing here I don't have
299:31 - any
299:34 - user you can create many users if you
299:38 - want you can use fake
299:40 - package to generate 20 15 50 55 records
299:45 - and you can and then you can provide
299:48 - into the repository user repository it
299:51 - will create all these records but I use
299:54 - a single record I just want to show you
299:57 - the process you can manipulate with your
300:00 - own use
300:01 - case one more thing I could not find the
300:05 - official package or official
300:08 - documentation or in typ orm seeding I
300:12 - got I have implemented my own
300:16 - strategy now my application is
300:20 - running you can see I have couple of new
300:25 - users you can see I have couple of new
300:29 - artist I think I will have only single
300:34 - artist yes but if you look at the
300:38 - users it has picked a random first name
300:43 - random random last name random last name
300:46 - and the email and the password and the
300:50 - API key it has generated one more thing
300:53 - if you want to look at the playlist I
300:56 - will also have a one
301:02 - playlist electronic music
301:06 - song that's how the seeding work
301:11 - works whenever you create a new entity I
301:15 - would recommend you to create a seed
301:19 - function whenever you run the
301:22 - application it is it is going to create
301:26 - a new data but I'm going to comment this
301:36 - code you can
301:38 - enable
301:41 - the
301:44 - seaing
301:46 - here if you want to make it more Super
301:49 - productive you can create a console
301:52 - command in
301:53 - njs I'll teach you in the advanced
302:02 - Concept in this lesson I'm going to
302:04 - teach you the concept of
302:06 - configurations we're going to create
302:09 - custom configur ation file with the help
302:11 - of nestjs
302:15 - config if you see our main. file I have
302:19 - mentioned the port number
302:22 - manually if you want to have a separate
302:24 - port for development project or for
302:27 - production environment you can specify
302:30 - in the environment variable we don't
302:33 - have any EnV file in if you have worked
302:35 - with
302:36 - nodejs you will have separate EnV
302:40 - environment file. EnV file for
302:42 - development and you you will have
302:45 - separate. EnV file for
302:47 - production one more thing if you look at
302:51 - our type orm
302:59 - configurations here we have type orm
303:03 - configurations I have specified a
303:05 - username
303:07 - manually password manually database
303:11 - manually I also specify the host
303:15 - manually what if you want a different
303:19 - environment variables for production
303:21 - let's say you want to deply the project
303:23 - to AWS or Hoku you need a separate en
303:27 - andv environment variables for
303:30 - production level but we did not
303:32 - Implement that logic now we need to do
303:38 - it if want to read what is configuration
303:41 - you can read this complete text I have
303:45 - explained
303:47 - configurations you may need a database
303:50 - setting for in for development and
303:54 - production you may have different API
303:57 - keys for production and API keys for
304:02 - development you can have multiple
304:04 - environment files for production
304:07 - production and testing
304:12 - nestjs provide provide config module
304:16 - we're going to use this package I'm
304:19 - going to copy
304:21 - it and I'm going to paste in my
304:24 - dependency section or if you want to
304:26 - install manually you can do that I have
304:29 - to do npm
304:32 - install in The Next Step you have to
304:35 - import config module in the app module
304:40 - this config module will have config
304:43 - service and we're going to use the
304:45 - config service to access the environment
304:48 - variables let me show you how can we do
304:50 - it package has
304:53 - installed now we need to import config
304:56 - module into the app
305:02 - module geted of these extra
305:08 - dependencies
305:16 - we have to import it here let's import
305:19 - config
305:26 - module so here we have config
305:29 - [Music]
305:33 - module after importing config module you
305:38 - have to provide the path of your EnV
305:42 - file here you have to provide the
305:46 - path we don't have any EnV file go to
305:49 - your root directory and create two files
305:53 - the first one for env.
305:59 - development for production
306:03 - level I can say en EnV for
306:07 - production this one is for development
306:10 - and this one is for
306:13 - production if you want to have a
306:16 - separate port for different environment
306:19 - you can do that but I'm going to keep
306:21 - with
306:22 - 3,000 for production you can place it
306:26 - here so we have created the EnV file so
306:30 - how can you load this EnV file we have
306:33 - to set the path in the app
306:36 - module here I have to provide the
306:38 - options configurations I can say EnV
306:41 - file path it can access the array the
306:45 - first one is do env.
306:52 - development and do
306:55 - EnV do
306:58 - production one more thing I would like
307:00 - to mention we have used the config
307:03 - module inside the config module config
307:06 - module is using do EnV
307:10 - package if you Google the
307:17 - envv this package is used to define
307:20 - environment variables for different
307:22 - environments for development and per for
307:25 - production but by default nestjs config
307:29 - package is using the
307:38 - EnV we have used this load ENB
307:49 - property so what you have to make it
307:53 - Global let's say I would like to import
307:56 - EnV module into my Au module into the
308:01 - artist module let's say I want to use
308:03 - API keys from env. development file to
308:10 - artist module you don't need to import
308:13 - config module you can use config service
308:16 - automatically but if you use if you make
308:19 - a
308:25 - global when you want to use config
308:27 - module in other modules you will need to
308:31 - import it as it standard with any Nest
308:35 - module or you can make it Global I have
308:37 - set it to Global
308:41 - so I can use config service without
308:43 - importing the config
308:46 - module now we have to create the custom
308:49 - configuration
308:52 - file you have to create a new folder
308:55 - inside the source folder I can say
308:59 - config let's create the
309:06 - configurations here you have to place
309:09 - all your
309:13 - configuration you have to define
309:16 - configuration inside the EnV
309:19 - file and this configuration dots file is
309:24 - is going to fetch or add
309:29 - validations for environment variables
309:32 - inside the
309:33 - configuration so config module is going
309:36 - to use this configuration .s file it is
309:41 - going to to extract all these values
309:45 - from config does let me show you
309:48 - how we have to load our configuration
309:51 - file custom configuration file I can say
309:55 - load you can have multiple configuration
309:58 - file you can have different
310:01 - configuration file for database you can
310:04 - have different configuration file for
310:06 - app settings or user profile settings
310:09 - something like that but I'm going to
310:12 - keep it simple let's use a simple
310:14 - configuration
310:16 - file we have to import the
310:19 - configuration now our next
310:23 - step is to test the EnV
310:27 - variable we have created the port and we
310:30 - have defined or getting the port
310:34 - from uhv and here now let's say if you
310:39 - want to access this port variable I'm
310:42 - going to do it for testing purpose don't
310:45 - do it in
310:47 - production inside the O service let's
310:51 - say I can define a new Vari new function
310:54 - get EnV
310:57 - variable you can call any function
311:03 - here here how can you use
311:06 - the configuration dots file while how
311:09 - can you get the this
311:13 - port into your a
311:16 - service like we have to inject the
311:19 - config service we have to inject the con
311:22 - config
311:26 - service config
311:30 - service remember I did not import the
311:33 - config module into the Au module because
311:37 - we have set it to Global in the app
311:39 - module so we can use config
311:45 - service config service.
311:48 - get pass it into as a integer you have
311:53 - to provide the name of your key which is
311:56 - Port when you open the configuration. ES
311:59 - file we have specified the key which is
312:03 - Port so how can you use this function
312:06 - let's say I'm going to create
312:10 - a controller function for testing don't
312:13 - do it in production I just want to show
312:15 - you the demo I can say
312:20 - test get
312:24 - EnV or you can say
312:26 - test EnV
312:31 - variable it is going to return this do
312:34 - out
312:34 - service calling the get EnV variable
312:37 - that's it do not do any fancy stuff here
312:42 - let's start the application and we have
312:45 - to test this
313:02 - route now we need to test
313:05 - it I have to send the request to this
313:09 - URL this
313:11 - endpoint we have to send the get
313:15 - request can say test
313:35 - EnV 3000 sl/ test
313:53 - amazing I got the Port Port value which
313:56 - is 3,000 it's working fine
314:01 - now now if you check the main.ts
314:06 - file we have defined the port into
314:10 - configuration we are using the port
314:13 - value manually I would like to use the
314:16 - config service here I want to get the
314:19 - Value Port value from the config service
314:22 - and I would like to use it here this is
314:24 - how you can do it you can get the config
314:27 - service instance from the by calling the
314:30 - app.get method and providing the
314:32 - instance providing the config service
314:34 - class it is going to give me the
314:37 - instance config service
314:39 - then I can use the method
314:46 - here so you can do it
314:49 - here config service you can import
314:53 - it now I
314:56 - can get the port
314:59 - value service.
315:02 - getet let's pass it as a
315:05 - number here I can say the port which is
315:14 - key get rid off this no I'm not using
315:18 - seed service we
315:33 - have our application is running fine now
315:36 - let's send the test test request test I
315:39 - got the port 3000 we successfully
315:42 - configured the port in the main.ts
315:46 - file now we also need to add our secret
315:50 - key inside the EnV
315:55 - file we are using getting the value from
315:59 - the Au constants but I don't want to get
316:02 - it from the Au constants I would like to
316:05 - add secret key inside my EnV file
316:11 - I have to place it here secret now I
316:14 - would like to use this
316:16 - secret we are using this secret inser
316:20 - the app
316:23 - module inser the Au module not app
316:27 - module here we are using the O constant.
316:31 - secret but I want to get it from the
316:34 - config
316:37 - service I want you to think about it how
316:41 - can you add or how can you get the value
316:44 - from config
316:47 - service we also need to add a property
316:51 - in the
316:53 - configuration I'm going to do it
316:55 - here and this is
316:58 - how you will get the
317:01 - value from config service we have to
317:04 - register this module as a
317:07 - async and and it is going to return the
317:10 - dynamic
317:11 - module so you have to follow this
317:15 - pattern if you want to configure Dynamic
317:19 - module Dynamic module is a feature that
317:22 - allows you to dynamically configure and
317:24 - register modules at runtime based on
317:28 - Dynamic
317:29 - conditions so we have this Dynamic
317:35 - value so what I want you also have to
317:38 - inject the config service you have to
317:41 - import the config module this use
317:44 - Factory is used to inject the config
317:47 - service and we are getting the value
317:50 - here so I'm going to copy
317:55 - that I'm going to replace my Au module
317:59 - with this
318:00 - code import config service and config
318:06 - module Imports I don't want to use the O
318:09 - constant get rid of the
318:12 - Hat we have to import config
318:16 - module we also need to import config
318:19 - service that is it
318:23 - now we have specified The Secret inside
318:26 - the
318:29 - configuration did I Define the secret in
318:32 - the production I think I did
318:36 - not if you want you can do it
318:39 - env.
318:42 - production let's restart the
319:00 - server our application is running
319:03 - successfully it means we successfully
319:05 - configured the secret key you can test
319:09 - it by sending the API
319:12 - request I have to open it
319:15 - here rest
319:19 - client I can send this signup
319:28 - request
319:29 - it's oh I got I sent the login request
319:33 - we have to send the signup request user
319:36 - has created successfully
319:40 - it's working fine now now our next step
319:44 - is to configure the DB configurations
319:47 - database
319:49 - configuration I'm going to add the
319:53 - configurations inside the my EnV file
319:57 - development
319:59 - file if you want to add a
320:03 - separate EnV file separate configuration
320:06 - for database you can do it can say that
320:09 - DB
320:15 - configuration my database is end
320:23 - test now we have to define the values
320:27 - inside the configuration. ES
320:35 - file I'm going to copy the same code
320:40 - or I need these
321:07 - values now we have to update or refactor
321:12 - the manual
321:15 - values with configuration config
321:19 - service so I I'm going to
321:22 - create a new type orm async config
321:27 - object and then we're going to use
321:29 - inside our type orm
321:33 - module let's refactor it you have to
321:37 - create it this is the same process you
321:39 - have to create this module or register
321:42 - this module as a
321:46 - dynamic I'm going to use the same
321:48 - configuration when defining the type or
321:51 - a
321:52 - module I'm going to do it
321:55 - here you can import type orm config
322:00 - options we also need to get config
322:03 - module and config
322:07 - service
322:10 - type or module
322:17 - options I got the DB host DB Port
322:21 - username DB name password entities and
322:24 - synchronize set to
322:26 - false here we are going to get it from
322:29 - the process.env
322:32 - I'm going to copy
322:35 - that code and I'm going to paste or you
322:39 - can
322:41 - say replace this text
322:49 - host inside the app module we have to
322:53 - register
322:54 - it type orm module this
322:57 - time type
323:00 - orm ASN
323:03 - config get rid of data
323:07 - source
323:24 - wrong driver I think something is
323:27 - [Music]
323:29 - missing
323:37 - postgress
323:45 - we have to use the for root async in the
323:50 - app module I think that is why it is
323:54 - showing me the
324:07 - error
324:15 - you can see that application is running
324:17 - fine now it means we have successfully
324:20 - configured the
324:22 - database we have successfully configured
324:24 - the
324:25 - settings it's working fine
324:32 - now in the previous video we have
324:35 - created the environment variables
324:39 - we have set up the DB configuration DB
324:42 - Port username password and database
324:47 - name we if you want to add the
324:50 - validation if you want to validate these
324:53 - environment variables you can also do
324:56 - that with the help of class validator
325:05 - package to implement the validation you
325:08 - have to create the env. env. validation.
325:13 - TS
325:15 - file we did not add node EnV inside the
325:21 - development or production.
325:24 - EnV I have set the Isam which
325:28 - is
325:30 - enum here I have defined the validation
325:33 - for Port DB host username password DB
325:38 - name and the
325:40 - secret we're going to use class based
325:44 - validator class validator package that's
325:47 - why I created the
325:52 - class and we will have the validate
325:55 - method it is going to accept the config
325:59 - object with record key value
326:03 - pair first of all we're going to use
326:06 - plane to instance from class Transformer
326:11 - package plain instance converts a plain
326:14 - literal object to class based
326:16 - Constructor object you can learn more
326:19 - about class Transformer by looking at
326:21 - the doc so class Transformer allows you
326:25 - to transform plain object to some
326:28 - instance of a class you can look at the
326:31 - documentation of class Transformer if
326:33 - you want to learn more about
326:37 - it
326:39 - and you have to enable this property to
326:44 - true and we have to provide the
326:47 - environment variable which we have
326:49 - created the class this one environment
326:52 - variables and we have the config SE
326:55 - config
326:56 - object you I'll teach you I'll show you
326:59 - what is inside the validated
327:02 - config now it should be the instance of
327:05 - a
327:07 - class
327:08 - if error comes you can send the error
327:11 - back
327:12 - otherwise you have to return the
327:14 - validated config and then you have to
327:17 - provide this validate method inside the
327:21 - config
327:24 - module we don't have node EnV you can
327:27 - create inside the environment variable
327:30 - let me do that
327:37 - first
327:43 - env. environment I'm going to copy
327:46 - that in the production I'm going to copy
327:53 - here now you have to create a new
327:57 - file inside the root
328:04 - directory env. validation. TS file
328:10 - file we will have the enum for
328:14 - development
328:15 - environment it could be development
328:17 - production test and
328:20 - provision now you have to create a
328:23 - class to validate the environment
328:32 - variables we have Port dbhost username
328:36 - password and the secret now we have to
328:38 - implement the logic for validate
328:48 - function it should return the validated
328:51 - object validated
329:03 - config so I got the instance of the
329:06 - class we provided the environment
329:09 - variables here let's say if I would like
329:12 - to
329:13 - log the config I can say please log the
329:20 - config and here I would like to
329:26 - say
329:28 - please log validated
329:34 - config now we have to perform the
329:37 - validation
329:40 - there is a validate sync method you can
329:42 - use
329:44 - it let me import
329:53 - them I'm going to import them
330:06 - here
330:21 - if error comes we need to throw the
330:23 - error otherwise we need to return the
330:25 - validated object validated config
330:29 - object so we created the validate
330:33 - function now it's time to register it
330:37 - inside the app
330:39 - module I'm going to register it in the
330:44 - config module here there is a
330:47 - validate we have to import the
331:06 - validate you have to import it manually
331:10 - it's not giving me the
331:13 - suggestions can say
331:16 - validate
331:36 - from
331:43 - it should not be
331:45 - EnV it should
331:47 - [Music]
331:49 - be env. validation that's why I'm not
331:53 - getting the
331:55 - suggestion because this is a typescript
331:58 - file it's not an environment
332:00 - file now I should get the suggestion for
332:06 - validate
332:08 - let me import it from env. validation do
332:12 - not import it from the class validator
332:17 - package I would like to test this
332:30 - application you can see that we have I
332:34 - have the config object inside the the
332:38 - config object I have the property Port
332:41 - secret node EnV DB host we Define these
332:46 - properties inside the environment file.
332:49 - env. development I got the DB name all
332:53 - these couple of things now you have
332:57 - environment variable which is the
333:00 - instance of a Class A Class based
333:05 - object in environment variables I got
333:09 - all this port all this
333:11 - stuff I'm going to comment this
333:16 - out what if I set the wrong value in the
333:20 - development file let's let me test
333:34 - it if I set the DB Port should be string
333:38 - let's say
333:40 - that it should give me the
334:01 - error I have to restart the application
334:04 - because I have made changes in theb do
334:07 - development
334:25 - file I did not set the validation for DB
334:30 - Port that's why I did not get the
334:34 - error let's say I'm going to do it here
334:43 - DB
334:44 - Port I can say the type should be
334:49 - number I have saved the
334:59 - application I have to restart
335:06 - it
335:23 - you can see that I got the
335:27 - error property DB Port has filed the
335:30 - following constraints is
335:35 - number let's replace the DB
335:40 - Port we have successfully implemented
335:43 - the validations for environment
335:50 - variables in this lesson I'm going to
335:52 - teach you how to increase the speed of
335:56 - module reloading what do I mean by
335:59 - module hot reloading if I change
336:03 - anything here in any file it will take
336:06 - too much time time to reload the
336:13 - application if I'm going to log
336:16 - something
336:19 - here now my application is running first
336:23 - time it will take some time let me show
336:26 - you the problem and what problem we're
336:29 - going to solve and how we going to solve
336:31 - that
336:36 - problem
337:06 - e
337:36 - for
337:39 - in this lesson I'm going to teach you
337:42 - how to increase the speed of nestjs
337:45 - project
337:46 - reloading if I make changes in any file
337:50 - let's say I'm going to delete this code
337:54 - it will take some time to reload the
337:57 - application I would like to increase
338:00 - this speed with the help of web
338:03 - pack you can see that it's taking too
338:06 - much time to reload
338:08 - application nestjs provides a way to
338:11 - increase the speed of your hot
338:15 - reloading you can see that it's still
338:19 - calculating the
338:23 - changes it's still calculating waiting
338:26 - for the file
338:36 - changes I think it has took 30 seconds
338:42 - to load the application let's increase
338:45 - the speed with the help of
338:48 - weback first of all you have to create a
338:51 - new file web H hot modu reloading doc
338:57 - config you have to create this file
339:00 - inside the root
339:02 - directory and I'm going to copy this
339:05 - code because I'm not not going to teach
339:08 - you weac in this
339:14 - course and step number two we have to
339:17 - make some changes in bootstrap function
339:21 - I can open the bootstrap function in the
339:23 - main. file we have to add the code here
339:29 - if module. H then you going to do this
339:36 - process
339:43 - it is asking me which module I going to
339:48 - talk about let me check it from my
340:00 - project yes I need to declare module as
340:04 - a
340:06 - variable
340:10 - I can I would like to declare it here I
340:13 - can also add that
340:16 - part into my
340:31 - documentation now our third step is to
340:34 - add a script to use web pack instead of
340:38 - default configuration to run the project
340:41 - in development
340:42 - mode we have to refactor the start dep
340:49 - script I would like to change it and
340:52 - let's do
340:55 - it this time we're going to run the
340:58 - project with web
341:06 - pack
341:36 - e
341:38 - cannot find run script weback
341:43 - plug-in do we need to install
341:52 - it oh yeah we need to install
342:06 - it
342:36 - e
342:47 - make sure you installed it as a Dev
342:50 - dependency so I need to uninstall
342:58 - it now we need to install it as a dep
343:06 - dependency
343:13 - let's run the
343:36 - project
343:47 - weback is building your
344:06 - sources
344:15 - project is
344:19 - completed let's try to send the API
344:25 - request but it's still
344:36 - running
344:37 - first time it will take some time to
344:40 - initiate the
344:56 - project now project has completed it's
345:00 - time to send the API request I'm going
345:04 - to send API request to root URL
345:08 - let's say I would like to make some
345:11 - changes I can
345:14 - say hello world I saved the
345:18 - application now you can see that it took
345:21 - 2 to 3 seconds to reload the
345:26 - application updated modules you can see
345:29 - that it also loged the message updated
345:34 - modules so I'm going to move this
345:39 - line application has started again I
345:43 - found it's very helpful when you are
345:46 - building a project in development
345:51 - environment we're going to use Swagger
345:53 - package to document the
345:57 - apis if you don't know about Swagger
346:00 - it's an OP Source software Frameworks
346:04 - that enables developer to document and
346:07 - design the restful web
346:10 - services it provides a set of tools and
346:13 - specification for defining the structure
346:16 - end points and data models of an
346:19 - API we will have Swagger specification
346:22 - Swagger editor and Swagger
346:26 - UI if you haven't looked at the Swagger
346:30 - let me show you the
346:35 - demo
346:41 - this is the example of swagger
346:45 - documentation you will have all the end
346:49 - points what these end points are doing
346:53 - you can look
346:56 - at as you can see that we have profile
346:59 - route we have all these routes available
347:04 - you can also create a section for each
347:06 - each route I'll teach you how to do that
347:10 - so I just want to show you this is the
347:13 - overall view of swagger
347:21 - documentation so we have to implement it
347:25 - first of all you have to install a third
347:28 - party package which is nestjs
347:31 - Swagger uh Swagger Nest has created this
347:35 - package
347:46 - let's install this
347:48 - package or I can add into my
347:51 - package.json
347:57 - file let's install
348:05 - it
348:11 - Swagger package has installed now we
348:14 - need to configure this Swagger module in
348:17 - bootstrap function you have to do it
348:21 - here you can use document Builder from a
348:25 - Swagger
348:26 - module you can have to set the title
348:29 - title should be Spotify GL the name of
348:31 - your
348:32 - application and you can write the
348:35 - description for your
348:37 - application you can set the version and
348:39 - finally you got to call the build
348:41 - function and then we will create the
348:44 - document with the help of swagger module
348:47 - and you have to provide your application
348:49 - instance and this config module this
348:52 - config
348:54 - setting and here we're going to mount
348:57 - the Swagger document at/ API route and
349:02 - you have to provide the application
349:03 - instance and your document
349:07 - I'm going to copy the same code and I'm
349:10 - going to place it here inside the
349:12 - bootstrap
349:14 - function you got to do it
349:26 - here let's import Swagger
349:35 - module
349:38 - I'm not getting the hints for Swagger
349:41 - module and
349:43 - document let's import
349:55 - manually cannot find a module nestjs
349:58 - worker
350:05 - why
350:09 - I think I have to install it
350:11 - manually and install next just
350:22 - swager now the error is going
350:26 - now we have a Swagger
350:35 - dependency
350:42 - here we have the nest F
350:53 - package you can write the name of your
350:56 - title
350:57 - application and you have to write the
351:00 - description version and finally we got a
351:02 - call the build and we are creating the
351:05 - document and we have set up the Swagger
351:09 - module it's time to run the
351:19 - application oh there is an
351:25 - issue it was an extra
351:35 - parenthesis
351:38 - application is running now let's try to
351:41 - test
351:42 - it I can go to the Local Host colon 3000
351:46 - SL
351:52 - API now we have the title of the
351:55 - document and the
351:58 - description we have all these routes but
352:02 - we did not add the
352:04 - tags I'll show you tags
352:07 - in the next
352:09 - video let's try to send the request to
352:12 - the root
352:14 - URL so I got this response hello I am
352:18 - learning nests
352:20 - fundamentals if I execute this endpoint
352:24 - I got the
352:25 - port the 200 status
352:31 - code in this lesson I'm going to teach
352:33 - you how to document this signup
352:41 - route if you look at this signup
352:45 - route I don't have any schema yet it's
352:48 - not displaying the schema what type of
352:51 - parameters do we need do we need first
352:54 - name do we need last
352:58 - name I also want to show the description
353:02 - or the purpose of this signup
353:05 - route
353:11 - first of all you have to add the API tag
353:14 - to the O controller let's convert all
353:18 - these routes into o
353:22 - section we're going to place the login
353:25 - route into OD section enable to fa and
353:28 - validate to fa let's do it first I'm
353:32 - going to open the O
353:35 - controller
353:38 - here I can
353:39 - say API
353:44 - tags I can use the
353:51 - Au my application is running
353:59 - now you can see all the routes are
354:03 - placed inside the O section
354:10 - one more thing I would like to add in
354:12 - the O
354:16 - controller we have to decorate the sign
354:19 - up route the next step we have to add
354:22 - the API operation and the
354:25 - response I'm going to use the API
354:30 - operation we need to get it from this
354:33 - Swagger
354:35 - module
354:37 - it will return the user in the response
354:39 - with 2011 status code this is called
354:42 - please register a new
354:48 - user make sure it's running
355:01 - now let's
355:05 - refresh
355:08 - I cannot see the sign up rout I think it
355:10 - is taking too much
355:13 - time oh I found the
355:16 - error API
355:24 - response we need to get the API response
355:27 - yes we have the API
355:30 - response let's restart the
355:32 - [Music]
355:35 - application
355:40 - now you can see that we have the
355:42 - register
355:44 - user we have specified it
355:48 - here somebody which is registered new
355:51 - user and you can see the
355:55 - response it should it will return a user
355:58 - in the
356:03 - response let's try to test it
356:07 - if I if I provide first
356:13 - name NH last
356:16 - [Music]
356:18 - name
356:22 - shsf and we have to provide
356:26 - email SN
356:30 - gmail.com let's provide the
356:35 - password 1 2 3 4 5 let's try to test it
356:43 - out internal server
356:49 - error because let me look at the error
356:54 - entity metadata note found no metadata
356:57 - for a user was
356:59 - found I found there is an issue with
357:03 - type orm and a web pack if you use vbac
357:08 - hot reloading like we have used weac
357:11 - package to reload the application fast
357:15 - type orm does not work with this
357:20 - configuration like this one we have to
357:22 - replace it and you have to register all
357:26 - the entities manually but it can work
357:30 - with migrations there is no problem with
357:32 - migrations but you have to replace it
357:35 - here
357:39 - we have to import couple of
357:48 - entities application is broke
357:52 - now I think I have to restart
358:04 - it application is running fine let's
358:08 - test it out I'm going to create a new
358:12 - user a user has created successfully you
358:16 - can see that with 2011 status
358:30 - code when you look at the sign up
358:34 - route if you check schema it is not
358:37 - displaying me in the schema what do I
358:39 - mean by
358:41 - schema here I cannot see the login dto I
358:46 - don't have create song dto I don't have
358:49 - create user
358:58 - dto it should display me the schema let
359:01 - me run the
359:05 - application
359:10 - my application is running
359:14 - now if you look at the schema in the
359:17 - signup route you will see the empty
359:19 - create user
359:23 - dto you can fix it with the help of API
359:27 - property you have to tell Swagger hey
359:29 - this is the API property I want to I
359:32 - want to see in this Swagger
359:35 - document let's add API property in the
359:39 - user
359:41 - entity we have to do it here please
359:44 - provide the first name of the user first
359:47 - name of the user let me import API
359:50 - property you have to do the same thing
359:53 - for last name you can also add example
359:58 - like what could be the data type look
360:04 - like
360:07 - I'm also going to add API property for
360:12 - email let's do it for the
360:27 - password my application is running
360:33 - now but I cannot see this schema value I
360:36 - cannot see properties here for my
360:42 - schema you have to register nestjs
360:46 - Swagger plugin you can do it in the nest
360:51 - CLI I'm going to copy the
360:54 - plugins open
360:57 - nli and I'm going to do it
361:03 - here let's restart the application
361:06 - because we have modified
361:15 - nli let's refresh the
361:28 - application I cannot
361:30 - see my
361:34 - schema
361:45 - I have to register the plug-in inside
361:48 - the compiler
361:49 - options that was the
361:52 - mistake restart the
362:04 - application now you can see the schema
362:08 - value first name last name email and the
362:15 - password it will also show you the
362:17 - schema value for login
362:34 - dto
362:38 - here we have the user example value
362:42 - email ID API key
363:00 - playlist in this lesson I'm going to
363:02 - teach you how to test Authentication in
363:06 - Swagger
363:09 - document we have to enable barer o it's
363:13 - a
363:14 - scheme you can do it in main.ts file you
363:19 - have to add this function Nest Swagger
363:22 - module provides this function add
363:25 - barrier
363:27 - o this is the type HTTP scheme is
363:31 - barrier format should be
363:34 - JWT name is
363:37 - JWT you can add you can add the
363:39 - description jwd token and I would like
363:43 - to provide in the
363:45 - header this is the name when you need to
363:48 - use or apply on the controller
363:53 - function one more thing we also need to
363:56 - update the secret key in the JWT
364:01 - strategy I don't want to use o constant.
364:04 - secret I I have to get it from the
364:07 - process.env
364:09 - secret this get profile is our protected
364:15 - route if you want to apply
364:17 - authentication or app if you want to
364:21 - protect or apply authentication of
364:24 - swagger document you have to use the API
364:28 - barrier a and this is the name we use
364:33 - jw/ here this one
364:37 - like create songs endpoint is also a
364:40 - protected route you can also apply
364:43 - authentication on that in the songs
364:48 - controller these are all the protected
364:52 - routes only
364:54 - artist can access update endpoint delete
365:00 - endpoint and create endpoint so you can
365:04 - apply Authentication
365:06 - on these routes as
365:09 - well but I just want to show you the
365:13 - demo in the app controller we have this
365:17 - protected route get profile
365:20 - endpoint let me show you in
365:24 - our Swagger document SL
365:32 - API here we have login
365:36 - route we don't have any authentication
365:41 - section let's implement it first of all
365:45 - let me write documentation for login
365:50 - route inside the O
366:00 - controller it looks
366:04 - good now we have to enable the
366:09 - authentication I'm going to copy the
366:12 - code and paste it
366:23 - here now we have to apply JWT
366:28 - authentication we also need to update
366:30 - the secret key in the JWT
366:34 - strategy
366:36 - I don't want to use o secret from the O
366:40 - constants let's get it from the
366:43 - environment
366:47 - variable and this is we have to
366:51 - use I'm telling to Swagger hey Swagger
366:54 - this is the protected
367:03 - route application is broken now restart
367:07 - the application I found an issue when
367:10 - you are working with we hod module
367:13 - reloading do not save the application if
367:16 - your application is in error
367:20 - format if there is an error in the file
367:24 - do not save the application otherwise it
367:26 - will break the V hod module reloading
367:30 - now it it will take some time
367:33 - to restart the app
367:43 - application application is running
367:46 - now I have to refresh my
367:50 - page now you can see the
367:54 - authorize if I try to access the profile
367:58 - route from
368:01 - here it should give me the error unauth
368:05 - red so you can you have to log in to get
368:09 - the access
368:11 - token I'm going to send the login
368:20 - request password does not match what was
368:25 - the password 1 2 3 4 5
368:32 - 6 I have got the access token
368:37 - now I can use this
368:41 - token and I'm going to provide it here
368:43 - this is the name JWT o you can see that
368:48 - authorize
368:50 - Now by enabling this JWT o
368:57 - here this Swagger will use this token
369:02 - just like we saved
369:04 - here
369:07 - let's access the protected
369:10 - route you can see that I got the user ID
369:14 - and the email it has already
369:18 - attached authorization barrier and the
369:26 - token if you have all protected routes
369:30 - in the controller you can also add API
369:34 - barrier or
369:36 - here for all controller routes but I
369:40 - have only single route is protected
369:43 - protected this is the public right route
369:46 - that is why I did not use the API or o
369:50 - barrier or inside root inside the
369:54 - controller for a
369:56 - controller so I applied separately API
370:01 - or API barrier OD
370:24 - you can also Define the tags for songs
370:28 - controller I want you to do
370:33 - it you can apply High authentication on
370:37 - songs controller protected
370:43 - route like create is a protected route
370:48 - you have to add API or o barrier
370:53 - decorator
371:02 - here it did not create the aay tax
371:06 - because my application has broken now by
371:09 - using this code restart the
371:19 - application my application is running
371:22 - now I can see all the songs related
371:25 - route you can also do it for the
371:29 - playlist API
371:34 - TX
371:36 - you can see the playlist
371:39 - section in this lesson I'm going to
371:42 - teach you how to install mango DB using
371:46 - docket
371:49 - compose if you don't have installed
371:51 - mongod DB on your machine you can
371:54 - install it manually or you can install
371:57 - with Docker compose I have already
372:00 - installed Docker on my machine my Docker
372:02 - is
372:03 - running you can see that here is my
372:06 - Docker is running
372:15 - now but we don't have any project right
372:19 - now to use with
372:22 - mongodb I don't want to install mongodb
372:25 - in my previous project we're going to
372:27 - create a new project to play around with
372:30 - mongod DP
372:31 - database I want you to create a new
372:34 - project
372:37 - I can say Nest
372:41 - new and we need to provide the name of
372:43 - your project I can
372:46 - say n
372:50 - production nestjs
372:52 - project with mongod DB and I want to
372:56 - ship it on production level you have to
372:59 - choose your package manager I'm going to
373:01 - use
373:02 - npm it will take some time to install
373:05 - the
373:12 - dependencies my project has created
373:15 - successfully all the dependencies have
373:19 - installed I'm going to go to my
373:28 - project I'm going to open the project
373:30 - into my vs
373:34 - code
373:40 - let me run the project by using npm Run
373:42 - start
373:45 - Dev let's commit in
373:50 - it and I would like to create a new
373:54 - Branch I'll store this code into this
374:04 - branch
374:06 - [Music]
374:10 - to connect with mongodb we will install
374:13 - this dependency or this package in the
374:15 - next video or you can install it
374:19 - here we need NCS mango package and we
374:23 - need mango separate
374:28 - package this is the magic we need to
374:30 - implement we're going to use docket
374:33 - compose to start mang DB
374:38 - driver I'm going to create a new file in
374:42 - the root directory I can say Docker
374:45 - compose
374:48 - EML you have to Define your
374:53 - version I can say one you have to define
374:57 - the
375:00 - services here we need to define the
375:02 - service mongod DB or mango
375:06 - mongodb the name of the
375:09 - service you have to provide the
375:12 - environment I can
375:15 - say mongod DP
375:21 - database and we need to provide the name
375:23 - of the database which is
375:27 - test we also need to provide the image
375:32 - we need to get the local uh latest image
375:35 - from the docker
375:38 - repository Docker Hub or you can say
375:41 - let's define the port I'm going to copy
375:43 - the same code I don't want to make
375:46 - mistake that's it or you can change your
375:51 - database I can say
375:55 - Spotify
375:58 - clone now you have to start MB
376:03 - driver you have to execute this command
376:06 - do compose
376:07 - up my project I'm going to open my
376:10 - project into R directory and let's
376:13 - execute this
376:21 - command I
376:25 - think already allocated I think my
376:27 - already project is running
376:30 - on 2701 docket compos let me stop that
376:34 - project
376:36 - project here we need to stop
376:40 - it let's try it
376:43 - [Music]
376:45 - again now it is going to start the
376:48 - mongod
376:51 - DB I'm also going to use external tool
376:55 - it's a graphical user
376:58 - interface mango DP Compass you can
377:01 - install it you can play around with GUI
377:06 - with mongodb database this is the GUI
377:09 - mongodb mongodb
377:11 - Compass you have to have a new
377:14 - [Music]
377:15 - connection you can have a new
377:21 - connection it is going to ask me the
377:25 - host and the port I can say Local Host
377:27 - and this is the port
377:29 - 2701 because my mango DB is running on
377:32 - this port 27017 so I'm going to connect
377:38 - it and you can create a new database
377:43 - Spotify clone and you can have the
377:47 - collection which is
377:50 - songs you can see
377:52 - that I have interacted with mongodb
377:55 - database and I created a new
378:03 - database
378:06 - so our mongod DP driver is running
378:08 - successfully in the next video I'll
378:10 - teach you how to connect nestjs
378:12 - application with mangos or mongod
378:18 - DP in the previous video we have
378:20 - installed these two packages
378:24 - mangos and nestjs
378:28 - mangos if you would like to connect
378:31 - nestjs application with mango or mango
378:34 - DB
378:35 - you have to create a new module in the
378:39 - app module you have to create it by
378:42 - calling the for root method this for
378:45 - root method is similar to mango. connect
378:48 - from the mango package you can read the
378:51 - connect package from the official
378:54 - documentation what I want you to make
378:56 - sure your mongodb is
378:59 - running my mango mongod DB driver mongod
379:03 - DB is running with the help of Docker I
379:07 - use Docker compose
379:10 - up here it is running Docker compose
379:17 - up now we have to call this method
379:21 - mongos module. forward in the app
379:24 - module make sure you have this database
379:28 - Spotify clone if I run the application
379:30 - let's see what will
379:33 - happen
379:40 - npm runs start
379:52 - def mango module because we did not
379:56 - import it let's import it with the help
379:59 - of VSS code I'm going to save the
380:03 - application
380:07 - you can see that Mango's package has
380:10 - installed it has also initialize the
380:13 - mango score module
380:15 - dependencies it means we have
380:17 - successfully connected to mongod
380:21 - DP if I will write the invalid Port
380:25 - let's see what will
380:33 - happen
380:38 - I'm getting the error mangos module
380:41 - unable to connect the
380:43 - database so it means we have configured
380:47 - the mango DB with
380:50 - nestjs but if you look at mango
380:54 - Compass I think I don't have Spotify
380:57 - clone
380:58 - database it can work without creating
381:01 - the database if I create the database
381:06 - it will
381:07 - work I can create the name of the
381:12 - collection now we have Spotify
381:15 - clone it looks
381:19 - good now we're going to create schema
381:22 - using mongos
381:25 - model in mongos everything starts with
381:29 - schema each schema maps to mongodb
381:33 - collection and different finds the shape
381:35 - of the document within the
381:37 - collection schemas are used to define
381:40 - the models and models are responsible
381:43 - for creating and reading documents from
381:46 - the mongodb
381:49 - database so we're going to create the
381:51 - first
381:52 - schema you have to create a new folder
381:56 - songs here you have to create the
381:58 - schemas folder and you have to have a
382:01 - schema which is songs. TS file but we
382:04 - will use this song document when we will
382:07 - inject the model into song
382:10 - service you can use the decorator schema
382:14 - nestjs mango module provides schema
382:18 - decorator this prop represents the
382:21 - property in the
382:23 - collection we will have songs collection
382:27 - and inside the song collection we will
382:29 - have these Fields Title release date
382:34 - duration
382:35 - and the
382:39 - lyrics Yep this schema decorator marks a
382:42 - class as a schema definition it Maps Our
382:45 - Song class to mongod DP collection of
382:48 - the same name but it will add S at the
382:52 - end of the final mango collection name
382:54 - will be
382:55 - songs and prop decorator defines a
382:58 - property in the document and finally we
383:01 - will have schema Factory
383:06 - it will return the raw definition of
383:09 - schema I logged on song schema and I got
383:12 - this result schema object we have these
383:15 - properties title release date and
383:17 - duration and couple of metadata for each
383:22 - field this is how you will create a
383:24 - schema I want you to implement
383:33 - it
383:37 - so I'm going to implement
383:39 - here by creating a new
383:44 - folder inside these
383:49 - songs we will have
383:54 - schemas here I'm going to create a song
383:59 - schema or song. TS
384:03 - file
384:05 - I just pasted my
384:16 - code we have defined four Fields I got
384:20 - all these properties from our previous
384:23 - project which we worked with tym and
384:25 - post I got title release date duration
384:30 - and lyrics I set this data type for dur
384:35 - string I couldn't find a Time Field Time
384:38 - data type in mangos so you can validate
384:42 - manually duration by using third party
384:46 - date
384:51 - plug-in so we created the schema
384:56 - successfully this lesson I'm going to
384:58 - teach you how to save record in mongodb
385:02 - database we're going to save record card
385:04 - in mongod DP
385:06 - collection right now we don't have a
385:08 - songs module we don't have songs
385:11 - controller we don't have song surveys
385:13 - we're going to create all these stuff
385:16 - and then we're going to create post end
385:18 - point inside the songs controller you
385:21 - have learned how to create the post
385:23 - endpoint how to create network request
385:26 - object or data transfer object
385:31 - dto and then I'm going to use song song
385:34 - service song service has create method
385:37 - to save the record in mongodb collection
385:40 - and finally we will create create song
385:43 - dto object inside the create song d.
385:50 - file and here I would like to inject the
385:54 - model remember schema will act as a
385:58 - model you can use schema to generate a
386:01 - model so I'm telling please give me the
386:03 - model
386:04 - the name of the model which is songs and
386:07 - I would like to use here I would like to
386:10 - inject it as a dependency I remember I
386:14 - have created the type in the song schema
386:17 - file I got the song
386:20 - document and this song model provides
386:23 - crud operation create read update and
386:26 - delete it is similar to type orm
386:28 - repository it will be treat treated as a
386:31 - type RM
386:33 - Repository and finally we have a safe
386:36 - method in the song model and I am going
386:38 - to call the method here it is going to
386:40 - return the
386:43 - promise and finally we have created the
386:47 - songs
386:48 - module we have to inject the song model
386:51 - just like we did with type orm
386:54 - repository if you will not do that part
386:56 - you will not be able to inject song
386:59 - module here that's why you have to
387:02 - register it as a here I'm telling to njs
387:06 - I would like to use song model in the
387:08 - service or in my
387:11 - provider and then you can send the
387:13 - request to this
387:14 - URL to to create a new song in the
387:19 - mongod TB collection I want you to
387:21 - implement
387:24 - it let me implement it for
387:27 - you let's
387:31 - generate let's generate controller
387:36 - songs let
387:38 - generate so
387:41 - service
387:49 - songs it has created the songs
387:53 - module it has also updated the entry in
387:56 - the app
387:58 - module you can also see the songs
388:01 - controller it has also updated Creed the
388:05 - songs controller inside the app module
388:08 - you can see
388:11 - that now we have songs
388:16 - module inside the songs module we have
388:19 - songs controller and the song
388:25 - service now it's time to create a new
388:30 - endpoint I'm going to copy the code
388:33 - inside the songs
388:35 - controller we just injected the song
388:38 - service right now this create method
388:41 - does not exist in the song
388:46 - service we also don't have create song
388:50 - dto Let's create let's create create
388:54 - song
388:55 - dto I'm going to create a new folder
388:58 - dtos and I'm going to create a new file
389:02 - file create song hd.s
389:06 - file that's
389:12 - it I already taught you how to create a
389:16 - method in the
389:19 - service let's refactor the song service
389:23 - add a new
389:24 - method we have injected the song model
389:28 - make sure you provide the name of the
389:29 - song model here we are injecting the
389:34 - song model and I called called create
389:38 - method from song
389:57 - model and finally we have to tell njs I
390:01 - want to use this song model in the songs
390:04 - module so please make it
390:30 - injectable and now we have to run the
390:32 - application
390:46 - I have to import
390:49 - song dependency
391:02 - song
391:08 - it looks
391:10 - good we have to test
391:16 - it I'm going to create a new file to
391:19 - make API request I can say api.
391:26 - HTTP let's send the API
391:32 - request
391:42 - you can see that a song has created we
391:45 - can verify from
391:48 - Compass here is the record inside the
391:51 - songs
391:55 - collection let's add another
392:02 - song
392:06 - so we have another
392:15 - song it should display the second song
392:18 - but I cannot find
392:24 - out no I can see the second
392:28 - song we have two records in mongodb
392:33 - collection this is the
392:40 - document if I don't set the title what
392:45 - will happen you will see internal server
392:49 - error because we have set the
392:52 - validations inside the song
392:55 - schema these properties are required
392:59 - title is required release date is
393:01 - required and duration is required
393:09 - in this lesson you're going to learn how
393:11 - to implement find and delete method we
393:16 - will create two endpoints to handle
393:19 - find and
393:21 - delete
393:26 - request let's start implement it I have
393:30 - already taught you how to implement crud
393:33 - or rest based API end
393:41 - points let's create a method find to
393:45 - fetch all the records from mango DP
393:49 - collection it is going to give me all
393:52 - the
393:55 - documents now we have to create a route
393:58 - to handle the
394:02 - request
394:06 - our application is running now let's
394:09 - send the API
394:12 - request to fetch all the
394:15 - songs we have to send the get API
394:27 - request we don't have any record yet
394:31 - let's create a new song I have I've
394:33 - created a new song I'm going to create
394:37 - another
394:40 - song now we have two songs let's fetch
394:44 - all these
394:53 - songs we have successfully implemented
394:56 - the find all
394:58 - method now it's time to implement the
395:01 - find by
395:02 - ID
395:12 - I'm going to create a new method find by
395:15 - ID in the song service and there is a
395:18 - method find by ID in the song model you
395:22 - have to provide the ID we're going to
395:25 - get the ID from the request
395:29 - parameter let's create a new
395:32 - route
395:42 - now we are going to send the request to
395:44 - fetch song Only based on
395:50 - ID find one
396:01 - song we have to get the ID I'm going to
396:05 - send the request to fetch all the
396:08 - songs now I'm going to copy the ID and
396:12 - we need to provide the ID
396:15 - here so I got the single record on the
396:19 - based on
396:23 - ID you can also implement the delete
396:28 - endpoint I'm going to create a delete
396:30 - function inside the song service
396:34 - song model provides delete one method
396:38 - and you have to provide the ID mango
396:41 - work works with underscore ID if you
396:44 - have worked with mongodb the ID
396:47 - stored ID stores in this underscore ID
396:54 - format if you if you are using or have
396:58 - used postgress or MySQL in my SQL or
397:02 - postgress you say the primary key or
397:05 - primary ID with this ID without
397:11 - underscore now we have to create a
397:14 - delete endpoint in the songs
397:18 - controller we have to get the delete
397:21 - method that is
397:32 - it
397:34 - let's create a new
397:37 - song because we're going to delete that
397:40 - song I'm going to get the ID and now we
397:44 - have to delete the song to send the
397:46 - delete API
397:48 - request delete
397:57 - song you can see deleted count is one
398:01 - acknowledged true it means we have
398:04 - successfully deleted the song you can
398:07 - double check it by sending the API
398:10 - request to fetch all the songs and you
398:13 - can see new song does not exist
398:18 - here you can also implement the update
398:22 - functionality I already taught you when
398:24 - you were learning type or mcard
398:27 - operations similarly you can implement
398:29 - the update operation you can have you
398:32 - first of all you have you have to Define
398:34 - update function Here song model provide
398:37 - the update method you can use that
398:40 - method and then you got to create a
398:42 - controller to handle the update
398:47 - request in this lesson I'm going to
398:50 - teach you the concept of
398:52 - populate if you want to make a relation
398:56 - or a reference between two document
398:59 - between two collections remember in
399:02 - mongodb
399:04 - collection collection will have
399:07 - documents in my SQL or post you will
399:11 - have tables and
399:13 - columns so if you want to make the
399:15 - reference or relation between two
399:17 - collection you can do with the help of
399:20 - poate you have to implement the concept
399:22 - of
399:24 - poate I have this use case or scenario
399:27 - each song must have must belong to one
399:31 - album and each each album can have many
399:36 - songs I want you to implement it if you
399:39 - want to do that you can Google Mongo's
399:42 - relation or check the official
399:45 - [Music]
399:47 - documentation this is our
399:50 - album schema we did not create the album
399:54 - schema yet I'm going to teach you how to
399:57 - do that or you going to create or you
399:59 - can create the album schema just like we
400:02 - did the song schema scha it is going to
400:05 - take the array of the songs because each
400:09 - album can have many songs that's why I
400:12 - created the array of songs and you can
400:15 - have multiple
400:17 - types it's an array I got the types from
400:21 - mango package here you will see type
400:25 - from the mangos and I'm telling that the
400:29 - reference is
400:31 - songs because when you create the song
400:35 - when you created the song schema you
400:38 - have defined a class for class song by
400:42 - default the collection will be songs you
400:45 - can also double check it from mongod DB
400:48 - Compass let me show
400:52 - you I'm telling you I would like to make
400:55 - a reference with songs
400:59 - [Music]
401:00 - collection let me do that
401:06 - inside the Spotify clone we have the
401:09 - collection name which is songs I have
401:12 - added the reference
401:14 - here and finally you also have to add a
401:18 - relation for this for the album in the
401:22 - song schema I'm creating a property and
401:25 - type should be Mango's object ID or
401:29 - mongodb object ID here I'm I'm getting
401:33 - the or defining the reference album.
401:36 - name it should be
401:39 - albums and we have the album and finally
401:43 - you got to create album module just like
401:46 - we did the song module and I'm saying I
401:49 - want to use the album model in the album
401:52 - service or we we will be able to inject
401:56 - the album model to perform crud
402:01 - operations and here I have injected the
402:04 - album model in the album service just
402:06 - like we did songs model inside the song
402:11 - service and I created a new method we
402:14 - will have a create album dto and here we
402:18 - will have find
402:21 - albums this is how you will implement
402:23 - the populate let's say you want to
402:26 - display all the songs on the front end
402:30 - against each album then you need this
402:34 - query you got to I'm telling to mongod
402:36 - DB please give me all the albums please
402:40 - give me all the albums for each Album
402:43 - please also give me all the songs this
402:45 - is how you going to do
402:47 - it and create when you are trying to
402:51 - create a new album you got to provide
402:53 - the title and the songs it should be the
402:57 - IDS and we have create method to create
403:02 - a new album
403:04 - and uh find all albums and you also have
403:08 - to refactor create Song D you can
403:11 - implement it I want you to do it I
403:13 - already taught you all of these steps to
403:15 - do
403:16 - that first of all we have to
403:20 - create album nextest
403:24 - generate nextest generate module
403:28 - albums or I can say
403:31 - albums and next gener at
403:34 - controller
403:37 - album and Nest generate service
403:57 - albums Nest generate
404:01 - module albums
404:04 - Nest generate
404:07 - controller
404:10 - albums Nest generate
404:14 - service
404:32 - albums
404:37 - I don't need spec files I'm going to
404:40 - delete
404:44 - them now you have albums module albums
404:48 - controller and album service it has also
404:53 - added the entry in the app
404:56 - module let's create a new folder
405:01 - schemas I have to create create a new
405:03 - schema I can name it to album
405:08 - schema. we will also need a
405:13 - dtos now we're going to I'm going to
405:16 - copy album
405:19 - schema and I'm going to paste it here
405:22 - that's
405:31 - it
405:33 - and I can
405:35 - use I also have to refactor the song
405:54 - schema we have to add another property
405:58 - one thing I forgot to add it should be a
406:02 - mongodb property that's I forgot to
406:07 - add add prop decorator for the lyrics
406:14 - property we need to get the types from
406:17 - object
406:18 - ID from
406:20 - mango we also have to import the
406:24 - album from album
406:29 - schema everything is good right now
406:36 - let's
406:38 - create we have to
406:41 - update album
406:43 - module actually we
406:47 - need we need this line I'm going to copy
406:52 - [Music]
407:01 - everything
407:31 - e
408:00 - we don't have dto let's create
408:04 - that create Alum
408:17 - dto now we have to
408:20 - define a
408:22 - controller we already created the
408:26 - controller I can
408:28 - say should be albums
408:31 - controller album
408:44 - service and we also need to refactor the
408:47 - create song
409:01 - dto
409:10 - I have found the error in the album
409:14 - service get rid of the song Let's import
409:18 - it
409:19 - here if I save the
409:22 - [Music]
409:24 - application we also have to
409:27 - refactor in the song
409:31 - schema
409:47 - everything is good
409:49 - now what we what I want to do I would
409:53 - like to create the album
409:55 - first create
409:58 - album we have to send the post
410:01 - request by providing the
410:07 - data it is going
410:09 - to get give it is going to asking me the
410:12 - name of the
410:14 - album title title of the
410:18 - album let's say
410:21 - dance and I would like to provide the
410:24 - array of the
410:25 - songs I want to save let's
410:29 - say these two
410:31 - collections
410:34 - these two
410:36 - collections inside the dance inside the
410:39 - dance
410:40 - [Music]
410:47 - album I'm also going to save this
410:54 - document or save the song inside this
410:58 - album let's create a new
411:01 - album
411:03 - I got the
411:06 - eror song validation
411:10 - failed duration duration is required
411:15 - OMG I forgot to add the albums
411:20 - here now you can see that I got the
411:23 - dance album with these two
411:26 - songs now we have to fetch all the songs
411:31 - I'm going to test the popular method
411:33 - popular
411:35 - functionality find all
411:37 - [Music]
411:38 - albums with
411:43 - songs this time we have to send the get
411:49 - request let's fetch all the
411:54 - albums you can see that I got the albums
411:57 - array this is the first album and we
412:01 - have all the songs against each album
412:05 - this is how you can make a relation or
412:08 - reference with document with
412:13 - collections or with
412:23 - models in this lesson we're going to
412:26 - prepare our application for
412:29 - deployment I'm going to teach you how to
412:31 - deploy nestjs application at
412:35 - Railway you will also deploy your
412:38 - postgress
412:39 - database at Railway we're going to
412:42 - deploy our application this one the
412:45 - Spotify clone which we were
412:50 - building our application is using postp
412:54 - database with type orm I'm going to
412:57 - teach you how to deploy the complete
412:59 - application at
413:01 - sailway
413:03 - first of all you got to create a new
413:06 - project make sure you deploy your
413:09 - project at GitHub
413:12 - repository I did not deploy the project
413:20 - yet first of all we have to do a do a
413:23 - little bit
413:25 - configuration we have to set our
413:28 - environment variable when I will run the
413:31 - application in production it should run
413:34 - this production. EnV file if I'll be
413:38 - working at development environment I
413:40 - want to work with local post database I
413:42 - don't want to change in production
413:45 - level so we got to configure a couple of
414:01 - settings we already created the env.
414:05 - development. env. production but it is
414:08 - not configur configurable when my
414:11 - project is running in production mode it
414:13 - should pick this production
414:20 - file I've already written down the
414:24 - validation in EnV validation for node
414:28 - environment but I did not set in the
414:31 - configuration
414:34 - let me do
414:35 - it I can say node
414:39 - EnV and I can get the value
414:42 - from process
414:49 - dot process. env. node
414:57 - EnV now this variable is available for
415:01 - the config
415:05 - service I've already provided you the
415:08 - nests deployment raway started kit BR
415:11 - started kit project you have to open it
415:14 - and run npm install to install all the
415:26 - dependencies now we have to configure
415:28 - the EnV file path in app module
415:34 - get rid of this
415:37 - stuff I don't want to do
415:40 - it
415:52 - configure get it off this
415:59 - middleware get rid of this data source
416:17 - here we have to update our
416:22 - path what I can
416:26 - say please get the value
416:30 - from process do
416:35 - do
416:40 - EnV do node
416:46 - EnV or you can say get the path from the
416:50 - current working directory and you can
416:52 - provide the name of your
416:55 - file current working
416:59 - directory and
417:01 - Slash
417:05 - dot here we need to do EnV dot
417:09 - development or
417:23 - production we have to remove this
417:31 - one
417:39 - please get the working
417:41 - directory and find the env. production
417:45 - file or env. development
417:50 - file we have to set the script or we
417:53 - have to set the development environment
417:55 - in our package.json file for the dev I
417:59 - can say I want to mention node EnV to
418:06 - development we have to do
418:15 - it here we have to set the production
418:19 - value when you run the application with
418:27 - production how can I test
418:30 - it in the main.ts file maybe I can use
418:36 - that or what can I do yeah I have the
418:42 - access to config
418:44 - service I can say console
418:48 - DOT
418:50 - log
418:52 - config
418:54 - service
418:57 - doget I can provide the name which is
419:00 - not
419:01 - EnV
419:02 - let me part it to
419:04 - string let's see what will
419:19 - happen you can see that it's working
419:22 - fine now my application is running in
419:26 - the development
419:29 - environment if I run the application in
419:31 - produ prodction
419:33 - environment when you see the production.
419:36 - environment I don't set the I didn't set
419:39 - the database configuration so it will
419:41 - not work my application will be crashed
419:43 - let me show
419:58 - you you can see that my application has
420:01 - crashed
420:03 - an instance of environment variable has
420:30 - failed
420:33 - yeah it is showing me the validation
420:37 - error dbport does not exist DB host does
420:41 - not exist if I copy this
420:46 - configuration what will
420:49 - happen now it should run the
420:59 - application you can see that my
421:01 - application is working fine
421:07 - now but we will replace these
421:10 - configurations with Railway post
421:24 - configuration I have everything in the
421:27 - master
421:29 - Branch let's create the GitHub
421:33 - repository because Railway will be
421:35 - asking for GitHub
421:50 - repository let's create a new repository
421:53 - I can give any
421:55 - name nextjs deploy to
422:00 - railway
422:18 - if you want you can create private
422:21 - repository I'm going to make it
422:29 - public we have to add
422:32 - origin it is asking me to create push as
422:36 - a main
422:38 - branch let's do
422:42 - that so I got the main branch everything
422:46 - inside the main
422:53 - branch let's try to check it
422:59 - out so I have everything in the main
423:05 - branch now we
423:09 - have we have EnV doev development we
423:13 - have env.
423:15 - production you should not push your env.
423:19 - development or env. production to the
423:23 - GitHub
423:29 - repository because we wanted to set it
423:32 - to the kit
423:35 - ignore do not add
423:38 - Dov
423:42 - files if I add.
423:51 - EnV update get
424:00 - ignore
424:04 - we have to push the
424:15 - code I try to add do EnV in the G ignore
424:22 - edit I try to
424:25 - add EnV in the
424:29 - ignore and it was not not
424:32 - working I also removed the cache for
424:36 - env. development and env. production
424:45 - file
424:46 - removed
424:50 - envs now we have to push
424:55 - it
424:59 - oops envs
425:06 - let's push the
425:30 - code
425:37 - let me delete this file
425:47 - manually I'm also going to delete env.
425:51 - [Music]
426:00 - production
426:11 - now we got to pull the
426:18 - code everything is up to date right now
426:22 - if I try to
426:24 - push you should not
426:26 - see env. production and EnV do
426:30 - development
426:38 - file so we have pushed the source code
426:41 - to our GitHub repository you going to
426:44 - say deply from the GitHub
426:46 - repository here we have to configure
426:51 - our repository I can say deploy njs app
426:57 - to I can say now it is going to deploy
427:00 - the code
427:09 - it is
427:10 - building and running env. production no
427:14 - it is trying to building the
427:30 - project
427:33 - now you can see that our project has
427:37 - deployed if you want you can see the log
427:41 - what is going on
427:46 - here I got this
427:49 - error instance of environment variables
427:52 - has failed in the valid
427:55 - validation that's an issue we have to
427:58 - configure our environment variables
428:06 - our application has crashed now we have
428:10 - to set the environment
428:13 - variables first of all I have
428:17 - to create a new database it's very easy
428:21 - to create a database in real
428:25 - way just right click and find the
428:30 - database I'm going to have
428:41 - post now you can have the
428:47 - post when you see the connect here you
428:51 - can find your database
428:55 - option I can say this is
428:59 - post and you can up create your EnV
429:03 - production file
429:06 - EnV
429:07 - [Music]
429:11 - production oops I deleted that
429:23 - files we need to get back our
429:26 - development. EnV
429:30 - file do env.
429:36 - development and I also need to get
429:40 - production EnV
429:47 - file now I'm going to copy my
429:51 - database in the
429:55 - production let's do it
430:00 - here
430:08 - [Music]
430:11 - database this
430:13 - [Music]
430:14 - one and we need PG
430:19 - Host this
430:27 - one and we need password I want you to
430:31 - use your own password do not copy my
430:37 - password
430:45 - username it should be post it's working
430:48 - fine you also need a
430:54 - port everything is good to go
431:00 - now
431:05 - now I want you to copy these EnV file
431:10 - the your production EnV
431:12 - file and open the N nestjs deploy to
431:16 - raway
431:17 - project and in the in in the variables
431:21 - you have to set your environment
431:24 - variables that's it I'm going to update
431:27 - my variables now it is going to redeploy
431:30 - the app
431:40 - application now redeployment is in
431:43 - progress It's Time to it's it will take
431:46 - some
431:53 - time my application has deplo
431:57 - deployed now it is going to start let's
432:01 - look at the deployment
432:03 - logs amazing I I was logging the
432:07 - production in the app module or I think
432:09 - I was doing in the main.ts file you
432:12 - should not do
432:14 - that it's working fine it means we
432:17 - successfully deployed our
432:21 - application so how can you test it maybe
432:24 - you had thinking about it how can I test
432:26 - this application right now we don't have
432:29 - any domain let's generate domain to test
432:32 - the
432:34 - application uh if you want to refactor
432:37 - you can change that I can say Spotify
432:41 - clone
432:47 - production now we have this domain name
432:49 - I'm going to open
432:51 - it it is going to give me the nothing
432:54 - here don't worry when you try to access
432:56 - the API
432:58 - routes it will take some time because we
433:01 - have set the domain
433:06 - name it is going to take some
433:19 - time now it's working I think fine
433:23 - now after 30 seconds my project has
433:30 - Reloaded
433:35 - now we're going to figure it out I'm
433:36 - going to send the API request to test
433:39 - the application it is working fine now
433:44 - but what will happen if I try to create
433:47 - a new user let's say I want to perform
433:50 - database operation I'm sure it is going
433:53 - to give me the
433:57 - error let's create a new
434:00 - user
434:06 - Jane
434:08 - Don Jan
434:13 - gmail.com 1
434:15 - 2 3 4
434:18 - 56 I'm going to send the
434:23 - request I got internal server
434:26 - error you can check the log what what is
434:31 - going
434:38 - on users does not
434:42 - exist because my database is empty now
434:48 - we did not implement the migration
434:51 - remember you have seen in the data
434:54 - source we have set this synchronized to
434:57 - false but do not use synchronize to true
435:00 - in
435:02 - production what we have to do we have to
435:04 - run our migrations to perform changes we
435:08 - have to add relations because I done
435:10 - that I've done
435:15 - it I think I don't want phone migration
435:19 - you can delete
435:23 - that
435:24 - now I have to execute these queries
435:29 - these queries will create table
435:32 - in our postrest database here
435:37 - here what we have to do we got to run
435:39 - the
435:46 - migrations I got this issue we have to
435:51 - migrate the database in the production
435:54 - so we have to use a
435:57 - migration make sure you are using the
436:01 - password process. env. password not a DB
436:04 - password because we have defined the
436:08 - password in our environment
436:19 - file we have to run the migration I'm
436:23 - going
436:23 - to run the script npm run migration I
436:28 - would like to create all my tables
436:30 - that's why I just provided the name in
436:40 - it so I got the
436:44 - undefined
436:47 - process. I'm doing the log for node
436:50 - environment I'm also doing the log for
436:52 - DB DB host I'm also doing the log for DB
436:57 - password you can see that I got the
436:59 - development value it is working fine but
437:03 - when you look at the env. development
437:06 - I'm using the database for the Local
437:08 - Host like post gra local instance here
437:11 - I'm using the railway postra
437:14 - instance so I have to tell to nestjs
437:18 - build
437:20 - command under the they are using
437:23 - generate command is using njs build
437:26 - command this one type orm but I want to
437:30 - say please run the produ run the project
437:33 - in the production let if you want to run
437:36 - the de in migration in production you
437:39 - have to Pro tell njs project you can
437:44 - create a separate script for build for
437:47 - production or separate SCP for separate
437:50 - script for build in the development
437:54 - environment but you can do quickly by
437:58 - using say that
437:59 - export node EnV here I want to set the
438:03 - node environment variable to production
438:06 - now you can see development environment
438:09 - should be in the
438:11 - production I'm going to run the
438:16 - migration I've also logged the node
438:18 - environment it should give me the
438:20 - production by default
438:22 - it if it if it logs
438:26 - production it means it is going to run
438:28 - the production EnV
438:32 - this
438:35 - one you can see node environment is
438:38 - production but I got DB host is empty
438:41 - undefined and password I figured it out
438:45 - the issue I have to
438:47 - install do EnV
438:50 - package and here we have to use the EnV
438:54 - package it is not getting variables from
438:57 - EnV because we were using the config
438:59 - module for config
439:05 - configuration after installing config
439:09 - module do EnV
439:12 - package you have to import it
439:15 - here do en/ config now you should be
439:19 - able to access these variables
439:23 - so I'm going to run the
439:29 - migration
439:34 - before running the build you have to set
439:37 - the node envirment do you want to run it
439:40 - for production or do you want to run it
439:41 - for development but if you want you can
439:44 - create a separate script SE separate
439:47 - build script for production and
439:56 - development I still got the
439:58 - eror production
440:03 - it's not getting the
440:09 - value I think it is not finding the env.
440:14 - development
440:19 - file so there was an issue it is not
440:25 - loading the EnV from the env.
440:29 - development. env.
440:31 - production if we will have simple. EnV
440:35 - then EnV package can get variables from
440:38 - the file but right now it is not getting
440:41 - it so you have to provide the custom
440:44 - path I just did a little bit
440:46 - configuration we have to import the
440:58 - path we have import the
441:09 - part so we have to
441:13 - use this
441:16 - syntax
441:20 - require this
441:24 - one all I have to do is provide the EnV
441:29 - path
441:33 - now it should work it should get the
441:38 - values so I'm going to create the
441:45 - migration cannot read
441:53 - property
441:55 - PA is equals to
441:59 - path
442:03 - but I got still
442:09 - undefined let's log EnV
442:17 - path oh it is getting the value
442:22 - from
442:23 - DB but my file is located
442:28 - at root folder so it is not here inside
442:34 - the
442:40 - DB if I try this
442:47 - one I tried to work with this env.
442:50 - production with custom path but it is
442:53 - not
442:54 - working all I did if I
442:58 - change EnV it is it will work let's let
443:01 - me show
443:02 - you get rid of
443:04 - [Music]
443:08 - everything now if I copy that and
443:16 - create EnV file in the root directory it
443:19 - will
443:21 - work I found there is an issue with type
443:24 - orm now I'm going to paste my
443:28 - code for production
443:31 - you you have
443:32 - to adjust nestjs build when you try to
443:36 - run the migration you have to update the
443:39 - changes here I found this is the way you
443:43 - can implement it but there was an issue
443:46 - with custom file path so now it will
443:49 - work I'm going to run the
443:55 - migration now I can see production and
443:59 - the my container name which is my DB
444:03 - host and my password now migrations has
444:09 - been generated
444:11 - successfully it's time to run the
444:13 - migration we got to run this
444:19 - command npm
444:22 - run
444:26 - migration
444:29 - run should be
444:37 - run you can see that it is running all
444:40 - the queries creating tables in the
444:43 - railway postris
444:50 - database now you can understand you can
444:52 - use this EnV for type orm
444:56 - build use it for type or RM
445:02 - migrations because in the app module we
445:04 - are using the configuration of config
445:07 - module we are not loading this EnV file
445:11 - we are loading envir environment
445:13 - development env. production file but you
445:17 - can use this EnV for
445:21 - migrations now we need to double check
445:29 - it
445:35 - we have to deply our
445:42 - code now it will take some time to
445:45 - redeploy the
445:51 - application the application is running
445:54 - now I got this secret key the database
446:00 - host and the
446:03 - password now we're going to run
446:09 - it/ API open this Swagger
446:16 - tool you can also double check it from
446:19 - postris
446:21 - database I have only migration table it
446:25 - should give me all the tables but
446:29 - something went wrong
446:32 - here inside the
446:35 - migration the record is empty table is
446:41 - empty unique key primary key what is
446:46 - going
446:57 - on oh I have two migr
447:00 - ations get rid of this
447:09 - file get rid of all these
447:15 - migrations let's generate the migrations
447:18 - from the
447:19 - scratch I'm going to name it to in
447:27 - it now migration has R it
447:33 - successfully I'm going to comment this
447:40 - code now you have to run the
447:50 - migration everything is good to go all
447:53 - the ques has have
447:56 - executed now you should see the data in
447:59 - the data datase you can see I got artist
448:02 - playlist songs and users
448:05 - table we have these
448:08 - columns if you want you can run the
448:11 - seed from App module I think we we were
448:15 - doing seeding in main.ts
448:19 - file you can enable this
448:23 - code application is running
448:26 - now let's create a new user
448:35 - amazing we have created the record
448:38 - successfully you can also double check
448:41 - it from the post
448:43 - database you will have the user
448:47 - here but I created this user
448:51 - from the this one from seeding because I
448:55 - think my seeds are running
448:58 - constantly I think I enable that seed in
449:02 - the app module we got to disable
449:05 - it otherwise it will generate more
449:11 - users I'm going to remove them now you
449:16 - have to see constantly a new
449:23 - data I can say disabled
449:29 - seats now it is going to redeploy the
449:33 - application so this is how you can
449:37 - deploy nestjs application to
449:46 - railway in this module I'm going to
449:48 - teach you how to do unit testing
449:51 - integration testing and end to end
449:53 - testing for nestjs
449:55 - application before getting started on
449:58 - testing I want to teach you some of the
450:00 - basics of just because we're going to
450:02 - write a lot of mock functions we're
450:04 - going to write we're going to write a
450:06 - lot of spying spy
450:09 - functions you will learn how to create
450:12 - Mo implementation of service of a
450:15 - controller of a
450:17 - repository if you know the basics of
450:20 - justest if you know mo functions if you
450:22 - know spy function then you can skip
450:24 - these three
450:25 - lessons if you want to refresh the
450:27 - knowledge of just you can continue this
450:35 - video just as you if you don't know
450:38 - about just just is a popular JavaScript
450:42 - framework it is developed by
450:45 - Facebook you can use for testing
450:48 - JavaScript
450:50 - application you can use just with react
450:53 - view angular and
450:57 - nodejs these are all the function alties
451:00 - of the Gest asynchronous testing code
451:03 - coverage snapshot testing moing and
451:05 - spying we're going to use a lot of
451:07 - moking and spine with nestjs that's why
451:10 - I want to teach you these two concepts
451:13 - in more
451:14 - details you will learn how to do matches
451:17 - and test suits and test running and
451:19 - assertion uh before creating the just
451:24 - project I want you to open an empty
451:26 - folder we're going to start it from the
451:28 - scratch and you got to create
451:30 - package.json
451:32 - file I can say npm in it d-s please
451:37 - create the package.json file for
451:39 - me I got the package.json file now I'm
451:42 - going to copy
451:44 - that and let me replace
451:50 - that here what I want to
451:54 - say we we need to install the typing of
451:57 - the justest we need to install the
451:59 - justest app a Dev dependency and I
452:01 - created the script to test the justest
452:04 - if you want to run the justest in watch
452:06 - mode I'll teach you how to do that you
452:08 - got to run you got to run this
452:10 - script so uh please install these two
452:14 - dependencies I'm going to install
452:23 - them it's going to install the
452:25 - dependencies let's create a new file I
452:28 - I'm going to name it to some .js file
452:31 - we're going to test this function we're
452:34 - going to write test cases to test this
452:38 - function in the third step we have to
452:41 - create some.
452:44 - test.js file I'm not using typescript
452:48 - here I just want to show you the basics
452:50 - that's why I want to keep it more
452:54 - simple we have to import the sum
452:57 - function from the sum. JS file
453:10 - I have to write the test case at 1 + 2 =
453:15 - 3 now we're going to write the test case
453:18 - you can use the
453:24 - test it should give me the
453:28 - result 1 + 2 =
453:33 - 3 so we're going to call this
453:37 - function it's going to take the call
453:39 - back
453:43 - function I can
453:45 - say
453:47 - expect it's not giving me suggestion
453:50 - because it is taking too much time to
453:51 - install the
453:55 - dependencies because I think my internet
453:57 - connection is slow right now
454:00 - so we need a
454:03 - [Music]
454:16 - function sum. 2 B 3 we have to call that
454:22 - function it is going to take two
454:24 - arguments if you look at the sum. JS
454:27 - file you will see two arguments A and B
454:31 - the first argument I'm going to provide
454:33 - one and the second argument I'm going to
454:36 - provide two let's try to test it
454:39 - out it's still
454:45 - working npmi minus
454:50 - TJ my both packages have installed just
454:54 - in the typing of the
454:56 - just now you can write the test case
455:00 - I've written the test case you can run
455:03 - it npm run test I would like to run it
455:06 - in the watch
455:23 - mode dash dash watch is not
455:27 - sported so you have to write the watch
455:45 - all now you can see that I have to
455:47 - update the script for the watch
455:55 - all now we have to select the pattern I
455:58 - would like to run this s test.ts file
456:01 - right now we have only single
456:03 - file it's going to execute this file the
456:07 - test has passed now if I write the
456:11 - invalid value I save the
456:14 - changes it has started automatically and
456:18 - I got the
456:20 - error expected four but received
456:24 - three you can play you can play around
456:27 - with multiple matches function let's
456:31 - say 1 +
456:35 - 4
456:37 - or to have been
456:40 - called to have property to have
456:45 - returned to have returned with let's say
456:52 - five you can play around with multiple
456:57 - watches received have as type
457:04 - number so this is not a right matcher
457:07 - function so I can say it should be
457:17 - five this is how you will write your
457:20 - first test
457:23 - case now I'm going to teach you the
457:25 - concept of
457:27 - mocking we're going to play around with
457:29 - mock functions Auto mocking inest refers
457:34 - to the automatic creation of mock
457:37 - implementation for imported modules or
457:39 - dependencies during
457:48 - testing let's create the mock
457:54 - functions you can use the mock function
457:57 - to track the function calls
458:00 - if you want to remove the dependencies
458:02 - we're going to do in njs testing we're
458:05 - going to remove maybe the implementation
458:08 - of service implementation of the service
458:11 - then we will have more implementation we
458:14 - can simplify the testing and control
458:17 - behavior when you do the unit test your
458:20 - code let's say if your code is dependent
458:24 - on five dependencies let's say if your
458:27 - class is dependent on on Class
458:32 - B Class
458:34 - B Class
458:36 - C or class D let's
458:41 - say and you want to do the unit testing
458:44 - let's say this is the class A now Class
458:46 - A is dependent on let's suppose Class B
458:49 - Class C and class
458:52 - D now Class A let's suppose we has two
458:56 - function or one function if you if I
458:59 - want to test the one function from the
459:02 - class A when you do the unit testing you
459:05 - test the individual Parts you test the
459:08 - individual functions to test the
459:11 - individual function maybe the individual
459:14 - function of Class A is dependent on the
459:17 - function of Class B function of Class C
459:20 - and the function of Class D then we have
459:24 - to write the mock implementation for the
459:26 - class B Class C and the class D
459:30 - I'll teach you in the later
459:34 - videos now we're going to create mock
459:37 - function this is how you will describe
459:40 - or you can group all your test cases
459:44 - into a
459:45 - group describe I want to write all the
459:48 - mo function examples in this
459:51 - section it is similar to the test you
459:54 - can Define the it or the test it is
459:57 - referring as a test so it should create
459:59 - the basic mock function let's create a
460:03 - new file Mo function. spc. TS file I
460:07 - have created the test.js file but you
460:10 - can also create the
460:12 - spec. JS
460:14 - file the concept is same
460:21 - now now we have to write the mo
460:25 - function here I can
460:28 - say
460:30 - I will provide the
460:32 - mo write Mo function
460:37 - examples here this this this section
460:42 - will have the mo function
460:46 - examples let's write our first test case
460:49 - it should create a basic Mo
460:52 - function should create a
460:55 - basic mock
460:58 - function
461:03 - you can create a mock function by using
461:06 - the just. function I can say this is the
461:09 - mock
461:11 - function just provide is a
461:14 - FN now we have the empty Mo function if
461:19 - you log the mo function you will see
461:22 - this is the empty function let's try to
461:24 - do it run the script again to run the
461:29 - Tex test in the watch
461:31 - mode this time I'm going to add the
461:34 - pattern for the more Dash function. spc.
461:41 - file it is going to ask me the pattern I
461:44 - can say mock now it's going to run this
461:49 - file if you see the log you
461:54 - have a function a mo function if I call
462:02 - that you will see there is nothing here
462:05 - we have undefined
462:08 - function if you pass the argument it is
462:12 - going to still it is going to still give
462:14 - me the
462:15 - undefined this is the empty mooch
462:21 - function if you want to return the value
462:24 - from the mock function you can also do
462:28 - that
462:29 - return
462:31 - value Mo return value now let's say I I
462:35 - would like to return the
462:37 - four now if I call that function it
462:41 - should give me the value of four I can
462:44 - write the match functions on it mock I
462:48 - call the
462:50 - function to be the value should be
462:57 - four you can see our test has passed now
463:00 - if I add the invalid value which is
463:03 - three it's going to give me the error
463:06 - expected three but received
463:14 - four if you want to remember I told you
463:19 - you can also keep track the calls of the
463:23 - function with the help of Mo how many
463:26 - times this function has cost
463:30 - called mo. calls.
463:34 - length to be we have called
463:38 - only one time so it should give me the
463:41 - length is
463:43 - one if I call the function two
463:47 - [Music]
463:48 - times Mo
463:51 - function
463:53 - dot to
463:55 - have been
463:58 - called
464:02 - been
464:03 - [Music]
464:22 - called let's say I want to call that
464:26 - function and I'm expecting the four
464:30 - it should give me the error you can see
464:32 - that the save to expected is one here we
464:36 - have the
464:37 - error it should give me the two because
464:41 - we have called this function two times
464:44 - if you want to keep track of the calls
464:46 - of the function how many function have
464:48 - how many times you have called the
464:50 - function you can also do measure on
464:55 - that here I can say expect
465:00 - mock function to have been
465:09 - called it is checking that did you call
465:11 - the function yes we already called two
465:15 - times this is how you you can return the
465:19 - value from the mock function you can
465:21 - create you have learned how to create
465:23 - the basic mock
465:27 - function
465:31 - now you're going to learn how to create
465:34 - a basic Mo function with
465:37 - arguments we did not create a function
465:40 - with
465:41 - argument we just created a basic mock
465:44 - function then we have returned the
465:47 - value here I can
465:50 - say it should create a mock
465:54 - function with an
465:57 - argument
466:12 - let's create a function con
466:15 - mock song function you can say song
466:23 - mock just.
466:27 - function it can have create song dto
466:31 - let's say
466:33 - that
466:34 - mock create
466:44 - song and this
466:47 - function will have this
466:51 - argument but I also want to write the
466:55 - implementation you can do that as well
467:01 - well right now we did not return the
467:04 - value if you want to return the value
467:07 - you can
467:08 - do this stuff it is going to return a
467:13 - song
467:15 - title animals and
467:19 - ID or you can oh
467:25 - animals and ID which is one let's say
467:28 - that
467:29 - that if I am expecting on
467:34 - that it should give me the same
467:38 - object
467:41 - animals ID which is
467:45 - two or ID which is one if you want to
467:49 - test the object you can use this two
467:51 - equal
467:56 - expression make sure you have called
467:58 - that function with
468:01 - argument create D is not
468:04 - defined title should be
468:21 - animals create D is not
468:26 - defined I think it will not not work we
468:30 - have to write the implementation here I
468:35 - just want to show you the another
468:36 - alternative path it's a call back
468:39 - function it's going to it's going to
468:42 - return the create song
468:44 - dto now you
468:47 - can look
468:50 - at this
468:57 - one
468:59 - now my test has passed now if I will
469:02 - write the ID it should give me the false
469:05 - it should give me the false value or it
469:08 - has failed because I am just returning
469:10 - the ID but you can pass this
469:15 - test if I create if I return the
469:20 - object use the spread operator and ID
469:24 - which is
469:26 - one let's try to check it out
469:35 - out now my function has my test has
469:40 - passed
469:41 - now if I provide the another value
469:54 - lower in our application this function
469:58 - like create song function does not exist
470:01 - here we don't have a create song
470:04 - function we don't have njs project we
470:06 - don't have repository we don't have
470:08 - service controller that's why this is
470:10 - how you can create the mock
470:19 - implementation you can also create a
470:22 - mock function with mock
470:25 - implementation we used callback function
470:28 - here here but if you want to
470:31 - use this Mo implementation you can do
470:34 - that as
470:35 - well it should create a mock
470:40 - function with an
470:44 - argument with Mo
470:48 - implementation this
470:56 - one I don't have preer
470:59 - file R
471:03 - see single C to
471:06 - true because I use this prettier
471:11 - formatter now my code has formatted
471:16 - now we're going to use the same
471:20 - approach const mock create
471:24 - song just.
471:27 - function I have defined the
471:31 - function mock create song do
471:36 - mock
471:41 - implementation create song
471:46 - dto it's going to return the object
471:49 - create song dto and the ID which is
471:54 - one now I'm going to ex run the mat to
472:00 - test the
472:03 - code my code has passed now my test has
472:07 - passed now you can approach you can
472:11 - implement the same stuff by using the
472:15 - call back function here or if you prefer
472:18 - the mug implementation you can do in
472:20 - this
472:27 - way now I'm going to teach you how to
472:30 - create a mo function and it function
472:32 - this function should return the
472:38 - promise all you need to do is call the
472:41 - mo result value we use the mo return
472:45 - value you can do that with the help of
472:48 - Mo resolved
472:51 - value let's say I would like to create a
472:54 - new
472:57 - function
473:01 - let's create a new test case it
473:04 - should create a mo function with
473:11 - promise ultimately it it is ultimately
473:14 - it is going to return the
473:17 - promise fetch song data or you can say
473:20 - that fetch all the songs from the DB or
473:23 - you can say the network
473:27 - request now we got a
473:30 - return Mo return or Mo resolved
473:35 - value let's say fetch songs I got the
473:39 - array ID
473:41 - one title
473:50 - Lover now I will like to call that fetch
473:55 - [Music]
473:56 - songs Doc do
473:58 - results dot to
474:01 - equal if you want to apply assertion on
474:06 - promises you can call the results
474:09 - property and then I can apply this
474:13 - Expressions to equal this
474:18 - one make sure you could to call that
474:24 - function now my test has passed if I
474:28 - write fetch I'm going to call the fetch
474:32 - functions do
474:37 - resolves dot to have
474:42 - length it should have
474:50 - one my test has passed if I write the
474:53 - two it should give me the error because
474:57 - we have only one property in the songs
475:01 - array I got the
475:04 - error I'm going to call it with
475:08 - one this is how you will do the
475:14 - mocking you have learned the feature
475:18 - Auto moing which is mock
475:20 - functions but we did not talk about the
475:24 - spank and you can control the
475:27 - behavior
475:28 - and you can assert on their usage during
475:32 - testing you can create the function
475:34 - spying on spy you can spy on a function
475:37 - by using the just. spy
475:40 - on it allows you to create a spy or a
475:45 - mock function for an existing object
475:48 - method if you want to spy on existing
475:51 - object you can do that if you want to
475:53 - spy on existing class you can do
475:57 - that now we're going to spy on an
476:01 - object we have an object spy on a method
476:05 - on the
476:07 - object we going to Let's imagine we will
476:10 - have the song repository and we have the
476:13 - create method what I want to do I want
476:16 - to spy on the create method I don't want
476:19 - to use this implementation I want to use
476:22 - my fake implementation in under the
476:25 - hood just will tell you you I called
476:29 - this function but I have used your
476:35 - implementation this implementation this
476:38 - one instead of instead of using this
476:41 - original
476:49 - implementation let's spy
476:52 - on I want to I want you to create a new
476:55 - file since by on demo dopc
477:07 - dots let's create a song
477:11 - repository and we have a create function
477:14 - let's imagine we have a find
477:20 - function let's imagine we have the find
477:24 - one
477:26 - function I want you to add the add this
477:30 - Pi on this find find and find one but
477:34 - first let me do that find one will
477:36 - accept the ID let's
477:39 - imagine the
477:42 - ID now let's create a
477:45 - [Music]
477:57 - function so I created the test case it
478:00 - should spy on the
478:03 - existing method
478:05 - function object
478:13 - method so you can create a function on
478:17 - this py
478:27 - on
478:31 - so this is how you will spy on the
478:35 - function it should also give me
478:42 - the toll tip
478:48 - create if I log this piy function let me
478:51 - show you what is inside
478:54 - that I have to run this file
479:09 - P I want to spy
479:12 - on it's going to run this
479:15 - file my test has passed but this is a mo
479:22 - function if I call
479:26 - that it should give me nothing because
479:29 - it's an
479:31 - [Music]
479:33 - undefined what what if I call the
479:37 - function SP and I'm going to call
479:42 - it not an ID let's provide the
479:54 - title or let's say if I call the
479:57 - function
479:58 - [Music]
479:59 - function of this song
480:02 - repository you will see the
480:09 - magic I have called this function now my
480:14 - function this function is pying on this
480:21 - function what will
480:25 - happen if I log
480:29 - spy do
480:32 - mock do
480:34 - calls it should say I have been
480:40 - called with this argument
480:45 - array it's an array mo. length which
480:49 - should be
480:50 - [Music]
480:51 - one it is saying I've been called only
480:54 - one time by using this one if I call
480:58 - song repository. create let's
481:02 - say
481:04 - title new
481:07 - song now the length should be
481:10 - two you can see
481:13 - that if you want you can spy on the
481:17 - function spy do to have been
481:25 - called now my function has been
481:29 - called expect
481:35 - spy you can also say that to have been
481:42 - called called
481:53 - with called
481:56 - with title should be
482:02 - lower it is fine now if I say lovers it
482:07 - should give me the
482:08 - error you can see I got the
482:18 - error you can also track the how many
482:23 - times this function has called to have
482:26 - been being call times it's going to give
482:30 - me the
482:32 - one I'm spying on this function song
482:36 - repository. create similarly you can spy
482:38 - on the find and the find
482:43 - one you can also spy on a class I'm
482:47 - going to create a new
482:50 - class we
482:53 - have let's say I'm going to place the
482:55 - Clause here we have safe method in the
482:58 - artist repository I want to spy on this
483:06 - function but you can also write the
483:09 - implementation just like we did it we
483:12 - can have our own custom
483:15 - implementation I call this
483:17 - method now you can see
483:21 - that to have been called times to have
483:24 - been called with at the end you can also
483:28 - restore the
483:30 - mo but I would like to do this one after
483:35 - each please restore all the mocks this
483:38 - is a hook after
483:41 - each it is going to run after all the
483:44 - test in this section in describe
483:48 - section now we're going to copy
483:51 - that test case and paste it
483:56 - here
483:58 - we have created a new instance from the
484:01 - artist
484:03 - repository and I call just. spy on I
484:06 - want to spy on the save function but I
484:08 - also want to add my
484:11 - implementation it is going to return the
484:13 - create artist dto or it is going to
484:16 - return you can say
484:18 - that I would like to return the
484:23 - object create artist dto and I want to
484:27 - add the
484:29 - ID now you can see that spy it is going
484:34 - to call this function artist. save what
484:38 - is here I called spy name and it has
484:42 - returned Martin Garrick and with ID
484:45 - which is one and how many times to have
484:49 - been called yes expector to have been
484:52 - called with name we provided the Martin
484:56 - garx
484:59 - spy and I don't need to do that because
485:02 - we are doing it
485:05 - here
485:07 - expect
485:12 - spym do calls. length how many times
485:16 - have you been
485:17 - called I think I did it one time
485:23 - rt. everything is to have been
485:27 - [Music]
485:29 - hold with two
485:34 - times also called artist. save and I
485:38 - also called it
485:45 - manually now it looks
485:50 - good in this lesson I'm going to teach
485:52 - you the concept of unit testing in
485:55 - nestjs when you do unit testing you test
485:59 - the individual component of your
486:01 - application individual component means
486:03 - individual function of a controller of a
486:06 - repository of a
486:09 - service we have song song service I have
486:15 - attached this started kit project you
486:17 - have to open it and run npm install you
486:21 - got to install all the
486:24 - dependencies we have uh we have this
486:27 - song
486:28 - controller when I'll be talking about
486:31 - unit testing I mean I have to test
486:35 - individually this function get song get
486:40 - songs create song and update song and
486:44 - delete
486:46 - song but you notice the song controller
486:50 - is dependent on song
486:53 - service here we need more implementation
486:57 - of song
486:58 - service
487:00 - because I want to test individually this
487:03 - song controller but when we will do end
487:06 - to end or integration testing when you
487:10 - will test the end to end you will
487:12 - integrate all of your services all of
487:15 - your classes all of your
487:22 - dependencies you can verify your unit of
487:26 - code such as fun s methods or
487:31 - classes with the help of unit test you
487:34 - can find the bugs earlier you can
487:38 - improve the code quality you can do
487:40 - faster debugging you can refactor all
487:44 - refactor code very
487:50 - easily now when you run the source code
487:54 - when you run the test for song control
487:57 - dopc file nestjs already created this
488:02 - spec file for us if you run that it is
488:06 - going to say hey when I look at the song
488:11 - controller I saw dependency There song
488:15 - service but when you are creating the
488:19 - testing module here we are creating the
488:22 - testing module on the Fly n sjs will
488:25 - compile it when it will comp compile it
488:27 - will instantiate all the dependencies
488:30 - for the testing module here it is saying
488:33 - I'm depending I'm dependent on song
488:36 - service but you are not providing any
488:38 - song service here you not providing any
488:41 - provider let's
488:43 - say you are not any provider song
488:49 - service so it will give me the
488:52 - error because we are doing unit testing
488:55 - I don't want to include song service
488:57 - here I want to test individually these
488:59 - components but I'll teach you how to
489:02 - fake how to create the fake
489:04 - implementation of song service here we
489:06 - are getting the controller from this
489:09 - module and it should be defined this is
489:13 - the first test NP you can run the test
489:18 - they have created the script for testing
489:21 - I'm going to use this one npm run
489:25 - test watch
489:30 - let me provide the pattern for song
489:34 - controller
489:36 - dopc now it is going to watch this spec
489:44 - file you can see that test has failed
489:48 - now
489:52 - here have you included song service in
489:55 - the
489:56 - provider
489:57 - no we no we did
490:00 - not if I will add the song
490:09 - service but still getting the error now
490:13 - the song service is dependent on the
490:16 - song
490:18 - repository but we will include all these
490:22 - dependencies in integration testing but
490:25 - I want to test the individual components
490:28 - so get rid of the song
490:30 - service I got the error so we need a
490:33 - fake implementation we got to create the
490:35 - mo service for the
490:40 - song Here is how you can
490:44 - register a mock service with the help of
490:47 - Mo
490:51 - implementation you have to register the
490:54 - song service and you going to provide
490:56 - the song service
490:58 - provider here you have to use the use
491:01 - value property to create the fake
491:04 - implementation object or the
491:07 - service you will have the get songs
491:10 - method inside the song service here I
491:14 - created the mo function and it is going
491:17 - to return the promise with this
491:20 - record let's try to check it
491:23 - out when I will open the song service
491:28 - we H we will have these methods get song
491:32 - is returning a promise get song is also
491:35 - you have to write the fake
491:37 - implementation or Mo implementation of
491:39 - the song
491:45 - service we
491:47 - need
491:50 - providers song
491:56 - service
491:58 - song
492:01 - service here we have to write the fake
492:05 - implementation get
492:09 - songs you can create a mock
492:13 - function all you need to do is return a
492:18 - promise with a value let's
492:21 - say ID is
492:23 - [Music]
492:24 - one title
492:30 - title let me check the song
492:33 - model or song entity we have one
492:36 - property which
492:38 - is
492:41 - title dancing
492:45 - feed now I
492:49 - have the mock implementation of get
492:55 - songs now you can write the test
492:58 - case make sure you get the
493:02 - service if you need I think I don't need
493:09 - that you can see that now my test has
493:13 - past now I'm going to write another test
493:17 - case it
493:19 - should it should fetch all the
493:26 - songs
493:31 - or you can wrap your code inside the
493:36 - describe fetch all the
493:40 - songs here I have to write this one or
493:44 - you can say if you need to write
493:46 - multiple test
493:48 - cases for get songs functionality you
493:52 - have to do it in this
493:56 - block
494:00 - now we have to call the
494:02 - function
494:05 - songs v
494:10 - controller. get
494:12 - songs it's going to call this method get
494:17 - songs you have to use the async
494:26 - keyword
494:28 - now we have to write the
494:31 - matcher it is going to give me the array
494:33 - of the songs to
494:38 - equal now we're going to copy this
494:48 - one a test has passed now get
494:52 - song should fetch all the
494:55 - songs
495:04 - now I'm going to
495:06 - copy all of the code for mock
495:11 - implementation for the methods of
495:17 - controllers it should add the create
495:20 - song dto it should have the update song
495:25 - dto what we have done so far I created
495:29 - the mo
495:30 - function with Mo implementation remember
495:34 - it is get it is getting the idea is an
495:39 - argument now it's going to return the
495:43 - promise here for the create song it is
495:46 - accepting the create song
495:48 - dto I create the ID which is a unique
495:51 - key and I have separate the separate the
495:55 - create Song D it's returning a promise
495:58 - similarly we have done for the update
496:02 - song we created the mock function with
496:05 - an argument update song dto returning
496:08 - the
496:10 - promise in song service for the update
496:14 - it is returning the update result so
496:16 - make sure you have this affected one and
496:19 - delete song what is an
496:21 - error oh I have to restart
496:24 - the
496:25 - project
496:27 - now we have a fake implementation of
496:29 - delete
496:30 - song now let's test this
496:35 - [Music]
496:36 - function get song by ID I'm going to
496:40 - copy
496:42 - that get song by
496:45 - ID you can provide an ID which should be
496:51 - anything get song Yes ID could be
496:55 - anything or I I can provide
496:57 - a unique
496:59 - key a uu
497:10 - ID you can see the test has pass now for
497:14 - get song
497:15 - ID now I'm going to copy the create song
497:19 - Let's test
497:23 - it we have created the new new song by
497:28 - using Create song
497:30 - dto we have to provide this create song
497:33 - dto and song. title should be run away
497:36 - because we are giving this argument here
497:40 - create function is giving me the create
497:42 - song dto with
497:46 - ID or you can also write
497:50 - another matcher to
497:53 - equal ID should be a uu ID
497:57 - ID and
498:00 - title should
498:03 - be
498:04 - Runway run
498:18 - away you can see that my test has passed
498:23 - now similarly we have to do the same
498:26 - thing for update
498:31 - song we are creating the update song
498:34 - dtoo by using the update song dto object
498:38 - I would like to update the
498:42 - title it should be defined and affected
498:44 - should be
498:53 - one update
498:55 - song
498:58 - you can see update song has passed
499:02 - now now we have to
499:05 - perform testing for delete
499:12 - song I just provided the ID you can
499:16 - provide any
499:23 - ID you can see that delete song has also
499:27 - passed now this is how you will test
499:30 - your controller unit testing for
499:36 - controller in this lesson we're going to
499:38 - test our service we're going to write
499:41 - unit test for
499:43 - service when you run this service you
499:46 - will get the same error because in this
499:49 - song service we have a one dependency
499:52 - which is repository the song Repository
499:58 - we have these so repository will
500:02 - have this we have to write the mo
500:06 - implementation for find method find one
500:10 - or fail save method and create method
500:15 - update and the delete because our
500:18 - service is using these methods from the
500:21 - song repository so if you write the if
500:25 - you run the test for song service. speec
500:29 - you will get the same issue this is the
500:31 - default implementation from nestjs
500:34 - Project they are using the provider
500:38 - right now we don't need any controller
500:40 - here we are doing unit testing we are
500:43 - doing individual testing for each
500:53 - function let's run the song
500:57 - service it is going to find the song
501:00 - service. spc. TS
501:07 - file the test has failed
501:11 - now it is dependent on the song
501:14 - repository but I did not provide here I
501:16 - did not register it so we have to create
501:19 - the fake or Mo implementation for song
501:25 - Repository
501:28 - what I'm going to do I'm going to copy
501:31 - this code we
501:34 - need
501:39 - these get
501:42 - repository and get
501:51 - song I have created a two objects song
501:55 - array song one song song and the song
502:02 - array this is how you will create the mo
502:06 - implementation for the repository we
502:08 - have to get the repository
502:12 - token here I can do
502:23 - that one thing make sure you provide the
502:25 - song service
502:27 - I forgot to do that in the controller
502:30 - Let's test
502:40 - it so everything is working fine now now
502:44 - we're going to test the
502:53 - service we have to import it get
502:56 - repository
502:59 - token I'm telling to nestjs this is my
503:03 - fake or Mo implementation for the
503:10 - repository song
503:16 - service for the find it is going to
503:19 - return the array we use promise. resolve
503:22 - Mo
503:23 - implementation for the just I'm getting
503:26 - the options as a find one options you
503:29 - can import it from the type orm we also
503:32 - need to
503:34 - import create song
503:37 - dto it is returning a promise with one
503:41 - song it is going to return the promise
503:45 - with a song newly created song and save
503:47 - method is just a simple Mo function it's
503:50 - not doing
503:51 - anything in update we need to get update
503:55 - song
503:57 - dto we have return the mo
504:01 - implementation and it is returning a
504:03 - promise with one
504:05 - song for the delete it is returning a
504:08 - promise with
504:09 - affected but maybe for the update you
504:12 - can give this response affected
504:17 - one now we have to test
504:20 - it if you need a repo you can get the
504:25 - repo yes we may need a repo I can get
504:29 - the repository by using get repository
504:34 - token let's
504:37 - test the method from the song
504:40 - service it should give me this song by
504:43 - ID we're going to test this method this
504:46 - [Music]
504:48 - one this
504:50 - one get song by ID this
504:54 - one it is using find one or fail and is
505:01 - using fetching the song on the based on
505:04 - ID so what I have I have done I created
505:07 - a new
505:09 - song I I got the song on the based on ID
505:13 - it should be Yu
505:15 - ID Yu
505:19 - ID so I'm going to spy on this find one
505:24 - or fail
505:27 - what I have
505:29 - done I called this method get song in
505:32 - under the
505:34 - hood this Pi this method this Pi just Pi
505:38 - will be spy on find one or fail it is
505:41 - saying hey you have called find one or
505:44 - fail from the original repository
505:47 - method and it has been called with this
505:53 - one this is how you can write the unit
505:56 - test
505:58 - now we're going to write the test
506:01 - case to create song I created this
506:07 - song and I'm going to expect it with one
506:13 - song called one
506:15 - time and you can say called with title
506:20 - lover let's copy the
506:25 - update let's copy the
506:43 - delete everything is passed
506:49 - now for update I think inside the song
506:53 - service what we have done update
506:58 - result so we have to fix
507:02 - it more repository it should give me the
507:06 - affected and the
507:13 - one
507:17 - result
507:19 - result do affected equals
507:23 - to
507:25 - affected
507:34 - one test has passed now if you want to
507:38 - spy on delete method how many times I
507:41 - have call delete method if you want to
507:44 - track the calls you can spy on that by
507:48 - using the Spy repository on delete
507:51 - method I've have been called this one
507:54 - time and it is affected one time I got
507:57 - the it means affected means one record
508:00 - has deleted
508:01 - successfully and it has been called with
508:05 - uid that's all for unit testing with
508:25 - service
508:29 - now you're going to learn the concept of
508:32 - end to end testing we're going to do end
508:34 - to end testing for our nextjs project
508:38 - end to end testing is a software testing
508:40 - methodology that focus on testing the
508:43 - entire application flow from start to
508:46 - finish now we're going to integrate all
508:48 - the song controller repository song
508:52 - service
508:54 - everything you can do
508:57 - API testing in end to endend
509:01 - testing validation of the user flow
509:04 - improved user
509:05 - experience now we're going to start
509:07 - doing the end to end testing first step
509:10 - we have to add the script in our
509:12 - package.json
509:14 - file they have written the script for
509:16 - end to endend testing but they did not
509:19 - add add the
509:20 - watch that's why I just addit the watch
509:24 - or detect open handle
509:27 - I I have written this line or keyword
509:30 - for to handle the
509:33 - errors if you will not at this line This
509:37 - one this
509:38 - word it will give you some type of
509:41 - warning
509:44 - messages the first step we have to
509:46 - register it the type or a
509:52 - module in the song and to end test here
509:56 - we have the end to end
509:59 - test this
510:05 - one this is the end to endend test for
510:07 - our generic application let's run
510:10 - it npm run
510:13 - test find the
510:17 - script test E2
510:21 - e and the watch
510:24 - mode
510:33 - let's provide the pattern
510:36 - app it is going to run this spec file
510:40 - this is end to endend testing for app
510:47 - module going to create nests application
510:51 - and initialize it here it is going to
510:54 - test our root
510:58 - URL under the hood they are using the
511:01 - Super
511:03 - Test request from the Super Test making
511:07 - the API request by using calling the
511:09 - server this is the end point and it is
511:13 - expecting the 200 status
511:17 - code test has
511:21 - failed got expected 200 but got 4
511:39 - 44 but I would like to add the test
511:45 - case into to end testing for our song
511:49 - controller for song
511:54 - module
512:05 - let's create a new
512:09 - file here inside the test I'm going to
512:13 - name it to
512:14 - songs I can call it
512:17 - songs do E2
512:22 - do- spec. DS file
512:31 - it is just an initial code you can copy
512:34 - that from the app do e2e
512:38 - testing I got this
512:43 - one describe it should be
512:48 - songs import couple of
512:52 - dependencies type or module
512:56 - make sure you have created the database
513:01 - for testing I created that with the test
513:04 - F and syn synchronize set to true you
513:08 - have to register entity manually it will
513:12 - not work with regular
513:14 - expression at the end of each or at the
513:18 - end of all test when all the test will
513:21 - be finished it is going to drop the
513:23 - schema we will have the song Mar
513:29 - is not getting the path I think
513:36 - so we have to do in This
513:45 - Way song Find song
513:51 - entity same thing
513:54 - here
513:58 - there
513:59 - is I got the testing
514:04 - modu that's
514:06 - it now we have to run
514:16 - it here you have to provide
514:20 - your
514:22 - username
514:23 - password and the Local Host Post Port in
514:27 - the name of your
514:32 - TP it is going to run this
514:36 - file I got the error you your test Suite
514:40 - must contain at least one test all right
514:43 - now we're going to test the
514:49 - code first
514:52 - step after each test we have to clear
514:56 - the repository because we're going to
514:58 - interact with
515:03 - database in the
515:06 - describe this will be run before all and
515:09 - we will have after each we have to clear
515:15 - everything from the song table or song
515:18 - repository this clear method will delete
515:21 - the records from the table but it will
515:23 - keep the schema schema
515:26 - this function or this hook will run
515:28 - after every
515:32 - test make sure you import the super
515:43 - test I'm going to write the test case
515:46 - for
515:47 - delete or not not a delete for
515:54 - create
515:56 - I just created a new method create song
516:00 - we have the song song. title song.
516:03 - repository and it is going to save the
516:07 - song in the real database right now we
516:10 - don't have more implementation for the
516:13 - song repository or the song service it
516:16 - is going to save the record in our real
516:19 - database we are using the test
516:21 - def if you don't have test def you can
516:24 - create it
516:27 - I have set the title get the repository
516:30 - instance from the app.get and called the
516:33 - safe
516:40 - method maybe you need to
516:43 - add a weight
516:52 - expression because we are returning a
516:54 - song
516:56 - with
516:59 - promise you can do in this
517:02 - way it will automatically get this
517:05 - promise with
517:06 - song let's write the test
517:11 - case before fetching these songs make
517:15 - sure you have the record in the database
517:18 - that is why that is why I created a new
517:22 - song with create song first you got to
517:26 - save the song in the in the postest
517:29 - database with title
517:31 - animals and then you have to send the
517:35 - API request to this URL
517:38 - doget and here I'm checking the status
517:42 - code should be 200 and the request body
517:46 - or the results body should have length
517:48 - one which should be have one record it
517:51 - is an array it is going to give me the
517:53 - array in results. party and I'm I have
517:58 - created a one song
517:59 - so it should be there there should be
518:03 - one song in our database so that's why I
518:06 - converted into an
518:08 - array after then when this test will be
518:12 - completed it is going to call this
518:15 - method clear the
518:17 - repository you can see our test has
518:20 - passed now if I write let's say 20 1 or
518:26 - maybe 400 it is going to give me the
518:28 - error hey I'm expecting
518:46 - 200 you can see I got the
518:50 - error so get song endpoints has tested
518:54 - successfully
518:56 - now we're going to get test get song by
519:00 - ID first we have to create a new song
519:04 - then I have to I have to send the API
519:06 - request make sure you have to send the
519:09 - ID I created this song because after
519:12 - each test it is going to clear the
519:14 - repository it is going to delete all the
519:17 - records from the songs
519:20 - table create a
519:23 - song then it's going to you have to
519:25 - provide the ID first I have created the
519:27 - song then we have to test it make sure
519:31 - the body should equal to this
519:35 - song I'm going to save the
519:38 - application it should
519:44 - pass two test has passed
519:47 - now now we're going to test update songs
519:54 - endpoint make sure you have to import
519:59 - it it should be
520:04 - it create a new
520:07 - song and you have update song dto I
520:10 - would like to update the animals to
520:13 - wonderful sending the API
520:16 - request this is how you will send the
520:22 - data to if you want to send the Json op
520:25 - object into the request body you can
520:29 - call the send method I want to send it
520:31 - as a update song
520:33 - dto this one I want to update the title
520:35 - which is wonderful status code should be
520:39 - 200 and affected should be one it means
520:42 - our record has updated
520:47 - successfully and
520:50 - let's do this for
520:54 - post
520:58 - we have this is our create song dto we
521:01 - did not
521:04 - create we did not create the song right
521:07 - now I'm going to use the create song dto
521:10 - provide it as a request
521:13 - body the status code should be 2011 and
521:16 - the title should be
521:20 - animals for test has passed now we have
521:24 - to test the delete song
521:27 - endpoint let's create the song first and
521:32 - then we have to provide the ID which
521:34 - record you want to
521:36 - delete status should be
521:38 - 200 and the affected body should be
521:42 - affected should be one it means record
521:44 - has deleted
521:49 - successfully this is how you will write
521:51 - the end to endend or integration testing
521:53 - with database or the nestjs
521:57 - application nestjs version 10 has
522:01 - released
522:02 - now I'm going to show you how to create
522:06 - new projects with nestjs version 10
522:10 - version 10 is very fast they have
522:14 - integrated the rest rust compiler they
522:18 - have integrate the rest to compile the
522:20 - source code
522:23 - sjs if you Google the version 10 you
522:26 - will find the blog post from the owner
522:29 - of the
522:32 - nestjs they have
522:34 - released version 10 in the version
522:39 - 10 you you can compile the code in a
522:43 - faster way like it will also improve the
522:47 - hot
522:48 - reloading you
522:50 - can you can do development in the more
522:54 - fast
523:00 - way to start a project you have to add
523:03 - this
523:05 - command we we're going to use this
523:07 - [Music]
523:09 - options this one we will add these
523:11 - options into Nest
523:13 - CLI they have also introduced a new
523:17 - feature this time you can Mo the entire
523:21 - module instead of provider and
523:24 - controller
523:26 - these are all the new features in the
523:29 - nestjs version 10 but the main feature
523:33 - is improving the compile code speed of
523:38 - the
523:39 - compiler but let's create a new project
523:44 - first of all you have
523:46 - to
523:48 - remove or uninstall nest
523:53 - jli because you will have have the older
523:56 - version of n
523:59 - CLI I'm using Mac so we need to add the
524:03 - sudo keyword instead of install first we
524:07 - need to
524:10 - uninstall the
524:12 - nli I have already installed
524:18 - nli can I check the version of this
524:21 - package I don't know let's try to look
524:23 - at that
524:27 - I have
524:29 - 8.1.0 I have I have the latest version
524:33 - but it will generate the nestjs 10
524:37 - project Nest
524:40 - new and we have to provide the name of
524:43 - our project I can
524:48 - say web
524:51 - socket
524:53 - implementation
525:04 - nextest let's do it again nextest new
525:08 - the name of the project
525:13 - websocket
525:19 - implementation I would like to use the
525:23 - npm
525:25 - it will take some time to install these
525:49 - dependencies my project has
525:52 - created I can look at by going to this
526:00 - directory I would like to open this
526:03 - project into my vs code
526:13 - editor if you check the package. jsn
526:16 - file you can see we have the nest
526:19 - version
526:22 - 10 now what I have to
526:25 - what I have to
526:27 - do we have to compile the code
526:34 - faster let's first we have to run the
526:38 - project without this command This
526:42 - One S swc Speedy web compiler first we
526:47 - have to run it
526:49 - without Speedy web
526:53 - compiler
526:58 - you can look at the time for running the
527:11 - project when you will have multiple
527:15 - modules you will have multiple
527:17 - controllers and you added the testing
527:20 - functionality your application speed
527:22 - time will be slower your development
527:24 - time will will be
527:26 - slow so let's make it
527:29 - faster with the help
527:32 - of these two options I want you to add
527:35 - these
527:38 - options into package into
527:43 - nli n c.
527:46 - Json I'm going to add these two options
527:49 - to my
527:53 - compiler these two
527:56 - options Builder I would like to use the
527:58 - S swc and type
528:06 - check let's run the
528:22 - project you can see that I got the issue
528:26 - fail to load fail to load s swc CLI and
528:31 - S swc core we got to install these two
528:36 - packages let me execute this
528:39 - [Music]
528:40 - command install it as a def dependency
528:44 - because I want to improve the project
528:47 - running
528:49 - time increase the
528:51 - development
528:53 - time
529:01 - so packages have
529:04 - installed now we need to run the
529:07 - project now it can take the S
529:13 - swc it can use this Builder and type
529:21 - check our project is running
529:34 - the project running time has increased
529:40 - now if I save something in our
529:44 - application let's
529:46 - say in the app
529:50 - controller in the app
529:52 - [Music]
529:53 - service
529:55 - hello world from nestjs version 10 I
529:59 - want to save the
530:03 - application successfully
530:10 - compiled this is how this is how you can
530:14 - improve this implement or in improve the
530:19 - development time the project running
530:23 - time in development
530:33 - environment in this module we're going
530:35 - to work with web
530:38 - sockets when you want to implement real
530:41 - to real time application like chat web
530:44 - application real time web
530:47 - analytics live streaming online gaming
530:50 - then you need web
530:53 - socket which we have worked with HTTP
530:57 - server in
530:59 - HTTP where client sends the request in
531:02 - the server
531:04 - response but if you if you're using web
531:08 - sockets web sockets establish a
531:11 - persistent connection between client and
531:13 - the
531:14 - server and you can have ongoing
531:17 - communication the best example is
531:20 - Facebook Messenger you send a message to
531:22 - your friend and your friend rep replies
531:25 - and you reply to your friend and your
531:26 - friend reply this is how the bir
531:29 - directional communication Works in under
531:31 - the hood they have implemented the
531:33 - websocket protocol they are using the
531:36 - websocket
531:38 - technology if you need to make
531:40 - persistant connection then you need
531:43 - websocket you want to implement a
531:45 - realtime feature like live updates live
531:49 - score live streaming then you need
531:53 - websocket
531:55 - here is chat application can be built
531:57 - with web socket collaborative editing
532:00 - tools real time analytics online gaming
532:04 - and the live streaming nestjs also
532:08 - provides websocket module you can use
532:11 - that but it also provide two approaches
532:14 - you want to do you want to work with
532:16 - socket iio or you want to use the web
532:18 - socket you can get the details from
532:20 - their official
532:22 - documentation but in this video I'm
532:24 - going to implement the socket
532:26 - IO you got to install these two
532:32 - packages I'm going to open my
532:35 - package.json file let me add my
532:40 - dependencies I think I already installed
532:43 - these two dependencies I don't need to
532:45 - do it again you can do it manually by
532:48 - running npm install and first install
532:52 - this
532:52 - dependency and then you have have to
532:54 - install these
532:57 - dependencies our next step is to create
533:00 - the events module we will have the
533:03 - Gateway a Gateway will be responsible
533:06 - for handling the events you will have
533:10 - the events module a Gateway is nothing
533:12 - more it's a class with provider you can
533:15 - inject it as a
533:17 - provider here we we need this Gateway
533:20 - we're going to create the event Gateway
533:22 - it's nothing more it's a class
533:25 - here you have to decorate with websocket
533:28 - Gateway I'm allowing any origin you can
533:32 - use any specific origin if you
533:35 - want here I'm trying to implement the
533:38 - own module in
533:41 - it when any client connected to my
533:45 - application this event will be
533:47 - triggered this is how you will register
533:49 - the event by using the own own
533:53 - function I can also get the socket ID I
533:57 - can also log that have has it connected
534:01 - or
534:04 - not this is how you will create or
534:06 - register a new event subscribe message
534:10 - and we will have a function new message
534:13 - you will have the message body you will
534:15 - get the
534:17 - data if someone sends message or filed
534:22 - an event from the client side
534:25 - application like react angular view or
534:28 - any kind of front- end
534:30 - application this function will be called
534:34 - but make sure they have called this
534:37 - event with message key this key and it
534:41 - is going to lock the data you can read
534:44 - this text here for every
534:48 - detail let's create events
534:53 - module
534:57 - we have created the events module now
535:00 - let's create the
535:04 - Gateway you can see we have the events
535:14 - module Gateway will be registered as a
535:17 - provider you can see in the events
535:22 - module we have websocket Gateway by
535:26 - using this decorator and we have one
535:32 - event if you want you can add the
535:42 - CES and we also need to establish a
535:47 - connection I need to check make sure you
535:51 - imported server from socket IO
535:55 - Library you have to import it manually
535:59 - otherwise it will not
536:01 - work websocket G websocket
536:05 - server now we have this handle
536:08 - message subscribe
536:10 - message when you need to register an
536:13 - event in backend application or the
536:16 - nestjs application you will use the
536:18 - Subscribe message
536:23 - decorator
536:27 - and what I would like to do I want to
536:31 - get the data or you can have client but
536:34 - I like the data I don't have any payload
536:37 - option but I'll use the message body
536:41 - decorator instead of use this one
536:44 - message
536:46 - body data should be type
536:51 - any I'm not going to return any thing
536:54 - right now all I want to log the
536:57 - message I can say message received from
537:01 - the
537:03 - client and this is my
537:06 - message or I can log the
537:13 - data so far we have registered the event
537:16 - when any web application like any
537:19 - front-end application has connected to
537:22 - our websocket server
537:24 - first they need to connect on the our
537:27 - host here we have provided but right now
537:30 - we're going to run the project on Local
537:31 - Host so any front end application should
537:35 - connect with Local Host colon 3000 and
537:39 - then he can establish a connection
537:41 - between with with this application when
537:44 - when any front end application establish
537:47 - the connection it's going to call the
537:49 - own module in it but right now I don't
537:51 - have any own module in it right now it
537:53 - will log
537:54 - this
537:58 - message
538:00 - implements on module in it that's it
538:05 - after module loaded or this file is this
538:08 - class is loaded successfully then we can
538:11 - log the
538:12 - message when connection established this
538:14 - event will be triggered and it is going
538:16 - to call with socket I ID and the
538:19 - connected its Boolean
538:21 - value now we have set of the websocket
538:26 - server and we created our first event
538:29 - which is message you can have multiple
538:32 - events here you can also perform the DB
538:35 - operation like if someone sends a
538:37 - message you can save the message into
538:48 - database in the next video in the next
538:51 - lesson we're going to consume this event
538:54 - from our frontend application we will
538:56 - have a simple basic front end
538:58 - application with index.html and there
539:01 - would be JavaScript in the index.html
539:05 - file now it's time to consume the
539:08 - application consume the event or send
539:12 - message from the frontend application
539:15 - when you run your server let's say npm
539:18 - Run start
539:21 - def now my server is it's ready to
539:24 - listen this message event it's waiting
539:28 - for someone to send a message by using
539:32 - this event
539:33 - key so all you need to do you got to
539:37 - create a
539:39 - basic
539:41 - index.html file you can copy that code
539:43 - or you can create manually I can say
539:46 - client here I will have
539:49 - index.html file one more thing you will
539:52 - see events Gateway subscribed to the
539:56 - message event to this
540:00 - message so it means we successfully
540:02 - created the event I'm going to copy the
540:05 - code I'm using the socket IO Library
540:09 - where we are creating the socket IO
540:12 - instance by providing our application
540:14 - path in our case we have nest's
540:17 - application is running on Port
540:21 - 3000 we have registered a event
540:26 - it's trying to connect with our
540:30 - application with nestjs application when
540:33 - it when it will be connected it is going
540:35 - to log this message and emit this
540:39 - message to the server here I'm going to
540:41 - open the
540:42 - server this one events
540:45 - Gateway we have registered the message
540:48 - event this is how you can emit the event
540:50 - I'm telling to socket IO please call
540:55 - this function that's it and we also
540:58 - registered couple of events if someone
541:01 - if if server sends data back to the
541:06 - client we have to register it we have to
541:08 - catch the data here that's why I use the
541:11 - on
541:12 - listener if exception event trigger it
541:15 - is going to call this method if if our
541:18 - backend application disconnected or
541:20 - stopped it is going to call this event
541:23 - it is going to trigger this event now we
541:25 - right now we're not returning anything
541:27 - here let's try to test
541:31 - it uh I'm going to use open Live server
541:35 - go live when you open the index.html you
541:38 - will
541:39 - see this it is going to open my project
541:43 - into live server please check the
541:44 - console for message
541:50 - reply inside the console you will
541:54 - see you have connected
541:57 - successfully when you open your backend
542:01 - application this message is received
542:03 - from the
542:05 - client so client has sent this message
542:10 - or you can
542:11 - say I am the
542:15 - client I'm going to reload the
542:17 - application it has automatically reload
542:21 - reloaded you can see I'm the client
542:24 - so it has also connected one more thing
542:27 - you will also see this socket ID and it
542:30 - has it means connected successfully
542:33 - first it is going to log this message
542:35 - console. ID Lo connected we have emitted
542:39 - this message event it's going to call
542:41 - this
542:42 - function now we we are not returning
542:46 - anything that's why this event is not
542:48 - triggered let's try to return from
542:51 - return something I'm going to return
542:54 - some value let's
542:58 - say some value from server let's see
543:01 - what will
543:04 - happen our application
543:07 - reloaded let's try to test it out
543:10 - message received from the
543:17 - client but I did not log what message
543:21 - have you received
543:35 - you can see message received from the
543:38 - client on the client side we sent this
543:41 - message I'm the client it has
543:45 - received but it is not triggering this
543:48 - event I cannot see anything here let's
543:51 - say if I if I'll try to log
543:55 - something
543:59 - hello I cannot see this Hello message in
544:02 - my
544:04 - console it's not
544:06 - triggering so that is why you need
544:09 - observable websocket also provides the
544:13 - observable you can
544:15 - say I would like to return this
544:22 - observable
544:25 - websocket response and I can have any
544:30 - type here we have
544:32 - to convert the object to observable
544:35 - that's why I'm going to use the off
544:37 - operator from
544:42 - rxjs I can say
544:44 - event you got to provide the name of the
544:47 - event which is message and the
544:50 - data here you can return anything from
544:52 - the server
544:54 - message
544:56 - returned from
544:58 - server
545:01 - hello you should see this message here
545:04 - because we are listening on the client
545:09 - side you can see event message received
545:14 - from the server if I will refresh our
545:18 - application you will
545:20 - see this
545:22 - one message returned from the server
545:28 - hello if I stopped my application it is
545:31 - going to F this or trigger this
545:34 - disconnect event you should see the
545:38 - disconnected this is how you will create
545:42 - wi directional or realtime chat
545:45 - application with web
545:49 - socket in this lesson I'm going to teach
545:52 - you how to set up graphql server we're
545:56 - going to use Apollo server nestjs Apollo
545:59 - package nestjs graphql package graphql
546:03 - and TS
546:04 - Mor you can read the documentation of
546:07 - these
546:11 - packages I'm assuming you must know the
546:15 - basics of graph ql I'm not going to
546:18 - teach you the basics of graphql what is
546:21 - graphql and why do we need graph Q
546:25 - I have attached a started kit project
546:28 - you have to open it and run npm
546:32 - install I have already I have already
546:35 - installed all these dependencies I don't
546:38 - need to install them
546:40 - again all I need to do is to install
546:44 - graphql packages I'm going to copy all
546:47 - of these
546:52 - packages
546:55 - the packages have installed
546:58 - successfully and now the next step we
547:02 - have to register the graphql
547:10 - module I'm going to open my app
547:13 - module and we I would like to import
547:16 - graph module
547:19 - here we need to import couple of
547:21 - dependencies Apollo driver config
547:24 - I'm telling graphql hey I want to use
547:27 - Apollo
547:28 - driver and I will have do graphql
547:32 - file where I will place all my schema
547:35 - definitions in the graphql
547:41 - file this file will have the typescript
547:44 - typings of
547:46 - graphql and output as a class don't
547:50 - worry I'll Teach You How can you
547:51 - generate the typings
547:57 - we are using for RO to register the
548:00 - graphql
548:01 - module the Apollo driver config specify
548:05 - the type of the configuration options
548:08 - being
548:09 - provided so driver AP poo driver this
548:13 - property sets the driver used by the
548:15 - graphql module in this case we are
548:18 - telling graph Nest chairs hey I want to
548:20 - use a polo
548:22 - driver
548:24 - we will place all of our graphql schema
548:27 - in graphql file the extension should be
548:32 - do
548:36 - graphql uh if you want to generate
548:40 - typescript definition from your graphql
548:42 - schema you have to specify these
548:44 - definitions I'll teach you how to do
548:46 - that and we are just combining the
548:51 - path we will have so graph. TS file
548:55 - inside the source
548:57 - directory this property specified that
549:00 - the generated type script definition
549:02 - should be outputed as a class this means
549:05 - that the generated code will be
549:06 - representing represent the types as
549:09 - typescript
549:12 - classes now our next step is to create a
549:16 - schema
549:22 - file
549:24 - inside the song folder I'm going to
549:26 - create a new file song.
549:29 - graphql here I will place all of my
549:31 - schema file we're going to have a
549:36 - query let's define a song
549:39 - type we will have ID and the type of ID
549:44 - is required this means it is a required
549:47 - property it should not be
549:49 - null and I'm going to add a string
549:53 - variable or string type field which is
549:56 - title the type of the title is string
550:00 - and I'm also going to add a new query
550:03 - type here I can say I want to fetch all
550:06 - the
550:07 - songs and you can say the type should be
550:10 - song and it is going to return all the
550:14 - songs our next step is to generate the
550:17 - typings which is typescript definition
550:22 - file
550:24 - we need a graphql definition
550:28 - Factory
550:29 - class here we are trying to in we are
550:33 - instantiating or creating a new object
550:36 - from graph definition Factory there is a
550:40 - generate method to generate the typing
550:43 - you have to specify the type which is
550:46 - I'm using the regular expression here I
550:50 - will have all of my schema file in the
550:53 - cql that's why I use the type definition
550:57 - path and I would like to I would like to
551:00 - create all the type typescript
551:03 - definition in the graphql dots file it
551:07 - will save it as a class let's create a
551:10 - new
551:11 - file generate typings dots file inside
551:15 - the root
551:19 - directory typings
551:22 - dots
551:27 - now all you need to do is to execute
551:30 - this
551:31 - command NPS npx DS node generate
551:40 - typings it is going to generate the
551:43 - graphql dots file with this
551:48 - definition you can see that a graphql
551:51 - dots file has
551:53 - created we have a class which is song
551:57 - and we have a abstract type which is I
552:00 - query and we have this
552:03 - type so we will use this type definition
552:07 - when we will creating disolver functions
552:10 - when we will resolve queries against
552:13 - your schema
552:15 - files now I would like to run the
552:18 - application is everything fine now let's
552:21 - test it
552:27 - my application is running
552:29 - now let's send the request to Local Host
552:32 - colon
552:34 - 3000 and you will have playground at
552:38 - this graph quel
552:40 - Endo when you go to the Local Host colon
552:42 - 3000 you will see the playground this is
552:45 - how you will perform
552:48 - graphql apis you will test graphql apis
552:52 - by using this
552:54 - playground let's
552:59 - say I'm going to send the API request
553:02 - graphical API request I want to fetch
553:04 - all the songs I want to see the ID and
553:07 - the title but it is going to give me the
553:10 - error hey you don't you are not
553:12 - resolving this
553:14 - query because it's returning
553:17 - n it's getting the validation eror
553:21 - because we don't have any resolver to
553:24 - resolve this query this
553:29 - one in the next video I'll teach you how
553:32 - to create mutations and how to create
553:37 - queries we're going to we're going to
553:39 - fill our song
553:42 - schema let's complete our
553:50 - schema let's create a new
553:53 - query to fetch a single
553:57 - song when you try to fetch a single song
554:01 - you must need to provide the ID so ID
554:04 - should not be
554:06 - null and it should return this
554:09 - song in the
554:11 - response let's write a new
554:16 - query it should give me the
554:20 - song and I would like to fetch the the
554:23 - song on the based on
554:26 - id id should not be
554:29 - null now we're going to write uh venue
554:33 - query in the playground you got to
554:35 - follow the structure song and you have
554:37 - to provide the ID in this case I'm
554:40 - providing the 1 2 3 as an
554:44 - ID now we're going to Define mutations
554:47 - we learned how to fetch data with the
554:49 - help of query but I want to write the
554:53 - data so to to mutate the data you need a
554:58 - mutation so let's define an mut
555:03 - mutation
555:05 - mutation I'm going to have create
555:08 - song it will accept the create song
555:11 - input
555:12 - or create song
555:16 - input and I don't have any type so
555:19 - that's why I'm going to define the
555:21 - input create song
555:30 - input I will have the title field and
555:33 - the type should be string it should not
555:35 - be null so I can say the type of create
555:39 - song
555:40 - input it should be create song input and
555:44 - it should not be null and it should give
555:47 - me the song in the
555:51 - response
555:57 - now I want to write the mutation for
556:00 - delete song or you can say update
556:04 - song I would like to update the song
556:06 - Only the based on ID the first argument
556:09 - it should be ID and the update song
556:13 - input we will have update song
556:16 - input it should give me the update
556:21 - result this is not an empty
556:25 - field that's why I use this exclamation
556:29 - mark and
556:31 - input
556:33 - update song
556:36 - input title should be string but I did
556:42 - not mention it to required property if
556:45 - you will have multiple song multiple
556:48 - fields in song let's say a user will
556:51 - have let's say a song can have
556:55 - date or you can
557:00 - say date release date or publish date or
557:08 - artist something like that but I cannot
557:12 - set date required in the artist required
557:16 - field because it depends on the user a
557:19 - user can update the title or whatever he
557:22 - wants to upate
557:23 - update now I don't have any type for
557:26 - update
557:27 - result let's define a new type update
557:30 - result it will have
557:33 - affected and type should be
557:36 - number do we have int yes
557:42 - int similarly we will have a type for
557:45 - delete
557:48 - result delete
557:51 - result and typ should be int now we're
557:54 - going to Define mutation for delete
557:59 - song I can delete on the based on
558:03 - ID here I can say delete
558:06 - song I don't need to put anything and it
558:09 - should give me the delete result that's
558:13 - it so we did not resolve these queries
558:16 - in mutations in the next video we're
558:19 - going to write resolver functions to
558:21 - resolve these query and mutations Let's
558:25 - test it out by generating the
558:28 - type one more thing I want to show you
558:31 - can create a script to run the typings I
558:34 - can say in the package.json
558:37 - file let's define a new
558:41 - script we here you need to define the
558:44 - script generate slash colon typings TS
558:49 - node generate typings this njs project
558:52 - all already installed TS node as a def
558:55 - dependency you don't need to install it
558:57 - again npm
558:59 - run I can say generate
559:09 - typings it will generate the typings or
559:13 - types in the graphql dots
559:21 - file
559:28 - I found an
559:31 - error unknown type create song input did
559:35 - you mean create song input or update
559:37 - song
559:39 - input oops I have to fix
559:47 - that everything is fine now let me see
559:50 - my graphql dots file we have type for
559:53 - create song input type for update song
559:57 - input we have types for mutations and
560:01 - update result and delete
560:13 - result when you see your
560:16 - playground you have to look at the
560:18 - queries in mutations we have queries and
560:24 - mutation when you try to
560:28 - fetch let's say I want a query for
560:32 - songs ID let's say I'm going to provide
560:35 - invalid
560:36 - ID let's try to fetch the title and the
560:39 - ID I'm going to send the request it
560:41 - should give me the error hey you are not
560:45 - resolving that's why we need resolver I
560:49 - can use n CLI to generate a new resolver
560:54 - I can say
560:56 - song it's going to create a new resolver
560:59 - resolver is nothing more it's a provider
561:02 - like a service you can inject it as a
561:08 - dependency here you can see
561:11 - that inside the providers we have a song
561:15 - resolver and it is it also created the
561:18 - song resolver dopc file and song
561:21 - resolver we have resolver
561:23 - Tator now I'm going to resolve these
561:28 - queries I'm going to open song do
561:30 - graphql let's resolve this
561:34 - query I also need song
561:37 - service so Constructor
561:40 - private song service song
561:48 - service let's import
561:51 - it
562:00 - I have this I need a query
562:05 - decorator here I would like to resolve
562:07 - this query
562:10 - songs I can say get
562:12 - [Music]
562:14 - songs return this
562:16 - do song service dot get songs
562:23 - and you can also mention your return
562:26 - type I can get it from the song entity
562:30 - or song graphql type this
562:37 - one make sure you are using the Asing
562:42 - here what is saying unable to resolve
562:44 - the signature of method decorator when
562:47 - called as an
562:51 - expression
562:57 - oh we need to get the query from nestjs
563:00 - Craft
563:04 - ql now it looks
563:08 - good let's try to test it
563:18 - out let's try to resolve this query
563:23 - I would like to fetch all the
563:28 - songs you can see
563:30 - that we have a song I already created a
563:35 - song If you don't want to see the title
563:37 - you can say I only want to see the
563:40 - ID but I have single song in my
563:48 - database now let's resolve the query to
563:51 - fetch a sing single song I Can Say
563:55 - song
563:57 - async Get
564:01 - song it should give me the song with
564:08 - promise this do song service
564:12 - dot get
564:15 - song you need to provide the ID but I
564:18 - can get the ID
564:21 - here
564:24 - I can use the arcs from the N graphql I
564:27 - can say the
564:28 - id id is
564:32 - string let's provide the ID
564:41 - here I have saved my
564:44 - application let's try to resolve this
564:47 - query I want to copy this
564:50 - ID and let's fetch a
564:54 - song ID should be this one and I'm
564:58 - expecting the title in the response fail
565:01 - to fetch please check your connection I
565:03 - think my application did not start it
565:06 - now I have to send the request I got my
565:10 - record which is song on the based on ID
565:13 - if I provide the invalid ID let's
565:17 - say you will see the error invalid input
565:21 - Syntax for the type
565:24 - the ID does not exist as same
565:28 - here now I'm going to provide the
565:30 - correct ID I got the
565:34 - record you have learned how to resolve
565:37 - queries in the next video I'll teach you
565:40 - how to resolve
565:42 - mutations now you're going to learn how
565:45 - to resolve mutations in the previous
565:48 - video we resolved our queries let's
565:51 - resolve
565:53 - these mutations create song update song
565:57 - and delete
566:01 - song now you need mutation instead of
566:06 - query we also need create song dto as An
566:14 - arcs or you can say create song
566:18 - input you can also do that you can also
566:20 - get this typing from from graphql
566:24 - file and I just called this
566:32 - function it's not finding source. cql we
566:36 - have to do it
566:43 - manually now it looks
566:51 - good
566:54 - it is taking some time to in restart the
567:07 - server let's create a new
567:10 - song I'm going to write mutation create
567:13 - song create song input we have to
567:16 - provide
567:19 - title the name of the song which is
567:21 - follow me
567:23 - I want to see ID and title in the
567:26 - response you can see a new song has
567:29 - created I can fetch all the songs and
567:32 - you can see follow
567:34 - me it means we successfully created this
567:38 - we have successfully resolved this
567:39 - create song
567:41 - mutation now it's time to resolve update
567:44 - song
567:45 - mutation I'm going to copy this
567:47 - [Music]
567:49 - one update song we need to Res solve we
567:52 - need to get update song
567:54 - input update song
567:57 - dto or you can use update song input
567:59 - from graphql file I also need to get
568:05 - update result from
568:09 - graphql it is
568:18 - saying I'm getting the
568:21 - error
568:23 - update
568:26 - song If I get this
568:30 - from from typ orm let's see what will
568:36 - happen now it looks
568:39 - good because this start update
568:42 - song it's returning the update result
568:45 - from type
568:46 - orm when you look at the update song you
568:50 - will see the Promise with update result
568:53 - I imported update result from
568:59 - typm let's try to update the
569:03 - song I'm going to write
569:06 - mutation update song we need the
569:10 - ID I'm going to copy this
569:13 - ID let's place it
569:20 - here and we we also need to provide
569:23 - update song
569:26 - input I would like to update the title
569:29 - update
569:33 - song Let's fetch all the songs and you
569:37 - can see the updated
569:39 - song similarly we need delete mutation
569:43 - let's resolve it I'm going to copy it
569:47 - here delete song we have to get it from
569:50 - the type orm
569:57 - let's try to delete this song
570:00 - mutation delete
570:02 - song we need to provide the ID I'm going
570:05 - to copy this
570:09 - ID let's see
570:14 - affected delete
570:16 - song successfully executed it should
570:20 - delete the song
570:22 - let's try to fetch the song on the based
570:24 - on this
570:26 - ID you will see there is no song here
570:29 - you can see there is no
570:34 - song in this lesson I'm going to teach
570:37 - you how to handle errors in
570:40 - graphql let's say I want to fetch all
570:43 - the songs but instead of returning all
570:46 - the songs I have to return the
570:50 - error you can do simp simply by using
570:53 - throwing the error or you can say let me
570:56 - do this in this way I'm going to comment
570:59 - this line through new
571:02 - error I can say unable to fetch
571:07 - songs let's try to send the graphical
571:11 - request it's still
571:16 - working my application did not reload
571:19 - yet let's wait
571:22 - now it has
571:26 - reloaded you can see unable to fetch the
571:28 - songs I got the error internal server
571:34 - error uh if you check the Apollo
571:36 - documentation we are using Apollo driver
571:39 - Apollo driver is saying you can use the
571:41 - graphql error class and you can provide
571:45 - your own
571:47 - message Apollo Apollo Apollo
571:50 - documentation is saying
571:52 - they also provide buil-in error codes
571:55 - like Parts field graphql validation
571:58 - field Pat user
572:00 - input bad request we're going to use
572:02 - this error bad
572:06 - request all you need to do is to throw
572:09 - the error and you going to provide your
572:11 - message in the code so let's use the
572:16 - throw the
572:18 - error new graphql error
572:23 - I got this graphql error class from
572:27 - graphql package here you can see that
572:31 - now first I have to say unable to fetch
572:35 - the
572:37 - songs you have to provide the options
572:40 - you can provide the
572:42 - code you can say server error or what
572:46 - what type of message you want to use it
572:48 - depends on your use
572:50 - case
572:53 - I can say internal server
573:00 - error let's try to test it out I saved
573:03 - the
573:07 - application it will take some time to in
573:10 - reload the
573:11 - [Music]
573:14 - application application has reloaded
573:17 - let's send the request and I got the
573:20 - error unable to f F the songs and I got
573:23 - internal server error this time you can
573:25 - see graphql error unable to fetch the
573:29 - songs you can also see the message I got
573:33 - the error at song resolver doget songs
573:36 - you can also check the error
573:38 - stack get song song song resolver doget
573:42 - song we have the error at this function
573:45 - get songs this is how you can send the
573:49 - error in
573:50 - graphql
573:52 - if you want to use your own custom
573:54 - message you can also do that you can
573:56 - provide your custom message your custom
573:58 - code and your custom
574:01 - extension you can also set the HTTP
574:04 - status if you're working with HTTP API
574:07 - you can also set your HTTP status code
574:10 - and some type of
574:14 - headers in this module you're going to
574:17 - learn how to apply authentication in
574:21 - graphic
574:22 - SQL we have implemented authentication
574:25 - with rest
574:26 - API now I would like to implement
574:30 - authenticate graph cuel
574:34 - apis in the previous module you learned
574:37 - how to create graphel apis with
574:41 - nestjs I'm going to pick the same
574:45 - example project just like we did with
574:48 - authentication in rest API
574:52 - I have provided the starter kit code you
574:55 - have to open it and run npm
575:00 - install when you install all these
575:04 - dependencies you can run the project and
575:08 - you will get this
575:10 - error let me run the
575:13 - project because there is no graphql file
575:18 - there is no graphql extension file
575:23 - when you open the app
575:25 - module you will see the graphql
575:29 - setup we have a graphql module I'm
575:33 - creating a graphql module by using the
575:36 - Apollo driver just like we did with in
575:39 - the previous module I'm using the
575:42 - context I'm just returning a simple
575:44 - request mapping the request into request
575:47 - it's nothing more I'll teach you more
575:49 - about when we will protect
575:54 - resolvers so I've already taught you all
575:57 - of these stuff like we created the OD
576:00 - service we have a login
576:03 - method here we have a JWT guard I taught
576:08 - you how can you do that what type of
576:10 - implementation we have done we have
576:13 - passport strategy with JWT it's
576:16 - validating the
576:17 - user and we have dto login dto
576:20 - everything
576:22 - everything I have taught to
576:24 - you if you don't know about all of these
576:29 - functionalities you can go back to the
576:31 - module number six on
576:34 - authentication you can watch the first
576:36 - four lessons on authentication or first
576:39 - three lessons on authenticating nestjs
576:44 - apis you will get the
576:47 - error no definition found no type
576:50 - definition word found because we don't
576:53 - have any graphql file I just did the
576:56 - graphql setup first of all we're going
576:59 - to set up our we're going to define the
577:01 - schema we don't have we don't have any
577:05 - schema what I want to do I want to do
577:07 - schema in O folder let's create o.
577:13 - graphql what we are going to do we're
577:16 - going to create the user type and we're
577:19 - going to Define query
577:22 - and we will have mutation for sign up
577:25 - mutation and we will have login
577:32 - mutation first of all let's define a
577:35 - user
577:39 - type the first argument is ID it should
577:42 - be required not null first name the type
577:46 - should be
577:47 - string I can get this value from the
577:50 - user entity
577:52 - you can open the user entity on the
577:54 - right hand side right
577:57 - side first name is required last name is
578:02 - also
578:05 - required and email is also
578:08 - required and password is also required
578:13 - so we need these properties these five
578:17 - properties I'm not going to play around
578:19 - with playlist something like
578:23 - that let's make it more simple we
578:27 - defined a user
578:30 - type now I'm going to define a
578:36 - mutation sign
578:39 - up it is going to take the signup input
578:43 - and the type should be signup input we
578:46 - did not create it
578:48 - yet it should be required and it is
578:50 - going to turn a user back in the
578:53 - response or sign up
578:55 - response we not we did not create this
578:58 - we did not create this signup response
579:02 - type now let's define a new type with
579:06 - signup
579:08 - input when you when you sign up we are
579:13 - telling you need to provide hey client
579:15 - you need to provide the first name you
579:18 - need to provide the last name you need
579:21 - to provide the
579:24 - email email is also required password is
579:27 - also
579:29 - required now let's define the sign up
579:34 - response sign up
579:40 - response what you want to send in this
579:43 - signup response you can send a simple
579:46 - email it depends on you I'm going to
579:49 - send a simple email
579:53 - now we're going to Define
579:56 - query we have a mutation let's
580:00 - define login
580:03 - query I can say
580:06 - login it is going to take login
580:12 - input inside the login
580:16 - input and it is going to return a login
580:19 - response we did not not have these type
580:23 - yet it's are
580:25 - required let's define an
580:29 - input I'm going to Define input here
580:32 - login
580:37 - input we need
580:40 - email type should be string we need
580:43 - password type should be
580:46 - string and we also need to Define login
580:50 - resp
580:53 - response I want to send the access token
580:56 - you can double check it from your OD
580:58 - service or user service we have a login
581:02 - in the login we are just returning the
581:04 - access token here you can see that
581:07 - access token the type is string we're
581:10 - going to follow the same convention the
581:13 - type is string it should be
581:17 - required we created the login mutation
581:21 - that that's
581:22 - it let's try to test it out by running
581:26 - the mutation or running the typing
581:28 - command npm run
581:32 - generate
581:33 - [Music]
581:36 - typings it is going to generate the
581:39 - typescript definition
581:44 - file typescript definition file has
581:47 - created you can see graphql do s
581:52 - file we have all of these
581:56 - typings we have created or defined our
582:00 - schema in the next video I'll teach you
582:04 - how to resolve queries and mutation
582:08 - we're going to work on sign up mutation
582:14 - first in the previous video we have
582:17 - created this sign up
582:18 - mutation now we need to resolve this
582:21 - signup
582:22 - mutation we don't have resolver inside
582:25 - the O module let's create a new
582:40 - resolver we have to provide the name
582:42 - which is
582:46 - O Au resolver has created you can check
582:51 - inside the Au
582:54 - module we have Au resolver we have spec
582:58 - file and we have Au
583:04 - resolver we have to resolve our signup
583:07 - [Music]
583:09 - mutation
583:12 - mutation which is sign up I'm going to
583:15 - open the autra ql
583:18 - here I want you to do it should be sign
583:23 - up
583:24 - user I'm going to define a new function
583:27 - and it is going to return a sign up
583:30 - response you can get the
583:32 - typing from graphql dots
583:37 - file and one more thing we need to
583:42 - inject
583:44 - service user service and OD service we
583:47 - need both of
583:49 - them user service and we need OD
584:01 - service we have a create
584:03 - method let's get the argument I can use
584:08 - the
584:09 - arcs we need to get sign up
584:14 - input and I can say sign up
584:19 - input you can also also get the type
584:22 - sign up
584:23 - input and I'm going to provide sign up
584:30 - input everything is fine now let's try
584:33 - to test this signup
584:35 - mutation I'm going to run my
584:44 - application my application has started
584:47 - and I got the
584:49 - error
584:53 - sign up defined in resolver but not in
584:58 - the
584:59 - schema oops there is a type typo Here
585:03 - sign
585:05 - up we have to generate the typing
585:13 - again npm run generate
585:16 - [Music]
585:19 - typings
585:25 - everything is up to
585:32 - date it is taking too much time because
585:37 - I'm using no nestjs Version 9 because I
585:42 - built this project in module number six
585:45 - by using the nestjs version 9 that is
585:49 - why it's very slow
585:59 - I have to oh let's restart it
586:14 - again my application has
586:17 - started I'm going to send request to the
586:20 - Local Host callon 3000 and/
586:28 - graphql if you check the docs we have a
586:31 - sign up
586:36 - mutation let's create a new
586:40 - user first name make sure you have
586:43 - database in your
586:49 - postgress let's provide the last
586:55 - name let's provide the
587:03 - email let's provide the
587:11 - password I got the
587:18 - error because I did did not select any
587:22 - field here I would like to select the
587:28 - email because I can only access the
587:33 - email I think I already created a
587:37 - user with
587:39 - this email let's use new
587:44 - one there is an
587:47 - issue reading
587:49 - password
587:55 - let's try to check the
588:01 - error password
588:05 - is
588:10 - invalid
588:13 - why let's try to log sign up input what
588:18 - it is
588:19 - getting
588:27 - or do we have sign up function
588:31 - here inside the OD service do no we got
588:35 - to use
588:36 - the user service.
588:41 - create let me check in the Au controller
588:45 - what we are calling what we are
588:48 - using user service. create that is
588:58 - it I'm getting the
589:04 - undefined maybe there is an issue
589:08 - in autra Q let's check it
589:13 - out oh syn sying up
589:18 - input my God sign up
589:22 - input sync
589:28 - input sign up
589:37 - input let's run the project let's update
589:41 - the fix it sign up input we also need to
589:46 - update it here sign up
589:49 - input
589:51 - run the
590:00 - project Let's test it out by sending the
590:04 - request to create a new
590:12 - user sign up input we also need to
590:15 - update
590:19 - that
590:21 - we have created a new
590:24 - user a user has created
590:28 - successfully you can see that we got the
590:34 - object let's log in I want you to
590:38 - implement it I'm going to copy
590:43 - that we need to get the
590:47 - query from nestjs graphql
590:53 - package we also need to get login input
590:57 - and the login
591:05 - response we have a typo here
591:10 - aouc I need to run the typing
591:19 - again
591:21 - let's run the
591:28 - project let's try to send the login
591:42 - request I'm going to copy use email and
591:46 - the
591:49 - password I need to get the access
591:52 - token we have successfully logged
591:56 - in because I got the access
592:03 - token in the next video I'll teach you
592:07 - how to protect
592:09 - resolver we're going to create a new
592:14 - protected field which is
592:18 - profile only authenticate user can
592:21 - access this
592:24 - profile we have created all
592:29 - card this one JWT o card we have to use
592:34 - this o card into our resolver I'll teach
592:37 - you how to do that but I want you to
592:39 - think about how can we implement or how
592:43 - can we apply JWT off
592:47 - card we have completed the sign up
592:51 - and the login
592:53 - functionality let's say I want to
592:55 - protect
592:57 - resolvers when we were building the rest
593:00 - apis if you look at the app
593:04 - controller I can say this is the
593:07 - protected route only authenticated user
593:11 - can access the
593:13 - profile and here we also getting the
593:17 - user from the request
593:19 - object but you are thinking about how
593:22 - can we protect the resolver let's say I
593:25 - want to write a query
593:28 - profile and type should be profile we
593:31 - don't have any profile type let's create
593:35 - the profile
593:37 - type the type should be string the field
593:41 - should be
593:42 - string and here we have the user
593:48 - ID let's generate the
593:54 - typing when we resolve this
593:58 - query only authenticated user can access
594:04 - this
594:05 - profile we should not allow anyone to
594:08 - see other person or other people
594:14 - profile how can you do
594:16 - it when we were building the rest apis
594:20 - we use the JWT
594:22 - guard we have created this guard and we
594:26 - apply when we applied this JWT o card on
594:32 - our protected route just like we did in
594:35 - the app
594:36 - controller this is my protected route
594:39 - the profile route and I have applied the
594:42 - O card by using the use card JWT oard
594:47 - maybe you thinking how can we do into
594:49 - graph
594:50 - well I'm telling you I'm you you also
594:55 - need God you also need JWT o guard I
595:00 - want you to implement it you don't need
595:03 - to change anything in the JWT strategy
595:06 - because we were using the passport
595:08 - strategy if you are not sure if you
595:12 - don't know about how did I implement the
595:15 - passport
595:17 - strategy you can look up the
595:19 - Authentication section I think it's
595:22 - section number six or module number six
595:25 - or
595:26 - seven and then you can get the
595:30 - lesson for passport or jwd
595:36 - authentication it has generated the
595:40 - typings in the graphql dots we have the
595:45 - profile
595:46 - class now when we resolve this query I
595:50 - have to say hey this is protected
595:53 - route let's let me show you I'm going to
595:56 - run the
596:00 - project to access the protected
596:04 - route a user or client should or client
596:09 - must need to provide authentication
596:13 - token the user can get authentication
596:16 - token by executing or sending the login
596:19 - request
596:21 - and this login request gives the access
596:24 - token in the
596:27 - response let's wait for the
596:34 - application my application is running
596:38 - now let's send the request to the Local
596:41 - Host col 3000
596:49 - /ql here you can provide the
596:53 - authorization HTTP
596:58 - header I'm going to send the login
597:01 - request I got the access
597:05 - token here you can access the profile
597:08 - route you have to provide the token
597:12 - here we did not write the resolver for
597:16 - the profile
597:18 - query let's resolve
597:26 - it inside the Au
597:30 - resolver let's resolve Au query or
597:35 - profile
597:43 - query get
597:47 - profile it is going to give
597:51 - the
597:54 - promise
597:56 - with
598:03 - profile and here is the
598:06 - question
598:08 - how can you access the profile or how
598:13 - can you access the current logged in
598:16 - user like we need to send current logged
598:19 - in user
598:21 - actually we need to send the user ID the
598:24 - current logged in user
598:26 - ID and his
598:33 - email we are returning the
598:37 - promise that is why I caught this
598:43 - issue let's return new
598:49 - promise and
598:53 - resolve return
598:56 - resolve this
599:04 - object I just created the fake
599:08 - promise to pass this
599:15 - test oh I have written the profile in
599:20 - the
599:21 - mutation let's change it to
599:28 - query restart the
599:31 - [Music]
599:34 - application now we're going to send the
599:38 - request it's still
599:44 - running now we're going to access the
599:47 - profile I caught the profile
599:51 - but only authenticated user can access
599:55 - this
599:56 - profile so we need to apply the O guard
600:01 - how can you do it let's create a new
600:05 - guard I'm going to copy that guard and
600:08 - create a new guard and I'm going to say
600:12 - gql
600:18 - oards
600:23 - here instead of JWT I can say graph o
600:30 - card and now we need to do a little bit
600:43 - logic we need to use the can activate
600:48 - function because in graph ql we need to
600:50 - get the execution
600:56 - context and we need handle request it is
600:59 - going to
601:01 - return a
601:04 - user and you can import authentication
601:10 - error when you look when you look at app
601:13 - module you will see this
601:17 - request I'm just mapping
601:20 - the request from req request here I got
601:24 - the request from the context here you
601:26 - can see
601:29 - that and I call the super Constructor by
601:32 - calling this execution context
601:36 - host because in graphel you need to get
601:39 - the request object from the
601:42 - context when you have if you have worked
601:44 - with graphql before each resolver will
601:48 - have four argument
601:51 - here you will have for
601:53 - argument
601:55 - parent I think
601:57 - root context value and info you can get
602:02 - the documentation from
602:05 - Apollo server
602:17 - resolver here you can see
602:23 - each resolver has four arguments parent
602:29 - ARS context value and
602:33 - info ARS you can see
602:38 - ARs and I'm going to log
602:41 - everything
602:46 - parent console. log ARS
602:50 - console. log context
602:55 - value and we also need to log the info
602:59 - let's see what is inside this this stuff
603:04 - but make sure you apply the
603:07 - guard use guards I can say graphql or
603:17 - guard now this route this resolver is
603:22 - protected it is secure
603:30 - now don't worry I'll teach you
603:33 - everything what is going on
603:44 - here let's send the
603:48 - request
603:51 - here you can see the log
604:01 - console there are a lot of stuff
604:04 - here parent is undefined there is no
604:08 - parent for this query ARS is an object
604:12 - but is but there is nothing inside the
604:14 - ARs there's a context value this is
604:18 - there is the request
604:21 - object and inside the request object you
604:24 - can find your
604:37 - user here is the user I found the
604:40 - user this is
604:42 - the this is the
604:44 - user this is the this object is current
604:48 - logged in user
604:51 - if you look at the jwd passport
604:55 - strategy here we are
604:58 - saving user ID and the
605:02 - email that's why I got the user ID and
605:05 - email what I can
605:06 - say I can only
605:10 - return context
605:12 - value do request.
605:18 - user
605:20 - I don't need to use the promise
605:27 - here it's just returning a simple
605:40 - profile I'm going to send the request
605:42 - this time I got the original user ID and
605:47 - the email let's sign up up a new
605:52 - user I'm going to create a new
605:58 - user
606:05 - Linda let's save the
606:10 - email now I got the user we have
606:16 - successfully sign up let's log
606:22 - in I got the access
606:25 - token now I can use this access token
606:28 - here I want to access the profile of
606:31 - this route or user wants to see this his
606:35 - profile I got this
606:41 - user now let's debug the application I'm
606:45 - going to put couple of break points here
606:47 - what is going on here let's look
607:03 - at I have already set up the VS code
607:06 - folder inside you have launch. Json file
607:11 - if you don't know how to debug the
607:12 - application let me teach you I've
607:14 - already taught you there is a script in
607:18 - the package. s file for the debug the
607:22 - application you can
607:25 - say npm
607:29 - start please start the project in debug
607:42 - mode my application is running in the
607:45 - debug
607:48 - mode
607:51 - now I can start the debugging by
607:54 - pressing on this attach
608:01 - button I've put couple of break points
608:14 - here now it has
608:16 - started I can debug my applic
608:22 - a I can also put breako
608:26 - here or
608:31 - here now we're going to send the
608:34 - request it has stopped at this o
608:39 - card and first of all it is going to run
608:42 - the can activate function we are using
608:46 - getting the graphql
608:48 - context by calling the
608:51 - create and here I got the context
608:55 - object and inside the context you can
608:58 - see we have the Handler function we have
609:02 - the
609:03 - ARs ARS
609:05 - property the first one is object and we
609:09 - have a request we have this request and
609:12 - we have field name which is
609:15 - graphql field which is
609:18 - profile you you can see the field
609:21 - noes this is how graph run under the
609:27 - H this is my string or the query graph
609:33 - request and here is the name something
609:36 - like that profile which is
609:39 - profile let's step over the code you
609:45 - will see the
609:47 - context inside the context we have OD
609:50 - context type
609:52 - graphql now I'm extracting the request
609:57 - object by calling the get
610:01 - context so I got the
610:05 - request inside the
610:10 - request you can see
610:14 - that this is the request we have this
610:17 - endpoint SLG graph
610:19 - ql this is the body we have the
610:22 - query and we have the
610:29 - variables let's jump to the next break
610:34 - point there is no
610:37 - error and there is a user you can see
610:41 - that and it is going to return the
610:45 - user now you can access the user
610:50 - inside the
610:52 - context parent is null which is
610:56 - undefined we don't have anything in the
610:59 - ARs now you have the context value you
611:02 - can also do debugging here context value
611:07 - dot request.
611:10 - user you can see I got the
611:16 - user and we have the info
611:19 - info is related to information related
611:22 - to query if you need to access the path
611:25 - parent type field name something like
611:28 - that
611:29 - schema then you can use the info
611:32 - validation error we have directives
611:35 - include skip
611:36 - deicated query type graphical object
611:39 - type we have the fields login
611:44 - profile all this information related to
611:46 - graphql schema and the query inside the
611:49 - info
611:51 - object now we are going to just return
611:54 - the current logged in
611:57 - user that's how the authentication Works
612:02 - under the hood in
612:06 - graphql if you need to implement
612:09 - realtime application you have to build a
612:12 - realtime functionality like chat
612:15 - application or notification type
612:18 - application
612:20 - then you use graphql subscription if you
612:24 - have worked with API rest
612:26 - apis we used websocket and socket iio
612:31 - for realtime
612:32 - application but we are building graph
612:35 - apis if you need realtime functionality
612:38 - then you need graphql
612:41 - subscription I'm going to build or
612:45 - Implement graphql subscriptions with
612:48 - nestjs Pro project first of all you have
612:51 - to install dependency graphql
612:54 - subscriptions and then we will install
612:57 - the subscription
612:59 - Handler just like query and mutation you
613:03 - need to define a new type
613:06 - subscription I have created this song
613:08 - created field it means when a new song
613:13 - is published to Spotify
613:16 - application this Spotify application
613:18 - will send the notification to all users
613:22 - we want to implement this
613:26 - feature when you define the type
613:29 - subscription we defined it
613:32 - here you have to write the resolver to
613:35 - resolve this field we need a pops up
613:39 - module from graphql subscriptions the
613:42 - package we have installed
613:45 - earlier here it is going to listen
613:49 - for song created event this
613:53 - resolver is listen for song created
613:59 - event here we are resolving this field
614:02 - song
614:04 - created when you run the application you
614:07 - should go to the Local Host colon 3000
614:09 - /g
614:11 - graphql I'm going to run the
614:13 - subscription song created we have ID
614:16 - title I have started the subscription
614:19 - you will see the subscription is
614:20 - listening it's in the listening mode our
614:24 - next step is to publish this
614:28 - event when we will publish the event you
614:31 - have to send the payload which is a new
614:34 - song and I have created a new song Here
614:39 - we are publishing an
614:42 - event
614:45 - here it is going
614:47 - to now the subscription is already
614:51 - running here you can see and now it can
614:54 - receive it has received a new
615:01 - song if you want implement this
615:04 - subscription you can do
615:07 - it otherwise you can follow me I'm going
615:10 - to implement it you have to install
615:13 - package graphql
615:17 - subscription and we have to install the
615:21 - Handler in the app
615:30 - module install subscription Handler
615:34 - let's define a new type subscription in
615:37 - the song
615:39 - graphql I'm going to Define It Here song
615:43 - created it is going to return a new
615:45 - song now we need to resolve it
615:49 - resolve the song created field inside
615:53 - the song
615:55 - resolver we need to import psup at the
615:59 - top of our
616:01 - resolver you can import it from graphql
616:05 - subscriptions
616:10 - package now we're going to resolve this
616:14 - subscription song
616:16 - created I can do it here at the
616:19 - bottom we need to get
616:22 - subscription from nestjs graphql
616:35 - package let's try to import manually
616:39 - from cql
616:42 - subscriptions we need pups
616:47 - up
616:49 - let me run the application and then I
616:52 - will be able to start the subscription
616:54 - in the listening mode the pups sub Asing
616:58 - iterator we are telling to pups sub
617:02 - module or the ppup module is saying I'm
617:06 - listening for the song created event
617:08 - with this label this is an event I'm
617:12 - listening for an event with this label
617:14 - song
617:17 - created my application is running
617:20 - now let's run the
617:24 - subscription when you check the docs you
617:27 - will see subscription with song
617:31 - created I'm going to start the
617:33 - subscription song created when a new
617:36 - song will be published it is going to
617:38 - give me this record the song object now
617:42 - it is in the listening
617:47 - mode
617:51 - when we will
617:52 - create a new
617:54 - song it means when artist in real world
617:58 - Spotify application has published a new
618:02 - song Spotify application will send the
618:05 - notification of this song to all
618:14 - users new song I can say new
618:17 - song
618:19 - I need to get ID and the
618:25 - title a new song has created but I
618:30 - cannot see anything here because we did
618:33 - not publish the event when we will
618:35 - create when we will be creating a new
618:40 - song Here we have to
618:45 - publish this event this one song creat
618:50 - event so you can do it as well I'm going
618:53 - to copy my
618:56 - code and let's do it
619:01 - here this is how you
619:04 - can sent message to the event by using
619:08 - the song created label and we have
619:11 - provided the payload make sure you use
619:13 - the song
619:15 - created Property name otherwise it will
619:18 - not not
619:23 - work let's create a new
619:30 - song I have created a new song and it is
619:34 - saying I cannot could not connect to
619:37 - websocket
619:39 - endpoint please check if the endpoint
619:43 - URL is
619:46 - correct now it's in the listening mode
619:49 - mod created a new song now I have got a
619:53 - new
619:57 - song because we are publishing a new
620:01 - song and it has received it
620:08 - here let's say I can say new the name of
620:12 - the
620:13 - song you can choose any
620:16 - name I have created a new song or artist
620:21 - has published a new song at Spotify web
620:25 - application now the Spotify application
620:27 - has has sent the notification to all
620:30 - users who are subscribing to song
620:32 - created
620:34 - event that's it the concept of
620:40 - subscription in this module you're going
620:44 - to learn how to test graph
620:47 - apis we have already tested our rest
620:51 - apis we're going to use the same logic
620:54 - to test graphql
620:57 - apis we're going to do Mocking the same
621:00 - way just we did in the previous
621:06 - module when you see song resolver dopc
621:10 - file you will see this default
621:14 - code when you run the test by using this
621:17 - command npm run test you will get this
621:21 - error hey you are using a song resolver
621:25 - but your song resolver is dependent on
621:29 - song
621:30 - service you have to import it but we are
621:33 - doing unit testing so when you are doing
621:37 - unit testing you have to test individual
621:40 - parts of your code you have to test
621:43 - individual
621:45 - functions if this function is depend
621:48 - dependent on some other functions or
621:50 - some other dependency or some other
621:53 - classes or some other services you will
621:56 - create a Moog implementation of the
622:00 - dependency I've already taught you the
622:02 - Moog implementation when we will when we
622:05 - will be testing song
622:09 - controller this is how you will create
622:12 - the mo implementation of song
622:16 - service you we will have have these
622:19 - methods inside the song
622:22 - service in get song create song we are
622:25 - just creating the mo
622:27 - implementation I just copied this code
622:31 - from the song Ser song controller song
622:34 - controller spec file and I have updated
622:37 - the create song dto to create song input
622:40 - and update song dto to update song
622:43 - input and then you will test your
622:47 - functions
622:49 - if you want to test your get fet song
622:52 - Get song function inside the song
622:54 - resolver you can do
622:56 - that I'm applying the await expression
622:59 - on get song and I got the song here I'm
623:02 - doing
623:03 - expectation checking asserting or
623:06 - expecting value it will pass this is how
623:09 - you will test create
623:11 - song create song will be passed update
623:14 - song and the delete
623:17 - song Let's execute it or you want to
623:21 - execute by yourself I want you to do
623:31 - it let's select the song
623:37 - resolver it's going to run the song
623:39 - resolver dopc
623:47 - file
623:52 - you can see the
623:55 - error hey your resolver is dependent on
623:59 - the song service but you did not import
624:02 - the song service let's fix it by mocking
624:06 - the
624:14 - service I'm going to copy the same
624:17 - code
624:19 - and paste paste it
624:35 - here we don't have song service let's
624:39 - import
624:47 - it
624:49 - it's not giving me the suggestion I have
624:51 - to import
625:07 - manually I got the song service we also
625:10 - need to get the create song input and
625:13 - update song
625:17 - input
625:24 - I think it will not get this path Source
625:27 - do/ graphql
625:29 - let's add the complete
625:41 - path you can see our test has passed
625:47 - now
625:49 - now we're going to write the test unit
625:52 - test for a song's
625:57 - query it should fetch a song first of
626:01 - all I need to apply a weight expression
626:03 - on get songs it is going to give
626:07 - me this song because we are using our Mo
626:12 - implementation inside the get songs it
626:15 - is going to return this object or this
626:19 - array with a promise here we are just
626:22 - resolving
626:35 - it unable to fetch songs I got the
626:41 - error let me check my song resolver what
626:44 - is inside the song
626:47 - resolver I think I'm throwing the error
626:50 - that's why I got this error let's
626:53 - comment this code and I would like to
626:55 - return this song
626:57 - service with get songs array it is going
627:01 - to give me the array of the songs we are
627:04 - just
627:05 - using this get song method
627:09 - but we are using this
627:15 - implementation this one it will call the
627:18 - get songs but it is it will use our own
627:23 - implementation this
627:39 - one this is how you can fix the bugs
627:42 - with the help of unit
627:47 - testing
627:51 - our test has
627:53 - passed now we need to test a single song
628:01 - query we have created this
628:06 - song actually we need to yeah we need to
628:10 - test this one we need to create test
628:13 - create new song
628:15 - resolver we're just creating a new song
628:18 - and we are expecting
628:25 - it because create song will give me the
628:28 - ID and whatever we
628:31 - passed
628:33 - here the object it is going to return
628:36 - the same object
628:47 - here
628:52 - the test has passed now we need to test
628:55 - update and
629:01 - delete it is giving me the error update
629:05 - song a unique
629:17 - ID we are not expecting the ID in the
629:22 - update
629:23 - song there is an issue I
629:37 - think it is going to give me the
629:46 - ID
629:52 - let's look at the update song
629:55 - [Music]
629:57 - resolver song
630:00 - resolver let's look at the update
630:14 - song update
630:16 - song
630:23 - I think I have to change the order first
630:26 - I need to get the ID I need to place the
630:29 - ID and then I need to get the update
630:31 - song input you have to rearrange the
630:40 - order now it should
630:46 - work
631:00 - let me look at the song
631:06 - service ID it's giving you are not using
631:10 - the update song
631:12 - tto title
631:14 - but let's restart the application
631:18 - the error is gone
631:33 - now everything is fine our update test
631:37 - has passed and our delet delete the song
631:41 - test has also
631:44 - passed it is returning the affected
631:48 - that's why I use the affected
631:52 - here in the next video I'll teach you
631:56 - how to do end to end
631:58 - testing graphql
632:02 - apis this lesson I'm going to teach you
632:05 - how to do end to endend testing with
632:08 - graphql apis in the previous lecture we
632:12 - tested unit tested we tested the
632:15 - individual function of resolver now
632:18 - we're going to do integration or end to
632:20 - endend testing we're going to test
632:22 - exactly the API by sending the HTTP
632:25 - request or queries from the HTTP
632:29 - module this is how you will test the
632:32 - songs
632:35 - query and it is going to give me the
632:37 - result I'm using the
632:39 - request request package to send the HTTP
632:43 - request if you are working with graphql
632:46 - there is only single endpoint which is/
632:50 - graphql it will be same for each query
632:53 - and
632:54 - mutation now I'm trying to fetch all the
632:56 - songs and I got all the songs this is
632:59 - how you will test the end to end testing
633:03 - I already taught you how to set up the
633:06 - end to end testing
633:08 - file when we were building when we were
633:11 - testing the rest API in the previous
633:14 - previous
633:15 - module so
633:18 - before each we're going to create
633:20 - testing module this is a
633:22 - same before
633:24 - all we're going to
633:28 - create new database I have the test
633:31 - database it will drop after completed
633:34 - all the
633:37 - test and after each we're going to
633:40 - delete everything after each test we're
633:43 - going to delete everything from the
633:44 - songs table that's why I'm using the
633:46 - songs Repository do clear method and
633:50 - after all we're going to stop the
633:52 - application we're going to use this
633:55 - method to test it's a helper function to
633:59 - perform our testing nothing more it's
634:02 - just creating a new
634:05 - song and this is how you can test a root
634:08 - end point it means our testing is
634:11 - working fine let's implement
634:15 - it there is no script for end to end
634:19 - testing for the we have an end to end
634:22 - test but I'm looking for a watch mode
634:25 - testing that's why I'm going to add a
634:27 - new script it will run end to endend
634:31 - testing in the watch
634:33 - mode let me run the end to end
634:39 - test in the watch
634:42 - mode it should be e to
634:46 - e e to
634:49 - e right now we have only a single file
634:53 - which is AB
634:58 - do E2 e-pack
635:02 - dojon if you run this file let's say
635:06 - app it is going to run this
635:12 - file I'm going to copy this source
635:15 - code and let's create a new file inside
635:18 - the test
635:20 - folder we will use this test folder for
635:24 - in to end
635:25 - testing let's define a new file
635:29 - song SL do E2
635:37 - e-. I have copied the source
635:46 - code
635:49 - this is the default
636:00 - code we need to add a type orm setting
636:04 - before all the
636:07 - test we need to create a new
636:14 - database let's run it here
636:20 - we need to import couple of
636:24 - modules we need a song module and
636:28 - song entity let's get
636:45 - it type Ork
636:49 - module we also need to import type or
636:56 - module actually I'm going to copy
636:58 - everything and paste it
637:04 - here now we have before
637:08 - all we also
637:12 - need let's
637:16 - define it should be song
637:20 - resolver end to end
637:27 - test we need after all and after
637:33 - each after each test you need to clear
637:38 - the songs table and after all the test
637:43 - you have to close the
637:46 - application
637:50 - I'm also going to use this helper
637:52 - function I already taught you these
637:55 - Basics when we were building when we
637:57 - were testing the rest
638:01 - apis that's it our setup is complete
638:07 - now let's run the
638:11 - test this time I would like to run songs
638:17 - file
638:26 - let's try to run the song file song. E2
638:40 - e-pack our test has passed now and you
638:44 - can see this test is running fine now
638:47 - now so we have successfully done the
638:50 - setup now it's time to test the
639:00 - query we need to create the song first
639:05 - because there is no record in our
639:08 - database table which is songs there is
639:10 - an empty here there is no
639:14 - record so I'm just trying to write the
639:18 - query to fetch all the
639:23 - songs I created the query data object
639:27 - I'm providing the
639:29 - query and I'm sending the query in the
639:33 - HTTP
639:35 - request when you test the API graphql
639:38 - API you will get the data or the
639:42 - response in data object and we have the
639:45 - songs I'm just expecting the songs
639:49 - array uh uh let me run the application
639:53 - in development so you will understand it
639:57 - more
640:07 - deeply application is running
640:15 - now let's try to write the query to
640:18 - fetch all the
640:20 - songs if you write the query or you can
640:23 - do without without query I'm going to
640:26 - write query
640:27 - query and I would like to fetch all the
640:32 - songs ID and the
640:35 - title so you got the result in the data
640:40 - object and we have the songs
640:43 - array one more thing if you write the
640:46 - name of the query you can also do that
640:49 - if you have experience in graphql then
640:52 - you will know what I am doing you I'm
640:56 - just I just gave the name of the query
640:59 - get songs you can also do that it will
641:01 - work fine there is no
641:07 - issue now we're going to test a single
641:10 - song
641:16 - query
641:20 - this time first step I created this
641:24 - song and I created the query
641:28 - object now we need the variable this is
641:32 - how you can Define the variable in
641:35 - graphql so I'm providing the variable ID
641:38 - here you can exactly
641:42 - query in your graphql playground let's
641:46 - say
641:48 - it this is a new
641:51 - tab I can give you the name of the query
641:54 - get
641:57 - song let me copy that get
642:02 - song now I def I created the get song
642:06 - query and I'm expecting the ID as a
642:09 - variable here I'm providing the variable
642:12 - ID this is how you will set the query
642:16 - variable this is a another way to fetch
642:20 - the get song query I already taught you
642:24 - this method it will work fine you got to
642:28 - provide the
642:29 - ID and here you can expect the name it
642:33 - will work fine but this is another
642:37 - alternative way of doing this
642:40 - thing if you have an ID you can provide
642:43 - the ID
642:45 - here ID
642:51 - we don't have any record that's why I
642:54 - got the
642:55 - error now we going to test
642:59 - it you can see our test has passed now
643:03 - because first we are creating the song
643:07 - then I'm providing the
643:09 - ID variable from the new song object you
643:13 - don't need to change anything here you
643:16 - can also do expectation
643:20 - for assertion check for the status code
643:24 - here instead of calling this
643:28 - one that's why I I'm expecting the 200
643:30 - status code and it is going to give give
643:34 - me the response data and the song and
643:36 - I'm checking on the based on new song
643:39 - both are
643:44 - same now our next step is to test the
643:47 - create song
643:54 - mutation it is the same way you define
643:58 - the mutation I give the name create song
644:01 - mutation instead of ID I'm expecting the
644:05 - create song input we have created the
644:08 - variable and I'm getting the create song
644:11 - input we have title and here you can
644:14 - provide the values for your
644:18 - variables if you want you can do the
644:21 - exact same
644:23 - thing from your graphql playground let's
644:27 - say I can say I'm going to create a new
644:32 - song I just past it pasted the
644:37 - mutation if you run there is no query
644:41 - variable for create song
644:44 - input let's define it you have to
644:48 - provide the title I can
644:51 - say
644:53 - lover
644:54 - song you can see the lover
645:00 - song now I can provide the ID here let's
645:04 - test it
645:08 - here I provided the ID so I got the song
645:12 - object there is a data object and we
645:15 - have a create song
645:18 - object that's why I used create song
645:22 - Here create sing do title should be
645:26 - animals our test has passed now we need
645:29 - to run update mutation similarly just
645:32 - like for just like with create
645:36 - mutation it is expecting to arguments ID
645:40 - and the update song input and we are
645:43 - providing the ID in the variables and
645:45 - update song input here
645:48 - here it is going to return the affected
645:51 - with
645:52 - integer now we're going to copy this
645:56 - delete
645:58 - mutation delete is expecting only the ID
646:02 - and it is going to return the
646:04 - affected I defined the delete song
646:06 - mutation and here I'm expecting the
646:09 - value which is
646:15 - one
646:22 - our test have has P tests have
646:27 - passed
646:29 - query and we also need to test delete
646:35 - [Music]
646:43 - mutation delete mutation test has passed
646:50 - F this is how you will do end to end
646:53 - testing in
646:56 - graphql in this lesson I'm going to
646:59 - teach you the concept of
647:01 - caching Apollo server provides caching
647:04 - on the server site you can implement
647:07 - it caching is a process of or method of
647:11 - storing copies of file or data in a
647:15 - temporary storage location
647:17 - or cash to be accessed quickly like you
647:21 - want to store the data temporarily in
647:23 - some type of in memory built-in memory
647:27 - you can store the data Maybe for 30
647:30 - seconds or 60 seconds or a 1
647:33 - minute it's called caching what is
647:36 - server side caching you want to store
647:38 - let's say you want to fetching the query
647:41 - results you have a
647:43 - query and user is fetching the
647:47 - query constantly after every 10 seconds
647:51 - after every 20 seconds or after every 10
647:54 - seconds in that case you need caching
647:58 - you don't want to send the request
647:59 - backend server to DB server again and
648:03 - again so it will increase the massive
648:07 - traffic
648:08 - load you are thinking why do why need
648:11 - why do we need
648:14 - caching if user is fetching the query
648:17 - after 3 seconds again and again you did
648:20 - not implement the caching your
648:23 - application will send the request to the
648:25 - backend server DB server and it will and
648:28 - it will fetch the data from that server
648:31 - again and
648:34 - again it will decrease the performance
648:38 - so the help of caching you can improve
648:41 - the performance of your
648:43 - application you can avoid unnecessary
648:46 - request to server because the data will
648:50 - be fetched from the cache
648:52 - immediately you can reduce the bandwidth
648:55 - which will be benefit to user you can
648:58 - reduce the massive DB
649:02 - loads with the help of caching you can
649:04 - handle massive Network traffic
649:07 - request yeah you can decrease the
649:10 - service
649:13 - calls so that was the basic fundamental
649:16 - concept of caching now we're going to
649:18 - implement the caching in in nests
649:21 - project nests already using Apollo
649:23 - service AP poo server Apollo
649:26 - package so we're going to install the
649:29 - package uh install this caching module
649:32 - Apollo server plug-in response
649:39 - cache this plug-in helps optimize the
649:42 - performance of graphql queries by
649:44 - caching the responses
649:47 - this this plugin will help us to Cache
649:50 - the response and serving the data from
649:53 - the cache instead of executing the same
649:56 - query
649:57 - repeatedly our next step will be
650:00 - register the caching
650:02 - plugins when you install this plugin you
650:06 - can register it as a plugins
650:09 - array I have set the default maximum age
650:12 - which is 5 Seconds I'm
650:15 - saying hey
650:17 - Apollo you can keep the data in
650:21 - cash for 5
650:24 - seconds after 5 Seconds you have to
650:28 - refresh the
650:30 - cache you have to refresh the
650:38 - data and then you need to create a
650:41 - directive cash controls SC private or
650:44 - public you want to fetch the data
650:47 - publicly or you want to fetch save the
650:49 - data privately private represents a cash
650:53 - control scope where the response should
650:55 - be cached privately if you want to fetch
650:58 - the authenticated user something like
651:00 - that then then you need to set the
651:02 - private represent a cache control scope
651:05 - where the response can be cached
651:08 - publicly this directive will have max
651:12 - age scope and inherit max age and you
651:17 - can apply cache control directive on
651:21 - field
651:22 - definition you can apply on a fing field
651:25 - like title field in a song
651:28 - type you can apply on object interface
651:32 - and Union the max age is an optional
651:35 - argument of type in that represents the
651:39 - maximum age of the cach control in
651:42 - seconds how long the
651:44 - response can be considered a fresh and
651:49 - cachable you can read this documentation
651:53 - of maxh I've written down for
651:59 - you private and public scope this will
652:02 - be used for parent let's suppose your
652:05 - query is dependent on parent
652:09 - query then you need to use this
652:14 - one you can also set the cach control
652:17 - set cach
652:19 - hint in the resolver by using this
652:23 - line our next step will be apply the
652:26 - cache control directive I applying it
652:29 - for titled field inside the song
652:34 - type cache control maximum age for 30
652:38 - seconds I'm saying to Apollo hey
652:41 - Apollo you can keep the title field
652:45 - record
652:47 - for 30 seconds in a
652:49 - cache if user is fetching this title
652:53 - field constantly after 20 seconds or
652:58 - after 10
652:59 - seconds then it will fetch from the
653:03 - cash if user needs to fetch record after
653:07 - a minute or after a 2 minute it will
653:11 - fetch the data from the DB server but it
653:15 - depends on you on your case on your use
653:19 - case but 30 60 and 40 are the
653:22 - recommended values on the based on
653:25 - Apollo
653:26 - documentation Apollo server uses
653:28 - inmemory cache by default we are we are
653:31 - going to use inmemory cache but you can
653:34 - also configure different backend like
653:36 - redis or M
653:38 - cach you can also apply cash control
653:42 - directive on a complete type let's say
653:45 - if you have a scenario where you need to
653:48 - fetch all of the fields from a specific
653:52 - type then you can
653:55 - add here cache control directive maximum
653:59 - age to 40
654:00 - seconds I just give you the basics
654:03 - Basics when you implement in real world
654:06 - scenario in real world large application
654:09 - you will know your use case better now
654:12 - it's time to implement it or you can
654:14 - implement it by your own
654:17 - let's install the plug-in
654:32 - first plug-in have installed let's
654:36 - import it in the app
654:42 - module now we're going to register the
654:45 - plug-in into plug array when you are
654:48 - creating graphql module you can register
654:50 - it
654:55 - here so our third step is to creating a
654:58 - cache control
655:04 - directive I can do it
655:08 - here it will have max age scope inherit
655:13 - inherit max age private if you want to
655:16 - dig into more deeper you can look at
655:19 - from the Apollo server
655:21 - documentation when you Google Apollo
655:24 - server
655:27 - caching this is the document you got to
655:30 - read if you want to dig into deeper what
655:33 - is Max age what is cach control scope
655:37 - you can read this
655:39 - document this is the implementation of
655:43 - caching in AP poo server
655:46 - if you want to do ready setup you can
655:48 - also do
655:55 - that we have created the cache control
655:59 - directive
656:01 - now I want to apply the cache control
656:04 - directive on our field right now I have
656:08 - only one single Field title I'm saying
656:12 - I'm assuming that my
656:14 - title field is going to be
656:17 - feted
656:19 - after 10 seconds I have a query in that
656:23 - use case like client is asking title
656:27 - field again and
656:34 - again let's try to test it
656:45 - first
656:51 - my application server has
657:00 - started now I can say I want to access
657:03 - the
657:04 - query of the songs I want to fetch the
657:09 - title you can see it's working fine
657:13 - now let's fetch the title again
657:17 - now it is accessing the title field from
657:21 - the inmemory
657:23 - cache one last thing you can also apply
657:27 - cache control directive on a type here I
657:32 - want to say I have only single type
657:34 - that's why I want to use it for only
657:36 - demo purpose in real world application
657:39 - you will have a different use case
657:42 - restart the
657:43 - [Music]
657:45 - application
657:52 - [Music]
657:57 - my application is running now I'm going
658:00 - to access this song FEI
658:02 - songs it's still working
658:08 - fine if I try to access the
658:13 - song we need to provide the ID
658:18 - let's fetch the
658:26 - ID I'm going to copy the ID and let me
658:30 - paste it
658:33 - here now I would like to access the ID
658:37 - and the title let's access the title
658:41 - only or the
658:44 - ID now the data is is going to be
658:48 - cached I can access it
658:52 - easily it's working
658:56 - fine in this lesson I'm going to teach
658:59 - you the concept of data loader why do we
659:02 - need data
659:05 - loer we have this schema I've already
659:08 - found example project regarding data
659:14 - loader we have a user and we have a post
659:18 - there is a
659:20 - relationship between user and the
659:24 - post when you send the graphql request
659:28 - to fetch all the post and you also want
659:32 - to the owner of this post who has
659:35 - created this
659:36 - post under the
659:39 - hood graphql your application will send
659:44 - a a different different a new data
659:48 - request to the database a new request to
659:52 - the database to fetch a user for each
659:57 - post this will decrease the performance
660:00 - of your application because you're going
660:03 - to do lot of database
660:07 - request here your output will look like
660:10 - that if I will show you
660:14 - here let me show you with the help of
660:18 - example I'm going to send the
660:21 - request it is going to take a 3 seconds
660:25 - because I have set this delay for the 3
660:28 - second we have how many post we have we
660:32 - have three post you can look at the
660:36 - schema or our database I don't I'm not
660:40 - using any database
660:44 - here
660:49 - so here is the
660:51 - data we have a three
660:54 - post inside the post we have a user
661:02 - ID when you look at the user service we
661:05 - have all of these
661:08 - users every time let's say I log the
661:12 - message fetching data from DB
661:16 - let's example you can say that getting
661:18 - user ID 1 fetching the user ID one this
661:23 - is the you can imagine this is the
661:25 - database
661:26 - request every time it is going to fetch
661:30 - the post for each user against post it
661:35 - has to fetch the record from the
661:38 - database you can imagine if you want to
661:41 - load 50 post and you have to send the
661:46 - API or backend DB request for each user
661:52 - separately so what data loader will do
661:55 - data loader will batch all of the users
662:00 - it's going to wait and say I can send
662:03 - you
662:07 - request here what data loader will
662:13 - do it will say
662:16 - I
662:17 - will get all of the IDS of the
662:22 - users like one 2
662:25 - 3 and then I will
662:31 - fetch all of the
662:34 - users for all post and then if you need
662:40 - any post if you need any
662:43 - user against each
662:46 - post you will fetch from the cash or
662:51 - from the data loader cash data loader
662:54 - maintains cash
662:57 - also did you get the
663:00 - point let's say I'm going to add I have
663:03 - four users inside the post
663:13 - service I'm going to add post
663:21 - for title post
663:25 - for
663:27 - something and user ID which is for this
663:37 - one application is running now I'm going
663:40 - to send the request to fetch all the
663:44 - post
663:48 - now I got the for post and it has sent
663:53 - the DB request to fetch a single user
663:57 - what we can do we can say I want to
663:59 - fetch if we are using data loader please
664:02 - fetch all the users it's batching all
664:06 - the users from the DB and maintains a
664:09 - cache and next time our application will
664:12 - fetch the user from this cache
664:17 - I have already implemented the data
664:19 - loader in this project actually I found
664:21 - the source code on the internet to
664:23 - explain the data loader it's a simple
664:25 - source code so I thought I should teach
664:27 - it with the help of this source
664:31 - code inside the post
664:35 - resolver here they are resolving the
664:37 - created by field created by and it is
664:41 - going to return the
664:43 - user here instead of loading the user
664:47 - from the database let's user service
664:49 - will send the DB request so I'm going to
664:53 - comment and now you will see the magic
664:57 - instead of loading the user from the
665:00 - DB I would like to fetch the user from
665:04 - data
665:10 - loader now we're going to send the
665:14 - request
665:21 - you can see that getting the users with
665:24 - ID 1 2 and
665:27 - 4 it has bashed all the users and
665:32 - created the user map to send the ID's
665:37 - record to data loader and here is the
665:41 - result so let me
665:44 - explain what this source code is doing
665:47 - if you check the app
665:50 - module here we are providing the loader
665:54 - I created the create user loader and
665:57 - they are injecting the user
665:59 - service inside the user service inside
666:03 - the create user loader I'm passing the
666:05 - user
666:09 - service to work with data loader you
666:12 - only need a single package which is data
666:18 - loader this one you have to install only
666:21 - the data
666:26 - loader here you will have a user
666:30 - loader what this loader will do it is
666:33 - it's nothing more it's just a function
666:37 - takes a user
666:40 - service so I created the instance of a
666:43 - data loader the ID will ID would be
666:47 - number and another type which is the
666:50 - object should be the
666:52 - user this when you create the data
666:55 - loader you have to provide it is going
666:58 - to give me the IDS all of the
667:02 - IDS and here I can fetch all of the
667:06 - users against IDs here I did the users
667:11 - map you you saw the users map here 1 2 3
667:16 - because data loader Works in this way
667:18 - you have to provide the results in this
667:21 - way like I got 1 2 4 then I did the map
667:26 - to fetch all the records ID 1 2 and
667:34 - 4 we created the user loader I have
667:37 - attached inside the context
667:40 - object remember graph resolver can have
667:43 - four arguments in for context and
667:50 - parent we have user loader here to fetch
667:54 - all the users against a
667:57 - post here this one inside the post
668:01 - resolver I'm resolving the created by
668:04 - field I got the user loader from the
668:06 - context here you need to load the
668:09 - user from the user
668:13 - loader I got the parent I parent record
668:18 - from the post which is the
668:20 - post so I got the user
668:24 - ID which we saved
668:26 - here we have one more thing we have used
668:30 - a schema based approach to build graphql
668:33 - apis but I also wanted to show you
668:35 - another way to build graphql API which
668:38 - is code first approach this code first
668:41 - approach will generate the schema.
668:43 - graphql file automatically it depends on
668:46 - you but I like the most schema based
668:48 - approach but you can use both of them it
668:50 - depends on your use case this is how you
668:53 - will Define the graph qu object
668:57 - type but we have worked with this schema
669:00 - based
669:01 - approach let's say you want to create
669:04 - this graphel type which is posted with
669:06 - the help of code based
669:08 - approach you will say this is the graph
669:11 - object type you can get it from nestjs
669:14 - graphql package and this is the field
669:16 - you can say this one this is the field
669:19 - and you can
669:23 - say title field and we have the body
669:27 - field and we have the user ID I'm not
669:30 - I'm not saving into the graphql datab
669:32 - graphql graphql type that's why I keep
669:36 - the user ID for entity based to build a
669:39 - relationship with them so created by
669:42 - this is the relationship between a user
669:46 - here you can see that created by the
669:48 - return type should not be null that's
669:51 - why I they have used the user this is
669:55 - this represents the return type what
669:58 - your field will return so it's the type
670:02 - of this created by it should return a
670:05 - user user
670:07 - type similarly you can look at the user
670:14 - entity
670:16 - object type this is how you will Define
670:18 - here this is graphql type and my user id
670:22 - the type should be number that should be
670:25 - int that's why it's a nonn knowable
670:28 - field and it should return or the type
670:33 - of this ID should be int and we have a
670:37 - field which is graphical type so this
670:39 - code will be converted into this schema
670:43 - type and how can you resolve the
670:47 - resolver when you look at the post
670:53 - resolver this is the resolver and I say
670:55 - this is the post resolver that's why I
670:57 - provided the post
671:00 - entity now we have the post resolver the
671:03 - query
671:05 - tag so here you want to say what
671:10 - resolver this will do in we are in the
671:13 - post we are here
671:17 - so this query will return all the post
671:23 - and the name of the query should be post
671:26 - I'm resolving this query so I'm fetching
671:29 - the post similarly if you want to
671:32 - resolve the created by here this one you
671:36 - have to provide the resolve
671:38 - field is all
671:41 - field there is a field inside the post
671:44 - Ty which is created by and it should
671:46 - return a
671:47 - user so this is the return type this is
671:51 - how you will mention the return type it
671:53 - should give the user and I got the
671:56 - parent and the
671:58 - context this is a uh nextjs has
672:02 - documentation on
672:06 - graphql you can learn more about a code
672:10 - based approach if you like the code
672:13 - based approach you can learn more about
672:15 - from the
672:16 - [Music]
672:17 - documentation this is the code first
672:19 - approach the object types you can read
672:21 - the documentation if you are not getting
672:23 - what I'm talking about you can just read
672:26 - this text it will help you to understand
672:29 - the code very easily so this is how a
672:33 - field and type should be post array I
672:37 - want you to check this documentation one
672:39 - more package I want to share you have
672:43 - graph nestjs graphql
672:52 - tools if you want to use the code based
672:55 - approach
672:56 - and let's say you are using post or type
673:01 - orm this is the package if you want to
673:05 - work with
673:06 - database and and you want to use loader
673:10 - they have already built a data loader
673:13 - here if you like this package you can
673:16 - implement it it's simple you need to
673:19 - provide resolver user object type user
673:22 - resolver here it will have graphql
673:26 - loader you only need to just provide The
673:28 - Decorator graphql loader and it is going
673:31 - to implement the loading stuff
673:34 - here if you like it you can implement it
673:37 - there is a this is how you will
673:39 - Implement one to many many to one and
673:43 - this is the usage
673:46 - I just want to show
673:47 - you you can do if you want to use
673:51 - database and data loader you can
673:54 - Implement by using this package this
673:57 - package also have more features on
673:59 - pagination sorting and field extraction
674:06 - Etc if you want to fetch data from
674:09 - external rest API you can do that we're
674:12 - using Apollo server AP poo server
674:15 - provides a package to fetch data from
674:18 - external rest API a
674:21 - poloo data source rest I have attached a
674:25 - started
674:27 - project I have already in I have already
674:31 - have this package in package.json file
674:35 - you have to install it Apollo data
674:38 - source
674:40 - rest you have to do npm install to
674:43 - install all the dependencies
674:45 - this is a class you have to extend
674:49 - it we're going to do we're going to
674:52 - fetch
674:54 - todos from this Json placeholder API
674:57 - it's a fake API with real data let's say
675:01 - I want to send to-dos
675:04 - request it is going to give me all of
675:07 - the to-dos I want to fetch this rest
675:13 - API
675:15 - now this is how you will implement
675:19 - it you will have this schema you will
675:22 - create the schema to do ID user ID title
675:27 - completed with
675:28 - Boolean I'm using the same property I
675:31 - defined a graphql type and then we have
675:34 - a query query to fetch all the
675:36 - to-dos I have a to-do module inside
675:39 - to-do service to-do resolver now to-do
675:43 - service is is going to f fetch the data
675:46 - from external rest API instead of data
675:51 - database inside the to- do service here
675:54 - you have to extend the rest data source
675:57 - it will it will ask the call the super
676:00 - Constructor this is the base URL I'm
676:03 - going to call this.get to fetch all the
676:06 - to-dos you can use this method I I can
676:10 - get the data source object from the
676:13 - context here you got call data sources.
676:16 - too api. getet too I'm talking about
676:19 - this too API like this one so another
676:24 - important thing this is how you will add
676:27 - a data sources inside the context it's
676:30 - an asynchronous so I provided the data
676:33 - sources if you want to implement you can
676:36 - go ahead and do it and let me do that
676:39 - for
676:42 - you I have I have to do docraft in my
676:45 - started kit
676:47 - project now let's extend data
676:51 - source rest rest data
676:55 - source let's have the
676:59 - Constructor I'm going to call the super
677:02 - Constructor now let's set the base
677:06 - URL I can get the base URL from
677:11 - here I don't need to provide todos this
677:14 - should be the base URL now let's define
677:18 - a function to get
677:22 - to-dos and it is going to return the
677:25 - array of
677:30 - to-dos I can get the type from the
677:33 - source. graphql file the typescript file
677:37 - I've generated the typing by executing
677:40 - this
677:41 - command npm run generat typing
677:47 - so let's call this
677:53 - dot here disor get and provide the path
677:58 - to
678:00 - do is everything right I can check the
678:03 - path which is to
678:07 - do so we created the data
678:10 - source and now we have to add this data
678:14 - source
678:16 - into to do resolver we got to call this
678:20 - actually we need to add in the
678:27 - context I'm going to create the data
678:29 - sources
678:30 - function it's going to return a to-do
678:33 - API let's create import to-do
678:38 - service it's going to return the object
678:40 - and the function is going to return the
678:42 - object now I can add in the
678:49 - context
678:50 - here it looks good so you can use the
678:54 - context object here inside the to-do
679:00 - resolver to do resolver let me get the
679:11 - context data sources and I'm going to
679:14 - call all this
679:16 - method data source is a function there
679:19 - is a to-do API object and we have get
679:22 - too
679:27 - function let's start the
679:38 - project project is already Runing on
679:40 - 3,000 let me stop the project let's run
679:44 - it again
679:52 - my project is running I'm going to send
679:54 - the
679:58 - request I got all the 200 toos
680:03 - Unfortunately they don't have pagination
680:05 - otherwise I can implement the pagination
680:08 - but you got the concept how to implement
680:11 - the rest data source if you want to do
680:14 - more Advanced Thing by using the rest
680:17 - data source package there is also a
680:20 - caching functionality you can override
680:23 - the method I want you to check the
680:25 - documentation if you want to implement
680:27 - the rest data source there is also a
680:31 - data loader you can also use the data
680:34 - loader with rest data
680:37 - source I want you to check this
680:41 - documentation it also provide to fetch
680:44 - duplicate
680:45 - records you can read the documentation
680:48 - to understand how to use the
680:52 - cache stuff like
680:56 - that in this module we're going to use
680:59 - Prisma orm and we're going to build rest
681:02 - apis Prisma is an orm in nodejs or
681:07 - JavaScript when you look at the
681:09 - documentation it's they are saying it's
681:12 - a Next Generation orm for nodejs and
681:15 - typescript
681:17 - project it's similar to type orm but it
681:19 - is faster it's an efficient they are
681:23 - maintaining this project
681:25 - regularly so you can look at the use
681:28 - cases and customer stories when when do
681:31 - you need
681:32 - Prisma you can read the customer stories
681:36 - and use
681:39 - cases so in this video I'm going to
681:42 - teach you how to set a Prisma in next
681:45 - nestjs project you can also get the
681:48 - Prisma documentation from nestjs package
681:51 - from nestjs package inside the njs
681:55 - documentation you will find a Prisma
681:57 - folder you will see the Prisma section
682:01 - here is a Prisma orm
682:05 - documentation the first step we need to
682:07 - install the
682:11 - Prisma I have provided the started kit
682:14 - code for you you can go to the starter
682:18 - branch and run nbm install to install
682:21 - all the dependencies this is just a
682:24 - basic Nest CH
682:26 - project I don't have anything here just
682:29 - Basics basic setting for nest CH
682:35 - project it is taking some time to
682:37 - install the dependencies meanwhile I'm
682:40 - going to create a new database for
682:42 - Prisma because we're going to use postp
682:45 - with
682:46 - Prisma I'm going to create a new
682:51 - database
682:54 - Prisma API something like that you can
682:57 - choose any
682:59 - name all the packages have
683:05 - installed now we need to install a
683:08 - Prisma as a dep
683:11 - dependency
683:13 - Prisma left dependency has
683:18 - installed now we need to initialize the
683:21 - Prisma project I can use npx init Prisma
683:25 - in
683:26 - it it will set up the Prisma in our
683:30 - project you will see schema. Prisma file
683:35 - inside the Prisma folder here I'm
683:37 - telling I'm going to use Prisma client
683:39 - Library this is my post database
683:42 - provider this is my database
683:44 - URL they have also added a created EnV
683:49 - file here we have postp database URL
683:53 - make sure you have ADD theb in the git
683:57 - ignore I think I've already added it yes
684:01 - no I cannot see that let's add EnV I
684:05 - don't want to put push my EnV to
684:10 - GitHub they have already installed post
684:13 - so I'm going to work with
684:18 - post this is how you will set a Prisma
684:21 - in your project in your nestjs
684:24 - project in the previous video we have
684:28 - set up our Prisma
684:31 - application now we're going to create
684:33 - our first
684:37 - model I'm going to create the song
684:40 - model the type should be int
684:49 - and by
684:52 - default this should be
684:55 - int by default I'm going to set it to
684:57 - Auto
684:59 - increment and this is the
685:02 - ID let's add another property this time
685:06 - the type should be
685:08 - [Music]
685:11 - string but we did not set
685:14 - database URL for the
685:18 - post I'm going to create a new
685:24 - database let's create a new
685:28 - DB
685:30 - Nest Prisma app or Nest
685:36 - prisma-p my username or owner is
685:42 - postgress now we need to replace the
685:46 - owner here
685:48 - postgress and your
685:50 - password and the name of your database
685:54 - and schema should be
685:58 - public I'm going to run the
686:04 - application my application is running
686:08 - fine let's try to check the tables
686:12 - inside the schema I'm going to
686:16 - refresh and inside the tables I cannot
686:20 - see any table because we did not migrate
686:25 - the
686:25 - database let's create our first
686:29 - migration migrate
686:33 - F Prisma migr F and the name of your
686:37 - migration I can say in it this is my
686:40 - first
686:43 - migration
686:48 - I think I did not provide the right
686:50 - command Prisma
686:52 - migr
686:54 - DB or Dev yeah npx PR migrate
687:00 - Dev Das Das name of your
687:04 - migration this is my first migration
687:07 - that's why I chose the init name but you
687:09 - can choose anything
687:13 - here
687:15 - Local Host provided DB credentials are
687:19 - not
687:21 - valid post
687:24 - SC there was an issue with double
687:28 - s now a new migrations folder has
687:32 - created inside the
687:35 - folder we have in it migration
687:39 - file we have song table this is the
687:43 - migration log
687:46 - let's try to check in our database I'm
687:50 - going to refresh my
687:52 - tables and you can see the song table in
687:56 - our
687:58 - database but we also have two columns ID
688:02 - and
688:08 - title in the previous video we have
688:11 - created our first model and we ran
688:15 - migrations but Prisma also provides a
688:19 - Prisma client to perform cred operation
688:22 - this Prisma client will generate the
688:25 - correct
688:26 - apis correct functions for song model
688:30 - you will have prism client. creat song
688:34 - prism client. find song all of these
688:37 - methods in the prisman client Library
688:40 - here we are using the prisman client but
688:43 - we have to install this package Prisma
688:45 - client and P install at Prisma
688:50 - client this package will provide scrud
688:53 - operations for all of your
688:56 - models this Prisma client will interact
688:59 - directly to the
689:01 - database so we created the Prisma Cent
689:04 - installed the Prisma client now we need
689:08 - a service inside the source directory
689:10 - and I call it Prisma dos service.
689:14 - s it's injectable
689:20 - service
689:22 - exort class Prisma
689:25 - service and I'm going to extend the
689:28 - Prisma
689:33 - client Prisma client
689:42 - here we also need to
689:45 - implement on module in it because we
689:48 - have to set up the Prisma client when
689:51 - our application is
689:54 - running I can call it on module in
689:58 - it on module in it this
690:02 - do
690:04 - connect this connect method will connect
690:10 - our uh connect this Prisma client to our
690:13 - database
690:16 - I have I have not imported injectable
690:18 - decorator let me get it that's all you
690:22 - need to connect Prisma client to
690:27 - our
690:28 - database so we will not use Prisma
690:33 - client we will use Prisma service to
690:36 - interact with
690:42 - database we're going to talk about how
690:45 - to create cred
690:53 - operations we have created a song model
690:58 - here I want to create the correct end
691:02 - points one more thing I did not talk
691:05 - about or I did not teach there is a
691:07 - resource
691:12 - generator this CLI command will generate
691:17 - the correct API endpoints controller
691:21 - module service dto object something like
691:27 - that if you need to scaold your
691:31 - application you can use this command
691:42 - resource
691:46 - it can also works with work with graphql
691:50 - code first approach schema first
691:53 - approach or you can create a micro
691:56 - service or you can create the web socket
692:00 - but I chose the rest API because I would
692:03 - like to build the rest API yes I also
692:07 - want to generate correct entry end
692:10 - points we have the songs model we have d
692:14 - object entities so on
692:19 - controller
692:21 - service we have all of these method
692:23 - inside the
692:25 - service we have created a Prisma service
692:28 - now I'm going to use a Prisma service
692:30 - here to interact with database can call
692:34 - it
692:35 - Prisma Prisma
692:38 - service it is going to give me the
692:41 - error that's why I use this
692:50 - path first of all let's create the
692:54 - create
692:56 - method return this do
693:00 - Prisma
693:02 - Dot Song you can see we have a song
693:07 - object there is a create method and you
693:11 - have to provide the data here you have
693:14 - to provide create song
693:22 - dto one more thing I want to talk about
693:25 - you can use the types from Prisma client
693:29 - Prisma client already generated couple
693:31 - of typescript typing let's
693:34 - say first I need to import
693:38 - Prisma from Prisma
693:42 - client
693:48 - you will find book create input the
693:54 - type in this type you will have title
693:59 - field we also need to update inside the
694:03 - song
694:08 - controller we got to get Prisma client
694:12 - and you will have book
694:16 - DOT
694:18 - book create
694:21 - input my vs code is not giving me the
694:25 - hint or
694:40 - suggestion now we're going to run the
694:43 - application it is going to give me a
694:44 - couple of Errors
694:47 - maybe oh it's not a book it should be a
694:50 - song because I'm accessing the song
694:54 - model I'm using the
694:57 - book
694:59 - song song.
695:05 - input not a book song create
695:12 - input
695:27 - I did not import Prisma service inside
695:31 - the song
695:34 - module because we have to import it
695:37 - that's why you have to register it as a
695:42 - provider
695:44 - Prisma service so I can get the Prisma
696:01 - service my application is running fine
696:05 - now now we're going to test it with the
696:08 - help of fresh client let's create a new
696:11 - file I can say HTTP
696:14 - client.
696:18 - HTTP create
696:23 - song post
696:25 - HTTP HTTP Local Host colum
696:29 - 3000 SL
696:31 - songs what is the name of the API I can
696:35 - check it from the
696:36 - controller we have the
696:39 - songs content
696:41 - type application
696:45 - Json let's provide the
696:49 - title follow
696:55 - me you can see a new song has created
697:00 - successfully now we're going to write
697:03 - the function to fetch all the song This
697:07 - start
697:12 - Prisma
697:16 - I'm going to reload my window it is not
697:18 - giving me
697:24 - suggestions Prisma
697:28 - Dot
697:31 - Song dot find many there is a method
697:35 - find
697:42 - many
697:45 - let's try to get all the
698:04 - songs you can see I have a single
698:08 - song now we have to implement the find
698:11 - by ID this do
698:14 - Prisma do song now it is giving me
698:19 - suggestion find
698:21 - unique and we have to provide the
698:33 - ID where clause and you have to provide
698:36 - the
698:42 - ID
698:44 - let's try to fetch the song on the based
698:46 - on
698:47 - ID fetch song by
698:53 - ID so I got the song by ID if I provide
698:56 - the invalid
698:59 - ID I should get the empty
699:07 - record I'm getting issues here I think I
699:10 - need to generate the typing you can call
699:13 - this method npx Prisma
699:17 - generate it is going to generate the
699:20 - typing inside the node node modules and
699:25 - Prisma inside the Prisma you will get
699:27 - the typing I got this from
699:29 - documentation this typing will be stored
699:32 - inside the node modules inside the
699:35 - Prisma and the client
699:40 - directory generated Prisma client
699:45 - reload the
699:53 - window now the error should be gone
699:59 - now I have to update it it's a song
700:02 - create
700:05 - input we also need to update in the
700:08 - controller we have the song
700:12 - controller
700:13 - here it should be
700:18 - Prisma Prisma
700:21 - SL song create
700:24 - input I have to get this ke Prisma
700:34 - client now the error should be gone now
700:37 - it looks
700:42 - good
700:43 - so I can create a new
700:49 - song and I can fetch all the songs that
700:53 - looks
700:57 - good in this lesson I'm going to teach
701:00 - you how to create update endpoint
701:05 - actually we have already created the
701:07 - update
701:09 - endpoint you will see the patch endpoint
701:13 - Point inside the song
701:21 - controller there is also a method inside
701:24 - the song service there's an update
701:29 - method all I need to do is to use a
701:34 - Prisma service inside the song
701:41 - service we have have to use the update
701:46 - method from the
701:48 - Prisma and there is an update method
701:52 - inside the
701:53 - song
701:56 - update here you got to
701:59 - provide we clause and the
702:10 - data where and
702:20 - data we have to fix a little bit
702:23 - changing
702:24 - here I'm getting I'm going to get we
702:28 - clause and I can get the type for for Vi
702:33 - song We unique input similarly I would
702:38 - like to change the type here Prisma do
702:44 - song update
702:51 - input you can remove the V because both
702:54 - the key and the value are same so I can
702:58 - use a single
703:00 - V we also need to update the type in
703:05 - controller file let me update the type
703:12 - here
703:13 - here I would like to send the object
703:16 - instead of single parameter which is
703:20 - ID here I can change the type Prisma do
703:25 - song update
703:35 - input we also need to update the find
703:39 - one a little
703:42 - bit
703:45 - I would like to get the songw
703:50 - unique input and let me get the
703:55 - songw
703:57 - unique
704:01 - input and I'm going to
704:03 - provide song wear unique
704:12 - input
704:21 - we also need to
704:22 - update controller for the find
704:27 - one let me send the ID in the
704:34 - object because I'm receiving the object
704:37 - here
704:39 - here if you want to look at all of these
704:42 - types where these types have
704:45 - stored when you go to the node modules
704:48 - you will find there is a package
704:51 - Prisma do Prisma
704:54 - client you will have all of your types
704:58 - in index. D.S
705:01 - file so I can get song whereare input
705:05 - you can see we have a song We
705:08 - input can say
705:11 - type here here we have a song We input
705:15 - you can have ID and the
705:19 - title here we have the song where unique
705:22 - input you have you can have ID and or
705:25 - note in the
705:39 - title now we have to test it run run the
705:55 - application cannot find
705:58 - primsa let me fix
706:01 - that there is an issue
706:11 - Prisma
706:15 - now my code looks
706:20 - good I'm going to send the update
706:22 - request from my rest client from my HTTP
706:30 - client the song by ID we have to send
706:34 - the patch request instead of
706:41 - put and going to update this song with
706:46 - id2 copy the content
706:54 - type dancing
707:01 - feet let's see a song has updated
707:06 - successfully if I fetch the song on the
707:08 - based on ID it looks good we have
707:11 - dancing feed
707:13 - let's create another
707:18 - song I have created another song I would
707:21 - like to update the
707:27 - title my title has updated so you can
707:30 - fetch all of the
707:33 - songs it looks
707:38 - good we have implemented the update
707:41 - operation now now we have to implement
707:43 - delete
707:45 - operation I'm going to use the same
707:48 - strategy to delete let me get the ver
707:51 - clause in the
707:53 - input there is a method in the
707:58 - Prisma Prisma do song. delete it is
708:03 - going to accept the V
708:09 - Clause now I have to get it in the
708:13 - controller we need to pass
708:16 - that inside the song
708:19 - controller here I have to provide the ID
708:22 - inside the
708:24 - object
708:41 - ID
708:44 - let's try to test it with the help of
708:46 - HTTP
708:54 - client I can say delete song by
708:58 - ID I'm going to provide the ID instead
709:01 - of patch we need to use the delete
709:04 - operation you can see this song has
709:07 - deleted I can verify by fetching all of
709:09 - the
709:10 - songs you can see we have only only two
709:13 - songs right
709:22 - now now we're going to build
709:25 - relationship between
709:27 - models Prisma also provides one to one
709:31 - relation one to many relation and many
709:34 - to one
709:37 - relation and also have many to many
709:40 - relation I'm going to add a new model
709:44 - artist let's add Fields inside the
709:49 - artist I will have the ID and the name
709:53 - of the
710:03 - artist now each
710:08 - song an
710:11 - artist
710:13 - I'm going to add one to M relationship
710:16 - between artist and
710:23 - songs each artist can publish many
710:28 - songs I saved the application you can
710:32 - see it has automatically added a
710:36 - relation let's rename a small a to a
710:40 - capital A to small a
710:46 - here you can see there is a reference
710:49 - here
710:50 - artist and fields which is artist ID and
710:55 - the reference with the
710:58 - ID now we have to run the migrations npm
711:02 - run
711:05 - migrations oh I have to run
711:09 - npx Prisma migrate
711:13 - Dev the name of the
711:15 - migration which is ADD
711:33 - artist it has also generated the Prisma
711:36 - client queries or Prisma client
711:41 - types when you see the migrations you
711:44 - will
711:46 - have the create table cury it is going
711:50 - to create the artist table it has also
711:53 - added a relationship between song
711:56 - relationship between songs
711:58 - model let me try to check the types you
712:02 - can check it from Prisma client index. D
712:07 - dots do I have the artist type yes let
712:10 - me find artist create input yep it has
712:16 - generated the types for
712:21 - me now I'm going to generate a new
712:25 - resource for
712:34 - artist an artist resource has created I
712:37 - don't need entities I'm going to delete
712:41 - them
712:43 - here I also don't need entities in this
712:47 - song because we are defining our models
712:50 - in the schema. Prisma
712:53 - file let's create the
712:57 - artist we have to open the r service and
713:01 - here we need to
713:03 - inject the artist the Prisma
713:07 - service I can get it from the song
713:11 - service which we have to import these
713:14 - two dependency Prisma service and the
713:17 - Prisma
713:19 - client I'm going to copy the
713:24 - Constructor here we have to
713:28 - find the Prisma create
713:35 - input command F to to
713:39 - find artist
713:41 - create
713:44 - input yes I would like to use that type
713:47 - I can get it from the Prisma
713:50 - client
713:52 - Artist Artist create input that's it now
713:58 - I can
714:00 - use Prisma do
714:03 - artist do
714:05 - create here we have to provide the data
714:07 - object and inside the data I can
714:11 - provide create
714:13 - artist
714:18 - dto one more thing you need to add
714:22 - Prisma service in the artist
714:25 - module we have to register it Prisma
714:36 - service let me import Prisma
714:39 - service and here I need to add Prisma
714:46 - service we also need to adjust a type in
714:50 - the controller for artist controller we
714:53 - have to update our
714:57 - type I have to use the same
715:01 - type Prisma dot artist create we have to
715:06 - import a
715:09 - Prisma otherwise it will give you the
715:13 - error I'm not going to use the create
715:15 - artist
715:16 - dto so the artist create input can take
715:20 - the name of the artist if you want to
715:22 - inject the multiple songs you can also
715:24 - do that you can look up the
715:27 - documentation of Prisma how can you
715:29 - insert multiple
715:31 - records if you want to do in this way
715:34 - you can also do that artist unchecked
715:37 - create input but I'm going to use this
715:39 - one simple one npm R start
715:54 - Dev my application is running fine now
715:57 - let me open the HTT HTTP client let's
716:01 - send the
716:03 - request to create new
716:10 - artist create
716:15 - Artist
716:17 - Artist here I can provide the name of
716:21 - the
716:22 - artist can say Martin
716:28 - Garrick a new record has created
716:31 - successfully the artist record has saved
716:35 - let's add a new
716:39 - artist V
716:46 - another artist has
716:50 - created we have made one too many
716:53 - relationship between artist and songs
716:56 - when you add a new song you can add a
716:59 - relationship for the artist here when
717:02 - you check the schema. Prisma file you
717:06 - will have the artist ID in the song
717:08 - model that's why we need this is how you
717:11 - can build a relationship between song
717:13 - and the artist so what I can do inside
717:16 - the song
717:21 - service we have to
717:24 - expect the song actually author ID I can
717:30 - find
717:31 - that song
717:34 - create
717:38 - input so I have this song create input
717:43 - type I also have song unchecked create
717:47 - input did you notice the difference
717:50 - between these two types here we have the
717:54 - artist ID I can add the artist ID if you
717:57 - want to insert a complete artist while
718:00 - creating a new song you can also do that
718:04 - you can look up the
718:06 - documentation and here you
718:09 - can you can do in this way
718:13 - you can provide the array if you want to
718:15 - do that if you want to insert a single
718:17 - record you can also do that but I just
718:20 - want to show you the way to
718:22 - add
718:27 - record so I'm going to use this
718:31 - type instead of
718:34 - simple song create
718:37 - input now you also need to provide the
718:41 - author ID in the in the request
718:45 - parameter here I'm creating a new song
718:50 - here let's provide the author
718:54 - ID which is one I'm going to create a
718:58 - new song let's say
719:02 - Animals by Martin
719:07 - gck I got an issue not an author ID it's
719:12 - an artist
719:14 - ID why I'm saying the author ID I got
719:18 - the record with this author ID if you
719:23 - want to
719:24 - query the artist in
719:27 - the response let's say I'm going to I'm
719:30 - going to fetch all these songs but here
719:33 - we have artist ID null here we have the
719:36 - artist ID one if you want to populate
719:39 - the record of the artist you you can do
719:42 - that in the find menu and here you can
719:46 - say
719:48 - include artist to true that's
720:00 - it let's fetch all the
720:04 - songs here the artist ID is null artist
720:09 - is null here you can see
720:12 - the artist ID one and we have a complete
720:16 - artist
720:21 - record that's how you do
720:35 - population we have used this include
720:39 - syntax you can also use the connect
720:42 - object if you want to make the
720:44 - connection or update the reference ID
720:48 - you can use the
720:54 - connect now we're going to implement one
720:57 - to one relationship between two models
721:01 - we're going to have a user model here we
721:05 - have a one to one relationship between
721:08 - user and profile each user will have one
721:12 - unique profile in the profile we have
721:15 - photo we have the phone number of the
721:18 - client of the user this is how you will
721:21 - make a one toone relationship user and a
721:25 - relation and this makes each profile
721:29 - will have a unique ID of a user table
721:34 - then we will generate Prisma
721:37 - migrations then we will generate a new
721:39 - user with the help of nest generat
721:42 - resource a user we're going to use cred
721:44 - AP endpoints and finally we're going to
721:47 - save a user on the based on profile like
721:50 - when we are when we are saving a user I
721:54 - also want to save the profile this is
721:57 - how you can do that profile and a create
722:00 - object and the attributes of profile
722:05 - table it will automatically made a
722:08 - relationship between user and a profile
722:11 - and finally I want to fetch all the user
722:13 - with the
722:15 - profile if you want to implement it you
722:17 - can do it but let me show you how can I
722:21 - implement it I'm going to copy the
722:29 - model here here here inside the
722:33 - schema let's add two new
722:36 - models I've added two new models let's
722:39 - run the
722:40 - migration
722:43 - npx Prisma migrate Dev the name of the
722:48 - migration one
722:50 - to1
722:51 - [Music]
722:58 - relation it has run the
723:00 - migrations and now it has also generated
723:03 - the types inside the Prisma client I can
723:06 - double check that from the Prisma here
723:09 - you have all of your user types user and
723:13 - profile when you search the
723:19 - profile here we have profile
723:25 - stuff our next step is to generate a
723:35 - resource Nest generate
723:38 - resource
723:40 - users
723:45 - select rest API end
723:48 - points getri
723:51 - of the
723:57 - entities and I need to inject Prisma
724:00 - service inside the
724:03 - module inside the users module I have to
724:07 - inject the Prisma service
724:09 - here Prisma
724:17 - service inside the user service we need
724:22 - to inject Prisma service
724:26 - dependency I can get that from the song
724:31 - service we need the Prisma
724:40 - service
724:42 - and I'm going to copy this one as a
724:49 - Constructor so we have to call the
724:51 - create method I'm going to copy the
724:55 - exact create
724:56 - method and provide it
724:59 - here that's it this time I'm going to
725:03 - use the create user
725:07 - dto I have not defined the properties in
725:11 - the create user user dto if you want to
725:13 - add the validation you can use the class
725:16 - validator I taught you earlier in the
725:19 - previous
725:20 - modules we will have photo the URL of
725:23 - the photo should be
725:27 - string and phone number the type should
725:30 - be
725:37 - string now we're going to I'm going to
725:39 - copy find all method
725:43 - and I'm going to use this profile I want
725:46 - to fetch the profile with each user now
725:50 - let's try to test it run the
726:00 - application this create object is used
726:03 - to create an nested object a relation
726:08 - relation
726:10 - object
726:18 - let's create a new
726:22 - user
726:25 - users provide the name of the user
726:30 - jendo and we have to provide the photo
726:34 - URL some
726:36 - api. com/
726:39 - phos 1. J
726:42 - APG and you need to provide the phone
726:49 - number let me create a new
726:53 - user a user has created successfully
726:57 - let's try to find all the
727:04 - users VCH
727:10 - users
727:14 - here you can see that I can see the
727:18 - user and we have the profile object
727:22 - inside the user you will also see a
727:24 - relationship with user ID one which is
727:28 - one that's how you implement one to one
727:32 - relation in this lesson you're going to
727:35 - learn how to implement many to many
727:38 - relationship between
727:40 - models I have this use case one blog
727:43 - post can belong to many categories and
727:47 - many categories can belong to a single
727:50 - block post so there is a many to many
727:55 - relationship when you implement many to
727:58 - many relationship you need a third model
728:02 - in the third model you store the foreign
728:06 - key of your first model and the foreign
728:09 - key or prime for foreign key as the
728:12 - primary key the foreign constraint here
728:17 - it's a it's a foreign key of category
728:22 - table and in Prisma you define the
728:26 - primary key by combination of post ID
728:29 - and the category
728:33 - ID this is how you will make uh many to
728:36 - many relationship now the categories
728:39 - instead of categories array you will use
728:42 - the categories on post array the same
728:46 - stuff here instead of using post array
728:49 - here you will use the categories on post
728:53 - array and then
728:55 - you we will generate
729:00 - migrations we will generate migrations
729:03 - and it will also generate the Prisma
729:05 - client
729:07 - types and then we will generate the
729:09 - resource post we will create the post by
729:13 - using this input type post create
729:19 - input and I also have to update the type
729:22 - in the
729:24 - controller and this is how you will send
729:28 - the request to create a new
729:31 - post here the title of the post one to
729:35 - many
729:36 - relation this this is the Prisma post
729:40 - and it it can have two
729:43 - categories here you can say I I'm going
729:45 - to create a new category this post can
729:50 - also belong to Prisma category this post
729:54 - can also belong to nestjs category that
729:58 - is why I created two categories you can
730:01 - see that category number one and this is
730:04 - category number two here I here we have
730:08 - the array of the
730:10 - categories similarly you can do the same
730:13 - thing if you don't want to create a new
730:15 - post you can connect with existing
730:18 - post I'm going to teach you transaction
730:21 - let's say I'm going to write blog post
730:23 - on transactions in
730:25 - Prisma and here this post also belong to
730:30 - nestjs category and Prisma category
730:33 - that's
730:34 - why I'm I'm connecting to category
730:38 - number one and the category number two
730:42 - and finally you can also do a relation
730:45 - queries with the help of this type post
730:49 - where uni input also have to update in
730:52 - the
730:53 - controller this is how you can send the
730:57 - request categories this is a we Clause
731:00 - category and the name you can check all
731:03 - of different type of queries in the
731:08 - documentation let's try to implement it
731:12 - first if you want you can Implement by
731:20 - yourself many to
731:23 - many
731:35 - relation I'm going to create a post
731:38 - model and my next model model is
731:43 - category it will have name and the ID
731:47 - and my third model is categories on post
731:50 - I'm going to save now you can see
731:54 - that these two properties are inside the
731:57 - categories on post I would like to store
732:01 - the
732:03 - date and I want to store who has created
732:10 - this
732:12 - let's run the
732:28 - migration it has also generated a Prisma
732:31 - client
732:33 - types you can check it in the node
732:35 - modules at Prisma /
732:39 - client our next step step is to generate
732:42 - the post resource we're going to perform
732:45 - some cred
732:56 - operations please select the rest
733:00 - API yes I want create entry end
733:05 - points I have the post get rid of the
733:10 - entities
733:14 - one more thing I would like to register
733:17 - a Prisma
733:18 - service inside the post module otherwise
733:22 - you will get the
733:30 - error now we're going to write the code
733:33 - in to create a new
733:36 - post we also need to inject Prisma
733:41 - Service as a
733:43 - dependency I'm going to copy these two
733:47 - lines and I'm going to paste here Post
733:52 - Service let me copy The Constructor we
733:56 - need to inject the
734:01 - dependency I'm going to copy my
734:04 - create
734:10 - function
734:15 - something is
734:32 - missing I have done something
734:38 - wrong so let's you use the
734:48 - Constructor pris
734:51 - private Prisma and Prisma
735:07 - service let's use this type
735:15 - actually I don't need
735:18 - that let me copy the fold
735:24 - create what is
735:30 - this now it looks
735:33 - good so we also need to use that post
735:37 - create post create input in the post
735:52 - controller let me import
736:00 - Prisma now it's time to test this
736:09 - application
736:15 - the application is running fine let's
736:17 - send the API
736:20 - request I'm going to copy my API
736:29 - request here I'm going to create a new
736:32 - post and I'm going to also create a two
736:37 - categories so you can use the create
736:40 - array
736:41 - inside the create array I have the
736:43 - category this is the post on category
736:47 - object so that's why I use that
736:51 - properties let's send the
736:55 - request it should be 3,000
737:00 - or 3,000 it should
737:05 - 3,000 now you can see that one to many
737:08 - relation post has created
737:16 - successfully now it's time to do a
737:20 - register another
737:25 - post this time I don't want to create a
737:28 - new
737:31 - category create a post
737:34 - with existing
737:39 - categories I would like to create a new
737:42 - post and I want to use
737:44 - the category number one and category
737:47 - number two let's create a new post has
737:52 - created it has also made a
737:55 - connection with this category you can
737:59 - double check from the PG
738:07 - admin meanwhile I'm going to write the
738:11 - code to do relational
738:15 - queries let's
738:17 - update the find find
738:24 - all that looks good we also have to
738:28 - update the
738:30 - get inside the post
738:39 - controller
738:42 - now we have to fetch all the post with
738:45 - nestjs
738:48 - category so you can do that you can
738:51 - learn more about how to do queries in
738:54 - Prisma
738:56 - documentation I'm going to send the
739:00 - request the post the should be
739:09 - 3,000 now you can
739:11 - see I got these two post with the help
739:16 - with the I justed query with
739:33 - category what is my name of the database
739:37 - let me get it from
739:39 - EnV PR
739:41 - Nest Prisma
739:43 - DB here I have Nest Prisma DB let me
739:47 - find the
739:50 - tables and we have post category and
739:54 - categories on post let's look at the
739:59 - post we should have two
740:04 - post you can
740:08 - see I have one too many and
740:11 - transaction I must have two
740:18 - categories you can see that let me find
740:21 - categories on
740:27 - post here you can see I have four
740:36 - records there is another way to use
740:40 - transac ction feature if you have to
740:43 - perform the batch or bulk operations
740:46 - like delete manyu create manyu and
740:49 - update manyu you can use all of these in
740:54 - a one query you want to create three
740:57 - records you want to delete two records
741:00 - or maybe you want to update a single
741:03 - record or maybe you want to update five
741:05 - records so in that case let's say if any
741:09 - query fail
741:11 - then all of the operation will be
741:16 - discarded I'm going to run multiple
741:19 - queries at same time if any query failed
741:23 - you will not get result
741:29 - back you can use this query or
741:33 - transaction API when you want to create
741:36 - batch
741:38 - operation here is an example
741:41 - I want to find all of the post I want to
741:44 - find all of the artist I want to find
741:46 - all songs I want to find all
741:48 - applications in a single query if this
741:52 - query fails it is going to give me the
741:55 - this operation this complete operation
741:57 - will be discarded I will not get any
742:00 - result that is why you use this
742:02 - transaction
742:04 - API to implement the demo or to
742:07 - implement the transaction
742:09 - API let's do it in app
742:13 - controller we have to inject Prisma
742:17 - service I just want to show you the demo
742:20 - how can you use the transaction
742:24 - API this my
742:27 - service we have to inject it
742:31 - here I can say
742:38 - transaction let me register Prisma
742:45 - service now I have injected it
742:53 - here we have to import
742:56 - it sounds good I'm going to create a new
743:01 - method with name
743:05 - sequential and get
743:09 - sequential result results this could be
743:12 - the name of the
743:13 - query and here I'm going to copy my
743:20 - code so let's try to test it I'm going
743:23 - to run the
743:30 - application let me send the request for
743:33 - sequential query in my HTTP
743:37 - client
743:39 - sequential
743:41 - query
743:43 - HTTP Local Host colum
743:47 - 3000 and
743:53 - sequential you can see I got the result
743:57 - of all of my post
744:03 - applications this these should be post
744:07 - the
744:09 - songs
744:11 - and here you will have application these
744:14 - are all the applications with customer
744:17 - ID this is how it will
744:20 - work if you want to add include or to
744:24 - fetch nested record you can also do
744:31 - that now I'm going to talk about the
744:35 - concept of nested
744:37 - queries this topic already is in the
744:41 - transaction
744:43 - API I'm talking about transaction when
744:46 - you have this type of use case let's
744:51 - say first I have to create the customer
744:56 - email customer or the user and then
744:59 - there is an address let me look at the
745:02 - model structure we have a customer model
745:06 - and we have an address model there is a
745:09 - one toone relationship between customer
745:11 - and the address and I have created the
745:14 - enum application type and I have the
745:18 - application model and the type should be
745:20 - application type and default to now and
745:23 - I choose a loan loan
745:26 - here and I have made one to many
745:29 - relationship between application and the
745:32 - customer we have the applications array
745:36 - here so let's say I want to create a new
745:42 - customer address and here I'm creating a
745:46 - new address and here is the Fe here are
745:50 - the fields of
745:52 - customers and I'm going to create
745:55 - applications basically we going to we
745:57 - are talking about a banking type
746:00 - application let's say a customer comes
746:02 - to apply for the loan customer can apply
746:06 - for multiple loan applications loan car
746:10 - financing or business financing a
746:12 - customer can apply apply all of these or
746:15 - can can apply to one or second type
746:20 - application so tenure of your
746:23 - application would be 5 years or 2 years
746:25 - how many amount you want how much how
746:27 - much loan you
746:30 - want so this type of application when
746:33 - banking banking in banking application
746:37 - when an application comes they create a
746:41 - new customer record they create the
746:44 - address and they create the application
746:47 - based on current user or current
746:50 - customer
746:52 - demand let's say a new customer comes
746:56 - with business financing application John
747:00 - wants to get the business financing from
747:03 - a bank so he's decided he's going to
747:06 - apply for business financing application
747:09 - what under the hood is saying what under
747:12 - the hood banking application will create
747:14 - a new customer they will create a new
747:18 - address and they will also create a new
747:23 - application but they have a
747:25 - feature a customer can apply for two
747:28 - loans two applications or three
747:31 - applications he can also apply on
747:33 - business financing he can also apply on
747:36 - car
747:37 - financing so that's why there is a
747:39 - create array
747:41 - here what what are the benefits of using
747:44 - transaction under the
747:47 - hood Prisma is using transaction when
747:51 - you run the nested queries these are all
747:53 - the this is the nested
747:55 - query we are creating address and we are
747:58 - creating applications this is the nested
748:00 - query let's say if an error comes here
748:03 - if I will add the invalid value
748:06 - here it will not create the complete app
748:10 - application it will not create the
748:11 - customer it will not create the
748:14 - address so that is the benefit of
748:17 - transaction I'll show you with the help
748:19 - of demo this is how you can
748:22 - implement the nested queries in Prisma
748:27 - I've already done that for you I'm not
748:30 - going to implement it here first of I
748:32 - can walk walk through the code I created
748:35 - the customer model we have the ID we
748:38 - have the name field we have the email we
748:41 - have the address and we have the
748:43 - applications
748:46 - array so address should be here it
748:50 - should be at the top here so I have made
748:54 - a on to one relationship between address
748:57 - and the customer here is a unique
748:59 - denotes to denotes to one to one
749:02 - relationship we have Zip City Country
749:05 - inside the address and there is a on
749:07 - toone relationship between customer and
749:08 - the address but I also have one too many
749:12 - relationship between application and
749:15 - customer so I told you a John can apply
749:18 - for car car financing he can apply for
749:21 - business
749:22 - financing that's why I use the
749:25 - application
749:27 - array so the tenure amount application
749:30 - type I have set the default to
749:33 - loan so that was our model structure
749:36 - next step I have executed nested query
749:41 - Migration by executing this command
749:45 - nested
749:48 - queries
749:50 - here it is going to create the customer
749:53 - table it is going to create the address
749:55 - table and create the constraint with
749:57 - customer and the address it is also
750:00 - going to create uh application table and
750:05 - create constraint between application
750:08 - and the customer
750:11 - and then I have set the default value to
750:15 - laan and then I have created the
750:18 - application resource by running Nest
750:20 - generate resource and you will see the
750:22 - application inside the application
750:24 - module I have injected the Prisma
750:28 - service and then here I'm injecting the
750:31 - Prisma Service as a dependency and I
750:34 - just
750:35 - called create application dto by using
750:39 - the customer customer create input you
750:42 - can double check it from the customer
750:43 - create input you can get name email
750:46 - address and
750:47 - application all of this stuff
750:51 - here name
750:53 - email address I provided the address and
750:57 - I'm creating it here I also can provide
751:00 - the applications array you can check the
751:04 - type by copying it and type and paste
751:10 - so it should give me
751:13 - the this one
751:19 - type so I got this application create
751:22 - nested with custom customer input so I
751:24 - use the create did you see I use the
751:28 - create can have the array so create can
751:31 - have the array
751:38 - here so you can provide the application
751:42 - object
751:44 - here if any fails the transaction will
751:49 - roll back or discarded the
751:55 - operation let's try to test
751:59 - it you have to send the AP request
752:03 - inside the HTTP
752:05 - client here I'm going to send the API
752:08 - request John J
752:12 - 2 jendo City New York ZIP code this one
752:17 - amount he wants say
752:24 - 10,000 inue over 5 years and he wants
752:27 - business financing I'm going to create a
752:29 - new
752:30 - application you you can see a new
752:33 - application has created if I provide the
752:36 - invalid value I have set the integer
752:39 - here I'm providing the float or float
752:42 - value I got the issue now it will not
752:46 - create an application you can double
752:49 - check it from PG
752:51 - admin that's the benefit of
752:56 - transaction in this lesson you're going
752:59 - to learn the interactive
753:01 - transactions what do I mean by
753:03 - interactive
753:04 - transaction when one query is dependent
753:08 - on another query one query result is
753:11 - dependent on another query result let's
753:15 - take a use case you're going to build
753:17 - account transfer feature in banking
753:20 - application we're going to build this
753:23 - use case a John has an account in a bank
753:26 - and he want to he want to transfer the
753:29 - $100 to Sam account so what would be the
753:33 - process you have you have to implement
753:36 - as a developer you have to update the J
753:39 - account or deduct the $10000 from a Jone
753:43 - account and then you have to check the
753:45 - balance of JN account if balance is less
753:48 - than zero you have to roll back the
753:50 - transaction the operation should not be
753:53 - continue
753:54 - so this query result is dependent on
754:00 - this query result you can see if any of
754:04 - the step fails operation will be
754:07 - discarded if there is an error occurs
754:09 - here it will roll back the
754:15 - transaction so first of all we need
754:19 - account model we will have these
754:22 - properties
754:24 - ID balance and the title then we're
754:28 - going to generate migration and resource
754:31 - for
754:32 - accounts we will inject Prisma service
754:36 - here I will use Prisma account create
754:38 - input
754:40 - and I'm also going to update in the
754:43 - controller we we're going to create
754:45 - first account John then we will create
754:49 - second account which is
754:51 - Sam and we will implement the logic to
754:54 - transfer amount to One account to
754:57 - another
754:59 - account I'm going to create a route
755:02 - Handler for
755:03 - transfer we will need transfer account
755:07 - dto because I cannot use from from
755:10 - Prisma
755:11 - types there is no specific type for
755:16 - transfer account I have to use the
755:19 - custom data transfer object here when I
755:23 - will transfer I will send the transfer
755:26 - account request you need to provide
755:30 - sender ID receiver ID and the amount you
755:33 - want a
755:35 - transfer so we will create a simple
755:37 - basic transfer from transer method
755:40 - inside the account service here is the
755:44 - logic from the controller I will get the
755:47 - sender and I have renamed to
755:50 - from here I will have receiver I have
755:53 - renamed to two and I will get the amount
755:56 - and first we will
755:58 - deduct the balance from the John account
756:02 - by getting by getting the account on the
756:05 - Bas ID here decrement the amount from
756:09 - the John account then we try to verify
756:13 - the balance of the John if balance is
756:16 - less than zero we have to send the error
756:18 - back and we have to roll back the
756:21 - transaction here we here we got to roll
756:23 - back the transaction but this
756:26 - transaction object will do for us and
756:29 - this transaction function it will take
756:33 - all it will take it's a it's a call it's
756:35 - a asynchronous operation it it's going
756:38 - to take TX
756:41 - so first this is the asynchronous
756:44 - operation if error comes please scroll
756:47 - back the transaction do not deduct any
756:50 - amount from the John account and here is
756:53 - our second
756:54 - operation if everything is fine we got
756:57 - to add balance to the same account and
757:00 - finally we have to return the balance or
757:04 - return the
757:07 - recipient that's our trans transer
757:09 - process this is how you can test you
757:12 - have to provide the sender ID receiver
757:14 - ID and amount you want to transfer here
757:17 - I'm saying I want to transfer $50 from
757:20 - join account to Sam account and here I
757:23 - want to transfer $40 from J account to
757:26 - Sam account we created both account with
757:29 - $100 now if I try to send $20 now John
757:34 - will have $10 in account in his account
757:37 - if I try to send or deduct the $20 from
757:41 - Jo
757:42 - account you will receive this error
757:44 - balance is less than zero and our
757:47 - transaction will automatically roll back
757:50 - this operation that's how the
757:53 - transaction is helpful when your one
757:55 - query result is dependent on another if
757:59 - you want to implement it you can do it
758:00 - on your own but let me do that for
758:04 - you first of all we got to create a new
758:07 - model inside the schema file
758:11 - I have already done that
758:13 - model oh I have to implement
758:18 - here interactive transaction op schema.
758:23 - Prisma and we have to
758:26 - add a new
758:28 - model finally we got to run the
758:38 - migration
758:41 - migrate not a
758:44 - migrate also have to update here M
758:52 - crate our next step is to generate the
759:08 - accounts
759:22 - select the rest
759:26 - API let me
759:28 - delete
759:33 - entities and we have to register a
759:36 - Prisma service inside the account module
759:40 - I can register as a provider Prisma
759:46 - service and we have to import Prisma
759:51 - service Prisma service
759:54 - from Prisma
759:59 - service let's inject Prisma service
760:04 - inside the account
760:07 - service I'm going to do dependent see
760:11 - injection I have to copy this
760:15 - line and I'm going to paste it here I
760:18 - also need to get Prisma client so I
760:21 - imported the Prisma
760:26 - client let's rename or add a logic to
760:31 - create a new
760:35 - account we got to do the same stuff
760:38 - inside the account
760:47 - controller import
760:49 - [Music]
760:57 - Prisma let's run the application and
761:00 - create two accounts in our database for
761:08 - testing
761:38 - e
761:50 - application is running now I'm going to
761:53 - create a new account let me send the
761:56 - request for account
762:02 - creation board should be 3,000 not
762:08 - 3001
762:14 - so I have created the account John now
762:17 - we have to create another account with
762:19 - Sam name account has
762:23 - created let's implement the
762:26 - transfer account logic transfer amount
762:29 - not an account transfer amount
762:32 - logic open the account controller we
762:36 - have to register a new route for
762:39 - transfer
762:41 - amount I'm going to create a post method
762:47 - we don't have transfer dto let's create
762:51 - that transfer dto in our dto
762:56 - accounts
763:03 - dto
763:06 - transfer
763:08 - account -
763:14 - D.S so here we have transfer account dto
763:18 - we also don't have a method
763:21 - yet inside the service account service
763:25 - so I can
763:26 - open account
763:29 - controller let me import transfer dto we
763:33 - don't have method I can use the vs code
763:37 - please declare the
763:40 - method inside the account
763:44 - service now you will have a method
763:48 - inside the account
763:53 - service this is the transfer
764:00 - method so here we're going to implement
764:03 - our logic to transfer the account from
764:07 - John to Sam I'm going to copy the
764:10 - complete op complete function I'm going
764:13 - to paste it
764:16 - here so everything is good to go now we
764:19 - have to test the
764:21 - process let's send the transfer amount
764:28 - request it should be
764:37 - 3,000
764:42 - let's deduct the $50 from John account
764:47 - to Sam account I'm going to deduct $50
764:50 - from John now you can see the balance of
764:52 - the
764:53 - Sam if I deduct the $40
764:57 - again let's use it
765:00 - here so now the Sam has 190 and the John
765:05 - has
765:06 - $10 if I try to
765:10 - uh deduct $20 from John right now the
765:13 - balance of John is 10 it should give me
765:15 - the
765:16 - error you can see I got the error one
765:19 - does not have one the ID sender sender
765:22 - ID with one does not have enough to send
765:27 - $20 so I got the
765:30 - eror so I got the error here my
765:35 - transaction function automatically roll
765:38 - back back this
765:41 - operation that's why transaction is very
765:46 - helpful if you are doing 1020 operations
765:51 - or 1020
765:52 - queries your one query result is
765:55 - dependent on another another query
765:57 - result is dependent on another let's
766:00 - imagine after 10th query there is an
766:02 - error then the transaction will do the
766:05 - roll back for
766:07 - you
766:10 - in this lesson I'm going to teach you
766:12 - how to upload the file in
766:16 - njs nestjs has already created a molter
766:21 - module if you have used molter in
766:23 - Express we're going to use the same
766:26 - logic they have created the molter
766:29 - module they also have nests platform
766:33 - Express to
766:35 - implement file upload feature so this
766:39 - package provides the typescript typing
766:42 - to work with multer package which is a
766:45 - middleware for handling multiart form
766:50 - data and then we will create our route
766:54 - Handler for
766:55 - update they have we're going to use the
766:58 - Interceptor that's why I use the use use
767:02 - Interceptor
767:03 - decator here we have file
767:06 - Interceptor they have already created
767:09 - this file Interceptor and you got to
767:12 - provide the name of your file and here
767:15 - we will have the upload file decorator
767:18 - the type should be express. multer do
767:21 - file that's it then it will log the file
767:25 - when you send the API request from Front
767:27 - End application or Postman to upload a
767:30 - file it will receive the
767:33 - file so this decorator indicates that
767:36 - the method should use the f file
767:39 - Interceptor
767:40 - Interceptor to handle the file uploads
767:44 - the string file inside the file
767:46 - Interceptor decorator refers to the
767:48 - field name in the request
767:55 - body now we're going to implement this
767:57 - file upload
768:00 - method first of all we have to install
768:03 - the molter
768:07 - type I've already attached the started
768:11 - kit project or if you don't have an sjs
768:14 - project you can create a brand new
768:16 - project and start from them start from
768:19 - there we have
768:22 - installed uh package now I'm going to
768:25 - copy the same
768:28 - code and I'm going to do it here inside
768:31 - the app
768:37 - controller
768:43 - we also need to import file Interceptor
768:46 - from nestjs platform
768:49 - Express whenever you need to upload the
768:53 - file you have to use the use Interceptor
768:56 - and they have created the file
768:58 - Interceptor the name of the file here
769:02 - you will provide the molter options when
769:06 - you worked with molon if you already
769:09 - work with molter opt molter package
769:13 - these are the options are same these
769:17 - options are same when you work with
769:18 - molter
769:19 - package so I'm not going to do it
769:23 - here and we will have upload file now we
769:26 - need to test it I'm going to start the
769:30 - project we need a postman to send the
769:32 - API
769:35 - request in terms of
769:37 - file
769:45 - so here I'm going to send
769:47 - request to the upload and we have to
769:51 - provide the
769:52 - file select the body and you got to
769:57 - provide file you can select the file
770:01 - from here a body and a file and then you
770:06 - have to select the file
770:12 - I'm going to use this PNG file you can
770:15 - choose any
770:19 - file B request I have to remove this one
770:22 - now I'm going to send request you can
770:25 - see a file has created successfully
770:29 - actually uploaded this is the original
770:31 - name this is the field file but I want
770:35 - to save this file some somewhere in my
770:39 - folder you can create a disc folder and
770:42 - you can save save that save there to
770:46 - implement this logic you going to
770:49 - provide these two
771:05 - options actually I'm going to copy the
771:07 - complete
771:10 - file intercept use
771:15 - intercept I'm going to copy the complete
771:18 - use Interceptor now it looks
771:20 - good so we have to import this package
771:24 - from disk
771:26 - storage I think I can get that from
771:29 - molter
771:33 - package
771:36 - molter disktop
771:40 - storage now it looks
771:46 - good so it will create the upload folder
771:50 - for me and here I will have the files
771:55 - folder now we're going to send the
771:58 - request to save upload the
772:02 - file and you can see there is a file
772:06 - inside the upload folder and inside the
772:09 - files we have create song mutation. PNG
772:12 - file you can also add a
772:19 - validation let's say you can
772:22 - say I only want
772:25 - to accept PNG
772:29 - file how can you add a
772:32 - validation I can say upload
772:36 - PNG you can do the validation upload PNG
772:41 - [Music]
772:43 - file you can implement the validation
772:46 - here let me copy the validation
772:50 - logic they provided the pars file pip
772:54 - Builder what this pipe Builder will do
772:57 - this is a custom utility that creates a
773:01 - pipe for validating uploaded files if
773:06 - you want to add a maximum size you can
773:08 - can accept you can also do that but I'm
773:10 - not going to implement
773:12 - that we need this
773:16 - logic inside the upload
773:25 - file
773:31 - here I also added an error status code
773:35 - if error comes it is going to log this
773:38 - error
773:39 - message unprocessable
773:42 - entity now it can accept only the PNG
773:46 - file type I've applied the pipe to add
773:51 - PNG validation let's test it
773:55 - out if I add upload
773:59 - PNG if I add invalid file what will
774:05 - happen I'm going to add jpack
774:11 - I got the
774:13 - error oh upload Das
774:17 - PNG I got the error for double to
774:21 - unprocessable
774:31 - entity if I provide the valid file which
774:34 - is
774:35 - PNG what will happen
774:47 - can get that from
774:50 - here this is the PNG
774:53 - file now the file has uploaded
774:56 - successfully
775:07 - here
775:12 - one more thing we got to return the
775:15 - message I forgot to return the
775:18 - message
775:19 - from here
775:22 - to also need to upload the
775:26 - message file uploaded
775:35 - successfully let's test it out
775:54 - out this is the PNG
775:58 - file you should see the
776:02 - message file uploaded
776:06 - successfully and you you will see your
776:09 - file
776:12 - here in this lesson I'm going to teach
776:15 - you the concept of custom
776:20 - decorator if you want to add additional
776:22 - functionality to a class to a method you
776:25 - can use custom decorator just like we
776:29 - did with app module app controller we
776:32 - use decorator a lot when you look at the
776:35 - app module here we have used a decorator
776:40 - this module decorator in the controller
776:43 - app. controller we have controller
776:46 - decorator it mean this decorator is
776:49 - adding an additional functionality to
776:52 - the app
776:54 - controller like they are adding
776:58 - metadata this controller can have
777:02 - functions attributes all of the
777:07 - stuff
777:09 - so you can improve your modularity and
777:13 - reusability with the help of custom
777:15 - decorator you can organize code very
777:20 - easily you can extend Nest functionality
777:23 - by adding custom
777:27 - decorator here we're going to use custom
777:30 - decorator I have a basic simple example
777:33 - we're going to create our own custom
777:35 - decorator the user decorator.
777:38 - this you use pram decorator so I can
777:43 - apply it on a
777:45 - parameter and I'm using a function this
777:48 - function is accepting to argument data
777:50 - it should be unknown type and we are
777:53 - getting the execution
777:55 - context and I can get the request from
777:58 - this execution context here I'm am
778:02 - adding a user into the request. user
778:06 - when you have implemented auth tication
778:08 - you can create a custom decorator for a
778:11 - user imagine you can get
778:14 - this request. user from a Json web token
778:18 - and Json web token Parts the token and
778:21 - found the user you can imagine that but
778:24 - I hardcoded it and return request.
778:29 - user yeah this is The Decorator Factory
778:32 - function it takes to parameter data and
778:35 - the Conta execution
778:37 - context
778:38 - and now we're going to create a new user
778:40 - entity here we have applied a user
778:44 - decorator let's say this is this is
778:46 - authenticated route only authenticated
778:49 - user can access this route so I would
778:53 - like to get the user so you can use a
778:55 - user
778:56 - decorator and the user entity this user
778:59 - decorator is going to execute this
779:01 - function and this function will be
779:04 - executed and it is going to add a user
779:07 - in the request EST object that's how you
779:11 - can implement the custom decorator let's
779:15 - create a new file here I can say a user
779:22 - decorator
779:26 - decorator. I'm going to copy my
779:29 - code user
779:32 - decorator you can use any name
779:36 - here I also need to create another
779:40 - entity this time I'm going to call user.
779:45 - entity
779:49 - TS now we're going to apply The
779:52 - Decorator on a
779:55 - user do I have a route I can create the
779:58 - complete route to implement this user
780:05 - decorator copy this and and paste it
780:11 - here and we need these two
780:22 - Imports now we have to test our
780:27 - application so whenever you need to get
780:30 - a user inside any function all you need
780:34 - to do is to apply the decorator
780:39 - here you can apply The Decorator upload
780:41 - file you can apply decorator here it
780:45 - depends on your use
780:50 - case so my application is
780:59 - running I'm going to create a new HTTP
781:02 - client. HTTP file to send API
781:06 - request can say that find
781:10 - user only based on
781:14 - ID we have to send the get
781:19 - request 3,000 slash user and you got to
781:25 - provide a user
781:31 - ID now you can see I got a user so this
781:37 - decorator a user decorator is calling
781:40 - the user decorator function and this
781:43 - function is getting a user or setting a
781:46 - user to the request object and returning
781:49 - the
781:51 - request get decorator is nothing it's
781:55 - just like a function here in our
781:57 - case I'm running a function
782:02 - here uh in this lesson I'm going to
782:04 - teach you if you want to schedule any
782:07 - method or any function you can do with
782:10 - grown
782:12 - task uh let's uh if you want to schedule
782:15 - any task let's say you want to run you
782:18 - want to
782:20 - calculate the expiry date of a license
782:23 - let's say your trial version is going to
782:27 - be expired after 7 days You're Building
782:31 - this type of SAS application you your
782:34 - company provides 14 days free trial
782:38 - and the trial version will be expired
782:41 - after 14
782:42 - days what your application will do under
782:46 - the hood application will run a crown
782:50 - task it will execute every day in try to
782:54 - find out the expiry date for the current
782:57 - user if user has used software for 14
783:01 - days your Chown to will determine that
783:05 - and it will send the notification to the
783:07 - user into your application hey this user
783:11 - has used 14 days free trial and you may
783:14 - must have a logic or a code to handle
783:18 - this
783:19 - situation maybe you can send the credit
783:21 - card information to
783:22 - upgrade so nestjs provide a package to
783:26 - implement this type of
783:29 - functionality we're going to we're going
783:31 - to we're going to install a couple of
783:33 - packages first you
783:36 - need next
783:38 - JS
783:41 - schedule
783:43 - and you also need or I can install it
783:53 - here
783:55 - types of
783:59 - grown actually I need a type as a Chone
784:03 - SE as a Dev dependency let's first
784:05 - install this package
784:15 - now we
784:16 - install the
784:19 - types or I can use the minus
784:22 - t and types
784:32 - Chone NJ has provide a schedule
784:36 - module from nestjs casual package I have
784:40 - to import it if you want to use this
784:43 - package let's import the module schedule
784:47 - module I have to register it or create
784:51 - this
784:55 - module this root module will initialize
784:58 - this casual
785:00 - module and it will register any
785:02 - declarative chrone jobs timeouts
785:06 - interval that exist assist within your
785:09 - application right now we did not Define
785:11 - any Crone task if you have defined Crone
785:15 - task this for root will initialize all
785:18 - of your crown
785:20 - task and registration occurs when the
785:23 - application when the own application
785:25 - bootstrap life cycle hook
785:29 - occurs now we're going to declare some
785:34 - cras this cronas will run the function
785:37 - autom automatically we will specify some
785:40 - specific dat time when this Crown task
785:43 - will run it depends on your use case do
785:46 - you want to run this Crown task every
785:48 - week or every day or every 5 minutes or
785:51 - every 10 minutes or every hour it
785:53 - depends on your use use case now we're
785:57 - going to create a new task
786:02 - service let's create a new to
786:06 - service
786:13 - so let's define our first gr task in
786:17 - task
786:21 - service private read only logger it will
786:26 - log some
786:29 - message task
786:31 - service do
786:35 - name if you want to Define a crown task
786:38 - you need a decorator in the previous
786:40 - video I taught you what are the benefits
786:44 - of decorator like I can extend the
786:47 - functionality of a function by adding
786:49 - the Chone
786:52 - decorator here you will provide your
786:55 - time path time date something like
787:01 - that so start start
787:05 - start you can learn learn more
787:09 - about this strategy by looking at Crown
787:15 - task schedu Nest or
787:36 - npm
787:49 - you can play around with these timing
787:53 - settings from this package this package
787:56 - you can learn more
787:58 - about how can you set the current dat
788:01 - stuff like
788:05 - that here the first star
788:09 - represent second the second star
788:13 - represent minute the third star
788:17 - represent R and the fourth star
788:20 - represent the day of the month and the
788:24 - fifth star represent the
788:26 - month and the last star represent the
788:29 - week
788:32 - day did you get that let's say I want to
788:35 - run the crown task after every 10
788:40 - seconds so what I want to do I want to
788:43 - log a simple message after every 10
788:49 - seconds and say Myron
788:55 - task I'm going to log a message this do
789:02 - logger not a
789:04 - throw this. logger do
789:08 - debug called when the
789:12 - current second is
789:17 - 10 let's try to test the
789:20 - application I have registered the
789:23 - schedule module here this for will will
789:27 - initialize this method and we set up the
789:31 - configuration to run after 10
789:34 - second let's do
789:36 - that
789:50 - you can
789:53 - see it has run this debug after every 10
790:06 - seconds
790:14 - what if I change the setting to
790:36 - five
790:38 - now after 5 Seconds it has
791:06 - executed
791:36 - e
791:39 - actually it is running called when the
791:43 - current second is actually it is wait it
791:47 - will wait for 1 minute and 5 Seconds
791:52 - then it will
792:03 - run wait for 1 minute and 5 Seconds
792:36 - is
792:38 - now you can see at
792:42 - 519 and then it has ran after a minute
792:46 - and on the fifth
792:49 - second what if I run this cronas after
792:54 - every
792:54 - [Music]
793:01 - second you can see it's running after
793:04 - every
793:05 - seconds so I can use
793:10 - that called when the
793:14 - crun C call that's
793:30 - it so it will wait for a minute and a 15
793:36 - seconds
793:49 - if you want to do a little bit setting
793:52 - let's say I want to run every hour at
793:57 - the start of five uh at the start of the
794:01 - fifth
794:02 - minutes but it depends on you how you
794:05 - want to run
794:12 - this will
794:13 - run
794:14 - after
794:17 - every
794:30 - minute
794:33 - yep after every minute it's
794:35 - running
794:38 - this is how you can play around with
794:39 - crown
794:43 - task in this lesson you're going to
794:45 - learn cookies cookies are small pieces
794:49 - of data dat a server sends to a user
794:52 - browser while the user is browsing a
794:57 - website these cookies are stored in user
795:00 - device and are used to store information
795:03 - about the user interaction with website
795:08 - if you look up the Google Chrome you
795:11 - will see the developer tools and you can
795:14 - find the application
795:19 - tab here you will find all of your
795:21 - cookies if you have
795:26 - stored we have only single cookie you
795:30 - can Implement also cookie based
795:31 - authentication just like we did in
795:33 - authentication module we saved at
795:37 - Json web token into a local
795:42 - storage but if you were if you work with
795:46 - a local storage or front-end application
795:49 - you can store your Json web token in
795:52 - this storage but you can also use a
795:55 - cookie and you can save your token in
795:57 - encrypted
795:59 - format so these are all the use cases of
796:02 - cookies like most of the time when
796:05 - you when you access or fetch or look at
796:11 - the same look at the website or when you
796:13 - visit the same website again and again
796:16 - the next time it tries to fetch the data
796:20 - from your cookies it has saved all of
796:23 - your
796:25 - authentication Lo all of your password
796:27 - in cookies when you go to the Google
796:29 - password
796:31 - manager where all of this data is stored
796:34 - all of this data is stored in your cook
796:38 - is remember when you look at the history
796:42 - or let
796:44 - me you look at the
796:46 - history if you want to delete all of
796:50 - your data it will also ask you hey do
796:54 - you want to do you want to delete all of
796:56 - your cookie stuff you have data inside
796:59 - the
797:05 - cookie so you can save any token inside
797:08 - the
797:10 - cookie let me talk about the use cases
797:13 - of
797:14 - cookies you can manage user sessions
797:18 - let's say if you want to expire a user
797:20 - session after 30 days or after 24
797:25 - hours you can have that type of logic in
797:29 - cookie and this cookie will be stored
797:31 - here inside the application and the
797:33 - cookies
797:34 - tab if you have any type of shopping
797:38 - cart application you can also do a
797:40 - little bit saving in
797:43 - the in the cookies let's say a user has
797:47 - uh add added three to four items to the
797:50 - checkout and he left the website and
797:53 - then you can send user hey you left
797:56 - something a user can see all of his
798:00 - checkout
798:05 - items you can do some type of tracking
798:08 - and analytics you can do authentication
798:11 - like cookies can help with
798:12 - authentication and security by storing
798:15 - tokens or other information that
798:17 - verifies a user
798:21 - identity you can use load balancing
798:24 - State Management and cashing stuff with
798:26 - cookies now I'm going to implement the
798:29 - cookies in NS project you got to install
798:33 - these two packages I have already
798:35 - installed them
798:37 - I've already installed in my
798:39 - package.json file this is the cookie
798:41 - parser you need and then you also need a
798:44 - typing for cookie parser go ahead and
798:47 - install
798:51 - them all right our next step is to
798:53 - register a cookie parts sir in main.ts
798:57 - file this is our main entry file here I
799:00 - have registered a cookie parser you can
799:03 - import it as a
799:04 - star and here if you want to add add
799:07 - your secret you can do it here or if you
799:09 - want to
799:10 - add uh some logic or decode something
799:14 - like that this is the option from a
799:17 - cookie package you can go to cookie
799:24 - parser so this package is similar to
799:27 - this one this one cookie parser but you
799:30 - can look at the documentation what type
799:32 - of options you
799:35 - have
799:40 - now our next step is to set the
799:44 - cookie I'm going to create a new route
799:46 - to set the cookie and we need a response
799:51 - from the nestjs comment and response
799:54 - type from the Express package here I'm
799:57 - allowing the framework you can set the
799:59 - cookie I am I'm going to set the cookie
800:02 - cooking token name encrypted cookie
800:04 - string something here it's a key value
800:06 - PA here and I'm sending a message cookie
800:08 - saved
800:09 - successfully here here I'm trying to log
800:12 - all of your cookies and return cookies
800:15 - in the get route now we need to test the
800:18 - application when you look the app
800:23 - controller here let's say I'm want to
800:25 - set a new
800:27 - cookie I've already saved that cookie in
800:30 - my application when you look at the
800:32 - Local Host colon application tab here we
800:34 - have the cookie let's say I want to set
800:36 - a new cookie it should be let's say a
800:41 - user
800:42 - token or authenticated token something
800:46 - like that JWT
800:48 - or
800:51 - JWT encrypt something like
800:57 - that yes jw.
801:03 - iio so what I want to do I want to
801:08 - so
801:12 - let's can I do
801:17 - that let's add this payload
801:23 - here or you can say I want to add a user
801:27 - ID let's
801:28 - say
801:30 - token I'm going to add a user
801:35 - ID
801:38 - let's say a mongod DB
801:44 - ID or you can say user
801:50 - ID so let's send the request from our
801:53 - browser to first set the
801:55 - cookie so I can set the request please
801:59 - set the cookie cookie saved successfully
802:03 - and you can see your user ID here this
802:06 - one but it did not
802:13 - encrypt but it did not save as
802:16 - encrypted you have to save your
802:19 - encrypted value here let's say I'm going
802:21 - to copy this
802:24 - token and you got to paste it
802:27 - [Music]
802:35 - here now I have an encrypted
802:40 - value so cookie saved successfully what
802:43 - if I try to get the
802:46 - cookie get all of my
802:49 - cookie it is going to give me the user
802:52 - ID and cookie token
802:56 - name that's how if you want to implement
802:58 - cookie based authentication you can do
803:03 - that if you want to implement High
803:06 - intent intensive task then you need
803:09 - cues High intensive task
803:13 - mean sending emails generating reports
803:17 - processing images or any task that can
803:20 - be offloaded from the main application
803:27 - flow with the help of cues you can
803:30 - manage in process task in the background
803:33 - without blocking the main application
803:35 - execution
803:41 - so you can use cues in task
803:46 - generation when you you identify task
803:49 - that can be processed
803:51 - asynchronously let's consider sending an
803:54 - email after a user register instead of
803:57 - sending email directly with the
803:59 - registration endpoint you can push the
804:02 - task of a sending email to a
804:05 - queue
804:10 - so this task is executed in the
804:12 - background separate from the main
804:14 - application thread this this ensure that
804:17 - the main application remains responsive
804:20 - and does not get blogged by the time
804:23 - consuming
804:25 - tasks so if you have highly CPU
804:28 - intensive task then you can use
804:33 - qes let's dive into the implementation
804:37 - of cues in nestjs nestjs provided the
804:41 - bull package they have written their own
804:44 - implementation by using the original
804:46 - bull package you have to install the
804:49 - package
804:50 - first I'm going to install the nestjs
804:57 - bll I also need to install npm B npm
805:02 - install B the simple bull
805:05 - package nextjs pull is using the redish
805:10 - under the
805:13 - hood so you need radish caching
805:20 - Library make sure you have Docker in
805:23 - your
805:25 - system we're going to use Docker to pull
805:29 - redish image I'm not going to install
805:32 - redish separately so that's why I'm
805:34 - going to use docker
805:40 - now let's create a new module our
805:44 - application what we want to do we're
805:46 - going to create a fake implementation to
805:49 - convert do wave audio file to MP3 we're
805:54 - going to write fake implementation let's
805:56 - say you have a use case where you want
805:58 - to convert do wave file to MP3 or you
806:03 - have an application where you need this
806:05 - functionality you want to convert video
806:07 - MP4 to MP3 in that case you need a
806:15 - q
806:17 - let's create a new audio module we're
806:20 - going to write implementation here to
806:22 - convert do wave file to
806:26 - MP3 then we need a docket
806:30 - compose we're going to use redish
806:35 - image
806:37 - now we're going to set up Ries in the
806:39 - docket compose file let's create a new
806:42 - file inside the root
806:48 - directory I'm going to do it here docket
806:53 - compos
806:56 - yl let's rename it to
807:02 - yl so we have to in start the docker
807:07 - compose my Docker is running
807:10 - now let's install Docker
807:13 - compose
807:15 - up it will pull the redish image from
807:18 - the docker Hub but I have already pulled
807:22 - Docker radish
807:24 - image so my
807:27 - radish server has
807:31 - started I think I've already installed
807:34 - another extension to work with redes if
807:38 - you want you can install
807:41 - that here you can see the redis I have
807:45 - installed this one database manager for
807:48 - my SQL Maria B post sqlite and redis
807:53 - here you will see the database if I try
807:56 - to create a connection for the
807:58 - redes Local Host
808:01 - 6379 that's my port so I can connect now
808:06 - now you will
808:07 - see all of my
808:10 - databases so this is my current or the
808:13 - latest I'm going to delete the rest of
808:16 - the
808:16 - other now I have the empty let's remove
808:23 - everything let's
808:26 - connect so I have the audio
808:30 - que so get rid of this
808:33 - one now we have the empty data
808:42 - SP now we need to
808:44 - register a bull
808:47 - module so in the app
808:51 - module I'm going to register it
808:56 - here your module
809:01 - and I'm going to do it
809:04 - here make sure you imported a bull
809:11 - module bull
809:22 - module
809:29 - import from Nest
809:34 - CHS SGS Bull and bull
809:42 - module so I'm going to open a new tab to
809:44 - run my
809:47 - application next we need to register a
809:52 - queue inside the audio module you will
809:56 - find the audio module here so we got a
809:59 - register it
810:01 - here make sure you imported the bull
810:05 - module and I'm going to copy
810:08 - that and let me paste it
810:12 - here so this register Q This method is
810:16 - used to register a queue with your
810:18 - within your application it takes an
810:21 - optional object as an argument to
810:23 - configure the que we have provided the
810:25 - name of our Q audio
810:28 - q and this is the name you will see the
810:33 - name here
810:37 - here it should be the audio Q this one
810:40 - where is my redish
810:43 - yep you will see the audio queue
810:48 - here let's move forward now we're going
810:51 - to create a convert end point I'm going
810:54 - to copy
810:56 - that into audio
811:01 - controller and
811:04 - I'm so we have audio Q let's imagine we
811:08 - would like to convert v file into MP3
811:11 - this is my I'm just writing the fake
811:14 - implementation we are not writing the
811:17 - exact logic to convert the file but you
811:20 - can do that this is just a file name
811:22 - this is an optional object so this will
811:27 - add a new entry inside the
811:30 - Q so we have injected the audio q i got
811:35 - this Q from from The Bu package the type
811:38 - now we need a processor to process the
811:42 - queue let's define a new audio
811:47 - processor audio.
811:52 - processor. it would be a service or
811:54 - provider so we got to register it here
811:57 - inside the
812:00 - providers
812:01 - AIO
812:04 - processor
812:08 - so
812:09 - here when you want to process this when
812:12 - the application wants to process it is
812:15 - going to call this handle convert this
812:19 - job will take this argument as a job
812:24 - here inside the audio
812:27 - processor so I'm just trying to do the
812:29 - log here let's run the
812:32 - application to convert W file to m B3 we
812:36 - have to send the convert request
812:39 - so in the HTTP
812:42 - client I'm going to send the post
812:47 - request convert let's say dot v file to
812:54 - MP3
812:59 - post HTTP Local Host Callum 3000 SL
813:04 - audio SL convert I don't need to provide
813:07 - any argument but if you want to provide
813:09 - argument or or request body you can do
813:13 - that now you can see it has run
813:18 - successfully I got this message starting
813:22 - wave file inside the audio
813:27 - processor here starting start converting
813:31 - v file to MP3 and I got the object which
813:36 - is sample. W file which which I have
813:39 - passed here whatever you pass here it
813:42 - will be received here inside the job.
813:45 - data and finally it has completed this
813:47 - one if you have any type of logic to
813:50 - convert P file to MP3 you will Implement
813:53 - here
813:54 - here but what if I look up the
813:58 - database do you have this
814:01 - one convert yep you can see the bull and
814:05 - we we have the audio Q this is our
814:08 - message I can show
814:12 - you here you can see the name is
814:16 - convert which we named here the convert
814:21 - this one q key key is here
814:28 - convert
814:29 - convert and the data is sample. W file
814:33 - and all of these metad data
814:37 - what if I provide additional data let's
814:40 - say ID which is one so it is going to
814:42 - save also
814:50 - ID let's run the request you can see I
814:54 - got the file and
814:56 - ID and Let me refresh
815:04 - it
815:17 - I'm going to
815:21 - connect uh you can
815:23 - see file sample
815:26 - do wave and you can see the ID the name
815:30 - is convert and the audio CU which is we
815:34 - have named here here inside the audio
815:38 - module this is the audio
815:44 - Q in this lesson I'm going to teach you
815:47 - the event
815:49 - emitter in nextjs event emitor is a
815:52 - mechanism that allows different parts of
815:54 - your application to communicate with
815:57 - each other and even driven
816:01 - approach so you can learn more about you
816:04 - can do communication between module
816:06 - Services components or classes under the
816:10 - hood nestjs uses event emiter to
816:13 - collaborate with these services and
816:15 - modules and
816:16 - components so an event emitter works
816:20 - with Publisher and subscriber pattern if
816:22 - you heard about this design pattern or
816:24 - you have used this design
816:30 - pattern now we're going to talk about
816:32 - some practical use cases of event
816:34 - emitter you can do module communication
816:37 - you can send the notification
816:40 - system we're going to use this use
816:43 - case in the previous video we have
816:46 - converted wave file to
816:49 - MP3 now I want to convert I want to send
816:52 - the notification if the file has
816:54 - successfully converted we need to send
816:57 - the notification to the user we can also
817:00 - use from for Real Time updates if you
817:04 - have any plugin syst system you can do
817:06 - with the help of event emitter you can
817:08 - achieve logging and monitoring you can
817:11 - do error handling and Reporting this one
817:13 - is also useful you can Implement in user
817:17 - authentication and
817:21 - authorization for example authorization
817:24 - service could emit an event when user
817:26 - logs in and other parts of application
817:29 - can respond Accord accordingly let's say
817:33 - user has logged after 10 days your you
817:37 - can your system or your application can
817:40 - have
817:41 - notification you can also Implement in
817:44 - the caching and management in our case
817:47 - we're going to take example from our
817:48 - previous
817:50 - example let's say you want to send the
817:53 - notification when w file converts
817:55 - successfully into MP3 format you can use
817:59 - event emitter to send the
818:04 - notification
818:06 - you got to install the package first
818:08 - nestjs event
818:11 - emitter and Next Step you got to
818:13 - register the event emitter in the app
818:20 - module let me change my
818:26 - Branch
818:30 - here
818:32 - event emitter Pro
818:36 - we got to create install event emitter
818:40 - again because I was in a different
818:43 - branch let's install
818:52 - it we have event
818:56 - emitter let's register it in the app
819:02 - module I'm going to do it here
819:08 - we have to import the event emiter
819:14 - module I have to import it manually
819:19 - event emitter
819:23 - module from
819:26 - nestjs event
819:28 - emiter that looks good we have
819:30 - registered the event emitter module this
819:33 - will register all of your event listener
819:36 - or or create all of your event listener
819:39 - we will have audio converted
819:42 - listener it's a service it's a
819:45 - provider this we have just a method it
819:48 - will accept the event and the audio
819:51 - event we will create the type this is
819:54 - the name of the listener or the name of
819:56 - the event that's why I used on event
820:00 - here when you emit the event this audio
820:04 - converted event this function will be
820:08 - called we're going to emit this event in
820:11 - the handle convert in the previous video
820:14 - we used this method to convert fave into
820:18 - MP3 so when you emit this event this
820:21 - method will be
820:23 - called so you can have any type of logic
820:26 - here maybe you will have an email
820:29 - service and your email service will have
820:31 - a method to send email let's create a
820:35 - new file I'm going to copy all of the
820:38 - code this is a provider we're going to
820:40 - in we're going to create inside
820:43 - the
820:47 - audio
820:48 - converted what's the name of the file
820:51 - audio converted
820:55 - listener I can say audio do
821:01 - converted or you can say audio
821:06 - converted
821:13 - listener. so we have this
821:18 - file we did not create this type let's
821:21 - create this
821:24 - type in audio
821:27 - folder I can say
821:31 - audio actually we can do it in an events
821:37 - folder we're going to store all of the
821:40 - types
821:42 - audio converted
821:45 - event. it's nothing it's just a type for
821:48 - types typescript
821:52 - class it looks good make sure you
821:55 - register your provider in the audio
821:58 - module so audio
822:02 - converted
822:04 - listener
822:06 - now we need to import we need to emit
822:08 - this
822:11 - event in your handle convert we have
822:15 - done it in the
822:16 - processor while converted successfully
822:19 - and you can send a
822:22 - message make sure you
822:26 - have import or inject event
822:32 - emitter event emitter
822:37 - event emitter
822:40 - 2 from njs event emitter
822:45 - package
822:48 - njs event
822:50 - emiter
822:52 - oops event emiter I don't know why they
822:55 - use two so I'm going to use the same
822:57 - stuff two event emitter
823:01 - to and we have emit this
823:05 - event this
823:08 - one now we have to test the application
823:12 - let's run the
823:14 - application I think do I need a
823:18 - Docker let's run the
823:23 - application yes I need a
823:26 - Docker let's install the uh let's start
823:30 - the docker first because we were using
823:34 - redes when we were building this Q so
823:40 - this Q is dependent on bull module is
823:43 - dependent on
823:45 - rades let me start my
823:54 - Docker now my Docker is running now
823:57 - let's run the application to test this
823:59 - event
824:03 - emitor we have to send the API request
824:06 - to convert fa file to
824:09 - MP3 it should log the message actually
824:12 - it should run this
824:15 - event this
824:33 - meth
824:38 - let's send the
824:45 - request I'm not able to send the request
824:50 - why saying
824:53 - waiting I think I did something wrong
824:57 - here look at the audio
825:01 - processor or audio
825:03 - controller
825:12 - wa I think it is not calling this method
825:17 - or emitting this
825:20 - method emitting this IM
825:30 - event oh I think we did not stop part
825:36 - that is
825:43 - server let's do it I'm going to send the
825:55 - request connect with
826:00 - r
826:03 - so it has X executed
826:07 - successfully and I got the message
826:10 - notification has sent to the user that
826:14 - file is converted
826:16 - successfully so I also loged the
826:19 - event that looks good we have
826:22 - successfully
826:23 - achieved our desired use
826:27 - case here it has emited the event I also
826:31 - passed a data object from the Q job.
826:37 - data which we were sending from here so
826:41 - I received the same
826:44 - object inside the event
826:50 - listener here I received the same event
826:55 - here and here I locked the event the
826:57 - first one is the event and the message
827:00 - notification has sent to user
827:02 - successfully this is how you will
827:05 - Implement event emitter in
827:13 - nestjs in this lesson I'm going to teach
827:16 - you the streaming in
827:19 - sjs streaming is the process of sending
827:22 - or receiving data in small chunks called
827:26 - streams rather than sending or receiving
827:29 - the entire data at once the concept is
827:33 - based on stream API in
827:36 - nodejs and is utilized for more
827:40 - efficient data handling especially when
827:44 - dealing with large amounts of data such
827:46 - as files Network request or realtime
827:50 - data
827:53 - Transmissions you can use streaming for
827:55 - file upload and file download you can do
827:59 - realtime communication if you have to
828:02 - build a media streaming type application
828:05 - like Netflix then you need streaming
828:08 - API API responses reading and writing
828:12 - from
828:14 - stream when processing data from sources
828:18 - that generate data
828:20 - incrementally such as reading log file
828:24 - or parsing large XML or Json
828:27 - documents you can do some data
828:29 - aggregation server sent events database
828:32 - operations proxy servers all of these
828:35 - practical use cases of streaming in this
828:40 - video I'm just showing you how to
828:44 - download a file with the help of
828:47 - streaming we need a nest controller a
828:51 - file controller here I will
828:54 - specify a a a method it will download
829:00 - the file from this crun project as a
829:04 - package.json file it is going to save in
829:08 - my computer this is another customized
829:11 - way to download the
829:14 - file when you download the file with
829:17 - this method it will download the exact
829:20 - package.json file here it will not
829:23 - download with extension only text file
829:26 - let me show you the difference between
829:28 - them let's create a new
829:33 - controller open the file controller let
829:36 - me import some
829:40 - dependencies and we need to use this
829:43 - method to download the file I'm going to
829:46 - create a new method here let's run the
830:01 - application let's try to send the
830:04 - request to the
830:07 - file file we have the endpoint file and
830:11 - the stream
830:14 - file file and stream
830:19 - file now it is going to
830:22 - download the package.json
830:26 - file you can
830:29 - see it is giving just only a stream file
830:34 - it did not download with package.json
830:37 - file if I open the file you will see it
830:41 - is nothing more it's just a simple text
830:43 - file in a Json
830:45 - format but we going to we want to
830:48 - download the exact Json file you can do
830:51 - the same stuff when you down when you
830:53 - want to download
830:55 - images or video you have to specify here
830:59 - the content type should be video or
831:01 - audio it depends on your use case and
831:04 - you also can provide the name of your
831:08 - file just like we did the package.json
831:10 - file you have to do it content dispo dis
831:16 - disposition now we're going to copy the
831:18 - same part method and place it
831:23 - here it will return a streamable file I
831:27 - have created the stream by you joining
831:30 - the path which is this one I'm referring
831:33 - to package.json file
831:35 - file and finally I'm setting the
831:39 - response by setting application Json my
831:42 - file name would be this one act as the
831:44 - attachment and finally it is going to
831:46 - return the streamable file now if I go
831:49 - to this
831:51 - endpoint file and/ stream file
831:56 - customize what will
831:58 - happen now it is going to do stream file
832:02 - customize. Json on not not it should be
832:06 - Json now it is going to see you will see
832:10 - the package.json file I already
832:12 - downloaded the package.json file when we
832:15 - were when I was practicing this I can
832:18 - replace that you will see the
832:21 - package.json
832:25 - file I have opened the file in my
832:29 - Mozilla
832:31 - Firefox you can see your the package
832:34 - Json file we have scripts we have all
832:36 - the dependencies and we have the dev
832:39 - dependencies this is how you can
832:40 - download any file if you have images you
832:43 - can specify your image format or you can
832:46 - name the file name or your image file
832:49 - name you can also set your image content
832:55 - type in this lesson you're going to
832:58 - learn this session in
833:00 - sjs session refers to the concept of
833:03 - maintaining stateful data between
833:07 - consecutive request from the same client
833:10 - a session allows you to send allows you
833:13 - to store and retrieve user specific
833:16 - information on the server server on the
833:19 - server across multiple request typically
833:23 - using cookies to identify the session if
833:26 - you have used session based
833:28 - authentication in your project the
833:30 - concept is
833:32 - same you can use session to maintain the
833:36 - authentication state of a user when a
833:39 - user log in logs in session can be
833:43 - created with their authen authentication
833:45 - data and subsequent request can be
833:48 - authenticated based on the session you
833:51 - can use session in authorization user
833:54 - preferences shopping cards user tracking
833:57 - caching
833:58 - personalization and form data
834:03 - persistence we going to use the express
834:05 - session let's install these two
834:09 - packages I have already installed in my
834:12 - package.json
834:15 - file
834:17 - session Express session and the next
834:20 - package you need type of Express session
834:24 - then our next step is to register a
834:27 - middleware when you go to main.ts you
834:30 - got to register it
834:32 - here AB do session make make sure you
834:34 - import your session from the express
834:37 - session you can use any secret key you
834:41 - can also set resave you can read the
834:44 - documentation of resave what this resave
834:46 - is doing you can also read the
834:49 - documentation of save
834:54 - uninitialized you can find documentation
834:57 - here from the express
834:59 - session when you check a save or
835:03 - resave here you will find the
835:05 - documentation
835:08 - uninitialized initialized you can also
835:10 - find the documentation of
835:14 - uninitialized next we have app
835:18 - controller here I'm going to create a
835:20 - simple route to login let's say uh a
835:25 - user wants to log in when logged in
835:28 - successfully we have verified the user
835:30 - from the database then you can set the
835:34 - user into the session I have set the
835:37 - object ID and the username and when
835:40 - later user wants to access his profile
835:44 - he can do that because we have saved the
835:47 - user in the session so here if there is
835:49 - a user in the session it is going to
835:51 - return user else not logged in you can
835:55 - test it simple by sending the login
835:57 - request it is saying a user has logged
835:59 - in just like we did just like it did if
836:03 - I said if I try to retrieve the profile
836:06 - it is going to give me the profile
836:09 - because we have set that user when we
836:11 - were logged in this one now I got this
836:15 - hello with the user and the name this is
836:17 - how uh if you use Json web token we
836:20 - basically stored a Json web token in the
836:22 - storage but if you want to use session
836:25 - based authentication on front end you
836:27 - can do that