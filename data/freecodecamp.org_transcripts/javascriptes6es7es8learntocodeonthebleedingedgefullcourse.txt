00:05 - all right ladies and gentlemen welcome
00:07 - to introduction to es6 and you know we
00:10 - might want to actually call this es6
00:12 - plus because i'm going to throw in some
00:13 - es7 and 8 features that i think are that
00:17 - are good and exciting and that you
00:19 - should know as a javascript developer if
00:21 - you're a little unfamiliar with how
00:22 - javascript gets new
00:24 - additions to its programming language
00:26 - the ecmascript foundation who runs
00:28 - javascript at the end of the day every
00:30 - year they do an update and they release
00:33 - new content es6 was 2015 es7 2016 es8
00:39 - 2017
00:40 - and so we're going to be talking about
00:42 - some of the latest additions to the
00:44 - language
00:45 - over 17 lessons and four challenges i
00:48 - will be your host if you will for this
00:50 - course my name is dylan israel i am a
00:52 - content creator on youtube i also have
00:54 - udemy courses scrimba courses i'm also a
00:57 - full-time front-end engineer and if you
00:59 - click this icon you can go find some of
01:00 - my videos and check it out but let's go
01:03 - ahead and dive into all the fun
01:10 - strings historically in javascript have
01:12 - been sort of a second-class citizen and
01:14 - have haven't got as much love as other
01:16 - programming languages might have in the
01:19 - past so what we're going to be talking
01:20 - about right now is template literals and
01:22 - what that's going to allow us to do is
01:25 - going to first i guess first let's go
01:27 - ahead and showcase how what the issue
01:29 - might have been with strings in the past
01:31 - let's say we had a word one and we set
01:33 - this equal to dylan
01:34 - and we had
01:36 - word let uh word two
01:39 - equal to
01:40 - my last name of israel so
01:43 - if we wanted to concatenate this in the
01:45 - past in some sort of constant if we want
01:47 - it doesn't really matter and we'll say
01:49 - full name
01:51 - if i concatenate this in the past we
01:53 - would have to do something like word one
01:56 - plus
01:57 - and then because we want it to look nice
01:59 - empty character plus word two and then
02:01 - we could of course console.log
02:04 - out
02:05 - word uh full name excuse me
02:09 - and you'll see here that we get this you
02:12 - know it's nice this isn't the prettiest
02:14 - way and it gets very
02:16 - um it gets very long very ugly very
02:20 - quickly right this is a pretty basic
02:21 - example so template literals uh allow us
02:24 - to
02:25 - using backticks
02:27 - let's go ahead and delete this using
02:29 - backpicks which if you're not if you
02:31 - can't find backpicks on the keyboard i
02:32 - didn't know where they existed they're
02:34 - to the left of the one key on on a
02:36 - keyboard we can use this dollar sign
02:38 - open curly brace closing curly brace
02:40 - pass in
02:42 - our value here put a space
02:45 - go ahead and pass in our value 2 here
02:48 - and you'll see when we save now we're
02:50 - able to print it out and we can do this
02:53 - much easier easier rather than having to
02:56 - repeat ourselves with pluses and spaces
02:58 - but that's not it there's a lot more
02:59 - that we can do with template literals as
03:01 - well
03:02 - template literals also give us an easy
03:05 - way of having variables say we wanted to
03:08 - have you know let num1
03:10 - equal to two
03:12 - and let
03:13 - num2 equal to three and we didn't know
03:16 - what they were going to be we can
03:17 - actually just have because this at the
03:18 - end then it's just javascript we have
03:20 - num1 plus num2 and we can do this this
03:24 - sort of concatenation of our variable
03:26 - similar to how we would normally do
03:28 - within our template literals
03:31 - now last but not least say we wanted to
03:33 - actually have a multi-line string and
03:36 - have that print out let's go ahead and
03:37 - comment this part out here and we'll
03:39 - create this variable called example
03:42 - in the past how we would have to do a
03:43 - multi-line string we'll do uh hello
03:46 - world
03:47 - hello and then we want world to be on
03:49 - next we'd have to escape
03:51 - the with the slash and then we can go
03:52 - ahead and add world
03:55 - like so
03:57 - and then um
03:58 - because of the way that console log
04:01 - works
04:02 - with uh it's not going to actually
04:03 - showcase it here as you'll see
04:06 - it's going to print it out on one line
04:08 - so what we'll have to do is we'll jump
04:09 - into our index html i'll create a little
04:11 - paragraph tag
04:13 - and what we're going to do is we're just
04:15 - going to give it an id
04:16 - equal to example
04:19 - and then in our index.js instead of
04:21 - console login we're going to go ahead
04:22 - and just target that so that we can
04:24 - actually see it being on multiple lines
04:27 - on the page so we're gonna say document
04:28 - get element by id
04:31 - and then we're gonna say example which
04:33 - is the id on the page or set this equal
04:36 - to our example variable let's go ahead
04:38 - and save it
04:42 - excuse me dot inner text
04:44 - because we need to we're trying to set
04:46 - the text value of that and then you'll
04:48 - see hello world on two lines although
04:49 - this slash n is really sort of obnoxious
04:53 - so how can we go about i'm fixing that
04:54 - well let's go and use our variables here
04:58 - with some string str uh with our some
05:01 - template literal so we use the backticks
05:03 - and notice
05:04 - on the first line here i'm going to put
05:06 - my
05:07 - name
05:08 - which would be word one and then on the
05:10 - second line
05:11 - i'm just going to go ahead and put word
05:14 - two on here and us formatting our string
05:17 - like this we'll also get dylan israel on
05:19 - multiple lines and if we obviously
05:21 - didn't want that we could do it on one
05:22 - line as well
05:26 - but it allows us a very easy way a very
05:28 - clean way to have multi-line strings
05:37 - one of my favorite additions to the
05:40 - javascript programming language has been
05:43 - destructuring objects so see here we
05:45 - have this personal information object
05:47 - with first name last name city state zip
05:49 - code a bunch of stuff now
05:52 - what we want to do is or what these
05:54 - structuring objects gives us the ability
05:56 - to is it gives us the ability to
05:58 - essentially write shorthand code as well
06:00 - as reassign values uh what what i mean
06:03 - by that let's go ahead and create a
06:05 - const here where you'll see we have this
06:07 - opening and cr and closing curly brace
06:09 - and what we want to do is we just want
06:11 - to put first name we want to access
06:13 - first name because personal
06:15 - information.first name every time we
06:16 - want to use it that's kind of a pain
06:18 - it's kind of a long name we're going to
06:20 - access last name and anything and we
06:23 - could access every property on here if
06:24 - we want and on this side
06:27 - we're going to go ahead and just set it
06:28 - equal to
06:29 - the personal information constant
06:33 - see what that's going to give us the
06:34 - ability to do here
06:36 - is
06:37 - and let's go ahead and use um some
06:39 - template literals or um string string
06:41 - exfoliation here and it's going to give
06:43 - us the ability to just do something like
06:45 - this where you can do first name
06:47 - and then last name
06:50 - and
06:52 - it's going to print it out like so and
06:54 - we don't have to do personal
06:55 - information.first name every single time
06:57 - we want to use it but we can actually do
06:59 - one step farther one step further than
07:02 - that is say we wanted to actually
07:04 - reassign the value here we just put
07:07 - colon and put fn for first name and
07:10 - colon
07:11 - ln for last name and we could replace
07:13 - this and put fn and ln
07:17 - to hit those values as well
07:20 - you'll see we have first name and last
07:21 - name now i i would say that if you are
07:24 - going to rename something
07:26 - you know make sure that the when it
07:28 - comes to naming convention it makes
07:30 - sense or if you're gonna do very short
07:32 - names like this in this instance make
07:34 - sure that you follow good naming not
07:36 - only good naming convention but also
07:38 - make sure that the scope of it is very
07:40 - short but this allows us uh in general
07:42 - to destructure our objects so that we
07:44 - can have access to these things and
07:46 - we'll talk a little bit about how we can
07:48 - destructure arrays in the next video
07:56 - destructuring arrays is another great
07:58 - feature that's been added to javascript
07:59 - in recent years it's very similar to how
08:02 - we destructured the objects earlier so
08:04 - we have this
08:05 - name array
08:07 - and what we want is to essentially
08:09 - create a
08:10 - pointer element to de
08:12 - destructure our array so that we can get
08:16 - the first name the middle name the last
08:17 - name in this instance how might we do
08:19 - that well
08:20 - we can go ahead and wrap it remember how
08:22 - we wrapped it with the object we wrap it
08:25 - and we'll get first name like so and we
08:27 - console.log
08:30 - first name
08:32 - you'll see we'll save we'll get dylan
08:33 - right and then uh we can do multiple
08:36 - values right it's and we do we'll say
08:38 - middle name
08:39 - and we can pass the middle name we'll
08:41 - just do a little plus here and throw in
08:44 - middle name
08:45 - and it's going to not look very nice but
08:47 - you'll see we get dylan coding god we're
08:50 - dealing codeine without any space and we
08:52 - can do last name as well but that's not
08:55 - that's not it
08:56 - as uh let's just go ahead and print this
08:59 - out piece by piece so we can see it's
09:01 - all working now you'll notice that it's
09:03 - going index by index we don't have to
09:05 - have all of them but we can and in our
09:08 - instance
09:10 - we can actually reset the value here so
09:12 - first name is actually storing a
09:13 - reference to
09:15 - that zero index so if we wanted to
09:17 - overwrite the value in in in this case
09:20 - we could let's say i got a uh let's go
09:22 - last name i got let's say my girlfriend
09:25 - uh took i took on her last name or
09:28 - something like that and we're just gonna
09:29 - sit hey and i'll now become a clements
09:32 - it's not gonna happen but we'll pretend
09:34 - right
09:35 - and now you'll see that last name
09:37 - becomes clement so this is one way that
09:39 - you can destructure an array
09:47 - if you haven't noticed by now es6 has
09:49 - put an emphasis on writing less code
09:52 - while still being readable and
09:54 - maintainable and object literals are no
09:57 - different so what are object literals
09:59 - well a little bit of the setup you see
10:01 - we have this function here called
10:02 - address maker it takes in two properties
10:04 - city and state
10:07 - let's define a new
10:08 - variable and we'll just call this new
10:11 - address
10:14 - right now we're going to set it to an
10:15 - empty object
10:17 - and all we want to do at the end here is
10:18 - we're in console.log new address
10:21 - if we had let's say
10:24 - we'll have a property called new city
10:26 - and we'll set the value here to city
10:28 - and then we'll have a new state and
10:31 - we'll set the value to state
10:33 - and then you'll notice that we prince
10:35 - print out you know new city austin new
10:38 - state texas as we would expect nothing
10:40 - new here however object literals give us
10:43 - the ability to if these keys are the
10:46 - same as the value that they're passing
10:48 - in
10:49 - we don't actually have to set it it's
10:50 - going to make the assumption so in this
10:52 - case let's say instead of new city the
10:54 - key was
10:56 - city instead of new state the key was
10:58 - state what's going to happen here is
11:01 - it's going to assign
11:03 - the value of city to city and of state
11:07 - to state and we don't actually have to
11:10 - write
11:11 - city is equal to city
11:13 - and state is equal to state as you might
11:16 - have done in the past
11:18 - and you'll you'll see it'll work the
11:19 - same but object literals give us the
11:22 - ability to do that now one caveat to
11:24 - that is if you are going to use object
11:26 - literals just make sure it makes sense
11:28 - don't try to
11:29 - change your object or change your
11:31 - properties so much so that it doesn't
11:33 - make sense but object literals is an
11:36 - excellent way for us not to have to
11:37 - write duplicate code that doesn't help
11:40 - in explaining it but allows us to write
11:42 - less code while still being very
11:44 - descriptive
11:50 - all right in this challenge we're going
11:52 - to try and combine the template literal
11:54 - the object literal and the object
11:56 - destructure and how might we do this
11:57 - with the setup that we have here you'll
11:59 - see we have this address maker function
12:01 - taking in a city and state key in the
12:04 - object we then have this new address
12:07 - where we're applying the values that
12:09 - we're passing in
12:10 - and
12:11 - on the end goal all we wanted to do is
12:13 - console log the new city the new state
12:15 - and the
12:16 - country with it and we're going to use
12:19 - struct destructuring we're going to use
12:21 - template literals and we're going to use
12:22 - object literals
12:24 - all right i hope you took a second to
12:26 - try and figure this out on your own if
12:28 - not that's okay and if you struggled
12:29 - that's fine we're going to go through it
12:30 - right now so
12:33 - what we're going to do here is we're
12:34 - going to create a constant and we're
12:36 - going to destructure our object
12:38 - we're going to pass in the city we're
12:39 - going to pass in a state and we're going
12:41 - to set the reference to the address
12:43 - object that we're passing in
12:45 - this is going to give us the ability to
12:47 - no longer need to
12:48 - say address dot city we could in theory
12:51 - say city city but that wouldn't use the
12:54 - object literal and so what we're going
12:55 - to do is we're going to get rid of the
12:57 - city we're going to do the same thing
12:58 - with state as well or the assignment of
13:00 - city because this is going to know to
13:01 - say hey for the city key assign this
13:04 - city value then we're going to leave
13:06 - country alone and last but not least
13:09 - we're just going to console.log our new
13:11 - address using
13:13 - interpolation or template literals and
13:16 - we're going to say
13:17 - new address
13:19 - city
13:21 - space or comma and then we'll say
13:24 - new address
13:27 - from state
13:28 - and then finally a little one more comma
13:31 - and i'll do a last one here of new
13:34 - address
13:35 - country
13:37 - save it
13:38 - and we're good go so you'll see austin
13:40 - texas united states
13:48 - before of loop is a great addition to
13:50 - the javascript language and let me
13:53 - showcase a little bit of what it does
13:56 - say we wanted to iterate over all these
13:59 - values in the array and perhaps add it
14:02 - to this total value and at the end here
14:04 - all we wanted to do was cancel out
14:06 - console log the total of the incomes
14:12 - we could use the for of loop
14:14 - and it's going to start off as a simple
14:16 - for loop and then we can define const
14:19 - and we're going to say income
14:21 - of incomes in our case we're not going
14:24 - to reset the value of anything in our in
14:26 - our logic nested in the for loop so
14:29 - that's why we're using columns but if
14:30 - you're going to reset income nested in
14:32 - there and use it for some calculation or
14:34 - something like that you would use let so
14:36 - we're going to say cons and we're going
14:38 - to say total
14:40 - gives me total
14:42 - plus equals
14:46 - to the income we're passing and we'll
14:48 - get something like 204 000. now let's
14:50 - check how we're you know if we wanted a
14:52 - console.log out income
14:55 - you could see we're going to get each
14:56 - individual
14:57 - income
14:59 - okay get rid of that so we get sixty two
15:02 - thousand sixty seven thousand sixty five
15:03 - thousand so this income here
15:05 - is saying each
15:07 - element
15:08 - in
15:09 - incomes are iterable in this case it's
15:11 - an array we're able to do something with
15:14 - it and so that's really what the for
15:16 - for of loop does is it allows us to
15:18 - iterate through an entire entire
15:20 - interval
15:22 - so you may have been wondering why is
15:23 - dylan keep saying iterable and not array
15:26 - well because we can actually use the for
15:28 - of loop
15:29 - with various iterables what is another
15:32 - example of a popular interval let's
15:34 - start off by get rid of our previous
15:37 - logic here because they're no longer
15:39 - going to use total
15:40 - and
15:41 - we're going to change it comes to
15:44 - um we'll say full name
15:46 - and we're going to set this equal to a
15:47 - string
15:49 - so you can actually iterate over each
15:50 - character
15:53 - of the string
15:54 - like so and instead of
15:57 - it comes we'll pass in full name instead
15:59 - of income here we want to make sense
16:01 - we'll just call it char
16:03 - and passing
16:05 - char
16:06 - and we'll save it and you'll see here
16:09 - that as we print out our logic we get d
16:12 - y l a n and then so on and so forth and
16:15 - we can actually iterate over strings as
16:17 - well so anything that is an iterable we
16:19 - have the ability to go through so that's
16:21 - map sets typed arrays and we're not
16:23 - going to dive into this in this course
16:25 - perhaps later on we may do an advanced
16:27 - course where we break out all the
16:30 - craziness that you can do in javascript
16:32 - and some of the newer newer types but
16:34 - here you can see that anything that's an
16:36 - interval we can go through with the four
16:38 - of loop
16:45 - in this challenge we're going to pose a
16:47 - question of what do you think would
16:48 - happen if we gave each one of these
16:49 - incomes a bump of five thousand dollars
16:52 - and change this cons to a let
16:55 - and added five thousand dollars to the
16:57 - income would it change it would it not
16:59 - why might that be
17:02 - all right so hopefully you took a second
17:04 - to figure out what this might be and
17:05 - just sort of think about it and let's
17:07 - see what happens when we say look let
17:09 - excuse me let take income and set it you
17:13 - know equal to itself
17:15 - and add five thousand dollars they all
17:16 - got a bonus what are we going to get
17:18 - from incomes you'll notice none of our
17:20 - values change well recently
17:22 - the reason for this is it's not designed
17:24 - to do that
17:26 - you can if you for some reason we're
17:28 - going to
17:29 - add a value to this you don't want to
17:31 - create a new variable you could do that
17:33 - and then store it elsewhere but in this
17:36 - instance when we're using the led and
17:38 - we're trying to reset the value of the
17:39 - four rev loop that's not what it's
17:40 - designed for it's just designed to
17:42 - iterate over iterables not actually used
17:45 - to set up new values or update the
17:47 - values of iterable objects
17:55 - so what is the spread operator this is
17:58 - another great addition
18:00 - to javascript and one i use
18:02 - almost on a daily basis at work
18:05 - so the spread operator you'll see here
18:08 - in our in our setup is we have an array
18:09 - of values and then we're just printing
18:11 - out the values nothing special here
18:13 - let's go ahead and create this example
18:15 - two
18:16 - and this is gonna be an array and then
18:18 - we're gonna say dot dot dot example
18:21 - one what is that doing it's essentially
18:24 - unwrapping the values of example one
18:27 - into
18:28 - example two and you'll see here when we
18:31 - console log it out
18:33 - all the new values are being added to
18:36 - example two and it's also not passing it
18:38 - by
18:39 - reference so
18:41 - he's instantiating a new array in this
18:43 - instance and so if we were to take
18:45 - example two
18:47 - dot push
18:50 - a push and we'll just push a boolean
18:52 - doesn't have to be a number
18:53 - and then we want to check hey did this
18:56 - actually
18:57 - pass this to example one if it was by
18:59 - value no it didn't so because we don't
19:02 - have that on example one there
19:04 - now the spread operator
19:06 - can be used with objects as well
19:09 - unfortunately we're not going to be able
19:10 - to at this time showcase
19:13 - i can show that an example of it but we
19:15 - won't be able to actually see it in
19:17 - practice the spread operator when it
19:19 - comes to objects is a very new feature
19:22 - and something that the babble setting
19:23 - says running on scrimba don't currently
19:26 - compile because they're probably a
19:27 - little bit more strict as they should be
19:29 - but an example of what might happen here
19:31 - is let's say we have example one this is
19:33 - equal to
19:34 - an object of first name
19:36 - set it to dylan
19:38 - and then we said let
19:40 - example
19:41 - two equal to an object and then within
19:45 - here we might do dot dot dot example one
19:48 - and what would happen here if we were to
19:50 - and we're going to calm this out because
19:52 - this isn't going to run what would
19:53 - happen here is that we would have our
19:57 - example 2
20:00 - essentially
20:01 - it would unwrap the keys and the values
20:04 - that are in example one and we get this
20:06 - object with first name
20:10 - and
20:11 - uh with first name of dylan now there's
20:13 - a bunch of different reasons that you
20:14 - might do this i do it in my
20:17 - constructors when it comes to typescript
20:21 - where sometimes i'll have a default
20:23 - value for first name in case first name
20:25 - doesn't come from the backend so i might
20:27 - have something like first name
20:29 - is going to be equal to not applicable
20:33 - and that way
20:35 - when i'm
20:36 - writing my code is if something's not
20:38 - passed from the back end but i need to
20:40 - have a value another great example is an
20:42 - empty array because that will break our
20:44 - code if we're iterating over something
20:46 - i'll assign an empty array unless
20:47 - something comes fulfilling that in the
20:49 - back end so that's just one way of how
20:50 - you might use the
20:52 - spread operator when it comes to objects
20:54 - once it's a little bit more widely
21:00 - supported the rest operator although not
21:03 - as widely used as the spread operator is
21:06 - somewhat similar and just as valuable so
21:09 - what is the rest operator it gives us
21:12 - the ability to get the arguments out of
21:15 - our function
21:16 - and it's used in a case in which we
21:18 - don't know how many inputs are going to
21:20 - be used so in our example here we have a
21:21 - function add with a parameter called
21:23 - nums and all we want to really do at the
21:26 - end of the day is console.log
21:28 - nums let's go ahead and just add a
21:29 - function call real quick and so we'll
21:31 - take add we'll pass in five or four and
21:35 - cool it prints out four what if we
21:36 - wanted this to take in as many numbers
21:39 - as possible
21:41 - what's going to happen right now
21:43 - is our code is not going to do what we
21:45 - wanted to do we wanted it to print out
21:47 - all of nums and in the past what we
21:49 - might have to do to get those arguments
21:51 - is there's an arguments object for
21:53 - variables and you can see here it's
21:55 - actually going to say look this is on
21:57 - the zero index of our add function if
21:59 - you wanna think of it that way zero zero
22:01 - input then the one input and then we can
22:03 - get the values that way and we do
22:05 - something with that now it's not an
22:06 - array it's not iterable and typically
22:08 - that's what you're going to want to use
22:10 - so
22:11 - in theory arguments have sort of been
22:13 - deprecated unofficially with the rest
22:15 - operator and what this is going to allow
22:17 - us to do is in our input here on the
22:20 - nums you'll see we have the three dots
22:21 - that's why i kind of say it's related to
22:23 - the spread operator and now when we
22:26 - access nums you'll see that we're going
22:28 - to get an array of the input values here
22:30 - so when you're going to write a function
22:33 - and you don't know how many
22:35 - values are going to be inputted you just
22:36 - know it's going to be some sort of value
22:39 - and you don't necessarily want to just
22:40 - pass an array for for various reasons
22:43 - you may want to consider using the rest
22:45 - operator it's extremely powerful i use
22:47 - it whenever i need to i don't use it as
22:50 - much as the spread operator but i find
22:52 - it much more intuitive than having to
22:54 - convert the arguments to an array and
22:57 - get the values that way so the rest
22:59 - operator is a great addition to es6
23:07 - we're going to recycle a little bit of
23:08 - our code from the rest operator section
23:12 - so just a reminder here we have our
23:14 - function add that's taking in
23:16 - a numerous amount of values and using
23:19 - the rest operator we're going to get an
23:20 - array of these values
23:23 - arrow functions are a great way to
23:25 - eliminate some of the really unnecessary
23:28 - boilerplate of callback functions and
23:31 - that it comes with
23:32 - a lot of functionality as well as just
23:36 - some gotchas that if you don't know
23:37 - exist but let's start off by creating
23:39 - this total
23:40 - and we're going to
23:41 - we're going to essentially call the
23:43 - reduce array method using arrow
23:45 - functions to return these values and
23:48 - then just below it we're going to
23:49 - console.log out total
23:52 - now
23:54 - this is a reminder nums here is an array
23:56 - so we can't we have access to all the
23:59 - things that would come in it so we'll
24:01 - have reduce we'll just do
24:03 - x and y and you'll notice here that i've
24:06 - already by pure instinct uh typed this
24:09 - out i wanted to show an instance of what
24:11 - we might do in the past
24:13 - uh without arrow functions so you'll see
24:15 - function and then we'll define this with
24:17 - the brackets and then we'll say return
24:20 - x plus y
24:22 - and then semicolon semicolon go ahead
24:25 - and save
24:27 - and you'll see we end up with 36
24:29 - as it adds all the numbers together so
24:31 - this callback function we can replace
24:34 - using arrow functions and the only
24:36 - downside to that is that it doesn't have
24:38 - its own instance of this
24:41 - which is may or may not hurt may or may
24:43 - hurt you in your code so if you come
24:44 - across that really
24:47 - just be aware that that is part of the
24:49 - trade-off for what we're doing here so
24:51 - let's go eliminate this function and so
24:53 - we can eliminate this code and you're
24:54 - saying well
24:56 - uh
24:57 - why are we in this error well when we
24:58 - eliminate function we have to assign
25:00 - this arrow function hence the name
25:03 - you'll see it still works but we can
25:04 - actually eliminate even more code at
25:06 - this point
25:07 - where if we're doing a simple one-line
25:10 - return in our arrow functions such as
25:11 - just adding these values together
25:14 - we can eliminate this curly brace here
25:18 - and we can also eliminate this return
25:20 - statement
25:21 - and we can eliminate this semicolon that
25:24 - we get is a very clean arrow function
25:27 - that
25:28 - will return the values that we're
25:30 - looking for and we have we've eliminated
25:33 - maybe 20 characters of code and a lot of
25:36 - spacing for something that we really
25:37 - didn't need to get going so arrow
25:39 - functions are very powerful and they're
25:41 - also just very condensing condensed and
25:44 - eliminate a lot of the the useless
25:46 - boilerplate when it comes to callback
25:47 - functions
25:54 - default parameters for javascript is a
25:56 - another new concept but it's been around
25:58 - in other programming languages for quite
26:00 - some time and it provides us a lot of
26:02 - value that's going to stop a lot of
26:05 - forced
26:07 - error checking and force air prevention
26:09 - and
26:10 - let's take a look at our code here where
26:12 - we have an add function takes in an
26:14 - array presumably it's called num array
26:17 - and you'll see here in our ad we're not
26:18 - calling it
26:20 - which right now we're not using num
26:21 - array but let's say we were we wanted to
26:23 - for each iteration of number a we're
26:26 - going to for each on it take an element
26:28 - you'll notice we're going to be go ahead
26:29 - and use the arrow functions
26:32 - and we want to say total
26:34 - plus equals to that element what's going
26:37 - to happen here in our current iteration
26:40 - is we're going to error right uh type
26:42 - error for each of undefined we never
26:44 - pass in num array and
26:47 - that's going to give us an issue because
26:48 - we don't have a we don't have an array
26:50 - to iterate over now what we can do
26:52 - instead is we can use optional
26:55 - parameters to help prevent this from
26:57 - airing our code out because sometimes
26:59 - maybe someone calls it sometimes maybe
27:00 - it doesn't matter
27:02 - sometimes it's just going to be an empty
27:04 - array or whatever the case may be but
27:06 - now what happens is when number a isn't
27:08 - passed in
27:09 - we are providing a empty array saying
27:12 - hey if it doesn't exist set it to an
27:14 - empty array therefore our array methods
27:16 - don't break
27:17 - and then in our case we just get a total
27:19 - that returns zero because there's
27:20 - nothing to iterate over and thus nothing
27:22 - gets added to the total
27:24 - so um and plus equals there we go um and
27:29 - thus we have a solution in place to
27:32 - prevent those undefined errors that it
27:35 - will be so rampant especially when you
27:37 - get incorrect data maybe from apis or
27:39 - the back end or even just your own logic
27:41 - or user input
27:48 - javascript's always been kind of a
27:50 - strange language in the fact that
27:52 - we don't always have a method that does
27:55 - what you would expect a language to have
27:58 - and so in the past when we wanted to
27:59 - check if an array
28:01 - had a value we would use index of so in
28:05 - our case we have console.log and we say
28:08 - nomare
28:09 - dot index of and index of of course
28:12 - returns the index of value is in there
28:14 - and if it's an index value like zero
28:17 - it's going to return negative one
28:18 - because it doesn't exist that's kind of
28:21 - wonky and so
28:22 - we got introduced to
28:25 - a new method called includes and
28:28 - includes will return a boolean value of
28:31 - true or false so you'll see here when we
28:33 - throw in zero it's going to return false
28:36 - and when we include
28:38 - two here it's going to return true
28:39 - because it's contained within the array
28:42 - one thing to keep that in mind for this
28:44 - if you are trying to support
28:46 - internet explorer for some unknown
28:48 - reason you may run into issues this is
28:51 - not supported by internet explorer but
28:53 - it is supported by all major web
28:55 - browsers besides ie
29:02 - we're going to talk a little bit about
29:04 - letting cons but
29:06 - in order to understand why let exists
29:08 - and cons for that matter exists you have
29:10 - to sort of understand variable hoisting
29:12 - in javascript let's take a look at our
29:15 - example code right here you'll see that
29:17 - we have if false var example is equal to
29:19 - five console.log example now
29:22 - what may surprise you is that we're
29:23 - going to get a null value and not a like
29:26 - this is completely an error why would
29:28 - you log this value and that's because
29:30 - what's called variable hoisting when you
29:34 - when it comes to javascript var
29:37 - is it hoist the variables and so what
29:39 - javascript actually sees when this
29:40 - renders is what's in our commented out
29:43 - code here where var example
29:45 - uh and it hoists it to the to the root
29:48 - to the essentially to the function scope
29:50 - level and then it looks like oh example
29:53 - is equal to five and then console log z
29:55 - so it hoists your variable and this is
29:57 - solved by using let and const moving
30:00 - forward so let's dive in a little bit
30:01 - about let and const
30:04 - so let
30:05 - essentially is a stricter version of var
30:08 - and which it uses block scope so in our
30:11 - case right now we're getting null we're
30:12 - not getting an error though when we try
30:14 - a log out example however if we go ahead
30:17 - and
30:18 - define let
30:19 - in our instance here you're going to see
30:21 - that we're going to get a undefined
30:23 - error because
30:26 - the example variable doesn't exist
30:28 - unless it's within this nested block
30:31 - scope as you might imagine because the
30:34 - way that it's actually interpreting it
30:36 - is exactly
30:37 - how it is printed
30:40 - which makes a lot of sense so although
30:42 - funk of var
30:44 - is using hoisting let does not and
30:46 - neither does cons and moving forward you
30:50 - for the most part should be always using
30:52 - let when you're gonna have values that
30:54 - are reassignable now let's dive in a
30:57 - little bit about constant how that
30:58 - differs from let
31:01 - cons as you might have guessed stands
31:02 - for constant but it may not work in the
31:04 - exact same way that you would expect so
31:06 - let's go ahead and clean up our code a
31:08 - little bit here
31:09 - const is denoted by the const word and
31:12 - we'll just say example and we're going
31:13 - to set this equal to a primitive
31:16 - data type which would be
31:18 - a number a
31:20 - a string or a boolean
31:23 - so we're excluding objects and arrays
31:25 - now what you may see console.log as
31:29 - as you would expect in our example we're
31:31 - going to get the value however we can't
31:33 - actually reset the value example when
31:36 - we're dealing with the primitive types
31:39 - will give us an error so we'll set this
31:41 - to 10.
31:42 - doesn't matter if it's the same type
31:44 - example when dealing with the primitive
31:46 - types are
31:47 - read-only properties these are things
31:49 - that have been set and you don't plan on
31:51 - changing however where this may get a
31:53 - little bit confusing is this
31:56 - it's not necessarily the case when we're
31:58 - dealing with arrays so in our case we
32:00 - have an empty array we can actually
32:02 - still
32:03 - in our const example push to it
32:06 - and set it you know push a value to five
32:08 - that's fine however if we wanted to
32:11 - change the value from an array to i
32:13 - don't know
32:15 - uh three
32:17 - we're gonna get a syntax error so that's
32:19 - not um that's not okay and that goes the
32:22 - same for objects if we have an empty
32:24 - object here
32:26 - and see empty object we can actually
32:27 - assign properties to it as well and
32:31 - this will work
32:34 - similar to how array works so although
32:36 - const is sort of a constant
32:39 - uh theory it's not exactly you can
32:41 - modify objects and arrays but you cannot
32:43 - override the data types with those
32:46 - moving forward any and when it comes to
32:47 - primitive values the numbers the the
32:49 - strings and the booleans you can't
32:51 - change those at all
32:59 - import and export have been a great
33:00 - addition to
33:02 - javascript it allows us to follow the
33:05 - solid principles and do dependency
33:08 - injection and
33:09 - and more object-oriented programming and
33:12 - essentially allow our code to be more
33:14 - modular in nature which it lends it to
33:16 - be more
33:17 - easily organized which is a great thing
33:20 - how do they work what do they do well
33:22 - let's take our example.js file that we
33:24 - have here and define in this case we're
33:27 - going to define just a variable a const
33:30 - variable and the reason that you might
33:31 - do something like that is you may have a
33:33 - data set that you're going to use by
33:35 - multiple parts of your application and
33:38 - or it may just be long it's cleaner and
33:40 - you just want it in one spot it really
33:41 - just doesn't matter but in our case here
33:44 - we're going to find a const and this is
33:45 - just we're just going to call it data
33:47 - we're going to set it equal to an array
33:48 - and we'll go ahead and throw in maybe a
33:50 - 1 a 2 and a 3.
33:53 - really matter in this case so this
33:55 - export allows us to in this case export
33:58 - a data
34:00 - export data which we can then import in
34:02 - another application
34:04 - you can do classes you can do a enums if
34:07 - you're working in typescript and things
34:08 - like that um let's go ahead and show how
34:11 - we can import it so we'll have this
34:13 - import and then these two curly braces
34:15 - now remember how we had
34:17 - data here that is what we're going to be
34:19 - importing within these curly braces and
34:22 - in our example here we don't have
34:24 - multiple things being exported but if we
34:26 - did like a data 2 you just throw a comma
34:29 - and then you'd have access to it
34:32 - we're going to import data and typically
34:34 - you want to space it out like so and
34:36 - then you have to say from where in our
34:38 - case it's just from the example
34:42 - dot
34:43 - bas file and now if we wanted to
34:46 - console.log data
34:48 - we could
34:50 - you'll see here we actually get our one
34:51 - two three we'd even create a reference
34:53 - to it let data
34:55 - equal
34:57 - uh let's
34:59 - uh updated data
35:01 - equal data really could push to it if we
35:04 - wanted to as well and just treat it like
35:06 - any other item that we wanted
35:10 - updated there we go
35:12 - oops
35:13 - updated data
35:17 - and there we go we get one two three and
35:19 - five so this allows us to make our code
35:21 - more module as well as
35:24 - be able to organize in such a way it's
35:26 - very helpful and something i use on a
35:27 - daily basis
35:34 - javascript gives some more love for
35:36 - strings with the pad start and pad and
35:39 - methods what this does is it gives us
35:42 - a way to add values to the starter
35:44 - string and add values to the end of the
35:46 - string depending on how long the string
35:48 - is so let's take the example here which
35:51 - is my name
35:52 - which is five letters long
35:54 - what we're going to take in what we're
35:56 - going to call on this is the pad start
35:59 - method and this is going to allow us to
36:01 - put in an integer in this case 10 and
36:04 - then we're going to follow up let's just
36:05 - throw in the letter a and you'll see
36:07 - here when console log it out we get 5
36:10 - a's and dylan however let's say we
36:12 - spaced this out like so when we put
36:14 - dylan israel we're just going down
36:16 - israel there's no there's no room left
36:18 - to add values on to our string and and
36:22 - the vice versa if we wanted to do with
36:24 - and start it's going to work in a
36:25 - similar fashion
36:27 - so i'm just going to add it on to the
36:28 - end and
36:30 - excuse me pad end i don't know why i
36:32 - said pat start pad and
36:35 - you'll see okay there's no values here
36:37 - and if we remove israel we'll have five
36:40 - values left and then we'll add dylan a
36:43 - to the end of the string a little bit of
36:46 - fun i haven't found a use case where i
36:47 - would use pad starter pad in but it's
36:49 - definitely worth mentioning probably
36:51 - help you on some of those algorithm
36:52 - sites where you're practicing a little
36:53 - bit as well
37:01 - so one thing you may not have noticed is
37:03 - that are known because i didn't mention
37:05 - it yet is that you can actually pass in
37:07 - just a number here the second parameter
37:09 - that we've been passing in with the
37:10 - string is optional so let's take a look
37:12 - at my shameless plug right here
37:14 - youtube.com slash code tutorial360
37:16 - string which is very long string and a
37:18 - very great youtube channel but besides
37:20 - that you'll see that we have a pad start
37:22 - to 100 and a pad end to one what do you
37:24 - think is going to happen to our string
37:26 - when we do that
37:28 - did you come up with some guesses if so
37:31 - and you guessed that it had an empty
37:33 - string it would have been right
37:35 - for our 100 one right here and you'll
37:37 - see now it's going to print it out we
37:39 - get that empty string but it's actually
37:40 - going to
37:41 - print out if we call dot length on it
37:43 - you'll see the length of it's 100
37:45 - there's like 80
37:47 - empty characters on here just the the
37:49 - editor here is too smart to know not to
37:51 - print all 80 of those
37:52 - what about pad end well in our case it's
37:55 - just going to ignore it right because
37:57 - our string is clearly longer than one
38:00 - empty character and thus it prints out
38:03 - appropriately
38:10 - classes are a great addition to take
38:13 - javascript to be in a more
38:15 - object-oriented way and what we're going
38:17 - to do here is we're going to find a
38:18 - class and showcase some of the things
38:20 - that you can do with classes how they
38:22 - work it's going to be one of the long
38:24 - longer sections of this course but stick
38:26 - with it it's a really important concept
38:28 - so let's start by go jumping into our
38:31 - animal.js file and define a class you do
38:33 - that with this class keyboard in our
38:35 - example we're going to use an animal
38:36 - because i have three cats and i love
38:38 - animals so we've defined a class here it
38:40 - doesn't do anything yet
38:42 - but we need to build a instance of this
38:45 - and to do that we have to set up
38:46 - something called a constructor so our
38:48 - constructor here
38:50 - essentially
38:51 - set some values when we when we create
38:54 - it in our case maybe an animal has a
38:57 - type
38:58 - and we'll also say it has
39:01 - you know we'll say legs every animal
39:03 - should have legs
39:05 - and we'll go from there and we're going
39:07 - to use the this keyword say look this
39:09 - dot type a site meaning that this animal
39:12 - class has a type is equal to the type
39:14 - that we're passing in
39:16 - and vice versa this dot legs
39:19 - is equal to
39:20 - the value that we're passing in when we
39:22 - create
39:23 - our
39:24 - object so the constructor here is really
39:26 - just assigning those values to our
39:28 - animal class
39:30 - now i think this will make more sense
39:33 - if we
39:34 - use it in a example so let's go ahead
39:37 - and we take what we learned with the
39:40 - export remember export class
39:43 - animal so all we have to do is throw
39:44 - export on here and now we'll jump into
39:46 - here
39:47 - we'll go ahead and import
39:50 - animal
39:52 - from
39:54 - dot slash
39:56 - animal
39:58 - dot js
39:59 - and to create an instance of a class we
40:01 - go ahead and just create a variable here
40:03 - and we'll say let cat
40:06 - equal new animal
40:10 - now when we
40:12 - go ahead and we're gonna get air we go
40:14 - ahead and console.log cat you'll see
40:16 - that
40:18 - it's telling us i'm surprised it even
40:20 - printed that but essentially what the
40:22 - issue is here is that we need to now
40:25 - go and add some values so maybe we have
40:28 - um
40:29 - a type we'll say cat and legs we'll say
40:32 - four
40:33 - and we have access to the channel so if
40:35 - we say cat dot type who are we gonna get
40:39 - we're gonna get cat right
40:40 - if we say cat dot
40:43 - legs
40:44 - we're gonna we're gonna get legs and so
40:46 - we have access to those properties and
40:48 - they're being set via the constructor
40:51 - here the constructor is setting these
40:53 - values that we're passing in for our
40:55 - animal class
40:56 - so we've already shown you that we can
40:58 - get values but we can also change values
41:01 - relatively easily without having to
41:04 - change anything all we have to do is say
41:06 - cat dot
41:08 - and you'll notice how it's it's bringing
41:09 - it up right legs or
41:11 - or uh type
41:15 - the legs and let's say
41:17 - heaven forbid our cat lost a leg now
41:19 - they have three we can then reset the
41:21 - value of that just as we would with any
41:23 - other object
41:25 - we can also define functions in our
41:27 - classes
41:28 - and you'll see that we aren't going to
41:30 - use the function keyword for this so
41:32 - let's say we define a meow or a make
41:36 - noise
41:37 - function because this is a generic
41:40 - animal class it's not necessarily for a
41:42 - cat
41:43 - and we'll take in a property we'll just
41:45 - call it sound and then we'll go ahead
41:47 - and
41:48 - console.log sound and while we're at it
41:51 - why don't we go and practice a little
41:52 - bit of the default params because we
41:54 - covered that earlier and we'll say meow
41:57 - we'll just make the assumption
41:59 - uh actually just say loud loud noise
42:02 - there we go uh and that should work just
42:04 - fine so now when we go to index.ps and
42:06 - we can say cat dot make noise
42:11 - it's going to come to log loud noise out
42:14 - from the function that we passed in and
42:16 - of course we can we made it that
42:18 - optional parameter so if we do pass meow
42:20 - in we'll now get meow from our function
42:23 - that we've defined in our animal class
42:26 - static may be a new concept for those of
42:28 - you who are not familiar with classes
42:30 - and object oriented programming and what
42:33 - static allows us to do is essentially
42:37 - create a function in our
42:40 - class in our animal class in this
42:42 - instance where we don't actually have to
42:44 - create an instance of animal to use it
42:46 - this is often what happens when you're
42:48 - creating a large library or you're
42:50 - importing
42:51 - someone's stuff and you don't have to
42:53 - create a instance of that class so uh
42:56 - let's create a static
42:59 - and um let's say we just want to say
43:03 - return we all we want to do is return
43:05 - 10. it uh it really could do whatever
43:07 - you want it to do
43:09 - and we'll say um
43:11 - 10
43:13 - and that's a function
43:15 - and in here all we want to do is return
43:17 - 10.
43:18 - not not the most impressive function but
43:22 - if we were to comment all this out now
43:24 - and all we wanted to do was console.log
43:29 - animal
43:30 - and then say return 10 you'll notice
43:33 - that it's going to work just fine excuse
43:35 - me it's a function call so we have to
43:37 - use that you'll see we actually get the
43:39 - number 10 and we never had to
43:42 - instantiate the
43:43 - the class to use it so these are really
43:46 - functions that you need that you want to
43:48 - write that you don't need an instance or
43:50 - anything too too unique about it and
43:53 - that it's just going to take in some
43:54 - properties perhaps and return some data
43:57 - or runs
43:58 - another great option when it comes to
44:01 - classes is the ability the ability to
44:03 - create a get
44:05 - method so what is a get method a get
44:06 - method is really a property you want to
44:09 - create that only to return some value so
44:12 - let's go ahead and cancel out our static
44:14 - or get rid of our static method here and
44:16 - comment this back in
44:18 - and we'll go ahead and just delete this
44:20 - no need to do that we all know that
44:22 - works at this point
44:23 - and we're going to jump into our
44:25 - animal.js file and we're going to create
44:28 - a get and you'll see you'll notice the
44:30 - get
44:31 - keyword in front of our function call
44:33 - and in here all we're going to basically
44:34 - do is return a string that says the type
44:37 - and the legs you know so maybe we'll
44:39 - we'll just call this metadata
44:44 - and we're going to return with the
44:46 - backticks
44:48 - say this uh
44:50 - this dot type
44:53 - and let's let's make this look a little
44:54 - a little nice type call in space
44:57 - and then we'll say
44:59 - um
45:00 - you know maybe comma
45:02 - uh legs
45:06 - this dot legs and so this kit this
45:10 - getter here will allow us to
45:13 - treat this as a property on our object
45:15 - so when we jump back into index.js
45:18 - instead of printing out legs here if we
45:20 - create it as git we can now get the
45:22 - metadata on it and you'll notice that
45:25 - it'll print out so that's another thing
45:26 - that you can do
45:28 - it also gives us the ability to maybe
45:30 - say call functions in there hide a
45:32 - little bit of our class from the from
45:34 - the user if we want to
45:37 - but uh this is a another great option
45:39 - when it comes to working with classes
45:42 - now as you continue to dive into classes
45:45 - and the object-oriented programming
45:47 - approach
45:48 - what will happen is you'll sometimes
45:49 - have classes that will share properties
45:52 - or be very similar right so in our
45:54 - instance here we created this animal
45:56 - class
45:57 - to
45:58 - replicate a cat but let's say we had a
46:00 - dog and we had a cat and we had a mouse
46:03 - and all these sort of things there there
46:05 - may be a cat class or maybe a dog class
46:07 - or maybe
46:08 - a you know a mouse class and but we
46:11 - wanted to inherit some of this animal
46:13 - class
46:14 - and not have to rewrite all of our logic
46:17 - well
46:18 - we could do that by defining a new class
46:19 - and we're gonna do it in the same file
46:21 - here but typically you'd probably have a
46:22 - different folder and then just import
46:25 - this animal class
46:27 - so we want to do is we want to export
46:29 - a class in this
46:31 - case it's going to be cat that extends
46:33 - the animal class that's going to allow
46:35 - us to inherit some properties from that
46:38 - as well as overwrite the ones that we
46:40 - want right and the one that uh you know
46:42 - so we're going to inherit this
46:43 - constructor
46:45 - we're not going to have our own
46:46 - constructor but if we did we would we
46:49 - could do that but we'd have to put some
46:51 - keywords i'm going to show you this but
46:52 - we're not going to use it right now
46:55 - so let's say we wanted to have a
46:57 - constructor in our cat class here like
47:00 - so
47:01 - and we're going to have it also take in
47:04 - the same parameters which was type and
47:06 - legs
47:08 - but we also wanted to have a parameter
47:11 - tail here
47:12 - and
47:14 - we'll maybe just make it a boolean
47:16 - perhaps
47:18 - a cat got its tail ran over no longer
47:20 - has a tail so it's a true or false
47:22 - but when we use this constructor when
47:24 - it's being extended out from a parent
47:27 - class in this case animal we're going to
47:29 - need to use the super keyword
47:32 - let it know that hey pass in
47:35 - pass in the values that were that we
47:37 - have here which in this case is type
47:40 - and legs and then we would also go about
47:42 - it the same way here where we'd say this
47:45 - dot
47:46 - tail
47:47 - is equal to tail and we're not going to
47:48 - do that in this instance but i want to
47:50 - bring that up that you may run into some
47:52 - issues as well as you can use super to
47:55 - call some functions from the parent
47:56 - class
47:57 - uh but i just wanted to mention this
48:00 - let's go ahead and keep moving forward
48:02 - and see how we can override a method in
48:04 - this case we're going gonna override
48:05 - this make noise
48:07 - method
48:08 - and
48:09 - we're just gonna
48:11 - make noise
48:12 - and we'll just still have it sound
48:15 - and we'll set default equal to meow
48:20 - is this cat right we want it to you know
48:22 - and all it's going to do is console.log
48:24 - the sound
48:26 - and so what's going to happen here is
48:27 - these are both named the same and they
48:29 - have the same amount of arguments and
48:32 - because cat extends animal we can
48:34 - overwrite this function
48:36 - in our cat class to make it more unique
48:39 - and more specific to what we're doing
48:40 - while still have access to these other
48:42 - methods so let's jump back into the
48:45 - index.js
48:47 - and import
48:49 - our cat class
48:51 - and instead of cat we're an animal
48:53 - excuse me we're going to import cat
48:56 - the first thing we're going to do here
48:57 - is we're just going to say hey
48:59 - cat dot make noise
49:02 - we'll see
49:03 - that it will do the meow and it's not
49:05 - going to do the loud sound as before
49:07 - because we've overwritten that class
49:09 - over in the parent class in our child's
49:12 - class cat
49:14 - one last thing i want to note is we
49:15 - didn't really showcase it but we now
49:18 - even though we're using our cat class
49:20 - we've actually inherited the properties
49:22 - and the types and the methods from our
49:25 - parent animal class
49:28 - so we can get that metadata for instance
49:31 - and you'll see here we're gonna get the
49:32 - type is cat legs is four
49:35 - so
49:35 - uh as you're starting using this object
49:38 - oriented approach i would suggest using
49:40 - that lightly a lot of times people
49:42 - create very tightly coupled
49:44 - parent and child classes and sometimes
49:46 - they should just be
49:47 - separate classes um but in certain
49:50 - instances it does make sense to extend
49:53 - your parent class out and here is a good
49:56 - example of how we might do that
50:03 - a debatable nice feature i'm not too big
50:06 - a fan of this but a new feature added in
50:08 - es6 is trailing commas
50:10 - so in the past if you had an uh a comma
50:14 - that didn't follow anything you would
50:16 - get an error however now if we were to
50:18 - do something like define a function
50:20 - we'll just call it add and we were to
50:22 - have you know param1
50:24 - and then we had this comma
50:28 - it would be fine uh there wouldn't be
50:29 - any sort of logic error
50:31 - that would work just fine and same goes
50:33 - for objects right so let's say pram one
50:37 - we'll say we'll just print out a const
50:40 - variable and we have name and we'll set
50:42 - it to dylan and then we went and said
50:45 - this trailing comma here
50:47 - that would work uh as well excuse me
50:50 - let's example
50:51 - equal to dylan
50:53 - and then at the end here all we did was
50:56 - just that we could see it console.log
50:58 - param1
51:00 - and uh
51:01 - excuse me example console.log example
51:05 - but trailing comments are now something
51:07 - we're not doing anything with variables
51:08 - just call it though that
51:10 - we don't have issues with anymore
51:12 - so you're allowed to have trailing
51:14 - columns i'm not a super big fan of this
51:16 - i think this is something i got put into
51:18 - javascript
51:20 - maybe someone can convince me but just
51:22 - to solve little tiny errors but it is
51:24 - something that's there be aware of it
51:32 - so this is going to be a little bit of a
51:33 - longer section we're going to be talking
51:35 - about promises async and await and how
51:38 - they are all sort of related when
51:40 - working with them in the front end in
51:42 - javascript
51:44 - let's start by talking about what we
51:45 - have on our page here you'll see i have
51:47 - this constant that is a url that's going
51:50 - to link us to a top 100 of the all-time
51:54 - active users on
51:56 - freecodecamp.com which is a open source
51:58 - javascript site it's an excellent place
52:01 - if you're uh i believe they're actually
52:02 - going to be partnering up with scrimba
52:04 - on some future stuff so it's uh check
52:05 - them out if you're interested in that
52:07 - what we're going to do here is we're
52:09 - going to do an asynchronous call we're
52:10 - going to go and do an ajax call and and
52:14 - we're going to be using fetch which
52:16 - returns a promise and we're going to
52:17 - showcase how to handle that and then
52:19 - later on we're going to showcase a
52:20 - little bit of async and await and how we
52:22 - might use that alongside promises so
52:25 - let's let's get going here you'll see we
52:27 - have our function get top 100 campers
52:30 - this is not like call of duty campers
52:32 - these are the campers of free code cam
52:34 - we use the fetch method here which what
52:37 - this is going to do we're it's going to
52:38 - take in the url this is really going to
52:40 - go and get the data that we're looking
52:42 - for but there's a little bit more we
52:44 - have to do for that we have to call this
52:46 - dot then on it and you'll see here when
52:48 - it say then
52:49 - is it's returning a promise of type
52:51 - response that's what that means and
52:55 - uh so fetch is returning a promise then
52:57 - we're going to handle that
52:59 - response
53:00 - object which
53:02 - we then said hey
53:04 - when the promise actually gets delivered
53:06 - you can kind of think of like hey we
53:08 - promise to send you some data with fetch
53:10 - and then says okay when when you
53:12 - actually send me the data i'll do
53:14 - something with it in the meantime just
53:15 - keep running your code that's sort of
53:17 - how asynchronous
53:18 - uh items work and how promises work in
53:21 - this case and then says hey
53:23 - i'm gonna give you a response
53:26 - um
53:27 - let's say r for a response and what
53:29 - we're going to need to do is first we're
53:31 - going to need to turn that into json
53:34 - otherwise uh we're not going to know
53:35 - what to do with it our computer isn't
53:38 - going our our javascript doesn't know
53:39 - what to do with it and so we have to
53:41 - convert that promise into something that
53:42 - we can use
53:44 - once we do that we can then
53:48 - take that that promise which is another
53:50 - promise and we can which at this point
53:52 - we can say json and we can do something
53:56 - with that data what do we want to do
53:58 - with it well let's just say we want to
54:00 - console.log the first value of that json
54:04 - this is going to return an array of a
54:06 - lot of values
54:08 - and put a little semicolon here
54:11 - and we'll just see that our asynchronous
54:13 - call got set up you can see here we get
54:14 - this object from our ajax call
54:18 - now while we're at it let's go ahead and
54:19 - showcase how we might catch this ajax
54:22 - call and in case an air is thrown and
54:24 - that's i might have already given it
54:26 - away is by catching it and so you'll see
54:29 - here
54:30 - catch takes in
54:32 - a air result in our case we're not going
54:34 - to use it because it's going to look
54:36 - identical to the errors we would get in
54:38 - our application so if for any reason our
54:40 - server side fails on the fetch or
54:42 - converting it to json we can get that
54:44 - error so let's say that we
54:47 - wanted to just console.log failed so
54:50 - that we know that it's firing off and
54:52 - we're going to go ahead and change this
54:55 - put like an empty space here and an a
54:57 - and save it you'll see here we're going
54:59 - to get this failed message and none of
55:00 - this is actually going to run
55:02 - because it failed immediately at the
55:04 - fetch standpoint let's go back and fix
55:06 - that and you'll notice now it's going to
55:08 - go ahead and print out our code let's
55:10 - move on
55:12 - so now that we've done our ajax car
55:14 - asynchronous call and we've resolved the
55:16 - promises and everything's working let's
55:18 - show how we might do this with less code
55:20 - using asynchronous and a weight for an
55:24 - ajax call now just keep in mind you
55:26 - don't have to use async and await or
55:28 - promises just
55:30 - for
55:31 - something when it's hitting a server
55:33 - that's the most common instance but
55:35 - let's say you had a timer and it was
55:36 - timing out for three four seconds and
55:38 - you wanted to
55:39 - have something to delay it you might use
55:42 - promises or async await for that i just
55:44 - wanted to show you the most common one
55:46 - which is server calls
55:48 - and get calls specifically so let's go
55:50 - and fetch that data except instead of
55:52 - doing it with the promises we're gonna
55:54 - do with the async and away we're gonna
55:56 - define a function same name as before
55:58 - and uh get top 100 campers
56:06 - now the way that you tell it that it's
56:08 - an asynchronous function so i'm going to
56:10 - do so this async in front of it
56:12 - now it now the javascript knows like hey
56:14 - there may be some asynchronous
56:17 - items going on in our function and it
56:19 - will give us access to the await keyword
56:23 - how we're going to get that data we're
56:24 - going to just define a const here and we
56:27 - don't have to store it but i think it's
56:29 - a little bit easier it explains the
56:32 - logic a little bit more and we're going
56:34 - to say this is going to be equal to and
56:35 - we're going to do our first asynchronous
56:37 - call here which is follow follow the
56:39 - logic is fetching the data so we're
56:42 - going to fetch
56:43 - on that api url
56:46 - now that we've done that and what that
56:48 - await is saying is please wait until
56:50 - this fetch completes
56:52 - whether it's successful whether it's not
56:54 - please just wait until it completes the
56:57 - next thing that we want to do
56:59 - we go ahead and define a conch here and
57:02 - call this json this would be our second
57:04 - json which is a another asynchronous
57:07 - call
57:08 - and we're going to set this equal to a
57:10 - weight
57:11 - where we're saying please await
57:14 - our response being turned into json
57:18 - response.json excuse me
57:22 - now that we have that
57:24 - we have access to it and it's saying
57:26 - this line will run and it's not going to
57:29 - this line will not run until this
57:30 - resolves that's what this async and
57:33 - await is doing and finally at the end
57:34 - here we can console.log
57:37 - our
57:38 - json and again we're just going to hit
57:39 - that zero spot because uh the data is
57:42 - very large so when we save
57:45 - look at this nice asynchronous call now
57:48 - if this wasn't asynchronous
57:50 - uh then we didn't have or it wasn't an
57:52 - async in a way what would happen here
57:54 - is our console log wouldn't know what
57:56 - json zero index is because all the code
58:00 - would run synchronously just one after
58:02 - another and would not be resolved before
58:05 - we'd actually get this data
58:12 - so this challenge is going to be a
58:14 - little bit instructional as well as
58:16 - really probably just by far the most
58:18 - challenging one of the course so you'll
58:21 - see here that we have
58:23 - a function called resolve after three
58:25 - seconds and we showcase how to use
58:28 - promises
58:30 - in
58:31 - or having a promise being returned but
58:32 - we actually showcase how to create one
58:34 - you'll see here that we're create we are
58:36 - returning in this function a new promise
58:39 - with the resolve eventually being the
58:41 - data that we're going to pass that back
58:43 - in our instance here we're going to set
58:45 - a timeout for three seconds so promises
58:47 - are typically used with asynchronous
58:49 - calls or things that take time and
58:52 - in our case that's what we're returning
58:54 - so
58:55 - how might we solve this
58:57 - resolving that promise to get that
59:00 - resolved
59:01 - set and how might we solve this using
59:04 - async and a weight really take a second
59:06 - to see if you can solve this this is an
59:08 - important concept
59:10 - all right hopefully you're able to solve
59:12 - that if not don't sweat it this is a
59:14 - fairly new concept for most people
59:16 - javascript has been synchronous for some
59:18 - time and now we're learning to work with
59:21 - it asynchronously so how might we solve
59:23 - this using the promise then mechanism
59:26 - pretty straightforward if you remember
59:28 - our last example we are going to call
59:31 - our function resolve after three seconds
59:35 - and then we're gonna call the promise
59:38 - method
59:39 - dot then which takes in our return data
59:44 - it's successful and then we want to in
59:46 - our case just console.log that data
59:49 - which will fire off
59:50 - after
59:51 - three seconds right 3 000 milliseconds
59:54 - is one second so any day now there we
59:56 - have resolved the other way that we can
59:58 - go ahead and solve this is we can define
60:01 - a asynchronous function that uses async
60:03 - and away
60:05 - so let's go and define a function
60:07 - remember when we're defining async
60:09 - functions we use the async keyword and
60:11 - we'll say get
60:13 - async
60:14 - data
60:17 - and then at the end of course we're
60:18 - going to want to call this to call this
60:21 - function to go get that data
60:23 - now in here all we have to do is
60:26 - await
60:28 - await our output await our data using
60:31 - the await keyword
60:34 - so we we can store this in a result
60:36 - that'd probably be the most proper way
60:37 - of doing it
60:38 - cost result and then a weight
60:42 - the
60:42 - resolve after three seconds
60:45 - and then console.log that result which
60:48 - will happen in exactly three seconds
60:51 - so
60:52 - our data here it's all going to flow
60:54 - properly it's all going to work properly
60:55 - and now we're handling
60:57 - getting
60:58 - data from asynchronous places or when
61:01 - from asynchronous
61:03 - endpoints or in our case using promises
61:06 - with timeouts and
61:07 - it's another way that we can use this
61:09 - and uh important concept moving forward
61:12 - when you're trying to deal with with
61:14 - databases and getting data receiving
61:16 - data
61:17 - so i hope you found this helpful
61:23 - so this have been a great addition to
61:25 - javascript
61:26 - what they allow us to do is create a
61:28 - unique
61:29 - list now how might we go about creating
61:31 - a set we can start by just creating a
61:34 - variable
61:35 - and go ahead and say cons
61:37 - we'll just say example set is equal to a
61:40 - new set
61:42 - and then uh inside here we're going to
61:44 - throw in an array and let's throw in
61:47 - some duplicate values the reason for
61:48 - this is
61:51 - the to showcase the idea also um the way
61:54 - that babble's set up in scrimba right
61:56 - now it doesn't fully work
61:58 - in terms of um the way that it compiles
62:00 - to the console log so instead of
62:02 - actually printing out the example set to
62:05 - c it's just going to say set um no way
62:08 - around that right now at this time but
62:10 - the idea you'll see right here we have
62:12 - two unique values in here and that's all
62:14 - the set cares about the other values
62:16 - they don't even exist so when we want to
62:17 - see the size of it we can do it with the
62:19 - dot size you can see there's only two
62:23 - now let's say that we wanted to add to
62:26 - our set that we have created here we can
62:28 - do that with the add
62:30 - the add method and we could throw in a
62:33 - new value here five and this is going to
62:34 - add three and add works the same way
62:37 - where if the
62:38 - set already has a value
62:41 - it's not going to add it it's just going
62:43 - to basically ignore it and we can chain
62:45 - these as well if we wanted to let me go
62:47 - ahead and throw 17 in there and you'll
62:50 - see our set size continues to increase
62:53 - you can also remove
62:55 - values from set using delete one thing
62:57 - to keep in mind is a cool function of
62:59 - sets and in my opinion anyhow is that
63:02 - when you delete it
63:04 - it actually returns a boolean of true or
63:06 - false whether it was successful so let's
63:08 - say we delete five and we're gonna
63:10 - console.log this out
63:12 - what we're gonna get is true because the
63:14 - 5 exists in there
63:16 - and
63:17 - you'll see right here so then it of
63:19 - course removes it from our elements
63:21 - that's another side effect of the delete
63:24 - method
63:26 - we can also check if a value even exists
63:29 - in our
63:31 - set using the has
63:33 - properties so
63:34 - we still have five in this point and we
63:36 - want to say hey does this set have five
63:40 - and let's see it does it's true right
63:41 - and our size is four and then last but
63:43 - not least one more thing to mention is
63:45 - that we can actually clear out our
63:47 - entire set
63:49 - and reset it
63:51 - with clear and then you'll see our count
63:53 - here is going to be zero
63:55 - the last thing i want to mention is that
63:57 - a set is iterable so you can use things
64:00 - like for each on it and four of and all
64:02 - the great ways that you would normally
64:04 - iterate through
64:05 - a
64:06 - a interval
64:12 - let's just take a second to pat
64:14 - ourselves on the back for finishing this
64:17 - course because it is a hard thing to do
64:18 - so many people start courses out
64:21 - and they never get to the end they start
64:22 - it they forget about it they move on
64:24 - they go back to playing halo or doing
64:25 - whatever they're doing it is a hard
64:27 - thing to intellectually stimulate
64:29 - yourself as well as follow through with
64:31 - that so congratulations for you for
64:33 - finishing the course and as a favor for
64:36 - going through and making the content
64:37 - would you do me a favor and share the
64:40 - course for scrimba's sake as well as my
64:42 - own
64:43 - this was a great introduction course i
64:45 - really enjoyed making it and
64:47 - i hope that you enjoyed it as well and
64:49 - if you did
64:50 - sharing it goes miles and uh so what's
64:54 - next for you well
64:55 - given what we've equipped you with with
64:57 - now the introduction javascript and now
64:59 - the introduction to es6 plus
65:02 - you're ready to pretty much write
65:04 - anything so you can start practicing
65:06 - there's a bunch of wonderful tutorials
65:08 - on scrimba to practice in algorithms
65:10 - they uh build some projects or start
65:12 - your own project you have the skills and
65:15 - have been
65:16 - you know introduced to a ton of the core
65:18 - concepts that you should be ready to
65:20 - start building something in javascript
65:21 - so get out there start playing around
65:24 - and enjoy yourself