00:00 - how's it going everyone and welcome back
00:01 - to another video today we're going to be
00:03 - going through the numpy library which is
00:05 - considered to be kind of the fundamental
00:08 - package for all scientific computing in
00:11 - python so it's a super super important
00:13 - library uh
00:15 - it's kind of the base for a lot of the
00:16 - other
00:17 - like major data science libraries in
00:19 - python so like
00:20 - pandas that i've done a video on before
00:22 - it builds pretty much like entirely off
00:25 - of the numpy library so it's super
00:27 - important and kind of because it's
00:29 - important it's because it's this like
00:31 - base
00:32 - uh the way we're gonna do this video is
00:34 - i'm gonna start off with kind of a
00:35 - background information on how numpy
00:38 - works and i think really having that
00:40 - intuition is helpful for when you
00:41 - actually start writing code with it so
00:43 - we'll do the background information and
00:45 - then after that we'll jump into all
00:46 - sorts of useful
00:49 - methods and ways you can utilize this
00:52 - library as far as actual code goes as
00:54 - always make sure to
00:56 - smash that subscribe button throw this
00:58 - video a thumbs up uh
01:00 - follow my tweeters
01:02 - tweetergram instagram twitter github too
01:08 - hit the bell for the notifications
01:11 - throw this another thumbs up
01:13 - yeah
01:14 - to begin numpy is a multi-dimensional
01:17 - array library so what that means is you
01:19 - can use numpy to store all sorts of data
01:21 - in
01:22 - one-dimensional arrays two-dimensional
01:24 - arrays three-dimensional race
01:25 - four-dimensional rays etc
01:28 - and so the common question you kind of
01:30 - ask or i'm commonly asked when
01:33 - you know you first bring up numpy is why
01:35 - do you use numpy
01:37 - over
01:38 - lists so the main difference comes from
01:42 - the speed so lists they are very slow
01:45 - meanwhile numpy
01:47 - is
01:48 - very fast and so why are lists slow and
01:51 - numpy fast well one reason is because
01:54 - numpy uses fixed types
01:58 - so what that means is imagine we have
02:00 - this
02:01 - three by four matrix three rows four
02:04 - columns
02:05 - and it's all integer values and we're
02:07 - going to kind of look at how those
02:09 - integer values
02:10 - differ between numpy and lists so let's
02:13 - just zoom in on that 5 that's there in
02:15 - that matrix
02:17 - so our computers they don't c5 they see
02:21 - binary that represents five
02:25 - and so
02:27 - this is the number five in binary and
02:29 - it's eight
02:30 - bits which makes up a byte so our
02:32 - computers read uh information in bytes
02:36 - so when we use numpy
02:39 - this
02:40 - this one bit five is actually by default
02:44 - going to be
02:46 - casted to this int 32 type which
02:49 - consists of four bytes
02:51 - uh and so it represents five in
02:54 - a total memory space of four bytes
02:57 - so in 32 and you also you can even
02:59 - specify so by default it's in 32 but you
03:01 - could even specify that you didn't need
03:04 - all four bytes to represent this value
03:06 - so you could specify within numpy that
03:08 - you wanted maybe an n16 which is 16 bits
03:11 - or two bytes or even if you had really
03:14 - small values
03:15 - into eight which is just a single byte
03:17 - on the other hand
03:18 - with lists
03:22 - there's a lot more information you need
03:24 - to store as an integer so
03:26 - in lists lists use a built-in int type
03:30 - for python and so that built-in in type
03:33 - consists of four different things it
03:34 - consists of the object value
03:37 - which you know has its own bits
03:40 - associated with it object type
03:42 - the reference count how many times that
03:44 - that
03:45 - integer has been specifically like
03:47 - pointed at and the size of that integer
03:50 - value
03:52 - and so if we break this up into the
03:54 - actual binary that it represents we can
03:57 - take the object value
03:59 - and that's represented as a long which
04:01 - is like 8 bytes
04:03 - the object type same deal reference
04:05 - count same deal and then the size i
04:07 - believe is a little bit smaller
04:09 - i think it's only 4 bytes but as you can
04:11 - see that's a single integer within lists
04:14 - using the built-in int type
04:16 - it requires a lot more space than numpy
04:19 - so basically the takeaway from this is
04:23 - that
04:24 - because numpy uses less bytes of memory
04:28 - the computer can read less bites of
04:30 - memory quicker obviously so it's faster
04:33 - in that regard
04:35 - another reason that i didn't
04:36 - specifically say is that
04:39 - when we're iterating through each item
04:41 - in a numpy array we don't have to do
04:44 - type checking each time so in python
04:46 - built-in lists you could have a list of
04:47 - like an integer then a float then a
04:49 - string then a boolean
04:52 - and you'd have to check each element
04:53 - you're looking at what type it is but
04:56 - numpy we don't have to do that so
04:57 - another reason it's faster is that
04:58 - there's no type checking when
04:59 - integrating through objects
05:01 - moving on another reason that numpy is
05:04 - faster than list is because numpy
05:06 - utilizes contiguous memory so what that
05:09 - means is imagine that
05:10 - this kind of array-like structure is our
05:14 - computer's memory so we could store
05:16 - information in any one of these memory
05:18 - blocks
05:20 - so if we had a list
05:21 - the way that that would look in a list's
05:23 - memory
05:24 - is that our list would be kind of
05:27 - scattered around so maybe we have a
05:29 - list that takes up eight memory blocks
05:32 - the thing is that these memory blocks
05:34 - aren't
05:35 - necessarily next to each other so you
05:37 - have some information here you have some
05:38 - information here you have a good amount
05:40 - of information in here
05:42 - then you skip a block here here and skip
05:44 - two blocks you have some information
05:45 - here so it's all kind of scattered
05:47 - around
05:49 - so kind of if you have an eight item
05:51 - array what that looks like is that that
05:54 - array is actually just
05:56 - or that list is just
05:59 - um containing pointers to the actual
06:02 - information that's scattered around our
06:04 - computer's memory
06:07 - and so
06:08 - it's just that all the information is
06:10 - not right next to each other kind of you
06:11 - have to
06:12 - bounce around your computer's memory a
06:14 - bit and it's not super super fast to
06:17 - like rapidly go through and
06:19 - kind of
06:20 - potentially perform functions on all
06:23 - items at a time or subsets of the items
06:26 - a numpy array however uses contiguous
06:30 - memory so
06:31 - all eight blocks in this case would be
06:33 - right next to each other and this has
06:35 - all sorts of advantages um and also just
06:38 - to mention real quick you'd also kind of
06:40 - have to have to store somehow where the
06:42 - start of that memory is and then like
06:44 - the total size and the type of
06:47 - memory block
06:48 - but it's a lot easier than this kind of
06:51 - pointer structure that's up here
06:53 - and so the benefits of numpy using this
06:56 - contiguous memory are a couple of
06:58 - different things so
07:00 - the first benefit is that our cpus our
07:04 - our computers have these
07:06 - cindy
07:07 - vector
07:08 - processing units and so when this memory
07:11 - is all like right next to each other we
07:12 - can utilize this
07:14 - unit and basically what cimd stands for
07:16 - is single instruction multiple data
07:20 - so we can like if we have to do an
07:21 - addition of like a lot of values
07:24 - instead of just doing one addition at a
07:25 - time we can use this cmd vector unit and
07:28 - basically perform
07:30 - computations on all these values at one
07:33 - time
07:34 - so it's quicker in that regard another
07:36 - reason it's quicker is that we more
07:38 - effectively utilize our cache so our
07:41 - kind of our quicker memory in our
07:42 - computer basically if we load in all
07:45 - these values
07:46 - we can keep them
07:48 - close to where we need to access them
07:51 - and like perform all sorts of operations
07:53 - while as in the list case you'd maybe
07:55 - load in like half of this but then this
07:58 - other half because it's scattered around
08:00 - in different places you'd have to like
08:02 - go back and like reload that in
08:06 - uh to your cache
08:07 - like
08:09 - you know just be overall slower because
08:10 - you'd have to do more like longer memory
08:12 - lookups within your computer
08:15 - okay so we kind of went over some of the
08:17 - performance benefits but how are lists
08:19 - different from numpy
08:21 - well lists we can do insertion deletion
08:23 - appending concatenation etc and we can
08:26 - also do those same exact things in numpy
08:29 - i guess the big difference though is
08:31 - that within numpy we can do all that
08:34 - and we can do lots and lots more and
08:36 - we'll see the lot slots more
08:38 - throughout the video but as a simple
08:41 - example imagine we have
08:43 - these two arrays
08:45 - one thing that we can do that's really
08:46 - nice in numpy is that if we try to
08:48 - multiply these one item at a time
08:52 - we could do that in in lists you
08:55 - couldn't multiply one and one three and
08:57 - two
08:58 - uh five and three
09:00 - um etc but when we do the exact same
09:03 - computation within numpy it allows us to
09:05 - do these you know single value like
09:09 - item-wise
09:10 - computations which is pretty neat and
09:12 - pretty useful so that's one example and
09:15 - you'll see a lot more throughout the
09:16 - video uh so applications are known by
09:18 - there's all sorts of applications i
09:20 - think the first one the kind of the
09:21 - first one that comes to my mind is that
09:23 - is a kind of a
09:25 - matlab replacement you can do all sorts
09:28 - of mathematics with numpy i think i
09:30 - should say that i think the scipy
09:32 - library
09:34 - has even more mathematics like functions
09:37 - and whatnot so if numpy isn't cutting it
09:39 - for you
09:40 - try to look through the scipy
09:42 - documentation you might be able to find
09:44 - even more but yeah it's pretty powerful
09:46 - the math that numpy can do
09:49 - it's useful in plotting it is
09:52 - the back end of many different
09:54 - applications so pandas
09:56 - which i've done a video on before
09:58 - it is just like the core
10:01 - component of pandas library it really
10:03 - allows pandas to work
10:05 - um if you've seen my connect 4 how to
10:07 - program that video i use numpy to store
10:10 - the board
10:12 - and then in future videos i'm going to
10:13 - do
10:14 - you can you can actually store
10:16 - images uh through numpy so like png
10:20 - images you can use numpy to store all
10:23 - the information and like do all sorts of
10:24 - cool stuff that i'll uh post future
10:26 - videos on
10:28 - uh let's see also
10:30 - another i think useful reason to know
10:33 - numpy is that it's kind of like pretty
10:36 - important for machine learning
10:37 - applications
10:39 - both directly and then also kind of
10:41 - indirectly because
10:43 - one of the key
10:45 - libraries or key kind of concepts you
10:47 - learn with
10:48 - machine learning is the idea of like
10:50 - tensors
10:52 - and tensors are pretty connected to kind
10:54 - of like the tensor libraries are pretty
10:57 - similar to like the numpy library it's
10:59 - just a way to store all sorts of values
11:01 - so
11:02 - knowing numpy will help you
11:04 - kind of
11:05 - be able to do some stuff with machine
11:07 - learning
11:08 - all right to get started with the code
11:10 - the first thing you're going to do is
11:11 - import the numpy library
11:13 - and just so we're on the same page i'm
11:14 - using a jupiter notebook to use to code
11:17 - this up but you can use whatever editor
11:19 - you prefer also all this code that i'll
11:21 - be going through will be on my github
11:23 - and the link to that will be in the
11:25 - description
11:26 - okay so import numpy as np if that works
11:29 - for you great if it didn't work you'll
11:31 - have to do a pip install
11:33 - so you can go ahead into your terminal
11:36 - and type in pip install numpy
11:45 - and so
11:46 - uh it's already installed for me
11:48 - so
11:50 - and if pip doesn't work for you try pip
11:52 - 3 install numpy that should work
11:54 - so the first thing that's important to
11:55 - know is how to initialize an array so
11:58 - we'll just say that a equals
12:00 - np dot array
12:03 - and then within this we just basically
12:05 - pass in a list
12:06 - so one two three this would be a one
12:08 - dimensional array containing the values
12:10 - one two three
12:12 - as you see
12:13 - uh and you can go ahead you're not using
12:15 - jupyter notebooks and print a
12:18 - okay cool so we could also initialize a
12:20 - little bit more complex arrays so we
12:22 - could
12:23 - do like a 2d array of floats and i could
12:25 - do that the following way
12:28 - we're going to have a list within a list
12:34 - so here's some floating values and then
12:37 - we're going to make this two dimensional
12:39 - so here's some more
12:40 - float values
12:46 - and let's go ahead and
12:49 - print b
12:51 - cool so now that we know how to
12:53 - initialize arrays uh and you can keep
12:56 - doing this like i can nest lists within
12:59 - a list within a list to create a
13:00 - three-dimensional array etc
13:03 - some other useful things to know about
13:05 - this is
13:06 - how to how do you get the dimension of
13:10 - your
13:11 - numpy arrays so if i did a dot
13:16 - number dimensions
13:18 - so this tells me that it's one
13:20 - dimensional for a and if i did b dot and
13:23 - m
13:25 - it would be two
13:26 - shape is another important function so
13:28 - get shape
13:30 - uh if we do the first one a dot shape
13:32 - this is all we have to do it's a vector
13:34 - so it's only going to tell me the one
13:36 - dimension because it only has one
13:37 - dimension so it's size three
13:40 - if i do b dot shape it's going to tell
13:41 - me the rows and the columns so this is
13:43 - two rows and three columns so it should
13:45 - print out two by three as it does
13:49 - okay other things we want to know how
13:51 - much memory our numpy arrays take up so
13:54 - we can get the type and also get the
13:56 - size so
13:58 - if we want to get the type we do
14:00 - just a dot type
14:05 - oh sorry a dot data type
14:07 - in 32 by default
14:10 - so even though these are small values by
14:12 - default it specifies that it should take
14:15 - up four bytes or be an n32 if we wanted
14:18 - to specify what type we wanted to store
14:21 - at so maybe we knew that we didn't have
14:24 - many like big values
14:26 - so we could do like an n16 and so that
14:29 - would take up less size and you can see
14:31 - the difference in size and i say
14:35 - so right now it's in 16 and if i want to
14:37 - see
14:38 - the size there's a couple different i
14:40 - guess important functions with this
14:42 - we could do a dot item size
14:44 - so this should tell me two bytes
14:47 - as it does
14:48 - if we left this as an int 32
14:52 - it will tell me
14:54 - four bytes down here
14:57 - as it does
14:59 - you can also do i think
15:03 - the total size
15:11 - um i guess a dot size
15:13 - is
15:15 - uh the total number of elements so the
15:17 - total size would be
15:18 - a dot size times a dot item size
15:22 - um another way to do that is i think
15:24 - just number of bytes
15:26 - as you see that's the same thing
15:28 - and
15:29 - um
15:31 - you can also do this with b it's like b
15:33 - dot item size
15:35 - bs are floats and i believe that this is
15:37 - an eight byte type so if i do b item
15:39 - size as you see yeah it's eight so
15:42 - floats are going to be bigger than
15:44 - um
15:46 - floats are bigger than integers
15:49 - usually unless you define this as like
15:51 - an int 64.
15:53 - and so yeah you really i usually don't
15:55 - even worry about the data type too much
15:56 - i don't specify it but if you really
15:58 - want to be efficient try to specify this
16:01 - so that it fits all your data
16:03 - but um
16:05 - if yeah i guess it fits all your data as
16:07 - tightly as possible all right so now
16:09 - that we've gone through some of the
16:10 - basics let's actually show how we access
16:12 - change specific elements rows columns
16:15 - etc so imagine we have the array
16:21 - there's gonna be a two dimensional array
16:23 - so
16:24 - i'm gonna make this kind of long and
16:26 - you'll see why in a second
16:33 - okay so this is a two by seven
16:37 - array
16:38 - if i print that out
16:42 - okay and i could
16:44 - prove that it's a two by seven by doing
16:45 - a dot shape that's just a reminder
16:48 - so what if we wanted to get this a
16:50 - specific element
16:53 - well to do that we can use this notation
16:57 - of row comma column
17:00 - so this is the row index this is the
17:02 - column index so i could just do
17:03 - something just like a
17:07 - let's say i wanted to get this 13 right
17:10 - here well that would be in the
17:12 - second row but because we started python
17:14 - indexing at zero be the first row
17:17 - and then the
17:18 - zero one two three four five fifth
17:22 - column
17:24 - so yeah that gives us the 13 as you see
17:27 - down here and one thing that's kind of
17:29 - cool is you can also
17:31 - use the negative notation similar to
17:33 - lists so i could also say the negative
17:36 - second element would be
17:38 - 13 as well because this would be
17:39 - negative 1 and then negative 2.
17:42 - so there's a couple different ways to do
17:43 - this but we'll stick with the first one
17:46 - okay let's say we wanted to get a
17:47 - specific
17:52 - i can't spell
17:54 - row
17:55 - that's pretty straight forward as well
17:57 - so in this case if we wanted the first
17:59 - row we would do zero and then because we
18:01 - want all columns we use the basic slice
18:04 - syntax similar to lists i can just do a
18:06 - single column
18:08 - and that will get me everything in the
18:09 - row
18:10 - that's nice what if we want a
18:12 - specific column well if you know how to
18:15 - do rows you probably know how to do
18:16 - columns a let's say we wanted
18:19 - this row right or this column right here
18:21 - three and ten
18:23 - that would be all the rows and then the
18:25 - zero one
18:26 - two column
18:29 - that gives me the 310
18:31 - and from here we can do even some more
18:32 - like tricky stuff so
18:34 - um
18:35 - [Music]
18:36 - uh
18:39 - let me just say getting
18:40 - a little more fancy
18:43 - and we have the
18:45 - start index
18:46 - this is just a reminder start index
18:49 - end index
18:50 - and then finally the step size
18:54 - so if i wanted to let's say get
18:57 - between the numbers two and six every
19:00 - other element so two
19:01 - four and six
19:03 - well to specify that i would do
19:07 - well i want the first row
19:09 - and then i want to start at the first
19:11 - element
19:13 - the two
19:14 - and i actually screw that up it should
19:16 - be one so i start at the two then i want
19:18 - to end here at the six
19:20 - which is the
19:24 - it's exclusive so that would be
19:26 - uh i want to actually go to the sixth
19:28 - element and then i want to
19:30 - step by two because i wanted two four
19:32 - six so i do one six two
19:34 - and that gives me two four six and i can
19:37 - also use the negative here and do like
19:40 - negative two
19:41 - ah what happened there oh shoot that was
19:44 - going backwards i didn't want to change
19:45 - it there i wanted to change the six to
19:48 - be negative two
19:50 - ah okay it's exclusive so i wanted this
19:52 - to actually be negative one
19:54 - a little bit more of a fancy way to do
19:56 - that
19:57 - okay so that's how you access elements
20:00 - and then if we wanted to change
20:01 - something it's pretty straightforward
20:02 - too let's say i wanted to change that 13
20:05 - that i originally accessed
20:07 - well i can just do
20:09 - like
20:10 - 20.
20:11 - if i print out a now
20:15 - that original element that was 13 is now
20:17 - 20
20:18 - and you can do the same thing for
20:20 - um
20:22 - series of numbers so like for an entire
20:24 - column let's say we wanted to replace
20:25 - this 310 column
20:27 - i would do something like
20:30 - a
20:32 - colon two
20:35 - equals let's say i wanted it to be all
20:37 - fives
20:39 - i could start like this
20:42 - and as you see it's all fives five five
20:45 - and then if i wanted it to be two
20:46 - different numbers you just kind of
20:48 - specify the same shape as
20:50 - what you've subsequent so it'd be like
20:52 - one two
20:54 - so now you see that we have a one two in
20:56 - that's position
20:59 - really quickly let's just show a 3d
21:02 - example
21:04 - if i had a 3d so we'll say b equals
21:13 - numpy array of all this and if i print
21:18 - b
21:23 - so if we want to get a specific element
21:25 - here
21:26 - the recommendation i have is work
21:28 - outside in so work outside in so let's
21:31 - say i wanted this four right here
21:34 - well the farthest outside would be which
21:37 - one of these do i want and i want the
21:39 - first set so i want this area right here
21:42 - so if i wanted that i would do b
21:45 - zero and then now that i'm in here i
21:48 - want the second row
21:50 - so i want the three four
21:52 - so that would be one
21:53 - and now that i'm within this i want the
21:57 - first
21:58 - or the second yeah the second element
22:00 - but the first index
22:02 - like that so that gives me the four and
22:04 - you can do similar type stuff with like
22:06 - the colons in here so each one of these
22:09 - dimensions that you're indexing you can
22:11 - be all fancy with
22:13 - uh how you access elements so i can do
22:15 - something like this
22:17 - and
22:18 - you know get three four seven eight you
22:21 - can kind of play around with this and
22:23 - see how
22:24 - changing different things changes what
22:26 - you get
22:28 - and if you wanted to replace in this
22:29 - case
22:30 - um
22:32 - basically you just have to create a
22:34 - subsequence that's the same dimension
22:36 - so if i did b
22:39 - one
22:40 - this that gives me three four seven
22:42 - eight let's say i wanted to change that
22:44 - to
22:45 - nine nine
22:48 - eight eight
22:51 - as long as it's the same dimension
22:53 - it's gonna work so nine nine eight eight
22:55 - if i try to like do something like nine
22:57 - nine nine eight eight it's gonna have an
22:59 - error
23:00 - all right so that's the basics of
23:02 - indexing
23:03 - i think by the at the end of the video
23:05 - i'll do a little like
23:06 - um challenge problem on like some
23:09 - advanced indexing so look at the end of
23:12 - the video for that all right next let's
23:14 - go through how to initialize all sorts
23:15 - of different types of arrays so to start
23:18 - off let's uh initialize in all zeros
23:21 - matrix
23:24 - and to do that there's a nice built-in
23:26 - function called np.zeros
23:30 - and we can first i guess actually all we
23:32 - really need to do is specify a shape so
23:35 - i did like mp05 it's gonna just give me
23:37 - a vector of five length five but i also
23:40 - can pass in
23:42 - a
23:42 - more complex shape so if i wanted it to
23:44 - be like a two by two or two by three
23:47 - let's say
23:48 - as you see there i could do three
23:50 - dimensional two by three by three
23:52 - you could even do four dimensional if i
23:54 - wanted to
23:55 - two by three by three by two
23:57 - it gets pretty crazy but yeah uh you can
24:00 - do all sorts of
24:03 - zeros with that
24:06 - next let's do an all ones matrix pretty
24:09 - similar to the last one and p dot ones
24:13 - of
24:15 - let's say
24:16 - four by two by two
24:20 - and there you go and you can also
24:22 - specify the data type here so if you
24:24 - wanted like all ones but in 32
24:28 - uh you can go ahead and do that so all
24:31 - ones
24:32 - all zeros
24:34 - however you might want to initialize a
24:36 - matrix that's not
24:39 - ones or zeros any other number
24:42 - so for that you can do np.full
24:45 - and this one takes in two parameters so
24:47 - the first is the shape so
24:50 - two by two and then the next is the
24:53 - value so if i wanted all 99s
24:55 - [Music]
24:56 - then it's a two by two with
24:58 - 99 another useful
25:02 - and you can you know that has a data
25:04 - type too so if i wanted that to be float
25:06 - 32
25:08 - there you go
25:13 - and i'll put a link in the description
25:15 - to a list full of these like array
25:17 - creation routines
25:19 - uh useful to know is there's also this
25:23 - full like um
25:29 - there's this full like method and
25:32 - basically that just allows us to take a
25:34 - shape that's already built so let's
25:36 - imagine
25:37 - we wanted to reuse that
25:41 - this array that we i guess had in in the
25:44 - last section
25:45 - a
25:46 - well i think it's still loaded and let
25:48 - me just make sure
25:49 - well i can pass in and make a
25:53 - array that's the same size size
25:57 - of fours let's say by doing full
26:01 - like
26:04 - or actually i think i don't even have to
26:05 - pass in
26:07 - a dot shape
26:08 - i just have to pass in a
26:11 - there we go if i didn't use full like i
26:13 - would have to do full
26:15 - of
26:16 - a dot shape i don't know if that's that
26:17 - useful for you but
26:19 - i guess it's potentially good to know
26:25 - okay next one let's say we wanted to
26:29 - initialize
26:31 - a
26:33 - array or a matrix of random numbers so
26:37 - random decimal numbers to start
26:41 - to do that we do np dot random.rand
26:46 - and we specify the shape
26:47 - so let's say four by two
26:50 - oh no what did i do wrong
26:52 - uh
26:55 - huh
26:56 - actually confused
27:00 - tuple state
27:02 - oh
27:06 - okay yeah this one's a little bit
27:07 - different so instead of passing in a
27:10 - tuple you can pass in directly the
27:12 - integers you wanna
27:14 - the integers of the shape so it's a kind
27:16 - of a weird thing to remember
27:18 - so if i did the 4x2 this way i would
27:21 - actually pass it in like that and when
27:22 - you get errors like this oftentimes you
27:24 - can just do a quick google search
27:26 - and realize that that's what you need to
27:28 - do so i can even keep going so i could
27:30 - do a four by two by three
27:32 - of random numbers between 0 and 1.
27:36 - i could also pass in something like
27:38 - a dot shape i don't know if this would
27:40 - work let's try
27:43 - yeah so if you wanted to pass in like a
27:46 - shape you can do a random sample
27:49 - a dot shape
27:51 - and that now you see
27:53 - gives us the same shape as our a from
27:57 - up here
27:59 - so yeah rand and then there's random
28:02 - sample which is another method
28:05 - we'll keep it as random four by two
28:08 - okay what if you didn't want just
28:10 - decimal numbers but you wanted random
28:12 - like integer values
28:17 - well to do that
28:18 - we can do
28:21 - random.rand
28:24 - i'm getting
28:25 - np.random.brandint
28:28 - and in this one we're gonna pass in the
28:30 - start value or if you don't specify a
28:32 - start value it's gonna just start at
28:34 - zero
28:36 - um
28:37 - and so if you don't specify a shape then
28:40 - it's just gonna do one number so let's
28:42 - say we wanted a three by three
28:45 - ah what did i do wrong
28:47 - and this is not shaped it's actually
28:50 - size
28:52 - and yeah all the documentation has these
28:54 - like you know you're not expected to
28:56 - memorize all of these things what i
28:58 - think it is helpful to see is that you
29:00 - see that you can do these types of
29:01 - things so like when you're thinking
29:03 - about a problem
29:04 - you can like kind of point back like oh
29:06 - i remember that that's possible
29:08 - uh maybe do a google search on how to
29:10 - get it but yeah random.random07
29:15 - with size 3x3 is here you can also
29:18 - specify like a different parameter so
29:20 - let's say i wanted four to seven
29:22 - and i think and if i keep running this
29:24 - too it's kind of cool you can see it
29:26 - changing and so it looks like that seven
29:28 - is exclusive so if i wanted to include
29:30 - seven i would stop a little bit later
29:32 - you could also throw in like negative
29:34 - numbers here
29:37 - cool
29:39 - all right uh what else other than a
29:41 - random integers maybe you wanted to do
29:43 - like the identity matrix you do
29:46 - identity of three this one only needs
29:48 - one parameter because the identity
29:50 - matrix
29:52 - by its nature is going to be a square
29:55 - major matrix
30:03 - what else is useful
30:07 - maybe it's useful to repeat a array a
30:10 - few times so to do that you could do
30:12 - say we had the array
30:15 - um
30:16 - one two three
30:19 - let's say i wanted to repeat that
30:22 - three times
30:28 - pass in the array you want to repeat
30:30 - and then that's print r1 see what
30:32 - happens
30:35 - okay
30:36 - and then if i specify the axis equals
30:39 - zero oh no it did do anything
30:41 - uh
30:42 - what i can do is make this a two
30:43 - dimensional array i think because it was
30:45 - a vector it didn't do what i wanted to
30:47 - what i wanted to do is one two three or
30:50 - one two three
30:52 - one two three
30:53 - one two three
30:55 - so if i wanted to do that
30:58 - now i made this a two dimensional array
31:00 - and it will repeat the inner part
31:03 - uh on the zeroth axis so it'll be
31:05 - basically making it rows
31:07 - there you go so if i made this
31:10 - equal to one that's going to be what we
31:12 - saw before
31:16 - cool
31:34 - okay so next here's a picture
31:37 - of an array i want you to try to
31:38 - initialize using everything that we kind
31:40 - of just went through
31:42 - so all these different methods
31:44 - so look at this picture and then try to
31:47 - put it together without just manually
31:49 - typing out all the numbers because you
31:50 - can imagine like this isn't too too big
31:53 - but if you got into a matrix that was
31:56 - massive you'd want to know how to build
31:58 - it up using these kind of like
31:59 - fundamental concepts
32:02 - okay so here's the solution to that so i
32:04 - can do
32:05 - output equals
32:08 - i'm going to start with making
32:09 - everything ones
32:11 - so ones and it's gonna be a five by five
32:14 - of ones
32:17 - print output
32:20 - so this is what i have now
32:22 - okay and now basically what we're gonna
32:24 - do is fill in this middle part with
32:26 - zeros
32:27 - so
32:28 - z i'm going to just say equals np dot
32:31 - zeros and that's going to be a three by
32:33 - three
32:34 - and if i print
32:36 - z now we have this
32:40 - now what i can do is fill in
32:42 - the
32:44 - middle element so that's 1 1
32:46 - with a 9
32:49 - and now if i print z we get this and
32:51 - then finally we need to replace the
32:53 - middle part of the ones matrix so output
32:56 - the middle part so that's going to be
32:58 - the first row to the
33:01 - third row
33:04 - so i want the
33:06 - first row to the third row and then i
33:08 - want the same thing with columns because
33:10 - it's the middle
33:11 - first column to the
33:13 - third column and actually this is an
33:15 - exclusive value so it needs to go to
33:17 - four
33:18 - and that's going to equal
33:19 - [Music]
33:22 - z and now what happens when i print
33:26 - output
33:29 - is yay we got what we're looking for and
33:31 - actually one thing that i think is nice
33:33 - is
33:33 - instead of using four i can also do
33:35 - negative one so basically the from the
33:37 - first element to the last element
33:40 - uh
33:41 - do that and as you see it didn't change
33:43 - this last initialization i want to go
33:45 - through i guess is a little bit
33:46 - different it's uh over on the concept of
33:49 - copying but something you got to be
33:50 - really careful about so i'm just going
33:52 - to quickly mention it
33:59 - i want to do explanation points there we
34:00 - go
34:01 - um okay so imagine we have two
34:05 - arrays
34:06 - or we have one array
34:09 - let's call it a
34:11 - and so now a is just a normal array
34:14 - as you can see
34:15 - and let's say we want to make b a direct
34:18 - copy of a so now i'm going to just do b
34:21 - equals a
34:23 - and then print out b and as you can see
34:27 - it's still one two three
34:29 - and so i'm like okay i have this copy
34:31 - like things are cool it's fine
34:33 - i want to change the first element in b
34:35 - so i'm going to do b zero equals
34:37 - 100.
34:40 - here's the issue
34:41 - my printout b
34:43 - looks good
34:44 - the issue lies in if i print out a
34:47 - look what happens
34:49 - i just printed out a
34:51 - and a now has
34:54 - a 100 instead of the 123 that i
34:56 - initially set it as
34:58 - and that's because when we did b equals
35:00 - a we just said that
35:02 - the
35:03 - the variable name b points the same
35:06 - thing as a does we didn't tell like
35:09 - numpy to
35:10 - make a copy of what is
35:12 - the contents of a
35:14 - so that's that's why because we're just
35:16 - pointing at the same exact thing that a
35:18 - is pointing when we change the value it
35:20 - also changes the value of a
35:22 - so if we want to prevent that we can use
35:24 - this dot copy function oh sorry i
35:26 - shouldn't do it yet um b equals a dot
35:29 - copy
35:31 - and then when we run the cell as you can
35:33 - see one two three
35:35 - it's still there because now we're just
35:37 - copying the contents of what's in a
35:40 - and if i print b
35:42 - it has the 100 200
35:44 - 100 2 3. okay so one of the big uses of
35:47 - numpy is all the math capabilities it
35:49 - offers
35:51 - um so just to kind of show some of that
35:54 - um one thing that it can do is
35:56 - element-wise um
35:58 - i'll just make those four values
36:00 - element-wise addition subtractions
36:02 - element y is i guess arithmetic so
36:05 - here we have a
36:07 - print out a
36:09 - um and if i wanted to do something like
36:12 - a plus two
36:14 - um adds two to each element you can do a
36:16 - minus two
36:18 - subtract two from each element a
36:20 - times two
36:22 - as you can see
36:23 - uh a divided by two
36:28 - um
36:29 - divides everything by two
36:31 - uh one thing to note with and you can
36:33 - also do stuff like
36:34 - uh a plus equals two so now i printed
36:37 - out a
36:39 - in this column
36:41 - it's going to be
36:43 - 2 plus everything
36:46 - it's kind of cool you can do like the
36:47 - same type of math that you can do in
36:50 - python
36:52 - you can also create another array an
36:54 - mp.array
36:56 - and that's like let's say
36:59 - one
37:00 - zero
37:01 - one
37:03 - zero
37:04 - and i could do something like a plus b
37:06 - and that should be two two
37:09 - four four
37:10 - oh and because i added
37:12 - if i rerun this okay two two four four
37:15 - like we expect
37:16 - uh so all sorts of useful things you
37:18 - could even do like a to the second power
37:24 - 1 4 9 16 and that might have made it a
37:26 - bigger data type i'm not sure
37:28 - um
37:29 - cool
37:31 - we can do stuff like
37:33 - take the sine of all the values so let's
37:36 - say we had a we do np dot sine pass in a
37:42 - gives us all the
37:44 - sinusoid of all those values which
37:46 - you know and you have like the cosine of
37:49 - all those values
37:50 - all sorts of useful things that you can
37:52 - form on an entire array or entire matrix
37:55 - all at once and if you want all the
37:58 - different things that you can do
38:01 - i'll paste in a link
38:02 - here this will all be part of the as i
38:05 - mentioned before i have this on my
38:06 - github so if you look in the description
38:09 - you can find this exact notebook
38:12 - so yeah look up the routines right here
38:16 - for math all sorts of cool stuff
38:20 - all right
38:21 - moving on we're gonna still be in math
38:24 - but let's jump into
38:26 - linear algebra type stuff so here we are
38:29 - doing linear algebra
38:32 - so this is kind of like basic
38:34 - all sorts of functions you can do on
38:35 - elements
38:36 - uh linear algebra so this is like really
38:38 - i feel like when i'm using matlab it
38:40 - would be doing these linear algebra type
38:42 - stuff so let's say we have two matrices
38:46 - and the big difference with linear
38:48 - algebra is like we're not doing element
38:50 - wise so like
38:52 - in this case this b
38:54 - we're doing element-wise computation so
38:57 - like a times b
39:02 - in you know linear algebra you're trying
39:04 - to multiply matrices and that's a
39:06 - different process so let's say we have
39:10 - two matrices we'll have a
39:12 - and i'm going to use the syntax we
39:13 - learned about earlier i'm going to say
39:15 - this is a 2 by 3 matrix of all twos
39:21 - or actually let's make this
39:24 - 2 by 3 matrix of ones
39:27 - so we have a
39:29 - as you can see and then we'll have
39:33 - b which is equal to np dot full
39:37 - it's going to be a 3 by 2
39:40 - and it's going to be a value 2.
39:43 - so if i print out b
39:45 - now we have this and if you remember
39:48 - linear algebra you have to have the
39:50 - columns of the first matrix be the equal
39:53 - to the
39:54 - rows of the second one so as you can see
39:56 - this says three columns and this has
39:58 - three rows so we're good there so we
40:00 - would multiply this row by this column
40:03 - um and you know you do the the process
40:06 - of matric multiplication we're not going
40:07 - to walk through the whole thing but we
40:08 - should end up with a 2
40:11 - by 2 matrix at the end if we want to do
40:16 - matrix multiplication and it doesn't
40:17 - just automatically occur if you try to
40:19 - do a times b
40:20 - it's not going to work because these are
40:22 - different sizes so we can do is mp has a
40:25 - matrix multiply function and if i pass
40:27 - an a then pass in b
40:30 - we get
40:32 - 6 6 6 6. did i say enough sixes
40:36 - i don't know but uh yeah it uh multiply
40:39 - those two matrices
40:40 - um
40:41 - you know and if i try to switch up this
40:43 - dimension in the middle
40:45 - uh it's not gonna work because it's now
40:47 - incompatible
40:50 - uh yeah that's matrix multiplication
40:53 - you could also want to do maybe some
40:54 - other stuff with matrices so let's
40:56 - imagine i wanted to create the or to
40:59 - find the
40:59 - [Music]
41:01 - um
41:02 - let's say determinant of a matrix so
41:05 - we could as a sanity check you know make
41:07 - c equal the
41:09 - identity matrix and if you are familiar
41:12 - with linear algebra you know that
41:14 - the identity matrix has a determinant of
41:16 - one
41:18 - so if i do linear algebra dot
41:20 - determinant
41:22 - of c we should get one
41:24 - 1.0 as we get so
41:27 - find the determinant
41:31 - you know there's all sorts of other good
41:33 - things like eigenvalues
41:36 - you know the inverse of a matrix so what
41:40 - what do you multiply by a matrix to get
41:42 - the identity matrix
41:44 - um
41:45 - and so yeah all sorts of good stuff on
41:47 - that
41:48 - like i guess i'll do
41:52 - and if you want to have all this
41:54 - information on the other types of linear
41:56 - algebra stuff
41:58 - here is some useful information
42:01 - definitely go to this link and as i've
42:03 - said a couple times in this video
42:06 - this notebook is on my github page so
42:08 - you can find
42:09 - all this there but yeah there's so many
42:12 - different things that you can do
42:13 - with matrices and linear algebra using
42:16 - the numpy library
42:19 - okay continuing onwards let's look at
42:23 - some
42:25 - statistics with numpy
42:28 - so kind of the easiest things we might
42:30 - think about when we think about
42:34 - sorry
42:35 - um statistics there's like min mean max
42:38 - etc
42:40 - so let's say we have this array
42:45 - so let's say we want to take the min of
42:46 - it you can just do np.min
42:49 - of stats
42:51 - that's going to give us the one that you
42:53 - see there you can do
42:54 - mpmax of stats
42:58 - six you could also do it
43:00 - on like a row basis so if i said axis
43:03 - equals one
43:04 - that's going to give me the min of the
43:07 - first row and the min of the
43:10 - second row or maybe this is a better way
43:12 - to see it if i said x is equal to zero
43:15 - well it's going to give me all the
43:16 - values that are up top here because
43:17 - those are all the the mins
43:20 - uh so yeah you can do all sorts of cool
43:23 - stuff with min and max with this
43:27 - same thing with max let's say x is equal
43:29 - to zero
43:32 - x equals one
43:34 - three and six is the biggest value
43:36 - three is the biggest value and the six
43:38 - is the biggest value you can also do
43:40 - np.sum of stats if i do it
43:43 - just as is it's going to sum up all the
43:45 - elements in the
43:47 - matrix and then same thing i can do row
43:50 - or column
43:51 - so
43:53 - actually equals 0 is going to add up all
43:55 - these terms going downwards next let's
43:58 - talk a little bit about reorganizing
44:00 - arrays so kind of the i would say the
44:02 - key method within reorganizing arrays so
44:04 - if i have the array i'm going to call it
44:06 - before
44:10 - and let's say that that is equal to
44:13 - this value right here
44:15 - so we have before i'll print before out
44:20 - looks like that so let's say we wanted
44:22 - to instead of this
44:24 - shape that it currently has which is a
44:27 - two by four
44:29 - um let's say we wanted to make it a
44:33 - i don't know a
44:35 - eight by one or something or maybe a
44:38 - four by two um
44:40 - or a yeah all sorts of different things
44:42 - we could do i'll start with eight by one
44:44 - so we have before
44:46 - and if we wanted to make it something
44:48 - else we can do after equals
44:51 - before dot reshape and then we pass in
44:54 - the new size we want it to have so if we
44:57 - wanted it to be an eight by one
44:59 - you can pass it in like that and we can
45:00 - print out after
45:03 - as you can see it's an eight by one now
45:06 - i could also say maybe i wanted it to be
45:08 - a four by two
45:09 - so now you got that
45:11 - you could even pass it in as a
45:14 - two by two by two as long as it has the
45:17 - same amount of values like it's fair
45:18 - game so as you see
45:21 - two by two by two still works with the
45:23 - reshape
45:24 - uh what doesn't work is like if i wanted
45:26 - it to be two by three
45:28 - um the values don't fit in so when you
45:30 - get errors with using their shape it's
45:32 - usually because there's a mismatch
45:33 - between the shape you're trying to
45:35 - resize it to versus the original shape
45:39 - moving onwards let's look at vertical
45:41 - stacks so
45:43 - vertically
45:44 - stacking
45:47 - vectors or matrices
45:49 - and you know dimensions are important in
45:52 - vertical stack as well
45:54 - so vertical stacking matrices let's say
45:56 - we had
45:58 - these two arrays
46:01 - if i wanted to stack
46:03 - um you know one two three four on top of
46:05 - five six seven eight i can do mp.v stack
46:10 - and i can pass in v1
46:12 - v2 and as you see now they're part of
46:16 - the same matrix
46:18 - and one two three four is on top of five
46:20 - six seven eight what i can even do is
46:22 - keep passing these in so let's say i
46:24 - wanted like three copies of
46:26 - this five six seven eight and only one
46:28 - copy of this or i could enter tweet
46:30 - weave them
46:32 - that's a vertical stack
46:35 - horizontal stacks are pretty similar and
46:38 - also note here like i can't do that the
46:40 - size is mass mitch miss
46:43 - match
46:44 - so yep horizontal stack very similar
46:48 - um
46:49 - let's say we had
46:52 - um
46:53 - we'll use uh some notation we've learned
46:55 - before we had these two matrices
46:58 - so if i printed out h1
47:00 - you got like that and then h2 is this
47:03 - well i want h2 to be on the back of h1 i
47:06 - can just do an mp.h stack horizontal
47:10 - stack
47:11 - and that will be h1
47:13 - and then h2
47:15 - and that did not work
47:17 - because i did not surround this in
47:20 - parenthesis
47:21 - either parenthesis or brackets i think
47:22 - they both work yeah
47:24 - there you go so now we've
47:26 - horizontally stacked the zeros on top of
47:28 - the or to the right of the ones all
47:30 - right let's get into some miscellaneous
47:32 - things so first off imagine you have
47:36 - uh you know some sort of text file with
47:37 - all sorts of data and
47:40 - for whatever reason you choose you don't
47:41 - want to use pandas but you want to load
47:44 - all that data from that file into a
47:47 - numpy array
47:49 - well we can do that without too much
47:51 - trouble
47:52 - so i have this
47:55 - text file that i created as you can see
47:57 - here this is on my github page
47:59 - you can download it there this is just
48:00 - really simple data but it shows kind of
48:03 - what you can do
48:04 - with it all delimited by commas called
48:07 - data txt
48:10 - what i can do is i can do
48:13 - mp and i can use this function called
48:15 - gen from text
48:18 - and i pass in the name of the file which
48:20 - is data.txt and then i pass in a
48:23 - delimiter which is the separator and
48:26 - that's a comma and if i do that
48:28 - you see that i get
48:30 - that data that i just showed you
48:33 - um
48:35 - you get that i can increase
48:37 - the zoom here
48:42 - i get that um as an array so that's
48:45 - pretty nice so
48:47 - i'll just call this file data
48:50 - equals
48:52 - and
48:53 - file data
48:55 - yeah
48:56 - one thing you notice though is it
48:57 - automatically cast it to a
49:02 - float type
49:04 - and what if i wanted it to be an integer
49:06 - well i can do another function as type
49:09 - which basically copies all the data into
49:11 - a whatever
49:13 - format you specify so i'll say n32
49:17 - and as you can see now all this stuff is
49:19 - here and if i go ahead and print file
49:22 - data now
49:24 - it is back to what we had originally and
49:27 - the reason it's back is that this
49:29 - actually makes a copy because the
49:31 - float type and the n32 type are
49:33 - different sizes it can't just like in
49:34 - place
49:35 - um copy everything it doesn't really
49:37 - make sense to so if i did file data
49:40 - equals file data
49:43 - uh dot as type
49:46 - into 32 and then printed out file data
49:51 - as you can see now it's all floats so
49:53 - that's how you load data from a file and
49:55 - you can change up this delimiter based
49:57 - on how your data is split but i think
49:59 - that this gen from text will handle your
50:02 - new line breaks properly if that's how
50:04 - it's formatted
50:06 - write in the comments if you have any
50:08 - questions about this
50:09 - okay the second thing i want to go
50:11 - through is
50:12 - um
50:13 - what happened there
50:15 - i didn't want that to be marked down
50:17 - ah
50:19 - the second thing i want to go through
50:20 - with this miscellaneous section is
50:23 - some
50:24 - advanced indexing so there's some really
50:28 - cool stuff you can do with numpy
50:31 - i'm going to say
50:32 - boolean
50:35 - masking
50:36 - and advanced
50:38 - indexing
50:39 - so what can we do here so let's say i
50:42 - wanted to learn
50:45 - where in file data
50:48 - the value is greater than 50. so if i
50:50 - just type in file data greater than
50:52 - 50. it's pretty cool that you
50:55 - get
50:56 - false or true based on whether that
50:58 - specific location was greater than 50.
51:01 - so as you can see there's four falses
51:02 - and then a true if we go to our data
51:05 - four falses and then 196 is in fact
51:08 - greater than 50.
51:10 - so that's like one way and you can do
51:11 - all sorts of cool stuff with it it's
51:13 - like you could do greater than equal to
51:15 - you know
51:16 - all sorts of different combinations
51:19 - one thing that's pretty neat is you can
51:20 - do file data
51:22 - and then you can
51:23 - index based on
51:25 - where it is greater than 50.
51:28 - and
51:29 - by doing this you grab only the
51:33 - values that actually have a value
51:35 - greater than 50.
51:37 - so that is pretty cool and kind of the
51:39 - reason that this right here works is
51:41 - that one thing i did not
51:44 - mention until now
51:46 - is that you can
51:49 - can index with a list in numpy which is
51:53 - pretty cool so if you have the
51:54 - array
51:56 - one two three four five six seven eight
52:00 - nine
52:01 - and i wanted let's say
52:03 - the zeroth spot the second spot and then
52:07 - the last spot
52:09 - i could do
52:12 - mp or let's say that this is a
52:16 - i could do
52:17 - a of
52:19 - 0
52:20 - 1
52:23 - and or i wanted 2 3 and 9 so i would do
52:26 - 1
52:27 - 2
52:28 - and then 8.
52:30 - as you see that gives me two three and
52:32 - nine i
52:33 - passed in a list and it indexed those
52:35 - spots so basically it also works
52:38 - if you like had trues and falses it like
52:41 - basically if it is true then it knows to
52:43 - take it if it's false doesn't so that's
52:45 - why this up here
52:47 - works
52:58 - we could do all sorts of other things so
53:00 - let's say
53:01 - um i wanted to figure out
53:04 - if any value in any of these columns was
53:07 - greater than 50 so i can do a
53:10 - np.any
53:12 - file data greater than 50
53:15 - and the axis
53:17 - of zero so that should tell me like if
53:19 - we looked downwards
53:21 - on all of these are any of the values
53:24 - greater than 50. let's see what happens
53:26 - so false false false false true that's
53:30 - correct
53:31 - true these two values are greater than
53:32 - 50 this even though this one isn't
53:35 - um
53:37 - false
53:38 - true
53:38 - [Music]
53:40 - yeah true true false true
53:43 - cool so this is telling us you know
53:45 - where what columns have a value greater
53:47 - than 50
53:48 - and i can also do np.all
53:53 - and as you can see there's less trues in
53:55 - this case i think the only time that all
53:58 - the values are greater than 50 are right
54:00 - here
54:01 - yeah you see there's one true in the
54:02 - fifth spot
54:04 - which corresponds to this right here
54:07 - uh what else can we do with this
54:11 - um
54:13 - if you
54:14 - did axis equals one
54:17 - it's gonna be the rows
54:19 - you can also do multiple conditions so i
54:22 - could do like
54:24 - i want file data to be
54:27 - greater than 50
54:29 - and
54:30 - let's say file data is less than 100 and
54:34 - this syntax is very similar to pandas
54:36 - here and as i said before numpy builds
54:39 - is what's the base of panda so it makes
54:41 - sense
54:42 - ah no
54:46 - the
54:47 - truth value of an array with more than
54:48 - one element
54:50 - is ambiguous how do i do this
54:53 - i think if i do something like this it
54:55 - will work
55:02 - not positive let's see
55:05 - yeah what happened
55:07 - no i need to end it
55:09 - yeah cool so this is all the values that
55:11 - are
55:12 - greater than 50 but less than 100 so
55:14 - like the first true should happen at the
55:16 - sixth spot one two three four five six
55:21 - as you see
55:22 - uh and i could do something like
55:26 - all the spots if i wanted to
55:28 - make all this
55:29 - not
55:30 - so this
55:31 - means not greater than 50 and less than
55:34 - 100 this is going to be the reverse of
55:37 - what we just did
55:39 - so yeah now the
55:42 - um
55:43 - sixth spot is the first false
55:46 - so this meant not so yeah all sorts of
55:49 - cool stuff you can do with this boolean
55:50 - masking and advanced indexing
55:54 - i mean yeah any sort of like condition
55:56 - i'll put a link and some more
55:58 - information about this all right quick
56:00 - little quiz on uh indexing this is kind
56:03 - of using all sorts of advanced stuff
56:04 - that you just learned in that last
56:06 - section include and then also like some
56:08 - of the original stuff so first question
56:10 - uh basically pause the video after i ask
56:13 - it and then try to figure out what the
56:14 - command would be so we have this matrix
56:17 - and how would you index this part of the
56:19 - matrix
56:25 - so this is the
56:29 - second and third row and the first and
56:32 - second column
56:33 - or zero and first column so it looks
56:36 - something like this
56:39 - rows columns
56:40 - next question how would you index
56:43 - this this is something we haven't done
56:45 - before but you potentially with that
56:47 - last section might have an idea
56:49 - if not no worries
56:54 - so to do this one
56:57 - you need to use two different lists
57:01 - within your
57:02 - uh indexing
57:03 - so it's gonna look something like this
57:07 - we need the zeroth first second and
57:09 - third row
57:11 - and then the first second third and
57:13 - fourth columns that's what that is and
57:15 - then final question
57:18 - how would you index this
57:20 - this is like also something we haven't
57:23 - immediately looked at but you might be
57:24 - able to get especially with that last
57:26 - one
57:29 - take a second
57:34 - all right that would look something like
57:37 - this
57:38 - where you get the zeroth fourth and
57:40 - fifth row zero
57:42 - fourth and fifth rows
57:44 - and then you want columns three onwards
57:47 - so this would
57:49 - like three onwards works you could also
57:51 - do like three to five
57:53 - you'd also do three or like a list of
57:55 - three four but yeah that's one way to do
57:57 - it it's a fun little quiz i don't know
57:59 - it's i guess good to revisit this type
58:01 - of thing and like think critically about
58:02 - it
58:03 - all right thank you guys very much for
58:05 - watching i think this is all i have for
58:06 - this video
58:08 - peace out