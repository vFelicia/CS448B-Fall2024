00:00 - welcome to this comprehensive video
00:02 - course on graphql The Cutting Edge query
00:05 - language designed to empower your data
00:07 - retrieval needs for modern web
00:08 - applications throughout this course
00:10 - you'll learn its core principles
00:12 - explores advantages over traditional
00:14 - rest apis and gain the practical skills
00:17 - to design and Implement robust
00:19 - data-driven applications this beginner's
00:22 - course was developed by the net ninja he
00:25 - is one of the most popular graphql
00:26 - instructors on the internet so you're in
00:29 - good hands hey there gang and welcome to
00:31 - your very first graphql tutorial
00:37 - thank you
00:39 - okay then so although I do already have
00:41 - a graphql course it's about five years
00:43 - old now and I wanted to make a fresh
00:45 - up-to-date one with less bloat so that
00:48 - anyone wanting to get up and running
00:49 - with graphql quickly can do here before
00:52 - diving into more advanced tutorials and
00:54 - projects using it so in this series
00:56 - we'll be learning what graphql is and
00:59 - why we use it and then we'll build a
01:00 - graphql server from scratch using
01:02 - node.js and the Apollo server package
01:04 - we'll also look at how to make queries
01:06 - to that server using Apollo Explorer
01:09 - which is a free tool for testing
01:11 - different kinds of queries now before
01:13 - you start I would already expect you to
01:15 - have a basic understanding of node.js
01:17 - because we'll be using that to make our
01:19 - graphql server so if you want to learn
01:21 - that a little bit more first of all
01:22 - which I highly recommend then you can
01:24 - check out my node.js crash course on
01:26 - netninja Pro and also on YouTube so I'm
01:29 - going to leave a link to that course
01:30 - down below the video you're also going
01:32 - to need a recent version of node
01:34 - installed on your computer which you can
01:36 - get from nodejs.org just click on this
01:38 - download button and then go through the
01:40 - installation steps that easy and then
01:42 - finally before we start I've made course
01:44 - files for this entire series you can get
01:46 - them from this repo on GitHub graphql
01:48 - crash course the link to that is also
01:50 - going to be down below the video now
01:52 - each lesson has its own Branch so if you
01:54 - want the code for a specific lesson you
01:56 - can head to the branch drop down and
01:58 - select that branch that corresponds to
02:00 - that lesson then to download the code
02:01 - just hit the green code button and
02:03 - download a zip folder or if you prefer
02:05 - you can clone the entire repo to your
02:08 - machine
02:09 - so then let's get started by talking
02:11 - about exactly what graphql is and why
02:13 - we'd want to use it so graphql is what's
02:16 - known as a query language which is what
02:18 - the ql in the name stands for query
02:20 - language and by query language we mean a
02:23 - specific syntax that we can use to query
02:25 - a server to request or mutate data so
02:29 - it's kind of like an alternative to the
02:31 - more traditional approach of sending
02:32 - standard requests to a rest API using
02:35 - endpoints but whereas using a rest API
02:38 - is more of an architectural style an
02:41 - approach to serve and fetching data
02:43 - graphql differs in that it's an actual
02:45 - query language with its own syntax and
02:48 - rules and it still uses HTTP requests
02:51 - under the HUD like we'd normally send to
02:54 - a rest API it's just that we have this
02:56 - nice query language sitting on top of
02:59 - that to give us more flexibility and
03:01 - control about how we make them and what
03:03 - data we want to fetch or mutate and also
03:06 - the way a graphql server handles those
03:08 - requests is very different to how a
03:10 - typical rest API would handle them as
03:13 - well
03:13 - so let's take a quick look at those
03:16 - differences and see why in some cases
03:18 - graphql has the edge so when we use a
03:22 - rest API we typically send HTTP requests
03:24 - to specific endpoints like this to
03:28 - interact with a certain type of data
03:29 - right for example we might send a get
03:32 - request to this endpoint to fetch a list
03:34 - of Pokemon and we could also send a post
03:37 - request to that endpoint to add a new
03:39 - Pokemon to the data set we might send a
03:42 - get request to an endpoint like this
03:43 - with an ID on the end of it to fetch a
03:46 - single Pokemon with the ID and we might
03:48 - also send a delete or put request to
03:51 - this endpoint to delete the data or
03:53 - update it and the server would handle
03:55 - requests to those endpoints by
03:57 - connecting to a database probably where
03:59 - the data was stored and either fetching
04:01 - the data and sending it back to the
04:03 - client the browser or updating or
04:05 - deleting the data from the database
04:07 - instead so this is your traditional rest
04:10 - API and for the most part it's really
04:13 - effective and a good way to expose data
04:15 - to clients but there are sometimes some
04:17 - drawbacks when it comes to using a rest
04:19 - API when your application scales and
04:22 - your data gets a little bit more complex
04:24 - now the first drawback is something
04:26 - called over fetching
04:28 - another fetching is when we request some
04:30 - data from an end point and the server
04:32 - sends back too much data so much more
04:36 - data than we actually need for example I
04:38 - might have an endpoint which is forward
04:40 - slash courses and that gets all the
04:43 - courses so that request goes to the
04:45 - server the server gets the courses from
04:47 - the database and sends the whole list of
04:49 - them back to us in Json format now each
04:52 - course object might have a ton of
04:55 - different properties like an ID the
04:57 - title the author property which contains
05:00 - author name and the author ID maybe the
05:03 - price a thumbnail URL a description a
05:07 - video URL and so forth and it might
05:09 - actually be that in this case we only
05:12 - need the ID the title and the thumbnail
05:15 - for each one because that's all we're
05:17 - going to be showing on this particular
05:18 - page and so the rest of this data for
05:22 - each course is pretty much Obsolete and
05:24 - we don't need it for anything which
05:26 - means that we've over fetched what we do
05:28 - need so that's the first drawback of
05:30 - fetching the second drawback is the
05:33 - polar opposite under fetching and under
05:36 - fetching is when we don't get back all
05:38 - the data that we need from a single
05:40 - request and it could lead to making
05:41 - multiple requests to different endpoints
05:44 - to collate everything that we need
05:46 - together for example we might send a get
05:49 - request for a single course the server
05:51 - handles that request by getting the
05:53 - course from a database and sending it
05:55 - back in Json format and it might look
05:57 - something like this with an ID title
05:59 - thumbnail URL description the author
06:01 - property which contains the author name
06:03 - and the author ID price video URL Etc
06:06 - and in this case we need all of those
06:08 - things that's great
06:09 - so we show all of those on our course
06:11 - page on our website but we also want to
06:14 - show additional stuff on the page about
06:16 - the author of that course as well for
06:18 - example the other course is that this
06:20 - author has made and information about
06:22 - those courses such as the title the
06:24 - thumbnail the ID the price and so forth
06:26 - and we don't have all of that deeply
06:28 - nested data here in the course object
06:30 - that we got back so we've actually under
06:32 - fetched what we need in that single
06:34 - request and that could mean we now need
06:36 - to make additional requests to the
06:38 - server to different endpoints to get
06:40 - back that additional data so these are
06:43 - two potential drawbacks of using a rest
06:45 - API when your data layer gets a little
06:47 - bit more complex and these are two
06:49 - things that can easily be solved by
06:51 - using graphql instead so now let's look
06:54 - at how graphql works and how it combats
06:56 - both over fetching and under fetching so
06:59 - first of all when we send a request
07:00 - using graphql to a server we typically
07:02 - do that to a single endpoint which might
07:04 - be forward slash graphql and this is
07:07 - totally different to when we used a rest
07:08 - API where each resource typically has
07:10 - its own set of endpoints for get post
07:13 - delete and put requests Etc so whenever
07:16 - we send a query using graphql to the
07:18 - server it's always going to be sent to
07:20 - probably that single end point and then
07:22 - the server can handle it now the way
07:24 - that we send a query to the server is by
07:26 - using a special graphql syntax that
07:28 - looks something like this and we're
07:30 - going to talk more about this syntax
07:31 - later on in the course but essentially
07:33 - this syntax allows us to specify exactly
07:35 - what data and what fields we need back
07:37 - from the server so in the example from
07:39 - before if we want maybe the call courses
07:42 - data then we can send a query that looks
07:45 - something like this so we'd specify that
07:47 - we want the courses resource and for
07:49 - each course we can also specify which
07:50 - properties we want back as well so in
07:53 - this case that would be the ID the title
07:55 - and the thumbnail URL so it's send that
07:57 - query and the server would respond with
07:58 - a Json array of courses where each one
08:01 - of those courses would only have those
08:03 - properties that we need so there's
08:04 - absolutely no fetching going on there
08:06 - whatsoever which is really good the
08:08 - other thing graphql allows us to do is
08:10 - fetch nested related data within a
08:13 - single query so again for the example
08:15 - before where we needed a single course
08:16 - we'd send a query like this one and
08:19 - specify whatever properties we need from
08:20 - that course but we also said that we
08:23 - wanted extra information about the
08:25 - author of that course along with any
08:27 - related data or any related courses
08:29 - rather that author made and we can do
08:31 - that in graphql by nesting those
08:33 - properties inside the query so I can say
08:35 - get the author Name ID and then also get
08:38 - the courses of the author where for each
08:40 - course I want to get the ID the title
08:43 - and the thumbnail URL and all this is
08:45 - done in a single request or query
08:48 - so we're no longer under fetching the
08:50 - data that we need which is really cool
08:52 - and this right here is one of the really
08:54 - good things about using graphql the
08:56 - ability to Nest any related data we need
08:59 - into a single query instead of making
09:01 - multiple queries as you might do when
09:04 - you're using a rest API
09:06 - so that's the basics of why graphql
09:08 - might be beneficial to you and your
09:10 - application especially as like I said
09:12 - before you scale up the app and the data
09:15 - layer becomes a bit more complex now at
09:17 - the moment you've only seen how to
09:19 - retrieve data here and we'll look at
09:21 - this more closely later on but you can
09:24 - also perform something called mutations
09:26 - to do things like ask the graphql server
09:29 - to add new data or update it or delete
09:31 - it I'm watching the same way a post
09:33 - request might ask a rest API to add new
09:36 - data or a delete request would ask the
09:39 - server to delete some data so we're
09:41 - going to talk much more about that later
09:43 - on in the course as well so in this
09:45 - course then we'll be making a graphql
09:47 - server from scratch using node.js and a
09:50 - package called Apollo server and that
09:52 - server is going to be responsible for
09:54 - handling all the queries and mutations
09:56 - that we send to it now to send the
09:58 - queries we'll be using Apollo Explorer
10:01 - which is a graphql client that we can
10:03 - run in the browser you can kind of think
10:05 - of this as a bit like Postman but it's
10:07 - the graphql equivalent and postman by
10:10 - the way is a free tool to test out rest
10:11 - apis so you're going to learn how to set
10:14 - up a graphql server and also how to make
10:16 - queries and mutations from the front end
10:18 - using this kind of graphql syntax so my
10:22 - friends that's the introduction out of
10:24 - the way now in the next lesson we're
10:25 - going to go over the basic syntax of
10:27 - making queries
10:32 - so then before we get started actually
10:34 - making a graphql server that can handle
10:36 - all of our queries I wanted to go over
10:38 - the basics of this query language right
10:41 - here and show you how I typically
10:42 - structure these queries from the front
10:44 - end now to do this we're going to be
10:46 - using Apollo Explorer which I showed you
10:48 - briefly in the first video of the series
10:50 - an Apollo Explorer is a way for us to
10:53 - send test queries to a graphql server
10:55 - and see the responses that we get back
10:57 - from it now you might have worked with
10:59 - something called Postman before which is
11:01 - for rest apis and it's basically a
11:03 - graphql version of Postman what we're
11:05 - using here it allows us to test and sync
11:07 - queries as we would from a front-end
11:09 - application without having to actually
11:11 - build a front end so the way we're going
11:14 - to be making and sending queries from
11:15 - here is essentially the same way we'd be
11:18 - sending them from a client-side
11:20 - application like a react app for example
11:22 - so this window right here is where we're
11:25 - going to be making the queries and then
11:27 - to send them we'd press this button
11:29 - right here and the response from the
11:31 - server is going to show over on the
11:32 - right now for this lesson I'm connecting
11:35 - Apollo Explorer to a backend graphql
11:38 - server I've already made and it's the
11:40 - one that we're going to be making
11:41 - through the rest of this series but you
11:43 - can also use something called the Apollo
11:45 - sandbox which you can find on the Apollo
11:48 - docs right here I'm going to leave this
11:49 - link down below and when you open the
11:52 - sandbox it connects to a dummy graphql
11:54 - server so you can play around with
11:56 - requests without having to worry about
11:57 - making a server yourself but for now I'm
12:00 - going to go back to the Explorer
12:01 - connected to my own graphql server
12:04 - because that's more pertinent to the
12:05 - rest of this course that we're doing so
12:07 - then how do we make a query using
12:09 - graphql well first off we'd use this
12:12 - word query and then after that we can
12:13 - give our query a name if we want it for
12:15 - example I'm calling this one reviews
12:17 - query because I'm going to be fetching
12:19 - reviews from the server makes sense
12:20 - right so you can call this whatever you
12:22 - want then we open the curly braces and
12:24 - inside these we specify what data
12:26 - resource we want to get back now a
12:28 - graphql server can expose multiple
12:30 - different resources to the clients for
12:32 - example they might expose the reviews
12:34 - resource and author's resource a user's
12:37 - resource games resource Etc and we can
12:40 - specify any of those resources right
12:42 - here as our entry points for the query
12:44 - so right now we're saying we want to
12:46 - jump into the graph on this resource
12:49 - entry point in essence we want to fetch
12:52 - the reviews data to begin with now on
12:54 - its own that's not going to do much for
12:57 - us because although we've said we want
12:58 - to get the reviews data we've not
13:00 - specified which fields from each review
13:03 - that we want to retrieve now this is one
13:06 - of the major differences between graphql
13:08 - and using a rest API because when we
13:10 - send a request for a resource to a rest
13:13 - API endpoint we don't then specify which
13:16 - parts of that resource we want to get
13:17 - back we just get the whole lot back but
13:20 - in graphql we can manually choose which
13:22 - field from this resource that we want to
13:25 - fetch and the way we do that is by
13:27 - opening curly braces again and then
13:29 - writing down whatever fields we want so
13:31 - I could just say get me the rating field
13:33 - of each review and if I press send now
13:37 - I'll see the response is a bunch of
13:39 - review objects each one with just the
13:42 - rating field awesome
13:44 - now if I want more Fields I can just
13:47 - list them inside these curly braces
13:49 - right here so I could say that I want
13:51 - the content of each review and also the
13:54 - ID of each review as well and now if I
13:57 - hit send you're going to see this time I
13:59 - get back all of those fields in each
14:01 - review object so this is a really cool
14:04 - feature of graphql only getting back the
14:06 - fields from the data that we actually
14:08 - need now before we go any further I want
14:11 - to just jump to some slides to quickly
14:14 - explain from a bird's eye perspective
14:15 - how we query the graph and move around
14:18 - it to navigate data so when we make a
14:21 - graphql server or API we're making
14:24 - something called a graph right and a
14:26 - graph in visual terms is basically a
14:28 - bunch of connected data that looks
14:30 - something like this so in this case
14:32 - we've got three different data types
14:33 - we've got reviews authors and games and
14:36 - we can choose to jump into the graph at
14:38 - any point that's exposed to us by the
14:40 - server when we make a query and from
14:42 - there the graphql layout allows us to
14:45 - Traverse or walk through this graph to
14:48 - also fetch any related data to that
14:50 - starting point right so we just made a
14:53 - simple query whereby we requested all of
14:56 - the reviews data and specified which
14:58 - fields we wanted back for each review
15:00 - right
15:01 - so the reviews resource was our jumping
15:04 - in points we landed right there and from
15:07 - there I could say okay also get me the
15:10 - author of each review that I got back
15:13 - and I could also specify which fields of
15:15 - the authors that I want to get back as
15:17 - well and the query would look something
15:19 - like this and the reason I could do this
15:22 - is because when I made the graphql
15:24 - server I connected these data resources
15:28 - I said that each review was related to
15:31 - an author who wrote that review and the
15:33 - author is a separate resource and all of
15:36 - this data would be brought back from a
15:38 - single request we've only made one query
15:40 - and sent that one query to the server we
15:43 - didn't have to first get the reviews and
15:45 - then make a second request for the
15:48 - authors of each of those reviews even
15:50 - though it's a separate resource that
15:52 - we're getting right here
15:54 - another example could be that my initial
15:56 - entry point to the graph would be a
15:58 - specific game with a certain ID and the
16:01 - query for that would look something like
16:03 - this where we specify the ID of the game
16:04 - that we want as a variable now we'll
16:07 - learn more about query variables later
16:08 - on so don't worry too much about that
16:10 - for now but then having jumped in at
16:12 - these points on that game I could also
16:15 - say get me any review related to that
16:18 - game and from those reviews just get me
16:21 - the rating field and to take it one step
16:24 - further I could also say then get me the
16:27 - author of each of those reviews and just
16:30 - give me their name so you can see how
16:33 - this general idea of a graph allows us
16:35 - to initially jump in somewhere and then
16:38 - navigate between related data and fetch
16:41 - it all in a single query and that is the
16:44 - Crux of graphql so let's try one of
16:47 - these queries with nested related data
16:49 - again in Apollo Explorer
16:52 - all right so we saw before that we had
16:54 - this reviews query where we fetched all
16:56 - the reviews and we got the rating
16:57 - content and ID for each one so we got
16:59 - those back right but now we can also get
17:02 - nested content so say for example I want
17:04 - the author of each review now this
17:06 - author is actually a separate resource
17:08 - so they don't have author properties
17:10 - these reviews they're a separate
17:12 - resource but they're linked to reviews
17:14 - so the related data and we've specified
17:16 - that or I've specified that in the
17:18 - graphql server we'll see how to do that
17:20 - later on but let me just show you how we
17:21 - can fetch this stuff now so from the
17:23 - author I could get the name and the ID
17:26 - of the author we also have a verified
17:28 - property to say whether they're a
17:30 - verified author now if I click on this
17:33 - we're going to get all of the same stuff
17:35 - here plus the author details so it's
17:38 - grabbing that as well for each different
17:40 - review now we could also get the game
17:44 - associated with each of you so down here
17:47 - I could say game
17:49 - and then inside parentheses or rather
17:52 - curly braces we can say which properties
17:54 - we want back for the game so I could say
17:56 - the title of the game the price of the
17:58 - game and also the platform of the game
18:01 - and it looks here like we don't actually
18:03 - have a price property so let me get rid
18:05 - of that I mustn't have added that so let
18:08 - me just leave it with the title and
18:09 - platform press that and we can see now
18:11 - we get the title of each game and the
18:13 - platform of each game as well which is
18:15 - an array of different platforms so these
18:18 - are three separate resources author game
18:20 - and reviews but we're getting them all
18:22 - back from the same aquarium and we can
18:24 - take this one step further if we wanted
18:26 - to we could say okay well get me all the
18:29 - reviews now associated with each author
18:32 - for example so let's do it right here we
18:35 - can say we want the reviews from each
18:37 - author and from that we just want the
18:39 - rating and we want the ID of each of you
18:43 - click on that and now you can see nested
18:46 - inside the author we can see the other
18:47 - reviews
18:48 - they've done and again we can take this
18:50 - one step further we can say we also want
18:52 - the game for each one and we want the
18:54 - title for each one now this is getting a
18:56 - bit complex it probably wouldn't make a
18:58 - query this complex I just wanted to show
19:00 - you how we can work with this related
19:01 - nested data all right and how flexible
19:04 - it is that's really cool isn't it all in
19:06 - one query
19:07 - so like I said before we can also have
19:10 - mutations to add new games if we want to
19:13 - delete games or reviews whatever it
19:15 - might be to update different records so
19:18 - we're going to see all of that later on
19:20 - as well so now hopefully you can
19:22 - understand a little bit more about how
19:24 - these queries are made and how we can
19:25 - fetch related data within a single query
19:28 - now there is much more to graphql than
19:30 - making queries like this but for now I
19:32 - think that's probably enough to get us
19:33 - started I just wanted to make sure we
19:35 - all have a little bit of an
19:36 - understanding of this General syntax so
19:39 - in the next lesson we're going to start
19:40 - making our very own graphql server on
19:43 - the back end
19:44 - all right the gang so now we want to
19:46 - make a brand new graphql API and to do
19:49 - that we'll be using node.js and a
19:51 - library called Apollo server an Apollo
19:53 - server is one of many different
19:54 - libraries that you can use to easily
19:56 - spin up a graphql server and each
19:58 - library has their own kind of take on it
20:00 - but the nice thing about using Apollo
20:02 - server is that it automatically spins up
20:05 - an instance of the Apollo Explorer for
20:07 - us on localhost which we can use then to
20:10 - test out our API
20:11 - so when we use Apollo server it's going
20:14 - to create a graphql server for us that
20:17 - then allows us to easily set up resolver
20:19 - functions that can respond to incoming
20:21 - queries it also lets us easily model our
20:23 - different data types like authors blogs
20:26 - reviews
20:26 - Etc and decide how they're all connected
20:29 - on the graph by making something called
20:31 - a schema so we'll talk more about that
20:33 - in the next lesson but for now let's go
20:35 - ahead and make a new node project and
20:38 - install Apollo server alright so I'm on
20:40 - the Apollo docs right here Apollo server
20:42 - and I will leave this link down below
20:43 - just click on get started and this is
20:45 - going to show us how to make a new
20:46 - project with Apollo server so the first
20:49 - step is to make a new directory then see
20:50 - the internet and then we initialize a
20:53 - new project a new node project using npm
20:55 - we also set the type to be module and
20:57 - that allows us to use es6 modules so we
20:59 - can say import something from something
21:01 - rather than require and it also allows
21:03 - us to use top level awaits as well once
21:06 - we've done that we have to install a
21:07 - couple of dependencies graphql which is
21:10 - the meat and bones of graphql we need to
21:11 - install that but also Apollo server and
21:13 - that's the graphql library that we're
21:15 - going to use which makes it really
21:17 - easier to spin up a graphql server make
21:19 - schemas types respond to queries using
21:22 - resolver functions and all that jazz so
21:24 - it just makes working with graphql so so
21:26 - easy so we're going to install both of
21:28 - those right here now if you're using
21:30 - typescript then you can follow these
21:32 - directions we're going to be using
21:35 - JavaScript and basically we're just
21:37 - opening up the index.js file or rather
21:39 - we're making one and then opening the
21:42 - the file up and notice here we have that
21:44 - type set to module inside package.json
21:47 - as well
21:48 - so once we've done that it's all set up
21:51 - and we can go ahead and start defining
21:52 - the schema the resolver functions and
21:54 - all that stuff so to begin with let us
21:56 - go up here I'm just going to copy the
21:58 - installs
22:00 - up here so these two things so we can
22:02 - use them in our project alright so I've
22:05 - opened the terminal right here and
22:06 - navigated to this directory where I want
22:08 - to make the project then I'm going to
22:10 - say npm init and then hyphen Y and
22:13 - that's going to create our package.json
22:15 - file for us I also want to say npm PKG
22:18 - and then we want to set the type to be
22:21 - equal to module that allows us to use
22:23 - es6 modules we'll see that inside
22:25 - package.json in a second then I'm going
22:28 - to open up this director written Visual
22:30 - Studio code so codes and a space then
22:32 - full stop press enter and it's going to
22:34 - open up this project for us so inside
22:36 - package.json we can see that the type is
22:40 - module awesome okay so now we need to
22:42 - install those dependencies so open up a
22:44 - new terminal and you want to paste in
22:47 - that npm install that we grabbed from
22:49 - the Apollo docs so it should be at
22:51 - Apollo forward slash server and also
22:53 - graphql so press enter to install those
22:56 - dependencies
22:58 - all right and now that's done the next
23:00 - thing I'm going to do is create an index
23:02 - .js file and this is where we're going
23:04 - to set up our Apollo server for graphql
23:07 - so the way we do this is we first of all
23:10 - import a couple of things so I'm going
23:11 - to paste these in we import Apollo
23:13 - server from at Apollo forward slash
23:16 - server that was the package we just
23:17 - installed and then also we import this
23:20 - thing start Standalone server from ad
23:22 - Apollo forward slash server forward
23:24 - slash Standalone so basically this
23:27 - Apollo server is first to set up the
23:29 - server and configure it and tell Apollo
23:31 - how to handle all of our different types
23:33 - of data and respond to queries and
23:36 - things like that this one right here
23:37 - this is just to start up the server so
23:39 - we can start listing for requests so
23:42 - after we've imported both of those
23:43 - things I remember for this to work these
23:45 - import statements we need to be saying
23:48 - the type is module over here
23:50 - anyway after we've done that we can do
23:53 - our server setup
23:55 - so we can say const server
23:58 - is equal to new
24:01 - Apollo
24:03 - server like so so that's this thing
24:06 - right here all right like so
24:11 - and then down here I'm going to come
24:13 - back to that in a minute but down here
24:14 - I'm going to say const
24:16 - and then
24:18 - URL a destruction here is equal to a
24:21 - weight and then starts standalone
24:25 - server so that's the other thing we
24:27 - imported
24:28 - and then we pass in
24:29 - this Apollo server we just created and
24:32 - then as a second argument an object to
24:35 - say right here we want to listen to a
24:37 - particular port number so we're passing
24:39 - object as the value here and we say the
24:41 - port is four thousand and then down at
24:44 - the bottom I'll just do a little console
24:46 - log console.log and then in here I'll
24:49 - say server
24:51 - ready at Port and then it was four
24:54 - thousand Okay so we've got the basic
24:57 - setup sorted now we're using Apollo to
24:59 - create a new Apollo server and we start
25:02 - the server using this method down here
25:04 - now the Apollo server takes in an object
25:07 - as an argument and that object expects
25:10 - two properties the first is one called
25:13 - type defs which is short for type
25:15 - definitions and these are basically
25:17 - descriptions of our data types and the
25:20 - relationship they have with other data
25:22 - types so that's what we're going to be
25:25 - looking at in the next lesson but the
25:26 - other property is a resolver's property
25:28 - which is basically a bunch of resolver
25:31 - functions that determine how we respond
25:33 - to queries for different data on the
25:35 - graph so in the next lesson we're going
25:37 - to look at that first property type Deft
25:40 - and we're going to make up our own
25:41 - schema
25:44 - all right then my friends so now we're
25:46 - going to make some type definitions and
25:49 - then later on as well some resolver
25:50 - functions which we can then pass into
25:52 - the Apollo server so it can do its magic
25:54 - with them so let's start with the type
25:57 - defs what are type defs well type defs
26:00 - are definitions of the different types
26:02 - of data we want to expose on our graph
26:04 - for example we might make a type def for
26:07 - an author data type and specify the
26:09 - different fields that author might have
26:12 - like a name an avatar URL a bio Etc and
26:15 - we might have one for a game which is a
26:18 - title a price a platform Etc so these
26:20 - would be the different types of data
26:22 - that we want to make available on the
26:23 - graph that a user can then eventually
26:25 - query
26:27 - and the combination of all of these
26:29 - different types and the relationship to
26:31 - other types and the kinds of queries
26:34 - that can be made combine up to make
26:36 - something called a schema so the schema
26:39 - is something that describes the shape of
26:41 - the graph and the data available on it
26:44 - and normally your graphqbal schema the
26:47 - data that's available on the graph will
26:49 - be fairly similar to the data you're
26:51 - storing in your application database now
26:53 - it can be different they don't have to
26:54 - fully match or anything because graphql
26:57 - is a layer between your database and
26:59 - client-side queries but generally
27:01 - speaking the schema will probably look
27:03 - fairly similar to the kind of data that
27:05 - you have in your database so let's try
27:08 - making a schema then with a few
27:09 - different types of data that we want to
27:11 - add to the graph now to do this I'm
27:13 - going to make a new file called
27:15 - schema.js and inside this is where I'm
27:18 - going to Define all of my different
27:20 - types of data now before we do anything
27:23 - inside here I want to show you a package
27:25 - I've got installed so just typing up
27:27 - here graphql and it's this one graphql
27:29 - syntax highlighting so what this does is
27:32 - it allows us to have syntax highlighting
27:35 - for our different types in our schema
27:37 - because without this we wouldn't get
27:38 - that so if we scroll down it might show
27:40 - you an example you can see
27:43 - down here
27:45 - if we keep on going this is how we're
27:47 - going to be using it using a template
27:48 - string and then we start the template
27:51 - string with hash graphql and if we do
27:53 - that when we're making our types inside
27:55 - that template string we're going to get
27:57 - syntax highlighting on them so
27:58 - definitely install this package first of
28:01 - all or a similar one
28:03 - then if we go back to the schema file
28:05 - the way we're going to do this is by
28:06 - first of all exporting a constant
28:08 - because we're going to use this schema
28:10 - inside this index file over here so we
28:12 - need to import it later so make sure you
28:14 - export it first we'll call this type
28:16 - defs and we set this equal to a template
28:19 - string and like we just saw we started
28:22 - with hash graphql and notice when I
28:24 - press L now it goes green to Signal we
28:27 - are going to get syntax highlighting for
28:29 - this now inside here we're going to
28:31 - Define our different types and built
28:34 - into graphql there are five basic scalar
28:37 - types that we can use so they are ins
28:40 - which are just basically whole numbers
28:42 - floats which are decimal numbers we have
28:45 - strings we have Boolean types and also
28:49 - we have a special ID type as well now
28:52 - the ID type is something that graphql
28:55 - uses as a key for data objects now the
28:58 - basically serialized as strings and
29:00 - that's how we're going to declare the
29:02 - IDS in our data when we make it later
29:04 - but they are their own unique type in
29:07 - graphql
29:08 - and these five types right here are
29:10 - going to be the ones you find yourself
29:11 - using pretty much 99 of the time you can
29:14 - make your own types to build on top of
29:15 - this and use them which we'll see kind
29:17 - of later on but yeah these are the types
29:19 - we're going to be using so let's delete
29:21 - that and then go up here now we want to
29:24 - make different data types for our
29:26 - different types of data that we're going
29:28 - to have later on now we're going to have
29:30 - three types of data we're going to have
29:31 - game objects we're going to have review
29:33 - objects and also auth objects so they're
29:36 - the three different types we need to
29:38 - Define inside this template string now
29:40 - the way we make a type is by saying type
29:42 - first of all then the name of the type
29:45 - so we'll start with game and then inside
29:48 - here we'll Define the different
29:50 - properties that a game data type should
29:52 - have so it should have an ID property
29:54 - and then we do a colon and we say what
29:57 - data type is that using the five
29:59 - different types that we just saw well
30:01 - this is going to be of type ID
30:05 - then the second property is going to be
30:07 - a title because every game needs a title
30:09 - that's going to be a string and then the
30:12 - third one will be a platform now that
30:15 - could be a string as well however it
30:17 - might have multiple platforms so ideally
30:19 - we want this to be an array of strings
30:22 - and we can say that something is an
30:24 - array of a certain type by just putting
30:25 - square brackets around it so now we're
30:27 - saying the type of this property should
30:28 - be an array of strings
30:30 - all right so at the beginning if we were
30:33 - to make a new game using this type later
30:36 - on there's nothing to say that these are
30:38 - required Fields now we can make a field
30:41 - required by adding on the exclamation
30:43 - mark at the end of something if we don't
30:45 - have that then we're basically saying
30:47 - this is allowed to be null if we have
30:50 - the exclamation mark we're saying it's
30:52 - not allowed to be null so I want all of
30:54 - these to be required so this one this
30:56 - one and also this one now right here
31:00 - this exclamation mark is outside of the
31:02 - square brackets meaning we must have a
31:05 - value for platform which is an array of
31:07 - strings but the arrays sorry the
31:10 - elements inside that array can be
31:12 - nullable at the minute because we don't
31:13 - have an exclamation mark after this so
31:16 - we need it there as well to say that
31:17 - this string can't be nullable all right
31:19 - so we need two here one at the end of
31:21 - the entire value type and then one for
31:24 - the type inside the array as well
31:27 - okay so that's the first type done let's
31:29 - do another one I'm going to say type or
31:32 - review this time and then inside here we
31:35 - also want an ID which is of type ID
31:38 - required and then we also need the
31:42 - second property and by the way you don't
31:43 - need
31:45 - commas here
31:46 - the second property inside the review
31:48 - which is going to be the rating and
31:51 - that's going to be an integer also
31:52 - required and then the third one will be
31:55 - the content of the review and that is
31:57 - going to be a string also required so
32:00 - that's the second type the third one is
32:02 - author so type author
32:05 - and inside here again we need an ID
32:09 - which is required we also need a name
32:12 - for the author which is a string also
32:15 - required and get rid of the commas this
32:17 - is just habit and then the third one is
32:20 - going to be the verified property
32:23 - and that is going to be a Boolean and
32:25 - this is just basically to say whether an
32:27 - author is verified on a sign we don't
32:29 - need that I just want to demonstrate the
32:31 - different types that we can use okay
32:33 - then so now we've made three different
32:35 - types Game author and review now there's
32:37 - one more special tag that we need to
32:39 - make and that's the type we're going to
32:40 - call query now the query type is
32:43 - something that every graphql schema that
32:45 - you make needs to have it's not optional
32:47 - and its job is to define the entry
32:49 - points to the graph and specify the
32:51 - return types of those entry points so
32:53 - for example if I want users to be able
32:55 - to query the review data that we have
32:57 - and get back a list of reviews then I
33:00 - need to specify that inside this query
33:02 - type so I could make a field called
33:05 - reviews and then tell graphql that we
33:08 - expect the return type of this entry
33:10 - point to be a list of reviews and now if
33:14 - we left the query type like this we're
33:16 - essentially saying we only want to
33:17 - expose that one single entry point to
33:20 - the graph meaning a user would only be
33:22 - able to enter the graph at this point
33:24 - and then they'd be free to navigate
33:26 - around the graph to eventually get
33:28 - related data but they wouldn't be able
33:30 - to jump in at any other point whether
33:32 - that be a single review instead of a
33:34 - list of reviews or an author or game
33:37 - because we've not specified those entry
33:40 - points right here so this query type is
33:42 - our way of gatekeeping Entry onto the
33:45 - graph if you like and deciding where a
33:47 - user can jump into it initially so let's
33:50 - make some more entry points for our
33:52 - users so after reviews we shall say
33:55 - games and when a user lands on this when
33:59 - they request all the games we're going
34:01 - to send back a list of Game objects and
34:04 - the final one for now is going to be
34:05 - authors and same again it's going to be
34:08 - a list this time of auth objects now
34:10 - eventually we're going to allow Landing
34:12 - points for single reviews single authors
34:14 - and single games at the minute we're
34:16 - just allowing the user to land on a list
34:18 - of reviews to grab them all we'll see
34:21 - how to land on a single one later on so
34:24 - then now we've defined our types and
34:26 - we've also made a query type to say
34:28 - where a user can essentially land on the
34:31 - graph or where queries can start from
34:33 - the next thing we need to do is pass all
34:36 - these type definitions into the Apollo
34:38 - server that we made in the previous
34:40 - lesson so first off make sure these type
34:43 - defs are exported from this file so that
34:45 - we can then go ahead and import them in
34:47 - the index file somewhere near the top so
34:50 - do that first of all and then once
34:52 - you've done that we can then pass them
34:54 - into the Apollo server that we created
34:57 - as the first argument so that Apollo
34:59 - server knows about our different types
35:02 - and query entry points and I just said
35:05 - as our first argument I meant the first
35:06 - property in the object argument
35:09 - but anyway that's our first step
35:11 - completed making our type defs to map
35:14 - out what the graph looks like I also
35:17 - said that we need to pass another
35:18 - property into this Apollo server and
35:20 - that was a resolver's object which
35:22 - basically contains a bunch of resolver
35:24 - functions and the resolver functions are
35:26 - there for us to handle any incoming
35:28 - requests and return data to the client
35:30 - because at the moment all we've done is
35:32 - Define what the graph looks like in
35:34 - terms of the data types that we have and
35:36 - the entry points but we've not yet said
35:38 - how we want to handle requests or
35:40 - queries for that data and that's what
35:43 - the resolver functions are for so you
35:46 - can kind of think of the schema and the
35:48 - type definitions that we set up as like
35:50 - a map for Apollo to structure the graph
35:53 - but they don't actually handle any
35:55 - queries and then we make resolver
35:57 - functions to handle the queries based on
36:00 - our schema and type so I hope that makes
36:01 - sense so in the next lesson we're going
36:04 - to take a look at that and we're going
36:05 - to try making some resolvers for the
36:07 - different types of data that we're
36:09 - making available we're also going to set
36:11 - up some domain local data that we can
36:13 - use on the server as well so that we've
36:14 - got something to send back to the client
36:16 - so that's coming in the next lesson
36:21 - right then so in the last lesson we made
36:23 - our type definitions to describe the
36:25 - data on the graph and also specify the
36:28 - entry points to the graph using the
36:30 - special query type and we pass those
36:32 - into the Apollo server so it knows how
36:34 - to set the graph up next up we need to
36:37 - make some resolver functions which allow
36:39 - us to decide how we respond two queries
36:41 - to the graph so it might be that if a
36:44 - query comes in for all the games then we
36:46 - could maybe fetch all the games records
36:48 - from a database and return those as a
36:50 - response now in our case we don't have a
36:52 - database setup for this and instead I'm
36:54 - just going to use some local data stored
36:56 - in a variable in another file but you
36:59 - could quite easily hook this up to
37:00 - whatever database you prefer and work
37:02 - with that data instead so for now what
37:04 - I'm doing is making a new file called
37:06 - underscore db.js which stands for
37:08 - database and this underscore thing isn't
37:10 - necessary it's just a little naming
37:12 - convention I sometimes use when I'm
37:14 - making a data file but anyway inside
37:16 - this file I'm going to paste in a bunch
37:18 - of data which is essentially just three
37:20 - arrays stored in variables one array for
37:23 - the reviews one for the games and one
37:25 - for the authors and we can see the
37:27 - different properties that these objects
37:29 - inside the arrays have are the same ones
37:31 - that we defined in the types that we
37:33 - made in the last lesson the only
37:35 - difference is that the reviews objects
37:38 - we have a game ID property and also an
37:41 - author ID property and this is for later
37:43 - when we start to talk about how data is
37:46 - related but the rest of the properties
37:48 - match up to the ones that we defined in
37:50 - our different types
37:52 - so if you want to grab this data as well
37:54 - you can do it's all up on my repo I'm
37:57 - going to leave the exact link to that
37:59 - file to grab this data down below the
38:01 - video anyway now we have our data let's
38:04 - start making some resolver functions for
38:06 - the three entry points that we defined
38:08 - in our query type because we need to
38:10 - send a response for queries to each of
38:13 - those so then to make our resolver
38:16 - functions we'll first make a new
38:18 - constant called resolvers and then we're
38:20 - going to set that equal to an object and
38:23 - inside this we can make resolver
38:24 - functions for each different type that
38:26 - we defined now to begin with we want to
38:28 - make resolver functions for the query
38:30 - type because that root query type is
38:32 - where we Define entry points to the
38:34 - graph and specify what data should be
38:36 - returned for them we'll also be making
38:38 - resolver functions for other types later
38:40 - on as well like the review type and
38:42 - author type when we start talking about
38:44 - related nested data but for now we just
38:48 - want to make resolver functions for
38:50 - every field defined in the root query
38:52 - type
38:53 - so that's one for reviews one for games
38:55 - and one for authors and to do that we
38:58 - make a property called query capital Q
39:00 - which matches exactly the type name and
39:03 - this property is going to be an object
39:05 - as well and now we can Define in this
39:07 - object resolver functions for each of
39:09 - the properties defined on our root query
39:12 - type
39:13 - so the way this is going to work is that
39:15 - we need basically a resolver function
39:17 - for reviews called reviews one for games
39:19 - called games and one for authors called
39:21 - authors and the names need to match so
39:24 - if we go over here our first one is
39:26 - going to be for games and then this is a
39:28 - function which returns some data and
39:31 - basically we want to return the data to
39:34 - a user that they've requested now
39:36 - they've requested games so we need to
39:38 - send back an array of game objects now
39:41 - in order to do this we need access to
39:43 - this DB file so let me import that at
39:45 - the top I'm going to come to the top and
39:47 - say DB and then just paste in this
39:50 - import so import DB from dot forward
39:52 - slash underscore db.js and then down
39:55 - here we can use this to say DB Dot and
39:58 - then whatever the property is down here
39:59 - so we've got games authors and reviews
40:01 - that match up to this data so what you
40:03 - want to send back DB dot games and
40:07 - that's all there is to it we're sending
40:08 - back the array of games
40:10 - now remember when a user makes a query
40:13 - they can do so like this so let me just
40:15 - do
40:16 - some
40:18 - comments like this
40:20 - and if they make a query
40:22 - they might make a query that looks like
40:25 - this games
40:27 - and then inside here they want specific
40:29 - properties like just the title now if
40:32 - we're returning the full array right
40:34 - here you'd think well we're returning
40:36 - the ID the title the platform as well
40:38 - however Apollo handles that for us all
40:42 - it needs to know is where to grab the
40:45 - data and then if we're just requesting
40:47 - the title from each of the games it will
40:50 - do its magic on this data to take out
40:52 - any of the other stuff like the platform
40:54 - and the ID and it will just return the
40:57 - title property for each one so we don't
40:59 - have to worry about which fields are
41:01 - returned
41:03 - Apollo server is going to do that for us
41:05 - okay which is really cool so let's get
41:07 - rid of that that's the first resolver
41:09 - function done that's simple so the
41:12 - second one is going to be for reviews
41:14 - let's do that come back to index and
41:17 - we'll say
41:19 - reviews
41:21 - and this is also a function
41:23 - we need to return
41:25 - DB dot reviews and then the final one is
41:30 - going to be for authors so let's do that
41:32 - authors
41:34 - and then inside here we need to return
41:37 - DB
41:38 - dot authors all right and that's it
41:41 - we've made our three now basic resolver
41:44 - functions
41:46 - for this data over here and that's
41:48 - pretty much all we need to do so
41:51 - before this works we need to pass this
41:53 - resolvers object into here as the second
41:56 - property on this argument so let's do
41:58 - that we'll say resolvers
42:02 - and that's it
42:03 - so now what we want to do is start up
42:06 - this server so that we can test it from
42:08 - the front end so let me do that by
42:10 - opening up the terminal and if you've
42:14 - got node one installed you could type
42:16 - node Mon and then the name of the file
42:18 - which is what I'm going to do and
42:19 - basically what node mod does is it
42:22 - restarts the server every time you make
42:23 - a change to the server otherwise if
42:25 - you're just using node and then the file
42:27 - name you need to manually cancel the
42:29 - server every time you make a change and
42:30 - rerun it to pick up that change so we're
42:32 - going to say nerdman and then the name
42:34 - of the file we want to run which is
42:35 - index and hopefully oops
42:38 - we get an error so what's the error
42:41 - so refuse did you mean review let me
42:45 - have a look at this
42:47 - so we've got reviews down here let's go
42:50 - to schema oops there it is okay so this
42:54 - shouldn't be plural because it's a
42:56 - singular type Insider list all right so
42:59 - save that
43:00 - and now hopefully this is gonna work
43:04 - I'm going to cancel out this process and
43:06 - run it again
43:07 - and okay the app crashed again we have
43:10 - another error so let's have a look what
43:12 - this one is okay address is already in
43:15 - use okay so that's because I've got
43:17 - another instance of a graphql server up
43:20 - and running so let me just close that
43:21 - down first of all okay so I've just done
43:23 - that I'm going to cancel out of this
43:24 - again and try running it third time
43:27 - hopefully this is going to work now Okay
43:28 - cool so now the server is ready at Port
43:31 - 4000 awesome all right so now if you
43:34 - visit localhost Port 4000 in the browser
43:36 - you're gonna see Apollo Explorer so it
43:39 - automatically spins this up for us so we
43:41 - can test out our graphql server and let
43:44 - me just take you on a quick tour of this
43:46 - first of all if you go to schema then
43:48 - you're going to see the different
43:49 - queries that we can currently make so
43:51 - you can see it's looked at our code and
43:54 - it's seen the different queries we can
43:55 - make the different entry points our
43:57 - authors games and reviews right here and
44:00 - it also shows the data type so if we
44:02 - click on this it's going to show the
44:04 - different fields that that data type has
44:06 - and it shows what we can base get back
44:08 - all right so we have those three data
44:11 - types right here also if we look at
44:14 - scalar types it's going to come down
44:15 - here show us the different things we're
44:16 - using directives okay we don't really
44:19 - need to worry about directors for now if
44:21 - you go back to Explorer this panel on
44:23 - the left is where we're going to make
44:24 - the queries this is where we're going to
44:25 - get the response down here you might see
44:27 - another panel as well this is for
44:28 - variables which we're going to look at
44:30 - later on so let's make our first query
44:33 - you can name this something different if
44:34 - you want so I could say something like
44:36 - games query to get the games you don't
44:39 - have to name it that it doesn't really
44:40 - matter what it's called
44:42 - but now I want to get the games so I can
44:45 - click on that and remember we have to
44:47 - open up our curly braces and specify
44:49 - What fields we want from this particular
44:52 - resource so I could say that I want the
44:54 - title of each game and also the platform
44:57 - of each game so now if I click on this
45:01 - we can see we get an array of all the
45:03 - games inside a data object so we have
45:05 - this one the title and the platform
45:07 - title and platform and so forth so we're
45:10 - getting all of the games awesome
45:11 - all right so let's change this to
45:14 - something else let's try the authors
45:16 - and from each one we want the name and
45:19 - we also want the verified
45:21 - status
45:23 - click on this and it's going to fetch
45:25 - those for us Mario verified true Yoshi
45:27 - Falls Peach true awesome final one let
45:30 - us try the other resource which is
45:32 - reviews and then from here we can get
45:34 - for example the ID the rating and the
45:38 - content I'm going to click on this and
45:40 - we can see all those reviews now like I
45:42 - said you can just request some of the
45:46 - field so I could get rid of content and
45:47 - I could get rid of ID and just say that
45:50 - I want the rating click on this and now
45:52 - it still fetches all the reviews but we
45:54 - only get that rating property so we're
45:56 - not over fetching which is awesome so
45:58 - even though we explicitly return the
46:00 - full array of data Apollo is using our
46:02 - resolver function and the data we return
46:04 - to automatically filter out any of the
46:07 - fields the user doesn't need which is
46:09 - awesome so this is all working now but
46:12 - what if we wanted to fetch just a single
46:15 - review or a single author or a single
46:17 - game well for that we need to use
46:19 - something called query variables and
46:21 - we'll talk about those in the next
46:22 - lesson
46:25 - all right then gang so now we have some
46:28 - type definitions which describe the data
46:30 - we have on the graph and also specify
46:32 - the entry points to the graph which are
46:34 - to query all the reviews all the games
46:36 - and all the authors and we also have
46:38 - resolver functions for each of those
46:40 - queries too which return the data so it
46:43 - can be sent to the client but what if a
46:45 - user just wants to send a query for a
46:47 - single review or a single author or a
46:49 - single game well currently that wouldn't
46:51 - work for two reasons first we don't
46:54 - specify that a user can enter the graph
46:56 - in that way in the root query the only
46:59 - three entry points that we have are
47:01 - queries for other reviews all the games
47:03 - or all the authors and secondly we don't
47:06 - have any resolver functions to handle
47:07 - queries for single items we only have
47:10 - them to match these three entry points
47:12 - for lists of data so we need to address
47:15 - both of those things starting with this
47:17 - root query type
47:19 - and the way we do that is by just adding
47:20 - more entry points to the graph so
47:24 - underneath reviews I'm going to make
47:26 - another query available called review
47:28 - singular for a user to fetch a single
47:31 - review and that query is going to return
47:33 - a single review object now we need to
47:36 - add one more thing to this and that's a
47:38 - query variable to say that when a user
47:41 - makes this query we expect them to send
47:43 - a variable along with it as well and
47:46 - that variable would be the ID of the
47:48 - review that they want to fetch because
47:49 - we need the ID to find the review in our
47:51 - data in order to send it back to them so
47:54 - to do that we just add parentheses after
47:57 - the query name and then we can add a
47:59 - variable name which I'm going to call ID
48:01 - and we also need to specify the type of
48:03 - this variable that we expect as well
48:05 - which is going to be the ID type and
48:07 - finally we want to say that this
48:09 - variable is required when someone makes
48:11 - this query so it can't be null
48:13 - and we know to do that we can just add
48:15 - the exclamation mark at the end of it so
48:17 - now we're seeing a user can make an
48:19 - initial query for a single review but
48:21 - they must pass in this variable to the
48:24 - query which must be an ID so now we just
48:27 - need to make a resolver function for
48:29 - this query as well so back in the index
48:31 - file we can add a new function inside
48:33 - the query property of the resolvers
48:35 - object and that function is going to be
48:37 - called review singular again and inside
48:40 - this function we basically need to
48:42 - return a single review based on the ID
48:44 - variable that a user passes into the
48:46 - query so how do we get that ID in this
48:48 - resolver function well we automatically
48:51 - get three arguments available to us in
48:53 - these functions that we can use the
48:55 - first one is something called appearance
48:56 - which refers to the parent resolver in a
48:59 - resolver chain that probably doesn't
49:01 - make much sense at the minute but
49:03 - hopefully it will do later on when we
49:05 - start working with related data and
49:07 - nested queries I'm going to rename this
49:09 - first one to underscore because we don't
49:11 - need that in this function the second
49:13 - one which we do need is called args
49:16 - which stands for arguments and it's on
49:18 - here that we can access any query
49:20 - variable since with the query the third
49:22 - one is a context object which we can use
49:24 - for supplying context values across all
49:26 - of our resolvers such as authentication
49:29 - information or something like that but
49:31 - we don't need that third argument right
49:32 - now
49:33 - so we can get any query variables that a
49:36 - user sends in the query from this args
49:39 - object and what we want is the ID
49:41 - variable so we can just say
49:44 - args.id to get that and we can use the
49:48 - ID now to find whatever review has the
49:51 - ID in our data and then return it so the
49:53 - way I'm going to do this is by just
49:55 - taking db.reviews again
49:57 - and then I'm going to use the find
49:59 - method to find a single review so this
50:02 - find method basically finds a function
50:04 - for every item inside the reviews array
50:06 - and for each item we can take in a
50:10 - review as an argument so if we go back
50:12 - to the data if we're cycling through
50:15 - this
50:16 - it will refer to this first then this
50:18 - then this then this okay so each time we
50:21 - cycle through one of these items we can
50:23 - check the ID property of it now if the
50:26 - ID property matches the ID on this
50:28 - argument then we want to return true
50:31 - inside this function and when we return
50:33 - true
50:34 - it no longer needs to cycle through the
50:37 - rest of the array and it just returns
50:38 - that value for us right here okay so we
50:42 - need to say
50:43 - get the review dot ID and see if it's
50:46 - triple equal to args.id so when that is
50:50 - true that is the review that we want to
50:53 - return to the user hope that makes sense
50:56 - and that's pretty much all there is to
50:58 - it so now we can save this and test it
51:00 - out in the browser okay so how do we
51:02 - actually send a query variable from the
51:04 - front end when we're making a query well
51:07 - first of all after the query name we can
51:09 - use parentheses to declare any variables
51:12 - that can be passed into this query as a
51:14 - whole now that can be multiple variables
51:16 - in the future but for now it's just
51:18 - going to be one variable the ID and if
51:21 - you were using something like react to
51:23 - make this query you could pass those
51:24 - variables into the whole query from a
51:27 - react component and then within the
51:29 - query we can use those variables for
51:31 - different parts of the query so first of
51:34 - all let's declare what variables can be
51:36 - passed into the query as a whole so
51:38 - inside parentheses we declare each
51:40 - variable that can be passed in using a
51:42 - dollar sign and then the variable name
51:44 - so we can say dollar sign and then ID
51:46 - and then after that we use a colon and
51:49 - specify what type of data this variable
51:51 - should be in our case that's the ID type
51:54 - for all intents and purposes it's going
51:56 - to be a string that we pass in but it's
51:58 - an ID type
52:00 - now in order to pass that variable into
52:02 - the query from Apollo sandbox you can
52:05 - come down here to the bottom and select
52:07 - variables and then you can make a Json
52:10 - object of key value pairs one for each
52:13 - variable so we can add the ID one and
52:16 - set it to be one in quotations so now
52:19 - these variables are going to get passed
52:21 - into the query and populate the
52:22 - arguments inside the parentheses right
52:24 - up here so this variable will now have
52:27 - the value that we passed in from down
52:29 - here and we can use that variable when
52:32 - we request a single review inside this
52:34 - query so let's do that let's ask for a
52:38 - single review and then passing the ID of
52:41 - the review that we want to find so we
52:44 - can say ID is equal to the ID variable
52:47 - which in turn is equal to one and that's
52:51 - all we have to do to say that we want
52:53 - that one single review
52:55 - we can also specify which fields we want
52:58 - back as well though for example the
52:59 - rating and also the content properties
53:02 - so now we're asking for one single
53:05 - review with the ID of one and we just
53:06 - want these two fields for that review
53:08 - and if we hit send we should see the
53:10 - response from the server which contains
53:12 - that review and inside it the two fields
53:15 - that we asked for awesome so that's how
53:17 - we use Query variables from the front
53:19 - end now let's try and do something
53:21 - similar for the other two data types
53:23 - that we've got
53:24 - or rather than so back in a schema let's
53:27 - define our different entry points so
53:28 - underneath games I'm going to do a
53:31 - single one so game and that's going to
53:33 - return a single game object now again we
53:35 - need to declare that this needs an ID
53:39 - argument or variable which is of type ID
53:42 - and that's required and same for this
53:44 - down here author
53:46 - and again we need to define the query
53:48 - variable which is of type ID and
53:50 - required and that returns a single
53:53 - author so that's the schema done back
53:55 - over in index we need to basically do
53:58 - the same thing for author and game that
54:00 - we did for review so I'm just going to
54:03 - copy this and I'm going to paste it up
54:05 - here
54:06 - change the name of this to game and we
54:09 - still need the args the whole logic is
54:11 - the same however we just need to rename
54:14 - this to game and this to game as well so
54:16 - we're basically returning the game where
54:18 - the IDS match and then down here we need
54:22 - a comma first of all
54:24 - and we have authors so let's paste this
54:27 - in again do a comma change this to
54:29 - author singular
54:31 - and we'll change this to author and
54:34 - change this to author and also we need
54:37 - to change this one right here because we
54:38 - want to look inside the games array and
54:40 - this one should be the author's array I
54:43 - think that's pretty much it so now they
54:45 - should all work for the other two types
54:46 - as well but let's check it out in Apollo
54:48 - Explorer so let's give this a whirl I'm
54:51 - not going to change the name because it
54:53 - doesn't really matter but we're always
54:54 - still passing in the ID and we'll just
54:56 - pass in one it doesn't have to change I
54:58 - mean we'll change it to two just to have
54:59 - a look and then this time instead of
55:02 - review in fact let's try and review
55:03 - first of all to see if we can get a
55:05 - different one back which we do okay now
55:08 - let's change this to game with the ID of
55:11 - two now we need different fields for the
55:13 - game I think we have a title and also a
55:16 - platform I'm also going to return the ID
55:17 - just to make sure it's getting the
55:18 - correct one and we can see the ideas too
55:21 - the title and also the platforms uh
55:24 - let's try a different one so we'll say
55:26 - three here
55:28 - send that okay yeah that works and then
55:31 - finally let's try the authors so
55:34 - singular author
55:36 - I'm gonna go back to one and we want the
55:39 - name and we'll also
55:43 - get the verified status that's it
55:45 - verified like so and the ID
55:48 - press this send button and we can see
55:50 - this works as well let's change the
55:51 - variable to two
55:53 - and yeah it brings back the Yoshi one
55:56 - the different one awesome so this is all
55:58 - working now that's how we can send query
56:00 - variables in our queries
56:04 - all right then so things are starting to
56:06 - take shape now we can query lists of
56:07 - data and also we can query single data
56:09 - items as well using query variables and
56:12 - now I want to take this one step further
56:13 - and talk about related data in graphql
56:16 - so if we open up the DB data file and
56:18 - look at the reviews data we can see that
56:20 - each of you has an auth ID property and
56:22 - also a game ID property and that's the
56:24 - way in our data we're relating these
56:27 - different things so that every review
56:28 - has an Associated author an Associated
56:31 - game as well so if I was to pluck out a
56:34 - random review I would then be able to
56:36 - try and find the author and the game
56:39 - associated with that review and likewise
56:41 - if I was to pick out a random game I
56:43 - could look at the ID of that game and
56:45 - then run through the reviews array to
56:47 - find any review where the game ID
56:49 - matches that meaning I could pick out
56:50 - all the reviews associated with a single
56:53 - game now that's how this looks on the
56:56 - data side of things but currently in our
56:57 - schema we don't really Define any
56:59 - relationships between the data so when
57:02 - Apollo makes our graph based on this
57:03 - schema it won't know that every game has
57:06 - a list of related reviews at the moment
57:08 - and that every review has a related
57:11 - author and game and also that every
57:13 - author has a list of reviews that they
57:15 - wrote so we need a way of defining those
57:18 - relationships in our schema so that
57:20 - Apollo knows to make our graph that way
57:22 - with those relationships alright so
57:25 - let's start with the review type right
57:26 - here so we know that every review is
57:29 - associated with a game and an author so
57:32 - I could say that the game is going to be
57:34 - of type game like so and that's required
57:37 - right because we can't have a review for
57:39 - no game that's not going to exist also
57:42 - we have the author
57:45 - property which is going to be of type
57:47 - auth again required because every review
57:49 - needs an author alright so down here
57:53 - every game is going to have a list of
57:56 - reviews so we'll say reviews
58:00 - it's a list so square brackets and then
58:03 - inside the type is review now the types
58:07 - inside this can't be nullable the data
58:10 - inside it so we need exclamation mark
58:12 - right here but that's not to say that we
58:14 - have to have reviews we're not going to
58:16 - put exclamation mark right here this can
58:18 - be nullable as a whole if the game
58:20 - doesn't have any reviews but if we have
58:23 - some data inside this list it has to be
58:25 - a tight review that is required it can't
58:27 - be null okay
58:29 - so same down here for the author let's
58:31 - say the reviews by this author
58:34 - are going to be a list of review objects
58:36 - again exclamation mark but none at the
58:38 - end because there can be authors that
58:40 - haven't written any reviews yet all
58:42 - right okay so now we've made those
58:44 - connections in our different types we
58:46 - also need to make some resolver
58:47 - functions to resolve any nested queries
58:49 - for the related data for example I might
58:52 - query it for a single game and then make
58:55 - a nested query for all the reviews for
58:57 - that game and that query would look
58:59 - something like this where the initial
59:01 - jumping in point is for a single game
59:03 - but then we also ask for the reviews
59:05 - related to that game along with the
59:07 - rating and content for each review so at
59:10 - the moment Apollo doesn't really know
59:12 - how to handle that nested query for the
59:14 - reviews inside a specific game the only
59:17 - way it knows how to resolve reviews
59:19 - currently is either by grabbing all of
59:21 - them or just by grabbing one of them
59:23 - based on the ID and these are both root
59:26 - queries defined in the query type in our
59:28 - schema so it doesn't know how to get a
59:31 - subset of reviews based on the ID of a
59:33 - particular game we don't have a resolver
59:36 - for that so the way we make this
59:37 - resolver is not by making it inside this
59:40 - query object because these are resolvers
59:43 - for entry points to the graph as defined
59:46 - by the query type that we made in the
59:48 - schema
59:49 - so instead because this nested request
59:52 - is associated with a game object we make
59:55 - a new property inside the resolvers
59:57 - object called game which is also an
60:00 - object and then inside this we can make
60:02 - a resolver function called reviews where
60:05 - we can tell Apollo how to get all the
60:07 - reviews based on the pair inquiry for
60:10 - the single game
60:12 - so I'm going to make a function called
60:14 - reviews to do this and it's going to
60:16 - take in that first argument called
60:18 - parents now remember I mentioned this
60:20 - one in a previous video but we didn't
60:23 - need it back then however now we do need
60:25 - it so the way this is going to work is
60:27 - because our entry point for the query is
60:29 - a single game Apollo will run that
60:32 - initial resolver function inside the
60:34 - query object to get that single game
60:36 - then to resolve the reviews for that
60:39 - game it's going to look to the game
60:41 - object since that's what we just grabbed
60:44 - right again and then it's going to look
60:46 - for the reviews resolver inside that to
60:49 - grab the reviews
60:50 - so it's inside this function that we
60:54 - tell Apollo how to do that but how do we
60:56 - know what game we're getting reviews for
60:59 - well we can access the ID of the game
61:01 - via the parent argument because the
61:04 - parent argument is a reference to the
61:06 - value returned by the previous or parent
61:09 - resolver now in our case that's going to
61:13 - be the game one so the initial one
61:15 - inside the query object so that parent
61:17 - argument will basically be a game object
61:20 - and that game object is going to have an
61:23 - ID which we can then use so we can use
61:25 - the ID now to return all the reviews
61:27 - associated with that game ID and the way
61:31 - we're going to do this is by first of
61:33 - all returning DP which is the data
61:35 - remember that we imported and then we
61:38 - want the reviews array on that then
61:40 - we're going to use the filter method so
61:42 - what we're going to do is filter out any
61:44 - review that doesn't have the same game
61:47 - ID as the ID on the parent
61:50 - because if they are the same and we
61:53 - return true for each of those then it's
61:55 - going to keep those in the filtered
61:57 - array and that's what we want any review
61:58 - associated with the game where the IDS
62:00 - match if they don't match it's going to
62:02 - filter them out and they're not returned
62:03 - in that array so we fire a function for
62:06 - each item inside the array I'm going to
62:09 - refer to each review item as R and then
62:12 - we want to return r dot game underscore
62:16 - ID remember that is the property
62:18 - if we go over here each of you has a
62:20 - game underscore ID to associate it with
62:23 - a particular game and we want to check
62:25 - if that matches with a particular game
62:27 - the game we've just queried so we'll say
62:30 - triple equal to the parent which has the
62:34 - ID property because that is essentially
62:36 - the game object so where they match
62:38 - they're going to stay in The Returned
62:40 - array because they're associated with
62:42 - each other and that's what we want we
62:44 - want to return all the reviews
62:45 - associated with that game where they
62:47 - don't match the filtered out so we don't
62:49 - return those okay so let's save this and
62:52 - give it a whirl okay then so I've got
62:54 - this query already set up so we're using
62:57 - a query variable ID which we're passing
62:59 - right here so id2 we ask for the game
63:02 - with the ID and grab the title but also
63:04 - all the reviews associated with that
63:07 - particular game ID and we'll get the
63:08 - rating and the content from each one so
63:10 - let's give this a whirl and yep cool so
63:13 - we can see we get the game title and two
63:15 - reviews right here and what I'm gonna do
63:17 - is also put in here
63:20 - the game ID let me do commas here like
63:23 - so and then I'll say the game underscore
63:26 - ID that should be two oh in fact we
63:30 - can't do that and the reason we can't do
63:32 - that is because we didn't specify that
63:34 - on our schema all right so I'm not going
63:37 - to do that but if you remember in our
63:39 - different types on the review object we
63:41 - didn't add the game ID that is something
63:43 - you could do if you wanted to but it's
63:45 - not going to work here because I didn't
63:46 - add it but either way we can see that
63:48 - this works and if I put in a different
63:50 - ID like three and try that out we can
63:53 - see now we get a different game with one
63:55 - review I'm gonna put in an idea of one
63:57 - here and yeah that's working as well
63:59 - awesome Okay so we've sorted out related
64:02 - data when it comes to finding reviews
64:04 - for a game but reviews can also be
64:06 - associated with an author can't so if we
64:09 - take a look at author they could have a
64:11 - list of reviews as well so let's do the
64:12 - same thing for author so like we had a
64:14 - game property this time we need an
64:17 - author property like so which is an
64:19 - object and then we want the reviews
64:21 - resolver for this where we're taking the
64:24 - parents and then inside there we're
64:26 - going to do essentially the same thing
64:27 - as this
64:29 - so let's return reviews.filter this time
64:33 - we want to check the author ID is equal
64:37 - to the parent ID all right so the author
64:40 - ID on the review remember we have that
64:42 - right here we're checking this against
64:44 - the ID of the author we selected and
64:46 - then we're only returning the reviews
64:49 - where if this was the author for example
64:51 - one we'd return this one and this review
64:54 - okay
64:55 - so let's save that I'm not going to test
64:58 - it just yet because there's one more set
65:00 - of resolvers I want to do and that's for
65:03 - the review so imagine we select a single
65:07 - review if we go to our schema
65:09 - we can see that each review has an
65:12 - Associated game and author so they would
65:15 - be nested queries so we need to make a
65:17 - resolver function to get the game
65:18 - associated with that review and also the
65:21 - author so two resolver functions right
65:23 - here
65:24 - so let's do the auth first of all
65:27 - and we're taking the parents so the pair
65:29 - at this time is going to be a single
65:31 - review and we're going to return DB
65:34 - dot authors and then we're going to find
65:37 - a single author because this isn't a
65:40 - list of authors associated with a single
65:42 - review we only have one author per
65:44 - review so we're finding a single one so
65:47 - we fire a function for each element in
65:49 - the array and I'm going to call each
65:51 - element a for author and then what we
65:53 - want to do is grab the ID of that so a
65:55 - DOT ID and we want to return true when
65:58 - it's equal to the parent which is the
66:01 - review object dot author ID so where
66:04 - they match it means that author is
66:06 - associated with this review and we're
66:09 - returning that single author now we need
66:11 - to do the same thing but this time it's
66:13 - going to be for the game because again a
66:16 - single game is associated with a
66:18 - particular review so game and then we'll
66:21 - change this to G change this to G for
66:24 - game and then this is going to be game
66:26 - underscore ID and that's all there is to
66:29 - it oops this needs to be games
66:31 - right here
66:32 - cool so now we have our resolver
66:34 - functions for nested authors and games
66:37 - inside a review object and also for
66:40 - reviews inside an author alright
66:43 - cool so let's save this and try it out
66:46 - again
66:47 - all right then so let's start the
66:49 - starting off point as author we'll keep
66:53 - the ideas one that we pass in we want
66:55 - the author name
66:58 - and then we'll get the reviews
66:59 - associated with the author so we'll
67:02 - press that and we can see Mario has
67:04 - these reviews right here these two
67:05 - awesome and then let's try author with
67:09 - the ID of two
67:11 - like so so we have Yoshi and these three
67:14 - reviews awesome so that's working now
67:16 - what I'm going to do is I'm going to
67:18 - copy this and I'm going to make a new
67:20 - query so we can come back to this and
67:23 - I'm going to paste it in here and just
67:24 - change it so we'll change this to
67:26 - review
67:28 - query and then we'll pass in an ID again
67:32 - so let me go back here and copy this
67:35 - like so paste it in and then we want a
67:38 - single review right here with the ID
67:40 - we're going to get the rating of that
67:44 - review but then also we want the
67:47 - associated game and for the game we will
67:50 - get the title and the platform like so
67:53 - oops
67:55 - platform
67:57 - press send and we can see now we get the
67:59 - review and the single game associated
68:02 - with that review which is awesome we
68:04 - also can get the author Remember so
68:06 - let's do that as well and for the author
68:08 - we want the name and also we'll get the
68:10 - verified
68:12 - property as well which is true or false
68:15 - so now we get the author as well awesome
68:17 - change the ID and those should change as
68:19 - well
68:20 - yep cool awesome so this is all working
68:23 - now not only this but
68:27 - what I could do is I could get a single
68:29 - review and the rating get the game that
68:32 - is associated with that review and I
68:34 - could also say well I'll tell you what
68:35 - get me all the other reviews
68:39 - associated with that game and from those
68:42 - I could just get the rating
68:44 - now the reason I can do this is because
68:46 - we have a resolver chain so the first
68:50 - one the entry point is for a single
68:52 - review right so we use that initial
68:54 - resolver function defined inside the
68:56 - query object
68:57 - to get that single review then we move
69:00 - on to the game resolver inside the
69:03 - review object so it gets the game
69:05 - associated with that review that's the
69:06 - quick that's the resolver function we
69:08 - just made
69:09 - and then since we're asking for reviews
69:11 - inside the game it goes to the resolver
69:15 - function for reviews inside the game
69:18 - object and this time the parent refers
69:21 - to this right here so we have this kind
69:24 - of resolver chain and we always have
69:25 - access to the previous resolver as the
69:27 - parents so we can Nest as much as we
69:29 - want here and this is going to work
69:30 - which is awesome so we'll get the review
69:33 - and the rating for that review the game
69:34 - associated with it and all the other
69:36 - reviews along with the rating for that
69:39 - particular game awesome
69:43 - all right then my friends so now we can
69:45 - do quite a lot in terms of making
69:46 - queries to fetch data and related data
69:49 - as well which is cool but at the moment
69:51 - all we can do is fetch the data we can't
69:53 - add new data or edit the current data or
69:56 - delete data or any of that jazz so I
69:58 - want to address that now by talking
70:00 - about mutations and the mutation is
70:03 - basically a generic term in graphql for
70:05 - any kind of change that we want to make
70:06 - to the data whether it be to add new
70:09 - data delete data or edit current data so
70:12 - the first thing we need to do is Define
70:14 - our allowed mutations in the schema by
70:16 - making a new type which is called
70:18 - mutation and it's inside this type that
70:21 - we can then decide how users can mutate
70:23 - any data for example I might want to
70:26 - expose a mutation called delete gain and
70:30 - for that mutation we need an ID argument
70:32 - to say what game should be deleted we
70:35 - also specify the return type as well
70:37 - after a user makes this mutation much
70:40 - like we did for the root queries so for
70:43 - example once a user deletes a game from
70:45 - the data I might want to send back an
70:47 - updated list of all the games after that
70:50 - one has been removed so I'd use an array
70:52 - of game objects right here okay so
70:56 - that's the mutation defined but we also
70:58 - need to make a resolver for the mutation
71:00 - as well inside our resolvers object
71:03 - called mutation so right at the bottom
71:07 - down here comma and then mutation
71:10 - which is an object and we just make
71:12 - resolvers in much the same way as we did
71:13 - for these for these Etc so we want to
71:16 - make a resolver called delete game right
71:19 - here so let's do that
71:20 - delete
71:22 - game like so and it also takes in the
71:25 - same arguments so we have the parent we
71:27 - also have the args over here and then
71:29 - context if we want it so we don't
71:30 - actually need the first one which is
71:32 - parents to delete a game but we do need
71:34 - the arguments because we want the ID of
71:36 - the game that we want to delete so
71:38 - inside here oops
71:40 - inside here what we want to do is
71:42 - basically update the value of the games
71:46 - array because that's what we're editing
71:47 - right here we're deleting a game so we
71:49 - want to remove one right so let's say
71:52 - that DB
71:54 - dot games is equal to something new and
71:56 - that's going to be DB
71:58 - dot games dot filter
72:01 - and by the way in a real application you
72:03 - probably use a database right like maybe
72:05 - mongodb or something like that so you
72:07 - would use the library for mongodb to
72:10 - connect to that and just delete a game
72:12 - this way we're just using local
72:14 - variables as data because then it's
72:16 - easier for me to keep the focus on
72:18 - graphql all right anyway so dot filter
72:21 - so we want to go through this array and
72:23 - we fire a function for each game which
72:25 - I'm referring to as G inside this array
72:27 - and we want to return false
72:32 - whereby the ID is equal to the ID on
72:37 - here and we're returning false in that
72:40 - scenario because if we return false it
72:42 - filters it out of the array and
72:43 - therefore the filter array is not going
72:45 - to include that game that we want to
72:46 - delete so we say g dot ID is not equal
72:50 - to args.id so where they're not equal it
72:54 - returns true and it keeps that in the
72:56 - array where they are equal that's the
72:58 - game we want to delete it returns false
73:00 - and therefore we filter out the array
73:02 - all right
73:03 - so now we also need to return something
73:06 - and we specified the return type to be a
73:08 - list of games so the updated games array
73:10 - so all we need to do then is return DB
73:13 - dot games like so all right so let's
73:16 - save this and give it a whirl so how do
73:19 - we actually make a mutation from the
73:20 - front end because when we make a query
73:22 - we use this query keyword give it a name
73:24 - and then specify what we want now with a
73:26 - mutation it's a very similar we just
73:28 - specified that it's a mutation not a
73:30 - query it anymore then we can give this a
73:32 - name so I could call it delete mutation
73:37 - we can specify any variables that need
73:40 - to go into this query and we do need a
73:42 - variable that's going to be the ID
73:44 - and that's going to be of ID type
73:46 - and then inside here we can specify what
73:49 - mutation we want to make and that was
73:50 - called delete game so let me get rid of
73:53 - this because it's automatically created
73:55 - it for us
73:56 - and this should be ID instead to refer
73:59 - to this
74:01 - so now we need to pass in the ID
74:03 - variable down here and that is going to
74:06 - be
74:07 - 2. so we're deleting the game with the
74:10 - ID of two and remember we get back as a
74:13 - return an array of games with that game
74:17 - deleted so an updated version of it so
74:19 - we can specify now what fields we want
74:21 - back so I could say we want the ID of
74:23 - the game back the title and the platform
74:27 - so let's give this a whirl delete
74:28 - mutation all right so now we can see ID
74:31 - 1 and 3 and 4 and 5 but no two because
74:35 - it's been deleted
74:36 - now obviously when the server restarts
74:39 - that is going to be there again because
74:41 - we reinitialize the variables and all
74:43 - that jazz this is not permanent this
74:45 - deletion it's only while you know this
74:48 - current session is going on if you like
74:49 - but as soon as we restart the server
74:52 - that's going to return but like I said
74:54 - you'll probably use a database where
74:55 - you'll have a bit more persistence than
74:57 - this so anyway now we've deleted a game
74:59 - Let's also try adding a new game okay so
75:03 - now we've made this delete game mutation
75:05 - next I want to try making a mutation
75:07 - whereby a user can add a new game so how
75:09 - do we do that well first of all we need
75:12 - to go to the mutation type in the schema
75:14 - and we need to add the mutation which
75:16 - I'm going to call add game and it's
75:19 - going to accept some arguments so we do
75:20 - need parentheses but we'll come back to
75:22 - those in a second now as a return value
75:25 - we're going to send a single game object
75:27 - back to the user the one that we just
75:29 - created
75:30 - so for the arguments of this mutation we
75:33 - need to basically grab all of the fields
75:36 - that make up a new game minus one of
75:38 - them the ID because we don't want the
75:40 - user to decide the ID of the new game
75:43 - that they add instead we're going to
75:45 - generate a random ID in the resolver
75:47 - later for this mutation but we still
75:50 - need the game title and maybe the game
75:53 - platform
75:54 - maybe the game price if there is one
75:56 - basically any property that makes up a
75:59 - new game so we could add each of those
76:01 - fields as different arguments inside
76:04 - here or we could make a new special
76:07 - input type in our schema which allows us
76:09 - to group together several arguments into
76:12 - one type and then that can be used as a
76:15 - single argument elsewhere like in this
76:17 - mutation so the way we do that is by
76:20 - coming down here and first of all saying
76:22 - input instead of type which says to
76:25 - graphql that this isn't an actual type
76:27 - of data but more of a collection of
76:29 - fields that we can use in a mutation as
76:32 - a single argument for example
76:34 - so inside this then we can choose What
76:36 - fields we want this input to have and
76:39 - also the type of those fields
76:46 - so I've said right here we need two
76:48 - properties the title which is a string
76:50 - and also the platform which is a
76:52 - collection of strings or a list of
76:53 - strings and they're both required we
76:55 - don't want to add in the reviews because
76:57 - we're not making a review we're just
76:59 - making a game and then later if you were
77:01 - to have a review you would associate it
77:03 - with a particular game we don't need to
77:05 - do that right here when we're adding a
77:06 - game for the first time but now what we
77:08 - can do is we can say okay this mutation
77:10 - takes in a variable called game and that
77:14 - is going to be of type add game input
77:17 - and it's required so when we're making
77:18 - this mutation from the front end it's
77:20 - going to require us to add a game
77:23 - variable which looks something like this
77:25 - an object with these two properties okay
77:28 - so now we have that mutation sorted we
77:30 - can go back to the index file and we can
77:32 - add that mutation right here after
77:34 - delete game so I will call this add game
77:37 - and we're going to take in the args
77:40 - argument so we don't need the first one
77:42 - which is parent so underscore for that
77:43 - then args and the reason we need that is
77:45 - because the game property is going to be
77:47 - on the arguments because we're sending
77:49 - that from the front end and on that game
77:50 - it's going to be the title and platform
77:52 - properties so what do we want to do here
77:54 - well we want to make a new game object
77:56 - and add it to the game array right
78:00 - so we can make the object first of all
78:02 - by saying let's game equal to an object
78:05 - then we're going to spread out so dot
78:07 - dot dot args dot game and it's dot game
78:10 - because that is the name of this
78:12 - variable and on that will be those two
78:14 - properties the title and the platform so
78:16 - we're adding those two properties to the
78:18 - new object and then the reason I'm
78:20 - spreading that is because we also need
78:22 - an ID property which we need to randomly
78:24 - generate now you might be better off
78:26 - using some kind of random uid generator
78:29 - library or something like that I'm going
78:31 - to use the mass object to generate this
78:33 - for the sake of our tutorial but we're
78:35 - going to say math.flor then math dot
78:37 - random and this generates a random
78:39 - number between 0 and 1 in decimal format
78:41 - and then we'll times that by 10 000 so
78:45 - what this will do is generate a random
78:47 - number between one and ten thousand and
78:49 - it will have decimal points as well but
78:51 - then what we're doing is flooring that
78:52 - so it becomes an integer okay and then
78:55 - we'll convert it to string like so
78:58 - so we have our ID property we also have
79:01 - the other arguments that we passed along
79:02 - and we have the new game object now we
79:04 - just need to push that to the games
79:07 - array so we can say let me come back up
79:09 - a line DB dot push and then we're going
79:11 - to push on in fact not
79:15 - db.db.games.push to push onto the games
79:17 - array and we push on the new game
79:19 - awesome and then finally we return
79:22 - that new game that we created because if
79:24 - we go to the schema we can see we return
79:26 - a game type all right so that is pretty
79:29 - much it my friends so let's try this
79:31 - from the front end okay then so let me
79:34 - just copy this and then we'll go over
79:36 - here and paste it in and we're going to
79:38 - call this one add mutation
79:42 - we also need to pass in the ID no we
79:44 - don't in fact do well we need to pass in
79:46 - a game object and that is a type
79:52 - add
79:53 - game
79:54 - input like so all right so now we need
79:58 - to specify that the game is required
80:01 - here
80:02 - like so and then this is called
80:05 - add game instead
80:07 - alright so now down here we need to pass
80:09 - the variables in
80:10 - so remember we need a game
80:14 - property and that is an object and
80:16 - inside the object we have the title so
80:19 - we'll just say a new game
80:22 - very original right and then we also
80:24 - need a platform and that platform is
80:27 - going to be an array and inside here we
80:30 - will say switch and PS5
80:35 - like so so remember it Returns the new
80:39 - game back and we're requiring D3 feels
80:42 - from The Returned game so let's try this
80:44 - add mutation and you can see now we get
80:46 - this random ID 263 the title and the
80:49 - platform awesome so that's worked and
80:52 - now I'm going to go back over here and
80:55 - I'm going to just require all of the
80:56 - games right here so games like so we
80:59 - don't need these anymore just so we can
81:02 - see an updated list of games and we'll
81:03 - get the title of each one and we don't
81:06 - need these parentheses let's run this
81:09 - and you can see now a new game so it's
81:12 - been pushed on to the array awesome so
81:14 - in the next lesson we're going to look
81:16 - at one more mutation and that is to
81:18 - update existing data
81:22 - all right then so in the last lesson we
81:24 - made our first two mutations want to add
81:25 - the game and one two delete a game and
81:27 - for adding a game we made this ad game
81:30 - input where we collated two Fields
81:32 - together so that could be our variable
81:35 - right here just this one variable called
81:36 - gain which has this kind of structure so
81:39 - we're gonna do one more mutation now and
81:41 - that is going to be for editing a game
81:43 - so I'm going to come down to the bottom
81:45 - and I will make a new one called update
81:48 - game like so now in here we need some
81:52 - arguments now what do we need we need
81:54 - the ID of the game that we want to
81:55 - update and we didn't need an ID here
81:58 - remember because we're adding a new game
82:00 - that doesn't have an idea yet but when
82:01 - we're updating existing data we need the
82:03 - ID of the game that we want to update so
82:06 - let's put that in but we also need any
82:09 - kind of edits that we want to make all
82:11 - right so what I'm going to do is make
82:13 - another argument called edits and for
82:15 - this I'm going to create a new input so
82:17 - let me copy this
82:19 - and paste it down here and I'm gonna
82:21 - call this
82:23 - edit game input and then we'll set that
82:26 - here edit game input like so and we're
82:31 - not going to make this yeah in fact we
82:32 - will make this required
82:34 - okay and this is going to return
82:36 - game now these things right here these
82:39 - two Fields they are the same so you
82:41 - might be thinking well why didn't we
82:43 - just reuse this one here and the
82:46 - difference is that I'm not going to make
82:47 - these two required because if you go to
82:50 - update a game
82:52 - you might just want to update one of the
82:54 - fields like title so I don't want to
82:55 - make there for the platform required if
82:57 - you don't want to update that and
82:59 - likewise if you just update the platform
83:00 - you might not want to update the title
83:02 - so therefore I don't want to make this
83:04 - required so if I reuse this we would
83:06 - have to basically update both of the
83:08 - fields in order for this to work but I
83:10 - don't want to make a user do that
83:13 - so by making a new one where they're not
83:15 - required it's a bit more flexible and
83:18 - also I'm not putting the ID in here
83:22 - like so and instead of specifying it
83:25 - here and the reason for that is because
83:27 - it's not really an edit is it so I don't
83:30 - want to group the ID into some kind of
83:32 - edits object I'd like that to be its own
83:34 - separate argument so let me
83:37 - delete that save it and now we can
83:40 - create a resolver function for this
83:42 - update game mutation all right then so
83:45 - let's add this in down here update
83:48 - game like so and we don't need the first
83:50 - argument the parent but we do need the
83:52 - arcs because the edits and also the ID
83:54 - are going to be on that and then down
83:55 - here what I'm going to do is just paste
83:57 - in a bit of code and this is what we're
83:59 - using to basically update the games
84:02 - array so we're taking the games on DB
84:05 - and we're setting it equal to
84:07 - db.games.map so we're mapping through
84:09 - the array and basically creating a new
84:12 - array out of it so we fire a function
84:14 - for each item in the array and for each
84:16 - item we check does that particular game
84:19 - that we're currently iterating have an
84:21 - ID that is equal to the ID on the
84:24 - arguments because remember we're going
84:26 - to have an ID property on this right
84:29 - here
84:30 - and if it does match then we're going to
84:33 - return
84:33 - this thing right here G so the current
84:36 - objective you like and spread those so
84:39 - whatever properties it currently has
84:40 - we're adding right here and I'm also
84:42 - spreading args.edits so if for example
84:46 - we update the title then it's going to
84:47 - override the title that's over here that
84:49 - we're spreading does that make sense
84:51 - so that's the returned object right here
84:54 - and that's going to go inside the array
84:56 - then if these don't match then we don't
84:58 - need to change it and we just return the
84:59 - original object to the array so I hope
85:01 - that all makes sense
85:02 - now at the end of this update game
85:05 - mutation we need to return something
85:07 - back to the user so if we take a look at
85:08 - the schema we return the game that we
85:11 - just edited so we shall say return and
85:15 - then we'll say db.games dot find to find
85:18 - a particular game and we can cycle
85:21 - through those and we want to return the
85:23 - game where the ID is equal to
85:26 - args.id because again remember we have
85:29 - the ID argument right here okay
85:33 - cool so now we have that mutation let's
85:36 - try it out okay then so back over here
85:38 - I'm going to create a new tab and I'm
85:41 - going to copy this mutation which is for
85:42 - adding a game I'm going to paste it over
85:44 - here and then I will call this edit
85:47 - mutation and this right here needs to be
85:50 - edit
85:52 - game input and this is called edits
85:56 - this and this right here is edits and
86:01 - dollar sign edits but also remember we
86:03 - need to pass in the ID so we can say the
86:05 - ID is equal to oops I need dollar sign
86:08 - first of all ID is of ID type like so we
86:12 - need the ID right here
86:14 - so let's say the ID
86:17 - is
86:18 - the ID variable awesome okay this is not
86:23 - ad game it's updates game like so and we
86:27 - don't pass in the ID we can pass in a
86:30 - title and a platform
86:32 - or imagine these are what we're going to
86:33 - get back so we can pass in the ID here
86:35 - if we want to for the variables let's
86:37 - copy this again
86:39 - because it's going to be very similar
86:41 - and paste it right here so we're going
86:43 - to have an edits property
86:46 - and we also need an ID property so let's
86:49 - do the ID down here oops done that
86:51 - incorrectly comma here and then ID
86:56 - or set that equal to two
86:58 - and we'll change this to
87:03 - I don't know Dark Souls
87:05 - like so
87:06 - and then we don't need to pass in an
87:08 - update for this
87:09 - so let's just do that
87:12 - so then we're going to get these fields
87:13 - back so what we're doing is we're
87:15 - passing in the edits right here of which
87:17 - we just have won the title and then the
87:19 - ID of the game we want to edit so we're
87:21 - passing both of those in here and then
87:23 - we're using those inside this mutation
87:25 - and we're saying look once you've made
87:27 - this mutation this edit send back the
87:29 - game and give us the title and platform
87:31 - so the title should be updated now so
87:34 - let's do that
87:35 - and we can see now the title is Dark
87:37 - Souls the platform is unchanged if I
87:40 - change instead
87:42 - platform
87:44 - and this needs to be an array of strings
87:45 - now doesn't it
87:47 - and we'll just change this to be
87:50 - I don't know um XBox whatever let's edit
87:54 - that again and now it's just Xbox I can
87:56 - change this now to PS5 if I wanted to
87:58 - and we'll do switch as well
88:02 - and also if we wanted to change the
88:04 - title as well we can do so we'll just
88:08 - say I don't know some other game can't
88:10 - think off the top of my head edit and we
88:13 - can see now we've made those edits
88:15 - awesome all right then gang so that's
88:16 - pretty much it for this series then I
88:18 - really hope you enjoyed it and hopefully
88:20 - you feel comfortable now with the basics
88:22 - of graphql in terms of making a graphql
88:25 - server but also in terms of the query
88:27 - syntax and actually making queries from
88:29 - the front end and if not then I guess
88:32 - thanks anyway for wasting the last two
88:33 - hours of your life watching my videos
88:35 - but yeah hopefully not and fingers
88:37 - crossed it wasn't a complete waste of
88:38 - time but anyway in the future I will do
88:41 - more courses to incorporate graphql like
88:43 - how to use graphql in a next JS site or
88:46 - maybe with super bass or something like
88:48 - that and that's one of the main reasons
88:49 - I wanted to make this course right here
88:51 - so that it serves as a jumping in point
88:53 - to learn the basics of graphql quickly
88:55 - so we can do more advanced stuff in the
88:58 - future