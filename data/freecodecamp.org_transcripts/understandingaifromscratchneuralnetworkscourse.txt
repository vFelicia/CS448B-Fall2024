00:00 - learn the fundamentals of neuron
00:01 - networks from one of the most popular
00:03 - machine learning instructors Dr Ru in
00:07 - this unique handson course you'll learn
00:09 - Core Concepts and manually tweak Network
00:12 - parameters to create a self-driving car
00:15 - while this is phase three of his machine
00:17 - learning series it's fine to start here
00:19 - so let's get started I've been wanting
00:21 - to make this course for six years I got
00:25 - the idea when Grant from three blue and
00:27 - brown posted his video on neural
00:29 - networks the moment he said this one
00:32 - thought experiment that is at once fun
00:34 - and kind of horrifying is to imagine
00:36 - sitting down and setting all of these
00:38 - weights and biases by hand so welcome to
00:41 - my fun and horrifying new course where
00:43 - we'll play with neural networks inside
00:45 - this special playground I created the
00:48 - goal is to teach the car how to drive
00:50 - and we'll do that by manually changing
00:52 - the network parameters using the mouse
00:55 - wheel we'll start with a simple Network
00:58 - that just stops the car from going off
01:00 - Road and gradually increases complexity
01:02 - to teach the car different traffic rules
01:05 - as well there I say you don't need any
01:08 - prerequisites to start this course I
01:10 - think the playground and the lessons do
01:12 - a good job explaining the math I use
01:15 - human language and only introduce fancy
01:17 - terms so you know they exist in case you
01:19 - find them elsewhere but if I'm wrong and
01:22 - you still get confused just ask in the
01:24 - comments or on
01:25 - Discord Now by changing these parameters
01:29 - manually will understand exactly what
01:31 - the neural network does this is really
01:34 - different because courses normally teach
01:36 - neural networks in a machine learning
01:38 - context where they're automatically
01:39 - generated from data that makes them work
01:42 - really well but it becomes impossible to
01:45 - tell what they do exactly it's why we
01:47 - call them
01:48 - blackboxes but I want you to understand
01:51 - what the neural network can do before I
01:53 - teach those complex algorithms for
01:55 - generating them and the best way to
01:58 - understand I think is by playing with
01:59 - them like this now this course is good
02:03 - for those starting with AI but also
02:05 - those with some experience who want to
02:07 - understand things better I've been
02:09 - working with machine learning for over
02:11 - 10 years now and some things still
02:13 - surprise me I think it's because
02:15 - training complex models is so easy
02:17 - nowadays just write few lines of code
02:20 - and you're done makes us overconfident
02:23 - thinking we know more than we do I've
02:26 - seen many solutions that fall short are
02:28 - overly complex and use unnecessary
02:31 - resources if you took my machine
02:33 - learning course you know what I'm
02:35 - talking about there we use the huge
02:37 - neural network to get the best results
02:39 - but one with the fraction of the size
02:41 - could have good accuracy as well and we
02:43 - could explain what that does so I think
02:46 - there's real value in revisiting Basics
02:49 - from time to time throughout the course
02:52 - I'll give you homework assignments to
02:54 - improve your logic and deepen your
02:56 - understanding I'll also give you a final
02:58 - challenge toach teach the car how to
03:01 - race instead of following the rules
03:03 - nicely I'll host a live stream event
03:06 - where I race against your AI cars and
03:09 - there will be prizes I just haven't
03:12 - figured out what those are yet but stay
03:14 - tuned and while you're designing your
03:17 - race car I'll continue to teach how to
03:19 - code some things as well for that part
03:22 - you do need to know some math and
03:24 - JavaScript this playlist can help with
03:26 - that and we will continue the
03:28 - self-driving car project so it's good to
03:31 - be somewhat familiar with it but will
03:34 - mostly just add new functionality into
03:36 - it so if you feel confident in your
03:39 - skills take the last version from GitHub
03:41 - and try to follow along what I'll teach
03:44 - then is how to implement drra shortest
03:47 - path algorithm so the car knows how to
03:49 - reach its destination I'll also teach
03:52 - how to make the game mechanics we'll
03:54 - control the main car but the others will
03:57 - be AI I'll show you how to monitor their
03:59 - progress and make the
04:01 - scoreboard now this top view is not
04:04 - great when racing I think I'm really
04:06 - used to seeing things from the car's
04:08 - perspective so I'll teach you how to
04:10 - code the camera sensor where we render
04:12 - what the car sees this might be useful
04:15 - someday for object recognition but for
04:18 - now I just like it and what I like even
04:20 - more is this view from behind the car
04:23 - I'm going to teach you how to do that as
04:25 - well and I'm not
04:27 - done controlling the car with the
04:29 - keyboard is not ideal I'll teach you how
04:32 - to implement analog steering Twice first
04:36 - by turning this into a mobile app and
04:38 - using the device orientation sensor to
04:40 - turn I think it's better than using the
04:42 - keyboard but I have an even better one
04:46 - using the camera some basic image
04:49 - processing and these blue wristbands
04:52 - we're basically going to become Iron
04:55 - [Music]
04:57 - Man oh yeah and the sound it's
04:59 - procedurally generated from scratch all
05:02 - of this is just plain JavaScript no
05:05 - libraries like everything else on the
05:07 - channel so you can learn all inner
05:09 - workings of a complex system like this
05:12 - and all of this is AI the new camera
05:15 - sensor the path finding the fancy
05:18 - controls using the smartphone or this
05:21 - thing image processing augmented reality
05:24 - they all make the system more
05:26 - intelligent that's what I want you to
05:27 - get from this course AI is often a
05:30 - combination of things not just neural
05:32 - networks and artificial intelligence is
05:35 - not the same as machine learning many
05:38 - people confuse the too there's no
05:40 - machine learning in this
05:42 - course which reminds me someday I'll
05:45 - teach you how to add machine learning
05:47 - into the system as well but for that we
05:50 - need data so if you want to help go to
05:53 - this link and raise try to beat my time
05:56 - from there if you make an account and do
05:58 - a good job your name will appear there
06:01 - and others will see you racing next to
06:03 - them that's actually me racing I'm
06:06 - recording every move we do so I can
06:09 - replay it like that but don't worry
06:11 - about making mistakes for machine
06:13 - learning we need to teach the car what
06:15 - not to do as well so mistakes are more
06:18 - than
06:19 - welcome excited great now get ready to
06:23 - put your neurons into
06:28 - overdrive this is the playground and
06:31 - look at the car it's doing something
06:35 - it's applying the so-called right hand
06:37 - rule for solving mazes so if you're
06:40 - inside a maze put your right hand on the
06:43 - wall and you'll eventually get out of it
06:46 - most of them anyway there are some mazes
06:48 - where it doesn't work but we'll get to
06:50 - that later now just look at this the car
06:54 - is exploring it's going everywhere and
06:57 - it's actually great it's not easy to do
07:00 - this you can press this manual override
07:04 - button on the right and now the car is
07:07 - controlled by the keys on the keyboard
07:09 - and just try to use the arrow keys and
07:14 - make the car do the same things without
07:17 - crashing it's really difficult like a
07:21 - very
07:23 - tedious thing that you have to do and um
07:27 - if it happens so that that you crash
07:30 - then you can always press this other
07:32 - button here and the simulation will
07:35 - restart so for me this is quite
07:38 - challenging to get it to go even half as
07:43 - good as what this neural network can do
07:46 - so turning off this manual override you
07:49 - can see it's going much more confidently
07:52 - than me and knows how to turn just
07:56 - right now let me put back on this manual
08:00 - override and teach you about the sensors
08:03 - next so you can see these two lines
08:06 - coming out of the car these are what I
08:09 - call sensors
08:12 - and you can see what happens to
08:15 - this front sensor here when the car gets
08:20 - close to the Border it lights up it's a
08:24 - proximity sensor so it knows when
08:26 - something is is nearby and how close
08:29 - that thing
08:30 - is now the sensor also has a range so
08:34 - this tip here is as far as it's going to
08:37 - read anything and the values in that
08:41 - case are going to be zero so now this
08:44 - front sensor doesn't read anything and
08:49 - you can see these sensors as input
08:52 - values here to the network and if you
08:55 - hover the value is written there so if
08:59 - I'm going to go now up here you can see
09:02 - how that value is increasing from zero
09:07 - to one essentially or 100% but not
09:12 - exactly 100% because if I'm going to
09:16 - zoom here a little bit you'll see that
09:19 - the sensor starts in the middle of the
09:21 - car so it's not going to go all the way
09:24 - to 100% because the car is going to
09:28 - crash before that happens so let's see
09:31 - where it crashed it was at
09:34 - 93% or
09:36 - 0.93 let's restart this
09:40 - simulation and the other sensor is here
09:43 - on the
09:44 - right and it's the second input to The
09:48 - Matrix and this one might actually go to
09:52 - 93 um percent
09:56 - maybe without crashing because the car
10:00 - is not as wide as it is long but I think
10:05 - soon after this 0 93 now
10:10 - um oh
10:12 - 0.94 okay so it can go a little bit
10:16 - closer than the other one just because
10:18 - of how the car looks like let's restart
10:21 - this simulation and even without
10:24 - hovering you can see the intensity of
10:27 - these inputs like this one is is colored
10:29 - yellow this one is grayed out it
10:32 - indicates that this one is reading a
10:36 - larger
10:38 - value and see how this one is now
10:42 - lighting up as well the last input here
10:45 - is a different kind of sensor it's the
10:48 - speed of the car in phase one of the
10:50 - self-driving car course we only had
10:53 - these kind of sensors implemented via
10:57 - Ray casting but there are other things
10:59 - that the car can know like it knows its
11:02 - speed so this value here is going to
11:06 - have negative values when going
11:08 - backwards and positive values when going
11:11 - forward so it's a little bit different
11:13 - than the other two sensors it can also
11:15 - have negative values the other ones
11:17 - couldn't have those and look at the
11:20 - color coding when I'm going backwards
11:23 - that meter
11:26 - there is blue and when I going
11:30 - forward it's yellow so this color
11:35 - coding yellow for positive values and
11:38 - blue for negative values is going to
11:41 - appear everywhere so you can see here
11:45 - negative weights that are blue and this
11:47 - is a positive weight and here this
11:50 - spinning bias value here is a positive
11:53 - value this one here you know it's a
11:55 - negative value because it's blue and
11:58 - these up here are the outputs so the car
12:01 - can go forward left right and in reverse
12:07 - and it only goes like that if these
12:09 - neurons light up so these two are
12:12 - lighting up now it means that the car
12:14 - would like to go forward and to the left
12:17 - but because of this manual override is
12:21 - is on it doesn't do that I don't let it
12:24 - do that but it wants to do that so let's
12:28 - see what happens if I move the car
12:30 - forward and that right sensor here
12:34 - doesn't read anything anymore what
12:36 - happens to the outputs
12:40 - there you can see it changed a little
12:44 - bit it tries to go to the right now
12:47 - because it wants to look for that border
12:51 - for that you know that right hand rule
12:55 - there it looks for the border so it's
12:57 - going to turn right
13:00 - let's see it do that if I turn off this
13:02 - manual
13:04 - override the car continues like
13:11 - that and you can actually play with
13:14 - these values here on the right by using
13:17 - the mouse wheel so for example you could
13:21 - change the value of this weight maybe
13:23 - make it negative weight instead and you
13:27 - can see that this is a very very
13:29 - delicate system here so the car doesn't
13:32 - work now as as before anymore but you
13:36 - could do that the playground lets you
13:39 - play with these values any way you want
13:41 - like maybe let's make this bias also uh
13:47 - negative it actually did something it
13:49 - started working again but then it
13:51 - crashed so again really sensitive and
13:55 - I'm not going to explain to you what
13:58 - this network is doing right now you will
14:01 - eventually understand what everything
14:03 - here is doing and be able to implement
14:08 - this Logic for the right hand rule and
14:10 - even the more complicated logic like
14:12 - with the stop signs and traffic lights
14:14 - and things like that you'll see but we
14:17 - have to take things slow and step by
14:20 - step so go to the top of the URL here
14:24 - where it says s is equal to default and
14:27 - type S is equal
14:29 - to
14:32 - [Music]
14:34 - FWD and this here is a much simpler
14:37 - scenario from before first the car has
14:40 - only one sensor this time this
14:42 - front-facing sensor here but it works
14:45 - like before so if I turn on this manual
14:47 - override and move the car forward you
14:50 - can see that it's lighting up and it
14:54 - also shows here as the input to the
14:56 - neural network so this part is exactly
14:59 - the same as before but only one input
15:02 - and the network is really simple it's
15:06 - just one neuron here making the
15:08 - decisions and the only decision it can
15:11 - make is to go forward we can control the
15:14 - car to do more than that like we have
15:16 - access to all its capabilities here if
15:19 - I'm going to use the arrow keys but this
15:22 - neural network can't decide all that it
15:25 - only has the potential to go forward or
15:28 - not go forward and at the moment it's
15:31 - doing nothing like if I'm going to turn
15:34 - off manual override the car just stands
15:37 - still this neuron is not lighting up and
15:40 - the reason for that is how this thing
15:42 - works so this input value coming from
15:46 - the sensor here we can call this x it's
15:49 - a variable this value is multiplied by
15:54 - the weight in this case it's zero and
15:58 - then if this value x times this weight
16:01 - is greater than the bias here which is
16:05 - also zero then this neuron lights
16:09 - up but it can't be greater than the bias
16:14 - because this is zero here so any value
16:18 - for x multiplied by 0 it's going to be
16:21 - zero and 0 is not greater than zero so
16:25 - with this neural network here it can
16:28 - never light up no matter what the input
16:32 - says we could make it light up by
16:35 - lowering the bias here for example let's
16:38 - make it minus
16:43 - 0.10 it crashed there but basically any
16:47 - value here that is negative is going to
16:50 - work and zero or any positive value for
16:53 - the bias is not going to turn this
16:56 - network on ever because the result of x
17:00 - * W here is always zero because W is
17:04 - zero so let's just leave this bias to
17:08 - something like minus
17:10 - 0.2 and restart the
17:13 - simulation and see the car going forward
17:16 - like that it never stops now okay
17:20 - because again no matter what the value
17:23 - for x here it's never going to be
17:26 - anything else than zero in one
17:28 - multiplied by zero so this also needs to
17:32 - be something for it to work and let's
17:36 - turn on manual override and restart and
17:41 - go somewhere up here with the car for
17:44 - example this location and let's try to
17:47 - modify this weight so that this neuron
17:50 - turns off because we want the car to
17:52 - stop going forward when it sees
17:55 - something so that it doesn't crash you
17:57 - can try playing with this weight and
18:00 - having large values like this and you'll
18:03 - see that nothing happens this output
18:05 - neuron still says go forward but if you
18:08 - go lower values negative values minus
18:12 - 0.2 0.3 4 5 6 minus 0.6 in this case
18:20 - then this neuron turned off and if I'm
18:23 - going to move the car a little bit here
18:26 - you can see that there is this kind of
18:28 - Sweet Spot there where this neuron turns
18:33 - on and
18:34 - off let's restart this simulation and
18:38 - turn off the manual
18:41 - override
18:43 - and the car still hits that
18:46 - place so we need a different value for w
18:51 - let's put back manual override restart
18:55 - and let's try to get maybe somewhere
18:58 - here here so that when we are further
19:00 - away it turns off so I'm going to modify
19:04 - now this weight and go lower looks like
19:08 - minus
19:09 - 0.8 is a value but we can go actually
19:13 - even lower than this so maybe -
19:17 - 0.9 minus one and let's see what the
19:20 - result is here you can see now this
19:23 - sweet spot is much lower here let's try
19:27 - to see what happens now so restart this
19:31 - simulation and turn off the manual
19:35 - override and it stopped it didn't crash
19:38 - anymore it stopped exactly at this
19:41 - dotted line here nice so let's turn back
19:45 - on the manual override restart and see
19:49 - where is the spot where it
19:56 - changes so here this is the moment where
20:00 - it changes from on to off and if you
20:04 - look at the input value this 0 19 and
20:08 - play a little bit with the car at that
20:10 - point you will see that it changes at 20
20:15 - basically this 20 is the same value as
20:20 - here but minus 20 in this
20:23 - case and it's clear why that is if you
20:26 - look at this weight value because it's
20:28 - just -1 so whatever X is multiplied by
20:34 - -1 means - x has to be greater
20:40 - than-
20:41 - 0.2
20:43 - or X less than 0.2 because the sign
20:49 - switches if you multiply by a negative
20:52 - value so that's why these values are
20:56 - matching right now because this weight
20:58 - weight is one minus one but basically it
21:01 - doesn't have any scaling effect other
21:04 - than flipping the sign so having weights
21:07 - of one or minus one are making the math
21:11 - easier in a way but basically what this
21:14 - means is that if x is going to be less
21:18 - than 20% Then This neuron stays on
21:23 - otherwise the neuron stays off now there
21:27 - is a way to visualize things so that we
21:29 - don't have to do this kind of mental
21:31 - math all the time I'll show you you just
21:34 - go here in the title and say s is equal
21:37 - to
21:38 - FWD uncore
21:43 - D and it's the same thing as before if
21:46 - you will turn off the manual override
21:48 - you will see that the car is going to
21:50 - stop at this dotted line but now this
21:54 - thing appears here at the bottom this
21:56 - axis here is the same thing that we are
22:00 - visualizing here and here so 0.79 or
22:06 - this
22:07 - 79% it means 79% of this Arrow that's
22:11 - where this yellow dot is present so this
22:16 - arrow is for the input value changing
22:20 - back to manual override you can see that
22:23 - I'm moving this point up and down
22:26 - because that's how the relation ship
22:29 - with the sensor is changing this point
22:33 - will always be in the positive side of
22:36 - this axis because if we go far away like
22:39 - this the smallest value that the sensor
22:42 - can read is zero so it aligns like that
22:45 - and there is also this other line here
22:48 - and this lighter region this is
22:51 - controlled by the weight and the bias
22:54 - the bias if you're going to lower it
22:56 - make it even smaller it's going to to
22:58 - move that region up and increasing it is
23:03 - going to move that region down now we
23:08 - had it at minus 0.2 let's keep this
23:11 - value and let's see what happens when we
23:14 - modify the weight increasing
23:17 - it does
23:19 - this and decreasing it does that it
23:23 - changes the slope of that line so this
23:26 - describes a line and the lighter region
23:30 - that I have here I made it so that when
23:33 - this yellow dot is inside of this
23:37 - lighter region it means that this neuron
23:41 - turns on so now if I'm going to move the
23:44 - car up a bit you can see that that place
23:48 - where the lighter region
23:51 - intersects the axis is the same spot
23:55 - where the neuron turns on and off
23:59 - so you can tell where that point is just
24:03 - visually this is 20% of the whole
24:07 - distance here without doing any mental
24:09 - calculations and this network that we
24:12 - have here that solves our problem is not
24:15 - the only one that solves our problem let
24:17 - me show you you can put here a value of
24:20 - minus
24:22 - 01 and then this value let's change it
24:25 - to
24:27 - minus
24:29 - 0.5 and you can see that this point
24:32 - lines up again the difference now is
24:35 - that this slope right here decreases at
24:39 - a slower rate at half the rate that the
24:43 - value on X is and this network works
24:46 - exactly as before so if I restart this
24:50 - and remove the manual override you can
24:53 - see that the car is stopping exactly at
24:56 - the same spot so there are two Sol
24:58 - solutions for the
25:00 - problem now homework task for you think
25:03 - about it how many solutions are there
25:05 - really let me know in the comments let's
25:08 - do the math as well to confirm that this
25:10 - point here is at 20% so x * - 0.5 has to
25:16 - be equal to -
25:19 - 0.1 so dividing by - 0.5 means that X is
25:24 - equal to 1 / 5 basically and that is 20%
25:30 - and you could write this in code you
25:33 - could make a simple if statement and say
25:36 - if
25:37 - -0.5 x if the variable X is the input is
25:42 - greater than minus
25:45 - 0.1 then accelerate otherwise do nothing
25:50 - so that piece of code is the same thing
25:53 - as what this neural network is doing
25:56 - it's important to understand that the
25:57 - neural netor works are capable of doing
26:00 - these kind of if statements now there's
26:02 - one more thing I want to show you here
26:04 - if you click on this diagram is going to
26:08 - show you a simplified view where it only
26:12 - uses one dimension so these two
26:15 - Dimensions here are important if you
26:17 - want to display this slope as well so
26:22 - the simplified mode loses some
26:25 - information we don't know what that
26:27 - slope is
26:28 - but for understanding what happens here
26:32 - and seeing that the neuron is on when
26:36 - the sensor is Reading in this section
26:39 - here this is enough and reducing from
26:43 - two Dimensions to one dimension like
26:46 - this will mean that in the future we'll
26:48 - be able to show higher Dimensions easier
26:52 - so losing some information but it will
26:55 - let us do some nice visualiz ations
26:58 - later on play around with these values
27:01 - again and see how the visualization
27:04 - changes there maybe we use the minus 0.2
27:09 - value and the minus one weight the one
27:12 - with the simple math for previously and
27:15 - you see it still looks the same as
27:18 - before but the slope now decreases much
27:22 - faster at the same rate as X and what I
27:25 - mean by that is if I'm going to go here
27:28 - and put this bias to zero whatever the
27:31 - value is here it's going to be the same
27:37 - here so this is essentially a square now
27:40 - if this weight is going to decrease by
27:43 - 05 for example then this rectangle here
27:48 - is not a square anymore it actually fits
27:50 - two squares because the rate this
27:53 - decreases is half of this x now believe
27:58 - it or not I'm not done talking about
28:01 - just one output there next time we'll
28:04 - still have only one output there and
28:06 - there's a lot to talk about it but uh I
28:09 - want to leave you with something more
28:11 - fun to do so go here at the top and say
28:14 - s is equal to BC
28:18 - K and now you can practice having two
28:22 - outputs going forward and backward and
28:26 - see what you can do with that let let me
28:28 - just show you something real quick so
28:31 - here this is the same as before you can
28:37 - control this lighter grayish region but
28:41 - the other is going to control
28:45 - this green region here so if I'm going
28:49 - to increase this bias so that it goes
28:52 - like that and decrease this one now the
28:56 - car is going to go back backwards in the
28:59 - beginning your homework is going to be
29:01 - to make it go forward and then bounce
29:05 - back like
29:08 - that people teach neural networks in
29:11 - different ways and that can make things
29:14 - confusing I'm going to try to clarify
29:16 - some things now you don't really have to
29:18 - listen to this part it won't matter in
29:20 - the rest of the lessons but it might
29:23 - help you
29:24 - someday now some people say that for the
29:26 - neuron to light up x times the weight
29:29 - must be greater or equal to the bias not
29:32 - really a big change but that neuron
29:34 - would light up now with everything set
29:36 - to zero and in ours it doesn't but you
29:39 - can always make a small change to the
29:41 - bias and it's going to work pretty much
29:43 - the same there's no real reason to
29:45 - choose one over the other so you will
29:47 - find both implementations out there just
29:50 - don't be confused another thing people
29:52 - do is move the bias here on the left
29:56 - same thing so far but they also changed
29:58 - the minus to a plus this doesn't seem
30:02 - right I mean it's not the same thing
30:04 - anymore but again it doesn't really
30:07 - matter any network you find that works
30:10 - in the first case can be transformed
30:12 - into one that works in the second case
30:14 - just flip the value of the bias the
30:17 - reason you find this implementation is
30:19 - because it looks like the line equation
30:21 - something people are familiar with I
30:24 - like to use the neuron fires when
30:26 - stimulated above a threshold idea so
30:30 - it's just personal
30:31 - preference another thing you may find is
30:34 - people removing the bias entirely but
30:37 - that would break things we saw earlier
30:39 - that we really need a bias so for it to
30:42 - still work they add here an extra weight
30:45 - connected to a fake node that is always
30:48 - on so this weight here acts exactly like
30:51 - the bias and everything is all right I
30:55 - think people like this because it groups
30:57 - together all parameters in one thing so
31:00 - to speak now this here is called an
31:03 - activation function and this one in
31:05 - particular is a step function there are
31:08 - others that are more powerful like a
31:10 - sigmoid here would produce values
31:12 - between zero and one so the car could be
31:15 - more like in the real world and
31:17 - accelerate more or less depending on the
31:20 - situation I don't want to teach smooth
31:22 - activation functions because our
31:25 - controls here are binary and it would
31:27 - make things more
31:29 - complicated our car will still be able
31:31 - to control the speed by pressing the
31:33 - acceleration at different rates so we
31:36 - don't really need those but they are
31:39 - important when doing machine learning a
31:41 - gradient like that helps optimize the
31:43 - networks that's why you'll find them
31:46 - everywhere like in this other playground
31:48 - I found while building mine it's really
31:51 - great a bit more abstract but a really
31:54 - useful learning tool so check that one
31:56 - out as well
32:00 - we learned what one neuron can do with
32:02 - one input next we'll see when one input
32:06 - is not enough we'll try using two inputs
32:09 - and even a hidden
32:11 - layer prepare for some neurons in the
32:16 - shadows open the playground from the
32:18 - link in the description it should have
32:21 - here
32:23 - fwdg is the session name now let's have
32:27 - the same Network as before so-
32:30 - 0.5 for the weight and-
32:35 - 0.1 for the bias and the car is going to
32:38 - stop right here at this dotted line
32:43 - let's change the objective so that it
32:45 - goes up as much as possible so can we
32:48 - figure out a network that lets the car
32:50 - go as much as it can before hitting the
32:53 - Border there and we could try playing
32:56 - with this basically Ally It's kind of
32:59 - logical that this needs to be a little
33:01 - bit to the right so maybe moving the
33:05 - bias like
33:07 - this this might be too much let's let's
33:10 - try
33:12 - it too much we probably need to change
33:16 - also this maybe something like that I
33:19 - don't
33:22 - know still too much this is tedious we
33:26 - can also do something else to figure it
33:28 - out we can use the genetic algorithm
33:31 - from phase one it's right here let me
33:35 - show you when it optimizes here it's
33:39 - going to try to create many different
33:42 - cars
33:43 - simultaneously and each of them have a
33:45 - different
33:46 - network how different from the one we
33:50 - started with is controlled by this
33:52 - slider here so if I'm going to go down
33:56 - all the way and press this button again
34:00 - you will see apparently just one car
34:03 - going up but it's actually 100 or
34:06 - whatever going up and this network is
34:09 - the same that we were playing with
34:11 - before here in this simulation when the
34:15 - car touches the Border it disappears
34:17 - entirely because there are many of them
34:19 - and I don't want it to be too crowded so
34:23 - let's try to give a little bit of a
34:25 - mutation here and that means that the
34:28 - network is going to be similar to the
34:30 - one before but not exactly the same so
34:34 - now you can see that we found a car that
34:36 - is pretty much touching the Border but
34:39 - it didn't disappear it's still here so
34:41 - it's a good car and when we find a good
34:44 - car like this we press this save button
34:48 - and now we have this new car to work
34:52 - with like if we close this Optimizer
34:55 - from here you can see it going up and
34:58 - then stopping exactly there pretty much
35:02 - let's see close is it really very close
35:05 - or could it go even
35:07 - higher it might go even higher a little
35:11 - bit let's try optimizing
35:19 - again let's save and try again every
35:23 - time we run this optimization the
35:26 - previous best car is not lost so if it
35:30 - looks good saving in the worst case it's
35:34 - just going to give us the same thing we
35:36 - have previously we don't lose anything
35:39 - valuable like this so let's save again
35:44 - and the last
35:46 - time I just want to be sure that I'm
35:50 - getting a as good value as I can get
35:53 - there
35:56 - safe
36:01 - I think it looks kind of like as before
36:04 - so maybe it was good the first time
36:07 - already and these values minus
36:11 - 0.56 and-
36:15 - 0.14 let's figure out what this value is
36:18 - here turning on the calculator and
36:23 - 0.14 divided by
36:26 - 0.56
36:28 - [Music]
36:30 - 0.25 so that seems to be the point here
36:36 - 0.25 but this weight and bias are quite
36:41 - complicated we already start to have now
36:44 - the second decimal there and these are
36:47 - some things that we can expect from
36:49 - neural networks they don't give us the
36:53 - easiest way to write
36:56 - 0.25
36:58 - there there are several easier ones that
37:01 - I can think of right off the bat for
37:03 - example here I could
37:06 - put minus
37:09 - 0.1 now if you press the zero key on
37:12 - your keyboard it's going to zero that
37:16 - and lower like this minus 0.1 and this
37:21 - could be minus 0.4 so zero
37:26 - that minus
37:29 - 0.4 so this should be the same thing as
37:33 - before let's try to
37:37 - restart and it is but it's a simpler one
37:41 - because 1 iD 4 is
37:43 - 25% so easier for us to understand the
37:47 - values but the end result is the same
37:50 - there are other values here that are
37:52 - easy to understand like Min -1 and-
38:01 - 25 for these small values when scrolling
38:06 - hold down the shift key this is going to
38:09 - make you scroll more precisely like
38:13 - that so
38:17 - refresh and this one works as well there
38:20 - are many solutions here the one found by
38:23 - the genetic algorithm is just one of
38:26 - them and and these for me at least are
38:29 - easier to understand when I look at the
38:31 - numbers what is really going on here now
38:34 - it's important to stop and think what is
38:37 - the car really learning here what is
38:40 - this function
38:43 - for and one thing that can help with
38:46 - that is changing here the title
38:49 - FWD
38:52 - Corb and we get the same thing but now
38:55 - the car is a bus
38:57 - and you can see it doesn't
39:00 - work the reason why it doesn't work is
39:03 - that the bus is longer so the distance
39:06 - here from the center of the sensor to
39:09 - the tip of the bus is longer than we had
39:12 - before
39:16 - so it is going to touch we could run the
39:20 - same Optimizer again and find the
39:23 - solution that works for the bus so
39:26 - that's no problem but but the same brain
39:28 - that we had previously doesn't work also
39:31 - for the bus and for the previous car
39:34 - that we had let's save this one and now
39:37 - close and let's see the bus going
39:40 - smoothly and it stopped perfectly there
39:43 - but if we go back
39:45 - now we can see that the car is
39:49 - stopping not anymore in the last moment
39:52 - where it could stop there because it's
39:54 - using the brain that we made for the bus
39:58 - so this is important how big the car is
40:02 - and in some cases real life cases people
40:06 - are making the same kind of cars
40:09 - equipped with the same kind of brains
40:10 - and then they have different brains for
40:12 - other cars that are different just
40:14 - because the car has a different size uh
40:17 - to it if you want to have one brain that
40:22 - does everything then the size of the car
40:25 - has to be an input here here an
40:28 - additional input we won't be doing
40:30 - anything like that here it's not very
40:32 - complicated but I don't want to teach
40:35 - you about the buses here I just want to
40:37 - focus on the cars but basically we need
40:40 - to be able to understand that a longer
40:43 - car needs to stop accelerating earlier
40:47 - than a shorter one now let's go back to
40:50 - these values here
40:52 - minus1 and minus
40:56 - 0.25 five like
40:59 - this restart just to see that it
41:03 - works and another thing that doesn't
41:07 - work is if you write here FWD uncore
41:18 - 2 so we have the same car from
41:21 - previously and it goes just as expected
41:25 - but there's another car on the left and
41:27 - both of them have the same
41:29 - brain
41:32 - so interestingly the car on the left
41:35 - does
41:37 - nothing stop and try to figure out why
41:41 - maybe pause the video and think about it
41:44 - I'm going to start talking again in five
41:48 - 4 3 2
41:53 - one so there are two dots here on the
41:57 - right right one is
41:59 - for the car on the right the one that is
42:03 - moving and the other one is outside of
42:05 - this region to begin
42:10 - with so this car is so close that it's
42:14 - already inside of that black region
42:18 - where the neuron doesn't fire so it's
42:23 - never going to start if the car is too
42:25 - close there it's going to start and you
42:28 - can really tell that something else is
42:30 - needed here I mean what happens if we do
42:34 - make this car move just like this for
42:37 - example we can lower this bias more like
42:42 - that it's moving
42:44 - right but if we restart the simulation
42:47 - that means that this other car on the
42:49 - right is going to crash because it's
42:51 - going to stop accelerating much later so
42:55 - we can't have them both not with one
42:57 - input here let's see what happens if we
43:01 - introduce the speed as well so here at
43:04 - the top s is equal to
43:07 - SPD underscore
43:11 - 2 and now we have some extra things here
43:14 - we're going to get to them in a little
43:16 - bit but first let's just put some values
43:18 - for these weights and biases let's put
43:21 - minus 4 here minus
43:26 - 0.4
43:28 - and minus
43:30 - 0.4 here as
43:33 - well and here minus
43:39 - 0.3 and let's
43:44 - refresh and something happens and
43:46 - arguably it's better than before it's
43:49 - not perfect this car is not going all
43:51 - the way till the end this one is also
43:54 - not going till the end it's it's worse
43:56 - than the one on the right but both of
43:59 - them move this time so it looks like
44:03 - something now before we get into what is
44:06 - happening here I want to show you a nice
44:09 - tool this uh Desmos calculator has a 3D
44:14 - version now so desmos.com
44:18 - sl3d here and let's write the
44:22 - same function we had previously so m -
44:29 - 0.4
44:31 - x -
44:34 - 0.4 y has to be greater
44:38 - than
44:41 - -0.3 and you can see a flat surface here
44:45 - this red region in the XY plane now just
44:48 - a little bit of exploring here this is
44:51 - the same thing as if you write Min -04 x
44:55 - -04 y +
44:58 - 0.3 greater than 0 right so let's write
45:03 - that plus
45:06 - 0.3 greater than zero it's exactly the
45:10 - same thing we just moved that one
45:12 - term now if we remove the greater than
45:16 - zero we move out of the XY plane and
45:20 - we're in 3D now we are defining a plane
45:25 - this now what we have here is not
45:29 - defining a line anymore it's defining a
45:33 - plane and only when we do that kind of
45:36 - comparison like equal to zero means the
45:41 - line where that intersect the XY plane
45:44 - there or greater than zero means all the
45:50 - parts of this plane that are above water
45:55 - so to speak so positive values now this
45:59 - 0.3 here is called the Z intercept it's
46:04 - actually this point right here where the
46:07 - plane is touching this
46:11 - z-axis because if X and Y are zero here
46:15 - then you get just that so that's why
46:18 - it's called the Z intercept and this
46:21 - here controls the rate of decrease in
46:24 - this case on the X and this one on the
46:27 - rate of decrease on the Y so this plane
46:31 - is tilted in the same way on X as it is
46:35 - on y but if you would have here minus
46:39 - 0.8 y for example is going to be tilted
46:43 - on X less than it is tilted on y it's
46:47 - much more tilted this
46:49 - way than this
46:53 - way but let's go back to our original
46:57 - one so-
46:59 - 0.4 Y and let's go here and have this XY
47:06 - orientation and zoom in a little bit
47:08 - because we are only interested in values
47:11 - between minus one and one now this is
47:15 - not centered really well you can go to
47:17 - these settings here and say Center
47:22 - origin we can also make these surfaces
47:26 - translucent
47:27 - like that so we can see through it let's
47:30 - zoom out a bit so that this one appears
47:33 - here and minus one is here so this what
47:37 - you see here is the same that what I am
47:41 - plotting here I'm just using a little
47:44 - bit of shading here so kind of like the
47:47 - plane going under the water there you
47:50 - can see it like that and there is a
47:53 - slider here at the bottom that actually
47:57 - controls how pixelated this image is it
48:02 - takes effort processing power to
48:05 - calculate this image right here so I
48:09 - don't really recommend getting this
48:12 - smooth version from the left side
48:15 - sticking to something like this and
48:17 - above if your computer starts to burn up
48:21 - but um basically This Plane where this
48:26 - plane is above the water that's when
48:29 - this is going to trigger now so if these
48:33 - dots appear to be on land then that is
48:37 - going to trigger for them and this mode
48:40 - also has a simplified view because this
48:43 - is showing a 3D space here right but we
48:47 - don't really care about what is going
48:50 - underwater so if you click on this once
48:53 - it's a simplified view showing just the
48:56 - part of the plane that is above water or
49:00 - you can consider it like
49:04 - that so back to the 2D space coming
49:09 - after we have an inequality sign there
49:13 - so let's rerun now this simulation and
49:17 - see what is happening
49:23 - here it's very interesting right
49:32 - you should take a moment and try running
49:35 - this many times and paying close
49:37 - attention to what is really going on
49:43 - there so this car on the left that is
49:46 - stopping
49:48 - early it's this
49:52 - point it's moving on the edge of this
49:56 - plane here and then somehow going down
49:59 - and stopping early the other one the car
50:02 - on the
50:03 - right goes higher here and somehow
50:07 - slingshots away from this plane like it
50:10 - it jumps from there kind of and it falls
50:13 - down later interesting isn't it now if
50:17 - you look at the top here I can only show
50:20 - one of the two brains they are the same
50:23 - brain so the same value for uh this
50:26 - weight the same value for that weight
50:27 - and for the bias but the inputs for them
50:31 - differ because now this one is closer so
50:34 - it has a larger value for for this
50:37 - 0.86 this is 0.86 here this is going to
50:42 - be smaller right so the brain that you
50:44 - see on the right here is going to be
50:47 - from this car here and if you turn on
50:51 - manual
50:53 - override you can see that brain
50:57 - changing while I'm moving that car and
51:00 - look at what the point is doing under
51:02 - the right so I'm moving the car forward
51:06 - and backwards and forward and backwards
51:09 - and because I'm changing the speed like
51:12 - that it kind of looks like it's drawing
51:15 - a circle because it moves the point up
51:19 - and down also below the zero point
51:23 - vertically because the speed can be
51:25 - negative in this
51:27 - case but uh combined with the sensor
51:33 - there is also moving it from the left to
51:38 - right so somehow it's drawing a
51:41 - circular um pattern there of course if
51:45 - you would do this somewhere below here
51:47 - where this doesn't read anything then
51:51 - that point just moves up and down like
51:53 - that because there is nothing moving it
51:55 - left to right the sensor isn't picking
51:57 - up
51:59 - anything and of course if I'm stopped
52:02 - then the point is just going to lie on
52:05 - the horizontal axis like that so really
52:08 - there is a lot going on here and I
52:12 - recommend you play with this it's um
52:15 - it's really fun but let's try to
52:19 - optimize this so that the cars go as
52:22 - much as possible and let's use the
52:25 - optimizer from here so hopefully we're
52:29 - going to get cars that are going to be
52:32 - as close as possible to the Border there
52:36 - and now we are getting something better
52:38 - actually so let's save this and let's
52:40 - try
52:45 - again now one thing when doing this
52:48 - simulation the cars there are two sets
52:52 - of them right on the left and on the
52:54 - right they have the same
52:57 - brains what I mean here is that the cars
53:01 - here are all a little bit different
53:03 - mutated slightly but exactly the same
53:07 - brains from this set are copied in this
53:11 - set and the car showing in red here is
53:14 - the best
53:15 - one of both sets so you might see here a
53:21 - car that is a little bit better still in
53:23 - front of this one and it didn't yet
53:25 - touch but its counterpart from here it's
53:29 - maybe below somehow so the added
53:32 - distance that they
53:33 - traveled is less let's save and try one
53:37 - more
53:38 - time let's see if we can get it really
53:40 - really close
53:48 - there it's still doing something so wait
53:51 - for it to stop before saving anything
53:54 - otherwise it might collap
53:57 - eventually let's save this and I think
54:01 - I'm happy with this it looks really good
54:03 - now let's close this and see just two
54:08 - individual
54:10 - cars
54:14 - and it's nice they are stopping there
54:18 - and they are doing some kind of crazy
54:20 - things here but if you're like
54:24 - me something bugs you at this point the
54:28 - car on the right actually seems to
54:32 - arrive faster than the car on the left
54:36 - which doesn't make sense I mean look at
54:40 - this it's overtaking it about now and
54:46 - stopping it let me show you that again
54:49 - so it's overtaking it
54:52 - now and stopping there and if you look
54:56 - here in the
54:58 - diagram this one is slowly making its
55:01 - way there and you can kind of see the
55:04 - overtaking moment from this slingshot
55:08 - guy that
55:09 - just lands there where it should be
55:13 - ending so the fitness function described
55:17 - inside of this optimization is go as far
55:21 - as possible but it doesn't say anything
55:25 - about the
55:26 - speed like it doesn't matter if they are
55:30 - going there as fast as possible or not
55:33 - and integrating both of those in a
55:36 - fitness function is not easy because
55:38 - it's a kind of a two parameter
55:40 - optimization function so we are just
55:44 - going to not use the optimizer anymore
55:47 - but I do want to show you still this
55:51 - like if we decrease this value even more
55:56 - the rate of decrease on the speed here
56:00 - it's going to move that plane kind of
56:03 - like that even more so
56:08 - here this
56:10 - apparent slope is going to go down like
56:14 - that and refreshing now is going to make
56:19 - the cars start to do that even earlier
56:22 - and now they have this really really
56:25 - slow
56:27 - movement at the end here you can go even
56:30 - further than that like this and now you
56:34 - see very soon they start doing that and
56:38 - they start to really really crawl there
56:41 - in a in a funny way of course increasing
56:45 - this too much like this is a big problem
56:49 - because this is going to make them
56:52 - slingshot like that really much uh it
56:56 - makes them slingshot because they
56:59 - accumulate speed and then the friction
57:01 - is not enough to slow them down on time
57:05 - so there are very many things here to
57:09 - consider when doing this
57:11 - optimization like how the slope should
57:13 - be here exactly but the really important
57:17 - thing is this point right here where the
57:20 - car must stop let's refresh
57:25 - now
57:29 - and we see that we got something good so
57:33 - this point here is really important it
57:35 - needs to be outside of this lighter
57:39 - region so it shouldn't be on land
57:41 - because if it is then it's going to
57:43 - accelerate more and that means that it's
57:45 - going to get so close that it collides
57:48 - but now let's focus on the car on the
57:51 - right let's refresh and it's this one
57:55 - it's sling
57:57 - shotting we kind of want it to slingshot
58:00 - more right so that it lands perfectly in
58:04 - that one spot could we do
58:13 - that so I need this to be a little bit
58:18 - higher
58:20 - there I think that's too much so I'm
58:23 - going to hold shift and maybe say minus
58:33 - 35% ah too much so let's
58:39 - try minus 38% on this
58:48 - one it's now doing that thing it's
58:51 - fixing it getting close so it should be
58:54 - a little bit
58:58 - higher minus
59:00 - 0.37
59:02 - maybe let's
59:09 - refresh still doing
59:13 - that
59:19 - 36 and now it crashes there so it's not
59:23 - easy to figure out the exact values we
59:25 - would need even more decimals there or
59:28 - we could play with this value as
59:31 - well increasing this is going to lower
59:34 - this a little
59:42 - more okay now it stops nicely without it
59:47 - triggering anymore it could still go a
59:50 - little bit higher so maybe this one we
59:55 - try to increase a little
60:02 - bit okay this is perfect for me but
60:05 - let's now focus on this other car what
60:07 - is happening with that
60:11 - so you can see it doesn't go as
60:18 - far and it even moves a little bit after
60:21 - that one has stopped so it's not as good
60:24 - let's see what happens here
60:27 - here it's sliding down like that right
60:32 - and you can see it's stopping before the
60:34 - other car um closer to this zero here so
60:39 - that means that the sensor is reading a
60:42 - smaller value here so it's further away
60:44 - from the border we could get closer to
60:47 - the Border if we move this a little bit
60:52 - like that so we could go here and make
60:56 - it higher but hold down shift so let's
61:00 - make 29 and you could see it moved a
61:04 - little bit
61:05 - forward let's try
61:08 - 28 and the one on the right is also
61:10 - moving now and it's too much it actually
61:13 - collides to the wall so let's just stick
61:16 - to minus
61:19 - 0.29 and rerun this
61:24 - simulation and this one got closer but
61:28 - it's still not exactly there and it's
61:32 - doing that thing where it's sliding down
61:35 - the hill instead of jumping somehow
61:39 - slingshotting like that so that it lands
61:43 - perfectly there let me run this with a
61:46 - higher quality here just to show you
61:50 - better what is going
61:53 - on because that pixelation is
61:56 - interfering a little bit basically we
61:59 - would like there to still be some land
62:04 - here so that this car can accelerate a
62:08 - little bit more and then slingshot
62:11 - exactly there but there is a problem
62:13 - with that you say this other car needs
62:18 - this point here to be the
62:21 - border so if that car needs that point
62:25 - to be the Border
62:26 - and the one on the left needs a point
62:29 - there and this point here needs to be
62:32 - outside of that region it's not possible
62:35 - to do this with one single line is
62:38 - it and that's where hidden layers come
62:41 - in a hidden layer is a row like this
62:44 - where we can add more neurons they're
62:47 - called hidden neurons or hidden nodes if
62:49 - you prefer the graph terminology because
62:52 - their computations are not usually seen
62:54 - from outside the blackbox
62:56 - now here we do see everything but I
62:59 - still use the word hidden when I mean
63:02 - not an input or output
63:05 - node more terminology this is also
63:09 - called a perceptron when we add hidden
63:11 - layers it becomes a multi-layer
63:14 - perceptron it's important to know this
63:16 - because some libraries use it like when
63:19 - we use neural networks in the machine
63:21 - learning course we used the MLP
63:23 - classifier inside the psychic learn
63:25 - library in Python so good to know that
63:28 - means a neural
63:31 - network go up here and put underscore H
63:37 - instead of
63:43 - two now go here and make sure that this
63:47 - pixelation is on because we're going to
63:50 - change some things here and it's going
63:51 - to be slow otherwise and let's do
63:55 - something click first on this point and
63:59 - now you can actually create a new Point
64:03 - here and this
64:05 - one here connect to the same one so we
64:08 - created a new neuron here with these
64:11 - inputs and let's add the same values
64:15 - here so minus
64:17 - 0.29 I'm just going to go to minus 30
64:20 - and then hold shift and go up one and
64:25 - here
64:29 - 0.35 and 1 2 3 4 five like this and the
64:34 - bias here minus
64:40 - 0.26 like so this neuron is the same as
64:44 - this one here you're going to see if we
64:46 - rerun this simulation that both of them
64:49 - are going to Blink exactly in the same
64:52 - way now we can actually remove these
64:56 - links by right clicking on them and this
65:00 - one and let's move this one under right
65:04 - click on it and connect it to the output
65:07 - now reset the bias here to zero you can
65:10 - press zero on your
65:12 - keyboard and you can put any positive
65:15 - weight here anything will work because
65:19 - basically the value of this neuron here
65:23 - when it's on of value of one multiplied
65:27 - by any positive weight is going to be
65:30 - greater than zero so these now are in
65:35 - sync I'll show you we go here and
65:38 - refresh and this is the same thing as
65:42 - before you can see the same shape
65:44 - appearing here in this
65:46 - diagram now this solution here with
65:50 - these neurons Works nice for the car on
65:53 - the right but not for the one on the
65:55 - left that's the one that we try to fix
65:59 - so let's create a copy of this and try
66:02 - to modify it so that it works well for
66:06 - the car on the left I'm just going to
66:09 - click on this and create a new neuron
66:13 - here and same values so minus
66:21 - 0.29 minus
66:24 - 0.35
66:29 - and minus
66:34 - 0.26 so now if I'm going to connect this
66:37 - one up here and let's set this weight to
66:41 - zero and this one to 0.1 or anything
66:45 - positive we get the same thing here so
66:48 - just to
66:49 - test this should work in the same way
66:52 - the car on the right is stopping
66:54 - perfectly the one on the left still has
66:56 - a little bit of work to
67:00 - do let's get this slope to go a little
67:03 - bit like that so we're going to increase
67:05 - this value here slightly so holding
67:09 - shift
67:11 - and basically I want to get this other
67:14 - car here to slingshot I don't care if
67:17 - this one breaks anymore I just want this
67:19 - one to
67:24 - work
67:26 - and it doesn't really work it does
67:29 - slingshot a little
67:32 - bit a little bit maybe until here but it
67:35 - needs to be a little
67:40 - higher maybe
67:47 - 26 it's
67:49 - better but still a little bit
67:53 - more 24
68:00 - even
68:06 - more okay so now it
68:10 - looks perfect it stops perfect but the
68:14 - other one
68:15 - breaks so let's compare now the two
68:17 - functions and I'm going to put back this
68:21 - high quality diagram here and let me
68:25 - turn off this
68:29 - one and on the other one let's rerun the
68:34 - simulation and see where the car on the
68:38 - right jumps it's this point right
68:42 - here and now with the other
68:49 - one let's see where the other one
68:53 - jumps it's this point right
68:57 - here now turn on this pixelation more
69:01 - because it's really quite slow and let's
69:05 - create another
69:10 - neon where we try to define a line that
69:14 - touches both of those
69:17 - points let's set this one to
69:21 - zero this one to some positive value and
69:26 - here let's try with this left one first
69:31 - maybe minus 40 the one on the
69:35 - right
69:39 - minus
69:42 - 90 and the bias here let's
69:47 - say
69:49 - 60 and now I'm going to teach you how to
69:51 - do the conditional and so we want this
69:56 - one and this one to be on because then
69:59 - this region will
70:01 - essentially intersect with this region
70:05 - giving us a curve here not a straight
70:08 - line so to do that we put both of these
70:12 - values like this and you can already see
70:15 - a curve appearing here but we don't want
70:18 - it like that we want it at the
70:20 - intersection somehow so now this is
70:24 - actually an
70:27 - or because it's either this
70:31 - one or this one so we also learned how
70:35 - to do the conditional
70:37 - or but to do the end we are going to
70:40 - increase the bias
70:43 - here like that so the value here if it's
70:48 - on then it's going to be multiplied by
70:51 - 0.1 so we have 0.1 from here and and if
70:56 - this is on 0.1 from here so adding these
71:01 - is going to be 0.2 which is greater than
71:05 - 0.1 but if only one of these is on like
71:09 - now then this doesn't turn on because it
71:11 - needs both of them to
71:14 - activate so let's just try to see how
71:17 - this one works probably we need to do
71:19 - some fine
71:20 - tuning yeah looks like this car is
71:23 - crashing because this is too high we
71:26 - need to lower it down a bit so
71:32 - minus 92
71:45 - maybe if you look closely what happens
71:49 - here it touches that tip a little bit
71:53 - you can see here after it sto oops it
71:56 - blinks a little bit so I think that we
71:58 - need to also adjust that one slightly so
72:01 - here where it says minus
72:04 - 0.40 let's make
72:07 - it maybe minus
72:17 - 0.43
72:23 - okay I think this is perfect
72:26 - and we don't need this one anymore
72:29 - because this is anyway connected to zero
72:31 - here it was just used as a as a
72:33 - reference so let's remove it by right
72:36 - clicking on this node then it's going to
72:38 - remove all the other links as
72:43 - well now your
72:45 - homework go up here and say SPD uncore
72:52 - 3 try to get it to work for or three
72:56 - cars this one seems to be crashing at
72:59 - the
73:02 - moment one quick note here I've found
73:05 - many resources claiming you need smooth
73:07 - activation functions to have curves here
73:10 - one of them in a lecture by top
73:12 - university now what I'm sure they meant
73:15 - was a smooth curve because we got a
73:17 - curve here already using a step function
73:20 - a curve just means something deviating
73:23 - from a straight path doesn't NE
73:25 - necessarily have to be
73:27 - smooth it may sound like a small thing
73:30 - but I think that false information like
73:32 - that is confusing especially because it
73:36 - seems like it should be true so people
73:39 - pass it around a lot and it makes
73:42 - understanding things harder I
73:44 - think the playground doesn't support
73:47 - smooth activation functions and as I
73:49 - said earlier we won't be studying them
73:51 - in this course but if you're curious
73:54 - that shouldn't stop you from learning
73:56 - nowadays there are a bunch of resources
73:58 - that can
74:18 - help it's lesson three and we're still
74:21 - using one output but that's about to
74:23 - change we'll start using two and then
74:26 - four so the network can tell the car to
74:28 - go forward backward left or right now
74:32 - this is called a multi-label neural
74:34 - network and you don't need to know this
74:37 - name to follow along but I do want to
74:39 - tell some terminology and don't confuse
74:42 - it with a multiclass neural network a
74:45 - multiclass neural network is what we had
74:47 - in the machine learning course where the
74:49 - drawing could be classified as one thing
74:52 - but here the network can say to go
74:55 - forward and left at the same time for
74:58 - example so it's a different
75:01 - thing okay finally the car will start
75:07 - exploring open the playground from the
75:09 - link in the description and you're going
75:11 - to see this scenario with three
75:13 - cars but the difference is that now we
75:16 - also have the possibility to go in
75:18 - reverse and I'm going to show you how
75:21 - easy it is to solve this problem when we
75:23 - can do both of these
75:25 - things I'm going to set this weight here
75:28 - to minus
75:32 - one this one also to minus
75:36 - one and up here the bias Min -
75:42 - 0.9 like this now this by itself crashes
75:46 - two of the cars but if we also go under
75:49 - right here and put the weight of
75:51 - one
75:53 - one and
75:56 - 0.9 essentially filling this remaining
76:00 - space and restarting the
76:09 - simulation see what
76:11 - happened let's check this
76:16 - again it looks really good the cars are
76:19 - stopping where they should and they are
76:22 - slowing down only when they need to at
76:24 - at the very end this one arrives first
76:27 - this second this third if you just look
76:29 - at what happens
76:31 - here it looks all right and we don't
76:34 - have any curves or any fancy things but
76:37 - what we do have is this other ability of
76:40 - the car to slow down quicker so even if
76:43 - you could see a little bit of that kind
76:47 - of bouncing effect
76:49 - here only for the fastest moving car I
76:54 - don't know if you can even notice it uh
76:57 - it's not a big deal anymore because this
77:00 - is such a powerful maneuver that it's
77:04 - basically making all of these points
77:07 - just follow this line separating the two
77:11 - surfaces here and at the very end you
77:14 - can see these things blinking like crazy
77:16 - because we're at the edge this is a bit
77:19 - annoying here if you look at the neural
77:23 - network but if you look here on the left
77:25 - even if you zoom in the cars don't
77:28 - really move because the acceleration is
77:31 - so small there and going in both
77:33 - directions so I'm not really bothered by
77:36 - it but if you are you could set for
77:38 - example this to minus
77:41 - 0.89 and now there will be a small Gap
77:44 - there maybe if I'm going to do
77:48 - this you can see this very narrow Gap
77:51 - here forming where the points stabilize
77:54 - nice
77:55 - now let me show you the next
77:58 - homework go to S equals to
78:03 - revcore
78:05 - H it's going to be the same thing but
78:08 - just one car in the middle and the goal
78:11 - for you is to make it do this where the
78:14 - car goes up and down like that forever
78:20 - try to find a network configuration that
78:22 - does that I think it's pretty pretty
78:25 - cool but now we're going to move on and
78:28 - I'm going to teach you about steering so
78:31 - let's change the link at the top
78:34 - to S equal to
78:39 - sdore
78:41 - 0 and you're going to see this new
78:44 - scenario here and the car has one more
78:48 - sensor the one on the right you can see
78:52 - this extra input appearing here
78:55 - and it's now sensing something because
78:57 - the road border is quite close but the
79:00 - other two are zero because the car is
79:03 - not moving and because this is not
79:05 - sensing anything now here at the top
79:08 - there are two new outputs for turning
79:12 - left and for turning right and all these
79:15 - weights connecting them now these are
79:17 - really confusing to work with like that
79:19 - so let's remove them from this button
79:21 - right here and move things around to
79:24 - make things a little bit clearer so
79:27 - let's separate this into two
79:31 - parts one on the left here will be what
79:35 - we just did
79:37 - previously going forward and being able
79:40 - to stop so we don't Collide and then on
79:43 - the right let's keep the steering part
79:48 - it's going to work with this new sensor
79:50 - that we have here and let's do the same
79:54 - thing that we did before so let's
79:57 - connect this one and say here
80:02 - minus1 and this
80:04 - one - one and here minus
80:09 - 0
80:12 - 9 and for the
80:17 - reverse one
80:20 - one and 0
80:23 - point
80:25 - nine now this is the same thing that we
80:28 - had before and the car should stop
80:30 - nicely at the
80:33 - end and it did but if you look here
80:37 - something strange happens focus on this
80:40 - diagram and when we refresh crazy things
80:44 - are are going on this doesn't look
80:47 - anything like what we had previously
80:51 - right and that's because here we we
80:54 - don't have the speed now we have this
80:57 - sensor if you click on it it's going to
81:00 - change to the speed and show what we had
81:03 - before exactly so now you can recognize
81:06 - this pattern here but what were we
81:09 - looking at before so this is what you're
81:13 - going to have to understand
81:15 - next it looks like these regions are
81:18 - somehow changing but they're not you can
81:21 - only change those things if you play
81:24 - with the weights and biases from up
81:26 - there what happens is that this is
81:29 - really a 3D space now and one axis that
81:34 - goes like that is the speed in this case
81:37 - it's the one that is missing from these
81:40 - two labels here and what we are seeing
81:44 - here is a slice of the cube at that
81:48 - speed somewhere inside of this Cube at
81:52 - the value of the current speed so if I'm
81:55 - going to change to this it's like we are
81:58 - watching the cube now from the from the
82:01 - top and what we see when we change this
82:05 - we see the cube from the side so this
82:10 - amount of green that is still on the
82:12 - right of this point is actually the same
82:15 - in this case but as the speed of the car
82:19 - changes this amount of green that we see
82:23 - in this other View is going to start
82:25 - growing and then shrink back because
82:29 - here as the point is moving up if you
82:32 - think about some kind of horizontal line
82:36 - at that point location the amount of
82:39 - green on that line is growing and then
82:42 - shrinking again so growing and then
82:46 - shrinking again so this is what we see
82:49 - in this
82:51 - view growing and then shrinking again
82:56 - it's not easy maybe it's going to help
82:59 - if we use Desmos again and let's type in
83:03 - the functions so we have
83:06 - -1x - x -1
83:10 - y minus y and there is no weight
83:15 - connected to Z at the moment so I'm just
83:18 - going to put plus 0
83:21 - Z and nothing appears here and this is
83:26 - because what we are describing now is a
83:28 - hyper plane it's something in four
83:32 - dimensions and here Desmos is saying
83:35 - something try adding an equal sign to
83:38 - turn this into an equation because it
83:40 - can't show four dimensions there so you
83:44 - could put equals like equals to our bias
83:48 - which was
83:50 - -0.9 and this now turns into a plane in
83:53 - three Dimensions but we're really
83:56 - interested in the values that are above
83:58 - this bias so greater than minus
84:03 - 0.9 so what we have now here is
84:07 - essentially the gray area in our diagram
84:12 - but let's look at it from the top like
84:15 - so let's make it actually gray it's
84:18 - possible to do that here and let's zoom
84:22 - in here so that we focus on the minus1 +
84:26 - one area and let's add the green one
84:29 - next so that was x + y + 0 Z we are not
84:38 - using that at the moment and this is
84:41 - greater than
84:44 - 0.9 and this is our green area let's
84:47 - make it green so it's similar to
84:50 - ours and it looks pretty much the same
84:54 - as what we have
84:56 - here looking from the top but if we look
85:00 - from the
85:04 - side like
85:07 - this and slice the cube somehow I'm not
85:11 - sure if we can do that let's try going
85:14 - here in the
85:18 - settings let's try putting here
85:22 - zero okay it looks like we can so zero
85:26 - means that we are basically having a
85:29 - zero speed
85:31 - now and the car has a zero speed at the
85:34 - moment let's turn on this manual
85:38 - override and when I go in reverse you
85:41 - see this green part disappears from
85:45 - here it disappears from there because
85:49 - when you have a negative value for the
85:52 - speed like minus one for example then we
85:56 - are watching this part this slice of the
85:59 - cube that doesn't have any green in it
86:03 - but if we go forward and increase the
86:06 - speed we get more green appearing
86:12 - there and that's because we are slicing
86:16 - more in front
86:17 - there
86:20 - like let's
86:23 - say one would be very much maximum speed
86:27 - of the car but let's put 0.5 for example
86:31 - so this is half as much as the maximum
86:34 - speed and let's see if we can get to
86:36 - that if I start all the way at the
86:39 - bottom
86:39 - here so let's see how much green is
86:43 - coming
86:46 - here yeah I could get to that but I
86:49 - don't want to crush the car I really
86:51 - hope this is clear for you because
86:54 - because these things start to not be
86:57 - very easy to understand and the tools
86:59 - can only do so much now let's think
87:03 - about turning so I want to turn based on
87:07 - this sensor here if it doesn't sense
87:10 - anything or if nothing is close if the
87:13 - border is not close here I want the car
87:16 - to turn to the
87:18 - right so I'm going to connect here this
87:21 - sensor and to keep things easy I'm just
87:24 - going to put minus1 Here and Now
87:27 - vertically I can move that red
87:30 - region as a percentage so this 20% minus
87:36 - 20% here just means
87:38 - 20% upwards here so let's move this all
87:43 - the way to the top maybe minus 0.9 like
87:47 - this and it's still off because this dot
87:51 - is above it here
87:55 - but if I'm going to move the car
87:57 - somewhere where this doesn't appear then
88:01 - it's now moved in this red area so this
88:04 - will make the car turn and let's see how
88:07 - it goes I'm going to remove this manual
88:10 - override and the car is
88:12 - turning a bit too much and then crashes
88:16 - in the wall so maybe a value of-
88:21 - 0.8 is better let's try try to
88:29 - restart
88:36 - okay yeah looks like we got it to turn
88:40 - so it's really
88:42 - nice and see what happens here in the
88:45 - diagram so what did we add this red
88:49 - region let's try adding it in Desmos as
88:53 - well
88:55 - so this one doesn't depend on X at all
88:58 - it's 0 X Plus 0 Y and minus Z because we
89:06 - have a minus one weight there greater
89:09 - than minus
89:12 - 0.8 and we can change the color here to
89:17 - red and this is what we get now the
89:20 - option from here to have translucency to
89:23 - see through these things doesn't really
89:26 - work when we have these solid
89:29 - objects I think it shouldn't really work
89:32 - it's kind of hard to to think about
89:35 - these solid elements and seeing through
89:38 - them somehow it's going to be very
89:40 - confusing anyway but this didn't affect
89:43 - the other things they are still there if
89:45 - I'm going to toggle it from here it's
89:48 - just a new thing that was added so here
89:51 - you have a combination of green and red
89:55 - really and that combination of green and
89:59 - red is what I'm showing here as this
90:02 - orange when they are overlapping
90:08 - there the gray and red makes the red
90:12 - appear brighter like this but from here
90:15 - you can actually remove some of these
90:16 - elements if you find them confusing like
90:19 - if you just want to see the red area
90:23 - here you can turn off the gray and you
90:25 - can see it now well and the green and
90:29 - you can focus on what happens with the
90:31 - point and in relation to this control
90:35 - here but let's turn them back
90:38 - on and change this to the previous View
90:42 - and see what is
90:43 - happening so you see this crazy blinking
90:47 - that is happening there it's because the
90:50 - point goes inside the red region and out
90:53 - outside of the red region sometimes
90:56 - really really quickly here when it's
90:59 - actually doing the turn it's it's doing
91:02 - that so what happens is the point is
91:06 - basically somewhere at the border here
91:09 - and then moving like that really fast
91:13 - that's what makes everything blink red
91:16 - when seen from this side here again
91:21 - really hope you get it play with these
91:23 - things it really helps I think now if
91:27 - you look at this something is weird
91:30 - because the car is not really driving on
91:33 - its side of the road it's driving in the
91:35 - middle like like crazy so let's try to
91:39 - do that probably what we need to do is
91:42 - decrease this value here let's try going
91:45 - slowly because minus 0.9 crashed it so
91:50 - I'm just going to try 81 8 two and focus
91:55 - what happens on the car as I'm changing
91:57 - this
91:58 - 83 you see it got
92:03 - closer got closer
92:09 - 84 it's getting closer but it's also
92:12 - sometimes moving on this kind of
92:15 - trajectory that is probably going to hit
92:18 - the wall
92:20 - eventually let's see
92:22 - 86
92:26 - ah almost almost hit there let's try 87
92:31 - maybe this is as much as we can
92:36 - go
92:38 - okay so at
92:40 - 87 this thing happened basically it
92:44 - turned in a way that it was on a
92:47 - collision
92:48 - course and we need to correct for that
92:52 - if it gets too close to the side of the
92:54 - road we have to teach it to turn left so
92:58 - let's connect this here and do the
93:01 - opposite so minus1 turns to + one and
93:05 - then here we have +
93:12 - 87
93:14 - okay and probably it helps to switch
93:17 - back into this other mode where we can
93:19 - see now this so red and blue are the two
93:24 - different sides if it's not going to
93:26 - turn right it's going to turn left and
93:29 - if we
93:32 - restart we see the car correcting itself
93:36 - it's actually doing it like crazy if you
93:38 - see here very quick Corrections
93:40 - happening and that's because there's no
93:43 - spacing here between the blue and the
93:47 - red it also reminds me that in phase one
93:49 - of the course some people were asking
93:51 - why does the car shake like that
93:54 - so now you have an answer it was in
93:56 - between regions like this now it's
93:59 - better it's on its side of the road but
94:02 - it's touching that lane a little bit I
94:04 - think we can do even better than that so
94:06 - maybe let's try changing this to minus
94:11 - 0.9 like so and this one to
94:17 - 0.9 so forcing it even
94:22 - closer
94:24 - I think this looks good if this shaking
94:26 - bothers you then you can always put here
94:29 - a higher value like minus
94:32 - 0.89 and now the car is not going to
94:35 - correct itself as
94:40 - often let's see how it does in a
94:43 - different scenario so change here to Str
94:48 - strore
94:52 - one
94:54 - and now you see the car going in circles
94:57 - like
94:58 - that and this is what I meant in the
95:00 - beginning that the right hand rule in
95:02 - mazes doesn't necessarily guarantee that
95:05 - you're going to get out of the maze you
95:07 - can also get stuck in situations like
95:10 - this so I just wanted to show you a
95:13 - situation where it doesn't work let's
95:16 - move on to a more complex scenario S
95:19 - strore
95:22 - 2
95:24 - and see what happens
95:32 - here something kind of crazy happened
95:36 - there
95:38 - right let's look at it a little bit more
95:44 - so these things are quite nice it's
95:48 - really keeping its lane and then here oh
95:53 - no
95:56 - oh even crashing
95:58 - horrible
96:00 - so let's look again and see what happens
96:04 - here this is fine but here it's doing
96:08 - something crazy and that's because the
96:11 - front sensor doesn't see anything when
96:15 - moving here but it saw something when
96:18 - moving there so it slowed the car
96:21 - down this is the problem here as well
96:23 - the front sensor doesn't see anything so
96:26 - the car only sees that it has to turn
96:29 - right but it has large
96:32 - speed and the same thing happens here
96:34 - picks up speed even more and then sees
96:38 - that it has to turn right but then when
96:40 - the front sensor sees something
96:42 - eventually it's too late for it to turn
96:46 - now the solution for this
96:48 - is really to add more
96:51 - sensors so that it can see things in
96:54 - front at different angles and figure out
96:57 - that something is coming but I don't
96:58 - want to increase the complexity of this
97:01 - structure too much because we will still
97:04 - add things to this and it's going to
97:06 - become more and more confusing if we
97:09 - have more things to work with what we
97:12 - will do is Cap the speed so that the car
97:15 - cannot go as fast as it can but at a
97:20 - speed where this problem doesn't happen
97:23 - anymore think about it the car sensing
97:25 - things on the
97:26 - right really it finds out in the last
97:29 - minute that it has to turn so if it's
97:32 - going some crazy speed there it is going
97:36 - to fail it's too late so let's see how
97:39 - we kep the speed and let's change here
97:43 - so that we see this chart and let's
97:45 - remove blue and red because they are
97:50 - confusing and let's remove these two
97:52 - links from here we will do something
97:55 - else with the reverse section later for
97:59 - now it's best to focus just on this
98:01 - green area and cap it so I want this
98:04 - section here to be black so that the car
98:08 - doesn't accelerate to the speed that it
98:12 - could manage mechanically and for that
98:16 - I'm going to have to add here a new
98:18 - node like this and let's just copy these
98:21 - values here so minus 1 - one and this
98:26 - one here is -
98:29 - 0.9 and now these nodes are doing the
98:33 - same so let's remove these links put a
98:36 - zero here you can press zero on your
98:39 - keyboard to do that faster and let's
98:44 - connect these with some kind of positive
98:47 - WID 0.1 for example and you see this
98:51 - shape appearing here again
98:54 - so now whatever this value is this one
98:57 - is going to be the same now let's put
99:00 - this to zero and create a new shape here
99:04 - that is just a horizontal flat line here
99:07 - and the bottom part gray so I'm going to
99:11 - take the speed here only it doesn't
99:14 - depend at all on this one right it's
99:16 - going to be a flat shape and for
99:19 - Simplicity I like to put here minus one
99:22 - so
99:24 - here I can
99:25 - control a percentage and let's try to
99:29 - put minus 0.4 and connect this one to
99:33 - the gray output and add some value there
99:37 - so now this percentage here if it's
99:40 - minus 0.5 it's exactly in the middle
99:43 - this is higher this is lower let's start
99:46 - at minus 0.5 and see if the car Behavior
99:50 - changes but we also have to do the
99:52 - combin
99:54 - so the intersection between this
99:58 - region and this region it's going to
100:01 - keep just this kind of trapezoid
100:04 - here to do and you put both of these to
100:09 - 0.1 and at the moment this is actually
100:12 - doing or so it's either that or that and
100:16 - here we can put 0.1 so that means that
100:21 - this needs to be on this needs to be on
100:24 - for this one to activate great and
100:28 - another homework for you would be to do
100:31 - the same
100:32 - thing for the green region here you
100:36 - would have to use or so it's a good
100:38 - chance to practice that logic and you
100:41 - need to duplicate these make similar
100:44 - logic many many complicated things maybe
100:46 - clean this up a little bit organize
100:48 - things differently and connect in the
100:51 - same way to that one
100:54 - or do what I'm going to do now and use
100:58 - the not operation so what will happen is
101:02 - that when this one is on this will be
101:06 - off and when this one is off this will
101:08 - be on which kind of makes sense I mean
101:10 - when you drive a car you typically
101:12 - accelerate or decelerate you don't
101:15 - really let the car slow down by itself
101:19 - in almost any situation unless you think
101:22 - about
101:23 - conserving gas or or something like that
101:26 - but if you want it to be fast then you
101:29 - probably want to apply the brake if you
101:32 - are not accelerating so having a not
101:35 - here does make some sense and let's see
101:39 - how to do
101:40 - that I'm going to create another node
101:44 - here it's easiest to teach you like
101:47 - this and let's copy these values now so
101:50 - 0 1 0 1 0 1
101:56 - and remove these other links right
102:01 - clicking and zero this one positive here
102:06 - so these nodes are now in sync we have
102:08 - the same thing as before we introduced
102:10 - another hidden layer
102:14 - here and for the not we are going to
102:17 - connect this one here with a negative
102:20 - weight and here we have to use a
102:24 - negative bias as well if you're going to
102:26 - use a value of minus 0.1 it will work
102:29 - because when this is on so a value of 1
102:32 - multiplied by - 0.1 so we do get here -
102:37 - 0.1 and it's not greater than minus 0.1
102:42 - so when this is on this is not going to
102:45 - be on but when this is off then that's
102:48 - going to be 0 * something which is 0 is
102:52 - greater than minus 0.1 so basically we
102:55 - have a way here to get the opposite of
102:58 - this node and that's why the green area
103:01 - is appearing here nice like that and
103:05 - there's no overlap or anything going on
103:07 - like if you remove the gray area here
103:09 - it's clear that the green is the
103:12 - opposite of the gray okay so does it
103:15 - work let's
103:22 - restart still doesn't work it's still
103:24 - going too fast there on that section so
103:27 - we're going to have to cap the speed
103:29 - even more
103:31 - maybe minus
103:34 - 03 let's say and let's see what happens
103:38 - here these were the most problematic
103:41 - things and the car is going to go now
103:44 - quite slow compared to
103:46 - before yeah it still did a little bit of
103:50 - a of a loop there
103:57 - but it's not crashing anymore so maybe
104:00 - even a smaller
104:05 - speed minus
104:09 - 0.2 let's see if it crosses no okay it
104:13 - doesn't cross the line anymore so with
104:15 - this Logic the car moves relatively slow
104:18 - to what it can do but if you think about
104:21 - it and if you would think that these are
104:23 - real cars and you have you're watching
104:25 - them from the helicopter or whatever um
104:29 - they would look like that they wouldn't
104:31 - speed up crazy like what we had
104:33 - previously so this is really a decent
104:36 - speed for a car inside of a
104:39 - city so we did it the car can now
104:43 - navigate these complex situations it's
104:46 - even going on its own part of the
104:49 - road and maybe it's a good time I show
104:52 - you these other buttons up here so you
104:56 - can save the current car Network
104:59 - structure that we have here we put a lot
105:02 - of work into this so maybe we don't want
105:04 - to lose it and saving from this button
105:08 - and you can also load from this other
105:11 - button so you can try different
105:12 - configurations save them under different
105:15 - names and then load them to see how they
105:18 - work in different scenarios which by the
105:21 - way you can load from this button right
105:23 - here so if you took the virtual world
105:27 - course you have the editor there and you
105:30 - can create any world you want for the
105:32 - cars to drive in and you can use this
105:35 - playground to load those worlds into it
105:38 - and see this car or any car you buil
105:43 - here manage
105:45 - it now one thing that I still want to
105:48 - show you is that the network here
105:51 - doesn't look
105:53 - like the one I showed you in the very
105:57 - beginning of this course like if you
106:00 - type here
106:04 - default the network here is quite
106:07 - different it has just one hidden layer
106:10 - right and then this right sensor is
106:14 - connected to something here and to
106:16 - something there not directly to these
106:18 - outputs and there are significantly many
106:21 - weights here on the right this is the
106:24 - common structure neural networks have
106:27 - really and the reason why everything on
106:30 - this line is connected to everything on
106:32 - this line and here the same thing has to
106:36 - do with
106:38 - how neural networks are represented
106:41 - internally as matrices and speeding up
106:45 - some of the operations and also a few
106:48 - other things I'm not going to get into
106:50 - but basically we could convert our
106:54 - Network into this network by just adding
106:59 - zero weights where they are needed and
107:01 - making this kind of relationship here so
107:04 - that this node is in sync with this node
107:07 - and and so on the problem is this one
107:10 - more hidden layer is missing here so how
107:12 - can this car do something here and let's
107:16 - go
107:18 - back I can show you that we can actually
107:21 - remove this node from here as well so
107:25 - right click on
107:28 - it connect like this and just put here
107:32 - the.
107:34 - 1.1.1 so now we have that gray area here
107:38 - but it's covered by the green so we
107:42 - can't see it and the green has to be a
107:45 - knot again but somehow created without
107:49 - that extra node from there so we can can
107:53 - connect this as such put a negative 0.1
107:57 - here a negative 0.1 here and it's not
108:02 - quite right here this needs to be minus
108:05 - 0.2 I'll let you do the math for this
108:09 - one but you can see the end result is
108:11 - exactly the same and we didn't really
108:14 - need another node there another hidden
108:17 - layer now you may want to save this
108:21 - version of the network as well
108:23 - because it's different than the previous
108:25 - one and what I'm going to show you next
108:28 - will kind of destroy it so focus on this
108:32 - network here and change the url to S
108:37 - strore
108:41 - three and notice that it looks different
108:45 - but it's really the same thing it's
108:47 - doing the exact same things as
108:51 - previously like you can recognize this
108:54 - shape here and adding on these other two
108:59 - you can see them here whatever Network
109:01 - you create in Str strore 2 is going to
109:04 - be converted in this kind of full
109:07 - Network that you see here and these
109:10 - weights are essentially zero all of them
109:13 - that are added new and you can recognize
109:16 - the other connections there plus these
109:19 - new nodes two new nodes that are needed
109:22 - to connect to the turning right and
109:25 - turning left and they are just in this
109:28 - kind of synced relationship so whatever
109:31 - the note here is this one at the top is
109:33 - doing the same and this network looks
109:36 - much more like the one on the first page
109:40 - there but that one had also some values
109:42 - for these weights and the reason why
109:44 - that is is that I optimize this network
109:47 - a little bit more by using the genetic
109:50 - algorithm so I did this
109:54 - I lowered the mutation
109:59 - here and I tried to generate cars that
110:03 - are very similar to that one but a
110:06 - little bit different so that maybe they
110:09 - act better and this is really
110:11 - slow uh maybe it's acting a little bit
110:14 - better if we put this to the max but
110:18 - basically this is really slow because
110:20 - it's trying to process this large
110:22 - Network and do these visualizations
110:25 - and yeah but you can see this car that
110:29 - is leading here the one that covered the
110:31 - most distance is not the one that we
110:34 - previously had that we were previously
110:37 - working with because it has some values
110:40 - for these other weights it might crash
110:44 - at some point I don't know but it's at
110:48 - least a car that is going for now better
110:53 - faster than the previous one the one we
110:57 - designed and I think I saved one of
110:59 - these cars and I've used it as the intro
111:04 - there you can see some of these
111:06 - connections here are still quite obvious
111:08 - that they are that the network is based
111:10 - on what we designed but there may be
111:13 - some relationships between these notes
111:15 - that we didn't even think of and this
111:19 - network is potentially finding some of
111:22 - those it's also making this much harder
111:26 - to explain what is going on so this is
111:31 - the truth whenever you optimize using
111:34 - automatic methods like this you will
111:36 - start to get a network that you can't
111:38 - explain every single thing from there
111:42 - usually you can't explain anything from
111:45 - there but in this one because of all the
111:48 - things that we have done we do still
111:51 - have some IDE a of what is going on now
111:54 - this car seems to be doing quite a good
111:57 - job I'm going to save
112:00 - it and let's close this and see it going
112:05 - and it might be faster but it's not as
112:09 - smooth as what we had previously it's
112:12 - doing this kind of fidgeting here
112:18 - um sometimes it's pressing acceleration
112:21 - and break at the same time but you see
112:24 - how these small changes in the weights
112:27 - are affecting the overall result even
112:29 - though it's kind of doing the same thing
112:34 - some of these structures are totally
112:36 - different so here there is not anymore
112:40 - that kind of Separation the gray area
112:45 - looks
112:46 - different it's doing a an an or here now
112:50 - it's not doing an and anymore more so
112:54 - probably yeah this bias here has been
112:57 - made lower so this is interesting an
113:01 - interesting change and the green
113:04 - region is very much the same as before
113:07 - so now this is not anymore when not
113:10 - breaking when not accelerating you break
113:15 - um it's also this these two sections
113:18 - appearing here where both of them are
113:20 - pressed at the same time and there's
113:23 - much more going on here like when the
113:25 - car is turning at some point I noticed
113:28 - that the green region is you saw that it
113:32 - was changing a little bit the other
113:34 - sensor is somehow
113:36 - interfering
113:37 - with the logic from the component that
113:40 - we had independent previously and there
113:43 - might be some good reason for that like
113:47 - if you do see that it's empty on the
113:49 - right maybe you want the car to break
113:52 - break because you don't want it to go
113:55 - crazy even if the front sensor is not
113:57 - doing anything so it is possible to come
114:00 - to some better logic more complex logic
114:04 - automatically like
114:09 - this and
114:12 - here this this thing here is
114:18 - really
114:19 - strange before we just saw the clear
114:22 - separation between blue and red and what
114:25 - is this thing if we remove the red you
114:29 - can see that this is actually blue
114:32 - appearing here so the blue somehow
114:36 - makes this shape now and it depends on
114:40 - the speed as well if it's going to act
114:43 - like that so depending on the speed this
114:46 - steering left which we only use to
114:49 - correct its Direction has a different
114:53 - effect hopefully with all this you can
114:55 - see that we can
114:58 - still understand some of the things that
115:01 - the car is doing even though the
115:03 - complexity has grown especially because
115:06 - it's based on something we created but
115:09 - also because of the tools that we are
115:11 - using here and the understanding that we
115:14 - gained during these lessons it's
115:18 - important to remember that this is a
115:20 - small Network I mean compared to that
115:23 - deep neural network we had in the
115:25 - machine learning course this is nothing
115:27 - and the one there is nothing compared to
115:29 - powerful ones out there so just imagine
115:32 - the complexity those can handle if ours
115:35 - can already do so much and by the way in
115:39 - case you're curious I did teach how to
115:42 - implement that chart and the decision
115:44 - boundary plot in the machine learning
115:46 - course the diagram that we're using here
115:49 - is that but regions can also overlap
115:52 - because of what I said earlier multic
115:55 - class multi label
116:00 - remember the car is now moving nicely
116:03 - staying on the right side of the road
116:05 - and navigating this maze quite well but
116:08 - what will happen if we add some
116:12 - markings well nothing the car has no
116:15 - idea there even there we need to add
116:18 - more sensors and update the logic for
116:20 - them as well the new network will have
116:23 - five inputs this time so get ready to
116:26 - navigate in higher
116:28 - Dimensions start the playground from the
116:31 - link in the description and you're going
116:33 - to see this scenario which is pretty
116:35 - similar to the last one but it has also
116:38 - these markings on the road like the stop
116:41 - marking and the traffic
116:43 - lights now the way we're going to solve
116:46 - this problem is the car is equipped with
116:49 - two new
116:51 - sensors they are not really visible here
116:54 - but if you're going to turn on the
116:56 - manual override and go forward like this
117:00 - you're going to see that this red sensor
117:04 - appears here it's overlapping the other
117:06 - one the way I implemented this on top of
117:10 - the code from phase one is I just added
117:12 - a stop sensor another sensor to the car
117:15 - and it has only one Ray here that is
117:19 - casted in front but it's looking for
117:21 - borders from these markings instead of
117:24 - the road one other thing that I did is
117:28 - the car is only seeing this border if
117:31 - it's looking at it from this angle like
117:34 - if I'm going to go up
117:37 - here
117:39 - slowly and look at the stop like that it
117:43 - doesn't see it it doesn't turn red you
117:46 - could model this logic in the neural
117:49 - network as well but that will make it
117:52 - even more complicated and you'll see
117:54 - today it's going to be quite complicated
117:56 - by the end now let's go back here and
117:59 - see the input node associated with this
118:03 - sensor so it's this one here it works
118:06 - pretty much the same as the front one
118:08 - but it's the distance to the stop
118:11 - marking there not to the side of the
118:14 - road so you can see that value changing
118:17 - like this and it's zero if it doesn't
118:20 - see
118:21 - anything now for the traffic lights the
118:24 - same thing but a different input node a
118:27 - different sensor in the car object as
118:29 - well and you can see those values
118:32 - changing but if the traffic light is
118:35 - green then this sensor is not reading
118:39 - anything so it only looks for yellow or
118:43 - red traffic lights and the same thing
118:47 - applies as before if you're looking at
118:49 - some traffic light from the wrong angle
118:51 - like this then it's not going to to
118:54 - trigger anything you need to look at
118:57 - them from the correct
119:00 - angle like this assuming that you're
119:03 - driving on the right side of the road so
119:06 - two new nodes here and stop to think
119:09 - about it when we had one node we were
119:13 - using that to define a
119:16 - line two they were defining a plane
119:21 - three
119:23 - we had this hyper
119:26 - plane what are these they're also called
119:30 - hyper planes anything after three
119:32 - dimension is just hyper but visualizing
119:36 - or understanding what is going on now
119:38 - when we build this new network is going
119:41 - to be much more challenging than
119:43 - anything else because we are not anymore
119:45 - in the 3D world that we are used to so
119:51 - let's start solving this problem and
119:53 - we're going to start from scratch I'm
119:55 - not going to load any version of the car
119:58 - from previously because I think
120:01 - recapping what the logic is helps to
120:04 - understand how we complement the logic
120:07 - so we will build the same card that
120:10 - follows the right hand rule of solving
120:12 - mazes as previously but a little bit
120:16 - different he'll
120:18 - see let's move this sensor for detecting
120:21 - the the right side of the road there
120:26 - and the turning left and right let's get
120:29 - them out of the way for now and here
120:33 - let's focus on moving forward and
120:36 - stopping we're going to focus on moving
120:38 - forward actually and for that we need
120:41 - the forward sensor so that we can detect
120:44 - when the car is going to stop and the
120:47 - speed so that we can control stopping at
120:49 - different moving rates now let's create
120:53 - a new node here like
120:58 - this and uh two more one like this and
121:03 - one like this and one like this you can
121:06 - probably tell something crazy is going
121:08 - to happen but we begin with the very
121:11 - basic logic here so let's define this
121:14 - weight to be minus one minus one and
121:18 - this one was Min - 90%
121:22 - like this and all of these weights here
121:25 - I'm just going to put plus 0.1 so that
121:28 - this node just whatever it is it's going
121:31 - to sync with this node and this will
121:33 - sync with that node and this will sync
121:36 - with that node so the logic here is
121:40 - really simple what is happening here
121:42 - whatever this value is just transfers to
121:44 - all the other ones and you can see here
121:47 - on this axis that that just means the
121:50 - car is going to ex accelerate until it's
121:53 - very close to the border so like if we
121:57 - are going really really close to the
121:59 - Border then it doesn't accelerate
122:02 - anymore and this line moves here when
122:06 - the car is moving oops I crashed it
122:10 - let's restart this the reason why that
122:13 - line moves like that is because of the
122:16 - speed so because this is still a 2d
122:21 - scenar Ario we can put here this one
122:24 - like that and see the decision border
122:27 - here so now the car should be able
122:32 - to go forward and stop
122:36 - whenever oh it's going to crash because
122:40 - I didn't connect the reverse so here we
122:43 - are going to do a not whenever this one
122:46 - is
122:47 - on this will be off and vice versa I'm
122:50 - just going to put here -
122:52 - 0.1 and - 0.1 and if this is off 0
122:59 - multipli by something is zero it is
123:02 - greater than- 0.1 but if this is on then
123:07 - minus 0.1 is not greater than minus 0.1
123:11 - so this node whatever it's going to say
123:16 - this will be the opposite and now
123:20 - restarting
123:26 - is going to stop like that and I'm not
123:28 - going to bother with this kind of
123:30 - blinking here because it's not possible
123:34 - to solve without doing a lot of
123:37 - redundancy and changing some biases a
123:40 - little bit but to stop the blinking
123:42 - because it it is bothering me watching
123:45 - it like that I'm going to press this
123:47 - button for the manual override and now
123:50 - it's going to stabilize to some
123:52 - position there and let's do the steering
123:55 - logic next so
123:57 - basically in this situation it shouldn't
124:00 - steer because it sees something on the
124:03 - right so let's change this here to
124:08 - show this sensor pointing to the right
124:12 - and connect it to steering right I'm
124:16 - going to put here
124:18 - min-1 and here a good value was minus
124:22 - 0.9 so at the moment it's not steering
124:26 - to the right but if I'm going to move
124:29 - the car a little bit in front then this
124:33 - point here moved in that reddish region
124:36 - so that means that it does want to steer
124:39 - to the right and it's going to want to
124:41 - steer to the right a lot like that and
124:45 - eventually it's going to crash if we
124:47 - don't teach it also to steer to the left
124:51 - as well and we solved that by filling
124:54 - the remaining part here with blue so it
124:58 - was like this now let's restart this and
125:03 - turn off the manual override and the car
125:06 - is shaking a little bit like like crazy
125:09 - there but it is kind of
125:12 - steering except for this crazy thing
125:16 - that happens because let's see this
125:20 - again
125:22 - because now it's just speeding up and
125:25 - all of a sudden it found out it has to
125:27 - turn so the speed it had was so much
125:30 - that it made it jump to the other side
125:32 - and then it it got confused so our
125:35 - solution to that was
125:38 - to cap the speed to make it go not as
125:43 - fast as it can but at a reasonable speed
125:46 - that the sensor is enough to solve this
125:50 - problem nicely and we did that by doing
125:54 - this adding a new node here for the
125:57 - speed let's change this to see what's
126:00 - going on and I'm going to remove the
126:01 - blue and red so that they are not
126:04 - confusing we have to cut this gray plane
126:08 - here like that and the good value for
126:12 - this was uh 20% so I'm going to put this
126:16 - to minus one and
126:19 - here - 20% like this and this was now
126:24 - connecting here let's just remove this
126:29 - um set this weight to
126:32 - zero turn this one to on to see how it
126:36 - looks like so 20% means that from
126:42 - here and we want to combine the two
126:47 - so not like that this is now doing the
126:50 - or so it's
126:52 - either below this slanted line
126:56 - or
126:59 - below this section we want to combine
127:02 - them so that we get the intersection of
127:04 - the two and we can do that by increasing
127:07 - the bias here by 0.1 like this let's
127:10 - stop also that fidgeting here so we can
127:13 - put
127:14 - minus
127:16 - 0.89 for the turning right and that's
127:20 - going to give a small Gap here for when
127:24 - turning so that it doesn't correct its
127:26 - location all the time like that let me
127:29 - show you here if we put the sensor to
127:33 - the right and turn on the other two
127:35 - colors and we really need to use high
127:38 - resolution here let's take off
127:42 - also these other things um it's still
127:47 - not very
127:49 - visible but um
127:53 - a gap like this appears
127:56 - there even if it's minus
128:00 - 0.89 it's a small Gap that prevents it
128:04 - from fidgeting like
128:07 - that okay let's put this back here
128:11 - because my computer is starting to
128:13 - breathe heavily and turn off this manual
128:17 - override and now the car should be doing
128:21 - very nice nice things
128:26 - here let's have a quick check to see if
128:30 - it's turning properly and if it's
128:33 - visiting all of these regions as
128:37 - well everything looks nice on the
128:41 - right yeah turning properly and not
128:44 - crossing the
128:48 - border so this is exactly what we we had
128:51 - last time but the extra nodes that we
128:54 - have here are to help with the New Logic
128:57 - that we are going to create for the stop
129:00 - marking and for the traffic lights yeah
129:03 - so what should happen now is that the
129:06 - car should stop at the stop marking not
129:09 - just cross there like like it's nothing
129:13 - and the way we do that is the same way
129:16 - that we stop at the road border like we
129:20 - are going to call this Logic for the
129:24 - Stop node here as well so let's try to
129:27 - do
129:31 - it this is
129:35 - minus1 this is
129:37 - minus1 and this is minus
129:41 - 90% like that and now let's investigate
129:45 - if this works we're going to put here
129:47 - the speed like so let's not worry about
129:50 - turning anymore and just keep these gray
129:54 - and green regions there I think it's
129:57 - actually clearer if we keep just the
129:59 - gray region because the green one is
130:01 - always going to be the opposite now so
130:05 - here with the gray region
130:08 - emphasized we look what happens when the
130:11 - car is reaching the stop
130:16 - sign and let's turn on the manual over
130:19 - right here so
130:23 - when it's reaching the stop sign
130:26 - here we still have this front sensor
130:30 - telling us that it's okay to go because
130:33 - it doesn't see the stop
130:35 - sensor but if we change this to be the
130:38 - stop sensor you're going to see that
130:40 - this point is going to be much closer to
130:44 - this side because the STP marking here
130:47 - is closer than the road border so let's
130:50 - see that
130:54 - right so this did move like that but now
130:57 - it doesn't have that region that tells
131:00 - it to to slow down so we have to give
131:05 - that to the end result here and I'm
131:08 - going to create a new node I think it
131:10 - makes it clearer like this and let's
131:14 - just copy whatever happens here on the
131:17 - right for
131:19 - now 0 1
131:23 - 0.1
131:25 - 0.1 and let's disconnect this one so I'm
131:29 - going to put here zero or let's just
131:32 - remove it entirely and connect this one
131:36 - instead so now we do get that thing here
131:40 - but we don't get it anymore for the
131:43 - front sensor because that part is
131:46 - disconnected all right let's still focus
131:49 - on the stop for now and just check if it
131:52 - works so I'm going to remove this manual
131:54 - override and it goes and it stops at the
131:58 - stop marking and it never goes anywhere
132:02 - else from here so this is something we
132:06 - all have to fix let's put on manual
132:09 - override so that this doesn't blink like
132:12 - like crazy and now because we are
132:15 - stopped at the stop we want to move
132:19 - again so looking at this we would like
132:21 - to have some gray region here on the
132:25 - right it's okay to move now after we
132:27 - have stopped at the at the stop so let's
132:31 - add another link from here it's only
132:35 - going to be a vertical region it doesn't
132:37 - depend on the speed or or anything like
132:39 - that when we are really close to the
132:42 - stop marking it's okay to go so we can
132:46 - set here a value of + one like this and
132:51 - a value here of
132:54 - maybe let's try 90% so that this part
132:58 - from here 90% from here gets
133:04 - gray so
133:06 - 90% now this node needs to be connected
133:10 - as well and we are going to do an or
133:13 - here between this one and this one
133:16 - because if this is okay or this is okay
133:20 - it's going to
133:23 - accelerate and you can see this region
133:26 - appearing here it's not capped but
133:29 - actually we don't have to worry about
133:31 - capping for now I think it makes it more
133:33 - complicated so let's remove this line
133:36 - and here instead of having a bias of 0.1
133:40 - we just have it zero so that this value
133:43 - transfers like that and let's refresh to
133:46 - see what is going on remove manual
133:50 - override
133:53 - so the car is slowing down like this and
133:56 - at some
134:02 - point it continues like that so it's
134:05 - great it crashes there but the logic
134:08 - from here is going to prevent that it's
134:10 - going to do the capping and and
134:11 - everything now it's up to you if you
134:13 - like what happened with the stop I think
134:15 - that it actually took a little bit too
134:18 - long so maybe a value of
134:25 - 85 let's try 87 I think this is now
134:29 - growing too
134:31 - much I don't want it to be a full stop
134:34 - and to wait seemingly so long there
134:37 - so I think this is this is decent how it
134:41 - looks like in the real world a stop
134:43 - should mean a full stop checking if
134:46 - other cars are there and if not you can
134:48 - go but I like things to be a bit faster
134:51 - here and uh speaking of other cars in
134:54 - the demo I have on the website cars give
134:56 - way to other cars on the ride that works
134:59 - with another sensor like this it looks
135:03 - fancy but they just a bunch of rays in
135:05 - front and to the right that check for
135:06 - cars if any of them sees something a
135:10 - sixth input is used to make the car stop
135:13 - we won't be adding more cars here
135:15 - because it's quite messy but we will do
135:18 - the traffic lights logic and that's
135:21 - exactly the same think about it waiting
135:24 - for a car to pass or for a light to
135:26 - change is the same thing really just the
135:29 - sensor is different we'll move on to the
135:31 - traffic lights in a moment but first
135:33 - let's reconnect this side so the car
135:35 - doesn't crash like that I'm going to
135:38 - replace this link from here to this
135:44 - node in the same way nothing changes
135:47 - really so that I can move this one here
135:49 - on this side and connect nicer to this
135:52 - one here we have to do an and
135:57 - so both of these need to happen for it
136:00 - to work
136:01 - properly let's
136:04 - restart and we can see now how this
136:07 - looks like combined with the cap
136:09 - there it's slowing down at the stop and
136:13 - now moving to the
136:16 - right and now as it's moving down let's
136:19 - change this back to the up Arrow
136:21 - which doesn't have that special part
136:24 - there for accelerating again which would
136:26 - just make it crash there but you can see
136:29 - that it's slowing down and it's doing
136:32 - the turn properly so both Logics are
136:37 - combined now in a in a proper way it's
136:41 - good if you stop
136:43 - and play with these values try to
136:46 - inspect things and get your own
136:48 - understanding of this before moving
136:50 - forward
136:51 - but the last part here really is going
136:54 - to be quite easy it's um a trick that
136:59 - we're going to do to make the traffic
137:01 - lights also work with as little effort
137:05 - as
137:07 - possible for that we are going to move
137:10 - the traffic light here in the middle and
137:13 - the stop to the right and the traffic
137:16 - light is just going to connect to this
137:19 - node with minus one here and just like
137:24 - magic it's going to work let's have the
137:28 - car go back to the starting point and
137:33 - see what the traffic light is showing
137:43 - here you saw it was slowing down and
137:47 - wanted to stop but then the traffic
137:49 - light just became green so basically
137:51 - what we want the traffic light to do is
137:54 - like the stop but we don't want it to
137:56 - start all of a sudden while the traffic
137:59 - light is still um red it's going to stop
138:04 - there and wait there until the traffic
138:07 - light turns to Green by itself
138:11 - so that's the logic it's actually a
138:15 - simpler Logic for the traffic lights
138:17 - than it is for the Stop even though you
138:20 - think that these are more complex it's
138:23 - the traffic lights themselves that are
138:25 - complex not the logic that the car is
138:29 - doing car just stops and this is a
138:32 - little bit cheating because I'm assuming
138:35 - that there are no traffic lights and
138:38 - stops next to each other so that's why
138:42 - this logic works
138:44 - but it works in most cases so I'm happy
138:49 - with this
138:51 - now the logic here this or and this and
138:55 - and this and can actually be simplified
138:58 - so we don't need these hidden layers
139:02 - I'll show you let's remove this
139:07 - node and car is wow it's doing some
139:11 - crazy things now and connect these ones
139:14 - here as
139:17 - well so everything connected to this one
139:20 - note there now this is a value of 10 and
139:24 - this is 10 let's make this one
139:29 - 30
139:31 - 30 and this one here let's make
139:35 - it 60 because we're going to put these
139:38 - weights here to 0.1 and 0.1 and if only
139:43 - one of these is on it's enough to turn
139:46 - this one on so we are essentially doing
139:49 - an end here combined with an ore somehow
139:53 - with one single neuron there it's uh
139:56 - it's interesting but it does help to
139:58 - simplify this and if you restart
140:02 - now it doesn't work because I forgot
140:05 - this bias here so now I just want to
140:08 - transfer whatever is here to here and
140:11 - this bias has to be
140:14 - zero okay so now it should work exactly
140:17 - as before but with a simpler structure
140:20 - here
140:21 - we can also get rid of this node so if
140:23 - your goal is to have less hidden layers
140:27 - we can do that like so and connect this
140:30 - one here and this one here the minus and
140:33 - a plus and it's the same logic as before
140:37 - let's just check
140:38 - it and you may wonder why is this moving
140:41 - here well it's because there are other
140:44 - things there are other sensors appearing
140:46 - on some other axis so now this slicing
140:50 - here here it's not anymore a slicing of
140:53 - a cube it's a slicing of a hyper Cube we
140:57 - have not just one more axis the forward
141:01 - sensor we have the forward sensor we
141:03 - have the right sensor we have the stop
141:06 - sensor all of them are there somewhere
141:09 - and here we are just visualizing a slice
141:12 - of that complex hyper Cube and you may
141:16 - see some of these movements happening
141:20 - there from time to time but yeah you can
141:23 - actually get rid also of this Noe and
141:26 - simplify this even more so you could
141:30 - connect all of these directly to that
141:32 - and all of these directly to that and
141:35 - figure out how to do here the not by a
141:40 - combination of of links like that I'm
141:44 - not going to show you that that's going
141:47 - to be your homework but it is possible
141:49 - to Simply y this even more so that you
141:53 - need only one hidden layer here but in
141:56 - my opinion the logic that I'm reading
141:58 - now is actually clearer for for me for a
142:02 - human to understand so I can definitely
142:06 - understand here this kind of compound
142:08 - operation that is happening like this
142:11 - will turn on when it's greater than 0.6
142:16 - these two will make it 0.6 exactly it
142:19 - needs something else and these are not
142:22 - enough to get anywhere close than that
142:24 - so this logic here is clear it needs to
142:27 - have both of these and one of these so
142:30 - it's actually even simpler than having
142:32 - the more more nodes there and here we
142:36 - just transfer the value here and not to
142:39 - that if I'm going to have all of the
142:41 - connections copied to the other one
142:43 - that's just going to make more math in
142:46 - your in your head but here the not is
142:49 - very easy for me to understand I don't
142:51 - know about you please keep in mind that
142:54 - we are not really solving self-driving
142:57 - here this simulation is very simple and
142:59 - these markings in real we don't
143:02 - recognize them so easily I mean we could
143:05 - like Road markings could send signals
143:07 - and smart cars could pick those up but
143:10 - that would be very costly to maintain so
143:13 - car companies have a different approach
143:15 - they make cars see the world as we do
143:18 - with a bunch of cameras they have good
143:21 - reasons for doing that the roads were
143:23 - made for us so seeing the same way we do
143:26 - should be enough to solve
143:29 - self-driving but that gives another
143:31 - layer of complexity here large neural
143:34 - networks are used to look at the scene
143:35 - like that and figure out that there is a
143:38 - stop sign there not too different from
143:40 - the drawing recognizer we built in the
143:42 - machine learning course where to get the
143:44 - best accuracy we used a monster of a
143:47 - network and there we didn't get to 100
143:51 - 100% no big deal for the drawings but
143:54 - here we kind of have to right luckily
143:58 - stop signs look the same everywhere
144:02 - so never mind anyway the problem is far
144:06 - more complex and we're simplifying a lot
144:08 - is all I'm trying to
144:11 - say we have a nice car now going around
144:15 - and obeying all kind of rules but the
144:18 - car just goes around forever usually
144:20 - they go somewhere so we'll experiment
144:24 - with adding a kind of a compass sensor
144:26 - that tells where the target is Now
144:30 - spoiler alert this Compass approach is
144:32 - not great so I won't insist on it too
144:35 - much I just want to get something that
144:37 - kind of works so you see it's not enough
144:40 - in practice and why we'll need to study
144:42 - path finding algorithms
144:44 - soon speaking of which I'll have to show
144:47 - you how to update the self-driving car
144:49 - code base to load the cars we make in
144:52 - this playground and also how to get it
144:54 - ready for pathf
144:55 - finding about time we get back in the
144:58 - code
144:59 - settle start the playground from the
145:02 - link in the description and you're going
145:05 - to get this scenario that also has a
145:07 - Target the car has three sensors this
145:11 - time because we're going to teach it to
145:12 - turn left or right depending on where
145:15 - the target is so it's going to need to
145:18 - see on the left as well and there is
145:21 - another sensor that is not really
145:23 - displayed anywhere but you can see it
145:25 - here as this node this value here tells
145:30 - the angle that you need to turn to to
145:34 - face the target kind of it's not really
145:37 - an angle it's again a value between zero
145:40 - and one but let's check it out so I'm
145:42 - going to turn on this manual override
145:46 - and hovering this you see there a value
145:48 - of minus 20 before this just
145:52 - means that you have to turn
145:56 - left minus means left and positive
145:59 - values mean you have to turn right so
146:02 - now you have to turn right
146:05 - 25% and then you would be facing this so
146:09 - a zero value means that you're pointing
146:11 - exactly at the Target there and if
146:14 - you're going to go all the way like
146:17 - opposite
146:19 - direction then it's going to say minus 1
146:25 - but as soon as it's more convenient to
146:27 - turn right you're going to start getting
146:30 - positive values there so one essentially
146:34 - and it's just telling you that now the
146:36 - car should turn right so that you turn
146:40 - to face the target that's what this
146:43 - sensor says and really it's kind of like
146:46 - a compass if you look at a compass then
146:48 - you get the same information from that
146:50 - as well many devices have these kind of
146:53 - magnetic sensors nowadays including
146:56 - smartphones okay so with this setup
147:00 - let's try to make the car head to that
147:03 - Target and I'm going to start by
147:06 - cleaning everything and we're again
147:09 - going to work with some components here
147:12 - like last time so let's move now this up
147:16 - sensor and the speed sensor here and and
147:20 - put the
147:23 - reverse in this top left corner and now
147:27 - turning left turning right and it's
147:30 - going to use these sensors here the left
147:36 - and right sensors and it's also going to
147:39 - use this one but let's set it aside for
147:41 - now the logic will Implement here is
147:44 - going to be really easy I want just the
147:47 - car to move somehow and control the
147:50 - steering based on this other sensor it
147:53 - won't be anything nearly as polished as
147:55 - what we did in the last lessons I just
147:57 - want to give you the idea how you might
148:00 - do such a thing and let's do the simple
148:02 - Logic for moving forward so let's focus
148:05 - here on the speed and the forward sensor
148:11 - and make that slope appear there
148:16 - so
148:18 - minus1 and
148:24 - -1 and here we're going to set
148:28 - minus 90 and this is going to be just
148:31 - the opposite so I'm going to put here +
148:36 - one +
148:38 - one and
148:40 - positive 90% like that now if we restart
148:45 - and turn off the manual override we
148:47 - should see the car going there and
148:50 - stopping like that good I'm going to
148:53 - turn back manual override and move the
148:57 - car down a bit like this and let's
149:01 - Implement steering with a similar logic
149:03 - as as here for that I'm going to put
149:07 - here this sensor and here this sensor so
149:11 - we are focusing on that and let's
149:15 - connect this one
149:18 - here with the Min - one
149:21 - weight and a + one here this time and
149:27 - now here we are going to
149:30 - use + one
149:33 - and minus one so we get this very simple
149:38 - looking structure here and what this
149:40 - does really is now the point is here so
149:44 - the car wants to turn left and it's
149:46 - essentially trying to balance out the
149:49 - ratio between between these so the end
149:51 - result is going to be that the car wants
149:53 - to line up in the center of the road
149:56 - most of the time let's try to see how
149:59 - this
150:01 - works so the car is in the middle of the
150:04 - road and now these are equal so the card
150:08 - doesn't decide to turn at all it's
150:11 - really perfect here how how equal those
150:14 - values are normally you don't get
150:16 - something like
150:18 - that let's turn off this gray and green
150:22 - so that there is no blinking happening
150:24 - and see this
150:28 - again all right and now let's see what
150:31 - happens if we add the bias here so we're
150:35 - going to add a bias maybe 20% here for
150:40 - this one and minus 20% for this one and
150:46 - this is going to mean that the car wants
150:48 - to turn right here and it's going to
150:50 - prefer the right lane actually let's try
150:54 - to restart and now you see the car
150:58 - keeping the right lane there and then at
151:00 - the intersection it's steering left
151:04 - because of its initial position when
151:06 - entering the intersection it's
151:07 - acceleration and actually at the
151:10 - intersection if you look here this point
151:13 - is somehow going a little bit crazy but
151:16 - anyway this kind of configuration means
151:19 - that that the car tends to turn left at
151:23 - the intersection and not right and if
151:26 - you do the opposite like put here minus
151:32 - 20 and here +
151:35 - 20 then the car wants to drive on the
151:37 - left lane and here at the intersection
151:40 - what's going to happen is that the car
151:42 - is going to turn right in this case and
151:45 - it actually does a pretty good job even
151:47 - with this very simple logic here
151:50 - but um fails at the end because it this
151:53 - proportion here tells it to turn left
151:57 - anyway uh this is not important I just
151:59 - wanted to get here some logic that
152:02 - actually works and decides how to turn
152:06 - at the intersection currently based on
152:10 - these biases but we are not going to use
152:14 - those we're going to use the value of
152:15 - the sensor instead so I'm going to put
152:19 - here
152:20 - Zer and zero as we had before and let's
152:25 - move this one here because it's somehow
152:27 - a natural place for it to sit and here
152:31 - I'm going to connect this one with a
152:33 - positive weight let's say 20 and a
152:38 - negative weight here like so and look
152:42 - what happens here I'm going to turn on
152:44 - manual override refresh and now I'm
152:49 - going to to move the car somehow here as
152:55 - Center as I
152:56 - can there it's not fantastic but anyway
153:01 - and you see this falls into the red
153:06 - region now because of how this target is
153:11 - influencing the car has to turn to the
153:14 - left so it needs to now turn right so
153:17 - that it's on the right lane for
153:20 - turn to
153:21 - work so if I'm going to turn off the
153:23 - manual override then the car is going a
153:27 - little bit to the right and then is able
153:29 - to manage that left turn but if you
153:32 - change this link to TGT
153:37 - uncore
153:41 - 1 then there's a Target on the right and
153:45 - uh the car is already doing crazy things
153:48 - there let's see this again so the car
153:51 - turns to be on the left lane and
153:53 - prepares for the turn to the right and
153:56 - then it continues to do some things here
153:58 - and it is affected somehow by this um
154:02 - Target still like you can see that it
154:05 - starts on the left lane but after
154:08 - passing this it moves mostly on the
154:10 - right lane because now the target is on
154:12 - its left so it's still preparing to turn
154:15 - left to head back to the Target but it
154:18 - never gets another intersection to try
154:22 - anyway this does work to make the car
154:25 - turn in different directions according
154:28 - to where the target is but it's not
154:30 - always a good solution like if you go
154:33 - here and put TGT
154:36 - uncore
154:41 - 2 you see the target is now on the left
154:45 - and the car is going left at this
154:49 - intersection
154:50 - because it's where it thinks the target
154:52 - is but it has no idea of the road
154:56 - structure here so this is a big problem
155:01 - we either have to teach this road
155:03 - structure to the car make it part of the
155:06 - neural network somehow a lot of inputs
155:08 - weights biases very very complex stuff
155:12 - or rely on some other solution that
155:15 - gives us the path to
155:18 - follow go up here here and type S is
155:22 - equal to SP for shortest
155:26 - path and you're going to see very
155:29 - different things here this logic is not
155:32 - the one we were playing with now it's
155:34 - actually the one that teaches the car to
155:36 - do the right hand rule that we played
155:39 - with previously and that Target the
155:43 - compass sensor is completely gone so the
155:46 - car is just exploring here this Maze and
155:51 - nothing else but there is this added
155:53 - button here that tells the car to follow
155:57 - a specific path and let's try restarting
156:01 - this and pressing this button and it's
156:04 - going to obey now this Corridor that
156:07 - appeared here so these lines here that
156:12 - you see are going to be new borders that
156:14 - the car is going to try to listen
156:18 - to this Corridor is the shortest path
156:22 - from where we press the button to where
156:25 - the target is and you can actually
156:28 - remove it and press it anytime you want
156:30 - like now and see what the car is doing
156:34 - we just told it go to that Target and
156:38 - it's doing it it's going to that Target
156:40 - no matter um where it is in this maze so
156:46 - to speak I'm going to teach you how to
156:48 - implement this algorithm for for finding
156:50 - the shortest path between two points in
156:51 - a graph but for that we need to take
156:54 - this brain back into our code base from
156:59 - the end of phase two so we're going to
157:01 - need to set things up a little bit there
157:04 - and in the next lesson we're going to
157:07 - implement D
157:09 - algorithm this part is mostly for those
157:11 - who followed along with coding the self
157:13 - driving car simulation and want to get
157:15 - the full connection here if you just
157:17 - want to learn about dice algorithm them
157:19 - you can skip this part I'll post a new
157:22 - code on GitHub and you can take it from
157:24 - there before the next
157:26 - lesson this is the code from the end of
157:28 - phase two and index HTML looks like
157:33 - this there are many cars there in this
157:36 - simulation and they're trying to
157:38 - navigate this more complicated world the
157:43 - best one is always
157:46 - highlighted now the first thing we want
157:48 - to do is bring the logic for the right
157:52 - hand rule here inside of this system and
157:57 - we're going to go to the code and create
157:59 - a new folder here we are going to name
158:03 - it
158:05 - saves and in it I'm going to paste the
158:09 - car we saved in that one
158:11 - lesson mine looks like this and if we
158:15 - open it we can see a lot of different
158:18 - things here it's B basically Json
158:20 - information and it's stored inside of
158:23 - this car info Global variable the only
158:27 - important things here really are the max
158:30 - speed the acceleration and the friction
158:33 - because they have different values in
158:35 - the playground than in our code base but
158:39 - also the brain um let's see where that
158:43 - is not these but that one so the levels
158:49 - the inputs outputs biases and the
158:52 - weights we have to load these from here
158:55 - now and the sensor is also important
158:58 - like the car here has five of these Ray
159:02 - casting sensors we have to use just two
159:05 - of them at the right angle and um with
159:09 - an offset this system doesn't yet
159:11 - support that but it's an easy fix and we
159:13 - have to include the speed of the car as
159:16 - well right so a little bit wor to get
159:20 - this to work exactly like in the
159:21 - playground but it's not very complicated
159:24 - the sensor
159:27 - values are here as well this Ray count
159:31 - Ray length Ray spread and the new offset
159:35 - so let's go back to index HTML here and
159:41 - um load the car just here beneath the
159:47 - world so it's going to be in included
159:50 - like a basic JavaScript file right hand
159:54 - rule. car the extension is just to mark
159:58 - that it's a car file and let's save this
160:02 - and go inside main
160:06 - JS close this and go to the place where
160:10 - we generate the cars so there is this
160:14 - generate cars function down
160:17 - here and we want the car to load the
160:20 - information from inside of that car
160:25 - info I'm going to say here
160:29 - car is equal to and let me copy this
160:35 - from
160:38 - here I'm going to cut it
160:41 - here and this is going to be what we
160:44 - push inside of the cars array but before
160:49 - that we will say car
160:52 - load the car info like this and this
160:56 - load function inside of the car object
160:58 - is what we need to implement so we go
161:02 - here and below the
161:05 - Constructor we just have to
161:07 - type load given some
161:12 - info let's set the brain to info. brain
161:17 - and those proper is Max Speed info Max
161:24 - Speed
161:26 - friction info do
161:29 - friction
161:33 - acceleration info do
161:36 - acceleration and the ray count from the
161:41 - sensor from info
161:44 - sensor Ray count and we have to do this
161:47 - for the ray spread length and offset so
161:50 - I just copied
161:51 - this three more times and this is going
161:55 - to be
161:56 - here
161:58 - rray
162:01 - spread let's copy it
162:04 - here array
162:07 - length let's copy it here and array
162:13 - offset here and this offset is something
162:17 - that the sensor doesn't support at the
162:19 - moment so let's fix that real
162:22 - quick they are all made to be symmetric
162:25 - at the moment so here I'm going to
162:29 - say this array offset is equal to zero
162:33 - in the
162:35 - Constructor by default but it can be
162:38 - assigned something else if we load it
162:40 - from that file and when we cast the Rays
162:45 - this is the important part we need to
162:48 - add that offset to the to each
162:50 - individual array angle so here I will
162:53 - say
162:54 - plus this array
162:57 - offset and we're almost done the last
163:00 - thing we need to do is set the speed as
163:03 - the last input to the neural network so
163:05 - in car JS where we update here we get
163:10 - these offsets as inputs and that's just
163:15 - fine but here we also have to add the
163:18 - speed at the end and we can use Dot
163:23 - conat and it has to be an array that we
163:27 - give here it's going to be an array with
163:29 - just one element so the speed it's going
163:31 - to be a normalized value of the speed so
163:34 - we take this speed and we divide by this
163:39 - Max Speed so that it's going to be
163:41 - between zero and
163:44 - one and if we save this and
163:48 - test
163:51 - we can see here the
163:53 - network
163:55 - working uh it's the same thing that we
163:58 - have in the playground but visualized a
164:01 - little bit differently you can probably
164:03 - recognize here the weights and the
164:06 - biases how they look like and this is
164:09 - the speed value that we have in the
164:12 - right and these two are the front and
164:16 - right sensor respectively and it's doing
164:19 - that right hand rule
164:25 - now but one thing that you might be
164:29 - curious is where are the other
164:31 - cars so we see that all cars are loading
164:36 - this car info they have the same brain
164:40 - and they are actually overlapping in the
164:43 - simulation now here we do have this code
164:46 - that is doing a mutation but it needs to
164:50 - have something in local storage for it
164:53 - to work so if we go back and save this
164:57 - car in local storage and
165:01 - refresh we see that it does now some
165:05 - mutation like that and it actually gets
165:08 - other cars as well not just the one that
165:10 - we originally created many of these can
165:14 - fail depending on the
165:16 - mutation and how much change has
165:20 - happened there but it is what it is and
165:24 - uh you can control the mutation from
165:26 - here if you want but I think a value of
165:28 - 0.1 is quite quite good most of the time
165:32 - now to teach the car to follow a path to
165:35 - do the path finding we will have to
165:39 - create a world that has a Target so
165:42 - we're going to go inside of the world
165:44 - folder and open this index HTML next
165:49 - this one should show empty like this and
165:51 - we're going to start clicking to create
165:54 - a graph that is useful to teach about
165:57 - pathf finding now I'm going to start
166:01 - clicking here and it would be good if
166:03 - you try to follow the same kind of
166:05 - structure if not you can also get this
166:07 - world from GitHub but uh basically I'm
166:11 - going to start here like
166:14 - so and let's zoom out a little
166:17 - bit
166:19 - so here if you haven't followed the
166:21 - previous course we just click to add
166:23 - points and zoom uh out and use the
166:28 - middle Mouse button the one with the
166:31 - scroll wheel to pan around and after
166:35 - doing this we can create now few more
166:38 - points
166:44 - so maybe something like this let's also
166:48 - add a new Point somewhere here on the
166:51 - right and connect this one back to the
166:58 - start now right click to deselect this
167:02 - point and clicking to select this one
167:04 - let's add a link also here and few more
167:09 - of these segments up
167:14 - here like
167:17 - so so this should be complex enough for
167:23 - teaching about pathf
167:25 - finding and the starting point is going
167:28 - to be here so we select the car and we
167:33 - click here at the bottom somewhere where
167:36 - we want the car to be in the very
167:38 - beginning and the target this one is
167:42 - going to be all the way
167:45 - here at the top somewhere here
167:49 - like this now when saving the world it's
167:52 - important to choose some good position
167:55 - to start at and maybe the zoom level
167:58 - this will make some things easier later
168:01 - on when testing so maybe something like
168:05 - this is what we're going to see at first
168:07 - and let's save
168:10 - this I called this path finding and you
168:14 - can find it here pathf finding. world in
168:18 - the SA
168:19 - from the world folder so we have two
168:22 - different saves one for cars and one for
168:25 - worlds here now to load this new one we
168:28 - go to the index HTML from the root not
168:32 - inside of the world so this one and here
168:36 - instead of including this big
168:40 - world we are going to make a copy of it
168:44 - so that I remember that big world exists
168:50 - and include the new one so pathf
168:54 - finding world now if you save this and
168:59 - go to our car simulation and refresh
169:03 - you're actually going to get an error
169:06 - turn on the developer tools and you'll
169:08 - see this kind of errors here and the
169:12 - reason for these
169:13 - errors are here in the way the world was
169:17 - saved so pathf finding world is just
169:20 - adjacent object but big
169:23 - world has world is equal to world. load
169:28 - and inside of that function we have the
169:31 - Json
169:33 - object and it ends with this parenthesis
169:37 - and semicolon you could add these
169:40 - manually to that but I'm going to teach
169:43 - you how to make the world Editor to save
169:46 - in this format because it's more useful
169:49 - I
169:50 - think so inside of the world project we
169:54 - open index HTML and we look for the save
170:00 - function so this save function is here
170:04 - and it just writes here the stringified
170:07 - version of the world we are going to
170:10 - change this a little bit so we are going
170:13 - to say
170:17 - here like like
170:23 - this and now we stringify here like
170:28 - that and
170:31 - then we close this and now save this
170:35 - file go back to the world editor
170:40 - refresh and press save again overwriting
170:44 - the file is just fine and if you look
170:47 - now at pathfinding World it does start
170:50 - like that so we made this so that we
170:52 - don't have to do any manual editing
170:55 - anymore like what we did in phase two
170:58 - and if we go back here and refresh this
171:01 - page we can see now the cars going in
171:04 - this new world but before we check
171:07 - things out there let's also fix the load
171:10 - function inside of the index HTML from
171:13 - world so what we need to do is go to the
171:17 - load and here prepare to cut out the
171:21 - extra strings at the beginning and at
171:24 - the end there so I'm going to go
171:28 - here above this Json data and I'm going
171:32 - to take the Json string first from this
171:38 - file content and I'm going to take the
171:43 - subring like
171:45 - so and starting at the index of the
171:50 - first open parenthesis plus one because
171:53 - I don't want to include that parenthesis
171:56 - and then ending at the last index
172:00 - of the close parenthesis so basically
172:03 - taking the same thing that we had
172:05 - previously otherwise loading worlds will
172:07 - not work with this new format we just
172:10 - need to take this Json string and put it
172:14 - here instead of the original file
172:17 - content now now if you save this go to
172:20 - the world editor and refresh now load
172:25 - for example the big world that we
172:28 - already had
172:29 - there something crazy happens so it's
172:32 - still not perfect if you zoom out and
172:37 - um go down a little bit you can actually
172:40 - see that that other world is
172:43 - there but if you open the console you'll
172:46 - see that there is an error happening
172:49 - and this error is because after this
172:53 - world is loaded it's set into local
172:56 - storage and that part fails this world
173:01 - is too big to fit into local storage so
173:05 - we're going to implement the same
173:06 - solution we used to load the world in
173:09 - the simulator let's remove entirely this
173:13 - load function from here and at the top
173:18 - I'm going to also remove this button for
173:22 - loading the
173:23 - world instead we are going to go at the
173:28 - bottom and add a new script from saves
173:35 - big.or and this is going to load the
173:37 - world in the same way that we had
173:41 - previously in the simulator but we need
173:44 - to take out from here these attempts to
173:48 - read from local storage so all of these
173:51 - things can be
173:54 - removed like so now if you
173:59 - save it works but there is one small
174:04 - problem with the code and that is that
174:07 - the roads here at the roundabout are
174:10 - supposed to be one way and there is a
174:14 - mistake I omitted last time so to fix it
174:19 - we have to go in World
174:24 - JS World JS here and see where the
174:29 - loading is happening so here we load the
174:34 - graph with this function and this is
174:37 - where the problem is so we actually have
174:39 - to open math graph and load and here the
174:45 - segments are just loading what is P1 and
174:48 - P2 but not also the information if this
174:53 - is um oneway Road or not and we can fix
174:58 - that by typing this here and saving
175:02 - refresh and you're going to see that the
175:07 - lines here look different because they
175:11 - are supposed to be oneway segments it's
175:15 - a small thing but really important
175:17 - because I'm going to teach you about
175:18 - about path finding and we will have to
175:20 - take into consideration oneway roads as
175:23 - well now maybe we want to have a Target
175:26 - in this world as well to have a more
175:29 - realistic scenario this
175:32 - is my hometown after all so let's add
175:36 - the target here and figure out a
175:41 - nice zoom and center point maybe here
175:45 - where the car is and save this new
175:50 - world big with Target let's go to the
175:54 - index HTML from the root so not inside
175:58 - the world anymore and add a way to
176:02 - include that one as well I'll comment
176:07 - out the path finding for now and this
176:10 - will be
176:13 - big with
176:16 - Target save and go to the
176:20 - simulation
176:22 - refresh and now it's loading the Big
176:25 - World hopefully with the target let's
176:30 - see yeah you can see it there in the top
176:40 - right okay so this is what we are going
176:43 - to be using to study about pathf finding
176:47 - but we will work with this pathf finding
176:51 - world to begin with it's easier than the
176:54 - big one we just created and uh helpful
176:58 - when explaining how the algorithm
177:00 - works so let's make sure we have it here
177:04 - and also loaded by default in the world
177:09 - editor let's add these other ones for
177:17 - reference
177:31 - save and
177:32 - refresh and seems to
177:36 - work quite
177:41 - well D algorithm for getting the
177:43 - shortest path is really important when I
177:46 - was at Microsoft I used to hear about it
177:48 - every day now it's not strictly speaking
177:52 - an AI algorithm but when added to an
177:54 - intelligent agent like this it makes it
177:57 - more intelligent because it can find its
177:59 - way to Any Given location so I like to
178:02 - count it this one we will implement the
178:06 - algorithm for calculating the shortest
178:08 - path in the graph object which is in
178:12 - World JS and then math and the graph is
178:18 - here now this file is pretty big but
178:22 - it's just a graph implementation it has
178:25 - points and segments or nodes and links
178:29 - or vertices and edges depending on the
178:33 - terminology you want to use I call them
178:35 - points because this is a spatial graph
178:37 - and the nodes do have physical locations
178:40 - there so I prefer this terminology in
178:43 - this case and all these functions are
178:46 - not really important for us all because
178:48 - they are for constructing the graph
178:51 - adding removing points and segments and
178:54 - things like that the only method that we
178:57 - will use is this get segments with point
178:59 - so given a point in the graph we will
179:02 - get all the segments that are connecting
179:05 - to
179:05 - it and below this one we are going to
179:10 - start to implement our
179:13 - algorithm so get shortest path between
179:18 - two points so let's call these start and
179:22 - end and this method is going to create a
179:25 - path in this path array and to debug to
179:30 - see how the algorithm is progressing as
179:33 - we are coding I'm just going to add to
179:36 - it the start and the end and see if we
179:41 - can make these light up in the interface
179:44 - let's return the path save the file and
179:48 - we are going to be modifying the graph
179:50 - editor here to also display the shortest
179:55 - path so let's open this one and uh all
180:00 - the way at the bottom in the display
180:02 - method at the end we are going to
180:06 - calculate the shortest path on the fly
180:09 - so path is equal
180:13 - to get shortest
180:16 - path between two points and I'm just
180:19 - going to take out the graph point of
180:24 - zero the first point and the last point
180:27 - so graph points
180:30 - of this graph points do length minus one
180:35 - this is just for debugging a first
180:38 - version here now let's display these we
180:42 - are going to Loop through every point of
180:45 - the path like this and draw it on this
180:50 - context the canvas associated with this
180:54 - uh graph editor now let's save and um
180:57 - open the index HTML from
181:01 - world not the one here in the root
181:04 - folder the one from
181:07 - World here above this
181:10 - one and it's going to look like this and
181:14 - doesn't seem anything special but if you
181:16 - look closely this Point here is darker
181:20 - than the other ones let me zoom in a
181:23 - little
181:24 - bit you can see it's clearly darker
181:27 - because it's drawn twice we are also
181:30 - drawing it now the start and end
181:32 - locations and this is the last point
181:34 - that was added when constructing this
181:37 - graph so this is also darker but let's
181:39 - mark them a little bit
181:42 - better we can add here for example a
181:46 - size Maybe be 50 and let's give it the
181:51 - blue color as
181:53 - well and when you refresh you're going
181:56 - to see this much clearer here and the
182:00 - end point is now there so the algorithm
182:04 - works by expanding starting to expand
182:08 - here at the start point and growing and
182:11 - growing and growing until eventually
182:14 - reaching the end point let's start this
182:17 - expansion from this start point and see
182:20 - if we can get to this other point here
182:23 - going back to graph
182:27 - JS
182:28 - and here I'm going to get all the
182:32 - segments that are connected to the start
182:34 - point in this case it's only one there
182:36 - but there can be more so seg is equal to
182:41 - this get segments with
182:44 - point the start point and that's this
182:48 - method from here and looping through all
182:52 - of these segments like this I'm just
182:55 - interested in the other point the point
182:58 - that is not the start point so let's
183:01 - take it out like this other point we
183:05 - check if the first point of the segment
183:08 - is equal to the start and in that case
183:12 - we return here P2 otherwise P1 so
183:16 - whatever start is we get the other point
183:20 - and let's add this one to the path and
183:22 - see if it lights up so path
183:27 - push other point like this let's save
183:33 - this and refresh and you're going to see
183:36 - here both of these lighting up now when
183:40 - we have traveled from here to here it's
183:44 - important to keep a note of the distance
183:47 - that was traveled because eventually we
183:49 - want to get to the end point there and
183:51 - we want the shortest possible travel
183:54 - distance so the distance here is just
183:57 - the length of this segment in this case
184:00 - we can go here and say other point
184:05 - distance is equal to the segment length
184:10 - simple as that and now this point knows
184:13 - how far it is from the start point and
184:16 - after this for Loop
184:18 - here we are done with the start point we
184:21 - can mark it as visited we don't need to
184:23 - worry about it anymore all of the points
184:26 - connected to it have been processed now
184:30 - these attributes distance and visited we
184:33 - should set them in the beginning so
184:35 - initialize them to something here let's
184:39 - Loop through all of the points in the
184:43 - graph and the distance we set it to
184:47 - something think really large and I'm
184:49 - going to use the maximum possible value
184:52 - that we can use in JavaScript so
184:54 - Infinity pretty much and they are not
184:59 - visited and now we expanded already from
185:03 - the start point and we need to choose a
185:05 - new point something that hasn't been
185:07 - visited yet and expand from that one so
185:12 - let's prepare for that and Define here
185:16 - current point
185:18 - set it to the start point and let's give
185:21 - it a distance of zero because we are
185:25 - starting from here we haven't traveled
185:28 - at all so makes sense to put this here
185:30 - like that and you can probably tell that
185:33 - this is going to Loop and this current
185:36 - point will update from start point to
185:37 - something else so let's change now
185:41 - everything here where start appears to
185:44 - current point and get a new point to
185:50 - Loop this section and it's going to be
185:53 - an unvisited point so to keep things
185:56 - clear let's define here
185:59 - unvisited and we get that by using the
186:03 - filter method on the points and saying
186:05 - that we want the points that are not
186:09 - visited we always want to expand the one
186:12 - with the shortest distance that we
186:14 - currently have so it's also useful to
186:17 - take out these distances and I'm going
186:20 - to use the map method here remapping
186:23 - each point to just its distance so this
186:26 - is an array of distances from all the
186:28 - points and now to find the unvisited
186:32 - point with the smallest distance we are
186:34 - going
186:35 - to find inside of this unvisited array
186:40 - the point with the distance equal to the
186:45 - minimum
186:46 - distance from this other array here so
186:51 - the minimum function expects many
186:54 - parameters here not an array like that
186:57 - so we have to destructure it and then it
187:00 - finds the point with the smallest
187:03 - distance and this is the thing that
187:05 - Loops so we can try writing here a loop
187:08 - for
187:10 - example and let's just Loop twice so
187:13 - starting at one going to two I ++ and
187:18 - everything here inside of this for
187:21 - Loop like so and if you refresh you're
187:25 - going to see that these two new points
187:28 - are marked there and that's because in
187:30 - the first Loop we visited this one so
187:33 - expanding to process its neighbors and
187:36 - in the second Loop this one expanded as
187:38 - well now the distance that we are
187:41 - calculating here needs to be a
187:45 - cumulative distance we need to add add
187:48 - what was previously here to the new
187:52 - length of the segment that we are
187:54 - processing in this
187:55 - step so here I'm going to
188:00 - type current point do distance plus the
188:05 - segment length because in the second
188:08 - Loop this point here has already a
188:11 - distance and that is important to be to
188:14 - be kept so that this point knows the
188:16 - travel distance from the starting point
188:19 - along this path and this point now knows
188:22 - the travel distance from the starting
188:24 - point along this path if you look
188:27 - closely you're going to
188:29 - see small issue here that this point is
188:33 - visited twice it looks darker because of
188:36 - the transparency and that is happening
188:39 - with the current logic but it makes no
188:41 - sense because we move from here to here
188:45 - and then from here to here so instead of
188:49 - this point having a distance of zero
188:52 - which it originally had it was the
188:54 - starting point now it has double the
188:56 - length of this segment we don't update
188:59 - these distances if we find larger ones
189:04 - so
189:06 - here let's also not add a point to the
189:10 - path in that case so if this distance
189:14 - that we are calculating now this current
189:16 - Point distance plus segment length is
189:19 - less than other point distance then we
189:24 - do these
189:27 - things like so if you save and refresh
189:31 - you're going to see that this point is
189:33 - not emphasized anymore because when
189:35 - expanding like that it doesn't go back
189:38 - here it's counterproductive let's try to
189:41 - expand more let's put here three and see
189:43 - what
189:46 - happens you can see this expanded
189:51 - here this one didn't expand here just
189:54 - yet because we only expand from the
189:57 - point with the smallest travel distance
190:00 - that took to get there so this one
190:02 - expanded and most likely this is going
190:05 - to expand again and again and again it's
190:07 - going to take some time until these
190:10 - distances here cumulate to the same
190:13 - value of this distance here so let's try
190:17 - and see see if that's true put the
190:21 - four
190:24 - okay let's see
190:27 - five growing here
190:29 - again let's see
190:33 - six yeah let's see what happens next I
190:37 - think that this distance starts to be
190:39 - almost the same as this one
190:42 - here
190:45 - seven okay so this did this expand or
190:49 - did this expand let's see aha it looks
190:53 - like actually this one expanded now and
190:56 - these are the two new points it helps to
191:00 - understand if we visualize the previous
191:03 - point it was connected to highlighting
191:06 - this segment let me show you where we're
191:10 - updating this distance here I'm going to
191:12 - type other point previous is equal to
191:16 - the current point and now to visualize
191:19 - these in the graph editor I can
191:23 - check if there is a previous there might
191:27 - not be like for the start point then we
191:30 - create a new segment from the point to
191:33 - the previous and we draw it we can draw
191:36 - it on this context and uh let's
191:39 - emphasize it with uh larger width so
191:43 - that it's obvious
191:45 - save and re refresh and now you can see
191:48 - that this point is connected to this one
191:51 - so at the moment it seems like the
191:53 - shortest path to get to this point is
191:57 - from here but we haven't processed this
192:00 - point yet this is not yet visited that
192:02 - happens in The Next Step so let's put
192:06 - here
192:10 - eight and now you can see this update
192:13 - here and it's showing twice because this
192:17 - point was added into the path array once
192:21 - when visited from here and then it's
192:24 - updated it's added again to the path
192:27 - with uh an update to its previous value
192:30 - here so a little bit confusing
192:32 - visualization here but this is correct
192:35 - now it shows that this is the best way
192:38 - to reach this point and the algorithm
192:41 - goes on and it's going to end up
192:44 - eventually to the end point there so we
192:48 - have to think about the stop condition
192:50 - and it's not very complicated we can
192:53 - just replace this with a
192:57 - while the end is not visited and
193:01 - save refresh and now you can see the
193:05 - full path here but we are not interested
193:07 - in this part from here we just want to
193:10 - know how to get from the start to the
193:12 - end right and the trick is to backtrack
193:16 - from here so from the end point we are
193:18 - going to go back back back back back
193:22 - back back back back all the way to the
193:23 - starting point and that will be the
193:25 - shortest path from the start to the end
193:28 - let's go back to our code and we don't
193:31 - need to create the path early on like
193:34 - this we only do it after this Loop ends
193:38 - so let's remove also adding this other
193:40 - point here it was just for
193:43 - debugging and here we can create the
193:46 - path
193:48 - again like so as an array and let's loop
193:53 - again with this current Point let's set
193:55 - it to be the end point and now while
193:58 - there is a current point because the
194:01 - start point doesn't have a previous So
194:04 - eventually this Loop will
194:06 - terminate we unshift the current Point
194:10 - into the path and this is the same as
194:12 - push but it's putting it in the
194:14 - beginning of the array so at the end
194:17 - we're going to have the path in proper
194:20 - order and update this current point to
194:23 - be the
194:26 - previous save and refresh and you're
194:30 - going to see the path is correctly
194:33 - forming there and this shortest path
194:37 - calculation is being executed on every
194:40 - frame so if you're going to change the
194:44 - structure of the graph like this you
194:47 - will see the path is updating as well
194:50 - and if we're going to add here a new
194:53 - segment then this new shortcut is going
194:56 - to be preferred over this one so it
195:00 - seems to work but one thing that I still
195:03 - want to do is we have added here these
195:06 - attributes to the points of the graph
195:10 - and they are things that relate to this
195:12 - algorithm and we should remove them from
195:16 - there so that other people working on
195:18 - this code seeing that these attributes
195:21 - exist there don't get
195:23 - confused and actually doing this is not
195:27 - really proper like adding attributes
195:30 - like this is not the best practice in
195:34 - the
195:35 - world but um alternative would be to
195:39 - create different structures with
195:43 - the with the metadata and um
195:47 - that would be just too much work so this
195:50 - is a quick quick fix for that and if you
195:55 - refresh you will see that it still works
195:58 - but those segments are not visible there
196:00 - anymore because this um previous was
196:05 - removed now we were able to test what
196:08 - happens on different graphs but we
196:10 - should also be able to test what happens
196:12 - with different start and end
196:14 - points testing properly is really
196:17 - important no matter what you're
196:19 - developing so let's try to add this this
196:22 - feature next into the graph
196:25 - editor we're going to go up where we are
196:28 - adding the event listeners here and I'm
196:31 - going to add the way to Mark a start
196:34 - point and an end point and we'll do this
196:37 - by pressing the S and E keys on the
196:41 - keyboard while hovering uh point so
196:46 - let's add the event
196:49 - listener for key down to the
196:53 - window and the call back function first
196:57 - it checks if we are hovering a point so
197:01 - like that and now if the key that we
197:05 - have pressed is an S key then we are
197:09 - going to set the start to hovered we're
197:14 - also going to copy this
197:18 - below and same thing for the E key and
197:23 - this will be end as the attribute that
197:27 - we are going to store the value in and
197:29 - now the display at the bottom is going
197:33 - to do here the shortest path not between
197:36 - these
197:37 - hardcoded values there but um this start
197:42 - and this end and it makes no sense to do
197:47 - this code when we don't have a start and
197:49 - an end we will get an error so we have
197:51 - to do here this check
198:03 - first now let's save and refresh and
198:07 - you're not going to see anything yet but
198:09 - if I'm going to press for example s
198:13 - while I'm hovering this this point here
198:16 - s
198:17 - and now if I press e after hovering this
198:21 - other one I'm going to get the shortest
198:25 - path from s to e let's say if we put
198:29 - here this as the end point and this as
198:33 - the start point you can see this Loop
198:37 - appearing here so it seems to work let's
198:41 - try also the real world example so going
198:47 - here in index HTML the index from the
198:52 - world
198:56 - again and uh replacing the path finding
199:00 - world
199:01 - with this one
199:05 - so I'm just swapping these here so that
199:08 - I have a reference of what is available
199:11 - save and refresh and you're going to get
199:15 - this world but uh a little bit of a
199:18 - warning here you can't move
199:22 - points here or add new points click on
199:26 - this world or anything you can but if
199:29 - you do that it's going to block the
199:32 - interface because this is a really big
199:34 - world and adding things to it manually
199:39 - um it's a really slow process so safest
199:42 - thing to do is
199:45 - actually go down here where the world is
199:49 - generating inside of the animate
199:52 - function and comment that part out when
199:55 - you refresh now nothing is different but
199:59 - if you try to add new points to this
200:02 - world or make modifications like drag
200:06 - this point around it's not going to
200:08 - regenerate everything around it like the
200:11 - roads and buildings and and whatever and
200:15 - if you accidentally click on something
200:17 - you don't have to wait like I don't know
200:20 - 2 3 minutes for it to process so let's
200:23 - see does this work here let's say that
200:26 - this is going to be the start point I'm
200:28 - going to press s hovering this one and
200:32 - let's put an a destination an end point
200:36 - somewhere here close to the Target so
200:38 - maybe here
200:40 - e and you can see it works
200:45 - um almost almost
200:50 - perfectly the problem is this was the
200:53 - start point it's going up like that and
200:55 - then here at the roundabout this is bad
200:59 - it's going in the opposite way here in
201:02 - Finland you drive on the right side of
201:04 - the road so it should go on this way and
201:07 - it's choosing the other one because it's
201:10 - apparently faster like um less distance
201:15 - to travel
201:19 - this other place looks good but we need
201:22 - to incorporate
201:24 - this these
201:26 - um oneway roads here so these are
201:29 - essentially one-way roads here you can
201:31 - only go this direction on this one and
201:34 - this direction on this one and currently
201:37 - it's going opposite there so we need to
201:40 - do a fix for
201:43 - that and it's not complicated we just
201:46 - have to go back to graph JS in our
201:49 - algorithm here and instead of getting
201:52 - segments with point we have to get
201:55 - segments that are leaving from the point
201:59 - so get segments leaving from point like
202:05 - this and we need a function for that
202:08 - it's not available here in the object so
202:12 - I'm going to copy get segment withd
202:15 - point Bel low and rename this one get
202:21 - segments leaving from point like that
202:26 - and the logic is going to be quite
202:29 - similar so here in the
202:31 - loop if the segment is one way we're
202:35 - going to have to do something special
202:37 - for that but otherwise if the segment
202:39 - allows to go both ways then this is same
202:45 - as before
202:47 - if the segment is one way we have to
202:50 - only push into this segments array if
202:54 - the first point of the segment is equal
202:56 - to point
202:58 - so if segment. P1 equals
203:04 - point then push into the
203:07 - segments this segment that we are
203:10 - looping and if you save refresh and now
203:15 - press here s and let's add also the end
203:21 - location also close to this target as
203:24 - before now the path looks like this it
203:28 - looks proper so this is how you solve
203:32 - the issue about oneway
203:36 - roads how was it did you understand D
203:39 - algorithm by coding it like this or do
203:41 - you need a better explainer let me know
203:44 - in the comments I could also teach more
203:46 - about it if you want like how to make it
203:48 - more efficient or how to use it to
203:50 - compute some other path like the fastest
203:53 - path or how to include traffic
203:55 - information whatever my PhD was on
203:58 - location based applications so you can
204:00 - ask pretty much anything
204:03 - here just having the shortest path is
204:06 - not enough the car needs to obey it
204:09 - somehow now there are several ways you
204:11 - can do it in practice first thing that
204:13 - comes to mind is to cover the path in
204:15 - targets and have the car navigate to the
204:18 - nearest one each time using the compass
204:20 - sensor if these targets are close enough
204:23 - the problem I showed before goes away if
204:26 - you like this idea that's your new
204:28 - homework because I'm going to teach you
204:30 - another approach will'll generate a
204:33 - corridor around the shortest path like
204:35 - that so the car from earlier doing the
204:38 - right hand rule has no choice but to
204:40 - follow it to the
204:42 - destination now get ready to go down the
204:45 - corridor of
204:47 - knowledge we are going to add the
204:49 - functionality to generate a corridor in
204:52 - the world because we need to have
204:54 - information about how wide the roads are
204:57 - and things like that so in World JS and
205:03 - then World JS below this generate method
205:09 - from
205:10 - here and implement the method generate
205:14 - Corridor it's going to be a corridor
205:17 - that links again a start and an end
205:19 - point so start
205:22 - end and We Begin by Computing the
205:26 - shortest
205:27 - path between the start and end using
205:33 - the method we implemented before now
205:37 - from this path we are going to get the
205:39 - segments the consecutive segments that
205:42 - build the path so
205:45 - let's
205:47 - generate those in this array we are
205:50 - going to Loop starting at one and all
205:53 - the way until the length of the
205:57 - path and add to these segments a new
206:02 - segment with the point from IUS one so
206:06 - the previous point and the current Point
206:08 - path of I and to get the corridor we're
206:11 - going to wrap these segments in the
206:14 - envelopes so
206:16 - going
206:18 - here let's say temporary envelopes
206:21 - because we're going to unite them
206:25 - later we remap each segment to an
206:29 - envelope created from this segment using
206:32 - this segment as a
206:33 - skeleton so each segment is remapped to
206:37 - an
206:38 - envelope using the road width and the
206:42 - road
206:43 - roundness like this and let's let's just
206:46 - set the
206:49 - corridor to be these envelopes for now
206:53 - we still have to do something to them
206:55 - but let's debug so that we know these
206:57 - things are working at the moment we're
207:00 - going to draw this
207:03 - Corridor Below in the draw method here
207:08 - and uh before drawing the cars so that
207:12 - we don't draw the corridor above the
207:14 - cars now
207:16 - we have to check if it exists maybe we
207:20 - don't have
207:21 - one and then looping through all the
207:24 - elements these are eventually going to
207:26 - be Road borders so segments I'm going to
207:29 - use this variable name here to Loop
207:32 - through the
207:34 - corridor and um just draw it on the
207:38 - context but both the segments and the
207:41 - envelopes have a draw method so this is
207:44 - going to stay the same now save this
207:47 - file and we have to generate this
207:50 - Corridor somewhere and we'll do that
207:54 - inside of the graph
207:57 - editor so in our event listener we
208:01 - defined
208:03 - before we have to check do we have here
208:07 - a
208:09 - start and
208:11 - and location and if so we tell the world
208:15 - to to generate the
208:19 - corridor between the start and end
208:22 - locations like this now because the
208:25 - world has a way to display its Corridor
208:28 - we don't need this code at the bottom
208:30 - here
208:32 - anymore and uh generating the corridor
208:35 - is done only when we press SN e over
208:40 - some points there so not on every frame
208:43 - it will be displayed on every frame but
208:46 - not regenerated on every frame it's
208:49 - important because generating the
208:50 - corridor is more processor intensive
208:53 - than just figuring out the shortest path
208:56 - let's save this and
208:59 - refresh and now let's press s here and
209:03 - let's go somewhere maybe just here and
209:06 - press
209:07 - e and these are now the
209:12 - envelopes let's try a few more times
209:14 - maybe e here
209:18 - s
209:22 - here e
209:25 - here seems to work but when generating
209:28 - these corridors we really want to use
209:32 - the car's location and the Target
209:34 - location and the car can be not where
209:37 - the point of the graph is it can be
209:39 - anywhere like it's here and the target
209:41 - can be at a house so we need to
209:45 - implement way that the start and end
209:48 - points can be anything along these
209:51 - segments here and we'll make that work
209:54 - by essentially pressing SN e no matter
209:57 - where the mouse is here but then
210:00 - projecting the mouse to that segment and
210:03 - that will be the start
210:05 - location I'll show you we go back to our
210:09 - graph editor here and we don't need to
210:12 - be hovering over anything anymore so we
210:16 - can do this and instead of this hovered
210:20 - here we can say this mouse both for this
210:25 - one and for this one now of course we
210:28 - can't use this point directly so we need
210:30 - to project it on the graph and actually
210:33 - add it to the graph it's going to be a
210:36 - little bit work to do but not horrible
210:40 - you'll see inside of world JS where we
210:44 - are constructing the corridor so in the
210:46 - generate Corridor method up here we have
210:50 - to do something to these points before
210:53 - passing them to the shortest path let's
210:57 - take first the nearest segment to the
211:01 - mouse click so we can use
211:07 - here the get nearest
211:11 - segment from the
211:13 - start and looking inside of all the
211:16 - segments from the graph like that this
211:18 - is going to give us the start segment
211:21 - and we can do the same thing for the end
211:26 - segment but using end
211:29 - here and now we need to project this
211:33 - start Point onto the start segment to
211:36 - get a point that is on the graph somehow
211:40 - we can do a projection using the
211:43 - segments method to project the
211:47 - point like this now this here
211:52 - returns two things it Returns the point
211:55 - and the
211:57 - offset how far from the start of the
212:00 - segment we are and I want just to use
212:02 - the point and I don't want to complicate
212:05 - the syntax too much afterwards so we
212:09 - will destructure this directly to get
212:11 - just a point and we will refer to this
212:14 - point as appr start and we can do the
212:18 - same thing for the end for the Target
212:28 - essentially and now these two new points
212:31 - that are over some segments in the graph
212:34 - we need to add them in the graph as
212:38 - actual points and they need to be
212:39 - connected to other points in the graph
212:42 - so let's do that here
212:47 - taking the graph points and pushing the
212:50 - projected
212:51 - start and doing the same thing with the
212:56 - projected
212:58 - end and now the segments we need to
213:02 - Define as well they will be temporary
213:05 - segments after we do this path finding
213:09 - here we don't need to have them there
213:11 - anymore we should remove them from there
213:13 - we don't want to alter this graph
213:15 - structure forever it's just a temporary
213:18 - thing that we need to do right now so
213:22 - the first one is going to be a segment
213:25 - from the first point of the start
213:27 - segment to the projected start and then
213:31 - the second one will be from the
213:33 - projected start to the second point of
213:36 - the start
213:38 - segment then we're going to have the
213:40 - same things going on for the end segment
213:44 - and the projected end
213:50 - Point like so and the graph segments
213:54 - also need to know about these temporary
213:58 - segments now I'm going to append them at
214:02 - the end using
214:04 - concat like so and very important here
214:08 - when finding the shortest path we don't
214:11 - use start and end anymore instead we're
214:14 - going to use the the projected start and
214:17 - projected end the points that we just
214:20 - added to the graph so that we can have
214:22 - any start and end location on the
214:25 - road now after the shortest path is
214:28 - found we can clean up so let's remove
214:32 - the points that were
214:34 - added and we can do that with the remove
214:39 - Point method from the graph let me copy
214:43 - this for pro n
214:47 - and this is everything we need to do
214:48 - really because when removing a point
214:51 - with this method it removes also all the
214:53 - segments that are connected to it so
214:56 - these temporary segments will be removed
214:59 - as a result of this refresh and now if I
215:03 - press s here and E
215:07 - here you can see it doesn't need to be
215:10 - anymore on a point in the graph it can
215:13 - be anywhere like s here
215:18 - e here and my mouse can be anywhere like
215:21 - I can press s here and it's going to map
215:24 - to this point because that's the nearest
215:26 - point from the
215:28 - projection there is one problem that
215:30 - happens like um if e is here and S is
215:37 - here you can see this thing we need to
215:41 - also connect the projected start and the
215:44 - projected end if both of them are on the
215:47 - same segment if the start seg is equal
215:51 - to the end seg essentially so I'm just
215:54 - going to go here and
215:57 - um if they are the same
216:01 - segment I will add to these temporary
216:06 - segments a new
216:08 - segment connecting the projected
216:11 - points like so now save refresh and if
216:16 - you press s here and E here you can see
216:19 - there's no more that problem and
216:21 - everything from before still
216:23 - works but we still need to unite these
216:27 - envelopes to do a polygon Union a union
216:30 - on their polygons so let's go back to
216:36 - World JS after we have the envelopes
216:40 - here we are going to generate the
216:43 - segments the road borders
216:46 - let's say segments is equal to polygon
216:51 - Union and we are going to take out from
216:55 - the envelopes just their
216:58 - Poes because the union method here Works
217:02 - only with
217:03 - polygons and let's set the corridor to
217:06 - these segments now save and refresh
217:11 - let's press s here and E here
217:16 - and this is now the corridor and it
217:18 - doesn't have those kind of artifacts
217:21 - where the intersections are so it's good
217:24 - but I want to emphasize it a little bit
217:26 - more so down where we are drawing the
217:29 - corridor
217:32 - here we are going to also
217:36 - pass a color let's make it red and
217:41 - thicker like so save re refresh and now
217:47 - when pressing s here and E here it looks
217:50 - better I
217:52 - think the next thing we'll do is close
217:56 - this world project Here and Now focus on
218:00 - the simulation and make the cars in the
218:03 - simulation respect this Corridor let's
218:07 - open main
218:10 - JS and close the other two files so we
218:13 - don't get confused and and where we are
218:16 - creating the road borders here we're
218:20 - going to have to do something different
218:23 - so first we need to find where the
218:27 - target is because the corridor will be
218:29 - between the cars like the best car for
218:32 - example and the target wherever that is
218:36 - so I'm just going to take out the Target
218:40 - by looking through the markings like
218:43 - this and taking the mark marking that is
218:46 - an instance of Target like so and only
218:50 - if the target exists we are going to
218:54 - take the road borders as the uh Corridor
218:57 - otherwise we just do as we do now and
219:01 - everything is a
219:04 - border so if there is a
219:06 - target let's tell the world to generate
219:10 - the
219:11 - corridor between the best car which has
219:14 - an X and y so it's going to work and the
219:18 - Target Center like this and now the road
219:23 - borders are going to be equal
219:26 - to taking the segments the corridor
219:30 - which is the segments but we have to map
219:33 - them like you see below there because
219:37 - the code from phase one was working with
219:41 - this kind of structure not segments that
219:44 - have a P1 and a p too but an array with
219:46 - two points in it and now else we
219:51 - essentially have this thing from here
219:53 - but we remove the const let's close this
219:57 - parenthesis and um above here we need to
220:02 - Define Road borders and I just set them
220:05 - to nothing because they will be
220:08 - populated here now let's save this and
220:11 - open this other index
220:14 - HTML
220:16 - and it
220:18 - works
220:20 - somehow maybe this is the obedient car
220:23 - those were just mutated ones I think
220:27 - this is the one that
220:30 - is that we created previously in the
220:34 - playground I recognize these structures
220:37 - here and it seems to work just fine
220:40 - going all the way from the start
220:42 - location to the Target
220:46 - exactly the way we
220:50 - want I wonder what happens at the end I
220:52 - guess it just starts going
220:58 - back let's
221:04 - see yeah it's just going to go back it
221:07 - doesn't care that the target is there it
221:09 - just follows the corridor until the end
221:11 - then there is no end it's an infinite
221:14 - Loop
221:19 - but this is actually a way to train cars
221:24 - to get them to be faster or different
221:27 - because this code also has mutation and
221:30 - now this one is better than the previous
221:33 - one this is a different network it's
221:35 - slightly different because it's doing
221:37 - this fidgeting here I don't really like
221:40 - the fidgeting but uh maybe it has some
221:44 - other components that are useful so it
221:46 - seems like it is faster than the
221:48 - previous one and if you think about the
221:51 - racing scenario then it is
221:54 - better
221:55 - um so this would
221:59 - win
222:00 - yeah and uh you might be able to
222:03 - increase the number of cars here like
222:06 - this is 100 I think that this code
222:08 - supports even more like maybe
222:13 - 500 yeah seems to be
222:16 - just fine so in the playground the
222:19 - number of cars is more limited because
222:21 - there are a lot of crazy things going on
222:23 - in the background and uh it's using up a
222:26 - lot of uh
222:28 - CPU but wow what is some crazy things
222:32 - are happening here it kind of looks like
222:34 - a race
222:38 - already wow that one is speeding
222:42 - up so somehow it's cornering care Yul
222:45 - but then it was really really speeding
222:48 - up at some point and now it's not doing
222:50 - it anymore I wonder what happened okay
222:53 - now it's speeding up again interesting
222:56 - behavior from some of these cars uh this
222:59 - one crashed but it already passed the
223:01 - finish line so I guess it's it's
223:06 - okay I'm already thinking about the game
223:08 - even though it's not yet a game that's
223:11 - what we're going to do next
223:13 - time now for the Big Challenge open the
223:17 - playground using the link in the
223:18 - description and try to design the logic
223:21 - for a racing car instead of this
223:23 - obedient one we have now you can use as
223:26 - many sensors as you want and try it on
223:28 - as many scenarios as you can I've added
223:31 - several there but if you have the world
223:33 - editor we built in Phase 2 make more of
223:36 - them it's important to test a lot
223:39 - because you don't know what the track
223:40 - will be on race day there's a danger
223:43 - your car becomes really good in some
223:45 - specific cases learning the track
223:48 - basically but it won't do good in
223:50 - general so again remember to test well
223:54 - and when you're happy with the car send
223:56 - it over on Discord deadline is in May
224:00 - I'll be done posting tutorials for the
224:02 - racing game around that time and the
224:04 - live stream will be soon after that
224:06 - detailed rules and info about the prizes
224:09 - are on Discord so check those out and
224:11 - ask if anything is unclear thanks for
224:14 - watching and see you guys