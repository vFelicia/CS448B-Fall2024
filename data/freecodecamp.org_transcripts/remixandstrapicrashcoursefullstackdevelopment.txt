00:00 - Learn how to build projects using Remix and Strapi.
00:03 - In this course you'll discover how to harness the power of Remix,
00:06 - a modern React framework to create dynamic, user-friendly front-end interfaces.
00:12 - And you'll learn how to integrate Strapi, a flexible, open-source, headless CMS,
00:16 - to efficiently manage and deliver your content.
00:19 - Paul Brett Slofsky developed this course. He'll teach you essential concepts, best practices,
00:24 - and practical tips to help you create seamless, scalable web applications.
00:29 - Hello, you wonderful people at Free Code Camp.
00:31 - I'm excited for this new tutorial that I am going to share with you.
00:36 - We're going to learn about Remix, Strapi, and how to combine both of them together
00:41 - to build things quickly.
00:43 - We're first going to start by learning about what Remix is, getting started with the basics.
00:48 - Then we're going to add Strapi to our Remix applications
00:52 - to see how you can use Remix and Strapi together.
00:55 - So what is Remix?
00:56 - Remix is a full-stack web development framework
00:59 - created by the same team that brought us React Router.
01:02 - It is also backed by Spotify, so you know it'll be around for a long time.
01:06 - More importantly, it allows you to build amazing user experiences
01:09 - while embracing the web standards.
01:11 - Since it's a full-stack framework, you're able to build both your front-end and back-end together.
01:16 - But as a new developer or someone who's just starting out
01:19 - or you just don't have a lot of time and you want to build applications even faster,
01:24 - this is where Strapi comes in.
01:26 - Strapi is a headless CMS that allows you to create API in minutes.
01:31 - It gives you this amazing admin panel area to manage your data,
01:34 - and more importantly, you have a functional API
01:37 - that comes in with authentication, user management, and other great functionality.
01:42 - So to empower us to build cool things for our clients,
01:45 - we're going to leverage Remix and Strapi together.
01:48 - So let's take a look on what we're going to build during this tutorial.
01:51 - We're going to cover the basics of Remix,
01:54 - everything you need to know to get started with Remix quickly.
01:58 - Once we learn the basics of Remix, we're going to jump in
02:01 - and add our Strapi back-end to our Remix application.
02:05 - We're going to cover full crowd functionality
02:07 - from creating, deleting, updating, and getting our data.
02:10 - And you'll be able to visually see your data within your Strapi application, which is pretty cool.
02:16 - So let's take a look at all the things we are going to learn about.
02:18 - We're going to cover Remix routing.
02:20 - We're going to take a look at nested routes and outlets.
02:23 - We're going to also look at how to create dynamic routes.
02:26 - We're going to cover how to use loader and action functions
02:30 - to get data from our Strapi API, which will cover full crowd functionality,
02:35 - including create, read, update, and delete.
02:37 - We're also going to take a look at form validation with ZOD, which is pretty cool.
02:42 - And we're going to learn how to submit forms using Remix,
02:45 - including useFetcher function, as well as how to handle errors via error boundaries,
02:51 - and few additional things as well.
02:53 - I hope you're excited about this tutorial, as I'm as much teaching it to you.
02:57 - So with that being said, let's jump right into it.
03:00 - And finally, before we start, how can you get help?
03:03 - Well, one of the main ways that you could ask me questions
03:06 - is actually go to the project repo that I'm going to have in the description of the video.
03:11 - And you could click on issues and you could create a new issue with your question.
03:16 - And then I will be able to see it and give you any help that you need.
03:20 - Also, if you're looking for the code snippet that we reference in the course,
03:24 - you will find them all below here in the readme file.
03:28 - We just have a couple of snippets that you will want to have access to while doing this course.
03:33 - And more importantly, while doing this tutorial,
03:36 - you'll be able to ask questions in the comments for the video on FreeCodeCamp channel,
03:41 - as well as I'm going to create a thread on the forum to be able to answer questions there as well.
03:47 - So let's jump to it and build cool things.
03:50 - Before we get started, let's go over some of the prerequisites.
03:53 - Although I made this course with beginners in mind,
03:56 - you should have some basic understanding of basic programming, like HTML, CSS, and JavaScript.
04:01 - Also, you should feel comfortable around your computer,
04:04 - like opening a terminal and being able to install basic packages.
04:08 - You should have Node installed, and that should be enough.
04:11 - With that being said, the focus of this course is to really
04:14 - improve our understanding of remix and Strapi.
04:17 - And that's what we're going to do.
04:18 - With that out of the way, let's get started.
04:20 - Let's navigate to remix.run and click the Get Started button.
04:24 - We're going to navigate to this tutorial.
04:27 - We're going to start here because I want everybody to start with the basics of remix.
04:31 - We're going to do this tutorial together,
04:33 - and then I'll show you how to hook up Strapi to this project.
04:36 - The reason why I'm using documentation is because I want everybody to feel comfortable
04:40 - that documentation is your friend.
04:42 - And whenever you get stuck,
04:43 - these are the resources that you have available for you to help you get unstuck.
04:47 - So we're going to work through this together.
04:49 - But if you run into any issues, you can always reference the documentation.
04:54 - It is amazing.
04:55 - But with that being said, back in our remix tutorial,
04:58 - let's navigate to the bottom here where we could see this
05:02 - Generate Basic Template command.
05:04 - And this is what we're going to use to get started.
05:06 - So I'm going to go ahead and copy it.
05:08 - Inside my terminal, I already created a folder for my project.
05:12 - I'm going to go ahead and paste that command and click enter.
05:16 - This is going to go ahead and start creating our project.
05:19 - I'm just going to keep this the same, click enter,
05:21 - and it's going to go ahead and create your project.
05:24 - It's going to ask you if you want to initialize a new Git repository.
05:27 - You could say yes, install dependencies 1NPM,
05:30 - click yes, and it's going to go ahead and create your project.
05:34 - Once your project is installed,
05:36 - you could type LS to see the newly created folder.
05:39 - We could CD into that folder,
05:42 - and we could open our project inside VS Code by running code, period.
05:47 - And here you are.
05:48 - You have your remix project.
05:50 - The most important part to keep in mind
05:52 - is that we're going to be working inside this app directory.
05:55 - We have our basic app CSS.
05:57 - We have our data file that came with this template
06:00 - to allow us to simulate that we are connected to the database
06:05 - when we're making our basic requests.
06:07 - And our project starts from this root.
06:11 - And here you see all the basic JSX that will render our pages.
06:16 - And this is just a starting point,
06:18 - and we'll learn more about this as we continue.
06:20 - And we could run our project by running NPM run dev.
06:25 - This is going to start our project in development and environment.
06:28 - So let's take a look and see what we have so far.
06:31 - So what do we have here?
06:32 - Not much, because this is just the beginning of our project,
06:35 - but we have our basic input form and a button
06:38 - to submit our form with a list of few items.
06:42 - And this is coming from our root.dsx file,
06:45 - which is the entry point to our application.
06:48 - And we'll talk more on this later.
06:49 - But right now, as you could see inside our body element,
06:52 - we have our input and we have our button as well as our list items.
06:58 - So now that our app is set up,
06:59 - let's take a look at the root route
07:02 - and adding our link to link to our style sheet.
07:05 - Root.dsx is our root route,
07:07 - and it's typically what is rendered first.
07:10 - And this is where you would put your layout if you wanted to.
07:13 - So here's our root route, and this is where we have our sidebar.
07:16 - We could add additional elements such as a header or a footer
07:21 - and an outlet component that would render all other routes,
07:25 - which we'll talk a little bit more about it.
07:27 - But for now, let's take a look how we could add CSS to our project.
07:31 - To import our CSS into our remix application,
07:35 - we're going to use the links tag.
07:37 - You could read more about it in the documentation.
07:39 - We're also going to need to get its types.
07:42 - And then finally, we want to import our style sheet that we want to use.
07:46 - And we're going to use our links function to inject it inside our HTML.
07:52 - So now let's add these changes in our app.
07:54 - We are already importing our links.
07:57 - So in the top, let's import our links function types.
08:02 - Now let's import our style sheet.
08:04 - That's found in the app under app.css file.
08:08 - This is where you could find all the styles used in this application.
08:12 - And finally, let's use our links function to import our styles.
08:17 - Now let's refresh your application.
08:19 - Beautiful.
08:20 - And now you could see our style sheet is being applied.
08:23 - Now that our application is taking shape,
08:25 - we probably want to navigate to other pages.
08:27 - So let's give it a try.
08:28 - Let's click on your name.
08:30 - Oh my gosh, it is throwing a 404.
08:32 - But notice that we're going to a URL context slash one.
08:38 - So inside our application, if you scroll down, we see our anchor tags.
08:42 - When we click on the anchor tag, it changes our URL to context slash one.
08:48 - The reason why it's not found is because we don't have any routes that represent that.
08:53 - So let's go ahead inside our app folder, create a new folder called routes.
09:00 - And inside our routes, let's create a new file.
09:03 - And we're going to call it contacts dot TSX.
09:08 - And now let's create a very basic component here.
09:10 - I'm going to call it contacts route.
09:14 - And now let's go back to our application.
09:17 - And notice when I go to slash contacts, I don't see anything.
09:21 - Well, the reason that we don't see anything is because we don't have a way to tell remix.
09:26 - Hey, go ahead and show that route.
09:29 - So the way you would fix this is by using outlet.
09:32 - So in order to make this work, we're going to go ahead and import outlet from remix.
09:38 - Then we're going to use our outlet by creating a div where we're going to pass all of our children routes.
09:46 - So now let's make these changes in the code and see if we could see our newly generated route.
09:52 - So within our route dot TSX file, let's go ahead and import our outlet.
09:58 - And finally, let's scroll to the bottom.
10:02 - And after the sidebar div, we're going to add another div with ID of detail.
10:10 - And inside here, we're going to add our outlet.
10:13 - Let's refresh your application.
10:15 - And notice you're now able to see our contact route.
10:18 - We are making some excellent progress.
10:20 - Why don't you go make yourself some cup of coffee, take a little break or tea or water,
10:25 - whatever it is you like to drink.
10:27 - And then when you're back, we're going to take a look at how to create dynamic routes
10:32 - and use the link component to navigate.
10:35 - See you in a bit.
10:36 - All right, let's jump back into it.
10:38 - Currently in our application, we have two anchor tags, which are our links.
10:43 - So when we look at our application, we have your name, your friend.
10:46 - These are the links that we just saw in code.
10:48 - When I click them, we still fail because we don't have a route that
10:52 - matches the URL route that we're looking to get.
10:54 - So to fix this in our code, we're going to create two additional routes.
11:00 - So here I'm going to create a new file called contacts dot one.
11:06 - We'll use number one dot TSX.
11:09 - And then we're going to create another one new file called contacts dot two dot TSX.
11:16 - So looking at our link, we are navigating to context slash one, context slash two.
11:23 - And that's exactly what we did here.
11:25 - We define our routes whenever we use the dot separator in the routes.
11:29 - That basically means context slash one.
11:32 - So that's what you want to go.
11:34 - And let's go ahead, add some basic JSX here so we could see it here.
11:38 - So I'm going to say contact one route.
11:42 - And then I'm going to copy this same example.
11:45 - I'm going to go here and I'm going to say contact to route.
11:49 - So now when we go back into our example and we click your name, we get contact route,
11:56 - contact to route, it doesn't fail anymore.
11:58 - But notice that we only see the contact route here.
12:02 - And so the way we could fix this is two ways.
12:05 - So we could either remove it and then we'll either match contact one contact two,
12:10 - or we could use this as a layout route.
12:13 - And to make this a layout route, I'm just going to say lay out contact route.
12:20 - And in order for us to render the items from our children routes,
12:24 - we would need to use an outlet.
12:27 - And let's put this under age one, just like so.
12:35 - So now when we go back, notice we have our layout route.
12:38 - And then we see both our your name, contact one, and your friend contact two.
12:43 - So notice when we are matching contacts and one, we are matching the contacts.
12:52 - That's why we're able to render this layout.
12:55 - And then we're also matching one.
12:57 - And that's why we would see contact one route inside there.
13:01 - Now, for instance, if you did not want to have a layout route,
13:04 - you could just remove this.
13:06 - And this is what we're going to do for now.
13:08 - So now when we go to your name, we're just going to see
13:12 - just those routes for contact one and contact two.
13:16 - But the issue is that this could be contact one.
13:18 - This could be contact 32.
13:20 - This could be 57.
13:21 - And so the idea is like we don't want to continue to make routes
13:24 - from one to 50 or 70, however many items you might have.
13:28 - So in this case, we want to use a dynamic route.
13:32 - And the way we create a dynamic route is that we,
13:36 - instead of passing a one, we could signify a dynamic parameter
13:42 - by using dollar sign.
13:44 - And we're going to say contact ID.
13:47 - And now when we do this, we could remove this one and delete.
13:51 - And I'm going to refactor this to say contact dynamic route,
13:58 - just so we could clearly know what route we're in.
14:01 - And I'm going to say contact dynamic route.
14:05 - And so now when we go back to our application,
14:08 - regardless if we go to your name, your friend,
14:11 - they're both going to render.
14:12 - Now that we know how dynamic routes work in Remix,
14:16 - let's go ahead and set up our contacts ID TSX file
14:21 - by importing this existing code.
14:23 - Now, if you're following via this documentation,
14:27 - you could paste it from here.
14:28 - But I'm also going to create these gist just with the code snippets
14:32 - that you need.
14:32 - And I'll make sure to have them in the link in the description below.
14:37 - So make sure you copy the code.
14:39 - And let's inside VS code in our contact ID.TSX file.
14:46 - And now let's go ahead and paste that boiler code here.
14:50 - And we'll go through it in a little bit.
14:53 - But first, let's check it out and see if it worked.
14:56 - So now if we refresh our application,
14:59 - notice for our dynamic route,
15:02 - we now see this boiler plate that we will update as necessary.
15:07 - But before we could update it, we need to learn how to load data.
15:11 - So let's first review how you can use a loader function
15:15 - to add data to your Remix application
15:18 - that you could get from either external API
15:21 - or from making a direct call to your database,
15:24 - or in our case, in this example application, our dummy data.
15:28 - In Remix, we have a loader function that allows you to load your data.
15:32 - So let's take a look at a basic implementation
15:35 - before we continue with this tutorial.
15:37 - We can access a loader function by exporting it in our application.
15:42 - So for instance, here, we're going to export a sync function, call it loader.
15:47 - And inside the return, we could return the data that we want.
15:50 - And right now we are returning this dummy data,
15:53 - but this loader function runs on the server
15:56 - and we could make an API call or call to the database
15:59 - to retrieve the data that we need.
16:01 - Once we declare our loader function,
16:03 - next we're going to import our use loader data hook
16:07 - that allows us to get our data from the loader.
16:10 - So notice how we are using use loader data hook
16:14 - and saving it to a data variable which will have our data.
16:18 - So let's see how this is going to look in our code.
16:21 - So inside our root.tsx file,
16:24 - we're going to first import use loader data from remix.
16:30 - Then we're going to define our basic loader function.
16:34 - And in order for us to get that data,
16:36 - we are going to use our use loader data hook
16:39 - and we're going to give it a type of loader.
16:43 - So TypeScript doesn't complain.
16:45 - And now let's go ahead and console.log our data.
16:50 - And notice we get our data that we are passing
16:54 - from our loader function.
16:56 - So now let's see how we could load all of our users
16:59 - to populate our left sidebar here.
17:01 - So inside our root.tsx file,
17:04 - first we're going to import get contacts from that data.
17:08 - This is available in your application.
17:11 - If you go inside that data and you search for get contacts,
17:17 - you're going to see this function.
17:19 - And what it's doing,
17:20 - it's getting our data to populate our users.
17:25 - And currently this data is stored in our application.
17:29 - But as we continue,
17:30 - we'll show you how to get this data from our Strapi API.
17:34 - So now inside our loader function,
17:36 - let's go ahead and use our get contacts function.
17:40 - So we're going to say const contacts
17:43 - and we're going to await our get contacts.
17:46 - And we're going to go ahead and return.
17:49 - Now whenever you're returning items from the loader function,
17:54 - it actually returns as a response.
17:56 - So remix has a helpful function for us
18:00 - that allows us to return this response
18:03 - with all the appropriate headers within.
18:05 - So that's what we're going to do.
18:07 - We're going to say return contacts.
18:09 - Now when we take a look at our console.log,
18:11 - notice we get an array of all of our users.
18:14 - So now let's update our return code
18:18 - to allow us to visualize the data that we just received.
18:22 - You can find the code snippet inside the remix tutorial here.
18:26 - And we're going to copy the contacts code snippet here
18:30 - and we're going to paste inside of our application.
18:33 - Now if you're not following this tutorial,
18:35 - which you should use it as reference,
18:37 - I'm also going to have these jists
18:38 - that I'm going to put in the description below as well,
18:41 - just so you could find the code snippets.
18:43 - If for some reason you can't find them.
18:45 - So inside my application,
18:47 - I am going to scroll down to our navigation here
18:52 - and I'm going to replace the code within the UL.
18:56 - And I'm going to paste it in.
18:59 - And we just have to rename our use loaded data
19:04 - that we're getting here.
19:04 - Instead of data, we're going to call it contacts
19:07 - and we could remove this console.log.
19:09 - And now when we navigate back to our application,
19:12 - notice we have all of the items coming from our fake database,
19:16 - which is pretty awesome.
19:17 - So let's do a quick recap before we move on.
19:20 - So to recap, we imported our loader function
19:24 - that allows us to call a method that either connects
19:27 - your database or makes an API request to get our data.
19:30 - Then we return our data using the JSON method,
19:35 - which allows us to return it as a response
19:38 - with all the appropriate headers.
19:39 - You could learn more about it on the remix documentation,
19:42 - but it is being imported from at remix-run-node package.
19:48 - Once we get that data back,
19:50 - we're using the use loaded data hook to save that data
19:54 - into contacts and then we're iterating through those contacts,
19:58 - mapping through them and rendering our links.
20:01 - And this is what we see here.
20:02 - So next, we're going to take a look how we could click
20:05 - on any one of these individual links.
20:07 - And notice as we click them, the URL changes.
20:10 - So in order to be able to display the items here
20:14 - in our details page, which we're going to create to,
20:17 - we need to figure out how we could access
20:20 - the URL params to allow us to do that.
20:22 - And that's exactly what we're going to do in the next section.
20:25 - So from our root.tsx file, let's go ahead and copy
20:28 - our loader function inside our contact ID.tsx file,
20:32 - which is our dynamic route after line five.
20:35 - Let's go ahead and import our loader.
20:37 - Now, if you take a look inside our data.ts file,
20:42 - you're going to see that we have get contact method
20:45 - that expects an ID, which is a string,
20:47 - which will return one item for based on the ID that we pass.
20:51 - So inside our contacts.id.tsx, let's first go ahead
20:56 - and import our get contact from data.
21:01 - Now let's refactor this to reflect
21:04 - that we're only getting one item.
21:06 - Now it's complaining that we did not import our JSON method.
21:10 - So let's go ahead and import it from remix.
21:13 - And now we need to provide an ID.
21:15 - So you're wondering, where do we find the ID?
21:19 - So the ID is based on this dynamic attribute that we have.
21:23 - So in the loader, we have access to the params
21:27 - and TypeScript is going to complain
21:29 - because we need to import the params
21:33 - and you could import them from remix.
21:36 - So we say we need type of loader function arcs
21:41 - and let's make sure that we add it here.
21:44 - Perfect.
21:44 - So now TypeScript is not complaining.
21:46 - And finally, if we take a look at our params,
21:49 - I'm just going to console log for now.
21:52 - Notice that we have an object and the key is contact ID
21:56 - and then it has the name of the item
21:58 - that we are searching for.
22:00 - And if you're wondering where that name was defined,
22:02 - it was defined here.
22:04 - So any time in our application,
22:06 - when our URL params change,
22:08 - notice how they're changing here.
22:09 - For instance, I'm going to go to me, Paul Bratislavski, right here.
22:13 - If we take a look in our code,
22:15 - notice the param that we get is Paul Bratislavski.
22:18 - So now I'm able to access that.
22:20 - So we're going to go ahead and here,
22:23 - just going to do const contact ID equals params
22:28 - and we're pulling that contact ID
22:30 - and we're going to pass that contact ID
22:33 - to our method to get our data.
22:36 - Now, right now it's complaining.
22:37 - What if contact ID is not defined?
22:40 - So we probably should do a check to see if it exists first.
22:44 - You could find this package on npm
22:46 - and read more about what it does.
22:48 - But it makes it an easy way for us to check
22:51 - if an item is false or not.
22:53 - And if so, it will throw an error.
22:56 - So let's go ahead, copy the install script
22:59 - in my terminal.
23:00 - I'm going to paste the script in and install.
23:03 - Once the script install,
23:04 - I'm going to restart my project by running yarn dev.
23:07 - And now we could add a check to see if the params exist.
23:12 - So we're going to use the invariant method.
23:14 - We're going to pass the params that contact ID.
23:17 - If it doesn't exist, we're going to return an error message.
23:20 - And if so, we're going to continue
23:22 - and notice how the error goes away.
23:25 - Whenever we return our contact,
23:27 - maybe we don't have any contacts.
23:30 - So we should do a check.
23:31 - So we're going to do if no contact found.
23:34 - Let's throw a new response with not found and return 404.
23:38 - Some people like to do the if statement with the brackets.
23:43 - But for me, it just makes my brain feel much easier
23:47 - when I remove the brackets for one-liners.
23:50 - And in my mind, it's just easier to read.
23:52 - Should you do this? I don't know.
23:53 - But this is what I'm going to do here.
23:54 - And now that we are getting our contacts,
23:57 - we're going to import our use loader data.
24:01 - And inside our component, we're going to go ahead and say
24:06 - const contact equals use loader data type of data loader.
24:11 - And we're going to remove this dummy text that we have here.
24:15 - So now let's do a quick recap.
24:17 - We are using our loader.
24:20 - We're calling our get contact method
24:22 - where we're passing our ID that comes from our params.
24:26 - If we don't have a contact, we're going to throw a not found.
24:30 - And if we do have a contact, we're going to return it here
24:33 - inside our contact that we're going to pass to our code below.
24:38 - So now let's navigate to a browser and see if it worked.
24:41 - Great. Look at this. This works.
24:43 - We are able to get all of our data coming from our phony data API.
24:49 - So in the next video, before continuing with this tutorial,
24:52 - let's actually go ahead and set up Strapi to show us
24:55 - how we could get data from an actual API endpoint.
24:58 - This way, you're going to have your front end with remix,
25:01 - and you're going to have Strapi as your backend.
25:04 - So before we install Strapi, go ahead and grab another cup of coffee
25:09 - or tea or whatever you like to consume.
25:12 - Take a little breather, take a little break,
25:14 - think about all the things that we've done,
25:16 - and then come back and we'll be ready to set up Strapi to set up our API.
25:20 - And you'll see it's going to go so quick,
25:23 - because Strapi allows you to create your API in minutes,
25:26 - and I'm really, really excited to show you how to do that.
25:28 - All right, and welcome back.
25:30 - Today, we're going to take a look on how to set up Strapi.
25:33 - Strapi allows you to create an API in minutes, but what's awesome,
25:37 - it's easy to get started.
25:38 - But also, if you need additional customization,
25:41 - if you want to dive deep, add additional functionality,
25:45 - add extra middleware controllers policies,
25:48 - you are able to do that.
25:49 - But what's awesome for beginners,
25:51 - you could get started with it right as it is
25:54 - to create an amazing backend for your project
25:57 - that's going to have this amazing admin area.
26:00 - So just like we've been using our remix documentation,
26:03 - Strapi has amazing documentation as well.
26:06 - So you could always reference it when you get stuck,
26:10 - but we're going to jump right into it.
26:12 - So it's very easy to get started.
26:14 - We're going to use the NPX Create Strapi app at latest
26:17 - to get our project going.
26:19 - So inside my terminal, currently I'm in my Remix folder.
26:24 - So I'm going to move one level down into the root of my project.
26:28 - And notice how we have our My Remix app.
26:31 - So now I'm going to use NPX Create Strapi app at latest.
26:38 - And we're going to call it my Strapi app
26:41 - just to stay consistent with our naming.
26:44 - Are there good names? I don't know.
26:45 - And you could choose Quick Start,
26:47 - but I'm not going to do it
26:48 - just to show you some of the options that you'll see.
26:50 - So this is going to ask, do you want to get started?
26:53 - Yeah, sure. Yes.
26:54 - Let's download the following packages and install them.
26:56 - Once the process is all set, you have the Quick Start option,
27:00 - but you also have the custom options.
27:01 - So let's take a look.
27:02 - Custom options allow you to choose
27:04 - if you're on use JavaScript or TypeScript.
27:06 - In that case, we're going to stick with JavaScript for the moment.
27:08 - And here you have your options of different databases.
27:11 - You can use SQLite, Postgres, or MySQL.
27:14 - I'm going to stick with SQLite.
27:15 - Yes, that sounds good for the database,
27:18 - where to save the files locally.
27:20 - And it's going to go ahead and create our Strapi application.
27:24 - Now that our application has installed,
27:26 - I'm going to cd into my Strapi project,
27:30 - and I'm going to run yarn develop.
27:33 - So because this is our first time starting our Strapi application,
27:36 - we have to create our first admin user.
27:38 - So I'm going to do Paul Bratz from coding after 30 at gmail.com.
27:47 - Let's do password monkey1234.
27:49 - Since this is running locally, that sounds secure enough.
27:52 - No one's going to guess monkey1234 ever.
27:55 - Let's click Start.
27:56 - And now we set up our Strapi application on the dashboard.
28:00 - So let's do a quick tour on the Content Manager.
28:03 - This is where you want to see all your content types
28:05 - and collection types that you have created.
28:07 - Currently, we have just the user collection type that has no users yet.
28:11 - And if we take a look at the content type builder,
28:14 - this is where you actually are able to create new collection types,
28:17 - content types, which we'll learn more as we continue through this tutorial.
28:21 - You could see that our user collection type,
28:23 - here's some of the fields that it has, username, text, email, and so on.
28:27 - And we will create a new collection shortly.
28:29 - But first, let's just finish up this quick little exploration of Strapi admin area.
28:35 - Here, we have our media library.
28:37 - All your files that are stored in Strapi will show up here.
28:40 - Afterwards, we have our plugins.
28:42 - If you have any additional plugins installed, you're going to see them here.
28:45 - And an example of a plugin, for instance, if you want to extend function on Strapi
28:49 - and store your files in Cloudinary, you could install Strapi Cloudinary plugin
28:54 - that allows you to do that.
28:56 - And if you're trying to figure out where to find these awesome plugins,
28:58 - you could always check out the marketplace.
29:00 - And if I say search for Cloudinary, and it's going to be a provider.
29:05 - And here, you could see the Cloudinary provider.
29:07 - And if you want to install it, you could copy the command and install it.
29:10 - And then we're going to take a look under settings.
29:12 - We have our general overview, all the details about our application,
29:16 - a couple of different options, the ones that we're going to use most.
29:20 - This tutorial is on the roles.
29:22 - On the roles, you are able to define which endpoints have permissions.
29:27 - And you could either say they're publicly,
29:29 - meaning there's no authentication required, or you could make them authenticate it.
29:33 - And this is something we'll dive into deeper.
29:36 - With that being said, let's go ahead and create our first collection type.
29:40 - So in our current application, if we go into apps,
29:43 - and we take a look at our data.ts file, we're going to see our types for our contacts.
29:49 - So we know that we need to have an ID, a first name, which is a string,
29:53 - last name is a string, we have an avatar, which is a string,
29:55 - which represents the URL for where we're going to store the image.
29:59 - Then we have Twitter and notes and favorites is a Boolean.
30:03 - So what we could do is we could actually create our Strapi collection type for our users.
30:08 - So within Strapi application, let's navigate to content type builder.
30:12 - And we're going to create a new collection.
30:14 - If you have like many users, many products, you would create a collection type.
30:18 - If you have, let's say, a single item, like a settings page, or what have you,
30:23 - you could use create new single types.
30:25 - But we're going to start here, click create new collection type,
30:28 - and we're going to call it contact and click continue.
30:32 - And now you'll see all these different fields that you have available to structure your data.
30:36 - For instance, you have your text, which is a string, you have your Boolean,
30:40 - you have your different editors available to you.
30:43 - We have your JSON data, you could represent emails, passwords, numbers, dates, media,
30:48 - enums, UI ID, different relationships.
30:51 - And we have a markdown text editor, as well as you could create components that dynamic cells,
30:56 - which we will talk much later when we work on our Cornerstorm project
31:00 - after we're done with this remix of Strapi introduction.
31:03 - So for this, we're going to use text.
31:06 - And for our first name, we're going to say first, and let's click another,
31:10 - do another text field, it's going to be last for the last name.
31:14 - Add another field, let's take a look at what we have here.
31:16 - So we did first, we did last, we have avatar,
31:19 - which is going to be for our image URL.
31:21 - So let's do text, say avatar, add another field.
31:25 - We need Twitter, let's copy Twitter text, also going to be for the Twitter feed.
31:32 - And then we have notes.
31:34 - So we're going to do text, we're going to call it note.
31:38 - I think it's notes or note, we have notes.
31:41 - Okay, let's say we call it notes, and it's going to be long text.
31:45 - And let's see, do we need anything else?
31:47 - And yes, we do.
31:49 - So add another field, and we're going to have a Boolean
31:53 - to signify that this is something that we favored it.
31:57 - And I think that is all we need.
32:00 - So check this out.
32:01 - We're going to click finish, click save.
32:03 - And now when we take a look at our content manager,
32:07 - we now see our newly created collection type content.
32:10 - So if I click on it, create a new entry, I'm able to add my information.
32:15 - I'm going to say Paul, Bratz, I have a URL here for my image.
32:20 - And I'm going to go ahead and say hello from Strapi.
32:25 - And we'll say true for our Boolean, click save and publish.
32:30 - So now if we want to give permission to users to be able to get this data,
32:35 - we are going to go into settings on the roles.
32:38 - And we're going to say it's publicly available.
32:41 - And now you're going to see all the different available API endpoints that we have.
32:45 - And this is our newly created contact endpoint.
32:48 - So if I click on it, we're able to give permission for create, delete,
32:52 - find, find one and update.
32:54 - So we're going to go for both find and find one and click save.
32:58 - And notice now that if we navigate to our Strapi application endpoint slash API contacts,
33:07 - because we gave the permission, we are going to see our API response.
33:12 - So we literally created our backend and we now have a working endpoint
33:17 - that allows us to get our data.
33:20 - So now let's see how we could get this data inside our remix application.
33:25 - Inside our data.ts file, we're going to make all the changes.
33:29 - By the way, in remix, you could define if your files run on the server or on the client.
33:35 - For our data fetching file, we want it to all run on the server.
33:38 - So I could be specific by renaming this file data.server.ts.
33:44 - And this is going to go ahead and it's going to run all this code server side, which is awesome.
33:50 - So now within our data.server.ts file, let's refactor it a little bit.
33:54 - We're going to delete this top part.
33:57 - We're going to keep the type definition here for now.
34:00 - And then let's scroll down to get contacts.
34:05 - And let's delete everything from get contacts to the export type here.
34:10 - And now within all of these functions that are getting that fake data,
34:14 - we're actually going to delete all the code inside and just leave them as placement functions
34:20 - to make our changes to reflect getting data from Strapi.
34:24 - And I'm going to do it for update contacts as well.
34:27 - And we're going to do it for delete as well.
34:29 - And this array here, we're going to save to a variable,
34:33 - which we'll use later as reference.
34:35 - And if you scroll all the way down to the end,
34:37 - you're going to see that we have this dot for each.
34:41 - We don't need it, just remove it.
34:43 - Nice.
34:43 - Now that we have refactored our data.server.ts file,
34:48 - we could start implementing our new code.
34:50 - So within get contacts function, we're going to go ahead and create a try catch block.
34:56 - And if there's an error, we're just going to console log that error.
35:00 - Nice.
35:01 - And within the try block, we're going to do const response.
35:05 - And it's going to equal to await.
35:07 - And we're going to use fetch.
35:09 - Once we fetch the data, we're going to get the JSON.
35:13 - So you're going to do data equals await response dot JSON.
35:20 - And inside our fetch, we're going to pass our Strapi app URL.
35:25 - And to that, we're going to append our endpoint,
35:28 - which is going to be API slash contacts to get our data.
35:33 - Now let's add our URL variable.
35:37 - Basically, I'll check, do we have a Strap URL in the parameter?
35:41 - If we do use that, if not default to local host, which is perfectly fine.
35:46 - And when we get this data from Strapi,
35:49 - if you look at the structure, we have data ID attributes and so on.
35:53 - But what I want to do is I want to flatten this response.
35:57 - So we have the data object.
35:59 - And instead of attributes, we just have the attributes.
36:02 - And this is helpful that if we were getting nested data,
36:06 - it would also have data attribute, data attribute, and so on.
36:08 - And so by flattening it, it makes it a little bit much more easier
36:12 - to use in our response.
36:13 - I also like this idea of having an intermediary function
36:16 - that allows us to define the structure of our return.
36:20 - So that way, when we make changes in our API,
36:23 - instead of having to redo our whole frontend,
36:26 - we could just rewrite our transform function.
36:29 - And I already have this flatten attribute function
36:31 - that I wrote that I'm going to share either in this gist
36:35 - or in our accompanying blog post,
36:38 - which you could use when doing this tutorial,
36:40 - as well as the final project.
36:41 - And let's go ahead and paste this function above our URL here.
36:45 - And we're going to minimize it so it doesn't act like a big eyesore.
36:50 - And now here, we're going to do another variable
36:52 - called const flatten attributes data.
36:56 - And that's going to come from our flattened attributes function
37:00 - that we imported.
37:01 - And it's going to get our data.
37:03 - And this data object is going to have our data
37:06 - and our meta information.
37:07 - So we just want the data.
37:09 - And finally, we're going to return our flattened attributes data response.
37:15 - Now, because we updated this file to be called data.server,
37:20 - we need to navigate to root.tsx and make sure that we make that change.
37:26 - We also did the same thing inside our contact ID TSX file.
37:31 - So make sure that we rename the imports accordingly.
37:35 - So server and same thing that server.
37:39 - So now let's see if we're able to get our Strapi data.
37:42 - I'm going to restart my Strapi application by running yarn develop.
37:47 - Once your Strapi instance is running,
37:48 - go ahead and restart your remix app by running yarn dev.
37:53 - Great.
37:54 - Now we're getting our data.
37:55 - And where is this data coming from?
37:57 - It's coming from our Strapi application.
37:59 - So check this out.
38:00 - If I go to my Strapi instance on the contacts,
38:03 - I click Paul and I'm going to change to my full last name.
38:08 - And we're going to take the star way by setting this to false.
38:11 - Click save.
38:12 - And when we go back to our application and refresh,
38:15 - notice we have our changes.
38:17 - So next let's fix us being able to get our single entry.
38:21 - Because right now if we click Paul Wyslowski,
38:23 - we get not found because currently we broke our application.
38:27 - Because instead of getting our dummy data,
38:29 - we are now looking to pull data from Strapi.
38:32 - So let's go into the code and fix this first.
38:34 - But first inside our Strapi application,
38:36 - let's go under settings, roles, public, and click on contact.
38:41 - Whenever we found all of our items, we use the find endpoint.
38:45 - And that's found by going to API slash contacts.
38:49 - Whenever we pass a parameter like one, the ID of our contact,
38:53 - it's going to look for that single entry.
38:56 - And notice that instead of returning an array, it returns an object.
39:01 - So that's the endpoint we're going to look to use.
39:04 - So if we could take a look here,
39:05 - we need to go to API slash contacts and provide the ID.
39:11 - So let's click save and within our code editor.
39:15 - And navigate to data.server.ts file.
39:18 - Our endpoint code is going to be similar to this code that we have here.
39:22 - So I'm going to copy it.
39:23 - Let's go to the get contacts by ID here.
39:28 - I'm going to open this code block and I'm going to paste in our code.
39:32 - And I must have missed the closing bracket there.
39:35 - So let's go and add that.
39:36 - We are going to be making a request to contacts.
39:39 - And the only difference is we now have to append our ID.
39:45 - Which we're going to get from this parameter.
39:48 - Everything else should be the same.
39:50 - So now let's go ahead and navigate to our single contact ID page here.
39:56 - And we're still getting our params using our param attribute in our loader function
40:01 - and repassing that ID to get contact.
40:04 - So that should have been an easy fix.
40:06 - We should now see the data.
40:08 - Now let's see if it worked.
40:09 - So back in our app, which originally was throwing a 404.
40:13 - Let's refresh.
40:14 - And Norris, now we are able to get our data.
40:16 - So now before handling edit, delete, or star our user,
40:21 - we want to have the ability to add the users.
40:23 - So let's connect the behavior to our new button.
40:26 - If we currently click our new button, we get four or five method not allowed.
40:30 - That's because we are going to use strappy to allows create users
40:34 - and save them to our database.
40:35 - So let's get started.
40:36 - Inside our code, inside the app folder, under root, navigate to the submit button here.
40:44 - Instead of using a button here, we're just going to have a link to a new form
40:47 - that we're going to create.
40:48 - So we're going to say link to and we're going to link to contacts slash create.
40:56 - And we're going to say create.
40:58 - Currently this route doesn't exist.
41:00 - So let's go ahead and make it inside our routes folder.
41:03 - Let's create a new file and we're going to call it contacts dot create dot TSX.
41:09 - We're going to create a very simple placeholder component.
41:12 - And we're going to call it create route.
41:14 - We could remove this react import since we're not using it.
41:18 - And now that we have this placeholder route, we could test it.
41:22 - So let's go back.
41:23 - So in our application, if I click new now, we'll fix the styling in a little bit,
41:28 - but let's check it out.
41:29 - If we click create Norris, now it takes us to a create route.
41:33 - So let's add a class to our link here.
41:36 - We're going to say class name equals button link.
41:41 - And we're going to navigate to our app that CSS file found inside the app folder.
41:47 - And we're going to copy some of the stylings for our new button link class.
41:52 - So I'm going to say button link and we're going to copy all of this button code,
41:57 - as well as this color and font weight.
42:03 - Now that we have our new button link class,
42:06 - this should apply these changes to our new link component.
42:10 - So Norris, that I create button looks pretty good.
42:13 - It's almost done.
42:14 - The last thing we need to do is remove the styling.
42:17 - And under font weight, let's do text decoration and it will be none.
42:23 - And Norris, our button now looks normal.
42:25 - And whenever we click create again, it takes us to our create page.
42:30 - So in our project, let's navigate to our routes context that create that TSX file.
42:36 - Here's where we had our placeholder text.
42:38 - What we're going to do now, just to make it easier for ourselves,
42:41 - we're going to paste a snippet.
42:43 - All the snippets I will make sure to link in the description of the video
42:46 - to all the gist that I'm using.
42:48 - And in this case, it is our remix create form starter.
42:52 - I'm going to click raw, do control A copy all to select all the code and control C to copy.
42:59 - And then let's navigate back to our code editor and paste it in.
43:04 - All this does is paste our basic boilerplate that we need for this form.
43:08 - I created a form input component and basically is just a flexible component
43:15 - to allow us to quickly define our input elements.
43:18 - But the part that you want to focus on is the our input is using the name attribute.
43:25 - That's very important.
43:26 - If you notice, we don't have any use state or use effect or any react ways to create a
43:32 - controlled form where we pass an unchanged.
43:35 - So you're wondering where well, how are we getting our form data?
43:39 - Well, we're using standard web form API.
43:42 - So whenever you submit a form is going to pass the values in the URL.
43:48 - So we'll have the name plus the value that we have in the form.
43:52 - So let me just show you what I mean before implementing the code.
43:56 - Remix handles form submission similar the way it is done traditionally using the form tag.
44:03 - This may be unfamiliar to some newer developers, but HTML form causes navigation similar to a link.
44:10 - The only difference is that you have the ability to change the request method get via or post.
44:17 - So let's take a look at what this means.
44:19 - Here's a simple form example, and this is using the classical way of just submitting the form
44:24 - and the action refers to an endpoint which is going to do something with the data.
44:28 - In this case, they're using get.
44:30 - The form data can be sent either as a URL variable when using method get or as a HTTP
44:38 - post transaction when using method post.
44:41 - When using the get request, and this is the example we're going to take a look at,
44:45 - the form data will be appended to the URL.
44:49 - If we were to make a post request, that form data would be appended to the body of the HTTP request.
44:55 - So if we take a look at this example, when I put Paul Bratz and click submit,
45:02 - notice that in the URL, our form data is being passed inside our code.
45:09 - If I do action equals test and method equals get, let's try submitting our form.
45:18 - So within our application, we're going to do Paul Bratz and click create.
45:23 - Since this test standpoint doesn't exist, we see 404 not found,
45:29 - but you could see that we have our first name Paul and last name Bratz.
45:33 - Remix has a form component that basically does the same thing.
45:37 - The only difference is, except of sending the request to the server,
45:42 - it uses the client side routing and sends it to the routes action function,
45:47 - which we're going to talk about in a little bit.
45:49 - So let's take a look at this quick remix example.
45:52 - Whenever you want to create, delete, or update data on your website,
45:55 - we will be making a post request.
45:58 - So we have our basic form already set up.
46:00 - So the next thing we need to do is create an action.
46:03 - In this case, they're defining an action in a separate file,
46:07 - but we're actually going to define our action inside the same file that we're working.
46:13 - So in order to create a function, we just need to export a sync function called action.
46:18 - So let's go ahead and do that.
46:20 - Inside my code, I'm going to type export sync function, and it's going to be called action.
46:28 - And we have the request available to us,
46:32 - and we do need to import action function arcs type.
46:35 - So let's go ahead and do that.
46:37 - We're going to say request, and let's import type action function arcs.
46:45 - Now we're able to access our form data from our request object.
46:50 - So we're going to say await request dot form data.
46:55 - There's multiple ways to get the data, but we're going to use the simplest one.
46:59 - We're going to say const data equals, and we're going to use object dot from entries.
47:06 - And we're going to pass in our form data.
47:11 - And all we're going to do is just return our data.
47:16 - In order to see the response from our action, we need to use a hook.
47:20 - And the hook is called use action data.
47:24 - So under navigate, I could do const form data equals use action data.
47:31 - And let's console log it.
47:33 - So currently, it's going to be undefined,
47:36 - because we don't have any submissions to our form.
47:39 - So let's import form.
47:42 - And here we're going to replace the HTML element with the remix form method is going to be post.
47:50 - And we're not going to define an action.
47:52 - Whenever you don't define an action, wherever the form is submitted,
47:56 - it's going to go ahead and look for the nearest declared action that we have in the same file.
48:00 - So now let's give this a test.
48:02 - So my application, I'm going to say Paul bratz at Twitter,
48:08 - HTTP, some image that JPEG.
48:13 - And hey, so now that we click create, we don't visually see anything here.
48:17 - But let's check out our console log noise that we have the output for our data.
48:23 - First name Paul last name bratz, Twitter avatar, and our note.
48:28 - And that's all coming from our form.
48:30 - And so the recap quickly before we continue,
48:33 - whenever submitting forms and remix,
48:36 - we're literally using the traditional method of submitting forms.
48:40 - We define what type of requests we want.
48:42 - In this case is post when we're using the post request.
48:46 - As we learn that data will be appended to our body of the HTTP request,
48:52 - and we have access to it in our request.
48:55 - So in remix, when we were submitting the form,
49:00 - we were able to get the data using the form data method on the request and save it.
49:07 - So now that we're able to get our form data to our action,
49:12 - we will be able to make an API call to save the data to DB using strappy.
49:24 - And that's exactly what we're going to do next.
49:26 - So taking a look at a strappy application,
49:28 - if we go to settings under roles, take a look under public permissions,
49:33 - we're going to look at contacts, and we're going to enable create.
49:38 - And basically, in order to post data to strappy,
49:41 - we just need to make a post request to this API endpoint.
49:45 - So let's save to enable our ability to create posts.
49:49 - And before we add the code, let's check the strappy docs.
49:53 - You could navigate to strappy website, click get started,
49:56 - and it's going to take you to the docs.
49:57 - We're going to scroll down to APIs and click on REST API introduction.
50:02 - And here you could get more information on how all the different endpoints work.
50:06 - For instance, if you want to make a get request post request to create an item,
50:09 - that's what we're going to look at now, how to make get requests, put requests, and delete.
50:13 - So let's create create entry.
50:15 - Here's going to take us to an example to take a look what we need to do.
50:18 - And basically, we need to make a post request to the endpoint that we specified,
50:23 - in our case is going to be API contacts.
50:25 - And notice how we need to wrap it in data object and pass our attributes inside there.
50:31 - And that's exactly what we're going to do.
50:33 - And when the data is submitted correctly, you are going to get a response.
50:37 - Then we could check if we successfully submitted the form or return some errors
50:40 - that we're going to take a look in a little bit.
50:42 - So now let's go back into our code and let's navigate to our data.server.ts file.
50:48 - And the good news, we're going to follow a very similar pattern here.
50:52 - So I'm going to go to the get contacts.
50:55 - And I'm going to copy this whole try and catch block, because it's going to be very similar.
51:00 - And we're going to navigate to create empty contact.
51:03 - And this is actually going to be renamed to create contact,
51:06 - because we're not going to create an empty contact, we're going to create actual contact.
51:10 - And so what we're going to pass inside here is our data.
51:13 - And our data is going to be any right now.
51:16 - We'll come back and add typing later.
51:18 - But for now, let's just get stuff to work.
51:20 - And it's going to be a post request to our API contact.
51:25 - So if you don't pass any second parameters on fetch, it will automatically make a get request.
51:30 - But we want to make a post request.
51:32 - So we're going to add an additional object where we're going to pass the information that we need.
51:38 - So we're going to say method is going to be post.
51:41 - Then we have to define headers.
51:44 - It's going to be an object.
51:45 - So now let's define the content type.
51:49 - I can't speak and type at the same time.
51:51 - It's okay.
51:52 - And it's going to be application JSON.
51:55 - And finally, the last thing we need to do is pass our body.
51:59 - And we're going to wrap our data within a data object, just like we saw in the docs.
52:05 - And we're going to destructure our data that we're passing to our form.
52:09 - And then the most important thing, we need to wrap this in JSON.stringify
52:15 - to stringify our data being sent.
52:18 - And then this is complaining here.
52:20 - No big deal.
52:20 - We're going to change it to response data.
52:24 - And then we're going to change this to response data.
52:29 - Perfect.
52:29 - And then everything else should be all set.
52:32 - So basically what we're going to do, we're going to make a post request to our API slash
52:37 - contacts endpoint to allow us to send data that we get from our form to make a new entry.
52:44 - So now let's go ahead and add it to our contact create form.
52:49 - So we're going to remove our const log here.
52:52 - And we're going to say const new entry is going to await create contact.
53:00 - And into our create contact, we're going to pass our data object.
53:03 - And now let's import create contact.
53:06 - Import create contact from our data.server.js file.
53:11 - And finally, we're going to just return new entry.
53:16 - And we're going to const log the response after our data is created.
53:20 - And currently right now, there's a couple of things we do need to add.
53:23 - For instance, we should probably have form validation, which we'll do next.
53:27 - And probably if there's a successful entry creation, we should probably redirect.
53:32 - But for now, we're just going to test that it works to see that we are posting data to our
53:36 - Strapi endpoint and just make sure that we are able to get the const log in the response.
53:40 - So let's go ahead to our frontend application.
53:43 - We're going to navigate to our create form.
53:45 - I'm going to say test, test, test.
53:48 - And that's fine for now.
53:50 - We'll leave the other one blank.
53:51 - It's no big deal right now.
53:52 - We click create.
53:53 - So notice it posted our data because we were able to create it.
53:58 - And let's just check inside our Strapi instance.
54:02 - Navigate to content manager to contacts and notice that we are able to post.
54:08 - And what I hope that you really appreciate it is the fact that when we added a new item
54:14 - without doing anything, remix was smart enough to be able to automatically refresh your sidebar.
54:20 - We didn't have to store anything in context or state.
54:23 - It's just smart enough to do it.
54:25 - So if we create a new entry, let's say test two, we say create, boom, it's right there.
54:31 - So notice that we're able to get our data.
54:34 - And so notice we didn't pass an image.
54:37 - Maybe we should check that passing image is required.
54:39 - So we run into errors like this.
54:41 - So next we're going to take a look on form validation to improve our create form form.
54:48 - All right.
54:48 - We're making amazing progress.
54:50 - So next let's add some form validation to our form.
54:54 - And to do this, we're going to simplify the process by using ZOD.
54:58 - ZOD is a library that allows you to add form validation very, very easily or object validation.
55:04 - So we're going to go ahead and first install it.
55:06 - So I'm going to click on copy and paste the command.
55:10 - In my terminal inside our remix app, we're going to run the command and install it.
55:15 - Then let's restart our application by running yarn dev.
55:18 - Next inside our application, let's go ahead and import ZOD.
55:22 - Fantastic.
55:23 - And now we're able to use it.
55:25 - So let's navigate to ZOD homepage from our NPM.
55:28 - And let me make this bigger.
55:29 - And then we're going to get to basic usage here.
55:32 - And here just shows you kind of like the basic thing that we're going to do here.
55:36 - We import ZOD and then we're going to create a basic schema that's going to define our structure
55:44 - for our form data.
55:46 - And here we could take a look all the different checks we could do.
55:49 - We could check if it's a string, if it's a number, if it's a big end, if it's undefined, and so on.
55:54 - And you could read more about it on there.
55:57 - But right now, let's just jump into our example and get started.
56:01 - So one ZOD is important here inside our form.
56:04 - And right after our data, we're going to create const.
56:07 - And we're going to say form schema where we're going to define the structure of our schema.
56:12 - It's going to equal to using ZOD object and we're going to pass in an object.
56:18 - And here we're going to define all the things that we want to check.
56:21 - So let's scroll down.
56:22 - Our form has a first name, last name, Twitter, and avatar and notes.
56:27 - So we're going to write very basic checks here.
56:30 - So we're going to say avatar, it needs to be a string.
56:33 - It needs to be a URL and minimum of two characters.
56:39 - So it can't be blank.
56:40 - Then we're going to check our first name.
56:42 - And we're going to say, again, it has to be a string.
56:45 - And again, we're just going to say minimum of two.
56:48 - But you could add whatever values to make sense for your application.
56:51 - And we're going to do the same thing for our last name, last.
56:56 - And don't forget your comments, everyone.
56:58 - And then finally, we're going to add Twitter.
57:01 - And again, it's going to be Z string and minimum of two.
57:06 - And again, I'm doing very basic checks here
57:08 - just to kind of show you how ZOD works.
57:10 - But you could decide and look more into it
57:12 - to kind of see how you can create custom checks for your items.
57:16 - And notes you're going to leave out because it's going to be optional.
57:19 - We're not going to worry too much about it right now.
57:21 - So now that we have our form schema,
57:23 - let's create a new variable called validated fields.
57:29 - And it's going to be equal to form schema dot save parse.
57:35 - And inside here, we're going to add the items that we want to check.
57:38 - So we want to check our avatar.
57:40 - And then we basically specify where that's coming from.
57:43 - And we're getting our avatar from our form data here.
57:46 - So we're going to say data dot avatar.
57:49 - Next, we want to check our first name data dot first.
57:53 - We're going to do the same thing for last equals data dot last.
57:57 - And finally, we're going to check Twitter.
57:59 - And it's going to be data dot Twitter.
58:02 - Fantastic.
58:04 - Now we could check for our validated fields.
58:06 - So we're going to do an if statement.
58:08 - And we're going to say if validated fields dot not successful,
58:14 - we're going to return our error.
58:16 - So we're going to say return.
58:18 - And we're going to use our JSON object here.
58:21 - If we have errors, we're going to get them from validated fields dot error.
58:27 - And we're going to flatten the response just to make it more consumable.
58:31 - And all we want to get is field errors.
58:34 - Then we're also going to return a message.
58:37 - And we're going to keep this message generic,
58:40 - which is going to say, please fill out all missing fields.
58:46 - And for data, we're going to return null because we weren't able to successfully
58:50 - submit the form.
58:51 - And then make sure you import JSON at the top here.
58:54 - And that's coming from remix run node.
58:56 - And we're just going to update this so we could have one line here.
59:00 - So I'm just going to say type here instead.
59:03 - Otherwise, I would have had to do it in two lines.
59:05 - Perfect.
59:05 - Now that our form is all set, we should be able to see our errors coming back
59:11 - when we make a mistake.
59:12 - So let's going to do here data from action just so we could see it.
59:18 - And so now let's try to submit our form without passing any of our params.
59:23 - And this should be caught by our ZOD validator.
59:26 - And because we're not going to pass all the items, it should return an error.
59:30 - It should return message that we have here.
59:32 - And also all the fields where the error has occurred,
59:36 - which we'll be able to visually show in our input in just a minute.
59:40 - But first, let's just check it out.
59:41 - So inside our application, I'm going to open my inspector here,
59:46 - go to console lock, and we're going to go to create.
59:49 - And I'm not going to fill anything out.
59:51 - I'm just going to click create.
59:53 - So Norris, when we click create, we now get all of our validation.
59:58 - And again, this is all happening on the server because actions and loaders run on the server,
60:02 - which is pretty cool.
60:03 - And when we fail our validation is going to show us,
60:07 - hey, here's the places where the errors have occurred.
60:11 - And it's going to give us the message errors that we want to show to our users.
60:16 - And so now that we know that we're getting our errors,
60:18 - let's show these errors to our users in our form.
60:22 - And so if you navigate, notice how we have an error prop that we could pass.
60:28 - So now instead of false, let's do form data.
60:32 - And we're going to check if it's undefined or doesn't have errors, just return false.
60:38 - And we're going to say errors.
60:40 - And this is probably complaining.
60:42 - So let's go here and under use action data, let's do type of action.
60:49 - And this should stop our complaint.
60:51 - And notice, boom, we fixed it.
60:53 - So now let's go ahead and add this to the rest of the form inputs.
60:57 - And I'll show you what is doing inside the input component in just a second that we have here.
61:01 - But once we have all the validation, we could go ahead and scroll down now.
61:06 - So let's take a look at our form input.
61:08 - So notice we are getting the errors prop.
61:12 - And what we're doing is we are iterating through the errors.
61:15 - And if the error matches the field name, we return the message.
61:19 - So let's take a look and see if this works.
61:22 - So now when I try to submit the form by clicking create,
61:26 - notice that we have all the basic errors showing up to us.
61:29 - And so we want to make sure that we fix the error.
61:31 - And if I fix one and click create, notice the error goes away,
61:35 - but I still have all the other ones.
61:36 - So let's go bratz at Twitter.
61:39 - Let's find a nice pixel image.
61:41 - Pexels.com.
61:43 - This looks great.
61:44 - Copy image address.
61:45 - Let's go back to our application.
61:47 - Let's throw in that URL and say, hey there.
61:51 - And now we're going to create submit and notice that it went ahead and created our form.
61:57 - And right now the experience is still kind of terrible because although we created our form,
62:01 - the form didn't clear.
62:03 - We didn't navigate to the item that we created.
62:05 - So it wouldn't be nice after the thing that's created, it navigates to that thing.
62:10 - So let's see how to do that next in the next part of this video.
62:14 - So looking in the remix docs, we're going to look for redirect and click enter.
62:19 - And here we have an example of redirecting from form action.
62:22 - And it's going to give us some example, but basically we want to use redirect
62:26 - and we want to import redirect from remix run node.
62:30 - And basically once we have the user ID, we could redirect to that newly created item.
62:38 - So let's go ahead and implement that in our code.
62:40 - So let's import redirect after Jason here.
62:43 - And we're going to use it right after our new entry.
62:47 - And for now, we're just going to return our redirect and we're going to pass.
62:52 - Where do you want to redirect it to?
62:54 - And we're going to redirect it to contacts slash and we're going to append new entry dot ID.
63:03 - So whenever we create a new entry, we have an ID and we're going to redirect our form
63:10 - to that new screen.
63:12 - So let's go ahead and check if it works.
63:14 - So let's give it a try.
63:15 - We're going to say new test at Twitter and we're going to paste the URL of an image and say hello.
63:23 - And now when we create the new item, it should redirect us, which it did.
63:27 - And boom, that is a great experience.
63:30 - Nice.
63:30 - We're making progress through learning remix basics with Strapi, which is pretty cool.
63:36 - So now it'd be really awesome if we could now select an entry,
63:40 - click the edit button and be able to update our entry.
63:45 - So that's exactly what we're going to do next.
63:47 - To get started, we're going to use a code snippet from remix tutorial here in their documentation.
63:53 - And so the next route we're going to create, it's to be able to add a form where we are
63:58 - able to update our items.
64:00 - So I'm going to copy contacts dot contact ID slash dot edit that TSX.
64:06 - And that's going to be a route we're going to create.
64:08 - And typically the reason why we're doing a dash afterwards, if you look here at the note,
64:15 - by default in remix, if a route matches with the same prefix name,
64:20 - it will be considered as a child route and be nested inside the parent.
64:25 - We don't want to do that.
64:26 - And the way you prevent that behavior is adding the dash.
64:29 - And that's exactly what we're doing here.
64:31 - And so now let's go in our code inside our app, inside our routes,
64:34 - we're going to create a new file and we're going to add our route endpoint.
64:40 - So whenever we navigate to contacts slash an ID of our item slash edit,
64:45 - it's going to bring us to this page.
64:47 - So let's add the code snippet.
64:48 - I'm going to scroll down and I'm going to click here on copy.
64:53 - And inside our code editor, let's paste it in.
64:56 - Just remember, we did update the tutorial instead of using dummy data that we had,
65:01 - but actually using our strappy API.
65:03 - So we're getting our contacts from our strappy endpoint,
65:07 - where we did update the data file to be data that server file and get contacts is found on that file.
65:15 - It's just a quick refresher.
65:16 - If we go to data that server, we see that we have, I get contacts and create contact
65:23 - and get contact functions that get the data.
65:27 - So now that our memory is refreshed, let's go back.
65:30 - So we won't need to change too much except just to point to our function
65:35 - that we refactored to use strappy.
65:38 - And the last update I'm going to do here, I like to have this throw on one line
65:42 - just because it mentally makes my brain happy.
65:44 - And if you scroll down, when we use this loader to get our strappy data,
65:49 - we get the data through this contacts using use loader data.
65:53 - And we are setting it as the initial value using the default value prop.
65:58 - So we're getting contact object and we have items there for the first name,
66:02 - the last name, our Twitter handle, our avatar URL, as well as our notes, our contact notes.
66:09 - So now everything should work in terms of showing our data.
66:14 - So back in our application, now if I hit edit,
66:17 - Norris, it takes us to our contact slash ID slash edit page
66:22 - with all of our data already pre-filled.
66:24 - And we don't see a Twitter handle here.
66:26 - Let me just check.
66:27 - That's because I didn't add a Twitter handle here.
66:29 - Let's try another entry.
66:31 - Here we go.
66:31 - Let's click edit.
66:32 - So Norris again, our form is pre-filled and we're able to now make our updates.
66:38 - So to make our updates, we're going to do something similar to when we created the form.
66:42 - So all we have to do is connect that logic to the save button.
66:45 - So inside our edit.tsx file, we're going to scroll to the bottom
66:49 - and we're going to find our submit button.
66:51 - Because our submit button has type of submit, we don't really have to do anything
66:55 - because whenever you click a button, which has a type of submit,
66:58 - it's automatically going to fire the form action.
67:01 - So all we have to do is we have to define our action function
67:06 - and our action function is going to expect a post request to handle updating our contact.
67:12 - So we're going to do export const action equals a sync.
67:17 - And inside this function, we're going to pass our params and our request.
67:22 - And this is coming from action function arcs.
67:27 - And we're going to do our error function.
67:28 - I realized that in other examples, I was not using error function.
67:32 - I prefer not using error functions, but I just want to show you that this works as well.
67:38 - And let's import our action function arc types.
67:42 - So let's do here action function arcs.
67:46 - And we're going to check with the invariant function like you did in our loader
67:50 - to see that our contact ID exists from our params.
67:55 - Next, we need to get our form data.
67:58 - And that's coming from our request.form data.
68:03 - And if you're just trying to remember how we get this data,
68:07 - it is passed automatically to us from our forms using the name attribute.
68:13 - So we're going to get name first, name last, we're going to get our name Twitter.
68:19 - And that's all going to be in our form data object that we get from our form.
68:23 - So we're going to destructure our data from our form using object.from entries.
68:31 - And we're going to pass our form data.
68:33 - So before we get too far, let's console.log our data.
68:38 - And let's return null for now.
68:40 - So it doesn't complain that we don't have a return in our form action.
68:44 - And I'm just going to go ahead and restart my project.
68:47 - Yarn develop to start my Strapi application.
68:50 - And then the front end of our application, we're going to do yarn dev.
68:54 - So back in our project, we're going to go to any entry,
68:58 - we're going to click edit, and it takes us to a form.
69:00 - So I'm just going to see if we're getting this data passed to our action.
69:05 - Can we see this in the action?
69:09 - And let's click save.
69:11 - When we click save, nothing happens.
69:13 - But let's look at our console.log here.
69:16 - And notice how we're getting our console.log that says,
69:19 - can we see this in the action?
69:20 - So I know that it's working.
69:22 - We know that it's updating our form data.
69:24 - So now that we know we're getting our data in our action,
69:27 - let's go ahead and write a function to handle our update.
69:31 - So I'm going to do const update response equals await.
69:37 - And we're going to call this update contact by ID.
69:43 - And this is going to get our data.
69:46 - And we're going to do a very basic check here.
69:48 - If update.responseError, we're going to return JSON object.
69:57 - And inside here, we're going to say data equals null.
70:00 - We're going to say error equals update response.error.
70:07 - And then if nothing terrible happens,
70:11 - we're going to redirect to contacts slash.
70:15 - And we're going to pass our params contact ID.
70:20 - Nice.
70:21 - So we could do additional error handling here.
70:23 - But for now, we're just going to keep it super simple.
70:26 - And if we wanted to get this response here,
70:30 - just remember, we would use action data.
70:34 - So we could do const form response.
70:38 - And it's going to use action data.
70:41 - And it's going to be type of action.
70:44 - And for now, we're just going to console.log for response.
70:51 - Then we're going to say from action.
70:54 - And so anytime this if statement gets triggered,
70:58 - it's going to return data null and our error
71:01 - that we'll be able to see in the front end.
71:02 - And we could show that error to our user.
71:05 - But we'll come back to this.
71:06 - Let's just make sure that we could actually update
71:08 - our data on our back end.
71:09 - So I'm going to now go to our data.server file.
71:14 - So we're going to update our update contacts.
71:17 - We're going to rename it to be update contact by ID.
71:20 - And here instead of updates, we could keep it updates.
71:24 - That makes perfect sense.
71:26 - And this is actually going to be very similar to our create method.
71:29 - So let's go here.
71:31 - And I'm just going to copy this whole try and catch block here.
71:35 - And we're going to paste it in.
71:38 - And the only difference is going to be we're making
71:42 - a call to API contacts slash and we're going to be passing our ID.
71:49 - And then instead of post, we're going to be making a put requests.
71:54 - And we're going to rename this to updates,
71:57 - because that's what we want to be passing.
72:00 - And then finally, once we get the response,
72:02 - we're going to return the response.
72:04 - If not, it's going to throw an error here.
72:06 - And if something goes wrong, the cache block will console log the error.
72:09 - So if you're wondering, how do I know that we need to make a request
72:14 - to API contacts while passing the ID?
72:16 - So let's take a look in our strappy application.
72:18 - If we go into settings and we go on the roles public and we look at contacts,
72:24 - we could see that we have this update.
72:26 - And it's great that I remember to do this because we do need to enable this.
72:30 - So if I click on update and click the checkbox,
72:33 - you're going to see that we need to make a put request to our API contacts endpoint
72:38 - and pass the ID.
72:39 - And that's exactly what we're doing.
72:41 - So I'm going to save this back in my code.
72:43 - Notice that's exactly what we're doing.
72:46 - And we're passing our data and our updates.
72:49 - And let's now import this inside our edit.
72:53 - And so we could import it from our data that server.
72:57 - And so now, and there's a typo here.
73:00 - That's why it's complaining.
73:01 - Boom.
73:01 - Thank goodness for our TypeScript.
73:03 - And so now everything I think looks pretty good.
73:07 - So let's give it a test.
73:10 - So I'm going to go to new test.
73:12 - I'm going to click edit.
73:13 - And I'm going to say Joe Mary at Joe Mary Twitter.
73:19 - And then did this work?
73:22 - And let's click save.
73:24 - You define an action route in contact but it did not return anything.
73:28 - So let's take a look here.
73:30 - So we want to return the redirect.
73:32 - That's why I was complaining.
73:34 - So let's try this again.
73:35 - Let's go back.
73:36 - Refresh.
73:37 - Notice the update still worked.
73:39 - But let's try to go to Paul Bratz.
73:42 - Let's go edit.
73:44 - I'm going to put my, I'm going to say Kyle Bratz.
73:49 - Sounds good.
73:50 - Hey, did this work?
73:53 - And we're going to do question mark and click save.
73:55 - Nice.
73:56 - So we know that our edit works.
73:58 - Let's try it again.
74:00 - To do the final sanity check.
74:01 - Paul is cool but not as cool as you all.
74:07 - And at coding 30.
74:11 - And I'm just typing random text because whatever.
74:13 - Hello from remix and strappy and save.
74:18 - And perfect.
74:19 - Look at this.
74:19 - Paul school but not as cool as you.
74:21 - Coding 30.
74:22 - And so our update works.
74:23 - So before we move on to the next step, which is write our delete functionality
74:28 - and then write our star functionality.
74:30 - Let's kind of quickly review what we did.
74:33 - So inside our edit.tsx file, we created our loader and our action and our form.
74:40 - Now to populate our form with initial data, we used our loader function to get that data
74:47 - based on the params.
74:49 - So whenever someone clicks edit, you see that there's a param of one here.
74:54 - That's that's the parameter that we are getting here.
74:57 - And we're passing it to our get contact method, which makes a call to strappy passing that ID
75:04 - returning that data.
75:06 - Once we get that data, we are using use loader data hook and be destructuring that data.
75:13 - And we're using it to populate our form with that initial data using default values.
75:19 - Now, once that's done, whenever someone hits the submit button after making the changes,
75:24 - that's going to fire our action.
75:26 - Our action is going to get the data from our form using the request form data method.
75:33 - Then we are passing that data to our update contact by ID method.
75:38 - And that expects our ID that we use to pass to our call and our data that we want to update.
75:46 - We're making a basic fetch put request to our strappy endpoint.
75:50 - Once we get the data back and if everything is successful, it's going to go ahead and redirect.
75:56 - If there is an error, we're going to return the error to our front end within this form response.
76:04 - And for now, I'm just console logging.
76:06 - And the reason why it's undefined is because we didn't submit the form yet or return any errors.
76:12 - You could challenge yourself to use this response and create a error block here that if you do get
76:20 - our error back, you could display it to the user.
76:22 - So with that being said, let's move on to the next step.
76:25 - It's Friday night, so I needed some mood lighting, but let's continue with this tutorial.
76:29 - So one thing that I do want to show you when we go to edit, we have the delete button,
76:35 - which is kind of cool.
76:36 - So we could press the lead to delete our entry.
76:38 - But if you go back to edit, we do have a cancel button that doesn't really do anything right now.
76:43 - So let's go fix it.
76:45 - And the fix for this is really easy because we want when someone hits the cancel button,
76:50 - it just goes back to the original view that we had.
76:54 - So let's implement it now.
76:55 - So inside our code inside edit.tsx file, we're going to import use navigate hook here from
77:02 - remix react.
77:03 - So let's do use navigate, and we're going to scroll all the way down to the bottom.
77:09 - Now, this could be a link, and that would probably make more sense.
77:12 - But I want to show you that you could do programmatic navigation through putting a
77:16 - on click event onto a button.
77:18 - So that's what we're going to do.
77:19 - So we're going to say on click, and we're just going to fire a function that's going
77:25 - to use a use navigate hook.
77:27 - And let's just scroll up to the top here because the first thing we need to do,
77:31 - we imported our hook.
77:33 - That's right.
77:33 - And so now what I want to do inside my edit contact component, we'll do it right below here.
77:40 - We're going to say const navigate equals use navigate.
77:45 - And what's cool, right where we're going to use navigate, you can pass, let's say a URL
77:52 - endpoint that you want to go to either home or contacts, or if you want to go back, you
77:58 - could just pass negative one.
78:01 - So very simple fix here.
78:03 - So now when we go back into our application, if I click edit, and I click cancel, it takes
78:09 - me back.
78:09 - So one more time, if I click edit, and I click cancel, it takes me back to where I was.
78:14 - Okay, awesome.
78:15 - Now we are going to implement the delete button.
78:19 - Now before we do that, let's go into settings.
78:22 - And we're going to enable delete and Strapi.
78:24 - And this is going to show us the endpoint that we want to hit.
78:27 - So let's go ahead first and create this function that will delete an item from Strapi.
78:34 - So in our code editor, let's navigate to apps, data.server.ts file, and just quickly
78:40 - review, let's look at the pattern that we've been following when creating these functions.
78:45 - Notice that we always start with a try catch block.
78:48 - And we're basically making a fetch request.
78:50 - And if we take a close look to all of our different API calls, we're following that same
78:57 - pattern.
78:57 - And so what I'm going to do is I'm going to use get contacts here as an example.
79:02 - And I'm going to copy the snippet, and we're going to use it to create our delete contacts.
79:07 - So under delete contacts, let's paste that try and catch here.
79:10 - And we know that in order to delete, we're going to this API slash contact slash, and
79:16 - then passing the ID endpoint.
79:18 - And we know that because we saw it here in Strapi.
79:21 - And the only difference is, instead of making a post or get request, we want to make a delete
79:29 - request.
79:29 - So we're going to say method is going to be delete.
79:33 - Excellent.
79:33 - And I believe that's all we need to do here.
79:36 - And now before we call this function and use it, let's kind of go and look at one example
79:43 - here in our routes.
79:44 - Let's go to edit.
79:45 - So notice whenever we were making a form submission, we were defining an action inside that same
79:52 - file.
79:52 - But you could actually define this action as a standalone route.
79:57 - So what we're going to do, we're going to create what we call a resource route.
80:00 - And a resource route is a route that does not default export a UI component.
80:06 - So for instance, I'm going to go into routes, and we're going to create a new file.
80:12 - And we're going to say contacts that we're going to want to get the ID through the program.
80:19 - So we're going to say contact ID, and we're going to say dot delete dot TS.
80:26 - I copied and paste this example action, and we're going to use it here as well.
80:31 - So I'm going to paste my example action.
80:35 - One thing we want to make sure we import is our types.
80:38 - So import type and its action function arcs, action function arcs from remix node.
80:46 - And we want to import invariant, import invariant from tiny invariant.
80:52 - And we don't need the form data or the data.
80:55 - All we're going to do here is await our delete method.
81:00 - And we're going to import from our data.service.
81:05 - We're going to import delete contacts here.
81:07 - So let's do import delete contacts.
81:11 - And the reason why I'm copying and pasting sometimes from our existing code
81:14 - is so you could see that a lot of the things that we create once,
81:18 - it's a pattern on that variation.
81:20 - And so a lot of times, when you create one basic functionality,
81:24 - you could use it as a pattern moving forward.
81:27 - And there's obviously other ways that you could optimize your code
81:30 - so you don't have to repeat yourself.
81:32 - But I just wanted to show you that there's a lot of patterns
81:36 - that once you establish them, you could reuse in your code.
81:39 - And basically what we're going to do here,
81:42 - we're going to check if the param exists.
81:46 - If so, we're going to go ahead and call our delete contact function
81:50 - by passing the ID of the item that we want to delete.
81:54 - And then if it's successful, it's going to redirect.
81:59 - And let's import redirect here from node redirect.
82:03 - And I guess let's adjust this.
82:05 - We'll say type in front so I don't have to put it on two lines.
82:08 - And if it's successful, it's going to redirect.
82:12 - And by the way, if there's an error,
82:14 - it's going to be caught by our try and catch here.
82:18 - But for now, we're going to keep it super simple.
82:20 - So now that we have our route defined,
82:25 - so basically, if we remember,
82:27 - contacts.contactid.delete actually stands for contact slash id slash delete.
82:35 - So if I wanted to delete an entry,
82:39 - and I guess I'm not using the request here so we could delete it,
82:42 - I would just make a post request to the delete action.
82:47 - And we're going to take a look at that next.
82:49 - So inside our code, we're going to navigate to our contact.contactid.tsx file.
82:56 - If we scroll down, we're going to have a form with an action called destroy.
83:01 - And this correlates to what we called the route.
83:05 - And notice that because we're in contacts slash contact id,
83:10 - we don't need to put the full URL here.
83:13 - We just put the endpoint that we want, which is delete.
83:16 - So notice contacts slash id slash delete,
83:20 - contacts slash id, the first two parts match.
83:24 - So we only want to show delete.
83:26 - And when we click delete, it's going to make a post request
83:29 - to our resource route that we have created.
83:32 - But before we could test our functionality,
83:35 - inside your strappy admin panel, go to settings,
83:38 - go to user's permission plugin on the roles, on the public,
83:42 - and on the contacts, make sure you click delete,
83:45 - and click the checkbox and click save to activate this endpoint for strappy.
83:50 - Because in our code, when we click the delete button,
83:54 - it's going to call our delete action that we defined in this file here
84:00 - that is going to call our strappy endpoint delete contact,
84:05 - which is making a request to our strappy endpoint here.
84:08 - So that's why we want to make sure that it's activated.
84:11 - Now that it is activated, let's see if it works.
84:15 - So I'm going to delete test user and I'm going to click delete.
84:18 - It's going to ask us to confirm.
84:20 - I'm going to say okay.
84:21 - And oh my gosh, we're at not found.
84:24 - What is going on?
84:25 - So we going to take a look at it.
84:28 - I think I know where we made a mistake.
84:30 - So inside your code, inside our delete action,
84:34 - notice here that we are passing an id.
84:38 - So what is happening, we are passing an id that no longer exists because we delete it.
84:43 - So all we have to do is just erase this and keep it this way.
84:48 - And now this is going to work.
84:49 - But we're still going to have an interesting problem.
84:51 - So let's try this again.
84:53 - I'm going to create a new entry test data at Twitter.
84:58 - For the dummy image, click create.
85:00 - So now when we delete the entry,
85:03 - notice right now we are contacts are 12 that exist.
85:06 - If I click delete, we are again going to show not found.
85:10 - So two things we need to do.
85:12 - Number one, we need to figure out how to handle an error
85:15 - such as 404 to not break our app like it's breaking right now.
85:20 - And number two, it's how do we render this empty page?
85:24 - For instance, if we have items or how to handle not found
85:30 - when there's items that are not found.
85:33 - Notice how putting IDs of items that don't exist
85:36 - and our application is just not working.
85:39 - So notice that we have one entry with ID of nine
85:42 - because it exists.
85:43 - We don't have an issue.
85:45 - If we do 10, it's going to complain.
85:48 - And if we just go to contacts, it's going to complain.
85:52 - So first thing, let's fix this contacts route.
85:56 - So let's take a look what is happening.
85:58 - So inside our application, let's go to our browser here
86:02 - and look at our routes.
86:04 - Notice how we have contacts slash ID slash added,
86:08 - contacts slash ID slash delete,
86:10 - contacts slash ID, contacts slash create,
86:14 - but we don't have just a contacts route.
86:17 - And that's why we're returning not found
86:19 - because this route doesn't exist.
86:21 - So let's go ahead and create it.
86:23 - And it's going to be very similar to what we did here.
86:26 - We are going to create a standalone route,
86:28 - so not a parent route.
86:30 - So for instance, if I create a new file called contacts.tsx
86:35 - is going to be a parent route.
86:36 - That's not what we want because TSX,
86:39 - this is going to be a parent route
86:41 - and everything underneath here,
86:43 - like all these items,
86:44 - they're going to be nested children of that route.
86:46 - That's not what we want.
86:47 - So the way we make it a standalone route,
86:50 - we put this dash.
86:51 - So here, I'm just going to create a very basic component
86:54 - and we're going to call it contact route.
86:58 - So this will show up when no items are selected.
87:07 - So let's see if that works
87:08 - and we don't need to import the react here.
87:11 - So now when we refresh,
87:13 - notice how this now doesn't fail, this works.
87:17 - But if I do navigate to anything here,
87:21 - notice how we still get 404.
87:23 - So next, let's take a look at how to handle errors in remix.
87:27 - Before we handle errors, by the way,
87:29 - you could also throw not found errors.
87:32 - And here's an example,
87:33 - you could do a response past the code
87:35 - and it could be for any type of response that you want.
87:37 - And we actually kind of use this already.
87:39 - So inside our code,
87:40 - if we look at contacts, contact ID,
87:45 - and we scroll up here,
87:46 - notice here we are,
87:47 - if there's no contacts available,
87:49 - we are throwing that new error.
87:51 - And that's what is actually causing our 404
87:54 - that we see on our page.
87:55 - But notice how that breaks our whole app.
87:56 - Wouldn't be nice if we could somehow catch errors
87:59 - and only encapsulate those errors
88:01 - to the routes where that error occurred.
88:03 - So that means that the rest of the application is going to work.
88:06 - So let's take a look at our root error boundaries found in remix.
88:10 - Root error boundaries allow you to throw errors within a specific route.
88:14 - So what we're going to do,
88:15 - we're going to use this example.
88:17 - And if you're following along with this tutorial,
88:19 - you could look up root error boundaries
88:21 - and you could find this example.
88:23 - And I'm going to copy it.
88:24 - And right now we're just going to paste it
88:26 - in the root of our project.
88:28 - So I'm going to navigate to the root of my project.
88:30 - And right above the app component,
88:33 - I'm going to paste in our error boundary here.
88:37 - And so there's a couple of things we need to import.
88:39 - So use router error hook allows you to get access to the errors
88:43 - and you import it from react.
88:46 - Use router error.
88:49 - And then we also need to do a type check.
88:52 - So remix gives us this amazing utility function.
88:56 - So let's also import that as well from react.
88:59 - And now our error boundary will stop complaining.
89:02 - This is just a warning.
89:03 - I have this freaking insane this extension called,
89:07 - if you want to hate yourself, error lens.
89:11 - Install this extension.
89:12 - You're going to you're going to hate yourself.
89:14 - And so it just complains all the time.
89:16 - And this is just a warning.
89:17 - So it's nothing, no big deal.
89:18 - But anyway, and so now that we have our error
89:21 - and just to kind of give us a visual representation of this,
89:26 - I'm going to say class name.
89:28 - I'm going to say root error.
89:30 - And this is the error that's going to be in the root of our project.
89:34 - And we could actually update just a little bit.
89:36 - I'm going to move this to a paragraph tag here.
89:40 - And then here we're going to say, oops.
89:43 - I don't know how to spell oops, but is it oops like this?
89:47 - Yeah, sounds good.
89:48 - It's game over.
89:51 - Okay, so we have our root error boundary in the root of our project.
89:56 - So no matter where we have the error is going to default to this boundary here.
90:02 - And let me just go to the app CSS and add some basic styling
90:06 - so we could visually see it.
90:08 - And so in app.css right here, I'm going to do my class root error.
90:15 - And we're going to keep it simple.
90:17 - We're going to say background red and then color white.
90:22 - So now in our application, if we go and everything is fine, this is great.
90:28 - But if I go to a different route or some sort of error cures,
90:32 - it is going to go ahead and fire that root error boundary.
90:37 - But notice how application is actually kind of broken
90:39 - because there's nothing I could do now.
90:41 - Let's kind of see how we could improve this.
90:43 - But before, let me add some padding because that looks kind of ridiculous.
90:46 - So we're going to say padding, we're going to do 6 RAM.
90:51 - That sounds good.
90:52 - And refresh.
90:53 - Nice.
90:54 - And so we have our oopses game over, but my application, there's nothing I could do.
90:58 - So let's see how we could do this better.
91:00 - So we know this is happening on our contacts.
91:03 - So if I want to catch an error in our contacts, what we're going to do,
91:07 - we're going to use the same pattern.
91:09 - So let me copy this here.
91:12 - And we're going to go to our routes, contact ID TSX.
91:18 - And so this is where we're having an issue when there's not found
91:22 - because this is where we're throwing this error.
91:24 - So by throwing the error in our loader, we could actually catch it here with our error boundary.
91:31 - And we're going to simplify this error boundary.
91:34 - We're going to instead of a body, make this div.
91:37 - And then we're going to delete all this unnecessary stuff here.
91:41 - We don't need the script.
91:42 - And let's going to do contact error just so we could style it differently.
91:51 - Let's import use router error.
91:55 - And then is router error response.
91:58 - Perfect.
91:59 - And now that we have our error, let's say your contact has left the building.
92:09 - And we're going to adjust this in our CSS.
92:13 - So it's not scary looking like our first error.
92:16 - So let's go to app.cs.
92:18 - And we're just going to add that class.
92:21 - And all we're going to do is keep it friendly.
92:23 - We're just going to give it 6, 6 RAM.
92:26 - So check this out.
92:28 - Going to our project.
92:29 - Now, whenever we have an error in a specific route,
92:33 - it is actually just going to throw that error in that route.
92:36 - But notice how the rest of the functionality still is there.
92:41 - So that's the benefit of having error boundaries
92:44 - that you could define in specific routes.
92:46 - So that way, whenever your application breaks,
92:48 - it is not going to be your whole app, but just that part.
92:52 - And if we wanted to improve the experience,
92:54 - we could kind of create a back to safety button, if you will.
92:58 - For instance, inside our contact ID here,
93:01 - we could add another div.
93:03 - And inside this div, we're going to put a button.
93:06 - And we're going to say back to safety.
93:09 - And we're going to add an unclick.
93:11 - And this could be a link, by the way.
93:13 - But I'm going to show you, just to review,
93:15 - the programmatic way of navigating in Remix.
93:19 - So we just want to have a back button.
93:21 - So we're going to use navigate.
93:24 - And to go back to the previous URL,
93:26 - we're just going to do negative 1.
93:28 - And for this to work, we need to import, use navigate.
93:33 - So let's navigate.
93:36 - And it's going to use navigate.
93:40 - And let's just double check.
93:41 - Make sure that got imported here.
93:43 - Perfect.
93:44 - So now our error boundary has a button.
93:47 - So let's see how that looks.
93:48 - So if somebody goes to a wrong URL,
93:52 - you now have this error boundary.
93:55 - Our application didn't fail.
93:56 - And we have this button that will take us back
93:58 - to previous URL, which was working.
94:00 - So this is a great way for you to maintain great usability
94:03 - in your application.
94:04 - So now that we know how to throw our errors,
94:07 - we are able to update, delete.
94:10 - Before we implement the search button
94:12 - and do final tweaks to our app,
94:15 - let's finally make this like button work.
94:18 - So we have this star.
94:20 - And what we want when we click the star,
94:22 - we want it to favor this.
94:24 - Or if we unclick it, we want it to unfavor this.
94:27 - So let's see how to do this in the next video.
94:30 - Believe it or not, implementing this update is going to be easy.
94:33 - Because we already have the foundation.
94:34 - If we go into apps, go into data.server,
94:37 - you'll notice that we have our update contact ID.
94:41 - And this is basically what we're going to use
94:44 - to update the like or dislike or star and un-star functionality.
94:49 - So let's go in our application into routes.
94:53 - And that's found in contacts.contactsid.
94:57 - And we scroll all the way down.
95:00 - We're going to have our favorite function.
95:03 - Which is a form.
95:04 - And if you had to guess, how can we get this?
95:08 - Of course, that's using our action function.
95:11 - We will be able to get the data based on the name in our action
95:15 - and update it accordingly.
95:16 - So let's scroll to the top.
95:18 - And right after our loader,
95:19 - we're going to export a sync function.
95:23 - And it's going to be action.
95:25 - We're going to need the params and response.
95:28 - And that's coming from action function args.
95:33 - We're going to use our invariant function to double check
95:36 - if we do have the ID.
95:38 - And if that's the case, we're going to get our form data.
95:42 - Which is going to await response.
95:46 - And I made a mistake here.
95:48 - That should be a request, silly.
95:50 - It's going to be request.formData.
95:54 - And this is going to give us access to our elements in our form.
96:00 - Now we're going to call our update content by ID.
96:05 - We're going to pass our first argument,
96:07 - which is our ID of the item that we want to update.
96:13 - And then the item we want to update,
96:15 - if we take a look in our strappy application,
96:18 - our content type builder, we have favorite.
96:21 - So this is what we're going to update.
96:23 - And it takes a boolean.
96:24 - So let's do favorite.
96:26 - And we're going to get it from form data.get.
96:31 - And we are able to reference the item we want to get here,
96:35 - which is favorite.
96:36 - And if you want to know where that's coming from,
96:38 - that's coming from here on the bottom.
96:42 - Our name of the button is favorite.
96:45 - And this is where we're getting that value.
96:47 - So back in our action, after we get favorite,
96:51 - we're going to check if it's equal to true.
96:55 - And if it's true, it's going to return true.
96:57 - And if it's not, it's going to return false.
97:00 - And that's really all we had to do.
97:02 - So now let's go check it out.
97:04 - In our local host, now I'm able to favorite.
97:06 - And notice by magic, remix updates the state here as well.
97:11 - And this is the power of remix,
97:12 - is that you don't have to worry too much about crazy state updating and nesting.
97:17 - Remix like magic just does it.
97:19 - Look at that.
97:19 - Change the state, change the state.
97:20 - This lives in two places.
97:22 - This is in our side menu.
97:23 - And this is in our contacts slash contacts ID route,
97:29 - which is pretty cool.
97:30 - And that's the superpower remix.
97:32 - So we're almost IT end here.
97:34 - We got our edit working.
97:36 - We got our delete working.
97:38 - We're able to add new items.
97:39 - We're able to update, meaning like or dislike or star on star.
97:44 - And now finally, let's implement our search to be able to search our items.
97:49 - So I went ahead and added the rest of the folks here into our application.
97:53 - And all of these users you could see are found in our Strapi instance.
97:58 - And let's do 50 so we could see all of our users.
98:02 - Fantastic.
98:04 - So this is pretty awesome.
98:05 - We have our data that is stored in Strapi being consumed by our remix application.
98:11 - So now let's go ahead and implement this search feature.
98:15 - And there's one thing that I want to show you before we do that.
98:18 - So I'm going to create a test user.
98:22 - And we're going to do test, test, test for everything.
98:25 - I'm going to add my image and click create noise that a user has been created.
98:30 - And I'm going to start a user.
98:31 - But when we take a look here, we don't see our user.
98:36 - And the reason is Strapi has pagination by default.
98:40 - And you could learn more about it by going to our doc.
98:43 - So in Google, you could just search Strapi pagination docs, click enter.
98:50 - It's going to find the search in Google, go to sort and pagination,
98:53 - and you could read more about it.
98:54 - But if I scroll down here a little bit, we'll see that by default,
98:58 - we set the page size limit to 25 because the idea is if you have a thousand,
99:03 - a million items, you don't want to get them all at once.
99:06 - And because we have more than 25 users in our application,
99:12 - the reason we don't see the newly generated user
99:14 - because we're only returning 25 of those.
99:16 - So the way you would handle this, you would implement a whole pagination
99:21 - where you would be able to navigate from page one to page two.
99:24 - And based on the page you select, you would get those items.
99:26 - That's slightly beyond the scope of this tutorial.
99:30 - I will make some future tutorials that will cover that.
99:32 - But for today, the easy fix will be for us to change this from 25 to 50.
99:38 - So if I just navigate to API slash contacts,
99:43 - and we take a look at the response, if I scroll all the way to the bottom,
99:47 - we'll notice that our pagination is set to 25 items.
99:51 - But in total, we have 31.
99:53 - So this is going to be easy fix that we'll do first,
99:56 - and then we'll cover how to hook up our search block here.
100:00 - So let's do this.
100:01 - So now within our project, let's navigate into apps
100:04 - and all the way to our root.tsx file.
100:07 - This is where we're getting our initial contacts to populate our left navigation.
100:12 - So notice we're calling the get contacts method.
100:15 - If we navigate to get contacts, you could either right click
100:18 - and click go to definition, or you could click and go to our data.server.ts
100:23 - because that's where that file is defined.
100:26 - I just wanted to show you that you could find it in both ways.
100:29 - And here we have our get contacts function.
100:32 - And we have this query param that I said we were going to come back to.
100:37 - And just like we alluded in our documentation here,
100:40 - notice how we're able to pass a query to our response here
100:46 - in order to pass additional query params.
100:50 - For instance, define the size of the page.
100:52 - Of course, you could use the documentation,
100:54 - but I just want to share with you this blog post that is found on strappy.io in blogs.
101:00 - And it's called demystifying strappy populate and filtering,
101:05 - which covers all you need to know to quickly get started.
101:08 - Because for beginners, this might be a little bit complex
101:11 - if you've never done this before.
101:12 - But this shows you how to populate and filter and query
101:16 - all the different items that you need.
101:18 - And the reason why we have populate and filter,
101:21 - because when you're working on an application,
101:22 - you might have a lot of data that you need to return.
101:25 - But the best practice when returning data from your API
101:29 - is only get the data that you need instead of getting everything
101:32 - because it might be too much for your front end.
101:34 - So the idea by using populate and filtering,
101:37 - you're able to tell strappy what items you want to get back
101:40 - that is required to populate your front end.
101:42 - And another resource that is great.
101:45 - And again, I always like to use Google
101:48 - because if you're not sure how to find something,
101:50 - Google is your friend.
101:52 - So if you type strappy query builder,
101:55 - it will bring up this nice interactive query builder
101:58 - and explain to you how to construct queries.
102:02 - So here's an example of our complex query
102:04 - that it's sorting in ascending order based on title.
102:09 - It is filtering.
102:10 - So it will only get the items where the title equals to hello.
102:15 - And it's restricting to populate certain data.
102:18 - For instance, author field may have a lot of items,
102:22 - but they're saying, hey, I don't need all the items.
102:24 - I just need the last name and the first name.
102:26 - And here, as you could see, they're
102:28 - defining the pagination, the page size, and so on,
102:32 - which we're going to use in just a moment.
102:34 - And so in order to use this human readable object notation,
102:40 - we do need to install a library called QS.
102:43 - You could accomplish the same thing using LHS syntax.
102:47 - But as you could see, this is not really human readable
102:50 - and it's a pain in the butt to use.
102:53 - You could find NPMQS to find the QS library
102:59 - and you could learn more about it.
103:00 - But basically what it allows you to do,
103:02 - it allows you to write your queries in a object notation
103:08 - similar to what we're doing here,
103:10 - which makes it much easier to manage and more human readable.
103:13 - So in my application, I'm going to stop the front end
103:17 - and I'm going to do yarn add QS.
103:21 - If you're using yarn, you could do NPM install QS.
103:25 - Also, because we're using TypeScript,
103:26 - it's going to ask us to install the types as well.
103:29 - It's not going to complain here,
103:30 - but it will complain in VS Code.
103:32 - So we're just going to do that right now.
103:34 - So once this is finished, I'm going to do yarn add types QS.
103:42 - Perfect.
103:43 - And then I'm going to restart my application by running yarn dev.
103:46 - Now, inside our code, we're going to add a question mark
103:49 - and we're going to append our query params here
103:53 - that we are going to use.
103:54 - So now let's navigate to our root.tsx file
103:59 - and add the appropriate changes.
104:01 - So the first thing I'm going to do
104:03 - is I'm going to import the QS library.
104:06 - So let's do import QS from QS.
104:11 - Now we're going to scroll down a little bit
104:13 - and here we're just going to define a simple variable called query
104:19 - and it's going to use our QS library that we just installed
104:23 - and the method is stringify which will take an object.
104:26 - And this object is going to take the query
104:29 - that we're going to use this object notation
104:31 - and we only want to for now fetch more data in our page donation.
104:36 - So I'm just going to copy this
104:38 - and definitely read the docs to learn more.
104:40 - Or if you have any questions, just ask them all in the comments.
104:43 - I'm going to make sure to be as supportive as possible
104:46 - in the comments below to answer questions
104:48 - and also start a separate thread on free code camp forum
104:52 - just specifically to answer questions for this tutorial.
104:55 - So now that we have our query, instead of page size being 10,
104:59 - we're going to set it to 50
105:02 - and we're going to pass our query to our loader.
105:05 - And I noticed that our loader is defined above
105:08 - so let's go and move this above our loader
105:11 - so we have this accessible.
105:14 - Nice, now that we have our query and I get contacts here,
105:18 - we are going to pass our query.
105:21 - And notice that our TypeScript wasn't complaining
105:23 - because if you take a look at get top texts,
105:26 - we did make query optional which is perfectly fine
105:30 - and it said either as a string or a null which is not an issue.
105:34 - If you want to make sure that query is always required,
105:37 - you could take out the question mark and in the root
105:40 - if you don't pass in the query, TypeScript is going to complain.
105:44 - So I'm just going to keep it like this for now.
105:46 - And there's many ways of doing things,
105:48 - you're just going to stick to the most simplest way.
105:50 - So now that we're setting the page size,
105:53 - the previous issue that we had where I added a new item
105:57 - and it wasn't being returned,
105:59 - now that we are limiting instead of 25 items to 50 items,
106:02 - we should see all the items.
106:04 - So if I scroll down now, you see that we have our last item test
106:08 - which is fantastic.
106:10 - So now let's take a look how we could modify our query
106:13 - and this form to allow us filter our users.
106:17 - When we created our create form,
106:19 - we learned about form submissions in remix.
106:22 - So now let's take a look what happens if I put a search term in here and click enter.
106:28 - We notice that we get a form submission with a query program
106:32 - that is sent via the get request.
106:34 - So if we take a look at our form in its current state in our code here,
106:39 - let's scroll down to our form.
106:40 - Here we have our input.
106:42 - Whenever we type any text and click enter,
106:46 - it gets submitted in our URL just like you see here.
106:50 - So now scrolling up to our loader,
106:53 - what we could do is we could get our URL param
106:56 - so we could utilize it in our search.
106:58 - So in our loader, we're going to get our request object
107:02 - and the type is loader function args.
107:05 - And now through the request object,
107:08 - we are able to get our URL.
107:10 - So we're going to save it to our variable called URL
107:14 - and we're going to say new equals URL
107:17 - and we're going to use the request.url.
107:21 - So let's console log it first to see what we get.
107:24 - Console log URL.
107:26 - And because this is in our loader,
107:28 - we're going to see the console log in our terminal.
107:30 - And let me just say from loader.
107:33 - And you're probably saying,
107:34 - wait a second, well, how come we're using the loader?
107:38 - Because in the past when we submitted the form,
107:40 - we used an action.
107:42 - So whenever you're submitting a form and using post,
107:45 - that would be using the action.
107:48 - But in our case, we are just submitting the form.
107:51 - And if we don't provide any method,
107:55 - it's going to go ahead and just use get.
107:57 - And whenever you use get, that request is caught by the loader.
108:01 - And that's where we're able to look for the URL
108:02 - so we could take out the URL query param
108:05 - that we want to pass to get contacts.
108:07 - But before we get that far, let's see what we get.
108:10 - So here one more time, I'm going to click enter.
108:13 - And again, it's going to pass our form params
108:16 - as a query param in the URL.
108:19 - And let's check our console log.
108:21 - And notice we have the whole URL path with the query param.
108:25 - We also have our search params with the search params.
108:28 - So if we wanted to get the params out of the URL,
108:31 - we could use the search params.
108:34 - And so that's accessible to us through this search param value.
108:38 - So let's go ahead and do that now.
108:40 - So in our loader, under the URL, we're
108:42 - going to say const query equals our URL dot search params.
108:49 - And we use the dot get method.
108:52 - And we'll pass the key that we want to get, which is a queue.
108:56 - So now let's say I say Joe and click enter.
108:59 - Notice we see Q, which is a key.
109:01 - And Joe is our value.
109:03 - And this is where we see here under our search params,
109:07 - we see Q as the key.
109:09 - And Joe is the value.
109:10 - So that's one way to do it.
109:11 - So now we know that we're getting the value.
109:13 - Now what we're going to do, we're going to pass that value
109:17 - into our get contacts.
109:18 - Now I know earlier in the example I showed you
109:21 - setting up this query here inside the root.tsx file.
109:25 - But we're actually going to move it
109:27 - inside the get contacts method here.
109:29 - So let me just erase the import that we no longer need here.
109:33 - And what is this complaining about?
109:35 - Loader function is only used as a type.
109:38 - That's right.
109:38 - So when it auto imported, it didn't do it the correct way.
109:41 - So I just set a type here.
109:43 - So now let's navigate to our get contact function.
109:48 - And inside here, this is where we're going to put our query.
109:52 - And we need to import our QS.
109:55 - And this we're going to just call Q.
109:56 - And we need to import QS in the top.
109:59 - So let's do import QS from QS to get access to the library.
110:07 - So now in our get contacts, we're
110:10 - going to be passing our query value,
110:12 - like whatever we want to query on,
110:14 - which is going to be the value that comes from a search box.
110:16 - And we're going to pass it into our query object
110:21 - here where we use QS.
110:23 - And you're probably wondering, well, how
110:25 - are we going to use this to be able to tell Strapi
110:28 - to find items with a specific search parameter?
110:31 - So in Strapi, we have this concept of filters.
110:35 - So again, if we go to Strapi documentation,
110:39 - and we say filtering, and we take a look,
110:42 - here we have all the different params, equals, not equals.
110:45 - And we could use these params to construct filtering options.
110:49 - For instance, here's one example using QS.
110:52 - So here we use filters.
110:54 - And we say we want username.
110:55 - If a username is equal to John or a query that we pass,
110:59 - please return that item.
111:00 - And that's exactly what we're going to do in our code.
111:02 - So inside our query string here, right above the pagination,
111:08 - let's add another object.
111:09 - And it's going to call filters.
111:10 - Let me make sure we put a comma at the end here.
111:12 - So JavaScript stops complaining.
111:14 - And we want to filter on couple of things.
111:16 - So in our app, we have our user's first name, last name.
111:20 - We also have their Twitter.
111:22 - And so let's give our app the ability to either search people
111:25 - by their first name, last name, or search via the Twitter.
111:29 - If you take a look at the data that our Strapi API returns,
111:33 - we have all these different things we could search on.
111:34 - So we're going to select to search on first or last or Twitter.
111:40 - So if any of those things match our query param that we pass,
111:44 - then go ahead and return any of the matching items.
111:48 - And the way we're going to do that is we're
111:51 - going to use our filters.
111:52 - And we could use the or because we're
111:54 - going to have a couple of different terms.
111:56 - So we're going to say, or, and it's an array.
112:00 - And it's going to be an array of objects of the items
112:03 - we want to check.
112:04 - So we want to check first.
112:05 - And so we're going to say, if first name,
112:08 - and we're going to use contains.
112:10 - And if you're like, where are you getting all this stuff?
112:12 - I'll show you again in just a second.
112:14 - But for instance, we're going to check,
112:16 - does the first name contain our query param that we set?
112:21 - So whatever we type here, and we click Enter.
112:24 - And notice how we just returned one entry with Paul
112:27 - because it found an exact match.
112:29 - And so the way it works is because we're
112:31 - taking this query term, and we're passing it from our form,
112:37 - recatching it in our loader.
112:39 - And we're taking that query term,
112:42 - and we're passing it into get contacts.
112:44 - And inside get contacts, within this filters object that
112:48 - is used by Strapi, we're saying, hey, check all the items.
112:52 - Check in the field first and see if it contains that query term.
112:55 - And we're actually going to also check for last name, last.
112:59 - And we're going to use this contains our query string.
113:04 - And then we're also going to check at Twitter.
113:07 - So we want to also match for Twitter items.
113:11 - We're going to say contains queue, perfect.
113:14 - And so now when we're sending our request,
113:17 - we're checking via our filter params
113:20 - to check does the first name contain the query string,
113:23 - or does the last name contain the query string,
113:25 - or does a Twitter handle contain that query string.
113:28 - And so now if we go back in our application,
113:30 - and let's say we go back to regular where we're not using any.
113:35 - So for instance, let's say I want to find Monica Powell's.
113:39 - I should be able to type Monica and click enter and boom.
113:44 - It will go ahead and show her if I remove the query.
113:48 - Let's say I want to find someone by last name.
113:50 - Let's say Lee.
113:51 - I could do Lee enter and then let's back.
113:54 - Or if I want to find someone by the Twitter handle,
113:58 - I could do at coding 30.
114:01 - That's my Twitter handle.
114:03 - So when I click enter, go, here you go.
114:05 - It goes and finds me.
114:07 - So you could see that we're able to search either
114:10 - by first name, last name, or the Twitter.
114:12 - But the experience is still terrible.
114:13 - I still have to type in my search, right?
114:16 - Like John and hit enter.
114:19 - Wouldn't be awesome if we could just start typing
114:23 - and it will automatically search and make a request to find that item.
114:28 - So let's go ahead and see how to do that next.
114:31 - And the coolest part about this right now,
114:32 - I went ahead and I disabled JavaScript.
114:35 - So right now, our JavaScript is disabled.
114:38 - And I'm going to continue blocking JavaScript
114:40 - because I want to show you something cool here.
114:41 - So our application will still work because it doesn't rely on JavaScript.
114:47 - And that is the cool part about Remix,
114:49 - this whole concept of progressive enhancement.
114:52 - So you could get majority of each of your functionality
114:55 - to work without JavaScript.
114:56 - And then you use progressive enhancement to improve the user experience.
115:00 - And I think it's kind of cool.
115:01 - And you could definitely look up more about this
115:04 - through reading on Remix documentation
115:06 - or just Googling progressive enhancement.
115:09 - But that is pretty, pretty awesome and pretty ecstatic.
115:13 - So now let's synchronize our search value inside our search box to our URL param.
115:19 - And what I mean here, if I type Paul right now, for instance,
115:22 - and click enter, it's going to go ahead and find Paul, of course,
115:24 - and we have this query string.
115:26 - And if I type John, it's going to go ahead and look for anything matching John.
115:34 - But what if I type a value here, let's say Lee and click enter.
115:39 - Notice we're able to find Lee, but we don't see this value inside our search box.
115:44 - So let's go ahead and add that first.
115:46 - So inside our root.tsx file, inside of our loader function,
115:51 - we're going to return our contacts,
115:54 - but we're also going to return our query param, which will be available to us.
115:59 - And let me rename this to Q just to make it much simpler here.
116:03 - And we will have to adjust this by the structuring our contacts and our query.
116:11 - And now inside our form, we're going to say the fault value,
116:16 - it's going to be either Q or an empty string.
116:21 - And let's see if that worked.
116:23 - We could type Paul, click enter, great, we found Paul.
116:27 - Now let's say if I type Lee here, Lee, enter, notice that it updates our UI.
116:32 - So there's still one issue we have, notice how we're on John.
116:36 - And if I switch back, the URL changes, but the search param inside the search box doesn't change.
116:43 - It only changes when I hard refresh, but we don't want to do that.
116:47 - We want this to be done automatically.
116:49 - So let's fix this by using a use effect.
116:52 - Let's import our use effect.
116:55 - So let's say import use effect, and that's from react.
117:03 - And we're going to scroll down here inside our app.
117:07 - After contacts, we're going to say use effect, which is going to take another function.
117:14 - And what's cool in remix, we could make this form be a controlled form or keep it uncontrolled form
117:21 - the way it is.
117:22 - If we were to make this a controlled form in order to get this value,
117:26 - we would have to use state and do something value equal set value and then do it this way.
117:32 - But you could actually just stick to JavaScript.
117:34 - So one way to get the data or the value of this form is just by using JavaScript
117:41 - and getting it based off this ID.
117:43 - And that's exactly what we're going to do in our use effect.
117:46 - So we're going to say const search field equals document dot get element by ID.
117:54 - And that ID is going to be Q.
117:56 - So that's going to give us access to our form element or I should say our input element that
118:03 - we have here, we're going to do a little type check here, we're going to say if search field
118:09 - is instance of HTML input element, then let's use it.
118:17 - And so we're going to get the value or set the value I should say by saying search field
118:23 - dot value, and it's going to be equal to either our query param or an empty string.
118:32 - Perfect.
118:33 - And let's set our dependency, which is going to be our query param.
118:37 - And this should fix that issue.
118:39 - So let's go back and check it out.
118:40 - So now in our app, when I use the back button before when our search field wasn't being updated
118:47 - with our current selected data, now it does so, which is pretty cool.
118:51 - So now let's finally add the ability to submit our form when we are typing,
118:57 - which currently is not what happening.
119:00 - So now in our root.tsx file, let's go down back to the form.
119:04 - And currently, if we take a look at our form, the only way we're able to submit it is by
119:08 - by hitting the enter button.
119:10 - But what we want to do is submit our form programmatically when values in the form change.
119:15 - And so what we're going to do, we're going to use on change prop.
119:19 - This is going to take a function that's going to currently be blank right now.
119:25 - And remix has a use submit hook that allows you to programmatically submit a form.
119:31 - So let's go ahead and import it.
119:33 - So here we're going to say use submit and scrolling down inside our app component.
119:41 - Let's do const submit equals use submit.
119:48 - And now we could use our submit method here inside our form in the on change.
119:54 - We're going to say submit and inside we're going to get our event.
120:01 - And let me move this down to another line so it's easier to see.
120:05 - And from our event, we're going to get current target.
120:10 - So this is going to get the value from our form.
120:12 - So let me refactor that a little bit.
120:14 - So perfect.
120:15 - So now anytime our form changes, we are going to fire this submit method that's going to go ahead
120:23 - and programmatically submit our form.
120:26 - So let's see if that works.
120:27 - So in our application, I'm going to type Paul and notice how now every time our form changes,
120:33 - we're able to query our search, which is pretty awesome.
120:39 - So currently when I am typing things to search, we don't have any visual representation that
120:46 - something is happening.
120:47 - So if we had a slower network, so let's go ahead here into network and say we have a very slow
120:56 - 3G network.
120:57 - And so any type I type something, notice how it takes a while to search for the item.
121:06 - So let's go ahead and improve the experience by adding a loading spinner.
121:12 - And we're going to reference the documentation to see how to do this.
121:16 - And in the remix, we have the use navigation hook, which gives us some feedback.
121:22 - So let's go ahead and use it.
121:24 - So what we're going to do is first import the use navigation hook.
121:29 - So after submit, we're going to say use navigation.
121:34 - And then inside our app component, we're going to do const navigation is equal to use navigation.
121:45 - And then we can also do navigation dot to kind of see all the things that we have access to.
121:52 - For instance, we have form action form data for methods and so on.
121:56 - And then we also have this access of state, which tells us if we are submitting, if it's
122:02 - idle or loading.
122:03 - So we have all these useful methods that we could use.
122:06 - So for the particular example here, we're going to use navigation location.
122:12 - And we're going to check if the query has a query parameter to identify if we are currently
122:20 - in searching state.
122:22 - So when there's nothing's happening, as you could see here, navigation location will be
122:26 - undefined.
122:27 - But when the user navigates, it will be populated with the next location while data loads.
122:33 - So let's go ahead and implement this.
122:35 - So we're going to say const searching is equal to navigation location.
122:43 - And we're going to create new URL search params, nav location search.
122:53 - And then we're going to check if it has our query.
123:00 - So now let's go ahead and utilize this in our form.
123:04 - So we're going to scroll down to input and we already have the CSS set up.
123:08 - So here we're going to say class name, and we're going to say if searching, then we're
123:14 - going to append the class loading.
123:16 - And if we're not loading, just have an empty string.
123:20 - And here currently our spinner is hidden.
123:23 - But now let's only make it hidden if we're not searching.
123:27 - Nice.
123:27 - So this should do the trick.
123:28 - So just quick review in the searching variable, we're able to use navigation location to check
123:36 - if we're currently in searching state.
123:38 - If so, we're going to use it here in our input.
123:42 - So if we are searching, we're going to change our class to loading, which is going to style
123:47 - our input appropriately.
123:49 - And same thing here for our spinner, which is currently hidden if we're not searching.
123:54 - But if we are searching, it's going to show.
123:57 - So let's go ahead and test it in our application.
123:59 - So now when I start typing, so notice how you could see the spinner happening when we're
124:05 - loading.
124:06 - This is pretty cool.
124:08 - So now let's see how we could improve our search functionality.
124:11 - And referring to remix documentation, they have a bit here called managing the history
124:16 - stack.
124:16 - And what is happening since the form is submitted on every keystroke, typing each character
124:22 - and then deleting it will create a huge history stack, as we could see in this example.
124:28 - So to prevent this, let's see the changes that we could do.
124:30 - So here we could use replace in submit.
124:34 - So let's search replace us props.
124:36 - And as you can see here, what replaced us, it replaces the current entry in history stack
124:41 - instead of pushing a new entry, which is exactly what we need in this use case.
124:46 - So let's go ahead and implement this in the code.
124:48 - So let's scroll down and make the following changes in our function that we're passing
124:53 - to our on change.
124:55 - So the first thing we're going to do, we're going to put it in the brackets.
125:00 - And above the submit, we're going to create a const.
125:03 - And we're going to call it is first search.
125:07 - And we're going to say if query is equals to null, then it is first search.
125:14 - Then inside of our submit method here, we're going to pass a second argument.
125:19 - And we're going to say replace.
125:21 - And we're going to say exclamation point is first search.
125:26 - Fantastic.
125:27 - So now that should fix our history stack issue and everything else should work accordingly.
125:33 - So now when we start using our search, instead of creating a new item and pushing it to our
125:41 - history stack, instead, it's going to replace it, which is awesome.
125:46 - So pretty much we're done with all of our basic implementation.
125:49 - So let's review what we've done quickly and then see some of the basic improvements we could add
125:54 - before finishing this tutorial.
125:56 - So we implemented full CRUD functionality using remix and Strapi.
126:00 - Our front end is built with remix and our back end is built with Strapi,
126:05 - where we're able to manage our user's database and information.
126:09 - Inside of our front end application, we're able to create a new user free code camp.
126:16 - If I try to create the form without validating required fields,
126:20 - we get our validation, which we use zod for, which is pretty awesome.
126:25 - So let's add our image and our Twitter handle and be able to create a new item.
126:30 - We're also able to like or unlike our item.
126:34 - We're going to like it.
126:35 - We are also able to edit.
126:37 - You are all awesome and safe, which will update our message.
126:43 - And we have our search functionality where we're able to search the items,
126:47 - which is great.
126:48 - And we could also delete, but we'll leave free code camp here.
126:52 - So let's take a look at some of the improvements.
126:54 - So one improvement we're able to do is notice when we select an item,
126:58 - the matching navigation item is not highlighted.
127:01 - Wouldn't be nice that we could show what link is active once it's selected.
127:05 - For instance, if I go out Paul Braslowski, this should stay selected.
127:09 - So let's take a look how we could fix this.
127:11 - So in our code, if you navigate to our root.tsx file and we scroll down to our link,
127:18 - we have a couple of different classes that we're able to add.
127:22 - So inside our CSS that was provided with this project, we have a class called active.
127:28 - If we take a look at what that looks like.
127:30 - And again, because right now we're not checking to see which link path is matching.
127:35 - So it's going to highlight all of them, but you could see that we have a highlighted active class.
127:39 - And we also have a pending class, meaning it's pending to load.
127:45 - So if we take a look, you see this nice pulsing animation.
127:49 - So what we could actually do in remix, we have a component called Nevelink.
127:56 - And Nevelink allows you to pass a function to your class name, which is going to have two states.
128:02 - And the function is going to have a state is active and another state called is pending.
128:10 - So what we could do is return.
128:13 - If the item is active, let's show the active class.
128:20 - And if it's not active and it is pending, let's show the pending class.
128:28 - Otherwise it's going to be an empty string.
128:31 - Now, the reason why this is complaining because we need to import our Nevelink at the top.
128:36 - So let's navigate to the top.
128:38 - And after use navigation, we're going to say nav link.
128:42 - So now if we scroll back down, notice how we're no longer having issues.
128:47 - So now let's take a look at our UI.
128:50 - So notice, since I'm on Paul Baslavsky, the route matches, it's active.
128:55 - So it's highlighted.
128:56 - If I switch to Shane Walker, notice how it's highlighted.
129:00 - And because we're loading things fairly quickly, we don't see the pending state.
129:03 - So let me go ahead and throttle down by going to network and say throttling and use slow 3G.
129:11 - Notice when I switch, now we have that pending state until the item loads, which is pretty awesome.
129:18 - So another improvement we want to make is for this star and on star function.
129:23 - Currently we implemented it using regular remix form submission, which is okay.
129:28 - But because we're not navigating and just want to change the data,
129:31 - instead of using just the regular form, we could use use fetcher.
129:35 - So let's take a look at remix documentation to kind of see what this means.
129:40 - So we could actually have forms without navigations.
129:43 - And this is where use fetcher comes in.
129:46 - It allows you to communicate with the action and the loader without causing navigation,
129:51 - which happens automatically when just using form.
129:54 - And since we're remaining on the same page and we don't want to change pages
129:58 - and just want to get the data, use fetcher is the perfect fit.
130:02 - Let's go ahead and use fetcher in our code.
130:05 - So in our project, let's go to apps and routes and let's navigate to our contact id.tsx route.
130:13 - And first thing we're going to do is we're going to import fetcher up.
130:17 - And I missed it the first time.
130:19 - So action function arcs, this should be a type if we didn't make that change before.
130:24 - But now let's go ahead and here import use fetcher.
130:30 - And now let's scroll all the way down to the bottom until we get to our favorite component here.
130:36 - And inside here, let's do const fetcher equals use fetcher.
130:43 - And the only change we need to do is instead of saying form, we are going to say fetcher form.
130:50 - And that's the only change we have to make.
130:52 - So now the form will no longer cause navigation,
130:55 - but simply fetch the action and fire the logic required to update our star state in the database.
131:02 - So if we go back to our application, notice how everything still works the same.
131:07 - And next, finally, let's take a look how we could throw errors if something happens to our backend.
131:13 - So in our application, let's go to data.server.
131:16 - And we're going to look at get contacts and notice how we have a try and catch.
131:22 - And if everything goes well and smoothly from Strapi, we will return our data, including Strapi
131:29 - errors. But if this try and catch block fails, we want to return an error here.
131:34 - And we know whenever we throw an error, it is going to be caught by our error boundary.
131:40 - And we have a couple of them in our application,
131:43 - but we're going to take a look at the one inside our root.tsx file.
131:49 - And here we have our error boundary.
131:50 - And whenever there's an error that's thrown, we have an error.
131:53 - What I'm going to do just simplifies this a little bit, I'm going to delete this h1.
131:58 - So instead, we only get the messages that are delivered from our error.
132:02 - And I'm going to make this an h1.
132:04 - So before we throw an error, just want to make a note here.
132:07 - And you could search error,
132:08 - sanitization in the remix stocks within production mode, any error that happens to be
132:13 - on the server are automatically sanitized to prevent leaking any sensitive information,
132:19 - such as stack traces to the client.
132:20 - This means when we use and throw a new error, the instance of an error that we receive using
132:27 - use router error hook will be a generic message and no stack trace.
132:31 - So one way we could throw errors is by just doing throw a new error with some message.
132:38 - So let's check this out.
132:40 - So in our application, in our root.tsx file, we are calling the loader where we get in context.
132:46 - So let's go to get context within our data.server.ts file.
132:50 - And here in our try and catch blocks, right after the console log,
132:55 - we're going to throw a new error.
132:57 - Oh, no, something went wrong.
132:59 - So if there's a server error or something is wrong, this will be caught in this catch block,
133:06 - which will throw an error.
133:08 - And depending which route this error occurred, we'll use the appropriate error boundary.
133:14 - And in this case, this is going to happen inside the loader in our root.tsx file,
133:19 - which is going to use this error boundary.
133:21 - So now let's say if we go to our data.server file, and let's say we don't pass a URL,
133:29 - and boom, oh, no, something went wrong.
133:32 - And where is that text coming from?
133:33 - It's coming from our data.server from this thrown new error.
133:39 - Another way you could throw errors is using the response object.
133:43 - So we take a look at the documentation, you could throw a new response,
133:48 - including the message that you want with the status code.
133:51 - So I'm going to go ahead and replace it here, just so you could see another variation.
133:56 - So now not only are we sending the response message, but we're also returning the status.
134:02 - If I refresh, notice how we're getting the 500 error.
134:06 - One thing you may notice when we had our error, we just showed the status of 500,
134:11 - but how do we display the text?
134:13 - So going back to our root.tsx inside our error boundary,
134:18 - we are getting the error using the response and passing the 500,
134:22 - and we are able to see the status.
134:24 - Let's take a look at what the error object looks like
134:26 - before we see the changes that we need to make.
134:29 - So before we figure out what's going on, let's go ahead and console log the error object.
134:34 - So now I'm going to refresh, and we get our error object.
134:37 - If you look, we take a look that our status text is blank,
134:41 - but we get our message within the data.
134:44 - So two ways to fix this.
134:45 - One thing you could do is inside the error boundary here,
134:51 - you could do an or statement, which will basically say
134:55 - if status text is an empty string, return error.data,
135:02 - and that's going to fix the issue.
135:04 - So if we go back here and I refresh, notice we're getting our message.
135:08 - Another thing that you could do is inside the data.server file after status,
135:14 - you could do status text, and you could add a custom message.
135:19 - This is custom error, and that would work as well.
135:25 - So let's take a look if I refresh, and notice we get this is my custom error.
135:30 - So now you have two ways to throw errors.
135:32 - You could either use throw new error or use throw new response.
135:35 - And now that we finally know how to throw our errors,
135:38 - this bring us to the end of our amazing journey.
135:42 - You did it.
135:43 - Thank you on embarking this journey with me of learning,
135:47 - remix basics and Strapi.
135:50 - And the most important part, what we learned today about remix,
135:54 - about basic usage of Strapi, you could now start building cool things.
135:58 - My biggest goal for myself is to build things quickly as easily as possible.
136:04 - And I hope you could see how combining remix and Strapi allows you to do that.
136:09 - This was just the beginning tutorial, so there's definitely a lot more to learn.
136:14 - You could check out my channel Coding After 30.
136:17 - I have a great Strapi crash course that you could take for absolutely free.
136:22 - And if you really like this tutorial here on Free Code Camp,
136:26 - and you want me to make more tutorials, just smash the like button.
136:28 - Let me know in the comments if you want me to make tutorials here on Free Code Camp.
136:32 - I really believe in free education,
136:35 - and I am more than willing to share everything I know about web development
136:40 - as someone who switched careers late in their 30s.
136:44 - Into development to share here on this channel.
136:47 - And if you have any questions, let them know in the comments.
136:50 - Also, you could go to the GitHub of this project,
136:54 - where I shared the link at the beginning of this video.
136:57 - And you could create an issue with your question,
136:59 - and I'll make sure to help and answer.
137:01 - And I'll also, once this goes live on Free Code Camp,
137:04 - I'm going to make sure to create a thread on their forum,
137:08 - so that way I could talk with you and help you with this course.
137:12 - Because I'm not AI-generated, and I am a human,
137:14 - I might have made a mistake here or there.
137:16 - And so if you find one, please let me know,
137:19 - and I'll fix it as soon as possible.
137:21 - But with that being said,
137:22 - thank you so much for coming on this amazing ride with me
137:26 - and learning Remix and Strapi.
137:28 - With that being said, I'll see you in the comments section.
137:31 - Take care.