00:00 - hi all and welcome to this new tutorial
00:02 - series to create a neural network in
00:06 - javascript which we will hopefully use
00:08 - to automate the game asteroids now we
00:12 - made this game asteroids in another
00:14 - tutorial series so feel free to check
00:16 - that out you can download the code from
00:17 - the links below there should be a sounds
00:20 - folder and an html file
00:23 - so let's open the game up
00:26 - so there's a triangular ship that can be
00:27 - moved around the screen
00:29 - and it can shoot
00:31 - the asteroids
00:33 - i'll just mute that
00:35 - so the goal of this tutorial series is a
00:37 - very simple one and intentionally so
00:39 - because new neural networks can be quite
00:42 - challenging
00:43 - the goal is to rotate towards the
00:45 - closest asteroid
00:47 - and shoot
00:48 - rotate to the next closest asteroid and
00:51 - shoot
00:52 - it's not going to be an algorithm we're
00:53 - going to train a neural network to do
00:56 - this
00:57 - so what is a neural network
01:00 - well here it is
01:02 - basically they're made up of a number of
01:04 - layers so an input layer a hidden layer
01:07 - and an output layer you can have
01:09 - multiple hidden layers but we'll focus
01:11 - on just having a single hidden layer to
01:13 - keep things simple
01:15 - now the input layer it will take our
01:17 - game information so we could pass things
01:20 - such as the angle to the nearest
01:22 - asteroid or the current angle of the
01:25 - ship
01:26 - the hidden layer is more like a
01:28 - processing layer i guess and the output
01:31 - well we'll probably have a single output
01:32 - whether to turn left or turn right so
01:35 - that'll be a single boolean so zero will
01:37 - mean left one will mean right we'll keep
01:40 - things nice and simple because these
01:42 - things can be quite complicated
01:44 - in between each of these layers there's
01:46 - a whole bunch of black arrows now each
01:48 - of these black arrows represent a weight
01:51 - a weight between -1 and 1 i believe
01:54 - so for each neuron in the previous layer
01:57 - it sends out information to each of the
01:59 - neurons in the next layer
02:01 - so ultimately we'll be sending in some
02:04 - training data for example the asteroid
02:07 - position and the ship's current angle or
02:10 - something similar and we'll feed that
02:12 - through with an expected output so
02:14 - either to turn left or turn right
02:17 - now if it gets it wrong we'll send that
02:19 - information back
02:21 - to the input i guess
02:23 - and use that to correct these weights so
02:26 - ultimately we'll be sending in thousands
02:28 - of points of information
02:30 - correcting these weights until finally
02:32 - we have a unique set of weights that can
02:34 - take any of our game information and
02:36 - give us an accurate and reliable output
02:40 - so here's the position of an asteroid
02:42 - what do i do
02:43 - turn left here's another position of a
02:46 - different asteroid what do i do turn
02:48 - right
02:49 - let's just close that down
02:52 - we'll have to create a new javascript
02:54 - file
02:55 - just a plain text document called say
02:57 - neural network
02:59 - neural
03:00 - network and give that the js extension
03:05 - yes and open both of those in your
03:08 - favorite editor i'm using visual studio
03:10 - code here
03:12 - so the first thing we should do is set
03:13 - up a flag to let us know that automation
03:15 - is on
03:16 - so currently we have a whole bunch of
03:18 - flags in here how about we pull them out
03:21 - and we'll put them in a different
03:22 - section just to make it a little bit
03:23 - tidier how about developer flags
03:27 - paste them in there
03:29 - sorry just doing some housekeeping
03:32 - so let's create a new constant called
03:34 - automation
03:37 - automation on
03:38 - we'll set that to true initially
03:41 - so when the automation is on we'll want
03:43 - to set up our neural network so just
03:45 - after we set up the game parameters here
03:48 - so after new game here
03:50 - set
03:52 - up the
03:53 - neural network
03:57 - so if automation is on
04:01 - let's leave ourselves a to-do here
04:04 - because we can't do it at the moment to
04:06 - do
04:07 - neural
04:08 - network
04:11 - good now also when the automation is on
04:14 - we don't want the player to be able to
04:17 - to control the ship do we so down in our
04:19 - key press uh functions so key key down
04:23 - yep here we go key down and key up so if
04:26 - the ship is dead or
04:28 - automation is on
04:30 - return don't do anything so they can
04:32 - press the keys as much as they like
04:34 - nothing will happen
04:35 - similarly in the key up method
04:37 - if ship is dead or automation is on
04:41 - return we'll let the computer control
04:43 - the ship
04:45 - speaking of computers controlling ships
04:47 - let's head down to the update function
04:49 - that's where all the
04:51 - objects drawn and moved and so on so
04:53 - just the start of the update function
04:56 - just up near here somewhere how about we
04:57 - say use the
05:00 - neural network
05:02 - to
05:03 - control to rotate the ship
05:06 - and shoot
05:09 - and shoot
05:11 - so again we'll just leave ourselves
05:13 - so if automation is on
05:16 - we'll leave ourselves a to-do here so do
05:19 - uh
05:20 - control ship
05:23 - okay good
05:26 - let's just make sure that we haven't
05:27 - broken anything so head up the top uh
05:30 - first of all let's try it with the
05:31 - automation flag on
05:40 - okay so i'm moving the arrow keys i'm
05:42 - pushing the spacebar nothing's happened
05:45 - and just to make sure that we haven't
05:46 - broken anything let's set it to false
05:53 - yep i can control the ship in that
05:54 - situation so when it's turned on
05:58 - when it's true
06:01 - i've lost control of the ship awesome
06:05 - now head over to our new file neural
06:07 - network dot js at the top of that file
06:10 - let's use a flag use strict
06:12 - now what use strict does it basically
06:14 - enforces good coding practice things
06:16 - like you must declare variables and so
06:18 - on we're also going to focus on es6
06:21 - javascript now es6 is like the latest
06:25 - major revision to javascript syntax
06:27 - things like class and constructors and
06:30 - so on so we're going to use that we'll
06:32 - try to use that throughout this tutorial
06:34 - series
06:35 - now neural networks use a lot of maths
06:38 - specifically matrix maths
06:41 - so how about we create a
06:44 - heading here called matrix functions
06:48 - a matrix is essentially just a
06:51 - two-dimensional array
06:52 - so
06:54 - it has a number of rows and a number of
06:56 - columns
06:57 - so i'm just making this stand out a
06:59 - little bit
07:00 - matrix functions there we go so how can
07:03 - we represent a matrix well how about we
07:06 - represent it as a class so class matrix
07:11 - give it a constructor
07:13 - the constructor will take a number of
07:14 - rows and a number of columns
07:17 - and how about optionally we'll have data
07:20 - here as well so if we put an equal sign
07:22 - here it's a default value so by default
07:25 - it will be an empty
07:27 - array
07:29 - so inside the constructor
07:32 - let's set the variables now usually
07:34 - private variables private instance
07:36 - variables are prefixed with an
07:38 - underscore so we'll follow that
07:40 - convention
07:41 - do the same sort of thing for the
07:43 - columns
07:45 - and the data
07:50 - calls and data now to access those
07:52 - variables we should put some getters so
07:55 - just get
07:57 - rows
08:00 - and all that does is return
08:02 - this
08:02 - dot underscore rows
08:05 - and do a similar thing for each of the
08:08 - other variables
08:11 - so coles
08:13 - data
08:16 - this
08:17 - calls and this
08:19 - data
08:22 - so to use that when we declare an
08:24 - instance of this matrix we'd go matrix
08:27 - dot rows and that would return
08:30 - this dot rose
08:32 - so inside the constructor let's
08:34 - initialize
08:37 - initialize with zeros initialize with
08:39 - zeros
08:41 - if no data
08:43 - provided
08:46 - so if data
08:48 - equals null
08:50 - somebody could pass null couldn't they
08:52 - or data dot
08:54 - length
08:55 - equals zero so in the default case
08:58 - that's true
09:00 - if either of those things occur then we
09:02 - want to populate this data this
09:06 - data will equal a new empty array
09:10 - you'll have to loop through each of the
09:13 - rows so four let i equals zero so let's
09:18 - is one of these new es6 words basically
09:21 - it means that i is only visible within
09:23 - the for loop
09:24 - let i equal 0 i is less than this
09:28 - rows
09:30 - i plus plus
09:32 - lowercase i plus plus
09:36 - we'll want to initialize the row so this
09:40 - data
09:41 - i
09:42 - will equal an empty array
09:46 - and we'll loop through each of the
09:50 - columns so let j equals zero
09:54 - j is less than this
09:58 - coles
10:00 - j plus plus
10:03 - this
10:04 - data
10:05 - will this data i
10:08 - j
10:09 - so we'll set each of the elements
10:12 - to equal
10:13 - zero
10:16 - good
10:17 - if data is passed we'll probably want to
10:19 - check its integrity for example somebody
10:21 - could put three rows three columns but
10:24 - provide data with only two rows so
10:26 - that's not good is it so let's put an
10:28 - else here
10:29 - else
10:31 - will check
10:32 - data integrity
10:36 - so if the data's length
10:40 - doesn't equal the row number doesn't
10:42 - equal rows
10:43 - or
10:45 - data
10:46 - maybe data zero dot length so that's the
10:49 - column length isn't it
10:51 - doesn't equal coles
10:53 - then let's throw a new error so throw
10:56 - new
10:57 - error now the error takes a message
11:00 - you can just put something like
11:02 - incorrect
11:03 - uh data dimensions
11:08 - that should be enough
11:10 - so let's test this let's go back to our
11:12 - main file
11:15 - we'll have to import that
11:17 - file so we can do that up in the
11:20 - style script
11:22 - create script tags so script
11:25 - and we'll need a type type will equal
11:29 - text
11:30 - javascript
11:34 - and the source will equal
11:38 - dot sorry dot slash that means the
11:41 - current directory
11:42 - uh neural
11:45 - network whatever we named our file
11:48 - neural network dot js
11:51 - close the script tags
11:54 - so head down to where we will initialize
11:56 - or set up our neural network just in
11:58 - here
11:59 - let's try to set up some matrices so let
12:02 - m0 equal new
12:04 - matrix
12:05 - uh rows say two rows three columns
12:10 - and let's output that to make sure that
12:11 - it's working
12:13 - we could probably use the table command
12:14 - here because it outputs table data
12:17 - tabular data
12:18 - so m0.data
12:23 - that's the data of our matrix
12:25 - let's take a look at that just need to
12:27 - open the console
12:29 - here we go we have a 2 by 3 matrix full
12:33 - of zeros
12:34 - that's good
12:37 - let's try to pass some data
12:40 - so we can do that by setting up an array
12:42 - here
12:42 - so
12:44 - an array of arrays i should say so 2 1
12:47 - just adding some values here
12:50 - and the next row four
12:52 - three
12:54 - uh four three zero say
12:56 - okay let's give that a go
12:59 - there we go two one minus one four three
13:02 - zero
13:04 - two one minus one four three zero now
13:06 - what if we declared the incorrect
13:08 - dimension here just so we said a three
13:10 - by three matrix instead of a two by
13:12 - three let's check our area checking
13:16 - good error incorrect data dimensions
13:20 - put that back
13:22 - to
13:25 - awesome
13:27 - head to our other file to create another
13:29 - function
13:30 - so let's create a function that
13:31 - randomizes the weights or creates a
13:34 - random set of weights remember between
13:36 - our neurons there's going to be some
13:38 - weights
13:39 - between -1 and 1 so let's create a
13:42 - function for that so apply
13:45 - random
13:47 - weights
13:48 - between
13:50 - minus one and one
13:52 - so we'll call this random
13:55 - weights
13:57 - so this is inside our class
14:00 - for
14:01 - let i equals zero
14:04 - i is less than this dot rows
14:09 - i
14:10 - plus plus
14:14 - for the columns for let j equals zero
14:18 - j is less than this dot columns
14:24 - j plus plus
14:27 - this dot data
14:30 - i
14:32 - j
14:34 - will equal
14:36 - math
14:37 - random
14:39 - that's a number between 0 and 1
14:41 - times
14:42 - 2 times two minus one
14:46 - so a random number between zero and two
14:49 - minus one is minus one between minus one
14:51 - and positive one
14:53 - good let's test it in our other file
14:56 - so on m0 we can just go m0 dot random
15:02 - weights
15:04 - and hopefully that should work
15:07 - so currently that's what it looks like
15:09 - let's run
15:10 - it ah there we go yep that looks good we
15:13 - got some random weights negatives
15:15 - positives and everything in between
15:18 - great
15:20 - head to our other file and let's create
15:22 - our next method
15:25 - add to
15:27 - matrices
15:28 - so we'll make this a static method that
15:30 - just means we don't have to instantiate
15:32 - the class we can just call it directly
15:34 - we can go matrix dot
15:36 - add
15:37 - it will require two matrices m0 and m1
15:43 - we probably want to check that them to
15:45 - make sure that they have the same
15:46 - dimension so we can go we'll create a
15:48 - new method a new static method matrix
15:51 - dot
15:52 - check
15:52 - dimensions
15:55 - it will require m0 and m1
15:59 - let's create that now actually
16:01 - so check
16:04 - matrices have the same
16:09 - dimension
16:12 - same dimensions
16:14 - so
16:15 - static
16:16 - check dimensions m0 and m1
16:21 - if m
16:24 - if
16:25 - m0.rose
16:28 - doesn't equal m1 dot rose
16:32 - or
16:34 - m
16:35 - zero dot coles
16:37 - doesn't equal
16:40 - m one dot coles
16:43 - then let's just throw a new error throw
16:47 - new
16:48 - error
16:50 - the message we could
16:52 - how about matrices are
16:56 - of different
17:01 - dimensions
17:08 - okay
17:09 - so we check that
17:11 - now we'll need to create a in our add
17:12 - method we'll need to create a new
17:15 - return matrix so let m equal new matrix
17:22 - uh the rows will just be the same as
17:25 - what's passed so m0 dot rows
17:28 - m0 dot columns
17:32 - and we'll need to loop through each of
17:34 - those so let i equal zero
17:38 - i is less than m
17:41 - dot
17:42 - rows
17:44 - i plus plus
17:48 - and another loop for let
17:51 - j equals zero
17:53 - j is less than
17:56 - m dot coles
18:00 - j plus plus
18:03 - what will we do here so m dot data
18:06 - i
18:08 - j
18:09 - will equal i'll just copy that
18:12 - m
18:13 - 0
18:15 - m 0 dot data i j
18:19 - plus
18:20 - m 1 dot data i j so we're just adding
18:24 - the each individual cells together and
18:26 - assigning it to the new matrix
18:29 - and we'll have to return that matrix
18:31 - return m
18:33 - okay let's test that in our other file
18:36 - first we need a couple of more matrices
18:38 - to test with
18:40 - so let's create two more m one which
18:43 - will be two by three and just change up
18:45 - some of these numbers here
18:49 - that will do
18:50 - and m two
18:53 - will be a different sized matrix say two
18:55 - by two
18:56 - so let's just delete
19:00 - that okay good
19:03 - uh let's try it we don't need to use
19:05 - this random weights anymore let's try to
19:08 - add m1 and m2 it shouldn't work because
19:10 - there are being invalid sorry they're of
19:12 - different dimensions so matrix dot add
19:17 - m1
19:19 - m2
19:21 - let's try that
19:23 - error matrices are of different
19:25 - dimensions and that's in the
19:28 - that's on line 81
19:30 - yep that's correct
19:32 - how about we try to add
19:34 - m0
19:36 - well m m0 and m1 they should add we'll
19:41 - probably want to print out the data
19:43 - before we add them
19:46 - m0 data m1 data
19:49 - and we'll print out this starter
19:56 - there we go so we'll add that and show
19:58 - the data of the
20:00 - result matrix
20:03 - okay so the first matrix two one f one
20:06 - four three zero next matrix zero one
20:09 - blah blah so adding each of these so two
20:12 - plus zero equals zero
20:14 - sorry
20:15 - two plus zero equals two
20:18 - four plus two equals six that's right
20:20 - one plus one equals two three plus minus
20:24 - three is zero minus one plus minus one
20:26 - is minus two and zero plus zero
20:29 - zero plus zero equals zero good adding
20:32 - works head back to our other file
20:36 - we also need to be able to subtract
20:38 - matrices so it'll be very similar to
20:41 - adding so just copy all of that
20:44 - paste it down here
20:46 - subtract
20:48 - two matrices subtract
20:53 - almost identical except that we just
20:55 - need to change this plus to a minus so
20:57 - it'll be m0 data minus m1 data so the
21:01 - order is important here
21:03 - let's test that
21:06 - right so instead of adding m0 and m1 how
21:09 - about we subtract
21:16 - okay so two minus zero is two four minus
21:20 - two is two one minus one is zero three
21:23 - minus minus three is six
21:26 - minus one minus
21:27 - one
21:28 - is zero and zero minus zero zero good it
21:32 - looks like it's working just make sure
21:33 - the error checking is working okay so m
21:36 - two minus m one should not work
21:40 - there we go error matrices are of
21:42 - different
21:43 - dimensions great
21:46 - we also need to be able to multiply two
21:48 - matrices together
21:50 - so in a similar way that we've
21:51 - subtracted them
21:55 - let's set up and
21:56 - multiply two matrices multiply two
22:00 - matrices multiply
22:04 - if you know anything about matrices this
22:06 - is not the dot product so let's make a
22:08 - note not
22:10 - the dot
22:11 - product
22:12 - that's a separate thing we'll need to do
22:14 - that too but it's a different operation
22:16 - it's just multiplying each cell by each
22:18 - cell so all we have to do is change that
22:20 - minus there
22:21 - to at times
22:24 - uh head back and test it so matrix
22:28 - multiply
22:29 - mol
22:30 - multiply
22:32 - uh m2 and m1 shouldn't work let's just
22:35 - make sure
22:36 - yep it doesn't work
22:38 - and m zero and m one should work
22:44 - good two times zero is zero four times
22:47 - two is eight one times one is one three
22:49 - times minus three is minus nine minus
22:51 - one times minus one is 1 0 times 0 0
22:55 - looking good
22:57 - next let's calculate the dot product
23:00 - let's create a function to calculate the
23:01 - dot product of two matrices so dot
23:04 - product
23:05 - of two
23:06 - matrices
23:08 - so static
23:10 - dot
23:11 - m0 and m1
23:16 - now for two matrices to be dot
23:18 - compatible as such
23:20 - the
23:21 - first one's columns must be the same as
23:23 - the second one's rows for example a four
23:26 - by two matrix and a two by four matrix
23:29 - they're dot compatible the inside
23:31 - numbers are the same so for example
23:33 - three by two and two by one they're
23:35 - compatible
23:36 - so let's test for that if
23:39 - uh m0.cols
23:42 - doesn't equal m1 dot rows
23:46 - then we have to throw an error here so
23:49 - throw
23:50 - oops throw new
23:52 - error
23:53 - and the error message can be just be
23:55 - matrices are not
23:57 - uh dot
24:00 - dot
24:01 - compatible
24:04 - okie dokie
24:06 - now the size of the resulting matrix so
24:08 - let's create a new matrix here let m
24:10 - equal new matrix
24:13 - the size of the resulting matrix is
24:15 - equal to the outside numbers for example
24:18 - four by two and two by four the
24:20 - resulting matrix will be a four by four
24:23 - three by two
24:24 - times a two by one would be a three by
24:27 - one so that'll be the m zero dot rows
24:32 - uh and the number of columns will be the
24:34 - m1 dot
24:36 - coles
24:38 - right
24:39 - next we have to do the similar sort of
24:41 - loops that we've been doing in all of
24:43 - these
24:44 - so that
24:47 - so for let i equals zero i is less than
24:50 - the m dot rows i plus plus and for let j
24:52 - equals zero j is less than the m coles j
24:56 - plus plus
24:59 - so inside here is where we need to do
25:00 - our tricky stuff basically we need to
25:03 - add so we need to multiply each cell of
25:06 - the first
25:08 - matrices row by each cell of the second
25:10 - matrices column and then add up those
25:13 - products
25:14 - i'll post a link below how to do this by
25:16 - hand if you're interested so we'll need
25:18 - to create a variable called sum let sum
25:20 - equal zero
25:22 - and another for loop for
25:25 - let k equal zero
25:28 - k is less than the inner number which
25:32 - will be the m0.cols
25:35 - k plus plus
25:39 - and then we'll have some plus equals so
25:42 - we'll continually add this together sum
25:45 - plus equals
25:46 - the
25:47 - m0
25:50 - data
25:52 - i
25:55 - the ith row and then the kth column
25:59 - multiplied by the m1's
26:03 - data
26:05 - and it will be the k
26:08 - row
26:08 - remember the inside numbers are what's
26:10 - matching them by the jth
26:13 - sorry the jth column
26:16 - i think that's right sum plus equals
26:18 - that and then finally we need to set the
26:20 - i j so m
26:22 - dot data
26:25 - i
26:28 - j
26:29 - will equal the sum
26:33 - okie dokie and then finally we'll need
26:36 - to return that matrix
26:38 - return
26:39 - m
26:40 - so let's test that out in our other file
26:43 - so matrix dot
26:45 - dot
26:47 - m0 m1 now m0 is a 2x3 matrix m one's a
26:52 - two by three as well so they're not dot
26:54 - compatible let's just prove that
26:58 - yep error matrices are not dot
27:00 - compatible
27:01 - so which of these are dot compatible
27:04 - well how about m 2
27:07 - m 2 times m 1
27:10 - so a 2 by 2 times a 2 by 3 is dot
27:13 - compatible because the inner numbers are
27:14 - the same
27:15 - let's just update this here
27:18 - give that a go
27:20 - right so the first row entries times the
27:24 - first so times the second
27:26 - first column entries so
27:28 - 1
27:29 - times 0 is 0
27:31 - plus minus 1 times two is minus two
27:35 - yeah
27:36 - the second one so one times one is one
27:40 - plus minus one times minus three is
27:42 - positive three is positive four in total
27:45 - yep looks like it's working fairly well
27:48 - next function that we'd like to do is to
27:50 - create some sort of conversion function
27:53 - to convert a regular array to a matrix
27:57 - because when we pass in our input data
27:59 - from our game into the neural network
28:02 - we'll probably just pass it as a regular
28:05 - one-dimensional array
28:07 - so
28:08 - convert
28:09 - array to
28:11 - a one-road
28:14 - matrix
28:17 - so static
28:20 - uh convert array we'll call it convert
28:23 - from
28:24 - array
28:26 - we'll pass an array
28:29 - and all we'll do is return a new matrix
28:33 - a new matrix with one
28:35 - row
28:37 - the columns will equal the array.length
28:40 - and the data will just be the array
28:43 - itself
28:46 - okay let's try that
28:49 - first of all let's create an array so
28:51 - let array
28:53 - equal
28:54 - just make an array of any length with
28:56 - some random numbers inside
28:58 - we'll want to print that out to the
29:00 - console so console log array
29:04 - and we'll also want to print out the
29:06 - converted array so using table
29:08 - so matrix dot
29:11 - convert
29:12 - from
29:13 - array
29:15 - pass our array
29:17 - and we want to see the data of that
29:20 - okay oh we don't want to see the rest of
29:22 - this stuff so let's just comment that
29:23 - out
29:26 - let's give that a go
29:29 - incorrect data dimensions okay
29:31 - something's gone wrong here
29:33 - 25 in our matrix
29:36 - uh function
29:38 - where are we so up the top of here page
29:41 - f line number 25
29:43 - okay so we failed this data integrity
29:45 - check i can see why because it's
29:47 - checking the data.length now the length
29:50 - of a single dimensioned array is the
29:53 - total length so it would be four in our
29:55 - case but we don't want that we want that
29:57 - to equal the rows which is one
30:00 - so to get around that all we have to do
30:02 - is create a
30:04 - two dimensional array in our convert
30:06 - array so convert from array
30:09 - here we just need to put square brackets
30:11 - around that so essentially we're putting
30:13 - an array inside of an array a 2d array
30:16 - okay let's give that a go
30:21 - that's better so our regular array four
30:24 - five six seven and our converted array
30:27 - to a matrix four five six seven so it's
30:29 - a four columned single row array
30:33 - great
30:35 - next we'll need to create a function
30:37 - that can apply a function to each cell
30:41 - of the given matrix so we'll call that
30:43 - map
30:44 - so just down here
30:47 - apply a function to each cell
30:52 - of the
30:53 - given matrix
30:55 - the reason we need to do that i do this
30:57 - is because in neural networks we'll be
31:00 - using a function called the sigmoid
31:01 - function
31:02 - and we'll need to apply it to every cell
31:05 - so let's create a static method static
31:08 - map
31:09 - which takes
31:10 - m 0 a matrix and a function we'll just
31:13 - call that m function
31:16 - and we'll need to create a new uh
31:19 - matrix so let m equal new matrix it'll
31:23 - be of the same size as the past so
31:26 - m0.rows
31:29 - m0
31:30 - dot coles
31:33 - and we'll have to loop over in similar
31:36 - fashion to what we've done up here
31:39 - so let i equal zero i is less than m
31:42 - zero dot well m rows is okay too
31:45 - m rows i plus plus
31:47 - j
31:48 - yep
31:51 - and inside here all we need to do is go
31:54 - m
31:54 - data
31:57 - i
31:58 - j m data i j will equal the function
32:04 - of
32:05 - that data so the function of that of
32:07 - itself effectively m data
32:10 - i
32:12 - j
32:14 - and then all we have to do is return
32:16 - that
32:16 - matrix
32:19 - hang on we don't want to assign the m
32:21 - data because that's empty we want to
32:23 - assign the m0 data so the one that's
32:26 - been passed so that data we want to
32:29 - apply the function to and then we'll
32:30 - assign that result to our empty
32:34 - array sorry our empty matrix let's give
32:37 - that a go
32:39 - we don't want to see that array anymore
32:41 - so console table matrix dot map
32:45 - we want to map let's just choose one of
32:47 - these arrays so we'll choose m2
32:49 - and let's apply a function we can use
32:52 - what they call an arrow function so
32:54 - that's just x equals greater than
32:57 - it looks like an arrow pointing
32:59 - rightwards and then we can just what do
33:01 - we want to do to x so x times two so
33:03 - that means we'll times every cell by two
33:07 - and also let's copy this just above
33:10 - let's show the original table
33:12 - okay let's give that a go
33:15 - so the original table one minus one
33:17 - three zero
33:19 - one times two is two three times two is
33:21 - six and so on that's working well and
33:24 - one more function so x divided by two
33:27 - say
33:30 - so point five three divided by one point
33:32 - five zero divided yet minus one divided
33:34 - by two is minus zero point five great
33:37 - that's our map function handled
33:39 - and the last function for today is to
33:42 - find the transpose of a matrix now the
33:45 - transpose of a matrix is simply when we
33:48 - switch the columns with the rows and
33:51 - vice versa
33:52 - so find the transpose
33:56 - of the given matrix
34:00 - so a 4 1
34:02 - matrix will become a 1 4 matrix
34:06 - so static
34:07 - transpose
34:10 - it'll just take a single
34:12 - matrix as its parameter
34:15 - and basically we'll be doing something
34:17 - very similar to this
34:19 - just need to modify a few things so let
34:21 - m equal new matrix we need to switch the
34:23 - columns for the rows
34:26 - and we need to make sure that we loop
34:28 - over the
34:29 - the original the past matrix
34:32 - so m zero rows m zero columns
34:35 - now m data i j we want m data j i
34:40 - m data j i will equal
34:42 - [Music]
34:44 - m zero data i
34:46 - j let's test that out
34:50 - okay so matrix dot transpose
34:54 - let's transpose say matrix 1 so m1
35:00 - and we'll just put the m1 data before it
35:06 - okay so the original
35:08 - the original matrix is 0 1 minus 1 and
35:12 - then the column down here is 0 1 minus 1
35:14 - 2 minus 3 0 2 minus 3 0 so a 2 3 matrix
35:20 - has become a 3 2 matrix
35:23 - excellent
35:27 - last time we created these matrix
35:29 - functions that like for example to add
35:32 - matrices and multiply them and so on so
35:34 - today we're focusing entirely on
35:36 - creating the neural network so first of
35:39 - all let's create the class neural
35:41 - network so class
35:43 - neural network
35:47 - create the constructor now the
35:49 - constructor needs to take the number of
35:50 - inputs the number of hidden and the
35:52 - number of outputs so num
35:54 - inputs
35:56 - num
35:57 - hidden
35:59 - and num
36:00 - outputs
36:03 - let's set the private
36:05 - variables the properties as such so
36:07 - we'll just call give them the same name
36:08 - just prefix it with an underscore num
36:11 - inputs equals num inputs
36:14 - num hidden
36:16 - num hidden equals num hidden and num
36:21 - outputs
36:23 - equals num
36:24 - outputs now going back to our diagram
36:27 - remember we have all these weights that
36:29 - are in between the input and the hidden
36:31 - layer let's call that weights zero and
36:34 - we'll call these weights here between
36:36 - the hidden and the output weights one
36:39 - so this
36:40 - underscore weights
36:42 - 0 will equal a new matrix
36:46 - the number of rows will be the number of
36:49 - inputs so this is the number this num
36:52 - inputs and the number of columns will be
36:55 - the number of hidden so this
36:57 - num
36:58 - hidden
37:00 - similarly weights 1
37:02 - will equal
37:03 - a new matrix except that its
37:06 - number of rows will be the number of
37:08 - hidden
37:09 - and the number of columns will be the
37:11 - number of outputs
37:14 - okay
37:15 - for the weights 0 and weights one we'll
37:16 - need to set that we'll need to update
37:18 - them during our training process
37:21 - so let's create getters and setters for
37:23 - them so get
37:24 - weights
37:26 - zero
37:28 - that's simply return
37:31 - this
37:32 - underscore weights zero
37:35 - and we'll also want to set that so set
37:38 - weights zero
37:40 - uh weight
37:43 - weights
37:44 - set weights zero weights so we can just
37:46 - go this
37:48 - underscore
37:49 - weights zero equals weights
37:54 - right
37:55 - and we'll do a similar thing for weights
37:57 - one
37:59 - weights one
38:01 - this weights one weights set weights one
38:07 - this weights one equals weights
38:10 - great
38:12 - so
38:13 - we've done this one here
38:15 - next we need to randomize the initial
38:17 - weights so let's just
38:19 - use that as our next comment
38:23 - so randomize the initial weights
38:25 - we've already created a function in our
38:26 - matrix functions actually where we can
38:30 - call randomized weights on any
38:33 - on any uh matrix so weight zero dot
38:36 - random weights
38:38 - and do a similar thing for weights one
38:43 - good that's that step done we should
38:45 - probably test this so go to our other
38:47 - file the html file
38:50 - and let's go down to where we set up
38:53 - here we are to do neural network so
38:55 - we'll have to create a variable here so
38:57 - variable nn we'll call it
38:59 - and here we can go nnn equals new
39:04 - neural network
39:07 - now we need to pass the number of inputs
39:09 - hidden in outputs here i think we should
39:11 - set them as constants so up where we're
39:14 - setting our constants let's create a
39:15 - section called
39:17 - neural network
39:20 - parameters
39:23 - const
39:24 - num of
39:26 - inputs i'm not entirely sure how many
39:30 - inputs we'll need but let's just say two
39:31 - to begin with
39:34 - const num
39:36 - hidden
39:39 - um again there's lots of theory behind
39:42 - what number this should be
39:44 - the higher usually means the more
39:46 - complicated processing it can do so
39:48 - we'll just start with five we can always
39:50 - adjust it later
39:52 - and const num
39:54 - outputs now this one i am confident
39:57 - about we just want one boolean flag
40:00 - zero turn left one turn right so one
40:03 - output
40:04 - so head back down to where we're setting
40:06 - up our neural network
40:08 - put in these as their the arguments and
40:10 - num inputs
40:12 - num hidden
40:14 - and num
40:15 - outputs
40:18 - so we don't need these matrices anymore
40:20 - so we can get rid of them
40:22 - to test that our neural network's
40:24 - constructor is working all right how
40:26 - about we output the weights so nnn
40:30 - weights
40:32 - zero
40:33 - dot data
40:35 - and we'll do a similar thing
40:37 - for weights one
40:38 - we don't need this transpose anymore
40:41 - so open that up in our web browser
40:45 - okay so we have one
40:48 - for the first matrices of weights is two
40:50 - by
40:51 - three four yep two by five that's right
40:54 - and our output one our weights one is a
40:57 - five by one
40:58 - with random weights inside
41:01 - awesome
41:03 - to head over to our neural network class
41:06 - let's go down and see what we need to do
41:07 - next
41:08 - feed forward now all that means is that
41:11 - we're going to input some information
41:12 - into our network it's going to feed
41:15 - through it and some output is going to
41:17 - be created
41:19 - so let's create a new method called feed
41:22 - forward in our class
41:25 - it will take an input array as an input
41:29 - as a parameter
41:31 - let's paste these comments in here
41:35 - so the first step is to convert input
41:38 - array to a matrix that's easy enough so
41:40 - let's declare a new
41:42 - array let inputs equal matrix
41:46 - dot
41:47 - convert
41:48 - convert from array we made this earlier
41:51 - so we can just put the input array in
41:53 - there
41:54 - and that will convert it to a single
41:56 - road matrix
41:57 - that's fine
41:59 - next one find the hidden values and
42:01 - apply the activation function okay to
42:04 - find the hidden values we can look at
42:05 - this diagram here you can see that each
42:08 - hidden
42:09 - neuron is made up of these
42:11 - weights one coming from each of the
42:13 - previous inputs
42:14 - so to calculate that it's just the first
42:16 - input multiplied by the first weight
42:20 - plus the second input times the second
42:22 - weight times the third input sorry plus
42:25 - the third input times the third weight
42:27 - and that can be handled using a matrix
42:29 - dot product
42:31 - we have a function for that as well so
42:33 - let
42:34 - hidden
42:35 - equal
42:36 - matrix dot
42:38 - dot
42:39 - which takes two matrices the first one
42:42 - being the inputs and the second one will
42:44 - be the weights which we all have already
42:46 - determined it's been randomly determined
42:49 - so weights zero
42:51 - okay
42:52 - now the activation function
42:55 - is simply well with lots of neural
42:57 - networks the activation function is
42:59 - something called a sigmoid function
43:01 - let's take a look at that
43:03 - now a sigmoid function is simply this 1
43:06 - divided by 1 plus e to the minus t now
43:10 - what that does we can input any value
43:12 - into this system and it will return a
43:14 - value between zero and one no matter how
43:16 - big that value is so if we put one
43:19 - trillion into this we'll get a it'll
43:21 - output a value close to one
43:24 - okay which suits our needs very well
43:27 - so let's go ahead and create a function
43:30 - down here just outside our class
43:31 - function we'll just call it sigmoid
43:34 - sigmoid
43:36 - it'll take some value we'll call that x
43:39 - and it will return
43:41 - 1 divided by
43:43 - 1 plus the
43:45 - exponent so that's e
43:49 - a numeric expression representing the
43:51 - power of e yep so math.exp to the minus
43:54 - x
43:56 - that's right
43:58 - now in order to apply that function to
44:00 - each of the cells of the matrix we made
44:02 - a function for that too so we just go
44:04 - hidden will equal
44:06 - matrix
44:07 - dot
44:08 - map
44:10 - okay so it takes the
44:12 - the matrix so which is hidden
44:16 - and the function to apply to it well we
44:17 - can use an arrow function here so x
44:21 - equals greater than
44:23 - x
44:24 - sigmoid x so sigmoid x so that should
44:28 - apply the sigmoid function to each of
44:30 - the values within our matrix
44:33 - good
44:34 - similarly
44:35 - so for the second part find the output
44:38 - values and apply the activation function
44:39 - it's the same sort of thing
44:41 - so we can just go let
44:44 - outputs
44:45 - equal matrix dot
44:47 - hidden will be the inputs
44:50 - so this will be from here from the
44:52 - hidden layer to the output layer so
44:54 - hidden will be the inputs and output
44:56 - will be the outputs
44:58 - so matrix dot hidden this dot sorry this
45:02 - dot weights one that's the second set of
45:04 - weights
45:06 - outputs
45:09 - matrix map
45:10 - so itself
45:12 - outputs and
45:13 - apply the sigmoid function to each value
45:16 - and finally we want to return
45:20 - return those outputs to the sender
45:23 - the next step apply bias i don't want to
45:26 - do that right now and the reason is
45:27 - because not applying bias can cause
45:30 - issues and i'd like to see what those
45:32 - issues are
45:34 - so let's first test this feed forward
45:36 - function so let's do some console output
45:39 - console log
45:41 - inputs
45:44 - and we'll just output the uh the data in
45:46 - the array so we can use table to that
45:49 - console.table
45:51 - inputs
45:53 - dot data
45:56 - and we'll do something similar each step
45:58 - of the way here so when we work out our
46:01 - hidden
46:02 - neurons we can just do that
46:07 - and we'll also want to see what happens
46:09 - after we apply the sigmoid function
46:12 - similarly for our outputs
46:18 - and
46:19 - after the outputs
46:23 - have had the sigmoid function applied to
46:25 - them so i'll just call that output sig
46:28 - that will be hidden sig
46:31 - okay head over to our other file
46:34 - let's call that function so all we have
46:36 - to do is go nn dot
46:38 - feed
46:40 - forward
46:41 - it requires an input array so something
46:43 - like zero comma one now remembering that
46:46 - the number of inputs that we declared
46:47 - for our neural network is two so we need
46:49 - to pass to
46:51 - an array of length two here now if we
46:53 - didn't let's just try that if we didn't
46:56 - it should break
46:58 - let's have to open our file
47:02 - open up the console
47:04 - yeah so inputs got through a single
47:07 - length array but there's an error
47:08 - matrices are not dot compatible so to
47:11 - fix that all we have to do is
47:15 - put the second element
47:17 - put the second uh
47:19 - input in there let's give that a go
47:22 - yep that worked fine so we've got two
47:24 - inputs zero and one
47:26 - the hidden values are calculated i'll
47:28 - just believe that
47:29 - the sigmoid is applied the output and
47:32 - the sigmoid is applied let's just keep
47:34 - resetting that until we get an output
47:36 - that is negative
47:38 - here we go so here's a negative output
47:40 - can you see that the sigmoid function
47:42 - has made that positive
47:44 - so that seems to be working okay
47:48 - so head over to our other file we can
47:50 - probably get rid of some of these
47:51 - console logs so let's just delete a few
47:54 - of them
47:58 - we'll keep one set we'll probably need
48:00 - it for our next function
48:01 - and that is train train using input and
48:04 - target arrays
48:06 - right so currently our system doesn't do
48:08 - very much we give it some inputs and it
48:10 - outputs some randomly generated outputs
48:12 - not very useful so in order to make it
48:15 - do something how about we create a
48:17 - function that allows us to put in some
48:19 - training data so we'll call that train
48:22 - so up inside our class
48:25 - train
48:26 - it will take an input array
48:30 - and the target array
48:33 - so for example if we
48:35 - had the inputs 0 and 1 and we expect 1
48:39 - to be the answer then that's what we
48:40 - would put in here
48:42 - let's paste those comments in there
48:47 - so the first step feed the input data
48:49 - through the network well we already have
48:51 - a function for that called feed forward
48:53 - so let's say let outputs
48:57 - equal
48:58 - feed
48:59 - forward
49:00 - this dot feed forward
49:02 - the input array
49:06 - okay that's that done
49:08 - next calculate the output errors
49:11 - target minus output okay in order to
49:14 - subtract matrices we'll have to convert
49:16 - the target array first so that
49:18 - let's targets
49:20 - equal matrix dot convert
49:23 - convert from away from array
49:27 - target
49:28 - array okay good
49:31 - and
49:32 - let's output errors
49:35 - so we're calculating the output errors
49:37 - here let output errors equal matrix
49:40 - dot subtract
49:42 - and we'll subtract the first which is
49:45 - the target so the targets
49:48 - minus the second which is the output
49:52 - the outputs
49:55 - let's test that so we'll grab this
49:57 - console data that we kept up here
50:00 - uh outputs
50:02 - targets and output errors
50:05 - so outputs that'll be fine
50:09 - targets
50:11 - targets and output errors
50:14 - output errors let's print out every step
50:19 - okay head back over to our other file uh
50:21 - nn.train
50:23 - we need an input array 0 1 and an output
50:26 - array remembering it has to match the
50:28 - number of outputs if it doesn't we're
50:30 - going to get an error we'll just
50:32 - give that a go we'll put a 2
50:34 - column one there
50:39 - okay so error matrices are of different
50:41 - dimensions so when it tries to subtract
50:43 - them it failed so let's put that to a
50:45 - single one
50:49 - right so we have our outputs which is
50:51 - 0.639
50:53 - the in the expected the target is one so
50:56 - the difference is point three six that
50:58 - sounds correct
51:02 - so on to our next step
51:04 - calculate the deltas
51:06 - which are equal to the errors times the
51:08 - derivative of the output
51:10 - so the derivative of the output is
51:12 - actually the derivative of the sigmoid
51:14 - function so let's update our sigmoid
51:16 - function to handle derivatives
51:19 - how about we just pass a flag derive
51:21 - equals false we'll set we'll give it a
51:23 - default value so you don't have to
51:25 - provide it and if you don't it'll just
51:27 - return what we always have
51:29 - if derived
51:33 - then we'll return the derivative now the
51:35 - derivative of this is x times 1 minus x
51:41 - that's not the true derivative of the
51:43 - sigmoid function
51:44 - but
51:45 - we've already applied the sigmoid
51:47 - function so we don't want to return the
51:49 - true so i'll put a note here where
51:52 - x equals sigmoid
51:55 - x
51:56 - right so the true derivative is the
51:58 - sigmoid x times 1 minus the sigmoid x
52:00 - but we've already applied it so this
52:02 - will be a good representation x times 1
52:04 - minus x
52:07 - so let's create a variable let output
52:10 - derives
52:11 - equal we can use our map function to
52:14 - apply this matrix.map
52:16 - the outputs
52:20 - and the function will be we can use an
52:22 - arrow function again
52:24 - will be the sigmoid
52:26 - x but this time we'll set the derived
52:28 - flag to true so it'll apply the
52:31 - derivative to each of these outputs and
52:33 - assign it to that
52:35 - and finally
52:37 - output
52:39 - errors no calculate the delta output
52:41 - deltas is what we're trying to find here
52:43 - output deltas will equal
52:46 - matrix
52:47 - dot so error is times derivative so
52:50 - multiply we can use our multiply
52:51 - function
52:52 - the first one is the errors output
52:55 - errors
52:57 - and the second one will be the output
52:59 - derivatives output derivatives
53:03 - and we'll just copy
53:05 - this console log here so we can test
53:07 - this
53:09 - output just the deltas we'll do output
53:12 - deltas
53:14 - let's test that
53:16 - let's run it again
53:18 - so we have outputs targets output errors
53:22 - and output deltas
53:25 - who am i to refute that it looks okay
53:29 - okay on to the next step
53:31 - calculate hidden layer errors so it's
53:33 - the deltas dot the transpose of weights
53:36 - one
53:37 - right so let's calculate the transpose
53:40 - first so we'll call that weights
53:42 - one
53:43 - capital t for transpose will equal we
53:46 - have a function for this matrix dot
53:48 - transpose
53:49 - it just takes a single matrix so that'll
53:52 - be the this dot weights
53:55 - one
53:57 - okay and then we'll need to calculate
53:59 - the hidden layer errors we'll call it
54:01 - hidden errors hidden errors
54:06 - will equal delta dot so matrix
54:11 - dot
54:14 - uh
54:15 - what was the first one the deltas dot
54:17 - the transpose okay so that'll be the
54:20 - output deltas output deltas
54:23 - dot what we just worked out the
54:25 - transpose their weights one t
54:29 - again let's output some just to make
54:31 - sure it's not
54:32 - throwing an error basically we don't
54:34 - really know exactly what we're after
54:36 - here
54:37 - uh the hidden areas is what we'll want
54:39 - to output here hidden errors
54:42 - let's give it a go
54:46 - right so we get some output deltas and
54:49 - then we get the hidden
54:50 - errors across ways that looks to be okay
54:56 - so the next step calculate the hidden
54:58 - deltas errors times derivative of hidden
55:02 - sounds very similar to what we've done
55:03 - up here so let's just copy and paste
55:05 - that
55:07 - let hidden derives
55:11 - equal matrix map
55:13 - hidden
55:14 - i just had a thought we don't have
55:16 - actually have visibility to hidden here
55:18 - hidden because hidden wasn't was used
55:22 - within this feed forward function
55:25 - here we go let hidden equals that so how
55:27 - about instead of creating a local
55:29 - variable here we use a property on our
55:32 - neural network we'll say this dot hidden
55:35 - this dot hidden so anywhere we use
55:37 - hidden inside here we'll go this dot
55:39 - hidden
55:40 - this dot hidden this dot hidden
55:43 - and we'll have to go create a property
55:45 - on the neural network so we can do that
55:48 - easily enough just at the top of it this
55:50 - dot underscore hidden will just equal an
55:53 - empty array
55:55 - and we'll have to set up some getters
55:56 - and setters for it so that we can access
55:59 - it
56:00 - get
56:01 - hidden
56:03 - we'll just return this
56:05 - underscore
56:06 - hidden
56:07 - and set
56:09 - hidden
56:11 - just pass a
56:13 - variable called hidden this
56:15 - hidden
56:17 - will equal hidden
56:19 - that should access yep that's the same
56:22 - as that
56:23 - right so that should all work in our
56:25 - feed forward now
56:27 - and back down where we have
56:31 - back in the train function
56:33 - where we have hidden here so hidden
56:34 - derivative with a matrix map this dot
56:36 - hidden so we're accessing the actual
56:38 - hidden values at this stat at this point
56:41 - in time
56:42 - x
56:43 - uh sigmoid x is true yep we're applying
56:45 - the derivative of it
56:47 - calculate the hidden deltas so the
56:49 - hidden deltas
56:52 - matrix multiply the hidden errors
56:57 - times the hidden derives
57:02 - right so let's output those hidden
57:04 - deltas
57:07 - let's give it a go
57:11 - so we have some hidden errors with some
57:13 - hidden
57:14 - deltas
57:15 - good
57:17 - now for the final step in our little
57:19 - neural network update the weights so we
57:21 - have to add the transpose of layers dot
57:24 - deltas so we add that to the weights
57:28 - okay so let's first calculate the
57:29 - transpose so let hidden
57:32 - transpose equal matrix
57:35 - dot transpose
57:38 - uh this dot hidden
57:43 - sorry
57:44 - um
57:45 - next we have to add the transpose to the
57:48 - weight so this weights the associated
57:50 - weights is one it's the second set of
57:53 - weights will equal matrix
57:56 - add
57:59 - add itself we have to add to itself so
58:01 - this
58:02 - weights
58:03 - one
58:05 - the
58:06 - layers the transverse layers dot deltas
58:08 - so matrix
58:12 - dot
58:15 - the transpose hidden t
58:17 - hidden
58:19 - t
58:21 - and the deltas which will be the output
58:24 - deltas of the associate are associated
58:26 - with the hidden layer so output deltas
58:31 - now we have to do a similar thing for
58:33 - the first weight so weights zero
58:37 - so we need to calculate the transpose of
58:40 - the inputs so inputs t well matrix
58:43 - transpose
58:45 - in do we have
58:47 - inputs
58:48 - do we have visibility on inputs
58:51 - no we don't because again within the
58:53 - feed forward
58:54 - we're converting it there
58:57 - and keeping it as a local variable
58:59 - so
59:00 - there's a couple things we could do we
59:01 - could just convert it again within our
59:03 - train array but we have to remember that
59:05 - this train function will probably be
59:07 - called like thousands of times if not
59:09 - hundreds of thousands of times so it's
59:11 - probably better just to assign it to
59:13 - what how we're doing with the hidden
59:15 - here so let's do that
59:16 - this dot inputs
59:21 - this input so we'll have to go up and
59:23 - create a property
59:24 - same as what we've done for hidden
59:27 - so this
59:29 - inputs will just equal an empty array
59:31 - and we have to create a couple of with
59:34 - create getter and a setter
59:37 - get inputs
59:40 - this
59:41 - return this inputs
59:44 - set inputs
59:45 - inputs equals inputs
59:49 - this inputs will equal inputs that's
59:51 - looking good so our feed forward
59:53 - function should work now we'll just
59:55 - assign instead of creating a local
59:56 - variable we're just assigning as a
59:58 - property now down in our train
60:02 - uh function
60:03 - this inputs should work now that's fine
60:06 - and we're updating weights zero at this
60:09 - point weight zero weight zero dot
60:12 - the inputs t
60:14 - inputs t
60:16 - and the deltas that are associated with
60:18 - that of the hidden deltas
60:20 - the next
60:21 - layer deltas let's run that make sure
60:23 - it's not broken
60:26 - okay it's not breaking so that's good
60:28 - enough test for me i think we should
60:30 - actually try this training and see if it
60:32 - actually works or not how about we get
60:34 - rid of all these comments first because
60:36 - they're just not
60:38 - we don't want them printing out every
60:40 - iteration when we've got like a thousand
60:42 - or ten thousand iterations
60:45 - remove all them remove all them
60:49 - this the weights are updating great go
60:52 - back to our other file
60:55 - right so we'll be calling train but we
60:58 - want to loop over the number of training
61:01 - samples that we have so we can go for
61:05 - i'll title this train
61:08 - the network
61:12 - for let i
61:14 - equal zero
61:16 - i is less than say let's set up a flag
61:19 - for this so num
61:21 - samples
61:23 - i plus plus
61:27 - in there we'll do our training for
61:29 - something
61:31 - a number of samples let's go up and
61:33 - create that now
61:36 - num samples
61:39 - i'm not exactly sure how many we'll need
61:41 - but let's start at say one thousand i
61:43 - know in other examples there's ten
61:45 - thousand and a hundred thousand and so
61:46 - on we'll just we'll start with one
61:49 - thousand num samples is 1000.
61:53 - and how about we use the classic example
61:55 - to test neural networks is the zor sorry
61:57 - the xor gate the exclusive or gate
62:00 - so x we'll call this a test test
62:05 - x or
62:06 - gate logic
62:09 - let's take a look at that xor gate here
62:12 - it is just this table down here so when
62:14 - you have two inputs 0 0
62:17 - output 0 0 1 or one zero output one and
62:20 - one one outputs zero so zero zero zero
62:24 - okay let's write that in here i think
62:27 - zero zero
62:28 - equals
62:30 - zero
62:33 - zero one equals one
62:36 - one zero equals one and one
62:40 - one equals zero so only when there's one
62:43 - of them
62:44 - flagged will it be one otherwise when
62:46 - they're both the same it'll be zero
62:48 - so let's create some random input we'll
62:50 - create one
62:52 - zero one there and one zero one there so
62:54 - we'll input one input two or input zero
62:57 - and input one input zero will equal
63:00 - well
63:01 - it'll be a random number and we want to
63:03 - round it so math round just rounds to
63:06 - the nearest integer
63:07 - and we want to round a random number
63:09 - math random which is a number between
63:11 - zero and one so that should produce a
63:13 - zero or one
63:15 - similarly for input 1
63:18 - so we can pass them into our
63:23 - training array here so input 0 and input
63:26 - 1
63:27 - and we also need an output so let output
63:32 - let output equal well what's the logic
63:35 - behind it if input 1 input 0 and input 1
63:38 - are the same then the output is 0 right
63:42 - otherwise the output is one so we just
63:44 - do a conditional here
63:46 - input zero
63:48 - equals
63:49 - input one if that's true the output is
63:53 - zero
63:54 - else the output is one that's the
63:56 - zorgate logic
63:58 - and put our output into this array here
64:02 - out
64:02 - put
64:04 - so basically we've created a whole bunch
64:06 - of random
64:07 - training data with the correct outputs
64:10 - fed it into our system in the hope that
64:12 - it's going to create an accurate uh
64:14 - prediction
64:16 - so let's test it test output
64:20 - we can just use the console for this i
64:22 - think
64:23 - console.log
64:25 - we'll put in each of the
64:27 - combinations of inputs so 0 0
64:30 - will equal
64:32 - let's feed it into our system together
64:35 - to get a prediction
64:36 - feed
64:38 - forward
64:38 - we need the array 0 comma the input
64:42 - array 0 0
64:43 - and we want to output to the screen the
64:46 - data of that so do that for each of the
64:49 - possible
64:50 - input combinations so zero one one zero
64:54 - and one
64:55 - one
64:56 - zero zero zero one
64:59 - one zero and one
65:02 - one
65:04 - let's give that a go
65:09 - okay zero zeros we're expecting a zero
65:13 - here and a zero here and a one here and
65:16 - one here it could be that we haven't got
65:17 - enough samples so let's try by bumping
65:20 - up the number of samples to say ten
65:22 - thousand
65:28 - ah that's looking pretty good that's
65:30 - close to zero that's close to one that's
65:31 - close to one that's close to zero let's
65:33 - just keep trying make sure there's no
65:36 - discrepancies here
65:39 - now i have read that not having bias can
65:42 - cause an issue in these situations
65:45 - so let's see if it comes up with a
65:48 - strange
65:49 - reading on occasion
65:55 - so here for example the prediction for 1
65:58 - 1
65:59 - is 0.5 so that could be because of the
66:02 - bias not being there so i think for
66:04 - safety we should put the bias in
66:07 - so first of all what is bias
66:09 - well here's a diagram basically we have
66:12 - our input neurons
66:14 - we just add an extra neuron for bias it
66:17 - always takes a value of positive one
66:20 - and we add it and all it does is output
66:23 - its own weights in effect it doesn't
66:26 - take an input of any kind it just
66:27 - outputs its own weight we'll have one
66:30 - bias node on the input layer and one
66:32 - bias node on the hidden layer the reason
66:34 - we do this is because the input
66:37 - neurons could take all zeros for example
66:41 - in our zorgate logic if we have zero
66:43 - zero as our inputs can you see that that
66:45 - could
66:46 - skew the results because 0 times any of
66:49 - these weights will be 0 so it's not
66:52 - going to behave correctly so that's why
66:54 - we add this bias node
66:56 - head into our other file
66:58 - go right up the top
67:00 - in the same way that we've created
67:02 - weights here let's create a bias zero
67:05 - and a bias for one
67:08 - so
67:09 - bias zero will equal a new matrix of
67:12 - just a single row so one row
67:15 - the number of columns will be the number
67:16 - of hidden
67:18 - and bias one same sort of thing one row
67:21 - but the number of columns will be the
67:24 - number of outputs
67:26 - okay and we'll have to randomize in the
67:29 - same way that we've randomized the other
67:31 - weights we'll randomize the bias so bias
67:34 - zero random weights
67:37 - do that for bias one as well
67:40 - okay that looks good
67:42 - head down to our feed forward function
67:44 - we've left the node here apply bias
67:48 - to apply the bias all we have to do is
67:50 - before we apply the sigmoid function to
67:52 - the hidden layer we can just apply we
67:55 - can add the bias so this hidden will
67:58 - equal matrix
68:00 - add
68:03 - this hidden so adding to itself
68:06 - this
68:07 - bias
68:08 - zero so that is applying the bias apply
68:12 - bias
68:14 - and in the same way we'll do that with
68:16 - the output so before we apply the
68:18 - sigmoid function
68:20 - instead we'll be doing it to the output
68:22 - so outputs will equal matrix add
68:26 - outputs
68:27 - this
68:28 - bias
68:29 - one
68:31 - now down in our train function we've
68:34 - left a note update biases
68:38 - now to do all we have to do there is go
68:40 - in the same way that we've updated our
68:41 - weights here we'll do the same thing
68:43 - this dot
68:44 - bias
68:46 - 1
68:47 - will equal matrix
68:50 - add
68:51 - this
68:52 - dot bias
68:54 - 1
68:55 - and we're adding the
68:58 - the deltas the output deltas for this
68:59 - one
69:02 - same sort of thing for the bias 0 except
69:06 - that we'll be adding the hidden deltas
69:10 - so this by zero
69:12 - hidden deltas
69:14 - so let's test that
69:17 - oh we have an error m1 is undefined
69:22 - okay
69:24 - uh m bias
69:27 - uh
69:28 - maybe no i didn't create the uh getters
69:31 - and setters for these private
69:33 - so let's do that now that was a bit
69:34 - silly so we're just as we do just as we
69:37 - get and set the weights let's get and
69:40 - set the bias so bias
69:44 - zero
69:45 - this
69:47 - bias
69:48 - zero
69:49 - set
69:50 - bias zero
69:53 - and this
69:55 - bias
69:57 - zero just pass the bias
70:01 - oops
70:03 - bias
70:05 - bias
70:06 - okay so but get biased you return this
70:09 - by zero set by zero bias this bias zero
70:11 - equals bias do that for bias one as well
70:17 - just update that to one
70:20 - one
70:22 - one
70:24 - and one
70:26 - okay that should be okay now let's give
70:30 - that a go
70:33 - great so if we run that a few times my
70:36 - hunch is that it will be fine we'll get
70:40 - a value close to zero a value close to
70:42 - one and finally a value close to zero
70:50 - we will actually be feeding in game data
70:53 - into our neural network so that we can
70:55 - rotate this ship i'm doing this manually
70:57 - of course so we can rotate the ship and
70:59 - shoot at the closest asteroid
71:02 - okay so let's head into our code i'll
71:05 - just turn automation back on
71:09 - okay and head to our neural network file
71:13 - the first thing i'd like to do today is
71:15 - to set up some error logging in our
71:16 - neural network class the reason for this
71:19 - is that i'd like to be able to keep
71:20 - track of how well our
71:22 - training function is doing as we're
71:24 - training it so let's set up a flag up
71:27 - here just a constant let's call it log
71:29 - on
71:31 - set it to true
71:32 - and that's just whether or not to show
71:36 - error
71:37 - logging
71:39 - we'll need to keep track of how often we
71:41 - show this message like show a message we
71:43 - don't want to show it every iteration
71:45 - because we could in theory be calling
71:47 - this
71:48 - uh train function like thousands of
71:50 - hundreds of thousands of times if not
71:52 - millions of times so let's set a log
71:54 - frequency
71:56 - uh initially we'll set it to a thousand
71:58 - say
71:59 - and that's just how often
72:02 - to show
72:04 - error logging
72:05 - error logs
72:07 - and that's in iterations
72:09 - in
72:10 - iterations
72:12 - okay we'll have to set up a private uh
72:14 - member variable here
72:16 - just down here so error
72:18 - logging
72:20 - this underscore we'll keep track of how
72:24 - many calls we've had or how many
72:26 - iterations we'll call it log count
72:28 - and it'll start the day at log frequency
72:33 - and we'll also because it's private
72:34 - we'll want to set up some getters and
72:36 - setters
72:39 - it's not technically private i'm kind of
72:41 - making it private i should say
72:43 - so get log count
72:46 - i don't get log count
72:50 - return this
72:51 - log count
72:53 - set log count
72:56 - count
72:58 - this log count
73:01 - equals count
73:04 - head down to our train function
73:08 - now what's the most appropriate thing to
73:09 - output here i'm thinking the output
73:12 - errors because the output errors are
73:14 - simply the target minus the output so if
73:16 - the target's 1 and the output's 0.7 then
73:18 - the error is 0.7 it's easy to understand
73:21 - so let's do our error logging here error
73:24 - logging
73:25 - if
73:26 - log
73:28 - on
73:30 - and if the this dot
73:34 - log
73:36 - count yep if this.log count equals the
73:38 - log frequency
73:41 - well let's do a console output so
73:43 - console log
73:46 - uh output errors
73:49 - output errors
73:51 - now it's a matrix so we'll need to grab
73:53 - its data array and we there's only going
73:55 - to be one error because we've only got
73:57 - one piece of output so we'll just do the
73:59 - first
74:01 - column
74:02 - sorry the first row first cell
74:05 - okay
74:07 - probably prefix that with something so
74:08 - we know that what we're outputting error
74:12 - equals that
74:16 - then we'll have to decrement the log
74:18 - count so this dot log count minus minus
74:21 - because we don't want it occurring every
74:22 - iteration
74:24 - and when that reaches zero if this dot
74:26 - log count equals zero
74:30 - what will we do well we'll just reset it
74:32 - this dot log count
74:34 - equals
74:35 - log frequency
74:39 - let's test that out
74:40 - so currently we we'll just need to turn
74:42 - our console on
74:44 - reset it
74:45 - okay here we go so we've got errors of
74:47 - 0.32 0.29 0.08 blah blah blah it's going
74:50 - down slowly isn't it uh how about so
74:53 - this is our zorgate logic that we used
74:55 - last time
74:56 - how about we increase the number of
75:00 - samples so go back to our other file our
75:03 - html file we'll increase the number of
75:04 - samples to say 100 000
75:07 - and we'll increase the number of hidden
75:11 - nodes to 10
75:13 - but because we're doing a hundred
75:14 - thousand samples now how about we change
75:16 - our log frequency to say 10 000 we don't
75:19 - want it showing so often
75:22 - let's give that a go
75:24 - point seven four point zero one as you
75:26 - can see very quickly the error is
75:28 - reduced with the zorgate logic so that's
75:31 - good our logging is working great
75:34 - that's all we really need to do for our
75:36 - neural network file so let's head over
75:39 - to our other file
75:40 - now we have to think about how many
75:42 - inputs are there going to be in our
75:43 - system
75:44 - i've always said that the goal was to
75:46 - turn our ship towards the closest
75:48 - asteroid and shoot it so knowing that we
75:51 - need to know the asteroids position
75:53 - don't we so there's going to be an x
75:55 - position and a y position so that's two
75:58 - inputs
75:58 - and we also need to know the ship's
76:00 - angle because if we're facing this way
76:02 - we need to know that we'll have to turn
76:04 - left to get to the asteroid or turn
76:06 - right or whatever so that's the asteroid
76:09 - x the asteroid y and the ship's angle so
76:11 - that'll be a minimum of three inputs
76:14 - uh how about just for testing purposes
76:16 - we'll just turn the roid number down to
76:19 - one there'll be a single asteroid
76:22 - right head down to where we set up our
76:24 - neural network where we train the
76:26 - network we don't need to do any of this
76:28 - all gate logic anymore that was just for
76:29 - testing our system
76:31 - and we don't need this test output
76:33 - anymore
76:37 - so let's create some variables well i
76:40 - need the asteroids x position asteroids
76:43 - y position the ship's
76:45 - angle and just for completeness let's
76:47 - include the ship's position as well so
76:49 - ship x and ship y
76:52 - so the first thing we'd like to do the
76:54 - first thing we'd like to include in our
76:56 - training data is a random asteroid
76:58 - location random asteroid location but we
77:02 - have to remember that asteroids can
77:03 - float off the left and right of screen
77:05 - as well as top and bottom up to their
77:07 - radius so we'll have to include
77:11 - off screen
77:13 - data here as well
77:16 - so a x will equal a random point random
77:20 - times by the width of the screen so
77:22 - canvas dot width
77:26 - but because
77:27 - it can go up to its radius off the left
77:29 - and its radius off the right well that
77:31 - will mean we'll have to add the total
77:34 - with the size of the roid here roid
77:36 - size
77:38 - which is the diameter in effect just
77:40 - bracket that
77:42 - and then fine so that'll generate a
77:43 - number a number between zero and say the
77:46 - width is 500 so 500 plus 100
77:50 - is 600 so 0 and 600 but we want it to be
77:53 - able to be negative so we'll have to
77:54 - subtract the radius so it'll be the roid
77:58 - size
77:59 - minus the roid size divided by 2 which
78:01 - is the radius
78:03 - do a similar thing for a
78:05 - y
78:06 - except that it will be the height
78:10 - good and now the ship's
78:13 - uh angle
78:14 - and position
78:17 - now the ship's angle
78:18 - it'll just be random we'll just randomly
78:20 - generate an angle anywhere between 0 and
78:22 - 360 degrees so in radians let's do a
78:25 - math random first math random
78:28 - times 360 degrees in
78:31 - in radians which is just pi times two
78:34 - good now the x location and the y
78:37 - location i'm not planning to move the
78:39 - ship at all that'll be far too
78:40 - complicated and i think it's a pretty
78:42 - good strategy just to sit in the middle
78:44 - turn to the nearest asteroid and shoot
78:46 - so we'll keep it fixed so sx will just
78:49 - equal the ships
78:51 - starting sorry the ship's starting x
78:54 - and s y
78:56 - will just equal the ship's starting y
79:00 - next we'll need to work out which
79:02 - direction to turn
79:04 - based on the angle of our ship and the
79:06 - angle of the asteroid
79:09 - so calculate
79:12 - the angle to the asteroid
79:16 - how about we write a function for this
79:18 - because it's possible that we'll use it
79:19 - again
79:21 - just down here
79:22 - function we'll give it a generic name
79:24 - such as angle
79:26 - to
79:27 - point
79:28 - angle to point we'll have to use some
79:30 - trigonometry here so we need to know our
79:32 - current position so x and y
79:35 - we'll need to know our facing or bearing
79:37 - we'll call that bearing
79:39 - uh we'll need to know the targets x and
79:41 - y location target x and target y
79:46 - and i think that's all we need to know
79:48 - so let's angle
79:51 - to
79:52 - target
79:53 - so let angle to target equal well it'll
79:56 - have to be the inverse tan because we
79:58 - have x and y coordinates so tan is
80:00 - opposite over adjacent so a10 there's
80:03 - two types of atans here there's a10
80:06 - which is our regular mathematics
80:08 - tangent
80:09 - but that doesn't take into consideration
80:11 - coordinate space you know how we have
80:13 - four quadrants in coordinate space
80:16 - but a10 2 does take into consideration
80:19 - that so we'll use that now it requires a
80:21 - y and an x so we'll have to find the
80:23 - differences between our
80:25 - target and our self
80:27 - so we'll put
80:28 - so this will be the y differences so
80:31 - it'll be target
80:33 - y
80:35 - minus
80:36 - y
80:38 - right and the x's will be the symbol a
80:40 - similar thing target x minus x
80:45 - however because y's on screen like pixel
80:48 - wise are in the opposite direction so as
80:51 - we go up the screen we're actually going
80:53 - in a negative y direction so we'll have
80:54 - to apply a negative to that and a
80:57 - negative to that so it'll be minus
80:58 - target y plus y
81:00 - target x minus x y x yep that's good
81:05 - we'll have to find the differences
81:07 - between our angle to the target and our
81:08 - bearing so we can just go let say diff
81:12 - equal
81:12 - our bearing
81:14 - minus
81:16 - the angle to target
81:19 - angle to target
81:22 - now that could result in a whole range
81:24 - of numbers because this a 10 2 function
81:27 - it returns a number between effectively
81:29 - 180 degrees and minus 180 degrees so it
81:33 - could be negative
81:35 - our bearing could be anywhere between 0
81:37 - and 360. so just that was 0 and we had
81:40 - 180 here we'll get a negative number
81:42 - won't we
81:43 - if the bearing is say
81:45 - 360 and our angle is minus we'll get a
81:48 - number
81:50 - over 360. so we'll need to do some
81:53 - normalizing as such here so how about we
81:55 - have or we can just return this i think
81:57 - return
81:59 - the
82:00 - diff
82:02 - remembering we can add 360 degrees to
82:06 - any angle and it's still the same
82:08 - effective angle if i'm facing 40 degrees
82:10 - and i add 360 degrees so 400 degrees i'm
82:14 - still facing at the same angle aren't i
82:17 - so
82:18 - we will add
82:20 - the
82:21 - we'll add 360 degrees math pi times 2
82:26 - but that would that could get us above
82:29 - 360 couldn't it'll get us above zero
82:31 - which is what we want but it could also
82:32 - get us way above 360. so we'll find the
82:34 - modulus of that the remainder so modulus
82:38 - math
82:39 - pi
82:40 - times 2 so that will
82:42 - guarantee us a result between 0 and 360
82:46 - degrees in effect in radians right so
82:48 - back up here we can just go let
82:52 - angle say angle equal call that function
82:55 - angle
82:57 - angle to point
82:59 - we have to pass the correct parameters
83:00 - so the x is our ship location ship x
83:04 - ship y
83:05 - the bearing is the ship's angle
83:07 - the target x is the asteroid x and the
83:11 - target y is the asteroid y so that'll
83:14 - give us our
83:15 - absolute angle as such
83:17 - and then we need to determine
83:20 - the direction to turn
83:23 - right so that's probably let's say let
83:26 - direction
83:27 - equal
83:28 - [Music]
83:29 - well if that angle is greater than 180
83:32 - degrees so angle
83:34 - is greater than math.pi that's 180
83:38 - degrees
83:39 - then we'd like to turn
83:42 - left so remember we have to um put in
83:45 - zero one here how about we set these as
83:47 - constants i think that would be the best
83:48 - move
83:49 - so back up here in our neural network
83:51 - parameters let's have constant
83:53 - output
83:55 - left
83:56 - will equal zero so that will be the
83:59 - expected
84:01 - output expected neural output
84:04 - for turning left
84:07 - similarly we'll have the output right
84:12 - which will equal one
84:14 - and that will be the expected neural
84:16 - output for turning right
84:18 - okay
84:20 - so back down here if the angle is
84:22 - greater than 180 math pi we'll
84:25 - output left
84:26 - else will output
84:28 - right so finally we just need to train
84:32 - the network
84:35 - so we can call
84:37 - neuralnetwork.train to do that it takes
84:39 - an input array
84:40 - so the input array is just our
84:42 - position of our asteroid ax and ay
84:45 - and the
84:47 - angle of the ship
84:49 - and the output array the expected array
84:51 - is just an
84:53 - array with direction in it it's just a
84:55 - single
84:56 - length sorry a one length array
84:59 - that's our training so we'll be training
85:02 - that every iteration
85:05 - now if i foresee one problem
85:08 - where this a x a y and s a they take on
85:11 - strange values so ax could be a number
85:14 - like 600 a y could be minus 23.
85:17 - sa could be
85:19 - uh
85:20 - 3.8 or whatever right
85:22 - they're not normalized are they but
85:24 - let's see what they do it might not be
85:26 - an issue
85:31 - okay
85:32 - you can see that these errors don't seem
85:34 - to be getting any better let's pump up
85:37 - the
85:38 - number of
85:40 - pump up the number of samples
85:43 - just while we're here we'll that's the
85:45 - number
85:46 - of training
85:49 - samples
85:51 - so we'll pump that up to 1 million let's
85:53 - see what that does
85:59 - to me that looks like it's not getting
86:01 - anywhere
86:02 - because these errors are still
86:04 - incredibly large
86:07 - they're not getting any closer to zero
86:09 - so i don't like that so i think we'll
86:11 - need to normalize our data
86:14 - we'll put that back to oops we'll put
86:16 - that back to a hundred thousand i don't
86:18 - think we need a million samples but a
86:20 - hundred thousand should do us head back
86:22 - down to our training here
86:25 - we'll need to normalize this data here
86:28 - before we input it into the training
86:30 - array so how about we create a method a
86:33 - new function called say normalize input
86:36 - or similar so just before shoot laser
86:39 - function
86:40 - normalize
86:42 - input
86:43 - we'll need to pass the roids x location
86:46 - the roids y location and our ships angle
86:51 - they're our three neural inputs now what
86:53 - we mean by normalize is normalize
86:56 - the values
86:58 - to between
87:01 - zero and one
87:02 - so we'll divide them by something in
87:04 - order to get them to be between zero and
87:06 - one
87:07 - so let's create a new
87:09 - uh array an empty array
87:12 - called input let input equal empty array
87:15 - and input
87:17 - zero
87:18 - that will be
87:19 - our roid x
87:22 - value
87:23 - we'll need to now normally you could
87:25 - just go right x divided by the canvas
87:27 - width that would give give us our screen
87:29 - position our relative screen position
87:31 - but because we've allowed it to be off
87:33 - screen up to its radius then we'll need
87:36 - to modify this so roid
87:38 - x
87:39 - so that could be negative 50 could be
87:42 - negative it could be the negative radius
87:43 - it could be negative 50. so we'll have
87:44 - to add the radius back to that to get it
87:47 - back to zero so roid
87:50 - size
87:52 - divided by two
87:54 - and we'll have to divide all of that by
87:58 - the new canvas width including the
88:00 - radius on the left and right so that'll
88:02 - be canvas
88:05 - width
88:07 - plus
88:09 - the diameter which is just the roid size
88:13 - let's just work through that logically
88:15 - so roid x could be minus 50. so minus 50
88:19 - plus
88:20 - 50
88:21 - equals zero zero divided by anything is
88:23 - going to be zero that's fine
88:25 - now the maximum value this could take
88:27 - would be
88:28 - just say we'll choose an arbitrary width
88:30 - of 500 so 500 plus 50 is 550
88:34 - plus 50 is 600 600 divided by 500 plus
88:39 - 100 is 600 so that'll be one that's good
88:42 - and halfway between say 250 250 plus the
88:46 - radius of 50 is 300 300 divided by 500
88:50 - plus 100 600 300 divided by 600 equals
88:53 - 0.5 that sounds good
88:56 - we'll do the similar sort of thing for
88:58 - the x sorry for the y
89:01 - position
89:02 - except that we'll use the height instead
89:06 - now the next one ships
89:09 - angle this is a bit of an easier
89:11 - exercise all we have to do is
89:13 - divide the
89:15 - past angle so that'll be a number
89:17 - between 0 and 360 in effect in radians
89:21 - we just have to divide that by 360. so
89:24 - math
89:25 - pi
89:26 - times two so an angle of zero divided by
89:29 - that would be zero an angle of 360
89:31 - divided by that would equal one and
89:33 - everything in between that's great let's
89:36 - return that input
89:38 - array so let's go up and implement that
89:40 - in our training section
89:43 - train the network so all we have to do
89:45 - is normalize this data beforehand
89:48 - normalize input before we put it through
89:51 - our
89:52 - chain function
89:53 - let's give that a go
89:59 - it's looking better
90:01 - at least it's getting closer to zero
90:03 - there's some discrepancies here maybe we
90:05 - just need to modify some of the
90:08 - parameters here so how about we bump up
90:10 - a number of hidden to say 20
90:12 - and we'll set our number of samples to
90:14 - say
90:15 - 500 000.
90:17 - just while we're here we might as well
90:19 - change the number the amount of logging
90:21 - let's change that to say every 20 000
90:24 - instead
90:25 - okay
90:27 - let's give that a go
90:31 - so it's a bit slower because we've got
90:32 - more hidden uh neurons
90:35 - but it does look like it's getting
90:37 - better the the errors aren't too bad are
90:40 - they
90:42 - look at that one down the bottom very
90:44 - close to zero so i think we've done
90:46 - quite well with that if we put that
90:48 - if we put the hidden nodes back to 10
90:51 - it'll speed it up a bit will that impact
90:53 - the quality let's have a look
91:00 - that's pretty good too actually
91:02 - either way well let's leave it at 20 and
91:05 - 500 000 number of training samples
91:08 - just while we're here i'm thinking that
91:10 - we'll need an output threshold because
91:13 - none of these predictions are going to
91:14 - be exactly zero or exactly one are they
91:17 - but they might be close
91:19 - so how about we create a threshold
91:22 - for example 0.25 just an arbitrary value
91:25 - to begin with
91:26 - and this is how close the prediction
91:28 - must be so how close
91:31 - the prediction
91:32 - must be
91:34 - to
91:35 - commit
91:36 - to a turn
91:38 - so at 0.25 for example if the prediction
91:40 - is 0.75 or greater we would commit to a
91:43 - right turn if the prediction was less
91:45 - than 0.25 we'd commit to a left turn
91:48 - however if the prediction was say 0.5 we
91:51 - won't do anything we'll just sit in the
91:52 - middle so how about we start
91:54 - implementing some of this so let's go
91:56 - down to well first of all let's see what
91:58 - happens when we push the left and right
92:00 - arrow keys so in the key down method
92:04 - so when we've got manual control of this
92:06 - all we're doing is setting the ship's
92:07 - rotation to this
92:10 - how about we create a function that can
92:12 - handle because when we turn right it's
92:15 - the same thing except we're going the
92:16 - opposite direction so let's pull those
92:18 - out and create a function for that
92:20 - because we'll need to call this function
92:22 - what will we call it rotate
92:25 - ship
92:26 - it was pass a boolean we'll say that
92:29 - false equals left
92:32 - right false equals left and here
92:35 - we'll rotate ship
92:39 - true so that'll be right
92:41 - and let's what do we do in the key up
92:43 - method the key up just sets the ship's
92:45 - rotation to zero so that's fine we don't
92:47 - need to do anything with that so let's
92:49 - go down make that rotate ship
92:51 - just after our normalize input function
92:56 - rotate
92:57 - ship
92:58 - it'll take a boolean which is equal to
93:01 - right
93:02 - so we'll be doing that
93:05 - now if it's right we want to put that as
93:08 - negative so how about we make a variable
93:09 - called say let sine
93:12 - equal now if it's right
93:15 - if it's right the sign will be -1 else
93:18 - it will be positive one
93:20 - and we'll just multiply this by
93:23 - the sign
93:26 - that should be okay just to make sure we
93:28 - haven't broken anything how about we
93:30 - turn it back into manual mode
93:32 - so automation on is false
93:35 - and make sure that we can control this
93:36 - ship
93:38 - yep i can turn left and right no problem
93:41 - that's all good
93:43 - put that back to true
93:45 - and now let's go down to our update
93:48 - function where is that down here
93:52 - to do control the ship
93:54 - so we'll need to make a prediction make
93:57 - a prediction
93:59 - based on current data
94:03 - so let's make some variables so we need
94:05 - to know the asteroids x which will equal
94:08 - roids
94:10 - um
94:11 - we'll just use because there's only one
94:12 - asteroid to begin with we'll just use
94:13 - roid 0 for the time being roid0.x
94:18 - similarly a y will equal roids
94:23 - sorry roids0.y
94:25 - and we also need to know the ship's
94:28 - angle don't we so that's just the ship
94:31 - dot a
94:32 - ship dot a
94:34 - now to make a prediction how we go let
94:37 - predict
94:38 - equal we just need to run our feed
94:40 - forward function
94:42 - feed
94:44 - feed
94:45 - forward
94:47 - it will take the input array so input
94:50 - array will be ax
94:53 - but we have to normalize this don't we
94:55 - so hang on do the normalize first
94:58 - normalize input it takes the voids x so
95:02 - a x
95:03 - a y
95:05 - and the ship's angle
95:07 - normalize input
95:09 - remember that returns a matrix an output
95:11 - matrix so we'll have to take its data
95:15 - and there's only going to be one output
95:17 - so it'll be the first column and the
95:19 - first so the first row first column 0 0
95:23 - that should be our prediction
95:25 - now we need to decide which way to turn
95:27 - so make a turn
95:30 - now we're going to get a value it's not
95:32 - going to be exactly zero it's not going
95:34 - to be exactly one so how about we find
95:36 - the difference between it between the
95:38 - prediction and our
95:40 - left and right turns so let
95:42 - we'll call it delta left or difference
95:45 - left whatever you're going to call it
95:47 - delta left will equal the prediction
95:49 - make this the absolute value math
95:51 - absolute value
95:53 - it'll be the prediction
95:57 - minus the
95:59 - uh output
96:01 - uh constant output left
96:04 - right and delta right
96:08 - will equal the prediction minus the
96:10 - output right
96:12 - so let's just
96:14 - try to analyze that so the prediction
96:15 - just say the prediction is 0.2
96:17 - right
96:18 - so 0.2 minus output left is 0.2 that
96:21 - means there's only it's 0.2 units close
96:24 - to the left
96:26 - 0.2 minus
96:28 - 1 is 0.8 the absolute value will be 0.8
96:30 - so that's not going to be what we want
96:32 - to do so we'll have to compare it we'll
96:33 - have to compare these to our thresholds
96:36 - okay
96:37 - so if
96:38 - delta left
96:41 - is less than our output threshold so if
96:45 - it's less than 0.25 or whatever value we
96:47 - choose to set it at
96:49 - then we wish to rotate left rotate ship
96:53 - now left is just false
96:57 - okay else if
96:59 - delta right
97:02 - is less than the output threshold
97:06 - then
97:07 - we will rotate the ship right
97:10 - which is true
97:12 - now if it's neither so for example 0.5
97:15 - 0.5 minus the output left is 0.5 0.5
97:18 - minus output right it's not going to be
97:20 - less than the threshold in either of
97:22 - these situations so how about we just
97:24 - put an else here saying that
97:26 - um
97:26 - [Music]
97:28 - stop rotating
97:30 - so if it's not confident it'll stay
97:32 - still so ship dot rotate
97:35 - equals zero so that's equivalent to us
97:38 - releasing the arrow keys
97:40 - i think we should just log this
97:42 - prediction here so console
97:44 - log
97:45 - predict
97:47 - just so
97:49 - we can see if there's any problems with
97:50 - it
97:51 - okie dokie let's try it
97:56 - so we're just training it to begin with
97:58 - with 500 000 samples
98:00 - the errors look pretty good
98:03 - that one wasn't very good
98:08 - okey-dokey what's it doing
98:11 - it seems to be stuck i know
98:15 - now it is turning
98:18 - it's kind of slowly turning
98:21 - towards the asteroid will it turn when
98:24 - it goes past it yes
98:27 - it's okay it's maybe not the best
98:31 - now i wonder why
98:34 - we'll just watch it a bit longer it's
98:36 - kind of getting confused a bit isn't it
98:39 - okay i've been watching this for a while
98:41 - now it looks like something's going
98:42 - wrong because it eventually the ship no
98:45 - matter how many times you run it the
98:47 - ship eventually starts spinning around
98:49 - in its inner circle without
98:51 - and it's got these really
98:53 - very confident predictions so see this
98:56 - prediction here it's very very low it's
98:58 - close to zero
98:59 - so
99:00 - i'm guessing something's going wrong
99:02 - with our angle so let's go into our
99:05 - code maybe we should log the angle here
99:08 - ship
99:09 - dot
99:10 - angle
99:12 - let's see what that does
99:18 - okay it's loading the training data
99:19 - again
99:31 - okay so the angle remember it'll be a
99:33 - number between 0 and 2 pi which is about
99:36 - 6 or so
99:37 - now that's not good see the angle is
99:39 - going negative there we want the angle
99:41 - to be zero between zero and two pi so
99:44 - there's something
99:45 - i think i might know what's wrong
99:48 - if we head down to where we rotate our
99:50 - ship in the update function
99:53 - i suspect that we're just letting it add
99:56 - on endlessly
99:57 - we are so for example the ship out the
100:00 - ship angle can just keep going up and up
100:02 - and up and up so it'll go beyond 720 and
100:04 - so on it could go below zero no problems
100:06 - which is fine it was working fine in the
100:08 - game but for our prediction we want it
100:11 - to be between 0
100:13 - and 360. so we want to keep the angle
100:17 - between
100:18 - 0 and 360 which is 2 pi remember 2 pi
100:23 - so if the ship's
100:26 - angle is less than 0
100:29 - we'll need to add 360 to it remembering
100:32 - if we add 360 it'll still be the same
100:33 - angle so plus equals
100:36 - math
100:37 - pi do we need to bracket this i'm not
100:39 - sure
100:40 - i'm not sure what the order of
100:42 - operations are for these
100:43 - these assignment operators we'll just
100:45 - bracket it won't hurt math times two
100:49 - we'll add 360 to it
100:52 - else
100:53 - if
100:54 - a ship's angle
100:56 - is greater than
100:58 - or equal to
101:00 - 360.
101:01 - 360. math times i'll bracket this one as
101:04 - well math dot pi
101:06 - times 2 if it's greater than that then
101:10 - we'll want to subtract we want to do the
101:11 - same thing except that we'll subtract
101:15 - 360. we don't want exactly 360 because
101:17 - our randomly generated uh position will
101:20 - never be 360 i don't think
101:24 - minus equals that
101:26 - and
101:27 - that should do it
101:29 - let's give that a go
101:30 - let's load it up
101:32 - loading the training data
101:36 - so the training data looks pretty good
101:38 - it should be working quite well
101:43 - okay
101:44 - i think that's acting a lot better
101:47 - where's the asteroid there's the
101:48 - asteroid yeah i think it's tracking it
101:50 - quite well
101:53 - i think that was our problem
101:55 - yep so it's choosing the first asteroid
101:57 - which is whatever's in the in the array
101:59 - first in the array and following it
102:02 - good okay how about we add some shooting
102:05 - to this little ship
102:07 - so let's head back all the way up to the
102:09 - top to set some
102:12 - parameters
102:13 - so we'll probably need to give the ship
102:15 - a
102:16 - rate of fire so just in under our neural
102:18 - network parameters here let's create one
102:21 - called rate of fire
102:24 - and we'll set that to say five shots per
102:27 - second so shots per second
102:32 - we'll also need to keep track of how
102:33 - many frames we count down to the next
102:36 - shot so
102:37 - where we set up our neural network here
102:39 - let's just put in a new something called
102:42 - say a i
102:43 - shoot time
102:45 - and we'll set that to zero to begin with
102:48 - where will we update that well we'll
102:50 - update that in
102:53 - our water where we do our prediction
102:57 - so just after we make it turn now what's
102:59 - the strategy for firing when when will
103:01 - we shoot well we could shoot just when
103:04 - it's not rotating
103:06 - but that's not really what i do i keep
103:08 - turning and just shooting all the time
103:09 - because eventually you're going to get
103:10 - lucky too so how about we shoot all the
103:13 - time it'll shoot as often as it can so
103:15 - shoot the laser
103:18 - if a i shoot time
103:20 - equals zero which will it'll start at
103:23 - zero then we want to reset that a issue
103:26 - time not this
103:27 - a i shoot
103:29 - time
103:30 - will equal the frame rate divided by the
103:33 - rate of fire
103:35 - i think we should find the ceiling of
103:37 - that
103:39 - math.seal
103:42 - so if we had a frame rate of 30 divided
103:44 - by the rate of fire of 5 that'll every 6
103:47 - frames we'll shoot if it was 10
103:50 - so 30 divided by 10 would have we'd be
103:52 - shooting every third frame so quite
103:55 - quickly
103:56 - uh we'll need to shoot the laser shoot
103:58 - laser
104:00 - just
104:01 - checking that function
104:03 - because part of that condition is that
104:05 - the ship can shoot and when we shoot a
104:07 - laser the ship can't shoot
104:10 - that's because the player must push the
104:12 - space key then release it so we'll have
104:14 - to set that up to be able to handle that
104:18 - or we can we can just do it here ship
104:20 - dot can shoot equals true so whenever it
104:24 - can fire we'll let it fire
104:27 - else so if the ai shoot time doesn't
104:29 - equal zero we'll want to count down a i
104:31 - shoot time minus minus so this is just
104:33 - counting down the frames left
104:36 - so let's give this a go
104:39 - so loading in our training data
104:43 - so hopefully this little ship will
104:45 - follow the first asteroid and just keep
104:48 - shooting at it until it's destroyed and
104:50 - then it'll follow the next asteroid
104:53 - yeah that's what it's doing
104:57 - bang bang bang bang yeah just keep
104:58 - shooting it's pretty effective actually
105:02 - even when we're not targeting the
105:03 - closest asteroid
105:05 - so how about we program it to target the
105:08 - closest one so head back into our
105:12 - update function
105:16 - so compute
105:19 - the closest
105:21 - asteroid
105:23 - uh we'll need to keep track of the index
105:25 - so how about we just make a variable
105:27 - called say let c equal zero so this will
105:31 - be the closest index in the array
105:34 - uh we'll need to calculate the distance
105:36 - we'll need to keep track of the closest
105:37 - distance so we'll call that say distance
105:40 - zero
105:42 - will equal we have a method for
105:44 - calculating distance distance between
105:46 - points
105:47 - uh the x1 y1 so the ship dot x
105:51 - the ship dot y
105:55 - uh the x2 will be the asteroid so roids
106:00 - zero
106:01 - dot x
106:03 - roids
106:05 - zero
106:06 - dot y
106:09 - and then we'll have to loop through each
106:11 - of the asteroids so four let i equal
106:15 - zero
106:17 - actually let it equal one because we've
106:19 - already calculated the first one
106:21 - distance zero there so let i equal one
106:24 - i is less than the asteroid's length
106:27 - roid's dot length
106:29 - i plus plus
106:32 - and then we need to
106:35 - get the distance of the current
106:36 - asteroids we'll call that distance one
106:38 - distance 1 will equal distance it's
106:40 - going to be the same thing really
106:43 - basically
106:45 - except that we'll be using i instead of
106:48 - 0 here
106:51 - and then all we have to do is do a check
106:53 - to see if that one's that distance is
106:55 - smaller less than the uh
106:58 - current distance so if distance
107:02 - 1 is less than distance 0
107:06 - that means it's smaller doesn't it so
107:08 - we'll replace distance zero distance
107:10 - zero will equal
107:12 - distance one and we'll want to update
107:14 - our
107:15 - uh index closest index so c will equal i
107:19 - so all we have to do is put that c
107:22 - into where we've got zero down here so
107:24 - ax will equal right c
107:26 - a y will equal roid c dot y
107:29 - and let's give that a go
107:32 - loading our training data again
107:37 - so hopefully it'll turn towards the
107:39 - closest asteroid and shoot at it
107:43 - there's only one asteroid here
107:45 - that reminds me we should probably up
107:47 - the number of starting asteroids back to
107:50 - its original so roid numb will equal
107:52 - three
107:54 - save that
107:56 - load it one more time
108:07 - okay is it turning towards the closest
108:10 - one
108:11 - certainly it's not shooting the furthest
108:12 - away ones anyway
108:14 - so it's doing fairly well
108:17 - it's not perfect
108:21 - i'm thinking we could probably make this
108:23 - a little bit better i think we'll do one
108:26 - more one more update to our little
108:28 - function here
108:30 - how about we pass some more information
108:33 - because we're only passing kind of the
108:34 - bare minimum we're passing the asteroid
108:37 - location
108:38 - and the ship's angle i think we can do
108:40 - better than that so head back into the
108:41 - code
108:42 - to head down to where we set up our
108:44 - training data
108:47 - what else could we pass
108:48 - well we are calculating the angle to the
108:51 - asteroid
108:53 - how about we stick that in as one of our
108:54 - inputs so we'll put it in after our
108:57 - asteroid position
109:00 - we'll have to bump up the number of
109:01 - inputs to four
109:05 - so down here our normalize input we'll
109:08 - have to add an extra
109:10 - here we'll pull that roid
109:12 - angle right angle it'll be our third one
109:16 - it's going to be very similar to how we
109:18 - do the ship angle we'll just put right
109:20 - angle there roid angle
109:22 - ship angle update its index to three
109:25 - uh wherever we call this what that fix
109:27 - it up which is just down in our update
109:30 - function
109:31 - so we'll have to pass an angle in there
109:35 - and we'll have to calculate that angle
109:37 - so what do we need to know for that we
109:39 - need to know the ship's x and y
109:40 - coordinates so s x will equal ship dot x
109:45 - you didn't you don't really have to do
109:46 - this but this is to make it clear
109:49 - ships y
109:50 - ship dot y
109:52 - and let angle equal
109:55 - angle
109:58 - angle to point now what does it take x
110:01 - and y which is the ship x and the ship y
110:04 - it takes the bearing which is the ship's
110:07 - angle
110:08 - the target x which is the asteroids x
110:11 - and the asteroids y
110:13 - and then we'll pass that in through our
110:15 - feed forward function to get a
110:16 - prediction i don't think we need to log
110:18 - this anymore with this prediction
110:20 - uh let's take a look at that
110:26 - okay import um
110:28 - doing our training
110:30 - wow those errors are very small so
110:31 - they're e to the minus 15 there's a
110:34 - couple of zeros in there so they're very
110:36 - precise
110:38 - so looking at our ship's performance
110:40 - yeah he's doing pretty well
110:42 - he should be doing very well the only
110:44 - issue i can see is that see that jitter
110:45 - there that's because we're only making a
110:48 - prediction every frame if we increased
110:50 - our frame rate we could probably make
110:52 - that better
110:54 - and also if we reduced our threshold to
110:57 - decide whether we turn or not so let's
110:59 - do that now
111:01 - so head up to the top
111:03 - we'll reduce our output threshold to say
111:05 - 0.05
111:06 - that means in order to make a right turn
111:08 - we'd have to have 0.95 confidence
111:11 - let's increase the rate of fire for fun
111:13 - to say to 15 shots per second
111:16 - and we want to increase our frame rate
111:19 - to say 60.
111:21 - let's give that a go eh
111:26 - okay just loading our
111:28 - training data
111:30 - the errors are very very good
111:38 - and here he goes
111:40 - wow
111:42 - we've created a monster
111:45 - so with his increased
111:46 - with his increased rate of fire
111:49 - and the faster frame rate
111:52 - he can make more accurate more subtle
111:54 - turns
111:55 - and really pepper those asteroids with
111:58 - laser fire
112:01 - cool
112:02 - so anyway that's the end of our tutorial
112:04 - series so we've gone from using matrix
112:06 - maths
112:07 - to creating a neural network only a
112:09 - fairly simple neural network but a
112:11 - neural network all the same i hope
112:13 - you've learned a lot from this i
112:15 - certainly have because i had to do a lot
112:16 - of research in figuring all this stuff
112:18 - out
112:19 - but in the end we managed to use our
112:20 - network to control a simple game such as
112:23 - asteroids and this is the result
112:26 - i wonder how far he could go how far
112:28 - could this uh what level could this
112:31 - ship reach
112:32 - well anyway feel free to download the
112:34 - code and try it out for yourself update
112:36 - the parameters have a play and learn
112:38 - something new
112:40 - until next time
112:41 - talk to you then bye
112:43 - [Applause]
113:09 - [Applause]