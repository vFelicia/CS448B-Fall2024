00:00 - learn how to create your very own
00:01 - programming language and the only
00:03 - prerequisite knowledge is basic python
00:05 - Ariane Hegde teaches this course along
00:08 - the way you'll learn more about object
00:10 - oriented programming linear data
00:12 - structures binary trees recursion
00:15 - tokenization parsing and more so let's
00:19 - get started welcome to this brand new
00:21 - course where I'll be teaching you how
00:23 - you can create your own programming
00:24 - language using python now the goal of
00:28 - this project was to teach you how you
00:30 - can Implement a bunch of programming
00:32 - Concepts into a real world project I
00:35 - have always felt that especially in
00:36 - computer science Concepts have been
00:39 - taught in a sort of abstract and
00:40 - detached manner independent from The
00:43 - Real World and that's why in this course
00:45 - I bring to you a bunch of Concepts like
00:47 - data structures like algorithms
00:49 - recursion object oriented programming I
00:53 - teach how you can Implement all of these
00:54 - Concepts into a real world project you
00:58 - can also head over to
00:59 - blog.algalon.net or click on the link in
01:02 - the description where I talk about a
01:04 - bunch of learning methods I employ
01:06 - during my learning phase to have a
01:08 - better grasp on Concepts and a higher
01:10 - memory retention now the only
01:12 - prerequisite for this course is basic
01:14 - python knowledge stuff like if
01:16 - statements variables while loops and
01:18 - functions and with the basic foundations
01:21 - laid I'll take you to the next level
01:23 - talking about data structures algorithms
01:26 - recursion and much more and by the end
01:28 - of this course you'll have your own
01:30 - programming language so by the end of
01:32 - this project we'll be having the final
01:34 - output so this is our I've run the
01:38 - shell.py file over here and this is what
01:42 - our output is going to look like so
01:43 - we're going to input our shadow script
01:45 - code
01:47 - as a python input so I'm gonna say let's
01:49 - say we can give an input arithmetic
01:51 - expression so one plus one it returns
01:54 - two I can do 5 plus 3 it will give us 8.
01:58 - now I can even talk about order of
02:00 - operation so I can even do one plus four
02:02 - multiplied by 7.
02:04 - in the wrong order of operations that'll
02:06 - be 5 times 7 which is 35 but the correct
02:09 - way to load is multiplication first so
02:12 - we'll have 7 times 4 which is 28 plus
02:14 - 129 which is what we get
02:17 - if we want to make the addition we want
02:20 - to give higher priority tradition we can
02:22 - add a pair of parentheses
02:24 - multiply by 7 and this should give us
02:26 - 35. so that's all about arithmetic
02:29 - Expressions that we can give it apart
02:31 - from math it can do other stuff as well
02:33 - it can create variables so I'm going to
02:34 - say make
02:35 - variable a
02:37 - and I can assign that variable to the
02:39 - value 10 and like how in JavaScript you
02:42 - have the VAR declaration or the let
02:44 - declaration and this time we're using
02:46 - make so the make will be used to create
02:48 - a new variable so we create a variable
02:51 - called a and give it give it the value
02:53 - 10. I can make another variable B set it
02:56 - to 15. and I can make another variable C
02:59 - and set it to a plus b
03:02 - and this stores the correspond the
03:05 - variables and the corresponding values
03:07 - in a python dictionary now after
03:09 - variables we can also deal with
03:11 - conditional operators and comparison
03:13 - operators so sorry Boolean operators and
03:16 - comparison operators
03:18 - so Boolean operators is something like
03:20 - stuff like and or and not the comparison
03:24 - operators are greater than less than is
03:27 - one thing equal to another thing and so
03:29 - on so I can run a Boolean operation I
03:32 - can say 7 greater than 2 and
03:36 - 5 greater than 3 in this case both of
03:38 - the
03:41 - um expression 7 greater than 2 and 5
03:43 - greater than three both are true and
03:45 - therefore this should return 1 which
03:47 - stands for true if I do 7 greater than 2
03:50 - and 5 Less Than 3 which will return 0
03:52 - which stands for false act into 7
03:55 - greater than 2 or 5 Less Than 3 which
03:59 - will give me 1 again
04:00 - I can do not so I can say not 7 greater
04:03 - than 2 so this will give me 0 because 7
04:06 - is greater than 2 and then we're not in
04:07 - that operation we are inverting it where
04:10 - um turning 1 to 0.
04:13 - so that's the Boolean operators we can
04:14 - even have two two things are the same I
04:17 - can check if C is equal to B so this is
04:20 - how I use it in Python you have two
04:22 - equal symbols to check if one variable
04:24 - is equal to another in in our syntax we
04:28 - Define it as C question mark equals B
04:31 - and if I run this this is 0 y because 25
04:34 - is not equal to 15.
04:36 - I can make another variable d
04:39 - set it to 25
04:42 - and now if I do D equals to C this will
04:45 - give us 1. so that's the comparison
04:48 - operators I can't even check if C is
04:51 - greater than a and that gives us 1 and
04:53 - so on
04:54 - so apart from the comparison operators
04:56 - you can now use if statements so I can
05:00 - say
05:01 - if
05:03 - a is greater than 3
05:06 - do something so do
05:08 - three times three that makes no sense
05:10 - but let's just see if this works and
05:12 - that will give us the output 9 because a
05:14 - is greater than 3 but if I do if a is
05:17 - less than 3 do 3 times 3 it will give me
05:21 - nothing
05:22 - I can answer on ellips so I can know if
05:26 - a is less than 3 do 3 times 3 l if a is
05:31 - greater than 12 do 5 times 5
05:36 - else do 10 times 6 so in this case a is
05:41 - not greater than 3 and it is not greater
05:43 - than 12. so both the conditions won't be
05:45 - met and it will go to the else statement
05:47 - and run 10 times 6 which is 60 as the
05:50 - output
05:51 - now the final thing that we Implement in
05:53 - this course is while Loops as well so
05:55 - how do you run a while loop I can say
05:58 - while
06:00 - a is less than 15. do and then we have
06:05 - to make a statement so do
06:07 - following a statement with following the
06:10 - do keyword we have to give a statement
06:11 - like make a equals a plus one so
06:14 - incrementing is value by 1.
06:17 - and this will print the variables list
06:20 - in every iteration of the loop
06:23 - so that's all there is to it in this
06:25 - course we haven't talked about more
06:27 - advanced functionalities like strings or
06:30 - possibly even
06:33 - styles of programming which we could
06:35 - Implement in our language like object
06:37 - oriented programming or functional
06:39 - programming we haven't talked about
06:40 - those aspects because we want to keep
06:42 - this course simple while also
06:45 - learning about a lot of other computer
06:48 - science Concepts like data structures
06:50 - algorithms and the programming paradigms
06:52 - and lots of stuff so we're gonna talk
06:55 - about all of those Concepts from a
06:57 - beginner level and by the end of this
06:59 - course we'll have this amazing project
07:02 - built from scratch so let's begin this
07:05 - course
07:08 - so I'm going to start this course by
07:10 - talking about how computers are able to
07:12 - read code on a high level now this is
07:15 - not really necessary to understand the
07:18 - implementation phase of this course
07:20 - where we will be dealing with python
07:22 - code and writing our interpreter but I
07:25 - just think that this help would helps
07:27 - put things into perspective and explains
07:30 - how computers are able to actually do
07:32 - this stuff in a more physical manner
07:36 - so ultimately
07:38 - um if you've scaled the microscopic
07:41 - level you'll find that computers are
07:43 - made of transistors and they are
07:45 - indicated by the following symbol
07:48 - so um the two wires over here are
07:51 - electrodes
07:57 - and in between is a material known as a
08:00 - semiconductor
08:03 - a semiconductor typically made of
08:05 - silicon or I'm not really going to go
08:07 - into the chemistry but but it composes
08:10 - of silicon and semiconductor is a
08:13 - material that allows current to flow
08:15 - through given a certain input from the
08:19 - control wire so this is the control wire
08:22 - when the control wire is on the
08:24 - semiconductor will allow current to flow
08:26 - through it when the control wire is off
08:29 - the semiconductor won't allow current
08:30 - refer to it so let's represent
08:34 - um these states on and off using two
08:36 - numbers zero and one also known as
08:38 - binary so
08:40 - when the control wire is on the
08:42 - semiconductor conducts electricity and
08:45 - if this let's say is the output
08:48 - so then and let's consider the control
08:51 - wire as the input so we have input and
08:53 - output and we have a way to represent
08:56 - data using binary
08:57 - so over here
08:59 - input is 1 the control wire is on the
09:01 - semiconductor can conduct electricity
09:03 - and it will generate the output 1 and if
09:07 - it is off the output will also be off
09:10 - Now using transistors we can generate
09:13 - logic gates there are multiple ways to
09:15 - generate logic gates
09:17 - um you can use different mechanisms as
09:18 - well but typically inside a computer
09:22 - you'll find transistors and transistors
09:24 - forming the logic gates
09:25 - so how do you make a transition how do
09:28 - you make a logic gate from a transistor
09:30 - I'm going to start off with a simple
09:32 - logic gate which is known as the not
09:34 - gate in fact there are three of them
09:36 - there's the not
09:37 - the and and the or
09:40 - which are the fundamental logic gates
09:42 - that computers use they are also known
09:45 - as Boolean operators that we will be
09:47 - working with during this course during
09:49 - the implementation so not essentially
09:52 - reverses the input so if the input is
09:54 - one a not operation turns it to zero the
09:57 - input is zero the not operation turns it
09:59 - to one
10:00 - and this not gate is built from
10:03 - transistors one way you can build a not
10:05 - gate is
10:08 - okay let me draw that again
10:10 - you can have the output go in that way
10:13 - and have the control y over here so
10:15 - control bar is the input and that's the
10:17 - output so over here
10:19 - input and output
10:22 - if the input is 1 that means current
10:24 - will flow in this direction it will go
10:26 - down and flow in this direction so the
10:28 - output will be zero if the input is zero
10:33 - the output will be 1. and what I'm
10:35 - drawing over here these tables so
10:39 - I know why that's not working yeah there
10:41 - we go so these tables are also known as
10:44 - truth tables they're one of the first
10:46 - things you actually taught in computer
10:48 - science anyway so it's it's just like
10:52 - four cells in an Excel sheet anyway
10:56 - so that's what the not gate does
10:58 - similarly you can construct the and and
10:59 - the nor gate using just combination of
11:02 - transistors I'm not going to go into
11:03 - those details but all you need to know
11:06 - is that the not gate flips the input
11:08 - operation the or gate has a different
11:11 - sort of truth table for a certain input
11:14 - it has two inputs i1 and let's say I2
11:16 - and one output if both of them are on
11:19 - this will be on if one is on it'll still
11:23 - be on but if both of them are off the
11:25 - output will be off
11:27 - so that's the or gate the and gate is
11:31 - um another logical logical operator it
11:33 - has two inputs i1 and I2
11:36 - and it has an output and only if both i1
11:39 - and I2 are on will the output be on
11:42 - otherwise the output will be zero
11:45 - so that's the basics of you know and
11:47 - Gates not Gates and or Gates these form
11:49 - the fundamental logic gates there are
11:52 - some other Gates as well like the X
11:53 - socket but I'm not going to talk about
11:55 - them right now these Gates instead of
11:58 - representing them as transistors we
11:59 - represent them as their own symbol so
12:02 - let me just draw their own symbol
12:08 - and that's the or gate
12:12 - 3 Gates three simple
12:17 - so how do computers perform arithmetic
12:19 - with these logic gates there are two
12:21 - main functionalities we're looking for
12:22 - arithmetic and memory and once we
12:25 - understand both of them I'm gonna move
12:26 - on to the more
12:28 - um the side of this course which is more
12:30 - relevant to creating your own
12:32 - programming language so again as I said
12:35 - we have two operations to accomplish
12:37 - arithmetic which is basic algebra or uh
12:40 - not basic algebra basic addition
12:43 - subtraction multiplication or Division
12:45 - and the memory is refers to storing data
12:49 - essentially storing binary and then we
12:52 - can use the binary to represent other
12:54 - forms of data like for instance video or
12:57 - audio or whatever
12:59 - so anyway
13:00 - before we move on to the arithmetic I
13:02 - want to talk about another gate which is
13:04 - the Excel gate I'm now going to talk
13:05 - about how it's formed this is its symbol
13:08 - it's similarly or gate actually and
13:11 - that's you know
13:13 - yeah there we go
13:15 - so that's how the xorbit looks like and
13:18 - it looks similar to the or gate it too
13:20 - has two inputs I2 and i1
13:24 - and the truth table
13:28 - and the truth table is something like
13:30 - this if both are 0 the output is zero if
13:33 - either one of them is on the output is
13:36 - on
13:37 - or one and if both of them are 1 the
13:41 - output is zero
13:45 - that's the xor gate
13:49 - now in binary you can also perform
13:51 - addition so what I was referring to as
13:54 - arithmetic let's say you want to add the
13:56 - binary numbers one and one
13:59 - so you would have to represent them as 1
14:02 - 0 essentially uh how do you how you
14:06 - represent binary numbers is the
14:07 - following you you represent decimal
14:09 - numbers which is the base 10 notation in
14:11 - forms of in the form of powers of 10 so
14:14 - for instance 10 to the power 0 10 to the
14:16 - power 1 10 to the power 2 and so on so
14:18 - that's the ones position tens and
14:20 - hundreds position and so on that we've
14:22 - been learning in elementary school so if
14:25 - you have let's say uh the number
14:29 - 3 4 6 so that just corresponds to 3
14:33 - times 10 to the power 0 plus 4 times 10
14:36 - to the power 1 plus 6 times 10 to power
14:39 - 2 which is 643.
14:41 - so that's how we represent
14:43 - um decimal numbers but binary is
14:46 - different it is base 2 so you have 2 to
14:48 - the power 0 2 to the power 1 and 2
14:50 - squared
14:52 - and you can't have numbers from 0 to 9
14:55 - it's not base 10 you have you can have
14:57 - numbers only from 0 and 1 so 0 and 1. so
15:00 - if you want to represent the number
15:01 - three let's say so that'll be 0 over
15:04 - here
15:05 - one over here a little bit it'll be one
15:07 - over here
15:08 - 1 over here and 0 over here so 0 1 1 is
15:11 - 3 how so
15:14 - um let's do that so it's 1 times 10 to
15:17 - the power 0 plus 1 times 10 to the power
15:20 - 1 plus 0 times 2 to the power 2 and this
15:24 - turns out to be 3.
15:25 - so that's how you do uh basic addition
15:28 - in in binary
15:31 - so
15:36 - so that's how you do basic addition in
15:38 - binary now if you look at the xor gate
15:41 - the truth table of the xor gate it
15:42 - actually looks pretty similar to our
15:45 - Edition so I'm gonna do addition for uh
15:47 - one bit numbers only just to demonstrate
15:50 - the idea of arithmetic using logic gates
15:53 - so I'm gonna do 0 plus 0 which is zero
15:56 - zero plus one which is zero
15:59 - one plus zero which is one
16:03 - okay and the previous one is also one
16:06 - and one plus one as I said it's not
16:09 - going to be
16:10 - um
16:11 - two it's going to be one zero and one
16:13 - zero essentially refers to the fact that
16:15 - it's two to the power zero and two to
16:16 - the power one so you have a 0 over here
16:19 - and one over here so that's just 2 to
16:21 - the power 1 times 1 which is two and one
16:24 - zero equals 2 in decimal
16:27 - so now if you look at this over here you
16:30 - can see that the sum which is the first
16:33 - number
16:34 - is exactly the same as the xor gate it's
16:37 - 0 1 1 0 0 1 1 0. but the carry bit which
16:43 - is this one over here that's called the
16:44 - carry bit because it becomes like like
16:46 - in decimal Edition you take one as the
16:49 - carry so you take one over here and then
16:51 - that comes down over here as one so
16:54 - on the carry bit is one that we have to
16:57 - we have to find another gate for the
16:59 - carry bit the carry bit is zero in these
17:02 - cases but one over here and that's the
17:04 - situation for the and gate so if you can
17:06 - combine the or gate the xor gate and the
17:09 - and gate you can actually come up with a
17:11 - way to handle addition in
17:14 - um using logic gates only and that's
17:17 - essentially how we go that's the
17:18 - starting point you go from there uh try
17:21 - to handle more complicated arithmetic
17:23 - like multiplication or Division and it's
17:25 - the that's the same basic idea you are
17:28 - trying to hook up logic gates in a smart
17:30 - manner to perform calculations and
17:33 - that's how arithmetic Works in computers
17:40 - so now let's talk about memory I'll be
17:42 - using a component called the and or
17:44 - latch as an example to show how
17:47 - computers have the ability to store data
17:50 - so it's called the and on latch as I
17:52 - said so let me just construct it
18:04 - so R stands for reset s stands for set
18:07 - and O is the output so we use the set
18:11 - um wire
18:12 - to save data so if you want to say save
18:16 - the num save the binary number one or
18:19 - just want to save the bit one so how do
18:21 - we do that so the first thing we need to
18:22 - do is turn on the set wire so I'm going
18:25 - to draw a truth table over here
18:29 - so we have set reset
18:31 - and let's not worry about reset for now
18:33 - and output
18:35 - so if you put set as 1 and reset as 0
18:38 - what will happen to the output so this
18:40 - is an odd this is an or gate over here
18:42 - so
18:43 - on or gate so once once you turn on the
18:47 - set wire
18:48 - one gets transmitted over here because
18:50 - if either of the inputs of the or gate
18:52 - are 1 the output of the or gate is one
18:55 - so the output of the or gate is one over
18:58 - here and the reset is zero so zero gets
19:01 - knotted and that becomes one so now the
19:04 - and gate
19:05 - converts these two input ones into the
19:09 - output one so in the following scenario
19:11 - where in where you turn on the set wire
19:14 - and leave this reset wire as it is the
19:16 - output turns out to be one
19:20 - now afterwards
19:21 - if we turn off the set y let's turn off
19:25 - the set wire so let's make it zero and
19:28 - there is the reset wire is still zero
19:31 - what will happen to the output
19:34 - so now the set wire is zero but
19:37 - regardless since the output is one and
19:39 - that was fed back as an input to the or
19:41 - gate this is one over here and since one
19:44 - of the inputs is one to the auger this
19:46 - Still Remains as one this uh uh the
19:50 - input to the and gate the right the
19:51 - bottom input to the and gate Still
19:53 - Remains is one and therefore the output
19:56 - Still Remains as one so the output is
19:58 - effectively unchanged
20:00 - even after we uh stopped even after we
20:04 - turned off the set wire and that is
20:07 - effectively what computer memory looks
20:09 - like so the computer has remembered
20:14 - the state
20:15 - it was in and that is known as saving or
20:18 - computer memory you can delete it by
20:21 - turning on the reset key and that's also
20:23 - pretty easy to follow if we turn on the
20:25 - ezt that gets knotted to zero and one of
20:28 - the inputs of the and Gates becomes 0
20:31 - and the output becomes zero and we are
20:34 - back to our original state so that's how
20:36 - basically computers store memory it's
20:39 - solve this feedback mechanism that they
20:41 - use that helps them store memory and now
20:44 - that we've understood these two concepts
20:46 - let's go ahead to the next section where
20:47 - we will talk about the need for
20:49 - programming and why we need to use
20:51 - programming languages
20:56 - so what is the need for programming
20:59 - that's what we're going to talk about in
21:00 - this section of the course now
21:02 - programming refers to giving input
21:05 - instructions to come to a computer so
21:07 - that we can execute them so before we
21:09 - understand how programming works we have
21:11 - to understand how computers understand
21:14 - instructions
21:15 - that's a mouthful let me say that again
21:17 - to understand how programming works we
21:20 - need to understand how computers
21:21 - interpret instructions and as I said all
21:24 - all along that they do this using logic
21:27 - gates so we have a set of logic gates
21:29 - hooked up in a smart way so that they
21:31 - can detect certain instructions like for
21:33 - instance if we have the instruction one
21:36 - zero zero zero
21:38 - so that's the 4-bit instruction over
21:40 - here now how do we decode this the
21:43 - computer has a control unit which is
21:46 - responsible for checking for certain
21:49 - instructions looking for certain
21:50 - instructions and once it finds those
21:52 - instructions it will perform the
21:54 - necessary action so
21:57 - that's how computers interpret
21:58 - instructions they have a control unit
22:00 - control units composed of logic gates so
22:03 - let me just say you have the instruction
22:05 - like this so this is the instruction
22:07 - it's fed into control unit
22:11 - and the control unit
22:14 - um detects the instruction checks if uh
22:17 - say for instance the instruction one
22:19 - zero zero corresponds to uh adding and
22:22 - adding to memory let's say
22:26 - so the control unit will check for that
22:28 - instruction if the instruction is one
22:30 - zero zero and again these instructions
22:32 - are stored in the memory of the of the
22:34 - computer we talked about how computers
22:36 - uh save Things So the instructions are
22:39 - stored in the memory of the computer so
22:43 - um once it once it so it sequentially
22:45 - goes through all of the instructions
22:46 - stored in the memory and let's say this
22:48 - is the instruction at first encounters
22:50 - and it tries to match it with the
22:52 - instruction one zero zero zero and let's
22:54 - say in this situation where it does
22:56 - match with this number
22:59 - uh
23:00 - this number let's say the instruction is
23:02 - one triple zero in that case the control
23:05 - unit will detect it using a logic gates
23:07 - and once it has detected that
23:09 - instruction it will go ahead and perform
23:10 - the operation of saving to memory
23:20 - so this two stages detecting the
23:23 - instruction using the control unit and
23:25 - then performing the uh instruction so
23:28 - you have a table like currents
23:30 - corresponding to 1000 uh corresponds to
23:33 - saving to memory maybe zero one zero
23:36 - zero corresponds to doing arithmetic
23:38 - adding two numbers let's say
23:44 - so you have a table of these
23:46 - instructions so you first design these
23:48 - instructions and then computers
23:50 - programmers will go ahead and input
23:54 - these instructions into the computer's
23:55 - memory the computer would sequentially
23:58 - perform each instruction and will
24:01 - execute them so this is how Computing
24:04 - works on a really high level and the
24:07 - problem arose and this is in the early
24:09 - ages of computing the problem arose was
24:12 - that the problem which arose was that
24:14 - you used harder mediums which is like
24:17 - Hardware interactions to input data
24:19 - these instructions like one zero zero uh
24:23 - were fed in by mechanisms like switches
24:26 - or plug boards or um you had some Punch
24:30 - Cards so these harder mechanisms are not
24:33 - really effective especially if you have
24:35 - thousands of instructions to give to the
24:36 - computer
24:37 - and that resulted in the need for a
24:40 - softer way a softer medium for
24:42 - interacting with a computer and that
24:44 - gave birth to a compiler a compiler
24:48 - converts you have high source code high
24:50 - level source code which is essentially a
24:53 - programming language like Python and
24:56 - that source code is written in such a
24:58 - way that it's human readable and you
25:00 - have a compiler which is just another
25:02 - computer
25:04 - which uses a set of techniques to
25:06 - convert that source code into binary
25:08 - which is also known as a machine code
25:16 - so that's the job of a compiler can
25:18 - converts source code into machine code
25:20 - and in this entire course we'll be
25:22 - learning about a lot of processes that
25:24 - compilers use to convert to machine code
25:27 - namely lexical analysis and um passing
25:30 - and interpretation we won't be building
25:33 - a compiler we'll be building an
25:34 - interpreter so we won't be dealing with
25:36 - converting the instructions into binary
25:40 - outputs rather we'll be using a
25:43 - programming language like python to
25:45 - convert to to interpret data in sequence
25:49 - to input interpret our own programming
25:51 - language sequentially so a compiler
25:54 - converts to machine code but our
25:56 - interpreter won't be doing that it will
25:58 - be using a programming language like
26:00 - python to understand our given input and
26:05 - then process it and perform the
26:07 - necessary action so anyway that's it for
26:10 - this section we've talked about how
26:11 - computers understand
26:13 - instructions how they execute those
26:15 - instructions
26:17 - and the need for compilers to convert
26:19 - high level code to low level code and
26:22 - those low level codes is just binary
26:23 - instructions and now with that
26:25 - information it's time to move ahead to
26:27 - the next section where we will be
26:29 - delving more into the implementation
26:32 - side of this course so I'll see you over
26:35 - there
26:39 - in our interpretation process there are
26:41 - three steps involved the first step is
26:44 - known as lexical analysis
26:50 - and then after that you go ahead and do
26:52 - parsing
26:55 - and the final stage is the
26:57 - interpretation
26:59 - which is done by The Interpreter
27:02 - so three steps and if you encapsulate
27:05 - these three steps into its own box
27:10 - so I have an interpreter over here and
27:12 - that box is called an interpreter
27:16 - and if I input some code which is in our
27:19 - own in our custom programming language
27:21 - and for the purposes of this course this
27:24 - programming language will be called
27:26 - Shadow script which is a fancy name for
27:29 - a not so capable language
27:31 - um because of course we won't be able to
27:33 - achieve
27:34 - tasks that advance programming languages
27:38 - like python or JavaScript can do but
27:40 - nonetheless we'll be talking about the
27:42 - core functionalities like variables like
27:45 - arithmetic operations
27:47 - um uh some if statements while loops and
27:52 - possibly even for Loops so all of that
27:55 - code will be implemented it won't be as
27:57 - powerful as the modern programming
27:59 - languages but still it's a great great
28:01 - opportunity to learn lots of programming
28:03 - Concepts so anyway this interpreter will
28:05 - take high level code and in our in our
28:08 - programming language it will take Shadow
28:10 - script in it
28:12 - so it will ingest Shadow script and spit
28:17 - out
28:18 - um the necessary actions the necessary
28:20 - output like say for instance you're
28:22 - creating variables it will spit out the
28:25 - value of the variable and save the
28:27 - variable if you want to do some
28:29 - arithmetic operations it will it will do
28:31 - the arithmetic for you and spit out the
28:33 - output and so on so they'll just give an
28:35 - output
28:37 - and it may also deal with some of the
28:40 - memory processes like saving new
28:42 - variables deleting variables and all of
28:44 - that so it produces an output which will
28:47 - be visible on the shell
28:50 - uh on on the terminal and it will also
28:53 - be dealing with some memory changes
28:59 - so it's these three steps that um
29:02 - okay I don't know what happened over
29:03 - here let's just fix that
29:13 - so it's these three steps that we have
29:15 - to talk about because this is this is
29:18 - what goes on inside the black spot black
29:20 - box and the first step is lexical
29:22 - analysis so I'm going to create a new
29:24 - page for this one
29:29 - and this is known as lexical analysis
29:32 - the process is pretty straightforward
29:34 - easier than the other steps and it
29:36 - involves just breaking down the input
29:38 - code into specific tokens now the tokens
29:42 - for our purposes can have a value and
29:45 - also a type like for instance the number
29:47 - five has a value of five
29:50 - and So that's its value and a type of
29:53 - integer
29:58 - the plus operator
30:00 - has a value of Plus
30:04 - and it's a type of operator so oh
30:11 - so the lexical analysis just breaks down
30:15 - the tokens breaks down the input into
30:17 - tokens and that's pretty much it that's
30:19 - all it does and in the next stage we'll
30:21 - feed the tokens as an input to the
30:24 - parsing so the input of the lexical
30:27 - analysis is the original code the output
30:30 - produced from lexical analysis will go
30:32 - to the parser and the output of the
30:34 - parser will go to The Interpreter and
30:36 - The Interpreter will give the final
30:38 - output so
30:40 - lexical analysis you give an input and
30:43 - I'm going to call it tokenization
30:45 - because lexical analysis is pretty hard
30:48 - to say
30:49 - and they mean the same thing so yeah so
30:52 - tokenization you give an input which is
30:55 - the shadow script code
30:57 - so tokenization
31:00 - and
31:02 - it will break down the input code into
31:04 - specific tokens
31:06 - and in our case it will store those
31:09 - tokens in in a python list I'll talk
31:12 - about data structures in just a few
31:14 - moments but probably in the next few
31:16 - sections but
31:18 - just know that it will store the tokens
31:20 - in a sequential way in a list so list is
31:23 - just like a traditional list
31:25 - token one
31:28 - token 2 and so on
31:31 - so that's a list and this is the first
31:33 - item of the list this is the second item
31:35 - of the list and that's how a python
31:38 - python list looks like
31:40 - now to give an example let's say the
31:43 - input is the arithmetic operation one
31:45 - plus three
31:46 - so we want to add the numbers one and
31:49 - three so after the tokenization process
31:51 - the output should look something like
31:53 - this
31:54 - it should store the token value
31:58 - of 1 and of type integer
32:02 - then it should store the token okay
32:04 - let's
32:05 - put it below
32:08 - so first we'll store token
32:12 - one
32:14 - and it will be a type integer
32:17 - then it will store a token
32:21 - the plus symbol or add symbol and that's
32:24 - an operator
32:26 - and so on
32:28 - and the third final one is the third
32:30 - token which represents the integer three
32:32 - so that's the output of the lexical
32:34 - analysis stage and now let's go to the
32:37 - next section where we will talk about
32:38 - how we process these tokens this stream
32:42 - of tokens how we process them
32:47 - so the next step is called parsing so
32:50 - from the tokenization process we have
32:52 - received a bunch of tokens stored in a
32:54 - python list and now we have to process
32:58 - that that list and generate a useful
33:00 - output
33:01 - so what is parsing first of all let's
33:03 - understand the definition of parsing and
33:06 - fundamentally parsing is just the
33:07 - recognition of patterns in an input
33:10 - like say for instance we have the input
33:12 - one plus one
33:15 - and in a very simplistic uh interpreter
33:18 - for our programming language
33:20 - we can we can
33:22 - interpret this expression by first
33:24 - tokenizing it so we tokenize this
33:26 - into a bunch of tokens we have the
33:28 - number one and we have the plus symbol
33:31 - and then we have the number one again
33:34 - and now once we have these tokens in the
33:36 - list in the parsing process we look for
33:38 - a pattern in a simplistic way let's say
33:41 - The Interpreter can process only the
33:43 - addition or subtraction of two singular
33:46 - digit numbers like for instance one plus
33:48 - one or three plus four or five plus six
33:51 - or something like that
33:53 - in this case the pattern that the parser
33:55 - has to recognize is that the first
33:58 - number is an integer
34:01 - the first okay wrong
34:04 - the pattern that The Interpreter has to
34:07 - recognize is the first number is an
34:09 - integer or the first token is an integer
34:11 - the second token is an operator and the
34:14 - operator could be plus or minus
34:17 - and the third token is again another
34:19 - integer
34:20 - that's all that the parser has to
34:23 - recognize and the simplistic scenario
34:25 - there's an integer plus or minus another
34:27 - integer and the parser just the remember
34:31 - the lexical analysis of the tokenization
34:33 - process blindly converts the input into
34:36 - a bunch of tokens it does not look at
34:38 - any structure it does not see if the
34:41 - input abides by the programming language
34:43 - rules it doesn't do anything like that
34:45 - all it does is converts the input into a
34:48 - bunch of tokens but in the parser it
34:51 - tries to search for patterns it tries to
34:53 - search for this pattern of integer
34:56 - integer plus integer
34:58 - so that's the general pattern so integer
35:03 - plus or minus and this vertical bar is
35:06 - also known as r
35:08 - so plus or minus another integer
35:11 - so that's the pattern that we're trying
35:13 - to look for in the simplistic scenario
35:15 - of course this is not how our parsing
35:18 - process will be in the in the
35:20 - implementation side we will be able to
35:23 - deal with extremely complicated
35:24 - Expressions as well
35:26 - but this is just to give an example of
35:28 - what parsing really is all it is is
35:31 - trying to find structure and
35:35 - um essentially it goes a step further
35:38 - from the lexical analysis and tries to
35:40 - structurize the input
35:42 - how does it do that and it does this
35:44 - using a bunch of grammar rules now in
35:47 - this simple scenario the only grammar
35:48 - rule grammar rule is that an expression
35:55 - is an integer
35:58 - plus or minus another integer
36:02 - in fact I'll write this in a better way
36:04 - so
36:05 - so it's an integer plus an integer
36:08 - integer minus an integer
36:12 - and the vertical bar here so either this
36:15 - is one possibility or this is the other
36:18 - possibility
36:20 - so in this simple grammar Rule and this
36:24 - is the this layout is known as a grammar
36:27 - rule there are certain formats of
36:28 - writing a grammar Rule and I'll come to
36:30 - that in just a second but this grammar
36:32 - rule essentially defines the structure
36:36 - of a programming language
36:39 - the parser
36:40 - checks for certain patterns check for
36:42 - such checks for such structures and C's
36:45 - if the input matches for them if it does
36:48 - not match them then there's probably an
36:50 - error in the input core and an error
36:53 - must be raised
36:54 - so let's talk about let's now talk about
36:56 - the types of grammar rules that exist
37:00 - so the ways in which you can write
37:02 - grammar rules the the one I'm going to
37:05 - use is called P and F and that's
37:07 - extremely hard to pronounce but it's
37:10 - called Backus nor form I believe and I
37:13 - probably misspelled mispronounce that
37:15 - but anyway B and F is a way of writing
37:19 - your grammar rules and let's just go
37:21 - through a bunch of examples now
37:23 - in basic math we have let's say an
37:26 - expression an expression just contains a
37:28 - bunch of terms and a term is just a
37:31 - bunch of integers multiplied together
37:34 - so what does that mean so let me let me
37:36 - go through this again I'm going to say
37:38 - an expression
37:40 - is equal to an in Bacchus now form you
37:43 - actually have two colons over here
37:46 - like that but I'm just going to write it
37:48 - as one colon because it looks much more
37:50 - prettier
37:51 - so like that expression is equal to
37:55 - a term
38:00 - plus another expression
38:04 - or it's equal to a term
38:08 - minus another expression
38:12 - or it's equal to just a term
38:16 - now this may seem a bit confusing
38:18 - because we're calling the expression
38:20 - inside the expression but what this
38:23 - tries to do is just ensure that there is
38:26 - a form of continuity in our expression
38:29 - what does that mean so let's say we have
38:30 - the expression 5 plus 3 plus 2. now
38:33 - that's an expression It's a combination
38:35 - of terms and a term can be an integer or
38:38 - it can also be two integers multiplied
38:40 - or divided but I'll come to that in just
38:42 - a second for now let's just assume a
38:44 - term is an integer
38:45 - so an expression just contains a bunch
38:49 - of integers added or subtracted together
38:51 - now this is where my recursion comes
38:55 - into play and I'll talk about recursion
38:57 - in probably the probably the next few
38:59 - sections but essentially recursion is a
39:02 - way is a type of programming where
39:04 - you're calling the function a certain
39:07 - functionality within the functionality
39:09 - so as you can see over here we call the
39:12 - expression inside the expression itself
39:15 - so what this aim what this tries to do
39:18 - is that it tries to ensure continuity so
39:20 - over here
39:21 - the term let's say the first term is 5
39:24 - plus another expression our expression
39:27 - can be equal to a term plus another
39:28 - expression so we can say 3 so the three
39:31 - is a term so we can have three
39:34 - plus now expression can be a term as
39:37 - well so 2 is a term so all we're trying
39:40 - to do is we're trying to ensure
39:42 - continuity so that we can enable
39:43 - multiple editions over here so even if
39:46 - there are thousand integers added
39:48 - together we can ensure that all of them
39:50 - uh
39:52 - uh conform to the grammar rule because
39:54 - this is a pretty sound and pretty uh
39:58 - grammatically correct expression five
39:59 - plus three plus two going on for n
40:01 - number of
40:03 - um terms if you still don't understand
40:06 - what I mean I'm gonna use a much more
40:08 - easier comprehensible format
40:10 - so another way to define an expression
40:13 - would be to say okay its expression is a
40:15 - term
40:17 - multiplied or divided
40:21 - so you see we use the bar in fact I'm
40:23 - just going to use the symbols
40:25 - so it's a term multiplied or divided
40:31 - by another term
40:36 - like that
40:37 - now what does this mean this means that
40:39 - an expression can be equal to just one
40:41 - term
40:42 - or it can be equal to a term multiplied
40:44 - or divided by another term actually that
40:47 - should be plus or minus that's my band
40:49 - plus or minus
40:52 - so an expression can be a term by itself
40:55 - but this part over here
40:57 - where we are enclosing uh
41:01 - let me just get that right these two
41:02 - enclosures over here
41:04 - followed by an asterisk represents zero
41:07 - or more times that means
41:10 - now let's clean up that yeah that means
41:12 - this
41:14 - uh the contents within that curly brace
41:18 - can be repeated zero or more times the
41:21 - final that means a term can be a term
41:23 - plus another term minus another term
41:25 - plus another term whatever zero zero or
41:28 - more times then that is effectively what
41:30 - the Backus now form is saying it's
41:32 - calling the expression within itself
41:35 - to tell you that okay an expression can
41:38 - contain n number of Expressions so we're
41:41 - using a form of recursion to to tell the
41:44 - users or to tell the programmers that an
41:47 - expression can have n number of integers
41:49 - n number of terms added a subtracted
41:53 - multiple times now let's define the term
41:57 - so a term as I said
42:02 - it can be equal
42:04 - to just another term or it could be
42:06 - equal to a term
42:09 - it could be it could be equal to a
42:11 - factor
42:13 - now a factor is just an integer for our
42:15 - purposes
42:16 - so a term could be equal to a factor
42:19 - multiplied by another factor or
42:22 - multiplied by another term and you see
42:25 - I'm doing the same thing over here
42:26 - recursion and just to symbolize the same
42:28 - thing as I said the multiplication that
42:31 - means the term can be equal to a factor
42:33 - multiplied by another Factor multiplied
42:35 - by another Factor n number of times zero
42:37 - or more times
42:39 - so a term could just as well be equal to
42:41 - one factor it could be equal to two
42:43 - factors multiplied together three
42:45 - factors multiplied together and so on so
42:47 - that's what I'm trying to signify by
42:49 - calling the term within the term itself
42:52 - so by calling term over here
42:55 - I'll just get the out of her drone for
42:56 - some reason so by calling the term
42:58 - within the term grammar rule I'm trying
43:01 - to Showcase that you can have multiple
43:04 - factors multiplied or divided together
43:07 - so
43:08 - as I said a factor can be multiplied by
43:10 - another term or it could be a factor
43:14 - divided by another term
43:18 - or it could be just equal to a factor
43:22 - now what is the factor for now although
43:25 - in the later part of this course I'll
43:27 - bring in another aspect to this factor
43:31 - definition but for now a factor is just
43:33 - equal to an integer so it could be yeah
43:37 - let's just do integer
43:39 - like that an integer is just a series of
43:42 - digits but I'm not going to go ahead and
43:44 - Define that because I'm pretty sure all
43:46 - of you know what an integer means now
43:49 - in the set of grammar rules we have some
43:53 - terminology as well so the integer
43:57 - although it technically isn't and okay
44:00 - let's just go ahead and do it so I'm
44:01 - going to say an integer
44:04 - is for now let's just say the integer is
44:06 - singular digit so I'm going to say in
44:08 - integer is just a digit
44:11 - 0 0
44:13 - or 1 or 2 or 3 or 4.
44:21 - right so an integer is just a singular
44:23 - digit and I'm defining that in this way
44:26 - just to keep things simple as you all
44:28 - know a digit an integer can be a series
44:31 - of digits like three four five is an
44:33 - integer or one two three is an integer
44:35 - and so on
44:37 - so
44:38 - in this notation in this in these
44:40 - grammar rules
44:42 - what is inside the angular brackets is
44:44 - called a terminal is called a
44:46 - non-terminal
44:49 - and that essentially means that a
44:50 - non-terminal can be defined by by using
44:54 - a terminal so a terminal in this case is
44:56 - something like an integer which we can
44:58 - concretely Define like a digit uh
45:02 - another terminal in our programming
45:03 - language could be the operator like plus
45:06 - or minus is another terminal these can
45:09 - be concretely defined they are the base
45:11 - tokens of our
45:13 - um of our language
45:15 - so with that knowledge of Bacchus in our
45:17 - form how does all of this relate to
45:20 - parsing so as I said backers now form is
45:22 - a way of defining rules once we have
45:24 - defined rules things actually get pretty
45:26 - simple it seems that you're still far
45:28 - away from having a workable interpreter
45:31 - which can convert your custom program
45:33 - and programming language and execute it
45:37 - it seems that we're far away from that
45:39 - goal but now that we've defined our
45:41 - grammar rules things get a lot more
45:42 - easier so now I'm going to take an
45:45 - example to Showcase how parsing is
45:47 - actually done now that we have the
45:49 - background knowledge of BNF and also
45:53 - about how parsing introduces structure
45:57 - so in passing let's say we're trying to
45:59 - pass the input 1 plus
46:03 - um let's say one
46:05 - now the expression using our previous
46:07 - notation we said that the expression
46:10 - is equal to terms added on added or
46:14 - subtracted from each other now a term
46:16 - can be equal to a factor
46:18 - a factor being just an integer so in
46:22 - this case the expression
46:25 - expression is equal to
46:28 - um one which is a term plus another term
46:30 - one plus one and that satisfies our
46:33 - grammar rule
46:35 - but even if we have something
46:36 - complicated
46:38 - let's say
46:40 - three
46:42 - plus five times two
46:44 - the grammar rule says that an expression
46:46 - is a term plus another expression
46:49 - so essentially saying that again I'm
46:52 - repeating myself but an expression is
46:54 - just a term added or subtracted from
46:57 - another expression
46:58 - n number of times
47:00 - zero or more times so
47:04 - the expression over here is equal to 3 3
47:07 - is a valid
47:08 - um term
47:09 - which is equal to a factor in this case
47:12 - and even 5 times 2 is a valid term
47:16 - because remember we said the term can be
47:18 - equal to a factor multiplied by another
47:21 - Factor what zero or more times so this
47:23 - is equal to a factor multiplied by
47:25 - another Factor
47:27 - so even this input is possible using our
47:29 - given grammar rules
47:31 - what do I mean by possible that means
47:33 - that it conforms to our grammar rules
47:35 - and such an input can be processed in
47:38 - the parsing stage
47:40 - now I'm going to use a data structure
47:43 - known as a binary tree which I'll talk
47:45 - about more extensively in the next few
47:47 - sections
47:48 - but I'm gonna introduce the binary tree
47:51 - to talk about parsing
47:53 - now parsing essentially involves uh
47:56 - again bringing structure into your code
47:59 - so let's say we have the expression one
48:02 - plus two times five
48:04 - I'm going to construct a tree for this
48:07 - given input
48:09 - and the tree
48:12 - is
48:13 - the following
48:19 - so this tree over here we are adding the
48:23 - integer one
48:24 - and we're adding the product of 2 and 5
48:27 - and this is the past Tree in fact the
48:31 - goal of the passing process is to
48:33 - generate a tree like this of course we
48:35 - won't be drawing a tree like this in
48:37 - Python but we will be representing such
48:39 - a tree in a list
48:41 - so how do we represent this tree
48:43 - specifically
48:45 - I'm going to write it over here so I'm
48:46 - going to say one
48:49 - Plus
48:51 - two times five
48:56 - like so
48:57 - so in this scenario plus is the operator
49:01 - one is the left node in fact this is
49:04 - known as the root node I'll talk about
49:06 - this terminology
49:08 - in just few sections
49:10 - but this is the left node
49:15 - and this is the right node
49:19 - so over here one is our left node plus
49:22 - is our root node and right node is 2
49:25 - times 5. so we have effectively
49:27 - represented this tree
49:30 - using this list in Python
49:36 - in this section of the course I'll be
49:38 - talking about object oriented
49:39 - programming and its four main pillars
49:42 - that make it according to me at least
49:44 - more Superior than the other paradigms
49:46 - or the other ways of programming so
49:49 - the first way is functionally functional
49:53 - based programming which uses po
49:56 - functions and functions is just a method
49:58 - like similar to how mathematical
50:00 - function works you have an input you
50:02 - give out an output that's basically it
50:04 - there's some inner workings to a
50:07 - function
50:08 - um it's like a black box you have an
50:10 - input you have an output but you don't
50:12 - see what's inside so that's how
50:14 - functions work and just to give an
50:16 - example let's say we're trying to
50:18 - calculate the amount of fuel that you
50:20 - have left in your car
50:22 - so we create a function called remaining
50:26 - underscore field
50:27 - and this takes in the initial field that
50:29 - you had the kilometers that you drove
50:32 - and also the ratio which is like the
50:35 - gallons per kilometer or whatever unit
50:37 - you're using liters per kilometer
50:41 - um the ratio of that and the remaining
50:43 - fuel would just then be equal to initial
50:45 - minus
50:47 - kilometers
50:48 - times the ratio
50:50 - so in functional programming or
50:53 - functional based programming you
50:55 - separate the data from the actual
50:58 - functionality you see that we have not
50:59 - accepted any data like the initial fuel
51:02 - that he had the kilometers that he had
51:04 - or the ratio we didn't accept any data
51:06 - this is just a standalone function a
51:08 - standalone functionality which can uh
51:11 - basically work fine I mean even if I run
51:13 - this right now there'll be no problems
51:15 - so
51:16 - uh it can work on its own as well so the
51:21 - actual
51:22 - um usability of it comes when we add
51:24 - some data and the essence of functional
51:26 - based programming is that you separate
51:28 - the data from the functionalities now
51:30 - over here I can give in some data let's
51:32 - say uh let's say I say the initial fuel
51:36 - is equal to 50 units the kilometers this
51:40 - person drove is
51:43 - um let's say 10 units or okay 10
51:45 - kilometers and the ratio let's say is 5
51:49 - units per kilometer five units of fuel
51:51 - burnt per kilometer drove so then I can
51:54 - calculate the remaining fuel I can print
51:55 - it as well remaining Fuel and I can give
51:58 - the parameters initial kilometers
52:01 - and ratio and this works fine so if I
52:04 - run again
52:05 - this time you see we have okay we have 0
52:08 - exactly zero let's reduce the ratio here
52:10 - a bit and let's run that again you see
52:12 - we have 30 units of fuel still left so
52:16 - this is a pretty basic example of
52:18 - functions and it seems fine in this
52:21 - level but let's assume that you have a
52:24 - lot of complexity in your application
52:25 - let's say you're building a website and
52:28 - you have the authentication aspect of it
52:30 - you have the payment aspect of it you
52:32 - have the content management aspect of it
52:35 - so many entities uh involved now how do
52:39 - you
52:41 - because if you have so many entities
52:43 - involved you'll have several functions
52:46 - you'll have authentication functions
52:48 - you'll have um payment functions and all
52:50 - of them clubbed in this messy file uh
52:54 - where it just becomes difficult to
52:56 - handle things and that's where object
52:58 - oriented programming comes in object
53:00 - oriented programming divides
53:03 - it divides
53:06 - um code into entities called objects so
53:09 - you can have one object of payments you
53:10 - can have one object of uh of
53:13 - authentication one object of content
53:15 - management one object of uh maybe like
53:18 - contact or server where you have chat
53:21 - functionality or something like that I
53:23 - don't know so
53:25 - and in object oriented programming you
53:27 - divide an application into objects these
53:30 - entities which have their own
53:33 - um data and their own functionality now
53:37 - let's try to understand how
53:39 - object-oriented programming works on the
53:41 - canvas
53:42 - so as I said just as a recap let's just
53:46 - recap what I said uh in operator into
53:48 - programming also called oop you divide
53:51 - things into their own entities called
53:53 - objects so you can have maybe an object
53:55 - for payments
53:56 - so it has its own data it has its own
53:59 - functionality
54:03 - but it's all enclosed in this own entity
54:07 - known as payment entity
54:10 - we can have another entity for let's say
54:12 - authentication which has its own set of
54:14 - data its own set of functions completely
54:17 - different from the payment
54:21 - and you have authentication over here
54:23 - and you can go on and on but you get the
54:25 - point your
54:27 - um encapsulating data and functionality
54:30 - into objects which are the basic unit of
54:33 - object oriented programming and these
54:35 - objectives represent entities like
54:37 - payments and Authentication
54:39 - now in object oriented programming and
54:42 - inside an object the data is referred to
54:44 - as properties
54:48 - and the functions are referred to as
54:50 - methods
54:54 - so now that we've understood the basic
54:56 - gist of object oriented programming
54:58 - let's try and understand what are the
55:00 - four main pillars that hold it and make
55:02 - it such a solid way of writing your code
55:09 - so the first main pillar of object
55:11 - oriented programming is known as
55:12 - encapsulation and it's the basic idea we
55:14 - talked about in the previous section
55:17 - encapsulation refers to
55:20 - basically just start encapsulating uh
55:24 - Properties or encapsulating data and
55:27 - functionality into their own entities so
55:30 - that we can better handle them and it
55:33 - just enables us to write more cleaner
55:35 - code so as an example of our own
55:38 - situation over here we have multiple
55:40 - entities we have the lexor we have the
55:42 - parser we have The Interpreter so it
55:44 - seems wise to use object oriented
55:46 - programming because it can encapsulate
55:48 - each of these entities and have allow
55:51 - designate them their own properties
55:53 - their own methods their own data their
55:55 - own functionality so we can have Alexa
55:59 - which has its own data its own functions
56:03 - or methods there's alcohol functions for
56:06 - now because yeah so the data is known as
56:09 - properties and functions and
56:10 - object-oriented programming is called
56:11 - method
56:13 - are called Methods so this is one object
56:15 - you can have another object you can have
56:18 - a parser
56:19 - which has its own data its own functions
56:23 - and you get the idea we can have a
56:25 - similar class for The Interpreter
56:28 - this is called encapsulation by your
56:30 - grouping things grouping data and
56:32 - grouping functionality
56:37 - the second pillar is known as
56:39 - abstraction
56:44 - an abstraction just refers to
56:46 - simplifying the inner functionality the
56:50 - inner yeah basically just that the inner
56:52 - functionality into its own entity like
56:54 - for instance in our situation over here
56:56 - all we need to do an object oriented
56:58 - programming is create a Lexa
57:01 - which is of the object Lexa and let's
57:05 - say we tell it to let's say we tell it
57:08 - tokenize stuff
57:09 - uh using the methods
57:13 - so
57:15 - this is some notation which I'll go over
57:17 - in just the next section but all this is
57:18 - doing is creating an object called Lexa
57:21 - and it's tokenizing the inputs uh the
57:25 - input expression so as you can see this
57:28 - is a much this is a very clean way of
57:30 - writing code because essentially you're
57:32 - just abstracting away the inner
57:34 - complexities uh and the inner
57:36 - functionality of the Alexa all you're
57:38 - doing is calling the tokenize method and
57:41 - you have your tokens ready all you're
57:43 - doing is create calling the lexor object
57:46 - and you have your own lecture so that is
57:48 - known as abstraction it allows for core
57:50 - reusability the loss for modularity and
57:53 - essentially if you have different
57:54 - developers working on different tasks
57:56 - and they really don't know how the other
57:58 - developers developer is coding his his
58:02 - stuff so they can use object oriented
58:05 - programming to communicate they can say
58:06 - okay this is one component this this
58:09 - component will give a certain output you
58:11 - don't need to know how it works inside
58:13 - it's a black box you don't to know how
58:15 - it works on the inside but all you need
58:17 - to know is for a given input you're
58:19 - getting this output so that's what
58:20 - abstraction is abstracting away the
58:23 - complexities making code looks simple
58:25 - and let's move on now to the third
58:28 - pillar
58:33 - the third pillar of object-oriented
58:35 - programming is known as inheritance
58:43 - inheritance is a concept that is best
58:45 - explained by an example so let's say we
58:48 - are creating a website and each website
58:51 - has different components it has the home
58:53 - page the about page and the home page
58:56 - has different contents in it the about
58:58 - page is different contents in it but if
59:01 - you're designing a website you typically
59:02 - would have the same layout for each page
59:05 - you'd have the heading you'd have the
59:07 - body in pretty much similar positions
59:10 - so inheritance in object-oriented
59:12 - programming allows you to inherit
59:14 - certain common properties within object
59:17 - so what do I mean by this let's say we
59:19 - have our an object called page it has
59:22 - properties like heading
59:26 - body and the images may be
59:30 - so this is the base class this is
59:34 - um this is what you are inheriting from
59:37 - whereas you have maybe another class
59:40 - like another class like the home class
59:42 - which is the home page or the about
59:43 - class which is the about page
59:45 - and um these classes will inherit
59:49 - inherit all of these
59:52 - properties The Heading all of these will
59:54 - be inherited
59:58 - by the Home Home object and um
60:03 - yeah so again the home object would
60:05 - inherit the properties and the functions
60:08 - of the page object while having its own
60:10 - custom functionality which will which it
60:12 - will add over the page object so that's
60:15 - basically what inheritance is you have a
60:18 - fundamental object and other specific
60:23 - implementations of it like the home page
60:25 - the about Pitch inheriting from that
60:27 - fundamental object
60:29 - this is a theoretical discussion here I
60:31 - hope you understand what inheritance
60:33 - mean means in a more theoretical sense
60:35 - in this course I'll be doing
60:37 - object-oriented programming in Python so
60:40 - um I'll be talking about how you
60:42 - implement inheritance and all of that as
60:44 - well
60:44 - and with that knowledge let's move on to
60:46 - the final and fourth pillar which is
60:49 - known as polymorphism
60:53 - so the fourth main pillar in object
60:55 - oriented programming is known as
60:57 - polymorphism
61:00 - and polymorphism is essentially the idea
61:03 - that so polymorphism is essentially the
61:07 - idea that you can treat object of
61:09 - different types so objects of different
61:11 - types as if they were the same type
61:14 - so that may sound a bit confusing but
61:16 - I'll explain it using an example
61:18 - so let's say we have three types of
61:20 - animals we have dogs we have cats and we
61:24 - have Birds
61:27 - now the common thing about all of these
61:29 - animals is that they can make a sound so
61:32 - how can we program a way in which we can
61:36 - how can we program the sounds of these
61:38 - animals so maybe for the dog we do make
61:41 - dog sound
61:53 - so this is what you would typically do
61:55 - but now in polymorphism the idea of
61:58 - polymorphism is that you can make a
61:59 - common interface now in this instance
62:01 - the common interface would be an animal
62:03 - all of three all of these three entities
62:05 - are a type of animal so the common
62:08 - interface over here I can Define it to
62:10 - be an animal
62:12 - polymorphism allows you to do is let's
62:15 - say we create a method in animal called
62:17 - make sound
62:19 - and now using this common interface you
62:23 - can add some custom functionality to
62:26 - this make sound method so maybe the dog
62:28 - does a woof upon the make sound method
62:31 - the cat does a meow on the make sound
62:32 - method and the bird does a chirp on the
62:34 - mix on method whatever but polymorphism
62:36 - allows you to call
62:39 - the same functionality of the dog and
62:41 - the cat and the bird using the same
62:43 - method but each of these entities dog
62:46 - cat embed do it in their own customized
62:48 - way and that's the idea of polymorphism
62:51 - which means many forms it's the idea
62:53 - that you can allow objects of different
62:55 - types to be treated as if they were the
62:58 - same type based on a common interface
63:00 - and the common interface being the
63:02 - animal so
63:04 - that's the idea of polymorphism and with
63:07 - that let's move on to the next section
63:12 - in this section of the course we will be
63:14 - talking about the python implementation
63:15 - of object oriented programming now we've
63:19 - talked about uh the theoretical aspects
63:21 - of object-oriented programming in the
63:23 - previous sections where we talked about
63:25 - objects how objects Define certain
63:28 - entity and we group a set of
63:30 - functionality a set of properties into
63:32 - each object and we separate them using
63:36 - object oriented programming so how do
63:39 - you define an object how do you define
63:41 - one entity like as I said previously we
63:43 - can have a payment entity we can have an
63:46 - authentication entity we can have a
63:48 - let's say contact page always to a chat
63:51 - entity in in the example of creating a
63:54 - website so let's see we're creating a
63:55 - website all three of these are their own
63:58 - entities so how do we create these
64:00 - entities in Python how do we create
64:02 - these objects in Python
64:04 - Now to create an object we must use the
64:07 - pro the at the keyword called class
64:11 - a class essentially defines a blueprint
64:13 - for each object so as you might know the
64:17 - payment will have different set of
64:18 - functions authentication will have
64:20 - different set of functions the payment
64:22 - will have different set of input
64:23 - parameters it might have the user it
64:25 - might have the amount of payment the
64:28 - recipient the donator
64:31 - the authentication will have different
64:32 - parameters it will have maybe
64:35 - um the username the password the ID or
64:39 - the email address the chat will have
64:41 - different input parameters so because we
64:44 - have different input parameters
64:45 - different functionality for each entity
64:47 - we must Define a blueprint for each
64:50 - entity so let's say we create a class
64:52 - for payment
64:54 - now as I said we each each entity will
64:57 - have different set of input parameters
64:59 - like payment will have the input
65:01 - parameter payment recipient amount and
65:04 - all of that and it will have a different
65:05 - set of functionality maybe to process
65:07 - the payment authentication will have a
65:09 - different set of functionality maybe to
65:10 - check if the password is correct or
65:12 - something like that so we can Define we
65:16 - can take in the input parameters for
65:18 - each class using the init method
65:21 - it's a special method and this init
65:23 - method Works in a way that you can take
65:26 - in the self parameter here now I'll talk
65:28 - about self in just a second in fact let
65:31 - me just leave this as pass over here and
65:33 - I'll create an instance of this payment
65:35 - method this payment class so I'll create
65:37 - an object over here I can say payment
65:40 - one
65:41 - is equal to payment
65:43 - and this is where payment one is an
65:47 - object it is an instance of the class so
65:50 - it takes in the blueprint defined by the
65:52 - payment class and it it's an instance of
65:55 - that so this is an object over here
65:57 - payment one
65:59 - is an object
66:02 - it is an instance
66:04 - of the payment class
66:07 - so all of those blue all of the the
66:09 - blueprint defined in the payment class
66:11 - the attributes the functionality the
66:14 - data all of that defined in the payment
66:15 - class all of that comes into play in
66:18 - payment one which is an object which is
66:20 - an instance of the payment class
66:22 - how do you accept parameters like for
66:25 - instance let's say I want to pass in the
66:26 - parameter recipient
66:28 - the uh amount
66:31 - and let's stick to two parameters for
66:33 - now how do you accept these two
66:35 - parameters in the payment class
66:38 - so we use the init method for that
66:41 - and this takes in by default a parameter
66:44 - called self now self is the same as
66:47 - payment one so as you might know that
66:50 - there are you can have different
66:51 - instances of the same class I can have
66:53 - payment one for maybe one transaction I
66:55 - can have payment two for another
66:56 - transaction
66:58 - so let's say another transaction will
67:00 - have will be called payment 2 and this
67:02 - two will have a recipient these two will
67:04 - have an amount
67:05 - so
67:06 - um payment 2 is also an object of the
67:08 - payment class now how do you keep track
67:11 - of each object over here we use the self
67:13 - keyword for that so self refers to the
67:16 - instance itself now I can add to that
67:19 - instance I can say okay now self dot
67:21 - recipient
67:24 - equals whatever input parameter given
67:27 - over here so here we have given a
67:29 - recipient over here let's say the
67:30 - recipient is um
67:33 - I don't know person a and amount let's
67:35 - say it's 25 units and over here the
67:38 - recipient is person B
67:40 - and the amount is
67:42 - 50 units so self dot recipient is equal
67:46 - to recipient
67:48 - and what I am doing by this I'm saying
67:50 - what I'm doing by this is that I'm
67:52 - saying that uh the payment one object
67:55 - you add to that payment one object which
67:58 - is self you add to that payment one
68:00 - object you add a property called
68:02 - recipient and make that equal to the
68:05 - recipient input which is given over here
68:07 - and to understand what that means I'm
68:10 - going to print payment one
68:12 - dot recipient
68:14 - and if I run this over here
68:17 - um okay so we also need to take in the
68:20 - amount
68:22 - and I'm going to surf dot amount
68:25 - equals amount
68:28 - so over here we can see that the
68:30 - recipient is person a so payment one dot
68:34 - recipient defines uh the recipient for
68:37 - this instance
68:39 - I can do payment 2. recipient
68:43 - and this will print out B
68:47 - as you can see over here
68:49 - so just to summarize a class defines a
68:52 - blueprint a set of methods a set of data
68:55 - that can be that pertains to one entity
68:58 - objects are instances of a class you can
69:01 - have multiple instances of one class and
69:04 - you can accept parameters input
69:06 - parameters from each object by using the
69:08 - init method which is by default called
69:11 - when you create an object over here when
69:13 - I'm creating payment this init method is
69:15 - called
69:16 - so you can use the init method to accept
69:20 - input parameters like recipient and
69:22 - amount and we say okay now add to the
69:25 - current object a property called
69:27 - recipient and make that equal to
69:29 - whatever value is inputted over here
69:32 - this is one input this is another input
69:34 - whatever input parameters provided add
69:37 - that to the self dot recipient which is
69:39 - itself add that to that instance itself
69:42 - so now when we Define other functions
69:45 - like maybe let's say
69:46 - um
69:47 - check balance
69:50 - by default I have access to self by
69:52 - default I have access to the instance
69:54 - itself so now I can have I can say okay
69:58 - now self uh is the instance itself and
70:01 - in the init method we added properties
70:02 - like recipient and amount to the
70:04 - instance itself so now in the check
70:07 - balance method I have access to those
70:09 - parameters I have access to those
70:10 - variables so I can Sprint self Dot
70:15 - okay let's say we have an initial amount
70:22 - and after the transaction I'm gonna
70:24 - return self dot initial minus the amount
70:28 - of transaction
70:30 - so over here let's do uh let's print
70:33 - payment one dot check balance
70:38 - and this is initial not self dot initial
70:41 - so initial minus self dot amount and
70:45 - let's say initially he had 500 units of
70:47 - uh cash and now if I pre if I save and
70:51 - run again you see we have 475 left
70:54 - so we've called the check balance method
70:57 - we provided an initial amount and we
70:59 - subtracted the self dot amount which is
71:02 - uh which we remember we added in the
71:04 - init method so hopefully that makes
71:06 - sense if this is the first time your
71:08 - learning object oriented programming
71:10 - this may sound a bit complicated but I
71:13 - if you still don't understand it I
71:15 - encourage you to revisit this section
71:17 - again and hopefully you get in the
71:19 - second time so after you have understood
71:22 - what instance variables are effectively
71:24 - variables that pertain to one instance
71:26 - like uh the recipient the amount we'll
71:28 - move on to class variables and class
71:30 - variables generally are for the entire
71:33 - class for all of the instances these are
71:35 - stuff like constants maybe you have a
71:38 - constant like the dollar to pound ratio
71:41 - that's one constant and that will be
71:43 - same for all payments that will be same
71:45 - for all payment instances so those are
71:47 - class variables that are same generally
71:49 - same for all of the instances so let's
71:52 - learn about class variables in the next
71:54 - section
71:57 - so in the previous section we talked
72:00 - about instant variable instance
72:01 - variables and how we can create
72:03 - variables pertaining to each instance of
72:06 - the original class so over here we set
72:09 - the recipient and we set the amount of
72:12 - the transaction for uh each payment and
72:16 - in that way we created instance
72:18 - variables because they are pertaining to
72:20 - each object they were not the same for
72:23 - all of the instances like for instance
72:24 - if you make one transaction you will
72:26 - have a different amount compared to if
72:28 - you made another transaction so that's
72:30 - why we created instance variables that
72:32 - were that were unique to each
72:34 - transaction to each object but certain
72:37 - on certain occasions you need to have
72:39 - class variables wherein there you have
72:42 - the constant value for all of the
72:44 - instances and that's the main purpose of
72:46 - introducing class variables now in this
72:48 - example let's assume that this class
72:51 - payment acts like a ledger for an
72:54 - individual who is making payments on the
72:57 - internet so let's say he he's making a
72:59 - bunch of payments on the internet and
73:02 - um whenever we he makes a new payment an
73:05 - object is created so payment one
73:07 - corresponds to one transaction payment 2
73:09 - corresponds to another transaction so
73:12 - whenever he creates whenever he does a
73:14 - new transaction a new object is created
73:16 - and this check balance uh method is run
73:19 - to check how much balance is remaining
73:22 - after each transaction
73:24 - in this situation we don't need to
73:26 - call the initial amount for every single
73:29 - object because the initial amount would
73:31 - be the same for no matter how many
73:33 - transactions he does the initial amount
73:36 - that he started with would be same so in
73:38 - this scenario we need to use a class
73:40 - variable to represent this value of
73:42 - initial initial being the amount of
73:45 - money he had before doing any
73:46 - transactions so to do that I can create
73:49 - a variable over here let's say initial
73:52 - balance
73:53 - and let's set that to 1000
73:57 - and now how do we access this class
73:59 - variable inside this check balance
74:01 - method so first of all we don't need to
74:04 - accept a variable a parameter over here
74:06 - so we can remove that
74:08 - and instead of writing initial
74:09 - underscore balance because even if we do
74:11 - initial underscore balance you'll see
74:14 - that we're getting this green
74:15 - highlighted uh the clo highlighted
74:18 - problem over here saying that initial
74:20 - balance is not defined even though we've
74:21 - defined it over here and that's because
74:23 - to access a class variable we need to
74:25 - write the name of the class before the
74:28 - name of the variable so over here I can
74:30 - say payment
74:31 - dot initial balance and in this way if I
74:35 - remove these the second payment and just
74:38 - run this command
74:39 - you see we get that the the remaining
74:42 - balance is 975 units so that's the basic
74:46 - gist of class variables and with that
74:49 - knowledge let's move on to the next
74:51 - section
74:55 - in this section of the course we will be
74:56 - talking about class methods and static
74:59 - methods so traditionally in these
75:02 - classes you saw that each method
75:04 - accepted the instance itself like in
75:07 - this situation here when we created
75:08 - payment one which represents a
75:10 - transaction so in fact I'll just call it
75:12 - transaction one
75:15 - so and some trade that as well
75:22 - I'll remove that for now okay so um
75:26 - uh in this example we created an object
75:28 - called transaction one which represents
75:30 - a transaction and it is an instance of
75:33 - the payment class so it's an object
75:35 - which is an instance of the payment
75:36 - class and each method in this class
75:40 - accepted the instance itself
75:43 - the transaction one itself it's as if
75:45 - the first parameter of each of these
75:48 - methods is the instance itself and we do
75:51 - that because in the init method we can
75:53 - uh assign a bunch of properties to that
75:56 - instance given these input parameters
75:59 - over here like recipient and amount and
76:02 - then we can access those parameters uh
76:05 - pertaining to one instance in the other
76:07 - methods as well
76:09 - but sometimes you don't need to you
76:11 - don't want the self to be returned you
76:13 - don't want to have access to the
76:15 - instance which is transaction one but
76:17 - rather you want access to the class
76:19 - itself like say for instance we want to
76:22 - update this initial balance now one good
76:25 - way we can do that is we can create a
76:28 - class method which will take in the
76:29 - class as an input and then we can update
76:32 - the class variable over here so for that
76:36 - we can use a class method and how do you
76:38 - create that easy use a python decorator
76:40 - now we don't really need to know much
76:43 - about python decorators except that they
76:46 - modify the functionality of our class
76:48 - method so I'll use the class method
76:50 - decorator and now whatever method I
76:53 - Define over here which will be update
76:55 - initial balance
76:58 - this method will be modified so that
77:01 - instead of accepting self it accepts the
77:04 - class itself and we don't use the
77:07 - parameter name as class but rather CLS
77:09 - because that is already reserved for
77:11 - creating a new class
77:13 - so update initial balance and let's take
77:16 - an input as the New Balance let's say
77:20 - over here
77:21 - what I can do is I can say class dot
77:24 - initial balance and that's the same as
77:27 - doing something like this over here
77:29 - after the class in line 16
77:33 - updating the initial balance to New
77:35 - Balance
77:36 - is the same as doing the following
77:41 - payment dot initial balance equals and
77:43 - if the new balance is 50 like so
77:46 - so it's effectively the same thing but
77:48 - we're now creating a class method and
77:50 - including the functionality inside the
77:52 - class itself so now if I do transaction
77:55 - one
77:57 - or let's do
77:59 - um
78:00 - payment
78:02 - dot update initial balance and I set the
78:06 - New Balance let's say 800
78:08 - and then if I print
78:11 - transaction one dot initial balance
78:17 - and in fact we can even print it yeah
78:19 - this works fine
78:21 - so if I run this now
78:23 - you see we get 800
78:25 - so since we modified the payment classes
78:28 - initial balance all of the instances
78:30 - initial balance also gets modified and
78:33 - that's why transaction one's initial
78:35 - balance is still 800.
78:37 - uh if we create another transaction it
78:39 - will also have 800 because it's an
78:40 - instance of the original class
78:42 - and since we've changed the class
78:44 - variable itself even the instance
78:46 - variables uh feel the same change so I
78:49 - can even do payment print payment dot
78:52 - initial balance and we'll get the same
78:54 - response
78:57 - if I run this you see we get 800 again
79:01 - so that's a class method now sometimes
79:03 - you you need to use static methods and
79:06 - static methods are basically methods
79:08 - that do not accept any
79:11 - um
79:12 - input parameter by default so in these
79:15 - in a traditional method in a in a class
79:18 - we by default accepted the instance in a
79:21 - class method we by default except the
79:23 - class but in the static method we by
79:26 - default except nothing so that's
79:27 - effectively a simple function but we
79:31 - want to function inside a class because
79:32 - it is closely related to the class
79:37 - so maybe one type of static method we
79:40 - can add is checking if the transaction
79:43 - can be held because checking if the
79:46 - transaction is between the working hours
79:48 - so maybe that's between 8 AM to 5 PM so
79:54 - if a transaction is not within those
79:56 - bounds then we'll have to return false
79:58 - else we can return true so for that I'm
80:01 - going to create a static method and the
80:03 - exact same way we do at static method
80:06 - and then over here we can say check
80:08 - valid transaction
80:12 - and this will take in Nothing by default
80:14 - but I want to take in two parameters the
80:17 - hour and let's say the 24 hour system so
80:20 - I'm going to say if our
80:22 - is um
80:23 - greater than 8 greater than equal to 8
80:27 - and our is less than equal to
80:31 - um 5 PM which is 17.
80:34 - I'm gonna say return true
80:37 - else let's return false
80:40 - [Music]
80:43 - so and this works because if the
80:45 - condition is true we'll return true and
80:47 - exit this function
80:49 - and we won't reach this error but if
80:52 - this condition is not true then we won't
80:54 - exit the function and we'll directly
80:56 - return false
80:57 - so now let's try this so I'm gonna say
81:01 - let's get rid of this as well
81:04 - and I'm going to do transaction one
81:07 - dot check valid transaction
81:11 - and we're going to say the r is 13.
81:15 - and let's print this
81:21 - if we run the file you see we get true
81:23 - if I given something like 24
81:27 - or less to 23 24 is invalid
81:30 - we get false
81:31 - so
81:33 - that's the basic idea of class methods
81:35 - and static methods and with that
81:37 - knowledge I'm going to go to the final
81:39 - section of object oriented programming
81:41 - which will talk about how we can inherit
81:44 - from parent classes and all of that so
81:48 - for all of that and more I'll see you in
81:50 - the next section
81:53 - so now it's time to talk about
81:55 - inheritance and how we can inherit the
81:58 - properties and methods from another
82:00 - class and to do this I'm going to use an
82:02 - example of a website
82:05 - so in our website you have multiple
82:07 - Pages you have the home page you have
82:09 - the about page you have the contact page
82:11 - and I'm gonna create a base class which
82:14 - is like the fundamental class and that's
82:17 - going to be the page class so this class
82:19 - is going to be page
82:20 - and this is going to have
82:23 - its own init method so the page class
82:25 - will take in
82:27 - um
82:28 - properties parameters like first of all
82:30 - we'll take itself by default and then it
82:33 - will go ahead and take the heading of
82:35 - the page and the body of the page
82:38 - so over here I'm going to say self dot
82:40 - heading equals heading
82:42 - and self dot body equals body
82:47 - moving on I'm gonna create a method
82:51 - called create page so over here I'm
82:53 - going to create underscore page
82:57 - and this will just return HTML code of
83:00 - that page so keeping it very simple
83:02 - let's just have a header tag and if you
83:04 - are not sure if you haven't learned HTML
83:07 - code uh all this is doing is creating a
83:09 - heading using a header tag and it's
83:12 - creating the main body text using a
83:14 - paragraph tag so over here I'm going to
83:17 - say H1 so this is the heading tank and
83:19 - within it goes the heading so I'm going
83:22 - to use an F string to embed self dot
83:25 - heading here
83:26 - so whatever the heading is we're gonna
83:28 - embed it inside the heading tag and then
83:31 - we're gonna create a new paragraph and
83:33 - this will contain the body
83:38 - so
83:39 - this opens the heading tag this closes
83:42 - the heading tag and within the heading
83:43 - tag you have the value of the heading
83:46 - which remember we assigned to the
83:48 - instance of the Page by accepting the
83:51 - heading as a parameter in the init
83:53 - method
83:54 - and over here as well same thing we're
83:57 - going to do it with self.body
83:59 - over here I'm going to return the HTML
84:01 - code to
84:02 - and that's going to be pretty much it
84:04 - for the page class
84:06 - now I want to create another class for
84:09 - the contact page but there'll be a lot
84:11 - of overlappings the page class is like a
84:14 - bigger Circle and the contact class is a
84:17 - smaller Circle within it so the page
84:19 - class is like the parent class of it
84:21 - where the contact class has to inherit
84:24 - stuff like the heading and body from the
84:27 - page class itself because if okay let's
84:29 - just assume you're creating a contact
84:31 - class like this in a simple way then
84:33 - we'd have to copy all of this code and
84:36 - paste it again
84:39 - like so and this is a very inefficient
84:41 - way of working because uh we have the
84:44 - page class which is the base class why
84:46 - don't we just inherit the init method
84:49 - why don't we just inherit the create
84:50 - page because they are effectively the
84:52 - same methods because
84:54 - um they have the same functionality
84:56 - contact page is after all a page and
84:59 - therefore it will inherit some of the
85:00 - methods and some of the properties like
85:03 - software heading and self.body and some
85:05 - of the methods like create page from the
85:07 - page class so how do you inherit how do
85:10 - you inherit these properties and methods
85:12 - from the page class
85:14 - now in Python you use the following
85:16 - notation so you go a pair of parentheses
85:19 - and you write the name of the class you
85:21 - want to inherit from
85:23 - and with that all of this code is saved
85:26 - I don't need to rewrite it again and all
85:28 - I need to do is plus pass essentially do
85:31 - nothing in the contact class
85:33 - and now let's create a contact page so
85:35 - I'm going to say contact UNESCO page is
85:36 - equal to contact
85:39 - and I'll provide a heading let's say
85:42 - um
85:42 - contact us
85:44 - and the body text will be
85:46 - please give us your feedback
85:52 - foreign
85:57 - dot headings let's see what the heading
86:00 - is and if I run this
86:05 - okay so I need to print that so let's
86:07 - print it
86:11 - and if I run you see we get the headings
86:13 - contact us so even if we don't have an
86:15 - init method over here it doesn't matter
86:17 - the python would first look in the
86:20 - contact class to see if there is an init
86:23 - method it doesn't find it it will go to
86:25 - its parent class which is the page class
86:27 - and over here it finds in it it finds an
86:30 - init method and it assigns self heading
86:33 - to heading it sees that over there and
86:35 - from that you see that the contact page
86:37 - instance
86:38 - gets the heading variable attached to it
86:42 - and then when we print it we get contact
86:44 - us as the heading so it first looks in
86:46 - the contact class if it doesn't find the
86:48 - net method it will go ahead into the
86:50 - base class
86:52 - so another thing we can do is create a
86:54 - page
86:56 - We inherited that method so if I run now
86:59 - you see without any code in the contact
87:02 - class it doesn't matter we're getting
87:03 - the same output here because we've
87:05 - inherited the method and the variable
87:07 - from the page class
87:09 - so now with that done I want to talk
87:11 - about one more thing which is the is
87:14 - instance
87:15 - um function the is instance function in
87:18 - Python is used to check if an object is
87:21 - an instance of a particular class
87:24 - I'm sorry for that so let me repeat that
87:26 - again the is instance
87:29 - function checks if an object is an
87:32 - instance of a particular class
87:34 - like for instance over here
87:36 - let's print is instance
87:40 - uh contact page of the contact class
87:44 - and as you'd expect it says true yes the
87:48 - contact page is an instance of the
87:49 - contact class because we have written
87:51 - contact over here if it's an instance
87:54 - but another thing we can check for is if
87:56 - it's an instance of the page class
87:59 - and if I run this now you'll see that 2
88:01 - will return true because although it's
88:04 - not directly linked to the page class
88:05 - the contact class in helps from the page
88:08 - class and therefore contact page is also
88:10 - an instance of the page class so we'll
88:13 - use this function is instance a lot
88:16 - during the coding of our um uh of the of
88:20 - our programming language so it's
88:22 - important to note the functionality of
88:24 - is instance
88:26 - another another thing I want to talk
88:28 - about is the super function so over here
88:32 - I'm gonna create
88:34 - the init method
88:36 - and let's say I want to accept another
88:39 - parameter for the contact page let's say
88:42 - I want to accept the email address of
88:44 - the person who wants to contact me
88:46 - now that's not that in the base page
88:48 - class because not every page would need
88:50 - to extract the email address but it
88:52 - turns out that the contact page does
88:54 - need to do so so over here it'll it'll
88:57 - extract The Heading first of all self in
88:59 - heading then body then the email address
89:05 - and over here
89:07 - what do I do do I just copy this part
89:10 - over here
89:14 - and then do self dot email ID
89:23 - is this the correct way to do it well
89:25 - let's try it out so if I um
89:29 - given an email let's say
89:32 - um
89:35 - if I get that email in and let's print
89:37 - the email ID
89:44 - if I run this you see this will work we
89:47 - get the email ID but code repetition is
89:50 - not always appreciated it's never
89:52 - appreciated in fact in uh in programming
89:54 - and therefore to avoid this repetition
89:57 - of
89:58 - assigning heading and body to
90:00 - the
90:02 - um instance instead of repeating this
90:04 - since we already have that functionality
90:06 - in the page class we use the super
90:08 - function so the super function
90:11 - calls the init method in the parent
90:13 - class which is page it calls the init
90:16 - method and we can pass in parameters
90:18 - heading and body
90:20 - so this ensures that the init method is
90:24 - called in the super class and the super
90:26 - class is the page class so this is like
90:28 - saying go to the page class and then run
90:31 - the init method
90:33 - and provide the heading and body as
90:37 - parameters so that's effectively what
90:39 - the super function is doing
90:42 - so after we have
90:45 - um handled heading and body then we do
90:47 - self dot email ID equals email ID and
90:49 - let's create another function over here
90:50 - let's say
90:51 - I want to create
90:54 - a contact button
90:59 - and this will take himself
91:01 - and all I'm going to do is return
91:05 - button and then inside the button I'm
91:07 - going to say
91:13 - self.email ID
91:21 - contact now
91:24 - something like that so if my name is if
91:26 - the email ID is
91:28 - ABC email.com then say ABC email.com
91:31 - contact now and this will be inside a
91:34 - button so in the edge in HTML the button
91:37 - tag is used to create a button so over
91:41 - here
91:41 - let's do the same thing let's contact
91:44 - page now we're going to create
91:46 - the contact button
91:48 - and let's print
91:53 - and hopefully this works there we go
91:55 - button ADC email.com contact now so this
91:59 - is the power of inheritance we are
92:01 - adding uh we are extending the
92:04 - functionality of the base class which is
92:06 - the page class we're extending its
92:08 - functionality by adding our own methods
92:10 - while also inheriting the most
92:12 - fundamental uh functionalities like
92:15 - create page and we're also inheriting
92:16 - the
92:18 - um
92:18 - the init method over here previously we
92:21 - we didn't even have to write the init
92:23 - method it automatically found it from
92:25 - the page class and executed that so
92:28 - that's the power of inheritance and with
92:30 - that I'm pretty much done with object
92:33 - oriented programming of course we want
92:35 - to understand objective object oriented
92:37 - programming on a deeper level there are
92:39 - several other Concepts to understand but
92:41 - I think that we've reached a fast stage
92:43 - now
92:44 - where with this base knowledge we can
92:46 - move on to the next section
92:51 - so in the next few sections we'll be
92:53 - talking about data structures and we're
92:55 - going to start off with lists now lists
92:58 - are like regular list that we talk about
93:00 - in common language in everyday language
93:03 - you can have a list of grocery items you
93:06 - can add add to the list of grocery items
93:08 - you can remove something from the list
93:10 - of grocery items you can add something
93:13 - at a certain position so let you know so
93:16 - it maintains a sequential order as well
93:18 - that means it respects sequence that
93:21 - means you can
93:22 - add elements at a certain position uh
93:26 - you don't it's not just that you can add
93:27 - them at the last position at the first
93:29 - position so let's demonstrate everything
93:31 - about lists in Python so this is the
93:34 - simplest form of data structure we'll go
93:36 - on to more complicated forms like
93:37 - eventually we'll talk about binary trees
93:39 - so anyways let's start with the list how
93:42 - do you create a list in Python uh you
93:45 - first create the name of a variable so
93:46 - I'm gonna call the variable R short for
93:49 - array so or let's just call it um
93:53 - I can't use list because that's a
93:55 - reserved keyboard so let's just use
93:59 - um a let's call the list a
94:01 - and you create a list by using these
94:03 - square brackets and I can create the
94:06 - first list by saying one comma two comma
94:08 - three comma four and that's one list
94:10 - over there
94:12 - you can add to the list using the append
94:14 - method so all of this list in Python are
94:17 - built-in classes so that means if I
94:20 - print
94:22 - is instance
94:24 - a of the class list and that's a
94:27 - built-in class if I run this you see it
94:29 - will return true because it's a built-in
94:31 - class and when you use these square
94:33 - brackets you sort of create an instance
94:35 - of the list class
94:37 - so over here in that list class there is
94:41 - a method called append so I can append
94:43 - let's say a number let's say append five
94:45 - and now if I print a you see that the
94:48 - output will be one two three four five
94:50 - the append method adds three last
94:53 - element
94:54 - um there is another method two which is
94:56 - called insert and the insert does not
94:59 - necessarily add at the last at the end
95:01 - of the list it can add things even in
95:03 - the middle or whichever position you
95:05 - define it to be
95:06 - in Python uh the position are defined by
95:10 - starting with the number zero so this
95:12 - first element is called is given the
95:14 - index 0
95:15 - the second element is given the index 1
95:17 - and so on so 0 1 2 3 so that's the uh
95:22 - order so you start off with zero so if I
95:25 - say print
95:26 - a square bracket 0 that means I want to
95:28 - access the zeroth element which is the
95:31 - number one so we'll get the number one
95:33 - over here
95:35 - so um we can insert as I said so I can
95:39 - insert
95:41 - a certain data it can be anything it can
95:45 - be a number it can be text whatever so
95:47 - I'm gonna into insert the number eight
95:50 - at position two so that means 0 1 2 that
95:56 - means it should be after the number
95:57 - three so let's print a now
96:00 - and see what we get you see it's um
96:04 - okay I I reverse the order my button so
96:06 - we have to mention the position first
96:08 - and then the numbers of two comma eight
96:12 - now let's see if it works so if I run
96:14 - this you see we get it before three so
96:17 - one two eight and three so at position
96:20 - two so zero one two so now this is a
96:23 - position two over here
96:25 - and follow me following that does the
96:27 - number three then four and five so
96:29 - that's the insert method
96:32 - um for lists I can even add a text here
96:35 - so we create text using these double
96:37 - quotes and let's say text and if I run
96:41 - this
96:42 - we'll get one to text at the second
96:44 - position remember zero one two second
96:48 - position
96:49 - second position three four five and
96:52 - that's that's how it works you can
96:54 - reverse the order so you can have five
96:55 - first in four second and so on by using
96:58 - the reverse method so I'm going to say a
97:00 - DOT reverse
97:02 - and if I run this you see we get it in
97:05 - reverse order
97:06 - we can sort it in ascending order and we
97:10 - can for now I'm going to say ascending
97:12 - number of order of numbers so let's say
97:14 - I have the number 9 here
97:16 - and I'm going to print it
97:19 - print a over here before the sort so
97:22 - before sort
97:24 - and then I'm going to sort a DOT sort
97:27 - and then I'm going to print a again
97:30 - and if I run this
97:33 - you see I'll get before sort it's five
97:35 - four three nine two one but after the
97:37 - Sorting process is stored in the sending
97:39 - order
97:41 - another method is the pop method and
97:43 - this Returns the last element of the
97:45 - list and also removes it from the list
97:48 - so if I right now
97:50 - let's remove all of this clutter and if
97:52 - I do a DOT pop
97:55 - and then I print a
97:58 - let's run this again and you see we get
98:00 - one two three
98:01 - and in fact I say if I can say last
98:03 - underscore element is equal to adopt and
98:06 - if I print the last element I'll also
98:08 - get what the last element was so if I
98:10 - run this you see I get 4 was the last
98:13 - element and now what remains of the list
98:16 - a is one two three
98:20 - so you can also remove all of the
98:22 - elements by using the clear method so
98:24 - over here I can do Aid or clear
98:26 - and if I print a
98:29 - run it you see we get an empty list
98:31 - which is symbolized like so
98:34 - so now
98:35 - let's move on to a few more operations
98:39 - one more Opera one operation you have is
98:41 - let's say I have the D list one like
98:43 - that
98:44 - now I can print
98:47 - or I can do a equals a times five and
98:51 - now let's print a you may think that
98:53 - that makes no sense but that essentially
98:55 - just multiplies this item by Phi so that
98:58 - means this item will be present five
99:00 - times now so 5 times 1 is 5 if this was
99:03 - existing twice then it will add the same
99:06 - array five times to itself and a would
99:08 - look something like this so if I run
99:10 - this you see we get the array with 10
99:14 - ones because the first base array is
99:18 - with two ones and then you multiply that
99:19 - with five and you get 10 months so
99:21 - that's uh how you can multiply or is you
99:23 - can even add arrays to each other so if
99:25 - I one array is one comma two
99:27 - another array is 3 comma four
99:31 - now if I print
99:33 - a plus b
99:36 - and run this you see we get one two
99:38 - three four
99:39 - so that's how we can add or multiply
99:43 - arrays one more thing you can do is you
99:45 - can go you can iterate over a range of
99:48 - values in an array so like say for
99:50 - instance I have
99:51 - one two three four five and six
99:54 - now if I print a
99:57 - one two three so a one two three
100:01 - let's see what we get over here so if I
100:03 - run this CC I get 2 comma 3 and this
100:05 - starts off from the index one which is
100:08 - here moves on to index two and it
100:10 - excludes the last value here so uh if
100:13 - you want to include the last value you
100:15 - have to add by once three plus one four
100:17 - and in that way it will include two
100:19 - three four like that so let me just
100:23 - um rephrase again so you have at index
100:25 - one you have the number two so two comma
100:29 - three comma four and this is index three
100:32 - zero one two three and this last is
100:34 - since it's four over here but
100:36 - um when you're when you're taking it
100:39 - over a range it does not include the
100:42 - last number it does it one minus that so
100:46 - foreign
100:47 - returns
100:51 - the list
100:54 - from a to the power 1 to a to the power
100:57 - a 3. so index 1 to index 3 that's how it
101:01 - works
101:03 - you can also have
101:05 - um no number to start and that will
101:07 - return everything until the index number
101:10 - three so if I run this you see
101:13 - everything until index 3 if you don't
101:15 - specify a number over here if I specify
101:16 - a number over here it'll be from index 1
101:18 - to index 3 but if I don't specify it
101:20 - it'll be from the start to the index 3.
101:25 - now after that you also have
101:28 - um copying arrays so how do you copy one
101:31 - copying list so how do you copy one list
101:33 - from to another list so let's say I have
101:36 - this list over here a equals one two
101:38 - three four five six
101:40 - now A2 I want to copy uh list one so I'm
101:43 - going to say a
101:45 - and uh let's see what happens if we do
101:47 - this so now if I print A2
101:51 - you see we do get one two three four
101:54 - five and six
101:55 - but check this out if I do A2 dot append
101:59 - seven
102:00 - and now I print A2 obviously it will
102:03 - have the seventh number
102:05 - after it
102:09 - but if I print it
102:14 - and run this again you see even a has
102:17 - experienced that change so when you
102:19 - equate these two together even a
102:21 - experiences the operation zero after
102:23 - that of after line two if you don't want
102:26 - that to happen you want to leave a as it
102:28 - is and work with this as a new array you
102:31 - can use the copy method so dot copy and
102:34 - if you do that you see this change does
102:36 - not get implemented on array a it's only
102:38 - implemented on array A2
102:41 - so that's about it for lists
102:46 - tuples are quite similar to lists in
102:49 - that they also store data in non in an
102:51 - ordered manner so you can create Tuple
102:54 - instead of using by instead of using
102:56 - square brackets you use the normal
102:58 - brackets so over here I can say Tuple
103:00 - one
103:01 - equals and you use a pair of brackets
103:04 - over here
103:05 - and I can have one comma 2 comma 3
103:09 - I can print the first element of the
103:11 - Tuple
103:13 - which is the zeroth index
103:15 - I can
103:17 - yeah let's just do that for now
103:21 - and you see we get one over here so
103:23 - that's how tuples work it's very similar
103:26 - to list but they have a few distinctions
103:28 - that you need to keep in mind
103:30 - one of the distinction is that a tuple
103:32 - is immutable so if I try to do the
103:35 - following Tuple one zero and I'll try to
103:38 - change the zeroth index so let's say the
103:40 - number five and I save it you see we get
103:43 - an error Tuple object does not support
103:45 - assignment
103:47 - so this is why tuples are immutable they
103:50 - can't be changed whereas lists are
103:52 - mutable so if I do list one equals 1
103:56 - comma two comma three and then I do list
103:58 - one
104:00 - zero is equal to 5 and let's comment
104:03 - this one out
104:05 - and I run this you see we don't get any
104:07 - error over here
104:08 - and let's just print list one as well
104:14 - if I run this
104:15 - you see we get 5 comma 2 comma 3 because
104:18 - lists are mutable but tuples are not
104:21 - one additional thing you need to note
104:23 - about tuples is that if we have a
104:25 - element if you have a tuple with one
104:26 - element
104:27 - then you can
104:29 - create them by using the following
104:32 - notation you do not you can't have no
104:34 - comma over here because if you do
104:36 - brackets one brackets that will mean
104:39 - that this is just
104:41 - a number inside a pair of brackets it
104:43 - does not resemble anything but if you
104:46 - put a comma over here you would realize
104:48 - that that's a tuple so in fact let's try
104:50 - and see the instances were whether it's
104:54 - an instance of Tuple or not so let's
104:56 - print
104:57 - is instance Tuple one
105:00 - of double
105:02 - if I run that you see we get false but
105:05 - the second I put a comma over here I'm
105:08 - telling python that this is a tuple I
105:10 - want to create this as a tuple so if I
105:12 - run this you see we get true over here
105:15 - now it's also possible to convert tuples
105:17 - to lists and list tuples so I'll delete
105:21 - all of this now
105:24 - and I can say list one
105:28 - equals
105:30 - Tuple or equals list of Tuple one
105:37 - and if I print list one
105:40 - you see it will be a list
105:42 - as you can see
105:44 - and if I do
105:45 - this one over here
105:47 - and let's create a list over here
105:52 - and I'll do tackle one here
105:54 - and let's create a tuple from the list
105:58 - you see that that too will work
106:05 - we get a tuple over here
106:07 - so that's about it for tuples let's move
106:10 - on to the final sort of simple data
106:13 - structure which most of you might
106:14 - already be familiar with but I thought
106:16 - it would be a good idea to give you a
106:18 - refresher about these data structures
106:19 - see the last one will be talking about
106:21 - is dictionaries and then we'll move on
106:23 - we'll move on to few Advanced data
106:25 - structures like Stacks or binary trees
106:29 - which we will be using in this course so
106:31 - I'll see you over there
106:36 - so how do you create a dictionary in
106:38 - Python well we use there are two ways to
106:41 - do it the first way is a simple one you
106:44 - just use a curly brace pair of curly
106:47 - braces and then the first thing you
106:49 - mentioned in a dictionary is the key so
106:52 - in a dictionary you have key and value
106:54 - so you have key value Pairs and an
106:56 - example of this will be the following so
106:58 - let's say I have an employee and his
107:01 - name is John
107:03 - so over here name is the key John is the
107:07 - value
107:08 - this employee will have an age
107:11 - and you have to also include that in
107:13 - double quotes and his age is 19.
107:18 - um this employee will have a profession
107:23 - let's say it's accounting
107:25 - so that's this that's how dictionaries
107:27 - work you have a key you have a value and
107:30 - these pairs you can have n number of
107:32 - them in a dictionary stored in a
107:34 - dictionary so the purpose of
107:36 - dictionaries is that they can store two
107:38 - values key they can they can store two
107:40 - pieces of data key and value and they're
107:43 - actually pretty useful when for instance
107:46 - creating Alexa where each token will
107:49 - have of a data type and a value like for
107:52 - instance the number five has a type of
107:54 - integer and has the value of five so in
107:58 - that sense dictionaries are really
107:59 - useful because they allow us to store
108:01 - two pieces of data
108:03 - how do you access uh values so you can
108:06 - say dict one
108:08 - um say the name of the key so let's say
108:11 - the name
108:12 - and let's print this
108:14 - so similar to an array how we use the
108:16 - square brackets to access a certain
108:18 - index we will use a square bracket to
108:21 - access the value of a certain key let's
108:24 - print this run it
108:25 - we get John
108:27 - we can do age
108:30 - and we'll get 19
108:32 - and this doesn't necessarily have to be
108:34 - a string it can also be a number so for
108:36 - instance let's say 5 is um I don't know
108:41 - 26 okay this makes no sense but I'm just
108:44 - trying to show how you can also store
108:46 - the key as an integer as a number so
108:48 - over here I can access the key 5 and
108:52 - that will return 26. one more thing you
108:54 - can do in dictionaries is Traverse
108:56 - through them iterate through each item
108:58 - of a dictionary and you use a for Loop
109:01 - for that
109:02 - so I can run a for Loop
109:04 - we can extract the key and the value
109:07 - indict one by using the items method the
109:10 - items method is a certain method present
109:14 - in the dictionary class which is inbuilt
109:16 - in Python just like the list class and
109:18 - the Tuple class so over here we're
109:20 - extracting the key and the value and I
109:22 - can print that in F string
109:25 - I can print key with the space bar and
109:27 - then value
109:29 - and if I run that you see we get name
109:31 - John age 19 professional Accounting in a
109:34 - new line every single time
109:36 - so that's the basics of dictionaries and
109:39 - that's all you need to know for this
109:40 - course and with that knowledge let's now
109:43 - move on to a few more complicated
109:44 - Concepts in data structures
109:49 - in this section of the course I have
109:51 - brought an interesting activity that you
109:52 - can do using the existing knowledge that
109:55 - we've built so far so we are going to
109:57 - create our own class for data structure
110:00 - known as a stack now a stack is
110:03 - effectively just
110:04 - um it's just like that it's just what
110:06 - the word describes a stack you can have
110:09 - items stacked on top of each other you
110:12 - can add an item at the top of the stack
110:14 - but you cannot add it in between the
110:16 - stack like we did in a list where we
110:18 - added items in a certain position of the
110:20 - list where we can't do that with Stacks
110:22 - the only three operations you have is
110:24 - you can add an item on top of the stack
110:26 - you can remove an item from the top of
110:29 - the stack or you can read the value of
110:32 - the item at the top of the stack so I
110:36 - have an activity for you how about try
110:38 - creating a class that performs all of
110:40 - these uh functionality so we'll have a
110:42 - class called stack
110:44 - and it will have an init method of
110:46 - course but I won't write that for now it
110:48 - will have three functionalities push
110:50 - which means adding to the stack
110:54 - adding an element to the end of a stack
110:57 - to the to the top of the stack
111:00 - we have pop
111:02 - adding an item to the top of this
111:04 - removing the top most item from the
111:07 - stack
111:08 - and you also have Peak
111:13 - which is reading the value of the item
111:16 - on the topmost of the stack so these
111:18 - three functionalities push pop and Peak
111:21 - can you try executing them using python
111:24 - list so you will be using python lists
111:26 - as a data structure to create the stack
111:29 - so now let's move on to the task how
111:32 - does this work so I'm going to first
111:33 - create the init method
111:37 - which takes in self
111:39 - and it will yeah that's it self and over
111:42 - here I'm going to create
111:43 - the stack now the push method adds an
111:47 - item to the top of the stack so this
111:50 - will simply append
111:52 - to the list
111:56 - Whatever item so we need to take self
111:58 - over here first of all and we also need
112:00 - to take the item that you want to push
112:02 - to the top of the stack so I'm going to
112:04 - say item over here we're going to append
112:07 - item
112:09 - we can pop as in remove the item at the
112:13 - topmost of the stack and for that we can
112:15 - use the pop method in in list so you can
112:18 - do pop
112:19 - and I'll also accept selfio
112:22 - and we can return
112:25 - self.stack.pop this removes the topmost
112:28 - item from the stack
112:30 - Peak we'll just return the topmost item
112:33 - from the stack now in Python to
112:36 - extract the last item of list because
112:39 - ins since we're using list to represent
112:42 - the stack the topmost item is the last
112:44 - element of the list so how do you
112:47 - extract the last element of the list
112:49 - for that I'm gonna use self first of all
112:52 - and I'm gonna say last underscore
112:54 - element
112:55 - is equal to self dot stack
112:58 - the length of the stack
113:01 - minus 1 because the indexing starts from
113:03 - 0
113:04 - and in this way we're extracting the
113:06 - last item of the list which corresponds
113:09 - to the stock topmost element of the
113:11 - stack so this is the last element and
113:14 - I'm going to return that last element
113:16 - so now let's try working with the stack
113:19 - so I'm going to say stack one
113:21 - is equal to stack
113:23 - and I'm going to stack one dot push
113:27 - let's push
113:29 - um
113:29 - the number five
113:31 - stack one double push
113:34 - number three
113:35 - stack one dot push
113:38 - the number seven
113:40 - and now I want to pick I want to see the
113:43 - topmost element of the stack so I'm
113:45 - going to print
113:46 - stack one dot Peak
113:49 - which is which will Peak at the topmost
113:51 - element of the stack since the first the
113:54 - bottom most is five then in the middle
113:56 - there's the number three and then the
113:58 - top of the stack is seven we should get
114:00 - the number seven so if I run this I get
114:02 - seven over here so that's it from this
114:05 - section I feel that this was a good
114:07 - exercise to get us warmed up for our
114:10 - upcoming challenges in creating the
114:14 - programming language so with that
114:16 - exercise let's move on to the next
114:17 - section where we will be talking about
114:19 - binary trees
114:23 - a binary tree is a form of hierarchical
114:26 - data structure it looks something like
114:28 - this so you have
114:31 - um the following placeholders you have a
114:33 - you have B
114:35 - C all of these points and these points
114:38 - represent a storage of data they're
114:41 - called nodes nodes are
114:44 - a unit of data
114:46 - it's a representation of data it's a
114:48 - placeholder for a day for a piece of
114:50 - data so B over here C
114:54 - and then we can do d e
114:57 - like so and this is a binary tree now a
115:00 - binary tree means that each node has a
115:03 - maximum of two children
115:05 - the child of node a is B and C so this
115:08 - is the left child
115:11 - this is the right child
115:13 - so the children of node a are the left
115:17 - child and the right child which is node
115:19 - B and node C and in a binary tree every
115:22 - node has a maximum of two children as
115:25 - you can see nodes d and e have no
115:27 - children and they are called Leaf nodes
115:29 - node D has two children node C maybe we
115:33 - can have one child to it
115:35 - like that so the idea is simple binary
115:38 - trees have a maximum of two children
115:40 - every node in a binary tree has a
115:42 - maximum of two children
115:44 - a bit of more terminology is the fact
115:47 - that every single level is given a
115:49 - number so this is called level one and
115:52 - it includes only node a
115:54 - this entire thing is called level two
115:59 - and this entire row is called level
116:01 - three
116:03 - so that's just the uh terminology used
116:07 - in describing binary trees but what's
116:10 - the use case of it how does it work
116:12 - we'll look into that in the next section
116:17 - the most important part the most
116:19 - important part of binary trees is a way
116:22 - in which we Traverse to them the way in
116:24 - which we visit each node and analyze and
116:26 - process each node so there are three
116:29 - ways of traversing a binary tree and
116:31 - just before we get into that I'm going
116:33 - to talk about something called a sub
116:35 - tree so I have the root node over here
116:37 - uh this is called the root node which is
116:41 - at the top of the tree
116:43 - and it has a few children two children
116:45 - maximum of two children
116:47 - and every single node after that also
116:50 - has a maximum of two children until we
116:52 - get to the leaf node which have no
116:54 - children
116:55 - so d
116:58 - and let's do e over here
117:01 - so in a binary and I'm going to do one
117:04 - more F over here in a binary tree we
117:07 - also have sub trees so this entire
117:10 - region which is uh enclosed by the
117:13 - dotted line is a sub tree it's a tree
117:15 - within a tree
117:17 - and now that we understand what subtrees
117:20 - are we can try and understand the
117:22 - traversal methods how you visit each
117:23 - node of the tree traversal refers to the
117:26 - fact that you have to visit above you
117:29 - have to visit each and every node in a
117:30 - binary tree so how do you do that there
117:33 - are various ways in which you can
117:34 - Traverse through binary tree and we're
117:36 - going to talk about three ways the first
117:38 - is called pre-order traversal
117:44 - pre-order traversal refers to the fact
117:47 - that you first go to the root you first
117:49 - visit the root node then you visit the
117:53 - left subtree
117:56 - and then you visit the right subtree
118:02 - so I'm gonna call the subtree over here
118:05 - subtree one and this subtree will be
118:10 - 2.
118:12 - so how can we Traverse to this entire
118:14 - tree
118:15 - Traverse through this entire tree by
118:18 - using the pre-order traversal method so
118:21 - the first step is going through the root
118:22 - so we start off with node a
118:26 - then we go to the left subtree so then
118:28 - we Traverse through left subtree
118:31 - and then we Traverse through the right
118:33 - subtree
118:35 - now we need to understand how we
118:37 - Traverse to the left subtree which is
118:39 - subtree one
118:40 - and we use the same pattern over here we
118:42 - start off with the root root so we go
118:45 - from B then we go to the left sub tree
118:47 - and the left sub tree is just node D so
118:50 - this is the left sub tree over here
118:52 - so that's node d
118:54 - then we go to the right subtree which is
118:56 - node f
118:58 - so that's what the pre-order traversal
119:01 - of subtree one looks like the period of
119:05 - traversal of subtree 2 will look like
119:07 - first we start off with the root node
119:09 - there is no left subtree so we don't do
119:11 - anything then we move to the right
119:13 - subtree which is e over here
119:15 - so in pre-order traversal the order of
119:18 - traversal is a
119:20 - B
119:21 - d
119:23 - f
119:24 - c e and this is known as pre-order
119:27 - reversal
119:31 - we sometimes use pre-order traversal we
119:33 - visit uh D3 in such a way to accomplish
119:38 - certain tasks in our scenario where we
119:41 - will be
119:42 - where we want to pass inputs parse uh
119:45 - inputs in a certain programming language
119:47 - and then given then execute it we have
119:50 - we'll be using post order traversal so
119:53 - let's take the example of an expression
119:55 - one plus two times three now how does
119:58 - all of this relate to a binary tree so
120:01 - we can represent one plus two plus times
120:04 - three instead of this expressed in a
120:07 - linear way like a list of tokens which
120:09 - is what we do after step one after
120:12 - lexical analysis step two involves
120:15 - making this linear data structure and
120:18 - converting it into a hierarchical binary
120:20 - tree so how can we express this
120:23 - expression as a binary tree
120:25 - so we start off with the plus operation
120:28 - which is the topmost which is the root
120:30 - node
120:31 - then we go left
120:33 - which is the number one
120:34 - then we multiply 2 and 3.
120:40 - so this is the binary tree
120:43 - [Music]
120:46 - of the expression 1 plus 2 times 3
120:50 - and the way in which we Traverse it
120:53 - affects how we get how we evaluate the
120:55 - expression
120:57 - so in post audit reversal so we talked
120:59 - about pre-order traversal in the
121:00 - previous section now I'm going to talk
121:02 - about post order traversal
121:04 - in post order you start off with the
121:07 - left subtree
121:09 - then you move to the right subtree
121:14 - and then you move to the root node
121:17 - so the left subtree is the following
121:20 - dotted line the right subtree is also
121:22 - the following
121:24 - left sub tree it's just
121:27 - um so I'm going to call this subtree a
121:29 - I'm going to call this sub tree B
121:33 - so subtree a
121:37 - is equal to just 1
121:39 - you start new that's the only thing you
121:42 - can that's the only way in which you can
121:44 - Traverse subtree a sub tree B if you
121:47 - want to do a post order traversal on
121:49 - this you start off with the left subtree
121:50 - which is the left node over here the
121:53 - node two then you move to the right
121:55 - subtree which is node three
121:59 - node three
122:01 - and then you do the root node which is
122:03 - multiplication
122:04 - so now finally to evaluate the binary
122:07 - tree we start off with the left subtree
122:08 - which is a
122:10 - to be to the root
122:12 - and that's 1 comma 2 comma 3 comma
122:17 - multiplication
122:19 - um yeah comma root so that's the way in
122:22 - which we Traverse through the Stream
122:24 - it's called post order traversal and the
122:27 - idea in personal traversal and how it
122:29 - relates to Computing or expression is
122:31 - the fact that the order of operations
122:34 - with higher precedence lie lower down
122:37 - the tree and do in Expressions when
122:40 - evaluating expressions we give
122:42 - preference from left to right so if you
122:44 - compute compute seven divided by 2
122:46 - divided by 3 we compute this first and
122:50 - then the answer of that we divided by
122:52 - three so the higher presence is given to
122:55 - left than the right
122:57 - so this is one fact and the other fact
123:00 - is that we give precedence to to
123:02 - multiplication and division more than
123:04 - the preference to addition or
123:06 - subtraction so in this scenario the
123:08 - order of operations with higher
123:10 - preference are lower down the tree they
123:12 - have a higher level so remember this was
123:15 - level one so they'll be lower down the
123:17 - tree will have a higher level and by
123:19 - traversing them in a post-order manner
123:21 - like one two three multiplication and
123:24 - then the root node by traversing them in
123:27 - such a way we are first Computing one
123:30 - then we are Computing the multiplication
123:32 - and then we are adding those two
123:35 - together that's what the effect of post
123:37 - order is
123:41 - so now let's understand how post audit
123:44 - reversal relates to Computing and
123:46 - expression so let's say we have the
123:48 - following expression one plus two times
123:52 - seven
123:54 - so over here we're gonna have addition
123:56 - first
123:58 - or in fact I'm gonna
124:00 - um do multiplication first because we
124:01 - already used a similar expression
124:03 - let's do one times eight plus seven
124:07 - so plus and then multiplication
124:09 - one and eight
124:13 - and seven
124:15 - so in this example over here let's start
124:18 - to do Post audit reversal
124:20 - so remember it's left subtree then it's
124:24 - the right sub tree and then it's the
124:25 - root node
124:27 - so that so the left subtree is the
124:30 - following
124:31 - and in here again we have to do Post
124:33 - audit reversal so the left subtree of
124:35 - this sub tree is the number one then you
124:38 - go to the number eight then you go to
124:40 - the root node which is multiplication
124:42 - and then again we move to the right
124:44 - subtree which is 7 over here this is the
124:47 - right subtree and then we move to the
124:49 - operation Plus
124:50 - so that's the post audit reversal of how
124:52 - this works and now let's try and see how
124:55 - we can compute an expression using post
124:57 - order traversal
124:59 - so
125:01 - I'm gonna erase this bit
125:05 - and over here
125:07 - uh
125:10 - yeah so over here let's see by following
125:13 - this order of operation by following
125:14 - this order of traversal how we can
125:16 - compute the expression so remember the
125:19 - first thing we're going to do is visit
125:20 - the root node the the node one which is
125:23 - over here the first thing we do is visit
125:25 - this so we visit this a then the second
125:29 - thing we do is visit this so B third
125:31 - thing we do is visit this so C then D
125:35 - and then finally we visit the plus
125:37 - operation so e
125:39 - so we start off with first then eight
125:41 - then multiplication then seven and then
125:44 - Plus
125:45 - so how does this relate to Computing and
125:47 - expression
125:48 - so we first visit root uh we first visit
125:52 - this node over here so I'm going to call
125:54 - that node a we first visit node a
125:58 - and we process it so that's the number
126:01 - one
126:04 - so we first process that
126:06 - um so let me keep that over here so one
126:08 - we first processed that process that
126:10 - then we go to root B and we process that
126:13 - we get the number eight so now we've
126:15 - processed that as well and it's the
126:16 - number eight
126:17 - then we go to root C and we process that
126:20 - okay now we see it's the multiplication
126:22 - of one and eight so then over here all
126:25 - we do is 1 times 8 which is equal to
126:27 - eight
126:29 - so in multiplication so there are two
126:31 - types of visiting one you visit a number
126:33 - in which you just return that number one
126:36 - or eight the second type of visiting is
126:38 - when you visit a binary operation over
126:41 - here plus is a binary operation is
126:42 - adding two numbers multiplication is a
126:45 - binary operation it's multiplying the
126:47 - left child node and the right child node
126:49 - so when we visit a binary operation we
126:52 - have to multiply the left trial node and
126:53 - the right child node so now we visited
126:55 - the multiplication node which is which
126:57 - was node C and we computed it it turns
127:00 - out to be eight times one which is eight
127:02 - so we visit uh we visit one first we
127:06 - visit eighth then then we use
127:07 - multiplication so we're done with this
127:09 - this and this then we visit node D and
127:12 - we compute it it turns out to be value
127:15 - of 7.
127:17 - 7 I'm sorry I just glad had a glitch
127:20 - over here so after we've processed node
127:22 - node 7 the the following node over here
127:25 - after we've processed that then we go to
127:27 - the root node which is over here and we
127:30 - do a binary operation we check the left
127:32 - node we check the right node and we
127:34 - compute them we add them together and
127:36 - the output turns out to be 15. so that's
127:40 - how we will be interpreting our input
127:43 - expression and this can be replicated
127:45 - for all of the input expressions in the
127:48 - programming language like say for
127:50 - instance we have an input a equals seven
127:52 - so then the operation would be equals
127:54 - and then a and then seven then we'll
127:57 - have to uh Traverse in the post order
127:59 - method and we'll have the similar output
128:01 - so that's how we're going to compute
128:03 - Expressions that's how we're going to
128:04 - interpret our parse Tree by following a
128:08 - post order traversal method
128:10 - and with that knowledge and I hopefully
128:13 - I hope that you understand how we are
128:15 - going to compute Expressions because
128:16 - this is an integral part of our course
128:19 - so now that you've understood it let's
128:21 - move on to the next section where we
128:23 - will be constructing a binary tree and
128:25 - doing some exercises with them
128:30 - so in this section of the course we'll
128:32 - be creating a binary tree essentially
128:35 - representing them in a programming
128:37 - language as of now we've just been
128:39 - drawing them and talking about them in a
128:40 - theoretical way but now we'll be
128:42 - creating a binary tree in the Python
128:45 - programming language
128:46 - so the first thing we need to do is
128:49 - create a class for the binary tree
128:52 - in fact I'll just call it 3 for now
128:56 - and this will have the init method
129:01 - and it will take in a root node to start
129:04 - off with and the root node I'm going to
129:06 - assign it the value of let's say 5. but
129:11 - I don't want to work with just numbers
129:12 - for now because I know that nodes
129:15 - denotes can also represent other pieces
129:18 - of data so to represent a node I'm going
129:20 - to create its own class so I'm going to
129:22 - create a class for the node as well
129:26 - the node class
129:31 - the node class will accept one parameter
129:34 - it will be the value of the node and I'm
129:36 - gonna say self dot value is equal to
129:38 - value
129:39 - and the node has two parts as you
129:42 - remember in a binary tree a node can
129:44 - have a maximum of two children so I'm
129:46 - gonna represent the left child
129:48 - by initially none so initially the node
129:51 - has no children
129:52 - and the right child will also be equal
129:54 - to none
129:56 - now let's go back to the tree and let's
129:59 - set the root to be equal to a node with
130:02 - the value of the root so over here we
130:05 - can create our first basic Tree by
130:07 - saying okay the tree is equal to an
130:09 - instance of the class tree and the root
130:13 - node will have a value of the number
130:14 - five
130:15 - so this is just creating the number five
130:18 - it has no left node it has no right node
130:20 - for now
130:21 - but let's add those parameters in so I'm
130:23 - gonna say tree
130:25 - dot root so the root uh variable now
130:30 - we're accessing that since it's uh it
130:33 - has a class of node I have access to
130:36 - these parameters left and right so I can
130:37 - assign these values I can say
130:39 - three dot root dot left is equal to 3
130:43 - and 3
130:45 - is equal to node three let's do node
130:47 - three
130:48 - and three dot root dot right is equal to
130:52 - node 4.
130:53 - what is the effective representation of
130:56 - this this has five at its root
131:00 - and
131:01 - it has three as the left child
131:06 - the right child of this node is 4.
131:11 - so this is the diagram this is the tree
131:13 - diagram
131:15 - um that we have created using python
131:17 - code so there is a tree it has the root
131:21 - of 5 and that's just a node with left
131:24 - and right assigned to be 3 and 4 and the
131:28 - left and right nodes of 3 and 4 are by
131:30 - default sent to none so that's how we
131:33 - can create a binary tree in Python now
131:36 - let's go ahead and do pre-order
131:37 - traversal on this tree
131:43 - to perform pre-order traversal I'm going
131:45 - to create a method called pre-order in
131:47 - the tree class itself so I'm gonna say
131:49 - def pre-order
131:51 - and this will take in self and the first
131:54 - parameter the first parameter it will
131:56 - take is the starting point of the
131:58 - pre-order and this will be the root node
132:00 - but as you will see we will change the
132:02 - starting node and we'll be using some
132:04 - recursion in this algorithm so uh yeah
132:08 - so the starting dot initially will be
132:10 - the root node but we take that as a
132:12 - parameter and another thing we're gonna
132:14 - take is the records field and I'll
132:17 - explain what this means in just a second
132:19 - but for now I'm gonna say if the
132:22 - starting point is not none which means
132:24 - if the starting point exists because
132:26 - remember for the left and right notes we
132:28 - set them as none so all we're checking
132:30 - is if they're not none that means if the
132:32 - starting point exists if the node exists
132:35 - itself then the first thing we're going
132:37 - to do is we're going to append that node
132:39 - to the records list so the records over
132:42 - here corresponds to a list which will be
132:44 - an empty list for now and over here
132:46 - we're going to append it
132:48 - uh the start dot value
132:52 - so
132:53 - let me talk about what this means again
132:55 - so remember in pre-order traversal we go
132:58 - in the order of root
133:01 - then we go to the left subtree
133:05 - and finally we do the right subgrade
133:09 - so in this case let's look at the uh the
133:12 - diagram so it's five the three diagrams
133:14 - so it's 5 starting off with five
133:16 - then we go to 3 in the left node
133:20 - and then over here
133:22 - 4 in the right node so we want to start
133:24 - off with the root so the in the
133:27 - pre-ordered traversal over here we're
133:28 - going to start call to pre-order so I'm
133:30 - going to say tree
133:33 - dot pre-order and I'm gonna pass in D
133:36 - root first so I'm going to say three dot
133:38 - root that is the starting point and
133:40 - Records will be an empty list so now
133:42 - let's see what happens so the first
133:44 - parameter is three dot root second
133:46 - parameter is an empty array so tree dot
133:48 - root is the starting point and start is
133:50 - not none and therefore it will append
133:52 - the starting point which is the root
133:55 - itself to the records records will be
133:57 - tracking our visits so the order of
134:00 - wizards that will track the order in
134:03 - which we Traverse through the nodes so
134:04 - the first thing that will be appended to
134:06 - the records list will be the root itself
134:09 - and that confirms that uh pertains to
134:12 - our rule of pre-order reversal where we
134:14 - start off with the root so indeed by
134:16 - printing I'll be by appending the
134:19 - starting point value which is roots
134:21 - value to the records list we are abiding
134:24 - by the rule set by pre-order reversal
134:28 - now let's go ahead now we want to do
134:30 - pre-order traversal upon the left
134:32 - subtree because remember when we were
134:35 - Computing a pre-ordered reversal we
134:37 - started off with the root then we went
134:39 - to the left subtree and we did pre-order
134:41 - traversal within that left subtree so
134:43 - now to compute the left subtree we need
134:46 - to do pre-order traversal in the left
134:48 - subtree so I have to do records equals
134:51 - pre self dot pre-ordered reversal so we
134:53 - have to do a pre-order traversal on the
134:55 - left subtree itself
134:57 - so the starting point now won't be the
134:58 - root it will be the left node left child
135:01 - of the root so I'm going to say start
135:02 - dot left
135:04 - so over here the starting point is root
135:06 - I am going to say start dot left we want
135:09 - to do a pre-order traversal on the left
135:11 - subtree itself so this is where
135:13 - recursion comes in recursion is the act
135:16 - of calling your own function inside the
135:18 - function so we're calling the pre-order
135:20 - method inside the pre-order method
135:22 - itself so over here we're doing uh start
135:26 - dot left so we want to do pre-order
135:29 - reversal on the left child on the left
135:31 - subtree so
135:33 - how will this look like so we start off
135:35 - with five then we go left and we start
135:38 - off with number three and we do
135:40 - pre-order traversal on the sub tree over
135:42 - here so right now there's no subtree but
135:44 - let's say there was so I'm gonna move
135:46 - them
135:47 - to the right
135:49 - and over here
135:51 - I'm going to add one final uh item it's
135:55 - going to be let's say the number two
135:57 - and over here
135:59 - we have
136:01 - um two child nodes for this node three
136:03 - and let's say eight so over here
136:06 - we start off with the root tone append
136:09 - that to the records array and the first
136:10 - thing we have is the is the root perfect
136:12 - River it's working perfect
136:14 - so now we move on to the left subtree we
136:16 - do pre-order traversal upon this node 3
136:19 - over here
136:21 - and that will call again that itself
136:23 - will call start dot left so it will do
136:25 - pre-order traversal on this left subtree
136:27 - itself so we are calling pre-ordered
136:30 - reversal on the left sum trees until we
136:32 - hit a leaf node until we eat a leaf node
136:35 - well self dot left is equal to none and
136:37 - we break out of this
136:39 - so that's the power of recursion so now
136:41 - we're going to do records so remember we
136:43 - had to compute root then left subtree
136:45 - and now we're going to do right simply
136:47 - so records equals pre-order
136:50 - start dot right
136:53 - and over here I also need to provide the
136:55 - records list itself as an input
136:59 - so now let's see how this works so I'm
137:01 - gonna
137:04 - list
137:12 - and I'm going to print the output given
137:17 - and if I run this file
137:20 - you see we get five three four so okay I
137:23 - shouldn't have deleted that comment over
137:25 - there so I'll just copy all of this and
137:27 - bring that tree
137:31 - okay there we go
137:33 - so let's paste all of that again so this
137:37 - is how the tree looks like five three
137:38 - four so we start off with the root note
137:41 - then we move left we compute that left
137:43 - subtree then we move right we compute
137:46 - the right sub tree so from root the left
137:48 - and then right even if we have a more
137:51 - complicated three like for instance
137:52 - we're gonna add uh let's say we had that
137:57 - the left sub tree within the node three
138:01 - so let's create that over here we're
138:03 - going to say tree dot root dot left
138:04 - which is node three for that node we're
138:07 - gonna add another left and that will be
138:09 - node
138:10 - node two
138:12 - and then three dot root dot left dot
138:15 - right it's right child will be equal to
138:18 - the node eight
138:20 - so even if we have this complicated
138:21 - expression how would the pre-order
138:23 - traversal work we'll start off with the
138:25 - root then we'll compute the left subtree
138:27 - and we'll do pre-order traversal on that
138:29 - left subtree so we go from root against
138:32 - 5 3 and then we start off let's subtree
138:35 - which is 2 and then eight so we should
138:37 - have the expected output to be 5
138:41 - then compute left subtree so that's
138:44 - we compute left sub 3 using pre-order
138:46 - traversal so that left subtree is three
138:48 - to eight so this is the left subtree
138:50 - over here
138:52 - uh if I can highlight just that part
138:55 - okay if I can't do that right now but
138:57 - let me delete that so the left subtree
139:01 - is this so how do we compute that left
139:03 - sub tree using pre-order traversal we
139:05 - start off with the root so three then we
139:08 - go to the left subtree of that left
139:11 - subtree which is two then we move to
139:13 - right
139:14 - okay and here it was I believe the
139:16 - number four
139:17 - and then we move on to the right subtree
139:20 - which is the number four and this should
139:22 - be the order of pre-ordered reversal so
139:24 - if I save and run you see we do get five
139:27 - three two eight four so this is what
139:30 - recursion looks like now if you still
139:31 - don't get it it's perfectly
139:33 - understandable because this is a
139:34 - complicated concept to grasp initially
139:37 - so I recommend you to move on to the
139:39 - next section understand recursion how
139:42 - recursion works and we'll be looking at
139:44 - a few algorithms dealing with recursion
139:46 - and then come back to this section where
139:48 - we will be talking about pre-order
139:50 - traversal again so in the next section
139:52 - we'll be doing post order traversal and
139:54 - then after that we'll do uh recursion
139:56 - we'll talk about recursion and the types
139:58 - of recursion algorithm algorithms so for
140:00 - all of that and more I'll see you in the
140:02 - next sections
140:05 - now I'll be doing the post order
140:07 - reversal which is quite similar to the
140:09 - pre-order traversal but except remember
140:11 - the fact that we have root over here
140:14 - that line corresponds to appending to
140:16 - root appending the route to the records
140:19 - list this is the left subtree
140:22 - feel like I've said that or not but uh
140:25 - yeah that's what recursions about doing
140:27 - things again and again so left subtree
140:29 - and this is the light right sub tree so
140:32 - this was the order in which we created
140:34 - the pre-order method
140:37 - and over here now to do Post order
140:39 - remember that's just left right and then
140:41 - the root so all we have to do is say
140:43 - Define post order
140:46 - in fact I'll just copy all of this
140:49 - and starts with self start and Records
140:54 - and let's paste
140:57 - and over here instead of putting
140:59 - records.pend first instead of
141:01 - registering the root first I'm gonna
141:03 - register the root last
141:07 - so now let's try post audit reversal of
141:09 - this uh binary tree so I'm going to
141:13 - print three dot post order
141:15 - tree dot root starting at the tree dot
141:17 - root and an empty array
141:21 - so if I run this you see we get um okay
141:24 - we get none because I did not return so
141:26 - let's return as well let's return the
141:28 - records
141:30 - and now let's run and you see we get a
141:32 - different order of traversal remember
141:34 - the tree order traversal for uh post
141:38 - order
141:39 - so how does post order work you start
141:41 - off with the left sub train okay this
141:44 - seems to be a problem
141:46 - it should start with two and then move
141:49 - on
141:50 - to write and then to the operation I
141:52 - think I have made a mistake over here
141:54 - okay yeah so
141:58 - yes so I forgot to change this to post
142:00 - order because we will be calling the
142:02 - post order instead of pre-order so I'll
142:03 - do Post order here and if I run this
142:06 - again you see we get the correct order
142:07 - of operations we start off with two then
142:11 - we move on to eight then three then four
142:13 - and then five
142:15 - so I'll do this one last time I'll give
142:18 - this a complete summary of the
142:19 - explanation if you've understood this
142:21 - completely congratulations you can move
142:23 - on to the next section where we will
142:24 - talk about recursion but uh I'll just I
142:27 - just want to summarize pre-order and
142:29 - post order one more time so pre-order
142:32 - this is how it works we have created
142:35 - this tree
142:36 - then we have the condition check if the
142:39 - stock is none or not root is no is not
142:41 - none so then we move into
142:44 - uh this if statement we append the route
142:47 - because pre-order starts off with the
142:49 - root then the left subtree and then the
142:50 - right subtree so we append the route
142:52 - first to our records array and the
142:55 - records array symbolizes the order of
142:58 - visits that we've done so we first
143:00 - append the root then we go down here and
143:03 - we say records equals self dot pre-order
143:05 - and we're essentially doing pre-order
143:08 - reversal on the left subtree itself so
143:10 - start dot left now we make this the root
143:13 - and three to eight we make that the left
143:17 - subtree and we do pre-order traversal on
143:19 - it itself
143:20 - then we do pre-order traversal on the
143:22 - right subtree and then we finally append
143:25 - the records uh then we finally return
143:28 - the records so that's how pre-order
143:30 - traversal Works post order is the same
143:32 - thing except we do the root at the last
143:35 - so I hope you get that and in the next
143:37 - section we'll talk about recursion
143:42 - so to get you more familiar with
143:43 - recursion I have prepared two problems
143:46 - in programming one is the Fibonacci
143:49 - sequence and the other is counting to a
143:52 - certain number so hopefully these two
143:54 - exercises will help you understand
143:55 - recursion which we will be using a lot
143:58 - in the later stage of this course so the
144:01 - first problem is the Fibonacci sequence
144:03 - now if you're not aware the Fibonacci
144:05 - sequence is a sequence of numbers that
144:08 - starts off with the first numbers being
144:10 - one
144:11 - and after that the from third number
144:14 - onwards
144:15 - the any nth number you take any nth
144:18 - number it's equal to the sum of its
144:20 - previous two numbers so the third number
144:22 - is the value three okay sorry the third
144:25 - number is the value 2 because 1 plus 1
144:27 - is 2. now the fourth number what is the
144:30 - fourth number equal to it's the number
144:31 - two plus the number one which is three
144:34 - the fifth number is the number three
144:36 - plus the number two which is five so
144:39 - that's how you construct a Fibonacci
144:40 - Sequence now how do we come up with a
144:44 - program that will tell you the value at
144:46 - a certain position that given a certain
144:48 - input like for instance the number four
144:51 - it will give spit out the value the
144:53 - number three
144:54 - so how can we come up with other such a
144:56 - program given an input of the position
144:59 - of the Fibonacci sequence it outputs the
145:02 - value of that Fibonacci Sequence so how
145:04 - can we come up with such a program so
145:07 - first of all I'm going to use a function
145:09 - I'm going to call create a function
145:10 - called Fibonacci
145:13 - and it will take in the position
145:17 - and it will return the uh
145:20 - value at that position
145:22 - so we're going to use recursion to solve
145:25 - this problem now let's take any position
145:27 - like this is the fourth position at the
145:30 - fourth position you're summing the
145:31 - second position and the third position
145:33 - values so we can Define Fibonacci the we
145:38 - can say Fibonacci or let's say output
145:41 - is equal to the Fibonacci
145:45 - of the previous position position minus
145:48 - one
145:49 - plus the Fibonacci
145:53 - of position minus 2.
145:55 - so we have an output we are recursively
145:59 - calling again this is recursion because
146:01 - we are calling a function inside a
146:02 - function we are saying okay the output
146:04 - is equal to the Fibonacci value at
146:06 - position minus 1 plus the Fibonacci
146:09 - value at position minus two so at
146:11 - position 4 it's the one previous to that
146:15 - which is the number two and two times
146:17 - previous to that which is the number one
146:18 - so one plus two equals three
146:20 - now this works for most cases but except
146:23 - for the first two scenarios where the
146:25 - first two scenarios
146:27 - the output is just equal to one so to
146:29 - handle this case I'm going to say okay
146:31 - if the position
146:33 - is greater than 2 or let's say greater
146:35 - than or equal to 3
146:37 - from here if it's greater than equal to
146:39 - 3 then we're going to use this
146:41 - expression else if it's not greater than
146:44 - or equal to 3 then I'm just going to
146:46 - return the number one because in that
146:48 - case it's either one or two and for both
146:50 - instances the output is one so we're
146:52 - using recursion to
146:55 - um handle to solve the Fibonacci problem
146:58 - we can return the output given a certain
147:01 - input so now a better way to write this
147:04 - is I am going to say output equals one
147:07 - output equals the following if it's
147:10 - greater than or equal to 3 output equals
147:11 - one if that's not the case and then at
147:14 - the end I'm just going to return the
147:15 - output
147:16 - so let's see let's test this out
147:19 - I'm going to say
147:20 - uh this response is equal to Fibonacci
147:24 - and let's say for the first number and
147:28 - that's pretty simple that should
147:29 - hopefully this uh respond with the
147:31 - number one and I'm going to print the
147:33 - response
147:36 - so if I run this you see we do get one
147:39 - pretty simple even if we do two we
147:41 - should get the same answer one
147:44 - now if I do 3 we should get the number
147:46 - two so let's see if that works
147:49 - I run you see we get the number two
147:51 - if I try the number four
147:54 - we should get three and indeed we do get
147:57 - three and if I try five we should get
148:00 - five
148:01 - as you can see over here let's try one
148:03 - more
148:04 - uh sixth number would be five plus three
148:06 - which is eight so if I do six here
148:10 - we'll get eight
148:13 - so that's how recursion works and uh to
148:16 - be honest this is not a very efficient
148:18 - algorithm because uh we'll have to
148:22 - eventually as the num as the input as
148:25 - the input number increases to maybe 40
148:26 - or 50 this thing will take a lot of time
148:28 - to process so 45 if I input 45 over here
148:33 - you see It'll take like a few seconds to
148:34 - process we're waiting for the output
148:37 - still waiting for it and uh
148:41 - yeah I'm still waiting for it and this
148:43 - will take a lot of time actually so um
148:46 - let's try out just let's let's just try
148:48 - 40.
148:49 - 45 seems to be taking a lot of time
148:52 - so let's try 40 over here and even this
148:54 - 2 will take a few seconds
148:57 - waiting for the output still and
149:04 - yeah there we go we get it after a long
149:06 - period of time I think that was like
149:07 - seven or eight seconds so yeah so you'll
149:10 - clearly see that this is not very
149:12 - efficient
149:13 - uh a more efficient way of solving this
149:15 - problem would be to save
149:17 - um the Fibonacci value at any position
149:19 - that you compute so if you compute the
149:21 - Fibonacci uh value at a certain position
149:24 - you save it in a data structure like a
149:27 - dictionary or something like that so
149:29 - that eventually when you need that same
149:31 - value when you want to refer to that
149:32 - same value you can quickly refer to it
149:36 - instead of computing it again in the
149:37 - Fibonacci function
149:39 - so then that trick is also known as
149:41 - memorization it's part of dynamic
149:42 - programming but I won't go too much into
149:44 - it because it's not very relevant to our
149:47 - course
149:49 - so yeah with that knowledge we've talked
149:51 - about recursion I'm going to go through
149:53 - one more problem and that'll be in the
149:55 - next section our second recursion
149:57 - problem deals with counting to a certain
149:59 - number so given the input 7 I want uh
150:03 - the program to count to seven so it
150:06 - should output one and then two and three
150:08 - and then four and then five all the way
150:09 - up to seven so to create this we have
150:11 - I'm going to use the function count to
150:13 - num
150:15 - and a very simple approach which is the
150:18 - iterative approach and it's pretty
150:19 - simple to understand as well is to run a
150:21 - for Loop now I hope you might be
150:23 - familiar with for Loops so in a for Loop
150:26 - you say for I in range num
150:30 - plus one in fact because the bound is
150:34 - not inclusive it's exclusive so we need
150:36 - to add by one and then I'm just gonna
150:38 - print I
150:40 - so that should work and if I run this
150:44 - let's count let's call this function as
150:46 - well I'm going to say count num
150:49 - count to let's say 10 and let's run this
150:52 - and you see we get one two three four
150:55 - five in fact I don't want it to be from
150:57 - zero so I'm going to say one to num plus
150:59 - one and let's run it this time you see
151:01 - we get one two three four five six seven
151:04 - eight nine and ten so that's the
151:06 - iterative way of solving this problem
151:08 - iterative way I can say that before it's
151:11 - the iterative way of solving this
151:12 - problem now let's come to the more
151:15 - complicated and to understand recursive
151:17 - way but hopefully it makes sense to you
151:20 - after this section
151:22 - so over here I'm gonna create the same
151:24 - function count to num
151:27 - this will take an input parameter now
151:29 - and we want to use a recursive way to
151:31 - solve this problem
151:33 - now bear with me while I'm quote this up
151:36 - I'll explain how what it all means so
151:38 - first I'm going to check if the number
151:40 - is greater than zero
151:42 - that's the first thing I'm going to do
151:43 - and if it is greater than 0 then I'm
151:45 - going to count to num calling the
151:47 - function again with the num minus 1
151:51 - and then I'm going to print the number
151:54 - and finally I'm going to count to num
151:57 - let's say 10 let's run this
152:00 - and you see we get the same output 1 2 3
152:03 - 4 5 6 7 8 9 and 10. so okay what what
152:07 - does all of this mean now
152:09 - in fact to make it more simple I'm going
152:11 - to use a number two first if you
152:13 - understand this you'll understand it for
152:15 - any number so let's run this again and
152:17 - the output should be 1 and 2. 1 and 2 as
152:21 - you can see over here
152:23 - so we start off with count to number two
152:25 - we give that as an input the number is
152:28 - equal to 2 and in this case the number
152:30 - is greater than 0 2 is greater than zero
152:32 - so then we count it up again so we say
152:34 - count to num num minus one at this stage
152:37 - within this Loop now what is num equal
152:40 - to num is equal to 2 but we're counting
152:43 - to num
152:44 - count underscore 2
152:47 - underscore num 2 minus 1 which is one so
152:50 - now recursive function we again count
152:53 - num we go back here is 1 greater than
152:55 - zero yes one is greater than zero and in
152:58 - this situation num is equal to one and
153:00 - now we count to num to zero
153:02 - okay bear with me for a second so num
153:06 - equals one and then we count to num we
153:08 - count to zero because one minus one is
153:10 - zero okay now we count them to zero
153:14 - we enter this function again is 0
153:16 - greater than zero no it's not greater
153:18 - than zero then we're gonna exit now over
153:21 - here we come back to this original
153:22 - situation where we had num equal to one
153:24 - and count from zero well count to num
153:27 - zero just return you just exited the
153:28 - function because number is not greater
153:30 - than zero so now we have processed line
153:32 - three we move on to line four what is
153:35 - num equal to num is equal to one at this
153:37 - point so it prints one okay we can now
153:40 - num is one now in the previous situation
153:42 - remember numbers two and count numbers
153:44 - one so after the after the after we
153:47 - process this num and after we exit this
153:49 - function we go back to the original
153:51 - position when count the numbers two num
153:54 - was equal to two and count number is one
153:55 - this line was processed just like before
153:58 - and num is two so we print two so print
154:01 - one and then print two
154:04 - it's it's difficult to understand
154:05 - initially
154:06 - but essentially what it's doing is it's
154:09 - counting uh it decrements so it goes
154:12 - from count to one so in the scenario but
154:14 - the count column is 10 we go from 10 to
154:17 - 9 to 8 to 7 to 6 to 5 to 4 to 3 to 1 to
154:21 - 0 when we hit zero num is not greater
154:24 - than zero and then we go back to the
154:27 - position in counter num is one now uh
154:30 - let me go back to the position where we
154:32 - print RAM and then count alarm is one
154:34 - and we go all the way up so while
154:37 - counting up decreases from 10 to 0 the
154:40 - uh printed output goes from one to ten
154:43 - so that's how recursion works it's
154:45 - definitely a much more difficult way of
154:47 - counting to a certain number but
154:50 - hopefully it makes sense to you now
154:52 - um after these two requesting problems I
154:55 - encourage you to revisit the pre-order
154:57 - and post order uh functions that I
154:59 - talked about in the binary tree and
155:01 - after we've understood all of that it's
155:03 - time to move on to the next section of
155:06 - the course so I'll see you there
155:10 - so in this section of the course we'll
155:12 - start by building our Alexa which as
155:15 - I've talked about in the previous few
155:17 - sections uh decodes the input string so
155:20 - let's say we give the input expression 5
155:23 - plus 3 our Pro this is a valid
155:26 - expression a valid input expression
155:28 - because our programming language should
155:30 - be able to do basic arithmetic so given
155:32 - this input the lexor or the tokenizer
155:35 - should be able to do lexical analysis
155:38 - and convert this into a list of tokens
155:42 - um five plus and three it should ignore
155:45 - any spaces like that and yeah that's the
155:48 - basic functionality of our lecture
155:50 - when we are making up making our
155:54 - programming language more extensive we
155:56 - are trying to include more functionality
155:57 - like strings or assignments variables if
156:01 - statements while loops and all of that
156:03 - kind of interesting stuff when we're
156:05 - doing that are we'll have to update our
156:07 - Alexa constantly but for now I'm going
156:09 - to create Alexa that will be able to
156:11 - process these numbers and these
156:15 - operations plus minus multiplication or
156:18 - division so for that I'm going to create
156:21 - a class called Alexa
156:25 - and this class will have the init method
156:29 - it will take itself
156:31 - which is the instance and it will take a
156:34 - second parameter which is the input text
156:37 - now over here I'm going to set text
156:38 - equal self.text equal to text
156:41 - essentially when I create the Alexa so
156:43 - if I do lecture equals Alexa and I give
156:46 - an input expression 5 plus 3. I'm
156:49 - assigning a property called text to self
156:52 - self being the instance itself and the
156:55 - value of that property will be equal to
156:57 - the input given over here which is 5
156:59 - plus 3 so that's what I'm doing with
157:01 - this line self.txt equals text
157:04 - now the next thing I'm going to do is
157:06 - I'm going to create a variable called
157:07 - idx and set it to 0.
157:10 - idx is the index of
157:13 - um
157:13 - of because when we're creating the rexer
157:16 - we'll have to iterate through each item
157:19 - of this um so this there's an input
157:22 - string over here we'll have to go
157:23 - through each character and to keep track
157:25 - of which character we're currently on
157:27 - I'm going to use this idx it's initially
157:29 - going to be 0 because indexing starts
157:31 - from 0 so if I uh the zeroth index of
157:34 - the string is equal to 5 the first index
157:36 - is equal to the space bar second index
157:39 - is this plus symbol and so on
157:41 - now I'm going to create a variable
157:43 - called tokens
157:44 - and that will be just an empty array
157:46 - where we will store all of our tokens
157:49 - now after that I'm going to set the
157:50 - current character Char and that will be
157:53 - equal to the tokens uh that'll be equal
157:55 - to the text
157:57 - idx self.idx so initially the current
158:00 - Char will be the number five the current
158:02 - character will be the number five then
158:04 - uh we'll have to create a function
158:06 - called move which will which will move
158:08 - to the next uh idx it will increment the
158:11 - index and once the index is increment
158:13 - incremented it will update the character
158:16 - the character will be this so the
158:18 - character keeps track of self.char keeps
158:21 - track of the current character
158:23 - and after that I'm going to create one
158:25 - more
158:27 - property and I'm going to say self dot
158:29 - token is equal to null and this will be
158:31 - the value of the current token and
158:33 - you'll see what this means in just a few
158:35 - minutes
158:36 - so after we've created the init method
158:38 - I'm going to create a method called
158:40 - tokenize
158:43 - which will convert this input text into
158:46 - the output tokens and this will take in
158:49 - self as usual
158:51 - now to iterate through each character of
158:55 - the string I am going to use a while
158:56 - loop and I'm going to say while the
158:59 - index is less than the length of the
159:01 - text
159:04 - um let's just do print self.index for
159:06 - now and if I run this and if I do Alexa
159:10 - Dot tokenize
159:12 - and if I run this
159:14 - you see okay so I I forgot to uh
159:18 - increment it so let's just increment
159:20 - over here
159:22 - and if I run this
159:26 - you see we get 0 1 2 3 4 0
159:30 - 1
159:32 - 2
159:32 - [Music]
159:33 - 3
159:34 - fold so we are going through each index
159:37 - of um
159:39 - of this input expression so let's remove
159:42 - all of that for now and now the first
159:44 - check I'm going to do so there are two
159:46 - data types as of now there's the number
159:49 - and there's the operator now a number
159:52 - Can it can be composed of multiple
159:54 - digits it can be this as well even this
159:55 - is a valid expression so
159:58 - a number can compose of a string of
160:01 - digits a combination of digits so one or
160:05 - more digits that's what defines a number
160:07 - so if we encounter a digit so if the
160:11 - current character
160:13 - is a digit now how do we check if it's a
160:15 - digit I'm gonna have to store all of the
160:17 - digits that exist let's say self dot
160:21 - digits equals zero one two three four
160:24 - five six seven eight nine so these are
160:27 - all the digits and then I can check if
160:29 - the current character is in self dot
160:32 - digits that means if it's if it's 0
160:34 - that's in self dot digits if it's 7 it's
160:37 - in self dot digits if it's eight it's in
160:39 - self dot digits now a better thing to do
160:42 - is since self dot digits the digits that
160:45 - exist is universal it doesn't change for
160:48 - each lecture that we create so a better
160:50 - thing to do is make this a class
160:51 - variable instead of an instance variable
160:53 - so over here I'm going to create digits
160:57 - and I'll just copy this string over here
161:01 - let's paste that let's remove that line
161:03 - and I'm going to do instead of doing
161:05 - self dot you just I'm going to do Alexa
161:06 - dot digits so if the current character
161:09 - is in Lexington digits for instance the
161:12 - first character is 5 it is in like
161:15 - certain digits then I need to extract
161:17 - the entire number the token is not just
161:19 - the number five the token is the entire
161:21 - number 5885 so we need to create another
161:25 - method that upon uh enter upon facing a
161:29 - number upon facing a digit this method
161:32 - will extract the entire integer the
161:35 - entire number
161:36 - so to do that I'm going to say
161:38 - uh the current token self-draw token
161:41 - which is set to none I'm going to make
161:42 - it equal to self dot extract number
161:47 - so let's create this method over here
161:49 - extract number
161:53 - so this extract number is if the current
161:56 - character is in digits like over here
161:58 - it's the number five extract number will
162:01 - extract the entire number 5885 so to do
162:04 - that we're gonna uh first of all store
162:07 - the number as a string
162:10 - and then while the current character
162:13 - is in a self dot digits
162:18 - lecture or digits my bad because this is
162:20 - a class variable
162:22 - and that's it for now and also I want to
162:25 - ensure that we are still in the within
162:27 - the text so we're not the index is not
162:29 - greater than the length of the text and
162:32 - self dot index is less than the length
162:35 - of self dot text
162:37 - if this is the case then I'm gonna add
162:40 - the number
162:41 - add the current character to the number
162:43 - now how do I increment the index
162:46 - so okay so when we hit the digit we call
162:50 - Self DOT number as self x dot extract
162:53 - number and then 5 the current uh
162:57 - character is 5 so that will be added to
162:59 - the string over here and the string will
163:00 - be 5. now how do I increment the index I
163:04 - can't just do self dot index plus equals
163:06 - 1 because I then also have to update the
163:08 - current character
163:10 - so I can do self Dot
163:13 - character equals self dot text self dot
163:16 - idx so updating it but we'll this is a
163:20 - common functionality we'll have to do
163:21 - this a lot of times we'll have to move a
163:23 - lot of times we'll have to move to the
163:24 - next character a lot of times so to move
163:27 - to the next character I'm going to
163:28 - create a method itself let's call it
163:30 - move
163:31 - and I'm going to say self dot idx plus
163:33 - equals one
163:34 - and if the self.idx is less than the
163:37 - length of the text
163:40 - then I'm gonna increment then I'm gonna
163:42 - update the value of the character
163:45 - set that to self.txt
163:47 - uh at the index position of the updated
163:50 - index which is plus equals one so
163:53 - whatever the index was before now it's
163:54 - incremented by one and the character is
163:56 - the next position so instead of doing
163:58 - this I'm just going to call Self dot
164:00 - move
164:01 - so that's our while loop essentially we
164:04 - still have to detect
164:06 - um floating Point numbers which have
164:08 - decimal points in them but we'll talk
164:10 - about that in just a few minutes
164:12 - so as of now I've set the number and
164:14 - then I can't just return the number over
164:16 - here
164:17 - because remember we want to store tokens
164:19 - tokens have two aspects to them they
164:21 - have the value and the type so now the
164:24 - type over here is an integer and the
164:27 - value is a number wouldn't it be better
164:29 - if we had a different class itself for
164:31 - the token where uh instead of returning
164:34 - number I can just return the token
164:36 - itself and given the number and the type
164:39 - let's say integer and that's it that's
164:41 - all we return and the token class
164:43 - handles the rest
164:44 - so for that I'm going to create another
164:46 - class let's call it token and I'll
164:48 - remove this over here
164:50 - let's create class token
164:54 - and over here we're gonna have an init
164:55 - method
164:58 - this token pass will have a value and a
165:00 - type
165:03 - let's let's do type first that makes
165:05 - more sense
165:07 - and over here I'm going to say self DOT
165:09 - type equals type
165:11 - self dot value
165:13 - equals value
165:16 - and I'm gonna do one more thing instead
165:19 - of returning a token I'll I'll just
165:21 - return
165:22 - um another class which is the class of
165:24 - an integer
165:25 - so I'm going to create a class called
165:27 - integer and this class will inherit from
165:30 - the token class
165:31 - so
165:32 - and I'll pass over here so instead of
165:34 - returning the token all I'm going to do
165:36 - is I'm going to return the integer
165:38 - itself the integer class itself now why
165:40 - am I doing this because the first of all
165:44 - integer floating points strings and all
165:46 - of these numbers inherit from The Base
165:48 - Class token because all of them have a
165:51 - type and a value so that's why I'm doing
165:53 - the inheritance and why I'm creating all
165:56 - of these subclasses the integer float
165:58 - strings is because these subclasses may
166:00 - have their own methods like for instance
166:02 - the integer class may have methods like
166:05 - converting an integer to a float the
166:07 - float class may have a method to convert
166:10 - a floating Point number to an integer so
166:12 - these classes will have their own custom
166:14 - methods if we have a class of a string
166:16 - which we will create later on this class
166:18 - string will also again inherit from the
166:20 - token and this class string may have its
166:23 - own additional functionality like for
166:24 - instance you have to concatenate two
166:26 - strings so this will we can write the
166:29 - method for concatenating two strings
166:30 - inside this class itself so that's why
166:34 - it's better to create these classes and
166:36 - have them inherit from the main token
166:38 - class
166:39 - now
166:40 - um if if I use the integer class over
166:42 - here and I have to pass the type and the
166:45 - value so the value will be number
166:47 - and type will be integer
166:50 - um like that now my problem with this is
166:53 - that even though I have defined the
166:54 - integer class I still have to pass in
166:56 - and that will always be the case so this
166:59 - is a form of code repetition how about I
167:01 - just passed the number and the integer
167:03 - class manages to do the rest
167:05 - so for that I'm going to use the super
167:07 - function so I'm going to call the init
167:09 - method again
167:12 - and this will take in just one parameter
167:13 - of the value
167:15 - and in the integer path itself I'm going
167:17 - to hard code the value int as the type
167:19 - so I'm gonna you do super which is the
167:22 - token class now in the token class I'm
167:24 - going to call the init method
167:27 - and the type will just be integer and
167:29 - the value will be whatever is passed
167:31 - over here so what am I doing with this
167:33 - I'm saying okay extract number and uh
167:36 - I'm gonna return a type integer the
167:38 - value of that integer is number over
167:40 - here which was which we extracted that
167:43 - is the value of this integer now over
167:45 - here when the init method is called when
167:47 - we create this class when we create this
167:50 - object the init method is called and in
167:52 - this init method the super classes init
167:54 - method is called which is the token
167:56 - class and here we assign type as int and
167:59 - value as value which is whatever is
168:01 - given over here instead of passing in
168:05 - hint every single time we create an
168:06 - integer which is a form of code
168:08 - repetition and is not varying it is not
168:10 - very efficient
168:11 - now let's try and handle floating Point
168:14 - numbers as well
168:17 - floating
168:23 - now let's try and handle floating Point
168:25 - numbers as well so a floating Point
168:27 - number will have a dot in them a decimal
168:30 - point in them and so I'm gonna first
168:32 - create a check is float as false
168:35 - because whether it's floating or not
168:37 - will depend on our output if it's a
168:39 - floating Point number we'll return a
168:40 - class of a float we'll return the float
168:44 - object and if it's not a floating Point
168:46 - number we'll return the integer object
168:48 - so over here is float is false and if
168:52 - the current character is in digits or
168:55 - self.char
168:57 - is equal to a decimal point
168:59 - so this is possible as well and if this
169:02 - is the case I'm gonna say
169:05 - um if self.r is equal to
169:07 - a decimal point that I'm just going to
169:09 - do is float equals true
169:12 - and I'm gonna add the current character
169:15 - as usual and now over here I'm gonna
169:17 - return the integer class if is float is
169:20 - false that means if not is float this is
169:23 - a way of checking if is float is false
169:25 - if not is float I'm gonna return an
169:27 - integer else if its float is true that
169:30 - means the number is a floating Point
169:31 - number then I am going to return a class
169:34 - of float and given number and now let's
169:36 - create the same class again I'm going to
169:39 - create a Class A float
169:43 - and the data type over here let's do FLT
169:47 - standing for float so that's integer
169:49 - that's float what next now in the next
169:52 - part we have to also talk about
169:53 - operations so the in car as of now
169:57 - arithmetic Expressions we can input
169:59 - numbers we can input operations so we
170:02 - need to deal with operations as well
170:03 - over here so I'm going to do L if
170:06 - um the current character
170:08 - in Alexa dot operations
170:13 - and let's store operations over here
170:18 - operations is equal to plus minus divide
170:21 - multiply
170:22 - so over here let's say self.token since
170:27 - these operations don't span for multiple
170:29 - characters like the digits they spanned
170:31 - for multiple characters you had five six
170:34 - seven or six seven eight three the span
170:36 - for multiple characters six seven and
170:38 - eight three but the operation is just
170:40 - one character so we don't need to call
170:42 - an external method over here all we can
170:44 - do is say search token is equal to first
170:47 - of all we need to create the operation
170:49 - class but the value will just be equal
170:51 - to the current character
170:56 - so now let's create the operation class
171:01 - this will inherit from the token class
171:03 - as usual
171:06 - self and value now let's call Super
171:09 - and in the init method
171:11 - I'm gonna pass operation up
171:14 - and the value will be whatever is passed
171:18 - so now I think this is pretty much it
171:20 - let's try and run it and see how it
171:22 - works
171:23 - actually one more thing I forgot to do
171:25 - is I forgot to return the token
171:29 - from the tokenized class from the
171:31 - tokenized method so let's go ahead and
171:33 - return self.token and now let's see if
171:35 - this works so I'm gonna run this
171:38 - and I'll create a shell in fact a
171:40 - shell.py
171:42 - and the shell.py will be used to
171:45 - interact with our programming language
171:46 - using the terminal over here
171:48 - so first I'm going to import from the
171:50 - lexap class I'm going to from Lexa
171:52 - import Lexa
171:55 - then I'm going to say tokenizer is equal
171:57 - to Lexa
171:59 - and over here I'm gonna run a while loop
172:01 - essentially taking input and input
172:04 - expression uh indefinitely until the
172:07 - user quits the program so while true
172:11 - tokenizer equals Elixir and we need to
172:14 - take an input expression so let's say
172:15 - text equals input
172:19 - Shadow script that's the name of our
172:21 - programming language if you remember
172:23 - so this is the input we're taking we
172:26 - will pass that input as a parameter to
172:28 - the lexer mac object to the Alexa class
172:31 - and over here I'm gonna do tokens equals
172:34 - tokenizer Dot
172:36 - tokenize
172:39 - and let's print the tokens so if I run
172:41 - this and let's do one plus one
172:47 - okay so it's still indefinitely uh
172:50 - present over here I think I made a
172:51 - mistake I did not move
172:54 - uh after the operation so over here in
172:57 - the extract number method I move to the
172:59 - next character and uh that we don't need
173:02 - to add another Movement we don't need to
173:04 - call move over here again after line 15
173:06 - but in Lexington operations I did not do
173:09 - that so I'll have to do search the move
173:11 - again and now let's run this see if it
173:14 - works
173:16 - I have to quit the program first
173:19 - and let's run let's do one plus one
173:21 - and okay another problem here we don't
173:24 - have to return self token with returns
173:26 - after tokens and over here in the while
173:29 - loop after we've
173:31 - um uh received the next token I'm gonna
173:33 - append to its F1 to the tokens list
173:36 - so append self dot token so hopefully
173:38 - now it makes more sense let me just
173:40 - recap we run a while loop we extract the
173:43 - token uh the token can either be a digit
173:45 - or an operation and once we find that
173:47 - token we append it to the SAS dot tokens
173:49 - list and then we return self dot tokens
173:52 - so now let's run it hopefully it works
173:54 - this time
173:58 - if I run and the one plus one okay we
174:02 - get a list and these are the classes
174:04 - over here integer operation and integer
174:08 - again
174:09 - now this is a way an ugly way of looking
174:11 - at uh the classes so I'm gonna use
174:15 - another special method called the
174:17 - representation method and I actually
174:19 - forgot to talk about this in the uh in
174:22 - the object oriented implementation
174:24 - object-oriented programming
174:25 - implementation but essentially what this
174:28 - does is if I print the class itself
174:30 - the representation will be printed so
174:33 - now when I print the class I get this
174:36 - ugly representation but I can customize
174:38 - that representation using the repr
174:41 - method
174:43 - and the representation will just return
174:45 - the current value
174:48 - in the self.token pass and since all of
174:51 - these subclasses inherit from that these
174:53 - two will have the same representation
174:55 - so let's run it again
175:01 - if I run it now and do one plus one
175:03 - you see we get the tokens one comma plus
175:06 - comma 1. now a problem we'll hit is if
175:09 - we use spacebars so if I do one space
175:11 - one we haven't dealt with spacebars we
175:13 - haven't told the program how to process
175:16 - face bars so if I run this we'll see
175:18 - that
175:20 - we don't get any output so to handle
175:23 - this issue I'm gonna create a list of
175:25 - stop words and stop words are just
175:28 - chunks that you ignore because they're
175:31 - irrelevant to your program so over here
175:33 - I'm going to create stock quotes and for
175:35 - now stop for the only stop code Will Be
175:37 - A spacebar
175:39 - so over here I'm gonna say l if
175:43 - self dot character is in lexa.stop words
175:48 - in this case I'm going to move to the
175:50 - next character
175:52 - and I don't want to append anything so
175:54 - I'm just gonna break out of this
175:56 - iteration and move to the next iteration
175:58 - so I'm gonna hit continue
176:00 - so now
176:03 - if I run this again and now I do one
176:06 - plus one you see it still handles if I
176:08 - have multiple space bars it doesn't
176:10 - matter
176:12 - we still get the same output
176:14 - so that's basically it and apart from
176:16 - that yeah okay so that's basically it
176:18 - for the Alexa as of now we've handled
176:21 - floating Point operations as well
176:24 - and even I can do I can even do one
176:25 - prime two plus seven point eight and
176:28 - that two will work
176:30 - I can do 7.5 multiplied by 3 and that 2
176:34 - will work and you see we are lecture is
176:36 - working perfectly fine and this is a
176:38 - good base template to work from now
176:41 - whenever we have to add additional
176:42 - functionality like variables if
176:44 - statements and while Loops all we have
176:46 - to do is modify these classes modify the
176:50 - um while loop over here the contents
176:52 - inside the while loop and will be done
176:54 - so that's about it for this section
176:56 - hopefully you understood all of the uh
176:59 - code related to Lexa and now we'll move
177:02 - on to the parser how we can create a
177:04 - pass tree okay how we can create a tree
177:06 - to represent these arithmetic operations
177:09 - and then finally in The Interpreter
177:11 - we'll Traverse through the tree and
177:13 - compute the operations so for all of
177:16 - that and more I'll see you in the next
177:17 - section
177:20 - so in this section of the course I'll be
177:22 - working on the parser which will create
177:24 - a list representation of the binary tree
177:27 - so you remember how we talked about list
177:30 - representations and binary trees in the
177:32 - theoretical aspects of how the passer
177:34 - worked so it's good to just review that
177:36 - section but as just as a quick reminder
177:39 - let's say we have the expression 1 plus
177:42 - 2 multiplied by three the parser will
177:45 - create a binary tree using just lists
177:47 - one plus and then it will have a nested
177:50 - list inside of it 2 multiplied by 3 and
177:54 - this is effectively the list
177:56 - representation of the binary tree where
177:59 - the following highlighted bit is the
178:02 - right sub tree and this is the left node
178:04 - and plus is the root node so now let's
178:07 - create the class I'm going to say class
178:09 - passive
178:11 - and over here I'm going to define the
178:13 - init method
178:15 - which will take in self and the tokens
178:18 - and over here I'm going to say self dot
178:20 - tokens equals tokens
178:22 - now one more thing I'm going to do just
178:24 - like how we did it in the Alexa I'm
178:25 - Gonna Keep An idx and I'm also going to
178:29 - create a move method to keep track of
178:31 - our tokens previously in the lecture we
178:34 - did it to track the current character
178:35 - now we're going to do it to track the
178:37 - current tokens I'm going to say self.idx
178:40 - equals 0 and then self.tok token equals
178:44 - self dot tokens
178:46 - on the current idx now let's define the
178:49 - move method as well
178:51 - this will increment the idx
178:54 - and it's going to do if D self dot idx
178:57 - ft index is less than the length of the
178:59 - tokens
179:02 - only then is it going to update the
179:04 - token value
179:10 - so
179:12 - now let's go ahead and create the method
179:14 - for passing our tokens so this will be
179:17 - the method pass
179:21 - and this method will compute an
179:24 - expression now remember how we talked
179:26 - about non-terminals and the different
179:28 - types of non-terminals that we have we
179:30 - have the expression we have the term we
179:33 - have the factor so these are three
179:35 - non-terminals and we're going to create
179:37 - three different methods to define the
179:39 - grammar rules for each of these
179:41 - non-terminals so we're going to first of
179:43 - all return
179:45 - self dot expression
179:48 - this is like the highest non-terminal we
179:51 - want to compute the expression
179:54 - and over here I'm going to Define first
179:55 - of all let's define the factor
179:57 - non-terminal the factor non-terminal is
179:59 - pretty simple we're gonna check if the
180:01 - token type is of integer or float so I'm
180:04 - going to say if self dot token DOT type
180:07 - is integer or if it's float
180:15 - in that case I'm just going to return
180:17 - the current token so let's say the
180:19 - current token is the number five the
180:21 - factor will check if the number 5 is an
180:23 - integer which it is so then it's going
180:25 - to just return the current token and
180:27 - that is the factor now the term is
180:30 - slightly complicated
180:33 - remember how we defined a term to be a
180:35 - factor multiplied or divided by another
180:37 - Factor zero or more times
180:40 - so I'm gonna first say the left node of
180:42 - this term because right now let's say
180:44 - the term is
180:45 - okay let's just take an example 1
180:47 - multiplied by two over here
180:50 - we'll have 1 as the left node
180:52 - multiplication is 0 node and two so this
180:55 - is our list so the last representation
180:57 - of this will be one comma multiplication
181:00 - comma 2 and this is the term that we're
181:03 - talking about
181:04 - now how do we construct this term first
181:06 - of all we need to extract the left
181:08 - factors I'm going to say left underscore
181:09 - node is equal to self dot Factor
181:13 - then we're gonna move
181:15 - and then we're gonna say as of now I'm
181:18 - going to assume that there's only one
181:19 - multiplication there's only one operator
181:21 - but as you know the factors can be
181:24 - multiplied or divided by each other zero
181:26 - or more times so it doesn't necessarily
181:28 - have to be one so I'm gonna say self-top
181:32 - move so zero more times so the term
181:34 - could just as well be a factor itself so
181:37 - I'm gonna first of all say output
181:39 - equals left underscore node in the case
181:42 - where there is only the out there is
181:44 - only one node and they are not
181:46 - multiplied to another Factor zero more
181:49 - times so it's just a factor itself in
181:52 - that case the output will just be the
181:53 - factor but in this situation where the
181:57 - operation
181:59 - value is equal to multiplication or
182:02 - division
182:05 - in this situation where the operation is
182:08 - multiplication or division the output
182:10 - won't just be equal to the factor rather
182:13 - the output will be equal to first of all
182:15 - we need to save the operations I'm going
182:16 - to say operation equals self dot token
182:18 - then I'm gonna move self dot move
182:22 - then I'm going to say right unless
182:23 - control is equal to self dot Factor
182:26 - again
182:27 - and in this case now the output will be
182:29 - equal to this list so how we construct
182:31 - the output it'll be left node operation
182:34 - right node so I'm going to say output
182:36 - equals left node
182:38 - operation
182:39 - right node
182:42 - and now let's return the output
182:45 - so I hope that makes sense
182:47 - in the case where the term is equal to a
182:49 - factor there are no multiplication or
182:51 - divisions in that case we'll just return
182:53 - output as the factor but in this
182:56 - situation where there is multiplication
182:57 - division in between the operands in that
183:01 - case I'm going to make output equal to
183:03 - the left node
183:05 - left node multiplication which is
183:07 - whatever the operation is multiplication
183:09 - or Division and right ornament and then
183:12 - we're going to return the output and
183:14 - I'll remind you we're not talking about
183:16 - multiple operations so this cannot
183:18 - handle stuff like 1 times 2 times 3 it
183:20 - can only handle a simple expression like
183:22 - 1 times 2 where there are two operands
183:24 - and one operator now let's do the same
183:27 - thing for the
183:29 - expression
183:32 - and in fact I'm just going to copy this
183:34 - code because it's pretty simple too it's
183:36 - pretty similar to the same code
183:39 - and in fact one more thing I forgot to
183:41 - do was to move after the right node and
183:43 - why am I doing this so when I call
183:45 - self.t term in line 25 instead of self
183:49 - dot factor in the expression the left
183:51 - node will be self dot term I don't need
183:53 - to move after this so I'm just going to
183:55 - remove that self.move method that I'm
183:57 - going to call over there
183:59 - in fact I can do the same thing over
184:00 - here
184:01 - I'm going to do self dot move
184:03 - or or rather let's just leave it like
184:06 - this so whenever you're calling a factor
184:08 - you have to move after that because all
184:11 - of the factors return the token
184:13 - but whenever you're calling a term you
184:15 - don't need to call self.move because it
184:17 - is all self-doubt move is already called
184:19 - in line 19 after the right node so we
184:23 - don't need to call search dot move in
184:24 - this situation
184:25 - so that's it that should work now I as I
184:29 - just need to change this to plus or
184:31 - minus
184:33 - and let me save this and I'm gonna do
184:36 - I'm gonna run shell.py
184:39 - so let's run it
184:42 - let's do something like one plus two
184:44 - multiplied by four
184:47 - and okay I have to call the passer first
184:49 - false I'm going to import
185:08 - so there we go let's run it again
185:11 - 1 plus 2 multiplied by 4 and okay we I
185:15 - think I made a small mistake over here I
185:17 - forgot to change this to self dot term
185:19 - so let me save now
185:21 - and
185:23 - run it again hopefully it works this
185:25 - time one plus two multiplied by three
185:27 - less to 3 and in this case you see we do
185:29 - get this list
185:32 - so how does this work let's just go
185:34 - through it left node equals self dot
185:36 - term in this case the term is just equal
185:38 - to a factor because there is no
185:40 - multiplication or division following it
185:41 - so then the term is just equal to the
185:44 - factor one and that's what we store as
185:46 - the left node
185:48 - then we check for additional subtraction
185:51 - which is the case then we move to the
185:54 - operation store the operation and then
185:56 - we saw the right node is self dot term
185:58 - and this time when we compute the term
186:00 - there is multiplicational division and
186:02 - that's why the term returns a nested
186:04 - list so this works perfectly fine this
186:07 - is in fact how our binary tree will look
186:09 - like even if we do one multiply by two
186:11 - plus four the this is the exact this is
186:14 - exactly how the binary tree will look
186:16 - like when we convert the python list to
186:19 - the binary tree but we haven't solved
186:21 - one problem which is multiple operations
186:24 - as of now we're only checking if there's
186:26 - one Opera if there's one operation plus
186:29 - but let's say we do one plus two plus
186:31 - three you see we have a problem it's not
186:34 - giving the appropriate output so how do
186:37 - we solve this I'm going to make two
186:38 - changes first of all I'm gonna run a
186:40 - while loop
186:42 - I'm going to continuously check if
186:44 - there's addition or subtraction and I'm
186:46 - going to continue continuous
186:48 - continuously check if there's
186:49 - multiplication or division
186:51 - so those are the two changes two changes
186:54 - I'm going to make and one final change
186:55 - I'm gonna make and I'll explain what
186:57 - this means in just a second
186:59 - is I'm gonna do left node
187:02 - equals the following list and I'm gonna
187:04 - return let node
187:07 - I'm going to do the same thing over here
187:10 - I'm going to return left node and get
187:13 - rid of this output business
187:15 - and make left not equal to that so let's
187:19 - quit and run again and I'll explain what
187:21 - this means in just a second
187:23 - so 1 plus 2 plus 3
187:25 - you see we get 1 comma two plus three if
187:28 - I do one plus two plus three plus four
187:31 - we get the following output now how did
187:35 - this work so effectively by iteratively
187:39 - changing the value of left node every
187:41 - single iteration of the while loop we're
187:43 - changing the value of left node and
187:45 - we're assigning it the previous value
187:48 - but by doing that we're effectively
187:50 - pushing down the left node of the tree
187:53 - so
187:55 - let me construct the tree and show you
187:57 - how it looks like
188:08 - so this is how our tree looks like and
188:12 - by continuously updating the left node's
188:14 - value and assigning it what the previous
188:17 - subtree was
188:20 - so by continuously assigning this let's
188:22 - go through this one time
188:24 - so let's try one plus two plus three
188:27 - and in this case we get the left node as
188:30 - self dot term
188:31 - and search for a term over here is just
188:33 - the number one and then we run a while
188:36 - loop to see okay we each time we look
188:38 - for a plus symbol we store the operation
188:41 - we move and then we get the right node
188:43 - as self dot term again so this is one
188:46 - plus two is the
188:50 - um is the list over here left node
188:51 - operation right node but we assign that
188:54 - value to the left node so essentially
188:56 - that list itself becomes the left node
188:58 - and then plus and then the number three
189:01 - and by doing this iteratively for all of
189:04 - and by going down the left node every
189:06 - single time by reassigning the left node
189:09 - we are creating the right tree as you
189:11 - saw over here so that's the basic
189:13 - process we are to summarize again we are
189:16 - on in every iteration we are updating
189:19 - the value of the left node and we are
189:21 - assigning it the previous left node
189:24 - operation and right node so what we
189:26 - previously had like over here what we
189:28 - previously had was one comma plus comma
189:30 - two so whatever we previously had we
189:32 - assigned that to the left node itself
189:33 - followed by plus followed by three so
189:37 - that's the process we used to accept
189:40 - multiple additions so that we can say
189:43 - okay now of an expression is equal to a
189:45 - factor
189:47 - added or subtracted by another Factor
189:49 - zero or more times now we've dealt with
189:51 - that zero more times aspect to it so
189:53 - that's the basic uh summary of passing
189:57 - stage and now let's move on to the next
189:59 - section where once we have created the
190:01 - tree we'll have to Traverse to the
190:02 - through the tree so we'll have to do
190:04 - Post order traversal and follow that and
190:07 - more I'll see you in the next section
190:12 - so before we move on to the
190:14 - interpretation stage I made a few
190:16 - changes to our Alexa code instead of
190:19 - storing the tokens and the token types
190:21 - in the elixir of UI file I thought that
190:23 - would be better to store it as though as
190:25 - its own external file over here and
190:27 - that's the same same code except for the
190:29 - fact that in the representation method
190:31 - we return it as a string because the
190:34 - repr and there's also another method
190:36 - called string def unders underscore
190:38 - string
190:40 - self and they are pretty similar they
190:42 - have a few minute differences which I'm
190:44 - not going to go into but they're pretty
190:46 - similar in nature and so these both of
190:49 - these methods return output as only in
190:51 - string format they don't return integers
190:53 - or floating Point numbers so it's better
190:55 - if we clarify that over here and return
190:57 - it as a string itself although in the
191:00 - lexical analysis stage we did implicitly
191:02 - Define the number as a string and then
191:04 - pass a string over here uh it's just
191:07 - going to explicitly Define
191:09 - the output to be of type string so after
191:12 - that change let's move on to The
191:13 - Interpreter of py file where we will be
191:15 - creating our interpreter so over here
191:20 - I'm going to create The Interpreter the
191:22 - init method
191:23 - and this is going to take the tree as
191:25 - its input
191:29 - just like how the parser took the tokens
191:32 - as its input now The Interpreter will
191:34 - take the tree as its input so after that
191:37 - I'm going to create a method called
191:39 - interpret
191:42 - and the interpret method is responsible
191:44 - for computing our arithmetic expression
191:47 - so as of now I have not talked about
191:50 - brackets how you can compute expressions
191:52 - like
191:53 - OnePlus 2 in Brackets multiply by three
191:55 - now we haven't talked about these we'll
191:57 - talk about that in the next section
191:59 - but as of now we can we should be able
192:01 - to compute expressions like one plus one
192:03 - or 15
192:06 - minus 6 multiplied by 5 whatever we
192:08 - should be able to compute expressions
192:10 - like this after the interpretation stage
192:13 - so in The Interpreter we'll have to do
192:15 - Post audit reversal now if you remember
192:18 - how the tree representation looked like
192:20 - let's say for an input 1 plus 2
192:23 - multiplied by 5 the tree representation
192:25 - would look something like this you'll
192:27 - have one over here you'll have plus and
192:30 - then you'll have a nested list to
192:33 - multiply by
192:35 - fine so that's how our
192:38 - uh our nested list how that's how the
192:41 - parser creates the creates a
192:43 - representation of the tree
192:45 - and we have to now interpret this we
192:48 - have to Traverse through this tree and
192:49 - how are we going to Traverse it using
192:51 - the post audit reversal method and if
192:53 - you recall post order traversal refers
192:55 - to the fact that you have to Traverse
192:57 - through the left subtree then the right
192:59 - sub tree and then after that if the
193:01 - Traverse you have to go to the root node
193:03 - now let's for a second assume there are
193:07 - no sub trees and let's just read the
193:09 - binary tree with two levels so there'll
193:11 - be only two levels here there will be a
193:13 - root node let's say a
193:17 - and then there'll be B over here
193:22 - and see over here so let's just treat it
193:25 - it should be here
193:28 - that's better
193:31 - doesn't seem right
193:38 - yeah there we go so that's let's just
193:40 - assume that the tree is pretty simple it
193:42 - has two levels and there are no subtrees
193:44 - in such a situation how will we
193:46 - interpret it so an example of an
193:48 - expression like this would be
193:49 - one plus one or five plus six or some
193:55 - five plus six or something like that so
193:57 - how can we interpret such a simple
193:59 - binary tree so first of all we have to
194:01 - go through the left node then the right
194:02 - node and then the root node so to do
194:05 - that
194:06 - in post order traversal form we'll have
194:08 - to first go through the left node so
194:11 - left node
194:12 - and in our tree let's say we have the
194:16 - expression one plus one
194:18 - the tree would look something like this
194:19 - so the left node will be surf.3 the
194:22 - zeroth index so the first position over
194:24 - here that's the left node
194:26 - the right node is equal to self Dot 3 2
194:30 - so we are traversing through the left
194:32 - node then the right node and finally
194:33 - we'll go to the root node and we'll
194:37 - compute the root node by adding the left
194:39 - and right nodes so let's say the
194:43 - operator
194:45 - is equal to self dot three one
194:48 - and over here we can return compute
194:51 - binary this will have to create a
194:53 - function for this and self compute
194:56 - binary so given the left node right now
194:59 - and operator we this function will
195:01 - calculate then the output and return it
195:03 - so here we'll give a left node operator
195:07 - right now
195:09 - so
195:10 - this is the left subtree
195:13 - and a sub tree which contains only one
195:15 - node as of now this is the right subtree
195:18 - and this is the root node
195:22 - so that's our post order traversal now
195:24 - let's create the method compute binary
195:30 - so we'll take in the left node so left
195:33 - up and right
195:36 - now remember we can't do the following
195:39 - so if
195:40 - this is how it will typically look like
195:42 - so we'll say if the operation dot value
195:45 - is equal to addition
195:49 - then return left plus right so
195:53 - this is one way of doing it but it will
195:54 - be wrong because right now the left
195:57 - token is a string it's not even if we do
196:01 - left dot value over here
196:05 - and write dot value
196:08 - these token values are stored as strings
196:10 - remember over here we store the number
196:12 - as a string and then we stored the data
196:16 - type which is integer we in that we
196:18 - passed a string number so we can't
196:21 - perform this operation right now in fact
196:23 - we have to convert the left or right
196:25 - values into whatever that data type is
196:28 - like for instance
196:30 - if it's if if the expression is one plus
196:32 - one let's say so when given the
196:35 - expression one plus one the first token
196:36 - will have a value of 1 and a data type
196:39 - of integer so then we have to convert
196:42 - from a string to an integer we need to
196:43 - convert that value from a string to an
196:45 - integer so one way we could do this is
196:48 - we can say okay
196:49 - if
196:50 - left dot value left or type
196:54 - is equal to integer
196:57 - left equals int left
197:02 - L if left to type
197:05 - is equal to float
197:07 - left equals float left
197:12 - and then over here let's do if
197:14 - try to type
197:17 - is equal to end same thing
197:21 - and you you'll see now that this is
197:23 - pretty inefficient and will come up with
197:25 - a better solution but just to illustrate
197:26 - my point
197:27 - that's uh now let's go along with this
197:32 - if you write the type
197:39 - okay so after all of that mess and it's
197:42 - really disturbing to see to the eye but
197:44 - anyway
197:45 - after all of that mess
197:47 - let's do if operation
197:51 - dot value is equal to
197:54 - Plus
197:55 - then I want to return
197:58 - left
198:00 - right
198:02 - and let's just handle this one now so
198:04 - I'm going to save this
198:06 - and let's let's close this over here
198:09 - I'm going to delete this itself
198:12 - now I'm going to call The Interpreter so
198:14 - I'm going to say interpreter is equal to
198:17 - interpreter
198:19 - this will take in the tree
198:22 - and this should be small
198:25 - so interpreter
198:27 - dot interpret
198:30 - so then I'm going to say result is equal
198:31 - to that
198:33 - and let's print this result
198:36 - I'll save I'll click on run and let's do
198:39 - one plus one
198:41 - okay we get an error
198:44 - all right so this should have been
198:48 - left dot value and not left so left up
198:51 - value write dot value I am purposely
198:54 - doing this to show how inefficient this
198:56 - way is
198:57 - no I don't value okay here we go one
198:59 - more time
199:01 - one plus one and
199:05 - that seems to be a problem
199:08 - okay this has to be LF okay my bad let's
199:11 - run this one more time and hopefully it
199:13 - works again
199:14 - one plus one okay we get two perfect
199:17 - let's try five plus three we get eight
199:19 - but again this is a very in very
199:23 - inefficient way of doing this problem so
199:25 - how can we solve this issue where we all
199:28 - our task at hand is to extract the type
199:31 - of the of the of the data of the token
199:34 - and then depending on the type whether
199:36 - it's Intel whether it's float using that
199:38 - type we convert it to its necessary data
199:41 - integer or float so how can we
199:43 - accomplish this task
199:45 - so the first thing we need to do is we
199:47 - need to extract the type so I'm gonna
199:49 - say left
199:51 - underscore type is equal to left DOT
199:55 - type and right underscore type is equal
199:58 - to right DOT type okay so now we've
200:00 - extracted both types what next so there
200:03 - is a function in Python called get
200:04 - attribute and to show you how this works
200:07 - I need to create two methods before and
200:09 - then you'll understand how this works so
200:11 - let's say the first method is read
200:13 - underscore int and just bear with me for
200:15 - a second when I do this
200:17 - and it will take in a value
200:21 - and this will return the integer of that
200:23 - value
200:26 - and they'll be refine read underscore
200:28 - float
200:30 - and it will return
200:32 - floating point value
200:35 - so there is a method there's a function
200:37 - in Python known as get attribute
200:40 - and we are essentially trying to find a
200:42 - method within the self instance the name
200:45 - of the method is the second parameter
200:47 - what's the name of the method
200:48 - it's equal to read it starts off with
200:51 - read then there's an underscore but now
200:53 - we don't know what the latter part of it
200:55 - is
200:56 - I'm gonna say the latter part of it is
200:58 - equal to left underscore type
201:00 - and I'm going to call it and it seems
201:03 - like a lot but it's actually not not
201:05 - that much
201:06 - okay so what does this mean so over here
201:08 - I'm saying okay now left is equal to
201:12 - read underscore left underscore type so
201:14 - if left DOT type is let's say integer
201:16 - it will find the method read underscore
201:19 - int and it will call that method by
201:21 - giving the value of the token as a
201:25 - parameter over here so okay let's let's
201:28 - not complicated first over here so now
201:30 - I'm gonna say get attribute within this
201:34 - instance find the method read underscore
201:36 - left underscore type so left under Skype
201:39 - underscore type is equal to integer so
201:41 - find a method called read int within
201:43 - self and once you've found that method
201:46 - call that method and the parameter which
201:48 - is value with as passing the value left
201:52 - dot value
201:53 - so pass the value of let left as a
201:55 - parameter to the read underscore int
201:57 - method of the read underscore float
201:58 - method depending on what the data type
202:00 - of left is and I'm going to do the same
202:03 - thing for the right as well so get
202:04 - attribute self
202:07 - read underscore
202:09 - and over here we're going to do right
202:10 - type
202:12 - and the parameter I'm going to pass is
202:14 - the value of write so write dot value
202:17 - so there we go let's save this and I'm
202:20 - going to try and run to see if it works
202:23 - one plus one we get to same output but
202:28 - it's much more easier to look at and
202:30 - much efficient much more efficient code
202:31 - so now with that sorted out we have to
202:34 - again look at the interpret method
202:37 - because we have still have to figure out
202:39 - sub trees now if I do something like 1
202:41 - plus 2 plus 3 you see this will start
202:43 - giving errors because we haven't found a
202:45 - way to deal with subtrees so let's
202:48 - remember now let's consider a sub tree
202:50 - over here an expression which has a sub
202:52 - tree
202:53 - so 1 plus 2 plus 3 what is the list how
202:56 - will that list look like so let's create
202:58 - it so there will be one plus two
203:01 - and then after that plus three so that's
203:04 - how the list step presentation of this
203:07 - of the binary tree will look like one
203:09 - plus two plus three so that's the
203:11 - representation so until now we were
203:14 - thinking we were assuming that every
203:15 - single node will be just that will be a
203:18 - node there won't be any subtree but now
203:20 - a node can be the value the node can be
203:22 - a sub tree as well so how do we deal
203:25 - with such situations
203:27 - the first thing we need to know is that
203:29 - if it is a sub tree it will be it'll
203:31 - have a type of list notice that this is
203:33 - not a subtree this node is not a sub
203:34 - tree and that's why it has a type of
203:36 - integer but this node over here is a sub
203:39 - tree and that's why it has a type of
203:41 - list so we need to First detect whether
203:43 - a tree whether a node is a subtree or
203:46 - not so to do that
203:47 - let's first do it for the left node and
203:50 - I'm going to say if
203:51 - is instance
203:53 - I'm checking if the left node is an
203:55 - instance of the inbuilt class in Python
203:58 - the instance of the class list
204:01 - so if it is an instance of the class
204:03 - list then we know that we need to
204:05 - compute this nested list as well and to
204:08 - do that I'm going to use recursion
204:11 - so how are you how are you going to do
204:13 - it I'm going to say left underscore node
204:15 - is equal to self dot interpret calling
204:17 - this method itself
204:19 - and the parameter I'm going to pass is
204:21 - this nested list so I'm going to pass
204:23 - this nested list
204:25 - to the interpret method and it will
204:27 - treat this as its own separate tree it's
204:29 - going to compute it and that value will
204:31 - be stored in left node and if there is
204:34 - multiple subtrees it will go recursively
204:36 - down this process is known as recursive
204:38 - descent parsing by the way
204:40 - and it's gonna for every single time we
204:43 - have a new sub tree within a sub tree
204:46 - it's gonna go to each subtree compute it
204:49 - and eventually it's gonna come to this
204:52 - higher level this topmost node which
204:54 - with an interpreted value so once we
204:57 - interpret left node we need to do the
204:59 - same thing with the right node so I'm
205:01 - gonna say if
205:02 - is instance
205:04 - right node of a list if it is a list
205:08 - then I'm going to say write node is
205:09 - equal to self dot interpret
205:13 - right
205:14 - so there we go those are our two
205:16 - evaluations and now we can deal with
205:18 - subtree so I'm going to say
205:21 - evaluating less sub tree
205:25 - and this is evaluating
205:29 - write subtree
205:32 - so we're done with both instances over
205:34 - here and this is finally the root node
205:36 - operation
205:38 - so with that done
205:40 - it's time to run our code let's see if
205:43 - we run our code what output we will get
205:45 - but actually before that we need to also
205:47 - modify our compute bin method because as
205:49 - of now it's only having handling
205:51 - addition so we need to manipulate that
205:53 - as well
205:54 - so I'm gonna do L if
205:57 - op dot value
205:59 - equals minus
206:01 - return left minus right
206:06 - and if and in fact are not going to do
206:08 - return I'm going to store this is an
206:09 - output because this is an intermediate
206:11 - representation we still have one more uh
206:14 - one one more piece
206:16 - remaining so instead in fact I'm just
206:19 - going to store this as the variable
206:20 - output so I'm going to say output equals
206:22 - this
206:24 - left plus right output equals left minus
206:27 - right
206:28 - LF op.value is multiplication I'm going
206:32 - to say output equals left multiplied by
206:36 - right
206:37 - and finally LF
206:39 - op.value is division
206:43 - I'm going to say output equals left
206:45 - divided by right
206:47 - so and we're going to return output over
206:51 - here not not just yet let's let's keep
206:52 - this for now
206:53 - so I actually figured that'd be one
206:55 - problem over here notice that the
206:57 - interpret method is not accepting a
206:59 - parameter it's using the original
207:01 - self.tree as a default tree to work with
207:03 - but we don't want to do that in cases
207:05 - when there is recursion I want to pass
207:07 - in my own custom treat which is the
207:09 - subtree and I want the interpret method
207:11 - to process that subtree to process that
207:14 - nested list so how can we do that so I'm
207:17 - gonna come up with a efficient way to do
207:20 - this so instead of passing in
207:23 - the tree in the interpret method which
207:25 - is one way you could solve this problem
207:27 - rather I'm going to create a variable
207:29 - called 3 equals none and what this means
207:31 - is to say that if and if The Interpreter
207:35 - method does not get a parameter it's
207:37 - okay it's not going to throw an error
207:39 - it's just going to set the tree
207:40 - parameter to none and that's the first
207:42 - case over here when we don't
207:44 - provide a parameter so in the case where
207:47 - it is none if tree is equal to none
207:50 - 3 is none in this case I want to make
207:54 - self.tree
207:55 - tree equals self.3
207:59 - so if it is none we're going to make 3
208:02 - equals self.3 and we'll be working with
208:04 - only the tree we won't be working
208:06 - directly with self.tree
208:09 - let's remove that as well
208:11 - but in the case when it's not none like
208:13 - this situation where we are providing
208:14 - our own custom uh tree over here
208:19 - in the but in this situation when we are
208:22 - providing our own custom tree over here
208:23 - like left node and right node in these
208:25 - two situations it will be using the tree
208:28 - parameter that will be passed in line 36
208:32 - and line 41. so I'm going to save this
208:34 - and now let's go back to the compute bin
208:36 - method
208:37 - so in this scenario I don't want to
208:40 - return the output as a default python
208:43 - integer or a floating Point number
208:45 - instead I want to return it as my own
208:48 - class I want to return the integer
208:49 - floater operation because that's the
208:51 - point of having our own data classes so
208:55 - how can we do that now if the output if
208:58 - left or right are both type of integers
209:01 - then the output will definitely be an
209:03 - integer but even if one of them are a
209:06 - floating Point number then the output
209:07 - will be a floating Point number like for
209:09 - instance if left is equal to 2.5 and
209:12 - right is equal to 2 the output will be a
209:15 - float if left is equal to 2 and right is
209:18 - equal to 2 the output will be an integer
209:20 - and let's say if left is equal to 2.5
209:22 - and right is equal to 2.5 the output
209:25 - will still be a float so if if even if
209:29 - one uh even if one of these numbers is a
209:33 - floating Point number the output will be
209:35 - floating Point else it will be an
209:36 - integer so for this I am going to say
209:38 - return
209:40 - integer
209:42 - and see this is where separating the
209:46 - data as its own custom file makes sense
209:48 - because now I can import from this file
209:50 - itself so I'm going to say from
209:53 - tokens
209:55 - import integer and float
209:59 - so
210:00 - return the integer value
210:02 - of output
210:04 - if
210:05 - left DOT type left underscore type let's
210:09 - deal with those
210:11 - left underscore type and right
210:13 - underscore type
210:16 - um let's say left under the sky is equal
210:19 - to integer
210:21 - and right underscore type is equal to
210:23 - integer if both are integer return the
210:25 - output as in the format of integer else
210:28 - return the output is a float
210:34 - so now hopefully this works we have the
210:36 - compute bin method written up we have
210:39 - the interpret method written up using
210:41 - post order traversal and if I run this
210:44 - entire
210:46 - let's see if it works so if I do let's
210:49 - start off simple let's do one plus one
210:51 - we get two
210:52 - let's try 1 plus 2 we get three
210:55 - one plus two plus three we should get
210:58 - six
210:59 - which we do let's try
211:01 - one plus three times two
211:04 - and over here it'll be 1 plus 6 rather
211:07 - than 4 times 2 it'll be one plus six so
211:10 - that should be 7 which we do get and I'm
211:13 - gonna try floating Point numbers 2.5
211:15 - into 2 we get 5.0 notice that even if
211:19 - one of the numbers is floating point the
211:21 - output is printed as a floating Point
211:22 - number so there we go our entire
211:25 - function is working I'll do one more
211:27 - test to see if it's working and again
211:29 - the output is floating point so our
211:32 - interpreters working and for the first
211:33 - time we have a running program that can
211:36 - compute arithmetic or uh Expressions as
211:39 - an input so this is a huge step now
211:41 - because we have our basic Foundation
211:43 - laid out and after this things get very
211:46 - easy all we have to do is write down our
211:48 - grammar rules compute make modifications
211:51 - to the Alexa the parser and The
211:53 - Interpreter I removed the password yeah
211:57 - so all we have to do is make changes to
211:59 - the Alexa interpret return passer and we
212:01 - should be able to work with variables if
212:04 - statements and all of that so in the
212:06 - next section we're going to compute
212:07 - variables so of all of that interesting
212:09 - stuff I'll see you in the next section
212:14 - so click quickly before we move on to
212:16 - variables I also need to talk about left
212:18 - brackings and writing brackets and how
212:20 - we can use them to change our order of
212:22 - operations so over here in the
212:25 - operations I'm gonna also add in the
212:27 - pair of parentheses which are valid
212:29 - Expressions which are valid tokens as
212:31 - well
212:32 - oops
212:34 - all right there we go so which have
212:37 - added tokens as well so now let's go to
212:38 - the parser
212:40 - and over here
212:41 - how will the camera look like the
212:43 - grammar rule will be changed just a bit
212:44 - remember when we said that the factor
212:49 - is
212:50 - um we set up was just an integer
212:53 - zero one or two whatever it's just an
212:55 - integer well now it can also be a left
212:58 - bracket and a right bracket followed by
213:01 - an expression inside
213:04 - so
213:05 - uh and then these brackets you know can
213:07 - contain expression so to extract the
213:10 - expression we can use the Expression
213:11 - method now so over here I'm going to say
213:13 - l if self dot token that value is equal
213:17 - to the Open Bracket Open Bracket
213:21 - and in this case
213:23 - I am going to say surf dot move to move
213:26 - to the next token because the open
213:30 - record is not very useful we move to the
213:32 - next token which is the start of the
213:33 - expression then I'm going to say
213:35 - expression equals self dot expression
213:38 - now we have extracted the expression
213:41 - and with that with that extraction now
213:43 - we can return the expression
213:46 - so if I save and now let's go to the
213:49 - Shell and I'm going to run this file
213:53 - 1 plus 2 multiplied by 3 gives you 7 but
213:57 - if I now enclose this with a pair of
213:59 - parentheses you see we get one plus two
214:01 - plus three one plus two times three
214:03 - equals nine
214:04 - and we can even deal with uh multiple
214:07 - parentheses over here so if I have let's
214:09 - say
214:11 - 1 plus 2
214:13 - multiply by 4 divided by 6 we get 2.0
214:21 - so now finally we are going to be able
214:23 - to work with variables assigning
214:25 - variables and again as usual now we're
214:28 - going to use the same pattern we're
214:30 - going to start off with Alexa update the
214:32 - Alexa update the password and then
214:34 - finally update The Interpreter so to do
214:38 - this I'm gonna first talk about the
214:39 - grammar rules that that are involved the
214:42 - first grammar rule involved is in in
214:44 - terms of the variable is the fact that
214:47 - the Declaration is going to be made by
214:49 - the keyword make so like in stuff like
214:52 - JavaScript you have let you have VAR in
214:55 - Python you don't have a declaration as
214:56 - such but in our programming language
214:59 - Shadow script the Declaration will be
215:01 - make so it's going to be make and then
215:03 - the variable name
215:05 - and then that's gonna equal something
215:07 - let's say 50. so that's going to be our
215:11 - grammar rule for creating a variable so
215:14 - we're going to start off with make so
215:16 - for that we need to to accept these uh
215:19 - text based inputs we need to accept
215:21 - letters so for that we need to First
215:23 - create a constant over here to check if
215:25 - there is a letter or not
215:28 - letter so
215:37 - so with that we have defined the letters
215:39 - now let's go ahead and uh in the
215:41 - tokenize method I'm going to say l if
215:44 - the current character is in Lexa dot
215:48 - letters
215:49 - so in this case that there are two
215:51 - possibilities the first possibility is
215:53 - that the letter makes up the Declaration
215:55 - the second possibility is that the
215:57 - letter makes up the variable name so
215:59 - over here
216:01 - we need to ensure that we
216:04 - take care of both situations so I'm
216:06 - gonna say first of all we need to
216:08 - extract the entire board be it be the
216:11 - Declaration be the variable name so just
216:13 - like how we had to extract number method
216:15 - I'm gonna run an extract word from uh
216:18 - method over here so I'm going to say
216:19 - word is equal to self dot extract
216:21 - underscore word
216:24 - and let's create that method just below
216:26 - the extract number method so over here
216:28 - I'm going to say extract underscore
216:30 - method extract unscope word
216:33 - and over here I'm gonna say the word is
216:36 - equal to an empty string for now
216:38 - while the current character
216:41 - is in lexa.letters
216:44 - same thing as before
216:46 - and the current index is less than the
216:50 - length of the text
216:52 - in in these two situations
216:56 - if both are true then I'm going to say
216:58 - word
216:59 - plus equals the current character and
217:01 - then we're going to move to the next
217:03 - character
217:04 - and at the end I'm going to return the
217:05 - word itself
217:07 - so over here we have extracted the word
217:09 - and after that we have to check if it is
217:12 - part of the Declaration so let's create
217:15 - a list
217:16 - for declarations I'm going to say
217:18 - declarations as of now it's just going
217:20 - to be one item the make declaration but
217:23 - if we intend to have multiple
217:25 - declarations like in JavaScript you have
217:26 - let you have var2 declarations so if you
217:29 - have multiple of these uh maybe when
217:31 - then we have to update this list so for
217:34 - now let's keep it as a list
217:36 - and then I'm gonna say
217:39 - if word
217:41 - in declarations
217:44 - or Alexa dot declarations
217:48 - in this case I'm gonna set the token
217:51 - type to a declaration so I'm going to
217:52 - create that data type over here in the
217:54 - tokens.py file
218:01 - I'm going to copy this init method
218:06 - and the
218:07 - the name of the type will be decl
218:11 - standing for declaration
218:13 - so now I'm gonna say self dot token
218:17 - is equal to declaration
218:20 - and we'll pass the word as the
218:22 - Declaration and that's import this
218:24 - in our extra PMI file one more thing we
218:27 - need to import is the variable class and
218:29 - let's create that as well be
218:31 - the same as our previous classes
218:35 - and over here I'm gonna create variable
218:40 - and the name of this data type will be
218:42 - VAR standing for variable
218:45 - so now that we've imported the variable
218:47 - and we can move on to the next uh
218:50 - situation in the case when it's not in
218:53 - the Declaration so else I'm gonna say
218:56 - self dot token is equal to variable
219:00 - and now we have the token stored so I'm
219:03 - not going to run the rest of the stuff
219:05 - let's just print the tokens to see what
219:07 - we get
219:08 - so if I print tokens
219:10 - and one more thing minitro is is we need
219:13 - to handle equal signs so over here we
219:15 - have the equal symbol so that is another
219:17 - operation that I have added over here
219:19 - so now let's run the file let's run
219:22 - shell.py and I'm gonna write make a
219:27 - equals 50.
219:29 - and you see we get the Declaration make
219:32 - a equals 50 the tokenization process
219:34 - works just fine
219:38 - so now I'm gonna go back to the Alexa I
219:40 - think we're pretty much done with the
219:42 - tokenization process now let's go ahead
219:44 - to the passer where things get a little
219:46 - bit complicated
219:47 - now we need to
219:49 - um okay let's go to the passer now so
219:54 - to handle the uh to handle the variable
219:57 - assignment part how can we handle this
220:00 - so we need to create a new method I told
220:03 - you for every grammar rule we'll be
220:04 - creating a new method and now I'll be
220:06 - creating the grammar rule for a
220:07 - statement now variable assignment is a
220:10 - statement it's a type of statement there
220:12 - will be other types of statements like
220:13 - if statements while Loops there are
220:15 - different types of statements but one
220:17 - type of statement is the variable
220:20 - assignment so how can you handle these
220:22 - variable assignments so for that I'm
220:23 - going to create a method called
220:25 - statement
220:28 - if the first token so if self dot token
220:34 - DOT type is equal to declaration
220:39 - then this will be a variable assignment
220:41 - statement
220:44 - but if the self.tok token DOT type
220:48 - is equal to integer or if it's equal to
220:50 - float
220:55 - or if is equal to
220:57 - operation like for instance we can have
221:00 - the left brackets so if it's equal to
221:02 - operation in these situations in these
221:04 - three situations
221:05 - I'm gonna set the statement type to be
221:09 - equal to arithmetic expression
221:13 - so now in this situation you have a
221:15 - arithmetic expression in this situation
221:16 - you have variable assignment
221:18 - so
221:20 - the first thing I'm going to do is I'm
221:21 - going to call statement
221:24 - like so
221:25 - now over here in the Declaration I'm
221:28 - gonna one once we know that it is a
221:30 - declaration I'm going to move to the
221:32 - next token next token will be the
221:34 - variable name and to extract the
221:37 - variable name I'm just gonna create a
221:39 - new method called variable so I'm going
221:41 - to say left underscore node is equal to
221:43 - self dot variable and in fact we can
221:46 - create a binary tree of this as well so
221:48 - how will the binary tree of make a
221:50 - equals 50 look like it looks something
221:51 - like this so we have the equals operator
221:54 - and then we have
221:57 - uh we have
222:00 - that connection
222:02 - and then a
222:05 - and let's do
222:08 - 50 over here so that's the binary tree
222:11 - of a make a equal 50. so now left node
222:15 - is equal to variable name so self dot
222:17 - variable will extract the variable name
222:19 - then we have to move after that
222:23 - and then the operation
222:25 - we have to check if
222:27 - self dot token DOT type is equal to
222:31 - operation or let's just say
222:34 - if the value is equal to equals
222:40 - in this case I'm going to save the token
222:42 - so I'm going to say operation equals
222:44 - self dot token
222:46 - and over here finally I'm going to after
222:48 - we save the operation I'm going to say
222:50 - self. move move to the next token and
222:54 - then the next token can be any
222:55 - expression it can be an arithmetic
222:57 - expression it can be just 50 or it can
222:59 - be 5 plus 7 minus 3 multiply by 4 so we
223:02 - need to extract that expression so I'm
223:04 - gonna say right underscore node
223:08 - is equal to self dot expression
223:11 - so finally I'm just going to return the
223:14 - list
223:15 - left underscore node operation
223:21 - so now we've extracted the statement and
223:24 - if it's not an assignment statement and
223:27 - this is going to do
223:28 - self return self dot expression
223:34 - so let's save
223:36 - and I'm going to delete and I'm gonna
223:38 - run the parser now just see how the
223:40 - passer looks looks like
223:42 - so if I save this and let's just run it
223:44 - to see if we get any errors first of all
223:47 - make
223:48 - a equals 12.
223:51 - and we don't get narrow okay we haven't
223:52 - defined the variable let's just Define
223:54 - that really quick
223:56 - so here the variable method
224:00 - all it will do is it will first move
224:02 - because right now
224:05 - um over here declaration okay so we have
224:07 - already moved from the Declaration and
224:09 - now the variable method will check for
224:12 - the it will extract the token so it's
224:14 - going to say if the self.token DOT type
224:19 - is equal to VAR that means if it's a
224:21 - type of variable
224:22 - in that case we're just gonna return the
224:24 - self dot token
224:27 - so now let's check this if I clear and
224:30 - run again
224:31 - make a equals 12 you don't get any error
224:35 - you know the tokenization has worked
224:37 - perfectly now if I print the tree
224:39 - you'll see what I meant by when I said
224:42 - order of Precedence the
224:45 - um how we computed and all about the
224:47 - trees and when I talked about
224:50 - putting the expression it's been in a
224:53 - nested list in uh and the Declaration in
224:56 - an outer list so that's how it looked
224:58 - like so if I run this now and I say make
225:00 - a equals 50.
225:04 - and I run it you see we get a equals 50
225:07 - over here
225:08 - and for now you can't see it but let's
225:09 - do make a equals 1 plus 2 multiplied by
225:13 - 5 you see now this expression is in a
225:16 - nested list it has higher precedence
225:18 - it's computed first and then after that
225:21 - the assignment works because we don't
225:23 - want to make a equal one and then
225:24 - compute we don't want to make a equal
225:26 - one and then compute the rest of that
225:28 - expression that makes no sense we want
225:30 - to compute the entire expression and
225:32 - then whatever the answer of that is we
225:33 - want to assign that value to the
225:36 - variable a so now we've modified the
225:38 - passer we have modified the Alexa and I
225:41 - hope that makes sense now let's go on to
225:43 - The Interpreter where we will be storing
225:45 - the variables in a dictionary so as of
225:48 - now we can compute basic arithmetic
225:50 - expressions and we have also deal with
225:53 - the code delt we've also dealt with the
225:56 - code regarding the tokenization and the
225:58 - parsing so let's say I create a variable
226:03 - and I will make a equals 5 so as you can
226:06 - see the parser and the tokenizer are
226:09 - working fine if I do make a equals
226:11 - something like 7 minus 2 then it knows
226:15 - that it has to encapsulate seven and two
226:18 - into its own nested list so we've dealt
226:21 - with the parser and the tokenizer now
226:24 - it's time to move to the interpreter but
226:26 - I realized just a few problems with our
226:28 - current code and I'm gonna fix them
226:30 - right now the first problem I noticed is
226:32 - that in the Alexa we are storing the
226:35 - variable and we're giving it only one
226:37 - value but in the tokens the type of the
226:41 - variable is just bar so effectively
226:43 - we're not specifying the data type so
226:46 - say for instance it's a variable with
226:48 - data type of integer so it's let's say
226:51 - we make the statement make a equals five
226:54 - so then the data type is integer and the
226:57 - value is 5 but in this case the data
227:00 - type we've kept it as VAR which is
227:02 - stands for variable and the valuable
227:04 - started as the variable's name so that's
227:07 - problematic we need to store three
227:09 - things over here we need to store first
227:10 - of all the variable name
227:13 - second of all the fact that it is a
227:15 - variable so R and third of all we need
227:18 - to store its data type
227:21 - now as of now like for instance let's
227:23 - take the example make a equals five we
227:26 - have not uh computed the expression over
227:29 - here so we don't know what the data type
227:31 - is it could be a float it could be a
227:32 - integer so we don't know what the data
227:34 - type is so initially what we have to do
227:37 - is set it as an empty data type and I'm
227:39 - going to do that using a question mark
227:41 - so how am I going to represent data type
227:44 - and variable well I'm going to say
227:47 - VAR
227:49 - and then I'm going to give a pair of
227:51 - parentheses and I'm going to give a
227:52 - question mark because we don't know the
227:53 - date of my data type as of now so this
227:56 - is what we're going to set the data type
227:58 - to as of now but later on in the
228:00 - interpretation stage when we have
228:02 - computed the value when we've computed
228:04 - this expression we're going to replace
228:06 - that question mark with the actual data
228:08 - type so that's the first change I want
228:10 - to make and over here let's go to
228:13 - the Alexa
228:15 - and yeah so so that was the only change
228:18 - I had to make so now the Alexa over here
228:20 - it will create variable from the word
228:22 - and in the tokens dot py file it'll
228:25 - it'll give the date time with VAR
228:27 - followed by a question mark over here
228:30 - now with that done let's move on to the
228:33 - next step now since we have changed our
228:35 - variable over here in the tokens we've
228:38 - created the type
228:40 - in such a manner we've changed it we
228:42 - cannot be checking for self.token.type
228:45 - to be equal to variables instead what we
228:47 - can check for is if it starts with the
228:49 - three letters VAR
228:51 - so we can use the starts with method
228:55 - which is an inbuilt method for strings
228:57 - in Python and this will check if the
229:00 - string starts with the three characters
229:02 - V A and R so similarly I just find the
229:06 - other instances where we have created VR
229:09 - and as you can see over here
229:11 - another instance so I'm gonna instead of
229:14 - making it equal I'm going to check if it
229:16 - starts with
229:18 - the variable
229:22 - and that's it so now that we've done
229:25 - this and now that we've changed the
229:27 - tokens.py file and updated the
229:30 - interdependencies it's time to move on
229:32 - to another file which is called the
229:34 - data.py file now the data.py file will
229:37 - be storing all of the variables in a
229:40 - class so this class will contain a
229:42 - dictionary and this dictionary will be
229:44 - keeping track of all the variables and
229:45 - their corresponding values so for that
229:48 - we need to go to the shell.pify file and
229:50 - we need to create or we need to create
229:52 - an instance of the data.priva file
229:54 - before the while loop we can't keep it
229:57 - in the while loop because if we keep the
229:58 - instance in the while loop the data
230:00 - would refresh every single time we get a
230:02 - new input but rather than doing that we
230:04 - want to keep track of the previous
230:06 - inputs as well so here I'm gonna say
230:09 - from data import the class data and I'll
230:14 - create it in just a second
230:15 - and over here I'm going to say base
230:17 - equals data so we're creating an
230:19 - instance of that data so I'm going to
230:21 - create class data
230:25 - and set the init method
230:30 - like so itself and we won't be taking
230:33 - any properties the only thing I want to
230:35 - run the first time the instance is
230:37 - created is I want to create the
230:39 - variables dictionary and set it to an
230:41 - empty dictionary
230:43 - so let's save that and the base is also
230:46 - set now I'm going to uncomment The
230:49 - Interpreter and pass the base as an
230:53 - input to The Interpreter
230:55 - so now The Interpreter can deal with all
230:58 - of the data so it can write to the
231:00 - dictionary when when like the action
231:04 - over here initially was with addition
231:07 - and subtraction the action was to add
231:08 - two numbers but in this time we have to
231:11 - deal with memory we'll have to add to
231:13 - the dictionary we have to interact with
231:14 - the dictionary and for that we need
231:16 - access to the base variable and that's
231:18 - why we're going to accept that base
231:20 - variable over here
231:22 - and we're going to interact with the
231:23 - base variable we're going to interact
231:24 - with the dictionary add variables to the
231:26 - dictionary change the values of
231:28 - variables to the dictionary and read
231:29 - from the dictionary so I'm going to say
231:31 - self.data is equal to base
231:34 - so that's it in terms of The Interpreter
231:37 - now let's go ahead and write the code
231:39 - for the data.py file so variable dot
231:42 - value refers to the variable name and
231:44 - now let's go ahead and refer now let's
231:48 - go ahead and save the data to the
231:50 - server.variables dictionary so I'm going
231:51 - to say surf top variables
231:53 - and in this the variable name is going
231:57 - to be the key and the value is just
231:59 - going to be the expression
232:01 - so that's what we've done we're done
232:03 - with the right method and now we're done
232:05 - with the data class itself it's time to
232:08 - move to The Interpreter where we have to
232:11 - save our data and sometimes you want to
232:14 - retrieve the data like for instance so
232:16 - we have two tasks now the first task
232:19 - is to save data like for instance if we
232:21 - have an expression make a equals 5 we
232:23 - need to save the value of a into this
232:26 - data dictionary and the second task is
232:30 - if we have it say another expression
232:32 - make D equal a plus one in an expression
232:35 - we need to be able to
232:37 - parse we need to be able to understand
232:39 - the value of a variable so in the past
232:43 - of py file we have to update our grammar
232:46 - to say that even if the even if the the
232:50 - gram we have to update the grammar in
232:53 - such a way that thing that a factor can
232:55 - be an integer it can be a float it can
232:57 - be an expression within a pair of
233:00 - parentheses also it can be a variable
233:03 - itself so it can start with the variable
233:05 - itself so that's the only chain I've
233:07 - changed I've made to the past of py file
233:09 - and I've written self dot token if it is
233:12 - a variable so this will just return the
233:13 - current token corresponding to the
233:16 - variable so that's it in the pastor py
233:18 - file and
233:20 - now we need to work with the
233:21 - interpreter.py file modify it so that we
233:24 - can be able to create new variables and
233:26 - read from the data py file when
233:29 - necessary uh during this expression
233:31 - during Computing during the compilation
233:33 - of such expressions
233:35 - so for all of that and more I'll see you
233:37 - in the next section so now in The
233:38 - Interpreter of py file I'm gonna treat
233:40 - the equal symbol similar to a binary
233:42 - operation there's a left part and the
233:44 - right part and we have to do some action
233:46 - with the operation the action being we
233:49 - have to set the left hand side equal to
233:51 - the right hand side and we have to save
233:53 - the data in the data.py file so how are
233:56 - we going to do this we can't make an
233:58 - alif and put it over here because we'll
234:00 - have we'll face problems in line 22 and
234:02 - 23 because they are reading the data as
234:05 - Floats or integers but now these are
234:07 - variables so before we hit line 22 and
234:10 - 23 we have to compute the variable
234:13 - assignment so over here I'm going to say
234:14 - if the operation of value
234:16 - is equal to an equal symbol now in this
234:20 - case what I'm going to do is I'm finally
234:21 - going to update the in in over here I'm
234:25 - going to replace the question mark with
234:27 - the actual data type
234:28 - notice that the right type is already
234:30 - computed we've already computed the type
234:34 - of the right hand side which is the
234:35 - expression so once you've computed the
234:37 - expression like for instance let's see
234:39 - the expression is
234:41 - make a equals 5 the right hand side is
234:44 - the expression the type of that is
234:46 - already computed in right DOT type and
234:48 - in right underscore type stores that in
234:50 - a string format so over here instead of
234:53 - the first thing I'm going to do is I'm
234:54 - going to update the variables type so
234:57 - how am I going to do this I'm going to
234:59 - say left DOT type
235:01 - remember left refers to the variable
235:03 - itself the token for the variable so I'm
235:06 - going to say left DOT type
235:08 - referring to here so left DOT type
235:10 - I'm going to update that left or type
235:13 - and I'm going to update that to equal
235:17 - VAR and then within the pair of
235:19 - parentheses I'm going to put in the the
235:22 - type of the right hand side which is the
235:23 - expression so if the expression is an
235:25 - integer is a type of an integer the type
235:28 - of the variable will also be integer so
235:30 - over here I'm going to set it to right
235:32 - underscore type
235:34 - so there we go that's the first thing
235:36 - I'm going to do I'm going to update the
235:37 - left DOT type and the next thing I'm
235:39 - going to do is I'm going to write to the
235:41 - data.py file so how I'm going to write
235:43 - it I'm going to say self dot data dot
235:45 - right
235:46 - and remember we had two parameters the
235:49 - variable and the expression so the
235:51 - variable will just have to pass it as is
235:53 - so the variable token and the expression
235:55 - I'm just going to pass that as is as
235:58 - well so the expression will also have a
236:00 - type of a token because remember
236:02 - in Computing a binary we return so
236:05 - because these expressions are sub list
236:07 - so even they have to be computed first
236:09 - and in computation of a binary we return
236:12 - an integer or a float and therefore even
236:14 - the right
236:15 - even the right expression is not just a
236:18 - number it is a type of token either of
236:21 - integer or either a float so that's it
236:24 - we're gonna write the data to served to
236:26 - the dictionary
236:28 - in the data class and once we're done
236:31 - with that I am going to test this so we
236:34 - won't be we haven't completed task 2 yet
236:37 - reading variables but we have we have
236:39 - the ability to write two variables so
236:41 - now let's see and just to see if it
236:43 - works on I'm going to return something
236:44 - so after we write
236:46 - I'm going to return the read all so I'm
236:48 - going to I want to see the updated
236:51 - variables list updated variables
236:53 - dictionary so to do that all I'm going
236:55 - to do is I'm going to return
236:58 - self.data dot read underscore all
237:02 - so let's save it and I'm gonna go to
237:04 - shell.py now
237:06 - and I'm going to run this so if I do
237:08 - make a
237:11 - equals 5 there we go we have a
237:14 - dictionary if I don't make b equals 10
237:17 - that 2 will work this is the variable
237:20 - name and this is not a number don't be
237:22 - deceived by it that's just because we
237:24 - have set the underscore representation
237:26 - as a string of the value it's not a
237:29 - number instead it is the token class
237:32 - it's the instance of the token class
237:34 - it's the instance of the integer or
237:37 - float class
237:39 - so that's how we can create new
237:41 - variables now let's learn how we can
237:43 - read new variables so that we can even
237:44 - pass expressions like make b equal a
237:47 - plus 1.
237:49 - so to do that I'm going to go back to
237:52 - our interpreter of py file
237:55 - and remember we have made
237:57 - the exception of variables as factors
238:01 - we've coded that part in in the past wi
238:04 - file so now let's go ahead and do SEC
238:07 - part two let's handle challenge two in
238:09 - an expression like a plus one where we
238:11 - have to compute a variable we need to
238:13 - create a new method to read from a
238:15 - variable as of now in lines 27 and 28 we
238:18 - can compute methods we can compute an
238:21 - integer and a floating Point number
238:23 - using these two methods which are
238:25 - highlighted but we need to create a new
238:27 - method for reading a variable so let's
238:30 - read VAR
238:32 - and self and this will take in the ID so
238:35 - when we're calling it left dot value
238:37 - corresponds to the variables name so ID
238:39 - is what I'm referring to as the
238:42 - variable's name
238:43 - now the variable itself is equal to
238:46 - self.data.read using this ID because in
238:49 - this data.py file we assigned the
238:52 - variable the way the variable name is
238:55 - the key and the value we assigned it
238:57 - will be the expression and the
238:59 - expression is an instance of the
239:02 - classes integer or float
239:04 - so right now we have the variable
239:07 - we have the variable
239:09 - instance of integer offload now we need
239:13 - to extract the type so in Integrity type
239:16 - is n turn and floor T type is float so
239:19 - we need to extract that so I'm going to
239:20 - say variable underscore type is equal to
239:23 - variable DOT type
239:25 - so now we'll extract the type from that
239:28 - token remember over here we saved the
239:30 - token and the token could be integer
239:32 - float Now using that value I am
239:35 - extracting the type of the token whether
239:37 - it's integer or whether it's float and
239:39 - now from the read underscore VAR method
239:41 - I'm going to call read underscore in and
239:43 - read underscore float so over here I'm
239:45 - gonna say get attribute from the self
239:48 - itself I'm gonna say read
239:52 - and I'm gonna input variable underscore
239:55 - type as our variable in this string
239:59 - inside of here so we're going to embed
240:00 - variable underscore type in this string
240:02 - over here
240:03 - and so we need now we need to call it
240:05 - and we'll call it using the variables
240:07 - value itself
240:08 - so what is the value of the variable
240:10 - that is equal to variable
240:13 - um it's over here it's not it's equal to
240:15 - variable dot value
240:19 - corresponds to whatever the expression
240:21 - evaluates to type corresponds
240:24 - so value corresponds to whatever the
240:26 - expression evaluates to type corresponds
240:28 - to the type of that expression whether
240:30 - it's integer whether it's float
240:32 - so that's it so now we have the get
240:34 - attribute function we're calling the get
240:37 - attribute function and from the get
240:38 - attribute function we're calling the
240:40 - read underscore in and read underscore
240:41 - float methods now I'm just going to
240:43 - return this
240:45 - and hopefully this should work now so if
240:47 - I save and just one more change I need
240:49 - to do here just one more changes in
240:52 - let's look at 933 and 34 left underscore
240:55 - type in this case let's say it's a
240:57 - variable over here so what will left
240:59 - underscore type B equal to it'll be VAR
241:01 - int it'll be equal to
241:03 - VAR in
241:05 - but the method's name is underscore VAR
241:07 - it's not equal to VAR unders so how do
241:11 - we handle the situation so I'm just
241:12 - gonna say left type
241:14 - we're going to make it equal to variable
241:16 - the type will be equal to variable if
241:19 - the string starts with
241:23 - variable
241:25 - so even if the type is this I'm going to
241:27 - assign the even if type is VAR int I'm
241:29 - going to assign the type to be equal to
241:30 - VAR so that when we reach 934 and 33 and
241:34 - 34 rerunsco bar is called and not read
241:37 - underscore brackets int so
241:40 - this is what I'm going to do I'm going
241:42 - to call I'm gonna make the typewr
241:44 - instead of VAR end of our float whatever
241:48 - if it starts with bar as it's just the
241:50 - normal number and in that case I'm just
241:52 - going to return the type
241:55 - left DOT type
241:57 - and similarly I'm going to copy this
242:01 - paste it over here
242:03 - we have to do right this time
242:06 - and let's save and hopefully it works
242:08 - this time so now I'm going to clear
242:09 - everything
242:10 - Let's test our program out so I'm gonna
242:13 - run it
242:14 - let's make a equal to 5
242:17 - I'm going to make b equal to 10 and then
242:21 - I'm going to make c equal to a plus b
242:24 - and there we go C is equal to 15 and our
242:27 - program is successfully working
242:29 - so that's all about variables and next
242:32 - up we're going to talk about unary
242:33 - operators I left this thing out during
242:36 - evaluation of arithmetic Expressions but
242:38 - now we're going to talk about unary
242:40 - operators so for all of that and more
242:42 - I'll see you in the next section
242:46 - so unary operators are simply operations
242:49 - that occur on just one operand so an
242:52 - operand is like a number so a binary
242:55 - operation remember was 5 plus 2 that's
242:58 - binary operation the first operand is
243:00 - five second operand is two you have two
243:02 - operands and one operations five plus
243:04 - two is a binary operation a unary
243:07 - operation is something like plus five or
243:09 - it's something like minus five
243:12 - since something like plus five or minus
243:14 - five so to handle such Unity operations
243:18 - to handle such Unity operations I'm
243:20 - gonna change the factor a bit I'm going
243:22 - to modify this Factor method a bit to
243:25 - accept even an operation so a factor can
243:28 - now be equal to an integer it can be
243:30 - equal to an expression inside a pair of
243:32 - parentheses it can be equal to a
243:33 - variable it can also be equal to an
243:36 - operation plus another integer so over
243:38 - here I'm gonna do L if self dot token
243:43 - dot value or let's do type DOT type
243:46 - if it's equal to
243:49 - op if it's an operation
243:51 - uh what do you do in this scenario
243:55 - in fact I'm not just going to do
243:57 - operation I'm gonna
243:58 - um because in the Lexus of py file we
244:01 - defined even the equal the equal sign to
244:03 - be an operation so rather than doing
244:05 - that I'm just gonna use plus and minus
244:07 - because those are the two possible
244:08 - unitary operations you can have so here
244:11 - if it's Plus or if self dot token type
244:15 - is equal to minus in this scenario I'm
244:18 - gonna first store the operation operator
244:23 - equals self.token
244:25 - then I'm gonna self dot move
244:28 - and then I'm gonna do operand is equal
244:31 - to self not Factor again
244:34 - so if it's an integer it will just
244:37 - return self.token and we get the operand
244:40 - as let's say plus 5 plus will be the
244:42 - operator and then operand will be safe
244:45 - dot Factor will go back here and say 5
244:48 - is an integer so we get 5 and plus 5
244:50 - will be the operator plus operand now
244:53 - finally I'm going to return an array
244:55 - operator
244:56 - operand
244:58 - instead of using three items in one area
245:01 - now we're gonna have only two this is a
245:03 - unary operation the operator and the
245:05 - operand and we need to handle this
245:07 - special case in the interpret method
245:09 - over here I'm gonna say
245:11 - if
245:13 - the if the tree is an instance of a list
245:17 - first of all it has to be an instance of
245:18 - list so I'm gonna say if tree is an
245:22 - instance of a list and after that
245:26 - and the length of the tree
245:28 - is equal to 2 which means it's a unary
245:31 - operation only the operator and the
245:32 - operand
245:33 - in that case what I'm going to do is I
245:36 - am going to compute it now I'm going to
245:38 - compute the unary operation I'm going to
245:39 - say return self dot compute underscore
245:43 - unary
245:44 - and the operator
245:46 - will be 3 0.
245:49 - operand will be three one
245:53 - so let's Define compute unary
246:01 - this will take itself this will take in
246:06 - left or operator
246:09 - operand
246:11 - and this should just return the operator
246:14 - upon the operands of
246:16 - it should just do operator or in fact
246:18 - I'll I'll do it in this way I'm say if
246:20 - operator
246:22 - is equal to plus and this time you have
246:24 - to still check for Value if operated at
246:26 - Value is Plus
246:28 - I'm gonna return
246:30 - Plus operand
246:33 - and we can't do operand here directly
246:34 - because remember we still have to
246:36 - configure
246:37 - the the left and right the operand the
246:40 - same in the same way we configured the
246:42 - left and right values and so I'm going
246:44 - to copy all of this over here
246:50 - it can be equal to a variable as well
246:52 - plus a for instance
246:55 - so
246:56 - it's just going to be for the operand
246:58 - this time operand
247:00 - is equal to variable
247:03 - operand DOT type
247:05 - and operand type again
247:09 - so one final thing
247:13 - I'm gonna read
247:18 - operand again
247:24 - yeah so yeah okay so let's do operand
247:29 - and operand
247:31 - so there we go now L if the operator
247:36 - dot value
247:38 - is minus
247:39 - in that case I'm going to return minus
247:42 - operate operand
247:44 - so now let's run this function so I'm
247:46 - gonna
247:47 - say in this uh your return compute unary
247:49 - so this should work and one more
247:52 - exception is let's say we just input a
247:54 - number like one or let's say we input a
247:55 - number like two we can't handle that
247:57 - right now because we are assuming there
247:59 - is a valid binary operation there is an
248:01 - operation but there is an exception
248:03 - where the user just does not have any
248:05 - operations just one number inputed in
248:08 - that scenario I'm going to do L if
248:13 - um let's say
248:16 - L if
248:17 - not is instance
248:20 - of list if it's not even a tree in that
248:22 - case I am just going to return
248:25 - the tree
248:26 - so if it's not a list like for instance
248:29 - uh if there are if the only input is the
248:32 - number one
248:34 - the input is the number one
248:36 - in that case our tree will look
248:38 - something like this it'll just it'll
248:40 - just look like the number one but
248:41 - instead it's actually the integer class
248:43 - so it's the integer class with type of
248:45 - int and value one
248:48 - so it won't be a list it'll just be this
248:50 - one value over here so if it's not an
248:53 - instance of a list that means the user
248:55 - has just inputted the value one or the
248:57 - value of two let's just input is the
248:58 - number in that case I just want to
249:00 - return that out because you don't have
249:01 - any operation to do else if none of
249:04 - these are true
249:06 - we are going to do our usual binary
249:08 - operation
249:13 - so let's delete
249:14 - and this is the urinary operation
249:19 - and this is no operation
249:26 - so let's save and I'm going to run the
249:28 - shell
249:30 - if I do plus five I get none this time
249:33 - let's see where we went wrong let's
249:35 - print the tree actually see if that's
249:36 - working
249:41 - plus five no even the tree is returning
249:44 - none so there's a problem over here
249:46 - itself
249:47 - okay that's not tight that should be
249:49 - value not type so that's my mistake
249:53 - so I'm gonna close this again
249:55 - run it I'm going to do plus five
249:58 - okay and now we get a proper error this
250:00 - time let's let's look at this look into
250:02 - this one
250:04 - okay so it turns out I made two mistakes
250:06 - the first mistake is that I'd install
250:08 - this as a type this is actually the type
250:10 - not the operand itself
250:12 - and I'm going to run type again and the
250:14 - second mistake I made was in the parse
250:16 - method I did not so this is value I
250:19 - store this is type so I wrote
250:21 - self.token.type instead of self.token
250:23 - dot value so let's save now and
250:25 - hopefully it works this time so if I run
250:26 - again
250:28 - class 5 we get the output is 5 let's do
250:31 - minus five I get minus five I'm going to
250:33 - make a equal to 10. and then I'm going
250:36 - to do minus a and we get minus 10.
250:40 - so that works now we've computed unary
250:42 - operations and we've also handled the
250:44 - scenario where we have no operation like
250:46 - let's try no operation just the number
250:48 - one we get one outputed so another proof
250:52 - computed unary binary and no operations
250:55 - were effectively done with arithmetic we
250:58 - can do complicated arithmetic as well
250:59 - and we can handle variables we can store
251:02 - them we can read from them and now we've
251:04 - covered most of the basics we have some
251:06 - additional functionality to add but
251:07 - it'll be really easy now since we have
251:09 - the basic Foundation uh mapped out so
251:13 - now let's move on to the next section
251:18 - so in this section of the course we'll
251:20 - be talking about compare comparison
251:22 - operators and Boolean operators now
251:25 - Boolean operators we've talked about
251:26 - this way back in the start of the course
251:28 - where we talked about logic gates and we
251:30 - said that there are three main Boolean
251:32 - operators as the and gate the or gate
251:35 - and the not gate so in programming as
251:38 - well you require these three
251:40 - logic kits you require these three
251:43 - operators you require these three
251:44 - Boolean operators
251:45 - to perform logical operations like for
251:48 - instance I can find
251:49 - an instance over here where we use the
251:52 - logical operation in Python itself so it
251:55 - only seems viable to it only seems
251:58 - logical to give these operators to your
252:00 - users who will be using our programming
252:02 - language for them to for to allow them
252:05 - to
252:06 - create more useful and logical code so
252:10 - that's about Boolean operators
252:12 - comparison comparison operators and
252:14 - stuff like greater than checking if two
252:15 - numbers are greater than each other less
252:17 - than greater than n equal to less than
252:19 - equal to if two numbers are equally then
252:21 - to each other so these are the sort of
252:23 - checks that comparison operators do and
252:26 - remember all of this write down in the
252:28 - fundamental level is just a bunch of
252:30 - logic gates operating and that's why I
252:32 - had talked about logic gates in the
252:34 - start of this course
252:35 - so to manage these operators first I'm
252:38 - going to talk about the Boolean operator
252:40 - so we're going to first create
252:42 - a list of Boolean operators I'm going to
252:44 - say Boolean
252:46 - Boolean operators let's just do Boolean
252:50 - and over here we're gonna have ADD
252:52 - the second one is r and these third one
252:54 - is not
252:56 - and after that I'm gonna go to the
252:59 - tokenize method and over here
253:02 - these are examples of words so in this
253:04 - will come in the lecture dot letters
253:05 - condition and we first check if it's a
253:08 - declaration and if if it's not a
253:11 - declaration then we're gonna We're Not
253:12 - Gonna immediately assign it a variable
253:14 - for which gun check if it is part of the
253:17 - Boolean operator so I'm gonna say
253:19 - and if
253:22 - word in lecture or Boolean operators
253:24 - lecture of Boolean
253:27 - and then I'm going to set token equal to
253:29 - class Boolean
253:31 - and inputting the Boolean the name of
253:33 - the Boolean operator let's create this
253:35 - class Boolean
253:40 - and I'm gonna call it I'm gonna I'm
253:42 - sorry I'm gonna call the init method
253:43 - inside
253:45 - still taken self value
253:50 - and super not underscore in it
253:56 - Bool and value
254:00 - so let's say that and let's import
254:02 - Boolean
254:04 - from the data types that we've stored
254:08 - so after that now we're pretty much done
254:10 - with the lexor now let's move on
254:13 - to the passer
254:16 - in the passer instead of calling the
254:18 - expression method I'm going to call
254:19 - another another method called Boolean
254:21 - expression now what do the what is the
254:24 - grammar rule for Boolean look like the
254:26 - grammar rule will be like something like
254:28 - this so we'll have Bool
254:30 - expression and that will just be equal
254:33 - to
254:35 - a normal expression
254:38 - and then the Boolean operator name let's
254:40 - say and it can be or it can be not and
254:43 - that's going to be in small case and or
254:47 - not and followed by another expression
254:50 - so two expressions followed by the
254:52 - Boolean operator so to implement this
254:54 - I'm gonna create a new method let's call
254:57 - it Boolean expression
255:02 - Boolean
255:04 - underscore expression
255:06 - self
255:08 - so left underscore node
255:10 - equals self dot expression
255:13 - then while the current token same thing
255:17 - over here and we're doing a lot of copy
255:19 - pasting
255:20 - so it seems logical now to assign this
255:23 - same boilerplate code this uh basic code
255:28 - as its own method and then we call that
255:30 - method every single time instead of
255:31 - rewriting all of this code
255:33 - which kind of gets a bit messy now we've
255:35 - already done it Thrice so now after I
255:38 - create the Boolean expression and the
255:40 - comparison operator expression I'll be
255:42 - wrapping all of this code
255:44 - highlighted over here I'll be wrapping
255:45 - all of this code into its own new method
255:47 - and we call that method using in the
255:50 - Boolean expression in the normal
255:51 - expression method in the term method and
255:54 - so on so over here we're gonna call
255:57 - self.expression and if the token type is
256:00 - of Bool
256:05 - that's it that's the only check in that
256:07 - case the operation self.token and self
256:09 - dot expression over here
256:12 - so let's save and I'm gonna check if
256:15 - this works in the parser itself so I'm
256:17 - gonna comment Out The Interpreter okay
256:19 - it's already commented out and I'm going
256:21 - to run this
256:22 - okay I'm gonna run the shell
256:25 - if I run and now let's do
256:28 - the Boolean operator five and six
256:31 - you see that works
256:34 - okay it's only it it did not work
256:37 - um
256:38 - so type Bool left underscore node is
256:41 - self dot expression
256:44 - so the token the it seems to be working
256:47 - in the token the token seems to be
256:49 - working well the problem comes in parse
256:51 - okay that's because we haven't called
256:53 - Bool unsca expression my bad so wherever
256:55 - we have called expression now
256:57 - self dot expression wherever we will
256:59 - call that
257:00 - we're gonna replace that with bold on
257:02 - expression so over here
257:04 - I'm going to say self dot Bool
257:05 - underscore expression
257:07 - so let's replace it
257:15 - I think that's the name of our method
257:18 - yes it is Boolean expression
257:21 - so let's replace the first one
257:24 - second one let it be like that third one
257:26 - let it be like that and let's replace
257:28 - this one as well
257:29 - and this one as well
257:31 - so there we go
257:33 - I think okay there's one more remaining
257:36 - so I think that's it I'm going to save
257:38 - now
257:41 - and I think it should work this time so
257:43 - let's go to the Shell let's run
257:46 - let's run again
257:49 - and I'm gonna do five and two that works
257:53 - let's say if I do
257:57 - um five plus three
257:59 - or seven plus six and these operations
258:01 - don't mean anything as of now they only
258:04 - make sense when combined with the
258:06 - comparison operator so over here you see
258:08 - we get 5 plus 3 or is the Boolean
258:12 - operator seven plus six and notice I've
258:14 - given this higher precedence sorry lower
258:16 - precedence over the other operators I
258:18 - want this to be done last
258:20 - because that's how you do it you don't
258:22 - want to do three or seven and then the
258:24 - addition that doesn't make any sense you
258:26 - wanna give this the lowest precedence so
258:29 - now let's move on to the conditional
258:32 - operators
258:35 - so I'm going to say conditional or
258:38 - whatever I keep saying conditional it's
258:39 - comparison comparison
258:42 - comparisons let's do comparisons and
258:44 - then the first one will be greater than
258:45 - next one will be less than
258:48 - third one will be greater than and equal
258:49 - to
258:50 - fourth one will be less than or equal to
258:52 - and to check if two things are equal and
258:53 - python it's done as equal equal but in
258:56 - our programming language it's going to
258:57 - be question mark equal because I think
258:58 - that makes more sense
259:00 - we're checking if it's equal or not so
259:01 - we use a question mark
259:03 - so now we need to create another
259:05 - variable special characters
259:07 - and only if the character is in these
259:10 - special characters do we check if it's
259:12 - in the comparison comparisons list
259:15 - so let me greater than less than equal
259:18 - question mark so these are the four
259:21 - possible special characters now let's go
259:23 - over here and I'm gonna say l if
259:26 - L if self dot character
259:36 - dot special characters
259:38 - in that case
259:39 - I'm gonna make the
259:43 - compare
259:45 - comparison equal to an empty list for
259:48 - now comparison operator let's do there
259:49 - is an operator
259:51 - and over here I'm going to say while
259:54 - serve dot character is in Alexa dot
259:58 - special characters
260:00 - and self dot index is less than the
260:03 - length of the text
260:06 - in this case I'm gonna
260:08 - add the current character and then I'm
260:09 - going to move
260:12 - and finally I'm gonna
260:14 - token
260:16 - is equal to this time it's not going to
260:18 - be a Boolean it's going to be a
260:19 - comparison it's a comparison
260:22 - and we're going to feed In the
260:23 - comparison operator here let's create
260:25 - that as well
260:32 - comparison
260:35 - and I'm going to call this comp
260:37 - is the data type
260:38 - so let's import that finally comparison
260:42 - save and hopefully it works now so
260:45 - I'm gonna go back to the first of py
260:48 - and remember where in Boolean expression
260:51 - we called expression now we're going to
260:53 - call comp expression the comparison
260:55 - expression and comparison 2 is pretty
260:57 - similar in a comparison components per
261:00 - expression
261:02 - that's just equal to
261:04 - an expression
261:06 - greater than or equal to less than or
261:08 - equal to another expression you get the
261:10 - idea all of the
261:12 - comparative Expressions so we add a five
261:15 - in front of each of them and all of them
261:17 - together and followed by another
261:18 - expression
261:20 - so we are going to create one define com
261:23 - underscore expression
261:25 - so we'll take itself the left node will
261:28 - be self dot expression
261:33 - and now we need to change this to make
261:34 - it com underscore expression and comp on
261:37 - this expression
261:39 - expression left dot equals F dot
261:41 - expression and while
261:43 - self dot token
261:45 - DOT type is comp
261:48 - same thing I'm going to copy this
261:55 - and I'm going to do yeah that seems fine
261:59 - lastly we need to return the left mode
262:01 - so let's return left node
262:04 - and over here instead of calling
262:05 - expression I'm going to call comp
262:07 - underscore expression
262:12 - save it and let's try and running it
262:18 - I'm going to file let's check if Phi is
262:20 - equal to 5
262:21 - and 7 greater than 2.
262:24 - so it groups this first as expression
262:28 - and groups the second expression and
262:29 - checks and and adding the Boolean
262:32 - operator between both of them
262:34 - so for The Interpreter I created the
262:37 - following code it's really messy but
262:39 - essentially what I'm doing is the same
262:41 - as what I did before if left is greater
262:44 - than right I'm going to Output 1 which
262:46 - stands for True else I'm going to Output
262:48 - 0 and I'm going to continue for this for
262:50 - all of the binary operators except not
262:53 - now not all there is a Boolean operator
262:56 - is a unary operator because it does not
262:58 - apply on two different operands it
263:00 - applies on just one operand so to handle
263:03 - not we have to form a different
263:05 - mechanism over here so in the past the
263:07 - py file I created not for the unary
263:10 - operator
263:11 - and I said okay this is how we made plus
263:14 - M minus unary operators I'm going to
263:16 - make not a unary operator and return the
263:18 - operator and self the Boolean expression
263:20 - just like how I did over here so because
263:23 - you can also have an expression not just
263:25 - a factor like for instance you can have
263:29 - um not 5 equals five so the Expressions
263:34 - 5 equals 5 and not is the unary operator
263:38 - and it actually turns out that even you
263:41 - can have the same thing over here since
263:42 - you're falling self tough factor I think
263:44 - it'll be more wise to call Self the
263:46 - Boolean expression over here itself
263:48 - so there we go now we're done with the
263:50 - parset of paper file and one more change
263:51 - I did it was
263:53 - I allowed for not
263:55 - so as of now we only call Boolean
263:58 - expression if it if the first token is
264:00 - integer floater operation now even if
264:03 - the first token is not like for instance
264:06 - not Phi equals 5 so this is still an
264:09 - arithmetic operation that I want to
264:11 - calculate and therefore I go into self
264:12 - dot Boolean expression so that's the two
264:15 - changes I made to pass the p y now let's
264:17 - go to The Interpreter and handle the not
264:20 - keyword in The Interpreter so over here
264:22 - it's a unary operation
264:24 - but do not that I just realized this
264:27 - that the in in the universe unary
264:30 - operation the operand can be an
264:32 - expression it doesn't necessarily have
264:33 - to be an integer like for instance you
264:35 - can have minus 5 times 5 this is a valid
264:38 - expression as of now I only thought of
264:40 - the possibility of maybe if minus five
264:42 - but it's not necessarily the operand is
264:45 - not necessarily an integer or a float it
264:47 - can be an expression as well so to
264:49 - handle that scenario I'm going to say
264:50 - expression
264:52 - equals
264:54 - cell a tree one
264:56 - I'm gonna say if expression is an
264:58 - instance of list that means it has
265:01 - a sub Tree in it so if expression is an
265:04 - instance of a list then I'm going to say
265:05 - expression equals self dot interpret
265:07 - recursion again
265:10 - expression
265:13 - so now instead of passing in tree one
265:15 - I'm gonna pass in expression itself
265:17 - so I'm going to save this now and let's
265:19 - go up to the compute unary method
265:23 - and over here let's add one final unary
265:26 - operator if operator dot value is not
265:30 - then I'm going to return 1 if not
265:33 - operand is true else I'm going to return
265:36 - 0. so let's save all of this let's go to
265:38 - shell.py and I'm going to run this now
265:41 - I'm gonna do not 5 equals 5 that means 5
265:43 - equals 5 is once not 1 should be 0 and
265:46 - that indeed is the output let's try
265:48 - something else let's try Phi equals 5
265:50 - and 7 greater than 2 that turns out to
265:54 - be 0 yes because 5 is equal to 5 and 7
265:56 - is greater than 2. if I do 5 equals 5
265:59 - and 7 less than 2
266:01 - we'll get 0 but if I do 5 equal to 5 and
266:06 - 7 or 7
266:08 - less than 2 we should get 1 which we
266:11 - indeed do so that's all about
266:13 - conditional operators and Boolean
266:15 - operators sorry comparison operators and
266:17 - Boolean operators and we'll use these
266:20 - two concepts to form our if statements
266:22 - and finally in the end we'll run a while
266:25 - loop as well so for all of that and more
266:27 - I'll see you in the next section
266:32 - so in this section the course I wrote
266:34 - the code regarding the if statements now
266:36 - before we go into it let's just talk
266:38 - about syntax so the grammar rule will
266:40 - look something like this we have an if
266:43 - statement followed by an expression and
266:46 - after that we can have L uh sorry the
266:50 - keyword do so expression and if the
266:53 - expression is true then do statement
266:57 - so that's the rule for if statements and
267:01 - also that can be if Alice statements as
267:03 - well in this so you can have if these
267:05 - statements not true then you have L if
267:07 - another expression followed by do
267:10 - another statement
267:12 - and this can go on and on the alif
267:14 - statements can go on and long and then
267:16 - finally at the end you can have an else
267:18 - statement followed by do and statement
267:22 - so that's the way in which we're going
267:24 - to create our if statement number I've
267:26 - already written the code for the Alexa
267:28 - and parser because this stuff is pretty
267:30 - repetitive and I don't want to write it
267:33 - all again so
267:35 - over here I've created reserved keywords
267:38 - as its own list now it has if alif else
267:42 - and do and in the tokens.py file we've
267:45 - also created a class for reserved tokens
267:48 - now after that I went into the lecture
267:51 - and apart from checking for Boolean
267:53 - values and declare declarations I'm also
267:55 - checking if the word is in the legs is
267:58 - in the result list
268:00 - in that case I'm going to add it to the
268:02 - instance of a reserved class
268:05 - now after that I'm going to go to the
268:07 - passer the passer has three aspects to
268:09 - it first of all in the statement method
268:13 - we check if the token value is if
268:16 - if it is if if it is if then we go to
268:20 - self.if statements we run the self.if
268:23 - statements method
268:24 - and the self.if statements method runs
268:26 - over here it stores the conditions and
268:29 - actions in two arrays so the conditions
268:31 - correspond
268:34 - conditions correspond to these
268:36 - expressions
268:37 - stored in a list and statements
268:40 - correspond actions correspond to these
268:42 - statements stored in the list
268:44 - so we store both of them as initially
268:47 - they are empty and then we call if
268:49 - statement make itself dot if statement
268:52 - now we go to this method Self Storage if
268:54 - statement which is responsible for
268:56 - grabbing the one con grabbing one
268:58 - condition and grabbing one action
269:00 - pertaining pertaining to one if
269:02 - statement or one alif statement
269:04 - so it first of all moves from the if for
269:07 - alif statement so it moves from the if
269:09 - statement goes to the condition
269:12 - and then it stores the condition as a
269:14 - Boolean expression
269:15 - then if these token dot value is due
269:18 - as we saw over here
269:20 - then we grab the statement we move up
269:24 - from the do and then we grab the
269:25 - statement and store it as an action and
269:27 - we return it now this second elf
269:30 - statement is for a special case when
269:32 - when we have unary operations now when
269:34 - we have unary operations and parentheses
269:36 - we call Self the Boolean expression
269:38 - within it and tend to move a point after
269:42 - the do keyword
269:45 - uh so we tend to move ahead of this so
269:48 - this second statement
269:50 - which is
269:53 - over here the second statement checks
269:56 - for if the the do keyboard is in the
270:00 - previous token in that scenario we
270:03 - return the condition and action
270:05 - so that's the alif statement and we run
270:08 - a while loop for all the LF statements
270:10 - in the end we check for an else
270:12 - statement we move from the else
270:14 - statement we move from the to keyword
270:16 - and then we we grab the action and store
270:20 - it in a list of three items if there is
270:23 - no else statement we store in it store
270:25 - the output in list of two out two items
270:28 - now let's go back over here
270:31 - the final output will contain self dot
270:33 - token and that is used to we are
270:37 - explicitly declaring if the statement is
270:39 - in if statement not because that makes
270:40 - it easy to detect the statement in The
270:43 - Interpreter so that's what the self
270:45 - token does in the first value and cef.if
270:48 - statements is just the output that we
270:51 - saw previously the conditions actions
270:53 - and else action
270:54 - now let's go to The Interpreter
270:56 - in The Interpreter we have
271:00 - okay so yeah over here in The
271:02 - Interpreter we check if the first value
271:04 - is reserved we first of all check if the
271:07 - instance of the trees list then we check
271:10 - if the first value is reserved and then
271:11 - we check if it's an if statement
271:13 - so we're using the
271:20 - so we're using this first item over here
271:22 - we're checking if it's reserved we're
271:23 - checking if it's an if statement in that
271:25 - case we are gonna
271:27 - iterate through each condition in the
271:30 - conditions list
271:31 - and we're going to also store the index
271:33 - of our Loop
271:35 - then we're going to interpret the
271:37 - condition and if the evaluation turns
271:40 - out to be to have a value of 1
271:42 - then in that case we need to we're going
271:45 - to use the corresponding index and match
271:47 - the action using that corresponding
271:49 - index and we're going to interpret that
271:52 - action
271:53 - finally if the length is 3 that means
271:55 - that there is an else statement I'm
271:57 - going to interpret that else statement
271:59 - but and even if both of those conditions
272:01 - fail that means even if there is no l
272:03 - state if there's no else statement and
272:05 - the if conditions fail
272:07 - and the LF conditions fail in that case
272:09 - I'm just going to break out and return
272:11 - so that's pretty much it I noticed one
272:14 - error I had made beforehand is that in
272:17 - the compute unary method I've forgotten
272:19 - to return the output in the form of an
272:21 - integer float and I updated that as well
272:25 - so finally I'm gonna go to Shell and I'm
272:27 - going to run this we can have
272:29 - expressions like if I is greater than 2
272:32 - 2 make a equal 3 and you see we get a
272:36 - equal to 3 and this is my printing from
272:38 - here so let me just delete this
272:39 - evaluation print
272:41 - so let's control C clear
272:43 - I'm going to do if 5 is greater than 2
272:45 - do make a equal to 3
272:48 - .
272:49 - 3 we get a equal to 3 if 5 is less than
272:52 - 9
272:53 - or
272:55 - 7 is greater than 3 do make a equal to
272:59 - 6.
273:00 - we can we make equal to 6 if 5 is
273:04 - greater than or equal to 5 do make a
273:07 - equal to 9 a becomes nine if
273:11 - let's see if
273:13 - a
273:14 - is equal to 9
273:17 - and 7 is greater than 3
273:19 - do make b equal to a plus 1
273:24 - and B becomes 10. so that's the if
273:27 - statement covered and with that we have
273:30 - completed if statements variables and
273:34 - expressions
273:38 - so in this section of the course I
273:40 - created the while loop and first of all
273:43 - I modified the lecture and before we do
273:45 - that we need to think about the grammar
273:47 - Rule and this is how it looks like it's
273:49 - similar to the if statement where you
273:51 - have a while divide keyword followed by
273:53 - an expression followed by do followed by
273:55 - a statement so I just add a while to the
273:58 - reserved list and that's it to the Alexa
274:01 - now I moved the passer in the passer
274:05 - apart from the if statement check I also
274:07 - need to check if it's a while statement
274:09 - and I need to return accordingly
274:13 - I am returning a while statement over
274:15 - here so self dot while statement so I
274:17 - move from the while keyword and move to
274:19 - the expression
274:21 - and then over here I store the
274:23 - expression as a condition
274:25 - then if the value equals to if the next
274:27 - value is equal to 2
274:29 - in that case I'm going to move and then
274:32 - I'm gonna store the action
274:34 - and then I'm gonna return this list and
274:37 - again for that special case when you're
274:38 - using unary operations you kind of move
274:41 - ahead
274:43 - because you call Boolean expression
274:45 - within the factor method and that's why
274:47 - I need to add this additional check over
274:50 - here
274:51 - so that's it in the passer now let's
274:54 - move on to The Interpreter
274:56 - so The Interpreter remember we had the
274:59 - check for if the value was an if now
275:02 - let's check if the value is wild then
275:05 - these are just some checks all right
275:08 - there we go now we check if the value is
275:10 - while in fact I don't even need this
275:11 - action over here so then I store the
275:14 - condition self dot interrupt three one
275:16 - zero that is the condition that we
275:18 - passed from the passer to The
275:21 - Interpreter
275:22 - then while the condition.value is one
275:24 - that means while that condition is true
275:26 - I'm gonna do the action and print out
275:28 - the response
275:30 - since after interpret the action then
275:33 - again I'm going to update the condition
275:34 - because if I don't do this the condition
275:36 - won't get updated
275:38 - and I'm going to update the condition
275:40 - and then again we're going to go into
275:41 - the while loop and check if the value is
275:43 - one
275:44 - so with that with those changes let's go
275:46 - and run the shell so I'm going to click
275:48 - on run and now let's do
275:51 - make a equals zero
275:53 - while a is less than 10. do make a
275:58 - equals a plus 1 and if I run this we get
276:01 - a equals 1 2 3 4 5 6 7 8 9 and 10 and
276:06 - finally we get none printed out so I
276:07 - don't really want that so I'm gonna go
276:09 - to the Shell and I'm gonna say if
276:14 - result is not none
276:20 - only then I'm going to print the result
276:23 - else you're just gonna leave it empty
276:26 - so let's do
276:28 - make a equals 0
276:32 - while
276:34 - a is less than 10 do make a equal to a
276:37 - plus one
276:38 - and that gives our correct response over
276:40 - here and as you can see it converts it
276:42 - to floating Point numbers for some
276:44 - reason and these are just some minute
276:46 - details that are that are a bit buggy in
276:49 - our code it's not 100 full proof it's
276:51 - not as good as the modern programming
276:53 - languages but the goal of this course
276:55 - was to teach a few Concepts and create a
276:57 - simple programming language which can
276:59 - compute arithmetic operations and also
277:01 - some additional functionality as well