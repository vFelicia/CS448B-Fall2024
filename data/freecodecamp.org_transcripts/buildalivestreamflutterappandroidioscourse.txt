00:00 - Thomas petrol is a popular instructor 
and excellent developer. In this course,  
00:03 - he teaches how to build a live streaming flutter 
app using a Gora thanks to agora for providing  
00:09 - a grant that made this course possible. Hello, 
everyone. My name is Titus Petra, I am a YouTuber,  
00:14 - Google Developer expert for flutter and Dart, 
and also developer evangelist at agora. And  
00:18 - this course will be covering a live streaming 
application where you can have multiple live  
00:22 - stream feeds from multiple people coming into a 
director application, the director has control  
00:27 - of whether they're muted, whether their videos 
on and whether they're on the stage at a lobby,  
00:31 - and then for those people that are in the stage, 
their video will get transcoded together and sent  
00:35 - out to any streaming platform that you want. I say 
this course is an intermediate level course. So if  
00:39 - you're completely new to flutter, I recommend 
taking a look at some of the other Free Code  
00:43 - Camp courses. I know they have some great ones for 
beginners. And if you're completely new to Gora,  
00:47 - I'll leave a couple of resources in the 
description. So you could see how to implement  
00:50 - simple video calling features with it. I will 
also be using ver pot for state management.  
00:54 - I'll be explaining a little bit about what state 
management is and how we're going to use it here.  
00:58 - But if you want to dive a little bit deeper, 
I'll leave some resources in the description  
01:01 - too. And lastly, I'd like to thank Freako camp 
for giving me this opportunity. And let's get  
01:05 - into the course who got a little cold in your 
head to put on a sweatshirt. But like I said,  
01:09 - this app is a little bit more complicated. So 
I wanted to break it down to visually, we're  
01:13 - going to start off with a homescreen. On the home 
screen, we're going to have to enter two fields.  
01:17 - One is the name of the room. The other one is your 
name. And as me two buttons, because technically,  
01:22 - we're going to have basically two apps within 
one app, we're going to have a participant view,  
01:26 - but we're also going to have a director view. 
So the first view is going to be the participant  
01:29 - view. Now this view should look like any other 
normal video call you can have, you'll have an  
01:34 - End Call button, a mute button, and a switch 
camera button. Within the participant view,  
01:39 - you're basically saying you're going to be a 
participant within the video call that a director  
01:44 - controls. So what you should see is basically 
what's going to be going out to the public,  
01:49 - the people that are going to be going out to 
the livestream platforms, they're going to be  
01:52 - the people that are on the stage, splitting the 
stage in this next part. So this is the basics  
01:56 - of the director layout. So the director basically 
controls how the whole video calls going, and who  
02:02 - actually gets pushed out to the live stream and 
who doesn't. So you'll have first the lobby here.  
02:08 - So when you first join as a participant, you'll 
be put into the lobby, then the director will have  
02:12 - the ability to bring you into the stage. And then 
you will be basically live. And the director will  
02:17 - also have the ability to bring you back to the 
lobby if you misbehave, or something like that.  
02:21 - At the top here, we'll put basically what 
streaming platforms you want to go to. So  
02:25 - let's see YouTube and Twitch. If you haven't 
heard that, at the bottom, we'll have a menu  
02:30 - for stuff like End call and start and stop 
live stream. So as you can see, there's a lot  
02:36 - of stuff going on in this director application. 
That's where state management comes in. Not to be  
02:40 - perfectly clear, you don't need state management 
here, you could definitely make this app work  
02:43 - without it. But in my opinion, adding some sort 
of state management solution kind of cleans up  
02:47 - the code a little bit and makes it easier to 
work with. So what is state management. So if  
02:51 - we take a look at this application, within the 
director part of it, we have a lot of different  
02:55 - states. So we have stuff like who are the 
people on the stage, people in the lobby,  
03:01 - what platforms we're streaming to whether the live 
stream is live or not, and things like that. So  
03:07 - depending on how big your application is, and how 
much of the state objects you're gonna be using on  
03:11 - different pages, you might want to split it up 
into multiple state objects. So you could have  
03:16 - something like a state object for the people on 
the stage, a state object for people in the lobby,  
03:22 - state object for what type of platforms you 
want to go to, and a state object for whether  
03:27 - the stream is started or not. But for this, 
we're going to keep things simple, we're just  
03:31 - going to have one state object for everything 
director related. So something like director,  
03:37 - state. Now within here, we'll have active users 
lobby users is live variable to tell us if we're  
03:44 - live or not. And which destinations we want 
to stream to. So that is the state that we're  
03:49 - going to be managing for this application and 
the whole director page. So this whole page  
03:54 - will be reactive to whenever this state changes. 
So anytime you update this, the our director  
04:01 - screen will react and update the UI to match 
whatever needs to match. And of course, when you  
04:06 - click buttons, so let's say there's a plus button 
to add a destination here. Whenever we click, it  
04:11 - will go to a function that changes and updates 
this destination, which updates the state which  
04:16 - updates the screen. And thus, we have a nice 
simple flow for how things get updated within  
04:21 - our application. Hopefully that makes sense. And 
for the participant app, since it's simple enough,  
04:26 - there's not too many things to manage. We're not 
even going to use any state management for that.  
04:29 - So how do we choose the gore for this project? 
Well, first I worked there, so I'm a little bit  
04:34 - biased. But also it makes building something like 
this a little bit easier than other competitors,  
04:38 - and also has a very powerful backend. So you 
know, you'll be getting quality and reliability  
04:42 - and all that stuff. Now that your platform will 
be taken care of all the video feeds are coming in  
04:47 - and putting them together sending them out to 
live streams, but also using signaling between  
04:52 - the director and all the participants, whether 
they're muted or whether they should be in the  
04:56 - lobby or the stage and stuff like that. 
Alright, enough explaining things. Let's  
04:59 - show how this is actually built. So we're gonna 
start off with the old flutter create command.  
05:04 - And we're gonna call this app streamer. 
Demo. Okay, jump into the directory  
05:11 - and open it in VS code. And here we have our basic 
flutter app. And there we go, we're running the  
05:17 - basic flutter demo application. And before moving 
forward want to add in all the dependencies that  
05:21 - we need. So he said, the main thing is going to 
be running on his agora, we go to the package  
05:25 - manager for Dart, we type in agora, we will see 
three agora plugins. Now we're going to be using  
05:30 - the gore RPC engine and the Agora RTM. But I 
want to show you what a gore UI kit does, too,  
05:36 - because it's really quick and simple. So we have 
added a gore UI kit here. So this is used if you  
05:41 - want to set up a simple video call application. 
Now the plan is to expand this to allow all the  
05:46 - complex features to So technically, what we'll be 
building here should also be possible with UI kit  
05:51 - in the future as well. So that's why I want to 
show it to you a little bit. So in order to add  
05:55 - UI kit to your project, you only really need to 
add three lines of code, we need to create an  
05:59 - agora client, I need to pass in a gore connection 
data and enabled permissions. So we're gonna need  
06:04 - two permissions for a video call, we're gonna 
need a camera permission, and a microphone  
06:08 - permission. Now that said, your connection data 
is a class that we need to add. And you'll see  
06:12 - you'll need app ID and challenging. So what 
the heck is that? Well, if you go to console  
06:19 - dot agora, that IO, you'll see a screen like this, 
now that have a list of all your projects, you  
06:23 - can create a new project. But for us, we're just 
going to be using this project that already have.  
06:28 - But you should see something very similar. 
Only creator, you might see a screen like this.  
06:32 - And you'll have a thing called App ID right here. 
So this is basically creating an a gore app for  
06:38 - you. And you'll be able to use your services and 
you'll have 10,000 free minutes of the services  
06:43 - every single month. So we're going to be copying 
this app ID and bringing it into our code. North  
06:48 - not be showing you my app ID this whole time, 
I'm gonna have a new file, and I'm gonna call it  
06:53 - app ID. And here on define const, app ID equals 
and then insert hap ID here. Name this file with  
07:06 - lowercase and underscores, that's fine. But then 
you're going to want to insert your app ID here,  
07:10 - but I'm going to put in my number. So there we go. 
Mine's in there. And we can type in app ID here.  
07:17 - And it will import our app ID file. And we can 
use that constant variable here. For our channel,  
07:22 - we're just going to call it test for now that we 
want to initialize that client. And then we're  
07:27 - done. So all the Gore said is this initialized, 
and we will just want to display a stack of  
07:33 - widgets. One of them is going to be the gore video 
viewer, which will show you the actual video,  
07:38 - you pass in the client. And then we have a Gora 
video buttons. So we could have an called button  
07:44 - and stuff like that. And that's a full video call 
application. Before I can demonstrate though there  
07:48 - are some permissions we need to add. So on the 
Android level build gradle, we need to add that at  
07:53 - the end of the repositories. So we can add that 
in here. Then Add a Device Permissions, which  
07:58 - we already did Android manifest file, add this 
required device permission to the file. So there  
08:04 - we go. Now this video call should be working. And 
we should be able to launch it and showcase it.  
08:11 - Alright, there was apparently a bug that took a 
little while to figure out but there was either  
08:16 - a new Android version or new permissions handler 
version that was released. So you want to make  
08:22 - sure you say your target SDK version and your 
compile SDK version, both to be 31 by default,  
08:28 - and flutter projects as 30. And something 
doesn't like that with permission. So with 31,  
08:34 - everything works. And you just see an app like 
this will ask for your permissions. Let's give it  
08:39 - permissions to do all that. And this little image 
is something we'll see throughout the video and  
08:44 - is the little fake camera emulator from Android. 
Let me join another device just to prove to you  
08:50 - that this works. And I forgot since mine is an 
iOS device, we're going to have to add these two  
08:54 - things to the info dot P list file. So iOS runner 
info dot P list and add these two keys in here.  
09:05 - Now save that. This time, hopefully it will 
work. And there we go. Here I am. So that was  
09:14 - the core UI kit. And while you can do a lot of 
things with the core UI kit, you can actually  
09:18 - do a lot of customizations. There's a couple 
small things you can't do right now that we're  
09:22 - working on adding in. So we're going to need 
to use a core API called a gore RTC engine.  
09:31 - So the core RTC engine handles all 
the video and audio related stuff.  
09:36 - But then you also need to add a gore RTM, which 
is real time messaging. RTC stands for real time  
09:43 - communication. RTM stands for real time messaging. 
And you can imagine the messaging is to send  
09:48 - signals between the peoples so we 
can have control of everybody within  
09:51 - the call. So those are going to be the 
packages driving the core a core logic.  
09:56 - Then we're going to need the advert pod. We're 
going to use flutter River pod, that's for the  
10:01 - state management. And then we're going to 
add a couple little small things like shared  
10:08 - preferences, we're going to need this 
because we're going to have to have a  
10:11 - UID of a person that we're going to generate 
randomly, and we're going to store it. So we don't  
10:15 - have to create a new one every single session. 
There's other ways to get you IDs, for example,  
10:19 - from Firebase, nah, stuff, but we're gonna do a 
simple route and a shared preferences just makes  
10:23 - it easier for you to store things locally. And 
then we're gonna have a couple neat little UI  
10:28 - packages, one's going to 
be called App, pop up menu,  
10:33 - just like it sounds, it's just a little pop up 
menu, they're gonna have a modal bottom sheet,  
10:40 - which is a nice little thing that comes up from 
the bottom, so you can add some information  
10:44 - in there. And then last one, circular menu. So 
really, there's three main ones driving the actual  
10:52 - logic behind everything that happens, then shared 
preferences just to store things locally, easily.  
10:58 - And then three UI packages, its UI elements that 
we could definitely make ourselves bow, why not  
11:03 - use the things we have out there. Alright, so 
everything is set up and ready to go. Now I have a  
11:07 - way that I organize projects, it's similar to the 
MEU architecture approach. And it's a nice way to  
11:13 - keep things organized within your app, so that 
you can keep building up and building up on it.  
11:17 - So I have a folder called controllers, that's not 
a folder, I have a folder called models, pages  
11:25 - utils. And sometimes they even have a folder for 
widgets. But in this case, we're not going to need  
11:30 - them. So the app ID goes within the utils. We 
don't need to look at that anymore. So utils,  
11:36 - as you could see is utilities, stuff they use 
throughout the app. But it's not really a feature  
11:40 - or anything like that. So for example, I put 
my colors in here, different colors that I have  
11:45 - for the app. And I can't even think of many other 
examples of things I put in here. But it's nice to  
11:49 - keep those organized. Then pages like it sounds is 
a different pages of the application. Models are  
11:55 - the data objects. So the different types of data 
that you hold within the application. And then  
12:00 - controllers are the main things that drive the 
whole application. So if you remember how we're  
12:05 - using river pot for state management, and then 
we have that director state that we talked about,  
12:09 - so that director state is going to be within the 
controller. So you can actually add the file so  
12:13 - we can envision it even better. So we will have 
a director, controller. And here we'll have the  
12:20 - director model, which is the big object that 
we're going to be using to control the whole  
12:24 - application, then we will have a simple stream 
dot Dart, this is going to have the information  
12:29 - for where we're streaming to, and a user dot Dart 
for all the people that are going to be within  
12:34 - the call and any data that we need to hold for 
them. Then pages, there's only three pages here,  
12:39 - we will have the homepage, we'll have the director 
page, and then we'll have the participant page.  
12:48 - Okay, so everything is set up, we're ready to 
start adding some code in here. So we can remove  
12:51 - this homepage class, remove all this. And we'll 
just call it home, we can leave all that as is  
12:59 - remove the title, we don't really need that. Now, 
since we're using river pirate want to wrap this  
13:03 - whole material app with a provider scope. So there 
we go. This provider scope basically a widget that  
13:09 - stores state, we're storing state for the whole 
application, so wrapping it around this whole  
13:14 - material app. Now this homeless, we have 
a problem. But we'll add a stateful widget  
13:19 - here called home. Now we can import that. And I 
think we can even make it custom. There we go.  
13:26 - So we're pretty much done with this whole main 
page, we won't be touching it much more. Now the  
13:31 - home screen, if we take a look at our design, we 
want the home screen to look something like this.  
13:36 - Whether you're a participant or director, 
it's actually going to be a little bit  
13:40 - different. Because one, we're going to need 
a username. And then we also need a channel  
13:43 - name. So instead of adding channel name here, 
we're just going to put it in the first screen.  
13:47 - So in the channel name, username and then two 
buttons. So first, we need to create a scaffold.  
13:52 - And then in the body, we're going to have a 
center widget in which we will have a column.  
14:01 - Within this column, let's center everything.  
14:06 - And that children will be two text fields and two 
buttons. So the first text button will take us  
14:12 - to participant. And the second text button will 
take us to director. And actually let's go and  
14:24 - set both of those up. So for the child of the 
participant, we're going to have a row with the  
14:28 - word participant and the little icon icons and be 
a live TV because you're going to be pretty much  
14:35 - joining a live broadcast. And the child for 
the director will be the word director and  
14:41 - a little cut thing so you know you know that 
you're directing something or you're in charge  
14:45 - of something. So let's set up our participants 
screens as well. So we have a stateful widget  
14:50 - called participant and then in here we will just 
do a simple scaffold with a body center Text,  
15:04 - participant. And let's just copy the same thing 
to director just to make sure everything works.  
15:13 - By the way, you can click Ctrl, D to do what I 
did here. And I just changed all the wording to  
15:18 - director. Now in order to get that next patient 
is to navigator dot push and then send our page  
15:24 - route for the specific widget that we want to 
push on. So we want to push the participant  
15:28 - widget here. And then do the same thing for the 
director, except here, we will push the director  
15:35 - page. Alright, so now we can actually run this 
to make sure at least navigation within the app  
15:40 - works. Alright, we ran into a 
little bug that then let us run.  
15:45 - So in this Mavenlink, I had WWW dot 
jetpack to IO, if you have this,  
15:51 - or I accidentally led you to have this make sure 
you remove that. And then your coaching run.  
15:57 - So we have an app that looks like this. And 
I think if we click into it will be taken to  
16:01 - the director screen. And if we click participant 
will be taken to the participant screen. So our  
16:07 - whole flow for the application is working. Now we 
just need to make this look a little bit nicer.  
16:12 - So let's create another folder in here we'll call 
it assets, this assets folder, we will put all our  
16:18 - images and things like that. So let's put it out 
into the main directory. And there's the assets.  
16:25 - In here we'll have the strimmer, you can't 
really see because it's a black background.  
16:30 - But you just got to trust me that 
this is the this is the right logo,  
16:34 - not to actually to actually add it into our 
app, we have to go to the postback diamo.  
16:39 - And here they have a commented out section that 
shows you how to add assets, but we're just gonna  
16:44 - add ours in, and it's in the directory called 
assets. So now it's ready to use. So at the very  
16:50 - top, we'll have image dot asset. And our path 
is assets slash streamer dot png, that a little  
16:56 - space between this and the next section, we'll 
give it a height of only five as some text like  
17:04 - multi streaming with friends. And these can be 
constants, because they were not going to change,  
17:13 - add another size box to give some space in between 
the titles and the text fields will have a height  
17:20 - of 40 here. And then for text fields, we'll do 
something a little more special. So first things  
17:25 - first, we need some controllers up here. So we'll 
have a channel name controller and a user name  
17:29 - controller. To format this to look a little 
nicer, we're going to wrap it in a container,  
17:35 - I'm going to give it a specific width of media 
query width. So this is the width of our screen,  
17:40 - and we're going to multiply it by point eight, 
five. So it's going to take up 85% of the screen.  
17:45 - This will make it more responsive for the 
different apps that we have. Now within a  
17:49 - text field, we'll have a controller this will 
be the username. And then some decoration.  
17:58 - And this decoration is just going 
to give it a nice little border  
18:02 - and have the text username in there. So nothing 
too special. Now we want to size box again,  
18:10 - of height, eight here, for example. And I'll 
hit copy paste the same thing here. And notice a  
18:16 - convert to size box because we're not really using 
much else within here. We're not using many of the  
18:21 - container things. So size box works here as well. 
And here we will have the channel name and change  
18:27 - this to channel name. Alright, let's run that. 
So there we go. It looks looks pretty nice. Now,  
18:33 - now there's one more thing we need to do is we 
need to add properties that we pass in here. So  
18:37 - we have a channel name and username, but we need 
to actually pass it into these specific widgets.  
18:42 - So there's the participant screen, we're going to 
need the channel and the username here. And then  
18:46 - for the director screen, we actually don't even 
need the username, we only need the channel name,  
18:50 - but director won't actually be within the call. 
So we don't need to see his username anywhere.  
18:56 - But we run into issues here because we're 
not passing the specific things we need.  
19:01 - Just simple to fix channel name, we take the 
controller we have, and we get the text from  
19:08 - it. Same thing with username, we take the 
user controller and take the text from it.  
19:17 - So this is taking the controller that we 
have set up for each of the text fields.  
19:22 - So when you're typing, there's a nice little  
19:25 - thing in the background that has all the text for 
you and we're retrieving the text value from it.  
19:32 - And then we should have one more problem at the 
director where we do something very similar town  
19:38 - name, we take the channel name controller and 
retrieve the text. So now each of these screens  
19:44 - should have the correct values that we need, 
and we should be good to go. Alright, so for  
19:48 - our next part, we're gonna start implementing 
the participants are things the participant is  
19:53 - going to be a lot simpler than indirect or so. 
So hopefully it'll be a good transition from  
19:58 - implementing something a little bit simpler. 
And then we'll step it up another level.  
20:02 - By adding it into the director, that participant 
still has a lot of things that we need to take  
20:07 - care of. And, and since this is a more complicated 
app, there's going to be a lot of functions that  
20:12 - the participant has to execute on as well. But, 
but we'll take it slow. And hopefully by the end,  
20:16 - you'll have a good understanding of how all these 
stuff works together. So the biggest thing we'll  
20:21 - be emphasizing here is how agora RTM and agora RTC 
work together. So if you remember, our TM is real  
20:29 - time messaging. So it's signaling is how we'll be 
able to communicate information between people.  
20:34 - So send like mute requests and all that type 
of stuff. And then I go to RTC will be the  
20:38 - actual video call happening. So on the 
participants are things we will need RTC  
20:46 - engine, which is going to be handling the 
actual video call. And then for RTM, we will  
20:51 - have a client and then we also have a channel. So 
within the core RTC engine or Gore RTC package,  
21:01 - this client and channel logic is within this RTC 
engine thing just made a little simpler to use. So  
21:08 - you could add video call a little bit easier. So 
the gore RTM, everything's broken down to exactly  
21:14 - how things work behind the scenes. So as I said, 
the gore RTC engine will be the actual video call,  
21:19 - they'll go RTM client is you logging into a gore 
RTM itself. And then a gore RTM channel is joining  
21:26 - that channel. Actually, let's go and initialize 
this, and you'll see exactly what I mean. So here  
21:32 - we're creating the actual engine. And then if we 
go to join channel, you'll see you have to give a  
21:39 - token, which will give as No. But then we need to 
pass in a channel name. So this channel that you  
21:45 - pass in here does the actual initialisation very 
similar to how a RTM does this initialization for  
21:51 - this channel. We're actually not going to be doing 
this yet, but I just wanted to show it to you.  
21:55 - So we created the instance of our engine. 
Now let's do same thing with our client.  
22:00 - And for both of these, you notice we pass in our 
app ID that we created for gore. So now we have a  
22:05 - connection with the engine and the client to our 
agora project. So by default, a core RTC starts  
22:12 - with only audio, so we want to make sure we enable 
video so we could actually see the video streams,  
22:16 - and then set this person's channel profile 
to live broadcasting. There's three types  
22:22 - of channel profiles, there's live broadcasting, 
a normal video call, and a gaming one. So we're  
22:27 - going to be using a live broadcasting. And you 
can either be a broadcaster or an audience member,  
22:33 - they will be a broadcaster in this case. 
Alright, so the basics are initialized,  
22:37 - and we're ready to move forward with it. The 
next thing we want to set is our event handlers.  
22:46 - So these event handlers get triggered 
whenever some sort of event happens within our  
22:51 - application. And there's a lot of them, we're 
going to be implementing a lot more of them.  
22:55 - But for now, let's just do one to showcase how 
it works. So we have joined channel success,  
23:03 - you can hover over this, and our occurs when 
the local user joins the specified channel.  
23:07 - So we'll do here will actually have a list of 
integers with the users that are within this call.  
23:19 - Now, whenever this person joins, we'll have users 
that add I'll add their UID to this list of users.  
23:29 - I actually want to set state so we can 
update the UI with this specific user shown.  
23:36 - This logic isn't Howard's gonna end with 
because we're we don't want to just display the  
23:41 - current user that Johnny wants to display any of 
the active people within the stage of the director  
23:46 - application. But we'll handle that a little bit 
later. So okay, here we set up the callbacks  
23:55 - for the RTC engine. Now if you remember, we 
have an RTC engine, and then we have our TM  
24:02 - client and our TM channel. So those have 
callbacks as well. So the RTM client is  
24:08 - your connection to the actual Gore RTM thing. So 
there's like a personal connection to the Agora  
24:14 - system. And our team channel is the 
channel that you join. So this is like  
24:20 - everybody in the channel will be on the same 
channel. But you will be the only one on that  
24:24 - specific client. Hello, editor, Titus here. 
So I messed up my wording a little bit there.  
24:29 - He won't be the only one on the client, but you 
will have an individual connection to the client.  
24:34 - So this client has callbacks, like on message 
received. And this callback has a message and  
24:39 - appear ID so we go to the definition of this. So 
this callback occurs when the local users receives  
24:44 - a peer to peer message. So when you get a specific 
message from a separate user to you directly, this  
24:50 - callback will execute and we'll just print out 
private message from this user with the message of  
24:55 - this. So I don't think we'll actually be needing 
to use this call But I thought we would include  
25:01 - it because I think it helps you understand what a 
client and what a channel is. But there's one that  
25:05 - we will definitely be using as on connection state 
changed. So this one will give us two variables  
25:11 - will give us the current state. And the reason. So 
the reason is why this connection state changed,  
25:16 - and the state gives you what's the current state. 
And you notice these are integers. And we're gonna  
25:22 - figure out what those integers mean, by going to 
developers on a gourd the IO go to documentation,  
25:28 - and documentation, go to API reference. And 
we're working with the real time messaging.  
25:34 - And currently, there's no documentation 
for the flutter SDK for this. But for now,  
25:37 - I don't know it's coming soon. But it has 
the same exact things as the Android SDK.  
25:44 - So we can get status and error codes and go to 
connection state. And then there's connection  
25:49 - change reasons. So connection state, we have 
connection state aborted is equal to five.  
25:55 - So if our state is equal to five, which 
means this connection state was aborted,  
26:02 - you want to leave the channel, want to log 
out the client. And we also want to destroy  
26:07 - the client. We could even add apprenticing logged 
out. So whenever our connection state is aborted,  
26:16 - we want to just basically clear out everything 
that we had going on. Now we can even go to  
26:21 - connection change reasons, we'll get see these 
numbers and elegant figure out if you want to do  
26:25 - something specific for whatever reason occurred, 
we can do that. But we're just going to keep it  
26:30 - simple for this example. Okay, so those were the 
callbacks for the RTM client. Now the last one  
26:35 - is a callbacks for the RTM channel. So these 
are channel one messages. This is what we're  
26:40 - actually going to be using to mute people 
and all that stuff, because we want to send  
26:44 - a message to every art everybody in the channel, 
and then the person within that channel checks  
26:49 - if they're supposed to mute themselves. And then 
they will go ahead and mute if their UID is passed  
26:54 - to this channel message. So first, we're going 
to use a simple example of member joins. So you  
26:59 - can see these printouts happen whenever someone 
joins a channel, that's also have one for member  
27:04 - left just so we can have all this information. 
And the last and most important one will be  
27:09 - will be called on message received, where we'll 
get a message from the channel and they'll  
27:14 - tell us which member actually sent this channel 
message. So you notice these callbacks are named  
27:19 - exactly the same. So we have on message received 
here, and our message seed here. But remember,  
27:23 - this is for the client, which means you're 
sending a specific private message. And this  
27:28 - is a channel wide message. So this is like a 
public message to everybody within the channel.  
27:34 - And again, the documentation it says 
occurs when receiving a channel message.  
27:38 - We're going to implement this later. But for 
now, we can add another print statement here,  
27:43 - that just tells us the public message. Alright, 
so there we go. I know this might seem a little  
27:48 - complicated. But once you actually understand 
what's going on here, hopefully it's not too bad.  
27:52 - So the last thing we have the callbacks 
declared, We have everything initialized,  
27:56 - there's only one thing left to do on essentially 
join all these channels. So first things first,  
28:00 - we actually need to login with the client to 
agora. And here's where we run into the next  
28:04 - problem. So we need to give a user ID to this 
client. Now there is a way around this where  
28:09 - you don't have to use a user ID. But for this 
application, we actually need to because we're  
28:13 - going to be using RTC and RTM. And they need to 
have matching user IDs. Technically, the user  
28:19 - IDs don't have to match. But you have to be able 
to connect an RTM ID and an RTC ID. Since we're  
28:25 - going to be using these UID to control all the 
users, we need to figure out a method to create  
28:30 - these IDs. And to do that, we're actually going 
to pass in a UID as well here. And then down here,  
28:37 - we could do widget that UID. And it actually needs 
to be a string. But we pass in as an integer for a  
28:43 - specific reason that you'll see real soon. So then 
we create our channel. And you remember, we passed  
28:49 - in at the top the channel name from that text 
field, we got do that by client create channel,  
28:56 - we get the channel name from the text, we passed 
it. But we'll probably notice something here.  
29:03 - We're creating the channel. But we're assigning 
callbacks on the channel here. That doesn't  
29:08 - really make sense. So we want to move this 
above the channel callbacks. To be honest,  
29:14 - we could probably move it all the way up here 
just keep all the callbacks together. But,  
29:18 - but this works just fine too. So next step 
is take that channel and we want to join.  
29:23 - So we have the RTM part completely figured out. We 
logged in the client, we created the channel and  
29:28 - we joined the channel. Now for the RTC. We have 
a very similar approach. We have the RTC engine,  
29:35 - but all we have to do here is just join 
channel. And it does all of this stuff for us.  
29:40 - And actually define the engine as a late variable. 
So we don't need a question mark here. By the way,  
29:45 - if I went over that too fast, this late variable 
is with flutter 2.0 means we're going to  
29:50 - initialize this before we use it. And we know that 
for a fact because we're doing it in a net state.  
29:56 - we're initializing it up here and we will be using 
it down here. So we'll For sure be initialized.  
30:02 - Again, here, we're not going to be using 
a token, channel name will be the same  
30:06 - channel name, optional info, we'll put no. 
And optional UID, we actually need it now.  
30:14 - Because we wanted to have a matching UID to our 
RTM client. So that's why we need that UID. Okay,  
30:20 - so the initialization, everything should be done 
here. I say UI isn't built yet. But I think that's  
30:25 - the less complicated part. So I wanted to get 
this out of the way. Now I know one thing we're  
30:30 - missing is this UID. So let's go back to the 
home and figure out a good way to do this.  
30:35 - So we're going to implement the UID 
here just to keep things a little  
30:39 - less cluttered. And we're going to do that in a 
very simple way. If this is a real application,  
30:44 - I'm not sure if that's the best way to do 
it, it probably wants to have some sort of  
30:48 - authentication service like Firebase or 
something like that, to give you a UID,  
30:52 - they keep track within a database. But 
where's it going to create something simple.  
30:56 - So during the initialization, we're going to get 
user UID. And if you remember, we added a package  
31:01 - called Shared Preferences. So this shared 
preferences just store something locally.  
31:07 - So the first time we run this will generate 
a UID. And then we'll just store it locally,  
31:11 - and reuse that same UID that we stored 
locally, for any future video calls  
31:16 - a function called Get User ID. And then we need to 
import shared preferences. So this get instance,  
31:23 - loads and parses the preferences 
from this app from the disk.  
31:27 - So all we have to do is try to retrieve that local 
UID. And we'll have two scenarios, we'll either  
31:32 - retrieve an actual stored UID. So that means we 
don't get a no value back. In which case, we will  
31:40 - set our UID right here to the stored 
UID. Or we haven't created one yet,  
31:46 - and then we will create it. But this should 
only happen once. Now I won't type this whole  
31:52 - algorithm out. But let me explain it. So get the 
current date and time in milliseconds since epoch,  
31:58 - how do you pronounce it I don't know. But 
it should give this exact time and anytime  
32:02 - further in the future won't be the same number. So 
this number is a little too long, we need to have  
32:07 - nine digits for Gore to work. So we take three 
digits from the front, which are the numbers least  
32:13 - likely to change, and we set those nine digits to 
the UID. Once again, that should only happen once,  
32:18 - and then we should be good. So now we can pass 
the UID to this participant. And finally, the  
32:25 - back end of our participant side of things should 
be done. Now time to serve the front end. Alright,  
32:31 - so we have the UID. In here. Now, the only 
things that was left is actually updating the UI.  
32:36 - Actually, there's a couple more things left, we 
have to add some more handlers here. So for this,  
32:41 - we're gonna have to do a little bit of logic here 
to send the users the current users information.  
32:47 - And when this person leaves, we want to clear 
all the users that we're seeing to then also  
32:52 - on message received, this will be a big part of 
the application. So we'll have to implement this.  
32:56 - But for now, let's just focus on the UI, get 
this looking right. And then we will be able  
33:00 - to see our video call with just this current user, 
we can actually add this lead channel handler in  
33:05 - here. So whenever we click Add, call or leave the 
channel, we clear all the users in there too. And  
33:10 - now we can move this to do inside the join channel 
success and rename it to add join channel logic.  
33:18 - Alright, now let's move on to the UI. So we're 
gonna have a scaffold with a center, and then a  
33:24 - stack of widgets. Two widgets we'll have here is 
a broadcast view, and a toolbar. So broadcast,  
33:33 - you will be the actual video feed, we'll see. 
And then layering on top of it, we'll have a  
33:36 - little toolbar so we can end the call and things 
like that. So for the broadcast view, we'll have  
33:41 - we'll have a child of expanded because we wanted 
to fill up the whole screen. And then in here, we  
33:47 - will have a an RTC local view and a surface view 
of that local view. But we need to import that  
33:55 - can do that right under the RTC engine. So keep 
the remote view in here because we'll need it.  
33:59 - Let's ignore that prefix because I don't know 
I think it looks a little bit nicer this we can  
34:04 - of course, follow the recommended library prefix 
if you want but we'll keep it like this for now.  
34:11 - So on this tastes are local a gore view and makes 
makes a view out of it pretty much. And apparently  
34:18 - we don't even need the container how for the 
toolbar, I feel like it's easier just to show  
34:22 - it all to you at the end instead of typing it all 
out piece by piece. So we will have four buttons.  
34:27 - You'll see a lot of errors right 
now because we haven't implemented  
34:30 - anything else because I wanted to take a 
step by step but we'll have four buttons.  
34:33 - Each one of them will do some symbols. So 
this one will toggle your mute this one on  
34:38 - the call. This one will disable your video 
and then this one will switch your camera.  
34:44 - So each one of them has a function and execute and 
some of them will need to hold a state actually.  
34:49 - So for this one, this button, it will look 
different depending if you're currently muted  
34:54 - or if you're not muted. Same thing with the video 
disabled. So let's add those two states in here  
34:59 - and they We'll start out as false. So you're not 
muted in this case and your videos not disabled.  
35:05 - And now to actually implement these 
functions. So first we have the on  
35:10 - Toggle mute function. And this one, we will 
just set the state of that muted variable  
35:19 - to not be muted. So that just 
changed the state locally.  
35:23 - But now we need to change that 
state within the actual video call.  
35:27 - So we do engine dot mute local audio stream aways, 
and we just set it to the variable whether it's  
35:34 - mute or not. So this will work for both cases, 
whether we mute or unmute, we'll have something  
35:39 - very similar for on Toggle video disabled. So this 
is for the button that turns everybody off and on.  
35:49 - Sort of mute local audio stream will have mute 
local video stream as sort of a muted variable, we  
35:55 - will have the video disabled variable. So almost 
exactly the same change the camera is even easier.  
36:03 - You have on switch camera. Here, we just call 
the engine and everything will happen magically.  
36:12 - And then finally, the last one is on 
call end, where we need to pass in the  
36:20 - the build context. And all we will do here is 
navigator that pop the context. So we go back to  
36:29 - the previous screen, they might say that doesn't 
really end the call that just jumps you out of the  
36:34 - screen. But we're going to handle that in a pretty 
nice way where we will add a Dispose method here.  
36:40 - So here we'll basically clean up this whole video 
call and whole RTM connection so that we have a  
36:45 - fresh slate whenever we go back into it. So first 
things first, we want to leave the channel for  
36:51 - the video call hash. Before we can do that we can 
clear the users that we have. So clear this local  
36:58 - variable of users that we have, that will leave 
the video call channel, and we can destroy that  
37:04 - video call engine overall, then this is the 
RTM channel, we can leave this channel as well  
37:13 - then log out of the client, this is the RTM client 
again, and then destroy the RTM client as well.  
37:22 - So we take care of the local state, we clear it 
will leave the channel and destroy the video call.  
37:28 - Then we leave the RTM channel, log out of 
the client and destroy the client as well.  
37:33 - And there we go. So that so that's a nice way to 
handle all that and call stuff because whenever  
37:37 - you leave, even if you click the back button, it 
will all execute this and call logic. So now we  
37:42 - should be actually able to run this project, how 
it will just see the participant. And when you  
37:47 - click the participant button, you'll be jumping 
in a call with just yourself. And we should be  
37:51 - able to see that person that says we're running it 
on Android, the way it works is they have like a  
37:56 - emulator camera, which is just this little 
pixelated image that they showed that  
38:00 - pretends like there's a camera there. Well, 
we ran into some issues, I tried to debug it a  
38:05 - little bit. So if there's no users there, I put 
out so that shows no users on the screen. But  
38:11 - if we try to join, you'll see no users at first, 
then the user joins, but it's just a black screen.  
38:17 - And when we leave, we get an exception called. Now 
this is because we missed a very important step,  
38:22 - we need another package called permissions 
handler. Now at this package, we'll be able to  
38:30 - ask for permissions to the camera and to the 
microphone. And you can't really have a video  
38:34 - call without permissions to that. So that was 
what we were missing. So we're going to need  
38:40 - two permissions, we need permissions 
to the camera. And we need permission  
38:48 - to the microphone. And we need to request 
both those. So this is for the participant you  
38:54 - and we need to do the same thing for the 
director view. Actually, I'm not sure if  
39:00 - it's necessary for the director. But if you want 
to add some functionality where you could bring  
39:04 - the director in as well, then you definitely need 
this. So now let's try to run it one more time.  
39:10 - Alright, so username is Titus show name. What 
is called tighter skin join as a participant  
39:18 - law to allow while using an app. And we want to 
allow while using this app. So we have no users  
39:23 - the beginning. And then we get this little Android 
emulator. Beautiful. Now we should be able to mute  
39:29 - this emulator. And you'll see the state changes 
here should be able to turn the camera off.  
39:35 - And I think this doesn't work because it is an 
emulator. So there's no camera to really turn off.  
39:40 - And we can switch camera because that works. 
There's like the back camera of the emulator.  
39:45 - And then we can of course end the call and 
they'll jump us back here where everything  
39:50 - gets destroyed. Sorry, that's the basic part of 
this application. Hopefully you understood all  
39:55 - because it's only gonna get more complicated from 
here. Or actually maybe it's not that much more  
39:59 - complicated. But there's definitely more pieces 
being added on to what we already have here. So if  
40:04 - you understood this participant section, this is, 
I think, the most complicated part of this whole  
40:10 - course, the rest, we're just gonna be adding on 
more stuff and making it all work together nicely.  
40:16 - Okay, so you got the participant mostly handled. 
Now it's time to start with the director app.  
40:21 - wherein I come back to the participants. 
Once we have the active users and the people,  
40:25 - the stage users all set up so that we can send 
them over here and we display a different view.  
40:31 - But now if you remember the director application, 
so first, we want to set up this director state.  
40:37 - This is going to be our state 
object that the director part  
40:40 - of the application responds to whenever changes.  
40:45 - And here, we're going to have the active users, 
lab users and then some other little things. But  
40:49 - let's focus on these active and lab users first. 
So this active users is the one thing that we're  
40:54 - going to have to go back to the participant side 
of things, because we want to not display just  
40:58 - yourself, but we want to display the active users 
within the actual call. So let's set up our state,  
41:03 - we need to first create our director model. 
So this is the actual data piece that we will  
41:08 - be tracking. This is this specific state. So this 
is what types of data we're going to be tracking.  
41:15 - And we'll have our PI create an instance of this 
data and use that instance as our state object for  
41:21 - the application. So we will have a class called 
director model, I realized my file naming isn't  
41:27 - the most consistent for these I just have stream. 
And this one is Director model. But I think it  
41:32 - just made sense in my mind, because we have a 
page director, we don't want to have a model  
41:37 - director and controller director too. So just to 
differentiate this a little bit from the director  
41:42 - page. So within the director model, we'll take 
a lot of things we had in the participants side  
41:47 - of things. So remember, when needed an RTC 
engine, linear a client on either channel,  
41:52 - so we will need those same exact things within our 
director. And for now, we're just going to have  
41:56 - three more things in here. And that is a set of 
active users, a set of lab users and local user.  
42:04 - So sets are pretty much lists, but you can 
only have one occurrence within that list.  
42:09 - So we're going to have a list of active users, 
our list of lab users, and then the local user,  
42:14 - which is the director. And here we could add a 
constructor. So we start off with an empty set  
42:19 - of both users. And then we will add a copy with 
method. So I do this using an extension called  
42:25 - Dark data class generator. And they do Command 
period, and you can generate a copy with class.  
42:31 - So this will allow you to change one thing within 
the object and still have the object. So let's  
42:36 - say you added a lab user to the active user, you 
can copy with the instantiation of this director  
42:43 - model that you have, except add a value to active 
user and remove one from here, and then you'll  
42:47 - have a new state object. And before we go forward, 
we're actually going to change something up a bit.  
42:53 - So I'm going to create a user class as well. 
So this user class will be called a gore user.  
42:58 - type of data will need here is a UID. Whether we 
are muted or not. Whether the video is disabled,  
43:08 - then a name for the user and the background 
color that isn't too important, but it makes it  
43:13 - look a little bit nicer. And I'll show you later. 
Again, we need to create a constructor for this.  
43:19 - Answer. Same way as we did before, we will create 
a copy with class. So if the user goes from muted  
43:24 - to unmuted, we can change this one variable and 
have an object with the new state. Now go back  
43:28 - to this director model, we can actually change all 
these ants to be a Gora users. Now we're ready to  
43:38 - go. One more thing. Let's jump back in here. So we 
have this list of users, we actually want it to be  
43:43 - a list of Gaura users. Instead of just adding the 
UID, we will add an A Gora user with UID of UID.  
43:55 - So we can keep things consistent throughout 
the app. Alright, next thing is setting up  
43:59 - the controller. So this is the workhorse of the 
application the behind the scenes state manager  
44:05 - of the app, we'll be using ver pod like I said, 
if you're not familiar with VO pod and state  
44:10 - notifiers. Specifically, there's some tutorials in 
the description that are recommended take a look.  
44:15 - But a state notifier pretty much holds this state. 
You can create functions in there that update it,  
44:23 - that we call those functions through this 
director screen. So we call those functions  
44:27 - they update the state that says it's a state 
notifier it will notify whoever is listening to  
44:33 - update their current UI or whatever it is they 
need to update because the state has changed.  
44:39 - So that's the gist of a state notifier. So to 
use a state notifier you need to create a state  
44:44 - notifier provider and we're going to go one step 
further and auto dispose it says auto dispose  
44:51 - basically whenever we stop using this provider 
it will dispose itself. Now within here we need  
44:55 - to give the type of what our state notifier 
is going to be and also what kind of state  
44:59 - We'll be managing. So let's create our state 
notifier, we will have a director controller  
45:07 - that extends state notifier. And the state that 
we will be managing is called a director model.  
45:16 - Now there's this reader that you will see us 
passing in this reader is super important.  
45:20 - So this allows you to read the state of anything 
within the provider scope. So any controllers  
45:26 - that you have within the provider scope, and 
if you forget what the provider scope is,  
45:31 - it's this thing that we surround the whole 
application with. So anything within this has  
45:36 - access to that read, are able to access any other 
controller that's within our app pretty much. And  
45:41 - during the first demo, I used another provider 
somewhere else, but in this case, we might not  
45:46 - even use it. So in here, we need the type of our 
state notifier. So we can just actually copy this,  
45:54 - paste here. And the second thing we need is that 
the type of the state we're holding as director  
45:59 - model, then all we need to do here is return this 
director, controller, with our reader. All right,  
46:07 - there we go. So our state is all set up. Now, 
we won't be doing anything right now with the  
46:11 - state. But just know it's there. And we're 
ready to work with it whenever we need to.  
46:16 - But the thing we're going to do now is actually 
set up our director screen before any of this.  
46:21 - So to do that, we're going to just take the 
scaffold and wrap the whole thing with a consumer  
46:28 - widget. Now, this is consumer, which has a 
requirement argument of builder. And we'll  
46:33 - take this scaffold and return it just like that. 
So what is this consumer to explain the consumer,  
46:39 - I went to the documentation, you can find all 
this through the river pod dot dev website.  
46:45 - And the reading about providers 
and there's a consumer over here.  
46:48 - And what they say about consumers is that it can 
be used to listen to providers inside a stateful  
46:53 - widget, or to rebuild as few widgets as possible 
when the provider updates. So this is the thing  
46:59 - that actually listens to the changes within our 
provider, in this case, a state notifier provider,  
47:04 - and updates our UI, to look how we want it to 
look based on the current state. So in here,  
47:10 - you will see this watch thing, we will use 
this watch to look for the director controller,  
47:17 - dot notifier. So let me type one more 
thing out and explain these as well.  
47:22 - So we have the director, Mark model, which 
will be our director data. And we will watch  
47:35 - director controller. Okay, so what's 
going on here. So when we just watch  
47:43 - our director controller directly, we we get this 
director model. So we get the current data within  
47:51 - that provider. When we do director controller 
dot notifier, we get the director controller.  
48:00 - So we get this first part. And if you see 
if we actually hover over the notifier,  
48:04 - we get the director controller here. So the 
structure controller will give us access  
48:09 - to all the functions or need to update our 
data. And this data will give us the current  
48:15 - data that we need. So just as a quick 
example, we might do director notifier, dot  
48:22 - new user, or something like that. But then we'll 
have a text widget that is tracking the director  
48:32 - data, active users element at one muted. So 
this is a live example. But pretty much, we  
48:41 - have one thing that will do the actual muting of 
a specific user. But then when we get that user,  
48:46 - maybe user one out of the active users, we can 
read it state from the director data. Okay,  
48:52 - so now everything's ready to go. And now time 
to implement all these features. So we're going  
48:56 - to start off with the initialization 
and pretty much them joining the call,  
49:00 - want to initialize this video call and actually 
join the call from the director point of view.  
49:06 - Now it won't be showing the director camera or 
anything, but we still want him to be within  
49:10 - the call so you can control everybody. So the 
two main functions are going to be joint call  
49:16 - and then also leave call. Now that joint call is 
going to be a little bit more complicated, but  
49:22 - leave call if we go back to the participant screen 
is going to be the same exact way as we did here.  
49:30 - Except this time, we don't need to clear any 
users because we're holding the state within this  
49:34 - director controller. You notice we get some errors 
here because we don't have a private variable of  
49:39 - engine declared. But remember, we have a state 
of director model and the director model has  
49:44 - engine client and channels. So we can do 
is we can create a cursor like this and  
49:48 - then just type out state DOT engine and 
everything will work but we'll get this because  
49:52 - in this case the engine isn't delete variable. 
It's actually something that we're will have to  
49:58 - make nullable due to The way this whole directory 
controller setup. So that's how we're going to  
50:03 - leave the call. Now to initialize it, we're going 
to break it up a little bit, we're going to have  
50:08 - a function called initialize, which will be a 
local function that does all the initialization.  
50:15 - Summary, the two main things is we need an 
engine and a client. Same way we did here  
50:19 - want to initialize the Gora, first thing 
to do was create the engine in the client.  
50:24 - If you remember, we created the channel a little 
bit lower in the whole process. And that's exactly  
50:28 - how we're going to do it here. Actually, to 
make it easier on ourselves, we could literally  
50:32 - just copy paste this here. But we're declaring 
these here. So we need to set them or TC engine  
50:42 - to that, and then import this as well. 
And also import a core RTM client  
50:49 - and import app ID. Now initialize it, but they're 
initialized into local variables want to actually  
50:56 - add this to the state. So since this is a state 
notifier provider every single time, we want to  
51:01 - update the state, we have to set it with a new 
state variable so so we're not amending it, use  
51:07 - a change notifier for that, or a state notifier, 
we're setting a completely new thing. Of course,  
51:12 - for this initial time, that obviously makes sense 
since we're creating an object for the first time.  
51:16 - But this is a key point to remember about state 
notifier and say notifiers providers is that  
51:21 - you're going to have to update the state every 
time and reset it to that state variable. And  
51:25 - that's why we implemented that copy with function 
here. Because we could take all the previous  
51:31 - things that we don't want to change and copy with 
the new values. Okay, so we have initialized,  
51:38 - now need to do this whole middle section. And then 
again, we go to the participant side of things,  
51:43 - and we could pretty much copy paste this, 
obviously, we're going to need to update  
51:46 - specific parts. But the essence is very similar. 
So wherever we see engine, we need to do state DOT  
51:54 - engine, wherever we see client, we do state 
DOT client mesh, you get some issues here,  
52:03 - because this is named the same thing, but 
we're going to change it to st instead.  
52:07 - And now the last one is the channel, we can 
change to state DOT channel. So I'm joined  
52:14 - channel success, we don't need to do anything 
here, we're just going to print out director  
52:23 - and the UID. So we can just see if they joined 
here, leave channel, we don't really have to do  
52:31 - anything here. And the rest of the event handlers 
will handle a little bit later. Sir to log in,  
52:37 - there's no widget necessary. Because we're 
actually past the channel name and the UID.  
52:43 - We can just remove that. And actually the one 
thing that is definitely hard to catch here  
52:48 - is we're setting the state channel. If you 
remember I said I mentioned we reassign that  
52:54 - state variable every single time if you want the 
UI to update. So this doesn't really work for us.  
53:02 - What we want to do instead is 
state DOT copy with channel  
53:11 - and then pass in this channel that we're waiting 
for. So now this will create the channel and we'll  
53:16 - be able to access that state channel whenever we 
use it. So now we got all the setup for a Gora,  
53:22 - an RTC and our TM setup. And we can close this 
function a little bit until we need to add those  
53:26 - event handlers. And it won't clutter up too 
much stuff. Let's close this initialize and,  
53:34 - and we can even close this leave call. So now we 
want to test it out and make sure that we get this  
53:41 - director and the UID printed out. So like I said, 
we're going to do that in the Init state where  
53:45 - we try to join the channel. And in here, since 
we don't really care about the return of that,  
53:50 - we're going to read our director controller that 
notifier click the Join call function. And we have  
53:59 - a channel name that is passed into this widget and 
we have a UID that's also passed into this widget.  
54:05 - Or so I thought I guess it's not passed 
in yet. So we want that to be passed in.  
54:14 - Alright, we've got on the home screen 
and then Director screen now as well.  
54:19 - So this context read, if we look at the 
description, it reads a provider without  
54:24 - listening to it. So just watch, we're listening 
to all the changes and we want to update  
54:28 - depending on what's going on here. 
And here. We just read it and  
54:32 - we forget about it. So we would just call that 
join call function, let it do the rest and we  
54:36 - don't even have to worry about it. So okay, then I 
think the director applications should be working  
54:40 - now. If we run it, we should see our emulator pop 
out a director with the UID print out just like  
54:46 - that and then we'll know everything works on this 
end. Okay, so we were able to get to this screen,  
54:52 - we see that the store ID is 634657764 and we 
joined the director sees something very similar  
55:02 - So username, we'll go with Titus, 
Titus here, click director,  
55:09 - we get to the director screen and director 
Boom 634657764, the same exact UID  
55:18 - as you got there. So it seems like everything 
works, we're able to join the call.  
55:23 - Now we can move on to the next section. 
And that's actually bringing on people  
55:26 - into the lobby and into the staging, 
managing multiple users within the call.  
55:31 - And we're going to do that by going to the 
director controller, and then there's join  
55:35 - call function. So remember, I said, we're going 
to add more events to the event handler, we're  
55:40 - going to have an event for user joined, and user 
offline. Now in this first section, let's just  
55:45 - print out that the user join. So we can have all 
the details in there. And here, we're just going  
55:49 - to have to implement two functions. So we're going 
to have add user to lobby, okay, I need their UID.  
55:58 - And then when the user jumps offline, for whatever 
reason, we want to remove user. Again, wanting to  
56:05 - define which user we want to remove. Now, let's 
close up this joint call function and implement  
56:12 - those two functions. So the first one we're going 
to have is the Add User to lobby and remove user.  
56:20 - And we see these errors that we had here go 
away, now we just need to implement them.  
56:24 - So these two functions are actually pretty 
straightforward, we just need to add a user  
56:28 - into our lobby users set. So let's get 
into since since this is a state notifier,  
56:33 - we need to reset that state variable. And we'll do 
that with a copy with me to update the lobby users  
56:41 - value. We're going to do that by taking 
the old lobby users. And I forget what this  
56:50 - what this is called again. So this is called 
a spread operator, you put these three dots  
56:55 - before a list, and you get all the values 
within that list added into the previous  
56:59 - list. And same thing works with sets. See, we're 
taking all the lab users putting them in a list.  
57:05 - And then at the end, we will add another 
lobby user. So be defined as an a gore user.  
57:14 - Eu ID, we're getting that passed in. 
We want them to be muted at first.  
57:21 - They want their video to be disabled at first as 
well. The name, we don't have that part sorted out  
57:26 - yet. We'll actually instead of naming a weight, 
we'll name it to do to dude. And background color.  
57:35 - We also don't have this sorted out, but I'll set 
it to blue for now. We'll do that real soon. But  
57:42 - let's implement the remove users. And then also 
allow them to be moved into active users as well.  
57:49 - So the Remove user is actually a little bit 
more complicated than the Add User to lobby  
57:52 - since we need to check in both the lobby and in 
the active user state. But it's still not too bad.  
57:58 - So first, let's create some temporary 
sets. And then all we have to do is  
58:02 - loop through all of these people in the 
active users list and in the lab users list.  
58:09 - So you see this as a nice for loop that goes the 
length of the active users checks if the element  
58:14 - at that user is equal to the UID, which we want 
to remove, and if so remove it from that list.  
58:19 - And once we have that update the state with our 
new active and new lab users. Now we're going to  
58:26 - switch a little bit to the UI side of things. So 
we can actually see this stuff working in action.  
58:31 - But before we do that, we're going to set up the 
base of the next two functions that we're going  
58:36 - to need to add. So we had add user to lobby remove 
user, but there's two more functions that we need.  
58:42 - And that's to be able to promote the user to 
an active user while they're in the lobby. And  
58:47 - to demote that user from an active user back into 
the lobby. And I guess before we even go to that,  
58:52 - maybe it makes sense to actually implement these, 
they're not that much more complex than these  
58:56 - other functions. So to promote the user, the lab 
user to an active user, we want a temporary lobby  
59:02 - of all the current lobby users. And then this temp 
color and temp name is this name and color that  
59:09 - we're assigned right here. They're obviously not 
initialized, but we want to pass that value on to  
59:16 - the active user as well. So similar loop, we loop 
through the temporary lobby, we check when the UID  
59:22 - is equal to the UID that we want to promote, 
let's say this temporary color that we have.  
59:28 - So from the cigar user, we're just copying 
this these values into a temporary variable  
59:33 - and then removing that person from the temporary 
lobby. After remove it, we need to set the state  
59:38 - again. So now the active users will be the 
previous active users plus a new agora user  
59:48 - with UID UID. Background Color equal to temp 
color and their name will be equal to temp name  
60:00 - Okay, So recapping, we updated the active users 
to have the new active user. But remember,  
60:04 - we also update the lab users to use the new 
lab users without the specific person in there.  
60:12 - And now we could pretty much 
copy paste the same exact thing.  
60:16 - So very similar code for the demotion process. But 
wherever we see, lobby, want to change to active.  
60:27 - And then wherever we see active, want to change 
that to lobby, the only difference here is we want  
60:32 - to make sure they are muted, and that their video 
is disabled. Okay, so even that's added and no,  
60:38 - so the management of all the users going between 
the active users and lab users is all complete.  
60:45 - Now let's implement the UI so you can actually 
see it in action. So for the UI part, we might go  
60:50 - a little bit faster, just because the UI I think 
matters a little bit less the how the actual back  
60:55 - end of it works, I think, is the most important 
part of this course. But I still wanted to cover  
60:59 - the UI here. So we have our whole scaffold wrapped 
in this consumer widget. So if you remember,  
61:04 - this will keep watching our state for any 
changes. And we'll be able to update our  
61:07 - UI whenever any of those change. So inside the 
scaffold, we will actually be doing a custom  
61:16 - scroll view. Because we can have a bunch of people 
within the call within the lobby within the active  
61:22 - users and want to be able to scroll nicely. And 
then this will be implemented using slivers.  
61:28 - So the first section will have 
a sliver list. A sliver child  
61:37 - list delegate. And here we'll just add a nice 
safe area where for now we're just put the  
61:44 - word director in there. So if you don't know what 
Slivers are, Slivers are pretty much little pieces  
61:49 - of code that work well with within a scrollable 
view. And so the sliver list is very similar to  
61:56 - just a widget within the sliver. So like a nice 
row, within a sliver view, or within a custom  
62:04 - scroll view. So the next part is we're going 
to check whether the users are empty or not.  
62:10 - So I take the director data and see if 
there's any active users. And if it's empty,  
62:16 - we will just display another sliver list that says 
this is an empty stage. But this is where it gets  
62:23 - a little bit more interesting. Here we'll add a 
sliver grid. So for the sliver grid, we'll need  
62:29 - a delegate and a grid delegate. So for the grid 
delegate, we're going to define something called  
62:34 - a sliver grid delegate with Max cross axis extent. 
So this section pretty much defines how big each  
62:40 - of your children are going to be. So here, we 
define the maximum extent of the cross axis  
62:45 - for each title, we wanted to take up half of the 
screen, I wanted to have some spacing in the two.  
62:52 - And the way we get half the screen as we get as 
there needs to get the size object. And we're  
62:56 - just going to define it up here, because we'll 
probably use it in a different section as well.  
63:03 - So we define the size by doing media query 
context, dot size. And this determines the  
63:08 - size of how many pixels is the size of our screen, 
pretty much. So we take the pixels of our screen  
63:13 - divided by two, that's how much each grid element 
is going to have. But we also want to have it give  
63:17 - us some spacing of 20 pixels. And that will give 
us the look that we want. Then there's a delegate,  
63:22 - which is the actual child. So this defines 
what we want each child to look like and how  
63:28 - many children there is going to be. So here we'll 
use a sliver child builder delegate. So in here,  
63:36 - I just decided to cut and paste to make a little 
bit easier. But let me explain to you. So at this  
63:40 - sliver child builder delegate where we get the 
context and an index for which child it is.  
63:47 - So total child is going to be the active users 
dot length, so how many active users we have.  
63:52 - And then each child will have the following 
design, where we'll have a row, and we expand it,  
63:58 - and then create this stage user. Now the stages 
here, I'll just paste it in. And then we'll  
64:04 - set up the rest of it and show you what the UI 
looks like and go through this in more detail.  
64:10 - I think it's kind of hard to imagine just with 
words, okay, and then we put a little divider in  
64:15 - between. So once again, using a sliver list. And 
here, we'll just do a divider with thickness of  
64:20 - three, and then some indents on the side. And then 
literally a copy paste of this above thing for  
64:25 - active users, except the same thing for lab users. 
Now, again, we need to implement this lab user,  
64:31 - but I'll just copy paste in. It's the same layout 
as the staged user. But I think it'll just be  
64:37 - easier to showcase when you could actually see 
the UI as well. So I think that's the UI for the  
64:41 - most part I know there's a lot of higher pacing 
here but we're going to go through it right now.  
64:45 - After we started up so I could actually 
showcase you with an example app and,  
64:49 - and what each part actually does. Okay, so we 
have user name. We'll just call it director  
64:57 - says username doesn't really matter channel will 
go to Tada. Click director. And we should see  
65:03 - this weird director text at the top. It's there 
for a reason right now, you'll see it soon. But  
65:08 - we could have just added an empty container there. 
Actually, let's let's do that just to make it  
65:13 - just to make it a little bit less 
cluttered. So with an empty container,  
65:16 - it's a little bit less cluttered. And 
we have the stage and the lobby here,  
65:21 - now actually need to join from a different 
device for the first time. If you remember,  
65:25 - in the director controller, when we said when we 
joined, we have a color of blue, and the name has  
65:30 - to do, that's what we get here. This is why we set 
the colors. So we're going to let the people input  
65:35 - their colors and have their names appear here. But 
for now, it's to do and the color blue. So this is  
65:40 - the design that we have. And there's actually one 
piece I missed to make it look a little bit nicer.  
65:45 - Actually, within the scroll view, 
let's add some padding around this.  
65:50 - And we could actually keep it at eight. So 
now it's going to look a slightly bit nicer.  
65:56 - So back to the lab user, let's see what we did 
in order to get this UI. So use a clip, our  
66:03 - rec service takes the rectangle that we created, 
we created the blue rectangle and takes off a  
66:09 - little bit of the border. Now in this case, we 
actually check if the video is disabled before  
66:14 - showing our stack of widgets, FS not disabled 
will actually show their view. And I realized  
66:19 - this probably isn't necessary anymore, because as 
a lab user, your video should always be disabled.  
66:24 - So we could simplify this a little 
bit. So in this clip the rectangle  
66:28 - we have a container that has the color 
of blue that we pass there and with.  
66:35 - So this is the we take the lab user, and at that 
element, we take their background color value.  
66:41 - So the background color value is blue. And for 
some reason, there's some air with this background  
66:46 - color will display black. And if there is no 
name, we display error name, but we take that  
66:51 - lab user at that specific element, and we display 
his name. And this one we have to do so I guess  
66:57 - we could have not added to do or color. In this 
case, we would just get black and an error name.  
67:03 - And then this is all within the stack. So 
on top of it, we have a little container  
67:08 - with again, a border radius 
of 10 to fit into the corner.  
67:13 - And that's that's what this is. So it's like 
a little button that fits into the corner.  
67:19 - We made it a little transparent 
black. And whenever we press on it,  
67:23 - we will promote this user to an active user. 
And if we set everything up within the director  
67:28 - controller correctly, or press this button, we 
should be taken into the stage. The video should  
67:34 - come in of me. And we should have a very similar 
UI on the stage. So let's try it out now. Tada.  
67:47 - So here we go. So for the stage user, we have a 
very similar UI, we'll have the same rectangle  
67:53 - that we had here. I said now we actually care 
about the surface view that we would have.  
68:00 - And then we want to put buttons on top of that 
service view. So we'll have different buttons,  
68:04 - one to either bring the user back into the 
lobby like this, or to turn off their video  
68:09 - or to turn off their audio, and the video is 
turned off, we'll have a nice video off screen.  
68:15 - Then this section takes that background color that 
we have from the user puts at the bottom corner,  
68:20 - and then tastes their name. And as they hear, 
as long as you know their names available. I  
68:25 - noticed we have these buttons over here. So I 
kind of said some of the functions out because  
68:29 - these aren't implemented yet. But when we click 
on these will toggle the other users audio and  
68:35 - the other users video, these buttons have a very 
similar setup as what we saw in the lab user,  
68:40 - except there's three of them now. And they also 
change colors depending on the state. So when the  
68:45 - video is disabled, this will be red on the video 
is enabled, this will be white, and same thing  
68:51 - with the mic muted. So that's what the stage user 
widget looks like. So the next step we're going to  
68:57 - do is actually implement these toggle user audio 
and toggle user video functions. So these, when  
69:03 - we see the word toggle, that's when we're doing 
it as a director, we're toggling them on and off.  
69:08 - But there's one thing to remember is that the 
participant user can actually click these toggle  
69:12 - buttons on their own side. And we need to update 
these states based on that as well. How to do  
69:17 - that through the event handler where we will find 
there some functions to check whether the user has  
69:21 - updated the audio or video, we will be adding 
four new functions here. So first one will be  
69:30 - toggle user audio will need to pass in which index 
of the user is so in the UI, we actually know  
69:37 - which active user needs to be toggled so we could 
just pass the index directly make it a little easy  
69:42 - on us. And then if we want a muted we will send 
a message to mute and otherwise want to unmute.  
69:52 - Send a message to unmute. They might be asking why 
are we sending a message instead of unmuting them  
69:59 - directly so This mute functionality is actually 
going to be a sending a request for the user  
70:05 - to mute themselves. Actually, maybe that made 
some more clear to start with the update user  
70:09 - audio then. So this gets a little bit complicated, 
because again, we need to rewrite the whole state  
70:14 - object here. So we're going to do is actually 
take the whole agor user, we're going to find  
70:20 - the element where the UID equals the UID, we pass 
in, we're going to set that to a temp variable,  
70:27 - however, a temporary set of active users, we're 
going to remove that specific temporary user,  
70:33 - I'll add that user back in with whatever 
mute state that it needs to be added in with,  
70:39 - now we just reset that state or reassign 
that state with the new active users.  
70:46 - And that should totally work fine. Now, 
there might be a better algorithm to do this,  
70:50 - there might be a simpler way, a more 
efficient way. But this works just fine.  
70:56 - Now, let's copy this function. And change 
this to update user. video instead.  
71:05 - So same logic, here, we're going to find 
that user within the Active Users list,  
71:09 - we're gonna create a temporary set. 
But then instead of copying muted  
71:16 - when a copy video disabled, now need to execute 
those functions when an event gets triggered.  
71:24 - And the event that we want to get triggered is 
remote audio state changed, and for the other  
71:29 - one will be remote. Video state changed. And 
here we will check. His state is equal to audio  
71:40 - remote state decoding. And if we take a look 
at it, what this means it means remote audio  
71:47 - stream has decoded and plays normally. So that 
means we're unmuted and we should be playing.  
71:53 - And then we can actually just call that update 
user audio with the UID and muted with false.  
72:01 - Then otherwise, if state is equal to audio remote 
state, that stopped, want to update user audio to  
72:12 - be muted, in this case, very similar thing 
here. So we need to change this to video.  
72:23 - And change this to video disabled. So you can 
actually test this out on our device to see if  
72:30 - it updates to the correct color. Alright, 
again, the username doesn't really matter.  
72:37 - Channel name, Thomas will go to director. 
Nobody here. I'll join on my end.  
72:46 - Here we have a participant. I'll 
bring this person into the stage.  
72:56 - And there we go, I'm muted. And you can 
see the red icon. By turn on my camera,  
73:01 - you see video off and camera turns off. I turn 
it back on, everything seems to be working well.  
73:09 - Okay, so that section was if the user mute 
themselves on there, and so we have it updating  
73:14 - accordingly. Now as last part is we need to, 
we need to be in control of them as well.  
73:21 - So we have toggle user audio and toggle 
user video, we had toggle user audio,  
73:27 - almost implemented. Yeah. So we need to be 
sending a message to mute and unmute them.  
73:34 - And this were our Gore RTM comes in real handy. So 
we're going to send them a message, they're going  
73:38 - to mute themselves. And then through this function 
that we implemented up here, update user audio,  
73:44 - we will get their updated state here but 
they will pretty much be muting themselves.  
73:49 - So we want to do here is take the state and 
it's going to be a channel wide message.  
73:58 - So we're going to send a message and the 
message is going to be formatted like this.  
74:03 - So yeah, our Chem channel from text that 
our Tim channel RTM message from text.  
74:16 - And if we're already muted 
that means you want to unmute  
74:23 - and we want to make sure to give 
the UID of who we want to unmute.  
74:29 - So our message is going to say unmute 
followed by UID. Same thing here  
74:40 - except here we are no muting what 
that Id are looking copy paste this  
74:49 - and change this a toggle of user video. 
Instead of muted. He will just say a name  
75:06 - If enable, we'll use the word disable this 
UID. And then if it's already enabled,  
75:11 - we will enable it. So the next part of this is we 
need to accept these messages and do the correct  
75:17 - actions upon these messages. But in order to 
not jump around everywhere, let's add all the  
75:24 - other RTM send messages in here. So if you 
remember back to this drawing, to participant,  
75:29 - you, you shouldn't be seeing yourself, right, we 
need to be seeing all the people within the stage.  
75:34 - So we need to somehow send all the users that are 
within the stage to the participant. And that's  
75:40 - going to be the last type of message that we're 
going to be sending. So we're going to send audio  
75:43 - mute and unmute messages, we're going to send 
video enable and disable messages. And we're going  
75:47 - to send active user messages. So these are going 
to meet need to be executed every single time  
75:52 - something changed with the user. So all four of 
these functions, we'll need to have some sort of  
75:57 - active user message. I'll actually create another 
util here. We'll call it message that Dart. Now  
76:06 - these helpers are going to be used to make it just 
slightly easier for us to work with sending all  
76:10 - the list of active users. So we're going to have 
a class called message. And it's going to have  
76:18 - a function inside that returns a string, because 
our team message needs to be a string. And we're  
76:24 - going to call this son active users. So we 
need to be passed in a set of agor users  
76:38 - will need to be turning this set into a string 
value. So our string will start with the keyword  
76:46 - active users followed by 
space, the space is important,  
76:50 - then we set up a four loop to 
go through all the active users.  
76:56 - And let's actually set up our 
return to return the user string.  
77:01 - Out in this for loop, we're going to append on to 
the user string. So the user string plus active  
77:11 - users dot element at this specific index, we 
take their UID turned into a string and then  
77:25 - add a comma after that. So this is where 
our messages are going to look like.  
77:33 - It's going to look like active users, which is a 
keyword we're looking for, and followed by UID,  
77:39 - UID, UID, UID. Okay, we're going to send 
out this string. But when we receive it,  
77:46 - we actually need to parse that specific 
string and get that list of users again.  
77:50 - So let's create that function here. So we want 
the list of gore users. Parse active users,  
78:01 - I'll pass in a string of UU IDs. So before this 
step, we will look for a space within the code  
78:10 - that will tell us that this is active users 
and we will send the string of UID UID UID UID.  
78:20 - So this the type of string that 
we're going to retrieve here,  
78:24 - so I'll create a list of the strings 
and split them where the comma is  
78:28 - out here to be turned into a gore users. So 
we can use it within our app. So we'll need to  
78:34 - loop through all the gore users who will check 
if this is an empty string, because remember,  
78:40 - we're parsing on every comma. At the end, there 
will be an empty string here with nothing.  
78:47 - So I want to get to that point want to continue 
out of the for loop and keep keep going. Before  
78:52 - we get to that part, we want to take all the users 
and we want to create a gore users from that UID.  
78:59 - And we get that from the list of strings that 
we have. We parse it, turn it into an integer  
79:04 - and set it to our UID. And finally, we're ready to 
return to users. Right? That was a little bit more  
79:10 - algorithm heavy. Hopefully, this all makes sense. 
We're basically working with string manipulations.  
79:17 - Now going back to Director controller, 
so so we need to add it to these four  
79:22 - functions. So when we add the user to 
lobby, we want to set out send out a  
79:27 - message of these active users so that the 
participant can update their own screen.  
79:33 - So we take the channel, send message, or 
message is going to be a Gora RTM message.  
79:44 - From Text we're gonna call that message 
class we created and say send active users  
79:54 - and active users we're going to send as the 
current state of active users because we  
79:59 - already just updated that state right here.  
80:02 - So we updated, the state is new and ready to 
send out. Now when we promote them to active user  
80:09 - can copy that same thing. There'll be a new 
user. But on top of that, we want to add two  
80:15 - more messages, want to unmute that person, and 
we want to actually enable their video as well.  
80:23 - We don't want to have them come into the 
stage and their videos off and everything,  
80:27 - that'd be a mess. So now when we're demoting them 
to a lobby, we want to do the opposite of this.  
80:36 - Well, except for that last line, we'd 
still just want to update with the current  
80:39 - state of the active users. But in this case, 
you want to mute that user and want to disable  
80:46 - their video. And lastly, when we remove a user  
80:54 - we'll send them to new active users as well. 
And we don't have to worry about muting or  
80:58 - muting them because they're gone. Okay, we're 
getting very close to the finish line here.  
81:02 - So next part is we want to retrieve the states 
with the participant side of things, I want to  
81:09 - address those actions that are those messages 
that are being sent over, we want to listen to  
81:13 - them and do the correct thing. So you remember 
these messages, we were sending out our channel  
81:17 - wide messages. So we're going to be using this 
section a lot. So this is where we'll see our  
81:22 - message and which member sent it and all that 
stuff. So first thing we need is to parse for that  
81:29 - space that we added. If you remember all of 
our message definitions, we have that first  
81:35 - identifying word either enable mute, on mute, 
disable, or active users, followed by a space.  
81:42 - So we're gonna split that text into a list of 
strings based on where the spaces now we're gonna  
81:48 - set up a switch case statement, we can look at the 
parsed message and position zero because we know  
81:54 - there should be two positions total, the first 
specific word and then the rest of the message.  
82:03 - So in the case that we need to mute, we will 
check the parse message and position one  
82:15 - will check if it's equal to our UID. So we 
need to set the state of muted to equal true,  
82:23 - since we want to meet this person, and insists 
that only does it locally like on our side of  
82:28 - the app, we want to also let the engine know 
that this person has muted themselves. Now this  
82:35 - mute local audio stream will trigger our director 
controller event for remote audio stay changed.  
82:41 - If it's muted or stopped, this will execute. 
And then the rest of the logic executes. And I  
82:47 - can imagine we'll have something very similar for 
the other cases. So we'll have the case of unmute.  
82:54 - Where this is just false. And this is false. And 
now we'll have the case of disable and enable.  
83:12 - Or this will be video disabled. 
And this will be mute video stream.  
83:22 - Last one is actually becomes pretty easy for 
us as well, because of how we set up that  
83:27 - parts active users function. So we get active 
users as the first part of that parse message.  
83:36 - Let's add a break in here. So we don't forget, 
all we have to do is set state and set our current  
83:44 - users to message parse active users. UID is 
going to be parsed message at index one. He just  
83:58 - can't be a setter, because it's final, who made a 
final, I didn't make a final was supposed to be.  
84:06 - Okay. So all the messages are accounted for. Now 
one of the last things we need here is to actually  
84:14 - show the UI of all the users. So toolbar is 
pretty much done. The main thing we had to  
84:21 - do is is broadcast you. I think I'll just 
copy paste this in here because again, it's  
84:27 - it's not the most important part of this 
application that we're dealing with.  
84:31 - And this reminds me we need one more 
thing to add in. So this active users  
84:35 - so want to have this variable called active 
user to know if they're on the main page or not.  
84:40 - Because we don't want to display all the buttons 
we don't want to have them the ability mute or  
84:45 - change their cameras if they're not even on the 
screen. And let's actually change this name to  
84:55 - local user active because we Have the active 
users over there, I don't want to get confused.  
85:05 - So we'll update this. And I explained that logic 
in a little bit, but let me update the buttons  
85:10 - first. So we have the mute button here, want 
to check if the local user is active, if he is  
85:17 - active, then we want to display that Material 
button. But if he's not just display an empty  
85:23 - size box, then call button we do want because 
we wanted them to be able to leave the call.  
85:31 - But the video disabled button we don't want again,  
85:36 - same situation as above, we'll just create 
an empty size box. And then switch camera,  
85:41 - we again don't want this. And if it's not active, 
then we want to display a sized box again.  
85:50 - Alright, so there, the buttons are updated. 
Now let's go through the view a little bit.  
85:54 - So as broadcasts, you gets all the render views 
that we have. And the render views function,  
85:59 - we have a list of all the users. So we 
have the gourd user with the UU IDs.  
86:06 - We go through that list. If the 
list is equal to your own UID,  
86:10 - then you create an RTC local surface view. 
So that means it takes your camera view.  
86:15 - And that's what we're going to be using. 
And we're going to be putting the user's  
86:19 - username at the bottom as well. And then so if 
we already did a check to see whether you are in  
86:25 - the active users list, so if you are 
then check if local active gets set.  
86:30 - And that's how we set the local user active thing. 
Otherwise, we will use the RTC remote surface  
86:37 - view. So this means a surface view or a video 
view that is not coming from your own device.  
86:45 - And then again, same thing will have their 
username at the bottom right. So you get these  
86:50 - stacks of different views. And now we need to set 
them into a grid of what we want to look like.  
86:56 - So if zero, you take up the whole screen, if it's 
two, you take up the top and bottom. And then if  
87:01 - you have three or four, you set them into their 
own view, if you want or need to add even more,  
87:05 - you can with a golfer you can add up to 17. And I 
think that might be increased soon, even. I mean,  
87:10 - he's expanded views just put this into an expanded 
role pretty much. So that's that's the UI,  
87:17 - the core thing you want to understand here is 
how the gore logic works here, the UI is I'm not  
87:21 - as worried about alpha or UI key don't even have 
to worry about that in the first place. So okay,  
87:25 - let's run it. Let's see if it works. Okay, 
so we will first try out the director part  
87:32 - where we'll try to mute the people. So 
when we join will see is blue to do again,  
87:37 - on my side, I see only and call button, 
but we'll showcase that here as well.  
87:42 - And then we bring the user in here, we should 
be able to mute them. So let's try it out.  
87:47 - There it works. And I can actually see our mind, 
we'll swap the roles around and then I'll show  
87:52 - you there too. But I can show you here, we 
turn off the video, and makes the video off  
87:57 - and everything's working well. Now, let 
me show you this from a participant point  
88:03 - of view. So if we join as a participant 
received and call button with nothing else.  
88:08 - So this is the lobby, we don't see anybody in the 
lobby, but when we try to bring the person in,  
88:13 - you will see we had the name director, 
and we have that little Android emulator.  
88:18 - And now I won't see my mouse here, I'll click mute 
on the other end. And you see the state updates  
88:25 - here to be muted, and I can turn off the video. 
And those still see it here locally, because we  
88:30 - don't update the UI to do anything when our video 
is off. And we're still technically on the stage,  
88:37 - we see the status updated. So okay, everything 
seems to be working well. So last thing we need  
88:41 - to do is add some logic to generate the color 
and send the name of the user to the director.  
88:48 - And we're going to do that within the participants 
to join channel success. So this is when you  
88:53 - successfully join the channel on your own. And 
I can actually remove this users that add here.  
88:59 - Because we're not relying on this anymore, the 
director is sending us all the information for  
89:03 - what users we actually need to display. I actually 
saw a little hiccup on my second device when this  
89:09 - first launched, because I saw the screen pop up 
for a second and then go back to nothing. Because  
89:15 - we added that user here on this joint channel 
success. But then as soon as we received the  
89:19 - message, we set that back to nobody. So that was 
a bug that would have totally been hard to spot.  
89:24 - So let's generate a random color and then 
also give the name that we want to pass.  
89:28 - So to get a random color. We're just going to 
do random dot Next, double multiply by that by  
89:41 - all the colors and turn it into an integer. And 
to send these we're going to be using a local  
89:48 - attribute that we can get access to from the 
director directly. It's a good way to phrase it,  
89:55 - so on to add or update local user attributes. 
This attribute is going to be name and color. So  
90:04 - see these local attributes take in a list of maps. 
So we need to create key value pairs for the name  
90:11 - and for the color. So the first one is 
the name. And then let's get the color.  
90:19 - Color, the key will be color, 
and random color.to string  
90:25 - to string as what we will want to pass 
here. So on the director side of things,  
90:32 - if you remember when we first 
joined, right here, we just set it to  
90:37 - a to do and colors blue. Instead, 
we're going to get the user attributes.  
90:46 - And we do that by asking the client for the user 
attributes for this specific UID. And to access  
90:58 - them, we just get the key value pairs, we'll 
look for a name. And to set the color, we want to  
91:07 - get the integer, and then user attributes.  
91:13 - Color. Okay, now unless I'm missing 
something, we should have colors here.  
91:22 - So there we go, we joined, you'll see we got a 
random color, we see the name Thomas, if we leave,  
91:30 - join back, oh, should get another random color, 
I believe, a darker green. Hopefully, they're not  
91:36 - all going to be greens. Yeah, we've got a nice 
orange here. If we bring them into the call,  
91:41 - we'll see the same orange with the name down here 
seems to be working great. Nice. So all the core  
91:49 - logic with the lobby and active users and sending 
RTM and RTC messages is all done. We're getting  
91:55 - all the people within the call. And now the only 
thing left to do is to actually stream them out to  
91:59 - all the other platforms. And to me, this is the 
most exciting part. So if you remember, we had  
92:04 - this model set up called stream, but we never 
added anything to here. Let's change that. So  
92:09 - first, we're going to create a Num called stream 
platform, we'll add YouTube, Twitch and other  
92:22 - they'll have a class called stream destination.  
92:28 - This will have a string platform 
and a URL where we want to stream.  
92:33 - So this is a very simple class, we just 
want the platform and then the URL.  
92:37 - So this section even though it might seem like 
it should be complicated with a gore, again,  
92:41 - it's not too bad. So let's close all these 
functions just to make our code a little bit  
92:45 - more readable. And at the bottom here, we're going 
to add a couple more functions. And before that we  
92:50 - need to update our director model to because we're 
going to need to store a couple more things here.  
92:56 - So first, we need a Boolean for his life. So know 
whether we are currently live streaming or not.  
93:03 - And then we will need a 
list of stream destinations.  
93:11 - So that we know where to stream to. And then we 
need to update that copy with function. But again,  
93:17 - we need to fault for that. So we're going to start 
with false. And our current destination starts  
93:24 - with zero. Alright, so now that we got that data 
in there, we can go back to Director controller.  
93:30 - And we could work with that now. So we'll 
have data for whether we are live and all the  
93:34 - destinations we want to stream to. So the first 
function, we're going to want a start stream,  
93:38 - second function will be called Update 
stream. So if the user gets brought to stage  
93:43 - law, the stream is live want to update that 
user, we want the ability to end stream,  
93:49 - then a function for publish destination. 
And we're going to need to import this enum  
93:53 - as well. So add publish destination is when 
we click we want to publish to YouTube,  
93:58 - or Twitch, we will add that into our 
destinations. And then if we add it,  
94:02 - we need an ability to remove it. So these are 
actually the last functions that we're going  
94:06 - to need within our controller. One thing we 
want to do before diving too deep into that  
94:12 - is whenever there's a change with the active users 
want to check if it is live, and if so want to  
94:19 - update that stream. So this is the scenario 
when you get promoted to an active user.  
94:24 - This is the same scenario when 
we demote to the lobby user.  
94:28 - And then also the same thing if we remove the 
user. While this isn't always going to be the  
94:32 - case, it doesn't hurt to update the stream just 
in case. So now to add publish destinations.  
94:39 - We want to give the ability for people to add a 
publish destination while they're already live.  
94:44 - So if you're already streaming on YouTube, 
you want to add it into Twitch real quick.  
94:48 - You can do that and it should update. 
So here if we check state that is live.  
94:55 - If we're alive we want to take a 
state engine Add publish stream URL.  
95:05 - So our past in this URL and transcoding 
enabled was set to true. Now I'll give a  
95:12 - little bit more insight on what that 
actually means a little bit later.  
95:17 - And then whether it's live or not live, we want 
to update the state with the new destination.  
95:25 - We'll do that with copy with then destinations. 
And very similar to how it did the users,  
95:32 - we want to use the spread operation, get all the 
destinations and add a new stream destination.  
95:42 - Let's platform platform URL URL. So to remove 
a published destination, we got to do something  
95:50 - very similar. So check if it's live, if 
it is want to remove published stream URL,  
95:57 - we don't need transcoding. And then 
we do a little bit of logic here,  
96:02 - where we loop through all the current 
destinations, we check if we check for  
96:08 - the location of the current URL that we want to 
remove, we remove it, and then we set the state  
96:16 - with the new locations, and we can return we 
don't need to loop through the rest of it.  
96:22 - So that's how we add destinations. And that's how 
we remove destinations. Now we actually have all  
96:27 - the data we need to finish up the UI, we have the 
complete director controller with all the pieces,  
96:33 - we can finish that up. And then the last thing 
we're going to need to do is implement these  
96:36 - last three functions, then we can show you the 
fully working application. Alright, so for the UI,  
96:42 - we have the little section at the top where we 
want to add all our streams and things like that.  
96:47 - And actually, since this is all gonna be UI 
stuff, we can just launch this app and see our  
96:51 - changes get updated real time. Actually, before 
we get into all that, we want to wrap our custom  
96:57 - scroll view in another widget. And this widget is 
actually one of the packages that we installed.  
97:03 - Called circular menu. So let's take our custom 
scroll, you wrap it with a widget. We'll call it  
97:10 - circular menu, just like the package wants. So 
items is required. That's the required field.  
97:18 - And then instead of child it should be background 
widget. So a circular menu puts basically a little  
97:24 - floating menu thing above our whole view. So we 
have the items. But we can also add some things  
97:31 - like alignment. Or gonna align it to the bottom 
right in change the toggle button color two  
97:40 - colors, black 87. And might as well give 
it a little bit of a shadow just to give it  
97:46 - a little extra spice. Now for your login 
to this director channel, we should see an  
97:52 - error pop up because items cannot be empty. 
Alright, I'll add some items. So in here,  
97:58 - when you're going to need to define circular 
menu items, this first one is going to be a big  
98:02 - End Call button. So we never want to end that 
call, we will call the director notifier leave  
98:08 - call and then pop out of this context. So go 
back to the old screen. And then a second item  
98:13 - we'll have in here is check whether we are live or 
not. If we are live at a button called end stream,  
98:21 - where we call the end stream function that we 
haven't yet implemented. And if we are not live,  
98:26 - we will call start stream and the colors will 
be orange for both of them. And this one will be  
98:32 - a video cam icon and then this one will 
be a cancel icon. And then we also do a  
98:36 - little check here before we started to make sure 
that there's at least one destination and where  
98:40 - we want to start the stream to. If not, 
we'll throw an error called invalid URL.  
98:48 - Alright, so let's try again and go to the 
director. And we should hopefully see a  
98:53 - nice little button in the bottom right. 
There we go. Now if we click this button,  
98:58 - you'll see an end call and a start live stream. 
So and the call will take us back to this screen  
99:06 - and go back into the director. Alright, so that 
section is done. Now the next is this safe area  
99:11 - that we just left an empty container for now. 
So that was on purpose, we're actually going  
99:16 - to turn this into a row. So for this one, we're 
going to use another package that we added in,  
99:21 - called the pop up menu button. And we're 
going to use it in conjunction to this  
99:25 - modal bottom sheet as well. So the pop 
up menu button takes in the item builder,  
99:31 - where we'll need to return a list of pop up menu 
items. We're gonna need to turn this list at the  
99:39 - end. And before we return them, we need to fill 
it up with all the different things we need.  
99:43 - So this part is going to be where we're adding 
the actual stream destinations. And everything  
99:49 - within here needs to be a pop up menu item and it 
will have a child and the value. And the reason we  
99:57 - had that enumeration that we declared as because 
we Want this value to be to be for YouTube. Now  
100:03 - the child will be a simple list tile. And just 
like that, we have our first pop up menu item,  
100:10 - then we'll add a little divider in 
between using the pop up menu divider.  
100:17 - And that's put in the wrong spot. There we go. And 
I'll have a load divided between the next section  
100:22 - where we can copy paste the same thing. 
Call this Twitch, made the streaming  
100:30 - platform twitch. And then copy this 
a third time to add an other field.  
100:45 - Alright, so we have our pop up menu defined 
here. But there's a couple more things we need  
100:50 - to add in. So the icon going to use a similar 
icons to add. And there's some functions you  
100:58 - can implement like on canceled where all 
we'll do is just print you have canceled  
101:07 - menu, then we have on selected. So if 
you actually choose something, and this  
101:13 - is where this value comes in very handy, we can 
create a switch case statement for this value.  
101:22 - If it's a stream platform, dot YouTube  
101:30 - we will do one thing. If it's  
101:39 - if it's Twitch, we will do something separate. 
And then lastly, we will have a shape  
101:49 - of rounded rectangle border with border 
radius of border radius circular of 16.  
102:05 - All right, there we go. So the next big thing 
is when we actually picked one want to have a  
102:11 - little bottom sheet pop out. So for YouTube, 
we will have a function called Show YouTube  
102:20 - bottom sheet, where we'll need to pass 
the context and the director notifier.  
102:26 - Because we'll need to access that 
function to add the published  
102:29 - destination. Alright, so 
let's create this function.  
102:35 - We will do it up here. And before we implement 
this, let's go over how to actually stream  
102:41 - something to YouTube. Sorry, go to YouTube, you're 
ready to go live. And click this go live button.  
102:47 - And you will have this stream key and you'll 
have a stream URL. And those are two things  
102:51 - you're going to need to do an RTMP push to YouTube 
on Twitch to get a stream key as well. But but you  
102:58 - can go to stream that twitch.tv/ingests. And 
it'll tell you what the actual URL you need.  
103:04 - So you take this URL at the beginning and then 
add your stream key at the end. And using those  
103:09 - two values, you can actually RTMP push your 
stream to both of the platforms. So I need to  
103:14 - input that here. Okay, text editing controller 
with the stream URL, then copy that and have  
103:24 - a stream key. And for this return, we actually 
wanted to be want to return a bottom sheet here.  
103:33 - And we get that from show modal bottom sheet. 
So we have the context. And within the builder,  
103:42 - we actually need to build out this form. 
And nothing too complicated about this one.  
103:48 - We just basically fill out a column with all 
the things that we want to add. So first add a  
103:52 - little text, then some space between the next 
thing, then a text field for our stream URL,  
103:58 - text field for our stream key. And then a nice 
button at the bottom that says Add. And this  
104:05 - goes to our director notifier and does the Add 
publish destination, we add a YouTube destination.  
104:11 - We take the stream URL, add a slash and add 
the stream key to the end. And that's our  
104:18 - URL for the stream destination. So this guy I was 
reading earlier had a different way to set up the  
104:23 - put stream. So they said do RTMP slash slash 
Twitch ingest server slash app slash stream key.  
104:31 - And the way I found this Twitch ingest server 
was going through OBS, but I have a feeling  
104:36 - this would work just fine. So maybe maybe 
you want to make this your URL and make it  
104:41 - more clear to your users how to how this all 
works. But yeah, the main point is that your  
104:46 - app actually goes gets a twitch so try these 
out. And maybe this is actually simpler to use,  
104:51 - just guide people to this website and then they 
could find it plus had a very similar function  
104:55 - for Twitch. So the way I had it was using this 
old method with our TMP slash slash slash AP.  
105:01 - And then string key. Again, just going to 
the direct and just sir might be easier.  
105:06 - So feel free to update this as necessary. Okay, 
those two are implemented. Now it could show  
105:12 - Twitch bottom sheet, we have context and director 
notifier. All there. Now when we click on this,  
105:19 - we should see these options pop up. Sorry, 
we had this first pop up menu button.  
105:24 - And right after that pop up menu button, we're 
going to loop through all of the destinations  
105:29 - and return some more pop up menu buttons, what 
the actual streams. So number, the item builder  
105:36 - needs to be a list of things even though this is 
just one thing the child will be stream button  
105:46 - with the director data and destination for that 
specific one, or define what this stream button  
105:52 - is in a second, and then the same three functions 
we have the odd cancelled, you have cancelled the  
105:56 - menu on selected, instead of adding a published 
destination here, we will be removing a published  
106:02 - destination what that specific URL again, and 
then very similar border. So last part of the UI,  
106:11 - we want to add the stream button. So this 
will return a widget of stream button.  
106:19 - And we're going to pass it a stream destination, 
we could set up a nice switch statement. Depending  
106:25 - on the platform. If it's YouTube, we want to 
return a container with a child text that says  
106:37 - YouTube style it to be white, give it a little 
bit of decoration. And then since it's YouTube,  
106:46 - we want to make it red. Give it a little 
bit of padding a little bit of margin.  
106:52 - And there we go. So YouTube wants to find 
we'll have a very similar thing for Twitch,  
106:57 - instead of red here we'll have purple, 
instead of YouTube, we will have twitch  
107:02 - and the rest should be the same. And then lastly, 
we have the other will make this color black.  
107:12 - Change this Twitch to other. Okay, 
so finally the UI should be done.  
107:20 - Let's run it. So again, we have this 
director Chowning tatis, let's join it.  
107:28 - And we'll see this nice plus icon at the top. 
If we click this, we'll see a bunch of options,  
107:33 - YouTube, Twitch other let's click 
YouTube will see this pop up  
107:42 - stream URL that's just put in for now 
youtube.com Just as a test stream key, whatever.  
107:53 - We actually had some sort of overflow there. But 
anyways, add that in and we should see YouTube  
108:03 - we can click on YouTube to remove it. Now 
let's figure out what this is all about.  
108:07 - So we need to add this is scroll controlled, and 
set this to true for our bottom sheets. And then  
108:13 - we won't have that overflow problem. 
And we did on this one. All right.  
108:23 - Now in this case, we go to YouTube order flow. 
Might want to add some sort of checks here.  
108:33 - But we just want to make sure it 
all looks nice first. Go to twitch.  
108:42 - Add in there we have multiple things. Okay, 
remove them and add them as necessary. So  
108:49 - UI is all there. So now the very very last 
thing is we actually need to push this stream  
108:53 - to our streaming platforms. And we actually have 
this all set up. So we have n stream and we have  
108:58 - start stream already and set up to go. And we 
only have three functions to implement there.  
109:03 - There's an update stream and streaming 
start stream update streaming. Remember,  
109:08 - we call this whenever the active users changed. 
So that's already handled. So this is also called  
109:14 - whenever we need. So last thing is just just 
implement them. Let's start with the empty  
109:18 - string because it's the easiest one. So we loop 
through all the destinations. And remember to add  
109:24 - a publish destination, we do this add public 
stream URL to mu do remove public stream URL.  
109:29 - So all we really need to do is loop through and 
remove every single public stream URL, just like  
109:34 - that. And then we set the state to state copy with 
is live false. And that's how you end the stream.  
109:43 - Now for the start stream. We need to create a 
list of transcoding users. So if the active user  
109:51 - is empty, we should probably do some sort of error 
checking. Find this case we're going to pretend we  
109:57 - don't like error checking and move to state Active 
Users length equals one. So the best showcase what  
110:04 - we need to do with this transcoding is to look 
at this this drawn out image. So transcoding  
110:10 - means we need to define the width and the height 
of each user and where their location is within  
110:17 - that block. So here, when we only have one, we 
have a use it as 1920 by 1080. And their index  
110:24 - is 00. For this one, we have two users, each 
user will have the resolution of 960 by 1080.  
110:33 - And this one will start at 00. But 
this one will start at 960, and zero.  
110:40 - And then so on for we're going to do it up 
to eight users. By the way, if you prefer  
110:44 - reading through a blog, this will also be in the 
description. So back to the better code. So this  
110:50 - is what that looks like. So like I said, if we 
only have one user to start, this will be 00,  
110:55 - which will be 1920 by 1080. If we have two 
users, first of all, start at 00 960. By 1087,  
111:02 - we'll start at 960 comma 09 60, by 1080, and so on 
and so forth, up to eight users. Now then there's  
111:10 - this live transcoding variable we need, are we 
passing passing those transcoding users that we  
111:15 - just defined, and set the total stream height 
and width to 1920 by 1080. Then on the engine,  
111:23 - we set, live transcoding with the transcoding that 
we just declared, that means we are now live with  
111:30 - the transcoding with these configurations. 
And then similar thing as we did for  
111:37 - the end stream, we want to do for the start 
stream where we go through every destination  
111:45 - and want to add publish stream URL. And the second 
variable is whether transcoding is enabled. And  
111:51 - that is, so we set that to true. And then is live 
also to true. Now last one update stream. So for  
111:58 - updating, we're not really changing. Whether we're 
live or not, we're not changing or adding any  
112:03 - published stream URLs. Those are done 
here, right when we do the Add or Remove.  
112:10 - So all we need to do is update the 
transcoding whenever the users get added.  
112:15 - So copy paste all this paste on the update stream.  
112:19 - And that is it. That is the last line of code 
for the fully functioning streamer application  
112:26 - that allows you to stream with multiple 
people that you have control over  
112:31 - and allows you to stream to multiple platforms at 
the same time. Now I understand that some of this  
112:35 - might have been a little bit complex. But this 
is a complex application complex use case. But  
112:41 - I'm hoping that a lot of you, after looking at 
the proper resources, were able to follow along  
112:46 - and see how a gore actually made this a lot 
easier than it would be to make from scratch,  
112:51 - I honestly don't know where I would even 
start trying to implement this without a guru.  
112:56 - So let's see this final product in action. We're 
gonna run this app and I have a YouTube account.  
113:01 - That's not the official YouTube account. And the 
nice thing about YouTube is it lets you see your  
113:05 - stream here before actually going live on like 
Twitch and makes you go live instantly. I found  
113:11 - this out from experience. But we'll be able to run 
and stream our stream to here and we'll see all  
113:16 - the changes update, it might not be as smooth here 
because I'm running an emulator on a stream. And  
113:20 - then we'll be using two other devices to stream 
into the actual streamer app as well. So this  
113:25 - user will be the director. So you could see this 
all in action, we'll use a channel named Titus.  
113:32 - On join us director. Now we can assign the YouTube 
stuff right away, and paste that in here. And then  
113:37 - copy paste the stream key in here as well. Now for 
this one, we might want to hide it in this case,  
113:44 - especially if you're live streaming this app. 
You don't want people to see this, of course.  
113:49 - But for now, we don't really mind, I'll 
just change my stream key right after this.  
113:54 - So you won't be able to use it. So you have 
added a destination. Now let's also run the  
113:58 - same application, the iPad that I have connected. 
And let's open up a new instance of the terminal  
114:04 - and run a third instance on the iPhone that was 
available here too. So the first device is there.  
114:11 - We'll call this user named Titus. I will see his 
show up here. If you guys are part of the flutter  
114:17 - community, and you know me, you probably know my 
good friend, Robert, that's also on YouTube. We'll  
114:21 - pretend like he's the other person in here. So 
there we go. So let's say we bring this user in,  
114:27 - and what I'll do is mute them right away so the 
two devices don't start echoing with each other.  
114:32 - Alright, well should be ready to push 
the stream live. We click this button,  
114:37 - start live stream. And we see we have a connection 
here. So one thing to remember this whole app,  
114:44 - everything we see here is running on a Gora. 
So this will probably be relatively fast.  
114:50 - But when it starts going out to YouTube, and 
there we go, we finally see it when I started  
114:54 - going out to YouTube is going to the CDN using 
RTMP. So we'll have a little bit of a delay  
115:00 - Someone can bring this other user in. And 
let's meet them here as well. And you can see  
115:05 - pop up here too. So our apps fully working, we're 
gonna bring them in, we could take them out now,  
115:10 - and update just like it should. And there you 
go. You see this layout updates, just how it's  
115:16 - supposed to as well. So you can add twitch and 
all these other streams and stream to all of them.  
115:21 - And if you want to enable the stream right away 
to both of them, whenever you start streaming  
115:26 - from the app, click this auto start and then the 
Twitch will automatically start and then YouTube  
115:30 - will automatically start. So there we go. That's 
the app I like to call streamer. Now if you'd like  
115:34 - to learn more about flutter development, or just 
overall developer entertainment comm subscribe  
115:39 - to my youtube channel at Titus Petro. If you're 
interested to learn more about a gore and how  
115:43 - all this video SDK in this real time engagement 
works, go subscribe to their channel at agora  
115:48 - and over I really appreciate you watching until 
the end of this video. This is definitely the  
115:52 - longest video I've ever made and probably the most 
complex project that I've tried to explain with a  
115:56 - video. I'm hoping most of you are able to keep 
up with it. If you have any questions make sure  
115:59 - to put them in the comments. I'll try to answer 
them as much as I can. And lastly, I'd like to  
116:03 - thank Freako camp for giving me this opportunity 
and hopefully I'll see around here some more