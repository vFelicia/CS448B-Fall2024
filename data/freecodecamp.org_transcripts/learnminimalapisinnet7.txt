00:00 - Welcome to this video course on
minimal API with dotnet. Seven.
00:04 - By the end of the course, you
will be able to build well
00:06 - constructed minimal API
endpoints Brueggen Patel
00:10 - developed this course, he is an
experienced and popular course
00:13 - creator and developer. Let's get
started.
00:16 - Hey, guys, and welcome to dotnet
mastery. My name is broken. And
00:21 - I will be your instructor for
this course on minimal APA. APA
00:27 - has been there since a very long
time. But Microsoft has launched
00:32 - something new with API, which
are minimal API. If you are a
00:37 - dotnet developer, your first
reaction would be, why would I
00:41 - need minimal API when I'm
perfectly happy with the
00:45 - standard API that are there. On
top of that minimal API, as the
00:51 - name suggests, offer less
features as compared to a
00:55 - traditional API. And in this
course, we will answer all of
01:00 - those questions, as we will
explore all the benefits minimal
01:04 - API brings to the table. We have
a lot to cover in this course.
01:10 - But there are some prerequisites
that you should know, you should
01:14 - be able to follow along, as long
as you have about three to six
01:18 - months of experience with C
sharp. That being said, let me
01:24 - walk you through on what we will
cover in this course, and
01:27 - explore the new world of minimal
API. Let's take a look at what
01:34 - will be all the topics that will
be covered in this course. First
01:39 - question that we will answer is
why minimal API? What is the
01:43 - reason behind the evolution?
Does it bring any benefits as
01:47 - compared to the API? And what is
the different structure when it
01:52 - comes to an API? Once we answer
that basic question, we will
01:57 - understand the basic
fundamentals of minimal API's,
02:01 - what files are there, and what
is different as compared to API.
02:07 - Then we will be building
endpoints with our API. And we
02:11 - will implement custom
validations. And minimal API.
02:15 - Minimal API does not support the
model state validations that are
02:19 - there in API. So we will see how
to validate some things and
02:24 - minimal API, we will learn more
about dependency injection, we
02:29 - will inject auto mapper and we
will see how to map DTOs in our
02:34 - application. And then we will
perform crud operation with
02:39 - minimal API. So you can see
there's a lot that we have to
02:43 - cover. Let me get started with
all of that from the next video.
02:50 - The main question that comes
around all the developers,
02:54 - especially dotnet developers, is
why minimal API, we had a
02:59 - perfectly functional API that
has been there. And we love that
03:03 - with the controllers, attributes
and all the features that are
03:07 - built in. If that is working
perfectly, why is Microsoft
03:12 - taking some bits and pieces out
of that API, and giving us a
03:16 - very empty template? Which is
something like a minimal API?
03:21 - What could be the benefits of
having a minimal API? To answer
03:26 - that? Let us consider the
scenario. If a developer is
03:30 - coming from a non dotnet
background, for example, no GS,
03:35 - in that case, they might not be
aware of what is your
03:38 - controller, what are naming
conventions for controller, and
03:42 - learning all of that would
require some understanding of
03:46 - dotnet. But their main focus is
to get the EPA up and running
03:50 - quickly, without learning all
the fundamentals of dotnet.
03:54 - Programming. That is one of the
reason behind development of
03:59 - minimal API, we want to have the
minimal code that is needed for
04:04 - API, rather than adding
controllers. Because if you
04:08 - think about that, when we have
to build an API, in other
04:12 - programming languages, or even
in dotnet controller is not
04:16 - something that is always needed.
It has been there because
04:20 - previously we had MVC, and we
had controllers. So Microsoft
04:25 - thought about unifying both of
them. And that is the idea
04:29 - behind controllers. With minimal
API's, we do not have the
04:33 - controller. We keep everything
simple and straightforward in a
04:38 - class file. Now, when we learn
minimal API, everything will
04:42 - typically be in a program.cs
class file. But then developers
04:47 - might think that my code will
look ugly. If I have 50 end
04:50 - points and all of them are in
one file. Do not worry. We can
04:55 - of course separate them out in
different files as well. But me
05:00 - point here is we don't need a
controller. Now since we are not
05:04 - adding extra features like
controllers and other overhead,
05:08 - which is not always needed for
an API, we gain performance
05:13 - improvement, which takes higher
priority in some situations. So
05:19 - if we are keeping things
minimal, then the performance of
05:22 - our API will increase. Microsoft
is investing time in minimal
05:27 - API. And it is adding more and
more features. Like previously,
05:33 - there were no filters, but they
have added filters with minimal
05:37 - API in dark net, seven, and much
more. With all the new features
05:42 - being added minimal API are
gaining more and more attention,
05:47 - especially in scenarios like
microservices, where API are not
05:51 - that intensive. And efficiency
plays a critical role. With that
05:57 - overview, I'm sure you are
excited to learn minimal API,
06:01 - and what they have to offer,
what is the syntax, how we can
06:05 - perform crud endpoints and much
more. To get started, we need to
06:12 - create a project that will use
minimal API. So I will open
06:17 - Visual Studio 2022. And we will
hit Create a new project. In the
06:22 - templates here, we will search
for the regular API project. And
06:27 - we have the ASP dotnet core web
API using C sharp. Let me hit
06:33 - the next button here. And we
need to give a project name,
06:37 - project name, I will change that
to be magic biller underscore
06:41 - coupon API, we will change the
location where we want to save
06:45 - the project. And the solution
name, I will call that minimal
06:49 - API demo looks clear. Let me add
that. And we have more option.
06:57 - The framework here we will be
using dotnet seven
07:00 - authentication type, we will
keep that as none. But later on
07:04 - in the course, we will be adding
authentication and authorization
07:09 - configured for HTTPS looks good.
We do not want the darker
07:14 - support. But the main thing here
is use controllers, we have to
07:18 - uncheck that if they want to use
minimal API. Because if you keep
07:24 - this checked, then it will
create the regular API project
07:27 - with controllers. We do not want
that. So we will uncheck that.
07:32 - And that will create a minimal
API, we will enable the open API
07:37 - support. And lastly, we do not
want to use the top level
07:41 - statements, we can keep that as
unchecked. With that in place,
07:46 - let me hit the create button
with the default settings. And
07:50 - great our project is created
here. And we have our minimal
07:55 - APA right here. Before we go
through the files that we have
08:02 - and minimal API here, let me
create a regular API project
08:06 - back then we can compare and see
what is different. So in the
08:11 - solution here, we will add a new
project. And it will be an API
08:17 - project. I will conduct regular
API sample, let me add that we
08:23 - want to use the controller. So
make sure that that is checked.
08:27 - And we will hit the Create
button. Perfect that is created.
08:32 - Now that we have a minimal API
and a regular API project. Let
08:37 - me compare to see what is
different. You can see in
08:41 - minimum API project, we have
properties folder. Same thing is
08:45 - there in regular API. And there
it is just the launch settings
08:50 - dot JSON file that basically
tells that which port it should
08:54 - use. And it has a profile for
Kestrel as well, that stays the
08:59 - same. Because no matter if it's
a minimum API or a regular API,
09:04 - it still needs to run the
project on a URL. And outside of
09:08 - properties folder, we have App
Settings dot JSON, that is also
09:13 - constant input of the files. But
other than that, in minimal APA,
09:19 - there is just one file, which is
program.cs. Whereas in the
09:24 - regular API, we have
controllers, we have program.cs,
09:28 - and the weather forecast model
class as well. So going by the
09:33 - name minimal API has actually
minimal file, only program.cs.
09:38 - And that file has all the logic.
Now let me set the startup
09:43 - project as part of the project
here. And let's see if the
09:49 - output is any different.
09:53 - And great. We have both of them
up and running here. Let me add
09:58 - them side by side. and perfect.
We have both of them right here,
10:03 - we have the regular API. And
here we have the minimal API.
10:08 - From the look and feel, you can
see both of them looks the same.
10:12 - We have one endpoint weather
forecast that looks good in the
10:16 - swagger documentation, we try
that. and execute, everything is
10:22 - the same, we have the same
response. And everything looks
10:26 - the same. So from the look and
feel, or the Functionality wise,
10:30 - minimal API is not that
different. Now, of course, as we
10:35 - proceed with the course, that
will be some features that are
10:38 - not yet available in minimal
API's, or they are not planned
10:42 - to be added. But the base
functionality that we can see
10:45 - right out of the box looks the
same. But minimal API has only
10:50 - one file, the regular API has
controllers, program.cs and
10:55 - weather forecast. So that gives
you a good comparison between
11:00 - the files that are present in
minimal API as compared to the
11:04 - regular API project. Now, as a
prerequisite to this course, I
11:10 - hope that you have a basic CRUD
functionalities of what API is
11:15 - responsible for. If not, I have
a free course on YouTube that
11:19 - you can take to get familiar.
But here in the regular API, we
11:23 - have a controller endpoint, we
have the API controller, and we
11:28 - have the HTTP GET action method.
That will be the endpoint, which
11:33 - will be invoked. And here we
have this model weather
11:37 - forecast. That is right here
included, that is the regular
11:42 - API for you. But now that we
open the only file that is
11:46 - present in the minimal API,
which is program.cs. Now, if I
11:52 - switch the funds here, you will
notice that add controllers is
11:56 - not present in program.cs, after
minimal API. And that makes
12:01 - sense, because in minimal API,
we do not have any controllers,
12:06 - then the swagger endpoints, they
are present, because we want the
12:10 - swagger documentation with our
minimal API as well. After that,
12:15 - we have app dot build. And that
is the same where we are
12:20 - configuring the pipeline. We
have swagger documentation for
12:23 - development, we have HTTPS
redirect authorization, map
12:28 - controllers and run. But in
program.cs, we don't have much
12:34 - things. We have swagger, we have
the HTTPS redirect. And that's
12:39 - about it. We just have the app
dot run after that. So we do not
12:43 - have any authorization or map
controllers that are added by
12:47 - default. The main idea behind
minimal DPI is to keep things
12:53 - super simple. If you have the
requirement to add those, you
12:57 - can of course add them. Like in
a minimal API project. It is of
13:01 - course possible to add a regular
API with controllers if you want
13:06 - that. But that is not the main
purpose of a minimal API. It is
13:11 - there to keep things super
simple. So if I examine the
13:16 - program.cs, we just have apps
that run with HTTPS redirect and
13:22 - swagger in the request pipeline.
Now, the main question is, how
13:27 - will it work? Before we check
that, let me remove the regular
13:31 - API project that we added. I
only added that to compare the
13:36 - differences. So you get an idea.
We don't need that anymore. With
13:41 - that, we only have one file
here, which is program.cs. Open.
13:46 - And that looks good. Let's
continue from the next video.
13:52 - When we run the project here, we
notice that there is one
13:56 - endpoint, which is weather
forecast. But where is this
14:00 - endpoint, we do not have any
controllers or any other file.
14:05 - So basically, that endpoint will
be somewhere in program.cs. If
14:10 - you scroll down here, we have
the map get right here. That
14:16 - endpoint is mapping a get
request. And we have the route
14:19 - right here. When we expand that,
you can see there is a little
14:24 - code right here. And this
defines what needs to be
14:28 - returned back when this endpoint
is called with an HTTP get
14:32 - request. We also have written in
and with open API that we will
14:38 - come back to later on. But
basically, this is how mapping
14:43 - is done. And if any model
clauses are needed, in the
14:47 - default template, they are added
right here, this is a record and
14:51 - we have the summaries array
right here. So all the
14:56 - calculation on what should be
returned when the endpoint is
14:59 - invoked. It is right here in the
program.cs class file. Now that
15:04 - will bring up lots of question.
If you are coming from a regular
15:08 - API background, and do not
worry, we will answer them one
15:13 - by one. But in order to get
started, let me remove all the
15:17 - code that is added here for the
endpoint. We want to start clean
15:21 - here. So perfect. Now, our
program.cs only has the swagger
15:27 - endpoints here. Pipeline also
has the Swagger UI, HTTPS
15:32 - redirect. And that's it. No
controllers, no authorization,
15:37 - nothing else is present in our
project or pipeline right now.
15:42 - Like me run the project, we
should not see the endpoint that
15:45 - was there before. And we see no
operations defined in the spec.
15:51 - So we do not have any endpoints
in our API. And everything is
15:56 - clean right now. Let's continue
and add our first endpoint in
16:01 - the next video. The next section
that I have is all about the API
16:08 - basics. Like what is a request?
What is a response? What are
16:12 - HTTP verbs, and so on. Now,
these are the fundamentals of
16:18 - API. And it does not matter
whether it's an API or minimal
16:22 - API. So if you are aware of the
basic fundamentals, like POST,
16:28 - PUT, patch, delete, and what is
a request response with the API,
16:33 - feel free to skip this section,
and move on to the next section,
16:38 - where we will start the
programming. But if you want a
16:41 - refresher, let's do that. From
the next video.
16:47 - We have the big question, what
is an API, the definition for an
16:52 - API is Application Programming
Interface. But that is not
16:57 - explanatory. In simple words,
API is responsible for
17:02 - transmitting the data. Or
rather, it is a way for multiple
17:07 - applications to communicate with
each other. In today's
17:12 - technology driven world, we are
connected like never before. API
17:17 - is the critical engine behind
sharing information across
17:22 - multiple application, and
programming. APA is responsible
17:27 - for getting a request from the
client, and then sending a
17:31 - response back to the client
based on the request, and the
17:35 - request and response that will
be multiple of them. And it
17:39 - continues. So basically, if a
client is looking for some data,
17:44 - it would ask API by sending a
request. And then EPA would
17:49 - return back that data in form of
a response. The model that we
17:54 - see here is the website model.
What is different between that
17:58 - and an API, what makes an API
stand out is it is not just the
18:03 - web browser that can call an
API, many other application can
18:08 - invoke an API endpoint. So let's
say you have an API that can be
18:13 - consumed by a web application,
your mobile application, or
18:16 - Windows application, and much
more. Not only that, you can
18:21 - expose your API to other
clients. And we have more
18:24 - examples of that. But before we
go into those details, the
18:29 - example that we see here is
related to programming. Let me
18:33 - simplify that by going to a real
world scenario. Let's say we go
18:38 - to a restaurant, and we have
menu on the table. And after a
18:42 - lot of thinking, we finalize on
what to order, Chef is also
18:47 - ready to start cooking. But the
missing link here is to tell
18:52 - chef on what we want. That is
where server comes into the
18:57 - picture, which is basically like
an API server will be
19:01 - responsible for taking orders
from the table and telling chef
19:05 - on what needs to be prepared.
And that would basically
19:09 - resemble a request. Once the
food is ready, tensor work will
19:14 - pick that food and deliver that
back to the table, which will be
19:18 - a response. So here you can see
how server is acting like an
19:23 - API, where it is taking the
request and then it is
19:27 - delivering back the response
from our kitchen. Now, let me
19:31 - show you one real world
scenario, which many of you
19:34 - would have experienced without
realizing that it is driven by
19:38 - APA. Let's imagine we are going
on a vacation and we need to
19:43 - book tickets by an hotel
reservation, like myself, I'm
19:47 - sure you want the best deal out
there. But it will be a huge
19:51 - pain to go to every airline
website to see what is the price
19:56 - of that ticket for a specific
date. Right than that, you would
20:01 - prefer going to a website like
kayak.com, Expedia or Priceline,
20:06 - where they will display the
rates for multiple airlines. And
20:10 - you can filter the best deal
from their website. What happens
20:15 - in the backend on kayak.com is
American united and spirit would
20:20 - have exposed an API kayak.com
will be calling those API
20:25 - endpoints based on date, origin
and destination. And it will
20:30 - return all the response from the
individual website. Whatever
20:35 - response it returns from those
website that will display all
20:38 - kayak.com. So basically,
American United spirit and other
20:44 - airlines will have their own
API. And kayak will be calling
20:49 - those API endpoints to display
the connected information in one
20:53 - place. Same thing happens when
you compare hotel rates on
20:58 - Expedia, Priceline, or other
websites, where they get
21:03 - information from multiple
websites. So as you can see, API
21:08 - is the main superhero between
connected services. In today's
21:15 - world, we take the web for
granted. When we open a browser
21:20 - and we go to a web page, we just
expect it to open up and work.
21:25 - That is the default behavior.
But what goes under the cover is
21:29 - a black box. In reality, many
things happen between when you
21:34 - search for something on the
browser, and what you see on the
21:38 - screen. Once you hit an Enter
button. Let's talk about what
21:43 - happens when we make such a
request, we will consider an API
21:48 - in our scenario. For example,
when we go on a laptop and
21:53 - search for something on
google.com, or any other web
21:56 - page, it is going to make a
request to some remote server.
22:01 - Now this request is actually a
text document. So basically, it
22:06 - will send a text document to
Google server. And this document
22:10 - will contain three information.
First, it will have a word,
22:15 - which defines what is the action
that server has to take. Then we
22:20 - have headers, which have
information about the request
22:24 - itself. And finally, we have
content, which is an optional
22:28 - field. As an example, let's say
you want to create something on
22:33 - the server. So in that case, the
HTTP word will be post. And we
22:39 - will learn about this words in
just a minute. But when we have
22:43 - to create, we will be using
post. And that is what we have
22:47 - in HTTP worm. Inside header, we
might have information about the
22:52 - content length, that the content
here will be nine byte. And
22:57 - finally, we are sending magic
API as the content. Let's say
23:01 - that is a string that we want to
create. So all the data will be
23:06 - inserted content. Now, this is
just an example. But this gives
23:11 - you a brief idea of what will be
there in the text document. When
23:17 - the server gets this request, it
can either recognize that as
23:21 - something it can process, or it
might reject it, because
23:25 - something might not be valid
with the request. But in both
23:29 - cases, it will send a response
back to the client. And in that
23:34 - response, we will have three
items. Again, we will have a
23:38 - status code, header and content.
When client makes a request,
23:44 - server processes that and sends
back a response response is also
23:50 - a piece of data. You can think
about that as another text
23:54 - document. The status code here
basically defines the request
23:58 - that was made, was it
successful, or did it fail?
24:02 - Based on the different failure
scenarios or successful
24:05 - scenarios, we have different
status code. In our example, we
24:10 - did HTTP POST request. So it
might send a status code of 201,
24:16 - which stands for created we will
get to know the status code very
24:21 - soon. So do not worry. Right now
it says 201 created in the
24:26 - response status code, which
means I have created the
24:30 - resource that you have asked me
to. And I'm going to return you
24:34 - some data along with certain
content type we are saying that
24:39 - the data that I'm sending back
is of type text. And then in the
24:43 - actual content, let's say the
server is sending back magic
24:47 - API. When important thing that
you have to remember is server
24:52 - itself here is stateless.
Stateless basically means that
24:56 - server will not remember things.
And what I mean by attack, a
25:00 - server will be getting multiple
request. Once it processes that
25:04 - request and sends a response
back, it forgets about that
25:08 - request. Because if it was
remembering about all the
25:12 - request, then you can just
imagine on how massive the
25:15 - memory consumption will be. And
the disk will be overloaded with
25:20 - the data of all the requests
that it received. So always
25:24 - remember that server will be
stateless. Based on what we have
25:28 - seen, we have a request that is
originated from the client, and
25:33 - we have a response. The request
will have word header and
25:37 - content and response will have
status code, headers and
25:41 - content. In the next video, let
me dive a little bit more into
25:46 - what exactly is in request, what
is HTTP web headers, content.
25:51 - And similarly, in response, what
a status code headers and
25:56 - content. Let me do that. In the
next video.
26:01 - Let's understand the request
object that we have. First thing
26:06 - in the request object is work.
And these are HTTP words are
26:10 - action. They basically define
what is the action that needs to
26:15 - happen. If you are working with
some data, you might want to
26:19 - create, read, update or delete
that data. We have specific
26:24 - word, which defines what action
is needed for the request. Most
26:30 - common of the HTTP word is when
you want to fetch some resource
26:35 - or a web page, which basically
means that Hey, get me something
26:39 - from the server. So that
basically means fetching some
26:44 - data. And that is most common.
After that, we have post which
26:49 - is used to create or insert a
new resource. Whenever you want
26:54 - to add a new record or anything
on the server, you will be using
26:58 - the post request, then we have
put, which is used to update a
27:04 - resource that already exists on
the server. Sometimes we also
27:09 - use patch, which basically means
that please do not update the
27:12 - whole resource, I only want to
update a part of that resource.
27:17 - For example, if your object has
100 properties, and you only
27:22 - want to update one of those
properties, you will use batch
27:26 - in that case, put basically
contains the complete resource
27:30 - and patch works on one part of
the resource. Then we have
27:35 - delete, which is pretty obvious.
It basically delete the resource
27:40 - from the server that are more
HTTP verbs, but they are very
27:45 - rarely used. And typically, we
always play with the five that
27:49 - are most common. So that gives
you a brief idea of HTTP verb,
27:55 - and what action they are
responsible for. The next part
28:00 - in the request object is the
header. Headers are a set of
28:04 - name value pair that are
metadata about the request.
28:09 - First one you can see is the
content type that basically
28:13 - answers the question on what is
the content type of the request?
28:18 - Is it a binary data? Is it a
JSON file? Is it an XML file, or
28:23 - is it a plain file, then we have
content length, which basically
28:28 - defines the size of the content.
In request microdata, you might
28:33 - also have authorization,
sometimes request needs to be
28:37 - authenticated. In that case, the
authorization header will be
28:41 - populated with a bearer token or
whatever authentication you are
28:45 - using. We also have accept type,
which defines what kind of a
28:50 - request is acceptable, like
JSON, XML, and so on. And then
28:56 - there are literally hundreds of
headers. You can also define
29:00 - your own headers if they are
helpful in your situation. But
29:05 - headers basically have metadata
of the content and request. And
29:10 - finally, we have content. Con
content is an optional field.
29:15 - Here, we can pass the content
that the server will require to
29:19 - complete the request. It can be
a JSON object, which can later
29:24 - be deserialized by the server to
process the request. It can also
29:28 - be blobs that have to be created
or updated. If you are trying to
29:33 - retrieve a resource, then you
will be using HTTP get word. And
29:38 - get will never have the body
because we are requesting the
29:42 - API to return something. And the
API does not expect any data in
29:47 - the request. But if you're
posting or updating, then we
29:51 - might have to pass the object
that needs to be updated or
29:54 - created. That way the EPA can
extract that object from the
29:59 - content to process the request,
this is a brief overview of the
30:05 - request object. Typing said,
let's analyze the response that
30:09 - we get from the API in the next
video. In the last video, we saw
30:17 - the request object, which had
work headers and content. Now
30:22 - let's examine the response
object, which is basically once
30:26 - the request is received by the
server or API, it will process
30:30 - that it might be accepted, it
might be rejected, failure or
30:34 - success. Whatever it is, it will
return back a response. The
30:39 - first thing that we have in
response here is the status
30:42 - code. status code is simply a
number that represents on what
30:47 - was done on the server, and its
final result. But all the
30:52 - numbers that are returned have
been arranged in some brackets.
30:56 - And they are very critical, like
100 to 199, or informational.
31:03 - You will rarely see the 100
status code, but they do exist.
31:08 - Most common one that you will
see is 202 299. Any status code
31:14 - in that range basically means
that the request was completed
31:18 - successfully. 200 is most
common, where it says everything
31:22 - is okay. And everything is done
as requested. That next we have
31:27 - to work one, which means
created. If you are posting
31:31 - something, then you can return
it to someone that the resource
31:35 - was created on the server that
defines 201. Then we also have
31:41 - war for no content. This is more
common when we are updating
31:45 - something. Because when we
update a record, we just want
31:49 - the user or client to know that
the update was successful. And
31:54 - we do not want to pass the
updated record. In that case we
31:57 - will return to work for which
basically means no content. But
32:02 - as you can see, it is within the
success bracket. That means
32:05 - everything was successful, but
we do not have any content to
32:09 - return. Next bracket is 300 to
399, which are typically used
32:15 - when there is redirection
involved. After that we have 400
32:20 - to 499, which relates to client
errors. What I mean by client
32:26 - error means that there is an
error in the request that was
32:30 - sent, you may not have included
a query string or some part of
32:34 - the URI does not exist. The
famous one that you would have
32:39 - seen on websites is 404, which
represent not found. So let's
32:46 - say you are accessing an
endpoint that does not exist.
32:49 - Like let's say you want to
retrieve something based on an
32:52 - ID, that Id does not exist. In
that case API might return back
32:57 - for or for that the resource
that you are looking for does
33:00 - not exist. We have 400 status
code, which stands for bad
33:05 - request, which means something
in the request was not as
33:09 - expected. And then finally, we
have status code within the
33:14 - bracket of 500 to 599. And these
are for internal server error,
33:20 - like the 500. Here is internal
server error, which means that
33:24 - errors have been encountered on
the server while processing. So
33:29 - basically, the request that was
sent to the server was a valid
33:32 - request. But when that request
was being processed by a server,
33:37 - let's say an exception was
thrown internally. And because
33:41 - of that, the server could not
process a valid request. So that
33:45 - time it will send a 500, which
means there was some error on
33:49 - the server side, and nothing was
wrong in the request. You can
33:55 - see status code plays a very
important role in the response
33:59 - object. Because based on the
status code, the client will be
34:03 - able to know if the request was
successful if it failed, and if
34:07 - it failed, what was the reasons?
So on the next we have headers
34:13 - in the response object as well.
And they contain metadata. But
34:18 - this time, they will have
metadata about the response
34:21 - object, like what is the content
type, what is the length of the
34:25 - response content, until when it
will be valid, and so on. Also,
34:30 - similar to the request object,
we have content in the response
34:34 - object as well. And that might
contain JSON result, it might
34:38 - contain blobs, HTML, whatever
the response server has to send,
34:44 - that will be in content. So
typically, if we have to compare
34:49 - request and response, both of
them will have headers and
34:52 - content, but the main thing that
differentiates them here is the
34:56 - word and status code. Request
has the word which defines what
35:00 - action needs to happen. And
response has the status code,
35:04 - which defines if the request was
processed successfully, if there
35:08 - were errors, and so on. headers
will be different for request
35:13 - and response. But typically
headers defined metadata, and
35:17 - content will have any content
that needs to be passed with
35:21 - either request or response. So I
hope this gives you a 10,000
35:27 - feet overview about request and
response, and what is included
35:32 - in them. That being said, let's
continue from the next video.
35:39 - Now we know the basics about
HTTP worm. But let's take a look
35:44 - at some URL and get some
theoretical idea behind the HTTP
35:49 - worms. Most common HTTP worm is
a get request. Let's assume we
35:56 - have a table where we have a
list of all the coupons in our
35:59 - website. That table is pretty
simple. It will just have
36:03 - something like a coupon name,
what discount we get and some
36:07 - other details. But we want an
API endpoint if someone calls
36:12 - that it should retrieve all the
coupons and send it back. Now
36:17 - this is more like a read
request, because of that the
36:20 - HTTP worm will be get. And then
we have the API path, localhost
36:26 - 7001, whatever your domain is,
that's okay. But after that,
36:32 - let's assume we are giving that
a route of API and 10 coupon, we
36:37 - cannot have any other parameter
here. And this basically, the
36:41 - action we want is to get all the
coupons. So in the request
36:46 - party, we will not pass anything
here. But in the response that
36:50 - we will get from the API, it
will give us a list of all the
36:54 - coupons from our database. So
that is a get request. Now
37:00 - another type of cat request is
where we are passing an ID of
37:04 - the coupon. At that point, the
HTTP word is still cared for.
37:10 - Because there is an ID here, we
know that the user only wants
37:14 - one coupon request will not have
any body, but the response party
37:20 - will have the single coupon that
user wanted. Now, of course, if
37:24 - the ID is invalid, we will not
send any response party with the
37:28 - coupon. But if that is valid,
the response party will have a
37:33 - coupon. These two are basic
request in HTTP kit. But let's
37:40 - say if a user or admin wants to
create a new coupon code, in
37:45 - that case, our HTTP word for the
request will be post, and we
37:49 - will use the same URL. Now the
way it will differentiate
37:54 - between the first URL and this
one is the HTTP word will be
37:58 - different. If the word is posed,
the API will note that that
38:03 - means that we will be creating a
coupon. So API automatically
38:08 - differentiates between the verb
even if the URL are same. So for
38:14 - post, we will create a coupon.
And when we are creating a
38:17 - coupon, if someone sends a
request, we obviously need the
38:21 - details about that coupon. Like
on the website, someone will
38:26 - write the coupon name, what is
the discount they want, and then
38:29 - the admin will hit the Create
button. At that point in the
38:33 - request, we will get all the
coupon details that the API has
38:38 - to create. So API will create
that coupon when it receives the
38:43 - request. And in the response, it
could send the created coupon or
38:47 - a route to that created coupon.
Now, if everything here does not
38:52 - make sense, right now, do not
worry. I am just giving you a
38:56 - basic idea of API and its
action. Next action or HTTP word
39:02 - that we have is book and that is
to update any existing coupon.
39:08 - In the route here, when we are
updating, we can pass the ID of
39:12 - the coupon that we want to
update because of the HTTP port
39:17 - word and request we will require
the coupon details that have to
39:21 - be updated. And once the API
updates the coupon typically
39:26 - does not send any response like
the updated coupon. If you want
39:31 - however, you can send it but
that is not the typical route
39:35 - that is taken. And finally, we
have the Delete HTTP verb, where
39:41 - again we will pass the ID here.
Action we just need to delete
39:46 - that coupon. It does not have
any request body or a response.
39:51 - Based on the ID that is there in
the parameter. It will delete
39:55 - that coupon and return an okay
request. That means everything
40:00 - was completed successfully. So
what we have seen here is what
40:04 - will be in the request party, or
what we will get in response
40:09 - based on the HTTP verb, and
something in the URL, whether we
40:13 - require an ID, if we don't do
that, and so on. So this should
40:19 - give you a brief idea about what
each request or rather HTTP word
40:24 - is responsible for. Now, again,
this is just a rough idea. Once
40:30 - we start programming, everything
will start making much more
40:34 - sense. That being said, let me
continue from the next video.
40:42 - Let me add our first endpoint
right here. One thing that you
40:47 - should remember is all the
endpoints, we will have to
40:50 - configure that before the
pipeline ends. Because in a
40:54 - traditional API project, if you
remember, we were using
40:57 - something like f dot add
controller, and that was adding
41:01 - controller to the pipeline.
Here, we are not adding the
41:04 - controller, so all the endpoints
of your API that you want to
41:08 - add, you will have to add that
before app dot run. Right here,
41:13 - we will say app dot map. And you
saw before, we had something
41:18 - called as map cat that actually
maps or rather tells that this
41:23 - will be an HTTP GET action
method. If you examine the
41:27 - parameters, here, we have a
string with a pattern and a
41:31 - delegate handler, I can define
the route of this API. So we can
41:37 - say something called as hello
world. And watch that return.
41:42 - You can keep it simple. And we
can just return back hello, word
41:47 - like that. That will add an
endpoint in our minimal API. Let
41:52 - me run the project. Perfect. You
can see we have that route here.
41:57 - We can try that out. execute
that. And we have hello world.
42:03 - If you want to test that using
swagger, or it is an HTTP GET,
42:08 - we can directly paste that. And
we see the word right here.
42:14 - Perfect. You can see our
endpoint is working as expected,
42:19 - and how simple it was to add an
HTTP GET and point right here.
42:24 - Now, that would make you
curious. And now you will be
42:27 - like, can I have an HTTP POST
endpoint? Of course you can. We
42:33 - just have map post here. We can
call this Hello World, too. And
42:38 - we can return hello world to Now
typically, an extra day began,
42:43 - you will have something in from
body where you will be creating
42:47 - a record. But we are keeping
things super simple, right now.
42:52 - Let me run this and see if that
works. Perfect. We have the post
42:57 - here, write that out. We don't
need any parameters. And
43:02 - perfect, we get the response.
That looks great. If it was an
43:07 - API project, there is no way
that you can add one line and
43:11 - the endpoint will be added
there. But here it is pretty
43:15 - simple. Similar to map get, we
have my foot and pap delete. So
43:21 - I agree if the app not map here,
and we scroll down, we have to
43:26 - delete. We have bad POST, PUT.
And where is the get right here.
43:34 - So you can see we have all of
those basic methods of the API
43:38 - endpoint. With that in place,
let me continue from the next
43:43 - video. Right now we are adding
or returning what we have in a
43:49 - single line. But what if you
have a complex calculation that
43:53 - your API needs to handle and
unique multiple lines for that,
43:58 - that is simple as well, we will
remove this and we will add a
44:03 - curly bracket here. We can
perform all the calculations
44:07 - right here. But to keep things
simple, we will just return as a
44:13 - word right now. Perfect. This
will work exactly the same. Let
44:19 - me run that. And show that.
Write that out. Perfect. That
44:26 - looks good. Now right now you
can see it returns 200. Okay,
44:31 - that is the response that we are
getting from the server. But
44:35 - let's say there are some errors
here. And we are returning an
44:39 - exception here. But that time
also it will return a 200. Okay,
44:47 - right now there is no way to
tell that, hey, this is a bad
44:50 - request or something went wrong
on the server. So basically, we
44:55 - have no way of controlling what
is the return type for our API.
45:00 - Alright, now, that is also done
everything that we want to
45:04 - return inside results dot end we
have the endpoints for the
45:09 - status code. We have accepted,
created, not found, bad request
45:14 - and all of that right here.
Let's say we have a bad request
45:19 - here. And inside there, we are
seeing that there is some
45:22 - exceptions that is being thrown.
Let me run that.
45:28 - Way. We'll try this here. And
perfect. Now you can see our API
45:34 - is returning a 400, which stands
for parrot request. If
45:40 - everything was good, right here,
we can directly return results
45:44 - dot Okay, inside there, we will
pass the hello world. If we want
45:50 - to keep that in same line. If
you want multiple lines, you can
45:54 - add the curly brackets and do
the same thing with results
45:58 - start. Okay. Let me run this and
make sure that works. We have
46:05 - enclosed here examined the
response that is 200. Okay, so
46:11 - perfect. With that, let's
continue from the next video.
46:18 - That returned results here we
can toggle on whether it is a
46:21 - good request or a bad request.
But in an API endpoint,
46:26 - sometimes we have to pass
something to the parameters.
46:30 - That might be a front body, or
let's say an integer or a string
46:34 - parameter. to parse some data.
When we have to use an integer,
46:39 - typically, in an API, we have to
write the integer name here, let
46:44 - that be an ID. That stays the
same. But right here, we will
46:49 - see that we are expecting an
integer ID. And we don't want
46:54 - exception, we will save okay
here. And we can print the ID.
47:00 - And we'll just say plus here,
let me run that. Perfect. You
47:07 - can see it expects an ID,
Swagger UI is displaying that.
47:12 - Let me enter 11 and execute.
Perfect, we have the correct
47:17 - response. If you enter a string
here, swagger will display the
47:22 - error message. It has to be an
integer, but we can open postman
47:26 - here, paste that URL, and see
what happens. We see the
47:32 - exception here failed to bind
the parameter integer ID from
47:37 - this. And you can see the
response type is 400. Bad
47:41 - request. But if we are passing a
string, then this should
47:45 - actually be a 404 not found.
Because the get endpoint that we
47:50 - have is the endpoint with an
integer and not a string. How do
47:55 - we fix that? Fixing that is
super simple. Let me go back to
48:00 - the map get here. If we go back
here, and we explicitly say that
48:05 - this ID will be an integer only,
that should solve our problem.
48:11 - Let me go back to the postman.
And let me execute. And perfect.
48:17 - This time, we have the 404 not
found. And that looks good. So
48:23 - we can be explicit with the
parameters similar to what we
48:27 - had in the API project as well.
We have seen some basic examples
48:34 - of adding the endpoints. But let
me work on something that is
48:38 - close to a real world
application. Let's say we want
48:42 - to perform CRUD operations on a
model and that will be coupons.
48:47 - So, first, we need to create a
model for that inside solution,
48:52 - we will create a new folder and
that will be models in there we
48:59 - will right click add a class
file, I will call that as coupon
49:05 - and inside there I will create
six properties, we will have
49:09 - idea of the coupon we will have
the coupon name, what percentage
49:13 - discount will that coupon give
and if that coupon is active or
49:18 - not, I will also add another
level created and last updated.
49:25 - Now if you are new to dotnet
six, and if we examined the
49:29 - project here at a project file,
you can see in a label is
49:33 - enabled by default. This
basically means that if
49:37 - something is not you have to
explicitly define that property
49:42 - will be now but to make things
simple or if you are working
49:46 - with a legacy dotnet application
or dotnet core project that is
49:50 - an older version, this must be
disabled, even if you upgrade
49:55 - that because many times
personally I have seen when I
49:59 - have upgraded Get the project to
latest versions of dotnet core.
50:03 - And if this nullable is enabled,
API endpoints are breaking,
50:08 - because previously, we did not
explicitly define every endpoint
50:12 - that it is an allowable
endpoint. But now if that is not
50:16 - defined, it does not find that
endpoint. So to be safe, you can
50:21 - disable the nullable in the CS
proj file. But right here, we
50:26 - have explicitly said that
created and last updated is
50:29 - nullable. So we should be good.
But to avoid any issues or
50:33 - confusion, we have disabled in
the level flag inside the
50:37 - project file. So our class here
looks good. Next, we need to
50:43 - create a store that will have a
list of coupon. Now down the
50:48 - road are typically in a real
world project, you don't have a
50:51 - store, you have a database where
you manage or update all the
50:55 - coupons. But to keep things
simple, for now, we will add a
50:59 - coupon store. Let me create a
new folder, which will be data
51:04 - folder. And in there, we will
add a class, which will be
51:10 - coupons store. Inside there, we
will add a static property,
51:15 - which will be coupon list that
will be released off coupon and
51:19 - we have just added two coupons
in there. We will make this a
51:24 - static class as well.
Thankfully, we do not have to
51:27 - create object every time.
Perfect. So our coupons total
51:31 - can now be accessed with our new
API endpoints that we will
51:36 - create in the next video. Now
that we have coupons store and
51:42 - coupon model, it is time to add
the first endpoint that will
51:47 - retrieve all the coupon. So we
will say tap that map get
51:52 - endpoint and the route here.
Rather than calling it coupon. I
51:57 - typically like to add API in
front of that. So we will say
52:01 - forward slash API, and then
coupon that will retrieve all
52:06 - the coupons. We will be using
the delegate here. And what he
52:12 - will return is results dot okay.
And inside there, we have to
52:17 - access the coupons store that we
created. I will add the USING
52:22 - statement. And in there we have
the coupons list. That is what
52:27 - we need to return. With that in
place. Let me run the project.
52:33 - Perfect. Let me try this out
here. And great. We can see both
52:39 - the coupons in our coupons
store. Now right now, even
52:43 - though we have one line here,
let me add a curly bracket here
52:47 - and break this out. Right here,
we will add a return statement.
52:55 - And we are missing the closing
semicolon. Perfect. We have the
53:00 - multi line function right here.
Great. So our cat endpoint looks
53:06 - good. Let me continue from the
next video. We have the endpoint
53:14 - to get all the coupons. But what
about when we have to retrieve
53:18 - an individual coupons based on
the ID, we can create that as
53:23 - well. We know how to retrieve
the ID. So right here, we will
53:28 - expect an ID and that will be
integer, we will have the same
53:33 - name here integer ID. And then
when we are returning back the
53:38 - result here from the coupon
last, we can use first or
53:42 - default to retrieve the record
based on the ID. So if you.id is
53:49 - equal equal to the ID, perfect,
let me run the project. We have
53:56 - ID one and Id two. Let me try
the ID two here. And great, we
54:02 - get the 20 off. So our coupons
store is working as expected, we
54:08 - have to ID and that retrieval is
working. Next what we want is
54:14 - post PUT and DELETE action
endpoints. So let me just add
54:20 - them for now. We need the post
here to create a coupon and when
54:25 - we post we will use the same
path API forward slash coupon.
54:31 - Now of course when we post in
the handler here we will receive
54:34 - a different object but we will
worry about that later on. Okay,
54:40 - let me copy this and paste it
two more times here lightmap
54:46 - post we have my put here and we
have the map delete. Now in post
54:54 - and put both of them we will
receive the coupon object and
54:57 - the parameters that pay we can
create yet are added the coupon,
55:02 - but when we delete here, we will
receive ID. So let me copy that.
55:07 - And we will get the ID right
here. Perfect. So these three
55:13 - looks good. In the next video,
let me first work on creating a
55:19 - coupon.
55:22 - Now we want to create a coupon.
When we create a coupon, we
55:27 - typically receive a coupon
object from the party. So
55:32 - getting that is exactly same
like we do in API project, we
55:36 - will save from party in the
parameter here, and we will
55:40 - receive a coupon object, let me
call that coupon. And we will
55:45 - add USING statement for our
model. Now from body requires a
55:51 - USING statement which is in
Microsoft dot ASP NET Core dot
55:55 - MVC. But once we add that it
will know that a coupon object
56:00 - will be passed from body when
the post request will be called.
56:06 - Then before we create, we
typically have some validation,
56:10 - we will add a validation here
that if the coupon ID is not
56:14 - zero, or if the coupon name is
empty, that is an invalid ID or
56:20 - coupon name, because when we are
creating the coupon ID must be
56:25 - zero. If it is something else,
then that is not a valid ID.
56:30 - Because ID is something that
typically the database, all the
56:34 - code is responsible for adding.
But we don't have any database
56:39 - right now. So now we need to
populate the ID. How will we do
56:44 - that? We will keep things
manual, we will say coupons.id
56:49 - is equal to inside our coupons
store, we have the last third,
56:55 - let me order by descending, so
we will get the maximum ID at
56:59 - the top here, you close to a
u.id. And on there, we will
57:05 - retrieve the first record, they
have to will retrieve the ID of
57:09 - that record. So here we are
getting the maximum ID of all
57:14 - the records that we have in our
coupon store. So that will be
57:19 - two right here. On that too, we
will add one. That means that we
57:25 - are manually setting the id plus
one by the maximum ID in our
57:30 - coupon store. And before I add
the ID here, I want one more
57:35 - validation, I do not want the
same coupon to be created again.
57:40 - So we can add an if condition in
our coupon store and try to
57:45 - retrieve first or default, based
on the name that is being
57:48 - created in the coupon. I will
use that to lowercase that we
57:54 - will make coupon case
insensitive. So if the code
57:58 - already exist, we return part
result. Coupon name already
58:02 - exist. Pretty good. Next, we
have the ID here. And then we
58:08 - have to add it to our coupon
store dot coupon List dot add we
58:14 - will be adding coupon perfect
our create or post is complete
58:19 - here. Once we do that, we can
return back with those dot okay.
58:27 - And there we can return the
coupon that has been created.
58:32 - Perfect. Let me run and see this
in action. Only parameter that
58:39 - we have to change here is name
let me call that 30 off. And it
58:43 - is a 30% discount ID we can
leave that as zero because if we
58:49 - go back to our application, we
are changing that Id based on
58:54 - the ID that we have in our
coupons store. The maximum one
58:58 - is two. So next one will have
the ID of three the ID here we
59:03 - can remove that and it will
still work because it will
59:07 - automatically populate the ID.
Let me remove that and hit the
59:12 - Execute button will scroll down
and perfect in the response body
59:17 - you can see it is three. If we
go back and we try to get all
59:23 - here. Now we have three coupons.
But again, this is a temporary
59:29 - data store. When you restart the
application, there are coupons
59:33 - stored will be back to the first
two which are the defaults that
59:37 - we have. So keep that in mind.
We are not storing this in
59:41 - database. It is temporary and in
memory. So perfect. Our post is
59:48 - working as expected. Let me
continue from the next video.
59:55 - Before I work on put or delete
when we have the post Here,
60:00 - there are quite a few things
that are missing in our API
60:03 - endpoint that we typically do in
a dotnet. core API. One thing is
60:10 - rather than returning an okay,
in HTTP POST, sometimes we
60:15 - return the created at route.
Now, of course, we can return
60:19 - the created. And that is
completely okay. Before that,
60:23 - let me show you how to use the
results dot created. When we use
60:28 - created, we have to write the
route where this is created. And
60:33 - then for the value, we can pass
coupon. So the URL here, let me
60:39 - use string interpolation here.
It's API forward slash coupon,
60:44 - and then we need the ID. ID will
be inside coupon.id. And let me
60:52 - run that we will create a new
coupon, we will update the name
60:57 - and percent. And let's go down
that is created. Here we have
61:03 - two one. And in the location, we
have API coupon and three. Let
61:09 - me go to the local host URL
here, we will add local how
61:13 - localhost and then we will paste
the route that we copied, and
61:18 - grade that retrieves the
appropriate coupon with the
61:22 - correct name, and percent. So
created is working as expected.
61:28 - But what if we want to use the
created add route? For that, we
61:33 - actually have to give this cat
some route name. How to do that
61:39 - with minimal API. After the map
CAC, here, we have something
61:43 - called as with name. And then we
can provide name of this
61:48 - endpoint. So right here, I can
call this endpoint as get
61:53 - coupon. And then we can use that
name. The first one here, let me
61:59 - contact s cat coupons, the HTTP
POST, we will call that as
62:05 - create coupon 10 Rather than
using created, let me copy this
62:12 - commented out. And we will be
using created at route. Inside
62:20 - there, we need the route name as
the first parameter. That is
62:24 - character coupons. Next
parameter here is the ID. So we
62:29 - will create a new object. And we
will say ID is equal to
62:34 - coupon.id. And finally, we will
pass the object that looks good.
62:41 - Let me see if that works. We
will post again, it will create
62:48 - an ID three. Let me try that.
And perfect. That looks good
62:54 - here in the location, we have
the complete URL, as well as the
62:59 - endpoint. If you copy that, and
cry that it should work.
63:05 - Perfect. So with that, we know
how to use the width name to
63:10 - give our endpoints a name. And
then we can use that in
63:14 - something like created at round.
63:20 - Now we have the names for our
endpoint. But if I run the
63:24 - project here, and if I look at
the swagger documentation for
63:28 - HTTP post here, the response
type here, it says that it will
63:33 - only return a 200. Okay. But
that is not correct. If we go
63:38 - back here, if the ID is not
zero, let me try that here. So
63:43 - we will keep it as three execute
this, we get a 400. So
63:50 - basically, our endpoint can
return a 400 bad request. But in
63:56 - the Available responses in the
Swagger UI, it only thinks that
64:00 - it will return a 200. Okay. And
that is because in a traditional
64:05 - API application, we have the
HTTP response. And we explicitly
64:10 - say that these are the possible
status code that our endpoint
64:15 - can return. How can we define
that with minimal API for that
64:21 - on the map post here, where we
have the with name, we also have
64:26 - something called as producers.
And here we have generic when we
64:31 - can see the model that will be
produced. We know we are
64:35 - creating a coupon here. So I can
say produces a coupon and then
64:40 - what will be the status code. If
everything is successful, that
64:45 - will be 211. We also have a bad
request here. The way the ad
64:50 - produces and when it is a bad
request. We do not have any
64:54 - model so we will just add a
produces 400 bad request If you
65:00 - have other status code, you can
also add them right here. Let me
65:06 - copy this, and we will modify
our individual kit and get out.
65:12 - Now this one will produce a 200.
Okay, it does not produce bad
65:17 - request. So let me remove that.
And to Hungary, the first one
65:23 - here will not be a coupon, it
will be an IEnumerable of
65:27 - coupon. Perfect. Let me restart
the application. Right here you
65:35 - can see we have an array, when
we have the individual GATT, we
65:39 - do not have the square bracket.
But let me open the post here.
65:44 - And there we have 201, we have
the correct model, and 400 bad
65:49 - request, we do not have any
model in that. So that way, we
65:55 - can explicitly define what will
be the response that will be
65:58 - produced. On top of that, you
can be explicit on what this
66:04 - endpoint will accept. Right here
it is expecting a coupon. So
66:09 - when we have the with name, we
can also a dot accepts that
66:14 - expects a coupon. And there you
can explicitly write the content
66:19 - type. Like if you want to limit
application JSON, you can see
66:23 - that explicitly right here. With
that, let me run the project.
66:29 - Once again. We go to post here,
and everything stays the same
66:34 - because we have the request
party. But that is more
66:37 - documented. Can now the swagger
can read, what are the exact
66:42 - things that it expects, what it
produces, and the models as
66:47 - well. So perfect. With that our
three endpoints that we have, I
66:52 - believe we have good
documentation so far. Let me
66:55 - continue from the next video.
When you work with a dotnet core
67:03 - application, Dependency
injection is a very critical
67:07 - piece. And minimal API supports
that. So don't panic. The first
67:13 - example that we will see is the
built in ilogger, that comes
67:17 - with an API project. To see that
in action, let me create an API
67:23 - project because I removed the
one that we have here, we will
67:27 - create a sample. That's okay, we
don't care about anything else
67:32 - here. And perfect. Here. If we
open our controller, you will
67:37 - notice we have an ilogger on
there we can use to log
67:42 - something in the console window.
This ilogger is being used with
67:47 - dependency injection, and it is
available by default. So how can
67:52 - we use that in our minimal API
project? Let me log something
67:58 - when we are getting all the
coupons right here. In the
68:02 - parameter here, we can
explicitly say that we need an
68:06 - ilogger. So if I go back to the
API project, let me copy what we
68:12 - were passing in the constructor
here, we do not need to create a
68:16 - private read only, we can
directly retrieve that in
68:20 - parameter like that, you can see
ilogger is being detected, but
68:25 - it does not detect the weather
forecast controller. But right
68:30 - now, we are in program class
here. So we can see that right
68:34 - here. And with that the logger
has been injected, I like to use
68:40 - underscore for all the
dependency injection that we
68:44 - have. We will add underscore
logger. On that we have the lock
68:48 - method, log level, we will say
information. And we will say
68:52 - getting all coupons. Let me run
the application and see if that
68:58 - works. We are using Kestrel to
run the application. So when you
69:04 - run the project, you will
actually have a command line
69:07 - window like this that is open.
Make sure to open that if you do
69:12 - not have that and if you're
using IIS express to run that
69:16 - you can also go to the output
window and we have debug here.
69:20 - Let me pin that as well.
Perfect. Now, if I go back here,
69:26 - let me try to get the coupons.
We execute that and perfect. You
69:33 - can see in the logs here and go
to places in the console window
69:37 - if that is open, if not we have
the output window here we have
69:42 - the log which is getting all
coupons. So that way you can see
69:47 - how Dependency injection is
already built in with minimal
69:51 - API's. If you are injecting
something that is not available,
69:56 - you will of course have to
inject that where we have If the
70:00 - add services right here, and it
will basically be before line
70:05 - 14, where you are calling the
builder dot build. So where we
70:09 - have the builder dot services,
you can register new services,
70:14 - and in the endpoint, you can
directly get the implementation.
70:19 - So with that basic example of
dependency injection, let's
70:24 - continue from the next video.
Now, let me run the project
70:30 - here. And I want to show you
when we are posting here, we do
70:35 - not want all of these
properties, we only want name
70:39 - present and is active. So in a
typical API, we do not expose
70:44 - the complete object, we only
expose the DTOs for that
70:48 - endpoint. So for create, we will
add a DTO in our project. In
70:55 - Models folder, let me add a new
folder for DTO. And in there, I
71:01 - will add a new class, which will
be coupon create ETL. Now that I
71:09 - only want three properties, so
let me copy them and paste those
71:15 - right here, we will go to our
endpoint here. And when we are
71:20 - creating from body, we will only
retrieve the coupon creativity
71:28 - that we are only getting what we
want. And I will call this
71:32 - coupon underscore C underscore
DTO, which has coupon create
71:37 - DTO. Let me change the names
here.
71:42 - We need the ID as well. Now in
our coupon create DTO, we do not
71:47 - have the ID, we can remove this
condition. But when we have to
71:51 - assign the ID, we actually have
to convert this coupon create
71:56 - DTO to coupon DTO. So if you
want, you can manually do that
72:02 - coupon is equal to new. And we
can do the manual mapping like
72:08 - that. Once we do that, we can
add ID on this coupon add that
72:14 - to our coupon store and we are
returning back the coupon. Now
72:18 - rather than coupon here, let me
add a new T to that we will call
72:23 - that as coupon TTL. The reason
behind that is let's say we
72:29 - never want to show when the
coupon was last updated. So in
72:34 - the coupon DTO we will not have
that property and we will return
72:38 - back the coupon DTO so produces
here will be a coupon DTL except
72:45 - we will change that to coupon
create DTO and when we return
72:50 - back, we will basically have to
convert this coupon to the
72:54 - coupon dt. So right here, we
will need the conversion again
73:00 - like that. And perfect. That
looks good. We will return back
73:05 - the coupon DTO let me run the
project and see that in action.
73:13 - We go to our post here perfect.
Now this is different, we only
73:18 - need a few properties here. Let
me change those and we execute.
73:24 - We take a look at the response.
Perfect updated is not present.
73:29 - And that looks good. Now created
is null you can change that if
73:33 - you want but I will skip that
for now. Basically, our details
73:39 - are functional. And we are not
exposing our entity, which is
73:43 - coupon that is great news. But
having all this conversion is
73:49 - super ugly. I would love if
someone would already do that
73:53 - for me. And the answer for that
in next video. Mapping all of
74:00 - the objects manually is super
painful. Thankfully there is
74:04 - auto mapper so far that we will
have to install the new kit
74:09 - package. Let me go there. In the
Browse tab, we will search for
74:14 - auto mapper we will have to
install the default auto mapper
74:19 - package, then we want to inject
auto mapper with dependency
74:23 - injection. So we will install
auto mapper dot extensions dot
74:28 - Microsoft dot dependency
injection perfect both of them
74:34 - are installed. Now how can we
define the mapping auto mapper
74:40 - is smart. If the property names
are seen here, it automatically
74:44 - maps them but we need to tell
auto mapper that hey, you should
74:48 - be mapping coupon to coupon
create DTO or coupon DTO to
74:53 - coupon that is something that we
have to tell Automapper let me
74:58 - add a class file And we will
write that inside that class
75:03 - file. I will call that as
mapping config. Now if you want
75:08 - that configuration, you can do
that in program.cs, when we
75:12 - register that to the container,
but rather than keeping
75:15 - everything clustered in
program.cs, I like to separate
75:20 - it out. Now that mapping is
present inside the profile that
75:25 - is inside auto mapper. Once we
add that here on the class file,
75:31 - in the constructor, we can call
the default methods, that is
75:35 - create map that create map is
inside the profile. And there we
75:40 - have to tell the source and
destination, we want to map our
75:45 - coupon at a USING statement. And
we want to map that to coupons
75:51 - create TTL. Now, that will only
map coupon to coupon create DTO.
75:58 - But what if you want to map
coupon create DTL two coupons,
76:02 - that is simple, we just have
rewards method. And that will
76:06 - handle both the scenario I will
copy this next I also want
76:12 - coupon to coupon DTM. We will
not be mapping coupon creativity
76:18 - to Groupon TTL. So that mapping
is not needed. While these two
76:24 - mapping liquor. Now we need to
inject Automapper to dependency
76:29 - injection. And that we will have
to do before we build the
76:33 - application. So right here, I
will say builder dot services
76:38 - dot add auto mapper. And then we
will explicitly say type of
76:43 - mapping config mapping config
has all the profiles for our
76:48 - auto mapper that we need. And
with that, it will do all the
76:52 - magic of dependency injection.
And we can use that right here
76:57 - in our post endpoint. If you
remember, when we have to inject
77:02 - the logger here, we were using
our logger. Similarly, we want
77:06 - the eye mapper, let me call that
underscore mapper. And we need
77:11 - to add the USING statement for
auto mapper that will
77:16 - automatically inject the mapper
based on the mapping profile
77:21 - that we have. When we have to
convert something we will say
77:25 - coupon is equal to and
underscore mapper dot map, we
77:31 - want to map this to a coupon.
And here we will say we want to
77:35 - map this coupon create DTO. And
this will be the destination. So
77:40 - it will automatically map this
coupon create DTO to coupon and
77:45 - assign it right here. One line
to replace all the mapping.
77:51 - Pretty simple. Let me go back.
And here we will say underscore
77:55 - mapper dot map. What is the
destination address coupon DTO.
78:02 - Let's add that. And what is
something that we are converting
78:06 - are the source here. That is
coupon object. Nothing else is
78:12 - needed. Perfect. That looks
good. With that, let me run the
78:17 - project and make sure it still
works. We were trying to create
78:22 - something here. And great, that
is still functional. And
78:29 - everything is working as
expected. If you have worked
78:35 - with the API's with dotnet, you
know that where we have all the
78:39 - models, like right here we have
the coupon create DTO we can add
78:45 - something like required, and we
can add data annotation. Then if
78:50 - we go to program that CVS right
here on the request, we can
78:54 - check if the model state is
valid, then proceed further. But
79:00 - with minimal API's model state
validators are not included by
79:04 - default. Well, at least not for
now. It might be in future, but
79:09 - that is not there in the
roadmap. And the idea is to keep
79:13 - it minimal. So if you require
validation, you can of course
79:18 - add your custom validation. Like
right here we have the bad
79:22 - request and so on. But if you
want to use something else like
79:26 - fluent API, you can also add
that in your API project. In
79:32 - order to add that we will be
adding nougat package. So right
79:37 - here we will search for fluent
validation. We will be
79:42 - installing the fluent validation
dependency injection extension.
79:50 - Perfect, that looks good. And
with that we can add validations
79:55 - rather than clustering
everything by we'll be adding a
79:59 - new folder here. or call that as
validation. And we will be
80:05 - adding individual validation.
Now validations might be
80:09 - different when you're creating
or when you're updating a
80:12 - coupon. So, that means add a
class here, which will be
80:15 - coupons create validation for
fluent validations, we will have
80:23 - the base class of abstract
validator, we will add the USING
80:27 - statement and there it is on
generic. So, we need to define
80:31 - what this class will be
validating and that will be
80:35 - cufon Create DTL
80:39 - we can add a validation and
constructor here. And with
80:42 - fluent validation, we use Rule
four and there we define what is
80:47 - the validation we want. So,
first thing we do not want name
80:51 - to be empty, and the percent it
must be between one and 100
80:56 - person, Satish great forward,
how can we add that validation
81:01 - inside our endpoint right here?
Well, we need to inject the
81:06 - validator right here similar to
what we did with AI mapper. So,
81:12 - right here, let me add I
validator on coupon create DTO.
81:17 - We will call that as underscore
validation. And before we check
81:22 - for the name here, we will say
variable validation result is
81:26 - equal to acing and on the
underscore validation, we have
81:31 - validate a sync insert there we
have to pass the coupon create
81:36 - DTO now, we have an error here
because this is an async method
81:42 - and we will have to await but
the endpoint that we have here
81:46 - is not a sink. One workaround is
to remove a weight and right
81:51 - here we can call the get awaited
dot get result and that will
81:55 - work that is completely okay.
Let me show that. Once we have
82:00 - the validation result here, we
can check if the validation
82:04 - result.we have the is valid. If
that is not valid, we will
82:10 - return back an error message.
Now error messages are also
82:15 - inside the validation result
here. So we can say validation
82:19 - result dot errors, duck, first
or default. And we can convert
82:25 - that to a string if there are
any errors. So that looks good.
82:30 - Of course, if you want you can
customize that rather than
82:33 - returning first or default, you
can return all the errors, but
82:38 - again, we are keeping things
super simple. For a fact, let me
82:43 - run this and show the error
message. When we run that we see
82:49 - a weird error message failure to
infer one or more parameters.
82:54 - And in the parameter service we
have something called as
82:57 - unknown. Well here it says Did
you mean to register unknown
83:01 - parameter as a service that
basically means the dependency
83:05 - injection that we added for
validation here, we of course
83:09 - forgot to add that to our
container. So to add that, we
83:14 - will say filter dot services dot
add validator from Assembly
83:19 - containing and here the class
that we are in is program class
83:25 - that will register the validator
service and we can use that with
83:30 - dependency injection. If we run
that, everything works and let
83:36 - me try first here are sent we
will make it more than 100 and
83:42 - execute. We scroll down perfect,
we see the error message percent
83:49 - must be between one and 100 you
enter rebel one zero. So our
83:55 - validation is working. But if we
go down here, we are using the
84:01 - get a waiter dot get result. Let
me continue and remove that in
84:06 - the next video. We are using the
get a waiter dot get result. But
84:13 - what if we do not want that we
indeed want to await here and we
84:18 - want to make our endpoint async.
Doing that is no big deal right
84:23 - before the bracket here. We can
write async here and that will
84:27 - make our endpoint an
asynchronous endpoint. So that
84:32 - was a super easy fix there. But
now I have one question for you.
84:38 - We are injecting two things here
i mapper I validator and then
84:42 - this one we are retrieving from
body. If we go up well we have
84:47 - the integer Id even if we don't
define anything here. Let's say
84:52 - if we are saying that I logger
will be present here. And then
84:56 - we have the integer ID FA
fronted you will Notice it works
85:02 - that out and grid that works.
So, how is the application
85:08 - determining on what it is
getting with dependency
85:12 - injection, what it is getting
with parameters, and everything
85:16 - is confusing, because we are not
seeing that this ilogger is
85:20 - actually being injected. What
happens is the application will
85:26 - first see for all the parameters
that hey, is there a dependency
85:30 - injection registered for this
logger or I mapper, if it is,
85:36 - then I will be injecting that
right here. For the other
85:41 - parameters, like ID, it knows
that it is expecting an ID here.
85:46 - But if it is a coupon, create
DTO or something else, and it
85:50 - does not find any dependency for
that, then it knows that that
85:54 - will be provided as parameter. A
does all of those pretty smart
85:59 - mapping automatically. And we do
not have to worry about that. So
86:05 - that is one thing that I wanted
to point out. With that, let's
86:09 - continue from the next video.
Now with the endpoints that we
86:17 - have, like let's say we have
this coupon create DTO. Right
86:21 - here, we are returning back a
coupon DTO. And then when we
86:26 - have get here, we are returning
a coupon per get all we are
86:30 - returning an IEnumerable of
coupon. What I want to do is
86:35 - rather than returning a
different response based on the
86:38 - type, I want just one single
response type. And that will of
86:43 - course have a data. Along with
that it will have other
86:46 - properties, like any error
message, whether the request was
86:50 - successful, what was the status
code, and so on. So that way,
86:56 - all of our endpoint will have a
standard response message. So in
87:01 - solution here in our models, let
me add a new class. And we'll
87:07 - call that API response. In
there, I want few properties.
87:13 - First one will be a Boolean on
if everything was good. So that
87:18 - will be a success. Then we want
an object, which we will call as
87:24 - a result. And anything that our
API or endpoint returns back,
87:29 - like a coupon list, or a single
coupon, or the coupon that was
87:33 - created. All of that will be in
this result object. Next, I want
87:40 - the status code. So that will be
of type HTTP status code. And
87:45 - finally, I want all the error
message. So let's have a string.
87:51 - And we can call that as error
messages. Perfect, that object
87:59 - looks good here in the
constructor, we will check to
88:02 - see error messages is equal to
new list of string. Perfect,
88:09 - looks good. So rather than
returning anything else here,
88:13 - every time we will be returning
the API response. So at the top
88:19 - here, we will have a new API
response. And when we are
88:23 - returning, we need to store the
result in response dot result is
88:28 - equal to we have the coupon
store that coupon last year. And
88:34 - once we retrieve that, we can
see the response that is success
88:39 - is true. And response dot status
code is equal to HTTP status
88:45 - code dot okay. Let me remove
system.net here and add that in
88:51 - a USING statement. Finally, when
we have results, that okay, we
88:57 - can return back the response
that looks good. This way, we
89:02 - are standardizing what will be
the return type that will be API
89:07 - response. Let me copy these four
lines. And we have the MapKit.
89:13 - Here, let me work on that. We
also need the API response, I
89:19 - should have copied that. And the
result here is right here with
89:25 - four star default, we will paste
that. And perfect. That looks
89:30 - good for the get individual
coupon. Then let me copy this
89:36 - again. While we have the post I
will paste it right here. And
89:42 - when we are actually creating we
can just set a success to be
89:46 - false. And the status code to be
HTTP status code dot path
89:51 - request that we were we have the
bad request. We did not have to
89:55 - assign both the flags here.
That'll cut the result here.
90:00 - everything that is good will be
at the end, we will paste it
90:04 - right there. But when something
is not valid, we need to assign
90:09 - the error message. So we can say
response.we have the error
90:14 - messages that add, we will be
adding the error message right
90:20 - here, cut that pasted, looks
good.
90:25 - Again, you can be fancy rather
than first or default, you can
90:29 - return all the error message,
but you will have to do some
90:32 - conversion where we have
resulted that bad request, we
90:37 - will return back the response.
Let me copy these two lines, we
90:43 - will have to add that right
here. And perfect, looks good.
90:52 - Now, here rather than using
fluent validation, sometimes you
90:56 - also need server side
validation. That is why I have
91:00 - added the custom error message
and returned back the response.
91:05 - We go down here where we have
the created at route, we will
91:10 - return just okay here, because
we have a standard response.
91:15 - That response will have the
coupon DTO. So let me add that
91:19 - here. And the status code here.
You can of course, a created if
91:24 - you want. And that looks good.
We do not need this return
91:28 - statement, we will comment and
let me cut and pasted at the end
91:33 - when we have the other created
with that the accepts here looks
91:39 - good. But the producers is API
response to a one looks good.
91:47 - Let me make sure everywhere we
have that it will be API
91:52 - response. Great. We have
modified quite a few things. But
91:57 - now we have streamlined on what
will be the response for all the
92:02 - endpoint, it will only have our
standard API response that you
92:06 - can see. Let me try to get here.
And it's success is true. It
92:13 - returns them status code 200
looks much better. Let me try
92:19 - the post here. We will try an
invalid percent. And perfect, we
92:28 - have the Edit message.
Everything is much more
92:31 - organized with a single type of
API response. Let me try to
92:37 - create and make sure that works.
Make this a valid one. And we
92:45 - scroll down perfect is success.
We have the result that looks
92:50 - good. With that API response.
Let me continue from the next
92:56 - video. Now that we have added
the cat endpoint get all and
93:03 - post, I want you to take an
assignment and implement the put
93:08 - and to delete endpoints. One
thing that you have to be
93:11 - careful is with the port
request. If I go back for
93:15 - create, we have a coupon create
DTO that we don't have an ID.
93:21 - But when you are updating, you
will require the ID that needs
93:25 - to be updated. So for that, you
will have to create a new DTO
93:30 - call that coupon update DTO and
implement all of those endpoints
93:36 - that are missing. We already
added them you just need to
93:40 - implement these two endpoints
right here. So good luck with
93:45 - that assignment. And I will show
you the solution in the next
93:49 - video. I hope you were able to
complete the assignment. First
93:56 - thing we need to create a DTO we
will copy and paste that and
94:01 - this will be coupon update DTL.
The name here one property that
94:10 - I want to add here is the ID
everything else looks good.
94:16 - Perfect. We need to work on my
port here. Let me go to the map
94:21 - post and copy what we have
pasted right here. Route is the
94:27 - same way we'll change that to be
math put here. And we need
94:31 - Automapper validator will be on
coupon update DTO and from body
94:39 - we will receive a coupon update
DTL Perfect. Now that we have
94:46 - validation like me add that as
well. Copy and paste here and we
94:55 - have coupons updated to letter
95:04 - Perfect. Now when we are
updating, we can add one more
95:08 - validation that Id cannot be
empty, and it has to be greater
95:13 - than zero. Perfect validation
looks good. That may go back to
95:18 - where we have the HTTP POST. Let
me copy what we have here. And
95:23 - we will update for a fact copy
that. Let me add some space
95:29 - here. That way, I can easily
read that. I think this is good
95:35 - enough. Delete, leave some
space. Perfect. Let's see what
95:43 - we are doing here. We have the
API response looks good. We are
95:48 - validating let me call this
underscore view for update.
95:53 - Perfect. We are validating the
result here. That looks good.
95:58 - Let me scroll down. We have the
logic for if coupon already
96:03 - exist, we will have to tweak
that when we are updating to
96:07 - make sure we don't get the ID
that we are already updating.
96:11 - But I will skip that for now.
You can add some more
96:15 - validations here if you want.
But I will keep things super
96:19 - simple. After that, in order to
update we need to retrieve that
96:24 - coupon. So basically, we will
retrieve that coupon using first
96:31 - or default based on the ID that
we receive in the coupon
96:35 - underscore you dot DTO. Once
rated crave that then we can
96:41 - manually update all the
properties in this coupon that
96:45 - we retrieved from the coupon
store based on the coupon yield
96:49 - DTO that we receive in
parameter, we do not need any of
96:54 - these larger care. Let me use
auto mapper using auto mapper,
97:00 - we will map that to be coupon
DTO. And we want to convert the
97:05 - coupon from store to coupon de
to assign that to the result,
97:11 - status code here will be okay
and not created. And perfect.
97:16 - That looks good. We also need to
add the accepts here, we can
97:21 - give that a name. So let me copy
this. And right here, I will
97:27 - paste that name, we can call
that as update coupon. It
97:33 - accepts a coupon update DTO and
produces will be 200. Okay,
97:42 - great. Update looks good. Let me
run and test that. If we try to
97:50 - get here, we have one and two.
Let me try to update do right
97:56 - they're not supposed. But try
that I ID if we keep that as
98:03 - zero, we should see our
validation. Perfect ID must not
98:08 - be empty. We will keep that as
two here. Change the name and
98:14 - percent here to be 12. Let me
execute with scroll down for a
98:21 - fact it is successful. Let me
try to get out of here. And
98:27 - great. Our update is working as
expected. We go back and we will
98:33 - update the Delete. I will copy
what I have within the method
98:38 - here. They stayed inside delete,
we only receive the ID here you
98:45 - can add a custom validator for
delete, but we will keep things
98:49 - simple and I will remove the
validations right here. When we
98:55 - are deleting we want to retrieve
that. So we will retrieve that
98:59 - using first or default. And here
we can just check if coupon is
99:05 - not known. Then we will delete
and this will be to one from
99:11 - store. In that case, we will
remove the coupon from coupons
99:16 - store. Else we have an error
here that we can add the error
99:20 - message invalid ID default
successes walls so we can return
99:25 - back the response or five looks
good. If everything is good in
99:32 - the if condition here. We can
return back the success is true.
99:36 - And status code is okay. If you
want you can also return no
99:41 - content. It depends on how you
want to implement. But with
99:45 - Delete. Typically we return no
content. Perfect. Looks good.
99:51 - With that. Let me try delete in
action. We get here we have the
99:59 - default Part One and two. If
required to delete the ID three,
100:04 - we should get an error message
invalid ID. Let me try to here
100:09 - we get 200. Okay, and execute
that. Our store now only has one
100:17 - coupon. So perfect with that,
update and delete
100:22 - functionalities are working as
expected.