00:00 - hello and welcome to this tutorial i'm
00:03 - antonio papa from scalablescripts.com
00:06 - and in this tutorial we will create a
00:09 - microservices example using python and
00:12 - react
00:13 - let's start by understanding what is a
00:16 - monolith and what are microservices
00:19 - a monolith can be a large code base that
00:22 - has a lot of functionalities
00:24 - and is connected with the single big
00:26 - database
00:28 - in this example that i'm showing you you
00:30 - can think this as a nicomer site
00:34 - we have a search functionality that has
00:36 - a lot of traffic
00:38 - we have a product list
00:40 - which
00:41 - are cached
00:42 - we have a product recommendation
00:44 - functionality
00:46 - we which we can use machine learning to
00:49 - recommend different products
00:50 - and we have a contact page where we have
00:53 - less traffic there
00:55 - the problem with this architecture is if
00:58 - we want to scale this up
01:00 - because the search has a lot of traffic
01:02 - we have to replicate
01:04 - all the functionalities
01:05 - so we are replicating also the parts of
01:08 - the code that has no traffic like the
01:10 - contact page
01:12 - also since it is one repository there
01:15 - can be only one language and you can
01:18 - cause
01:19 - other problems with other teams if which
01:22 - if you change their code since there is
01:24 - only one repository
01:26 - now what are microservices microservices
01:28 - are smaller independent services that
01:32 - have their own database and they can
01:34 - communicate with each other using an
01:37 - event bus
01:38 - so in our example we will have four
01:41 - microservices
01:42 - all have their own database
01:45 - and they will communicate with each
01:46 - other via messages
01:49 - the advantages in this case are that we
01:52 - can scale the applications based on the
01:55 - traffic so if we see the search
01:57 - microservice we scaled
01:59 - that microservice four times compared to
02:02 - the contact
02:04 - where we have only one instance of the
02:06 - contact microservice another advantage
02:09 - is the separation of concerns now the
02:12 - product recommendation team can only
02:14 - focus on machine learning and not
02:16 - scaling up the application
02:19 - also each team can use a different
02:22 - programming language based on their
02:24 - needs
02:25 - now let's jump to the application that
02:28 - we will build
02:29 - in this example we will build a simple
02:32 - microservices example using python
02:35 - the front end of this app will be built
02:38 - with angular react view and swelt
02:42 - you can pick your favorite there
02:45 - the backend is composed into two apps an
02:48 - admin app and the main app the admin app
02:51 - will be built using django
02:53 - and the main app will be built using
02:55 - flask
02:57 - both will run in docker and will connect
03:01 - with their own database in mysql
03:05 - they will communicate with each other
03:07 - using rabbitmq events
03:10 - and in one case the main app will
03:12 - internally call the admin app
03:15 - now let's see what this app looks like
03:18 - so this is the app that we will build
03:21 - it's a simple app where this is the
03:24 - admin and this is the main app
03:27 - in the main app we can like the products
03:29 - and in the admin app we can create the
03:31 - products
03:33 - it is very simple but don't get deceived
03:35 - because it
03:37 - it has two backend apps with different
03:39 - database
03:40 - communicating with rabbitmq which i open
03:43 - it on my right side
03:45 - so
03:46 - let's see an example for example
03:48 - i will like this product here
03:51 - and when i like the product you will see
03:53 - an event happening in rabbitmq right now
04:01 - so the event has been triggered here
04:04 - and we have one ready event and now is
04:07 - zero so it means it was consumed
04:10 - so if we see here let's refresh the
04:13 - admin
04:15 - we can see that we got another like here
04:19 - so in essence it's really simple
04:21 - but
04:24 - this like
04:25 - has more functionality to it since it
04:28 - will internally call also the admin to
04:30 - get
04:31 - a random user
04:33 - and
04:34 - if
04:36 - we happen to like with the same user it
04:39 - will throw an error
04:41 - we can also create a new product
04:44 - so let's create a product
04:48 - and i will add a sample image
04:51 - we will see that
04:52 - rabbitmq will trigger another event so
04:55 - this is a product that we created
04:58 - another head event has been fired
05:01 - and when it's consumed here
05:04 - we will see the product here
05:08 - so it
05:09 - seems that the product is
05:13 - on the admin app on the main app
05:16 - so
05:17 - we got the product
05:19 - so we will see how this app will work by
05:23 - building them so let's start
05:25 - creating
05:27 - the apps
05:30 - so let's start building the admin app
05:32 - using django rest framework
05:35 - to create the project go to tutorial
05:37 - quick start
05:38 - and these are the commands to create a
05:40 - simple
05:41 - django project you have to install
05:44 - django and jungle rest framework from
05:47 - pip
05:48 - i already did it so i can directly go to
05:51 - the terminal and write django
05:54 - admin
05:55 - start
05:57 - project
05:59 - admin
06:02 - and the project is created i can go to
06:04 - the folder now and run python
06:08 - 3 manage that pi
06:10 - run server
06:14 - so the project is running now and i can
06:16 - copy this url
06:19 - and paste it to the browser and we can
06:22 - see that we successfully installed the
06:24 - django project
06:26 - now let's open the project with our ide
06:30 - and this is the app that we just
06:31 - generated
06:32 - now let's run
06:34 - docker so let's create two files one is
06:37 - docker file
06:40 - and the other one is docker compose
06:45 - dot yaml file
06:50 - so
06:50 - let's open the docker file first
06:53 - and what we will write here is first
06:56 - from
06:58 - what type of project is this so we want
07:00 - to get it from python
07:04 - and we have to specify the version of
07:06 - python i will pick the latest one which
07:09 - is 3.9
07:12 - next we will add an environment
07:14 - variable
07:16 - python and buffered one
07:20 - because this is useful to get logs so we
07:23 - can see whatever is happening
07:26 - and now we have to specify a working
07:28 - directory i will call it just up
07:33 - so before going further
07:35 - i will create
07:37 - a requirements
07:42 - txt file
07:44 - so in this file we can put all the
07:46 - dependencies that we will use in our app
07:50 - so i will paste them here
07:52 - we will use django django rest framework
07:54 - mysql client and java mysql so we will
07:58 - connect with mysql
08:00 - jungle course headers this is needed for
08:03 - the front end
08:04 - to access the backend and pica this is
08:07 - useful
08:08 - when we will connect with a rabbitmq
08:12 - now that we added our requirements let's
08:14 - go to the docker file and we will copy
08:18 - requirements.txt
08:20 - to
08:21 - up
08:22 - let's copy the name here
08:25 - requirements.txt so we are copying this
08:28 - file
08:29 - to the work to the working directory
08:32 - requirements so we are copying inside
08:34 - the docker container
08:36 - and now we have to install it so we have
08:37 - to run a command
08:39 - pip
08:41 - install
08:42 - minus r
08:43 - requirements so
08:45 - paste it
08:47 - so this will install all these
08:49 - requirements
08:51 - and
08:52 - in the end we will copy all the files so
08:55 - dot
08:56 - slash up
08:58 - dot in this case means
09:00 - all the files here so we are copying all
09:02 - the files to the app directory
09:05 - the last command is running
09:08 - the project so we have to add here
09:11 - python
09:12 - manage that pi
09:14 - run server
09:16 - and we also need to specify the host so
09:19 - the host will be
09:20 - 0.0.0 0.0.0.0
09:22 - with port 8000
09:25 - so we have to use it this way otherwise
09:27 - we cannot connect the port with our
09:30 - localhost
09:32 - now let's go to our docker compose file
09:36 - here we have to start by adding the
09:38 - version
09:39 - the latest version of docker compose is
09:41 - 3.8
09:44 - and then we have to specify the services
09:46 - so for the moment i will just add the
09:49 - backend service
09:51 - which is our app here
09:54 - first we have to specify the docker file
09:56 - so
09:58 - build
09:59 - we have to put here context which which
10:02 - is this folder
10:04 - and the docker file which is
10:07 - docker file
10:08 - so basically this means
10:11 - that this docker compose file should use
10:13 - this docker file
10:15 - so that's it
10:17 - next we need to specify a port here
10:22 - so this port
10:24 - that is running here is inside the
10:26 - docker container is not our local host
10:29 - so we have to
10:30 - tell
10:32 - our localhost
10:33 - to listen to a specific port
10:36 - so in my case this is
10:39 - the dockerfile port
10:41 - and this is our localhost port so
10:44 - if we don't use this we won't be able to
10:46 - access
10:48 - the server
10:50 - and the last change is the volumes
10:53 - so add here volumes
10:56 - and inside we will specify dot
11:00 - column
11:02 - up
11:04 - this means that
11:05 - [Music]
11:07 - dot means all the files here
11:09 - are connected with the docker container
11:11 - every time we make a change in the app
11:15 - it will
11:16 - pass it to the slash
11:18 - to the docker file up
11:20 - and the opposite if change happens in
11:22 - the docker file it will reflect it here
11:26 - so that's it this is our app
11:29 - now we have to start it
11:31 - first
11:32 - we have to stop the server here
11:36 - and
11:36 - open the terminal and write docker
11:39 - compose
11:40 - up
11:42 - now he's building the backend is
11:44 - downloading all the required libraries
11:46 - for python and it will also install all
11:49 - the requirements here
11:51 - let's wait till it's completed
11:54 - so now everything is running correctly
11:57 - we can see that the development server
12:00 - is running
12:01 - and also we stopped the server from this
12:04 - uh terminal
12:06 - and if we refresh now
12:09 - we'll see we'll get the same page
12:11 - now this is running from the docker
12:13 - container
12:14 - if we stop for example we won't be able
12:17 - to see it so
12:19 - now we don't see it if i start again
12:22 - now it will be much more faster
12:26 - so we can see it
12:28 - so this is how you connect
12:30 - django with docker
12:32 - now we have to connect with the database
12:35 - we already have an sqlite database here
12:37 - but we will remove it
12:40 - because
12:41 - we will be using mysql
12:44 - so the first thing we have to add the
12:46 - mysql service i will call it db
12:49 - and here i will add an image which is
12:51 - mysql
12:53 - version 5.7.22
13:01 - so we added mysql next we have to add
13:05 - restart
13:06 - always
13:08 - so we have to add this command because
13:10 - uh sometimes mysql stops and this will
13:13 - stop also our docker container and our
13:16 - app is no will not run
13:18 - so this will restart it again
13:22 - next we have to add some environment
13:24 - variables so these are some environment
13:27 - variables that we will connect with our
13:29 - backend
13:30 - so we have to add
13:32 - mysql database
13:36 - which is admin
13:39 - mysql
13:40 - user
13:43 - root
13:44 - mysql
13:46 - password
13:49 - i will also put root here
13:51 - and mysql
13:53 - root password
13:56 - root so these values you can pick
13:59 - whatever values you want so
14:01 - you can specify them here
14:04 - next we have to add volumes
14:07 - so this is really important
14:09 - so mysql when we start when it stores
14:12 - data it needs to map them to a folder so
14:15 - i will create a folder here db data
14:18 - which will map var
14:23 - lib
14:24 - mysql
14:27 - so all the files here
14:29 - will be reflected to a folder here
14:31 - called
14:32 - db data so we will see that once we
14:35 - start this container
14:38 - so we are finished now we have to add
14:40 - here ports this is not
14:42 - required at all
14:44 - i will just add it so we can see the
14:47 - data inside the database so
14:50 - the port will be
14:53 - the default port for mysql is 3306 and
14:56 - this is inside the docker container
14:59 - outside we will use 33066
15:03 - or whatever port we want
15:06 - i didn't put the same port because it
15:07 - will conflict with my mysql installation
15:11 - so that's it
15:12 - the last change
15:15 - is we should add here depends on db
15:18 - this means that
15:21 - this container should run first and then
15:23 - this container should run
15:26 - now
15:27 - let's
15:29 - close it and start it again
15:32 - now it's pulling mysql
15:39 - so we can see now the database is
15:41 - running so
15:43 - we can also see a db data folder here so
15:46 - this
15:46 - are the files that when we store
15:49 - anything it will be reflected here
15:52 - we don't have to touch this folder so
15:55 - this is
15:56 - just there to stay
15:58 - now let's connect
16:00 - with our
16:01 - ide so we need a new data source mysql
16:05 - and our port was 33066
16:10 - root for the user root for the password
16:12 - and the database was admin
16:16 - let's test if we connect so we connected
16:19 - successfully
16:20 - now we have only one schema with no
16:23 - tables so now let's
16:25 - add some tables to the database
16:28 - first we have to create a new app
16:31 - so we have to go inside the docker
16:32 - container now
16:34 - so to go inside the docker container
16:36 - open a new terminal and write docker
16:38 - compose
16:39 - exec
16:41 - now we need the name of the service
16:43 - which in our case is backend
16:46 - backend
16:47 - sh
16:49 - we are inside now and now let's run a
16:52 - juggle command to create a new app so
16:54 - python
16:56 - manage that pi
16:58 - startup
17:02 - products
17:05 - so we created the app
17:07 - we can see here
17:09 - the products is created and we run the
17:12 - command inside the docker container
17:14 - now let's uh go to
17:17 - admin and we need to connect
17:20 - we need to add this products to the
17:22 - installed apps
17:24 - first we have to add here
17:26 - rest
17:27 - framework
17:29 - next we have to add here course
17:33 - headers
17:35 - and the products that we just created
17:39 - our course headers needs also
17:42 - a middleware so this is a middleware
17:44 - that we need to add
17:49 - and also it needs a new constant
17:52 - i will add it here in the end
17:55 - course origin allow all so
17:58 - we added everything we need
18:00 - now we need to connect with mysql
18:03 - here we have to change this sqlite to
18:06 - mysql
18:08 - the name of the database would be admin
18:19 - next we have to add the user
18:23 - which is root
18:25 - the password
18:29 - which is also root
18:31 - the host
18:33 - those is no in our case will be this
18:36 - service here so just db
18:40 - db
18:41 - and the port
18:44 - and in this case
18:47 - we won't be using this port but we will
18:49 - use the port inside this service so is
18:51 - 3306
18:55 - so i 3306
18:59 - so this is our connection with mysql we
19:03 - can remove again this sql light here
19:06 - and uh
19:07 - let's restart
19:10 - again the docker containers
19:13 - now we have to run migrations to create
19:16 - tables in mysql so let's go to the
19:18 - products
19:20 - and models so we will create two models
19:22 - here the first one is
19:25 - product
19:28 - this will extend from models
19:30 - model
19:31 - and we will add the fields for the
19:33 - product that we need title
19:36 - which is models a chair field
19:41 - with a max length of 200
19:45 - let's do the same for the image
19:50 - and we need another field which is likes
19:54 - this will be a positive in the integer
19:58 - field
19:59 - and the default value will be zero
20:02 - so this is our product
20:04 - and we need another table now
20:07 - i'll call it user
20:11 - models model so we won't
20:14 - be really using the user table we will
20:16 - just use the user id so
20:19 - i'll just pass
20:21 - so with this this table will have only
20:24 - the id field
20:26 - and the product will have the id and
20:28 - these other three fields
20:31 - so now we have the models we need to
20:33 - generate migrations for these models and
20:36 - we have to migrate so
20:38 - open the terminal let's go inside the
20:40 - docker container again
20:43 - and here
20:45 - we have to write
20:47 - python
20:48 - manage that pi
20:50 - make
20:52 - migrations
20:55 - so we can see we generated migrations
20:59 - these are the migrations that we
21:01 - generated
21:02 - and to run them run
21:05 - python
21:07 - make
21:08 - manage
21:09 - that pi
21:10 - migrate
21:14 - so
21:15 - we run all the migrations if we open the
21:17 - database now and refresh
21:20 - we'll see a bunch of tables
21:22 - we won't be using all these tables
21:24 - the only two tables that we are
21:26 - interested is the products which
21:28 - we have title image and likes
21:31 - and the user which
21:33 - has only the id field
21:35 - so this is how we connect django with
21:38 - mysql and we run migrations
21:41 - so we created our models and now django
21:44 - when we return the objects in an api we
21:47 - need to use serializers so now i'll
21:50 - create a folder a file here sorry
21:53 - serializers
21:58 - and inside i will create
22:00 - a class product serializer
22:05 - this will extend from serializers
22:09 - so let's import it first
22:12 - from
22:13 - rest
22:14 - framework import
22:16 - serializers
22:18 - and this will extend from serializers
22:21 - dot
22:22 - model serializer
22:26 - so inside we'll add another class which
22:29 - is meta
22:31 - and we have to tell
22:33 - which is the model
22:37 - in our case is a product
22:41 - let's import the product here so i will
22:44 - remove this
22:48 - so we
22:49 - said that the product
22:51 - is a model and now we have to specify
22:53 - the fields
22:56 - and i will use all of them
23:00 - so this is our serializer
23:03 - is very simple
23:05 - we won't be using a serializer for the
23:07 - user since we will return a random id
23:10 - there
23:11 - now let's go to the views and now we
23:13 - will use the serializers so
23:15 - here we will create all the five methods
23:17 - for rest api crowd
23:20 - so there are multiple ways to do it
23:23 - in my case i will use the view set so
23:28 - from
23:29 - so i will
23:31 - remove the render from
23:33 - django
23:34 - so rest framework sorry
23:37 - import
23:38 - view set
23:41 - and what we'll do with this view set is
23:44 - we will create a class product
23:46 - view
23:47 - set
23:49 - this will extend from view sets
23:53 - view set
23:55 - so this will have a five methods that we
23:58 - want
23:59 - so i will add here
24:02 - list
24:03 - this will be the list of uh
24:06 - the products
24:08 - so i will list them one by one so this
24:11 - needs a request
24:15 - so
24:15 - i will add here
24:18 - create
24:20 - self
24:21 - request also
24:23 - so these are for
24:25 - slash products route
24:27 - for slash product slash
24:29 - so i will write it here this is r4
24:33 - i will add a comment
24:35 - slash api slash products
24:38 - route
24:40 - i'll let pass here so it won't throw an
24:42 - error
24:46 - so this will have a get request this
24:49 - will have a post request
24:51 - now
24:52 - there are other
24:54 - endpoints that we will use which is def
24:57 - retrieve
25:00 - in itself
25:02 - request
25:03 - and the primary key which is known by
25:07 - default
25:08 - and this will be
25:10 - like
25:11 - this
25:13 - so i will added
25:16 - string
25:17 - id
25:21 - and i will pass it here
25:23 - so there are three
25:24 - methods for
25:26 - a single product
25:29 - one is retrieve the other one is update
25:33 - and the last one is delete
25:40 - so
25:42 - these are all the five methods
25:44 - now i'll remove the this part
25:48 - so to use
25:50 - this
25:50 - methods we have to
25:54 - add here a new file
25:57 - urls
25:59 - i'll copy the same
26:02 - code from this
26:03 - admin urls here
26:05 - i'll paste it here
26:07 - and here we will use
26:10 - products
26:12 - i'll remove the slash
26:14 - and what is
26:16 - this next parameter
26:18 - it will be
26:20 - product
26:22 - view set
26:24 - let's import it from views
26:28 - we have to edit here as a view
26:31 - but we still need extra parameters we
26:34 - have to tell that the get method
26:37 - will
26:39 - point to the list function
26:41 - so as we can see here we have a list
26:44 - and the get
26:46 - method will point to this list function
26:49 - the post method will point to the
26:52 - create function
26:55 - and we have to add another router
26:57 - right now for product slash
27:01 - the
27:02 - it needs a string which is a primary key
27:06 - and this get method now we will call the
27:09 - retrieve
27:12 - function
27:14 - we don't have a post we have a put here
27:18 - this will point to update
27:21 - and delete
27:26 - will point to destroy
27:28 - so i made a mistake
27:30 - this is destroyer
27:36 - so now all the methods are here
27:39 - now let's use them first
27:42 - let's
27:43 - add the list of the products so first
27:45 - let's get the
27:46 - products we have to get the product here
27:52 - objects
27:53 - all of them
27:55 - let's import this product
27:58 - from models
28:00 - so we got all the products
28:02 - now we need to use the serializer we
28:04 - just created so serializer
28:08 - is equal to product
28:10 - serializer
28:13 - let's also import it
28:16 - so imported product serializer here
28:19 - the first parameter is the products
28:22 - and we need another parameter here we
28:24 - have to tell that many is equal to true
28:28 - so we have this is a list of the
28:30 - products
28:31 - and it needs to return an array
28:35 - now that we got the serializer we need
28:38 - to return response
28:41 - with serializer that data let's import
28:44 - also the response here from
28:47 - rest framework response
28:49 - so this is the import
28:52 - so this is our list function
28:55 - let's see how it looks like so i open
28:58 - postman here you have to install it to
29:00 - test
29:01 - the apis
29:02 - here i will use http
29:06 - localhost
29:08 - port 8000
29:10 - slash i forgot also one other thing
29:15 - so we added the routes here
29:18 - i also need to
29:20 - add them here
29:22 - first let's import
29:24 - from django url 0 we will import include
29:30 - and
29:30 - let's add the new path
29:34 - which will start with api
29:38 - we'll add a slash here and we will
29:40 - include here our project which is
29:43 - products
29:44 - so this project
29:46 - dot
29:46 - urls which is this file
29:50 - now that we included
29:51 - now we can use it here is api slash
29:55 - products
29:57 - and normally we don't have any
29:59 - product so it will return an empty array
30:02 - now let's add the next
30:04 - function which is create
30:08 - here
30:09 - we'll get the serializer
30:13 - which is equal to product serializer
30:16 - and we have to pass the data from the
30:18 - request
30:19 - so data is equal to request the data
30:25 - so we will use those data and
30:27 - we have to first
30:32 - call
30:33 - is valid so if
30:35 - we send valid data to this serializer
30:39 - if not we will erase an exception
30:43 - and if it's valid it means we will go to
30:46 - this line
30:47 - it means we'll save it
30:50 - after we save it we return the response
30:53 - so response
30:55 - serializer.data
30:57 - and we have to put a status here so
31:01 - we'll import from status
31:05 - let's import status
31:09 - so i don't remember the exact import
31:12 - here but we'll use status is equal to
31:14 - status
31:17 - dot
31:18 - http
31:21 - 201
31:23 - created
31:26 - let's import this status
31:30 - so it's from rest framework we'll import
31:33 - status here
31:36 - now let's
31:37 - use it so we will change this from get
31:40 - to post
31:41 - and we will send some
31:45 - from
31:46 - json here we'll send
31:48 - some request
31:50 - we need the title
31:52 - title
31:53 - and an image
31:57 - which is
31:58 - image let's send the request
32:02 - and we return the title notice that we
32:04 - get also the likes here
32:05 - by default is zero
32:08 - we got also an id
32:09 - so our first product is created if we go
32:12 - to the get
32:14 - method now
32:15 - we'll see an array with a one product
32:19 - so this is the create function
32:23 - the retrieve is really simple
32:25 - we have to get the product
32:28 - which is equal product
32:30 - objects get
32:33 - the id is equal to this primary key
32:37 - now that we got the product we have to
32:39 - get the serializer
32:42 - is equal to product serializer
32:44 - with the product
32:46 - and we have to return in response
32:49 - serializer.data
32:53 - let's use it so
32:55 - this has id1 so
32:57 - if we put a get request with id 1 we
33:00 - return a
33:01 - single object
33:03 - products returns an array of objects
33:08 - now let's go to the update
33:11 - let's copy this part i'll
33:13 - put it to the update and also destroy
33:15 - because we will use the object there
33:18 - so we'll get the serializer here
33:22 - is equal to product serializer
33:25 - we have to pass the instance
33:27 - which is this product so the instance is
33:30 - a product
33:31 - with the data that it has
33:34 - and we have to update it with a new data
33:36 - which we will get it from the request
33:39 - the data
33:41 - so this is a project that the product
33:43 - that we have
33:45 - and these are the data that we want to
33:46 - update it
33:49 - now we have to
33:50 - do the same thing we have to
33:53 - ask if the serializer is valid then we
33:56 - have to
33:57 - save
33:58 - in the end we'll return a response with
34:00 - the serializer.data
34:02 - and we have to change the status which
34:04 - is
34:05 - 202 accepted
34:08 - so let's change
34:09 - product with id1
34:12 - we'll send a boost reboot request here
34:14 - and this is new title and the new image
34:19 - send requests and we can see that these
34:22 - values are changed now also the status
34:25 - is 202 accepted
34:27 - last change is destroying the object
34:31 - this is really simple we have to call
34:33 - product
34:34 - delete
34:36 - and that's it so we have to return here
34:38 - response
34:40 - with the status
34:42 - status
34:44 - http 204 no content
34:49 - so let's
34:50 - delete this product
34:53 - send the request and we have 24 no
34:56 - content we don't have a product and if
34:58 - we go to the products
35:01 - uh
35:02 - not delete method so
35:05 - we have still an empty array now here
35:09 - now the last call that we need is the
35:12 - user's call so we'll create another
35:14 - class here
35:16 - user
35:17 - api
35:20 - view so i will not use a view set now i
35:23 - will use an api view
35:27 - api view here so let's import it
35:31 - from rest firm framework views we'll
35:34 - import api view and this will be really
35:36 - simple we need
35:38 - to define the get
35:41 - function
35:43 - and we need the parameter here which is
35:45 - a request
35:47 - which we won't use it i will put an
35:49 - underscore here
35:51 - we have to get the users
35:54 - users
35:56 - user sorry
35:58 - objects all
36:01 - so let's import also
36:03 - user from the models so we imported it
36:06 - here
36:07 - now we got the user
36:09 - we have to get a random user so
36:13 - here
36:14 - i will import
36:16 - random
36:20 - to get a random user
36:23 - is equal to
36:24 - random choice
36:27 - users
36:29 - and this will be a random user now let's
36:31 - return the id response
36:37 - id
36:39 - is user.id
36:41 - so this is a user so let's add it also
36:44 - to the urls
36:47 - the path will be
36:48 - user
36:50 - and we have to import it here
36:53 - user api view
36:56 - user api view here as view
37:00 - so let's test this
37:03 - route
37:04 - so this will be a get request to the
37:06 - user
37:09 - this returns an error because we don't
37:12 - have any users in the database
37:15 - so i will manually add here some values
37:19 - so
37:20 - i'll add here one
37:23 - two
37:24 - three
37:26 - four and five
37:28 - so i'll add five users
37:31 - or five numbers
37:33 - now let's send the request again and i
37:35 - get five
37:36 - if i send it again it's four so
37:39 - the result is randomized
37:43 - so this was our main app
37:46 - now we have to create another app
37:49 - so we can communicate it so that the
37:51 - other app will be a flask app
37:54 - now it's time to create the main app and
37:56 - i decided to make it with flask
37:59 - so i created a main folder and inside i
38:02 - created an empty main.pi file
38:05 - so let's start first
38:07 - i'll paste here the requirements
38:11 - that we need so we need to install flask
38:14 - flask sql alchemy sql alchemy
38:17 - flask migrate flash scripts flash course
38:20 - request mysql client and pica
38:23 - so there are a lot of
38:25 - requirements that we need
38:27 - and
38:28 - now we will go to the other project and
38:31 - i will copy the docker files here
38:33 - and paste them here
38:37 - so
38:39 - the docker file
38:40 - will be the same here
38:43 - except for
38:44 - the command which will be simpler
38:48 - just python
38:50 - main
38:52 - dot pi
38:54 - so this will be the docker file a docker
38:58 - compose file for mysql it will be the
39:00 - same except this will be a new port i'll
39:02 - put 7 here
39:05 - and i will change the database name to
39:06 - main
39:09 - there is no need to change the database
39:10 - name because this is another container
39:13 - but
39:14 - we changed it
39:16 - so the port the default port for flask
39:19 - will be 5000
39:21 - and
39:22 - 8000 is occupied with
39:25 - the jungle up so i will use
39:27 - 8001 here
39:29 - and that's it so
39:31 - the docker files are completed now let's
39:34 - create
39:35 - a flask up here so from
39:38 - flask
39:42 - import
39:43 - flask
39:46 - let's create
39:47 - the app
39:49 - is equal to flask
39:53 - name here
39:56 - so
39:58 - let's start a basic app so here i will
40:00 - add new route up
40:03 - route
40:05 - so
40:06 - just slash
40:08 - i'll create a function
40:10 - index
40:13 - and
40:13 - here i will return just hello
40:16 - so let's see if this works
40:20 - so i need to add a condition
40:22 - if name
40:25 - is equal to
40:27 - main
40:31 - then up
40:33 - run
40:34 - with debug is equal to true
40:37 - we also need the host so the host will
40:40 - be 0.0.0.0
40:46 - so
40:47 - that's it now let's try to run it
40:49 - without a docker container
40:52 - python
40:54 - 3
40:56 - main.play
40:58 - so we got this port
41:00 - let's copy it
41:04 - and open a new tab in postman
41:10 - so we have an error
41:15 - so
41:16 - is hello
41:18 - not sure why throw the narrow
41:21 - now let's do the same
41:22 - but this time with docker
41:25 - so
41:26 - we have all the requirements we don't
41:28 - need to change anything
41:30 - so let's start
41:31 - docker
41:32 - compose
41:33 - up
41:35 - and let's wait till it's completed
41:42 - so it's finished
41:44 - we can see a db data folder here
41:48 - and uh
41:49 - let's test it now the port will not be
41:52 - 5000
41:54 - because this will be inside the docker
41:56 - container
41:57 - the port will be 8001 so here i'll
42:00 - change it with localhost
42:04 - port 8001
42:07 - and that's it so
42:09 - we can see hello now
42:11 - so
42:11 - docker is working
42:14 - now let's add
42:15 - mysql to
42:17 - this main.pi file
42:20 - so let's import sql alchemy so from
42:26 - flask
42:28 - sql alchemy
42:32 - import
42:33 - sql alchemy
42:35 - and we need to use it here so up
42:39 - config
42:43 - and we need to set a
42:45 - constant so is sql alchemy
42:51 - underscore database
42:54 - underscore uri
42:57 - so with this we will add the db
42:59 - connection
43:00 - and what we need is to add mysql here
43:06 - and
43:08 - here we need to add the user and the
43:10 - password so root root in our case
43:15 - at now we need the host the host will be
43:19 - the service here which is db
43:21 - so the host will be db
43:23 - and in the end will be the table which
43:26 - is main
43:28 - so with this we can connect to this
43:31 - database
43:34 - i will add also of
43:36 - course here
43:39 - since the front end will need it so
43:42 - let's import it from flask course
43:46 - i'll add it to the app
43:48 - and
43:49 - now
43:51 - the database is equal to sql alchemy
43:58 - and
43:58 - here we'll pass up
44:00 - now let's create two models that we need
44:02 - so class
44:04 - product
44:06 - this will extend from db
44:08 - model
44:10 - and let's add all the required
44:14 - properties for the
44:15 - product we need the id
44:18 - which is a
44:20 - db
44:21 - column
44:23 - db integer
44:28 - and also is a primary key
44:33 - now we have to make another change for
44:36 - the id here
44:38 - we will add here
44:40 - auto increment to false
44:42 - why did i add this field
44:45 - because
44:46 - the product will not be created in this
44:48 - app the product will be created in
44:52 - the jungle app
44:54 - and this app will just catch the event
44:57 - from rabbitmq
44:58 - and it will create the product
45:01 - and when we create the product we don't
45:03 - want the id to be auto increment
45:06 - because the id will be different than
45:08 - the the jungle app
45:11 - so if we want the same id we have to put
45:14 - it onto incremental false and to insert
45:17 - directly the id as it is from the django
45:20 - app so we'll see by example a little bit
45:23 - later
45:25 - now let's add the title
45:30 - db
45:31 - column
45:34 - db
45:35 - string
45:37 - and this will be a
45:38 - 200 character
45:41 - let's do the same for the image
45:46 - so this is a product
45:49 - notice that uh
45:51 - this product will be different than the
45:53 - product from
45:54 - the other app
45:55 - because we don't have likes here
45:59 - and the id is different so we can you we
46:02 - can think this as a different type of uh
46:06 - the same thing
46:08 - let's add also another class that we
46:09 - need each which is product
46:15 - user
46:17 - from db
46:19 - model
46:21 - so this will have an id
46:23 - which
46:24 - is a
46:26 - column db integer
46:30 - primary key to true
46:32 - so this will increment normally
46:36 - we need here the user
46:39 - id
46:41 - which is a db column
46:43 - db integer
46:46 - and the same for the product id
46:56 - we need also a unique
47:02 - constraint
47:06 - for user id
47:11 - product id
47:14 - and we need to set the name which is a
47:16 - user product
47:19 - unique
47:22 - so this unique constraint so let's
47:25 - import it from
47:27 - sql alchemy
47:29 - from here
47:31 - so
47:32 - this unique constraint will make sure
47:35 - that the combination of user id and
47:37 - product id should be unique
47:39 - we should not repeat it
47:41 - so we created the models that we will
47:44 - use now we need to migrate so
47:47 - to migrate
47:48 - i will create a new file here
47:51 - i'll call it manager
47:55 - and now here we need some imports so
47:58 - first
47:59 - from the main app
48:02 - we need to import up and db
48:06 - we need to import from
48:09 - flask
48:10 - migrate we need to import
48:14 - migrate and migrate command
48:17 - and from
48:18 - flask script we need to import manager
48:24 - now
48:25 - migrate
48:26 - will be equal to
48:28 - migrate with our app and our db here
48:33 - then we have to get to the manager so
48:35 - manager
48:37 - is equal to manager
48:40 - we need to pass the app inside and the
48:43 - manager
48:45 - will
48:46 - add the command db
48:49 - we'll add the migrate command here
48:52 - so
48:54 - we will have a db command to run our
48:56 - migrations so we will see it
49:00 - now that we will add the
49:02 - if
49:04 - name
49:07 - is equal to main
49:09 - so
49:12 - we need to add manager run
49:17 - and that's it
49:19 - so
49:20 - if we open the terminal now
49:22 - and open a new tab we'll run here docker
49:26 - compose
49:27 - exec
49:28 - backend
49:30 - sh
49:32 - and now we are inside the docker
49:33 - container now if we run
49:36 - python
49:38 - manager dot pi
49:41 - and
49:42 - we will
49:44 - run the command db so we added the
49:46 - command here
49:47 - with help
49:50 - we can see
49:51 - now that we have a command that we can
49:53 - run
49:55 - now let's
49:56 - migrate so to migrate we have to run
49:59 - python
50:00 - manager
50:02 - dot py
50:04 - db init
50:08 - so we created
50:10 - some migration files
50:13 - we can see them here
50:15 - now we need to migrate them so
50:18 - now around python
50:20 - manage
50:22 - dot pi
50:24 - db migrate
50:28 - so
50:29 - it should be
50:30 - python
50:32 - manager
50:33 - that pi
50:35 - db
50:36 - migrate
50:40 - so we created a new table if we open the
50:43 - database now we'll connect with the
50:45 - database
50:47 - so
50:48 - this will be 7 here
50:50 - the user is root
50:53 - password is also root
50:55 - and the database will be main
51:00 - so let's connect
51:04 - we'll see a
51:06 - database now with the emblemic version
51:08 - but we won't see our tables because we
51:11 - need to run another command for it
51:14 - which is python
51:16 - manage
51:18 - that
51:18 - manager sorry that pi
51:21 - db
51:22 - upgrade
51:27 - and now we run the migration if we
51:29 - refresh we'll see the table so this is a
51:32 - product table
51:33 - and this is a product user table
51:37 - so this is how we connect flask with
51:41 - mysql
51:42 - using docker
51:45 - now it's time to use rabbitmq to our
51:47 - python apps
51:48 - so i will use this service cloud ampq
51:53 - and
51:54 - you have to create
51:55 - a free account
51:57 - this is the free account i already have
52:00 - created so i can log in
52:04 - so this is my free account
52:06 - and what i will do here is
52:08 - this ampq url i will just copy it and
52:12 - now i can move to the app so
52:14 - i will go to the jungle app
52:17 - and uh in the products here i'll create
52:19 - a python file
52:21 - producer
52:25 - and for the moment i will just copy this
52:27 - url
52:29 - now let's send an event to rabbitmq
52:32 - so first we have to import pica
52:36 - this is a package that
52:38 - will help us
52:39 - send events
52:41 - and let's create a variable params
52:44 - is equal to pica
52:47 - url parameters
52:49 - and here we can put the url that we just
52:52 - pasted here
52:54 - as a string
53:01 - so we created the params
53:04 - this is annoying
53:06 - the connection now
53:08 - is equal
53:10 - to
53:12 - pica
53:14 - blocking connection
53:16 - and we will pass the params here
53:19 - so
53:21 - we created the connection with rabbitmq
53:23 - now we have to create the channel
53:26 - which is equal to connection
53:28 - channel
53:31 - so with this we
53:33 - created the channel now we can publish
53:35 - so to publish i will create a function
53:40 - publish
53:42 - inside i will put a method
53:45 - and a body
53:48 - so
53:49 - for a moment i will just keep it empty
53:52 - so we can see an example
53:55 - of the publish
53:57 - method so channel here
53:59 - basic
54:01 - publish
54:03 - we need to put an exchange i will put an
54:05 - empty string
54:07 - routing key this is a queue that we want
54:10 - to send the
54:11 - event
54:12 - so for the moment i will put it admin so
54:15 - i will publish it in the same queue as
54:17 - this one
54:20 - with the hit we need the body
54:22 - which is for the moment hello
54:26 - so that's it
54:28 - we can use this publish function now i
54:31 - will use it
54:32 - in the views
54:33 - when we list the products
54:36 - i'll just publish here
54:44 - so i imported the function
54:46 - and when we retrieve all the products we
54:49 - will publish hello
54:51 - now we created the producer
54:54 - now we need to create the consumer so
54:56 - here we need to create the consumer
55:03 - so the beginning is the same let's copy
55:07 - everything from the the producer
55:12 - paste it here
55:14 - and now we have to declare a queue so
55:16 - channel
55:19 - cue
55:22 - declare
55:25 - and the queue will be
55:26 - admin
55:30 - so now we need the callback
55:32 - so call back
55:37 - this
55:38 - accepts a
55:39 - channel as a parameter method
55:42 - properties
55:45 - and body
55:47 - let's pass for the moment
55:51 - after the callback we have to
55:53 - call channel basic
55:57 - consume
55:59 - here we have to pass the queue which is
56:02 - admin
56:04 - and
56:05 - we have to pass on message callback
56:08 - which is this callback that we just
56:10 - created
56:12 - so
56:14 - we are basically consuming now
56:16 - we can print
56:20 - started
56:21 - consuming
56:25 - since we want to have a message to see
56:27 - if we started consuming and the channel
56:31 - start
56:33 - consuming
56:37 - so with this
56:38 - in the end we'll close it so channel
56:40 - close
56:43 - so we basically have finished now let's
56:46 - uh print a message also to
56:48 - know
56:49 - if we received a message so print here
56:53 - re
56:54 - sieve
56:57 - in admin
57:00 - so we received a message and i will
57:02 - print the body here
57:04 - if we go to hello there
57:08 - so that's it now let's try to open the
57:12 - terminal
57:13 - go to the docker file so docker compose
57:16 - exec
57:18 - backend
57:19 - sh
57:21 - here we have to call consumer.pi so
57:24 - python
57:25 - consumer.pine
57:28 - so we received this messages because i
57:31 - already
57:32 - sent some test events
57:35 - now let's test it
57:38 - let's go to the route for the products
57:42 - and we can expect when we get the
57:44 - products here to send an event hello
57:46 - there
57:47 - send
57:50 - we can we can see now we received an
57:53 - event hello
57:55 - now let's consume to the flask app so
57:58 - what i will do is copy this consumer
58:00 - file
58:01 - go to the flask app and here i'll paste
58:04 - the consumer
58:06 - so everything is the same except the
58:08 - queue here will be
58:11 - main
58:15 - so
58:17 - we are done
58:19 - now
58:19 - i can
58:22 - so
58:24 - i can start it with pub python
58:28 - consumer
58:31 - dot pi
58:33 - so we started consuming
58:36 - and
58:37 - in the producer here
58:39 - i will change the
58:41 - routing key to
58:43 - main
58:44 - so now i will not publish here in the
58:46 - admin app but i will publish here in the
58:49 - main app
58:50 - so let's see if
58:52 - this makes any difference let's send the
58:54 - event
58:56 - we can see hello here was from before
59:00 - but this
59:02 - received the hello now so
59:04 - to see the difference
59:07 - hello main i will say hello main
59:11 - so let's send it again
59:14 - we don't see a hello main here but we
59:16 - will see it here so this is
59:18 - how
59:19 - we send events
59:21 - to different apps using pica and
59:24 - rabbitmq
59:26 - now we successfully
59:28 - connect us with rabbitmq and we started
59:30 - consuming uh
59:32 - with the both apps
59:34 - now we don't want to have all the time
59:37 - to tabs here to start the consumer
59:40 - so
59:41 - we'll change the docker compose file now
59:44 - first
59:45 - let's change the docker file
59:47 - we will cut this command here
59:51 - and
59:52 - we will add it directly here
59:54 - so
59:56 - when we build
59:57 - we'll execute the command
60:00 - that we just cut so this is basically
60:02 - the same as before
60:04 - we run the command here but now we are
60:06 - running it here
60:09 - we did that because we will create
60:10 - another
60:11 - container now so is q
60:14 - i will call it
60:16 - which will have the same docker file
60:19 - and the the difference now is
60:22 - we will start a command now
60:26 - and the command will be python
60:31 - consumer dot pi
60:34 - so we will run the command directly here
60:37 - instead of manually running it every
60:40 - time
60:41 - this also depends on the database
60:44 - because we will
60:46 - insert data later
60:48 - so let's
60:50 - do the same for the flask app
60:52 - so
60:54 - i'll paste the queue here
60:59 - so this file is the same so
61:02 - the difference now is
61:05 - i will cut this command here
61:09 - and i will
61:12 - put it here
61:13 - command
61:15 - python main api
61:18 - so
61:19 - now
61:20 - let's
61:20 - restart
61:22 - all the containers so i will run
61:25 - docker
61:26 - compose
61:28 - up
61:29 - build
61:31 - now we don't need the other tab
61:34 - let's do the same for this
61:36 - also let's remove this tab and
61:41 - we will
61:42 - build
61:43 - all
61:44 - the containers now we are building the
61:46 - queue
61:48 - so as we can see
61:51 - we are getting the q so the q is here
61:55 - so one other thing that we can make
61:58 - is by running it like this a docker
62:00 - compose
62:02 - up
62:03 - minus d
62:05 - for the
62:06 - database
62:08 - so d
62:10 - means we won't see the logs
62:13 - let's do the same for the backend
62:15 - or
62:16 - for the back end and the queue we need
62:18 - to see the
62:20 - logs so now we are seeing the logs from
62:23 - the queue and from the back end
62:27 - let's do the same here
62:29 - so
62:30 - minus d here db
62:33 - and docker compose up
62:39 - now let's see if this works so
62:42 - we are the products here let's send the
62:45 - request again we won't see it here but
62:48 - we should see it here
62:50 - also another change that we have to make
62:54 - if we close
62:56 - our containers and run them again
62:59 - we'll notice so if i do it with a
63:02 - database like this
63:04 - and the others
63:06 - double compose up
63:08 - you will notice that i will still get
63:11 - the cues but they
63:14 - they are not consumed yet so
63:16 - there is one last change that we have to
63:18 - add in our consumer
63:21 - and here we have to add auto ack
63:24 - true
63:27 - so with this we will
63:30 - consume the
63:32 - calls and we will not get them again so
63:35 - let's do the same for the
63:38 - other consumer
63:40 - and let's restart the containers again
63:44 - with build
63:47 - also this one
63:50 - will build
63:54 - so they are rebuilt now
63:56 - if we do the same
63:58 - with the database and we
64:01 - start the other apps
64:04 - we will see that the queue started
64:06 - consuming but we cannot see anything
64:09 - here
64:10 - so that's it now
64:12 - with uh these changes
64:15 - consuming becomes easier
64:19 - now we want to send events every time a
64:22 - product is created updated or deleted
64:25 - so we have to change this publish method
64:28 - we will add here a method
64:31 - and a body
64:35 - so
64:36 - for the method
64:38 - we have to create
64:40 - variable properties
64:42 - which is equal to pica
64:45 - basic
64:46 - properties
64:48 - and here we will pass a method
64:52 - and here we'll pass the properties is
64:55 - equal to properties
64:58 - also for the body so we need to
65:01 - import json here
65:04 - and the body will be
65:06 - json
65:08 - dumps
65:10 - body
65:12 - so we will send objects or anything but
65:14 - we have to convert it to json before we
65:17 - send it
65:18 - so this is our publish function now
65:22 - let's use it to our views
65:24 - let's remove this publish here
65:26 - and now
65:27 - when we create
65:29 - we will publish
65:31 - product
65:32 - created
65:34 - and we will send the serial laser the
65:37 - data
65:40 - let's do the same for product updated
65:44 - product
65:45 - updated
65:47 - and for the product deleted
65:51 - now instead of the object we'll send
65:54 - directly the primary key
65:57 - so these are the main events that we
65:59 - want to send
66:02 - and now let's make changes to the flask
66:04 - app
66:05 - here we have to get the
66:09 - data which is equal to
66:12 - json so i will import json here
66:17 - json
66:19 - loads
66:21 - body
66:23 - so
66:24 - in the django app we will convert it to
66:26 - json so now we will con convert it back
66:31 - let's print it so we can see what data
66:33 - are we sending
66:35 - and now
66:37 - we'll make the condition if properties
66:40 - content type
66:44 - is equal to product
66:47 - created
66:50 - will create the project so
66:52 - the product sorry
66:54 - so the product
66:56 - is equal to product
66:59 - with an id
67:01 - data
67:02 - id here
67:05 - title
67:06 - so let's import also this product here
67:11 - is equal to data
67:13 - title
67:15 - and image is equal to data
67:19 - image
67:21 - in the end
67:22 - let's import also the db
67:26 - db session
67:29 - add product
67:31 - ndb session
67:33 - commit
67:35 - so this is how you create a
67:37 - an object
67:39 - with sql alchemy
67:41 - now let's do the same for the other
67:44 - conditions so properties
67:46 - content type
67:49 - product
67:50 - updated
67:54 - so
67:55 - now we will get the product
67:58 - is equal to product
68:00 - query
68:02 - get
68:03 - data
68:04 - with an id
68:06 - and we have to change this product so
68:08 - product
68:11 - title
68:12 - is equal to data
68:15 - with the title
68:17 - and the image
68:20 - so
68:24 - image here
68:27 - in the end we will
68:29 - call session commit
68:34 - the last change is deleting so
68:37 - properties
68:39 - content type
68:41 - product deleted
68:45 - and in this case we'll get the product
68:47 - like this
68:49 - but we don't send an object we
68:53 - send directly the id so this data is the
68:56 - id
68:58 - we have to do it like this now db
69:01 - session delete
69:04 - product
69:06 - and tb
69:08 - session
69:09 - commit
69:12 - so
69:13 - these are all the three cases
69:16 - that
69:16 - we will receive
69:19 - from the other app
69:21 - now let's see if they work but before
69:25 - we should restart our
69:28 - containers just to be sure so
69:32 - build
69:39 - so there is no need to
69:41 - restart this one but
69:43 - just let's do it to be sure
69:48 - so this is started
69:51 - and now
69:53 - we have the products here which we don't
69:55 - have any
69:57 - let's create a product
69:59 - here i will
70:01 - send some data
70:05 - title
70:09 - is a title here
70:11 - and the image
70:14 - an image
70:18 - let's send the request
70:20 - so we successfully created pro the
70:21 - product in
70:23 - the django app but let's see if we
70:25 - created it in the
70:26 - uh
70:29 - flask app
70:30 - so we received the queue
70:32 - we probably forgot we should add here
70:35 - some
70:36 - print statements like
70:39 - product
70:40 - created
70:43 - product
70:44 - updated
70:45 - and product
70:47 - deleted
70:48 - but doesn't matter let's see the
70:50 - database
70:52 - and we can see this is a product now so
70:55 - we successfully created the product
70:58 - from an event from rabbitmq now let's
71:01 - try to update it so this product
71:06 - will put send a put request with a new
71:08 - title and a new image
71:13 - so i will not save it let's send the
71:15 - request
71:17 - this is updated
71:19 - and if we see the event
71:22 - we got the new title and a new image we
71:26 - don't see the
71:28 - print that we just added because we have
71:30 - to rebuild the containers
71:33 - now we're just checking the database
71:34 - which is correct
71:37 - and now let's try to delete it
71:42 - and
71:43 - this is received
71:45 - and if we refresh here
71:49 - we can see we have no product so
71:52 - now the databases for the product are in
71:56 - sync from the jungle app and for the
71:59 - flask up
72:02 - so we completed the jungle app now let's
72:05 - finish the flask up since we have only
72:08 - one route here
72:10 - so let's
72:11 - change this route to just api slash
72:14 - products
72:16 - and here we'll return a list of products
72:20 - so
72:21 - let's import jsonify from flask here
72:27 - and we will return jsonify
72:30 - product
72:33 - query
72:35 - all
72:38 - so
72:39 - let's see if this works
72:45 - so let's see if this works
72:49 - so
72:50 - the endpoint is api slash products
72:55 - and we got one product
72:57 - let's create
72:59 - one product here so we can see it if it
73:02 - works
73:05 - so we got this product that we just
73:07 - created
73:09 - so
73:10 - we should see it in the database
73:13 - notice that the id is three
73:16 - so when we created this product
73:19 - we don't start with one but the idea
73:22 - that we have it on our django app
73:26 - now let's send the request
73:28 - and we get an error
73:30 - because object of type product is not
73:33 - json serializable
73:35 - to fix this error we have to add here it
73:39 - data class
73:42 - and let's import it from data classes
73:45 - so
73:47 - with this now the
73:49 - class will be json serializable let's do
73:51 - the same for the product user
73:55 - send the request again
73:58 - and we got an md object
74:01 - but we want to see the data which we got
74:04 - id title and image here
74:07 - to do it we have to declare it here
74:10 - id should be an int
74:14 - title
74:17 - should be a string
74:20 - str so and image
74:24 - should be a string
74:27 - with these changes now
74:29 - we can see the id image and the title
74:34 - so with this we completed
74:37 - the main route
74:38 - now let's add another route so
74:42 - i'll call it like
74:45 - and this will have
74:47 - up
74:49 - route
74:52 - api
74:55 - products
74:57 - we need the idea of the product which is
75:00 - an integer
75:01 - the id
75:03 - and
75:04 - we have to like it so this is the end
75:07 - point the method
75:09 - is a post request
75:12 - and when we like we will
75:15 - send an id here
75:19 - so
75:20 - how do we like the product so now it's a
75:23 - little bit complicated we have to
75:24 - internally call
75:26 - the
75:27 - django up
75:28 - so we have to internally call this user
75:31 - api view here to get a random id
75:34 - and we have to assign it to the product
75:36 - user so first we have to
75:41 - create a variable i will call it rec
75:43 - and this
75:44 - will call requests
75:49 - dot get
75:51 - let's import requests
75:54 - from
75:55 - so we import directly requests here
76:01 - and now we have to get
76:04 - the endpoint so the endpoint is http
76:10 - localhost
76:12 - port 8000
76:14 - slash api slash user
76:18 - and for the moment we will just return
76:21 - json if i
76:23 - request
76:25 - json
76:27 - not sure if i need jsonify here but
76:31 - let's try it
76:33 - so
76:36 - products with an id1 we need to like it
76:41 - let's send a post request
76:43 - send
76:44 - and we get an error connection refused
76:49 - so what is the error here
76:51 - there is localhost here because right
76:54 - now we are inside the docker container
76:57 - and the localhost inside the docker
76:59 - container is 0.0.0
77:03 - how to connect
77:05 - with another docker container localhost
77:07 - we have to specify here
77:09 - that this is
77:11 - docker
77:12 - for
77:14 - mac
77:15 - localhost
77:18 - so this is the way the docker knows that
77:21 - we are referring not the
77:23 - container localhost but
77:26 - another localhost so our local localhost
77:29 - so with this change
77:32 - let's try to send it again
77:33 - it seems we
77:36 - the server stops so we probably need to
77:38 - restart it
77:44 - send it again and now we got id2
77:47 - so this is id from
77:49 - the user so
77:52 - this will be user here
77:55 - so not post get
77:58 - so
78:00 - this
78:01 - endpoint 8001 will call this other
78:04 - endpoint
78:07 - now that we got the response let's use
78:10 - it and create a product user
78:13 - so here
78:16 - we will
78:17 - get a json
78:20 - is request.json
78:24 - in the end if it is successful we will
78:25 - return a message
78:28 - success
78:32 - and
78:32 - we will
78:33 - make a try
78:35 - accept here
78:37 - so what we will try is we will create a
78:40 - product
78:41 - user
78:42 - which is equal to product user
78:46 - with user id
78:48 - is equal to
78:51 - json
78:53 - id
78:54 - and the product id
79:02 - is equal to the id that we just set this
79:05 - one
79:06 - from the url
79:09 - and now that we set this product user we
79:11 - have to add it
79:12 - db session
79:14 - add
79:16 - product user
79:18 - and we have to commit
79:24 - and here we'll send an event
79:27 - which i will send it later
79:30 - and if an error happens
79:33 - there is
79:35 - when the user tries to
79:37 - like again because this is an unique
79:39 - constraint
79:41 - if that happens we will abort
79:45 - let's import a board
79:49 - from flask board
79:51 - we'll put 400 here and
79:54 - you
79:55 - already
79:56 - liked
79:58 - this product
80:01 - so
80:02 - a board we imported from from flask here
80:07 - so let's try it
80:09 - let's send the request again send
80:12 - success
80:14 - if we see the database
80:16 - product user we created one
80:19 - and it will happen that we will fail
80:25 - it seems that our unique constraint
80:28 - didn't work
80:30 - so
80:31 - i probably made a mistake here but i
80:33 - won't focus on that
80:35 - let's uh finish this up by sending an
80:38 - event
80:39 - now we need to
80:41 - get the producer
80:43 - i'll copy the same producer here
80:48 - so everything now is the same
80:51 - and we have to use it here
80:55 - now
80:56 - if this is completed we have to add
80:58 - here producer so
81:01 - publish
81:04 - let's import it
81:07 - product
81:08 - liked
81:09 - and we have to pass the id of the
81:11 - product
81:13 - so let's we need to import it here
81:18 - so this is our
81:20 - flask up
81:21 - only one thing that
81:23 - i think is easy fixable
81:25 - now let's make the last change here on
81:28 - the consumer
81:31 - we will get the
81:32 - data here
81:34 - which is equal so let's import json
81:39 - json
81:41 - loads
81:42 - body
81:45 - let's print the data
81:48 - and we here will
81:51 - like the product so we'll get a product
81:53 - first
81:55 - which is equal to product
81:58 - let's import it so from products models
82:02 - we'll import product
82:05 - that
82:06 - objects
82:08 - get
82:10 - id is equal to data
82:13 - so i will directly make this
82:15 - an id
82:19 - so we got the id now product
82:25 - likes
82:27 - will equal to product
82:29 - likes
82:30 - plus one
82:32 - so we will increment it by one in the
82:35 - end we'll save it
82:40 - and we will print that
82:42 - product
82:46 - is
82:48 - product likes
82:50 - increased
82:56 - just to be sure let's
82:59 - rebuild the containers
83:04 - and we will rebuild this too
83:13 - so this is completed
83:15 - now
83:18 - we have the products here
83:22 - so
83:24 - we have two products and they have zero
83:27 - likes
83:29 - now for the product with an id2
83:33 - let's see if we have that product in the
83:35 - main
83:37 - so three i guess
83:40 - so for the product with id3 i'll post
83:43 - here to like it
83:46 - and this should increase the likes
83:49 - so i guess we have an error
83:53 - received in main
83:56 - so my bed
83:58 - when i made the producer
84:01 - i should change here the
84:03 - routing key should be admin
84:07 - so
84:08 - let's rebuild
84:13 - and this should
84:15 - receive the event
84:18 - now let's like again
84:21 - not here here
84:24 - so this should not receive the event it
84:27 - didn't
84:28 - this
84:29 - did receive the event
84:32 - actually we got an error here
84:34 - so
84:36 - requested setting installed ups but
84:38 - settings are not configured this error
84:41 - happens because this file is outside of
84:44 - django and we are using the product here
84:47 - and
84:48 - to use a product regularly we have to
84:52 - load
84:53 - so we have to set up jungle before
84:55 - getting the product
84:57 - so we have to import here
85:00 - os
85:01 - and
85:01 - django
85:03 - we have to set uh an environment
85:05 - variable django sent is sending settings
85:08 - module is equal to admin settings so
85:10 - this settings here
85:13 - and we have to add django
85:16 - setup here
85:19 - with this
85:20 - we won't have that error so let's
85:23 - rebuild the containers
85:25 - we can see now that we started consuming
85:27 - so
85:28 - let's
85:30 - try it again
85:32 - now success let's send it again and we
85:35 - see the likes are increased here so
85:38 - we received the event
85:42 - so now we are communicating back and
85:44 - forth with both apps
85:47 - so this was
85:49 - the app that i wanted to show
85:52 - now it's time to create the react
85:54 - frontend
85:55 - i'll create a react project with
85:59 - typescript so to create it write mpx
86:04 - create
86:05 - react app
86:08 - i will call it react
86:10 - crud
86:12 - and the template
86:14 - will be typescript
86:20 - let's wait till it's completed
86:36 - now the project is created we can go to
86:39 - the folder
86:42 - and run npm start
86:46 - now the project is running and if you
86:48 - open the browser we can see
86:50 - on localhost port 3000 we have our app
86:53 - running
86:55 - now let's open the project with our ide
86:58 - and this is the project that we just
87:00 - created all the files are in typescript
87:03 - so i will remove the
87:06 - app.test.tsx file
87:08 - we won't be using uh
87:10 - tests here in this tutorial and now
87:12 - let's add the template
87:15 - for
87:16 - this project so we don't use the default
87:18 - react template
87:20 - go to
87:21 - getbootstrap.com
87:24 - examples
87:25 - and
87:27 - i will go to the dashboard here
87:30 - and get this template so
87:32 - let's view the page source
87:34 - and i will copy the html from the body
87:38 - till
87:39 - the
87:40 - end
87:41 - so
87:43 - and i will paste it here
87:47 - so my id is smart so all
87:51 - class now are have been converted to
87:53 - class name
87:54 - if your id doesn't do that you make sure
87:57 - to do it yourself so i will remove all
88:01 - these tr's here because there are a lot
88:05 - and i will keep only one so
88:08 - i will keep only this
88:10 - we don't need the canvas
88:13 - we don't need the buttons
88:16 - so
88:17 - let's make some changes so
88:20 - we can remove this ul nh6
88:24 - so
88:26 - this can be removed also
88:28 - so we can keep the dashboard
88:32 - and let's remove this pan
88:35 - so
88:36 - let's make everything
88:38 - much simpler so we remove the
88:41 - ally here
88:44 - so
88:45 - we have an error here also which is the
88:48 - error
88:50 - so there is this input which we need to
88:53 - add a slash here
88:56 - and everything should be
89:00 - correct
89:01 - now let's remove this logo here
89:04 - and
89:06 - it will look ugly
89:09 - so if we see our app it looks very ugly
89:12 - because we need to add also the styles
89:14 - so
89:15 - here
89:16 - we have the dashboard.css
89:19 - which we have to copy it
89:21 - and add it to our app css
89:25 - paste it here
89:28 - and
89:29 - now it will
89:30 - look a little bit better but we also
89:32 - need to add bootstrap so go to
89:36 - bootstrapcdn.com and here we need to
89:39 - copy the html link
89:41 - and add it to our index.html
89:46 - now that we added this link
89:49 - it will look much better so this is a
89:52 - template
89:53 - we will be using
89:56 - so let's make further changes
89:59 - so i'll create two components now
90:02 - this is
90:03 - the
90:04 - navigation
90:06 - so
90:07 - i will create a folder
90:10 - components
90:12 - inside i will create a new component
90:16 - i'll create it
90:17 - now
90:18 - and will be typescript.jsx file
90:24 - inside i will create a stateless react
90:26 - component and i will use this shortcut
90:30 - in my ide
90:33 - so we need to import react from react
90:37 - we need to create our component
90:39 - as a constant
90:40 - and this is a function which we need to
90:43 - export in the end
90:45 - here is html so the html
90:48 - let's cut this part here
90:52 - and paste it in our nav so let's replace
90:56 - it
90:58 - now that we replace the html we can use
91:01 - the component directly here
91:03 - so let's call it
91:06 - nav
91:08 - my id auto imports components so
91:12 - you should import now from components
91:16 - nav here and use it directly
91:19 - if we see the browser nothing will
91:21 - change
91:23 - let's create another component now which
91:25 - is the menu which is this one
91:27 - so let's do the same
91:34 - menu
91:37 - create the component
91:39 - and let's
91:41 - cut html
91:51 - actually the name here will not be
91:53 - dashboard will be products
91:57 - and let's use the menu in our app.esx
92:09 - so that's it now everything looks
92:12 - much more simpler and our component
92:14 - looks much better
92:16 - now we need to create more components
92:18 - for our app
92:19 - so we will have two main apps so one is
92:23 - the admin
92:25 - and the second one is the main app
92:30 - so first we will focus with the admin
92:33 - which is
92:34 - what we have been doing till now
92:37 - and then we will create the main app
92:40 - so inside the admin app we need to
92:42 - create the products component so let's
92:45 - create another component
92:47 - products
92:50 - let's let it be a jsx typescript file
92:54 - and this component
92:57 - for html will have the html
93:01 - for this table basically so let's
93:04 - cut it
93:06 - and let's
93:07 - paste it here
93:12 - so note that react doesn't allow to have
93:15 - two
93:17 - html elements
93:19 - nearby each other
93:20 - they all need to be wrapped inside a
93:23 - bigger one so this makes
93:25 - sense
93:27 - either that or i will just remove the
93:30 - section title so
93:33 - i will keep it much more cleaner this
93:35 - way
93:37 - now
93:38 - let's add these
93:40 - products here so
93:42 - one way is to add directly the product
93:45 - here
93:46 - but
93:47 - we don't want to do this because we will
93:50 - create more components which
93:52 - they will change here
93:54 - nav and menu will stay the same but this
93:56 - will change so
93:58 - uh to fix this we have to install
94:00 - another package we see which is react
94:03 - router dom
94:05 - so open the terminal and write npm
94:08 - install
94:09 - react router dom
94:12 - and types
94:14 - react
94:15 - router
94:16 - dom
94:18 - we need this second package because the
94:22 - first one is javascript package and the
94:24 - second one is
94:26 - the typescript package so for all the
94:28 - typescript apps you need the to do it
94:32 - this way
94:36 - now
94:37 - reactor router dom is installed
94:40 - now we have to use it here so
94:43 - to
94:44 - map the products
94:46 - via the router we have to import two
94:48 - packages
94:50 - so the first one is browser router
94:54 - and the second one is
94:56 - route
94:57 - not router route so let's replace this
95:02 - products here
95:03 - and inside we will add browser router
95:08 - this is a container for all our routes
95:11 - and let's add our first route which is
95:16 - for the products so
95:19 - we have to specify a path
95:22 - the path for products will be
95:25 - admin
95:26 - slash products
95:30 - and the second parameter we need to add
95:32 - the component
95:34 - which in our case is the products
95:39 - so that's it so
95:42 - this is a path we can reference the
95:45 - products now
95:47 - so
95:49 - right now nothing is happening because
95:51 - we are at the main app
95:54 - so if we go to
95:55 - admin slash products
95:58 - we can see we can see the table now
96:01 - so
96:02 - this is working
96:05 - now let's add the main template so
96:09 - let's go again to get bootstrap.com
96:13 - to the examples and this will be the
96:16 - template for our
96:18 - main app
96:19 - so let's copy the code from the body
96:23 - so
96:24 - from here
96:26 - till here
96:27 - and
96:28 - we have to create a new
96:30 - component for main
96:34 - main here
96:37 - let's create a component
96:39 - and here we'll paste
96:42 - the html we just cut
96:45 - so let's remove
96:47 - most of the
96:49 - call md4 here because
96:52 - we don't
96:54 - need all of them
97:01 - so we keep only one
97:05 - we don't need neither the
97:08 - jump drone here
97:10 - and neither the header
97:12 - so we can remove the header
97:16 - and
97:18 - this is almost what it will look like
97:23 - so we will make changes later
97:26 - but for now
97:28 - i will remove also the svg here
97:31 - so for now
97:33 - let's create
97:35 - a
97:36 - route for this so
97:39 - the route for the main app will be route
97:46 - the path will be the main path
97:49 - so slash
97:50 - and the component
97:54 - will be the main component
97:58 - don't forget to import it
98:01 - so if we go to the main component
98:04 - now
98:05 - it will look
98:08 - so first
98:10 - this is what the product component looks
98:12 - like which is
98:14 - weird and also if we go to the main page
98:19 - we can see this is what the main
98:20 - component looks like but
98:23 - we don't want the navigation in the menu
98:25 - here
98:26 - so
98:27 - what is that we are making a mistake so
98:32 - first
98:33 - we need to
98:34 - remove the nav and menu from this route
98:38 - so the only way to do it is by creating
98:41 - a new
98:42 - wrapper
98:43 - component for the admin
98:45 - so let's
98:46 - do it
98:48 - let's create here
98:50 - a typescript file called wrapper
98:57 - so
98:59 - inside i will create a component
99:02 - and the html for that component will be
99:04 - this
99:05 - nav and the menu
99:07 - so
99:09 - i will cut this part
99:12 - go to the wrapper and paste it here
99:16 - so inside the div
99:19 - let's also cut
99:21 - what
99:21 - i left here
99:24 - and paste it
99:26 - so
99:28 - this is
99:29 - now the wrapper component
99:31 - so why do we need this component so we
99:34 - have to use it directly in our products
99:37 - so we can wrap this with the wrapper so
99:41 - wrapper
99:45 - and now
99:46 - in this component we will use the
99:50 - menu and nav
99:51 - so we are having an error here because
99:54 - we are not using it correctly
99:56 - inside here we have to
99:59 - use
100:00 - the child properties that we have so we
100:03 - have to add here props
100:07 - uh we are having an error also here
100:09 - because we are
100:11 - using typescript
100:13 - we have to specify a type which is
100:16 - props
100:17 - with children
100:20 - any
100:21 - so these are the props that we have and
100:24 - to pass the child properties we have to
100:26 - use props
100:28 - children
100:31 - this way
100:33 - we will
100:34 - pass
100:36 - the html inside here to the rubber
100:40 - and
100:41 - if we go to the
100:43 - this is the main
100:45 - app now which looks much better and if
100:48 - you if you go to the
100:50 - admin slash products
100:53 - still
100:54 - doesn't look good
100:56 - still we see this
100:57 - main
101:01 - card
101:03 - so
101:04 - what is the issue here the issue is
101:07 - this slash
101:09 - the problem with
101:10 - this slash is that
101:12 - they both have slash and react confuses
101:14 - them
101:15 - and to solve that we have to use exact
101:18 - here
101:20 - this means that
101:21 - the path
101:23 - is exact here and don't confuse it with
101:26 - the other
101:28 - paths
101:29 - with this
101:31 - products will look
101:33 - the same as before and
101:37 - the main app will look
101:39 - different
101:41 - so
101:42 - this is how
101:44 - we use route so let's remove nav and
101:46 - menu we don't need it here
101:48 - actually these components which are nav
101:51 - and menu we have to move it to our admin
101:54 - because they belong there
101:56 - don't forget also to
101:58 - change the imports here which my id does
102:03 - it automatically
102:05 - so now we got the admin
102:08 - the main app
102:09 - which we will use it later
102:11 - and now let's focus on our products
102:14 - component
102:17 - now let's fill the table for the
102:19 - products
102:21 - to fill the table first we have to get
102:25 - all the products and
102:27 - to do it we have to use
102:29 - use effect
102:33 - and
102:34 - inside
102:35 - accepts
102:36 - a function as a parameter
102:38 - and the second parameter
102:40 - will be an empty array
102:42 - this
102:43 - empty array means that this will be
102:46 - called only once
102:48 - if we put a variable that changes
102:51 - use effect will be called every time the
102:53 - variable changes
102:55 - we'll see this later on
102:58 - now inside here we need to call our
103:01 - backend to get our data
103:04 - so
103:05 - we cannot
103:06 - make this use effect asynchronous here
103:12 - it doesn't accept it so the way to do it
103:15 - is to create a function
103:19 - get products
103:21 - and this will be an asynchronous
103:23 - function
103:25 - and
103:27 - in the end we will call it so get
103:30 - products
103:32 - this is a way to call asynchronous
103:34 - functions in
103:36 - react but there is an even easier way
103:40 - so we can remove
103:42 - get products totally
103:45 - so let's open a parenthesis here and
103:48 - close the parenthesis
103:51 - when we call it so
103:54 - this is my preferred way of calling
103:57 - asynchronous functions in react so open
104:00 - parenthesis close parenthesis and then
104:02 - you call it directly
104:05 - here inside now let's call our backend
104:08 - let's get a response
104:11 - is equal to await
104:13 - fetch
104:14 - the endpoint would be http
104:17 - localhost port 8000
104:20 - slash
104:22 - api slash products
104:28 - once we get the response we have to get
104:29 - the data which is equal to a weight
104:33 - response
104:34 - json
104:37 - so we got all the data so first let's
104:39 - console.log it
104:45 - and
104:46 - inspect here
104:48 - we will see that we get the products
104:50 - here and the console log works
104:53 - so we got all the products
104:56 - now we have to get them and loop them to
104:58 - do it we have to use another react hook
105:01 - command which is use state so
105:05 - use state
105:08 - accepts a default first parameter so
105:11 - a default value which is an empty
105:14 - uh array for the products and the
105:18 - returns
105:20 - products
105:21 - as a variable and set products
105:25 - as a function so these
105:27 - work together with each other once we
105:30 - set the products these products get set
105:33 - so
105:34 - set products will be used here
105:39 - data
105:41 - now we set the products it means this
105:44 - variable has changed so
105:47 - we have to use that variable here
105:51 - let's
105:52 - use it
105:54 - so we have to
105:55 - map it so
105:57 - products
105:58 - map
106:01 - it will return a product
106:04 - that returns
106:06 - this
106:09 - html
106:11 - so the we need to add a key here so for
106:14 - every
106:17 - loop that we have we have to have a key
106:20 - now we are having a type error here
106:22 - because we have to cast the product here
106:26 - so we have to create a folder here
106:28 - interfaces
106:31 - and inside will create a product
106:33 - interface
106:34 - so
106:36 - product
106:39 - not products but product
106:44 - here we'll export an interface
106:47 - product
106:49 - and this interface will have an id
106:51 - as a number
106:53 - a title as a string
106:56 - an image
106:58 - as a string
107:00 - and
107:02 - it will have
107:04 - likes
107:05 - as a number
107:08 - so this is a product that we have
107:11 - let's go back
107:13 - and now we have to cast this product as
107:18 - product
107:19 - don't forget also to import it here
107:23 - so we have the key now
107:27 - now let's call
107:29 - every other variable so this is id
107:33 - i also forgot here to put the headers so
107:36 - the first one is the image
107:40 - this is a title
107:43 - this is a likes
107:46 - and this is the action
107:50 - so
107:50 - the second one
107:52 - is the image so we have to put an image
107:55 - here
107:57 - with the source
107:58 - to be
107:59 - product that
108:00 - image
108:02 - and the height will be
108:05 - 180.
108:08 - this is a
108:09 - product
108:10 - title
108:11 - and this is a product
108:18 - likes
108:20 - for the moment i will
108:23 - keep actions to an empty
108:26 - td
108:27 - now let's see it on the browser
108:30 - so we retrieved products with images
108:33 - so for some reason the image doesn't
108:36 - show so
108:38 - this
108:39 - site lorem pixel doesn't work uh
108:42 - currently for me but if it works
108:45 - it will show images here
108:48 - so this is how we retrieve products and
108:51 - we loop them
108:53 - to show them as a table
108:56 - now let's delete a product
108:59 - in the actions here
109:01 - we need to add some more html
109:04 - so i will add this html which is just a
109:07 - button delete
109:10 - so we want to delete a product
109:12 - so first let's create a delete function
109:17 - i will call it d
109:20 - deal not delete because it's a keyword
109:23 - so
109:24 - this function
109:27 - will accept an id as a number
109:32 - and we have to call it here
109:34 - so to do it we have to add the non-click
109:38 - listener
109:40 - and we have to
109:42 - call
109:44 - the delete function
109:46 - with the product id
109:50 - so this is how
109:52 - we call
109:54 - the delete function for a different
109:56 - product
109:59 - now that we have the delete product we
110:02 - have to make it asynchronous
110:05 - and we have to call our backend to
110:07 - remove the product
110:09 - so to do it we have to
110:13 - make
110:15 - a weight method
110:17 - fetch so i will copy
110:19 - this part here
110:24 - so in this case now we need to pass
110:27 - the id
110:28 - so
110:29 - i will
110:30 - convert the quotes here to this kind of
110:33 - quotes i don't know the name of these
110:35 - quotes
110:36 - but
110:37 - with these quotes
110:39 - you can add
110:40 - variables to the string which is the id
110:43 - in this case
110:46 - this is not a get request
110:49 - this is a get request but we want to
110:51 - make a delete request here so we have to
110:54 - pass some parameters
110:56 - so
110:59 - the method
111:00 - will be
111:01 - delete
111:05 - so with this function call we will
111:08 - delete a product
111:10 - in the back end but we
111:12 - need also to remove it from the front
111:14 - end
111:15 - so we have to call set products again
111:19 - so set products
111:22 - and we have to get all the products
111:24 - except the product that have this id
111:28 - so
111:28 - we have to get all the products
111:34 - and we have to filter them
111:37 - and the filter will have the product
111:41 - as a product id
111:43 - so product is a product here
111:46 - and we will filter all the products that
111:51 - have the id
111:52 - different than this id
111:56 - we can keep it
111:58 - one liner here
112:02 - so this means that we are getting all
112:04 - the products except this product id and
112:07 - we are setting it so
112:09 - the
112:10 - table refreshes itself
112:14 - one last change that we need here is to
112:16 - add a confirmation
112:18 - since we don't want to delete the
112:20 - products directly
112:22 - so we add a new condition here
112:25 - window dot confirm
112:28 - are you sure you want to delete
112:33 - this product
112:38 - and
112:39 - we close
112:41 - all what we did
112:44 - inside this if statement
112:47 - so once we click delete
112:50 - the browser will ask this question if we
112:52 - type yes then the product will will be
112:55 - deleted
112:56 - let's see it on the browser
112:58 - so i will delete product number four
113:01 - when i click i will get a question are
113:04 - you sure you want to delete this product
113:06 - i type ok
113:08 - then
113:09 - we can see product with id4 is removed
113:12 - if i refresh
113:14 - it's also removed in the backend
113:17 - so this is how we delete products
113:22 - now let's create some products first
113:25 - let's create a new rear component
113:28 - products
113:30 - create
113:33 - and this will be a normal react
113:35 - component
113:37 - and
113:38 - now that we created it we have to add it
113:41 - to our router so
113:44 - the route for this
113:47 - component will be admin products slash
113:50 - create
113:53 - and this will be products
113:56 - create
113:58 - let's make every component exact
114:03 - so we don't have any problems
114:07 - this also
114:11 - now let's go to our products
114:13 - we will add here
114:15 - this
114:16 - html
114:18 - it's just a link
114:19 - and we will have to change this anchor
114:22 - link to a
114:24 - link
114:25 - from react router dom so i automatically
114:28 - imported it but
114:30 - you have to do it on your own so import
114:32 - link from react router dom
114:35 - and this link will redirect to
114:43 - admin
114:48 - products create
114:51 - let's add a slash in front
114:55 - and we don't need this curly braces so
114:59 - this is the link that we want
115:02 - so if we see the browser we can see an
115:04 - add button here that when we click
115:07 - we go to the products create page
115:10 - which is empty right now so
115:12 - in the products create let's convert
115:15 - this div to just wrapper
115:17 - and
115:18 - now it looks better
115:20 - inside here i will create this simple
115:23 - form
115:25 - that
115:25 - accepts only a title and an image
115:29 - and a button to save it so it will look
115:31 - like this
115:33 - now let's make this form work
115:36 - first
115:37 - we have to create variables from the
115:40 - state for the title and the image so
115:43 - we'll create
115:45 - the title
115:46 - set title
115:48 - from
115:50 - use state
115:53 - and the default
115:54 - value will be empty
115:57 - let's do the same for the image so this
116:01 - is image and this is
116:04 - set image
116:07 - now that we got
116:10 - the variables we can set it directly
116:13 - here so when we change this input we
116:17 - have to set the title
116:19 - so we had an unchanged listener here
116:24 - and the event will call set
116:28 - title
116:30 - and the value will be event that target
116:33 - that value
116:36 - this means every time this input changes
116:38 - so when we type here
116:40 - we'll set the title
116:43 - so let's do it the same for
116:45 - the image so on change
116:48 - event we'll call set
116:51 - image event.target.value
116:57 - now in this title an image we got the
117:00 - values that the user set
117:02 - so we are ready to use them in when the
117:05 - form is submitted so
117:08 - let's add an onsubmit
117:12 - call here
117:13 - let's create also the function
117:15 - submit
117:19 - and
117:20 - for the moment just console.log
117:23 - the title and the image
117:28 - and on the submit here we will call the
117:31 - submit function
117:36 - so
117:37 - let's test it on the browser let's
117:39 - inspect
117:42 - and
117:42 - let's put a title here and an image
117:47 - save
117:49 - i saw console log but immediately the
117:52 - page
117:52 - refreshed
117:54 - so
117:55 - that is a problem so we have to
117:57 - prevent that
117:59 - and to do it we have to call here to to
118:02 - add an event parameter here and to call
118:06 - event.
118:10 - prevent
118:12 - default
118:13 - typescript wants us to type the event
118:16 - here so synthetic
118:22 - event
118:25 - let me type it
118:27 - synthetic
118:29 - event
118:32 - so
118:34 - that
118:35 - will prevent the page refresh so if we
118:38 - try it again
118:42 - we can see that we consult log
118:45 - test and test
118:47 - now we are ready to call backend to
118:50 - create our
118:51 - product
118:53 - so let's make this function asynchronous
118:57 - and
118:58 - here
118:59 - we'll call weight
119:03 - fetch
119:05 - http localhost port 8000
119:09 - slash api slash products
119:13 - and we have to add some
119:16 - options
119:18 - the first one is a method which is a
119:21 - post method
119:24 - the second one is the headers so this is
119:28 - a
119:29 - http request so we want to work with
119:33 - json
119:34 - so we have to add
119:35 - content
119:37 - type
119:40 - application
119:42 - slash json
119:46 - and
119:47 - we need also to send the data which are
119:49 - these two variables that we have here
119:52 - so we have to send them in the body
119:56 - and we have to stringify them so json
120:00 - stringify because
120:02 - it accepts a string
120:04 - we want to send
120:06 - an object so
120:08 - we need to add the title here
120:11 - and the image
120:14 - note that this title here is the same as
120:16 - title title here
120:19 - but
120:20 - to keep it short and simple
120:22 - we can use it like this
120:25 - now we can create products with this
120:27 - request
120:28 - we need
120:29 - one more change because we want to
120:32 - redirect to the products once
120:35 - we submit the form
120:37 - so let's create another state here
120:42 - i will call it redirect
120:45 - and set redirect
120:49 - use state
120:51 - and the default value will be false
120:55 - here i will add the condition if
120:57 - redirect
120:59 - we want to return
121:01 - redirect
121:05 - so let's import it so importer direct
121:08 - from react router dom
121:11 - we want to redirect to
121:14 - admin slash
121:16 - products
121:19 - and once we create a product we want to
121:23 - set redirect to true
121:26 - so this means
121:28 - if this is successful we redirect to the
121:32 - main table
121:34 - let's try it out
121:36 - let's create a product
121:39 - title
121:40 - image
121:41 - save so if we
121:43 - redirect it means it works
121:46 - so we can see it did work so let's
121:50 - create another one with a
121:52 - correct image
121:54 - and let's put a title here
121:57 - bird
122:01 - so we can see
122:03 - this is working correctly and the
122:05 - redirect works correctly
122:09 - now we want to edit products
122:12 - to edit products is almost the same as
122:14 - creating products so i will copy the
122:18 - products create component
122:20 - and
122:21 - paste it and change the name to products
122:24 - edit
122:27 - let's rename also this variable products
122:31 - edit
122:33 - and
122:34 - rename this also products edit
122:38 - so
122:40 - now that we created products edit let's
122:42 - add it also to our routes
122:45 - let's duplicate this
122:47 - and the route now is different
122:50 - so we need to go to admin slash product
122:53 - slash
122:54 - id slash
122:56 - edit
122:58 - we need the id of the product that we
123:00 - want to edit
123:01 - and the component is products
123:06 - edit
123:09 - now we need to get the product from this
123:13 - id that we are fetching
123:15 - but first let's go to our products
123:19 - and here we need to add another link
123:22 - let's copy the link for the delete and
123:25 - name it edit
123:27 - we don't need a non-click listener here
123:29 - but
123:30 - we have to rename this to a link
123:34 - and we have to redirect to
123:38 - the path that we want to redirect is
123:42 - admin slash products
123:44 - slash
123:46 - the id so product dot id here slash edit
123:53 - and don't forget to end it with the link
123:55 - here
123:58 - so this button will appear on the table
124:00 - now
124:01 - so along with
124:04 - the delete button now we have an edit
124:06 - button
124:07 - let's click the edit button
124:09 - and right now nothing happens
124:12 - so i made a mistake a spelling mistake
124:15 - here so it's products here
124:22 - let's go back
124:23 - and type edit again let's refresh just
124:26 - in case so
124:27 - this is the product edit form
124:30 - now we have product with id number two
124:33 - we have to set the titles and the image
124:35 - for the product with id number two
124:39 - so
124:39 - to do it let's go to products edit now
124:43 - we have to call use effect
124:47 - and
124:49 - inside here we need to call our backend
124:52 - for
124:53 - that product
124:54 - so like we did before
124:57 - i will open two braces here and make a
125:00 - sync function
125:05 - so this is my way of
125:07 - calling uh
125:09 - an sync function inside use effect
125:13 - inside here we need to call the backend
125:16 - so
125:17 - response is equal to weight fetch
125:22 - let me copy this
125:25 - part here
125:26 - so i will use this braces
125:29 - now we need the id of the product so we
125:31 - have to get a product with the id that
125:33 - we got from the url
125:36 - to get it
125:37 - we have to add the props here
125:41 - and this time is props
125:43 - with reference
125:47 - and
125:48 - based on the props now
125:50 - the id is
125:53 - props
125:55 - match
125:57 - params
125:58 - dot id
126:02 - the id here corresponds to
126:05 - this id here so the the actual name
126:10 - and to get the query params we have to
126:12 - use
126:13 - props match params
126:16 - now
126:18 - we get the response let's get also the
126:22 - product
126:24 - which is equal to a weight
126:26 - response.json
126:30 - once we got the product we have to set
126:32 - the title and the image based on this
126:35 - product so set
126:36 - title
126:38 - to product
126:40 - dot title
126:43 - set image
126:45 - product
126:46 - dot
126:47 - image
126:50 - we can cast this product as a product
126:53 - here
126:54 - since
126:55 - it is a product
126:58 - so
127:00 - let's see how this looks on the browser
127:02 - now
127:03 - and this is not working because we
127:05 - forgot to add something else
127:08 - we set the values but
127:10 - this doesn't mean that the inputs will
127:12 - reflect that value
127:14 - so we have to add here
127:16 - a default value
127:18 - for the title
127:21 - same for the
127:23 - other input so default value will be
127:26 - image here
127:29 - now once this change
127:31 - the input will change also now we can
127:34 - see
127:35 - the data are pre-filled based on the
127:37 - product so if i change this from number
127:40 - two to number one
127:43 - we can see we have different values
127:47 - the last change we need is
127:49 - to change this fetch now
127:53 - this now is a different url
127:56 - we'll call api product slash
128:01 - props
128:02 - match
128:04 - params that id
128:07 - and the method is put
128:12 - all of the other things are the same
128:16 - now let's test it on the browser
128:19 - so i will change the image to
128:22 - this image and i will say
128:26 - updated
128:28 - title
128:29 - for the product with id 1
128:32 - let's save it
128:33 - now i'm redirected and we can see a new
128:36 - image and an updated title
128:39 - so
128:40 - this is how
128:41 - we update products
128:45 - now let's
128:46 - complete the main app
128:49 - so this should be a list of products so
128:53 - let's
128:54 - create
128:56 - products from the state so products
129:00 - set products
129:04 - equals to use state
129:06 - and
129:07 - the products will be an empty array in
129:09 - the beginning
129:11 - now we have to get all the products so
129:14 - we have to use use effect
129:18 - an empty array a
129:20 - function sorry and this will be an empty
129:22 - array
129:24 - inside here
129:25 - we'll call
129:27 - our backend
129:28 - so this will be an async function
129:32 - will get response
129:35 - from
129:36 - fetch
129:38 - http localhost
129:40 - port 8001 now
129:44 - so before it was 8 000 now it's 8001
129:48 - api slash
129:50 - products
129:55 - once we get the response we have to get
129:58 - the data which is equal to weight
130:02 - response
130:03 - dot json
130:08 - i forgot a weight here
130:13 - and in the end we have to set the
130:15 - products
130:16 - to this data that we got
130:20 - now we set the products we have to loop
130:22 - them here
130:24 - so
130:25 - this is the html that we want to loop so
130:30 - products
130:32 - map
130:35 - we have to get every product
130:39 - and return
130:40 - this html
130:43 - so this needs a key
130:47 - product.id
130:50 - this needs the product to be cast to
130:53 - product
130:58 - so let's make the other changes now
131:00 - first we need an image here
131:04 - so
131:04 - let's write an image stack
131:08 - with the source
131:10 - to be product
131:12 - that image
131:15 - height will be
131:17 - 180.
131:20 - this is
131:21 - the product
131:23 - title here
131:30 - here we need to only one button
131:33 - which is like
131:37 - and
131:38 - this is a number of likes so it's not
131:41 - minutes
131:42 - this should be
131:45 - likes
131:50 - likes so that's it let's see how it
131:53 - looks like
131:54 - let's go to the main app
131:57 - and this is what it looks like so we
132:00 - have only two images that work because
132:02 - the other that don't work
132:04 - but this is the main idea
132:06 - now let's make this like function work
132:10 - so
132:12 - let's add a new click here
132:19 - on click
132:21 - and this will call the function
132:24 - like
132:25 - so this will be like this
132:28 - like
132:29 - with the product id
132:32 - let's make the like function
132:38 - this will have an id
132:41 - as a number
132:44 - so this works fine now let's complete
132:47 - the like function let's make this
132:49 - asynchronous here
132:51 - and this will call our backend
132:55 - here we need to wait
132:58 - fetch
133:01 - the
133:02 - url is almost the same here
133:06 - let's change it to these brackets and
133:10 - the endpoint is api slash product slash
133:13 - the id that we
133:15 - got as a parameter slash like
133:19 - and this will be a post request
133:26 - we need also to send some data but in
133:29 - this case we don't need any data so we
133:32 - need only to send the headers
133:35 - which is content
133:39 - type
133:41 - application
133:44 - slash json
133:48 - usually the post requests have some data
133:50 - but in this case we don't have any
133:55 - now that we like a product we also need
133:57 - to update
133:59 - this html so we need to set the products
134:02 - again
134:03 - so to set the products
134:06 - we need to loop and change all
134:10 - the current products so
134:12 - set products products
134:15 - map
134:17 - and for every product
134:22 - we have to make a condition now
134:25 - if
134:26 - this product
134:28 - that id
134:29 - is equal to this id
134:32 - that we got as a parameter here
134:35 - then
134:36 - product that legs
134:39 - will increase
134:41 - in the end return the product
134:43 - so this means
134:45 - that only this product with this id
134:48 - will increase the likes
134:51 - now we are having an error
134:54 - like
134:55 - argument of type product is not
134:57 - assignable of parameter of type
135:00 - set state action never
135:03 - this means that
135:04 - when we initialize the products here
135:06 - this is never
135:10 - this
135:11 - typescript interprets this is never like
135:14 - this
135:15 - so to fix this problem we have to
135:17 - manually cast
135:19 - this empty array as product array
135:24 - so this is an empty array but as a
135:26 - product array
135:28 - and immediately we see that we don't
135:30 - have an error anymore
135:33 - so this is how we fix typescript errors
135:36 - by casting
135:38 - the products directly
135:40 - let's open the browser now
135:42 - and
135:43 - if we like a product
135:46 - we can see
135:47 - the number of likes increases and that's
135:50 - it is very is very simple
135:52 - so this was our app that we wanted to
135:55 - build
135:56 - and
135:58 - i hope you like it
136:00 - don't forget to subscribe to the channel
136:02 - for more content thank you