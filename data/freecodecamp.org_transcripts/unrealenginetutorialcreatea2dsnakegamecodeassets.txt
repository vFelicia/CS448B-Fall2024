00:00 - What is up by here from my senses calm and 
welcome to another Unreal Engine mini course  
00:06 - here on YouTube. I mean, where else could it 
be? You're on YouTube, this is YouTube. Anyways,  
00:10 - before we begin, you always know that I first 
show you the game that you're going to create.  
00:14 - But before we do that, help the algorithm promote 
my channel so that we can grow together, hit that  
00:20 - like button, make sure that you comment, share the 
video so that others can see and subscribe that  
00:25 - way you're helping me This is the only thing I'm 
asking you. Okay, so now let's get inside and see  
00:31 - the game that we're going to create the if I hit 
the play button, we have the nice snake over here,  
00:35 - it's the snake's head. Now one thing that we see 
over here is that the controls of the snake are  
00:41 - pretty hard. As you can see, I still cannot 
get the first food. And the reason for that  
00:46 - is because we have one variable inside of our game 
that is going to allow us to control the snake,  
00:52 - you see that I just die. If I press the restart 
button, we restart and that variable is a delay  
00:58 - number. And the smaller that number is, the 
faster the snake will be. And it will be  
01:04 - easier for us to control it. As you can see, 
the more we eat, the larger the snake gets,  
01:09 - and the faster the snake will get. And that means 
we will be able to control it much faster. As you  
01:15 - can see, the larger the snake gets. I have 
more control over it because well we need to  
01:22 - have more control over the snake when this knee 
gets larger. If you're wondering, what's that  
01:26 - circle circle in the middle, that dot i have no 
idea. It's probably some kind of glitch. It's  
01:31 - not part of our game. But it doesn't bother us 
anyways, as you can see, now the snake is much  
01:36 - faster and I can control it much better. But 
I still died. We can go back here in the game.  
01:40 - And we can set this delay from point two to 
point one. So the smaller the delay number is,  
01:45 - the faster the snake will be pay attention. 
Now the snake is crazy fast as you can see,  
01:50 - look at the speed of that snake. Look at the crazy 
speed of that snake pay attention. We also have  
01:55 - the score at the top. And yeah, I can control the 
snake now very, very well. Very Val Val. Well that  
02:04 - is. So yeah, we have 1000 for the score. I am 
pretty good at this game. I'm the best nobody  
02:10 - can beat me and yada yada yada. You saw someone 
we die the snake please. Short that animation,  
02:17 - like everything disappears, goes transparent, 
so on and so forth. I'm going to die over here.  
02:22 - And you saw that what I just mentioned. Anyways, 
this is the game that we are going to create. And  
02:31 - we are going to learn a lot inside of this game. 
Even though it looks small, it looks a small game,  
02:36 - we're going to still learn a lot, a lot of 
cool techniques, a lot of things that we're  
02:40 - going to implement, especially in 2d because 
Unreal Engine is mostly for 3d and people  
02:46 - don't know and they're not basically no to 
the tutorials for Unreal Engine out there.  
02:50 - Except for some official ones anyways, I don't 
want to bla bla bla bla bla bla bla, just make  
02:54 - sure that you comment, like the video, share it 
and subscribe to the channel and enjoy the course  
02:59 - what else can I say, see in the next video, or in 
the next part of this video. Take care. So let's  
03:05 - get started. And as always, you know that we first 
create or open the Unreal Engine Project Browser,  
03:10 - click here on games and click on Next. Over here 
we can have a blank project that is not a problem,  
03:16 - click on Next again, blueprint, we can leave that 
because you're going to use primarily bla bla  
03:21 - blueprints in this project, no Starter Content 
over here, you are going to select where you are  
03:26 - going to store your project and over here you are 
going to name it. So here I'm going to say well,  
03:31 - we cannot begin it with a 2d. So we can say snake 
2d. And then I'm going to click on Create Project.  
03:38 - And of course, as always, we need to wait until 
Unreal Engine takes mercy upon us and you know,  
03:44 - opens the project and so on and so forth. So what 
I'm going to do is I am going to cut out the video  
03:49 - right now. And I'm going to come back when the 
project opens project. Yeah, so see in a few.  
03:57 - And here we are, I was surprised it opened pretty 
quickly. Anyways, that is not important. What's  
04:01 - important is that we click over here where it says 
show or hide the source panel. And then over here  
04:06 - we have the content. Of course everything is 
empty, we don't have anything. But we do have  
04:12 - these assets that you can download by clicking the 
link below this video. So simply download assets  
04:17 - and you also have a complete project there as 
well. So this is what you need to copy but before  
04:23 - that over here in the content, you're going to 
right click and click here show in Explorer.  
04:29 - And over here it is going to open in the Explorer 
which is well a folder and it is going to open  
04:34 - where your content is for this project. Let 
me just go back over here for the assets now  
04:39 - copy everything you see over here. So copy this 
so simply you're going to right click and copy  
04:45 - and go back over here and paste it when you paste 
it you will see it in your project and there you  
04:52 - go. So we have over here the sprites that we are 
going to use. We also have here are flipbooks  
04:57 - don't worry about that you can just click them 
now and Open them over here. We will see later  
05:01 - on what they are, how to use them, so on and so 
forth. But what's important is that everything is  
05:07 - working and we have everything set up. Now what we 
are going to do first things first, I'm going to  
05:14 - right click here and create a new folder, and I'm 
going to call it maps. And I'm going to Ctrl S to  
05:19 - save this current map. And in the maps over here, 
we're simply going to add a no name ID gameplay,  
05:25 - because you're only going to have one map, 
everything is going to happen over there.  
05:28 - So you can save it as a gameplay map over here. 
Now before we do anything with it, so we are not  
05:34 - going to touch anything right now later on, we 
will do, the first thing that I'm going to do  
05:39 - is go over here and again, right click and create 
a new folder. And I'm going to call this bad boy  
05:44 - blue prints. Inside of the blueprints for folder, 
we are going to right click, and we are going  
05:51 - to create a user interface. And it's going to 
be a Widget Blueprint. And I know this is not  
05:56 - what we usually do. But you know, we are going 
to do it this time. So BP underscore u i HUD,  
06:03 - this is how you can call it you can call hire 
however you want to call it you can call it Carl  
06:07 - Kenny, you know, I don't know, whatever. But I'm 
going to call it BP UI HUD. What's going to happen  
06:14 - here inside of our BB UI HUD. First things first 
in our canvas panel over here, I'm going to go on  
06:21 - the palette here at the top, and we are going to 
search for a horizontal box. And I'm going to add  
06:29 - the Horizontal Box over here inside of our panel. 
And here you go. This is our Horizontal Box.  
06:35 - What I'm also going to do with the Horizontal 
Box is that I'm going to call it score box.  
06:42 - Next, I'm going to click on it and I am going 
to click here on the anchors and set the anchor  
06:47 - at the top center. So over here, and we are going 
to reposition it as well. So what we are going to  
06:55 - do for the position x is going to be negative 150. 
Position y is going to be 32. The size x is going  
07:04 - to be 400. And the size of y is going to be 64. 
There you go. So position x minus 150. Position y  
07:14 - 32 size x 400. Size y 64. As the title suggests 
that this is a score panel. So what we are going  
07:23 - to do with the score panel is that we are going 
to add a text to it. So over here in the palette  
07:29 - in the search, we are going to filter for text 
and we don't want the rich text block but the  
07:33 - usual normal text block and put it over here. Now 
this text block I am going to call it score title.  
07:41 - And what we are going to do with this one is that 
over here, padding, we are not going to touch that  
07:46 - alto everything can be as is over here over here 
for the text block, we are not going to leave it  
07:52 - like that. Instead, we're going to say score, 
column and space. Also over here for the font,  
07:59 - we are going to set it at 44 so that it is a 
little bit larger, as you can see over here.  
08:05 - And also for the color, I'm going to click in 
over here where it says hex linear paste 741 c 00  
08:16 - ff and when you click OK, it's going to well 
be this color. Now of course you can pause  
08:22 - the video and see this number over here. So 741 c 
00 ff, but it's not important, you don't have to  
08:31 - do it the same way I did. It's not mandatory, 
you know, because I know that a lot of people  
08:36 - follow this. And they think like they need to have 
everything as I do. It's not mandatory for you to  
08:42 - do that. But if you want you can pause the video 
and again I you know dictated two times the hex  
08:48 - color for it. Anyways moving forward. Next we are 
going to again, take a text and put it over here.  
08:56 - And this text over here is going to be our score 
value. For the score value. We are going to set  
09:04 - the font size to 44. Same as what we did for the 
score. Over here where it says text block or the  
09:10 - text that's inside we're simply going to say zero. 
And again for the hex linear color paste 741 c 00  
09:19 - ff and click OK. So now this is what we have, as 
you can see here, score there you go at the top,  
09:26 - there you go. So we can compile and save 
this. Now of course we are still not done.  
09:34 - Over here in the palette. What we can do or what 
we need to do, we are going to filter for a canvas  
09:39 - panel, click on it and drag it over here not as 
a child of the score box, but as a child of the  
09:47 - canvas panel because this canvas panel over here 
is going to be our game over panel and that panel.  
09:56 - So the game over panel, what we are going 
to do with it is we're going to click on it,  
10:01 - and over here, it says anchors, I'm going 
to click on the drop down list over here.  
10:06 - For the x, I'm going to leave it at zero for the Y 
minimum is going to be point five. For the maximum  
10:14 - of x, I'm going to say one, and a maximum of the 
Y minimum is going to be point five. And you can  
10:20 - see now where the anchor is, is basically 
here in the middle, and it's stretched.  
10:26 - So this is our anchor, again, for the minimum 
for the x over here, point, or actually for  
10:31 - x is zero. for y, it's point five, for the 
maximum of the X is one, and maximum for the Y  
10:38 - is point five. Now over here, where it says offset 
left, we are going to say 512. For the position y,  
10:48 - we're going to say 550. So 550, for the offset, 
right, we are going to save 404 the size, why  
10:58 - we are going to set that at 598. There you go. So 
this is going to be our canvas. And purposefully,  
11:07 - it is here at the bottom, because later on, we're 
going to animate it and move it up. But before we  
11:14 - do that, what we are going to do is the following, 
we are going to, again, go here in the canvas, or  
11:21 - actually in the palette and search for a text and 
apply or drag and drop that text under the game  
11:28 - over panel. Now this text is going to be our game 
over text and we are going to hit enter Of course,  
11:34 - you can Compile and Save this so that we can save 
all of these changes. Next, what we are going  
11:41 - to do for our game over text is that I am going 
to select it. And for the anchors, I'm going to  
11:50 - leave it at the top left corner. So we're not 
going to touch anything here for the minimum,  
11:54 - the maximum, we are not going to touch anything, 
the size x is going to be at 100. And the size y  
12:01 - is going to be at 30. But over here in the 
font, we are going to leave it at Roboto bold,  
12:07 - the size for the font is going to be 90. And where 
it says text block, we are simply going to say  
12:14 - game over like this. And over 
here for the color and capacity.  
12:21 - For the hex linear, I'm going to paste FF and then 
we have 1234 zeros. So ff 0000. And again, FF at  
12:33 - the end, which is going to be our red color. What 
you can do as well over here for our game over  
12:40 - for the text, I'm going to select it and over here 
we can, you know, like add a few spaces over here  
12:45 - or a tab, and it looks like this. And you can add 
it all caps. So you can have it all caps as well.  
12:52 - So again, this is not mandatory, you will not like 
ruin the game, if you don't put the red color. And  
13:02 - instead you put the blue color or whatever. So I'm 
just saying that putting that out there anyways,  
13:07 - Compile and Save. Last but not least save the 
text again. And over here in the game over panel,  
13:14 - add that text and this one is going to be a 
re start text for the restart text over here  
13:22 - inside of the anchors, we are going to set the 
minimum for the y to be one maximum for x going to  
13:28 - be zero and maximum for the Y is going to be one 
again over here minimum for the x is zero, minimum  
13:35 - for the Y is one maximum for the X is one and 
a maximum for the Y it is one over here for the  
13:44 - offset on the left side, we're going to leave it 
at zero position y is going to be negative at the  
13:51 - offset the right is going to be zero and the size 
y is going to be 64. I am also going to set over  
13:59 - here I'm going to leave it the font at Roboto bold 
but the font size is going to be at 50. And over  
14:07 - here for our hex linear color, I'm going to paste 
ff c 600 f f. So again, it's f f c 600 f f and I'm  
14:23 - going to hit OK. Where it says the text block 
we are simply going to say press and over here  
14:29 - in quotes are actually in single quotes are with 
capital. And again single quote and to start a new  
14:40 - game. There you go. simply going to this 
play this over here. As you can see press R  
14:46 - to start a new game and Compile and Save that 
as you can see, this is with single quotes so  
14:51 - you don't have to do it. I mean you can again 
but it's not mandatory, it will not destroy  
14:56 - our game and it will not make it you know like 
better or what ever Moving forward, let us now  
15:01 - animate our game over panel. And in order to do 
that, we need to select it and over here we are  
15:06 - going to click on the animation. And I clicked 
over here on the green button in case you didn't  
15:12 - notice over here in that animation step, and now 
I'm going to select animation and first rename it.  
15:16 - So this is going to be game over animation. And 
now we need to select this game over animation.  
15:24 - And over here in the timeline where it says 
track, we're going to click on over here,  
15:29 - and we want the game over panel Canvas panel slot, 
this is what we need. And when you click on that,  
15:36 - there you go. So we have the canvas panels, 
slot one. Now when we click on this bad boy,  
15:42 - now over here, when you hover over on the plus 
button, which is the dark plus button at the right  
15:49 - side, you're going to click on this track. And 
from here, we're going to select the layout data  
15:55 - offsets, and there you go. When you click on the 
plus button over here, we have the left, top right  
16:00 - bottom, so on and so forth. And automatically, 
as you can see over here, we have the keyframes  
16:06 - for all all four of these. Now this over here 
is the timeline or however you want to call it  
16:12 - a basically, that's, you know, like the the track 
that you can move and this is the track over here,  
16:17 - what I'm going to do is I'm going to move with you 
over here on one, which is one second. And for the  
16:23 - top over here, we are going to click on the plus 
button to add a track over here. And for the top,  
16:31 - we are going to move it from 550. So 550, 
we are going to move it over to negative  
16:39 - 64. So over here, we are going to add and let me 
just type in minus 64, which is as you can see,  
16:47 - it is going to move the panel at the top now again 
over here only for the top, we're not going to  
16:53 - touch the left, the right the bottom, the so on 
and so forth. So we are not going to touch any  
16:58 - of these Now make sure that you Compile and Save 
this bad boy. So again, it is only for our top,  
17:06 - and it goes by clicking here on the animation 
to create the animation, I'm going to remove it  
17:10 - when you create the animation. So click on the 
plus button. When you create that animation over  
17:14 - here for the track, you are going to select 
First things first, like this one over here.  
17:20 - And now select the game over panel Canvas panel 
slot when you select that, and from there,  
17:27 - you're going to click on the plus button over 
here. And you're going to select the layout  
17:31 - data or offsets. And of course for the top we are 
going to move it so there you go. So now we have  
17:38 - the animation as you can see over here. So there 
you go. This is animation, Compile and Save that.  
17:44 - Now before we proceed, we are also going to do a 
little bit blueprinting, which is what I call the  
17:50 - blueprint programming. So over here, select the 
restart text. And over here, when you select it  
17:57 - over here, in the details tab you have this is 
variable. So we are going to click on that. So  
18:02 - click on each variable. And over here for the game 
over do the same thing, click on each variable.  
18:09 - And for the score value as well click on his 
variable, let me just Compile and Save that,  
18:14 - when you do this, you are enabling these variables 
are these elements, the text elements, the UI  
18:21 - elements to actually be variables. So now we can 
go here in the graph at the top right corner,  
18:29 - as you can see, so over here, when we click on the 
graph, we're going to go over here. Now we don't  
18:35 - need the pre construct, we do need the construct 
and we will use the tick as well. Or actually we  
18:41 - will create an invent for that. But over here in 
the event construct, what we are going to do is  
18:46 - we are going to take the game over text, so we 
need the game over text and we need the restart  
18:53 - text. There you go. And from here, we are 
going to set visibility, so drag a note  
18:59 - from them and click on Set visibility. And I'm 
going to plug in the execution order over here.  
19:05 - And I'm also going to plug in the restart text 
over here as well which means both of these now  
19:11 - are the targets for this and we are going to set 
the visibility to hidden which means they will  
19:16 - not be visible. So when we run the game, we are 
not going to make the game over and the restart  
19:21 - text visible. Next over here below that I'm 
going to right click and create a custom event.  
19:29 - And this custom event is going to be update score. 
The update score is going to have a parameter so  
19:36 - click on it and over here for the inputs click 
on the plus button and the parameter over here is  
19:42 - going to be score and instead of Boolean we are 
going to make it an integer. So now from here,  
19:48 - we're going to take the score value. And I'm just 
going to move a little bit down. Take the score  
19:54 - value and put it over here. From the score 
value I'm going to say set text Like this, plug  
20:02 - in the execution order over here, and plug in the 
score in the text, and of course, it is going to  
20:10 - automatically convert this integer to a text and 
plug it in over here. And this is how we are going  
20:15 - to display the score to the user. So this event is 
going to be used to display the score as I already  
20:22 - said. And last but not least, again, right click 
and create a custom event. Now this custom event  
20:29 - is going to be our game over event like this. 
And for our game over event, we are going to take  
20:38 - our text again. So we can select all of these and 
we can Ctrl C to copy them, and then Ctrl V to  
20:44 - paste them. And I'm going to plug in the execution 
over here. But this time, it's not going to be  
20:49 - hidden but visible. So the visibility is going to 
be visible, which means we are going to be able  
20:53 - to see the game over text and the restart text. 
And last but not least, we're going to take the  
20:59 - game over animation, the one that we have created 
a moment ago over here. And from the game over  
21:06 - animation, we're going to drag and know that 
we're going to say play animation like this blog  
21:13 - in the execution order over here. And everything 
is going to be as easy as playback speed is going  
21:18 - to be one, the Play Mode is going to be forward 
over here in animation Game Over animation start  
21:25 - at time zero number of loops to play is going to 
be one and Compile and Save that. So this is what  
21:32 - we are going to use later on when we create our UI 
widget, we are going to use it and we are going to  
21:38 - first get a reference to it. And then from there, 
we are going to use these custom events to play  
21:45 - the animation when the snake dies, update the 
score when we have the new score. And of course  
21:50 - hide the text. When we start the game. Moving 
forward, we are going to go back here inside of  
21:56 - our gameplay. And I am going to select everything 
inside of the level. So from atmospheric fog to  
22:03 - sphere reflection, capture, and simply delete 
all of that, and yes to all delete everything,  
22:08 - and we have a dark level. Of course, this is 
not what we want. So we are going to go here  
22:13 - inside of the sprites folder. So this is our 
sprites folder. And I'm going to drag here,  
22:18 - the background sprite, so I'm going to put that 
inside. And I'm also going to find the gray  
22:25 - back ground. And let me just find it here. Here 
it is. So we have that gray background sprite,  
22:31 - and we have the back ground sprite, what we are 
going to do is select the back ground sprite  
22:37 - for the location x over here inside of 
the transform. So this bad boy over here,  
22:42 - the location x is going to be at zero. And 
what did I do, I apparently deleted it. So  
22:49 - select the background sprite over here location 
is going to be zero for the X for the Y is going  
22:54 - to be negative 20 for the Z it is going to be 
zero rotation, we're not going to touch that.  
23:01 - But over here for the scale, we are going to set 
it to be 555 on all three axes. So x, y, and z,  
23:10 - all three of these they are going to have that 
scale. Now also, what I am going to do is here for  
23:16 - the sprite color, instead of white, we're going 
to set over here the hex linear 2345 C, nine zero  
23:25 - FF. So again, it's 345 c nine zero FF and again, 
you see it just changes a little bit the color.  
23:33 - And again, what I wanted to say is, you don't have 
to have exact the exact same color as I do, but  
23:40 - if you want just pause the video, we're here, take 
a look at this hex linear again, 345 c nine zero  
23:48 - f f. Now moving forward for our gray background 
Sprite. So for the gray backgrounds, right,  
23:55 - we are going to set the x at minus 50. 
This is for the position the position y  
24:01 - is minus 10. The position z is going to be 
minus 50 rotation, we're not going to touch  
24:08 - that. And over here for the scale x is going 
to be 12. Scale y is also going to be 12.  
24:15 - And last but not least the scale z it is going 
to be 10 There you go. Now also for this bad boy,  
24:23 - we are going to click here on the sprite color 
and where is that it's basically right over here  
24:28 - in the sprite. So when you click on this bright 
color over here hex linear, I'm going to paste  
24:34 - this for two to a five nine c c. So 422 
a five, nine cc or simply pause the video  
24:43 - and check out for yourself. I'm going to click ok 
and this is what we have. So this is going to be  
24:49 - our game background. Now of course we're still not 
finished because we do need to add one more thing  
24:55 - over here. So I'm going to go over here where it 
says please actors in search for classes here. I'm  
25:00 - going to filter for the camera and I'm simply 
going to drag and drop this camera over here.  
25:06 - Now for this camera, we of course need 
to reposition it. So select the camera,  
25:12 - the exposition is going to be minus 50, the y 
position is going to be 100. And the Z position is  
25:17 - going to be also minus 50. So it's minus 50. There 
you go. And the rotation on the z axis is going  
25:26 - to be negative 90. And this is what our camera 
sees. If we select the camera, you see over here,  
25:33 - when you select it, and you click on it over here 
in the world outliner, this is what the camera  
25:38 - sees. But of course, one more thing that we need 
to do is over here, the projection mode, I'm going  
25:43 - to change it from perspective to orthographic. 
And automatically, you can see how the preview of  
25:49 - the camera over here changed. Now also over here, 
or toe width, I'm going to save 4500. And again,  
25:58 - you see over here, how the camera view changed, 
or what the camera sees, has changed. Now again,  
26:06 - I'm not going to like experiment with this, you 
can see this on your own what is what this is  
26:11 - doing the order the width, and you can change from 
orthographic to perspective to see the difference.  
26:17 - So that way you can instead of me explaining 
what it does, it just changes the view of the  
26:21 - camera and the width, and so on and so forth. But 
again, as I said projection mode, just change it  
26:25 - from orthographic to perspective, and vice versa. 
And you will see that now we do have one thing  
26:31 - that is not working if I hit the 
play button, this is what we see. And  
26:35 - this is not how we want to see our level we want 
to see it, as we saw in the preview of our game.  
26:44 - How the camera is looking at the level 
so that we can actually see it better.  
26:48 - And in order to do that. While we are over here 
inside of the gameplay tab for the gameplay level,  
26:54 - we are going to click here on this blueprints 
drop down list. So click on this drop down list.  
27:00 - And we're going to click on Open Level Blueprint. 
And it is going to open this over here, we don't  
27:06 - need the tick event. But what I'm going to do 
is I'm going to move this over here and go back.  
27:11 - So as you can see I have a floating window. So I 
have a floating window of the gameplay level over  
27:17 - here on I'm simply going to do is take the camera 
actor and place it over here. So from the world  
27:23 - outliner here it is simply get the camera, drag 
it and drop it over here. And now we can well dock  
27:32 - the gameplay tab again. So now that we have 
the camera actor, what we are going to do is  
27:40 - from it or simply over here, can I do it like 
this set view target with blend, no I cannot I  
27:46 - need to drag a note from the camera actor over 
here I need to say set view target actually.  
27:56 - So we need to do this actually from the 
Player Controller. So right click over  
28:00 - here we need to say Get Player Controller 
and from him. So excuse me for this one.  
28:07 - from him, we need to see set view target with 
blend, there you go. So this is where it was.  
28:13 - Unreal Engine has so many functions, sometimes 
you forget where they are. So over here, the new  
28:19 - view target is simply going to be we're going to 
plug in over here, the camera and everything here  
28:24 - we're going to leave it as is blend times zero 
blend function vt blend linear blah, blah, blah,  
28:29 - blah, blah, blah, Compile and Save that. So again, 
it's from the Player Controller. So right click,  
28:34 - and over here Get Player Controller This 
is how you get the Player Controller.  
28:39 - And over here we have from the Player 
Controller, you drag a node you  
28:43 - type set view target with blend, and this is 
going to be or this is going to set the view  
28:50 - on the camera that we have specified. And over 
here new view target is the camera actor from  
28:55 - the level. So Compile and Save that again. 
And if we go back over here in our game plan,  
28:58 - kid the play button, there you go. So this is 
this is what we want to see. And this is well  
29:05 - our desired outcome. So if I hit the play button, 
now this is our level. So this is how we want to  
29:12 - see it with our main camera moving forward. 
Now we are going to start adding elements  
29:17 - inside of our game. So over here inside of the 
blueprints first we're going to right click  
29:22 - and go over here under blueprints. And we're 
not going to create a blueprint class or  
29:27 - none of these except for the enumeration. So 
click on the enumeration and we're going to call  
29:33 - this one food color underscore e num There we go. 
So again, it's right click under blueprints and  
29:41 - then enumeration and when you open it over here 
what is this well enumeration or enumerators are  
29:48 - basic we can create them however want to create 
them. So for example if we click here on new,  
29:52 - you see over here we are going to click on 
new and we have a new enumeration and we  
29:58 - can give it a name What whatever we want, and 
we are going to create four of these. So the  
30:02 - first enumeration over here is going to be blue. 
This is what I meant when I said we can create  
30:08 - however, we want to create them. So we can give 
them names, whichever we want. So over here, we  
30:12 - can say purple. For the third one, we can say red. 
And for the last but not least, we can say yellow.  
30:20 - And same way you can create I don't know, like, 
you can create enumerations for Kenny, Carl,  
30:25 - Johnny, Bobby, whatever, so you can give 
them names. And later on inside of our game,  
30:30 - we can use these enumerations to compare 
them with each other to basically check if we  
30:40 - have the same item. For example, if the color 
of our actor is blue, or purple, or whatever,  
30:48 - we can even use this for tags, we can give them 
tags over here, we can compare them later on, so  
30:53 - on and so forth. So this is for what we are using 
the enumerations. So the next step, now that we  
31:00 - have the enumeration, we are going to go back over 
here, I'm going to right click, and this time,  
31:03 - we are going to create a blueprint class. And it's 
going to inherit from the actor. And we're going  
31:09 - to call this bad boy BP food. So we are going to 
use this to actually create the food. So I'm going  
31:16 - to double click this, open it of course here in 
the Blueprint Editor. Now the first thing that we  
31:22 - are going to do is over here is click on the Add 
Component. And we are going to filter for sprite  
31:29 - and we want the paper sprites. So this will be one 
of the paper sprite components. If I hover over  
31:35 - you will see it's a paper sprite component. It's a 
component that handles rendering and collision for  
31:40 - a single instance of a new paper. Basically, this 
is a component where it will allow us to display  
31:48 - an image and I'm going to make it a default 
route. And I'm going to rename it to food sprite,  
31:54 - there you go. So I can compile this and save 
it. And of course over here inside outside,  
31:58 - of course, like you knew that was coming. So 
we're here in the variables, we are going to  
32:02 - create a score variable. And this is going to be 
an integer and I am going to make it public and  
32:09 - Compile and Save this bad boy. So this is when 
it comes to our food Sprite. Now of course, we  
32:15 - are still not done. Instead, what we are going to 
do is we are going to go here in the Event Graph.  
32:24 - And from here, I'm going to remove these 
two in the Event Begin Play, we are going to  
32:32 - create a custom function. So right here 
below, we are going to get a custom  
32:38 - event and I said function with a custom 
event. And we're going to call this set  
32:42 - food. And from here actually First, I'm going to 
click on it. And what we are going to have here,  
32:49 - so click on it and over here we're going to have 
an input which is a parameter. So we're going to  
32:55 - call it the type and from the drop down list over 
here we are going to click here and in the search,  
33:01 - we are going to say food. And there we go. So we 
want the food color e&m so this type that we're  
33:07 - going to pass here, inside of this custom event 
is going to be the food type enumeration that  
33:13 - we just add it. Now over here when we begin the 
event, or will we begin play we're going to call  
33:20 - set food. And let me just find it over here. Where 
is it? Where is my custom function, here it is. So  
33:27 - set food. And we are going to leave it at Blue and 
pay attention over here because we set the type  
33:32 - over here of this parameter to be the food color 
enumeration. You see that we have blue, purple,  
33:38 - red and yellow, which are these over here that 
we have created. So we can Compile and Save that  
33:45 - There you go. Now what we are going to do with 
this set food is that we are going to get our  
33:51 - food sprite so we are going to put it over here 
get it because based on the food we are going to  
33:57 - order based on the color of the food we are going 
to change the sprites appearance. So from here  
34:03 - I am going to say switch on first from here from 
the type we can say switch and it is going to  
34:10 - create a switch on the food color. And over here 
as I said on the food color, we have the blue,  
34:16 - purple, red and yellow, which are the ones that 
we have created. So I'm not going to go back again  
34:20 - because we already know that now from here from 
the food sprite, I'm going to say set Sprite.  
34:26 - And there you go. Now what I'm also going to do is 
copy and paste this, paste it again and paste it  
34:33 - again. So you have four of these possibilities. 
When I say possibilities that is we can have  
34:39 - the blue color over here we can have the purple 
color, we can have the red color, we can have the  
34:45 - yellow color. Also this food sprite goes into 
every single one of these. So make sure that  
34:51 - you do that you can move this a little bit away 
like this so that you can see it more clearly.  
34:56 - That's up to you. And there you go. So this 
food sprite needs to go in every single one  
35:02 - of these for the target, as you can see, 
because we are targeting that food sprite,  
35:08 - now that we have our everything is set up. So 
for the switch on the food color, we plugged in  
35:14 - the food sprite over here, when we have the blue 
one, we are going to click here and we're going  
35:18 - to select the blue polygon Sprite. Because again, 
as I said, if the food if the in among the food is  
35:26 - blue, we are going to set the blue polygon. And 
this is what I said a moment ago. So over here,  
35:30 - based on the switch on the enumeration food color, 
it is going to tell us if it's blue, then it's  
35:36 - going to execute over here. So if it's blue, it's 
gonna execute this if it's purple is gonna execute  
35:41 - this if it's red, this and so on and so forth. So 
over here, if it's purple search for purple, there  
35:46 - we go purple polygons right over here, we have the 
red, so type red, and we have the red polygon, not  
35:53 - the Red Square, but the red polygon Sprite. And 
last but not least over here, we have the yellow.  
35:59 - So over here we have the yellow polygon, Sprite, 
there you go. Now what we are also going to do is  
36:08 - we are going to set the score. So over here, set 
score, like this, copy and paste this bad boy,  
36:15 - and it does go This goes over here, paste 
it one more time, this goes over here.  
36:21 - And last but not least for our yellow, also 
paste it like this, this goes over here,  
36:27 - come on, let us go back. There we go. So now over 
here, if we have the blue color, we are going to  
36:34 - set the score to be 100. If we have the purple 
color, we're going to set the score to be 50.  
36:41 - If we have the red color, we're going to set the 
score to 20. And last but not least, if we have  
36:46 - the yellow color, we're going to set the score 
to 10. And we can compile and save this. Next,  
36:52 - we are going to wait and delay. So 
we're here we're going to delay.  
36:57 - And we are going to delay for three seconds. If 
is the blue color copy and paste this and I'm  
37:05 - going to plug it in over here. If it's the purple 
color, we are going to delay two seconds. And last  
37:11 - but not least, if it's the red color, we are going 
to delay one second. Now we are not going to delay  
37:18 - if we have the yellow color. So we're going 
to leave it as is Compile and Save that.  
37:23 - After we delay what we're going to do well 
over here, now we're going to set the food  
37:29 - like this, there you go. And we're going to set 
the color to purple. And I'm going to copy and  
37:34 - paste this. And this goes over here. And let 
me just move these a little bit like this.  
37:43 - And generally move the whole function over here. 
There you go. And I say function. It's a custom  
37:48 - event. But it's basically, if not the same thing, 
it's similar. And over here we have another set  
37:55 - food and this time this is going to be read. And 
last but not least over here we have the food.  
38:01 - And we are going to set this bad boy to yellow 
there you go Compile and Save that. So first,  
38:09 - when we go into set food, we are going to go into 
switch and we explained this based on the color  
38:14 - we are going to set the sprite of our or the color 
of our foods prior to that Sprite. And then we are  
38:21 - going to set the appropriate score based on that 
as well. And after that we are going to delay.  
38:28 - Depending on which color we have, we're going to 
delay a certain number of seconds. And after that,  
38:32 - we're going to change the color of the sprite 
again, so simply Compile and Save this. So this is  
38:38 - for our BP food. Now before we proceed to create 
the gameplay mechanic, we still need to create a  
38:45 - couple of more actors over here blueprints. 
So we are going to create another blueprint  
38:49 - and it's going to inherit from the actor. And 
this one is going to be BP block. There you go.  
38:55 - So double click this bad boy open it over here. 
And what's going to happen is we are going to go  
39:00 - again under Add Component and filter for paper 
sprite, and it's paper there it goes sprite,  
39:07 - so this will be one and this one is going to be 
our block Sprite. What I'm going to do with this  
39:13 - one is over here for the source of the sprite, we 
are going to click on the drop down list. And we  
39:20 - are going to filter for gray square sprites. 
This is what we want. So this is going to be  
39:27 - a sprite that's going to represent our block 
over here for the location for the why we're  
39:33 - going to say minus 10, just so that we can 
move a little bit backwards. And we're not  
39:38 - going to touch anything else. So make sure that 
you compile and save this as well. There you go.  
39:45 - Moving forward. The next thing is let me go back 
over here and right click blueprint class and  
39:51 - again, it's going to inherit from the actor and 
this one is going to be BP underscore snake body  
39:58 - part. So there you Go. And what I'm going to 
do is double click this bad boy and open it  
40:04 - to open it over here inside of our editor. 
Now what's gonna happen with the snake  
40:10 - body part is that we are going to use a paper flip 
book. So over here at component, we're going to  
40:17 - filter for paper flip book. And what the hell is a 
fake paper flip look, first, let me just set it to  
40:24 - be the default scene. There you go. So we have our 
paper flip book, we are not going to add anything  
40:29 - over here inside of our source for it. But over 
here for the variables, you're going to click  
40:35 - on the plus button and we are going to see is head 
and this one is going to be public. So make sure  
40:42 - that you check this eye box or this eye over here, 
so that we can make it public. Because of course,  
40:49 - we want to, you know, access it later on in other 
sprites and determine if this is the head or not.  
40:56 - Now what the hell is a paper flip book, paper flip 
book in Unreal Engine will allow us to create an  
41:02 - animation and here it is, you see flip books, and 
we already have the bait, the beat flip book and  
41:09 - the blank flip book. If I hover over over here, if 
I hover over if I right click and go to paper 2d  
41:17 - Here is where you can create a paper flip book. 
So it's simply right click paper 2d paper flip  
41:24 - book. And you can call this one test book, for 
example. And you can double click on it, and you  
41:29 - can open it here. So what is this what the hell is 
this, let me just open the one that we already had  
41:34 - over here, the beeth one, there you go, you see, 
and let me just stop it because it is animating.  
41:40 - So this is basically a way inside of Unreal 
Engine to animate sprites. And the way this works  
41:49 - is there are multiple ways how you can create 
animations like the ones you saw over here, you  
41:53 - can go over here and you can right click to add a 
keyframe and there we go, we have a keyframe and  
41:59 - you can right click on that and then over here you 
can pick a sprite for example that that sprite one  
42:05 - and you can save that so when you save it and this 
is not what I want. So save it if I preview it,  
42:11 - let me see do we see it actually for some 
reason we don't so let me just do this.  
42:17 - I am going to close it go back over here and open 
it and now we see it. Now you can also do it like  
42:26 - this you can go over here and click c you can move 
this handle over here to go at the last frame and  
42:35 - then you can click on add the new frame so now we 
have a new frame and again a new frame a new frame  
42:40 - a new frame so we can do it like this as well. And 
let me just delete these so we can delete them all  
42:47 - because you can also drag and drop them so the 
lead the lead save you can also move this over  
42:54 - here and then from here from your sprites you can 
then drop your sprites for example can drop this  
43:03 - one over here or simply over here in the frames 
to create an animation you can drop one then  
43:10 - the second and the third and so on and so forth 
are over here the new keyframe and you can click  
43:16 - here and pick a dead sprite one image add the new 
keyframe right click pick new sprite lets that to  
43:23 - sprite image and let me just save that. So when I 
preview it, you see automatically the animation is  
43:29 - being played. So it's a simple, it's very simple. 
It's not complicated. getting something is not  
43:35 - clear, make sure that you ask in the comment 
below. But basically, you'd simply right click  
43:40 - Add keyframes or click here to add keyframes 
and then on those keyframes, you right click and  
43:45 - select the sprites you want so that you can create 
the full animation. This is what we did over here.  
43:51 - I already prepared this so that we don't have to 
do it. But I explained right now how it is done.  
43:56 - And if I preview it, this is that animation. So 
we have 11 sprites or 11 frames. And again, paper  
44:02 - flipbook is a way to animate sprites in Unreal 
Engine. So here in the flipbooks weekend, let me  
44:10 - just save everything, we can delete this textbook 
because we don't need it anymore. This was just  
44:16 - for an example to show you how it works. And you 
can also delete it from here because we don't have  
44:22 - to like we don't need to keep it over here. Again, 
if something is not clear about what is a flipbook  
44:29 - and how it works just make sure that you ask in 
the comment below the video, let us move on the  
44:35 - main part of our game and here in the blueprints 
we are going to right click Create a blueprint  
44:40 - class which is going to inherit from the actor and 
this one is going to be BP underscore main game  
44:48 - and I'm going to drag and drop this bad boy in 
side of our game now inside of the level that is  
44:55 - and this is we are going to position 000 for all 
three axes. But you know it It's not important,  
45:01 - just some I don't know, I'm weird like that I 
like to, you know, position things. Anyways,  
45:06 - this is going to be the main blueprint, or 
the main actor that is going to control,  
45:13 - initialize and do everything with our game. Now 
before we start programming everything over here  
45:19 - in the Event Begin Play, I'm going to remove 
everything and over here in the variables,  
45:24 - first, I'm going to click here, and we're going to 
have snake parts. So snake parts array, not a rat,  
45:34 - but it's an array like this. And over here, we are 
going to search for our snake body parts. So here  
45:42 - BP snake body parts, and I'm going to click here 
object reference. Now, as I said, this is going to  
45:48 - be an array, there are two ways how we can declare 
an array if you don't know that, so you can click  
45:53 - right click on this blue circle over here, or 
you can click on here. And then from there,  
45:59 - you can choose so from here, if I click on you can 
see we have a single variable, we have an array,  
46:04 - we have a set, we have a map, we are going to 
click here on the right, or as I said over here,  
46:10 - we can right click, so we can right click over 
here. And there you go. So when you see these,  
46:16 - like these grids over here, if you didn't know 
that this is now an array. Now moving forward,  
46:23 - we are going to click on the plus button, we're 
going to have over here direction z, and this  
46:28 - one is going to be an integer and click on the 
plus button again, there's going to be direction  
46:36 - x, there you go. So Compile and Save that now 
directions in direction x, they are not going  
46:42 - to have any default value. So they're going to 
have default values of zero. Moving forward,  
46:49 - I'm going to click here on a new variable, and 
we're going to say can change direction, this is  
46:55 - going to determine if we can change the direction 
with the snake or not. So Compile and Save that  
47:01 - moving forward, we are going to have x underscore 
max. And this one is going to be a float.  
47:09 - And by default, I'm going to set the value of it 
to be 1200. And click on the plus again and we're  
47:17 - going to have z underscore Max, make sure that you 
Compile and Save that and for the Z, the maximum  
47:23 - is going to be 1000. So for the x max or x maximum 
1200 for the Z max, it is going to be 1000.  
47:36 - Moving forward, I'm going to click here and we're 
going to have a food actor reference. So food  
47:43 - actor ar e f, and from here I am going to search 
for food. And we want the BB food and we want the  
47:50 - object reference Compile and Save that. Moving 
forward, we are going to have our wall blocks  
47:59 - array which not again a rat what is what is wrong 
with me with the rat. It's an array not on a rat,  
48:07 - anyway is this going to be RBP block. So from 
here, click in search or filter for the block.  
48:13 - So this is what we want BP block and just 
to be sure BP underscore block here you go  
48:19 - select the object reference and make it an array. 
So we want the wall blocks to be an array moving  
48:28 - forward, click on the plus button over here to 
add a new variable and this one is going to be  
48:33 - delay not the ol I what I wrote 
over here a delay variable which  
48:38 - is going to be a float. So from here we have a 
float. Let me just compile this so that I can add  
48:45 - a default value over here so the default value 
is going to be point to Compile and Save that.  
48:52 - Moving forward we are going to have another one 
which is going to be is dead. And of course you  
48:58 - can assume this is a Boolean because it is 
going to determine if the snake is dead or  
49:04 - not. Next we are going to have the HUD r e f or 
the reference to our HUD which is going to be  
49:12 - our game Hots over here simply filter for HUD. And 
this is what we want BP you I heard and this is  
49:21 - the one that we want which is the one that we have 
created. So Compile and Save that moving forward.  
49:28 - Last but not least we are going to have the score 
which is going to be an integer so make sure that  
49:34 - you compile and save that as well. So this was 
the preparation for our main game blueprint  
49:42 - which is going to control our game. As you can 
see over here we have all the variables for the  
49:46 - snake parts we're going to store the snake parts 
that we create because you know the snake eats  
49:52 - a jam or eats a fruit or whatever 
in the game and then it grows.  
49:56 - Whenever we eat a new item we need to make the 
snake large Those parts are going to be stored  
50:02 - inside of this array direction z and x. This is 
pretty self explanatory, it's the direction where  
50:08 - the snake is going can change direction can we 
you know change the direction self explanatory x,  
50:14 - maximum z maximum, these are the speeds 
for the x and the Z we will see later on  
50:19 - how we are going to use that food actor 
reference self explainatory wall blogs,  
50:24 - these are the walls that we are going to you know 
create like this in the game to strip the movement  
50:31 - of the snake. So, this is the reference where we 
are going to put them that the lane is going to be  
50:36 - the speed of the snake we will see later on how we 
can increase it is that self explanatory hard self  
50:41 - explanatory score self explainatory. And I don't 
think that, you know, we need to explain that  
50:47 - moving forward here in the Event Graph, first, 
we are going to right click and create a custom  
50:53 - event. And this custom event is going to be 
called spawn new snake part, which is going to do  
51:00 - what the title says or it name says is going to 
spawn a new snake part. Now we are going to have  
51:06 - two parameters. So click this new parameter here 
on the input two times one, two. So over here,  
51:13 - the first parameter is going to be our spawn 
location. And the second parameter is going to be  
51:20 - is head for the spawn location, it is going to be 
a vector because vectors represent a location x,  
51:28 - y, and z. Next, what we are going to do 
is from here, I'm going to say spawn actor  
51:36 - from class. And the actor that I'm going to spawn 
over here, we are going to select the class we are  
51:42 - going to say snake body part. There you go. Now 
here we are going to have the spawn transform,  
51:51 - and we have here the location. So what we need 
to do is right click on the spawn, transform and  
51:56 - split struct pin so that now we have the spawn 
transform location, and I can plug this into the  
52:03 - location, we are not going to touch the Transform, 
rotation and scale and so on and so forth.  
52:11 - Over here collision handling override specifies 
how to handle commit collisions at the spawn  
52:18 - point. Basically, we are going to click on the 
drop down list and we are going to say spawn  
52:25 - always are always spawn ignore a collision. So we 
don't we don't care if there are any collisions  
52:31 - at the split space or the spot where 
we are going to spawn our snake.  
52:38 - Now moving forward, we are going to drag from 
here from the head, we are going to say select  
52:45 - like this, and you want this one over 
here, see this one that has this over here,  
52:49 - this like yellowish icon. So that's the one that 
you want. So I'm going to do it again select  
52:54 - and here we go, this is the one that we want. 
I'm also going to double click here on the pin  
53:00 - so that I can you know, restructure it 
like this, I can make this a little bit  
53:05 - clearer, it is better, it looks a little bit 
better. And we are going to do it like this.  
53:11 - So there you go. So what we are going to do on 
these pin structures is that we are going to  
53:21 - based on what's going to happen over here. So 
based on the value if it's true, or if it's false,  
53:29 - I am going to let me just see it like this. So 
over here, let me just Compile and Save that.  
53:35 - So this is okay. What we need to do over here is 
first drag from the drag from the paper flip book.  
53:45 - And for some reason the target over here needs 
to have it so we're going to get the paper flip  
53:52 - book. Let me just see it over here. Here it is the 
paper flip book from the returned value which is  
53:58 - basically let me just go over here and this thing 
body parts This is that paper flipbook. So we are  
54:04 - going to get that paper flip book and we are going 
to from here we're going to say set flip book.  
54:11 - There you go. And we are going to set this the 
return value, we're going to plug it in over here  
54:17 - as soon as we plug it in. As soon as this value 
is plugged in over here, the true and the false  
54:23 - will automatically give us it will give us an 
option to select a paper flipbook. So I'm going  
54:30 - to plug this in there you go, bam, you see right 
there. And let me just move this here. There you  
54:38 - go. This goes over here like that. So if the is 
head, if it's false, we are going to select the  
54:47 - yellow square flipbook. So this is the one that we 
want. If it's true, we are going to select the Red  
54:56 - Square flipbook and we are going to Compile and 
Save So again, if it's false, we are going to  
55:02 - select the yellow square flipbook. So yellow 
square foot book. If it's true, we are going  
55:08 - to select the Red Square flipbook. So if it's 
a head, it's going to be represented with red.  
55:16 - And this is what we are going to do. Now the next 
part or the next step that we are going to do is,  
55:22 - after we set the flipbook, we are going to get the 
snake parts array. And we are going to from here,  
55:30 - create a node and we're going to say add, which is 
going to add to this, it is going to add to this  
55:38 - array. Now we need to add a new element, the new 
element is going to be the returning value over  
55:43 - here that we have created from our spawn snake 
body part. So I'm going to take this return value  
55:50 - and plug it in over here. But before that, I am 
also going to double click on that, no, then move  
55:55 - it like this and double click on the node again 
so that I can you see it so that I can create like  
56:01 - this. And now we see that it goes, the node goes 
from here to here, and then goes over here to add  
56:06 - it into the snake parts array, which is what we 
want. Now the next step that we are going to do is  
56:14 - from here, from this one, we are going to say set 
is head, and that goes over here. And again, I'm  
56:20 - going to double click on the node just so that it 
is more visual, visually clear what we are doing.  
56:27 - And here is head we're going to plug in this one. 
And again, I am going to double click on this node  
56:34 - and move it over here like this, we can clearly 
see this goes from here his head, and then we're  
56:40 - going to plug it in over here and then it goes 
from here over here. And we're going to plug it in  
56:45 - and set it to the node if it's a head or not. So 
now moving forward, we are again going to drag  
56:53 - from this node, which is again the snake body part 
that we have created because now we are going to  
57:01 - set the actor or rotation for the snake body part, 
this goes over here and then we double click again  
57:08 - on the node itself. This goes over here. And in 
order to set the rotation for our snake, what I'm  
57:15 - going to do is I'm going to get a random integer. 
And this random integer is going to have maximum  
57:22 - of three because over here, if I hover over 
returns and uniformly distributed random number  
57:26 - between zero and maximum minus one, so we can get 
well as you can see, so zero maximum minus one,  
57:32 - what we are going to do over here is we 
are going to plug this into a select.  
57:38 - And there you go. So we have now the Select over 
here, I am going to add two more pins. So we have  
57:45 - options 012 and three, and option one First things 
first, I'm going to split the pin structure here  
57:52 - for the rotation. So split struct pin. And we 
are going to plug in the return value over here  
57:59 - inside of the why for the pitch. And 
when you do that automatically, these  
58:03 - options that are going to convert into integer 
actually float values. So when I plug it in bam,  
58:09 - they have converted into float values when we 
have option while we're going to say zero when we  
58:13 - have option two, we are going to say 90 degrees. 
Option actually options here, option one is 90,  
58:19 - option two is 180. And option three is 270. And we 
are going to Compile and Save that. And if you're  
58:27 - wondering why I added option three, well maybe you 
decide to later on add here maximum for four. And  
58:33 - there you go. So Compile and Save that this is 
going to be our spawn new snake and I'm going to  
58:40 - put it in a comment, right click Create a 
comment from section I'm going to say over here,  
58:45 - spawn new snake part there you go, Compile 
and Save that. Next we want to spawn our food.  
58:55 - And in order to spawn the food, the first 
thing that we are going to do is this,  
58:59 - we are going to get our x maximum and we're going 
to get our z maximum, we're going to put them  
59:05 - over here. Now what's going to happen is for 
the x maximum, I'm going to say minus float.  
59:13 - And the float that I'm going to subtract it or 
subtract from it is going to be 100. So 100. Next,  
59:22 - what I'm going to do is from here, I'm going 
to multiply this with a float. So I'm going to  
59:26 - multiply this with a float, the float that I'm 
going to use to multiply is going to be negative  
59:31 - one. And the reason for that is because you see 
subtraction, A minus B, the return value over here  
59:36 - is actually the result from this. So I'm going to 
multiply the result with negative one, because I  
59:42 - am going to use over here a random, random float 
in range. And the minimum is going to be this  
59:51 - value multiplied by negative one and the maximum 
is going to be this value. Let's assume z or x  
59:57 - maximum. Well actually it's 1002 100 minus 100, we 
are left with 1100 multiplied with negative one,  
60:04 - we have negative 1100. And over here we have the 
positive 1100. Next, what I'm going to do is from  
60:15 - here, I'm going to right click, and I'm going to 
say division, and we want the division with the  
60:19 - whole and remote remainder. The You see, if I 
hover over returns, the number of times divisor  
60:27 - will go into the dividend. So the divisor is this 
number that we have over here, it will return how  
60:33 - many times this number goes into this number. 
dividend is this number over here, the last the  
60:38 - random float in range, and the divisor is going to 
be 100. So this is going to return how many times  
60:45 - divisor goes into the dividend, it is going to 
return the value over here, but the remainder is  
60:51 - how much did it remain from the dividend. 
For example, let's say the dividend is 1050.  
60:59 - The divisor is 100, it goes 10 times into 
1050. So the return value here, we'll say  
61:06 - it goes 10 times inside, but what's remaining 
is 50. Because 10 multiplied by 100 is 1000  
61:14 - 1050 minus 1000, we are left with 50. And this 
is what we are doing over here. Now last but not  
61:21 - least, we're going to take that return value 
and multiply it with a float. And that float  
61:26 - is going to be 100. Now we are still not done, we 
are going to go back over here for our x maximum.  
61:33 - And here we're going to say minus float and do 
the same thing. So minus float, the minus value  
61:39 - is going to be 100. And over here, we're going 
to multiply that with a float. So multiply that  
61:45 - with a negative value over here. So we are 
going to say minus one random float in range,  
61:53 - this is going to be plugged in over here, this is 
going to be plugged in over here, basically doing  
61:59 - the same thing. So we can copy these two and 
paste them over here because the return value  
62:03 - goes into the dividend. And over here we have 100 
for the divisor, and we're going to multiply this  
62:09 - with 100 as well. Because now over here, I'm going 
to right click, and I'm going to create a custom  
62:16 - event. And this custom event is going to be 
called spawn food. And from here, I am going to  
62:24 - say spawn actor from class. And the class that 
I'm going to use is the BP food or simply type  
62:32 - food. And there you go. Now what we are also 
going to do is for the transformer going to  
62:37 - split the struct pin, but I'm also going 
to do that over here for the location,  
62:42 - right click on the location and split struct pin, 
because now I can plug in this one on the x. And  
62:49 - I can plug in this one on the location z and the 
location y is going to be equal to negative 0.1.  
62:58 - Because we are this is a 2d game. And we have 
the x and the Z. So over here, x and the Z and Y  
63:06 - is basically to move it backwards like this. So 
we don't care about why. And for the collision  
63:12 - handling, we are going to say always spawn, 
ignore collisions, and you can Compile and  
63:18 - Save that. And of course, the last step over here 
is that we need to set the set food actor AR F.  
63:28 - So we are going to set the reference to 
the food actor because later on we need to  
63:34 - test if our snake is colliding with the food 
actor. And I'm going to right click and create  
63:39 - a comment over here and this was going to 
be spawn food and make sure that you compile  
63:45 - and save that as well. Now what is happening over 
here? Well basically again, we are just doing some  
63:52 - basic calculations over here from the x maximum 
and the Z maximum. So that we can as you can see,  
63:58 - x maximum is 100 or 1200. And the Z maximum is 
1000. Now why is that if I go back over here,  
64:07 - and let me just take a sprite and let's say this 
is the food and this is where we can put the foot  
64:12 - pay attention to the x value over here. It's 
at 1000, negative 1180. And on the z axis,  
64:22 - if I move it down like this, it goes to negative 
900 or negative 1000 here is the positive 1000.  
64:29 - So this is basically what we are doing. 
And again, if you are wondering why am  
64:33 - I subtracting 100 from that because again, if 
I said the Z to 900, you see it's right over  
64:40 - here at the top. So this is what we are doing. 
So there you go, and this is why so basically,  
64:47 - we are going to use the these values to randomly 
So again, it's these values to randomly spawn our  
64:57 - food within these bounds because As you can 
see, if I go over here, if I select the food,  
65:03 - and if I go over here, this goes up to negative 
1000. You see 1100. This is where it goes,  
65:09 - if I move a little bit here towards the edge, it's 
negative 1170. If it goes over here, it's positive  
65:16 - 1000. So there you go, is going to spawn it 
within those bounds. Basically, this is what we  
65:24 - are doing. Did I move this by any chance? I don't 
think I did. I don't think that the negative 50  
65:31 - minus 10, minus 50. Yeah, that's okay. 12 
to 1210. Yeah, that's okay. That's okay.  
65:36 - So yeah, we are again, these values are going to 
randomize and spawn our food within that range  
65:44 - that we just saw. So this is what we are 
doing. And now that you know that you can  
65:48 - easily calculate or see which numbers are going to 
basically this is going to return a random number  
65:53 - between negative 101,100 and positive 1100. 
And this is going to do the same thing,  
66:00 - but for the Z max, but because 
the max is 1000 is going to return  
66:04 - a random number between negative 900 and positive 
100. There you go. Positive 900. Excuse me.  
66:12 - Anyways, moving forward, I'm going to right 
click here and create another Custom Event.  
66:17 - And this custom event is going to be called 
kill snake, which is basically going to do the  
66:23 - killing of a snake symbol going forward, 
you're going to set that is that  
66:28 - and is that is going to be true. So 
make sure that you said that over here.  
66:33 - After we set the snake to be dead, we 
are going to take the snake body parts.  
66:38 - And we are going to right click over here. And 
we're going to say for each loop, because we want  
66:44 - to loop through each element inside of this array, 
I'm going to plug this in over here and the array  
66:49 - that we're going to loop is going to be the snake 
parts array. Now what's going to happen over here  
66:56 - is that in the loop body part or loop body, we are 
going to set the from the array element, I'm going  
67:04 - to get the paper flip book. So let me just get it 
here it is get the paper flip book because we know  
67:13 - that the snake body part has a paper flip book. 
And from here I'm going to say set flip book.  
67:21 - Here it is. So this goes inside of our 
loop bodypart There you go. So every loop,  
67:28 - we are going to set the paper flipbook, 
and we're going to use the array index,  
67:35 - and we're going to say e select on it, there 
you go. And based on the options, we are going  
67:42 - to our actually let me just remove this we are 
going to take the array index and we're going to  
67:47 - test that if it's equal to zero. And based on the 
options over here, we're going to say East select  
67:53 - now on this Boolean. And let me just move this 
over here. And I'm going to plug in the Boolean  
68:01 - over here, which is going to give us the options 
to if it's false. We are going to select the beat  
68:07 - flipbook. If it's true, we are going to select 
the blank flipbook. What this means. Basically,  
68:14 - in our snake body part, the first element that's 
inside of the array is going to be the head. So  
68:21 - what we are going to do over here, if the array 
index is equal to zero, that means it's true.  
68:27 - So we have the head for the head, we 
are going to use the blank flip book,  
68:31 - because the head is not going to explode like 
this flip book over here. Basically, this is  
68:36 - the animation for this flipbook. So this is how we 
are going to animate the flip book for the snake  
68:42 - body part. It's like you know it's dissolving, 
it's going away, this is what we are doing.  
68:48 - So if the element is if the array element index 
is zero, meaning it's the head, then we're going  
68:54 - to use the blank. If it's false, it's not the head 
then we're going to use the beat flipbook. This is  
68:58 - what we are doing now when it's completed when all 
of this completes, and I'm going to move this over  
69:04 - here. So when it's completed, when the looping 
completes, we're going to go inside of the delay,  
69:10 - and over here the delay is going to be point five 
of a second so we are going to wait half a second  
69:16 - and after that we are going to go inside of 
for each loop again, for snake parts array  
69:22 - again. So over here, get the snake parts array, 
and we are going to go in the for each loop.  
69:30 - We are going to loop through this snake parts 
array again and this time we are going to  
69:38 - set every paper flip book so the loop body part 
from the target. We're going to get the paper flip  
69:44 - book, which is this one over here, get the paper 
flip book. And over here we're going to say set,  
69:51 - Phillip book. Here you go. This goes over here. 
We're going to plug it in and this time we are  
69:59 - going To set the blank flipbook. So here it is, 
for every single one of these when it finishes.  
70:07 - Why? Well, because we want to simply, we want to 
simply make the snake disappear when we set the  
70:15 - blank flip book. And if you go back over here, 
if you selected in the blank flipbook, there is  
70:19 - nothing, which means nothing will be represented 
in our, in the snake. So the snake will simulate  
70:26 - disappearance, this is what we are doing. And I'm 
going to right click over here, I'm going to say  
70:30 - kill snake. If something is not clear, make 
sure that you ask but basically going through  
70:35 - this again, when we call the kill snake event, 
we're going to set the is that to true, then  
70:40 - we're going to loop through the snake parts array. 
And if the index is equal to zero, that means it's  
70:46 - the head if that is true, set the blank flipbook 
so that the head is not visible. If it's false,  
70:51 - it's not the head, it's the rest of the 
parts of the snake then set the beat,  
70:55 - which is going to preview this animation that 
we already saw. And when the loop completes,  
71:01 - and when we loop through every single element 
in that array, we're going to wait half a second  
71:06 - and then loop through the snake parts array 
again, and this time for every single element  
71:11 - inside of our array, we are going to set the 
blank flip book, which is going to make the  
71:18 - snake not visible and look like we killed it in 
the game. Last part for our custom event, we are  
71:26 - going to create your custom event and this one is 
going to be update score there you go over here,  
71:34 - the score is going to have a parameter 
which is going to be the value,  
71:38 - we know it's the value and the value is going to 
be an integer, Compile and Save that. So now we  
71:44 - are going to take the score over here get the 
score. And this video we are going to say plus  
71:50 - integer, so we are going to add these two. 
So we are going to add to the value that we  
71:56 - pass over here the current score value. And 
after that, we are going to set the score.  
72:03 - So set the score and plug this in over here for 
the new value. And after that we're going to  
72:08 - get the HUD Reference that we will create in a 
moment. Don't worry about that. And over here,  
72:14 - we're going to say update score. And this 
goes over here. And this goes over here.  
72:22 - There you go. If you're wondering what is this 
update score, simply double click it go over here.  
72:27 - And you can see, we are going to have the score 
value over here. And we're going to plug it into  
72:32 - the score text that we already explained inside 
of our UI, HUD, which is going to display the  
72:36 - score to our user. And this is how we are doing 
it. So we are going to pass the value over here.  
72:41 - add to it, the current value of the score said 
the new score value passes through the update  
72:47 - score function of the HUD Reference, make sure 
that you compile and save that and let me just  
72:52 - right click over here create a comment and this 
one is going to be update score. Again, if it's  
72:56 - not something it's not clear, but this should 
be self explanatory because this is not complex  
73:02 - at all. But ask in the comment below. If it's not 
clear, and I will explain it. Now we can start  
73:06 - adding all of these features in our game. And 
first, you're going to start over here with the  
73:12 - Event Begin Play. And inside of our Event Begin 
Play, the first thing that we are going to do is  
73:19 - we are going to create the HUD digit, and we are 
going to do it like this, we're going to right  
73:24 - click, and then we are going to see, say over here 
Create Widget. But before we proceed, I'm going to  
73:31 - right click on this node. And I'm going to click 
here to collapse notes. There you go. And now that  
73:37 - is collapse. I'm going to call this node create 
herd widget. Now what the hell is this collapse?  
73:44 - No. Basically, when we click in here, this is 
where the action happens inside the Think of this  
73:51 - as a function. That's the best way to explain 
it, we group nodes inside of this collapse graph,  
73:58 - so that they don't take too much space over here. 
So if I double click this, what we need to do is  
74:04 - put this place this node on the input over here 
now and when I compile and save that and go back,  
74:10 - you will see now that we can drag a note on this 
collapse graph like this. And if you're wondering  
74:17 - how I'm going back and forth, well, I double 
click this to open it over here. But in order to  
74:22 - go back, you're going to click this back button, 
which is right there. Now over here, I'm going to  
74:27 - select the BP UI HUD that we want to create. After 
that we are going to set our HUD Reference. I'm  
74:35 - going to drag the note for that. So we're going 
to set it this is the HUD Reference. There you go.  
74:41 - And last but not least, we need to add 
it to Viewport so we need to say Add to  
74:45 - Viewport And who are we adding to the 
viewport? Well we're adding our HUD  
74:52 - And last but not least drag this node on the 
output to create the output line node but  
74:58 - you can also do is Over here, right click, 
and over here you see, I can go back and I  
75:05 - can click in here instead of then I can say, for 
example, next or something like that you can see,  
75:11 - it's renamed to next meaning what is the next 
thing that we will do if you click over here, for  
75:17 - the input that says execute, you can do something 
like do or whatever. But you can see over here do  
75:23 - and then it continues the execution. So again, 
this collapse, no does he do and then next,  
75:30 - basically, you don't have to do that. But you can, 
it's not mandatory, it will not change the game,  
75:35 - it will not do anything. But you know, if for 
your own reference, if you want to do that,  
75:40 - you can. But again, this collapse graph allows 
us to group all of these inside of the single  
75:48 - graph. So instead of having three of these, so 
three of these over here, we only have this one  
75:55 - collapse graph. So the next step is to get a 
random integer. So I'm going to say random int.  
76:04 - And I'm going to right click on it and collapse 
the note. And I'm going to call this one select.  
76:10 - So this is going to be select random direction 
random start start direction. And before we  
76:18 - actually proceed on this one, we can test the UI 
widget if it works. So let me just go quickly back  
76:24 - over here, if I hit the play button, make sure you 
see over here we have this score, we don't see the  
76:29 - game over tab, or the game over panel because 
it is down there. So it's down there when the  
76:36 - snake dies, we will see it. But what you need to 
do in order to have this if you don't see it, you  
76:40 - need to drag from the blueprints, you need to drag 
the BP main game over here in the level so that it  
76:47 - is over here visible in the world outliner. If 
you don't do that, then when you run the game,  
76:52 - you will not see this score, and so on and so 
forth. So if I go back over here, now we have the  
77:00 - Select random starts direction. And what we are 
going to do over here is from the random integer,  
77:05 - I'm going to set the value to be three. 
And what I'm going to do is do us switch  
77:12 - on this int some way to say the word shits 
like this switch on integer, there you go,  
77:19 - I'm going to plug this into the input over here, 
and we're going to have 1234. And this default I  
77:28 - am going to remove so we have these from zero 
up to three. Now what's gonna happen is, if we  
77:35 - have zero, we're going to say set direction x. And 
from here, the direction x is going to be one. And  
77:44 - I'm going to copy and paste it because if we have 
one, we are going to have the set direction x but  
77:50 - this time direction x is going to be negative one. 
from two, we are going to have set directions z,  
77:57 - which is going to be equal to one and copy 
and paste it again from three over here,  
78:04 - we are going to have our direction z, which is 
going to be minus one. Simple as that. And now  
78:10 - we are going to drag all of these nodes. So 
from here, plug it in like this, and I can do  
78:16 - something like this, double click on the node. 
So now we can plug all of these nodes over here  
78:24 - in this single dot, which means over here in the 
input, we go and we get into the switch integer  
78:31 - based on the random value of 301. And three, we 
are going to select the random direction x to be  
78:37 - one, or minus one, or Z to be one or minus one. 
And after that we are going to go into the output,  
78:44 - make sure that you Compile and Save that. So now 
we can plug in this over here. And we can continue  
78:50 - the execution because the next step is to get 
our delay. So from here delay, I'm going to set  
78:58 - it I'm going to right click on it and collabs 
the nodes and this one is going to be set  
79:02 - up date delay in parentheses, Snake speed, because 
as I said, if you remember, the delay is the snake  
79:11 - speed. So this goes over here, this goes over 
here and the speed of the snake is going to be  
79:16 - point two in the beginning. And I'm going 
to compile and save that and go back over  
79:22 - here, plug this in. And as I said, this serves 
a weight as a way for us to group our nodes. And  
79:29 - you can think of it as a function, which means 
that basically, the execution goes like this,  
79:36 - the Event Begin Play begins it goes over here 
inside of this create UI widget collapse graph  
79:43 - inside it is going to create the widget, set a 
reference to it, add it to viewport and then exit  
79:49 - outside of that collapse graph. And then from 
here, when it exits, it's gonna go inside of this  
79:53 - collapse graph and execute everything in there and 
then from there, exit and I entered this one and  
79:59 - so on and so so forth. So this is what we are 
doing over here. The next step is to spawn the  
80:06 - snakes head. So over here, what we need to do is 
get the snake parts array. And I'm going to right  
80:12 - click on it and collapse the graph. And I'm going 
to call this one spawn snake head, there you go.  
80:20 - inside of this bad boy, we are first going to 
clear this array. So we are going to say clear,  
80:26 - which is basically going to remove every element 
from this array. In case we have it but we don't  
80:32 - but you know, just as a precaution, we are going 
to clear everything. And after that, we are going  
80:36 - to say over here, spawn new snake part. There you 
go. And I'm going to plug this in over here. So  
80:44 - it's going to pause, spawn the snake part, and I'm 
going to click here is head to denote that it's  
80:49 - a head, the spawn location can be 000. And over 
here, now this goes over here, so that execution  
80:56 - flow continues. And next we are going to spawn 
our food. And in order to do that, I'm simply  
81:04 - going to right click over here and say spawn food. 
Now we can leave it like this. But since we are  
81:10 - doing these collabs graphs, just to you know, 
be consistent, I'm going to put it in the graph  
81:15 - and I'm going to say spawn, first food, there 
you go, double click it. This goes over here.  
81:23 - And this goes over here, and I can Compile 
and Save that. And if I go back, plug this in,  
81:28 - there you go. I can compile and save this as 
well. And we can test this spawn first food and  
81:33 - snakeheads if I go back, if I hit the play button, 
there you go. So over here we have our food.  
81:42 - And you can see the food is changing also. 
But for the snakehead, let me just go back  
81:47 - quickly over here, spawn snake had. So over 
here spawn new snake, it's a head and we left  
81:56 - everything as is so basically 000 snake parts 
array. Let me just double click this bad boy.  
82:04 - spawn new snake part at the location. Okay, 
so this is what I've missed. As you can see,  
82:11 - from here, I didn't drag the execution to this 
to set it the flipbook stupid, stupid. I know.  
82:18 - But as I said, there we go. So this will fix our 
issue. So drag the node from here to here. This  
82:25 - is what I forgot, then you probably saw that then 
you were like, stupid teacher. And yes, I am. But  
82:32 - as I said, anyways, there you go. So let me just 
Compile and Save that we can go back out side  
82:38 - of here now and Compile and Save again, compile, 
then save. If I go back and hit the play button,  
82:45 - we should see the snake as well. Here it is. This 
is our sneaky, sneaky sneaky. And we also have our  
82:50 - foodie foodie foodie. And there you go. Of course 
the snake will start moving, but at the moment,  
82:55 - it will not start to move because we still didn't 
program that but every single time we click the  
83:00 - play button, they are going to be spawned within 
these bounds because that's why we have the  
83:07 - maximum x and the maximum if I go back the x max 
and the Z max. So that is for the to put them  
83:16 - inside of these bounds. Anyways, moving forward. 
The last part over here is we are going to right  
83:24 - click and I'm going to create a for loop and 
every single time I write for a loop with two O's,  
83:30 - so for loop not for each loop but for loop, 
right click collapse and know that this one  
83:34 - is going to be spawn walls and double click it. 
So what's gonna happen is I'm going to plug this  
83:41 - in like this, the execution goes over here, the 
first index is going to be zero so we're going  
83:48 - to loop from zero. But next what we are going to 
do over here and I'm going to put this over here,  
83:54 - then we will move it if there is a need to do that 
I'm going to get the x maximum and the Z maximum.  
84:01 - Now for the x maximum, what I'm going to do is we 
are going to go inside of our division hole and  
84:08 - remainder I'm going to copy and paste it because 
we're going to need it for the Z maximum as well.  
84:14 - So the x maximum is going to go eat to the 
dividend and the divisors value is going to be 50.  
84:22 - And basically these can go a little bit away 
from here something like this. So dividend  
84:27 - is the x maximum divisor is 50. We explain 
what this is. Next here for the return value  
84:33 - we are going to say multiplied with integer. 
Now what we are going to multiply is we are  
84:40 - going to multiply the return value from here so 
this goes over here, and this goes over here.  
84:47 - And also z maximum goes into the dividend 
and the divisor is going to be 50 as well.  
84:54 - So what's gonna happen next is from 
here I am going to say minus into  
85:01 - And the value is going to be one, so I'm going to 
subtract it from one and that is going to be our  
85:06 - last index over here. And I can move this a little 
bit over here. So what's happening over here  
85:12 - basically, for our what's happening for the last 
index, or how many times you're going to loop is  
85:20 - we are taking the x maximum and z maximum, we are 
setting them to be dividends, and the divisor is  
85:25 - 50. And you know, I told you that the return value 
is returns the number of times divisor would go  
85:31 - into the dividend. So if the divisor is 50, and 
the dividend is 200, for example, divisor will  
85:38 - go four times into 200. Because 50 and 50 is 150 
is 150, and 50 is 200. That means four times 50  
85:46 - can go into 200. And what's remaining is zero, 
this goes until what's remaining is zero, or the  
85:53 - number that has remained is not the divisor bowl 
with the divisor. Because for example, if we have,  
86:00 - let's say, 210, and we use the divisor 50. So how 
many times 50 goes into 210, it goes four times,  
86:09 - because four multiplies by 50 is 200, what's 
left, it's 10 1050, cannot go into 10. So that's  
86:16 - not possible. So there, this operation will stop. 
From here, we are doing the same thing for the Z,  
86:22 - and then we're using and we're multiplying these 
two values, the return values and subtracting one  
86:27 - from them. And we're setting that as the last 
index. Now, what's gonna happen over here  
86:33 - is that we are going to move the output a 
little bit over here, what I'm going to do is,  
86:41 - I am going to take this index from the loop, 
and we are going to divide an integer. And the  
86:48 - integer that's going to be divided by this 
number, or this number is going to be divided  
86:53 - by the return value from here. So I'm going 
to plug it in, so the return value goes there.  
86:59 - Also, what we are going to do is from here 
from this pin, actually, from the return value,  
87:07 - that is from the return value over here for the x 
maximum. And let me just move this over here, move  
87:14 - these two over here so that we can see clearly 
what they're doing. So from here, I'm going to  
87:18 - say minus integer. And the number that we're going 
to use to subtract from it is going to be one.  
87:26 - And from here, I'm also going to take the index 
and I'm going to use the modulus. So this is  
87:33 - modulus which is basically the same operation 
as this one over here for the division. And the  
87:38 - divisor is basically going to tell us how many 
times this number goes into this number over  
87:46 - here. So how many times and we are going to set 
the return value from here. So basically, how many  
87:52 - times the return value from this value is going 
to go inside of the index. There you go. Now,  
88:01 - also, what we are going to do from here 
is again, we are going to subtract,  
88:05 - so we are going to see minus integer, and the 
value that we are going to subtract is going to be  
88:10 - one. So what we are going to do with all of 
these, well, let's go here on the top, the first  
88:16 - thing that we are going to do from this one, I'm 
going to test if it's equal to from here, we are  
88:21 - setting if it's equal to zero, and from here, 
we are going to say if it's equal to as well.  
88:30 - But here we're going to test if it's equal to the 
value that we have over here. And now I'm going to  
88:36 - save or because we are going to test these Boolean 
so or if this Boolean is true, or this Boolean is  
88:45 - true, or this Boolean is true, and we're going 
to have one more, then this whole value is going  
88:50 - to be equal to true. But before we proceed to 
do that over here, I'm going to test if this  
88:56 - one is equal to zero, the one with the modulus 
operator and I'm going to plug this in over here.  
89:04 - And last but not least, we're going to test if 
these two are equal as well. So if this goes  
89:10 - over here, if they are equal, this one goes in 
the last plug in over here. And this one goes  
89:18 - inside of the condition. And that condition, let 
me just do it something like this. There we go.  
89:24 - This goes into the branch from the loop There 
go the loop goes inside of our branch and I'm  
89:30 - going to move this over here. The condition 
goes over here now. And what's gonna happen  
89:37 - next is I'm going to take the x maximum again. 
So from here, I'm going to get the x maximum.  
89:44 - Actually from here, x max on here it is get x max. 
And from here, I'm going to multiply it with a  
89:52 - float. and the value of that float is going to be 
one or actually negative one. Excuse me for that  
89:59 - for Our operation over here that we use to divide, 
we are going to multiply that with a float.  
90:10 - And that float value is going to be 100. So we're 
here, it's 100. Why it's giving me so 100. And now  
90:20 - from here, we are going to add these 
two. So we're going to say plus float.  
90:24 - plug this in over here. And this is going to be 
our value that we are going to use over here to  
90:31 - spawn actor from class. There you go. This goes 
over here. If it's true, this goes over here,  
90:40 - the execution continues in the output. But from 
here, we're going to spawn the wall blueprint.  
90:48 - Actually, the brick, excuse me, how did I name 
the block, excuse me, it's not the brick, but the  
90:55 - block. There you go. So BP block. From here, we're 
going to say try to adjust location. So we are  
91:03 - going to say try to adjust location don't spawn 
if colliding. So let me just see, try to adjust.  
91:09 - There you go. This right here specifies height to 
handle and we talked about that. So it was it is  
91:15 - going to try to adjust the location so that every 
block is pond like this right next to each other.  
91:22 - And it's not going to you know, it's don't spawn 
if it's still colliding. So basically, if they're  
91:29 - colliding with each other like this, they are 
not going to be spawn over here from the spawn  
91:34 - transfer, I'm going to split the pin structure and 
also here for location split the pin structure,  
91:39 - this one goes into the spawn exposition. 
Now we are also going to have for the Z  
91:45 - position. So over here, what I'm going to do 
is move this like this, this goes over here,  
91:50 - I'm going to get the Z maximum. And for the Z 
max, and I'm also going to multiply that float  
91:58 - like this. Going back over here with minus one, 
Next, we are going to take this value that we have  
92:07 - here from the modulus operator, and we are going 
to multiply that with a float and that float value  
92:14 - is going to be 100. Same as what we did here for 
the x above, so 100. Now from there, we are going  
92:21 - to add these two together. So we're going to say 
plus float, this goes over here. And this float  
92:29 - last but not least goes inside of the Z position 
Compile and Save that now this is probably,  
92:37 - you know too much what we did. So what's happening 
over here is that we are using the division, the  
92:44 - divisions for the whole and remainder. To set the 
last index, we explain what this here is, after  
92:53 - that we are using these operations with divide 
minus modulus and minus again, with the index  
93:02 - over here from the loop body because that index is 
the current value of the index that we have over  
93:07 - here, which is going to be divided with the return 
value from the for the z axis, it is also going to  
93:16 - be used here for the modulus for the z axis as 
well. And we're going to compare all those values  
93:23 - if this is equal to zero, if these two are equal, 
if this from here is equal to zero, and if these  
93:30 - two are equal, and we're going to plug them 
into the OR operator condition or test for the  
93:36 - boolean value, which means if this Boolean so if 
this is true, or this is true, or this is true,  
93:42 - this is true, then this whole thing is true, we 
only need one of these to be true to for this to  
93:49 - work. So that goes into the branch over here, if 
it's true, we are going to spawn the actor block,  
93:55 - and over here, the position x so the location x 
and the locations, you are going to use that by  
94:02 - using the x maximum multiplying it with the 
negative because when we multiplied with the  
94:07 - negative, we are going to spawn them over here in 
over here, because the negative values are here  
94:14 - on the edges. So that's why we're multiplying 
that with the negative same thing we're doing  
94:19 - over here. Next, we are using this value that 
we got from dividing the index with the return  
94:27 - value from the xemacs. So we're using that value, 
multiplying it by 100. And adding to it adding to  
94:35 - add this value over here. This is going to be the 
location x. Doing the same thing for the locations  
94:40 - the multiplying with the negative because we 
want to put it on the edge moving forward the  
94:45 - value we got here from the modulars we are going 
to multiply with the 100 and then add these two  
94:50 - and this one goes into the locations and of course 
from here, it goes into the output or actually I  
94:56 - don't think we need to do that. We don't need 
to add To the output, we can even break this,  
95:03 - because we don't have any more operations 
over here. So from here, we don't have any  
95:08 - more operations, this goes over here, but you 
can leave it like that it's not important. But  
95:12 - what we need to do is this. From here, we do need 
to take these walls, so we need to take the wall  
95:19 - block array. And from here, we need to say 
ad, which is going to add every single time  
95:27 - this new block that is created. And no, that's not 
what we want. This goes over here. There we go.  
95:33 - And this goes over here, Compile and Save that. 
And from here, you can go in the output. But as I  
95:38 - said, you don't have to do that, because we don't 
have an output. We don't have any more executions  
95:45 - going from here. But I mean, you can leave it 
like that it's not important at all, it will not  
95:51 - affect our game. But what's important is that we 
do this, as you can see, we need to take the wall  
95:56 - blocks array, and every single time we create 
here, a new block actor, we need to put it inside  
96:01 - of this array, because later on, we're going to 
test if the snake is colliding with those blocks  
96:07 - by comparing them to the position of every 
block in the array, we will see that later on.  
96:12 - So Compile and Save that then make sure that from 
here from the spawning for his food, you plug the  
96:17 - execution order over here. As I said, this is not 
important, this other execution order over here.  
96:24 - So this one, it's not important, but you can, 
you know, leave it like that it's not important.  
96:30 - Going back, we can go here in the gameplay, 
if I hit the play button. Now there we go.  
96:36 - And thanks to this pay attention over here, let 
me just try to use shift and f1 to eject myself.  
96:45 - And if I come close, you will see that these 
blocks are not colliding with each other, they are  
96:50 - exactly put together on like their, you know, like 
this, I don't know how to explain it. So they're  
96:58 - exactly right next to each other, they're 
forming a whole view over here or a whole,  
97:06 - there's no space between them. But they're 
still not colliding with each other, which  
97:10 - This over here is going to help us achieve that 
what we said try to adjust location, don't spawn  
97:16 - if still colliding, there you go. So we can try 
this one more time. So Compile and Save that just  
97:22 - so that we can see it actually works. If I hit the 
play button, there you go. So these are the walls  
97:28 - that are going to be the bounds where the snake 
will be able to move. And if it hits those bounds,  
97:34 - then well, the snake is going to die moving 
forward. Let us go back here in our main game.  
97:39 - So now we have everything over here set up, I 
can select all of this here. And we can put in  
97:43 - a comment like initialize game or something like 
that. And every single time I make a mistake, so  
97:50 - it's lowercase a even though that's not important, 
but I'm crazy. And I have to you know, redo it  
97:55 - anyways, moving forward, I'm going to right click 
over here and we are going to search for our tic  
98:01 - event. And why well, because in the TIC event is 
where the magic is going to happen. First things  
98:08 - first, we are going to get our is dead. So we 
are going to get it and right click and collapse  
98:15 - the notes. And over here, we're going to call 
this one check for that collision or actually  
98:22 - condition one, there you go. From here, what 
we are going to do is you're going to take our  
98:29 - is that variable and we are going to go inside of 
a branch. And I'm going to plug this in over here.  
98:38 - And then what we are going to do is you're going 
to plug in both of these true and false in the  
98:44 - output. So it goes over here and it goes over 
here. So now we have true and false. And what  
98:51 - we can do is over here you can change these names 
for true you can say is that for example and for  
98:58 - false, you can say is not that so that when we go 
back now over here, pay attention so I can plug in  
99:06 - and now we have two execution orders that we can 
use. So we have is that and is not that meaning  
99:15 - when we check over here the condition is that 
if it's true, it will return over here true. If  
99:20 - it's false, it will return over here false. So we 
have two ways if it's true, if the player is dead,  
99:26 - we can do whatever we want over here if he is 
not that we can do whatever we want over there.  
99:34 - So what we are going to do, well we are going 
to and let me just move this a little bit down  
99:40 - then we can move it up again just so that 
we can then more clearly see these notes.  
99:45 - First I'm going to get the input r so let me 
just find it over here. Where is the R button  
99:52 - rrr Here it is. Now what we are going to 
do with the R button is we are going to  
100:00 - Create a sequence. But for that we are going to 
actually not a sequence but a collabs graph. But  
100:05 - for that, we're going to get a gate. And for here 
for this gate, I'm going to collapse the node and  
100:11 - I am going to call this one restart sequence. 
There you go. Now what we are going to do is  
100:18 - we are going to have when we entered the gate, so 
we're here we are going to have when we enter and  
100:23 - when we have opened the gate. So over here, as you 
can see, enter and open Compile and Save that. So  
100:30 - now what we are going to do over here, and let 
me just go back is that if the player is that,  
100:37 - we're going to go over here to enter in the 
sequence, or basically enter in this gate.  
100:43 - And when we are going to open the gate is when 
we press the R button, but let me just move this  
100:48 - a little bit up, and our button is here. And when 
we press the R button, we are going to open this  
100:54 - gate. So again, as you can see over here, when 
the player is that we are going to go and enter  
101:00 - inside of the gate, when do we open the gate when 
we press the R button. Now what does that mean?  
101:08 - This gate, if I hover over allows for opening 
and closing a gate to control the execution flow.  
101:16 - When we enter the gate, it doesn't mean 
that we will execute what's after over  
101:20 - here only when we open the gate, then 
it then that is when we are going to  
101:28 - that is when we are going to execute what's over 
here, but we cannot open the gate if we don't  
101:33 - enter it. So we are gonna enter the gate when 
the player dies. We know over here we tested this  
101:38 - condition. So if the player is dead, we are going 
to enter this gate. But we only open it when we  
101:45 - press the R button before we open it, it will not 
do anything. And even if we try to open it without  
101:50 - entering the gate, it will not work. So think 
of this as a control for the execution flow.  
101:57 - So what's going to happen when we enter and 
open the gate from here we are going to do once.  
102:04 - And the name says it all output fires only the 
first time the node is hit, but can be reset.  
102:11 - What's important over here is that we 
know that this will only execute once  
102:15 - so we can only press the R button once to 
execute everything that is over here. Which  
102:20 - means now we can take the HUD Reference. 
And from here I can remove from parent.  
102:28 - So we can remove from from parent this widget. 
There you go because we already have one.  
102:33 - And actually, when we start the game are going to 
create a new one. So that's why we can remove the  
102:38 - old one from our from the current parent. Next, 
what we can do is we can get the current level  
102:46 - name. And this is going to give us the name of the 
current level we are in because we want to reload  
102:52 - that same level. And next we are going to 
open the level. So we're going to say open  
102:58 - level here. And I'm going to plug this in over 
here. And last but not least plug this in over  
103:04 - here and it is going to convert because this 
returns a string and over here we need the name.  
103:09 - So this is going to convert a string to a name 
value the output we don't need to touch it because  
103:16 - well, there is nothing more that we are going to 
do over here. Basically if the player is dead,  
103:21 - and then we just go back. So if the player is 
that this is only what we are going to execute  
103:26 - when the player presses the R key, he is going to 
restart the game same as what we saw in side of  
103:33 - our preview, when I say the preview, I mean the 
preview of the game when we first started it. So  
103:38 - there you go, this is what's gonna happen here. If 
the player is not that what's gonna happen First  
103:44 - things first, we are going to wait and in order 
to wait we are going to get the delay from here,  
103:49 - I'm going to right click and collapse the nodes 
and this one is going to be called wait. And  
103:55 - what's gonna happen is we are going to call the 
delay function. So over here called the delay,  
104:01 - this goes over here and the duration is going 
to be the delay itself or the value of the delay  
104:07 - when it's completed. We are going to go here 
in the output meaning we are going to continue  
104:12 - the execution order and what did I do over 
here let me just go back there you go. So,  
104:20 - if the player is not that we are going to wait for 
the specified time that we just saw for our snake  
104:29 - and when we wait after that, what we 
are going to do is we are going to go  
104:34 - inside of sequence now what is a sequence so 
how did I read it see Quinn's There you go.  
104:42 - Now what is the sequence first I'm going to right 
click and collapse the node and this one is going  
104:46 - to be sequence one. What's going to happen over 
here is that we are going to enter in the sequence  
104:53 - and we are going to put put this over here and put 
this over here and what we are going to say over  
104:59 - here for them Zero, we are going to say do first. 
And for the den one, we're going to say do second.  
105:07 - Now a sequence, if I hover over, it says executes 
a series of pins in order, meaning it will first  
105:14 - execute this over here. And then it will execute 
this over here. And if we have more pins, you can  
105:19 - click here plus to add more pins, then it will 
execute the other pins in order. In this case,  
105:24 - what we did over here is that so this goes 
over here like this. First, we will do what's  
105:31 - in this sequence. And then we will do what's in 
this sequence. And whatever we put over here,  
105:36 - it will not be executed. Until this first one 
over here finishes, because is the first one.  
105:42 - So what's going to happen is that we are going 
to let me just Compile and Save that first,  
105:47 - I'm going to get the snake parts array, 
and I'm going to right click on it collabs,  
105:52 - the node and this one is going to be called 
check head self collision, this is basically  
105:58 - going to check if the snake collides with its 
own head. So what we are going to do over here,  
106:06 - for the input output, we're going to move a 
little bit away because over here, I'm going to  
106:10 - right clip, right click, and I'm going to see for 
each loop with the break. Now what is the break,  
106:17 - this goes over here, by the way, the array 
goes over here, break is we can call break,  
106:24 - to break out the loop. So it doesn't matter. 
For example, if this snake parts has, you know,  
106:28 - 30 elements, that means the loop will loop 30 
times, we can call break to break up that loop  
106:35 - on the I don't know, let's say 10th loop, so it 
doesn't have to loop 30 times if we find what we  
106:42 - need. Now how does that work? Well over here, 
I'm going to create a custom event. So Custom  
106:47 - Event. And I'm going to call this bad boy brake 
self collision test loop. And simply from there,  
106:56 - we are going to plug this in over here in 
the brake and there we go. So when we call  
107:01 - this custom event, it is going to break out of 
the loop. So what's going to happen over here  
107:10 - is going to happen that output when this 
completes, we are going to plug in the  
107:15 - output so when it completes, this is going to 
go in the output meaning we are going to go let  
107:20 - me just Compile and Save that we are going 
to go and continue the execution from here.  
107:26 - But what's going to happen in the loop body first 
in the loop body, we are going to go inside of  
107:32 - our branch. And the condition for the branch is 
going to be the array index and I'm going to test  
107:39 - if it's not equal to zero. So if the index is not 
equal to zero, that's going to be our condition.  
107:46 - Now the reason for that is because while for 
the first head, we cannot check if the head is  
107:50 - colliding with itself because the snake has a 
head then it has you know the body like this.  
107:56 - So there you go, there you go, there you go. 
We can we cannot check if this head collides  
108:01 - with Excel because it's not possible, we only can 
check if it collides with one of these body parts.  
108:06 - So what's gonna happen over 
here is from the array element,  
108:11 - from this array element, I am going to get 
the actor location like this. And I'm going to  
108:17 - move this over here and get it like this. There 
you go. So we will need our accurate location,  
108:24 - we will also need our snake Bart's array from 
here and we are going to get so we're going to  
108:32 - get a copy and we're going to get the element 
that's an index zero meaning that's the head  
108:37 - of the snake. And from the head of the 
snake, we are going to get the actor  
108:41 - location like this. So we have now two locations. 
Again over here this is going to execute,  
108:49 - the branch is going to execute only 
if the index is not equal to zero,  
108:54 - so we can rest assured that the array element we 
get over here, and the actor location is not the  
109:01 - location of the element that's at the index zero 
meaning not the location of the head, but over  
109:05 - here we're getting the location of the head. And 
why do we need that? Well, now I'm going to equals  
109:11 - equals test these two vectors if they are equal 
with the tolerance 0.001 meaning do they overlap  
109:19 - is the head of the snake. So for example, this 
is the head of the snake, this is the body  
109:23 - this is the Body Body buddy buddy, buddy buddy 
body so on and so forth. And this is the head  
109:30 - so we can test if this location of this head 
is for example same as the location of this and  
109:35 - that can only happen if like this. So this is the 
head of the snake and the snake goes for example,  
109:40 - like this, as you can see and then down over 
here or here, over here, over here and over here  
109:48 - and over here. So over here is where the head 
would collide with one of the body parts and this  
109:54 - is what we are doing. So if this is true, we are 
going to go inside of another branch and inside of  
110:00 - this branch, we are going to test or plug in this 
condition, meaning we are testing if the body part  
110:06 - that is at the current index does it collide 
with the head of the snake. If that is true,  
110:13 - then we are going to go over here and we are going 
to call kill snake event, which we already know we  
110:19 - created this in the previous video. So here it is, 
our custom kill snake event which is going to set  
110:26 - is that the true for each loop is going to go 
here and we explain everything what is going  
110:30 - on. So kill the snake. Next, we are going to get 
the HUD Reference. And from the HUD Reference, we  
110:37 - are going to call the game over event. And we know 
that our game over event in the HUD Reference,  
110:43 - if I double click it, it's over here, it's going 
to set the visibility to visible to the game over  
110:48 - text and the restart text. And it's going to play 
our animation that we have previously created that  
110:53 - we also explained. And last but not least, if this 
needs to loop 30 times, for example, as I said,  
111:02 - if the snake has 30 body parts, and this leads 
to loop 30 times, but the head is colliding with  
111:07 - let's say the 10th element in the array. Well, 
we don't need to loop anymore. And what we can  
111:13 - do is we can simply break out of the self. 
So break self, re, self, how did I name this?  
111:26 - Brett, I said the bake. So it's break. There you 
go. So break self. Again, let me just go over here  
111:33 - break self self collision test loop. And this 
is pretty self explanatory. So this is going to  
111:43 - call this Custom Event over here, which is going 
to simply break the loop and it's going to stop  
111:48 - looping, Compile and Save that. Now there is no 
need to explain this, again, what is happening.  
111:55 - So if something is not clear, as I already 
explained everything, you can rewind and see,  
112:00 - if it's not clear, something is not clear, 
make sure that you ask in the comment below.  
112:03 - But over here when all of this happens. So 
if we make a test, and none of these is true,  
112:09 - so this over here, it's not true. So we don't 
go inside of this condition, then the loop will  
112:13 - complete then it will go over here in the 
output. So this output now I can go back  
112:21 - in the main event over here. So this output 
now goes from here, now what we are going to do  
112:27 - is I'm going to get the wall. So wall block array. 
So now we are going to test if we are colliding  
112:33 - with the wall, meaning all of those bounds that we 
have over here. So if we are colliding with these  
112:39 - bounds that are set over here that we saw a moment 
ago, but I'm going to right click on the wall and  
112:44 - collapse the node and this is going to be check 
head wall collision. And notice I'm only checking  
112:51 - with the head because it's not possible for the 
body parts of the snake to collide. Now the output  
112:58 - over here, we do not need it, because we are not 
gonna do anything else over here. So what's gonna  
113:04 - happen here, again, we aren't going to have a 
for each loop with a break. And execution goes  
113:13 - over here, the array that is going to be looped 
over is this one wall blocks array. And again,  
113:20 - we need to create another Custom Event. So 
custom event, and this is going to be break wall  
113:27 - collusion test loop, and this one is going to go 
inside of the break. There you go. So Compile and  
113:36 - Save that we're basically going to do the exact 
same thing we did a moment ago for the for the  
113:43 - wall, except what we did is for the snake. 
So over here, we're going to take the snake  
113:50 - parts array and we are going to get the element 
that's at index zero meaning the head so get,  
113:55 - and is going to get over here see this is the 
index here. If I hover over given an array,  
114:00 - and an index returns a temporary copy of the item, 
and over here, as you can see the index is zero  
114:05 - meaning the head is the first element then from 
here we're going to get the actor location. Now  
114:11 - over here, we're not going to test if the array 
index is not equal to zero because we can collide  
114:16 - with any wall part. There is no wall part that is 
an exception over here. So from the array element,  
114:22 - we're going to say get actor location. And 
over here now we are going to test these two.  
114:29 - So what's gonna happen first, let me just move 
these a little bit back so that they are something  
114:34 - like this close to each other. I'm going to test 
equals equals with a tolerance over here 0.001 As  
114:42 - you can see, and that means we have collided with 
the wall, which means over here, the loop body  
114:48 - goes in a sign of a branch. There you go, and this 
is plugged in over here. So Compile and Save that.  
114:56 - So now if this is true, basically Everything 
is going to happen same as what we did before.  
115:02 - So over here, we're going to kill the snake. 
Next, we are going to get our HUD Reference.  
115:11 - And from there we are going to say Game 
Over event. And last but not least,  
115:17 - we are going to break outside of the loop. 
So we're going to call break wall collusion,  
115:22 - test loop, and output can stay over here. 
Now again, the only difference between this  
115:28 - what we did over here and what we did over here is 
that over here, we're testing if we are colliding  
115:33 - with the head of the snake. But over here we are 
testing. If we are colliding with any of the wall  
115:40 - elements, as you can see wall block, were getting 
that array element, its location, if the location  
115:46 - matches with the location of the snake head, if 
that is true, kill the snake Game Over event,  
115:51 - so on and so forth. Everything else you already 
know, we already explained, then over here, the  
115:57 - execution continues. So make sure that you Compile 
and Save that if something is not clear, make  
116:02 - sure that you ask in the comment below. Moving 
forward in the second sequence over here do next  
116:08 - or do second, excuse me, we are going to perform 
a check again, if the snake is dead. So over here,  
116:13 - I'm going to right click collapse nodes. And this 
one is going to be check that condition to and  
116:22 - this goes over here, double click it and simply 
we are going to go in a branch which we know is  
116:28 - a true or false statement. So over here, we're 
going to plug this in. And only if it's false,  
116:36 - it is going to go over here. And what I'm going 
to do is I'm going to say not that like this,  
116:40 - and we can Compile and Save this bad boy. So the 
next step is to so this goes over here like this  
116:50 - and moving forward. Next, we are going to go 
in a sequence again. So right click over here,  
116:57 - sequence search for a sequence, right click on 
it to collapse a node, and this one is going to  
117:03 - be our sequence to double click it and it goes 
like this, these two go in here. So let me just  
117:14 - go and click here, then we are going to say do 
first same as what we did before. And over here,  
117:21 - we're going to say do second, and Compile and 
Save that. Let's go back, and this goes over  
117:28 - here. So again, we have a sequence. If the 
snake is not that, notice that here we have  
117:34 - not that condition. And over here. We also have 
the knots that condition but we also have the  
117:40 - is that condition for the snake as you can see. So 
moving forward, what's gonna happen inside of this  
117:47 - sequence now? Well, in this sequence, we have 
a couple of things in the first one that is.  
117:52 - So for the first one, I'm going to right click, 
and I'm going to create a branch. And I'm going  
117:57 - to right click on the branch and collapse a 
node and this one is going to be check had food  
118:03 - collision and you got it right, this over here is 
going to check if we have collided with the foods  
118:10 - for our snake and it goes like this, so 
Compile and Save that input goes in the  
118:15 - branch and the condition for the branch 
is going to be from the snake bites array.  
118:20 - So from the snake parts array, we are going to get 
the element that's at index zero meaning the head  
118:27 - of the snake and we are going to get the location 
of it. So we're going to say get actor location.  
118:34 - There you go. Next, what we need to do is we 
need to get a reference to the food actor.  
118:40 - So here is our food actor, we can only have one 
food actor in the game at any given moment. So  
118:45 - we only have one and we are going to get the 
actor location as well, for the food actor  
118:51 - like this. Now we are going to test these do so 
equals equals and plug this in but over here,  
118:59 - this time the tolerance is not going to be 0.0001 
instead of that the tolerance is going to be one  
119:06 - if I hover over returns true if x vector is equal 
to vector b within a specified error tolerance. So  
119:13 - this one so one unit is the specified tolerance 
that we well specified. So that's like you know,  
119:21 - one one unit or one centimeter in Unreal Engine 
in Unreal Engine measurements. So if it's true,  
119:31 - we are going to plug in over here the execution if 
it's false, we are not going to plug in so if it's  
119:37 - false, we're not going to do anything but output 
goes only if it's true what we're doing again,  
119:41 - we're getting the element that's at either zero 
we know that's the head of the snake, getting the  
119:46 - location of the head of the snake, getting the 
food actor and its location do their location  
119:52 - match with one centimeter or one measurement unit 
of Unreal Engine tolerance. If that is true, then  
119:59 - Go into the output, make sure that you Compile and 
Save that. So this goes over here like this. So  
120:06 - only if it's true the next step what we are going 
to do, and I'm going to take these two inches  
120:12 - mobilebet down so that I can move these over here. 
The next step is we are going to update the game  
120:19 - score. So what I'm going to do is I'm going to get 
my actually we are going to get the food actor,  
120:27 - here it is, and right click on him and collapse 
the node and this one is going to be update score.  
120:34 - So actually is going to be update games course 
excuse me for that one, because we already have a  
120:38 - function name or an event custom event name update 
score. So update game score, it goes like this.  
120:47 - What's gonna happen with the food the actor, 
we are going to get the score. If you remember,  
120:51 - the food actor has its own score, if I double 
click it, so can I double click it to open it in  
120:57 - the foot doctor, apparently not for some whatever 
reason, but here it is, we have this score,  
121:01 - and we set it over here we talked about that, she 
can rewind those videos if you need a refresher.  
121:08 - So now from here, we are going to right click 
and we're going to get the update score.  
121:15 - And this goes over here, and the score value goes 
over here. And this goes over here. There you go.  
121:23 - So this is going to update our score again, you 
can double click this function and go over here  
121:27 - and see what it is doing. It is taking the current 
value over here the score, adding it to the score,  
121:33 - setting the score over here and then passing it 
to the HUD Reference so that we can actually have  
121:38 - our score. But this only happens again, this only 
happens if this is true. So if we collide with the  
121:46 - food actor, because if we don't collide with 
the food actor, of course, we are not going to  
121:53 - update the score. Next, now that we have 
collided with the food actor updated the score,  
121:59 - we are going to destroy the reference to the food. 
So we're going to get the food actor and I'm going  
122:03 - to again collapse the node and this is going to be 
this truly correct current food. Because we picked  
122:10 - it up, we don't need it anymore. So from here, we 
are going to call these Troy actor. There you go,  
122:17 - this goes over here, the plugin goes over here and 
this is plugged in over here. Again, we picked up  
122:24 - the food, there is no need for us to have that 
food anymore in our game, because now we are  
122:30 - going to create a new food so destroy the current 
one. Let's go back, this execution goes over here.  
122:37 - The next step for us is to spawn a new snake part 
because the snake if it's this big, for example,  
122:44 - and it eats a new food, it go it grows bigger. 
So for that we are going to get our snake parts  
122:52 - array, right click on it and collapse the node. 
And this one is going to be spawn new snake part  
123:01 - spawn snake. So we're going to say spawn snake  
123:08 - new part like this, because we already have spawn 
new snake part, apparently. So here we have our  
123:15 - snake parts array, what we are going to do is we 
are going to get over here, but we're not going  
123:24 - to get that element that's at the first index 
instead. From here, we're going to say last index,  
123:30 - and this is going to return the last index of our 
snake meaning the element that's at the last place  
123:36 - inside of our snake. And the reason for that is 
because we need to get the location, so get actor  
123:43 - location, we need to get the location of the last 
part of our snake so that we can call over here  
123:50 - our custom event spawn new snake part as you can 
see. So from here, this is plugged in over here.  
124:01 - And we can do something like this. This goes over 
here, this goes over here, this goes over here.  
124:07 - And this goes a little bit over here, just so 
that we can clearly see it. So this is going  
124:13 - to be plugged into the spawn location. Of course 
it's not a head because we're spawning a new snake  
124:19 - part. And notice here the beauty of this. So as 
I said we're spawning a new snake part it needs  
124:25 - to go at the end of the snake. So this is the 
snake's head Part Part Part Part snake eats this  
124:32 - food we are spawning a new snake part over here, 
which is the last element. So what we are doing,  
124:37 - we are getting the last index gets the last 
valid index in this array, we are getting that  
124:43 - and then we're getting the location of that actor 
and we are putting that as a spawn location here  
124:48 - in our snake bar because we know that we're 
going to use the location to actually spawn  
124:55 - so we're using the location to actually spawn 
that snake part. So Going back over here,  
125:01 - this execution continues here, spawn snake 
bar response snake new part. Moving forward,  
125:09 - we already know that we have destroyed our food, 
which is over here. So we need to spawn a new one.  
125:14 - So we're going to right click over here, we're 
going to say spawn food, this is going to spawn  
125:19 - a new food, we can connect these right away. 
But in order to follow what we did so far, with  
125:24 - the collapse graphs, we can simply right click on 
it, then we can see spawn new food, there you go.  
125:32 - And this goes over here like this, and this goes 
over here, like this. And we can go back and now  
125:39 - we can plug in the execution. But as I said, we 
can directly do that on the, on the custom event,  
125:45 - as well. so we can directly do it. But just you 
know, because we are having all of these collapse  
125:50 - notes. Well, we can follow it over here as well. 
The last step that we need to do over here is to  
125:56 - speed up the snake. And for that, we're going to 
get our delay and right click on it and collapse  
126:01 - the node and this one is going to be speed up 
snake. And what's going to happen over here,  
126:07 - now we have our delay, I am going to go over here 
and I'm going to say minus or actually plus float,  
126:16 - and the value of the flow that we are going to 
add to our snake is going to be negative 0.01. So  
126:23 - we're actually going to subtract from it. And over 
here, we are going to say set the delay. So this  
126:30 - goes over here, and this goes a little bit over 
here, because we are going to get our clamp float.  
126:39 - There we go, we are going to clamp this value that 
we get over here. And the minimum can be 0.0 75.  
126:49 - And the maximum is going to be 0.2. And this goes 
over here and this goes over here. There you go.  
126:57 - So Compile and Save that this is going to actually 
speed up our snake. So this is going to speed up  
127:05 - our snake because the delay is how much we are 
waiting. And when we have a lower value, we are  
127:10 - waiting less, which means the snake will move 
faster. So again, what we are doing is over here  
127:16 - for the output, we don't have to do this, we don't 
have to have the output because this is the last  
127:21 - collapse node in this line of sequence that we are 
going to execute. So taking the delay subtracting  
127:27 - from 0.01 value clamping that value, which is not 
going to allow us to go below the minimum which is  
127:33 - 0.0 75. And it will not allow it to go above the 
maximum which is zero point to set that value over  
127:42 - here into the delay and there you go. But we 
also need to plug in this execution over here,  
127:48 - so that it actually executes. So this is 
our do first sequence. So we are testing  
127:54 - for the head collision, updating the score, 
if we have the head collision with the food,  
127:59 - updating the score, destroying the current 
food, spawning a new snake part destroying,  
128:04 - or actually creating a new food and then speeding 
up the snake we explain everything what it is. But  
128:09 - in case if something is not clear, just make sure 
that you ask in the comment below. Moving forward,  
128:14 - there are only two parts left in our game. And 
they're going to happen over here do seconds. So  
128:19 - from this sequence, right click over here, 
and we are going to create a new sequence.  
128:24 - And I'm going to right click on this sequence 
and collapse the node and this one is going to be  
128:29 - check inputs. So we are going to check for the 
input. If we press the button to move the snake  
128:35 - and then we are going to move that snake so we're 
actually going to move the snake afterwards.  
128:40 - So let me go back over here, this goes over here. 
And there you go. So inside of our check inputs,  
128:47 - we are going to have 01, then two, then three, 
and then four of these sequences. On the fourth  
128:56 - sequence, we are gonna go in the output from zero 
to three, we are going to check for the input. So  
129:03 - we are going to check for the input for when up 
is presence on and so forth. Let me just go and  
129:07 - do my thing. So what we're going to do is right 
click over here and we are going to create a gate.  
129:12 - And this gate is going to be controlled with the 
input up. And over here. This is what we want.  
129:20 - So this goes over here in this gate. And let me 
just double click this bad boy, this goes like  
129:26 - this, and this goes over here. And probably 
we will need to move a little bit upwards for  
129:32 - other sequences to have place to you know stay 
to be visible. So we're here this is our first  
129:40 - so when we press the up button on our keyboard so 
when we press it, we're going to open the gate.  
129:45 - When we release it we are going to close the gate. 
Now, another thing that you can do is you can go  
129:51 - into the project settings in the input and over 
here in the action mappings you can create your  
129:57 - own action mappings if you want to move the 
snake And the W key on other keys, whatever,  
130:03 - but you will have to create your own action 
inputs. Because currently by using this over here,  
130:08 - we are only going to move the snake when we press 
the up arrow key on our keyboard. If I hover over  
130:13 - you see events for when the up key is pressed, 
or released. So this is the up arrow key on the  
130:20 - keyboard Anyways, what we are going to do when we 
enter this sequence, which is this one over here,  
130:27 - so do second, we're going to check in the inputs, 
and we are going to go in this in the sequence,  
130:32 - this sequence the sequence, this sequence is 
going to check if when we enter, so we're going  
130:36 - to enter this gate, and I open the gate, the gate 
implementation, but we don't need that anyways,  
130:44 - when we enter the gate, we're going to wait if we 
press the up arrow key, and when we release it,  
130:50 - when we press it, we are going to open the gate 
and execute what's over here, when we close the  
130:54 - gate, all the execution stops. So what's gonna 
be executed over here? Well, we are going to go  
130:59 - inside of a branch. So when we press the up arrow 
key, we're going to go in the branch. And what we  
131:05 - are going to test over here is the direction z. 
And we are going to test if that is equal to zero.  
131:11 - So over here, testing data if it's equal to zero, 
and from here, we just say, and so we're going to  
131:17 - test to Booleans. If direction z is equal to zero, 
and get can change direction. So if we can change  
131:26 - direction, and the direction z is equal to zero, 
that goes over here plugged in as the condition  
131:34 - if that happens, if it's true, we are going to 
set the direction x to zero. And we're going  
131:42 - to set the direction z to one, there you go. And 
last but not least, after that we are going to set  
131:52 - here can change direction, we are going to set it 
and this goes over here like this. And I'm going  
132:01 - to double click this to have this line over here 
so that we can plug in all of these others. So  
132:08 - we're going to plug them in later on, because over 
here can change direction is going to be false.  
132:12 - But we're going to do for all of these for all of 
our inputs. Because now what we are going to do is  
132:19 - I'm going to copy this gate, actually, I can copy 
all of this here, I can copy it, and I can paste  
132:24 - it over here. So now this goes, execution goes 
over here. But let me just again, select them and  
132:32 - move them over here because we do have space now. 
And what I'm going to do now we have the up key.  
132:38 - Now we want the down key. So from here, I'm going 
to right click, and I'm going to input down.  
132:46 - And let me just find it over here. Here it is 
input down when the down key is pressed. And let  
132:51 - me just double click this over here and move this 
execution like this. And this press goes here,  
132:57 - release goes here, same thing, same explanation 
as what we did. And you can move this a little bit  
133:02 - further so that you can distinguish these lines 
over here. But same explanation, same everything,  
133:09 - as for this one above. But this time only when 
we press the down key, we're going to open the  
133:13 - gate when we release it, we're going to close 
it. If the direction z again is equal to zero,  
133:18 - and we can change direction. If that is true, 
both of these we can copy and paste them again.  
133:25 - And we can plug this in. So if it's true, the 
direction x is going to be zero, the direction z  
133:32 - is going to be negative one because we're 
moving downwards and down is the negative side  
133:37 - up is the positive down is the negative 
right is the positive plus and over here  
133:44 - left is the negative. And last but not least, then 
this goes over here so that we can the note that  
133:51 - we cannot change the direction currently. Next, we 
can copy this gate, so I can paste it over here.  
134:00 - And this goes over here the execution flow goes 
over here like this. Next, we are going to get  
134:06 - the input for our right key. So when we press the 
right key, so over here, I can say something like  
134:13 - input, right. And this is the one that we want 
not right alt bracket command and blah, blah,  
134:19 - blah, only where it says right, and this goes 
over here and this goes over here. There you go.  
134:26 - And I can probably do something like this, so 
it is a little bit more visually clear what we  
134:31 - are doing. So now when we have this gate, again, 
we're going to go inside of a branch, the branch  
134:38 - goes up to here, but this time instead of getting 
the direction z we are going to get the direction  
134:43 - x because now we are moving on the left and right 
side. And if the direction x is equal to zero,  
134:52 - and again, we can change direction so we're going 
to get it over here. So if the direction x is  
135:00 - equal to zero and we can change direction. If both 
of these are true. And by the way, if you're a  
135:06 - complete beginner don't know what this end means. 
It means that this over here needs to be true. And  
135:12 - this over here needs to be true. If for example, 
direction x is not zero, but can change direction  
135:18 - is true, this whole thing will be false. When this 
is true, if direction x is zero, and that is true,  
135:24 - and can change direction is true, only then this 
will return true. And this over here will execute.  
135:30 - So basically, both of these conditions needs to 
be true. So when that happens over here, we're  
135:34 - going to say set direction x and the direction 
x, we are going to set it to be one because now  
135:42 - we are moving to the right side in the positive 
side, and over here, set directions z is going  
135:48 - to be equal to zero because we're not moving on 
the z axis and this goes over here. There you go.  
135:54 - Last but not least, we can basically copy all of 
this, and we can paste it over here like this,  
136:01 - and execution goes over here, enter the gate, 
right click. And now when we right click,  
136:08 - so right click again, input left. Again, it's 
not left command Ctrl Shift, it's only where it  
136:15 - says left. So over here, pressed goes into open 
released goes into clothes. If the direction x  
136:25 - is equal to zero, and we can change the direction, 
if both of these are true, the direction x  
136:32 - is going to be negative one. And the direction 
z is going to be equal to zero. And last but not  
136:38 - least, the plug goes over here so that we can set 
that we cannot change direction. So make sure that  
136:45 - you Compile and Save that then last but not least, 
which is our last sequence, the fifth one, it is  
136:52 - going to go into the output so that we can proceed 
and you know, you can click here instead of then  
136:58 - four, you can say next, for example, Compile and 
Save that so that we can proceed and do the last  
137:04 - step, which is actually moving the snake, because 
this over here is going to only get us the input.  
137:10 - So again, I went through all of this, it 
is pretty self explanatory. It's not hard,  
137:15 - this code over here is not hard at all. 
So we're simply setting based on which  
137:21 - button we pressed either for the Z or for the x, 
we're setting it to one or negative one. That's  
137:26 - all what we are doing. But if something is clear, 
make sure that you ask in the comment below.  
137:30 - So over here, we're checking the input. And well 
the next step is to actually move the snake. So  
137:36 - in the last step over here, first we are going 
to create a for loop and create a four loop,  
137:43 - right click on it, collapse the node and this one 
is going to be move snake and this is going to be  
137:49 - used to move our snake double click this bad boy. 
And the input goes in the for loop. And I'm going  
137:54 - to save this go back over here so that I can plug 
in the execution order and go back inside again,  
138:01 - the output, we are not going to need it. This 
is the last step. So we are getting close.  
138:07 - So what's going to happen over here what is the 
first index is zero, the last index is going to  
138:12 - be our snake parts array. And we're going to 
get the length. So actually simply here type  
138:19 - Lang to actually linked with th not 
HD. Now that we have the length,  
138:27 - I am going to subtract from it. 
So I'm going to say minus integer.  
138:34 - There you go. And I'm going to plug this in over 
here. What am I doing? If I go here, Snake parts  
138:39 - array and get the number of items in the array. So 
we are getting the number of items, how many items  
138:45 - do we have, if we have 30 items, we are getting 30 
items from that array, the input can go over here.  
138:52 - And I'm subtracting one because the last the last 
index, the last element in the array is always  
138:59 - at the length minus one. So from zero up to the 
length minus one, which is the last element over  
139:05 - here, when we complete the movement, we're going 
to say set can change direction to true, because  
139:12 - if you remember a moment ago, we changed over 
here, we set it to be false. So now we need to set  
139:20 - it back to true to be able to move again. And this 
goes over here because well this is the last step.  
139:25 - So when you complete the loop can change direction 
will be equal to true. Now what is going to happen  
139:34 - in the loop body. We are going to go inside of a 
branch and I can move this over here so you can  
139:42 - more visually see this more clearly. Now what's 
going to happen over here is that I am going  
139:48 - to get the snake parts array again. From the 
snake parts array. I'm going to get the link  
139:56 - again. So getting the length last but not least 
I'm going to say minus integer, so we're going to  
140:03 - subtract from it one again. And from here, we're 
going to say minus integer again. But this minus  
140:13 - integer is going to be the index from here, or 
the current index that's being iterated. So the  
140:24 - point here is that we loop through the whole 
array and get every element that's inside of our  
140:30 - get every element that's inside of the snake. And 
from there, we are going to move that element. And  
140:37 - this is how we are going to get those elements. So 
we are going to get the snake parts that already  
140:41 - and the length of it. So length minus one, which 
is the last element. So let's say we have 10  
140:46 - elements in the array, that means the length 
will be equal to 10 minus one that is nine. Next,  
140:52 - we are going to subtract from nine, the current 
index that's being iterated that can be 012345,  
140:59 - blah, blah, blah, up to when it gets 
to the number nine, this will allow us  
141:04 - in reverse to move the snake parts. So it will 
not actually move the snake parts from the head.  
141:09 - And then the second part and the second part 
and the third part of the fourth part, instead,  
141:13 - it will remove the snake from the last element, 
then the second to last, then the third to last,  
141:19 - and so on and so forth. So this is what we are 
doing over here. So now what we are going to  
141:24 - do from here is again, I'm going to get the snake 
parts array. And from here, I'm going to see get,  
141:31 - which is going to get the element added the 
current index, which is this one over here.  
141:36 - So the index that we have calculated 
with this that I have just explained  
141:41 - next over here are going to test his head. 
So we are testing each of the elements that  
141:46 - we are getting, if it's the head that goes 
over here inside of our branch condition,  
141:52 - because we need to know which one is the head and 
which one is not the head. Now moving forward,  
141:57 - what we are also going to do is I'm going to copy 
these two and paste them over here. Because again,  
142:03 - this goes over here like this, again, we are going 
to get then what I'm going to do is move this,  
142:11 - like this over here. So again, 
we are going to get the element  
142:17 - that's on the current index, and also from here. 
So from here, again, we are going to say minus  
142:23 - integer. And we're going to subtract one from 
this value. And again, we are going to paste this,  
142:31 - and we are going to get this element again. 
So we're getting the two elements right  
142:37 - next to each other this is what we are doing 
with these two. Now what is going to happen  
142:43 - is we have the true and we have the false. If 
it's true, we have the head, we are going to  
142:50 - say over here add actor, world offset. This 
is if it's true. So this goes over here.  
143:00 - If however, it's false, then we're going to say 
set actor location. So over here, we're going to  
143:05 - say set actor, location. And here it is. This is 
if it's false. And we're going to go over here.  
143:13 - And probably we'll need to move these to just a 
little bit over here. So what is going to happen  
143:20 - right now? Well, the target for both of these 
is going to be this one. So this goes over here  
143:28 - as the target and this one goes over here as the 
target. So make sure that you plug these two in  
143:35 - correctly or otherwise it will not work. The next 
step that we were what we need to do is from here,  
143:43 - we are going to get the actor location, there you 
go. And this location, this actor location goes  
143:50 - over here. So we're going to plug it in over 
here. And last but not least here at the top,  
143:58 - I'm going to right click and split the pin 
structure and we are going to get the direction  
144:02 - x get the direction x get the direction z and we 
are going to multiply these students so this can  
144:12 - be moved a little bit over here because x will be 
multiplied with float and the value that's going  
144:18 - to be multiplied is 100. We can copy and paste 
this over here and multiply z with 100 as well.  
144:29 - And now these 2x goes here 
in the X and Z goes in the Z,  
144:38 - the location y we're not going to touch that so 
location y we are not going to touch it instead,  
144:44 - we location y stays as is. Now let me go briefly 
again what we did over here, so Compile and Save  
144:51 - that. So this is explained what we did we get the 
last element minus one we're looping that many  
144:56 - times. From here when all of this completes when 
the loop completes. When we loop through the whole  
145:01 - loop, then what we are going to do is simply set 
can change direction to true so that we can change  
145:06 - the direction again, over here we're getting 
the snake parts array, and we're subtracting  
145:10 - from it the index, which will allow us to 
get the every element inside of the array.  
145:16 - From here, we are checking if the snake 
parts are the element that's at this array,  
145:23 - this index currently, if that is the head, if 
it's true, we are using actor or add actor world  
145:31 - offset, and we are changing the actors location 
x and z by using the direction x multiplying it  
145:37 - with 100 and direction z multiplying that by 100. 
We know the direction x or z, it's going to be  
145:44 - either one or minus one for both of these. So this 
is going to be negative and positive 100 for the  
145:50 - offset of the head of the snake. Moving forward, 
and over here we are plugging in we are getting  
145:58 - the element that's this index. So we are getting 
that element that we're plugging that in over  
146:03 - here is the target and doing the same thing over 
here for this one for set actor location as well.  
146:11 - Moving forward from there, what we are 
going to do is we are getting the next  
146:17 - element in that array. So let's assume this 
over here. So when we calculate these two,  
146:24 - let's assume this has a value of 10. Over here, 
we say minus one, that means this has a value of  
146:30 - nine. So over here we are getting, as you can see, 
we are getting the element that's add the value or  
146:38 - index 10. But we are setting its location 
to be where the index that has a value,  
146:45 - nine to be that way we are moving them so that 
way we are moving them. So let's assume this is  
146:51 - the head of the snake, we're getting that element 
that's here and setting his location to be over  
146:56 - here. And this we're doing with every single 
one of these. So this one will move the location  
147:01 - over here, this one will move on the location 
over here. If we have more of these over here,  
147:06 - this one will move on this location, this one will 
move on this location, just make sure that you  
147:13 - Compile and Save this. And now we can go back 
and test it out. So if I go back into gameplay,  
147:20 - hit the play button, you will see now the snake 
is moving and bam you see when we hit on or when  
147:26 - we touch one of these walls. Well as you can 
see, we die. So we need to press the R button  
147:34 - to restart the game but it's not working. And also 
if I try to play the game again, I'm moving left  
147:39 - and right but it's not working what is happening. 
Well there is one more thing that we need to do.  
147:44 - Over here we need to select the BP main game and 
scroll down so BP main game which is in the world  
147:51 - outliner over here and scroll down and go over 
here where it says the input as you can see,  
147:58 - we need to say out to receive input not disabled 
but player zero meaning that we will receive this  
148:06 - blueprint this actor BB main game will receive the 
input if it doesn't receive the input. While you  
148:12 - saw a moment ago what will happen. So if I hit the 
play button now if we hit one of these walls, bam,  
148:19 - you see we die. Game over press R to restart the 
game via press the our game is restarted. And now  
148:24 - you see I can move the snake you see I can move it 
up, left and down. And now I have picked up one of  
148:30 - these as you can see, picked up one of the foods. 
Let's try to eat another one and bam we died.  
148:37 - So let's try again. So over here, over here, there 
you go. Let's try it one more time. There you go.  
148:46 - We are eating the food pay attention to the score 
it is moving to 100 now we have score at comma on  
148:54 - 210. Again, eating and pay attention every single 
time The more we eat the larger the snake and the  
149:01 - faster the snake is. So let's go over here and 
I don't know if you're asking me What's this  
149:06 - in the middle this like I don't know this over 
here. I don't know what that is maybe some kind of  
149:11 - glitch, whatever. It's not important if somebody 
knows just tell me so 580 680 and now I can even  
149:18 - move the snake a little bit faster and better and 
more clearer. If you have issues with the control  
149:25 - in the beginning that's because of the delay. 
So you see the lower the delay is the faster  
149:30 - the snake is and the better control over it the 
we have. So there you go. And notice now when I  
149:37 - die with the snake It doesn't matter if I hit 
the wall or if I actually hit the snake body.  
149:44 - You see you saw how the snake like this appeared 
in an animation. Well that animation is if we go  
149:51 - if we go let me just see where it was over 
here. flipbook actually it's in the kill snake.  
149:57 - So let's go over here. Let me just find kill 
snake, here it is. So these are the flip books  
150:05 - that we are using our animations, we explain how 
you can create them. And you can go and check  
150:10 - them out and see how they look like. But this is 
what we are doing. So over here we're adding the  
150:14 - flipbook on every one of those animations. So 
now, you saw the effect of that. So let me just  
150:21 - play one more time. The last step that I want 
to test out is do we actually die if the snake  
150:27 - collides with its own body, so let's go back over 
here try to eat it, it is a little bit harder to  
150:34 - control the snake when we didn't want it then 
when the snake is not big enough, so when it  
150:41 - didn't eat enough, so come on, let's try it one 
more time, we need to get the snake a little bit  
150:48 - bigger so that we can actually come on man, 
I cannot be the game I created. What is this?  
150:56 - Actually not beat it I'm trying 
to die. But I'm trying to die with  
151:00 - the with colliding on the snakes by anyways, 
you can simply set the delay to be a lower value  
151:09 - in order for that to work. So the delay can have 
a lower value as well. In the beginning, that  
151:15 - is you see, the larger the snake the faster it is 
the delay is slower and that means we can control  
151:23 - the snake much better. So meaning you can, as 
I said, set the delay in the beginning to be  
151:31 - smaller value. So now we can actually test it 
out. So pay attention now the snake is moving  
151:36 - and we can control it way better. And now bam, 
you see I collided on my own tail and I died  
151:45 - you can restart the game by pressing R to play 
the game again. And that is that thank you again  
151:52 - for watching one or one another one of my Unreal 
Engine tutorials here on YouTube. And please, if  
151:58 - you liked the video, make sure that you share it, 
subscribe to the channel, comment and leave a like  
152:04 - because that helps the algorithm helps my channel 
grow because we want to spread the roots. We're  
152:09 - we want to spread the word so that other people 
can see and benefit same as like you did. Anyways,  
152:16 - thank you again for watching. If you want more 
Unreal Engine tutorials, I have plenty more inside  
152:21 - of my game development Academy link is in the 
description below. Click on that link enroll you  
152:26 - will learn you will help support the channel and 
it's very cheap, cheaper than any other website.  
152:32 - Anyways, I don't have anything else clever to 
say except again, help the algorithm push the  
152:38 - channel forward then the fire here from us who's 
calm. I will see you guys in the next tutorial.