00:00 - Creating a user interface for your machine 
learning model can make it easier to adjust  
00:04 - the model and visualize the results. Great yo 
is a Python library that makes it super easy  
00:11 - for machine learning engineers to create intuitive 
user interfaces. In this course, Abdul will teach  
00:16 - you all aspects of radio, including deployment. 
Dear fellow coders, welcome to one little coder,  
00:23 - radio machine learning AP course 2021. I 
welcome you to this course. And in this course,  
00:28 - you will learn the fastest way to demonstrate your 
machine learning model using gradient gradients,  
00:34 - a Python library, and we are going to learn more 
about gradients in this course. Follow us on  
00:38 - YouTube to learn more about machine learning data 
science and analytics. This course contains nine  
00:44 - sections, and this course runs about one hour 15 
minutes. Let's get started understanding what is  
00:49 - this course content. The first thing is you will 
learn what is the current problem that we have  
00:54 - in the ML prototyping space. And then you will 
learn about advantages of radio and what is radio.  
01:01 - Next, you will learn how to get started with 
radio with a very simple example to create your  
01:07 - first radio web application. And next, there are a 
lot of different components of radio. So you have  
01:12 - component for image of component for text, you 
have different components, and in this section,  
01:17 - you will learn the different components of 
radio. And in the next section, you will  
01:22 - learn how to handle multiple inputs and multiple 
outputs in a typical radio application. And next,  
01:29 - you will learn about debugging your radio 
application, and also using a very special  
01:33 - feature that radio has got called flagging. 
And next, you will learn how to improve your  
01:40 - radio applications user interface and user 
experience. This section will also help you  
01:45 - understand how can you change the theme and also 
have your own style in your video application.  
01:51 - And next, you will learn how to share the 
video application with everybody in the world,  
01:56 - and also how to add security which means add an 
authentication layer at the top so that way only  
02:01 - people whom you want to take the video application 
to can check. And finally we are going to finish  
02:07 - this course with a capstone project where we 
are going to build a Gradle application that is  
02:12 - powered by deep learning and that deep learning 
powered radio application, we will learn how to  
02:18 - deploy it on hugging face spaces. So starting from 
understanding the space to completely deploy this  
02:26 - application on a permanent hosting, you will 
learn everything from scratch to end to end  
02:31 - in this one hour 15 minutes course, which is 
about nine sections. If you do not have time for  
02:37 - all the nine sections of the scores. What I've 
done here is at this this particular page, you  
02:42 - can actually see that there are certain things, 
those have been highlighted. And those highlighted  
02:47 - things are the most important thing. If you only 
cover these important things, you will be able to  
02:53 - build a decent radio application. So if you do 
not have time for everything else, you can at  
02:57 - least go fast track with these highlighted items. 
And that will give you the necessary knowledge  
03:03 - to build a great new application, which you can 
use to demonstrate your machine learning model.  
03:09 - Let's get started with the course. And I 
hope you will find this course valuable.  
03:20 - In this section, we'll learn a little bit 
about the challenges that we have in building  
03:24 - a machine learning web application, especially for 
prototyping. So if you go to Google, and then say  
03:30 - machine learning web app, using then you will 
certainly see a lot of suggestions like flask  
03:35 - is the Code Stream latest area code Jango, Sasha 
got all these suggestions. So the first problem  
03:41 - that you usually face when you want to build a 
machine learning web application for prototyping,  
03:46 - let's say or even I can say that machine 
learning, machine learning web app, proto type  
03:53 - web app using Yep. So if you see this thing, now 
you'll you'll see a lot of a lot of suggestions.  
04:00 - flask is there. Again, the extremely it is there, 
you will see Django somewhere. So the first  
04:05 - problem that you have is, what is the solution 
that I should pick for my current need. And it  
04:10 - could be anything, right? So you have solutions 
varying from flask to Django, to streamlet.  
04:16 - And a lot of other solutions exist in this space, 
especially in recent times, if you see a lot of  
04:22 - new applications or libraries that helped that 
that is there to create web application around  
04:29 - your machine learning a data science model. So 
for example, solutions, like for example, if I go  
04:34 - online and then look for streamlet versus flask, 
versus then you see Django dash then vs. Then  
04:42 - you see grid view. So basically, if you see the 
current space, you have all these different Python  
04:48 - libraries that is there to create that is there 
to help you create a web application and on your  
04:54 - machine learning solution. So it is very important 
for you to understand what is the problem that  
04:58 - we have in the current space The problem that 
we have in the current space is that you have  
05:03 - either applications like flask, which is usually 
used for a full stack web application using Python  
05:10 - ecosystem flask or Django for that matter. Or you 
have something like streamlet, which is, which is,  
05:15 - again, a very good application library for you 
to create ml web application, or even any web  
05:22 - application of that sort. You can even build 
a streamlined dashboard analytical dashboard.  
05:27 - And you can, you can do everything with streamlet. 
But you don't need the level of knowledge of flask  
05:33 - or Django, because streamlet helps you wrap around 
all important components in the form of stimulate  
05:39 - and you have got stimulated, but components. 
So now when you see a world video chord,  
05:43 - stream rate and video, I've got flask and Django. 
Now you would start wondering, what is the one  
05:48 - that I need to pick. And because this course 
is about grade, you, I would like to highlight  
05:53 - that as grade you fit in this stack. So if you've 
see, like, let's go to the examples available on  
06:00 - hugging face spaces. So this is hugging face 
spaces where we have got a bunch of applications  
06:04 - available. Okay. So now when you go to spaces, and 
then look for one of the most popular spaces like  
06:09 - these are the spaces of the week. So if I look at 
one of the most popular spaces, when I click it,  
06:15 - it's running. And you can you can actually see 
a great view application popping up. So this is  
06:21 - this is built with grid view. So you have an 
input text, and then you need you can you can  
06:26 - do anything like multilingual summarization model, 
and then you have the ability to select languages.  
06:31 - And then you have an output design. So this 
is the typical use case where you want to  
06:36 - use radio or any other solution. So my pitch 
here is, let's say you want to build a startup.  
06:43 - And that startup should have like high 
scalability and then you want like a  
06:49 - production grade application, not now. Now 
this is the time probably you would start using  
06:54 - flask or Django because that's what people do. So 
you have a flask developer or a Django developer,  
06:58 - and then you put together a full stack 
development team. And then you can start  
07:02 - production using your application, will it let's 
say, like you're building the next Facebook,  
07:06 - next Google or whatever the next is, right? If you 
are in that condition, if you are in that state,  
07:13 - then you know, for the web application that we are 
talking about, for the machine learning powered  
07:18 - web application that we are talking about, 
you need a solution that is quite scalable,  
07:24 - that can handle a lot of different 
things, not just only machine learning,  
07:28 - but you know a lot of different things. So you 
would probably go with Flask, or Django. And  
07:33 - let's say like you are in a space where your 
solution is very confined to machine learning,  
07:37 - especially data science machine learning, 
you want to build a dashboard, you want a  
07:40 - tableau alternative. You want easy wrappers 
around machine learning, you want like simple  
07:45 - third party components, I would probably 
prefer to go with streaming it there.  
07:50 - Streaming, it is highly flexible, I love streaming 
it. And streaming, it also makes it easier for you  
07:54 - to deploy. Okay, so this is where streaming. 
Now in this process in this entire process,  
08:01 - let's say you want to build an MVP, what is 
an MVP? MVP stands for minimum viable product.  
08:07 - This is a product that you would build 
to gain your customer confidence to find  
08:12 - out product market fit. To find out whether 
this is a product that people want to use.  
08:18 - That is an MVP. The second thing is while 
your machine learning team is creating models,  
08:23 - you want to make sure that you have the best 
model in place, you have the best in class  
08:27 - state of the art model that is available for 
your customer. And so you which means you're  
08:32 - going to build a lot of models, like you're going 
to do an experiment probably weights and biases,  
08:37 - karma and Neptune whatever solution that you use 
for experiment, but at the same time, you also  
08:42 - want somebody to actually play with the model that 
you have built. So now we are talking about two  
08:47 - cases. One, you want to build an MVP minimum 
viable product for your startup. Or second,  
08:52 - you want to build a web application that is used 
for iterating your machine learning solution.  
08:58 - Now, if you are in this situation, either of 
these situation, I would strongly recommend  
09:03 - using radio because radio is specially built for 
this purpose, or at least in my opinion, like you  
09:08 - could talk Gradius founder, and then probably that 
person might have a different opinion. But if you  
09:12 - asked me, if you look at Radio, if you are in a 
corporate setup, or if you're a hobby hobbyist,  
09:19 - Mission hobbyist, or if you are somebody 
who's trying to build web application,  
09:25 - or like machine learning startup, like you could 
be an entrepreneur, you could be in academia,  
09:30 - you could be a normal data scientists like to 
build data scientists like me, or you could  
09:33 - be a hardcore machine learning engineer who's 
working for Facebook, artificial intelligence  
09:38 - research, or Google Brain or some kind of 
organization, you could be any of these things.  
09:43 - Now, one of the things that you would do across 
all these different verticals is that you need to  
09:48 - iterate on your machine learning application. You 
need to build an MVP before your startup looks,  
09:54 - you know, like go speak. So in that case, I would 
strongly prefer radio because gradient gives that  
10:00 - flexibility to build something like very fast very 
soon without having to be worried about you know,  
10:06 - scalability without having to be worried about 
deployment without having to be worried about  
10:10 - what is the CSS style looks like? What 
is the style? How do I have to change my,  
10:15 - you know, style, like what, how does the head 
headline or text should look like, I don't have  
10:20 - to be worried about any of these things. Because 
this is a phase, where I'm going to, if I'm,  
10:24 - if I'm an entrepreneur, I'm going to probably 
focus on you know, finding the product market fit,  
10:29 - making more people use my product and finding how 
they feel about it, like how they feel about the  
10:33 - solution. Or if I'm in academia, or if I'm 
in like building machine learning solution,  
10:37 - I will be probably more interested in finding the 
best model that I can serve my customers with.  
10:44 - So if you are caught in this situation, 
so you're not building the next Facebook,  
10:47 - you're not building the next Twitter, you are not 
even you know, building an analytics dashboard,  
10:52 - if you are in this situation, but still you want 
to have application that is to be created fast,  
10:57 - that is to be created and shared with everybody. 
And that also has, you know, some flexibility to  
11:02 - deploy permanently, then I would like completely 
support picking a gradient for this purpose,  
11:10 - because I strongly feel gradient is used for this 
purpose. So if you come across a question like  
11:15 - radio versus stream lit versus flask versus Django 
anywhere on the internet, then probably my take  
11:20 - on that is you have to use different products, 
different libraries, for different stages of your  
11:27 - product lifecycle, if you're an entrepreneur. So 
if you are in an MVP phase, I would close my eyes  
11:32 - and then pick radio. If you are in a phase where 
I'm going to deploy my production grade machine  
11:37 - learning solution, I would probably go with, 
like, if it is only a machine learning solution,  
11:43 - but it's only a machine learning solution, 
probably I would go with streamlet, again, like  
11:47 - slightly an enhanced version of me MVP. But if you 
want like a production grade solution, like let's  
11:53 - say I'm building the next Facebook or Twitter or 
something, then I would probably go with Django,  
11:58 - something that has people, something that people 
usually use for production grade web application,  
12:04 - something that can compete with the JavaScript 
ecosystem. So this is how I usually see this  
12:08 - problem. But you can see the natural problem that 
we have here, the problem that we have here is  
12:13 - not about which solution to pick. But generally, 
if you want to build a web application,  
12:19 - you don't want like, you don't want a public 
building a web application to be an overhead  
12:23 - for your current problem. So your current problem 
is solving a machine learning problem. And you  
12:28 - have to just solve that you cannot sit and spend 
your time on learning how to you know, connect  
12:33 - your API is within Java, like a flask, you cannot, 
you cannot think about how to you know, get your  
12:39 - app routed to a particular link, you cannot do all 
those things. These are like roadblocks. These can  
12:45 - inhibit your progress in your machine learning, 
research or application or whatever you do,  
12:49 - right? Whether it is machine learning research 
or applied machine learning, you don't want a  
12:53 - solution that can stay in your way prohibiting 
inhibiting your progress in doing something  
12:59 - greater than just building an application, you 
want a solution that should make it much, much  
13:03 - easier, just like icing on the cake. To enable you 
build a web application that can help you serve  
13:10 - your web application. So that can help you serve 
your machine learning solution as an application  
13:15 - that the entire world can use, I would strongly 
pick radio. So if you are wondering why radio,  
13:22 - then you do have the answer in this video, which 
is to say that I would pick radio whenever I want  
13:28 - to show machine learning demo whenever I want 
people to use my models. And I want to build  
13:32 - an MVP. And whenever I want people to actually 
you know, play with a model and iterate on it  
13:38 - and then find the best solution. So internal or 
external, customer facing or internal, you know,  
13:43 - like machine learning engineers, iterating, 
whatever this is, this is a place where I  
13:48 - would probably pick Grady over any other existing 
solution because every solution has its own place  
13:53 - in the machine learning lifecycle or product 
development lifecycle. So for this particular  
13:58 - phase, I would pre grade you and then we will 
learn more about grade you as well in this course.  
14:09 - A quick introduction to grade you. What is 
gradient gradient is the fastest way to demo  
14:15 - your machine learning model with a friendly 
web interface, so that anybody can use it  
14:20 - anywhere in the world. So gradient has this pitch 
that says, Build unshared, delightful machine  
14:26 - learning applications with anybody in the world. 
And what does it mean? It means if you have to  
14:33 - demo demonstrate your machine learning model, you 
don't have to create a full stack web application.  
14:38 - Rather, what you can do is you can wrap your 
function with gray do and then gradient would  
14:44 - be able to create a web interface for you. As you 
can see on the screen, it says, with five lines of  
14:49 - pure Python code, you should be able to create 
a UI around your machine learning application.  
14:55 - Let's look at the example here. So let's look at 
this sketch recognition. So you've got handwriting  
15:00 - recognition, machine learning model or sketch 
recognizing machine learning model. And then you  
15:04 - want to create a web application around it for 
people to use it. For people to experience how  
15:09 - good your machine learning model is, it could be 
a that you are creating a demo for somebody else.  
15:14 - Or it could be that you want to yourself, check 
the validity of your machine learning model,  
15:19 - the efficiency of your machine learning model. 
So for you to do all these things, if you have  
15:25 - a web application that you can play around with, 
that is a great, great way for you to learn how  
15:30 - your model is performing. And usually, typically, 
it's not an easy task for you to do. And gradient  
15:36 - makes it really, really easy. If you see this 
code here for sketch recognition, the first step  
15:42 - is import the library, then wrap your sketch 
recognition model everything within a function  
15:48 - and use that function as a radio interface. And 
the input in your image, you can see that the  
15:53 - input image, which is the input for the function 
has been given as an input image here, and then  
15:59 - output you're going to label the output like the 
display the output. So let's go ahead and then try  
16:04 - to use this application and then see how it works. 
So you have got a canvas here. And this canvas has  
16:13 - an attachment output. So you have an input, and 
you have an output. So let me clear this. And then  
16:17 - you can see there is like there is nothing here, 
right? So I'm going to clear this and then say,  
16:23 - three, okay, this looks like three, yeah, you 
can see that it has gone to the machine learning  
16:28 - model, and the machine learning more or less, 
try to figure out what is this, and then it has  
16:33 - given you the output score. So this is the easiest 
way, let me let me write something very ambiguous.  
16:38 - Okay, so I'm going to write like this. Okay, 
for not very ambiguous. So if I do like this,  
16:43 - yeah, so now, you know, it doesn't know whether 
I'm trying to write nine or six or for whatever  
16:49 - it is, right? So this is how you can actually 
see, okay, where are the places your machine  
16:53 - learning model is not doing good. And then you can 
probably fix that. And that is, that is one of the  
16:58 - advantages of using radio, because radio lets 
you do that with a very, very simple interface,  
17:04 - all you have to do is wrap around your machine 
learning functions, whatever you're doing within  
17:09 - within our like main function, here speech 
recognition, and use that function as an input  
17:15 - to the radio interface. So that is your input. And 
all you have to do is import the radio library and  
17:21 - like that, you can see couple of other examples 
that is there on the website, question and answer  
17:26 - you. So you have got a question. So the idea here 
is that you can use it for computer vision tasks,  
17:31 - just like this. You can use it for NLP 
tasks, like a question and answer generation,  
17:36 - you can use it for speech recognition, like 
you can speech detection and translation,  
17:43 - text to speech, speech to text. And also if 
you want to, you know, Mark some mark some like  
17:49 - segmentation within your image, you can still do 
that. So these are like all the examples. And the  
17:54 - one thing that common you would see across all 
these examples is that you import the library,  
18:00 - you wrap it around the function, and then you have 
the grade your interface, skates, recognition,  
18:04 - question and answer and everything you would 
see the same thing. It might be that you know,  
18:08 - the number of inputs differ, like, for example, in 
this case, you have got two inputs, right? But but  
18:13 - the fundamentals are same, you do the same thing, 
and then it just helps you create that interface.  
18:18 - Okay, so now we know that radio is an application 
or like a Python library that can help you create  
18:25 - easy web interfaces for your machine learning 
model that could be shared with anybody. Let's  
18:30 - look at some of the companies that are using 
radio. So if you see the logos that are available  
18:35 - here, you can actually see that almost all reputed 
companies that use machine learning model you can  
18:41 - see like Google is their Amazon is their Facebook 
is that you can call it meta, whatever you want.  
18:45 - Cisco is they're hugging faces. They're 
VMware Siemens, like all these companies,  
18:49 - and also educational institutes like MIT and 
Stanford, all of them are using radio. So this is,  
18:55 - again for you to gain a confidence that this 
solution is there to exist. It's not a solution,  
19:00 - you know, that's bi, that is just used by a bunch 
of hobbyists, gray area is a solution that is  
19:04 - being used at corporate level and academic level. 
And it is a way forward for you to demonstrate  
19:09 - your machine learning model, if you are not using 
radio. So what are the advantages of using radio.  
19:16 - So first of all, Gradius quite easy and fast 
to setup. All you have to do is install radio.  
19:23 - And you all know like, if you're in the Python 
ecosystem, you know that all you have to do is  
19:28 - pip install radio. And creating a great audio 
interface requires one only a couple of lines  
19:35 - of Python code to your existing project, which 
means you don't have to change a lot of things  
19:40 - in your code existing code because that shouldn't 
the objective of creating a user interface for  
19:46 - your machine learning model shouldn't be shouldn't 
be a roadblock in your machine learning itself. So  
19:53 - that's the whole point of Grady, right. So 
it's that you just have a machine learning  
19:57 - model and all you wanted to do is create a 
UI now You don't have to deal with you know,  
20:01 - a lot of API's, you don't have to deal with a lot 
of new classes, a lot of new libraries, the whole  
20:06 - advantage. And the point objective of gradient 
is that you keep your machine learning code as  
20:11 - it is. And all you have to do is add a couple 
of lines of Python code like pure Python code.  
20:16 - And then that entire script is now turned into 
a UI user interface that anybody can play with.  
20:22 - So So that's, that's the greatest thing. 
So fast and easy setup, that's a very good  
20:26 - advantage that you have got the first. 
The next thing is, you can present this  
20:32 - as part of a lot of things. For example, you can 
present this as part of your Jupyter Notebook,  
20:38 - or Python notebook to be precise, because now 
you have got a lot of different notebooks,  
20:41 - right? Zeppelin notebook, Jupyter, notebook vs. 
Code notebook. So you can present it as notebooks,  
20:47 - like embed within notebook, or you can 
also present it as a separate web page.  
20:51 - So you have the liberty for example, if you're 
prototyping something on a Google collab notebook,  
20:56 - you can still create a radio interface within 
a Google collab notebook and radio will give  
21:01 - you a URL which you can use to embed this 
radio UI, the web application within your  
21:07 - Google collab notebook, which means let's say 
I want to publish a paper, right? So what is  
21:12 - what what what is papers with code, so you try 
to publish your paper with the code. But imagine  
21:17 - you can publish your paper, not just with code, 
but also with a web interface, where people can  
21:22 - play around with your model, like, now, this is 
going to prevent a lot of things. For example,  
21:27 - let us say there is a bias in your model. And then 
you have no clue about the bias. But before the  
21:32 - model becomes mainstream, somebody plays around 
with that, and then come up with the bias, like  
21:36 - identify the bias. And you can you can actually 
see a lot of people have utilized radio to find  
21:42 - such biases available in image segmentation 
model language, language models in the past  
21:48 - about a particular community. So gradient has been 
already used, where biases have been identified.  
21:54 - The second thing is adversarial attacks, when you 
have a machine learning model, you want to make  
21:58 - sure that you know, the models are not going to be 
attacked by you know, some some silly examples or  
22:06 - some, like it's not prone to adversarial attacks. 
So for that, you cannot make sure everything and  
22:11 - then you know, the community can always help you. 
And for that, again, like if you have your model,  
22:16 - and you believe it's a very good model, you 
believe it can do something good in the world,  
22:20 - it's, it's very important for you to make sure 
what kind of adversarial attacks this model is  
22:24 - prone to and for somebody to actually even try 
out that adversarial attack, they need something  
22:30 - to play with, right. And radio can be that. So 
radio could be embedded within your collab code,  
22:35 - Google notebook, sorry, Google collab, notebook, 
Jupyter notebook or any sort of Python notebook  
22:40 - and also as a separate web page. So you can just 
take the link and then share it with anybody like  
22:45 - it generates a public link for you. And then you 
can generate it with anybody Imagine, imagine,  
22:50 - like you're you're trying to attend a machine 
learning interview, and you have been asked to  
22:55 - build a model. And then instead of just rather 
giving just a model in like a pickle file, you  
23:00 - can actually build an interface and then share it 
with your potential employer, or you're going to  
23:04 - go to a conference and then you want to, you want 
to show something out of your machine learning.  
23:08 - And instead of having the machine learning model 
on your PowerPoint presentation, you can also have  
23:12 - it as a web interface, where all the attendees 
of the conference can play with so this is  
23:16 - enormous potential. And that's the second biggest 
advantage of radio like you can present and share  
23:22 - radio applications within notebook outside 
of notebook with anybody in the world.  
23:27 - Another third thing is if you 
want to do permanent hosting,  
23:29 - like Until now we were talking about temporary 
hosting, you get a you get a like a URL that is  
23:33 - like an ngrok URL and then you can share it with 
anybody but but if you want permanent hosting,  
23:38 - today, you have a very good option which is called 
hugging face spaces. So hugging face spaces is an  
23:44 - initiative from hugging face the machine learning 
company that used to be the NLP company, where  
23:49 - you can deploy your very interface for completely 
free, very easy, very simple, I've got a separate  
23:54 - video about that already, I can link that in the 
YouTube description. But otherwise, you can also  
23:59 - check it out. At the end of this course we will 
learn how to deploy a radio you AI radio app  
24:05 - on hugging face spaces like even without even 
touching your local machine completely coded on  
24:10 - the web and also deployed deployed completely like 
seamlessly and the workflow is really really easy.  
24:16 - So, if you want permanent hosting again you have 
a very good option the form of hugging face spaces  
24:21 - to host your radio application now that you 
are you could share it with anybody you can  
24:26 - I mean you you can now share it with anybody 
permanently not just like a temporary interface.  
24:32 - So easy and fast setup, you can present and 
share the radio application with anybody in  
24:37 - the form of notebook or web application. And 
finally, you have the ability to permanently  
24:41 - host radio applications. These are these are 
really good advantages and like I said before,  
24:46 - have letting people to play around with your model 
has a lot of advantages. In a corporate world and  
24:53 - also in an academia. Oneness like I said like you 
can eliminate bias you can eliminate adversarial  
24:59 - attacks second Like, you can actually let people 
play around with something that you have built,  
25:03 - which is the whole point of building something, 
right. So a lot of advantages of using radio,  
25:07 - radio has very good interface with hugging, face, 
Jupyter, notebook, matplotlib, NumPy, pytorch,  
25:13 - scikit learn and a lot of other machine learning 
libraries or scientific stack in Python. And you  
25:18 - can see already there are a lot of people who love 
using radio, and then they have Windows radio to,  
25:24 - to use radio as a solution to do a lot of 
things. For example, if you see the last example,  
25:29 - it very clearly says honestly, without radio, 
we wouldn't be really doing a real time a trial.  
25:35 - So in clinical trials for them to try out their 
algorithm, they have used radio and like without  
25:41 - NLP, again, somebody has used radio. And you 
can you can actually see a lot of different  
25:45 - use cases of how people have used radio and what 
are the things that people have used radio for.  
25:50 - So if you're interested in taking your machine 
learning model, and then making a full stack  
25:56 - application, this course is for you. So we'll 
learn more about radio in the future section.  
26:07 - In this section, we're going to learn how to build 
our first radio application. Previously, we learnt  
26:13 - about why do we need radio and what is radio and 
some of the advantages of radio. And so here, we  
26:19 - are going to start with coding. And to code, I'm 
going to basically use the Getting Started page on  
26:25 - radio. This is quite a comprehensive page. If you 
don't prefer watching a video, I would strongly  
26:31 - recommend you to check out this page. So to code 
I'm choosing Google collab interface. So I've  
26:37 - created a Google collab notebook. So all you have 
to do is go to go to Google and then type Google  
26:42 - collab, you would get an interface and you have to 
go to File and click new notebook. Once you click  
26:48 - new notebook, you would get something like this. 
And then you can change the name of the notebook.  
26:52 - So I've given the name here called Building your 
first radio web application. Let me zoom it,  
26:58 - zoom it a little bit so that you can see 
it. After you have all these things. You  
27:02 - can connect with the Google collab notebook. 
Basically, Google collab notebook is Google  
27:07 - machine that Google gives us to practice machine 
learning, like create applications, whatever,  
27:12 - like create scripts, whatever you want. And this 
is a notebook interface hosted on Google collab.  
27:17 - So at this point, you can see like you have got 
a machine like you have got a decent machine. And  
27:21 - you can see the missions usage here, like the 
RAM disk, all these things. For our purpose,  
27:26 - you can do the same thing on your local machine as 
well. You don't you don't necessarily need Google  
27:31 - collab. But if you need Google collab, you can 
use that as well. So the first step, after you  
27:36 - have the Google collab interface is basically you 
will have certain basic Python libraries that are  
27:42 - predominantly used in Python machine learning 
stack for just just by default. For example,  
27:47 - if you want pandas, you would already have 
pandas here. But if you want something that is  
27:52 - not available there, then you need to unity unity 
install the library first. So in our case, we are  
27:58 - going to install CREATE VIEW. First, the first 
step is installing radius. So I'm going to say,  
28:04 - Pip, let me delete this, I'm gonna say 
pip install radius. So first step is  
28:12 - install the library radio. And you can you can see 
that it is getting started. If you face any issue  
28:19 - in this, basically, all you have to do is go 
here, and then just restart runtime. Yeah,  
28:24 - restarted runtime. After you restart runtime, 
you can see the runtime gets restarted.  
28:30 - And after the runtime has restarted, you would see 
being connected to a machine. So this, this icon  
28:36 - would change like from orange, so you're getting 
a new machine allocated. After this allocation,  
28:41 - you can again install the library. So whenever you 
face an issue, on Google collab, all you have to  
28:46 - do is go there, and then restart your runtime. 
But make sure if you have anything temporary,  
28:52 - like a temporary variable store, when you restart 
runtime, it may not be available for you. So let's  
28:58 - wait for the machines allocation to happen. So the 
first application that we're going to build would  
29:03 - something look like this. So you're given him and 
then it would give an output. And then I'm going  
29:07 - to explain you every single part of the code. 
So that's going to be this particular section,  
29:12 - where you would get to learn the radio web 
application. Once your connection is established,  
29:18 - you can see this here, and all you have to do 
is go ahead and then install the radio library.  
29:24 - At this point, the radio library would get 
installed. It's a very lightweight library,  
29:28 - so it shouldn't take a lot 
of time for you to install.  
29:36 - So you can see that the video library 
has been successfully installed.  
29:40 - So after the library is installed, you can you 
can basically like just for the sake of sanity,  
29:45 - I'm going to clean my outputs. But here you can 
just keep it as well or you can install it quietly  
29:50 - like this. So after the upgrade your libraries 
installed, the next thing that we're going to  
29:54 - do is we're going to build our first application. 
So the first thing that we have to do as in every  
29:59 - time Under libraries import grid view as gr, so 
you're basically importing the radio library here  
30:06 - with the alias GL, the next thing that you have 
to do is you need a function. So a radio interface  
30:12 - has three components of function, input and 
output. So first, we need to define the function.  
30:17 - So let's say we're going to define a function 
that says hello world, okay? Very typical  
30:22 - machine learning stuff, programming. So 
where we are going to return saying, hello.  
30:32 - And probably an emoticon plus the name, the 
name, okay. So this is what we are going to  
30:41 - do. And maybe like, if we want, we can, we can add 
something to this. So this is a function if you  
30:46 - want to see how the function works, what you can 
start doing is you can call the function and then  
30:50 - you know, pass on some name, maybe you can say, 
to coder, and then see whether it outputs okay,  
30:55 - it it outputs Hello, one little quarter. So 
let's, let's give some space. So that we have  
31:01 - this thing. So now our function is set that that 
function main function that you want to create,  
31:07 - assume that this is your machine learning model, 
right now you don't have a machine learning model.  
31:10 - But it's like you know, you could be you could 
have a speech translation model some some machine  
31:15 - learning model. So now that you have got your 
function, now let's start building our radio  
31:21 - interface. So the radio interface we want to like 
you can call it anything you can like, I can just  
31:26 - call it interface. So I can say interface is equal 
to, I can say gr dot interface. And within this,  
31:34 - I'm going to have three main components. One 
is a function, so they just call it wait.  
31:39 - Yeah, one of the function, the function, 
what we want to call here is hello world.  
31:46 - And then the second thing is an input. So 
what kind of input do we want? Do we want  
31:51 - to capture a text input? Because that's 
what we're doing here, right? So text,  
31:55 - and the third is output. And what kind of output 
we want, we want the text output. So text input,  
32:04 - text output. And also what is the function. 
So now let's define this interface.  
32:12 - Okay, hello world is not defined. It's because 
I've made a stupid typo. Okay, hello world is  
32:18 - defined. And then we have got the interface now 
that this is successfully run, the next step for  
32:23 - us is to launch the interface, interface launch. 
And once you launch the interface, ideally, you  
32:30 - should be able to see the application somewhere 
here. So let's wait for it to launch. So a couple  
32:35 - of things would happen behind the scenes. So 
Google collab notebook, if you want, if you want.  
32:41 - If you want the notebook to show, like if you 
want to debug, so you need to use debug is equal  
32:46 - to true while launching, you have a public URL 
as well. So this link will expire in 72 hours.  
32:52 - So if you want, if you want longer links, 
probably you need to contact radio support,  
32:55 - which is not required for us. And then 
also like you have, you have the app. Okay,  
33:00 - so let's click the link, then go here and see, how 
does it look like. It's loading, as you can see.  
33:13 - And we have the same application embedded here 
as well. So we can see the same thing here as  
33:17 - well. So you can see that of the name, and you 
have the output. So let's say I want to give  
33:23 - one little coder and submit this. And then you 
can see Hello, and little code. If I say hello,  
33:29 - Python with an emoticon maybe in face emoticon, 
and then submit. So you get this. So basically,  
33:37 - you have something you submitted. And while it is 
run, you can see you can see something happening  
33:41 - here, click this you can see you can see that 
right so you can see that this has been processed.  
33:46 - And then you can you can take a screenshot, if you 
want to flag it, you can do do all these things.  
33:49 - If you want to clear this input, you can clear 
this input. So these are like the basic default  
33:54 - options that you get with radio. But again, this 
is not what integrators and the same application,  
33:59 - whatever, we just open with a URL. So the URL 
is useful for you to share it with your friends,  
34:04 - and potential employer colleagues, like 
whatever whoever is on the world, the planet  
34:08 - with internet connectivity. But if you want to 
share this web application as a Google collab  
34:13 - notebook or Jupyter, notebook, or any notebook of 
that sort, so you can still do it because if the  
34:18 - same thing is also embedded here, so I can go here 
and then say, gradient, okay, and I can put put  
34:26 - some magic one. And when I click Submit, so you 
can see that it has taken 0.00 seconds like very,  
34:34 - very minimal time. And then you can see the output 
as well. And if I want to take a screenshot of  
34:39 - this, I can take a screenshot of this. So at this 
point, we have successfully managed to build our  
34:44 - very first greedier web application. And in the 
next section, we will learn how to improve this  
34:50 - web application is This is enough for let's say 
computer vision problem No, this is not enough.  
34:55 - Is this enough? Where we need to have multiple 
input option or this is not enough so the next  
34:59 - section we're going to learn the customizations 
of different components that are available in  
35:04 - grid view. But at this point, you should be able 
to code your very first video web application. So  
35:09 - congratulations to you. In this section, you're 
going to learn how to customize radio components.  
35:20 - Which means in the last section, you learned 
how to build a very simple radio application.  
35:25 - And this section will help you to improve or 
enhance your application for your needs. So if  
35:31 - you remember what we learned in the last section, 
a radio interface, a radio application, the  
35:36 - interface is a core interface class, it actually 
has three main parameters. One is the function,  
35:41 - the function is where the input is passed on 
to. And the output of the function, whatever  
35:47 - you're returning from the function is shown as an 
output. And if you remember, that's what you have.  
35:52 - So you have got the input, and you have got the 
output, and something goes between it that is a  
35:56 - function. So now we are going to learn and 
finally write, of course, after you do all  
36:00 - these things you're going to launch. So basic, the 
basic skeleton of a radio application is you have  
36:07 - the import statement, you have the function, 
then you have the interface, then finally,  
36:11 - you're going to launch. Now we are going to learn 
how to customize these components like input,  
36:17 - output, or also anything else that is available 
in such a way that you can build slightly more  
36:24 - complex applications, because that's the whole 
point, right? Nobody is going to just take  
36:28 - a text, and then show something. I mean, like you 
can build gradle applications like that as well.  
36:32 - But our whole point is to do something beyond 
this. And then we can see, we can learn how  
36:37 - grade your supports us or enables us doing that 
thing. And once again, like I said in the previous  
36:42 - video, and basically using the material, the code 
that is available in the radio documentation,  
36:47 - I strongly recommend you using this documentation. 
So if you have any, like if you have any concern,  
36:53 - whatever I'm showing the video, you should 
definitely refer the documentation because  
36:56 - that is exactly what I'm using as well. So 
let us get started and then try to understand  
37:02 - how to customize our radio component. So 
currently, our radio application looks like this.  
37:07 - So we have a name. And we have an output. Okay, so 
there is one mean, and one output. Like right now  
37:15 - you can see the textbox is not very big. What have 
you need a bigger textbox? With a valid question,  
37:21 - right. So what if you need a bigger textbox, all 
you have to do is you have to create an input  
37:26 - component. So I'm just copying the same radio 
interface that we already had. And instead of  
37:33 - creating a new function, I'm just going to 
show you like we can keep the same function,  
37:36 - which is the hello world in this case, but I'm 
going to show you how you can change the input. So  
37:42 - what we are trying to do is, we are trying to make 
this input slightly bigger. And for that, we are  
37:48 - going to use a new component from radio, which is 
radio because we have imported grade us. And here,  
37:55 - radio inputs. So we have inputs. And within 
that you can see you have a lot of inputs,  
38:00 - like you have audio checkbox, data frame 
drop downs, you have a lot of things. And  
38:05 - then the one that we are interested in is we're 
going to use a text box. And the text box takes  
38:10 - an argument that says lines, number of lines. 
So let's say we want a five line. And then we  
38:16 - can have a placeholder text, the placeholder 
text is enter your input here to the reader.  
38:23 - And then we can now execute this, and then say 
interface dot launch. And you should did I just,  
38:32 - yeah, that's mine. And then you can launch the 
interface like you can see the interface. And  
38:37 - you can see there is a different URL altogether. 
But you can launch. So now you have a bigger name.  
38:42 - So instead of had having a smaller name, 
so if you want this to be more like a lot  
38:47 - bigger than you can, again, change the number of 
lines, and then you can have a bigger textbox.  
38:51 - So this is how you can customize the input. Okay, 
so you had function, we kept the same function,  
38:58 - you had output, we get the same output, but we 
just change the input from a simple text box  
39:04 - like a single line text box into multi line text 
box that gives us multiple lines of the code. So  
39:10 - this way, this is a simple example for you to 
learn how to change the radio components like  
39:17 - how to change the radio component within the grid 
application, so that you can have multiple lines  
39:24 - of input text given that this is a text, let 
us say we don't want text. Okay. Let's say we  
39:30 - don't want text, but we want an image. So in the 
next section, we'll learn how to build an image  
39:38 - input. Instead of text input, we'll learn how to 
build an image input. And that image input will be  
39:44 - used for some kind of machine learning one second. 
So for that, let's go to the radial documentation.  
39:50 - And there is a very nice example that that is 
given. We're going to take the same example.  
39:54 - And then I'm going to show you I'm going to 
explain you the components. So input radio's Jr,  
40:01 - same thing. NumPy is for image processing, we are 
just going to apply a sepia filter. Okay, so we  
40:06 - are going to take an input image, and then we are 
going to apply a sepia filter. And then that's it,  
40:12 - let's let's leave this function because 
this is just going to apply a sepia filter.  
40:16 - So the most important part for us is instead 
of having a text, like as in here, which is  
40:23 - which is here, right, instead of having a text 
box, we are going to have an image as an input.  
40:29 - And then we are also giving the shape of the 
image. Okay, and the output is also supposed to be  
40:34 - an image. And once you run this, you can see the, 
you can see the textbox like I delete the box,  
40:43 - so you can click and upload it, or you can drop 
down the image. So if you have downloaded the  
40:47 - image somewhere, then you can drop the drop down, 
drop the image here, and then that will work. So  
40:52 - I can, I can show you a sample image. And then 
we can see how it works. So I've selected an  
40:58 - image from my folder, and you can see the image 
is available. So I'm going to click submit.  
41:06 - And then you can see that the sepia filter has 
been applied. So basically, instead of having a  
41:10 - text input, you're getting an input image. And 
also the output format is an image. So again,  
41:16 - this is not named document like if you want named 
again, you can say my function is equal to this,  
41:21 - my input is equal to this, my output is equal to 
this. But if you don't want that to happen, like  
41:26 - if you just want to just want to give this like in 
the same model, you can do the same thing as well,  
41:30 - like you have the grid your interface, your 
function, your input and output. And in this case,  
41:35 - image is not input is not text, but it is an 
image. And you get that from the inputs class.  
41:40 - So inputs image, and then output is also image. 
So we have successfully learned in this section,  
41:45 - we have successfully learned how to use radio two 
to build an image application like an application  
41:52 - that takes image as an input, and also image 
as an output. So now that this, this is quite  
41:59 - interesting, right? So we first saw text with 
them. So image, but now the question is, what if  
42:06 - we want to work with tabular data. So in the next 
section, we're going to learn how to build a radio  
42:12 - application that takes tabular data as an input. 
And once again, like I said, we're going to refer  
42:18 - the radio documentation. So radio documentation 
has a very nice example, where you work with  
42:26 - tabular data. So there is a tabular data 
and that tabular data has been taken inside  
42:31 - and then you know, some kind of data 
transformation and not not to the ETL level,  
42:35 - but some data transformation is happening. And 
then you can see there is an input data frame.  
42:39 - So there is a data frame as input. So this is 
again, use this for an example. But you could  
42:44 - you could be reading the data frame from your 
CSV file, and you could be displaying as well.  
42:49 - But the important thing that you have to note here 
is you have an input component called data frame.  
42:54 - So like you had text box like you had image, now 
you have an input format called data frames, and  
43:01 - also an output. So you have like data frame as an 
output, you have plot, and you have NumPy. So you  
43:07 - have input, and you have output, and you have the 
function, and we can add a description as well.  
43:13 - So this is something that we have not seen before, 
where we didn't see description, but we have seen  
43:17 - a description. So let's launch it. Once 
again, it's loading. And then you can see  
43:25 - that you have you have an input 
data frame, if you click submit,  
43:31 - you can see output one is a table. So you can see 
you can go to the function and see it's returning  
43:36 - three things. One, you are returning a tabular 
data frame, second, you are returning a plot.  
43:40 - And third, you're returning a numpy array. 
So you have an output, you have a plot,  
43:46 - and then you have a numpy array. So if you 
want to change the value, again, like go ahead  
43:52 - and change something around it. And then you would 
see like, again, ideally, in an ideal world, you  
43:57 - will not define the data frame asset is probably 
you would be loading a CSV file or something.  
44:02 - And that's what like when you load a CSV file, if 
you have a different value, click Submit. And then  
44:07 - you have three outputs output one, output two, 
output three, so you have three outputs. If you  
44:13 - again, if you want to change it, let's say like 
you don't want the outputs, you just want a plot,  
44:17 - we can go here, delete whatever we are returning, 
and then we can come back here also delete the  
44:23 - output format. So we have only plot here and then 
run this again. When you want to run this thing,  
44:30 - you would have only the input and output. And then 
once I click submit, you can see the output chart  
44:35 - itself. So again, you are not specifying where 
the output should be shown. So if you had noticed,  
44:40 - when we had more than one input, sorry, when we 
had more than one output radio itself managed to  
44:46 - display output one by one, but typically if you're 
building an application using any other existing  
44:51 - tool, so you have to manage that you have to 
manage how this search so on, you have to manage  
44:55 - whether it is responsible or not. But here you 
don't have to be worried about it. Once again.  
45:00 - You have the output here, if you want to change, 
then you can change. Again, like we saw before,  
45:04 - if you want to take a screenshot, you can take a 
screenshot, or right click and save the image like  
45:08 - whatever you want to do, you can basically do and 
this is how exactly, you have an input data frame,  
45:15 - you have an input data frame, and you have 
an output plot as a chart. Okay, so so far,  
45:23 - in the previous sections, we have learned input 
text, input, image. And now we learned about input  
45:30 - data frame. And that's quite helpful. So these 
these are the three main formats that typically  
45:36 - a data scientist or machine learning engineer 
would be using. Again, you can have audio, right,  
45:40 - so the potential is enormous like you if you want 
audio, all you have to do is go here, let's say  
45:48 - inputs. And you can see you can see audio. So 
you can have audio, like you can have audio and  
45:53 - lot other things. But if you ask, like a typical 
machine learning engineer, or a data scientist,  
45:59 - image, text, and these are like a few valuable 
with me, a few valuable things, a few valuable  
46:06 - formats, tabular format, image and date stuff, few 
valuable formats, typically, data centers, machine  
46:10 - learnings, use a lot. So we have learned how 
to create a radio application text application,  
46:15 - how to create a great year image application 
and also how to create a radio application  
46:19 - that takes a tabular data has an input. So now 
we have explored different components like image,  
46:29 - text and tab, data frame. The next 
section, we are going to learn  
46:34 - how to use this different components and also have 
different kinds of input. And more than that. So  
46:41 - let's see in the next section, how to use multiple 
inputs and outputs in your radio application.  
46:53 - So far, in the previous sections, we learned 
how to build a simple radial web application.  
46:57 - We also learned about customizing components 
like different formats, exploring different  
47:02 - formats like image, text, and tabular data. So 
in this section, we are going to learn how to use  
47:09 - multiple inputs, not different types of inputs, 
but multiple inputs. So not every time you want to  
47:14 - use only the same input, right. So for example, 
if you see here, you have one text box, if you  
47:19 - see this example, you have a bigger text box. And 
if you see this example, you have got one image.  
47:23 - But what if you are in a situation where you 
need to take multiple input from the user,  
47:28 - and you want to process it in such a way and then 
give some output. So for that, what we're going to  
47:33 - do is, we're going to make a simple function, just 
like a Hello World example. And then we are also  
47:39 - going to learn how to handle multiple inputs in 
a grid your application. Once again, like I say,  
47:44 - in every section, you can always explore the 
documentation for this part. And it is quite  
47:49 - comprehensive. And the examples that I've taken 
for this code is again from the documentation.  
47:55 - So let's start from scratch. If you have not even 
you know, seeing that, whatever we did before,  
48:00 - so we are importing radius, Jia. So that part 
is done. So the next thing is we need to create  
48:06 - a function, we need to create a function that can 
do something. So what we can do in this case is  
48:12 - we can say let's calculate BMI, okay? I don't, I 
don't necessarily know the formula for BMI, but  
48:18 - I'm just going to take a short BMI. And let's say 
we want to take BMI for a person. And then we want  
48:25 - to take height, and then we want to take weight, 
okay. And then we are going to calculate BMI now,  
48:31 - so and then we are going to also thank the person 
based on the BMI. So the first thing that we  
48:37 - need to do is, let's get the BMI calculation, BMI 
formula, let's say and then okay, basically it is  
48:46 - weight divided by height square, and the 
height should be in kilograms, the weight  
48:50 - should be in kilograms, and the height should 
be in meters. So what we can do is we can say,  
48:57 - Okay, first let's do the formula. And 
then we can we can have a description.  
49:01 - So BMI is equal to BMI, Val is equal to 
height, weight, divided by height squared.  
49:11 - Okay, use the parentheses so that you don't 
have confusion about anything. So now that at  
49:16 - this step, we are calculating BMI. So we're going 
to say, print. And then we're going to say hello.  
49:23 - And the name of the person, which 
is in this case is name less,  
49:32 - some thing and a new line and your BMI is and then 
you're going to say str of BMI. Okay, let's run  
49:44 - the function. Oh, I didn't return anything, right. 
So I should have ideally return this return this.  
49:49 - Let's run this and then try to give the 
value so I'm going to say one little quarter,  
49:55 - and the value which is 220. And then wait 
Let's say 15. And the BMI is point 334. I  
50:03 - have definitely missed up this formula, which 
is kilogram weight divided by height square. And  
50:09 - height should be in meters. right height should 
be in meters in the sense. One point, centimeters.  
50:18 - Okay, 1.2 Maybe. Yeah, so we have got a BMI. So 
approximately our formula works fine. So that BMI  
50:25 - participation. So the next important step for us 
to do is, so make sure that you have three inputs,  
50:30 - and one output, right? So if you want two 
outputs, we can still do that. But right now  
50:35 - we are exploring only one output. So what we're 
going to do now is we're going to say, okay,  
50:40 - interface is equal to radio interface of, and 
then we're going to say, function is equal to BMI,  
50:51 - that that part is simple inputs is equal to, 
what are the inputs we want. The first thing  
50:56 - that we want is a text input. The second thing 
we want is a checkbox. The second thing is,  
51:03 - let's say in this case, slider, maybe gr dot 
inputs, dot slider. And the slider value goes from  
51:12 - zero to, let's say, 100. And the label 
if you want to add a label, say height.  
51:21 - Okay, and then you're going to have another 
slider. And this slider is for weight  
51:29 - in kg, and height in meters. Okay. And this should 
be ID 200, I think, yep. Now this is done. The  
51:41 - next thing is we need to define the output. 
And the output in this case is a simple text,  
51:47 - we are not dealing with multiple items. So simple 
text should be fine. Define this. It's worked.  
51:53 - Now interface dot launch. So technically, 
you can actually do launch here also, like,  
51:58 - if you want to like if you don't want to define 
the interface in a separate step, you can do that.  
52:02 - But yeah, just just for the sake of explicitly, 
I'm just doing it here. And then I'm going to  
52:08 - launch it. Once we launch it again, the same 
thing happens where it says like debugging is  
52:12 - equal to true like all the same examples. So I've 
got a name, let's say name is one little coder.  
52:18 - And then height is somewhere like this. Weight is 
somewhere like this. Weight and kilogram height,  
52:24 - as let's see here, and then submit, you can see 
that the BMI has been calculated, like forget  
52:30 - about what the formula is doing right now, at 
this point, maybe what we can do is it looks  
52:34 - really ugly for us to show this thing, so maybe we 
can round it off, then we have to input okay, I'm  
52:39 - not not dealing with rounding off at this point. 
So you have Hello, the name, BMI and then the  
52:45 - value. So at this point, you can see that we have 
successfully managed to get three inputs. And then  
52:51 - we are also outputting one output. But what if you 
suddenly think okay, instead of just having three  
52:56 - inputs, let me have one more extra output, okay. 
And now probably the output is something like  
53:04 - a emoticon. Okay, if the BMI is less than 
this, let's say there is any more Deacon the  
53:09 - BMI is greater than this return to the remote 
icon. So result emoticon. emoticon is equal to,  
53:17 - again, for simplicity. We can we can use 
or I can I can actually actually use this.  
53:24 - Okay, so just use happy face.  
53:30 - If BMI while is less than, like maybe 30 I don't 
I don't know. So don't take health advice from  
53:39 - this. Otherwise, keep a sad face. How do I keep a 
sad face this is a sad face. This is a sad face.  
53:48 - So now we have a result emoticon. So now what you 
can do is you can result this emoticon as well  
53:53 - as part of this. So we have one, okay, we have 
one entire string if you want to make it easier,  
54:02 - you can see output string is equal to this. 
Okay, and then you have the emoticons so I'm  
54:08 - going to say output string. And then result emoji 
icon. And then I'm going to run this function.  
54:19 - I'm going to call the function to see okay, so 
my my BMI is terrible. So it's just giving me  
54:25 - this sad option. So now I can come back again and 
then specify that my first output is a txt. Again,  
54:33 - I want to do txt for the second output as well 
very good. If you want a different output, you  
54:37 - can still do it. But in my case I want text output 
as well. So run it come back here launch it again.  
54:46 - And once you launch it is going to give you 
the application and then you can see okay,  
54:51 - name is let's let's say Mars, maybe hide. A 
good mom. and weight is 58 Something submitted.  
55:05 - And then you can see, it's a happy face. The 
reason we have a happy face is primarily because  
55:12 - the BMI is less than 30. So if I go back to 
the same example, like for example, I should  
55:16 - be in meters, right? I should have ideally 
divided this because height isn't centimeters,  
55:23 - let me add centimeters, and then divide the height 
by two, I 100. Run this, and then try the code  
55:39 - and try the code on getting okay, it's because of 
order of precedents, my code is getting Messier  
55:49 - with all the parenthesis but that's okay. So 
now, I have defined height and centimeters  
55:54 - weight in kilograms and come back and launch 
it again. Then maybe this time, we can say  
56:02 - Mars and Jupiter, other names. Height in 
centimeters, okay, I didn't give centimeters.  
56:09 - It didn't get updated with this, okay? submitted.  
56:13 - Okay, the app did not refresh one last 
time. Let's refresh this. Launch ID.  
56:24 - And identity because here, one little 
quarter, height and centimeters on 60.  
56:32 - And then when you say BMI is 32, and you're sad, 
and your BMI is less. Okay, you're still sad.  
56:39 - Okay, let's reduce the weight. And then 
ideally, now you're happy because your  
56:43 - BMI is less than 30. So technically, 
we have managed to build an application  
56:48 - with two outputs. Again, if you want to change 
the name of the output, again, that's something  
56:53 - that you can change within your output as well. So 
basically, what we have managed to do here is if  
56:58 - taken multiple inputs, and we have done multiple 
outputs. And this is this is quite important,  
57:04 - because in a lot of cases, for example, let's say 
you're doing doing neural style transfer, usually,  
57:09 - for neural style transfer, you would have multiple 
outputs, sorry, multiple inputs and one output.  
57:15 - So you need to know how to do multiple inputs 
and multiple outputs. And that's quite simple.  
57:21 - You have to match the number of arguments that 
you're getting in your function with a number  
57:25 - of inputs, and all you have to do is the type of 
input. So one of your input could be a slider,  
57:30 - one of your input could be text, another input 
could be a number, another input input could be  
57:35 - an image. So you can you can have these multiple 
formats as well, which is not just, you know,  
57:39 - like numbers and all these things. Like for 
example, let's say like, suddenly we are deciding  
57:44 - that we want to add a checkbox, okay. And I 
want to I want to add something new. So that is  
57:51 - feeling okay. And based on feeling I wanted to 
say something, okay, so we'll say if feeling this  
58:01 - true, okay, then, then we'll do text is equal to 
happy. Yeah, and we're going to send feeling also,  
58:12 - sorry, text, we have to send the text. Okay, now 
this one, I'm going to make a Boolean out of it.  
58:18 - Okay, and how do we make a Boolean out of it 
or a checkbox. So my last attribute here is  
58:26 - gr dot inputs dot check. The check box is checkbox 
and you can see when I want to make a checkbox,  
58:35 - I have to specify default is false, right default 
is false and the label is your feeling today  
58:44 - and then everything else is fine. So we have 
the text as well. So we have a third text and it  
58:55 - ran the function again and then launch it. Now 
at this point, technically, you should have one  
59:02 - extra check box. So check box is selected 
something something height weight selected,  
59:12 - that is an error. There is an error and 
what is the error Okay, so we have got  
59:23 - three inputs 1234 Our four inputs 1234 
Okay, I think the problem is because  
59:37 - if get let me let me even do this  
59:44 - text is equal to if feeling is sad, okay. 
And let me run this and then try with this.  
59:58 - So we have one 12341234. Okay, that's done. 
And then let's run this, let's launch.  
60:09 - And then let's see this thing. So let's see 
if we can if we can get rid of the error  
60:17 - successfully worked, right, so you have 
output one, output two, output three.  
60:20 - And then you can disable the feeling, and then run 
it again, you get sad. So basically manage to add  
60:26 - a new type of input without any problem. So you 
have multiple types of input, multiple formats of  
60:31 - input, and also multiple formats and types of 
output that this done. So because we have got  
60:36 - a bug, maybe this is a very good opportunity 
for us to try. Try out the debugging option.  
60:43 - So what I'm going to do is I'm going to 
make the same mistake that we did before.  
60:47 - And the mistake was just using like this, right, 
so this was a mistake that we had. And there is  
60:54 - a way for you First, identify using this, for 
example, we can we can do like this. But if it  
60:58 - is false, it would probably throw an error like 
you can see the error. But but let's forget this  
61:03 - kind of debugging for a moment. And then let's see 
if we can find a way to debug here. So what I'm  
61:08 - going to do is I'm going to say debug is equal to 
true. And the launch date here. They did just say,  
61:17 - okay, sorry, I have to add debug 
is equal to launch. So that was  
61:21 - silly of me. So I'm going to do debug is equal to 
launch. When I do the same, it's going to launch  
61:28 - with the debugging option. Ok. So it says this, 
this cell will run indefinitely, so that you can  
61:34 - see the errors and logs. So if you want to turn 
it off, again, you have to go back and then say  
61:38 - debug is equal to false. So what we are going 
to do now is we are going to say something,  
61:43 - and then we are going to select some value, select 
some value, and then click. So your, your value is  
61:50 - good. So you have got all output, the problem 
arises when you have false value. When you  
61:56 - submit now, there is an error. Okay, so you 
can see that there is an error. Now that error,  
62:03 - because we have enabled debugging mode, that 
error is displayed here, which wouldn't have been  
62:07 - displayed otherwise. So now you can see the error 
local variable text referenced before assignment.  
62:12 - So which means saying it gets the same error that 
you would get when you're doing like a ripple  
62:17 - or interactive environment. So this will, again 
help you to debug, so I've just taken the liberty  
62:22 - of making a mistake to explain you that this is 
there. So all I can do is I can just add an else  
62:28 - or I can just go with list comprehension. Then 
fix this, and come back again in debugging mode.  
62:35 - Right? Come back again, in debugging mode do 
interface. And you can see all these are not  
62:42 - running because this launcher still running. 
So I'm going to stop it, everything has ran,  
62:47 - and then run this again, then try this out. 
But now the debugging mode is still true.  
62:55 - So you have the mode set. True is happy done. 
And false is error. Again, because this because  
63:03 - because we didn't run it. So ideally, you 
understand the point. The point here is,  
63:08 - once you once you've, once you have a mistake 
or a bug or an error, it's very important for  
63:14 - you to debug it the same interface that 
you have, you don't want to you know,  
63:17 - juggle between lots of different interfaces. 
So the easiest option for you to do that is  
63:22 - debug is equal to true. So once you do debug is 
equal to true, then you will be able to debug the  
63:28 - file. So we'll have a slightly extended debug 
session in the next section. But if you simply  
63:35 - want to debug this is your way to debug. So in 
this section, we just learned how to improve  
63:42 - your gradle web application with multiple inputs, 
multiple outputs, same format, different format.  
63:48 - And we also played around with a bunch of 
options for us to see how it works. And we  
63:53 - also made a deliberate mistake to understand how 
do we go about debugging. So in the next section,  
63:58 - we'll also learn a slight extension of how 
more to debug or log what is happening there.  
64:10 - This section, we're going to know a little bit 
more about debugging your radio web application.  
64:15 - And also, radio has a nice feature called 
flagging. And we are going to look more into that.  
64:20 - First, let's start with debugging in the previous 
section at the end, you might have seen that we  
64:24 - try to debug. So extending that we're going 
to see what kind of errors that we might face  
64:29 - and then some debugging options that we have. 
The first thing that you need to make sure  
64:33 - whenever you are building your radio application 
is that the function that you are using for your  
64:38 - radio application, the number of arguments in 
your function should be equal to the number of  
64:44 - elements in your inputs. And also the number 
of arguments or number of items that you are  
64:48 - returning should be equal to the number of items 
or elements in your output. So the first thing  
64:54 - very important thing that you need to make 
sure that it is right. The second thing is  
64:58 - the type of the argument For example, here name 
is a text, make sure they input his text. Here,  
65:04 - if you have an output text, again, make sure that 
it is an output text. So whatever the type is,  
65:09 - make sure it is that type so that you know, you 
know the types have not messed up, because you're  
65:14 - not going to compile anything and check. So it's 
always good to have you have this validation,  
65:19 - like, if you're creating a checklist of test 
cases, this is something that you should do.  
65:24 - And let's say that you have, you have done 
all these things, right. And then you have  
65:26 - built an application. But still, if you want to 
validate whether your application has any error,  
65:32 - and this is how you have to debug it. 
And the way if you want to debug this,  
65:36 - basically you have to enable debug is equal to 
two. So debug is equal to true is just a function,  
65:44 - like an extra argument that will help you enable 
display error messages. If you want error messages  
65:50 - to be displayed while the radio application is 
run, which is like which is linked to run without  
65:56 - stopping, then you need the need to enable 
debugging, like debug is equal to true.  
66:01 - So let me quickly give you an example. And 
then we'll move on to the next section.  
66:05 - So if you see this thing, for example, here, we 
have got height and weight and feeling right. So  
66:11 - by default, let's say if I don't have debug is 
equal to true. Okay, I have this thing here.  
66:17 - I'm going to give some name, right? And then I'm 
going to have something here. And if I submit,  
66:24 - it worked, but let's say if I keep it 
like this and submit you see an error.  
66:28 - Now do you know why this error is happening? 
Now, of course, you wouldn't know why this  
66:31 - error is happening, even though like probably, 
if you're a math whiz, you would have probably  
66:36 - predicted by this time, but yeah, let's assume 
that you are an average programmer. So you don't  
66:41 - know why the error is happening. And that's 
why it's important for us to enable debugging,  
66:46 - like this. And then after we do that, so it says 
the sale will indefinitely run like we saw before.  
66:51 - So it's going to run all the time, so that you can 
try a lot of different things. And then you have  
66:56 - the error log in place. So now I'm going to do 
the same thing, I'm going to put the name and then  
67:00 - keep it zero, keep it zero, and then submit. So it 
shows error, the moment it shows error is going to  
67:06 - also show the error message. And the error message 
here is zero division error. So float division  
67:12 - error. So basically what has happened here is that 
this is a thing that you wouldn't have probably  
67:19 - anticipated when you created this application, 
because now you're dividing weight by height, and  
67:24 - then height cannot be zero, because you're going 
to get divisible by zero error. And what is the  
67:29 - ideal solution, you can you can go to your code, 
you can change everything, you can handle the  
67:33 - test conditions. Or if you want to simply make a 
change, you can just come back here in the slider,  
67:37 - you can start with one so that your user can 
never go to zero. So let's run this and run this.  
67:46 - And now again, most likely, you are starting 
with one. So even if somebody submits something,  
67:52 - there is no way that they're going to 
hit zero in this case. So this is again,  
67:56 - a very typical example of how do you find out an 
error and then fix an error using RADIUS debugging  
68:02 - method. So if you want the debugging method to be 
enabled, and a lot of other things. So basically  
68:06 - the same way you debug your Python programming 
code, so you can debug your radio application in  
68:11 - a very similar way, with debug is equal to true 
enabled while you're launching the application.  
68:16 - Now that is said. So the other important 
thing that I just talked about is flag. I  
68:21 - just told the start of the section, that flag is 
another very interesting case. So what is flag,  
68:27 - the flag is a button that helps you flag any 
erroneous or unexpected behavior, the output. So  
68:35 - you could be running a model and then suddenly you 
see something weird. You can use flag, you could  
68:40 - you could have like let's say my segmentation 
model, and then you're trying to find out  
68:44 - which images have done well, which images have not 
done well. So you can just click flag, whenever  
68:49 - you see the images have not done well. And you 
could you could use this for a lot of purpose.  
68:53 - But what happens when you click flag? That's 
the most important question, right? Let's say  
68:57 - you have an internal machine learning team and you 
have created an application and given it to them.  
69:01 - And that team whenever they find out something, 
we are some, let's say some bias some something  
69:07 - unexpected happening in the model behavior or even 
this calculation, something weird is happening,  
69:11 - right? So now we want to flag the team that 
has created this application. So what does it  
69:17 - mean? What does the team see when we create flag 
here? So let's do a couple of flags. And I'll let  
69:22 - you know. So first, there is a flag. So let's do 
one more thing. And then we'll say another flag.  
69:30 - Okay, so we have flagged at this point, we have 
flagged two items in this case. So now what  
69:36 - happens here is when you create flag, ideally 
there is a flagged folder that gets created. So  
69:42 - I've stopped it and then if I go back, there is a 
flagged folder. So when when we go to the folders,  
69:47 - let me refresh the folder. And you can see there 
is a flagged folder and there is a lock here.  
69:52 - Let me copy the path of this folder. Come back 
here and then use pandas to show you what is there  
69:57 - import pandas as PD. PD dot read underscore CSV 
the path. And then you can see the instances,  
70:06 - you can see the instances, what is the 
name? What are the inputs that were given?  
70:10 - And what was the output. And these are flagged. 
So this is to help the machine learning team  
70:16 - or ml ops team, whatever the team that 
is going to look into the model issues  
70:20 - to check, what are the items that are flagged by 
the users or internal testing or whatever that is,  
70:25 - right. So whenever you flag something, there is a 
new entry that is made here. And, and that entry  
70:31 - is used in the future, to evaluate the model or 
the performance of the application. So right now,  
70:37 - what you saw is an application that just had 
text. So now what happens when you have images,  
70:43 - what happens when you have images, right? For 
example, we had we had an application like this,  
70:47 - what happens when you have an image like this, 
when you have an application that has images,  
70:51 - both the input and output images gets stored, 
unlike this, where you have text, where you have  
70:57 - everything in tabular data only, and you don't 
have anything else, right, so if you go to the  
71:01 - folder, you wouldn't see anything else other than 
dot CSV. But when you have images, the actual  
71:05 - images or any other media type for that matter, 
the actual media content itself is stored inside  
71:10 - that follows making it easier for you to evaluate 
what has gone wrong. This is a very important  
71:16 - aspect. Again, when you're going to use gradient 
for retraining your machine learning model or  
71:21 - improving your machine learning model, this is 
quite important and useful to us. And again, a lot  
71:26 - of people who build radio might not be very aware 
of this thing, because you know, just exist there.  
71:30 - But yeah, efficiently using flag can improve your 
machine learning model can help you identify,  
71:36 - there is a bias. Like for example, let's say you 
put together a machine learning model. And then  
71:40 - you've created a radio wave application, you have 
a published data hugging face basis or somewhere,  
71:45 - you can explicitly tell your users saying that 
if you find anything interesting or weird,  
71:51 - then please go ahead and click flag because 
that will help us improve the model, eliminate  
71:56 - the biases, or you know, be more robust. So you 
can tell this explicitly in the description that  
72:03 - you have a description right like you, you can 
like you can write a description here like this.  
72:09 - And then flag if you find any erroneous output, 
okay, so I can run this. And then I can let me  
72:20 - disable it. And then it can run when it runs 
it descriptor flag, any flag if you find any  
72:28 - erroneous or put some having this message 
very clearly as part of the application  
72:33 - could help people understand that when they 
see something wrong, they have to flag and that  
72:38 - comes to you as a very well structured 
data which you can use in the future,  
72:42 - to fix your machine learning model or do 
anything that you want to do with the data. So  
72:46 - one aspect of debugging in radio is actually 
you know, using the debug is equal to true.  
72:52 - But I'm also including this in this section, 
because I believe that if you our machine learning  
72:56 - model doesn't work well. If your machine learning 
model is doing something semantically wrong,  
73:01 - not syntactically but semantically wrong. Only 
the user who is actually seeing the output can  
73:06 - tell you that thing and that human intervention 
could be made, the flag could be raised using  
73:11 - this flag button. And that could be extremely 
useful in a lot of different cases. One thing that  
73:15 - you would want to note when you're talking about 
flaggers. So right now the flag content is in the  
73:23 - the actual folder, like the current folder, but 
if you want it to be in a different folder, then  
73:28 - you have a flagging directory. So you can have 
a separate directory, you can specify a separate  
73:34 - flagging directory. And that will probably enable 
you to have this flagging, like flagged content in  
73:42 - a different directory altogether if you want it 
to be in a different directory. But otherwise,  
73:45 - everything is good here flagging is extremely 
helpful. This is how you do debugging. And  
73:50 - these are some things that you 
should pay more attention to.  
73:53 - And in the next section, we will learn some 
quirks and nuances about radio application.  
74:04 - So far, we have learned all basic and 
very important things about building a  
74:10 - radio application. So in this section, we're 
going to learn how to enhance or improve your  
74:15 - existing radio application that looks better 
that does better It has better user experience.  
74:20 - And to start with, we are going to talk 
about examples in radio application.  
74:25 - So what is examples? For example, if you have 
a radio application that looks like this,  
74:29 - sometimes the user might get confused. What 
do I have to give here? What do I have to do  
74:33 - here? What do I have to do here? And to avoid this 
confusion, usually in user experience, if you see  
74:39 - a lot of existing tools, like I can quickly show 
you a tool that I came across recently, which is  
74:43 - called shield or how when you go here, it's still 
loading. But when you see this thing you can see  
74:49 - there are suggested commands. So these are like 
examples. So instead of somebody trying to figure  
74:54 - out what to type here, a good user experience 
would always be very intuitive where people can  
74:59 - just click And then select it. In a very similar 
user experience. Principle, radio also has got  
75:05 - something called examples. And I'm going to show 
you how to do examples in this section right now.  
75:11 - So let's start with the example. An example is 
quite easy. What do you want to do with example,  
75:16 - for all the input, you're meant to give an 
example value. So I'm going to come here,  
75:21 - and then say, after output, I'm going to say 
examples. Okay, and here, I'm going to just,  
75:27 - I'm going to select what all examples I'm going 
to give there. Like the the previous examples are  
75:33 - nothing but predefined answers. So I'm going to 
have a list. And within that, I'm going to have  
75:38 - another one. And the first one is, let's say, one 
little coder name. And then the second one is,  
75:43 - let's say 100. And the third one is, let's say 
50. And then the fourth one is true. Okay, so this  
75:50 - is one example. The next one, I'm going to copy, 
let's say, Mars 120 3020. Yeah. And third example,  
76:03 - like, we will stick to three examples, let's 
say moon, and then 200. Or maybe we can use u  
76:15 - and Moon. Under third 150 kilos,  
76:18 - and then false. So we have three examples. Now 
when we run this application, invalid syntax.  
76:29 - Because we didn't add the commodity, that's 
why it's invalid syntax. When we launched this  
76:33 - application, at this point, you would see this 
application being launched with examples. So  
76:39 - you can see, there are three examples. So when you 
have a great new application that looks like this,  
76:44 - if you don't know like, let me even open this 
video application separately, so that it's easier  
76:49 - for us to see. So when we have this great new 
application, it might be difficult at first for  
76:54 - somebody to know what to fill. So what they can 
do is we have examples, all I have to do is click  
76:59 - this application, and then submit, then they will 
get the output, click this example, click Submit,  
77:06 - and then give the output. So it becomes very easy 
for anybody to click something and then get an  
77:11 - output rather than themselves typing something. So 
this is very important for a very intuitive user  
77:16 - experience. And thanks to gray area for offering 
this because this is what a lot of good web  
77:22 - applications, especially to give intuitive user 
interfaces. So whatever the type is, like if you  
77:27 - have an image, you can give image as an example, 
if you have tabular data just like us like not  
77:31 - tabular data necessarily, but text and numerical 
data and Boolean values, you can have this. So  
77:36 - for whatever type of data that you have, you can 
specify examples. Very simply, just by defining  
77:43 - another parameter here that takes different list. 
Like you have multiple lists multiple examples,  
77:48 - you don't want to also give like 1020 Different 
examples, examples should be like one or two.  
77:53 - In this case, we have taken three examples. 
So example is a very, very important way for  
77:58 - us to improve the user experience of the radio 
application. So that is one important thing. So  
78:05 - you need to know when to use example, and how to 
use example. And that's what you just learned.  
78:09 - The second thing is, what if you don't want to 
click submit all the time, what if you want it to  
78:15 - be reactive, so if you have seen stream late, 
if you have seen are shiny, or if you have seen  
78:20 - even Tableau, like there are a couple of instances 
where you can select an option, and then suddenly,  
78:24 - it is reactive. So certainly you would see the 
output rather than somebody going and clicking.  
78:29 - And for that, within this, like within the greater 
interface, you have an argument called life.  
78:36 - If you say live is equal to true currently, by 
default, live is equal to false. If you say life  
78:42 - is equal to true, then you don't have to submit 
every time. And that's what we're going to see  
78:48 - now. I'm going to disable the exam. Okay, let 
me keep the examples and say, life is equal to  
78:56 - true, right? And then let's run it. And 
let's run it again. Is it going to restart,  
79:03 - imagine? So I have this thing here, right? I have 
this thing here. But you can see that there is no  
79:09 - submit button at this point. So submit button 
is gone, because it's live. So all I have to do  
79:14 - is I can go here and then select it. And then 
you can see the output. I have to go here and  
79:18 - let me zoom out a little bit. Yeah, all I have to 
do is go here, select it, you can see the output,  
79:23 - I can go here selected, you can see the output 
selected, you can see the output. So basically,  
79:28 - you are eliminating one extra step. So this is 
useful in some situations, not in some situations.  
79:34 - For example, if you have a situation 
where model inference takes a lot of time,  
79:38 - then you wouldn't want this to happen. Because if 
somebody like by mistake, click something silly,  
79:43 - no good start processing. So you would want that 
explicit submit button in those kinds of cases.  
79:48 - In cases where you like, for example, this case, 
right? We don't necessarily want somebody to  
79:52 - click Submit. In cases like this, you can like for 
example, you change the slider, it would it would  
79:58 - change. So in cases like this, this makes sense. 
But in some other cases, it may not make sense.  
80:03 - But live radio application is another useful 
feature because it again improves user experience  
80:08 - with a submit explicit submit action button 
action is not required. So if you think an  
80:13 - explicit action, like submit is not required, 
then you can then then you can actually have,  
80:22 - then then you can actually have this thing 
in place, which is a live application. So,  
80:28 - the next way to improve user experience 
is we discussed in the previous section  
80:34 - about flagging. So, flagging can also 
have multiple options. For example,  
80:41 - instead of just simple flagging, we can say 
flagging options, equal to, so we can say, is no,  
80:50 - maybe something like that, okay, and then run 
it and run it. And now when you run this thing,  
80:58 - you can actually see flagging options. So you 
instead of like, for example, let me click this  
81:03 - thing, and you have three flagging options, all 
you have to do is hover your mouse on it, you have  
81:07 - three flagging options. So as you know, maybe, 
and these things, these values might also get  
81:12 - recorded. So flagging again, instead of keeping 
a simple plugin, for example, let's say you want  
81:16 - to build a text annotation, some, like simple 
annotation tool. So now all you have to do is  
81:22 - like you can have all your entities here. And then 
you can ask somebody to annotate. So as simple as  
81:25 - that, even if you have a major whatever that is, 
or maybe like a prediction is right or wrong or  
81:30 - not, right, so you can again, use this to 
actually do unit testing under flag flag,  
81:37 - not only when something goes wrong, but also you 
can use this to kind of label things on the go  
81:43 - while you're building your machine learning model. 
Again, flagging options is extremely helpful,  
81:47 - because you can use it for something more 
than what flagging is supposed to do.  
81:52 - So flagging is very, very helpful. So far, 
we have seen examples. So far we have seen  
81:57 - live application. And also we have, we have 
seen different options in flagging. The final  
82:03 - thing that I wanted to highlight here, which 
I'm not going to show you right now is using a  
82:09 - state. So what is the state? Let me quickly 
show you state here. Radio getting started.  
82:22 - I'm going to copy the example from radio page. 
So what is the state? So one thing that you know,  
82:29 - very clearly is that every time you 
click Submit in your grading application,  
82:33 - the entire app resets. That's, I 
think that's something that we all can  
82:37 - agree. There is no persistence of data here. So 
anytime you submit something, the data is reset.  
82:42 - What if you want to have persistence of data? What 
if you want to use a data point or a data from the  
82:50 - previous before submitting to the next instance. 
And that's where state comes into picture. And  
82:55 - state is quite common, again, in full stack 
development. So if you want to create a state  
83:01 - that persists outside of a single function 
call, which means you need a global variable,  
83:06 - right? So you need something that is outside this 
function like outside the function that you have  
83:09 - this function, if you want, if you have a use case 
like that, then you need to set state and the chat  
83:17 - message is a typical example, right? Why chat 
messages, a typical example, somebody says hello,  
83:22 - and then you replay Hello. And somebody says, 
How are you, you will say I'm fine. Now in the  
83:27 - application, you want all these messages to be 
there, you don't want every time to you know,  
83:32 - initialize with empty message, because you want 
the previous data to be there. And that is where  
83:38 - state is quite helpful, because you want the data 
to persist across multiple submits. Okay, so let's  
83:45 - look at this demo quickly. And then we can see 
how it works. So quickly see the demo of state.  
83:52 - I'm running this thing. And again, like I said 
before, this is an example straight out of  
83:57 - radio documentation. So messages, 
hello. And then I'm going to submit it,  
84:01 - you can say hello. So it says, the next message 
is, how are you? And then I can see how are you  
84:08 - okay, you can see the response, you can see the 
response here, right? So and this is important,  
84:15 - because you want that message to persist as 
well. So that's why state is very important.  
84:20 - And you can refer data, I'm not getting 
deep into it, because that is again,  
84:25 - a topic for a separate, you know, Section 
altogether. So to avoid that, I'm just saying that  
84:31 - you can go to the Get Started page in radio. Also, 
you can check in the documentation about state.  
84:36 - So this is what the purpose of status to have 
something beyond the function like to create  
84:41 - like a global variable or to the function call, 
so that even when you when you load this thing,  
84:47 - it doesn't there is persistence. And the very best 
use case that you can think of is you want to load  
84:53 - a large model. And every time you want to load the 
model, you don't want it to be refreshed if you  
84:57 - have if you have the model being loaded inside In 
this, you don't want it to get refreshed all the  
85:02 - time. So you want to load the model outside the 
function. And then inside the function you do,  
85:06 - everything gets like inference, right. So. So that 
is a very good use case and states could be used  
85:11 - there. So explore state more. And that could be 
really, really helpful for you in improving your  
85:17 - radio application. So, if you need a variable that 
should be persistent outside the function call,  
85:24 - then set state is the function that you should 
set state and get state is a function that you  
85:30 - should be looking at, to store and retrieve 
the persistent data that you have created.  
85:36 - So that is state and the final state then. So 
we have seen examples, we have seen live radio.  
85:43 - And we have seen state. And the very final thing 
that I want to talk about improving your radio  
85:48 - application is grid, your themes, and grid, 
your CSS. So grid your application by default,  
85:53 - you would see something that looks 
like this, I'm going to remove,  
85:56 - I'm going to remove the flagging options, 
I'm going to remove the description,  
86:00 - I'm going to even remove the live option, okay. 
So by default, you would see the radio application  
86:05 - that looks orangish, which is in line with that 
radio color. But but sometimes you want something  
86:11 - else, right? So sometimes you want to, you want 
to try something else, like you want a different  
86:16 - color combination, you want a different thing. 
So Gradle has two options for that for you. One  
86:21 - gradient has got seen so quickly showing 
theme. So you have the default option,  
86:26 - you have hugging face option, you have 
grass option, peach option, dark option.  
86:30 - So you have got different themes. The second 
one is rather than using the existing theme,  
86:36 - the theme that is available on all these themes, 
you yourself can actually create custom CSS.  
86:41 - So you can use custom CSS option to create theme. 
And that is again, another important feature if  
86:47 - you want to try out something. So we are going 
to explore these two options now. So theme and  
86:52 - custom CSS. First, let's start with theme. So I 
have a Grady obligation that looks like this. And  
86:59 - maybe you know what I can I can do side by side. 
It doesn't it doesn't let me do side by side.  
87:07 - Okay, I thought I can just show it side by side. 
It doesn't allow me to do that. That's okay. So  
87:14 - first thing that I want to do is I want to enable 
a theme. Okay. So theme of theme is equal to what  
87:24 - is the theme name? Let's start with the hugging 
phase. And then we'll go to some dark theme. And  
87:29 - I run this thing and run this, you would see the 
theme color changing. It's you can see. Now the  
87:38 - theme theme has changed. Like it's an this is the 
hugging face theme. Right? So it's cleaner. And I  
87:44 - would actually say like it's cleaner if you want 
no no offense to existing default Dario theme,  
87:50 - but yeah, it's it's cleaner. If you want a 
different theme, let's say like you want a  
87:54 - dark theme, then you can just go like dog beach, 
or dog default. Maybe we can do doc freaking face.  
88:01 - Let's let's try how it looks. Doc. Okay, and 
this and this, and then see how does it look?  
88:10 - Well, this is quite nice. This is again, a very 
pleasant dark theme. So you can you can see the  
88:15 - font is white in color. You select something, you 
submit something, you have everything in Word in  
88:20 - color. So this way you can play around with the 
theme, right hugging face thing, let us say you  
88:26 - have played around with this thing. But there 
is one thing that you don't like necessarily,  
88:31 - and you want to change that. And that's where your 
CSS is going to help. So one thing that you can  
88:35 - do with CSS is you can for example, let's say you 
want to change the background color to something.  
88:39 - So I can go here, say CSS is equal to and 
then I can I can add the CSS, I'm going to use  
88:47 - multi lines just to keep it easy for me. And 
then I'm going to say background color. This  
88:59 - Okay, let's run this, run this. And then you 
would see the change in the color. Ideally,  
89:07 - it didn't change. Okay, let me 
disable the theme. And then see.  
89:16 - You can see after I disable the team because 
the team overrides the CSS. So after you  
89:20 - disable the theme, you can see the color of the 
background has changed. Like if you want to, let's  
89:24 - say like a different color altogether. 
Let's say you want you want, let's say,  
89:29 - yellow, maybe terrible option. 
But again, just for demo purposes.  
89:33 - If you want a background color to be a low 
end color, you can you can again change it.  
89:42 - In the previous section, we learned how to 
improve the user interface and user experience  
89:47 - of our radio web application. So we learned 
about examples. We learned about life mode.  
89:52 - We also learned a little bit about state and then 
finally we learned about themes and CSS custom CSS  
89:58 - to redesign our Radio web application. In this 
section we are going to learn how to share the  
90:05 - radio application with anybody in the world. And 
also the most important aspect is do you want  
90:09 - everybody to see that? Or do you want to add an 
authentication page before anybody could access  
90:14 - your radio application. So the first thing is, by 
default, when you launch your 3d application, you  
90:20 - would get a URL like this, and that that URL stays 
for 72 hours. So you can get this URL, and then  
90:26 - share it with everybody, anybody in the world. And 
then they can use the URL for 72 hours. But if you  
90:32 - want to make it explicit, there is an attribute 
called share. So if I say shared is equal to true,  
90:40 - whether to create a publicly shareable link from 
your interface, so you can say share is equal to  
90:45 - true. And that will also give you the same 
URL if you want. And then the next thing is,  
90:52 - you don't have to only share the app. But 
also you have the ability to share the APA,  
90:57 - which is something that not a lot of people 
who do so APs are very helpful. For example,  
91:02 - if you want to integrate this, let's say you 
have a JavaScript based stack available, and you  
91:06 - want to integrate this machine learning solution 
inside JavaScript based solution, the easiest way  
91:11 - for you to do is to use an APA. So what Grady also 
gives you is the APA with also some starter code.  
91:18 - So for example, the A for this particular 
app, when I click this view, the APA you  
91:24 - can see that there is an APA here, and then that 
APA says like this interface takes four inputs,  
91:30 - returns three outputs, the URL endpoint, you can 
copy. And these are the input types. These are the  
91:35 - output types. This is how the payload is going to 
look like. And this is how your response is going  
91:41 - to be. And also you have couple of examples where 
you have a Python code, you have a curl code,  
91:46 - and you have a JavaScript code. So if you want to 
check it, you can go here, and then click Post,  
91:52 - and then you would get the response yours. Or if 
you want to try it on your Google collab as well,  
91:58 - you can come back here and this and then 
say, okay, okay, true, we have to say true.  
92:08 - And then see if you have the outputs or the time 
it took the data input, sorry, the data output,  
92:15 - and then again, the time it took. So if you 
have multiple calls, then you can see the  
92:18 - average time otherwise, it would mean the same. 
So basically, not just the app that you can share  
92:23 - with the world. But you can also share the API 
where anybody can make a call to the endpoint,  
92:28 - and then get the result that they want. 
Instead of saying get the result should say,  
92:32 - post the response, post the request, then get the 
response. Yeah, whatever it is. So one, take this  
92:43 - link, share the link with anybody, they would be 
able to access the app, second, add slash APA, or  
92:50 - the EPA link that you can get from here, and then 
share it with anybody, they can use it the second,  
92:56 - now that we know how to share a radio 
application with the entire world.  
93:01 - The next important thing is, do you want to share 
it just like that, or you want to share it with  
93:06 - an authentication page. So now we are going to 
learn how to add an authentication page on top of  
93:13 - a radio application. So basically, when somebody 
clicks this link, it makes sure you're listening.  
93:18 - So basically, when somebody clicks this link, we 
don't want them to directly see this app, we don't  
93:23 - want anybody in the world to see this app. But we 
want one least specific people who have access to  
93:29 - this application. So maybe let's say I have 
generated a username and password and given to  
93:33 - them, I want to only them to use this application. 
So if you want to add an authentication page,  
93:39 - what are we going to do, and that is quite 
easy and simple unexpectedly, usually,  
93:44 - adding an authentication page could be another 
overhead. But it is extremely simple here because  
93:48 - all you have to do is when you're going to 
launch the application, all you have to do  
93:52 - is you have to give up. And also if you want 
any if you want to write only if you want any  
93:59 - HTML message on the authentication page. 
So I'm going to show you how it works.  
94:03 - First, let's start with an authentication page. A 
simple authentication page, I'm going to say odd,  
94:08 - is equal to, I'm going to add a username password. 
So basically, I'm going to do like this A tupple  
94:14 - username, password, and the user name here. Let's 
say I'm going to say user. And then the password  
94:20 - I'm going to say is one little code. Okay, so this 
is the username, this is the password. Okay, I'm  
94:26 - going to run this. After I run this thing. I have 
got the app. So I'm going to click the link here.  
94:33 - And you can see it takes us to an authentication 
page. Let's say I'm going to give a wrong  
94:38 - username password first. I'm going to say user 
and the password, I'm going to say something else.  
94:43 - And when I do that, it says the server could not 
verify you, you either supplied wrong credential,  
94:48 - or your browser doesn't understand how to 
supply the credential. So the first thing is,  
94:53 - it works. It works. The authentication works. It's 
not letting anybody to log in. So now let's try  
94:58 - I'm going to give one little coded. And then 
you can see it has successfully taken us into  
95:05 - the application. So basically, we have managed to 
add an authentication page on top of our radio UI,  
95:12 - just purely with one single argument. 
So added a value username password to  
95:17 - auth argument. And then we have managed to add 
a login page. So let's refresh this, you can see  
95:26 - this because we have already authenticated. So 
let's run this again. And I wanted to show you  
95:31 - an extra thing. So when you run this thing, when 
you go here and see this thing, you can see the  
95:37 - login page does not have much details. Let's say 
you have shared the login details to somebody in  
95:42 - the email. And you want to make this in the 
login page itself. So that is where you have  
95:48 - an auto message. So I can say odd message. 
We can say check your strong login details.  
96:02 - Strong sent to your email. So we can 
see email. And if you want to add,  
96:13 - add an emoticon you can probably add an emoticon. 
So now you're hiding a login message also along  
96:20 - with the usual authentication page. And, like 
authentication message also. So let me click this,  
96:27 - go here. And then say it says, check 
your login details into your email,  
96:32 - and you have this thing. So this way people would 
know that they have to look at their Slack channel  
96:36 - or an email or discord or whatever it is, so that 
they actually know where the email is, once again,  
96:41 - let's let's just log in one little corridor. And 
then try, we have successfully managed to login.  
96:48 - So this is how it is quite easy and simple for 
you to add an authentication page to your ad  
96:54 - application. And, and it's quite simple. So all 
you need to do is you can give a tupple. Or also  
97:01 - you have another option. So you can either 
give like, like username, password topple.  
97:07 - Or you can you can take in different formats also 
like if you want or you can have a function also  
97:12 - like that takes username and password 
and then you know, validate something,  
97:15 - and then returns true if there is like the valid 
authentication, like let's say you have a dB,  
97:20 - you don't want to just give hard coded values, 
then you can do all those things. And also you  
97:24 - have the ability to provide an authentication 
message along with the login authentication page.  
97:31 - So this basically takes us to the end of building 
a radio web application. But this course does  
97:37 - not end here. We want to also deploy the radio 
application. So for what we have done here, as we  
97:42 - have managed to deploy the radio APPLICATION make 
it available on the collab interface with radio  
97:47 - link. But can you deploy this radio application 
on a post permanent hosting, and we are going  
97:53 - to see in the next section, how to deploy a 
radio application using hugging face spaces.  
98:05 - This is the last section of this course. 
And if you have made till this section,  
98:09 - congratulations, you have almost done 
something that nobody usually does.  
98:14 - So in this final video, we are going to 
learn how to deploy a machine learning radio  
98:21 - application permanently on hugging face spaces. 
So the first question that you might have is,  
98:27 - why couldn't we have done whatever we were 
doing already as something permanently. So if  
98:32 - you see this thing, this link, whatever you 
share, it is applicable only for 72 hours,  
98:38 - and the interface has to run. So after 72 hours, 
you might not get it then you have to rerun it  
98:43 - and then the URL might change you have a lot of 
these complexities. And to avoid that in a typical  
98:48 - permanent hosting space. You need a server where 
you want to host it and hugging face the company  
98:54 - the machine learning company that used to be the 
NLP company has made it really really easy for  
98:58 - anybody who uses radio or stream li to deploy very 
simply using an interface basis. So in this video,  
99:05 - I'm going to show you how I've taken an 
existing python script and then translated into  
99:11 - a great new application and then how are we going 
to deploy that. So the first thing if you see I  
99:17 - am using radio and transformers I am installing 
both this libraries and from import radio as here  
99:25 - and from transformers. I'm importing pipeline 
transformers is the hugging page library  
99:29 - pipeline is what we are going to use to 
build a very simple sentiment analysis tool.  
99:34 - So the pipeline name is sentiment analysis because 
that is the task that we are trying to do. And  
99:39 - after we do this thing, we are downloading all 
the pre trained models you can see the model  
99:43 - because we have not specified any specific model 
it has been defaulted to distill bird bass and Ks  
99:51 - fine tune SST to English. It's basically a fine 
tuned version of distal Bert. After that we need  
99:56 - an important function. So basically anything you 
want to do with If you're brand new application,  
100:01 - you have to wrap it around a function. So here in 
this case, we are doing a very simple function.  
100:07 - So the function name is get sentiment, and 
then it has an input text and it returns  
100:11 - as the sentiment output, the output would look 
like this, I'm not formatting the output here,  
100:17 - I'm just leaving it out. Because I want it to 
be simple for you to deploy the application,  
100:21 - I don't want to take a lot of time off you to 
modify whatever I'm trying to do. So it's going  
100:26 - to be very simple Grady obligation. So the output 
is just a text that looks like this. After that,  
100:33 - our function is at this point ready. So gets 
increment function is ready, input is ready, and  
100:38 - then the output is ready. And then we have also 
tested it right. So I can I can write something  
100:42 - saying that this course is super awesome. Okay, 
so that's my narcissistic view of this course.  
100:50 - So it says it's positive, it's 97%. Positive, 
that's a good thing. So it's positive and 97%.  
100:55 - And whatever you want to do, like, for 
example, this, this course is terrible.  
101:02 - So probably it should say it's negative. Well, 
it, yeah, it says negative. So basically, we have  
101:08 - managed to build a sentiment analysis solution 
using the deep learning model, which is distilled.  
101:14 - And then with just few lines of Python code, 
thanks to hugging face. Now, what we have to  
101:19 - do next is we have to take this script, the 
few lines of Python code and translate into a  
101:26 - radio application. And for that, we all know if 
you have watched all the videos of this course,  
101:31 - you would have probably known that we are going 
to say gr dot interface interface, ie with caps,  
101:37 - upper caps, the function name, the input text, 
we have only one text and then output text, we  
101:42 - have another only one text as output. And also we 
have the title, the title is sentiment analysis,  
101:48 - we can also add a description if you want, we can 
say add, get sentiment, negative slash positive  
101:58 - for the given input. Okay, so we have managed 
to create the interface that looks like this  
102:04 - maybe better ways to do like this, this would 
increase readability. But again, I don't know  
102:10 - why am I spending time on this thing, but every 
Okay, so right now we have defined the interface  
102:16 - with the object a phase. Now all we have to do is 
launch a phase. Let's see when we launch a phase.  
102:24 - So again, you don't have to do this on collab, 
you can do it on your local machine. And then  
102:28 - then finally, you know, connected with your 
hugging face pieces, get and then upload it,  
102:32 - I don't want to touch my local machine at this 
point. That's the whole reason I'm doing this.  
102:36 - Because I assume that a lot of people 
might be trying to do this using collab.  
102:40 - So that's why I want this deployment experience 
to be how you would do it on collapse. So  
102:45 - we have the title, we have the description, 
we have the input text. So let's go ahead  
102:49 - and then say this course, is freaking 
awesome. And I want little quarter  
103:00 - this seriously narcissistic, but I would take 
it still. So it's a label positive, we have  
103:07 - this thing again, like I said before, we are not, 
we are not formatting output. So just take text,  
103:14 - I'm throwing it just for the demo purpose. 
So now at this point, our sentiment analysis,  
103:19 - application is up and ready. Now let's see what 
we are going to do with hugging face faces.  
103:26 - First, go to Google, and then 
probably say hugging face spaces,  
103:32 - you would get this, you need to sign in. If 
you're hugging face spaces are meant recently made  
103:39 - open for everybody. So it's out of beta. So if 
you if you go if you have a hugging face account,  
103:45 - you can log in with that if you do not have, you 
have to click click create a new account. So I  
103:49 - already have a hugging face account. So I'm going 
to use login. I'm going to use my username sorry.  
103:55 - And then I'm going to use my password. And I'm 
trying to log in. So this is how my initial  
104:00 - dashboard or my space front page looks like. So 
now we have to create a new space. So I'm going  
104:06 - to create click spaces. After I click spaces, I 
can create new space. Let me see if I can change  
104:13 - the theme. The dark theme to 
light theme No, I couldn't change.  
104:18 - I hope it is readable for all of you. So 
click create new space. You can read the  
104:23 - documentation if you want. You can read you 
know like what is what you can do with the  
104:28 - stream written radio what kind of things you can 
do, how do you go about like the best practices  
104:34 - all these things? So the good thing is all 
the models that are available in hacking face  
104:38 - hugging face transformers are also available for 
you here with less hassle. So create a new space.  
104:44 - After you create a new space. We have to give 
a space name so I'm going to call it and radio  
104:52 - sentiment analyzer. Is there a good name, 
okay. And the SDK that we want to use  
104:59 - so great SDK. And do you want it to be public 
or private, of course, I'm habitable from  
105:05 - public. So at this point, you can see 
there is no application file your space,  
105:11 - when you open the app, it shows the like, there 
is nothing here. So you have to do certain things.  
105:17 - For example, you can clone this repository, 
if you're familiar with Git, you can clone  
105:21 - this repository on your local machine. And 
then you can create a simple app.py file,  
105:27 - and then that app.py file can can you know, show 
can be served as an application. And after you  
105:33 - create this on your local machine, then all you 
have to do is add the file to your Git commit  
105:38 - the file, and then push it and then it would come 
here to this particular folder, and then your app  
105:44 - is available to be served. But on the other hand, 
what we are going to do is we are going to do  
105:48 - everything on the browser, because like I said, if 
somebody wants to try it out, just based on Google  
105:54 - collab, like you have already used Google collab 
your local machine is not powerful enough, you'd  
105:59 - have you don't know get, you don't have rights. 
So to get if you are in any of these categories,  
106:04 - then preceding section is for you. So I'm going to 
use the Create button at the last. So let's open  
106:09 - the Create dot app, create app.py file the new 
tab, and then we have to copy our code one by one.  
106:17 - So you can copy one by one, or in my case, I've 
already copied everything. So I'm going to paste.  
106:23 - So the first line is to import radio. The second 
line is to transfer like import pipeline from  
106:28 - transformers. Then we have the sentiment analysis 
pipeline task. And then we have the function  
106:33 - that helps us to get the sentiment, then we have 
the interface. And finally we have the launch. And  
106:40 - once we have all these things in place, you can 
specify launch in lane is equal to false. As well,  
106:47 - if you if you don't want it to be in like 
usually you use inline is equal to false  
106:52 - when you are going to avoid the app to be 
embedded within your Google collab notebook,  
106:57 - like if you wanted to build on separately. So now 
at this point, everything is ready, let's go ahead  
107:02 - and then commit the new file we have successfully 
committed and you can see it is trying to build  
107:07 - but it will end in a building error. The reason 
why it will fall in a building error is because  
107:12 - we have to install the Transformers 
library. So even though hugging phase  
107:16 - spaces is actually on hugging phase still, you 
have to manually install the Transformers library  
107:21 - and also torch which has a dependency for 
transformers library. Before we install the  
107:25 - library right now there is an error, that's 
completely fine. I just wanted to highlight  
107:29 - the readme. So if you're using this template, 
by default, you are sorted out. But if you are  
107:35 - not using this, then then you need to make sure 
that you have this Yamal at the top, clearly,  
107:41 - because this is what this is really important. 
Without this part, the Yamal part of the talk,  
107:46 - your app would not be rendered properly on Korean 
face. So you have the title, you have the emoji,  
107:51 - you have the color, and you have the 
app file SDK, and the app file, which is  
107:55 - actually used to create serve the application. 
So let's quickly go ahead and then create a new  
108:03 - requirements dot txt file requirements dot 
txt. Oops. And then we need two things. One,  
108:10 - we need a torch. Second thing we need 
transformers. So ideally, we should be able to.  
108:16 - So the first thing is they are going to install 
these applications, libraries. And after that,  
108:21 - they will render our app dot phi and our 
app.pi. Because we have already tested it  
108:26 - should be successfully running. Let's see. 
You can you can never be sure. Okay. It says  
108:33 - it's running. So let's copy this URL, 
go to a new tab, and then paste it. Oh,  
108:40 - wait, I think I got a little exited. You have 
to copy the entire URL, go back here, paste it.  
108:49 - And then see, okay, it has successfully managed 
to work. And also it has got the dark theme  
108:55 - that is that goes well with the interface dark 
theme that we have spaces. So I'm going to give an  
109:01 - input text, probably I think I'm tired of seeing 
that discourse is awesome. So maybe for a change,  
109:06 - to say radio is awesome. And I thank the 
developers for this amazing tool. Let's submit.  
109:16 - Okay, it's positive. So maybe I can say Java 
sucks. And then you have negative so you have  
109:23 - basically positive and negative. And at this 
point, you have successfully managed to build  
109:28 - a full fledged machine learning deep learning 
powered application deployed at Deep Learning  
109:35 - powered radio application, and successfully 
deployed it on hugging face spaces. Now you  
109:40 - can copy this link and then give it to anybody. 
If you if you want anybody to use the API. Again,  
109:44 - you have this thing also available for you. 
So you have successfully managed to learn  
109:50 - everything from building a simple grading 
application to improving the UI of the application  
109:54 - and then finally hosting or deploying your 
application permanently on hugging face paces for  
110:00 - free at this point, I don't know whether they'll 
charge us later, but at this point for free, which  
110:05 - you can share it with anybody in the world. Thank 
you so much. Congratulations, we have reached the  
110:11 - end of this course. Thank you so much for watching 
this course. And I hope you found this course  
110:16 - really valuable in learning how to build a machine 
learning web application using radio and also to  
110:22 - deploy the application. You could use this for 
a lot of different purposes as it is described  
110:27 - in the course. And I would love to see the radio 
application that you have built during the course  
110:32 - of this course. If you have any more questions, 
please let us know in the comment section, you can  
110:38 - always reach out to us on Twitter. And also please 
make sure that you subscribe to our channel and  
110:43 - share it with your friends. I wish you the best 
for your machine learning journey. Happy coding