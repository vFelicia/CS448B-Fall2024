00:00 - learn all about the exciting new
00:01 - features coming with react 19 including
00:04 - baked in ways to handle actions
00:06 - optimistic updates form statuses the new
00:09 - use API and more you'll also learn about
00:12 - the new open source compiler that
00:13 - automates performance optimizations
00:16 - behind the scenes Bob Zero from scrimba
00:18 - developed this course join him to
00:21 - explore these Cutting Edge updates and
00:23 - more ensuring you're fully equipped to
00:25 - leverage the latest advancements in
00:27 - react development
00:31 - hi there and welcome to this mini crash
00:34 - course on everything that's new in react
00:36 - 19 at the time of recording react 19 is
00:39 - in release candidate status which means
00:41 - that it is very close to becoming the
00:43 - new major version of react and so I
00:45 - thought it would be really helpful to go
00:47 - through some of the new features that
00:48 - are coming in react 19 both new apis
00:51 - that are being introduced as well as
00:53 - general improvements to the react
00:55 - library and the react ecosystem in
00:57 - general in this course we're going to be
01:00 - starting actually with something that
01:01 - came with react 18 called use transition
01:04 - and the concept of transitions in
01:06 - general and there's actually two reasons
01:08 - we're going to start with that first of
01:09 - all if you've taken my introductory or
01:11 - Advanced courses in react you'll know
01:13 - that we don't cover used transition in
01:15 - either of those courses and so this is
01:17 - an opportunity for me to teach that
01:19 - topic but secondly the idea of
01:21 - transitions is going to be crucial in
01:23 - understanding the new actions that are
01:25 - coming with react 19 however before we
01:27 - get to actions we are going to very
01:29 - quickly talk about the new compiler
01:31 - that's coming with react this is a
01:33 - really exciting way that will simplify
01:35 - some of the performance optimizations
01:37 - that we used to have to make manually
01:38 - with react after that quick lesson we
01:40 - will jump in and talk extensively about
01:43 - this new concept of actions which is a
01:45 - great new paradigm in react that allows
01:47 - us to handle mutations in our data in a
01:49 - slightly different way actions will help
01:51 - us segue into the new hooks that are
01:53 - being introduced in react 19 we'll see a
01:56 - really quick update to how we can pass
01:57 - refs to custom components we take a look
02:00 - at the new use API and we'll top it off
02:03 - with a number of other miscellaneous
02:05 - improvements that are coming to react my
02:07 - name is Bobs roll I'm generally
02:09 - responsible for the react curriculum on
02:11 - scrimba these days I am most active on X
02:14 - online so if you wanted to give me a
02:16 - follow you can click my screen name
02:17 - there and it will take you to my profile
02:19 - and without further Ado let's Jump Right
02:21 - In we'll start learning about what's new
02:23 - in react 19 after we play a little bit
02:25 - of catchup learning about transitions
02:32 - one of the headliner features in react
02:34 - 19 is a topic called actions however in
02:37 - order to understand actions it's
02:39 - important that you have a solid grasp on
02:40 - the concept of transitions in react now
02:43 - you may already be familiar with
02:45 - transitions if that's the case you are
02:47 - welcome to skip the scrim in my other
02:49 - react courses which I teach on scrimba I
02:51 - don't yet cover the concept of
02:52 - Transitions and so for those that have
02:54 - taken my other courses this is a way to
02:56 - sort of catch up on the concept of
02:57 - transitions before we talk about actions
03:00 - now the example that I have here is only
03:02 - a slightly modified version from what
03:04 - you can find in the used transition
03:06 - documentation on the react Doc's website
03:08 - so if you've seen that then this should
03:10 - look kind of familiar this would be a
03:12 - good time if you want to just peruse
03:14 - around the code and see if you can make
03:16 - sense of it but I'm just going to give a
03:18 - quick highlevel overview of what's going
03:20 - on here inside of our app component
03:22 - we're maintaining some State this is
03:24 - kind of like mimicking a react router
03:26 - scenario where we're displaying
03:27 - something different depending on which
03:30 - tab is currently selected we have these
03:32 - three buttons here which essentially
03:34 - just set the state of the tab there's
03:36 - also some Styles happening so we know
03:37 - which one is currently active and then
03:40 - down here we are conditionally
03:41 - displaying different elements depending
03:43 - on which tab is set in the state if the
03:46 - tab is selected as products then we
03:48 - instead of rendering an H1 we render
03:50 - this products component so let's come
03:53 - down to the products component this
03:55 - product component will iterate over an
03:57 - array of products these products are
03:59 - coming from data. TS this is using a
04:02 - library called Faker JS to create an
04:04 - array of 1500 fake products and so it
04:07 - iterates over that and for each one of
04:09 - those 1500 products it renders a slow
04:12 - product component the slow product
04:14 - component has a little artificial
04:16 - slowdown for 1 millisecond so if we're
04:19 - rendering 1500 of them it will slow down
04:21 - for 1500 milliseconds or 1.5 seconds and
04:24 - we can see this in action if we click on
04:26 - the products tab I'm going to click it
04:28 - right now
04:31 - and that took about 1.5 seconds for this
04:33 - to finally show up on the page the
04:35 - concept that we're talking about
04:36 - Transitions and the use transition hook
04:38 - it's not going to fix that problem of it
04:41 - taking a long time for products to show
04:43 - up however there is a bit of a bad user
04:45 - experience that happens if we try to
04:47 - click products and then click to another
04:48 - tab let me go back to home I'm going to
04:50 - click products right now and then about
04:52 - right now and let me do that a little
04:54 - bit faster so we'll click products than
04:57 - about okay so products never loaded but
05:00 - it did wait before it shifted me over to
05:03 - the about page this is something that I
05:05 - do all the time when I'm browsing the
05:06 - web I click something and then realize
05:07 - oh actually I wanted to click this other
05:09 - thing instead the way react is working
05:11 - under the hood and this is the important
05:13 - part to understand when I click products
05:15 - react adds the changing of the state
05:18 - that's happening right here when I'm
05:19 - setting the tab to products and it puts
05:21 - it in a cue of State changes and it's
05:24 - going to go through and process that cue
05:26 - one at a time from top to bottom there's
05:28 - a bunch of other things that are
05:29 - happening regarding concurrent mode and
05:31 - state change batching and whatnot but if
05:33 - you think of it this way it will help
05:34 - make sense of use transition when you
05:36 - click products it adds this set tab to
05:38 - products at the top of this queue and
05:41 - then when you click about immediately
05:42 - afterwards it puts that in the queue as
05:45 - well below the changing to products as
05:47 - such react is going to prioritize
05:49 - switching to products first and then it
05:51 - will switch to about afterwards and
05:54 - because products is a really slow
05:56 - component to load we get this experience
05:58 - where we click products about and and it
05:59 - takes 1.5 seconds before it eventually
06:02 - just switches immediately to about and
06:04 - the whole switching to products just
06:06 - looks like it never really happened this
06:07 - scrim has gotten a bit long already I
06:09 - want you to take time to look through
06:11 - this code make sure that you understand
06:12 - it and in the next scrim we'll talk
06:14 - about how we can solve this using used
06:20 - transition let's see how we can use
06:22 - transitions to improve the user
06:24 - experience that we have with this tab
06:25 - switching issue that we're facing again
06:28 - what's happening when I click products
06:29 - and then click about immediately is
06:31 - react is queuing up those two State
06:33 - changes to happen back to back and first
06:35 - it tackles changing the state to
06:37 - products however changing our tab to
06:39 - products also includes rendering our
06:41 - products array which has 1500 slow
06:44 - products in it and so that state change
06:46 - takes a while to complete once it has
06:48 - completed that it immediately starts
06:49 - tackling changing the state to about
06:51 - which takes almost no time at all and so
06:53 - we get this phenomenon where we click
06:55 - products then about and it takes a while
06:57 - before it just immediately switches to
06:58 - about the idea of transitions is it
07:01 - allows us to teach react that certain
07:04 - State changes are interruptable in other
07:06 - words if I tell react that calling set
07:09 - tab should be interruptable in effect
07:11 - telling it that it's a lower priority
07:13 - State change instead of queuing up a
07:16 - switch from home to products and then
07:19 - queuing behind that a switch to about
07:21 - when I click products and then
07:23 - immediately click about react will say
07:25 - well I can stop doing what I'm doing I
07:27 - don't need to complete switching to
07:29 - products before I switch to about
07:31 - because this state change is discardable
07:34 - or interruptable it's a lower priority
07:36 - State change let's see the Syntax for
07:38 - implementing that it's really simple and
07:41 - then we'll see how it's working in
07:42 - action in order to set up a transition
07:45 - we will use the use transition hook this
07:48 - again was introduced in react 18 we
07:50 - haven't yet gotten to the new react 19
07:52 - features and at the top level of our
07:55 - component we will call our use
07:57 - transition hook use transition simp SAR
07:59 - to use state will return an array which
08:02 - has two items in it the first one we
08:04 - will call is pending we'll talk about
08:06 - that in a second and the second one is
08:08 - called start transition start transition
08:11 - is a function and we'll go ahead and
08:13 - call that start transition function this
08:15 - is a lot of functions but it takes a
08:17 - callback function as its argument and
08:20 - whatever state changes we make inside of
08:22 - this callback function will be marked as
08:24 - a lower priority or an interruptable
08:26 - State change so I moved my set tab just
08:29 - inside side of my start transition
08:30 - callback function here this is
08:32 - essentially all we needed to do to mark
08:34 - this as a lower priority State change
08:37 - okay Moment of Truth I'll click products
08:38 - than about perfect it has discarded the
08:41 - state change to products because it
08:43 - realized that there was a more important
08:44 - state change happening and that was the
08:46 - state change to about as such react was
08:49 - able to just discard the entire
08:51 - rendering of our lengthy and slow
08:53 - products component in favor of switching
08:55 - to about and in the end our user
08:57 - experience is better than it was okay
08:59 - let's talk about this is pending
09:01 - variable this is the beginning of where
09:03 - we start seeing that react is providing
09:05 - some really interesting things for us to
09:07 - use the is pending value that we get
09:09 - here is something that react gives us so
09:11 - that we can in our code provide some
09:13 - immediate user feedback as to what's
09:15 - happening behind the scenes because
09:17 - notice even when I click products there
09:19 - still is no user feedback in the 1.5
09:22 - seconds that it's taking for the
09:23 - products page to render and if you've
09:25 - ever handled something like this before
09:27 - you're probably very familiar with the
09:29 - idea of having to manage this yourself
09:31 - and saying something like loading and
09:34 - set loading is equal to a call to use
09:38 - State and probably initialized as false
09:40 - and then when you switch tab you would
09:42 - set the loading to true and when it's
09:45 - all done you would set the loading to
09:47 - false and maybe you handle errors and I
09:49 - guess that would probably happen right
09:51 - here and this kind of boiler plate just
09:54 - is so so common that react built it
09:56 - right into the value of is pending which
09:59 - is a Boolean value as to whether or not
10:01 - the transition is still happening now
10:03 - your imagination is the limit as to how
10:06 - you can use is pending to make your user
10:08 - experience so much better I'm just going
10:10 - to do a really quick thing down here
10:12 - where on top of rendering these three
10:14 - different things I'm going to say is
10:16 - pending and just a paragraph that says
10:20 - loading and there might be a better way
10:22 - to do this but just so that I'm not also
10:24 - showing these if the is pending is
10:26 - happening I'm just going to add not is
10:28 - pending on top of here here so that it's
10:30 - only rendering either the pending state
10:32 - or one of these items okay let's refresh
10:36 - I click about I click home and if I
10:39 - click products we'll see we get a
10:40 - loading State before all the products
10:42 - finally load this is a much better user
10:44 - experience now I could do the same thing
10:46 - with my setting of styles so that when I
10:48 - click products notice when I click it
10:50 - nothing happens to the button I could
10:52 - set up another style that says if is
10:55 - pending is true then change the style of
10:57 - the button to some sort of pending State
10:59 - showing the user that they did
11:00 - successfully click this button again the
11:02 - sky the limit for what you can do so
11:04 - this is really nice that react is
11:06 - handling this for us hopefully this
11:08 - gives you a good reminder of what the
11:09 - used transition hook does or if this is
11:12 - your first time hopefully that makes
11:13 - sense because now we're primed to start
11:15 - discussing the new topic of actions that
11:17 - was introduced in react
11:22 - 19 one of the biggest features that was
11:25 - just announced with react 19 is a brand
11:27 - new compiler this compiler that was just
11:29 - released in beta is an evolution of
11:32 - something from a number of years ago
11:34 - that was called react forget and
11:36 - essentially what this compiler can do is
11:38 - understand your code ahead of time and
11:40 - translate it into code that is more
11:43 - performant and bypasses some of the
11:45 - limitations with react that we used to
11:47 - have to handle manually if you've taken
11:49 - my Advanced react course here on scrimba
11:52 - you do have to be a PR member to access
11:54 - that course I have an entire section all
11:56 - about performance it goes into use memo
12:00 - react. memo use callback and as it turns
12:03 - out with the compiler we are not going
12:05 - to need those things anymore the
12:06 - compiler can take your code understand
12:08 - where the potential performance
12:10 - drawbacks are and it can automatically
12:12 - handle those use cases so at least how
12:14 - it's being build at the current time we
12:17 - just will no longer need to really
12:19 - understand or use react. memo react. use
12:22 - memo or react. use callback at the time
12:24 - of recording the compiler documentation
12:26 - was just released a day ago so you can
12:29 - click the screenshot here to go over to
12:31 - the compiler docs and as you see it's
12:33 - still under construction so it's very
12:35 - possible this will have changed by the
12:36 - time you get there not only that but the
12:38 - compiler was open- sourced and so
12:40 - there's a lot of really exciting things
12:42 - happening with the compiler behind the
12:44 - scenes in the op Source community so
12:46 - it's certainly possible that things will
12:47 - change soon in these docs you can see
12:50 - how you can get it all set up so if you
12:51 - wanted to play with it click the
12:53 - screenshot here to go to the docs and
12:55 - learn how to get set up as of now that's
12:57 - pretty much all there is to say about
12:59 - the compiler so now we're ready to move
13:00 - on to the next main headline feature of
13:03 - react 19 and that is
13:08 - actions another main headline feature of
13:11 - react 19 is a topic called actions and
13:14 - the concept of actions have been around
13:16 - in the web for a very long time
13:18 - essentially what we're touching on here
13:20 - is anytime you want to make what's
13:22 - called a mutation to your data when
13:24 - you're interacting with data from say a
13:26 - database usually you can divide these
13:28 - intera actions with that data into two
13:30 - categories one being loading or getting
13:33 - that data to display to your users and
13:35 - another being to mutate or change that
13:38 - data so that it can be updated in the
13:40 - database actions touch on that second
13:42 - category of making mutations in the
13:45 - react docs they say that by convention
13:47 - any functions that use async transitions
13:50 - are called actions personally I think
13:52 - this definition is a bit more confusing
13:54 - than it might be helpful although once
13:56 - you understand the concept of
13:58 - transitions as we talked about with Ed
14:00 - transition it starts to make a little
14:01 - more sense but essentially this boils
14:03 - down to giving you the ability to make
14:06 - data mutations in a native react way and
14:09 - we're going to see two ways in which
14:11 - that's the case the first and maybe most
14:13 - straightforward way that we now have
14:15 - using actions in react 19 is to provide
14:19 - the action prop to the form element in
14:22 - the HTML spec the form element is
14:24 - allowed to take an action prop and you
14:26 - might already be familiar with this if
14:28 - you've been developing for the web for a
14:30 - while typically the action prop is set
14:32 - to a string the idea being that when a
14:35 - user submits a form it will send that
14:37 - data to the end point or to the route of
14:40 - that string where the code will then
14:42 - handle the form submission validation
14:44 - and everything like that in react 19 you
14:46 - now can pass a function to the action
14:48 - prop in a similar way that we passed an
14:51 - onsubmit Handler to handle form
14:53 - submissions previously in react this is
14:55 - what we'll be looking at first but
14:56 - really quick another built-in way to
14:58 - handle a lot of common use cases with
15:00 - actions is to use a new hook called use
15:03 - action State this gives us some
15:05 - additional tools that can make these
15:06 - common use cases a lot simpler but we're
15:09 - going to get to that in just a minute if
15:10 - you happen to have taken my react router
15:12 - course here in scrimba you might
15:14 - remember a scrim where I specifically go
15:16 - in to talk about how forms in react are
15:18 - just really challenging to work with
15:20 - they've been a paino in react since
15:22 - essentially the beginning of react and
15:24 - in my personal opinion this direction of
15:27 - using the action prop and passing aun
15:28 - function to it is quite a bit simpler so
15:31 - let's actually take a look at that let
15:33 - me walk through the basics of this code
15:34 - first and then we'll see how we can
15:36 - simplify it using this new form action
15:38 - in typical fashion with react we tend to
15:41 - control the components of our inputs
15:43 - this means that instead of allowing the
15:45 - form to maintain its own information and
15:47 - its own State kind of like forms were
15:49 - built to do from the beginning of the
15:51 - web we use react to maintain that
15:53 - information instead so we're tracking
15:55 - the input text for our input field and
15:58 - that means that on every keystroke of
16:00 - this input field we update State we're
16:02 - calling this handle change function and
16:04 - it's updating our state right here so
16:06 - that react can then display that state
16:08 - as the current value of this form
16:11 - something has always felt a little off
16:13 - to me about this and I'm sure that there
16:14 - are great reasons for this but
16:16 - personally it feels a bit more
16:17 - convoluted than it needs to be then our
16:20 - form has an onsubmit Handler it prevents
16:22 - the default from happening because if
16:24 - you remember the default is for that
16:26 - data to be sent to another page which
16:28 - requires some some kind of navigation
16:29 - event on your form in JavaScript if we
16:32 - don't include this then you might
16:33 - already know this but the page will just
16:35 - completely reset and our JavaScript
16:36 - won't continue to run when it's trying
16:38 - to process the information from the form
16:40 - so we add this prevent default and in
16:43 - this case we have this fake function
16:44 - that sends the input value from the form
16:47 - over to our database it takes a bit of
16:49 - time for that to finish and then if it's
16:52 - successful we take the new name that
16:53 - comes back from this function call to
16:55 - our database and we set it in state
16:57 - that's what gets displayed here here in
16:59 - this blue text we reset our input back
17:01 - to an empty input and in this case we're
17:04 - just console logging any errors that
17:06 - might happen along the way if you've
17:07 - been writing react for a while you might
17:09 - already be very used to this but with
17:12 - form actions there's now A Better Way
17:14 - new to react 19 and you might already be
17:17 - familiar with this concept if you've
17:18 - used nextjs is we can now provide an
17:21 - action prop so I'm replacing this
17:23 - onsubmit with a prop called action and
17:26 - we can pass to it a function this
17:28 - function will need to change a little
17:29 - bit though since action is not an event
17:32 - handler like onsubmit was we're not
17:34 - receiving the event as the parameter but
17:36 - instead we're receiving the information
17:39 - from the form I'll call it form data of
17:41 - course we can call it whatever we want
17:44 - and this form data object is the native
17:46 - web form data object you could go to the
17:48 - mdn docs right now search for form data
17:50 - and you would find the object with its
17:52 - properties right there this is awesome
17:54 - because it means I have access to all of
17:56 - the information from the form without me
17:58 - having to track it in local react State
18:01 - technically speaking I did have access
18:03 - to this with the event where I could
18:04 - grab the event.target which was the form
18:07 - and I could use that to get all the
18:09 - information from the form as well but
18:10 - this way is a bit more native and a lot
18:12 - more intuitive now that we've changed
18:14 - the signature for our handle submit
18:16 - there's a number of other changes that I
18:18 - need to make first of all I can get rid
18:20 - of event.prevent default because I don't
18:22 - want to prevent the default anymore or
18:24 - rather that's being handled for me by
18:26 - react because I'm going to be grabbing
18:28 - the information from my form using this
18:30 - form data object I no longer need to
18:32 - track my state so I can get rid of my
18:34 - input State down on my actual input I
18:37 - can get rid of this value and onchange
18:40 - properties awesome and instead of
18:42 - passing in the input because I'm not
18:44 - tracking that anymore we're going to do
18:46 - this a slightly different way in order
18:48 - to grab data from my form I can call
18:50 - form data. getet form data objects have
18:53 - a doget property and this allows me to
18:56 - get information from my form based on
18:58 - the name attribute for the inputs in my
19:00 - form well in my case I don't have a name
19:02 - attribute so let's go ahead and add a
19:04 - name attribute and in this case we're
19:06 - tracking a name or a username so I guess
19:09 - it's name equals name in this case to be
19:11 - clear this part needs to be name this
19:13 - part can be whatever you want maybe a
19:16 - name field was a confusing choice but
19:18 - that's okay so because the name of this
19:20 - input is the string name I can use doget
19:24 - name and this is how I can get access to
19:27 - the data from that form input let's look
19:29 - through the rest of this new name should
19:31 - stay the same I don't need to set input
19:33 - anymore so I can get rid of that line of
19:35 - code and as far as I can tell oh we can
19:39 - probably rename this from handle submit
19:41 - to I don't know whatever we want maybe
19:43 - form action and we'll just change it
19:45 - down there just to be clear that we're
19:47 - not doing a submit Handler anymore and
19:49 - our code is quite a bit simpler let's go
19:51 - ahead and hit save oh and I can get rid
19:54 - of this whole handle change function cuz
19:56 - I'm not using it anymore okay let's hit
19:58 - save again and let's try typing in Bob's
20:01 - roll I'll hit enter which will submit
20:03 - the form a couple seconds later it
20:05 - changes and updates exactly like it was
20:08 - before I personally really like this
20:10 - direction that react is heading in using
20:12 - the native form data object using forms
20:15 - with their native capabilities of
20:16 - maintaining their own State and
20:18 - accessing that state in the way that
20:20 - forms have been dealt with since the
20:22 - beginning of forms on the web okay now
20:24 - this isn't the full picture there are a
20:26 - number of other things that we would
20:28 - normally want to take care of manually
20:29 - but since we've already covered a lot of
20:31 - ground in the scrim feel free to play
20:33 - with the code as always and when you're
20:35 - ready we'll move on when we'll start
20:36 - talking about other benefits that come
20:38 - with react
20:42 - 19 at this point we're really only
20:44 - handling the happiest path when it comes
20:47 - to submitting our form in other words
20:49 - we're assuming that the call to the
20:51 - database is going to work and right now
20:53 - we are catching the error but we're just
20:55 - displaying it in the console usually
20:57 - we'd want to to provide some information
21:00 - to the user about what went wrong also
21:02 - we have no kind of pending or loading
21:05 - State happening on this form right now
21:07 - so when I type in a new username and I
21:09 - hit enter right now there's a lag of
21:12 - time that happens while it's speaking to
21:13 - the database before our current user is
21:16 - able to update and we don't give any
21:18 - feedback to the user that submitting the
21:20 - form is actually doing something in the
21:21 - background historically in react this
21:24 - would mean that we would need some
21:25 - additional States and so we would set up
21:27 - something like a loading and set loading
21:31 - this would be with State and maybe we'd
21:35 - initialize it as false and then pretty
21:37 - imperatively or manually we'd have to go
21:40 - to our action and say okay first we're
21:42 - going to set loading to true and then at
21:45 - the end of our block here we're going to
21:48 - set loading to false and if we wanted to
21:52 - do the same thing with error States we
21:54 - would need to track the error and so we
21:57 - might have error and set error in state
22:01 - again and maybe we'll start it as null
22:04 - and I need my equals there of course
22:06 - then at the beginning of our form action
22:08 - we'd want to make sure that we reset any
22:10 - errors that might have happened from
22:12 - previous submissions that had errors and
22:14 - here we might set the error to the error
22:17 - that comes back okay and then normally
22:20 - with those new pieces of State I would
22:22 - conditionally render some elements on
22:24 - the page like a paragraph that says
22:26 - loading or a loading spinner and
22:28 - probably a paragraph that says that an
22:29 - error has happened in this case because
22:31 - our form action is happening in a
22:34 - transition I believe this doesn't
22:36 - actually work the way we think but the
22:37 - point is that we had to do a lot of this
22:40 - manually because form actions run as a
22:43 - transition if you remember an action by
22:45 - convention is a function that uses async
22:47 - transitions these updates for the state
22:50 - are considered low priority and so
22:52 - inside of our action we're actually not
22:54 - able to update the UI in the same way
22:56 - that we had done before with an event
22:58 - handler because updating State both with
23:00 - whatever error we might be getting back
23:02 - and stuff like loading States is such a
23:05 - common use case react has given us a new
23:08 - hook and that new Hook is this use
23:10 - action state that we saw very briefly if
23:12 - you want to learn more about the use
23:14 - action State hook you can click the
23:16 - little Pi symbol down here in the bottom
23:18 - that will take you to the documentation
23:19 - for it or you can stick around with us
23:22 - because in the next Grim that's what
23:23 - we're going to be talking about we'll be
23:25 - turning the common use cases that we see
23:27 - here and using the use action State hook
23:30 - in order to get this functionality back
23:32 - so that's what's coming up
23:37 - next let's see how we can use the use
23:40 - action State hook to gain back some of
23:42 - the functionality that we want when it
23:44 - comes to maintaining State and loading
23:46 - errors and so forth inside of an async
23:48 - transition or an action the use action
23:51 - State hook gives us a way to track and
23:53 - change component State a pending status
23:56 - that automatically gets flipped for us
23:58 - back back and forth by react and gives
24:00 - us a wrapped action function that we can
24:02 - use in our form as the function that we
24:05 - pass to the action prop although the
24:07 - truth is these action functions don't
24:09 - have to be used in forms there are other
24:11 - ways that you can use them as well we
24:12 - just so happen to be using them in a
24:14 - form as it's going to be one of the most
24:16 - common use cases for actions so let's
24:18 - see exactly what this looks like I'm
24:20 - going to get rid of these two State
24:22 - Creations that I had before and
24:24 - everywhere that I'm changing them in my
24:26 - code so that's here and here we can just
24:28 - get rid of this finally all together and
24:30 - okay we're back to where we were before
24:32 - let's go ahead and pull in the use
24:35 - action State hook and at the top of my
24:38 - function I'm going to make a call to use
24:41 - action State and this is where the API
24:44 - for this hook differs a bit from what
24:46 - you might be used to with used State we
24:48 - know that we get a state value and we
24:51 - get a function to update that state with
24:53 - use action State we actually get three
24:55 - values back so I'm going to destructure
24:58 - the array that we get back the first
25:00 - item is going to be the state that we
25:02 - want to maintain inside of our component
25:04 - this is very similar to what we had
25:06 - before the second is going to be the
25:08 - action function and this action function
25:11 - we're going to provide in just a minute
25:12 - over here but while I'm doing this I'm
25:14 - going to make sure I update my form
25:17 - action to be this new wrapped action
25:19 - function that gets returned by calling
25:21 - use action State and in the case of this
25:23 - hook there actually is a third value
25:26 - often times in the documentation this
25:28 - value is called is pending because we're
25:30 - destructuring an array you could call
25:32 - this whatever you want I think just to
25:33 - distinguish it between the loading that
25:35 - I had before I'm going to stick with is
25:37 - pending this represents a Boolean value
25:40 - either true or false that will
25:41 - automatically update for us depending on
25:43 - the current status of the form if the
25:46 - form is submitted and things are
25:48 - happening in the background as part of
25:49 - the transition that react is performing
25:51 - then it will update is pending to be
25:53 - true and this gives us a chance to put
25:55 - that paragraph down in our return value
25:58 - where can indicate that things are
25:59 - loading or do a loading spinner or
26:01 - whatever it is you want to use okay
26:02 - that's going to be great so in use
26:04 - action state I'm going to provide two
26:07 - values the first value will be a
26:09 - function we'll fill this out in just a
26:11 - second and the second value is going to
26:13 - be my initial State this reminds me a
26:15 - lot of the array reduce function where
26:18 - we provided a function that allows us to
26:20 - alter the state and as a second
26:22 - parameter the initial state that it
26:24 - should start with the first time it runs
26:26 - in our case we do have some states that
26:28 - we care about in this component and that
26:30 - is our name State here so what I can do
26:32 - is just take the name State initial
26:34 - value that I gave it before and I'll
26:36 - just paste it in right here let's put
26:38 - these on their own lines so they're a
26:40 - little bit more readable okay now what
26:43 - do we do about this function well this
26:45 - function is the action that we want to
26:47 - run when the form gets submitted or
26:49 - again whenever this action function gets
26:51 - run so I want you to think for a second
26:53 - is there anything that we already have
26:55 - in our component that we can use as the
26:57 - contents for this
27:02 - function well we already wrote Our form
27:04 - action function down here and so I can
27:07 - either just take the name of that and
27:09 - put it right here or if I really wanted
27:11 - to I could take the contents of this
27:13 - function and just stuff it right in here
27:15 - in the use action State I think I'm just
27:17 - going to leave this here because we
27:19 - already wrote it out because I'm going
27:21 - to be using use action state to maintain
27:23 - the state of my component I shouldn't
27:25 - need this Ed State anymore so we'll go
27:27 - ahead and and clean that up and
27:29 - currently the only thing I'm tracking is
27:31 - that name state so I could maybe just
27:34 - choose to call this name so that I don't
27:36 - have to update everywhere else to say
27:37 - state so we'll do that for now this will
27:40 - be changing very soon all right at this
27:42 - point we have bitten off quite a big
27:44 - chunk of new information and there is
27:46 - one more thing that we have to make sure
27:47 - we cover when it comes to use action
27:49 - State and that has to do with this form
27:51 - action function however because we're
27:53 - trying to process a lot of information
27:55 - here we're going to do that in the next
27:57 - lesson instead
27:58 - however before just pushing ahead if you
28:00 - feel confused at all about what's going
28:02 - on here take the time to mess around
28:04 - with this code also don't be afraid to
28:06 - go over to the use action State
28:08 - documentation and just try to read a bit
28:11 - more about it in fact the funny thing
28:13 - about these slides these links that you
28:15 - see will actually lead you to the what's
28:17 - new in react 19 blog post and that's
28:19 - because when I recorded this that blog
28:21 - post did represent the most updated API
28:24 - for these new hooks whereas the actual
28:26 - documentation has not yet yet been
28:28 - updated to show the brand new apis for
28:30 - them so the documentation is not
28:32 - currently correct as I'm recording this
28:34 - but that blog post is so those links do
28:37 - lead you to the blog post and hopefully
28:39 - you'll get some helpful information
28:40 - there if you need to watch this again to
28:43 - help things sync in that is completely
28:45 - okay and in the next lesson we'll tackle
28:46 - updating form action so that it will
28:48 - start working again the way that it was
28:50 - before but this time with a few extra
28:52 - benefits so once you're ready we'll move
28:54 - on to that
28:58 - if you're familiar with the concept of
29:00 - reducers in Redux or use reducer in
29:03 - react you might already understand what
29:05 - we're about to talk about the react team
29:08 - has chosen to make this action function
29:10 - that you pass as the first parameter to
29:12 - use action State work in a similar way
29:14 - to use reducer as things currently stand
29:17 - this is not yet going to work and that's
29:19 - because this function doesn't just take
29:21 - the form data as the parameter but it
29:23 - also will receive the previous state for
29:26 - our component as its first parameter and
29:29 - then the job of your form action
29:31 - function assuming you want this state
29:33 - value which we're calling name in this
29:35 - case to be updated correctly the job of
29:38 - Your Action function is to return the
29:40 - new version of State whatever it should
29:43 - be before we were calling set name in
29:46 - this case we're going to return the new
29:48 - name notice that we're not making use of
29:51 - this preate value we're going to in just
29:53 - a minute but by returning the new name
29:56 - that means that react will will take the
29:58 - return value from calling our form
30:00 - action function and it will
30:02 - automatically update this name value for
30:04 - us and rerender the components that
30:06 - anywhere we're referring to name like
30:08 - down here will be correctly displayed to
30:10 - the user okay let's see how we're doing
30:13 - here let's go ahead and change this back
30:15 - to my name Bob's roll I hit enter it
30:17 - does still take a couple seconds and we
30:19 - don't yet have those pending values but
30:21 - it updated correctly awesome okay now
30:24 - that we're back in a working State let's
30:26 - actually start improving the user
30:28 - experience here and we're going to do
30:29 - this with the
30:31 - challenge if you're already relatively
30:33 - experienced with react then this might
30:35 - not be much of a challenge for you but I
30:36 - want you to figure out how you can
30:38 - display a paragraph with this loading
30:40 - text of course this is more of a
30:41 - placeholder for a much better designed
30:44 - loading spinner of some sort but it
30:45 - should display this loading paragraph
30:47 - whenever the action that you're running
30:49 - is still in the process of running I'm
30:51 - not going to get too much more detailed
30:53 - there because I think this is probably
30:55 - obvious enough and if it's not that's
30:57 - okay it's a good time to play around
30:59 - with the code and look at the values
31:00 - that you have access to to see if you
31:02 - can figure it out and I guess let's go
31:04 - ahead and just put the paragraph right
31:06 - here pause now and work on this
31:13 - challenge the key lies in this is
31:16 - pending value that we're getting back as
31:18 - the third item in this destructured
31:20 - array that we're getting back from 's
31:21 - action State the cool thing about is
31:23 - pending is react is already going to
31:25 - handle flipping it from false to true
31:28 - and true to false for us behind the
31:29 - scenes so I just already have free
31:32 - access to this is pending value we'll go
31:34 - ahead and say if is pending is true then
31:37 - let's go ahead and display this
31:39 - paragraph right here let's clean up the
31:42 - challenge text hit save and test this
31:46 - out I'll hit enter we get a loading
31:48 - value which is awesome that gives some
31:50 - kind of user feedback and then when it's
31:52 - done the loading value goes away it
31:54 - flipped back to false and the update
31:56 - finished okay I want to do a bit of a
31:59 - sanity check here because we have
32:01 - covered a lot of ground we have gotten
32:02 - rid of all manual State creation that we
32:05 - had before we originally had the input
32:08 - which tracked every keystroke of our
32:10 - input we had the name that we were
32:12 - saving we also at one point created
32:14 - State for the loading State and the
32:17 - error State and we've since removed all
32:20 - of that instead of the input we're
32:22 - letting the form track its own
32:23 - information just the way forms have
32:25 - always done in the past for the state
32:27 - that does affect how this component
32:29 - displays in this case just the name
32:31 - that's showing up in this blue text use
32:34 - action State gives us access to a state
32:36 - that we can update inside of the
32:38 - function that we passed to it in this
32:40 - case called form action actually you
32:41 - know what now that I think about it form
32:43 - action and action function are confusing
32:45 - names for this lesson let's go ahead and
32:48 - have this say something like update name
32:51 - this way this function can focus on
32:53 - doing the one thing it's supposed to be
32:55 - doing which is to update the name and
32:57 - we're not going to get bogged down in
32:58 - the term of action function or form
33:01 - action and other equally confusing names
33:03 - the state that we're getting back from
33:05 - use action state is going to be
33:07 - determined by whatever we decide to
33:09 - return from our function in this case
33:12 - the update name function cently we're
33:14 - only tracking the string name but in a
33:16 - second we're going to do this and
33:18 - include an error State as well we're
33:20 - also getting the is pending value just
33:22 - for free by using use action State this
33:25 - allows us to avoid having to track that
33:27 - state by ourselves and we're able to
33:29 - determine what the initial state would
33:31 - be just like in used State we can say
33:34 - blah blah blah equals use State and then
33:37 - provide an initial value right here we
33:40 - can essentially mimic that same thing in
33:43 - use action state by providing this
33:44 - second parameter if you don't care what
33:47 - the initial state is you can just put
33:49 - null here okay let's finally tackle the
33:51 - error State and see how we can provide
33:53 - feedback to the user when there's some
33:55 - kind of error when we're trying to
33:56 - update the name in the database or
33:58 - communicate with our server whatever the
33:59 - error might
34:04 - be the way we currently have this
34:06 - written the state that we care about
34:08 - with our component we are tracking just
34:10 - in this name value it's just a string
34:13 - however if you've ever used Redux and
34:14 - dealt with reducers in Redux or you've
34:17 - used use reducer or if you've ever just
34:19 - tracked your state using an object
34:21 - instead of simple primitive values like
34:23 - strings or booleans you might already be
34:25 - familiar with the idea of having your
34:27 - state that you're tracking in your
34:28 - component be an object rather than a
34:31 - simple primitive value so instead of
34:33 - grabbing my initial State just from
34:36 - local storage and having it be a string
34:38 - let's update this state so that it's an
34:40 - object instead and actually I'm going to
34:43 - make this a
34:44 - challenge okay your challenge is to
34:46 - update the state that we're getting back
34:48 - from use action state to be an object
34:51 - that will involve changing this initial
34:53 - State here and that object should have a
34:55 - name property instead of just being a
34:57 - bare primitive string value then I'd
35:00 - like you to change this from saying name
35:02 - to saying State and then update anywhere
35:04 - in your component that is currently
35:05 - referring to name to make it reference
35:07 - the correct thing so that things are
35:09 - still working exactly like they are now
35:11 - I'll give you a little bit of a hint
35:12 - most of this is straightforward the one
35:14 - thing that might be tricky is right here
35:16 - on line 25 you'll need to make sure you
35:19 - don't forget to return the correct value
35:21 - of State inside of your update name
35:23 - function okay I think that's enough
35:25 - information pause now and work on this
35:26 - challenge
35:33 - all right let's do this one by one so
35:35 - instead of just having this be a bare
35:37 - value I'm going to wrap this in curly
35:38 - braces and give it a name property just
35:41 - like that that should be everything we
35:43 - need there then personally I think it
35:45 - makes more sense to call this state
35:47 - because it now represents the state of
35:49 - this component instead of just the bare
35:51 - name value down inside of my return I
35:54 - have here referencing name but now
35:56 - that's going to be state. name and I
35:59 - guess that's the only change that needs
36:00 - to happen there and then this one
36:02 - instead of returning the string value
36:03 - for new name I'm going to return an
36:05 - object with a name property just like
36:08 - that this is one of those refactors
36:10 - that's not going to look like it really
36:12 - did much at all we'll go ahead and put
36:14 - in a new username we get our loading
36:16 - State and cool our name has updated and
36:18 - everything still seems to be working
36:20 - okay Bob now why did we go through all
36:22 - that trouble well because we're tracking
36:24 - an object we now can contain multiple
36:26 - pieces of State inside of this one state
36:29 - value whereas before we needed to track
36:32 - the error in its own separate error
36:34 - State like this using use State we now
36:37 - can track error information just inside
36:39 - the same state that we got back from use
36:41 - action State and again this is where if
36:43 - you've ever used used reducer or
36:45 - reducers in redex it's going to feel
36:47 - pretty familiar let's go ahead and add
36:50 - to our state an error value I'll start
36:53 - it off as null in this initial State and
36:55 - because that's getting kind of long let
36:57 - me put these on their own lines okay
36:59 - great well now we finally need to take
37:01 - this error message that we were catching
37:03 - inside of our catch block here and
37:05 - figure out a way to display that to the
37:07 - user and that's actually going to be
37:09 - your next
37:11 - challenge okay your challenge is to take
37:13 - the error message that is just currently
37:16 - being logged to the console right now
37:17 - and move it out into the UI so that the
37:20 - user gets meaningful feedback as to what
37:22 - went wrong by the way if you had a
37:24 - chance to look at the code for this
37:26 - update name in database it's really not
37:29 - doing anything with the database it's
37:30 - just waiting for, 1500 milliseconds and
37:33 - then updating local storage with the
37:35 - name that was provided I do have this
37:37 - little case in here though that says if
37:38 - anywhere in that new name there's the
37:40 - text error then it will throw an error
37:42 - so you can trigger the error by just
37:45 - typing in error that's probably the
37:47 - easiest way and hitting enter now the
37:49 - trickiest part about this challenge is
37:50 - going to be using the previous states to
37:53 - make sure that you don't get rid of the
37:55 - name property that used to be there it
37:57 - would be easy to just return an object
37:59 - that has an error property but doing so
38:01 - would eliminate the state. name and you
38:03 - would get some weird undefined values
38:05 - and then you'll want to display the
38:07 - error message I put a little placeholder
38:09 - right here where you can do that and I
38:11 - think that's all the information you
38:12 - need pause now and work on this
38:19 - challenge okay let me just get rid of
38:21 - the console. error cuz that's not really
38:24 - very useful to our users and instead
38:26 - we'll go ahead and return an object and
38:29 - that object should have an error
38:31 - property which will be the value of the
38:33 - error object that we're catching in this
38:36 - catch block because of the way
38:38 - JavaScript works if I have the same
38:40 - property and variable name I can
38:42 - actually just get rid of one of them so
38:43 - I'll just say error however if I don't
38:46 - return the name property then this state
38:49 - variable here will no longer have a
38:51 - state. name and then we'll have
38:53 - something like state. name being
38:55 - undefined and we just don't want that to
38:57 - happen so I will make sure to include a
39:00 - name variable and I'll just give it
39:02 - whatever the previous states name
39:04 - property or value was if you've used
39:07 - reducers or maintained State objects
39:10 - before you might be saying well can't I
39:12 - just spread in all of the previous state
39:14 - and then overwrite the error and yes you
39:17 - can in fact this is the way that I
39:19 - prefer to write it however just for the
39:21 - sake of clarity I think it's a little
39:22 - easier when you're learning this to see
39:24 - it written out this way the last thing
39:26 - that I'm going to do and I actually
39:27 - didn't mention this in the challenge
39:29 - text was I want to reset my error to
39:32 - something like null when the user is
39:34 - trying to update their name in the
39:36 - database again I don't want that message
39:38 - to stick around from before I'm actually
39:40 - not 100% sure this is necessary let's go
39:42 - ahead and test it out we'll keep it this
39:44 - way for now down here where I'm
39:45 - displaying the error I'm going to say if
39:48 - state. error is truthy or it exists then
39:52 - I want to display a paragraph and I did
39:55 - previously come up with a class name for
39:58 - this uh that's just called error and
40:00 - I'll just stick in states. error.
40:03 - message there might be an issue here
40:06 - let's clear out the challenge text and
40:09 - hit save let's try to submit error we
40:12 - get loading and perfect awesome we get
40:14 - failed to update name the name did not
40:16 - update so that's good we wouldn't want
40:18 - this to say error as well as telling
40:20 - them that the name didn't update
40:22 - correctly and uh just for curiosity sake
40:25 - let's go ahead and take this out like we
40:26 - were saying and see what happens if
40:29 - first I get an error and then I try to
40:32 - update it to Bob okay well for the most
40:34 - part that seems to work just fine I
40:36 - think it's maybe nice to be a bit more
40:38 - explicit and say we're setting the error
40:40 - back to null but uh at this point we're
40:42 - kind of splitting hairs now we've talked
40:44 - for a long time but in the end all we
40:46 - really did was add this error state to
40:49 - the state that we're tracking from use
40:50 - action State and then update our UI and
40:53 - our logic a little bit the only other
40:54 - update I might choose to make here if
40:57 - you noticed if we had an error we get
40:59 - our error State that's great but I'd
41:01 - kind of like to be able to click update
41:03 - and have that error disappear
41:05 - immediately right now if I click update
41:07 - it sticks around while it's talking to
41:09 - the database I think the easiest way to
41:11 - fix that would just be to say as long as
41:13 - we're not is
41:15 - pending and there is an error then
41:18 - display the error message this way if
41:20 - pending is true then that's just going
41:22 - to disappear and I guess we can test
41:24 - this we'll hit error so that we get our
41:26 - air state we'll say Bob's roll there we
41:29 - go okay the error message went away as
41:31 - soon as I submitted my form okay wow
41:33 - that was a lot of information on use
41:35 - action State however that does represent
41:37 - a huge new addition to react 19 so it
41:40 - warrants spending a bit of extra time so
41:42 - that we really understand what's going
41:43 - on under the hood there are a couple new
41:46 - awesome hooks that were included with
41:47 - react 19 and those will fit naturally
41:49 - into exactly what we're working on now
41:51 - so that's what we're going to do next by
41:53 - talking about use optimistic
41:59 - it's really important as we're
42:00 - developing our applications that we
42:02 - handle any potential error states that
42:04 - might happen however if we were to
42:06 - really look at the stats at how often
42:09 - errors occur versus how often our
42:11 - interactions with our server and our
42:13 - database just kind of work the way that
42:14 - they're supposed to I'm sure that we
42:16 - would find that a vast majority of those
42:18 - interactions with the server work out
42:20 - just fine I guess if that's not the case
42:22 - for your app then you have a couple
42:24 - other issues you might want to work out
42:26 - especially with your back developers one
42:28 - of the things that we can do is
42:29 - optimistically update our user interface
42:32 - when we submit something or make a
42:34 - mutation with the assumption that things
42:36 - are going to just work out and then if
42:38 - for some reason they don't work out we
42:40 - revert it back to a previous state doing
42:43 - this makes a huge difference in the
42:44 - snappiness of your app it can feel like
42:47 - it's truly happening natively and some
42:49 - of that loading State stuff can really
42:51 - just be removed so that the user feels
42:54 - like the app is immediately responding
42:56 - to their in puts for example if I'm here
42:59 - and I type a new username and hit update
43:01 - it would be ideal if the absolute
43:03 - instant that I click update it just
43:05 - updates up here and I don't need to
43:07 - worry about it loading or thinking about
43:10 - the round trip that's happening to the
43:11 - server as a regular user I just want it
43:14 - to update and that's where the new use
43:16 - optimistic hook comes in use optimistic
43:19 - has an API that's very similar to Ed
43:21 - State and it provides an optimistic
43:23 - state that can update to the user
43:25 - immediately and behind behind the scenes
43:27 - it will automatically be reverted if
43:29 - there is some kind of problem that
43:31 - happens in the background so let's see
43:34 - the Syntax for use optimistic first I
43:36 - need to make sure that I pull it in from
43:39 - react so we'll get use optimistic and
43:42 - right below my use action State we'll go
43:44 - ahead and pull in the optimistic name
43:48 - and a set optimistic name again this is
43:51 - very similar to the API for use state
43:54 - but we'll call use optimistic and then
43:56 - the key difference here is instead of
43:58 - giving it kind of an initial value like
44:00 - Anonymous user or whatever we're going
44:02 - to pass to it the value that we're
44:04 - trying to have it track between renders
44:07 - that will make a bit more sense to us in
44:09 - just a second by doing this we now have
44:11 - optimistic name which we can display
44:14 - immediately to the user instead of
44:15 - displaying state. name we'll go ahead
44:18 - and display the optimistic name and then
44:20 - we also need to make use of set
44:22 - optimistic name and actually that's
44:24 - going to be a challenge just to make
44:26 - sure you're alert and awake and paying
44:28 - attention your challenge is to figure
44:30 - out where would you run the set
44:32 - optimistic name so that it will update
44:35 - immediately when the user submits the
44:37 - form in fact you should place it where
44:38 - you think it should be and then test out
44:40 - the code and see if ultimately if it's
44:42 - working as soon as you hit update the
44:45 - name that's displayed should immediately
44:47 - update and if you submit some kind of
44:49 - error like Bob error and hit update it
44:52 - will display Bob error briefly and then
44:55 - it will revert back to the name that it
44:57 - had before and display the error message
44:59 - time to get your hands on the keyboard
45:01 - pause now and work on this
45:08 - challenge well it's this update name in
45:10 - DB function that is causing the delay
45:13 - that just is naturally happening as
45:15 - we're speaking to our server so even
45:17 - before we do that I'm going to call set
45:20 - optimistic name and we'll pass in the
45:23 - form data doget name like we're doing
45:25 - down here so that it can just
45:27 - optimistically set the name immediately
45:29 - before this await update in DB happens
45:32 - and that should be all that I need to do
45:35 - this set optimistic is pretty powerful
45:37 - we'll hit update I'll change this to Bob
45:39 - and hit enter and look at that we have
45:42 - Bob immediately and we did see that
45:44 - loading while the update name in
45:45 - database was still happening but in the
45:47 - end loading went away and we already saw
45:50 - what was happening in fact it almost
45:52 - feels like we really don't need that
45:54 - loading State anymore but let's tackle
45:56 - that in a second first of all I'm going
45:58 - to submit an error I'll hit enter we see
46:00 - error up here and then it reverts back
46:02 - to Bob and it gives us some user
46:04 - feedback that says that it failed to
46:05 - update the name this kind of optimistic
46:07 - update is something that you might not
46:09 - realize you're using everywhere but it
46:11 - happens everywhere for example if you're
46:13 - on Twitter and you hit the little like
46:15 - button or the heart you don't want a
46:17 - little loading spinner to show up while
46:19 - it's speaking to the database to see if
46:21 - it can correctly heart that tweet
46:23 - instead you just want it to fill in the
46:25 - heart immediately and do all the the
46:27 - other stuff behind the scenes a vast
46:28 - majority of the time it just works the
46:30 - way that it's supposed to so we can give
46:32 - our users that Snappy experience by
46:34 - using this use optimistic hook and
46:37 - automatically by react get the ability
46:39 - to revert it back to what it was before
46:41 - if something does go wrong honestly
46:43 - because the is pending value was only
46:46 - there to display loading while the
46:48 - interaction with the server was
46:49 - happening and now we're using an
46:51 - optimistic update I'm just going to get
46:53 - rid of that is pending value for now and
46:55 - let's hit save and try this whole
46:57 - experience again and there we go now
47:00 - there was a bit of a lag there where
47:02 - we're still seeing the text inside of
47:04 - our input I'm sure that there's a way
47:06 - that we could update that but for now I
47:08 - think the point has come across that use
47:10 - optimistic is a really helpful tool
47:12 - whenever you want to add a bit more of a
47:14 - Snappy responsive feeling to your
47:16 - application there's one more brand new
47:18 - hook that we're going to tackle next
47:20 - which is called use form status so
47:22 - that's what's coming up
47:27 - another new hook we have in react 19 is
47:30 - a pretty straightforward one but can be
47:31 - really helpful if you ever find yourself
47:33 - building a component library that relies
47:36 - on forms and of course this Hook is
47:38 - called use form status the main idea of
47:41 - use form status is that when you have a
47:43 - form element there's often a number of
47:46 - aspects with that form that can be
47:47 - really useful for your components to
47:49 - know about and it's a fairly common task
47:51 - to build component libraries that have
47:53 - specially designed elements like a
47:55 - custom input or a custom button and
47:57 - commonly you'll want those different
47:58 - elements to react to different states in
48:00 - your form like this is pending variable
48:03 - so first let's go ahead and make a
48:05 - custom button this is just an example of
48:08 - course this could be as complex as you
48:10 - might want it to be and in this my
48:13 - button component we are just going to
48:15 - render a native button and we'll just
48:18 - put in the children there and let me
48:21 - change button up here to my button now
48:24 - this is about as basic As It Gets but
48:27 - there's a few things that we still need
48:28 - to do in order for this to be a drop in
48:30 - replacement for example if we have a
48:32 - type or any other prop like style or
48:35 - class name we would want to make sure to
48:37 - pass those on so we can do that with a
48:38 - spread operator we'll just pull in the
48:40 - rest of the props and I'll go ahead and
48:43 - just spread those directly onto the
48:45 - button like this and that way if I had
48:47 - other props like type submit or like a
48:50 - class name that was associated with this
48:52 - button those would just get passed down
48:54 - automatically however when it comes to
48:56 - different form States like the is
48:58 - pending variable if you wanted your my
49:00 - button component to react differently if
49:02 - is pending is true historically you'd
49:05 - either have to pass this down as a prop
49:07 - in this case that's really not that big
49:09 - of a deal you could say is pending is
49:11 - equal to the value of is pending and
49:14 - then you would have to pull in is
49:15 - pending as a prop I won't go too far
49:18 - down this hole cuz that's not the way
49:19 - we're going to do it or if this button
49:21 - were maybe multiple levels nested deeply
49:24 - into this form you might decide instead
49:26 - of drill buing those props multiple
49:27 - levels down you would have to create
49:29 - your own context well in order to help
49:32 - with this pretty common use case react
49:34 - released this use form status hook and
49:37 - it couldn't be simpler to use the main
49:39 - thing that it does is it acts as a
49:40 - context consumer for the nearest parent
49:43 - form element so essentially react turns
49:46 - the form element into a context provider
49:49 - and use form status as a way to consume
49:52 - that context and it will automatically
49:54 - pass down information about the current
49:56 - status of that form for you this
49:58 - couldn't be easier to use the only thing
50:00 - that is a bit different is we're not
50:02 - going to import this from the react
50:04 - Library we're going to import it from
50:06 - the react Dom Library so we'll pull this
50:10 - in from react Dom I think the reason for
50:13 - this is because they're turning the
50:15 - native form element into a context
50:17 - provider that's something that needs to
50:18 - happen in the Dom and not just in the
50:21 - library of react so now that we have
50:23 - that imported inside of my button I can
50:26 - just consume that context let's go ahead
50:28 - and just see what comes in I'll call
50:30 - this object equals use form status and
50:34 - that consumes the context that's passed
50:36 - down and then we'll go ahead and conso
50:37 - log this object so we can get a chance
50:39 - to see what it's all about we can see
50:41 - that it's an object that has four
50:43 - properties pending data method and
50:45 - action let's go ahead and submit this
50:47 - form and there we can temporarily see
50:50 - pending changed to True data was an
50:53 - instance of form data the method which
50:55 - is the request method for this form was
50:58 - a get method and that's just because I
51:00 - didn't specify on my form that it should
51:01 - be a post or anything like that and then
51:03 - the action is the action function in
51:05 - case we needed to run that action inside
51:08 - of our button for some reason I imagine
51:10 - of these properties the pending property
51:12 - and the data property are probably the
51:14 - most useful for example I might be able
51:16 - to just pull in the pending status from
51:19 - use form status and I don't know maybe
51:22 - we want to say if pending is true then
51:25 - the button will display
51:27 - maybe submitting but otherwise it'll
51:29 - display the regular children it might be
51:31 - a contrived example but let's go ahead
51:33 - and see how that works and oh I need to
51:35 - not console log object anymore okay so
51:38 - let's change this to something and I'll
51:40 - hit enter we can see it says submitting
51:42 - while it's submitting and then it
51:43 - changes back to update again this is
51:45 - pretty straightforward it's really
51:46 - useful whenever you're building any kind
51:48 - of custom form component that needs
51:50 - access to the information about the
51:51 - current state of the form this used form
51:53 - status hook does represent the last of
51:55 - the brand new hook from react 19 but
51:58 - it's not the last of the features from
52:00 - react 19 so we still have a little bit
52:02 - of ground to cover as always play around
52:04 - with the code as much as you want and
52:05 - when you're ready we'll move
52:09 - on since we just created this custom
52:12 - button that we're using inside of our
52:13 - form I thought it would also make sense
52:15 - to talk about an improvement to refs in
52:18 - react really what a ref is is a way to
52:21 - maintain State between renders without
52:23 - triggering a render normal state in
52:26 - react will maintain state or maintain
52:28 - information from one render to the next
52:30 - but anytime that state changes it will
52:32 - rerun your components or reender your
52:34 - components that way what gets displayed
52:36 - on the screen is a function of whatever
52:39 - your current state is and a ref will
52:41 - essentially do the same thing but it
52:42 - won't cause that render often times a
52:45 - ref is used as a way to hold on to the
52:48 - reference to a Dom node if you ever need
52:51 - to imperatively interact with that Dom
52:53 - node a really common example is setting
52:55 - Focus inside of an input element but
52:57 - doing it with the native Dom JavaScript
52:59 - using Focus there's a lot of other
53:02 - reasons you might want to hold on to the
53:03 - Dom node of something but if you are
53:05 - creating a custom component like my
53:07 - button here and you're creating the ref
53:10 - in the parent component like we have in
53:12 - our form up here we need a way to pass
53:15 - that ref down to our custom component
53:18 - and we can do that with the dedicated
53:20 - ref prop and so we set ref equal to the
53:23 - ref that gets created up above I didn't
53:25 - bother to create this ref using the used
53:28 - ref hook because that's a little bit
53:30 - outside the scope of this lesson but in
53:32 - order for this to work we can't simply
53:34 - pass it down as a prop in react 18 and
53:37 - earlier instead we had to use a built-in
53:40 - function called forward ref and this is
53:42 - something that was sort of meant to be a
53:44 - workaround for a temporary solution to
53:47 - this issue of forwarding refs and using
53:49 - forward ref would provide the ref as a
53:53 - second property or a second parameter to
53:55 - our component so this destructured
53:58 - object here represents props but there
54:00 - would be a second one called ref and
54:02 - that way I could pass that ref onto the
54:05 - button and just give it to it like that
54:07 - as I said this was meant to be a
54:09 - temporary workaround on the react team
54:11 - and so fortunately with react 19 we
54:14 - don't have to do it this way anymore we
54:16 - can pass refs as a prop just as you
54:18 - might normally expect to do so this part
54:21 - would stay exactly the same where ref
54:22 - equals ref and then it would show up as
54:25 - one of the props so we have props do
54:27 - children and we would have props do ref
54:29 - and then all the rest that we pulled in
54:31 - so not a giant change but it is really
54:33 - nice to minimize the API of react when
54:36 - you can by getting rid of that forward
54:38 - ref function you don't need to do that
54:40 - anymore and again this really only is
54:42 - something that you'll do if you're
54:43 - making custom components often times
54:45 - when you're building a component library
54:47 - and you need to be able to give access
54:49 - to the ref on the native Dom element
54:51 - that you're rendering in your component
54:53 - so nice and concise pretty simple
54:55 - straightforward using refs as a prop
54:57 - that's one of the new features in react
55:02 - 19 one of the most exciting things
55:05 - that's been added to react 19 has been
55:07 - talked about quite a bit over the last
55:09 - couple years it's an API that they've
55:11 - been working on for quite some time and
55:13 - it's called use now this is actually
55:15 - separate from what we were talking about
55:17 - with new hooks because use isn't
55:19 - actually a hook in the documentation
55:21 - they simply call it a new API and now I
55:24 - know what you're thinking the name is
55:25 - really conf confusing there's a lot of
55:27 - debate about the name itself but try to
55:29 - keep in mind that it's not actually a
55:31 - hook and therefore it doesn't have to
55:32 - obey the rules of hooks one of the most
55:35 - prominent rules of hooks is that they
55:37 - cannot be used conditionally they have
55:39 - to be used at the top level of a
55:40 - component and you can't put a hook call
55:42 - like use State inside of an if block
55:45 - which I personally haven't run into too
55:47 - many issues with but I know that it is a
55:49 - bit of a headache or some use cases and
55:51 - what use does is it allows us to read
55:53 - some asynchronous resources and then it
55:55 - will automatically suspend the component
55:58 - this is using react suspense we're going
56:00 - to see in just a second how we can
56:02 - Implement that and then kind of randomly
56:04 - use can also be used to consume context
56:07 - essentially like a dropin replacement
56:10 - for use context anytime you've had to
56:12 - pull in and consume the context from a
56:14 - context provider however because of
56:16 - Point number one you now can replace use
56:19 - context with use and you could
56:22 - conditionally pull in that context if
56:23 - you needed to now let's work on point
56:25 - number two here where it can read async
56:27 - resources when react very first started
56:30 - talking about the upcoming release for
56:32 - version 19 a lot of people were talking
56:35 - about how you can take your fetch
56:36 - requests for example and pull them into
56:39 - your component and write your code as if
56:41 - it were synchronous I'm going to give a
56:43 - bit of a spoiler alert here we're not
56:45 - able to do that with the actual react 19
56:48 - as it currently stands at the time of
56:49 - this recording but I'll show you what
56:51 - I'm talking about first and then we'll
56:53 - see what the actual limitation is
56:55 - fetching resource inside of a component
56:57 - has always been a bit of a rigma rooll
57:00 - when it comes to doing it natively in
57:01 - react there are some really great and
57:04 - popular libraries like tanack query and
57:06 - S SWR that make this process quite a bit
57:09 - simpler but in vanilla pure react the
57:12 - way that we have typically had to do it
57:14 - is by using a use effect to run the
57:17 - fetch request when the component first
57:19 - mounts and then to save that information
57:21 - in state that would look something like
57:23 - this we'll import use state and use
57:28 - effect from react and we'll go ahead and
57:31 - set up our use effect and I'll put a
57:35 - dependency array that's empty so that it
57:37 - just runs the first time before we write
57:39 - the code there let's go ahead and save
57:41 - this information in state we'll call it
57:44 - Pokemon because we're going to pull from
57:46 - the Pokemon API and set Pokemon and
57:49 - we'll get that with State we'll just
57:51 - initialize it as null and then inside of
57:54 - my use effect we will make our fetch
57:56 - request so I can call Fetch and I'll
57:59 - just put in the URL that I already have
58:01 - copied we'll tack on a do then and get
58:04 - the Json from it or rather parse the
58:07 - Json from it and then we will take that
58:09 - data and we will set the Pokemon to that
58:12 - data presuming you've done a bit of
58:14 - react this hopefully looks pretty
58:16 - familiar or at least makes quite a bit
58:18 - of sense just from seeing it I'm not
58:19 - going to worry too much about what I
58:21 - actually do with this data so I'm
58:23 - actually just going to run json. string
58:25 - ofy and we'll stringify the Pokemon and
58:29 - I'm just going to do a little bit of
58:30 - formatting to it here okay great well
58:33 - that information comes in and it's
58:35 - working but essentially what we're
58:36 - having to do here is use an effect
58:39 - because this component we know is doing
58:41 - something asynchronous it's going to
58:43 - render and we need it to have something
58:46 - that it can render and then it's going
58:47 - to run an effect and we know that effect
58:50 - is going to take some time or that fetch
58:52 - request is going to take some time then
58:53 - when it finally comes back it's going to
58:55 - set the data in state so that it
58:57 - reenders the component now with a
59:00 - Pokemon object the way that we would
59:01 - expect and displays it down here below
59:04 - we really have to be thinking a lot
59:06 - about the asynchronous nature of these
59:08 - components and understand the rendering
59:10 - cycle and how everything's working under
59:12 - the hood use let's go ahead and just
59:14 - pull it in right now use is intended to
59:17 - make this process a lot simpler in react
59:19 - 18 they introduce the idea of suspending
59:22 - a component and that allows us to create
59:25 - a declarative boundary or a suspense
59:27 - boundary around the component that we're
59:29 - rendering and give it a fallback or a
59:31 - loading UI of some sort that when the
59:34 - inner component suspends the suspense
59:37 - boundary will display on the screen
59:39 - while things are still happening under
59:41 - the hood first let's make use of use and
59:43 - see how that benefits our code and then
59:45 - we'll need to make use of the suspense
59:47 - boundary right after that use is really
59:49 - nice I don't need a use effect anymore
59:52 - so I just have my Fetch and I won't need
59:54 - to save this information in state so I
59:57 - have my fetch here let's go ahead and
59:59 - save the promise that comes back from
60:01 - Fetch as let's say fetch promise just
60:05 - have to spell it right here there we go
60:08 - if you weren't familiar fetch returns a
60:10 - promise and all the then chains also
60:12 - return a promise and I don't know that
60:15 - it's okay for me to make a component
60:16 - that starts with a weight like this so I
60:18 - can't just await the response from that
60:20 - fetch but I have this fetch promise and
60:22 - I can call use from react and get the
60:26 - data what looks like synchronously so
60:29 - I'll say Pokmon equals use and then I
60:32 - will pass in my promise that I want to
60:35 - wait for it to resolve before I display
60:38 - anything and actually I can get rid of
60:40 - this do then because we're not doing set
60:41 - Pokemon anymore already this is so much
60:44 - easier to understand I can write my code
60:46 - as if everything were going to happen
60:48 - synchronously and I can more
60:50 - declaratively use a suspense boundary to
60:52 - suspend everything first of all let's go
60:54 - ahead and well let's just see what
60:56 - happens okay so I get an error it says
60:59 - that async a weight is not yet supported
61:01 - in client components and honestly this
61:03 - is a bit cryptic essentially what's
61:05 - happening is my component with use has
61:08 - suspended but I'm not catching that with
61:10 - a suspense boundary in anyway so let's
61:13 - do that we'll go ahead and pull in the
61:15 - suspense component from react and this
61:18 - is the only place we're rendering things
61:19 - so I'm just going to wrap this in the
61:22 - suspense boundary like this okay and
61:24 - then I can provide a a fall back prop to
61:27 - suspense we'll just set it equal to a
61:30 - paragraph that says loading of course
61:33 - this is where you'd want to put some
61:34 - kind of skeleton UI or maybe a loading
61:36 - spinner or something like that okay
61:38 - let's see what happens I'm going to hit
61:39 - save and look at that we get our data
61:42 - back in however we do get a warning from
61:45 - react the warning says a component was
61:47 - suspended by an uncashed promise
61:49 - creating promises inside the client
61:51 - component or hook is not yet supported
61:54 - except via a suspense comp library or
61:56 - framework and yes this leads us to the
61:59 - main limitation that we currently have
62:01 - with use and that is if we create a new
62:04 - promise inside of the code of our
62:07 - component then the problem is every
62:09 - single time this component renders it's
62:11 - going to create another promise it's
62:13 - going to make another fetch request and
62:15 - so we either need to create a mechanism
62:18 - that will cach this promise and make
62:19 - sure that it doesn't perform another
62:21 - fetch request when the component renders
62:24 - or like it says we need to use a
62:26 - suspense compatible library or framework
62:28 - that will do that work for us in fact we
62:30 - can go see that note directly here in
62:33 - the documentation and it just well gives
62:35 - you the exact same warning that we just
62:36 - saw there is a way around this where we
62:38 - can create our own cached promises
62:41 - however that is a bit outside the scope
62:43 - of this lesson I think that use shows
62:46 - pun intended great promise for the
62:48 - future especially when react Implement
62:50 - something that makes caching of promises
62:52 - a lot easier like they say down here in
62:54 - the future we plan to ship features to
62:56 - make it easier to Cache promises inside
62:58 - of render and by the way inside of
62:59 - render just means inside the body of
63:02 - your component in fact if you wanted to
63:04 - play with this code this would be a good
63:05 - time to do that you can see how this
63:07 - fetch request is happening again and
63:09 - again every time this component
63:10 - rerenders and you could just create a
63:12 - simple Boolean state or a counter state
63:14 - or something and a button that when you
63:16 - click it it flips that or increments or
63:18 - whatever anything to change the state of
63:20 - this component you'll see that this
63:22 - loading state right here this fallback
63:24 - loading State happens again and again
63:26 - and again every single time the state
63:28 - changes because it's making another
63:30 - fetch request in fact I'm pretty sure
63:31 - you could go to your network Tab and see
63:33 - that happening as well at this point
63:35 - that's about as far as I'm going to go
63:37 - into the new use function that we have
63:39 - access to hopefully in the future we'll
63:41 - find that it's much more I guess you
63:42 - could say useful for us and with that
63:45 - under our belts that really does
63:46 - represent the majority of what I wanted
63:48 - to talk about in this course however
63:50 - there are a number of miscellaneous
63:52 - improvements that don't necessarily
63:54 - require me to give you code examples but
63:56 - that I think would be important to go
63:57 - over so we're really rounding the end of
63:59 - this mini course but I want to make sure
64:01 - I touch on these miscellaneous
64:02 - improvements that are coming with react
64:04 - as
64:08 - well besides just all the new stuff that
64:10 - came with react 19 there's a bunch of
64:13 - miscellaneous improvements that they
64:14 - made to the react itself and I'm not
64:17 - going to go into every single one of
64:18 - these because honestly you can just go
64:20 - to see the blog it'll show you exactly
64:23 - in detail every single thing I am going
64:25 - to focus on the the ones that I think
64:26 - are easy to demonstrate especially here
64:28 - in the scrimba environment and the first
64:30 - one I wanted to show off which I think
64:31 - is really cool is the new support for
64:33 - document metadata I'm realizing now that
64:36 - title sounds pretty boring but it's
64:37 - actually pretty useful we can see an
64:39 - example over here I just have an app
64:42 - that's rendering this blog post
64:43 - component it's passing in a post which
64:46 - just has information about the post it
64:48 - might have a title I probably should
64:50 - have a body of some kind in here but
64:52 - this is just a sample anyway and in this
64:54 - case it has this keywords prop which is
64:56 - a comma separated string this is pretty
64:58 - much directly from this blog post here
65:00 - and the blog post component is taking
65:02 - that post object as props and it's
65:04 - rendering an article and displaying
65:06 - everything that you might want a blog
65:08 - post normally to display however one
65:10 - really common thing especially when
65:12 - you're talking about blogs is you might
65:14 - want to update the title tag of your
65:16 - HTML document to reflect the title of
65:19 - the post that you're at this is really
65:20 - common you'll see it in the tabs at the
65:22 - top of your browser when you go to a new
65:24 - blog post it might update what that
65:25 - title is It's not just a user experience
65:28 - thing it's actually a really big SEO
65:30 - benefit to have the title tag reflect
65:33 - the content on the page however when
65:35 - we're here inside of react typically we
65:37 - are interacting with the body everything
65:40 - that we render inside of react is going
65:42 - to get stuffed inside of this div with
65:44 - the idea of root and of course that
65:46 - lives in the body and we don't have
65:48 - direct access to the head of the
65:49 - document at least until now anytime you
65:52 - render a meta tag a title tag or a link
65:56 - tag react will take the content there
65:58 - and it will hoist it up to the head of
66:00 - your document thus making it a lot
66:02 - easier to modify those tags without
66:04 - using a third party Library the most
66:06 - popular of which I believe is react
66:08 - helmet the blog post does mention that
66:10 - there might still be instances where you
66:12 - want to use a thirdparty library like
66:14 - that but for simple things like this
66:16 - it's really nice for us to be able to
66:17 - just render the title element and have
66:20 - react hoist that up to the head for us
66:22 - now before I started recording I took a
66:23 - screenshot of the dev tools that shows
66:26 - that in fact my awesome blog post is the
66:28 - new value for the title tag and it's
66:31 - right here inside of the head of the
66:32 - component as opposed to being inside the
66:34 - body and you can see the other meta tags
66:37 - and here's the content with test one and
66:39 - test two all of which is being hoisted
66:41 - up to the head and that's pretty much it
66:42 - for support for document metadata it's
66:44 - pretty
66:48 - straightforward and that does it for
66:50 - this mini course on what's new in react
66:53 - 19 now as I mentioned before we haven't
66:56 - covered everything there are a bunch of
66:58 - other additional miscellaneous
66:59 - improvements that have been made to
67:00 - react in react 19 you can click the
67:03 - screenshot here to go to that blog post
67:05 - which at the time of recording does
67:07 - represent the most updated API that you
67:09 - can find with these new features as you
67:11 - might have noticed a lot of these new
67:13 - features don't necessarily affect the
67:15 - core way that react works and I do have
67:17 - an introductory course on react here on
67:20 - scrimba that I'm just about to start
67:22 - re-recording from scratch so I'm excited
67:24 - to jump into that however these updates
67:26 - to react 19 actually affect more of the
67:29 - intermediate or Advanced side of react
67:31 - and if any of this felt a little bit
67:33 - over your head or you just want a chance
67:35 - to dive a little bit deeper into react
67:37 - you can check out my Advanced react
67:39 - course here on scrimba my name is Bob
67:41 - zeroll it's been a pleasure to work
67:43 - through this react 19 information with
67:45 - you if you want to follow me on X that's
67:47 - the place that I tend to be most active
67:49 - these days online and with that I'm
67:51 - going to set you loose into this new
67:52 - bright world of react 19 happy Cod thing