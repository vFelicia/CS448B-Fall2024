00:00 - [Music]
00:07 - so let's just go ahead and get a look at
00:08 - what this final product is going to look
00:10 - like um so on like an x by x grid so
00:13 - whatever you want it to be you have a
00:16 - little snake moving around there's a
00:18 - snack is what i want to call it that
00:19 - shows up and as you collect it it
00:22 - increases the length of the tail and
00:23 - then obviously if you run into yourself
00:25 - and i just did that by clicking the back
00:27 - key while i was going forward it gives
00:28 - you a little error message here says you
00:30 - ran into your tail um your length was
00:32 - nine dot dot dot whatever um and then
00:35 - you can continue and
00:37 - play as long as you want um anyways what
00:39 - i'm going to be doing in here is i'm
00:40 - going to be coding everything object
00:42 - orientated i know that there's a much
00:44 - faster and easier way to do this but it
00:46 - doesn't really teach you that much
00:48 - this way you're going to learn a bit
00:49 - about objects about classes
00:52 - how we can kind of work with them
00:54 - and you'll see like how the flow of my
00:55 - program goes and you should learn quite
00:57 - a bit especially if you're somewhat a
00:58 - beginner programmer
01:00 - what we're going to be using to make
01:02 - this is module called pygame if you
01:04 - don't know about pi game and you want to
01:05 - learn about it before you do this i
01:07 - would recommend that all right so let's
01:09 - start coding so pretty much what i've
01:11 - done is i've just set up the flow of the
01:13 - program all the classes and the function
01:15 - just to remind myself what i need to
01:17 - write
01:18 - and while i'm talking here it's probably
01:19 - a good idea if you guys copy this down
01:21 - so what we're gonna have is we're gonna
01:23 - have two main objects we're gonna have a
01:24 - cube object and a snake object and our
01:26 - snake object is going to contain cube
01:28 - objects if that makes sense so each one
01:31 - of those little red
01:32 - i don't know squares that was moving
01:33 - around is a cube object and the whole
01:35 - thing is our snake object we're going to
01:37 - have a few functions here draw grid
01:39 - redraw window random snack message box
01:42 - and main
01:43 - so let's get started with
01:45 - our main function here and this is
01:47 - what's going to be our main loop so
01:49 - essentially what i need for the main
01:50 - loop to start is we need to make a
01:52 - surface so in high game to do this we do
01:54 - win equals pi game
01:56 - dot
01:57 - display dot set underscore mode and then
02:00 - i'm going to set it um
02:02 - let's see here what do i want the height
02:04 - to be let's say width
02:07 - and height like this
02:09 - oops bad spelling and i'm just going to
02:11 - make a variable here called width equals
02:14 - height equals and we'll just set this to
02:17 - 500 by what i have 500 like so
02:21 - now we need another variable i'm going
02:22 - to set this as rows uh i can delete this
02:25 - down here it's going to do something but
02:26 - i'll do that later um and this is how
02:28 - many rows you're going to have or rows
02:30 - or columns whatever you can set this to
02:32 - whatever you want just make sure it
02:33 - divides 500 evenly otherwise you're
02:35 - going to have like weird looking rows if
02:38 - you know what i mean so i'm just going
02:38 - to set mine to 20 that's what i'm using
02:40 - in the other one but if you want to make
02:41 - it harder set it to something like 10
02:43 - and there won't be as much room for the
02:44 - snake to move around and the games will
02:46 - go faster pretty well
02:48 - okay next what we need to do is we need
02:50 - to set up a snake object so i know that
02:52 - uh we haven't even created like anything
02:54 - in the snake class yet but i'm just
02:56 - gonna do s equals snake
02:58 - and i'm just gonna give it a position so
03:01 - in this case
03:02 - we want to or a color sorry
03:05 - which is going to be red because red
03:07 - green blue 255 for red and then i'm
03:08 - going to give it a position we're going
03:09 - to start in the middle so i'm going to
03:10 - start at 10 10. um now let's move into
03:14 - our main loop so i'm just going to say
03:16 - wow flag create my variable up here flag
03:20 - equals true
03:22 - and then we're just going to start by
03:24 - doing a pi game tick so pi game dot time
03:27 - dot delay
03:29 - 50 like so and that's just going to
03:31 - delay us uh i want to say like 0.5 or 50
03:35 - milliseconds
03:37 - every time so that our program doesn't
03:38 - run too fast i'm also just going to
03:42 - create this clock.tick i'm going to put
03:44 - that at 10 and what i'm going to do is
03:46 - i'm going to create a clock object up
03:48 - here um and this is a built-in thing in
03:50 - pie game and what this is going to do is
03:52 - explain in just one second once i finish
03:54 - typing it pie game dot
03:55 - clock i believe it is oops dot time dot
03:59 - clock
04:00 - like so
04:01 - so what this clock dot tick is actually
04:04 - going to do is it's going to make sure
04:05 - that our game doesn't run at more than
04:07 - 10 frames per second um so that would
04:09 - mean essentially that our snake would be
04:12 - able to move like 10 blocks in one
04:14 - second and again we don't want it to be
04:16 - that fast so that's why we're also
04:18 - delaying um by like a few milliseconds
04:20 - here if you put this too low um then
04:23 - again it's going to move too low you can
04:24 - play around with the speed this is kind
04:26 - of what i found was the best speed um
04:28 - and it may vary depending on what
04:30 - machine you're on it shouldn't it might
04:31 - so you might want to just change these
04:33 - numbers um again the lower this goes is
04:36 - the faster it's going to be and the
04:37 - lower this one goes is the slower it's
04:40 - going to be so they're kind of inversely
04:41 - proportional like that
04:43 - all right
04:44 - um next
04:46 - what are we going to do here i'm just
04:47 - going to call
04:49 - redraw
04:51 - window
04:53 - and i butcher that so bad oops
04:56 - redraw window like so i'm just going to
04:58 - give it a surface which is in this case
04:59 - going to be win
05:00 - that we've created up here
05:02 - and for now that's all i'm going to put
05:04 - in my main loop here and we'll move more
05:07 - into that once i start coding some other
05:09 - stuff okay so now that we have our
05:10 - redraw window being called here
05:12 - i'm going to go and i'm going to start
05:14 - coding our redraw window
05:16 - so what this is essentially going to do
05:17 - is we first need to update the display
05:19 - so pygame.display
05:22 - dot
05:23 - update like so
05:25 - and we also need to um draw the grid
05:28 - so we're simply going to draw a grid
05:30 - we're going to pass it that same surface
05:32 - that we were given um and move on from
05:35 - that we're also going to fill the screen
05:36 - so
05:37 - when dot
05:39 - fill
05:39 - in this case i'm just going to use black
05:41 - so it's zero zero zero um and there we
05:44 - are that's all we need to do right now
05:45 - but essentially we're also gonna need to
05:47 - draw the snake uh we're gonna need to
05:49 - draw a few other things on the screen uh
05:51 - that we'll get to later okay so draw
05:53 - grid let's move into this one now uh
05:55 - what we need to do here is a set like
05:56 - draw a grid which is pretty easy to do
06:00 - um so what we do is we we're given rows
06:03 - and surface so it's probably a good idea
06:05 - if i actually passed in the rows and
06:07 - surface so i'm just going to global them
06:09 - here so that
06:10 - i can reference them i think this is
06:11 - going to work we'll do global
06:13 - rows
06:14 - and width like that
06:17 - and here we also need to make these
06:19 - global just because i don't want to pass
06:21 - them in every time i draw a grid we're
06:22 - just going to say width uh oops
06:25 - androids and this height variable is
06:28 - actually not necessary because
06:30 - we are just going to draw a square um
06:33 - like a square surface every time so we
06:36 - can just make this the same we don't
06:37 - need two variables for width and height
06:38 - to it are going to contain the same
06:39 - number anyway so global width and rows
06:42 - i go here draw a grid
06:44 - given with rows and surface so now we're
06:46 - going to put in
06:48 - well first we're going to put our rows
06:50 - or oops
06:51 - width
06:53 - row
06:54 - and surface like that
06:56 - okay so that should be working now
06:58 - in here what we first need to do
07:00 - when we're drawing a grid
07:02 - is we want to figure out um
07:05 - how big each square in the grid is going
07:07 - to be because what we're going to do is
07:09 - we're going to just draw lines going
07:11 - down and across but we need to figure
07:13 - out where to draw those lines so we have
07:14 - to figure out kind of like the gap
07:16 - between each of the lines so the way we
07:18 - do that i'm just going to create a
07:20 - variable here size between is equal to
07:22 - our width integer divided by our rows
07:25 - this is just so that we don't get like
07:27 - large decimal numbers because that we
07:29 - cannot pass into our uh drawline method
07:33 - in uh in python okay so now i'm just
07:35 - going to create x variable
07:37 - and a y variable
07:38 - and i'm going to set these to zero and
07:40 - say 4l
07:42 - in
07:43 - range and this is just standing for line
07:45 - pretty well and rows like that now what
07:48 - i'm going to do is i'm going to
07:49 - increment my x by the size
07:52 - between and i'm going to increment my y
07:54 - by the same so
07:56 - y equals y
07:58 - plus oops
08:00 - size between i can get rid of one of the
08:02 - spaces here
08:04 - oh what okay there we are
08:06 - and now we're simply just going to draw
08:08 - two lines so to draw a line in pie game
08:10 - all we have to do is
08:11 - pygame
08:12 - dot draw dot line
08:15 - and the arguments that takes is a
08:16 - surface
08:17 - we need a color in this case it's gonna
08:19 - be white
08:20 - so we do 255 255 255 for white
08:24 - we're going to draw at x 0 comma
08:27 - x w and i'll go through this in just one
08:29 - second
08:30 - what this does and i'm just going to
08:32 - copy this and draw one more and then
08:33 - explain
08:34 - how this is going to work pretty well
08:37 - okay so now we need
08:39 - 0
08:40 - y
08:41 - and
08:43 - w
08:44 - y like so okay
08:45 - so what this is going to do is this is
08:47 - going to draw two lines for us every
08:48 - loop of this for loop
08:51 - and these arguments here is the start
08:52 - position of the line and the end
08:53 - position of the line so the first line
08:55 - that we want to draw is going horizontal
08:57 - which means we don't want to change the
08:58 - y value at all um so what we need to do
09:02 - is we need to find the x
09:04 - and then we're going to put y at 0
09:06 - because we're going to be at the top
09:08 - i think that's right at least oh sorry
09:10 - this this line is dropped being drawn
09:11 - down not being drawn to the right i was
09:13 - getting confused there okay so we're
09:14 - going to change the x but we're going to
09:16 - keep the y at zero and then we're going
09:19 - to stay at that same x and we're going
09:20 - to keep the y at the width of the screen
09:23 - so that we're going uh far enough down
09:25 - and then same thing here this one is
09:26 - going horizontal excuse me i messed that
09:28 - up before so our x is always going to
09:30 - stay at zero and our y is going to be
09:32 - what's changing as we draw horizontal
09:34 - lines across the screen i hope that
09:36 - makes sense to everyone how that works
09:38 - anyways i'm going to move on from that
09:39 - and that's all we need for the draw grid
09:42 - uh function so let's just go ahead i
09:43 - probably made a mistake here but we'll
09:45 - run the program to see if everything's
09:46 - working
09:47 - again our name win is not defined
09:49 - win.fill ah so i've called this win one
09:52 - really needs to be
09:54 - surface like that
09:56 - so let's try now and there we go we get
09:58 - a nice little grid um on our screen like
10:00 - so 20 by 20 grid
10:02 - there we are so now let's move into
10:05 - another uh function actually let's start
10:07 - coding on the classes here so like i was
10:09 - talking about before we're going to have
10:11 - a snake object which is going to contain
10:13 - a bunch of cube objects so essentially
10:15 - what we're going to do is we're going to
10:16 - have a list of cubes and that's going to
10:18 - be known as the snake body so let's go
10:20 - ahead and write that in now
10:21 - what i want to do for that is just
10:23 - create a list so we're just going to say
10:25 - body
10:26 - is equal to and then a blank list i'm
10:28 - also just while we're already up here
10:30 - and creating a class variable i'm going
10:31 - to create turns
10:33 - is equal to and it's just going to be
10:35 - this set of squiggly brackets here that
10:37 - we'll uh we'll get into in a bit
10:40 - okay so now that we're already in the
10:41 - snake function
10:43 - what we need to do is we just need to
10:44 - define our
10:46 - parameters here that we're passed in so
10:48 - we're just going to say self.color
10:50 - equals color
10:52 - say self.head
10:55 - equals
10:56 - cube which i'll get into in a second
10:58 - given the position say self thought body
11:01 - dot append
11:03 - our head
11:05 - self.head like this so what we're doing
11:07 - here now is we're saying okay so the
11:08 - head of our snake which is going to be
11:10 - important because we need to know where
11:11 - that is at all times so we can move
11:12 - accordingly is equal to a cube at the
11:15 - given position and the given position is
11:17 - what we pass in here as like the
11:19 - starting position of our snake
11:21 - or we could create a new snake like we'd
11:23 - have multiple snakes moving around and
11:24 - anyways that's the position
11:26 - now we're saying we're going to append
11:28 - to the body
11:29 - this head so now this is
11:32 - in our list here and then we can go
11:34 - through that list and we can draw things
11:35 - we can move it we can check things we
11:37 - want all of our cubes to be ordered
11:39 - within this list so that's why i'm
11:40 - putting that in first now i'm just going
11:42 - to give
11:43 - this one which is called during x
11:46 - is equal to zero and
11:48 - turn y which is equal to one
11:51 - so what this is going to do is we have a
11:53 - direction for x in a direction for y for
11:56 - moving our snake so obviously these are
11:58 - going to be
11:59 - a value like negative 1
12:01 - 1
12:02 - or 0 and that's going to be the same for
12:04 - y and x if y or x is equal to 1 negative
12:07 - 1 then the other one's going to be equal
12:08 - to 0 because you can only be moving in
12:10 - one direction at the same time and this
12:12 - is just going to keep track of
12:13 - what direction we're moving in and we'll
12:15 - use this in the next function that we're
12:16 - going to code which is our move function
12:19 - so moving is pretty straightforward
12:22 - at least in terms of just if you have
12:24 - one object moving around the screen
12:25 - getting it to go left straight right but
12:27 - when you have the snake object it has to
12:30 - turn at certain points so when i click
12:32 - left um
12:33 - the rest of the snake is still moving
12:35 - forward once it reaches the point where
12:37 - the head turned left then it has to turn
12:39 - left so that's where things can get a
12:40 - bit complicated
12:42 - anyways to start what i'm going to do is
12:43 - i'm going to say for event
12:46 - in pi game oops am i doing with my
12:48 - typing here
12:50 - pygame dot events dot gets like so
12:54 - and then we're just gonna say if
12:56 - event dot
12:58 - type equals equals
13:00 - pi game
13:01 - dot quit like this and this is the first
13:04 - one we always want to code in because we
13:05 - want to make sure that if they click
13:06 - that little red arrow it actually works
13:09 - and we can quit we're going to do pi
13:10 - game dot quit like that and i'm just
13:12 - going to say if
13:14 - actually we don't even need another if
13:15 - because the way i'm going to do this
13:16 - is
13:17 - this other way you might have seen in pi
13:19 - game before to move things around you
13:20 - said if uh event dot type equals key
13:23 - down and then you just check which key
13:25 - was pressed and move to the left this is
13:26 - a similar thing but it works smoother
13:29 - i've used both of them a lot and this is
13:30 - one i prefer so i'm just going to use
13:31 - this so pygame dot pygame.key.get
13:34 - underscore press so what this is going
13:35 - to do is it's going to get a list
13:37 - actually i think it's like a dictionary
13:39 - or something like that that has all the
13:41 - key values
13:42 - and then if they were pressed or not
13:44 - so that way if you press more than one
13:46 - key at once when you're looping through
13:48 - it'll adjust to that whereas the other
13:49 - one you can only click one at a time and
13:51 - you couldn't move like per se diagonally
13:53 - if you're moving like a character on the
13:55 - screen it doesn't matter too much for
13:56 - this but this is the way i like to do it
13:57 - so now i'm going to say four key
13:59 - in keys
14:00 - because remember this is going to give
14:02 - us all of the keys and then like one or
14:04 - zero value if they were clicked or not
14:06 - um so we need to loop through all of
14:08 - them in check we're going to say if keys
14:10 - and then
14:11 - pygame dot key
14:14 - or oops dot k underscore left
14:17 - i thought it was key there and then
14:19 - we're going to say if keys
14:22 - high game dot okay underscore right like
14:25 - that
14:26 - and we can continue down here with up
14:28 - and down
14:30 - and then we'll get into exactly what is
14:32 - going to happen when we click uh these
14:34 - keys so last one here
14:41 - all right and there we go okay so now
14:44 - what we're going to do
14:45 - is we're going to change the direction
14:47 - according to what key we click so if
14:49 - we're going left that means that our x
14:51 - has to be negative because the way again
14:53 - coordinates work in pi game is in the
14:55 - top left-hand corner of your screen is 0
14:57 - 0
14:58 - so if we want to be moving left we
15:00 - should be making our x negative to move
15:03 - more towards zero right if we want to
15:05 - move right now you make our x positive
15:07 - which would be one in this case because
15:09 - we're just going to move one cube at a
15:10 - time to go further to the right same
15:12 - thing with the y it's kind of weird in
15:14 - pi game how the y works because the more
15:16 - y you add
15:18 - the further down you go um
15:20 - so we'll do that inside so for x we're
15:21 - going to say itself.dern x
15:23 - equals negative one again because moving
15:25 - left and we're going to set our turn y
15:27 - equal to zero
15:29 - and this is because again we don't wanna
15:30 - be moving in two directions at once and
15:32 - be going uh diagonally
15:34 - now this is what i was talking about
15:37 - is we need to remember where we actually
15:39 - turned because if you just have one cube
15:41 - moving around that's fine but when we
15:43 - have multiple cubes we need to be able
15:44 - to turn left
15:45 - right we need to remember where we
15:46 - turned so the tail of our cube can turn
15:48 - at that point so that's why we have that
15:50 - self.turns list up here or just this
15:53 - turns um i want to say dictionary or set
15:56 - whatever
15:56 - so we're going to add to that self.turns
15:59 - and
16:01 - we're going to give it a new key
16:04 - and i'll go through how this works in a
16:05 - second
16:06 - self.pause here
16:08 - is equal to and then we're going to give
16:12 - just a list of self. during x
16:15 - and self dot during y
16:18 - okay so you might be kind of confused on
16:19 - what's going on here so i've created a
16:21 - new dictionary up here that's what i'm
16:22 - going to call it officially you could
16:23 - think of it as a set as well
16:25 - and pretty much we're going to add a key
16:28 - which is the current position of the
16:31 - head of our snake
16:33 - and then it's going to be set equal to
16:35 - what direction we turned so we're saying
16:37 - we have a new turn at this position and
16:40 - our character or our snake moved left so
16:42 - it's going to say we have self dot
16:44 - during y which is right here as negative
16:45 - one self dot er surf dot during x array
16:47 - and then during y is equal to zero so we
16:49 - know what
16:50 - way we actually turned and i hope that
16:52 - makes sense that's uh yeah that's how
16:54 - we're going to do that now i'm just
16:56 - going to copy and paste these and then
16:57 - change these values so when we're going
16:58 - right this is going to be one
17:01 - oops
17:03 - same thing here so we'll put that in
17:05 - this is going to be zero
17:06 - and during y we're going up is going to
17:08 - be negative one
17:10 - now when we're going down
17:12 - we need to change this to one
17:14 - and this to zero and i'm just going to
17:16 - get rid of that
17:17 - and there we go okay so
17:19 - that is uh pretty much how we go about
17:22 - doing this um and i can also just put
17:25 - lifts here as well because we don't want
17:27 - to be able to move in more than one
17:28 - direction so we're going to prioritize
17:30 - the left arrow key if they're not
17:32 - clicking the left arrow key then we'll
17:34 - check they're doing the right otherwise
17:35 - up otherwise down because we don't want
17:37 - them to be able to click more than one
17:38 - key at once okay so next we need to
17:41 - actually move our cube and this is where
17:43 - it gets a little bit more tricky in
17:45 - terms of looking where our cube is and
17:48 - if it's at that turn then we're going to
17:50 - turn it
17:51 - so i'm just going to start coding and
17:52 - i'm kind of going to go through exactly
17:53 - what i do sort for i see and
17:56 - enumerate
17:57 - oops
18:00 - and i spoke that wrong didn't they
18:04 - like that uh and then we're going to say
18:06 - self.body because we're going to look
18:07 - through the list of uh positions that we
18:10 - have in
18:11 - on the snake we're going to say p equals
18:13 - c dot position
18:15 - and i'm just going to copy this um by
18:17 - the way that's what this little arrow
18:18 - does here it just makes a copy so that
18:20 - we're not changing the position of our
18:22 - snake um
18:24 - when we do things each
18:26 - just uh just follow along with it it's
18:27 - not super important okay so we're gonna
18:29 - say if p is in self dot turns
18:33 - like this because remember what we did
18:35 - is we added the position
18:37 - of our head two turns so now we're gonna
18:40 - say well if this position
18:42 - is in the turns
18:44 - then we're going to move
18:46 - or we're going to turn right so let's
18:48 - say here so we're going to say
18:49 - turn
18:51 - oops
18:53 - equals
18:54 - self.turns p
18:56 - like that
18:58 - so now we've seen that it's in there uh
19:00 - so now it's in there we can find the
19:01 - index of it uh and we can grab the
19:03 - direction value so we know what way
19:04 - we're gonna be moving and now we're just
19:06 - gonna say c dot move
19:08 - like this and turn
19:11 - zero
19:12 - turn
19:13 - one like so
19:15 - okay now next i'm gonna say
19:18 - if
19:19 - i equals equals the length of
19:22 - self.body
19:24 - minus one
19:26 - oops then i'm gonna do self i don't know
19:29 - why that's capital self.turns
19:32 - dot pop p okay so i know i just did a
19:34 - lot of coding here and this probably
19:37 - doesn't make a lot of sense to you guys
19:38 - so i'm going to kind of run through
19:39 - exactly what i just did um it's it's
19:42 - pretty it's a little bit difficult to
19:43 - explain so anyways what we start off by
19:45 - doing is we're going to say we're going
19:46 - to get the index and we're going to get
19:48 - the cube
19:49 - object in our self.buddy because
19:51 - remember our self.body is made up of
19:53 - cube objects right here um that have
19:57 - these properties right they're going to
19:58 - have a directory in y direction x um a
20:01 - start color so on and we're going to get
20:03 - we're going to get to coding cube in
20:04 - just a second so they're cube objects
20:07 - now all of these cube objects have a
20:09 - position so i'm saying for each
20:12 - object here i'm going to grab their
20:13 - position
20:14 - and i'm going to see if that position is
20:16 - in our turn list and we create the turn
20:18 - list and add to the turn list um
20:21 - when we turn right when we click left
20:24 - center right so on um
20:26 - and then we're going to say okay so the
20:28 - actual turn so where we're actually
20:29 - going to be moving is equal to
20:32 - um that are the turns list at that index
20:35 - right so we grab
20:37 - um the turn direction x and direction y
20:39 - which we stored there and now we're just
20:41 - going to say our cube dot move which is
20:43 - another method that we're going to code
20:45 - and we're giving it that direction x in
20:46 - that direction y so it knows what way it
20:48 - needs to move
20:49 - pretty well
20:51 - and then i say if i is equal to the
20:53 - length of self.body minus one so that
20:55 - means if we are on the last cube
20:58 - we're going to remove that turn so once
21:00 - that last cube hits that turn we're
21:03 - going to remove it because if we were
21:04 - just to leave that turn in the list that
21:06 - would mean any time you hit that
21:07 - position on the screen regardless of if
21:09 - the snake was turning there or not
21:11 - you'd automatically
21:12 - change directions
21:14 - if you don't remove it from the list um
21:17 - i hope that makes sense
21:18 - okay now also after this if here
21:21 - we're going to say if the um
21:24 - what do you call it if it's not in the
21:26 - list so if our position is not in the
21:27 - list we still need to move the snake
21:30 - because it's constantly moving so what
21:31 - do we do to this well we write an else
21:34 - and i'm just going to copy this in
21:35 - because it's going to take a second to
21:36 - type because i have another file open
21:38 - and i'll go through what happened how
21:39 - this works okay
21:41 - now this looks like a lot but pretty
21:42 - much what this is doing for us is we're
21:46 - checking whether or not we've reached
21:48 - the edge of the screen
21:49 - so we're saying if we're moving left
21:52 - and the position so the x position of
21:54 - our cube is less than or equal to zero
21:58 - um then we're going to change that
22:00 - position so that it goes to the right
22:01 - side of the screen
22:03 - so the way that we can do that is by
22:04 - saying c dot rows minus one because
22:06 - again in you start counting at zero in
22:08 - computers um so if our rows is like 20
22:11 - then the last cube would be 19 in a list
22:14 - right
22:15 - so c dot rows minus one and we're gonna
22:16 - be at the same y value so we'll leave
22:18 - that there
22:19 - okay and then we say otherwise uh we're
22:22 - gonna check if we're going right from
22:24 - moving right
22:25 - and same thing if we're at the edge of
22:27 - the screen move back to the left side by
22:29 - putting zero here and then next one if
22:31 - we're going down uh what we're going to
22:33 - be doing is again checking
22:35 - are we less than rows minus one or
22:37 - greater than rows minus one no we're not
22:39 - or if we are then let's move us back up
22:41 - to the top of the screen
22:43 - by changing our y value and then same
22:45 - thing here if you're moving upwards
22:48 - now if none of that's true so we're not
22:50 - at the edge of the screen we're not
22:51 - moving up left down to whatever i just
22:53 - said uh then we're just simply going to
22:55 - move our cube at the direction x and the
22:59 - direction y of that cube already so if
23:02 - that cube is moving upwards and it's not
23:04 - turning and it's not going to the edge
23:05 - of the screen it doesn't need to be
23:06 - changed just keep moving it in whatever
23:08 - direction it's going and that's why i'm
23:10 - simply referencing the cube's already
23:12 - existing direction x and direction y
23:14 - we're not changing anything we're simply
23:15 - just saying okay let's move you forward
23:17 - one like that
23:18 - i hope that makes sense that was a lot
23:20 - and that's probably one of the hardest
23:21 - things in this program is figuring out
23:23 - the movement of the stake so if you guys
23:24 - understand that um then that is the hard
23:27 - part kind of over with and we're going
23:28 - to get into this cube object so you're
23:30 - going to understand what all this means
23:32 - and how our rows and columns kind of
23:33 - work and stuff like that
23:35 - okay so i'm just going to forget about
23:37 - reset and add cue for now because we'll
23:39 - worry about those later um but let's get
23:42 - into the uh draw method because we want
23:43 - to see if it's actually working and put
23:44 - this on the screen so simply for i
23:47 - see
23:47 - [Music]
23:49 - numerate
23:50 - why can i not spell enumerate today like
23:52 - that uh same thing self.body like that
23:56 - we're going to say if i equals equal 0
24:00 - c dot draw and you'll see why it is in a
24:03 - second
24:04 - true
24:07 - else
24:07 - c dot draw
24:09 - surface
24:11 - like that okay so the reason i'm
24:13 - doing this little check here rather than
24:15 - just drawing every object
24:17 - is because when we uh draw the first
24:19 - snake object i'm sure if you remember my
24:21 - other program it had eyes so what i
24:23 - would simply want to do is make sure
24:25 - that when we draw that first object we
24:27 - add eyes onto it just so we know where
24:28 - the head of the snake is uh we don't get
24:30 - confused like what direction it's moving
24:31 - in although you shouldn't we i want to
24:33 - add the little eyes maybe just for
24:34 - aesthetic as well so what this true does
24:36 - optional parameter simply says draw eyes
24:39 - if it's the uh first one in our list
24:42 - like that if it's the head uh and then
24:44 - in this draw method you can see i have
24:46 - eyes equals to false but when you make
24:47 - it equal to true we're going to do a
24:48 - special thing in here that's going to
24:49 - draw eyes for us
24:51 - okay so now that we've coded this this
24:53 - whole mess of stuff in the snake
24:56 - class let's just run the program quickly
24:58 - and see if anything's happening so
24:59 - currently we just have the grid we don't
25:01 - have any errors or anything
25:02 - but that's because we haven't drawn the
25:04 - snake object onto the screen yet so what
25:06 - we need to do
25:08 - is we just need to simply do s dot draw
25:10 - it within our redraw window here so i'm
25:12 - just going to type i'm going to global s
25:14 - here and i'll global it down there as
25:15 - well i'm going to say s dot draw
25:17 - like that
25:19 - and we need to give it surface so
25:21 - let's give it a surface and i'm just
25:22 - going to global s
25:23 - so that we can reference it there
25:26 - uh and is there a reason we aren't being
25:28 - drawn to the screen let's just have a
25:30 - look quickly
25:32 - s dot draw
25:35 - let's.draw oh it's because yes we are
25:37 - indeed drawing s but we haven't drawn
25:39 - any of the cube objects yet and it is
25:42 - calling the draw method on all of our
25:44 - cube objects which we haven't yet
25:45 - created
25:46 - hopefully that makes sense but we'll go
25:48 - ahead and do that now so we have to code
25:50 - a little bit more before we can see
25:51 - everything so let's just go ahead and
25:52 - get into the cube object here and let's
25:54 - just say self.start
25:56 - equals start
25:57 - except i'm actually just going to change
25:59 - this to position because i believe this
26:00 - is what it's supposed to be
26:04 - and then we're going to say
26:05 - self.turn x
26:09 - equals one
26:10 - self.
26:12 - during y
26:13 - is equal to zero and self.color
26:18 - is equal to color and the reason we have
26:19 - this is because we're going to be
26:21 - drawing later what i want to call like a
26:23 - snack for the uh for the cube to collect
26:25 - for the snake to collect um so we want
26:27 - to be able to change the color with that
26:29 - and i spelled it wrong like three times
26:32 - during x and during y the reason i have
26:34 - duran x here set to one initially is
26:37 - because
26:38 - i i want to make sure that we start
26:40 - moving in a direction
26:42 - if i had this at zero you would have to
26:44 - click a key before the snake starts
26:45 - moving but i want right when we run the
26:46 - program for the snake to just start
26:48 - moving so i'm setting it already with a
26:50 - direction x and the reason these are
26:52 - optional again is so that when we create
26:53 - a new cube object
26:55 - we don't have to implicitly
26:57 - say direction x is one direction y is
26:59 - zero because it's assumed that it's
27:00 - always going to be like that unless
27:01 - otherwise stated
27:03 - okay
27:04 - let's have a look what else do we need
27:05 - to do here uh we need to now code this
27:07 - move function which is actually really
27:09 - easy um
27:10 - all i'm just gonna do is we're gonna say
27:12 - since we're changing the direction x in
27:14 - the direction y in our snake class we
27:16 - need to do that in here so that it stays
27:18 - with the object let's say during x
27:20 - equals
27:22 - during x
27:24 - and then the same thing self thought
27:26 - during y
27:27 - equals during y
27:30 - like that
27:32 - and then we'll go down here and all
27:33 - we're going to do is we're going to
27:34 - change our position so self.position
27:37 - is equal to self.pause 0 which is our
27:40 - already existing position plus
27:42 - self thought during x
27:45 - and they're saying self.
27:47 - pause one
27:48 - which is our already existing y value
27:51 - plus equals self dot
27:53 - during y like that
27:55 - and just in case i haven't mentioned it
27:56 - here right we're working with a grid
27:58 - system of 20 rows in this instant so
28:01 - when i say something like uh if our
28:03 - self-deposition is like 1 3 or 10 10 i'm
28:07 - saying we're in the 10th row in the 10th
28:09 - column i'm not saying the x value is
28:10 - equal to 10 and the y value is equal to
28:12 - 10
28:13 - because it's not in the case of drawing
28:15 - on the screen because our screen is
28:17 - actually a width of 500 pixels um but
28:19 - just where we are in the grid which is
28:20 - most important to us right now um is
28:23 - equal to like that values like one four
28:25 - or three five um so on like that just
28:27 - just to make that clear for anyone who
28:28 - might have been confused okay so now for
28:30 - drawing
28:32 - um it's a little bit harder just because
28:34 - of what i mentioned as well
28:35 - is the fact that we need to figure out
28:37 - the distance between each x value and
28:39 - each y value so when we're drawing
28:41 - something in pi game it draws in the top
28:43 - left hand corner of the object so if we
28:45 - draw a cube
28:46 - we're drawing that in the top left um so
28:48 - we need to figure out what that x and y
28:50 - value is going to be for each cube when
28:52 - we're drawing it to the screen
28:53 - so
28:54 - i'm just going to call this gap here
28:56 - that is going to be our distance and the
28:58 - same thing self.w
29:00 - by self.rows
29:02 - and we're going to change w and rows
29:05 - down in our program later but we can
29:06 - actually just type it in now
29:08 - like this so 500 and 200 just so we have
29:10 - that set okay so self.w answer divided
29:13 - by self.rows again that's the same thing
29:15 - we did when we were drawing the grid to
29:17 - figure out the distance between our x
29:19 - and y values okay we're going to say i
29:22 - is equal to
29:23 - self.pause zero that's going to save us
29:25 - a bit of typing in our function here or
29:27 - in our method i'm just going to say
29:28 - j.self.pause1
29:31 - so we're just saying i which stands for
29:33 - row j stands for column
29:35 - um like a classic like convention for it
29:38 - so that we don't have to keep typing
29:39 - pause zero pause one when we move okay
29:42 - so the next one next thing we need to do
29:43 - is now draw a rectangle we're gonna say
29:45 - pygame.draw.correct
29:48 - like this
29:49 - and then we need a surface
29:51 - we need a color so self.color and then
29:53 - we need a rect and here is a little bit
29:55 - of math i'm just going to type it and
29:56 - i'll go through exactly what what it
29:58 - does
30:00 - j multiplied by
30:01 - this one
30:04 - this minus two
30:05 - this s2
30:07 - okay so the reason i have these little
30:09 - plus ones and these minus twos here is
30:11 - just so you can still see the grid when
30:13 - we draw the rectangle um
30:15 - because if we were to draw with exactly
30:18 - the dimensions of this distance um
30:21 - then what would end up happening is we'd
30:22 - cover the white lines of the grid and it
30:24 - just looks kind of weird if you can't
30:25 - see the white lines um so that's why i
30:27 - have plus one
30:29 - added here and minus two just so we're
30:31 - drawn inside of the uh the circle or
30:33 - inside of the square a little bit and
30:34 - you'll see that in a second so what i'm
30:35 - simply doing is i'm multiplying my i
30:37 - value
30:38 - which is going to be my current like row
30:40 - column by the distance that we need to
30:42 - get to the next one and then same thing
30:44 - for j
30:45 - and then these little add ones minus
30:46 - twos is just to make sure that we stay
30:48 - inside so a quick quick example if you
30:50 - don't understand is say we're in a
30:51 - position zero zero so our i is zero and
30:53 - our j is zero
30:55 - we're going to say i multiplied by
30:57 - distance let's say distance is like 40.
30:59 - okay so zero multiplied by forty zero
31:01 - zero multiplied by forty 0. so our
31:04 - position is 0 0 and that's correct
31:06 - because if we're drawing in the top left
31:07 - hand corner here and we're in position 0
31:09 - 0 then that's where we should draw again
31:11 - if you go something like 0 10
31:14 - and you or and you move down i guess so
31:16 - 10 you're moving wide down you're going
31:18 - to say 0 minus distance 0 and you're
31:20 - going to say 10 multiplied by distance
31:22 - let's say it's 40 then we move to that
31:24 - correct position down the screen
31:27 - so this is rectangle x y with height
31:29 - okay makes sense now the next thing we
31:30 - need to do is we need to draw the eyes
31:33 - now you can skip this part if you want
31:34 - i'm just going to copy it in because
31:35 - it's a little bit of math to make it
31:36 - them like perfectly aligned on the
31:38 - square um
31:40 - but yeah so we say if eyes and we're
31:42 - saying our center is equal to distance
31:44 - modulus 2 because that's going to be the
31:46 - center obviously or much so i'm saying
31:48 - divided by 2 is going to be the middle
31:50 - of our cube
31:52 - and we're saying the radius that's how
31:53 - big the i radius is going to be
31:55 - and then we go through a little bit of
31:56 - math here so circle middle is going to
31:58 - be high multiplied by distance plus
32:01 - center minus radius
32:03 - and then we're finding out the x and
32:04 - this is just like a random x that i'm
32:06 - setting by just putting it 8 pixels up
32:09 - like every time because i don't want to
32:10 - calculate the x
32:12 - i don't feel like doing that and then
32:13 - i'm drawing two circles based on circle
32:15 - middle one circle middle two and then
32:17 - the radius and a color of black
32:19 - or a color of white actually sir or no
32:22 - that's black i'm confused all right
32:24 - anyways
32:26 - with all that being said and done and
32:28 - you guys probably pretty confused right
32:30 - now let's just run and see if anything's
32:32 - actually happening and you can see we
32:34 - have a cube in the middle of the screen
32:36 - yay so that's all we've done with all
32:38 - this coding um so far it's drawn a
32:41 - cube so actually not quite because we
32:44 - still
32:45 - all we have to do now simply to start
32:47 - having that cube move and seeing our key
32:48 - presses work is just do a little bit in
32:50 - the main loop so let's move down to the
32:52 - main loop now
32:53 - and have a look here what we need to do
32:56 - okay so what i'm going to do is i'm
32:58 - simply just going to call
32:59 - s dot move which is our snake object
33:01 - every time this main loop runs
33:03 - and what this will allow us to do um is
33:06 - i want to call this before i read draw
33:08 - window is it's going to go up to that
33:09 - method in snake it's going to check
33:11 - every time that we run the loop if a key
33:13 - has been pressed if it has we're going
33:14 - to move accordingly and remember that in
33:16 - this move loop here it moves all of the
33:19 - objects for us so it moves all those
33:20 - cube objects
33:22 - and then we're just drawing the grid
33:24 - we're drawing everything in this redraw
33:25 - function so it'll just display that and
33:27 - update that to the screen so let's see
33:28 - here
33:29 - and we get an error tuple object is not
33:31 - callable self dot pause zero plus
33:33 - although they're next
33:35 - um all right one second guys oh it's
33:37 - because i've used
33:42 - okay so apparently i am an idiot and i
33:44 - forgot to add an equal sign here so the
33:46 - issue was simply that this looked
33:49 - something like this then i changed it to
33:51 - square brackets when all i needed to do
33:53 - was put an equal sign like this and now
33:55 - we should be up and we're working so to
33:57 - reiterate the line here
33:59 - that the issue is out you guys probably
34:00 - saw this when i coded it to be honest um
34:03 - is
34:04 - in move in cube it's near the top of the
34:06 - program all you have to do is change
34:08 - this add an equal sign between this like
34:11 - the bracket and the pause so now that we
34:14 - run it we can see that we have a moving
34:16 - object and that we can move up down left
34:18 - right etc so on and so forth like that
34:23 - okay so play around with that for a
34:25 - second and now we'll get into adding
34:27 - cubes
34:28 - and we're actually almost done we just
34:30 - need to add the add cube function
34:32 - message box a little bit in the main
34:34 - loop and then we'll be finished
34:35 - okay so what we're going to do now is
34:38 - that's all great we're moving around but
34:39 - we need to add stuff to our cube right
34:41 - like we need to progress the game so to
34:43 - do this we are going to generate what i
34:46 - want to call a random snack that we're
34:47 - going to place on the screen
34:49 - that our snake can't eat so
34:51 - the way that we do this i'm just going
34:53 - to say
34:54 - positions
34:56 - equals item dot body and this item oops
35:00 - shouldn't be items should be item
35:02 - it's just going to be a snake object i
35:04 - don't know why i'm calling it item but
35:05 - that's what i'm calling it
35:06 - um and we're simply just going to set
35:08 - like a new list equal to
35:10 - that list
35:12 - so on okay so now we're going to say
35:13 - while true
35:16 - capital t
35:18 - we're gonna do x equals random dot rand
35:22 - range if you haven't imported random yet
35:24 - make sure you do that and y equals
35:26 - random dot range
35:28 - range rows
35:31 - and rows again should be
35:33 - global so let's make sure that
35:36 - this works with global rows
35:39 - like that and then after this we're
35:41 - going to say
35:42 - if don't know how i just typed that but
35:45 - the length of
35:47 - and i'm doing something fancy here and
35:48 - i'll explain what this does in a second
36:06 - okay
36:06 - so i know i just typed uh this stuff
36:09 - that probably makes absolutely no sense
36:10 - you guys if you haven't been using
36:11 - python for a little bit but pretty much
36:13 - what this is going to do
36:15 - is we're going to get a list
36:17 - of a filtered uh list
36:20 - and we're going to see if any of the
36:22 - positions are the same as
36:26 - like the current position of the snake
36:28 - pretty well so what we're doing is we're
36:30 - saying that we want to make sure that
36:32 - we're not going to put a snack on top of
36:34 - the snake because if we have a really
36:36 - long snake the chance that happens
36:37 - actually somewhat high and i didn't do
36:39 - this when i first coded the game so what
36:41 - happened is when you have your snake
36:42 - moving around the screen all of a sudden
36:43 - the snack would pop up but it's like on
36:45 - the tail of the snake
36:47 - um which you don't want so what this is
36:49 - doing and just type it out you don't
36:50 - really have to understand it
36:52 - is we're saying this this means a
36:53 - function
36:54 - uh z
36:55 - and we're just checking if the z dot
36:57 - position uh is equal to uh x y
37:01 - so if it's equal to x y which is the
37:03 - position we just generated here by
37:04 - getting two random numbers so x and y um
37:07 - then we're going to have to do this
37:09 - again so we say
37:11 - continue
37:14 - and else
37:16 - we break
37:18 - like that and then i'm just simply going
37:19 - to return
37:22 - a tuple or a tubal whatever you want to
37:23 - call it x y
37:25 - okay so this is confusing but um you can
37:27 - do this in like a much longer way with a
37:29 - for loop where you pretty much loop
37:30 - through every position in this list you
37:33 - check it against x and y
37:35 - you see if it's the same if it's the
37:37 - same then do this loop again otherwise
37:39 - you break and you return x y that's all
37:41 - we're doing in there uh to generate a
37:42 - random snap
37:44 - any message box you're gonna leave that
37:46 - and in here now what we're gonna okay so
37:48 - now that i've created this uh this
37:50 - random snack function what i need to do
37:52 - is i need to use it so i'm just going to
37:54 - create a new object i'm going to call
37:55 - this snack and it's going to be equal to
37:57 - another cube right because we want to
37:59 - have the same functionality we want to
38:01 - be able to draw it
38:02 - possibly move it around right so we're
38:04 - just going to create a new cube object
38:05 - we're going to give it a position of a
38:06 - random snack which is going to be
38:07 - something like this
38:10 - random snack and then random snack i
38:12 - believe oh it takes a row in an item so
38:14 - what we're going to do is we're going to
38:15 - give it
38:17 - or rows and we'll just give it our item
38:20 - which is gonna be s
38:21 - um and then after that what else do we
38:23 - need for cube
38:24 - i don't think we actually need anything
38:26 - else i think that's all we need oh i'm
38:27 - gonna change the color that's what i
38:28 - wanna do i'm gonna change the color
38:30 - equal to green so red green blue 255 for
38:33 - green
38:34 - so that it shows up and is visible on
38:35 - screen and now what i'm going to do down
38:37 - here in this while loop is i'm going to
38:39 - say
38:39 - snack i'm going to check if our the head
38:42 - of our snake has hit the the snack and
38:45 - if it has we're gonna add
38:47 - another part to the body of the snake
38:50 - otherwise we're not gonna do that right
38:51 - and then we're gonna generate a new
38:52 - snack and so on so we're just gonna say
38:54 - if
38:55 - s dot body
38:58 - zero
38:59 - dot pause and this is going to be the
39:00 - head right because we have it ordered i
39:02 - don't need those brackets
39:03 - is equal to
39:05 - snap dot pause and remember these are
39:07 - both cube objects so this works fine
39:08 - because they're going to be tuples um
39:10 - then what we're going to do
39:12 - is we're simply going to say s dot add
39:14 - cube which is a method that we have
39:16 - there that we haven't actually written
39:17 - yet and we're going to say snack is now
39:19 - equal to well a new cube so i'm just
39:21 - going to copy this
39:23 - and paste it here um so all we're doing
39:25 - is now generating a new cube for snack
39:28 - i'm sure i could put something in that
39:30 - like changed it but this is just the way
39:32 - that works okay so now that we've done
39:34 - that we should be able to move around
39:35 - the screen and get the snack but we need
39:37 - to code in the add snack method here
39:40 - which i believe i have here or add cue
39:42 - so the ad cube is pretty straightforward
39:45 - we just have to figure out where we're
39:47 - adding that snack or wherever we're
39:49 - adding that cube i don't know why i keep
39:50 - calling it snack to the uh list so what
39:53 - we're going to do is we're going to
39:54 - figure out where the tail is and we want
39:56 - to add it after that tail
39:58 - so tail is equal to
40:00 - self dot body
40:02 - negative one the last element in that
40:04 - list i'm going to say dx dy which again
40:06 - is going to be our direction x direction
40:07 - why i'm just shorting it shorting it
40:09 - here it's going to be tail dot dern x
40:12 - and
40:13 - tail dot
40:14 - turn y like this
40:16 - now again you can do this in two lines
40:18 - i'm just doing it like this because it's
40:19 - faster and now i'm going to copy some
40:21 - again and we'll just go through exactly
40:23 - what this does
40:26 - okay so pretty much
40:28 - this looks complicated but all it's
40:30 - going to be doing is checking what
40:32 - direction that we're currently moving in
40:34 - like the head of the cube or the tail
40:36 - actually of the cube is moving in so
40:38 - that we can then make sure that when we
40:39 - add that um
40:41 - cube we know where to add it so for
40:43 - adding it like to the right of the cube
40:44 - to the left of the cube above it below
40:46 - it and we can give it the correct
40:48 - direction to be moving in
40:50 - so pretty much
40:53 - um what we do here
40:54 - is we just say we're going to append a
40:56 - new cube to our body
40:59 - and its position if we're moving to the
41:01 - right which in here we are because dx
41:03 - equals 1
41:04 - is one less than the x position of that
41:08 - tail
41:09 - so whatever the last cube is one less
41:10 - than that and that's so that we don't
41:12 - add a cube per se to the right when
41:14 - we're moving to the right and then
41:16 - we're just gonna have overlapping cubes
41:17 - and you're not gonna see them right
41:19 - same thing down here if we're moving
41:21 - down
41:22 - that means or not down sorry for moving
41:24 - left that means we need to add the cube
41:26 - to the right side um so one plus that
41:29 - tail of the exposition of the tail of
41:31 - the cube
41:32 - or of the snake sorry so that we can um
41:35 - have it in the proper position right and
41:36 - the same thing here with x and y uh or
41:39 - with y so that when we're moving up or
41:41 - we're moving down then we add it above
41:43 - otherwise we move we put it below
41:46 - so i just stumbled through that um
41:48 - because there was a lot of different
41:49 - words they're very similar anyways
41:51 - what we need to do now is simply set the
41:53 - direction uh for that cube so now that
41:56 - we added it in if we just left it like
41:58 - that it wouldn't be moving anywhere so
41:59 - we just need to change that to the
42:01 - current direction of that tail so
42:03 - whatever the tail is moving that's where
42:05 - this new cube is going to be moving in
42:06 - that direction so we're just going to
42:07 - say self.body
42:10 - negative1.dern
42:12 - x equals dx and then same thing down
42:15 - here except we're going to change these
42:16 - to y
42:18 - during y
42:20 - equals d y and that again is just the uh
42:23 - where our tail is moving at that current
42:25 - moment
42:26 - okay so now that we've got all that done
42:28 - it's time to see what syntax air we get
42:30 - next name rows is parameter and global
42:35 - one second
42:36 - so i've actually never even ran into
42:38 - that error oh global rows as
42:40 - okay so let's just make this r
42:42 - and let's change this to be
42:47 - one second ah we can just get rid of
42:48 - this
42:50 - and this should work there we go so now
42:52 - we move around like this the only issue
42:54 - is our snack is not being generated on
42:56 - the screen and i don't know why that is
42:58 - exactly happening oh it's because we're
43:00 - not drawing the snack that's why so
43:02 - now i'm just going to global snack up
43:04 - here i believe that's what i called it
43:06 - and i'm simply just going to say snack
43:09 - dot
43:09 - draw
43:10 - like that and i gotta give it a surface
43:13 - so let's give it a surface let's run
43:16 - and error name snack is not defined
43:19 - it's because i didn't global it down
43:20 - here so let's
43:22 - go over that
43:23 - okay so now we have the snack it's on
43:26 - the screen
43:27 - and you can see that when we collect it
43:29 - we have that cube added to the end of
43:31 - our snake
43:32 - and that pretty much is almost the game
43:35 - done so all we need to do now
43:37 - is write that reset method and then we
43:40 - need to just simply check like when we
43:42 - lose like right now the snake can go
43:43 - through each other right through itself
43:44 - and you can see we have a huge error
43:46 - when the snake can go through itself so
43:48 - we need to make sure that when we hit
43:50 - ourselves um we like end the game and we
43:52 - need to write that message method as
43:54 - well so to do this um
43:57 - again i'm just going to copy in this for
43:59 - loop uh and then we'll kind of go go
44:02 - from there so
44:03 - let's move in here
44:06 - okay so for x and range the length of s
44:08 - dot body uh we're going to say s dot
44:10 - body x which is going to be we're just
44:12 - looping through every cube in our snake
44:14 - body we're checking if the position
44:17 - is in a list of um
44:20 - all the positions after that works um
44:23 - that's how we're checking the collision
44:24 - if you want to do it your own way um go
44:26 - ahead but this is the way that i like to
44:27 - do it okay so now what i'm going to do
44:29 - um is i just want to print to the
44:31 - console like their score uh just so that
44:33 - i know what it is let's say a score
44:35 - oops
44:38 - and then we'll just say plus is the
44:40 - length of
44:42 - s dot body but this is going to have to
44:44 - be converted to a string unless i put a
44:46 - comma like that so let's just do it like
44:47 - that
44:48 - and then i am going to simply display a
44:50 - message box will say message box
44:53 - like this message underscore box uh we
44:56 - have a subject and we have content and
44:58 - we'll we'll do that in just a second
44:59 - because i haven't yet um actually coded
45:01 - that
45:02 - and then we're going to reset our snake
45:03 - by just doing s dot reset and this is
45:04 - going to take a position which is going
45:05 - to be our starting position again 10 10.
45:08 - um and then we're going to break out of
45:09 - this for loop because if we collided
45:11 - once we don't really care if we collided
45:12 - again
45:14 - and go back and we continue the game
45:16 - with a snake that has length one now
45:19 - okay
45:20 - so our reset um this is pretty
45:22 - straightforward all i'm doing in this
45:23 - reset
45:24 - is i'm just gonna get rid of
45:27 - our turns i'm gonna get rid of our body
45:30 - um and i'm just going to change like the
45:31 - direction x and the direction y so maybe
45:33 - it's faster if i just copy it and you
45:34 - guys can
45:36 - just copy this out
45:38 - so pretty much all i'm doing is i'm
45:39 - setting a new head um which is going to
45:41 - be equal to
45:43 - again like whatever position we give in
45:44 - because we can move it at a different
45:45 - position if we wanted to i'm clearing
45:48 - self.body which is in the class variable
45:50 - here
45:51 - and then i'm adding head i'm setting
45:54 - turns equal to blank direction x is zero
45:56 - direction y is set to one again so we
45:58 - start moving and you can see it's pretty
46:01 - much exactly what i have typed out here
46:02 - except i'm just resetting the turns list
46:05 - okay so now that we've done that
46:07 - all we need to code is message box so
46:09 - this one's pretty easy um you can see up
46:11 - here just in case you haven't looked yet
46:13 - um i import tkinter stk and then from
46:16 - decanter i import message box
46:18 - now this is how you create a message box
46:20 - in a pie game and this is how you create
46:22 - one that actually shows up on top of the
46:24 - screen um and that doesn't like float
46:26 - kind of below it or it doesn't show up
46:28 - right away if you want to say that um so
46:31 - just watch this is extremely useful to
46:32 - use in other programs too if you if you
46:34 - copy out this uh
46:35 - function and then you just drag it into
46:36 - other ones so
46:39 - attributes
46:43 - topmost
46:44 - comma true what this simply does is
46:46 - we're creating a root oops which is not
46:49 - root.tk it's root equal to tk.tk which
46:52 - is going to be a new tkinter window
46:54 - we're making sure that this window is
46:56 - going to be on top of anything so if we
46:58 - have like a bunch of different windows
46:59 - open it just comes up on top which is
47:01 - what we want i'm just going to simply
47:03 - make this window now
47:04 - invisible and i'll explain how this
47:06 - works in a second and then from this
47:08 - message box um
47:10 - what do you call it method class
47:11 - whatever it's going to say message box
47:13 - dot show info
47:14 - and then we're going to do subject
47:16 - and content
47:18 - and this just takes it takes a few more
47:19 - parameters as well if you want but
47:21 - pretty much just just shows info
47:22 - given whatever subject we type in and
47:24 - whatever content we have and now i'm
47:26 - going to say try
47:29 - root dot
47:30 - destroy
47:31 - like that
47:34 - accept oops
47:37 - uh pass and don't ask me what this does
47:39 - because honestly i don't know but it
47:40 - just works so pretty much it shows this
47:42 - message box
47:43 - and i'm actually pretty sure the way
47:45 - that this works is it constantly keeps
47:47 - trying to destroy the message box until
47:50 - eventually you click the x button and
47:52 - then it actually can i think it's like
47:53 - something like that so anyways that's
47:54 - how you create a message box and with
47:57 - that we all need to do is add a subject
47:59 - and content so i'm going to say you lost
48:03 - and
48:04 - our message will be play again
48:08 - let's run the program for the last time
48:10 - and make sure everything is working
48:13 - so there we go i just need to get my
48:14 - snake to a length that is uh large
48:16 - enough to the point where i can actually
48:18 - hit myself
48:21 - oh okay and there we go so pretty much
48:24 - we ran into an error
48:25 - what is the air i spelt attributes wrong
48:28 - that is lovely air to run into let's
48:31 - run back up here
48:33 - attributes attributes attributes where
48:35 - did i even make this function i must
48:36 - have scrolled path it all right there we
48:37 - go
48:41 - and i believe that's correct
48:43 - let's try this now
48:46 - so i'm actually just going to go and see
48:48 - if i can there we go okay so we get a
48:50 - message says you lost play again and the
48:52 - reason i died there by the way is
48:53 - because while i was moving right i moved
48:55 - left so technically um the head of my
48:58 - snake actually ran into another part of
49:00 - it so it says you lost play again um and
49:02 - you can make that say exactly what you
49:04 - want and then we can see that our guy
49:05 - just continues to move
49:07 - so on
49:08 - so anyways
49:09 - if you guys want to see more content
49:11 - like this go check out my channel it is
49:13 - named tech with tim and i do have a
49:15 - bunch of videos teaching stuff like pie
49:17 - game and doing a bunch of python
49:18 - tutorials you guys will definitely learn
49:20 - a lot following through some of my
49:21 - videos and i would be very grateful if
49:23 - you guys went over there and liked some
49:25 - of my videos and subscribed