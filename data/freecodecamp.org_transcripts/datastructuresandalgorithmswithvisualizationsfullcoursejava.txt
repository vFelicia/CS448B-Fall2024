00:00 - Data structures and algorithms are an important aspect
00:03 - of every coding interview.
00:05 - This algorithms and data structures course
00:08 - will teach you everything you need to prepare
00:11 - for placements, coding interviews, and logic building.
00:15 - This course walks you through multiple Java algorithms,
00:18 - data structure problems, and their solutions
00:22 - with step-by-step visualizations
00:24 - so that you're actually learning
00:26 - instead of blindly memorizing solutions.
00:28 - Dinesh Varyani created this course.
00:30 - He is an experienced cloud engineer at Google.
00:34 - Hello, friends.
00:35 - Do you want to learn data structures and algorithms
00:38 - through animations and implementation
00:40 - so that you can correct the coding interview?
00:43 - Hi, my name is Dinesh Varyani,
00:46 - and I am your instructor for this course.
00:48 - I have over 10 years of experience
00:50 - as a full-stack developer.
00:53 - Through this course, and by other means,
00:54 - I have helped over thousands of students
00:57 - just like you to improve on data structures and algorithms.
01:02 - So through this course, you will learn about
01:04 - singly linked list,
01:11 - doubly linked list,
01:20 - circular singly linked list,
01:28 - arrays,
01:37 - stacks,
01:45 - queues,
01:53 - binary tree,
01:57 - binary heaps,
02:02 - graphs,
02:09 - matrix,
02:24 - tries,
02:27 - tries,
02:32 - we will also look into its implementation
02:35 - by coding the algorithm in IDE.
02:42 - And what else?
02:43 - You will get much more than that
02:45 - through this course.
02:49 - So, friends, what are you waiting for?
02:52 - You can go to this playlist link
02:55 - provided in the description of the video
02:58 - where you will find all the videos
03:00 - that are part of this course.
03:09 - I update this playlist daily.
03:14 - So the only help I need from you is
03:16 - in case you like any of these videos,
03:19 - then please share this playlist
03:21 - with your friends and colleagues.
03:24 - And please subscribe to my channel.
03:26 - It will only motivate me to add more and more videos
03:29 - into this playlist.
03:32 - So friends, let's move ahead and begin this course.
03:35 - Thanks. Have a nice day.
03:48 - Hello everyone.
03:50 - So in this section, we will discuss about
03:52 - a basic introduction to data structures.
03:58 - So what is data structures?
04:01 - So if you see,
04:03 - it is a way to organize the data.
04:06 - Now what do we mean by that is
04:07 - when we want to program anything
04:09 - and we have a huge amount of data.
04:12 - So we basically take the help of data structures
04:14 - to organize the data into the memory.
04:18 - So why we organize the data?
04:21 - It is because after organizing the data,
04:23 - it becomes very easy to process it.
04:26 - Now what do we mean by that is,
04:28 - if we have an organized data,
04:30 - we can very much efficiently access and process it.
04:34 - So here let's say if we take an example.
04:39 - Let's say if you go to a library
04:41 - where you find these unorganized books.
04:44 - Now if someone asks you
04:46 - that bring a book related to algorithms
04:49 - from this unorganized books
04:51 - of let's say any particular author.
04:54 - So now you can see that as books are unorganized,
04:57 - there is a problem.
04:59 - Because in order to find a book related to algorithm
05:02 - for a particular author,
05:03 - you need to find that book in this unorganized books.
05:07 - So it will take a lot of time to find that book.
05:11 - Now let's say if this unorganized books
05:16 - are basically organized like this
05:18 - on a particular shelf.
05:20 - And now if somebody asks you that go and find
05:22 - a particular book related to algorithms
05:24 - of a particular author.
05:27 - So it would be very easy for you.
05:29 - You will just go to that particular section
05:31 - where the books related to algorithms are kept
05:34 - and you will just find that book.
05:36 - So here you can see that books
05:38 - can be related to the data.
05:41 - And when we organize these books,
05:43 - you can similarly relate it to the data structures
05:46 - where we are simply organizing the data
05:48 - so that it becomes easy to process it.
05:52 - So this is the basic introduction
05:54 - about what is data structures.
05:57 - Now let us see what are the types of data structures.
06:03 - So basically there are two types of data structures
06:05 - linear and non-linear.
06:08 - Now when we talk about linear data structures,
06:10 - they have the data elements arranged in a sequential manner.
06:15 - And they are arranged sequentially
06:17 - so that each member is connected
06:19 - to its previous and next element.
06:22 - And as they are connected sequentially,
06:24 - it becomes easy to traverse them.
06:27 - And usually the traversal is a single level.
06:30 - Now these type of data structures are very easy to implement
06:33 - because they are stored sequentially in the memory.
06:37 - So some of the examples of the linear data structures
06:39 - are as follows.
06:41 - So here if you see array, linked list, stack and queue.
06:45 - So these are the linear data structures
06:47 - where the elements are stored sequentially
06:50 - and mostly they are single level.
06:54 - So the other type of data structure is non-linear data structures.
06:58 - So if you see by this term non-linear
07:00 - we mean that the data elements inside these data structures
07:04 - are not in sequence.
07:07 - They are basically connected to one another
07:09 - through different paths.
07:11 - And as in linear data structures
07:13 - they were single level.
07:15 - Here they are basically stored in multi-level.
07:19 - And as they are multi-level
07:21 - so in order to traverse each and every element
07:23 - in this non-linear data structure
07:25 - takes some amount of time.
07:27 - Now as they are multi-level
07:29 - in order to traverse each and every element
07:31 - in this non-linear data structure
07:33 - is bit difficult.
07:35 - And compared to linear data structures
07:38 - they are not easy to implement.
07:40 - So some of the examples of non-linear data structures are
07:43 - tree and graph.
07:46 - So here if you see
07:48 - if we take an example of an array
07:50 - the data is arranged sequentially
07:52 - and it is basically in a single level
07:54 - so we can traverse it sequentially.
07:57 - So it is very easy to implement.
08:00 - But here if you see
08:02 - that non-linear data structures
08:04 - are multi-level.
08:05 - So here it is an example of a tree
08:07 - where the topmost element is the root.
08:09 - So here if you see
08:11 - these data elements are connected
08:13 - through multiple paths
08:15 - and they are in multiple levels.
08:17 - So here we discussed about the data structures
08:21 - and we also discussed about the types of data structures
08:24 - which is linear and non-linear.
08:26 - In linear
08:28 - few examples are array, linked list,
08:30 - stack, queue
08:32 - and in non-linear
08:34 - we have tree and graph.
08:36 - So in our upcoming videos
08:38 - we will discuss more about the array,
08:40 - linked list, stack, queue,
08:42 - tree and the graph data structures.
08:45 - So I hope you like this video
08:47 - Thanks have a nice day.
08:52 - Hello everyone.
08:53 - So in this section we will discuss about
08:55 - a basic introduction to algorithms.
09:00 - So what is an algorithm?
09:03 - So if you see the formal definition of algorithm
09:06 - an algorithm is a set of instructions
09:08 - to perform a task
09:10 - or to solve a given problem.
09:13 - So what do we mean by set of instructions is that
09:15 - let's say we are given a problem
09:17 - so there would be a sequence of steps
09:20 - or there would be a set of instructions
09:22 - if we follow that
09:24 - our given problem will be solved.
09:26 - So let's say for example
09:28 - we are aware of a recipe book
09:30 - so it is nothing but a collection of recipes
09:32 - in which each recipe provides
09:34 - and step by step instruction
09:36 - to prepare the food.
09:39 - So let's say if someone asks you
09:41 - that provide me the recipe
09:43 - to prepare a tea
09:45 - so basically the steps
09:46 - inside that recipe would be
09:49 - the first step would be
09:51 - that we need to boil water
09:53 - second would be put tea in the teapot
09:57 - the third step would be
09:59 - that put that boil water
10:01 - into the teapot
10:04 - so after adding the hot water
10:06 - the fourth step would be
10:07 - that as we have hot tea
10:09 - so we just put that hot tea into the tea cups
10:14 - so the fifth step would be
10:15 - that do you need sugar
10:18 - so there is a choice
10:21 - if yes
10:22 - then put that sugar into the tea cups
10:25 - and if no
10:26 - then do nothing
10:29 - and the last step would be
10:31 - stir, drink and enjoy the tea
10:33 - so here if you see that this recipe of preparing a tea
10:36 - is very much similar to
10:38 - an algorithm
10:40 - which is nothing but set of instructions
10:42 - which help us to solve
10:44 - a given problem
10:46 - so here let's say we take an example
10:50 - that we want to print the average of 3 numbers
10:53 - so we are given 3 numbers
10:55 - and we want to print the average of it
10:58 - now let's say you want to write an algorithm
11:00 - to solve this given problem
11:03 - so the steps you would provide would be
11:06 - first you will perform the sum of 3 numbers
11:10 - stored at sum into a variable
11:12 - by name sum
11:16 - divide the value stored in sum by 3
11:19 - and store the value
11:21 - into a variable average
11:24 - and finally print the value stored in the average
11:27 - so this would be the sequence of steps
11:29 - which you would perform
11:31 - to print the average of
11:33 - 3 given numbers
11:35 - and this set of instructions is nothing but an algorithm
11:40 - so here if we transform these 5 steps
11:42 - into the code
11:44 - then here we have a method
11:46 - find average
11:47 - where we are given 3
11:49 - numbers
11:50 - a, b and c
11:52 - so we perform the sum of 3 numbers
11:54 - here
11:55 - we store it
11:57 - in a variable sum
11:59 - so here we are storing it here
12:01 - then we are dividing the sum by 3
12:03 - so whatever the value is there in sum
12:05 - we are dividing it by 3
12:07 - we are storing the value in
12:09 - variable average here
12:11 - and finally we are printing the value
12:13 - stored in average here
12:16 - so this sequence of steps
12:18 - is nothing but an algorithm
12:20 - and usually when we are given any particular problems
12:24 - we derive this sequence of steps
12:28 - and we try to implement it in particular language
12:32 - and write the logic around it
12:34 - and finally after performing all the steps properly
12:38 - the given problem is solved
12:40 - so friend this was the basic introduction
12:42 - to algorithms
12:44 - in our upcoming videos
12:46 - we will discuss the algorithms
12:48 - and data structure in great detail
12:50 - I hope you like this video
12:52 - thanks have a nice day
12:56 - hello everyone
12:58 - so in our previous section we discussed about
13:00 - a basic introduction to algorithms
13:02 - and data structure
13:04 - now in this section we will mostly discuss
13:06 - about the analysis of algorithm
13:10 - so what do we mean when we say
13:12 - analysis of algorithm
13:14 - so before that we saw
13:16 - in our previous section that
13:18 - an algorithm is a set of instructions
13:20 - which we use
13:22 - to perform a task or to
13:24 - solve a given problem
13:26 - so when we talk about analysis of algorithm
13:28 - this set of instructions
13:30 - are very much important
13:34 - and why they are important because
13:36 - in order to solve a given problem
13:38 - there can be several different algorithms
13:42 - so our analysis
13:44 - mostly deals in finding the best algorithm
13:46 - which runs fast
13:48 - and takes in less memory
13:50 - so why we actually do that
13:52 - because
13:54 - let's say we are given a problem
13:56 - and we have 2 to 3 algorithms
13:58 - to solve that problem
14:00 - but out of the 3 algorithms
14:02 - one algorithm
14:04 - let's say takes 1 second
14:06 - the other takes 5 seconds
14:08 - and the third one takes
14:10 - 10 seconds
14:12 - and similar with the memory
14:14 - so we usually do analysis of
14:16 - those 3 algorithms
14:18 - and we take that algorithm which takes
14:20 - the less time
14:22 - because if we take an algorithm which takes
14:24 - more time then slowly our system will
14:26 - degrade and we have these performance issues
14:30 - so let's say for example
14:32 - we are given a problem
14:34 - to find sum of first
14:36 - and natural numbers
14:38 - so then natural numbers would be 1, 2, 3, 4, 5, 6
14:40 - and so on
14:42 - so 2 over method we are given a
14:44 - value n and we want to find its sum
14:48 - so let's say if we input n equal to 4
14:52 - so the output we get is 10
14:54 - that is 1 plus 2
14:56 - plus 3 plus 4
14:58 - so 1 plus 2 gives 3
15:00 - 3 plus 3 gives 6
15:02 - and 6 plus 4 gives 10
15:04 - so this is the sum of first
15:06 - 4 natural numbers
15:08 - and similarly
15:10 - let's say if we input
15:12 - n equal to 5
15:14 - then we get output as
15:16 - 15
15:18 - so when we do 1 plus 2 we get
15:20 - 3, 3 plus 3 we get
15:22 - 6, 6 plus 4 we get
15:24 - 10
15:26 - and 10 plus 5 we get 15
15:28 - so this is the sum of
15:30 - first 5 natural numbers
15:32 - now let's say we want to
15:34 - solve this problem
15:36 - and let's say we have
15:38 - these two programmers
15:40 - who come up with their own algorithms
15:42 - so Ramesh comes
15:44 - with one of the algorithms
15:46 - and Suresh comes with yet another algorithm
15:48 - so here Ramesh
15:50 - is trying to find the sum of
15:52 - first and natural numbers using the
15:54 - mathematical formula
15:56 - which is n into n plus 1 by 2
15:58 - so here let's say if we input
16:00 - n equal to 5
16:02 - so it will be 5 into
16:04 - 5 plus 1 by 2
16:06 - so 5 plus 1 is 6
16:08 - 6 divided by 2
16:10 - is 3
16:12 - and 5 into 3 gives 15
16:14 - so this is the mathematical
16:16 - formula which is directly using
16:18 - to find the sum of first
16:20 - and natural numbers
16:22 - and here Suresh has written one algorithm
16:24 - which is what we discussed
16:26 - in our previous slide
16:28 - that 1 plus 2 plus 3 plus 4
16:30 - plus 5
16:32 - so what he is actually doing is
16:34 - he is creating a variable sum
16:36 - initializing it with 0
16:38 - and he is providing a for loop
16:40 - which starts from 1
16:42 - so here i equal to 1
16:44 - and this i will go
16:46 - till it is less than or equal to n
16:48 - and once this statement gets executed
16:50 - we are simply incrementing i by 1
16:52 - so let's say if we input
16:54 - value of n as 5
16:56 - so the start sum will be 0
16:58 - so the start sum will be 0
17:00 - so when this for loop
17:02 - will start execution
17:04 - i becomes 1
17:06 - and we check that 1 is less than 5 or not
17:08 - so it is less than 5
17:10 - then we simply add
17:12 - 0 with 1 because
17:14 - some initial value is 0
17:16 - so 0 plus 1 becomes 1
17:18 - and 1 is assigned to sum
17:20 - now after this line
17:22 - we increment i by 1
17:24 - so i becomes 2
17:27 - we check whether 2 is less than 5 or not
17:30 - so 2 is less than 5
17:32 - the value of sum is 1
17:34 - so we do 1 plus 2
17:36 - we get 3
17:38 - we assign 3 to the sum now
17:40 - then we increment i by 1
17:42 - so i becomes 3
17:44 - we check whether 3 is
17:46 - less than or equal to 5 or not
17:48 - so it is less than or equal to 5
17:50 - so now
17:52 - as the value of sum is 3
17:54 - we do 3 plus 3
17:56 - we get 6
17:58 - we assign 6 to the sum now
18:00 - so sum becomes 6
18:02 - then we simply increment i by 1
18:04 - so i becomes 4
18:06 - 4 is less than equal to 5
18:08 - so sum value is 6
18:10 - we add 4 to it
18:12 - so 6 plus 4 gives 10
18:14 - and 10 is assigned back to sum
18:16 - and then we again increment i by 1
18:18 - so i becomes 5
18:20 - we check whether 5 is
18:22 - less than or equal to 5 or not
18:24 - so i is less than or equal to 5
18:26 - so sum value is 10
18:28 - we add 5
18:30 - we get 15
18:32 - we assign 15 to sum
18:34 - and then we increment i by 1
18:36 - so i becomes 6
18:38 - so now you can see 6 is not less than or equal to 5
18:40 - so this for loop terminates
18:42 - and whatever value
18:44 - we have in sum
18:46 - we simply return
18:48 - so the value of sum is 15
18:50 - we return 15
18:52 - so friends here you can see these are the two algorithms
18:54 - which can solve our problem
18:56 - of finding the sum of first
18:58 - and natural numbers
19:00 - but there is no way to figure out
19:02 - that which algorithm is better than other
19:04 - so in order to determine
19:06 - the best algorithm among these
19:08 - two algorithms
19:10 - we usually check two things
19:12 - one is the time complexity
19:14 - that how much time
19:16 - these algorithms are taking
19:18 - to complete
19:20 - and another is the space complexity
19:22 - that how much memory
19:24 - this algorithm is taking
19:26 - to complete
19:28 - so here in this section we discussed
19:30 - about the analysis of algorithm
19:32 - and its formal definition
19:34 - in our upcoming lecture we will discuss
19:36 - more on what is time complexity and what is
19:38 - space complexity
19:40 - i hope you liked this video
19:42 - thanks have a nice day
19:44 - hello everyone
19:47 - in our previous section we discussed about
19:49 - the analysis of algorithm
19:51 - and we also discussed
19:53 - that there are two complexities
19:55 - which decides
19:57 - that how best is the algorithm
19:59 - so one is the time complexity
20:01 - and the other is space complexity
20:03 - so in this video we will discuss
20:05 - about the time complexity
20:07 - of an algorithm
20:10 - so what do we mean by time complexity
20:12 - so in the simplest terms
20:14 - that is the amount of time
20:16 - taken by an algorithm to run
20:18 - so lets say we have written
20:20 - an algorithm
20:22 - and we try to execute
20:24 - so when that algorithm finishes
20:26 - the amount of time taken by algorithm
20:28 - determines our time complexity
20:33 - so here usually an algorithm
20:35 - takes in an input
20:36 - and in order to process that input
20:38 - some amount of time is taken
20:41 - so an efficient algorithm
20:43 - will try to process the input very fast
20:45 - and a non efficient algorithm
20:47 - will take some more time
20:49 - to process the input
20:51 - so this processing of input
20:53 - by an algorithm
20:55 - helps in determining the time complexity
21:00 - so here in our previous example
21:02 - where we have these two programmers
21:04 - Ramesh and Suresh
21:06 - who have written these two algorithms
21:08 - so here the input is
21:10 - same for both the algorithms
21:12 - but here Ramesh is calculating the
21:14 - sum of first and natural numbers
21:16 - using the mathematical formula
21:18 - which is directly putting the values
21:20 - inside this formula and
21:22 - returning the sum of first and natural numbers
21:24 - whereas here if you see
21:26 - that whatever value of n we are providing
21:28 - we are simply
21:30 - running this statement that many times
21:32 - so in for loop it is running from
21:34 - 1 to a value less than
21:36 - equal to n
21:38 - so here let's say if the value of n is very large
21:40 - this statement will run
21:42 - that many times
21:44 - so the time taken by this algorithm
21:46 - will be somewhat more than
21:48 - this algorithm
21:50 - because here we are processing an input
21:52 - based on a for loop where
21:54 - where this line is executing
21:56 - n number of times
21:58 - and here we are simply using the value of n
22:00 - into this formula
22:02 - which is directly returning
22:04 - the sum of first and natural numbers
22:06 - so definitely this algorithm will be
22:08 - more efficient than this algorithm
22:10 - because the time taken by this algorithm
22:12 - will be less as compared to this
22:14 - and we will also discuss more about
22:16 - how to calculate this time complexity
22:18 - in much greater detail
22:20 - in our upcoming videos
22:22 - but for time being we just
22:24 - analyze that this algorithm will be
22:26 - much better than this algorithm
22:28 - because here there is only
22:30 - one statement which is a constant
22:32 - statement and here we are
22:34 - iterating in a for loop
22:36 - where this line gets executed
22:38 - for n number of times
22:40 - because this loop goes from
22:42 - 1 to less than equal to n
22:44 - so let's try to
22:46 - execute this code in Eclipse and see
22:48 - that how much time these algorithms
22:50 - are taking
22:52 - so friends here you can see
22:54 - that we have written this both the algorithms
22:56 - and inside
22:58 - our main method we are simply calling
23:00 - this find some method
23:02 - now here what we are simply doing is
23:04 - when we run this main method
23:06 - we are storing the current time
23:08 - in this variable then we are
23:10 - executing our find some
23:12 - method
23:14 - and at the last we are again calculating
23:16 - the current time and we are simply
23:18 - subtracting
23:20 - this time so we can get
23:22 - the time taken by this algorithm
23:24 - and if you see
23:26 - it gives the time in milliseconds
23:28 - so if we run this algorithm
23:30 - with a very large value of n
23:32 - you will find it will take
23:34 - almost no time because this is only
23:36 - a single statement where
23:38 - we are providing this value of n into this
23:40 - mathematical formula
23:42 - so if I run this
23:44 - so this is the
23:46 - sum of first and natural numbers of
23:48 - 99,999
23:50 - and here you can see
23:52 - the time taken is almost
23:54 - 0 milliseconds
23:56 - now let's say if I comment this part
24:02 - and I uncomment this
24:06 - so now if I run
24:08 - this algorithm again so now this algorithm
24:10 - will be executed
24:16 - so here you can see
24:18 - the answer is the same but
24:20 - the time taken is almost 2 milliseconds
24:22 - so here you can see
24:24 - that though we have these 2 algorithms
24:26 - which solves our problem
24:28 - we usually do the analysis of the
24:30 - algorithms to get
24:32 - the best algorithm out of the options
24:34 - and also
24:36 - calculating the time taken by algorithm
24:38 - by this is also a not good idea
24:40 - because this depends
24:42 - on machine to machine
24:44 - so it is just giving us a rough estimate about
24:46 - the time taken by these algorithms
24:48 - but when we do analysis of algorithm
24:50 - there are different mathematical tools
24:52 - which can help us determining
24:54 - the time complexity of an algorithm
24:56 - so this was all about
24:58 - the time complexity of an algorithm
25:00 - I hope you liked this video
25:02 - thanks have a nice day
25:06 - hello everyone
25:08 - so in our previous video we discussed
25:10 - about the time complexity of an algorithm
25:12 - and we will discuss more on this
25:14 - in our upcoming videos
25:16 - so in this video we will discuss
25:18 - about the space complexity of an algorithm
25:23 - so the first thing which comes into our mind
25:25 - is what is space complexity
25:28 - so in simple terms you can say
25:30 - that space complexity
25:32 - is basically
25:34 - the amount of memory or space taken
25:36 - by an algorithm to run
25:41 - so friend let's say we have these 2 algorithms
25:43 - written by 2 different programmers
25:45 - Ramesh and Suresh
25:47 - now in order to determine
25:49 - which is the best possible
25:51 - algorithm
25:53 - one constraint is the time complexity
25:55 - which we discussed in our previous video
25:57 - the other is
25:59 - the memory required to process
26:01 - the input by an algorithm
26:03 - basically helps in determining
26:05 - the space complexity
26:07 - so usually we even measure
26:09 - that how much space
26:11 - this algorithm is taking
26:13 - and how much space or memory
26:15 - this algorithm is taking
26:17 - and whichever is taking the less memory
26:19 - we simply choose that algorithm
26:21 - because when we run these algorithms
26:23 - with a system having so many users
26:25 - it may happen that our memory
26:27 - gets exhausted
26:29 - so we try to fit in
26:31 - the best possible algorithm
26:33 - which takes less memory
26:35 - so here when we calculate
26:37 - the time and space complexity
26:39 - we never go
26:41 - into the exact numbers
26:43 - there are certain mathematical tools
26:45 - which help us in determining
26:47 - the time and space complexity of an algorithm
26:49 - and we usually
26:51 - term them asymptotic
26:53 - analysis of an algorithm
26:55 - in our upcoming videos we will discuss
26:57 - more about the asymptotic
26:59 - analysis and its notations
27:01 - and we will also discuss
27:03 - how we can use those mathematical tools
27:05 - to determine the time and
27:07 - space complexity of an algorithm
27:09 - I hope you have liked this video
27:11 - thanks have a nice day
27:13 - hello everyone
27:17 - so in our previous videos
27:19 - we discussed about the time complexity
27:21 - and space complexity
27:23 - of an algorithm
27:25 - we saw how time and space
27:27 - affects the performance
27:29 - of an algorithm
27:31 - but usually we don't go by the exact numbers
27:33 - that how much exact time
27:35 - an algorithm is taking
27:37 - or how much space in numbers
27:39 - an algorithm is taking
27:41 - so usually there are mathematical models
27:43 - which help us in determining
27:45 - the time and space complexity of an algorithm
27:47 - and the analysis
27:49 - which deals with those mathematical models
27:51 - we term it as
27:53 - asymptotic analysis
27:57 - so what do we mean by
27:59 - asymptotic analysis
28:01 - asymptotic analysis helps in evaluating
28:03 - the performance of an algorithm
28:05 - in terms of input size
28:07 - and its increase
28:09 - so lets say we are given an algorithm
28:11 - with certain input size
28:13 - we use this asymptotic analysis
28:15 - and determine the performance
28:17 - of an algorithm
28:19 - so this study also help us in
28:21 - determining lets say if the input size is less
28:23 - then how much time
28:25 - the algorithm is taking
28:27 - and if we increase the input size
28:29 - then how much time or space
28:31 - the algorithm is taking
28:35 - so usually when we do this asymptotic
28:37 - analysis we dont actually measure
28:39 - the actual running time
28:41 - of an algorithm
28:43 - this analysis simply
28:45 - help us in determining that how
28:47 - time and space taken up by algorithm
28:49 - increases with the input size
28:51 - so as we already
28:53 - discussed that if the input size
28:55 - to an algorithm is less
28:57 - then less time and space will be
28:59 - required by the algorithm to process that input
29:01 - and if we slowly increase
29:03 - the size of the input
29:05 - usually the time and space will also increase
29:07 - so this asymptotic analysis
29:09 - help us in determining
29:11 - that increase
29:13 - and also when we perform this analysis
29:15 - there are certain notations
29:17 - which we need to know to perform
29:19 - the asymptotic analysis
29:21 - so we will discuss about the asymptotic
29:23 - notations in our upcoming videos
29:25 - so in this video
29:27 - we simply discuss about the
29:29 - basic introduction to asymptotic analysis
29:31 - in our upcoming video
29:33 - we will discuss about the
29:35 - asymptotic notations and the types
29:37 - of asymptotic notations
29:39 - I hope you like this video
29:41 - thanks have a nice day
29:45 - hello everyone
29:47 - in our previous video we discussed about
29:49 - the asymptotic analysis
29:51 - and we also discussed about its basic
29:53 - introduction that asymptotic
29:55 - analysis help us in determining
29:57 - the runtime complexity
29:59 - and space complexity
30:01 - of a given algorithm
30:03 - so usually this asymptotic
30:05 - analysis is being done by
30:07 - asymptotic notations
30:11 - so what do we mean by asymptotic notations?
30:15 - so if we see the definition of it
30:17 - asymptotic notations
30:19 - are the mathematical tools
30:21 - used to describe the running type of an algorithm
30:23 - in terms of its input size
30:25 - so here we will discuss
30:27 - more on these mathematical tools
30:29 - that what are those
30:31 - and how it helps in determining
30:33 - the running time of an algorithm
30:35 - so in order to understand
30:37 - about this asymptotic notations
30:39 - we will take an example
30:45 - let's say you go to a car showroom
30:47 - where you want to purchase this car
30:49 - so mostly you will look into the
30:51 - design of the car
30:53 - and to the salesman you will ask
30:55 - one most important question
30:57 - what is the performance of car
30:59 - in 1 litre of petrol
31:01 - that how much this car travels
31:03 - in 1 litre of petrol
31:05 - so basically the salesman will never
31:07 - give you an exact answer
31:09 - he will simply give you the numbers
31:11 - based on certain conditions
31:13 - the car is running
31:15 - so he will simply tell you
31:17 - that if you are running this car on
31:19 - highway where the traffic
31:21 - is very minimum
31:23 - this car can give you
31:25 - 25 km per litre
31:29 - and if you are running it in a city
31:31 - where the traffic is max
31:33 - it will give you 15 km per litre
31:37 - and let's say if you are running
31:39 - for some amount of time in city
31:41 - and then in highway
31:43 - which means you are encountering an average traffic
31:45 - so it will give you around
31:47 - 20 km per litre
31:49 - so these are the 3 answers which
31:51 - salesman might give you
31:53 - when you ask about the performance
31:55 - of car in 1 litre of petrol
31:57 - so when we talk about
31:59 - an algorithm this
32:01 - asymptotic notations give us
32:03 - this rough idea that
32:05 - how an algorithm will be performing
32:07 - in certain situations
32:09 - so here
32:11 - the asymptotic notations help us in
32:13 - determining the best case
32:15 - average case and the worst
32:17 - case so you can
32:19 - simply relate this analogy to these
32:21 - conditions that best case
32:23 - would be that if you are driving
32:25 - on a highway the average case
32:27 - would be that you are driving in
32:29 - both city and highway and the worst
32:31 - case would be that you are simply driving in
32:33 - the city
32:35 - so this is how asymptotic notations
32:37 - provide us an in depth
32:39 - description about the
32:41 - running time of an algorithm in terms of
32:43 - its input size
32:45 - so in our upcoming videos we will discuss that
32:47 - what are the asymptotic notation types
32:49 - and how we can use those types
32:51 - to determine the running time of an
32:53 - algorithm in terms of its
32:55 - input size
32:57 - I hope you liked this video
32:59 - thanks have a nice day
33:03 - hello everyone
33:05 - so in our previous video we discussed about
33:07 - asymptotic notations
33:09 - and we also discussed
33:11 - that how asymptotic notations
33:13 - help us in determining
33:15 - the running time of an algorithm in terms
33:17 - of its input size
33:19 - and we also discussed that asymptotic notations
33:21 - help us in determining
33:23 - the best case, average case
33:25 - and the worst case
33:27 - and we also saw an example of a car
33:29 - that how the performance
33:31 - of a car in one litre
33:33 - of petrol differs in different situations
33:35 - so similar analogy
33:37 - is being performed on the
33:39 - algorithms where we determine the best
33:41 - case, average case and the worst case
33:43 - so there are types of asymptotic
33:45 - notations which determines these three cases
33:51 - so here you can see that there are
33:53 - three notations for performing the
33:55 - running time analysis of an algorithm
33:57 - the first notation is
33:59 - the omega notation
34:01 - which is being denoted by
34:03 - omega symbol
34:05 - the second is the big O notation
34:09 - and the third one is
34:11 - the theta notation
34:15 - so let's discuss about the
34:17 - omega notation first
34:19 - so if you see the definition of
34:21 - omega notation
34:23 - so this notation basically
34:25 - expresses the lower bound
34:27 - of an algorithms running time
34:29 - now what do we mean by lower bound
34:31 - of an algorithms running time
34:33 - so basically
34:35 - lower bound means that for any
34:37 - given input size
34:39 - this notation
34:41 - determines the best amount of time
34:43 - an algorithm can take to complete
34:45 - so by best amount of time we mean
34:47 - the lower time
34:49 - so therefore we denote it by lower bound
34:51 - and this determines
34:53 - the best case
34:55 - of an algorithm
34:57 - because omega notation provides
34:59 - us the best amount of time
35:01 - an algorithm can take to complete
35:03 - so as you already discussed
35:05 - that this is the best case analysis of an algorithm
35:07 - so what do you
35:09 - mean by best case
35:11 - let's say for example
35:13 - if you have written certain algorithm
35:15 - and if you say that algorithm takes
35:17 - 100 seconds as the best amount of
35:19 - time so what do you mean by that is
35:21 - that 100 seconds will
35:23 - be the lower bound of that algorithm
35:25 - and the algorithm
35:27 - can take more than 100 seconds to complete
35:29 - but it will not take less than 100 seconds
35:31 - to complete
35:33 - so the best case analysis
35:35 - takes the lower time and
35:37 - provide us with the information that
35:39 - a particular algorithm will take
35:41 - minimum let's say 100 seconds
35:43 - but will not take less than
35:45 - 100 seconds
35:47 - it can take more than 100 seconds but
35:49 - as the lower bound is 100 seconds
35:51 - it will be the best case for that algorithm
35:53 - so this notation is
35:55 - very least used because we are not interested in
35:57 - finding the best amount of time
35:59 - algorithm can take
36:01 - but this notation basically provides
36:03 - an information that what's
36:05 - the minimum resources we need
36:07 - to learn this algorithm
36:09 - the other notation is
36:11 - big O notation
36:13 - so this notation
36:15 - expresses the upper bound of an
36:17 - algorithm's running time
36:19 - now what do you mean by upper bound?
36:21 - upper bound means
36:23 - that for any given input size
36:25 - into an algorithm
36:27 - this notation determines the longest
36:29 - amount of time the algorithm may take
36:31 - to complete
36:33 - now what do we actually mean by the longest
36:35 - amount of time let's say for example
36:37 - that if we say that
36:39 - certain algorithm takes 100 seconds
36:41 - as the longest amount of time
36:43 - so 100 seconds will be the upper bound
36:45 - of that algorithm in
36:47 - big O notation
36:49 - the algorithm may take less than 100 seconds
36:51 - but it will not take more than 100 seconds
36:53 - so this is very opposite of the
36:55 - omega notation
36:57 - so when we say that 100 seconds is the longest amount of time
36:59 - that algorithm may take to complete
37:01 - then that would be the upper bound
37:03 - the algorithm may take
37:05 - 90 seconds, 80 seconds but it won't
37:07 - take more than 100 seconds
37:09 - so this notation is mostly used because
37:11 - we are very much interested
37:13 - in finding the maximum amount
37:15 - of time the algorithm may take to complete
37:17 - so that we can
37:19 - optimize that algorithm
37:21 - to whichever time we want
37:23 - so here the big O notation basically
37:25 - provides us the worst case analysis
37:27 - of an algorithm
37:29 - by worst case we mean
37:31 - determines the longest amount of time
37:33 - the algorithm may take to complete
37:35 - moving ahead
37:37 - the third
37:39 - notation is the theta notation
37:41 - now this notation
37:43 - basically expresses both
37:45 - upper bound and the lower bound
37:47 - of an algorithm's running time
37:49 - so what do we mean by both
37:51 - upper bound and lower bound
37:53 - it means that for any given input
37:55 - size to an algorithm
37:57 - this determines the average
37:59 - amount of time
38:01 - so basically the average case analysis
38:03 - is being determined by the theta
38:05 - notation
38:07 - so for example
38:09 - if we say that certain algorithm
38:11 - takes 100 seconds
38:13 - for the first run, 120 seconds
38:15 - for the second run
38:17 - and 110 seconds for the third run
38:19 - and so on so theta notation
38:21 - gives an average of running time
38:23 - of that algorithm
38:25 - so it basically determines
38:27 - the average of the upper bound
38:29 - and the lower bound of an algorithm's
38:31 - running time
38:33 - so this notation is also very leastly used
38:35 - because there are very rare
38:37 - use cases where we actually determine
38:39 - the average time taken by algorithm
38:41 - to complete
38:43 - so in this video we discussed about
38:45 - the three asymptotic notations
38:47 - which are being used to
38:49 - determine the running time
38:51 - of an algorithm
38:53 - and these three notations also
38:55 - determines the best case
38:57 - the average case and the worst case
38:59 - analysis of an algorithm
39:01 - I hope you have liked this video
39:03 - thanks have a nice day
39:07 - hello everyone
39:09 - so in our previous video we discussed about
39:11 - the best average
39:13 - and the worst case analysis of an algorithm
39:15 - and we also discussed
39:17 - about the three notation
39:19 - and we discussed that big O notation
39:21 - is the mostly used notation
39:23 - in analysis of the time
39:25 - and space complexity
39:27 - so in this video we will look into
39:29 - the analysis of time complexity
39:31 - in big O notation
39:33 - and we will also see certain
39:35 - rules in computing the big O notation
39:37 - so in our previous videos
39:39 - we discussed
39:41 - that big O notation
39:43 - provides us an upper bound
39:45 - of an algorithm's running time
39:47 - by upper bound we mean
39:49 - the longest amount of time
39:51 - an algorithm can take
39:53 - to complete
39:55 - so let's see some
39:57 - rules and assumptions
39:59 - when computing the running time of an
40:01 - algorithm using big O notation
40:07 - so let's say we are given
40:09 - a machine
40:11 - so we assume
40:13 - that it's a single processor machine
40:15 - so let's say the algorithm
40:17 - we have wrote, we are running
40:19 - it on the single processor
40:21 - and this processor is executing
40:23 - the algorithm sequentially
40:27 - now in an algorithm if we
40:29 - see any assignment operation
40:31 - then we simply
40:33 - assume that it can take
40:35 - one unit of time
40:37 - so this one unit of time can be
40:39 - anything, let's say
40:41 - one millisecond
40:43 - one nanosecond
40:45 - we simply term it as one unit of time
40:47 - so
40:49 - if we encounter something like this
40:51 - so we pretty much
40:53 - assume that it may take
40:55 - one unit of time
40:59 - if we encounter
41:01 - return statement we take it
41:03 - as one unit of time
41:05 - so something like this
41:07 - will be taken as one unit of time
41:11 - if we encounter
41:13 - arithmetical operation
41:15 - we take it as one unit of time
41:17 - so something like
41:19 - x plus y
41:21 - x minus y
41:23 - x divided by y
41:25 - x multiplied by y
41:27 - and many other operations
41:29 - we simply take it as one unit of time
41:31 - that this operation will require
41:33 - a single unit of time
41:37 - if we encounter any logical operation
41:39 - we simply take it as
41:41 - one unit of time
41:43 - so something like x and y
41:45 - x or y
41:47 - negation of x, negation of y
41:49 - x or operation
41:51 - so everything which deals with logical operation
41:53 - takes one unit of time
41:57 - and basically other small
41:59 - and single operation we simply
42:01 - take it as one unit of time
42:05 - now as we are computing
42:07 - the bigger notation of an algorithm
42:09 - based on the input size
42:11 - so we basically assume that
42:13 - we have a very large input size
42:17 - so let's say the time taken by algorithm
42:19 - comes out to be
42:21 - n2 plus 3n plus 1
42:23 - so here n is nothing but the input size
42:25 - so here you can see that
42:27 - time is proportional to n2
42:29 - plus 3n plus 1
42:31 - so which is a polynomial equation
42:33 - so here what we actually do
42:35 - that in order to calculate
42:37 - the big O of this polynomial equation
42:40 - we assume that we have taken
42:42 - n as very large
42:44 - so if n is very large
42:46 - we can simply drop the lower order
42:48 - terms
42:49 - so the lower order terms would be
42:51 - 3n and 1
42:53 - because n2 contributes more
42:55 - in determining the time
42:57 - taken by algorithm to run
42:59 - so we simply drop this lower order
43:01 - terms
43:02 - n2n2 we denote
43:04 - as O of n2
43:06 - which is nothing but denoting
43:08 - it in the form of big O notation
43:10 - we simply say
43:12 - the time complexity comes out to be
43:14 - O of n2
43:18 - so similarly
43:20 - there is one more rule
43:22 - we drop the constant multipliers
43:26 - so for example let's say the time taken
43:28 - by an algorithm
43:30 - comes out to be 3n2
43:32 - plus 6n plus 1
43:34 - where n is the input size
43:36 - so here you can see
43:38 - that 6n plus 1
43:40 - is usually dropped because they are lower order terms
43:42 - as we are taking n as very large
43:45 - but here you can see
43:47 - that it also contains the constant multipliers
43:49 - like 3
43:50 - 6
43:52 - so usually as n is very large
43:54 - we also drop the constant multipliers
43:57 - so here
43:59 - after dropping the lower order terms like 6n and 1
44:02 - we also drop this 3
44:04 - and we simply denote it by
44:06 - O of n2
44:08 - so we deduce the time complexity
44:10 - in big O notation
44:12 - by following these simple
44:14 - rules
44:16 - so friends in our upcoming lectures
44:18 - we will apply these rules
44:20 - and we will compute the time complexity
44:22 - of few of the programs
44:24 - so that calculation of big O notation
44:26 - becomes more clear to you
44:28 - I hope you like this video
44:30 - thanks have a nice day
44:35 - hello everyone
44:36 - so in our previous video
44:38 - we discussed about the rules
44:40 - related to big O notation
44:42 - so now let's apply those rules
44:44 - and calculate
44:46 - the time complexity
44:48 - of a constant algorithm
44:52 - so here you can see
44:54 - that let's say we are given
44:56 - this piece of code
44:58 - where we are getting
45:00 - two integers
45:01 - we are doing the sum of it
45:03 - and we are returning the result
45:05 - so here you can see
45:07 - that these are the line numbers here
45:09 - where second and third line
45:11 - are the statements which get executed
45:13 - and here is a simple table
45:15 - provided with the line number
45:17 - and the operations
45:19 - getting performed on
45:21 - each line
45:23 - and the unit of time taken by each line
45:25 - so here
45:27 - we start with the line number 2
45:29 - so here we are simply
45:31 - taking in two integers
45:33 - doing its sum and assigning it to the
45:35 - integer variable result
45:37 - so if we apply the
45:39 - rules which we discussed in our previous video
45:41 - so here
45:43 - first we are accessing x
45:45 - so it will be one operation
45:47 - then we are accessing
45:49 - y
45:51 - so it will be the other operation
45:53 - then we are doing the sum of it
45:55 - so this will be one more operation
45:58 - and then we are assigning it
46:00 - to the result
46:02 - so this will be one more operation
46:04 - so here we are simply
46:06 - performing four operations
46:08 - and we also discussed in our previous
46:10 - video that these four operations
46:12 - will take four units of time
46:14 - because we are providing
46:16 - one unit of time to assignment
46:18 - to arithmetic operation
46:20 - if we are accessing any variable
46:22 - so like that
46:24 - so line number 2 takes four units of time
46:26 - to execute this
46:28 - statement
46:30 - now let's see for the line number 3
46:32 - here we are accessing
46:34 - the result
46:36 - so it will be one operation
46:38 - and then we are returning the result
46:40 - so it would be the other operation
46:42 - so there are total two operations
46:44 - and we know that
46:46 - when we are accessing a variable
46:48 - and when we are returning
46:50 - we provide one unit of time
46:52 - to one operation
46:54 - so total it will take two units of time
46:56 - and when we take the total
46:58 - time taken
47:00 - by this piece of code
47:02 - it will be 4 plus 2
47:04 - which is 6
47:06 - and usually if we see 6
47:08 - is nothing but a constant
47:10 - because here whatever value you take
47:12 - of x and y
47:14 - it will always take a constant amount of time
47:16 - which is 6
47:18 - so here time taken is nearly
47:20 - equal to a constant amount of time
47:22 - so similarly if we see this
47:24 - piece of code
47:26 - let's say we are passing in an array
47:28 - and we are passing
47:30 - in an index and we want to
47:32 - simply get the value stored
47:34 - at that particular index
47:36 - so here you can see that accessing a value
47:38 - of an array from a particular
47:40 - index takes in a
47:42 - constant amount of time
47:44 - so the time taken by this piece of code
47:46 - will be constant
47:48 - now irrespective of how many
47:50 - elements are there in this array
47:52 - let's say if array has 1 lakh element
47:54 - still it will take the constant amount of time
47:56 - and if the array has 1 element
47:58 - still it will take the same amount of time
48:00 - so therefore this is
48:02 - a constant algorithm
48:04 - so we simply denote
48:06 - the time complexity of such
48:08 - algorithm as o of 1
48:10 - because this is the constant
48:12 - and usually
48:14 - in bigger terms
48:16 - we denote the constant by
48:18 - o of 1
48:20 - and if we see the graph
48:22 - of this constant algorithm
48:24 - so here you can see the x axis
48:26 - denotes the volume of data
48:28 - so here you can think
48:30 - of it as the number of elements
48:32 - in this array
48:34 - and the y axis denotes the execution time
48:36 - which is the time taken
48:38 - so here we already discussed
48:40 - irrespective of number of
48:42 - elements or the volume
48:44 - of data inside this array
48:46 - the time taken will be always constant
48:48 - so we simply denote
48:50 - it as constant algorithm
48:52 - which takes constant amount of time
48:54 - even if the volume of data
48:56 - increases
48:58 - so in this video we discussed
49:00 - how we can calculate
49:02 - the bigger notation
49:04 - of a constant algorithm
49:06 - I hope you liked this video
49:08 - thanks have a nice day
49:12 - hello everyone
49:14 - in the previous video we discussed
49:16 - how we can calculate the time complexity
49:18 - of a constant algorithm
49:20 - so in this video
49:22 - we will now discuss how we can calculate
49:24 - the time complexity
49:26 - of a linear algorithm
49:28 - so here let's say we are given this algorithm
49:30 - and this algorithm
49:32 - basically finds some
49:34 - of the first and natural numbers
49:36 - which we also discussed
49:38 - in our previous videos
49:40 - so here we are given a value n
49:42 - so let's say for example
49:44 - if we take value of n as 3
49:46 - so we want to find
49:48 - the sum of first 3 natural numbers
49:50 - so we start the sum
49:52 - with a value 0
49:54 - we then apply a for loop
49:56 - where i is equal to 1
49:58 - and we provide condition
50:00 - that i should be less than equal to 3
50:02 - so at the first step
50:04 - value of i is 1
50:06 - so 1 is less than equal to 3
50:08 - so this condition comes out to be true
50:10 - so in the for loop we do
50:12 - 0 plus 1
50:14 - and assign 1 to the sum
50:16 - and after this statement gets executed
50:18 - we do i plus plus
50:20 - so now i becomes 2
50:22 - then we check whether 2 is less than
50:24 - equal to 3 or not
50:26 - so here 2 is less than 3
50:28 - so then we do
50:30 - 1 plus 2
50:32 - because value of i is 2
50:34 - which gives 3 and we assign
50:36 - 3 to the sum
50:38 - now we again increment i by 1
50:40 - so i becomes 3
50:42 - and 3 is less than or equal to 3
50:44 - so now we do
50:46 - sum of 3 plus 3 which is 6
50:48 - and we assign it to the sum
50:50 - and then we increment
50:52 - i by 1 so i becomes
50:54 - 4 and we check this condition
50:56 - so 4 is not
50:58 - less than equal to 3
51:00 - therefore this condition comes out to be
51:02 - false and this for loop terminates
51:04 - and we return the sum as 6
51:07 - so here let's calculate the time complexity
51:09 - of this algorithm
51:11 - so here we have provided a table
51:13 - where we have marked the line numbers
51:15 - which actually gets executed
51:17 - and take some amount of time
51:19 - so if we start with line number 2
51:21 - so here you can see
51:23 - that we are creating
51:25 - an integer variable sum
51:27 - and assigning it to value 0
51:29 - so this will only take one step
51:31 - so the operation will be
51:33 - only 1 and the unit of time
51:35 - would be 1
51:37 - so now we will count the operations
51:39 - at line number 3
51:41 - so here you can see
51:43 - in the for loop we are creating
51:45 - an integer variable i
51:47 - with a value 1
51:49 - so this would be one operation
51:51 - now here you can see
51:53 - that we are accessing n
51:55 - so this would be one operation
51:57 - we are accessing value i
51:59 - this would be the second operation
52:01 - and then we are comparing them
52:03 - so overall for one execution
52:05 - of this for loop
52:07 - this takes 3 operations
52:09 - so we need to calculate
52:11 - how many iterations this for loop will make
52:13 - so that depends on this
52:15 - incrementation here
52:17 - so let's say value of n is 3
52:19 - so when i was 1
52:21 - it took 3 operations
52:23 - then we incremented
52:25 - i to 2
52:27 - so when i became 2
52:29 - it took 3 more operations
52:31 - and then we incremented i by 1
52:33 - so when i became 3
52:35 - it took 3 more operations
52:37 - and then we again incremented i
52:39 - so i became 4
52:41 - and here you can see
52:43 - that it took 3 more operations
52:45 - just to verify that
52:47 - i is less than equal to n or not
52:49 - so in total this statement
52:51 - executed 4 times
52:53 - we provided a value 3 and it executed
52:55 - 4 times
52:57 - so therefore when we have provided value n
52:59 - this will get executed n plus 1 times
53:01 - and as there are 3 operations
53:03 - in each step
53:05 - so the total operation would be
53:07 - 3 into n plus 1
53:09 - so then we move to i plus plus
53:11 - so in i plus plus
53:13 - what we actually do
53:15 - we access value i
53:17 - we increment it by 1
53:19 - and then we again assign it back to i
53:21 - so accessing i takes
53:23 - one operation
53:25 - incrementing it by 1
53:27 - and assigning it back to i
53:29 - takes 3 operations
53:31 - so for the one iteration of this for loop
53:33 - this takes 3 operations
53:35 - so now we simply count
53:37 - that how many times this i
53:39 - plus plus will get executed
53:41 - so let's say if we take n equal to
53:43 - 3
53:45 - the first time it executed
53:47 - it made i plus plus
53:49 - and i became 2
53:51 - then we executed to make i
53:53 - 2 plus 1 which was 3
53:55 - and finally we made it 3 plus 1
53:57 - which is 4
53:59 - so here you can see
54:01 - that for n equal to 3
54:03 - this got executed 3 times
54:05 - so if we take value of n
54:07 - this will execute n times
54:09 - and as this takes 3 operations
54:11 - per iteration
54:13 - for n times it will take
54:15 - 3 n operations
54:17 - so here we are simply adding 1
54:19 - to 3 into n
54:21 - plus 3 into 1 which is 3
54:23 - and then we are doing plus 3 n
54:25 - so it will become something like this
54:27 - 1 plus 3 n
54:29 - plus 3 plus 3 n
54:31 - so the total unit of time it will take
54:33 - is 3 n plus 3 n
54:35 - 6 n
54:37 - 1 plus 3 is 4
54:39 - so 6 n plus 4
54:41 - so now we will see the time taken by the step 4
54:43 - so here we are accessing i
54:45 - which is one operation
54:47 - we are accessing sum
54:49 - which is 2 operations
54:51 - which is 3 operations
54:53 - and we are assigning it back to sum which is 4 operations
54:55 - so for one iteration
54:57 - of this for loop it will take
54:59 - 4 operations and we know
55:01 - that this for loop will execute n times because
55:03 - i is travelling from 1 to n
55:05 - so this line will get
55:07 - executed n times
55:09 - so here
55:11 - in total it takes
55:13 - 4 operations
55:15 - multiplied by n
55:17 - multiplied by n
55:20 - so the total unit of time it will be
55:22 - 4 n
55:24 - so now we will calculate the time taken by line number 6
55:27 - which is accessing sum
55:29 - and then returning the sum
55:31 - which is 1 plus 1
55:33 - so total time would be 2
55:37 - so if we add this unit times we get
55:39 - the total time would be
55:41 - 1 plus 6 n plus 4
55:43 - plus 4 n plus 2
55:45 - which will be equal to
55:47 - 10 n plus 7 unit times
55:49 - and also in our previous
55:51 - video we discussed
55:53 - that while calculating the big O notation
55:55 - we usually ignore the lower order
55:57 - terms because we assume that
55:59 - value of n is very large
56:01 - so after ignoring the lower order
56:03 - terms
56:05 - and we also discussed that we ignore
56:07 - the constant multipliers
56:09 - so here we ignore 10 also
56:11 - so the time complexity
56:13 - comes out to be
56:15 - O of n
56:17 - which means that time is
56:19 - directly proportional
56:21 - to the value n
56:23 - which is nothing but the input size
56:25 - so if we plot the graph
56:27 - of the execution
56:29 - time on the y axis
56:31 - and the volume of data which is n
56:33 - on the x axis
56:35 - we find that time is proportional to n
56:37 - so here you can see
56:39 - that if we plot this graph
56:41 - it will come in a straight line
56:43 - because the execution
56:45 - time is proportional to the
56:47 - number of input size
56:49 - which is nothing but our volume of data
56:51 - so as volume of data
56:53 - will increase
56:55 - the time taken by this algorithm will increase
56:57 - so this comes out to be a straight line
56:59 - so this is how we denote
57:01 - the time complexity of O of n
57:03 - which is a linear algorithm
57:05 - I hope you have liked this video
57:07 - thanks have a nice day
57:09 - hello everyone
57:11 - so in our previous video we
57:13 - discussed that how we can calculate
57:15 - the time complexity
57:17 - of a linear algorithm
57:19 - so in this video we will discuss
57:21 - that how we can calculate the time complexity
57:23 - of a polynomial algorithm
57:25 - so here
57:27 - we are given an algorithm
57:29 - and we are also given an integer
57:31 - n
57:33 - now what we are doing in this method is
57:35 - we have provided a for loop
57:37 - which goes from
57:39 - i equal to 1
57:41 - to less than equal to n
57:43 - and it gets incremented
57:45 - by 1 for each
57:47 - iteration of this for loop
57:49 - and for each iteration of the
57:51 - outer for loop
57:53 - we have again provided a for loop
57:55 - which starts from j equal to 1
57:57 - and goes
57:59 - till j is less than equal to n
58:01 - and it also gets incremented
58:03 - by j++
58:05 - and inside this inner for loop
58:07 - we are simply printing
58:09 - the value of i and j
58:11 - on the console
58:13 - and after this inner for loop gets executed
58:15 - we are printing
58:17 - end of inner loop
58:19 - and after this outer for loop
58:21 - gets executed completely
58:23 - we are printing end of outer loop
58:25 - so here you can see if we run this code
58:27 - let's say for
58:29 - value n equal to 3
58:31 - so here you can see that
58:33 - this gets printed on the console
58:35 - so in our previous video
58:37 - we also discussed that
58:39 - this outer for loop will go from
58:41 - i equal to 1 to i
58:43 - less than equal to n
58:45 - which is 3 so it will get
58:47 - executed 3 times
58:49 - the outer for loop and for
58:51 - each execution the inner for loop
58:53 - will also get executed
58:55 - exactly 3 times because
58:57 - j is also starting from 1
58:59 - and j is also going till
59:01 - j is less than equal to 3
59:03 - so here you can see
59:05 - that what it gets printed
59:07 - on the console
59:09 - so for i equal to 1 inner for loop
59:11 - gets executed n times
59:13 - so here you can see
59:15 - i equal to 1
59:17 - i equal to 1 and i equal to 1
59:19 - so for i equal to 1 the inner
59:21 - for loop will get executed
59:23 - n times where j will
59:25 - go from 1 to 3
59:27 - so here you can see j equal to 1
59:29 - j equal to 2 and j equal to 3
59:31 - and after inner for loop gets
59:33 - executed end of inner loop
59:35 - gets printed which is here
59:37 - and once it gets finished the execution
59:39 - point reaches here does increment
59:41 - of i by 1 so i
59:43 - becomes 2 and we know that
59:45 - 2 is less than 3
59:47 - so therefore again the inner for loop
59:49 - will execute from j equal to 1
59:51 - to j is less than equal to n
59:53 - and this will get printed
59:55 - 3 times because the inner
59:57 - for loop will get executed
59:59 - n times
60:01 - so for i equal to 2
60:03 - the inner for loop gets executed
60:05 - from j equal to 1 to 3
60:07 - then we print end of inner loop
60:09 - here and then again
60:11 - i gets incremented
60:13 - to 3 and for i equal
60:15 - to 3 the inner for loop will
60:17 - again get executed 3 times
60:19 - and then here
60:21 - we print end of inner loop
60:23 - and then we again increment i
60:25 - by 1 so i becomes 4
60:27 - and 4 is not less than equal to n
60:29 - so therefore the condition breaks
60:31 - and finally we print
60:33 - end of outer loop
60:35 - so here you can see
60:37 - that for each iteration of outer for loop
60:39 - inner for loop gets executed
60:41 - that many number of times
60:43 - from j equal to 1
60:45 - to j is less than equal to n
60:47 - so here in this example
60:49 - as we have taken value of n as 3
60:51 - so you can simply think
60:53 - that outer for loop gets executed
60:55 - 3 times and inner
60:57 - for loop will get executed
60:59 - 3 into 3 times
61:01 - which is 9
61:03 - so here you can see that this statement gets printed
61:05 - 9 times for each
61:07 - value of i inner for loop
61:09 - gets executed from 1 to 3
61:11 - for i equal to 2
61:13 - it gets executed 1 to 3
61:15 - for i equal to 3 it gets executed
61:17 - 1 to 3 so usually
61:19 - this statement at line number
61:21 - 4 gets executed
61:23 - n square times
61:25 - so let's see how many operations are getting
61:27 - performed on each line
61:29 - so for line number 2
61:31 - so in our previous video we already discussed
61:33 - that how many times
61:35 - this for loop will execute
61:37 - so this assignment integer
61:39 - i equal to 1 will get executed
61:41 - exactly 1 time
61:43 - we are accessing i, we are accessing n
61:45 - and then we are comparing
61:47 - so this will get executed
61:49 - exactly n plus 1 times because
61:51 - so when we are providing value of n as 3
61:53 - so when i becomes 4
61:55 - this condition will come out to be false
61:57 - so therefore
61:59 - we provided value n
62:01 - and this will get executed exactly n plus
62:03 - 1 times
62:05 - this is the same
62:07 - stuff which we discussed in our previous video
62:09 - and then this i plus plus
62:11 - will also get executed
62:13 - 3 n times
62:15 - so this for loop will execute n times
62:17 - so it will take 3 n times
62:19 - and if we do the sum of it
62:21 - it will take
62:23 - 6 n plus 4 unit times
62:25 - now let's see about the operation
62:27 - taken by the inner for loop
62:29 - so here you can see the condition
62:31 - are exactly same
62:33 - so here we know that
62:35 - it will take 6 n plus
62:37 - 4 unit time
62:39 - the inner for loop
62:41 - because j is also getting started from 1
62:43 - and it will also go
62:45 - j is less than equal to n
62:47 - and we are simply doing j plus plus
62:49 - so here line number 4 will
62:51 - get executed 6 n plus 4
62:53 - unit of time
62:55 - but this for loop will also get executed
62:57 - multiple times based on the
62:59 - execution of outer for loop
63:01 - so if outer for loop runs n times
63:03 - the inner for loop will run
63:05 - n times of the
63:07 - outer for loop
63:09 - so which will give us
63:11 - 6 n square plus 4 n unit time
63:13 - of execution
63:15 - moving ahead at line number 4
63:17 - we are accessing i
63:19 - we are accessing j and we are printing
63:21 - so there are total 3 operations
63:23 - and how many time it will get executed
63:25 - you can see for value of n
63:27 - equals to 3
63:29 - it got executed
63:31 - 3 square times which is 9
63:33 - so here the total operations
63:35 - would be
63:37 - n square times 3
63:39 - which will give us 3 n square
63:41 - the line number 6
63:43 - which is end of inner loop will get exactly
63:45 - printed n times
63:47 - so here if n was 3
63:49 - it printed 3 times
63:51 - and for n time it will get printed
63:53 - n into 1 times
63:55 - which takes n unit of time
63:57 - and the line number 8
63:59 - will get executed exactly 1 time
64:03 - so if we add all the
64:05 - unit times we get
64:07 - the total time would be 6 n plus 4
64:09 - plus 6 n square plus 4 n
64:11 - plus 3 n square plus n
64:13 - plus 1
64:15 - and if we add the n square terms
64:17 - and n terms and then the
64:19 - constant it will become
64:21 - 9 n square plus 11 n
64:23 - plus 5
64:25 - so here as we assume that we take value of n
64:27 - to be very large we ignore
64:29 - the lower order terms
64:31 - and we also
64:33 - ignore the constant multipliers
64:35 - so we remove
64:37 - 9 also
64:39 - so if we want to represent the time complexity of this
64:41 - algorithm it would be
64:43 - O of n square
64:45 - because rate of increase of time
64:47 - is getting directly proportional to n square
64:49 - and if we plot the graph
64:51 - with time versus
64:53 - the input size it will
64:55 - give us
64:57 - a parabolic curve
64:59 - where execution time will increase
65:01 - by n square
65:03 - so here you can see that as volume of data will increase
65:05 - the execution time will increase
65:07 - n square times because
65:09 - time is directly proportional
65:11 - to n square
65:13 - so this is the graph for a polynomial algorithm
65:15 - so here you can see that
65:17 - this is a really bad algorithm
65:19 - because execution time is
65:21 - drastically increasing with the input size
65:23 - so usually we try
65:25 - to avoid the nested for loops
65:27 - because for each outer for loop
65:29 - inner for loop gets executed
65:31 - that many number of times
65:33 - so which you can see by the operation at line number
65:35 - 3
65:37 - so here you can see based on the condition provided here
65:39 - inner for loop gets
65:41 - executed n times the outer
65:43 - for loop
65:45 - and also friend similarly let's say if we had
65:47 - one more for loop inside
65:49 - the second for loop
65:51 - this would have gone to n cube times
65:53 - based on if the condition
65:55 - here provided are same
65:57 - so it would have taken O of n cube time
65:59 - so which is also a polynomial
66:01 - algorithm and which is also really
66:03 - bad so here in this
66:05 - video we discussed about
66:07 - how we can calculate the time complexity
66:09 - of a polynomial algorithm
66:11 - I hope you like
66:13 - this video thanks have a nice day
66:17 - hello everyone
66:19 - so in this section we will discuss
66:21 - about the array data structure
66:23 - we will see a basic
66:25 - introduction to array
66:27 - and then we will discuss that how we can
66:29 - create an array, initialize an array
66:31 - and assign some values to an array
66:37 - so friends what is an array
66:39 - so here let's take an example of
66:41 - a chocolate box
66:43 - so you must have seen a chocolate box
66:45 - having these chocolates separated by
66:47 - the partitions
66:49 - and the containers
66:51 - so when we actually see it for the first
66:53 - time we get few things
66:55 - in our mind
66:57 - the number one is we can tell that it's a collection of
66:59 - chocolates
67:01 - or a box of chocolates
67:06 - and all the partitions
67:08 - which are holding this chocolate
67:10 - you can see they are adjacent
67:12 - or we can say they are contiguous
67:14 - because they are very next to each other
67:19 - and here you can also see that each partition
67:21 - has two neighbors
67:23 - except the first and the last one
67:25 - for example the second partition
67:27 - has one neighbor to its left
67:29 - and one neighbor to its right
67:31 - but the first and the last one
67:33 - they have only one neighbor
67:35 - for the first
67:37 - it is the right
67:39 - and for the last it is the left
67:43 - and when we receive this pack of chocolates
67:45 - the size of this box
67:47 - is fixed
67:49 - and cannot be modified
67:51 - so any chocolate making company
67:53 - will first create this box
67:55 - and based on how many chocolates
67:57 - they want to add into this box
67:59 - they will create that many partitions
68:01 - and once this box is created
68:03 - it cannot be modified
68:07 - and also we saw that these partitions
68:09 - are very adjacent to each other
68:11 - so therefore they are also indexed
68:13 - and can be determined by its position
68:15 - so looking at the box
68:17 - we can simply number a position
68:19 - and simply can ask that okay I need
68:21 - four chocolate or four chocolate
68:23 - because we know that these chocolates
68:25 - are very adjacent and they are
68:27 - inherently indexed
68:29 - so friends similar analogy
68:31 - can be applied over an array
68:33 - so here you can see
68:35 - that this is an array
68:37 - having four elements
68:39 - so we can say
68:41 - it is a collection of data elements
68:43 - of a particular type
68:47 - and here you can see
68:49 - that all the partitions which are holding
68:51 - this data
68:53 - have contiguous memory locations
68:55 - so they are very next to each other
68:59 - we can also see that those partitions
69:01 - have two neighbors
69:03 - except the first and the last one
69:05 - and we can also
69:07 - deduce that once we create
69:09 - an array we need to provide
69:11 - a size so when we provide
69:13 - a size we are given with an array
69:15 - and once it is created we cannot modify
69:17 - it
69:19 - so if you want a dynamic array
69:21 - there is some complex logic behind it
69:23 - which we will discuss in our upcoming videos
69:25 - so for now you can have an
69:27 - understanding that an array
69:29 - can hold some data elements
69:31 - and the size
69:33 - to hold the data elements is fixed
69:35 - and we cannot modify it
69:39 - and here you can see that
69:41 - these partitions have
69:43 - contiguous memory locations
69:45 - therefore each partition
69:47 - comes with an index
69:49 - so for an array of
69:51 - 4 elements usually the index
69:53 - starts with 0
69:55 - and ends with number of
69:57 - elements inside this array
69:59 - minus 1
70:01 - so which is the length of the array
70:03 - minus 1
70:05 - so whenever we create an array
70:07 - basically we have an index
70:09 - associated with it
70:11 - which starts from 0
70:13 - dimensional array it ends with
70:15 - the complete length of this array
70:17 - minus 1
70:19 - so let's say length of array is 4 because we have
70:21 - 4 elements so the last index would be
70:23 - length minus 1 which is
70:25 - 4 minus 1, 3
70:27 - so from this was the basic introduction
70:29 - to an array data structure
70:31 - that how it holds the element
70:33 - and how they are very much next
70:35 - to each other and basically they are indexed
70:37 - so this indexing
70:39 - of array also help us in
70:41 - accessing the value inside
70:43 - that container
70:45 - so we can simply do array
70:47 - of 3 and we will get
70:49 - the value stored at the third
70:51 - index
70:53 - so this is also one of the advantage
70:55 - of having the index data
70:57 - structure so for
70:59 - in this video we saw a basic introduction
71:01 - to an array data structure
71:03 - in our upcoming videos we will see
71:05 - that how we can create an array
71:07 - initialize an array
71:09 - add values to an array
71:11 - I hope you like this video
71:13 - thanks have a nice day
71:15 - hello everyone
71:17 - so in our previous video we
71:19 - discussed about a basic
71:21 - introduction to an array
71:23 - data structure so in this
71:25 - video we will discuss that how we can
71:27 - perform declaration
71:29 - and initialization of an array
71:33 - so here when we say declaration of an array
71:35 - we will first
71:37 - discuss about the one dimensional array
71:41 - so the one dimensional array can be declared
71:43 - via syntax
71:45 - we can provide a data type
71:47 - then we can
71:49 - provide the variable name
71:51 - and then we simply
71:53 - provide the square brackets
71:55 - so that we can come to know that
71:57 - this is an array
71:59 - so this is the one way
72:01 - the other way is
72:03 - we can provide
72:05 - any data type
72:07 - and along with that we provide
72:09 - the square brackets and then comes our
72:11 - variable name
72:13 - so for example
72:15 - let's say if we want to
72:17 - declare an integer array
72:19 - so we can simply provide
72:21 - int
72:23 - and then we can provide our own
72:25 - customized variable name so here I have
72:27 - just given it as my array
72:29 - and then the square brackets
72:32 - and similarly we can do
72:34 - something like this
72:35 - that int
72:37 - square brackets and then we provide the variable name
72:39 - so here
72:41 - when we declare an array in Java
72:43 - we can use both these
72:45 - syntaxes
72:47 - the most preferred use syntax is
72:49 - the second one because
72:51 - we can simply deduce
72:53 - that this is an array of integer
72:55 - data type by just looking at
72:57 - the int and the square brackets
72:59 - so this is the mostly used
73:01 - syntax to declare an array
73:03 - moving ahead
73:07 - now let's see how we can initialize an array
73:11 - so by initialization we mean
73:13 - that when we initialize an array
73:15 - we are simply providing
73:17 - a memory to the array elements
73:19 - so that now array can store
73:21 - the collection of data into it
73:23 - so the
73:25 - syntax for the one dimensional array
73:27 - is something like
73:29 - once we declare an array
73:31 - what we saw in our previous slide
73:33 - in the next step we can do
73:35 - we can give the variable name
73:37 - and we can use the new
73:39 - operator
73:41 - to initialize an array
73:43 - and then we need to provide
73:45 - the data type
73:47 - along with a size
73:49 - so we also discussed that
73:51 - when we create an array
73:53 - we need to provide a size
73:55 - once the array is initialized
73:57 - we cannot modify the size
73:59 - so by this statement
74:01 - we are actually telling that provide as an array
74:03 - of this particular data type
74:05 - whose size is
74:07 - whatever the value you have provided here
74:09 - so once this line gets executed
74:11 - we are provided with an array
74:13 - of fixed size
74:15 - and certain memories
74:17 - associated with this data type
74:19 - so that now we can
74:21 - use this array and store our
74:23 - data elements
74:25 - so for example
74:27 - we can write something
74:29 - as we have declared my array
74:31 - in our previous slide we can say
74:33 - my array equal to new
74:35 - the data type
74:37 - and in the square bracket we can provide the size
74:39 - so this will
74:41 - initialize an array
74:43 - of size 5
74:45 - so we can add 5 elements inside this array
74:47 - and also
74:49 - friend usually we perform
74:51 - the declaration and initialization of an array
74:53 - in one go
74:55 - or in one step
74:57 - so the syntax for that is
74:59 - we can just combine the declaration
75:01 - and initialization
75:03 - in one step as
75:05 - we simply give the data type
75:07 - then square brackets
75:09 - then variable name
75:11 - equal to new
75:13 - data type
75:15 - for which we want to create an array
75:17 - and then the size
75:19 - the size
75:23 - and we can also use this syntax
75:25 - data type
75:27 - the variable name with the square brackets
75:29 - and then we can simply
75:31 - provide new data type and the
75:33 - size associated with it
75:37 - so for example
75:39 - we can simply create an integer array
75:41 - something like this
75:43 - so here using new operator
75:45 - this will create an integer array
75:47 - of size 5
75:49 - so that we can store
75:51 - 5 integers inside this array
75:53 - so this is the other
75:55 - syntax
75:57 - so the most preferred syntax is the first one
75:59 - so just by looking at the statement
76:01 - we can come to know that
76:03 - this is an integer array
76:05 - because usually the square brackets
76:07 - are alongside with the data type
76:09 - and also friend there is
76:11 - one more way to declare and
76:13 - initialize an array
76:15 - along with its data elements
76:17 - is we can write integer
76:19 - square brackets, variable name
76:21 - and we can simply say
76:23 - curly brackets and we can simply
76:25 - provide the actual data
76:27 - along with it
76:29 - so here you can see that if we know
76:31 - that what data we want to store
76:33 - inside is an array before and
76:35 - then we can simply use this syntax
76:37 - so it will directly
76:39 - initialize this array
76:41 - with proper values such as 5, 4, 3,
76:43 - 2, 6 at index 0,
76:45 - 1, 2,
76:47 - 3 and 4
76:49 - and here you can see
76:51 - it deduces the size
76:53 - by counting the number of elements we have provided
76:55 - inside this curly bracket
76:57 - so here as we have
76:59 - stored 5 elements
77:01 - this integer array will now have
77:03 - a size of 5
77:05 - so in this video we saw
77:07 - that how we can declare
77:09 - and initialize an array
77:11 - with various syntaxes
77:13 - in our upcoming video
77:15 - we will discuss
77:17 - that how we can add an element
77:19 - or update an element
77:21 - inside this array
77:23 - using the index position
77:25 - I hope you like this video
77:27 - thanks have a nice day
77:31 - hello everyone
77:33 - so in our previous video we discussed
77:35 - about how we can declare
77:37 - and initialize an array
77:39 - so in this video we will go a step ahead
77:41 - that after declaration
77:43 - and initialization of an array
77:45 - we will see how we can add
77:47 - or update
77:49 - the elements in an array
77:53 - so friends here you can see
77:55 - let's say we have this
77:57 - method as array demo
77:59 - having few statements
78:01 - so when we execute these statements in Java
78:03 - we will see what
78:05 - happens to this array data
78:07 - structure
78:09 - so when we call array demo method
78:11 - so here you can see
78:13 - at the first line what we are doing is
78:15 - we are declaring
78:17 - and initializing an array
78:19 - of integer type
78:21 - having a size of 5
78:23 - so when this
78:25 - line will get executed
78:27 - you will see
78:29 - that we have this
78:31 - variable name my array
78:33 - which is referencing
78:35 - an array of size 5
78:37 - so you can see 5
78:39 - partitions here
78:41 - and this array will also
78:43 - have a proper index
78:45 - starting from 0
78:47 - and ending at length
78:49 - minus 1
78:51 - which is 5 minus 1 which gives 4
78:53 - so here you can see
78:55 - this array object is created
78:57 - inside the heap memory
78:59 - and using my array
79:01 - we have this reference
79:03 - which is pointing
79:05 - to this object
79:07 - so you can consider this reference
79:09 - as a remote control
79:11 - where using my array
79:13 - we can simply control this
79:15 - array inside the memory
79:17 - so using this variable
79:19 - and the indexes we have
79:21 - we can simply store
79:23 - or update the element inside this array
79:25 - so how we can do that
79:27 - let's see its demonstration
79:29 - so let's say
79:31 - at the first position
79:33 - we want to store
79:35 - our integer having value as 5
79:37 - so how we can store that
79:39 - that we have this variable name
79:41 - and when we do
79:43 - square brackets
79:45 - and we provide this index
79:47 - so we are telling
79:49 - to this array via this remote control
79:51 - that please
79:53 - add 5
79:55 - to index 0
79:57 - so inside this partition here
79:59 - you will get a value as
80:01 - 5
80:03 - and also friend before that
80:05 - when we initialize or create an array
80:07 - using this new operator
80:09 - you can see that initial values
80:11 - of the integer came out to be 0
80:13 - so when we initialize an array
80:15 - this object doesn't know
80:17 - that what value
80:19 - this array could hold
80:21 - so it simply assigns
80:23 - the default value
80:25 - so for integer the default value is 0
80:28 - and similarly let's say for other types
80:30 - such as
80:32 - float double it would be 0.0
80:34 - for long it will be 0
80:36 - for boolean it will be false
80:38 - and for a proper object
80:40 - it will be a null value
80:42 - because those are the
80:44 - default values for primitive
80:46 - and non-primitive
80:48 - data types
80:50 - so here after giving the value
80:52 - 5 at index 0
80:55 - we can access
80:57 - the index 1 via this index
80:59 - and we can assign the value 1
81:01 - so it would look something like this
81:05 - that 1 is being stored here
81:07 - and similarly
81:09 - we can store it at index 2
81:14 - value 2 at index 3
81:20 - value 10 at index 4
81:24 - and now friends
81:26 - you can see that we have assigned
81:28 - all the values
81:30 - inside
81:32 - all the containers
81:34 - now let's say if we want to update any value
81:36 - so we can simply access
81:38 - it the normal way and assign a new value
81:40 - so here
81:42 - at this line
81:44 - we have added 8
81:46 - at index 2 here
81:48 - so if we again call this
81:50 - with a different value
81:52 - so 9 will
81:54 - over at this value
81:56 - and 8 will be gone
81:58 - and 9 will be at its place
82:00 - so this is just an update
82:02 - to an array
82:04 - and friends at the last step
82:06 - what we are doing is
82:08 - so here you can see that this integer array
82:10 - is of size 5
82:12 - and we know that index starts from 0
82:14 - so the last index would be
82:16 - 5-1
82:18 - which would be 4
82:20 - and now friends here
82:22 - what we are doing is let's say if we access
82:24 - my array and do something like this
82:26 - 5
82:28 - so here you can see the 5th index is not there
82:30 - and if we try to assign a value 7
82:32 - to it
82:34 - so once this line gets executed
82:36 - at runtime
82:38 - you will get this exception in java
82:40 - which says that array index out of bounds
82:42 - exception
82:44 - and it also gives a message saying
82:46 - index 5 out of bounds
82:48 - for length 5
82:50 - which means that
82:52 - the length of this array is 5
82:54 - which is the size
82:56 - and index 5 is
82:58 - basically out of bounds
83:00 - because in an array index starts from 0
83:02 - so the last index would be
83:04 - length-1
83:06 - which is 4
83:08 - so it simply says that index 5
83:10 - is out of bounds for length 5
83:12 - so this is the most common
83:14 - exception which we actually get
83:16 - when we try to work with an array data structure
83:18 - because sometimes it might happen
83:20 - that we
83:22 - wrongly access
83:24 - an index which is not present
83:26 - inside an array
83:28 - so friends this was all about adding or updating
83:30 - elements in an array
83:32 - now let's go to Eclipse and see
83:34 - the demonstration of this code
83:36 - I hope you liked this video
83:38 - thanks have a nice day
83:42 - hello everyone
83:44 - so in our previous video we discussed
83:46 - about how we can create
83:48 - initialize
83:50 - an array and we also discussed
83:52 - how we can add or update elements inside
83:54 - an array
83:56 - so in this video we will see
83:58 - the demonstration and working
84:00 - of the code which we discussed in our previous video
84:02 - so here we have this
84:04 - class array util
84:06 - and which has one utility method
84:08 - which prints the array
84:10 - on the console so this method
84:12 - we will be discussing in our upcoming
84:14 - videos in great detail
84:16 - so for timing just
84:18 - think that this will print the contents
84:20 - of an array
84:22 - so we have this method array demo
84:24 - so let's see the
84:26 - working of that code which we discussed in our previous
84:28 - video
84:30 - so at the first step what we did was
84:32 - we created an integer array
84:34 - we gave it a name as my array
84:36 - so
84:38 - we can provide any name
84:42 - and let's say we provide a size
84:44 - as 5
84:46 - so from here we can see that this
84:48 - will actually create an array
84:50 - which would be of integer
84:52 - type
84:54 - and the values this array will hold
84:56 - will be the default values
85:00 - and these default values
85:02 - will be decided based on the data type
85:04 - and here we can see
85:06 - let's say
85:08 - if we call
85:10 - array demo method
85:16 - so when this main method will run
85:18 - this line will get executed
85:20 - and this array will be
85:22 - created with default values
85:24 - so let's say if I call
85:26 - print array here
85:30 - and we pass
85:32 - my array to it
85:34 - so here
85:36 - this method will be called
85:38 - and the contents of this array will be printed
85:40 - so if I run the main
85:42 - method now
85:50 - so here you can see it printed
85:52 - 0 0 0 0
85:54 - so because we created an array
85:56 - of size 5
85:58 - 5 times 0 was printed because
86:00 - this integer has
86:02 - default value of 0
86:04 - so for each partition
86:06 - this array had
86:08 - it stored a value
86:10 - 0 into it
86:14 - so friends in our previous video
86:16 - we also discussed that
86:18 - we have this my array
86:20 - which will be acting as our remote control
86:22 - to modify the array
86:24 - object inside the memory
86:26 - so what we can do is
86:30 - let's say we want to add
86:32 - a value of 5
86:36 - at index 0
86:38 - so this would be the syntax
86:40 - and similarly
86:42 - let's say I fill all the values
86:46 - for each and every index
86:48 - say 0
86:50 - 1 2
86:52 - 3 and 4
86:56 - and let's say I give a different value
86:58 - 5 1 8
87:00 - 2
87:02 - and 10
87:04 - and if I call
87:06 - the print array
87:08 - method here
87:10 - after assigning this few values
87:12 - and if I run the code now
87:18 - you can see all the default values
87:20 - which were getting printed as 0 0
87:22 - 0 0 0 have been
87:24 - updated by
87:26 - 5 1 8 2 10
87:29 - and let's say after assigning a value 8
87:31 - at index 2
87:33 - which is here
87:35 - what we can do is
87:37 - let's say I want to update this
87:42 - and I want to update it by 9
87:45 - so I can do simply like this
87:47 - and if I run the code now again
87:51 - so you can see
87:53 - that only at index 2
87:55 - the value was updated from 8
87:57 - to 9
87:59 - and also friend
88:01 - let's say
88:03 - if we try to access an index
88:05 - which is not in range
88:07 - of this size
88:11 - so let's say if we try to
88:13 - access an index which is not present
88:15 - inside the array
88:17 - let's say 5
88:19 - and if we give a value
88:21 - let's say 26
88:23 - and if I run the code now
88:28 - so friend here you can see
88:30 - that we got an exception saying
88:33 - array index out of bounds exception
88:35 - giving an index 5
88:37 - saying that 5 is
88:39 - out of bounds
88:41 - for this array
88:43 - so here if you see
88:45 - when we do my array
88:47 - so the index starts from 0
88:50 - and ends
88:52 - at size minus 1
88:54 - which is 4
88:56 - so here you can see
88:58 - that this array
89:00 - will go from 0
89:02 - 1, 2, 3, 4
89:04 - so these are the indexes
89:06 - which we are using it here
89:08 - to access a particular container
89:10 - so that we can store these values
89:14 - so this array data structure inherently has this
89:16 - one variable by name
89:18 - length
89:22 - so if you want to know
89:24 - what is the length of any particular array
89:26 - we can simply use
89:28 - this value
89:30 - my array.length
89:32 - so let's say if I print this
89:34 - on the console
89:42 - and if I run the code now
89:46 - so here you can see it printed
89:48 - the length of this array as 5
89:50 - because we have created
89:52 - the integer array of length 5
89:54 - so usually when we get
89:56 - an array and if we want to just know
89:58 - what is the length of that array we can simply use
90:00 - this variable
90:02 - we can give
90:04 - the variable name.length
90:06 - and we will get the length of that array
90:08 - and similarly
90:10 - let's say if we want to access the last
90:12 - element of an array
90:14 - so what we can do is
90:18 - we can simply say
90:20 - my array
90:28 - and here you can see the last index is actually
90:30 - length minus 1
90:32 - which is 4
90:34 - so here we need to give the value as
90:36 - my array
90:38 - dot length
90:40 - minus 1
90:44 - so here my array.length
90:46 - will give value as 5
90:49 - and when we do minus 1
90:51 - we can get the last index
90:53 - of this array
90:55 - and in order to access that element
90:57 - we need to provide the name of the array
90:59 - and then square brackets
91:01 - and inside the square brackets
91:03 - we can provide the actual index
91:05 - for which we want to access
91:07 - a particular value
91:09 - so if I run the code now
91:13 - you can see
91:15 - that it printed 10
91:17 - because 10 is the
91:19 - value hold by the
91:21 - last index
91:23 - of this array
91:25 - and also similar to this
91:27 - what we can do is
91:29 - we can also create an array
91:31 - something like
91:37 - like this
91:39 - where we actually know what this array
91:41 - could hold
91:43 - so we can simply give the values as 5
91:45 - 10
91:47 - 8 and let's say 10
91:49 - so this array will hold
91:51 - these values
91:53 - at the respective index starting from
91:55 - 0 1 2
91:57 - 3
91:59 - so the length of this array is 4
92:01 - and the index goes from
92:03 - 0 to 3
92:05 - so if I print
92:07 - this array now
92:11 - and if I run the code
92:16 - you can see it printed 5 1 8 10
92:19 - which are the elements present
92:21 - inside this array
92:23 - so friend in this video we saw
92:25 - few operations related to an array
92:27 - but how we can create an array
92:29 - and how we can add
92:31 - or update values inside this array
92:33 - I hope you like this video
92:35 - thanks have a nice day
92:37 - hello everyone
92:39 - so friend in this
92:41 - lecture we will discuss
92:43 - how to print elements of an array
92:45 - in java
92:47 - so here most of you know
92:49 - how to print elements of an array in java
92:51 - the only reason we are discussing
92:53 - this algorithm here is because
92:55 - in our upcoming lectures
92:57 - this algorithm will be mostly used
92:59 - so let's see the demonstration
93:01 - of algorithm
93:03 - by an animation
93:05 - so friends here you can see
93:07 - that we have this
93:09 - public method by name
93:11 - print array
93:13 - which takes in an array
93:15 - and to this array will iterate its
93:17 - element one by one
93:19 - using the for loop
93:21 - and will print its content
93:23 - on the console
93:25 - so let's see the demonstration
93:27 - of this algorithm
93:29 - so let's suppose we call
93:31 - the print array method
93:33 - by passing in an array
93:35 - so let's say we pass
93:37 - this array
93:39 - having 5 elements as 5
93:41 - 1 9 2 and 10
93:43 - moving ahead
93:45 - so in the first
93:47 - step what we do is
93:49 - we take out the length of an array
93:51 - and store it in an integer variable
93:53 - n
93:55 - so here if you see
93:57 - as the array holds 5 elements
94:00 - so when we will do array.length
94:02 - the value 5 will be stored in n
94:04 - so it would look something like this
94:07 - the value of n is 5
94:09 - moving ahead
94:13 - now friends in order to print
94:15 - each and every element of an array
94:17 - we need to iterate this array
94:19 - from the first index
94:21 - to the last index
94:23 - and as we know that
94:25 - the index of array starts from 0
94:28 - so the value of i will be 0
94:31 - because this is our starting point
94:33 - and we will iterate
94:35 - in a for loop
94:37 - till i is less than n
94:39 - so here if you see
94:41 - i will start from 0
94:43 - and it should go to 4
94:45 - so we want this loop to go
94:47 - from i0 to i4
94:49 - so therefore we have provided this condition
94:51 - that i
94:53 - should be less than n
94:55 - it means for the last index
94:57 - 4 should be less than 5
94:59 - because when i will be equal to 5
95:01 - then we know that i
95:03 - has crossed the boundaries of this array
95:05 - therefore we will get an exception
95:07 - so we will iterate till i is less than n
95:11 - so here
95:13 - we will start with i equal to 0
95:17 - so if we see in this array
95:19 - then i is pointing to the zeroth index
95:21 - moving ahead
95:26 - now in order to print the elements
95:28 - on the console
95:29 - we are doing system.out.print
95:31 - and in order to access
95:33 - the value
95:35 - at this particular index
95:37 - we do array
95:39 - then we provide this
95:41 - square brackets and inside that we provide
95:43 - the index for which we want
95:45 - the value
95:47 - so on the console it will print
95:51 - 5
95:52 - because i is pointing to the zeroth index
95:54 - and array of 0
95:56 - will give value as 5
95:58 - moving ahead
96:02 - now we will increment i by 1
96:04 - so i becomes 1
96:06 - and now i will point
96:08 - to the index 1
96:12 - and here we will check whether
96:14 - 1 is less than 5 or not
96:16 - so this boolean condition
96:18 - comes out to be true
96:20 - so the for loop executes
96:25 - and then we will simply print
96:27 - the value at first index
96:29 - which is 1
96:31 - so it would look something like this
96:34 - moving ahead
96:38 - we will now increment the value of i by 1
96:40 - so i will become 2
96:44 - and it will point to the second index
96:46 - we will simply print the value
96:48 - at the second index which is 9
96:50 - so it would look something like this
96:54 - moving ahead
96:58 - we will again increment the value of i by 1
97:00 - so i will become 3
97:04 - and it will point to the third index
97:12 - we will print the value
97:15 - we will print the value
97:17 - at the third index which is 2
97:19 - so it would look something like this
97:25 - moving ahead
97:28 - we will again increment the value of i by 1
97:31 - so i becomes 4
97:35 - and it will point to the fourth index now
97:40 - and we know that 4 is less than 5
97:43 - therefore the condition in for loop
97:45 - comes out to be true
97:50 - and then we will print the value
97:52 - as index 4 which is 10
97:54 - so it would look something like this
97:59 - now we will increment i by 1
98:02 - so i will become 5
98:06 - so friends here we can see
98:08 - that 5 is not less than 5
98:11 - therefore the condition in for loop
98:13 - comes out to be false
98:15 - and as we have iterated each and every element
98:17 - and printed it on the console
98:20 - we will simply exit this for loop
98:26 - and at the last step we will simply do a print line
98:30 - so which will bring the cursor
98:32 - to print stuffs on the console
98:34 - to the next line
98:36 - so friends this was a demonstration
98:39 - that how we can print the elements of an array
98:41 - in java
98:43 - so here
98:45 - we iterated each and every element
98:47 - using for loop
98:49 - from the start index to end index
98:51 - and we printed
98:53 - the contents of array
98:55 - on the console
98:57 - so now let's go to eclipse
98:59 - and see the demonstration
99:01 - of this code
99:04 - I hope you like this video
99:06 - thanks have a nice day
99:12 - hello everyone
99:14 - so friends in our last lecture we saw
99:16 - that how we can print the elements of an array
99:18 - in java
99:19 - and we saw the animation
99:21 - of the algorithm
99:23 - now in this lecture we will code the algorithm
99:25 - and we will see
99:27 - it's working through main method
99:31 - so here
99:32 - I will be creating one method as public
99:35 - void
99:36 - and will give the name to it as print array
99:45 - so this method will take in an array
99:49 - let's have integer type
99:52 - so now our task is to
99:54 - print elements inside this array
99:56 - on the console
99:58 - so what we do is
100:00 - we simply iterate each and every element
100:03 - of this array
100:05 - and print it's content on the console
100:08 - so in the first step what we do is
100:13 - we simply take
100:15 - the length of the array
100:18 - and store it in an integer variable n
100:21 - so why we do this because
100:23 - in order to iterate this array
100:25 - we will provide a for loop
100:27 - and we know that array
100:29 - starts from the zeroth index
100:32 - so we want to know that what the size
100:34 - or the length of the array
100:36 - so that when we are using the for loop
100:38 - to iterate this array
100:40 - we can give a range
100:42 - that iterates the for loop from start
100:44 - to end
100:46 - so the value of n is nothing but our end point
100:51 - so then we will provide a for loop
100:57 - and inside it for loop
100:59 - we will start our iteration from
101:01 - index 0
101:03 - because in an array
101:05 - the storage of elements starts from
101:07 - zeroth index
101:10 - and we will traverse till i
101:12 - is less than n
101:16 - so let's say array is n elements
101:18 - so it will be distributed
101:20 - from the range of 0 to n-1
101:23 - so therefore we need to
101:25 - traverse from 0 to n-1
101:28 - so therefore we are providing this condition
101:30 - that i should be less than n
101:32 - and then we will simply do i++
101:34 - each time
101:38 - in order to print the elements of an array on console
101:41 - we simply provide the system
101:44 - .out
101:47 - .print
101:52 - and inside this print method
101:54 - we will simply take out the value
101:57 - stored at the ith index
102:02 - and print it on the console
102:05 - so i will traverse from 0 to n-1
102:08 - so when it will start from zeroth index
102:10 - it will print
102:12 - the value stored at zeroth index
102:14 - then we will do i++
102:16 - then it will print
102:18 - the value at first index
102:20 - and similarly
102:22 - at the last it will print
102:25 - the value stored at n-1th index
102:30 - and after forlow we will simply provide
102:32 - the print line
102:38 - so this is the code
102:40 - to print the elements of an array
102:42 - on console
102:45 - so here now let's see the working of this code
102:48 - through main method
102:50 - so first we will create the instance of arrayutil class
102:54 - so
103:06 - now we will call the print array method
103:08 - by passing in an array
103:14 - so here we will call print array
103:18 - and we will simply pass an array
103:25 - so let's say we provide 5 elements
103:29 - whose value would be 5
103:31 - 1
103:33 - 2
103:35 - 9
103:37 - let's say 10
103:40 - so friends here we have created a new array
103:44 - and using these curly brackets
103:46 - we have provided that this array should have 5 elements
103:49 - and we are directly passing this array
103:51 - to this print array method
103:55 - so now let's run this code
104:03 - so here you can see
104:05 - that it printed 5
104:07 - 1
104:08 - 2
104:09 - 9 10
104:10 - by iterating over the array
104:12 - one by one
104:13 - using this for loop
104:16 - so friends in this lecture we saw the working of this algorithm
104:19 - that how we can print the array
104:21 - elements on the console
104:25 - I hope you like this video
104:27 - thanks have a nice day
104:31 - hello everyone
104:32 - so in this video we are going to discuss
104:34 - that how we can remove even integers
104:37 - from an array
104:40 - now let's suppose we are given an array of integers
104:43 - we need to return an array
104:45 - with even integers being removed
104:48 - so for example let's say we are given
104:50 - the array such as 3
104:52 - 2
104:53 - 7
104:54 - 10
104:55 - 6 5
104:57 - so here 2 is
104:59 - even integer
105:00 - 4 is even integer
105:02 - 10 and 6 are even integers
105:05 - now we need to remove those
105:07 - even integers and only return
105:09 - the odd numbers
105:11 - which is 3, 7 and 5
105:14 - so let's see the demonstration of this algorithm step by step
105:18 - so friends before we start
105:20 - in case if you are new to my channel
105:22 - then please subscribe to my channel
105:24 - and click the bell icon so that you never miss any update
105:28 - so here is the algorithm
105:30 - which will help us removing the
105:32 - even integers from an array
105:34 - so the method name is remove even
105:36 - it takes in an array and returns
105:38 - an array
105:40 - in which the even integers are removed
105:44 - so let's say we take the example of
105:46 - the array having
105:48 - 7 elements
105:49 - 3
105:50 - 2
105:51 - 3
105:52 - 7
105:53 - 10
105:54 - 6
105:55 - 5
105:56 - and let's say when we call remove even
105:58 - method by passing in the array
106:00 - this method actually starts its execution
106:04 - now how we can remove the even integers from the arrays
106:06 - first we actually count
106:08 - the number of odd integers
106:10 - in the array
106:11 - and why we count the number of
106:13 - odd integers is because
106:15 - we need to return an array
106:17 - having only odd integers
106:19 - by removing the even integers from
106:21 - the given array
106:23 - so at the start odd count is 0
106:29 - now we provide a for loop
106:31 - and we traverse the array elements 1 by 1
106:34 - so starting from i equal to 0
106:37 - which is 0 index
106:39 - we go till i should be less than array.length
106:42 - so array.length is 7
106:44 - because there are 7 elements
106:47 - and less than 7 means up till 6
106:50 - so at the start i is actually less than array.length
106:56 - so friends how we can find the odd integers
106:58 - inside these arrays
107:00 - we can take the value
107:02 - at any particular index
107:04 - if we divide it by 2
107:06 - and if the remainder is not equal to 0
107:08 - it means it's an odd element
107:10 - so friends we know that even integers are
107:12 - 2
107:13 - 4
107:14 - 6
107:15 - where if we divide the element by 2
107:17 - let's say 2 divided by 2
107:19 - so we get the remainder
107:21 - as 0
107:23 - so the even integers
107:25 - when divided by 2
107:26 - give remainder as 0
107:28 - and if we take the odd integers
107:30 - 1 3 5
107:31 - if we divide 3 by 2
107:33 - we get remainder as 1
107:35 - if we divide 5 by 2
107:37 - we get remainder as 1
107:39 - so if the remainder is not equal to 0
107:41 - it means it's an odd integer
107:45 - so we will take the help of this modulus operator
107:47 - which will directly provide us the remainder
107:49 - and if it is not equal to 0
107:51 - we will increment the odd count
107:53 - so at the start
107:55 - we get 3
107:57 - 3 divided by 2
107:59 - will give remainder as
108:01 - 1
108:03 - 1 is not equal to 0
108:05 - so therefore this condition comes out to be true
108:07 - and if the remainder is not equal to 0
108:09 - we get remainder as 1
108:11 - 1 is not equal to 0
108:13 - so this condition comes out to be true
108:15 - we will increment odd count
108:17 - because 3 is an odd integer
108:19 - so here it becomes 1
108:27 - we will increment i
108:29 - now
108:31 - array of i which is 2
108:33 - 2 divided by 2
108:35 - will give remainder as 0
108:37 - so therefore this condition comes out to be false
108:39 - so this statement is skipped
108:43 - and we reach here again
108:45 - so we do i plus plus
108:47 - i becomes 2
108:49 - now 4
108:51 - divided by 2
108:53 - will give remainder as 0
108:55 - because 4 is divisible by 2
108:57 - so this condition
108:59 - comes out to be false
109:01 - we will increment i again
109:03 - i becomes 3
109:05 - so this condition comes out to be true
109:07 - now 7
109:09 - divided by 2
109:11 - will give remainder as 1
109:13 - and 1 is not equal to 0
109:15 - therefore this condition comes out to be true
109:17 - we will increment
109:19 - odd count
109:21 - because 7 is an odd integer
109:27 - we will increment i
109:29 - 10 divided by 2
109:31 - will give remainder as 0
109:33 - so this condition comes out to be false
109:35 - we will again increment i
109:41 - now 6
109:43 - which is the array of i
109:45 - divided by 2
109:47 - will give remainder as 0
109:49 - so this condition comes out to be false
109:53 - we will again increment i
109:55 - now 6 is equal to 6
109:57 - and it is less than array dot length
109:59 - because array dot length is 7
110:01 - so this for loop will run
110:03 - so this for loop will run
110:05 - one more time
110:07 - we will take 5
110:09 - 5 divided by 2
110:11 - will give remainder as 1
110:13 - 1 is not equal to 0
110:15 - so therefore this condition comes out to be true
110:19 - we will increment
110:21 - odd count
110:23 - it becomes 3
110:27 - now when we will increment i
110:29 - it will become 7
110:31 - and 7 is not less than 7
110:33 - so this condition comes out to be false
110:37 - and for loop will terminate
110:39 - so here you can see
110:41 - that when we traverse each and every element
110:43 - in the array
110:45 - we figured out that 3
110:47 - 7
110:49 - and 5 are 3 elements
110:51 - which are odd
110:53 - and we need to return these 3 elements
110:55 - by removing the
110:57 - even integers from the array
111:00 - so therefore the array which we want to return
111:02 - will have only 3 elements
111:04 - which will be the odd integers
111:06 - so we will create the result array
111:08 - we pass in the odd count
111:10 - because we have calculated the odd count
111:12 - through this for loop
111:15 - so the result array will have only 3 elements
111:21 - now here we will create one index
111:23 - starting from 0
111:25 - so this index will help us filling the result array
111:29 - so it will simply traverse
111:31 - the result array
111:34 - now here we will again provide a for loop
111:36 - which will iterate the array
111:38 - like we did here
111:40 - from i equal to 0
111:42 - to i less than array.length
111:46 - so i starts from 0
111:48 - now why again we are iterating the array
111:50 - and here providing the same condition
111:53 - to find out the odd integer
111:55 - is because once we find out the odd integers
111:58 - we will simply assign that value
112:00 - to the result array
112:02 - at a particular index
112:04 - so at the start 3 divided by 2
112:07 - will give us a remainder as 1
112:09 - so 1 is not equal to 0
112:11 - so therefore this condition comes out to be true
112:15 - so it means we have found
112:17 - one odd integer
112:19 - so we will assign the value in the array
112:21 - at the ith index which is the zeroth index
112:23 - which is 3
112:25 - to the result array
112:27 - at the index 0
112:29 - so 3 will come here
112:31 - with this assignment
112:35 - now after we have assigned one value
112:37 - to this index
112:39 - we will increment the index
112:41 - because we need to fill the next value
112:44 - so index becomes 1
112:48 - we will increment i
112:53 - 2 divided by 2
112:55 - will give remainder as 0
112:57 - therefore this condition comes out to be false
112:59 - and we skip this element
113:03 - we will again increment i
113:05 - i becomes 2
113:08 - so value at second index is 4
113:13 - 4 divided by 2 will give remainder as 0
113:16 - so this condition comes out to be false
113:20 - we will again increment i
113:22 - i becomes 3
113:26 - now the value at third index
113:28 - which is 7
113:30 - 7 divided by 2 will give remainder as 1
113:33 - 1 is not equal to 0
113:35 - therefore this condition comes out to be true
113:40 - it means we have found our second odd integer
113:42 - which is 7
113:44 - so we will assign the value 7
113:46 - to the result array
113:48 - as index 1
113:50 - so 7 comes here
113:53 - we will increment the index
113:59 - we will increment i
114:04 - 10 divided by 2 will give remainder as 0
114:07 - so this condition comes out to be false
114:12 - so friends here you can see
114:14 - that whenever we are encountering a even integer
114:16 - we are simply skipping that value
114:19 - and we are traversing ahead
114:22 - so when we increment i
114:24 - i becomes 5
114:28 - 6 divided by 2 will give remainder as 0
114:32 - so this condition comes out to be false
114:36 - we will increment i
114:42 - 5 divided by 2 will give remainder as 1
114:45 - so this condition comes out to be true
114:47 - because 1 is not equal to 0
114:50 - it means we have found our third odd integer
114:54 - so we will assign 5
114:56 - to the result
114:58 - at this particular index
115:00 - which is second index
115:02 - so 5 comes here
115:05 - and we will increment index
115:07 - so as we have filled all the values
115:14 - we will again increment i
115:16 - so when we will increment i
115:18 - 7 which will be going out of the
115:20 - boundaries of this array
115:22 - so this condition comes out to be false
115:24 - because 7 is not less than 7
115:28 - so this for loop will terminate
115:33 - and at the end we will simply return the result
115:37 - so here you can see that we have
115:39 - removed the even integers from the array
115:41 - and we are returning a new array
115:43 - having only odd integers
115:46 - so when this was all about this algorithm
115:49 - the main idea behind this algorithm is
115:51 - to figure out the odd integers
115:53 - so we can take the number
115:56 - and when we will divide it by 2
115:58 - if the remainder comes out to be
116:00 - 1
116:02 - it means it's an odd integer
116:05 - and if it comes out to be 0
116:07 - it means it's an even integer
116:09 - so why we calculate the odd count
116:11 - at the start because we need to find
116:13 - the length of
116:15 - the new result array
116:17 - so that we can create this new array
116:19 - of 3 values
116:21 - because the odd count is 3
116:23 - and then we can perform the same steps again
116:25 - we will figure out the
116:27 - odd integer
116:29 - and we will simply assign that odd integer
116:31 - to the respective indexes
116:33 - 1 by 1
116:35 - and at the end we will simply return the result
116:37 - so friends i hope you
116:39 - must have liked this video
116:41 - in case if you are new to my channel
116:43 - then please subscribe to my channel
116:45 - and click the bell icon so that you
116:47 - never miss any update
116:48 - thanks have a nice day
116:51 - hello everyone
116:52 - so in our previous video
116:54 - we saw an animation
116:55 - in which we discussed an algorithm
116:57 - that how we can remove the even integers
116:59 - from an array
117:00 - so in the problem statement
117:02 - we were given with an array of integers
117:04 - and our task was to remove
117:06 - the even integers from the array
117:08 - so in that video we saw the animation
117:10 - of the algorithm
117:11 - and in this video we will actually code the algorithm
117:13 - and we will test its working in the main method
117:16 - so friends before we start
117:18 - in case if you are new to my channel
117:20 - then please subscribe to my channel
117:22 - and click the bell icon so that you never miss any update
117:27 - so here in our previous videos we have discussed
117:29 - how we can print an array
117:31 - and in this video lets say
117:33 - if we are given with this array of integers
117:35 - and we want to remove the even integers
117:37 - from the array
117:38 - so the output would be
117:40 - 2, 4, 10 and 6 will be removed
117:43 - so it will give us
117:45 - 3, 7 and 5
117:48 - so here you can see
117:50 - 2 is even integer, 4 is even integer
117:52 - and 10 and 6 are even integers
117:54 - so we need to remove those elements
117:56 - and return an array
117:58 - having only odd integers
118:00 - so now lets code the algorithm
118:02 - which we also saw in our previous video
118:04 - lets say I provide the method name as
118:08 - remove even
118:18 - so this method will take
118:20 - an array of integers
118:25 - and it will return back an array of integers
118:27 - in which the even integers will be removed
118:30 - so here the basic idea we do is
118:32 - first we count
118:34 - the number of odd integers in the array
118:36 - so for that
118:38 - we create an integer variable
118:40 - oddCount
118:44 - and then we simply traverse the array
118:46 - using a for loop
118:56 - so while we are evaluating oddCount
118:58 - we will see later
119:00 - so here how we can figure out whether an element
119:02 - is an odd integer or an even integer
119:04 - we simply take that element
119:06 - we divide that element by 2
119:08 - and if the remainder is 0
119:10 - it means its an even integer
119:12 - and if the remainder is not equal to 0
119:14 - it means its an odd integer
119:16 - so here if
119:20 - array of i
119:22 - if we do mod 2
119:27 - and it is not equal to 0
119:29 - it means its an odd integer
119:31 - so 3 divided by 2
119:33 - will give remainder as 1
119:35 - so 1 is not equal to 0
119:37 - it means its an odd integer
119:39 - so this modulus operator
119:41 - is helpful in determining the remainder
119:43 - so if remainder is not equal to 0
119:45 - it means its an odd integer
119:47 - so we will simply increment
119:49 - oddCount
119:51 - and if it is an even integer
119:53 - then we simply skip
119:55 - so after knowing the number of odd elements
119:57 - what we do is, as we need to return
119:59 - an array of integers having only
120:01 - odd integers
120:05 - we will create a result array
120:11 - of size oddCount
120:13 - because we need to return these 3 elements
120:15 - so this oddCount
120:17 - after traversing each and every element
120:19 - will have value 3
120:21 - because there are 3 odd elements
120:23 - 3, 7 and 5
120:25 - so we need to return this array
120:27 - having 3 elements so we will create
120:29 - this result array of 3 elements
120:31 - so this is the reason we are
120:33 - evaluating oddCount here
120:37 - now after creating the result array
120:39 - we need to fill this result array
120:41 - with the respective odd elements
120:43 - so first we will create an index variable
120:47 - starting from 0
120:49 - and then we will again iterate the array
120:59 - and we provide the same condition what we have done here
121:09 - so here if
121:15 - element at ith index
121:17 - mod 2
121:19 - if it is not equal to 0
121:21 - it means its an odd integer
121:23 - so we need to put this integer
121:25 - into the result array
121:27 - so in order to put
121:29 - the element into result array
121:31 - we need to find the index
121:33 - that where we need to put
121:35 - in the result array
121:37 - so for that we have created this index
121:39 - variable
121:41 - so this index variable
121:43 - starts from 0
121:45 - so lets say if we encounter 3
121:47 - so we need to put 3 at the 0
121:49 - if we have encountered 7
121:51 - then we have to put in the next index
121:53 - and if we have encountered 5
121:55 - then we have to put in the next index
121:57 - so we will use this index variable
121:59 - to keep the track of these positions
122:07 - and after placing the odd integer
122:09 - at a proper index
122:11 - we have to increment the index as well
122:13 - because after putting 3
122:15 - lets say at 0th index
122:17 - 7 will cover index 1
122:19 - so we need to increment index as well
122:25 - and that will simply return the result
122:31 - so here you can see if the element
122:33 - at the height index is even
122:35 - we are doing nothing we are simply
122:37 - skipping it and if it is an odd integer
122:39 - then we are taking that integer
122:41 - placing into the result array
122:43 - at a proper index and then
122:45 - we are incrementing the index as well
122:47 - so now lets test its working in the main
122:49 - method
122:51 - so first we will print the original array
122:55 - if i run the code now
123:01 - you can see it has printed
123:03 - the original array
123:07 - now we will call remove even method
123:09 - we will pass the original array
123:13 - and it will return back a result array
123:17 - now this result array will have
123:19 - only odd integers
123:21 - so if i print it again
123:26 - if i run the code now
123:30 - so here you can see it printed
123:32 - 375
123:33 - it has removed the even integers
123:35 - 2, 4, 10 and 6
123:40 - so friend this was all about the implementation
123:42 - of this algorithm
123:44 - i hope you must have liked this video
123:46 - in case if you are new to my channel
123:48 - then please subscribe to my channel
123:50 - and click the bell icon so that you never
123:52 - miss any update
123:53 - hello friends
123:57 - welcome to my new data structures
123:59 - and algorithms in java tutorial
124:01 - series video
124:03 - friends in this tutorial we will discuss
124:05 - how to reverse an array in java
124:09 - so friends lets suppose we are given
124:11 - an array and our task
124:13 - is to reverse the array
124:15 - so for example
124:17 - lets suppose we are given an array of
124:19 - integers having values as 2
124:21 - 11
124:22 - 5
124:23 - 10
124:24 - 7
124:25 - and 8
124:26 - so when we will reverse this array of
124:27 - integers it would become
124:29 - 8
124:30 - 7
124:31 - 10
124:32 - 5
124:33 - 11
124:34 - 2
124:35 - which you can see below
124:36 - so friends lets suppose we are given
124:38 - a numbers array
124:39 - whose length is 6
124:41 - that is having index from 0
124:43 - to 5
124:44 - and we want to reverse this array
124:46 - so here is an algorithm
124:48 - to reverse an array
124:50 - so lets see the demonstration of this
124:52 - algorithm step by step
124:54 - so in order to call
124:56 - the reverse array method
124:58 - we pass in the numbers array
125:00 - which we actually want to reverse
125:02 - we also provide a range
125:04 - in which we want to reverse the array
125:06 - so here as we want to reverse
125:08 - this complete array
125:10 - we give the start position at 0
125:12 - and the end position
125:14 - numbers dot length minus 1
125:16 - so here you can see the length of the array 6
125:19 - and minus 1 becomes 5
125:21 - so the end index is 5
125:23 - because we want to reverse this complete array
125:28 - so when we call this method
125:30 - by passing in the numbers array
125:32 - which we want to reverse
125:34 - the value of start is 0
125:36 - and the value of end is 5
125:40 - so friends start and end is nothing but the range
125:43 - between which we want to reverse an array
125:45 - so the idea behind this algorithm is
125:48 - we usually take two pointers
125:50 - one is the start pointer
125:52 - and one is the end pointer
125:54 - so here you can see
125:56 - currently the value of start is 0
125:58 - so we simply refer
126:00 - to the index 0
126:02 - and the value of end is 5
126:04 - so we simply refer to the value at index 5
126:07 - so the values which start and end hold
126:09 - are nothing but the indices of the array
126:11 - which is nothing but the range
126:13 - so here we actually want to reverse this array
126:16 - from the start position to end position
126:20 - so let's see it's working
126:22 - so in the first step what we do is
126:24 - we actually provide a while loop
126:26 - and the condition we provide in the while loop is
126:29 - we check whether start is less than end or not
126:32 - so here value of start is 0
126:34 - and value of end is 5
126:36 - so here in the condition in while block comes out to be true
126:42 - so friends what we actually do
126:44 - is we simply swap the value at start index
126:46 - with the value at end index
126:48 - because we want to reverse this array
126:52 - so we actually reverse this array
126:54 - by making swap pairwise
126:56 - between start and end index
126:59 - so here in order to swap these two values
127:01 - first we will create a temporary variable
127:03 - to store the value
127:05 - at the start index
127:07 - so it would look something like this
127:11 - so the value at start index is nothing but 2
127:13 - so we are storing it in temporary variable
127:16 - moving ahead
127:20 - now as we have stored this value in the temporary variable
127:23 - we can simply assign the value
127:25 - at end index
127:27 - to the start index
127:29 - so it would look something like this
127:33 - so now value at index 0
127:35 - is 8
127:36 - moving ahead
127:39 - and now we will simply assign the value
127:41 - stored in temporary variable
127:43 - to the end index
127:45 - so it would look something like this
127:48 - so the value in the array at the end index
127:50 - now becomes 2
127:52 - moving ahead
127:55 - so friends here we have swapped these two values
127:57 - which are being referred by the start position
127:59 - and the end position
128:01 - so after we have swapped these two values
128:03 - now we simply increment the start by 1
128:07 - and we decrement the end by 1
128:10 - so here we are incrementing the start by 1
128:13 - so as start is holding the value of 0
128:15 - it becomes 1
128:18 - so now it will refer
128:20 - to the index 1
128:24 - moving ahead
128:27 - and then we will decrement the end by 1
128:29 - so as end is having value of 5
128:31 - now it becomes 4
128:34 - and now it will point
128:36 - to the 4th index
128:40 - in the while loop we will again check
128:42 - whether start is less than end or not
128:44 - so here you can see value of start is 1
128:47 - and value of end is 4
128:48 - so therefore the condition in while block
128:50 - comes out to be true
128:54 - and now we will simply swap these two values
128:57 - which are being referred by start position
128:59 - and end position
129:01 - so first we will store the value of array at start index
129:04 - into the temporary variable
129:07 - so now time becomes 11
129:12 - and then we will simply assign the value
129:14 - stored in array at index 4
129:16 - to index 1
129:18 - so it would look something like this
129:21 - that the value in array at start index
129:23 - now becomes 7
129:26 - moving ahead
129:29 - and now we will simply assign the value
129:31 - in temporary variable
129:33 - to the end index of the numbers array
129:35 - so it would become something like this
129:38 - that the value in numbers array at the end index
129:40 - becomes 11
129:42 - moving ahead
129:44 - now as we have swapped these two values
129:46 - we will simply increment the start by 1
129:49 - so the value of start is 1
129:52 - now it becomes 2
129:55 - and now simply start will point
129:57 - to the index 2
130:00 - moving ahead
130:03 - and will simply decrement the end by 1
130:06 - so currently the value of end is 4
130:08 - so it will become 3
130:12 - and now end will point
130:14 - to the index 3
130:16 - moving ahead
130:18 - now again condition in while block
130:20 - comes out to be true because
130:22 - 2 is less than 3
130:27 - so now we will swap these two values
130:30 - so we will assign the value at index 2
130:32 - to temporary variable
130:36 - so now temporary variable is having value as 5
130:41 - and then will simply assign the value at index 3
130:44 - to index 2
130:48 - moving ahead
130:51 - and finally we will assign the value
130:53 - in the temporary variable
130:55 - to the numbers array at the end index
130:59 - so it becomes something like this
131:03 - and finally we will increment the start by 1
131:06 - so start becomes 3
131:10 - and now it will point to the third index
131:13 - moving ahead
131:16 - and then we will decrement the end by 1
131:19 - so end becomes 2
131:22 - and it will point to the second index
131:24 - so now in while block we will again check whether start is less than end or not
131:31 - so here you can see the value of start is greater than end
131:35 - so therefore the condition in while block comes out to be false
131:39 - and also friend here you can see
131:41 - that is array is completely reversed
131:44 - so friend the idea behind this reversal algorithm was
131:47 - to actually take the two pointers
131:49 - one would be the start position
131:51 - and one would be the end position
131:53 - and we simply kept on swapping the values
131:56 - and then incrementing the value of start by 1
131:59 - and decrementing the end by 1
132:03 - so we performed this operation till start was less than end
132:07 - so as soon as start becomes equal to end or greater than end
132:10 - then we have actually reversed the complete array
132:14 - friend here we saw an example
132:16 - with an array of even number of values
132:19 - so we actually swapped in pairs
132:23 - but if it took an array of odd numbers of element
132:27 - then also this algorithm will work fine because
132:31 - because the middle element will always retain its place
132:33 - when we are reversing an array
132:36 - so friend let's go to eclipse and see the working of this algorithm
132:42 - so friend in our previous tutorial
132:44 - we saw the demonstration of how to reverse an array in java
132:48 - so in this tutorial we will actually code the algorithm for reversing an array
132:53 - so here I have created one class by name reverse array
132:57 - and this class has a starting method print array
132:59 - which will actually take an array
133:01 - and print its elements on the console
133:04 - and in the main method I have taken the same array
133:06 - which we discussed in the slide
133:09 - so initially if I run the code now
133:11 - you see it prints the values in the array as
133:18 - 2,11,5,10,7,8
133:22 - and now we will write the code to reverse this array
133:28 - so we will create a static method
133:30 - public static void reverse
133:37 - this method takes in the array which we want to reverse
133:46 - and it also takes the range that from which position to which we want to reverse the array
133:53 - so it actually takes the start position and the end position
133:57 - between which we will reverse the elements of the array
134:01 - so the first step will provide a while loop
134:04 - and we will iterate till start is less than end
134:10 - and in this value we will simply swap the values
134:13 - at the start index and the end index of the array
134:16 - so first we will create a temporary variable
134:20 - and to this temporary variable we will simply assign the value at the start index of array
134:34 - and then we will simply assign the value at the end index
134:37 - to the value at start index
134:47 - and finally we will assign the value of the temporary variable
134:50 - to the end index of the array
134:53 - and then we will simply increment the start by 1
134:57 - and decrement the end by 1
135:00 - so friend this is the algorithm to actually reverse an array
135:04 - now lets test its working in the main method
135:07 - so here I will call reverse method
135:12 - by passing in the numbers array
135:15 - and the start position is 0
135:18 - and end position is numbers.length
135:22 - minus 1
135:24 - so between this range the array will be reversed
135:28 - and finally we will print the array
135:39 - so if I run the code now
135:45 - so friends here you can see
135:47 - initially the array was having values at 2, 11, 5, 10, 7, 8
135:53 - so after reversing this array
135:55 - it became 8, 7, 10, 5, 11, 2
136:00 - so friend in this tutorial we actually coded
136:02 - the algorithm to reverse an array in java
136:04 - I hope you liked this video
136:06 - thanks have a nice day
136:10 - hello friends
136:11 - welcome to my new data structures
136:13 - and algorithms in java tutorial series video
136:16 - friends in this tutorial we will discuss
136:19 - how to find minimum value in array
136:23 - so friend lets suppose we are given an array
136:25 - having few elements
136:26 - so our task is to find the minimum value in array
136:31 - so friend below you can see the algorithm
136:33 - to find the minimum value of an array
136:37 - so the name of the method is find minimum
136:39 - which takes in an integer array
136:43 - and which returns back an integer value
136:45 - which is nothing but the minimum value of the array
136:49 - so friend lets see the demonstration of this algorithm
136:51 - step by step
136:53 - and we will take the input array which is given in this slide
137:00 - so friends in first step what we will do
137:02 - we will create an integer variable
137:04 - and we will give it the name as min
137:06 - so this min variable will always hold the minimum value of the array
137:12 - so at the start what we do is
137:14 - we simply take the first element of the array
137:16 - and we will mark it as the minimum value of the array
137:21 - so here min will have value as 5
137:27 - and at the start we will treat the first element
137:29 - as the minimum value of the array
137:34 - so friends the basic idea behind this algorithm is
137:37 - now we will provide a for loop
137:39 - which will start from the index 1
137:41 - and which will go till the last element of an array
137:47 - and inside this for loop we will compare each and every element
137:49 - of the array with the min value
137:53 - and lets suppose if we find any value
137:55 - of array which is less than the min value
137:58 - we will simply update the min
138:00 - with that particular value
138:03 - so we will start this for loop with i equal to 1
138:09 - so here the value of i
138:11 - basically represent the index of the array
138:15 - and we will check whether i is less than
138:18 - the length of the array or not
138:20 - so here you can see the length of array 6
138:22 - and 1 is less than 6
138:25 - so the condition in for loop comes out to be true
138:33 - so in the if block now we will check that whether the value
138:35 - at index 1
138:37 - is lesser than the min value or not
138:39 - so here you can see
138:41 - 9 is not less than 5
138:43 - therefore the condition in if block comes out to be false
138:50 - now we will increment i by 1
138:52 - so i becomes 2
139:03 - so now we will compare the value at index 2
139:05 - which is 3
139:07 - with the min value which is 5
139:09 - so here you can see 3 is less than 5
139:12 - therefore condition in if block comes out to be true
139:17 - so for an inside is array
139:19 - we have found a value which is less than the min value
139:24 - so at this step we will simply update the min
139:26 - with the value which we found as the minimum value
139:30 - so now min will become 3
139:35 - so after this assignment our new minimum value becomes 3
139:42 - now we will again increment i by 1
139:45 - so i becomes 3
139:56 - we will compare the value of array at index 3
139:58 - which is 15
140:00 - with 3
140:02 - and we will check whether 15 is less than 3 or not
140:04 - so here you can see 15 is not less than 3
140:06 - so the condition in if block comes out to be false
140:12 - we will again increment i by 1
140:15 - so i becomes 4
140:26 - and then in if block we again compare that value at index 4
140:29 - which is 1
140:31 - is less than minimum value or not
140:33 - so here you can see the value at index 4 is 1
140:36 - and we know that 1 is less than 3
140:39 - therefore condition in if block comes out to be true
140:43 - and we have found one more element which is less than the minimum value
140:47 - so here in the if block we simply update the minimum value
140:50 - with a value which we found to be the minimum
140:53 - so now min will become 1
140:59 - so after this assignment our updated minimum value would be 1
141:02 - now we will simply increment i by 1
141:05 - so i becomes 5
141:13 - so now here we will compare the value at index 5
141:16 - which is nothing but 2
141:18 - with the minimum value which is 1
141:21 - so we will check whether 2 is less than 1 or not
141:24 - so here condition in if block comes out to be false
141:27 - because 2 is not less than 1
141:30 - because 2 is not less than 1
141:35 - and then we will simply increment i by 1
141:38 - so i becomes 6
141:44 - so when i become 6 we know that i has crossed the boundaries of the array
141:49 - so the condition in for loop comes out to be false
141:52 - and the for loop terminates
141:54 - so after the for loop completes whatever the value min will hold
141:57 - it would be the smallest value of this array
142:00 - so at the last i will simply return this minimum value
142:03 - which is nothing but 1
142:08 - so from in this tutorial we actually saw the demonstration
142:11 - to how to find a minimum value of an array
142:15 - now let's go to eclipse
142:17 - and see the working of this code
142:21 - hello friends
142:23 - in our previous tutorial we actually discussed
142:26 - how to find a minimum value in an array
142:29 - we saw the demonstration of the algorithm step by step
142:32 - now in this tutorial we will actually code the algorithm
142:35 - and we will test its working in the main method
142:38 - so here i have created one class by name main
142:41 - and here i have created one class by name main
142:43 - in the main method
142:45 - so here i have created one class by name main array
142:48 - with a main method
142:50 - and here i have created one array
142:53 - which we saw in the slide
142:55 - and then i have initialized this main array class
142:59 - so let's write the code to find the minimum value of an array
143:04 - so first i will be creating a public method
143:07 - whose return type would be the integer
143:10 - and the name of the method would be
143:14 - minimum
143:20 - now this method will take
143:23 - an array
143:25 - and we have to find the minimum value of this array
143:28 - and we will simply return it from this method
143:32 - so friends in the first step what we will do
143:35 - we will simply provide an edge case
143:37 - we will check
143:40 - that whether array
143:44 - is null or not
143:47 - so if array is null
143:49 - or
143:51 - array.length
143:53 - is zero
143:57 - we will simply throw
143:59 - an illegal argument exception
144:08 - stating that invalid input
144:13 - so here if the array is not equal to null
144:20 - and array.length is not equal to zero
144:24 - then we will create one integer variable
144:27 - we will give it name as min
144:30 - and we will assign the first value of array to it
144:37 - so here
144:40 - min
144:42 - will hold
144:44 - the minimum value
144:48 - of array
144:52 - and here we are simply assigning
144:55 - the value of index zero
144:57 - to min and treating it as a minimum value
145:00 - so now we will provide a for loop
145:04 - and we will iterate over each and every element of array
145:08 - starting from one
145:12 - and we will iterate
145:16 - till the end of the array
145:24 - so inside this for loop
145:26 - we will simply provide a if condition
145:29 - and we will check
145:31 - that value
145:33 - of array IH index
145:35 - is less than min or not
145:39 - so if the value of IH index is less than min
145:42 - we know that inside the input array
145:44 - we have found a value
145:46 - which is less than the current min value
145:49 - so inside this if block we will simply update
145:52 - the min value to be
145:54 - the value of IH index
146:00 - and after iterating over each and every element
146:03 - and checking this if condition
146:05 - when the for loop terminates
146:07 - we simply return
146:09 - the min value
146:12 - so friend this is the algorithm
146:14 - to find the minimum value
146:16 - of an array
146:17 - now lets test its working in the main method
146:22 - so here after creating an array
146:24 - and initializing this class
146:26 - we will simply call
146:30 - find minimum method
146:32 - and we will pass array to it
146:35 - and whatever value this find minimum returns
146:38 - we will simply print it on the console
146:41 - so if I run the code now
146:53 - you can see it printed one
146:55 - so here you can see one is the smallest value inside this array
147:00 - so if I change the value
147:02 - to lets say zero
147:05 - and if I run the code now
147:06 - you see it printed zero
147:11 - because zero is the smallest value inside this array
147:17 - also friend if I pass null
147:22 - and if I run the code now
147:28 - you see it printed illegal argument exception
147:31 - saying that invalid input
147:33 - because we have passed null value
147:36 - for an array
147:39 - if I pass
147:42 - integer array array length is zero
147:45 - and if I run the code now
147:50 - you can see it again printed invalid input
147:54 - because array length is zero
147:59 - so friend in this tutorial we actually coded
148:01 - the algorithm to find the minimum value
148:03 - of an array
148:05 - and we also tested its working in the main method
148:10 - I hope you like this video
148:12 - thanks have a nice day
148:15 - hello everyone
148:17 - so in this video we are going to discuss
148:19 - that how we can find the second maximum value in an array
148:24 - so here we are given an array of integers
148:27 - we need to return the second maximum value
148:30 - now we have provided the array
148:32 - with some integers
148:34 - and the second maximum value
148:36 - and the second maximum value exists
148:39 - so for example we are given an input array
148:42 - 12, 34, 2, 34, 33, 1
148:47 - so here if you see
148:49 - the maximum value is 34
148:51 - here we have duplicate 34
148:53 - so the second maximum value is 33
148:56 - we have to return the second maximum value
148:59 - so despite we have duplicates value
149:01 - we need to return the second maximum value
149:05 - which is 33 here
149:07 - and the constraint is
149:09 - the second maximum value exists
149:11 - so we will be given with an array
149:13 - of some elements
149:15 - in such a way that the second maximum value
149:17 - will exist
149:19 - so lets see the demonstration of this algorithm step by step
149:23 - so friends before we start
149:25 - in case if you are new to my channel
149:27 - then please subscribe to my channel
149:29 - and click the bell icon
149:31 - to never miss any update
149:34 - now here is the algorithm
149:36 - to find the second max
149:38 - so when we will call
149:40 - the method findSecondMax
149:42 - and we pass in the array
149:44 - having 6 elements
149:46 - 13, 34, 2, 34, 33, 1
149:52 - so friends the idea behind this algorithm is
149:55 - we create two variables
149:57 - one is the max
149:59 - and another is second max
150:01 - the maximum value in the array
150:04 - and the second max will hold
150:06 - the second maximum value in the array
150:09 - and using this for loop
150:11 - we will figure out which is the max
150:13 - and which is the second max
150:15 - and at the end we will simply return
150:17 - the second maximum value
150:19 - so at the start what we do is
150:21 - to max we assign the minimum integer value
150:25 - so that when we will compare max
150:28 - with the actual array value
150:30 - we can compare it safely
150:33 - and here integer.min value
150:36 - is actually equal to
150:38 - minus 2 1 4 7 4 8
150:41 - 3 6 4 8
150:43 - so this is the integers min value
150:46 - which we are assigning to the max
150:48 - so if we have the lowest value
150:51 - and if we compare it with any of the value of the array
150:54 - then we can figure out that
150:56 - whether this max
150:57 - needs to be changed or not
151:01 - and similarly to second max we
151:04 - assign the integers min value
151:07 - so max and second max start from integers min value
151:12 - now we will provide the for loop
151:14 - which will iterate from i equal to 0
151:16 - to i less than array.length
151:19 - so i will start from 0 index
151:22 - 0 is less than 6
151:25 - which is array.length
151:28 - now we will take the first array value
151:31 - which is at 0th index which is 13
151:34 - so we will compare that whether 13 is greater than
151:37 - our current max or not
151:39 - so as the current max is the minimum value
151:42 - of the integer
151:44 - 13 is actually greater than max
151:46 - now what it suggest is we need to update
151:49 - max to 13
151:51 - because we have found one maximum value
151:54 - in this array
151:56 - till this point
151:58 - so this condition comes out to be true
152:01 - it means we have found
152:03 - a maximum value
152:07 - now here we need to update
152:09 - 13 to max
152:11 - because we have found
152:13 - a value which is greater than max
152:15 - so max will become 13
152:17 - but before updating this part
152:20 - array of i to max
152:22 - when we will update array of i to max
152:25 - max will become 13 but
152:28 - but as max has changed to a new value
152:31 - whatever the max old value was
152:34 - it will become our second max
152:36 - so for example let's say
152:38 - if second max
152:40 - would have been 1
152:43 - and max would have been 2
152:45 - and let's say array of i
152:47 - is 13
152:49 - for example
152:51 - so before assigning 13 to max
152:53 - we need to assign 2
152:55 - and max because after this assignment
152:58 - second max will become 2
153:01 - and max will become
153:03 - 13
153:05 - so here as max has been updated to 13
153:08 - whatever the value max had
153:11 - that will become our second max
153:13 - because that value is lesser than
153:15 - the actual max value
153:17 - so therefore we need to be careful
153:19 - while updating the max
153:21 - to array of i
153:23 - before updating max to array of i
153:25 - we need to assign the old max value
153:28 - to second max because this max will now
153:31 - become our second max
153:33 - so currently max value is integers min value
153:36 - and second max is also integer.min value
153:39 - so when we will assign max to second max
153:42 - the value won't change
153:44 - it will be still integer.min value
153:47 - and now
153:49 - 13 will be assigned to max
153:51 - so this value will be assigned to max
153:53 - so max will become 13
153:55 - and when we are doing ahead
153:58 - we will increment i
154:01 - i becomes 1
154:03 - 1 is less than 6
154:07 - now 34 is greater than max
154:10 - which means 34 is greater than 13
154:14 - max value is 13
154:16 - so 34 is greater than 13
154:18 - so this condition comes out to be true
154:22 - and we know that when we will update max to 34
154:25 - we need to assign the old max value
154:28 - which is 13 to second max
154:38 - so here before updating max to 34
154:41 - we will assign its value
154:43 - which is the old max value
154:45 - to second max
154:47 - so second max will become 13
154:49 - because this value comes here
154:53 - and max will become 34
154:56 - moving ahead
154:59 - we will increment i
155:02 - i becomes 2
155:04 - 2 is less than 6
155:08 - so friends here you can see
155:10 - that if we would have given an array
155:12 - of these two elements
155:14 - then max would have been 34
155:16 - and second max would have been 13
155:20 - so these two steps are critical
155:22 - when we will update max
155:24 - to any actual array value
155:26 - we have to assign that old max value
155:29 - to second max because
155:31 - as max is actually changing its value
155:33 - its old value will become our second max
155:36 - so currently array of i
155:38 - which is 2
155:41 - it's not greater than 34
155:43 - which is our max value
155:45 - so therefore this condition comes out to be false
155:50 - and the else part will be executed
155:52 - now why this else if condition is provided
155:55 - because let's say here
155:58 - value would have been 14
156:00 - for example instead of 2
156:02 - it would have been 14
156:04 - so 14 is not greater than 34
156:07 - and then we have provided else if condition
156:10 - where we are checking that there could be a possibility
156:13 - that 14 is actually greater than 13
156:15 - which is our second max
156:17 - it means we have to update second max to 14
156:21 - because if a value is not greater than max
156:25 - but this value can actually be greater than our second max
156:28 - so therefore after this condition
156:31 - we have to provide an else if
156:33 - we need to check whether array of i is actually greater than
156:37 - second max or not
156:39 - so currently
156:42 - 2 is not greater than
156:44 - 13 which is our second max
156:47 - so this condition comes out to be false
156:52 - we will increment i
156:56 - i becomes 3
156:58 - 3 is less than 6
157:01 - which is array dot length
157:04 - now here you can see
157:06 - this is one critical step
157:08 - array of i is 34
157:11 - 34 is actually equal to max
157:14 - but not greater than max
157:16 - so this condition comes out to be false
157:17 - now in the else part
157:19 - the first if condition
157:25 - 34
157:27 - is greater than
157:29 - 13
157:31 - which is true
157:33 - and if it is true
157:35 - but still we can't update 34 to second max because
157:38 - we need to provide yet another condition
157:41 - in the end part
157:43 - which will check whether array of i
157:46 - should not be equal to max
157:49 - it means it is checking for the duplicate max value
157:53 - so let's say our max is 34
157:55 - and if we have found 34 again
157:57 - so we have to compare
157:59 - this array value
158:01 - 2 over max
158:03 - and they should not be equal
158:05 - array of i should be greater than second max
158:07 - which is true
158:09 - but 34 should not be greater than
158:11 - the max which is 34
158:13 - so this is false
158:15 - the overall condition with this end operator comes out to be false
158:19 - so therefore though
158:21 - 34 is greater than 13
158:23 - which is this condition
158:25 - still we won't update
158:27 - 34 to second max because
158:29 - 34 is actually our max value
158:32 - which we have figured out here
158:35 - so therefore this overall condition comes out to be false
158:40 - we will increment i
158:43 - i becomes 4
158:45 - 4 is less than 6
158:53 - now here you can see array of i which is 33
158:57 - 33 is not greater than 34
159:01 - which is our max
159:03 - so this condition comes out to be false
159:06 - in the else if part
159:09 - 33 is greater than second max
159:12 - which is 13
159:14 - so 33 is greater than 13
159:17 - and we need to compare whether 33
159:21 - should not be equal to max
159:24 - so 33
159:26 - is not equal to 34
159:28 - so therefore this condition is also true
159:31 - so therefore now we have found one contender
159:34 - which can be our second max
159:36 - which is 33
159:38 - so this condition comes out to be true
159:41 - we will update second max to 33
159:47 - moving ahead
159:50 - we will increment i
159:53 - i becomes 5
159:55 - 5 is less than 6
159:57 - so this condition is true
160:00 - array of i
160:02 - which is 1
160:04 - 1 is not greater than 34
160:07 - so this condition comes out to be false
160:10 - array of i
160:12 - which is 1
160:14 - 1 is not greater than
160:16 - the second max which is 33
160:19 - so this condition comes out to be false
160:22 - and overall condition comes out to be false
160:27 - we will increment i
160:29 - so it will go out of the array boundaries
160:32 - i will become 6
160:34 - so 6 is not less than 6
160:36 - so therefore this for loop will terminate now
160:39 - and at the end we will return
160:42 - the second max which is 33
160:44 - so friend this was all about
160:47 - how to find the second maximum value in an array
160:50 - i hope you must have liked this video
160:53 - in case if you are new to my channel
160:55 - then please subscribe to my channel
160:57 - and click the bell icon
160:59 - so that you never miss any update
161:01 - thanks have a nice day
161:05 - hello everyone
161:07 - so in this video we will discuss
161:09 - that how we can move all the zeros
161:12 - to end of an array
161:16 - so here we are given a problem
161:18 - that given an array of integers
161:20 - write a function to move
161:22 - all zeros to end of it
161:25 - while maintaining the relative order
161:27 - of the non zero elements
161:29 - so friends for example you can see
161:31 - that we are given with an array of integers
161:33 - 0 1 0 4 12
161:36 - now our task is to move the zeros
161:39 - to the end of the array
161:41 - and we have to move it such a way that
161:44 - we have to maintain the relative order of non zero elements
161:47 - so here you can see
161:49 - that the first non zero element is 1
161:52 - then its 4 and then 12
161:55 - so we have to move this both 0
161:58 - to the end of the array in such a way that
162:00 - this order is maintained
162:02 - 1 4 12
162:04 - so the solution would be
162:06 - move the zero
162:08 - after that the first non zero element is 1
162:11 - then 4 then 12
162:13 - and both the zeros are at the end
162:16 - so lets move ahead and see
162:18 - the algorithm for it
162:20 - and we will see the demonstration
162:22 - of the algorithm step by step
162:24 - so here you can see that we are provided with this algorithm
162:27 - where the method name is move zeros
162:30 - which takes in an integer array
162:32 - and a value n which is nothing but the length of the array
162:35 - so when we will call move zero method
162:39 - and lets say we provide this array
162:42 - having the elements as 8 1 0
162:45 - 2 1 0 3
162:47 - going from index 0 to 6
162:50 - so therefore the value of n will be 7
162:53 - because there are 7 elements
162:55 - moving ahead
162:58 - so here the idea behind this algorithm is
163:01 - that we usually take 2 pointers
163:03 - and lets say we provide name to it as i and j
163:06 - so one pointer
163:08 - basically focuses on the non zero elements
163:11 - and the other pointer focuses on the zero elements
163:15 - and when these two pointers
163:17 - where one is at non zero element
163:20 - and the other is at zeroth element
163:22 - we simply perform a swap
163:24 - so here you can see
163:27 - that we are starting from j equal to zero
163:30 - and i equal to zero
163:32 - and in this algorithm
163:34 - j will basically focus on the zeroth elements
163:38 - and i will focus on non zero elements
163:43 - so here you can see that value of j is zero
163:46 - so we are simply representing it as like this
163:49 - but it is basically storing an integer value zero
163:52 - moving ahead
163:56 - now friends as you want to travel
163:58 - each and every element of this array
164:00 - and try to move zeros to the end of the array
164:03 - we need to traverse complete array
164:05 - so we have provided a for loop
164:07 - where i will start from zero
164:09 - and this will go
164:11 - till the end of array
164:13 - where we provide this condition as whether i is less than n or not
164:17 - so value of n is 7
164:19 - so i will travel till 6
164:21 - and after each iteration of this for loop
164:24 - we will simply increment i by 1
164:26 - and we also discussed
164:28 - that j will focus on zeroth elements
164:31 - and i will focus on non zero elements
164:33 - and we will perform the swapping of elements
164:36 - when j will point to zeroth element
164:39 - and i will point to non zeroth element
164:42 - so let's see the demonstration of this algorithm step by step
164:45 - so here value of i is zero
164:48 - and i is also less than 7
164:50 - so the condition for loop comes out to be true
164:52 - so the first step we check that the value of i-th index is non zero or not
165:00 - so here you can see
165:02 - the value of i is zero
165:04 - and the value at zeroth index is 8
165:07 - so therefore this condition is true
165:10 - and we also check
165:12 - whether value of j-th condition is equal to zero or not
165:15 - so here you can see
165:17 - value of j is also zero
165:19 - so the value at zeroth index is 8
165:22 - therefore this condition is false
165:25 - and we also know that when this both the condition will be true
165:28 - then only we will perform the swap
165:30 - but currently the second condition comes out to be false
165:33 - because the value at zeroth index is 8
165:37 - which is not equal to zero
165:40 - so we simply move ahead
165:44 - the value at j-th index is 8
165:47 - which is non zero
165:49 - so therefore we simply increment j by 1
165:53 - so j becomes 1
165:59 - and why we are traversing j by 1 because we need to find a value
166:03 - at any particular index which is zero
166:06 - so that j could reach there
166:08 - and we can perform this swap
166:10 - moving ahead
166:13 - now we will increment i by 1
166:16 - so i becomes 1
166:20 - and 1 is less than n
166:22 - therefore this condition also comes out to be true
166:25 - so for loop executes
166:29 - we check value at i-th index is zero or not
166:33 - so value at i-th index is 1
166:36 - which is not equal to zero
166:38 - so this condition is true
166:40 - and we also check value at j-th index
166:44 - so the value at j-th index is also 1
166:47 - but this condition comes out to be false because it is not equal to zero
166:51 - so therefore the condition in block comes out to be false
166:57 - and we check whether value at the j-th index is zero or not
167:01 - so here you can see the value at j-th index is non zero
167:06 - therefore this condition comes out to be true
167:09 - and we simply increment j by 1
167:14 - so j becomes 2
167:20 - now we will again increment i by 1
167:23 - so i becomes 2
167:26 - and also here you can see the value of i which is 2
167:30 - is also less than 7
167:32 - so therefore this condition also comes out to be true
167:35 - and for loop executes
167:39 - now here you can see the value at i-th index
167:43 - is basically equal to zero
167:45 - therefore this condition comes out to be false
167:48 - and we don't evaluate this condition because of this AND operator
167:52 - so this if block condition comes out to be false
167:58 - and we are checking the value at j-th index is zero or not
168:02 - so here you can see the value at j-th index is zero
168:05 - so therefore this condition also comes out to be false
168:08 - because we have encountered zero
168:10 - and j should focus on zero the elements
168:13 - so that we can perform a swap
168:15 - so this condition comes out to be false
168:17 - and j stays at the same position
168:22 - now we will again increment i by 1
168:24 - so i becomes 3
168:28 - and 3 is less than 7
168:30 - so for loop executes
168:35 - so here you can see that now we have encountered
168:38 - an interesting situation
168:40 - where j is pointing to zeroth element
168:43 - and i is pointing to a non zero element
168:46 - so this condition
168:48 - where the value at i-th index
168:51 - is not equal to zero
168:53 - so this condition comes out to be true
168:55 - and the second condition also comes out to be true
168:58 - because j is pointing to value 2
169:02 - and the value at second index is zero
169:05 - so therefore this condition also comes out to be true
169:08 - and overall if condition comes out to be true
169:11 - so now this if block will execute
169:16 - and we need to perform this swap
169:20 - so we are creating this temporary variable
169:23 - to store one of the values
169:25 - so we are simply storing
169:27 - the value at i-th index into the temporary variable
169:33 - so 2 is stored into this temporary variable
169:36 - because we need to perform the swap
169:38 - so somewhere we need to store this value
169:42 - and now we are storing the value at j-th index
169:45 - to the value at i-th index
169:48 - so value at j-th index is zero
169:51 - and we are assigning this zero
169:53 - to value at i-th index
169:55 - so it would look something like this
169:58 - that zero will be assigned
170:00 - to the i-th index
170:02 - moving ahead
170:05 - and finally we will assign
170:07 - the value showed in temporary variable
170:09 - to j-th index
170:11 - so it would look something like this
170:13 - so here we have simply swapped these two values
170:18 - and after this swapping
170:21 - we again check that value at j-th index
170:24 - is equal to zero or not
170:26 - so here you can see
170:28 - the value at j-th index is 2
170:30 - so we simply traverse j by 1
170:35 - so j becomes 3
170:36 - now we will again increment i by 1
170:38 - so i becomes 4
170:42 - and 4 is less than n
170:44 - therefore for loop executes
170:48 - so from here you can see
170:50 - the value at i-th index is 1
170:53 - which is not equal to zero
170:55 - so this condition is true
170:57 - and the value at j-th index
170:59 - is equal to zero
171:01 - so this condition is true
171:03 - and the value at j-th index
171:05 - which is zero
171:07 - is equal to zero
171:09 - so this both condition comes out to be true
171:12 - and when both condition comes out to be true
171:15 - we know that we have to perform a swap
171:19 - so we will store 1 into the temporary variable
171:26 - we will assign the value at j-th index
171:29 - which is zero
171:31 - and we will simply assign it to
171:33 - the value at i-th index
171:36 - so it would look something like this
171:40 - the zero has been assigned to the fourth index
171:44 - moving ahead
171:47 - and then we will simply assign the value stored in a temporary variable
171:51 - to the j-th index because we need to perform this swap
172:00 - we again check
172:01 - what's the value at j-th index
172:04 - so here you can see the value is 1
172:06 - so 1 is not equal to zero
172:08 - therefore this condition comes out to be true
172:13 - and we will increment j by 1
172:15 - so j becomes 4
172:17 - so friends the whole idea behind this check is
172:20 - that we need to traverse j
172:23 - so that it reaches to any zeroth element
172:26 - so that we can perform a swap
172:28 - so here the value at j-th index is non-zero
172:32 - therefore we are incrementing j by 1
172:35 - so j becomes 4
172:40 - we will increment i by 1
172:42 - i becomes 5
172:45 - and 5 is less than 7
172:48 - so this condition comes out to be true
172:53 - and now here you can see
172:55 - the value at j-th index is 0
172:57 - the value at j-th index is 0
172:59 - so this condition is true but
173:01 - this condition is not true
173:03 - because value at i-th index is equal to 0
173:06 - so this condition comes out to be false
173:08 - and this if block will not get executed
173:14 - and now as j is pointing to the zeroth element
173:17 - so this condition also comes out to be false
173:23 - we will increment i by 1
173:25 - so i becomes 6
173:29 - and 6 is also less than 7
173:31 - so the for loop will execute
173:35 - so in the first condition we will check whether value at i-th index is 0 or not
173:40 - so here you can see the value at i-th index is 3
173:45 - 3 is not equal to 0
173:47 - so this condition comes out to be true
173:49 - and then we will check whether value at j-th index
173:52 - is equal to 0 or not
173:54 - so the value at j-th index is 0
173:57 - therefore this condition also comes out to be true
174:03 - so we need to simply perform a swap
174:06 - so we will store 3 into the temporary variable
174:13 - and then we will swap 0 to this position
174:16 - by assigning value at the j-th index to the i-th index
174:19 - so this will become 0
174:25 - and at the last step we will assign the value 3 to the j-th index
174:30 - so 3 will come here
174:35 - and here we will simply check whether the value at j-th index is 0 or not
174:39 - so value at j-th index is non-zero
174:42 - so therefore this condition also comes out to be true
174:45 - so we increment j by 1
174:48 - so j becomes 5
174:53 - and here we will increment i by 1 again
174:56 - so i becomes 7
174:58 - but now here you can see 7 is not less than 7
175:01 - so the condition in for loop comes out to be false
175:04 - and this for loop will exit
175:10 - so after this for loop will exit
175:12 - so here you can see that this array had
175:14 - two 0 elements in the between
175:17 - and we have simply moved them to the end of an array
175:21 - by maintaining the relative order among the non-zero elements
175:25 - so when this is one of the simple algorithm
175:28 - to move the 0 elements to the end of an array
175:32 - now let's go to IntelliJ and see the working of this code
175:36 - so friends i hope you like this video
175:38 - and in case you have liked this video
175:40 - then please like, comment, share and subscribe my channel
175:43 - thanks have a nice day
175:50 - hello everyone
175:52 - so in this video we will simply code the algorithm
175:55 - and we will see that how we can move
175:58 - the 0 elements to the end of an array
176:01 - so here you can see that i have created on classes move 0s
176:05 - so this class is on main method
176:07 - and it calls the array demo method
176:11 - so where we have created this array
176:13 - which we also saw in our previous video
176:16 - and we have this one method print array
176:19 - which we already discussed in one of our previous videos
176:24 - so if i run the main method
176:29 - so here you can see it simply prints the array
176:32 - on the console as 8 1 0
176:34 - 2 1 0 3
176:36 - so these are nothing but the elements of array
176:39 - which has 2 0 elements
176:42 - so we need to move this 2 0 elements to the end of the array
176:45 - by maintaining the relative order of the non 0 elements
176:51 - so let's code the method
176:54 - so we will create public void
176:58 - we give the method name as move 0
177:05 - and as we discussed in our previous video
177:07 - this method will take 1 integer array
177:11 - and 1 value n
177:14 - which is nothing but the length of the array
177:18 - and we also discussed the idea behind this algorithm is
177:21 - we take 2 pointers
177:24 - let's say 1 as j
177:27 - which will focus on
177:32 - 0th elements
177:34 - and 1 pointer is i
177:37 - so here
177:45 - i will focus on
177:51 - non 0 elements
177:54 - and as we want to iterate
177:56 - each and every element of this array
177:59 - will provide this for loop
178:01 - where i will traverse from 0
178:04 - and it will go
178:07 - to a value lesser than the length of the array
178:11 - which is nothing but the value n
178:14 - and after each iteration will simply increment
178:16 - the value of i by 1
178:21 - so in for loop what we do is
178:23 - we provide a if condition
178:27 - and here we will check
178:30 - the value stored at ith index
178:33 - is not equal to 0
178:36 - because i will focus on non 0 elements
178:41 - and if
178:44 - the value at jth index
178:46 - is equal to 0
178:49 - because j will focus on 0th elements
178:52 - so if these 2 conditions are equal
178:55 - then we will simply perform a swap
178:57 - by taking a temporary variable
179:10 - so here we are assigning
179:12 - the value at ih index
179:14 - to this temporary variable
179:17 - and then we are simply swapping
179:19 - the value at jth index
179:21 - and storing it
179:23 - on the ih index and at the last step
179:26 - we are taking the value of the temporary variable
179:29 - and storing at the jth index
179:31 - so this will simply swap
179:33 - the value of the ih and jth index
179:37 - and after we perform swap
179:39 - we will provide one more if condition
179:43 - where we simply check
179:46 - that value at jth index
179:49 - is not equal to 0
179:52 - so if the value at jth index
179:54 - is not equal to 0
179:56 - we will simply increment j by 1
179:58 - because that is not the value
180:00 - that j is focusing on
180:02 - j will only focus on the 0th elements
180:04 - so this is the condition
180:08 - so friend this is the algorithm
180:10 - to move the 0th elements
180:12 - to the end of an array
180:14 - now lets see the demonstration of it
180:18 - now after printing the array
180:20 - we will simply call move zeros
180:23 - will pass the array
180:26 - and will pass the value of ns
180:30 - array.length
180:32 - and after moving
180:34 - the 0 to the end of the array
180:36 - will simply print the array again
180:40 - and if i run the main method again
180:47 - so friend here you can see
180:49 - that initially array was 8 1 0
180:51 - 2 1 0 3
180:53 - which had 2 0 elements
180:56 - and after we perform
180:58 - this algorithm where we are moving the zeros
181:00 - to the end of the array
181:02 - the value stored
181:04 - was like this
181:06 - 8 1 2 1 3
181:08 - where both the zeros
181:10 - came to the end of the array
181:12 - and even the relative order of the non zero elements
181:14 - remain the same
181:16 - with 8 1 2 1 3
181:20 - 8
181:21 - 1
181:23 - 2 1
181:25 - 3
181:29 - so here we simply coded
181:31 - an algorithm where we moved the zeros
181:33 - to the end of the array
181:35 - so friend this was all about this video
181:37 - in case you have liked this video
181:39 - then please like, comment, share
181:41 - and subscribe my channel
181:43 - thanks have a nice day
181:50 - hello everyone
181:52 - so friend in this lecture we will discuss
181:54 - how to resize an array in java
181:57 - so friend as you all know
181:59 - that when we initialize an array
182:01 - we provide a size
182:03 - that how many elements
182:05 - this array can hold
182:07 - and this size we have to provide
182:09 - when we are creating an array object
182:12 - but sometimes what happen
182:14 - that we don't know that how many elements
182:16 - can be there in an array
182:18 - at the time of initialization
182:21 - so therefore doing the resize of an array
182:23 - is a very common operation
182:25 - in many algorithms
182:28 - so for example when we use ArrayList
182:30 - inside the ArrayList
182:32 - we create an array of default size
182:35 - and when we add elements
182:37 - to that default size
182:39 - it gets stored in an internal array
182:41 - and as soon as we try to add
182:43 - one more element
182:45 - so internally what happens
182:48 - a new temporary array is created
182:50 - with a size more than that of the original array
182:53 - and then all the elements are copied
182:55 - from the original array to this temporary array
182:58 - and finally the original array
183:00 - points to this temporary array
183:03 - so friends now let's see the demonstration
183:05 - of this algorithm
183:08 - so here is the algorithm
183:10 - and let's say we have this array
183:13 - whose length is 4
183:15 - because it can store 4 elements
183:17 - and here you can see that all the elements
183:19 - inside this array
183:21 - are filled
183:23 - so therefore there is no more additional
183:25 - empty space left to add more elements
183:29 - and if suppose if you want to add more elements
183:31 - what we do is
183:33 - we simply call this resize method
183:35 - by passing in an array
183:37 - and we provide a capacity
183:39 - that how much more elements you want
183:41 - when this resize is done
183:43 - so let's say
183:45 - we call this resize method
183:47 - by passing in the array
183:49 - and whatever the length we have
183:51 - let's say 4
183:53 - we simply want to double the length
183:56 - so we pass the capacity as 8
184:00 - so now this method will be called
184:03 - with the capacity as 8
184:06 - and by passing this array
184:08 - moving ahead
184:11 - so friends once we initialize this array
184:14 - we can't add more elements to it
184:16 - so what we do is
184:18 - we create a temporary array
184:20 - for whatever the capacity we provided
184:23 - so here we will create a temporary array
184:29 - whose capacity or size would be 8
184:33 - so now this temporary array will range from 0 to 7
184:37 - storing the added elements
184:39 - which is nothing but the capacity of this array
184:43 - moving ahead
184:46 - now friends as we have created this temporary array
184:48 - our other task would be
184:50 - to copy each and every element
184:52 - of this array
184:53 - to this temporary array
184:55 - so in order to do that
184:57 - what we do is we provide a for loop
184:59 - which starts from 0th index
185:02 - and goes to the array.length-1 index
185:06 - so here
185:09 - value of i will be 0
185:11 - when this for loop starts
185:13 - it will simply point to the 0th index
185:15 - and we know that value of i
185:17 - which is 0
185:19 - is less than 4
185:21 - so therefore this for loop will execute
185:27 - and in the for loop what we will do
185:29 - we will simply copy
185:31 - the value stored at the ith index
185:33 - which is the 0th index
185:35 - to the temporary array
185:37 - at the ith index which is 0
185:40 - so here what we are simply doing
185:42 - we are simply copying this value
185:44 - which is 5
185:46 - to this temporary array at 0th index
185:49 - so it would look something like this
185:53 - so phi is copied here
185:56 - so now we will move ahead
185:59 - now we will increment the value of phi
186:01 - so i becomes 1
186:07 - it simply means that we can use this i
186:10 - to point to the 1st index
186:13 - and value of i which is 1 is less than 4
186:16 - so this for loop executes
186:21 - and now we will simply again copy
186:23 - the value at ith index which is the 1st index
186:26 - to this temporary array
186:28 - at 1st index
186:29 - so it would look something like this
186:33 - moving ahead
186:36 - we will increment the value of i
186:38 - by 1
186:40 - so i becomes 2
186:43 - it will point to the 2nd index now
186:49 - now we will copy the value at 2nd index
186:51 - to this temporary array
186:54 - so it would look something like this
186:57 - the 3 is copied from the 2nd index
186:59 - to temporary array at 2nd index
187:02 - moving ahead
187:05 - we will again increment the value of i by 1
187:08 - so i becomes 3
187:12 - so it will point to the 3rd index now
187:15 - and we know that 3 is less than 4
187:18 - therefore this for loop will execute
187:23 - and finally we will simply copy the value
187:25 - stored at the 3rd index
187:27 - to this temporary array
187:29 - at the 3rd index
187:31 - so it would look something like this
187:36 - moving ahead
187:39 - we will increment the value of i by 1
187:42 - so i becomes 4
187:45 - and we know that 4 is not less than 4
187:49 - so this condition comes out to be false
187:51 - so therefore for loop will terminate
187:54 - which actually makes sense because
187:56 - we have copied all the values
187:59 - of our original array to this temporary array
188:03 - so this for loop will exit
188:08 - and at the last step what we will do is
188:10 - here you can see
188:12 - that this temporary variable
188:14 - is pointing to this array object in a heap
188:19 - and our array is pointing to this object in heap
188:23 - so now what we will do
188:24 - whatever the value stored in this temporary array
188:26 - will assign to our original array
188:30 - so it simply means that we are reassigning
188:33 - this array to this array
188:36 - so it would look something like this
188:39 - that now this array will point
188:41 - to this temporary array
188:43 - which is nothing but pointing to an array object in heap
188:52 - so friends after this resize method gets executed
188:55 - our original array is pointing to an array
188:58 - having size as 8
189:01 - but here you can see that there is issue with this code
189:04 - once the resize method gets executed completely
189:07 - here you will find this array
189:10 - will also get garbage collected
189:12 - because the return type of this method is void
189:15 - and we are not sending
189:17 - the value stored in this array
189:19 - from this method
189:21 - therefore whatever we did here
189:23 - will be garbage collected finally
189:26 - so instead of keeping this resize method as void
189:29 - what we should do is
189:31 - we should keep the return type of resize method
189:34 - as integer array
189:37 - and here after assigning the temporary variable
189:39 - to array we should return
189:41 - the value stored in the array variable
189:45 - so that whatever the value is returned from this method
189:48 - and whoever is calling this method
189:50 - should actually get
189:52 - a reference to this object
189:54 - in the heap memory
189:56 - so this is one step which is very much important
189:58 - and we must do
190:00 - that we should return
190:02 - the array after resizing it
190:04 - and also friend here you can see
190:06 - that we even don't need to do
190:08 - this reassignment here
190:10 - what we can directly do here is
190:12 - as we have copied all the elements
190:14 - from the original array
190:16 - to this temporary array
190:18 - and this temporary array has capacity
190:20 - of what we have passed
190:22 - we can simply return
190:24 - the value stored in this temporary array
190:26 - instead of assigning it
190:28 - to array variable
190:30 - and returning the array variable
190:32 - we can simply return the value stored in this
190:34 - temporary variable
190:36 - so friend this was the demonstration
190:38 - of how to resize an array
190:40 - using this animation
190:42 - now let's go to Eclipse and see
190:44 - the working of this code
190:46 - I hope you like this video
190:48 - thanks have a nice day
190:52 - hello everyone
190:54 - so friends in our previous
190:56 - lecture we saw
190:58 - that how we can resize an array
191:00 - through an animation
191:02 - now in this lecture we will code the algorithm
191:04 - and we will see its working
191:06 - inside this main method
191:08 - so in our arrayutil class
191:10 - here I will be creating
191:12 - one method as
191:14 - public
191:16 - void
191:18 - and I will give the name to this method
191:20 - as resize
191:26 - now as we discussed in our previous lecture
191:28 - this resize method will take
191:30 - the array
191:32 - which we want to resize
191:34 - and it will take
191:36 - the capacity
191:38 - to which
191:40 - we want to resize
191:42 - so this is nothing but an integer value
191:44 - so what happens here is
191:46 - let's say our array has
191:48 - size 4
191:50 - and we want to resize it to
191:52 - 8, 10, 16 or whatever value
191:54 - we want we simply pass it
191:56 - here
191:58 - so in the first step what we do is
192:00 - as we have already created this array
192:02 - of a particular size
192:04 - we can't directly
192:06 - resize this array to this capacity
192:08 - so what we do is
192:10 - we first create
192:12 - a temporary array
192:19 - having the sizes
192:21 - the capacity we provide
192:25 - now after creating this temporary array
192:27 - what we do is
192:28 - we simply copy
192:30 - all the elements of this array
192:32 - to this temporary array
192:34 - so in order to copy all the elements
192:36 - of our original array
192:38 - to this temporary array what we do is
192:40 - we simply provide a for loop
192:44 - and inside this for loop
192:48 - we simply iterate
192:50 - each and every element
192:52 - of our original array
193:00 - so here you can see
193:02 - this for loop will iterate
193:04 - with a value of i as 0
193:06 - and it will go
193:08 - till the length of our original array minus 1
193:10 - and inside this for loop
193:12 - what we'll do
193:14 - is
193:16 - we'll simply assign
193:18 - the value stored at
193:20 - i as index
193:22 - of our original array
193:24 - to our temporary array
193:26 - at i as index
193:28 - so when this line will execute what it will do is
193:30 - it will go to our original array
193:32 - it will take the value
193:34 - from the i as index
193:36 - and then it will go to our temporary array
193:38 - to i as index
193:40 - and simply copy the value
193:42 - from our original array
193:44 - from the i as index
193:46 - to the temporary array at i as index
193:48 - so this copy
193:50 - will go from the 0th index
193:52 - and it will go to the last index
193:54 - of our original array
193:56 - which is array dot length minus 1 index
193:58 - so after we copy
194:00 - each and every element
194:02 - from our original array to this temporary array
194:04 - what we do is
194:06 - at the last step
194:08 - we simply assign
194:13 - the value stored in the temporary array
194:15 - to our original array
194:17 - so when this line will execute
194:19 - the temporary array which we created here
194:21 - which was pointed by
194:23 - this temp variable
194:25 - now our original array variable
194:27 - will point to this
194:29 - temporary array
194:31 - which has capacity of what we have provided here
194:34 - so after this method gets executed
194:36 - the original array has been resized
194:38 - to this capacity
194:40 - because at the last step
194:42 - we are simply assigning
194:44 - the value stored at the temporary variable
194:46 - to the array variable
194:48 - so initially this temp
194:50 - pointed to an array
194:52 - in an heap
194:54 - which had this capacity
194:56 - now what it means is
194:58 - our array will point to this array in heap
195:00 - so from this piece of code
195:02 - simply resizes the array
195:04 - so lets see the demonstration of it
195:06 - i will just copy this
195:08 - array initialization
195:10 - and i will just command this print array
195:12 - call
195:14 - here we will create an array
195:16 - we will give it a name as original
195:20 - and we will simply paste this part here
195:22 - so our original array
195:24 - has the size of
195:26 - storing 5 elements
195:28 - so lets say if we want to store more elements
195:30 - so we cant store here
195:32 - so then we have to resize
195:34 - this original array
195:36 - so what we do is
195:38 - here i will simply provide a sysout
195:40 - and here i will simply print
195:42 - the size of
195:44 - original array
195:48 - and lets say i provide a value as
195:50 - original
195:52 - dot length
195:54 - so friends if i run the code
195:56 - now
195:58 - so here you can see it printed
196:00 - the size of the original array is 5
196:02 - now friends as we want to resize it
196:04 - what we do is
196:06 - we simply call
196:08 - the resize method
196:12 - we pass in our original array
196:14 - and lets say we want to resize
196:16 - this array
196:18 - to a capacity of lets say 10
196:20 - and lets say we want to resize
196:22 - this array
196:24 - to a capacity of lets say 10
196:26 - so we pass the value of capacity
196:28 - as 10
196:30 - so friends
196:32 - after resizing the array
196:34 - we will simply print
196:38 - the size of original array
196:40 - after resize
196:42 - now what happens
196:44 - when i call this again
196:46 - the size of the original array
196:48 - after resize and i simply print
196:50 - original dot length
196:52 - so what it should print?
196:54 - it should print 5 or 10
196:56 - so friends here it looks
196:58 - that we have resized this original array
197:02 - to a capacity of lets say 10
197:04 - we have even copied the contents
197:06 - so we usually think
197:08 - that when we print original dot length
197:10 - here it should give
197:12 - the answer as 10
197:14 - but if i run it
197:16 - you will see
197:18 - that it gives
197:20 - the answer as 5
197:22 - so we have passed this original array here
197:24 - but when this method gets terminated
197:26 - this temporary array
197:28 - and everything will be garbage collected
197:30 - and when our call will reach
197:32 - this point
197:34 - the original array will be still pointing
197:36 - to this
197:38 - so what we do here is
197:40 - we have to return
197:42 - this array
197:44 - from this method
197:46 - and instead of void
197:48 - we have to give return type
197:50 - of the integer array
197:52 - so that here
197:56 - we can get this array
197:58 - as we are returning it from here
198:00 - and we can store it
198:02 - in the original and finally
198:04 - we can print
198:06 - the length of this original array
198:08 - and here if i run the code now
198:12 - you can see
198:14 - that now this original array
198:16 - is actually pointing
198:18 - to this resized array
198:20 - so friend
198:22 - this is one of the most smallest mistakes
198:24 - we usually make
198:26 - because we know that java is passed
198:28 - by value
198:30 - so we are passing the value stored
198:32 - in the original array here
198:34 - we are doing resize
198:36 - on this temporary array
198:38 - and this array variable
198:40 - and if you are not returning it back
198:42 - then this all will be garbage collected
198:44 - and our original
198:47 - will be pointing
198:49 - to this array only
198:51 - so here we are returning this array
198:53 - we are storing it here
198:55 - so now we have actually reassigned
198:57 - it to a different array
198:59 - by this line
199:01 - and when we printed the length of this original array now
199:03 - it gave the value as 10
199:06 - and also friend what we can do is here
199:08 - instead of assigning it to array
199:10 - we can even
199:12 - return something like this
199:17 - because we have copied the content
199:19 - of this array to this temporary
199:21 - array
199:23 - so instead of assigning the value of this
199:25 - temporary variable to
199:27 - array variable we can directly return
199:29 - something like this
199:31 - and if i run the code now
199:37 - you can see it again printed the size of the original array
199:39 - after resize is 10
199:41 - so here now we have actually resized
199:43 - this original array
199:45 - so friend this method is used
199:47 - very frequently
199:49 - in many other data structures
199:51 - which involves the array internally
199:53 - so friends i hope you like this video
199:55 - thanks have a nice day
199:59 - hello everyone
200:01 - so in this video we will be looking into a problem
200:03 - find the missing number
200:05 - in an array
200:09 - so here let's suppose we are given an array
200:11 - having n-1
200:13 - distinct numbers
200:15 - and basically in the range of
200:17 - 1 to n
200:19 - we need to find the missing number in it
200:23 - so it is a very famous interview question
200:25 - where you will see
200:27 - that we are given with
200:29 - numbers from 1 to n
200:31 - so this n could be
200:33 - let's say we are given with this array
200:35 - here you can see
200:37 - that there are 7
200:39 - numbers
200:43 - ranging from index 0 to 6
200:45 - so it is basically
200:47 - the array.length which is 7
200:49 - and here you can see
200:51 - the range is from 1 to
200:53 - n
200:55 - so here you can see in these 7 numbers
200:57 - we are given a range from 1 to
200:59 - 8
201:01 - and 1 number is missing in this
201:03 - so we need to find that number
201:05 - so for example here you can see 1 is present
201:07 - 2 is present
201:09 - 3 is present
201:11 - 5 is not present
201:13 - 6, 7 and 8
201:15 - are present
201:17 - so basically we are given n-1
201:19 - distinct numbers which you can
201:21 - see here
201:23 - and 1 to n is the range
201:25 - so here it is from
201:27 - 1 to 8
201:29 - so here n is 8
201:31 - and in the array we are provided
201:33 - with n-1
201:35 - which is 7 numbers
201:37 - so we need to find 1 missing number
201:39 - so here the output would be 5
201:41 - so this is the missing number from
201:43 - range 1 to 8 which we can
201:45 - see in the array
201:47 - so let's see how we can solve this problem
201:49 - so one constraint is we need to
201:51 - find it in O of n
201:53 - time complexity
201:55 - so let's see how we can find the missing number
201:57 - in this array
201:59 - so here you can see
202:01 - there is one mathematical
202:03 - formula which can help
202:05 - us in evaluating
202:07 - what's the missing number in the array
202:11 - so the mathematical formula
202:13 - is something like the sum of
202:15 - first n natural numbers
202:17 - which is 1 plus 2 plus 3
202:19 - plus 4 till n
202:21 - is given by this formula
202:23 - that we simply do n
202:25 - into n plus 1 by 2
202:27 - so for example if we want to do
202:29 - sum of first 4 natural
202:31 - numbers so we can do
202:33 - 4 into
202:35 - 4 plus 1
202:37 - by 2
202:39 - so this will give us 4 into
202:41 - 5 by 2
202:43 - which is 20
202:45 - by 2
202:47 - which will be equal to 10
202:49 - so here you can see 1 plus 2 will give 3
202:51 - 3 plus 3 is 6
202:53 - 6 plus 4 is 10
202:55 - so this is the formula
202:57 - which help us in evaluating the sum of first
202:59 - n natural numbers
203:01 - so we will use this formula
203:06 - and find the missing number
203:08 - in the array
203:10 - so for example let's suppose we are given
203:12 - with this 4 numbers
203:14 - so if we do array.length
203:16 - we will get 4 numbers
203:20 - and as we are getting 4 numbers
203:22 - the range will be from
203:24 - 1 to 5
203:27 - so here you can see
203:29 - the 4 numbers are 1, 2, 3 and 5
203:32 - so the missing number is
203:34 - actually 4
203:36 - so now how we can find the missing number is
203:38 - first
203:40 - the number of elements are 4
203:42 - which are present in the array
203:44 - we do plus 1 to it
203:46 - so 5 will be the actual final range
203:48 - so what we will do here is
203:50 - we will use this formula
203:52 - to calculate the sum
203:54 - so we will get 5 into
203:56 - 5 plus 1
203:58 - by 2
204:01 - so this will give us
204:03 - 30 by 2
204:05 - 15
204:07 - so the sum of first
204:09 - 5 natural number is 15
204:11 - and in order to find the missing number
204:13 - what we will do is
204:15 - we will iterate this array 1 by 1
204:17 - we will pick each element
204:19 - and we will simply subtract it from the
204:21 - sum
204:23 - and after subtracting all the elements
204:25 - whatever number will be left
204:27 - that will be our answer
204:29 - this is the sum of first
204:31 - 5 natural numbers
204:33 - and if we are subtracting
204:35 - 4 numbers from it
204:37 - the left over sum would be
204:39 - our missing number
204:41 - so for example
204:43 - first we encounter 1
204:45 - so we do 15 minus 1
204:47 - we get 14
204:49 - then we encounter 2
204:51 - so we do 14 minus 2
204:53 - we get 12
204:55 - then we encounter 3
204:57 - so we get 12 minus 3
204:59 - 9
205:01 - and then we encounter 5
205:03 - so we do 9 minus 5
205:05 - which will give us 4
205:07 - so this 4 will be our answer
205:09 - so here you can see
205:11 - that this formula is very helpful
205:13 - in many coding problems
205:15 - and this is one such problem
205:17 - so here
205:24 - the missing number is 4
205:27 - which we just evaluated
205:29 - using this mathematical formula
205:31 - now lets move ahead and see
205:33 - the algorithm for it
205:35 - so here you can see the algorithm is very simple
205:37 - so lets see the demonstration
205:39 - of this algorithm step by step
205:41 - using this array
205:43 - so before we start
205:45 - in case if you are new to my channel
205:47 - then please subscribe to my channel
205:49 - and click the bell icon
205:51 - so that you never miss any update
205:53 - so lets say we call
205:55 - find missing number method
205:57 - with this array
205:59 - and here you can see
206:01 - the size of this array or the length of this array
206:03 - is 7
206:05 - ranging from index 0 to 6
206:07 - so if length is 7
206:09 - we know that the range would be
206:11 - from 1 to 8
206:13 - and we need to find one missing number in it
206:15 - so first we evaluate
206:17 - total number
206:19 - of elements present in the range
206:21 - so if we do array.length
206:23 - we will get the numbers present in this array
206:25 - and if we do plus 1
206:27 - because this array doesn't have that number
206:29 - which we need to find
206:31 - so we simply add 1
206:33 - so n will be 8
206:37 - and now we will use the formula
206:39 - and calculate the sum
206:41 - so it will be 8
206:43 - into 8 plus 1
206:45 - by 2
206:47 - it will give us
206:49 - 8 into 9
206:51 - by 2
206:53 - which is 9 into 4
206:55 - which is 36
206:57 - so sum will be 36
207:01 - and now we will iterate
207:03 - the array 1 by 1
207:05 - using this for loop
207:07 - and inside this for loop we will
207:09 - subtract each number
207:11 - from the sum
207:13 - and at the end whatever the sum is left
207:15 - that will be our answer
207:17 - so lets see how
207:19 - first we get number 2
207:25 - when we subtract 2 from sum
207:27 - sum becomes 34
207:31 - then number becomes 4
207:37 - 34 minus 4 will give 30
207:43 - then number will become 1
207:49 - 20 minus 1 will give 29
207:55 - then number will become 8
208:01 - 29 minus 8 will give 21
208:09 - we encounter 6
208:15 - 21 minus 6 will give 15
208:19 - now number becomes 3
208:23 - 15 minus 3 gives 12
208:33 - and at the last number becomes 7
208:39 - so 12 minus 7 will give 5
208:45 - and then this for loop will end
208:49 - and whatever the value is left in the sum
208:51 - that will be our missing number
208:53 - so here you can see 1 is there
208:55 - 2 is there
208:57 - 3 is there
208:59 - 4 is there
209:01 - 5 is not there
209:03 - 6, 7 and 8 are there
209:05 - so at the end we will simply return 5
209:07 - so this question is frequently asked in the coding interviews
209:11 - and if you come up with this formula
209:15 - and in particular
209:18 - n into n plus 1 by 2
209:20 - which is sum of first and natural numbers
209:24 - then you can easily figure out what is the missing number
209:28 - so friend this was all about this question
209:31 - I hope you must have liked this video
209:33 - in case if you are new to my channel
209:35 - then please subscribe to my channel
209:37 - and click the bell icon
209:39 - so that you never miss any update
209:41 - thanks have a nice day
209:45 - hello everyone
209:46 - so in our previous video
209:48 - we saw an animation
209:50 - to find the missing number in an array
209:52 - where we were given
209:54 - an array having
209:56 - elements from 1 to n
209:58 - and in that one element was missing
210:00 - so our task was to find that missing number
210:04 - so in our previous video
210:06 - we actually saw the demonstration of this algorithm step by step
210:09 - so now in this video we will actually
210:11 - code the algorithm
210:13 - and we will test its working in the main method
210:15 - so here in our arrayutil class
210:19 - here I will be creating one method as public
210:23 - static
210:28 - let's say we give the method name as find
210:33 - missing number
210:37 - so this method takes in an array
210:42 - and it returns the missing number
210:45 - so the return type is int
210:49 - so here assuming the array is proper
210:51 - and it has various elements
210:53 - which are ranging from 1 to n
210:55 - and there is guaranteed one number is missing
210:57 - in the array
210:59 - and we need to find that missing number
211:02 - so at the start we first evaluate
211:04 - the value of n
211:07 - which is the last number of our range
211:09 - from 1 to n
211:11 - so that is evaluated using array.length
211:15 - so this will give us the length of the array
211:17 - and it has one missing number
211:20 - so we will do plus 1 to get the last number
211:23 - of the range
211:25 - and after knowing the value of n
211:27 - what we will do is
211:29 - we will use the mathematical formula
211:31 - to calculate the sum of first and natural numbers
211:35 - so here int sum
211:38 - we will use the formula as n
211:41 - into
211:43 - n plus 1
211:47 - by 2
211:49 - so after evaluating the sum of first and natural numbers
211:52 - what we will do
211:54 - we will iterate
211:57 - the array 1 by 1
212:01 - and as we need to find the missing number
212:04 - what we can do is we can subtract
212:06 - each element from the sum
212:09 - and whatever the sum will be left
212:11 - that will be our final answer because
212:13 - this formula
212:15 - is giving us sum of first and natural numbers
212:18 - and among those first and natural numbers
212:21 - in the array we have n minus 1 numbers
212:24 - so if we subtract n minus 1
212:26 - from the sum
212:28 - we will be left with the missing number
212:31 - so here we simply do
212:33 - sum equals
212:35 - sum minus number
212:38 - and after this for loop
212:40 - we will simply return
212:42 - the remaining sum
212:44 - which will be our missing number
212:46 - so now lets test its working in the main method
212:49 - here we are given with an array
212:51 - so here you can see
212:53 - the length of the array is 7
212:55 - but the range is from 1 to 8
212:59 - and we need to find the missing number
213:04 - so we will call find missing number
213:08 - we pass in the array
213:12 - and if i run the main method
213:19 - so here you can see
213:21 - it actually returned number 5
213:23 - from this method it means
213:25 - 5 was the number which was actually missing
213:27 - so here you can see 1 is there
213:29 - 2 is there, 3 is there
213:31 - 4 is there
213:33 - 5 is not there
213:35 - 6, 7 and 8 are there
213:40 - so friend this problem is asked
213:42 - in many coding interviews
213:44 - where we can use
213:46 - 1 single for loop
213:48 - and this mathematical formula
213:50 - to evaluate the missing number
213:52 - from the range 1 to n
213:56 - i hope you must have liked this video
213:58 - in case if you are new to my channel
214:00 - then please subscribe to my channel
214:02 - and click the bell icon
214:04 - so that you never miss any update
214:06 - thanks have a nice day
214:12 - hello everyone
214:14 - so friends in this lecture we will discuss
214:18 - that how we can check that a given string
214:20 - is a palindrome or not
214:25 - so friends what is a palindrome string
214:28 - so a palindrome string is a string
214:31 - when we do reverse of it
214:33 - and compare it with the original string
214:35 - they both are same
214:38 - so for example let's say we are given a string
214:40 - madam
214:42 - so if we read this string in forward direction
214:45 - we get
214:47 - m-a-d-a-m
214:49 - madam
214:51 - and if we read it from backward
214:53 - we get m-a-d-a-m
214:55 - which is the same
214:57 - so therefore this string is a palindrome string
215:00 - so let's say we are given a method
215:02 - in which we are passing a string
215:04 - it should return true
215:06 - if the string is palindrome
215:08 - or it should return false
215:10 - if the string is not palindrome
215:13 - so friends in second example you can see
215:15 - that we are given a string that
215:18 - if we read it in forward direction
215:20 - we get t-h-a-t
215:22 - and if we read it from backward direction
215:24 - we get t-a-h-t
215:27 - so here you can see that if we reverse that
215:30 - and if we compare
215:32 - the reverse string with the original string
215:34 - they are not equal
215:36 - therefore this string is not palindrome
215:39 - so friends let's see the demonstration of the algorithm
215:41 - step by step
215:44 - so here you can see
215:46 - that this is the algorithm
215:48 - where we are calling the method as palindrome
215:51 - and we are passing in a string
215:53 - and if the string is palindrome or not
215:55 - we are simply returning a boolean value
215:58 - that if a string is palindrome
216:00 - we return true
216:02 - and if it is not then we return false
216:06 - so let's say we call this palindrome method
216:08 - and we pass a string as madam
216:11 - so by looks of it you can see that
216:13 - madam is a palindrome string
216:15 - because if we reverse madam
216:18 - and compare it with the original string
216:20 - they both are equal
216:22 - so let's see how we can figure it out
216:24 - that whether madam is a palindrome or not
216:31 - so string word
216:33 - will hold the value as madam
216:38 - so friends in this algorithm what we do
216:40 - we take two pointers
216:44 - one we place at the start
216:46 - and other we place at the end
216:48 - and we just compare these two characters
216:50 - and if they are same
216:52 - then we move first pointer ahead
216:54 - and the last pointer backward
216:57 - and then we compare the second character
216:59 - with the second last character
217:01 - and if they are equal
217:03 - then we simply move ahead the first pointer
217:06 - and move backward the last pointer
217:09 - and similarly we keep on checking
217:11 - the value stored at these two pointers
217:14 - and if anytime these values are not equal
217:16 - we can come to know that
217:18 - the string is not a palindrome string
217:21 - so friends here in order to compare
217:24 - this string character by character
217:26 - we first convert this
217:28 - string to char array
217:30 - so in java string
217:32 - has this method to char array
217:34 - which returns a character array
217:37 - so it would look something like this
217:40 - the character array will store
217:42 - one one character at each index
217:46 - and it is in form of an array
217:48 - moving ahead
217:51 - so we will initialize the first pointer
217:54 - we will give it a name as start
217:56 - and it will start from the zeroth index
217:59 - so value of start is zero
218:04 - and we will also initialize an end pointer
218:07 - whose value will be word dot length minus one
218:10 - so here on a string if we do word dot length
218:12 - we get the length of the string
218:15 - so here we will get the length of the string as five
218:18 - because there are five characters
218:20 - and when we do minus one
218:22 - it simply means that this pointer
218:24 - will point to the last index
218:28 - so end value will be four
218:30 - five minus one will give four
218:35 - so friends we have got our two pointers
218:37 - and one is at start
218:39 - and other is at end
218:41 - now we will start comparing
218:43 - the character stored at start index
218:45 - and the end index
218:47 - using this while loop
218:50 - so this while loop will run
218:52 - till start is less than end
218:54 - so if the start becomes equal to
218:56 - end or more than end
218:58 - then we know that we have traversed this complete string
219:02 - so currently you can see
219:04 - that start value is zero and end value is four
219:07 - so therefore the condition while loop comes out to be true
219:13 - so friends we know the palindrome property
219:15 - that if we read the string in forward direction
219:17 - and if we read the string in backward direction
219:20 - both the string should be equal
219:23 - so friends means the first character
219:25 - should be equal to the last character
219:28 - second character should be equal to second last character
219:32 - and it should go on till we reach a midpoint
219:36 - and if any of these characters are not equal
219:39 - then we can come to know that
219:41 - string is not palindrome string
219:43 - so here we are comparing
219:45 - the character stored at start index
219:48 - and character stored at the end index
219:50 - so which is
219:54 - these two characters
219:56 - and we are checking that whether they are equal or not
220:00 - so if they are not equal we can straight away written false
220:03 - that string is not palindrome string
220:05 - but here if you see m is equal to m
220:07 - therefore the condition in if block comes out to be false
220:14 - so we have compared the first
220:16 - and the last character
220:19 - now we will proceed ahead to compare
220:21 - second character with second last character
220:24 - so for that what we need to do is
220:26 - we need to increment start
220:28 - and decrement end by one
220:31 - so here we will increment start by one
220:33 - so start will become one
220:38 - and then we will decrement end by one
220:40 - so end becomes three
220:44 - we check whether start is less than end or not
220:47 - so one is less than three
220:49 - therefore condition in while block comes out to be true
220:56 - and here we simply check that whether character stored at start index
220:59 - and character stored at end index
221:01 - are equal or not
221:05 - so as value of start is one
221:07 - it will point to this character
221:10 - and end is three
221:12 - so it will point to this character
221:15 - so we are simply comparing this character with this
221:18 - and here we know that these two characters are equal
221:21 - therefore the condition in if block comes out to be false
221:28 - and then we will simply increment start by one
221:31 - and decrement end by one
221:34 - so start becomes two
221:38 - and end becomes two
221:43 - so here we can see start and end
221:45 - will point to index two which is D
221:48 - and this is the only index left now
221:52 - and if we check whether start is less than end
221:54 - so here we can see two is not less than two
221:56 - therefore condition in while block comes out to be false
222:00 - and we don't compare this
222:02 - because even if we compare D with D
222:05 - we know that those are equal
222:08 - but as this is the only character left
222:11 - if we read the string from this point
222:13 - or if we read the string from this point
222:15 - this character will be at the same position
222:18 - so therefore we never check
222:20 - for start equal to end
222:22 - we simply do start should be less than end
222:27 - so here condition in while block comes out to be false
222:30 - and while loop terminates
222:32 - and as soon as while loop terminates
222:34 - if our execution point reaches here
222:36 - we know that the string is palindrome
222:40 - because we have compared
222:42 - every character from start to end
222:46 - so we finally return true
222:49 - therefore string madam is a palindrome string
222:57 - so for now let's see whether that
222:59 - is a palindrome string or not
223:02 - so here we call this palindrome method
223:06 - providing a string as that
223:11 - we will convert this string to character array
223:15 - by calling 2 char array method
223:17 - so it would look something like this
223:20 - let's set character array
223:22 - having length as 4 storing each character
223:25 - in each of the index of this array
223:29 - moving ahead
223:31 - we again create two pointers
223:33 - one starts from the beginning
223:35 - and other starts from the end
223:37 - so we create two integer variables
223:39 - start will give it a value as 0
223:47 - and we create integer variable end
223:49 - which points to the last index
223:52 - and in order to get the last index
223:54 - we do word dot length minus 1
223:56 - so word dot length is the length of the string
223:59 - which is 4
224:00 - if we do minus 1 we get the third index
224:02 - which is this
224:05 - so end becomes 3
224:08 - moving ahead
224:10 - we see whether start is less than end or not
224:13 - so here we can see 0 is less than 3
224:15 - so condition in while block comes out to be true
224:21 - so now we compare
224:23 - the value at start index
224:25 - and the value at end index
224:30 - which is these two characters
224:33 - and we check whether they are equal to or not
224:36 - so if they are not equal
224:38 - then we can simply return false
224:40 - though string is not palindrome
224:42 - but here you can see
224:44 - t is equal to t
224:46 - therefore condition in if block comes out to be false
224:53 - so now we move start pointer a step ahead
224:56 - and we move end pointer a step backward
225:00 - and then we will compare
225:02 - these two characters
225:04 - so start becomes 1
225:07 - and end becomes 2
225:12 - so we check whether start is less than end or not
225:14 - so here we can see
225:16 - 1 is less than 2
225:17 - so the condition in while block comes out to be true
225:23 - and then we will simply compare the value
225:26 - stored at the start index
225:28 - with end index
225:30 - so here you can see
225:32 - that h is not equal to a
225:34 - which means the condition in if block comes out to be true
225:38 - and we come to know that string is not a palindrome string
225:40 - because this should have been equal
225:42 - to make it a palindrome string
225:44 - but here h is not equal to a
225:46 - therefore condition in if block comes out to be true
225:50 - so finally
225:52 - we return false
225:54 - from this point
225:56 - that string is not true
225:58 - from this point
226:00 - that string is not a palindrome string
226:04 - so in this lecture we saw
226:06 - that how we can check
226:08 - that whether a given string is a palindrome or not
226:10 - we saw the demonstration of algorithm step by step
226:14 - now lets go to eclipse
226:16 - and see the working of this code
226:18 - I hope you like this video
226:20 - thanks have a nice day
226:22 - hello everyone
226:24 - so friends in our last lecture we saw
226:26 - that how we can check
226:28 - that whether a given string is a palindrome or not
226:30 - we saw the algorithm
226:32 - using an animation
226:34 - so in this lecture we will actually code the algorithm
226:36 - and we will test its working
226:38 - in main method
226:40 - so here I will be creating
226:42 - one method as public
226:44 - and we will test it
226:46 - in main method
226:48 - so here I will be creating one method
226:50 - as public
226:52 - and as we want to check whether a given string
226:54 - is a palindrome or not
226:56 - the method which we are creating
226:58 - should return
227:00 - a boolean value
227:02 - that whether a given string
227:04 - is palindrome or not
227:06 - we also provide the method name
227:08 - as is
227:10 - palindrome
227:16 - and into this method
227:18 - we provide
227:20 - a string
227:22 - lets say we give the name
227:24 - to it as word
227:26 - so friends here we are not seeing
227:28 - any edge cases
227:30 - so in order to check whether the given
227:32 - string is a palindrome or not
227:34 - what we do is
227:36 - we first convert
227:38 - this string to a character array
227:40 - by using the method provided in string class
227:48 - as 2 char array
227:52 - so this method returns a character array
227:56 - so whatever the characters are stored
227:58 - in this string
228:00 - it will be now in form of an array
228:02 - where each index
228:04 - will store one character
228:06 - also friends in last lecture we discussed
228:08 - that we are using two pointers
228:10 - to check whether the string is palindrome or not
228:12 - so one pointer
228:14 - will start from the beginning
228:16 - so to start we are providing a value as 0
228:20 - another pointer
228:22 - will start from the end
228:24 - and to this we provide the value as word.length
228:28 - and then we will provide the value
228:30 - as word.length
228:32 - and in the last lecture
228:34 - So, word dot length minus one will give us the last index.
228:42 - So, now we will start comparing each character at start and end index.
228:49 - So, we will provide a while loop and we will iterate in this while loop till start is less
228:57 - than end.
229:00 - So, inside this while loop, the first step we do is, we check that whether character
229:09 - at start index is equal to character at end index.
229:19 - So, if they are not equal, then we can straight away come to know that string is not a palindrome.
229:24 - So, here we will simply return false because as you are starting comparing first index
229:32 - with the last index to make string palindrome, those two characters should be equal and if
229:39 - they are not, then we can simply return false.
229:41 - So, friend after doing this first comparison, what we do is, we move start a step ahead
229:52 - and we move end a step backward so that after comparing this, we compare the second character
230:00 - with the second last character, then third character with third last character and similarly
230:07 - till start meets end because we are incrementing start and decrementing end.
230:15 - Also friend, here you can see that when the value of start will be equal to end.
230:21 - This while loop will terminate and we know that inside this while loop, we never got
230:26 - any chance that character at start is not equal to character at end.
230:31 - So therefore, once while loop terminates, we can come to know that string is palindrome
230:38 - and will simply return true.
230:40 - So, friend this is the algorithm to check whether a given string is palindrome or not.
230:49 - So let's test its working in main method.
230:52 - So here we will create instance of string util class
231:02 - and here we provide a if condition, we simply check by calling this palindrome method and
231:19 - we pass the value as let's say madam and if it comes out to be true, then we simply
231:27 - print the string is palindrome or else we print
231:48 - the string is not palindrome.
231:52 - So friend if I run the code now, so here you can see it printed the string is palindrome
232:06 - because if we reverse madam and if we compare with the original string, they both are equal.
232:13 - Now friend let's say if I provide the string as that which is not a palindrome string because
232:19 - if we reverse the string, we get t a h t which is not equal to our original string.
232:28 - And if I run the code now, you can see it printed the string is not palindrome.
232:39 - So friend this lecture we wrote the code to check whether a given string is a palindrome
232:43 - or not.
232:44 - We tested its working in main method.
232:48 - I hope you like this video.
232:50 - Thanks have a nice day.
232:54 - Hello friends, welcome to my new data structures and algorithm in Java tutorial series video.
233:00 - Friends in this tutorial we will discuss how to create a singly linked list in Java.
233:08 - So friends here you can see a simple singly linked list.
233:13 - In our previous tutorial we discussed what is a singly linked list.
233:18 - We discussed singly linked list is a data structure which actually stores collection
233:22 - of data.
233:24 - It contains sequence of nodes.
233:27 - So here you can see that there are four nodes having data as 10, 1, 8, 11 and you can also
233:35 - see the first node is being referred by the head.
233:39 - So this head node actually holds complete linked list and it is also the first node
233:45 - of the singly linked list.
233:48 - And you can also see the last node whose next always points to null because it signifies
233:52 - that it is the end of the list.
233:55 - We also discussed the node is having two properties.
233:57 - One is the data property and one is the reference to the next node in the list.
234:03 - So friends let's see a demo to how to create this singly linked list having the data as
234:08 - 10, 1, 8 and 11.
234:12 - So friends here is the code which can add few nodes in the singly linked list.
234:15 - We will also discuss the other ways to insert the nodes into the singly linked list.
234:22 - So let's see the demo of the code step by step.
234:26 - So friends when we initialize the singly linked list it contains instance variable head which
234:31 - is of type list node and when we initialize the singly linked list usually head points
234:36 - to null because at the initialization of the singly linked list there are no elements into
234:41 - the list.
234:43 - So at first head points to null moving ahead.
234:49 - Now in this step what we do is we first create a new list node and we pass the data into
234:54 - it.
234:55 - So here we are creating a new list node and we are passing the data as 10.
234:59 - So it would look something like this.
235:02 - Here you can see the data is 10 and whenever we create a new list node it next points to
235:07 - null and also here you can see when we are creating this new list node we are assigning
235:13 - its value to the head.
235:15 - So currently head points to null and after this assignment it would look something like
235:19 - this.
235:22 - So now head will point to this first node which is having data as 10 and its next is
235:27 - pointing to null.
235:29 - Moving ahead and in this step we are again creating a new list node and we are assigning
235:38 - its value to the list node by name second.
235:42 - So it would look something like this.
235:46 - That second is pointing to a list node having data as 10 and whose next is pointing to null.
235:52 - Moving ahead now here similarly we are creating third list node having data as 8 and we are
236:00 - naming the variable as third.
236:02 - So it would look something like this.
236:05 - The third is pointing to a node having data as 8 and whose next is pointing to null.
236:10 - Moving ahead and now we are creating a list node having data as 11 and we are assigning
236:18 - its value to a list node by name fourth.
236:24 - So here you can see the list node fourth is having data as 11 and whose next is pointing
236:29 - to null.
236:30 - So this is how a list node is created.
236:32 - We create a list node by passing into data and whose next always points to null.
236:40 - So friends in order to create a singly linked list what we do is like we connect all these
236:45 - four nodes together and form a chain.
236:48 - So this chain is built something like this.
236:51 - We connect first node to second, second to third, third to fourth like that.
236:56 - So in order to achieve this what we do is here we know that head points to a node having
237:00 - data as 10 and whose next is pointing to null.
237:04 - So in order to connect these two nodes what we do is we assign the value of second to
237:10 - heads next.
237:12 - So here you can see second is pointing to node having data as 1 and head next is pointing
237:16 - to null.
237:18 - So if we assign the value of second to heads next.
237:22 - So instead of pointing to null now it will point to second node because second is pointing
237:27 - to this node moving ahead.
237:33 - And now in this step what we do is we assign the value of third to seconds next.
237:38 - So here seconds next is pointing to null and third is pointing to a node having data as
237:43 - 8.
237:44 - So whatever value is in the third we assign it to seconds next.
237:48 - So it would look something like this moving ahead.
237:56 - And in the final step what we do is we assign the value of fourth to thirds next.
238:01 - So this fourth list node is pointing to a node having data as 11 and whose next is pointing
238:05 - to null.
238:07 - So we simply assign the value of fourth to thirds next.
238:10 - So it would look something like this.
238:14 - So now finally the third node is pointing to a node 4.
238:18 - So friends when method ends all these three nodes go away and as head is an instance variable
238:24 - of the singly linked list it is holding this complete list together.
238:30 - So friends let's go to eclipse and see the working code.
238:36 - So friends in our previous tutorial we created a class by name singly linked list.
238:44 - And to this class we provided an instance variable of the type list node by name head.
238:50 - So here the instance variable list node by name head will actually hold the linked list
238:55 - for us.
238:58 - And friends we also created one static inner class list node in our previous tutorial whose
239:04 - constructor only took the data part.
239:08 - So now let's move ahead and create a singly linked list what we actually saw in the slide
239:13 - in the previous tutorial.
239:17 - So we will create a main method.
239:22 - So inside this main method first we will initialize the singly linked list.
239:38 - So friends as soon as we say initialize the singly linked list the value of head is null.
239:47 - So here we will create the four nodes what we actually saw in the slide in the previous
239:50 - tutorial.
239:52 - So to head we will assign newly created list node having data as 10 then we will create
240:07 - a second list node having data as 1 then we will create a third list node having data
240:28 - as 8 and finally we will create a fourth list node having data as 11.
240:47 - So friends here we are having four nodes.
240:53 - Now we will connect them together to form a chain which is nothing but our singly linked
241:05 - list.
241:07 - So in order to form a chain we will first assign the value of second to heads next because
241:12 - currently head next is pointing to null.
241:16 - So
241:27 - so this would make structure something like this.
241:34 - Moving ahead we will connect second with third by assigning value of third to second next.
241:45 - So it would make structure something like this.
241:54 - And finally we will assign the value of fourth to thirds next in order to connect third and
241:58 - fourth.
241:59 - So third next will assign the value of fourth to it.
242:08 - So it would make structure something like this.
242:21 - So here you can see that we have connected all these four nodes together.
242:27 - So it would look something like this that 10 is pointing to 1, 1 is pointing to 8, 8
242:32 - is pointing to 11 and finally 11 next is pointing to null because there are no more
242:39 - nodes we have attached to this fourth node.
242:42 - So friends this is how we connect the nodes of a singly linked list together.
242:47 - In our upcoming tutorial we will discuss a more generic way to insert the node into singly
242:52 - linked list.
242:55 - I hope you like this video.
242:56 - Thanks have a nice day.
243:00 - Hello friends welcome to my new data structures and algorithm in Java tutorial series video.
243:06 - Friends in this tutorial we will discuss how to print elements of a singly linked list
243:11 - in Java.
243:14 - So friends let's suppose we are given the singly linked list having four nodes with
243:18 - the data as 10, 1, 8 and 11.
243:23 - So in this tutorial we will discuss how we can print the data of the elements of the
243:26 - singly linked list.
243:29 - So below you can see the algorithm of it.
243:34 - So currently in the console you will see no output.
243:38 - So let's see the demonstration of this algorithm step by step.
243:44 - Now on the first step what we do is in order to print the elements of the singly linked
243:49 - list we need to traverse each and every node one by one and we are given the head node
243:56 - which is the first node of the singly linked list.
243:58 - So we actually start traversing from this first node only.
244:03 - So in order to start traversing from this head node what we do is we temporarily create
244:07 - a list node which points to this head node.
244:11 - So the name of this list node is current and we assign the value of head to it.
244:16 - So it would look something like this that we are having a list node by name current
244:22 - and it is pointing to head.
244:25 - Moving ahead.
244:27 - Now in this algorithm we encounter a while loop and in while loop we place a condition
244:32 - that whether current is equal to null or not.
244:37 - So why we put this condition because once current is equal to null we come to know that
244:41 - we have traversed the list completely.
244:45 - So therefore we come to know that there are no more elements left to be traversed.
244:50 - So initially now as current is pointing to this first node we know that it is not null.
244:56 - So therefore condition in while loop comes out to be true and the code inside the while
245:00 - loop executes.
245:08 - So the first step what we do is we simply print the data associated with this current
245:12 - node.
245:14 - So it would look something like this.
245:18 - The data associated with this current node is 10.
245:23 - Moving ahead.
245:28 - So friend as we have traversed this node now it's time to move to the next node.
245:34 - So in order to move to next node what we do is.
245:38 - So friend if we assign the current next value to current what will happen is as current
245:42 - is pointing to this first node having data as 10 now it will point to the second node
245:47 - having data as 1.
245:50 - So here simply what we are doing is current next is pointing to second node and this
245:54 - value we are assigning to current itself.
245:58 - So it would look something like this.
246:04 - By this assignment we are simply traversing current to its next by assigning current next
246:08 - value to current.
246:13 - Moving ahead we again check whether current is equal to null or not.
246:19 - So here you can see as current is pointing to second node it is not equal to null.
246:23 - So the condition in while loop comes out to be true.
246:28 - And we simply print current data on the console.
246:31 - So current's data is nothing but 1.
246:35 - So it would look something like this.
246:39 - Moving ahead.
246:43 - So friend as we have not traversed the second node now we need to move to the third node.
246:49 - So the only way to move to third node is current's next because current next is pointing to this
246:53 - third node.
246:55 - So if we assign current next value to current current will now point to the node having
246:59 - data as 8.
247:02 - So it would look something like this.
247:08 - Moving ahead.
247:12 - So friends here again current is pointing to node having data as 8.
247:15 - So it is not equal to null.
247:18 - Therefore the condition in while loop comes out to be true.
247:24 - And then we simply print the data associated with this current node which is nothing but
247:28 - 8.
247:30 - Moving ahead.
247:35 - Now we simply assign the value of current next to current to traverse to the fourth
247:39 - node.
247:41 - So it would look something like this.
247:47 - Moving ahead.
247:49 - Now again we know that current is not equal to null because it is pointing to a node having
247:53 - data as 11.
247:55 - So therefore the condition in while block comes out to be true.
248:01 - We then print the data associated with this current node which is nothing but 11.
248:09 - Moving ahead.
248:14 - And then we simply traverse current to its next.
248:17 - So current is pointing to this fourth node and its next is pointing to null.
248:21 - So we simply assign the value of current next which is null to current.
248:25 - So it would look something like this.
248:31 - Moving ahead.
248:34 - So friends we already know that the list is traverse completely and we have printed all
248:40 - the nodes of the singly link list.
248:43 - So now the current is pointing to null.
248:45 - So in the while loop we check whether current is equal to null or not.
248:48 - So here you can see current is equal to null.
248:51 - So the condition in while block comes out to be false.
248:55 - And we know that when this condition comes out to be false the list is completely traversed.
249:01 - So now the statement in the while loop doesn't execute.
249:07 - And in the last step we simply print null.
249:13 - So on the console it will print something like 10 is pointing to 1, 1 is pointing to
249:18 - 8, 8 is pointing to 11 and 11 is pointing to null stating that after 11 there are no
249:23 - more nodes.
249:28 - So friends this is the algorithm to demonstrate how to print the elements of a singly link
249:32 - list.
249:33 - Now let's go to Eclipse and see the working code.
249:39 - Hello friends in our previous tutorials we have actually created this class by name singly
249:44 - link list.
249:46 - We also created a list node class.
249:49 - And in our previous tutorials we also created 4 nodes and we connected them together.
249:55 - So here they are connected in the form as 10 is pointing to 1, 1 is pointing to 8, 8
250:00 - is pointing to 11 and 11 is pointing to null.
250:03 - Because here what we have done is head next is pointing to second, second next is pointing
250:08 - to third and third next is pointing to fourth.
250:12 - So in this way they are connected to each other.
250:15 - And in this tutorial we will write the code which will actually demonstrate how to print
250:19 - the elements of a singly link list on the console.
250:23 - So here first we will create a method as public void.
250:27 - We will give the name of the method as display.
250:35 - Because it will be printing the elements of a singly link list on the console.
250:40 - So friends in our previous tutorials we actually saw the animation of this algorithm.
250:44 - So here now we will code this algorithm.
250:47 - So first we will create a temporary node by name current.
250:55 - And we will assign the value of head to it.
251:00 - And then we actually saw in the animation slide there was a while loop into which condition
251:09 - was that we were checking whether current is equal to null or not.
251:15 - So if the current was not equal to null we were printing the current's data on the console
251:20 - and then we are traversing the current to its next.
251:25 - So here we will print current's data on the console and then we will simply traverse
251:44 - current to its next by assigning current next value to current.
251:57 - And once the current is pointing to null we know that we have reached to the end of the
252:01 - singly link list.
252:02 - So there are no more nodes left to be traversed.
252:05 - So in the final step we will simply print value as null.
252:16 - So friends here we have already connected these 4 nodes together.
252:19 - Now let's test that whether they are actually connected or not.
252:24 - So we will simply call this display method and we will run the code.
252:36 - So friends here you can see it printed 10, 1, 8 and 11 because this head is having data
252:43 - as 10 and it is pointing to second node whose data is 1 and second is pointing to the third
252:49 - node having data as 8 and 8 is pointing to the fourth node having data as 11.
252:54 - And finally fourth next is null so therefore it printed null over here.
253:00 - So friends this is how we actually print the elements of the singly link list on the console
253:04 - by traversing one node at a time.
253:08 - I hope you like this video.
253:09 - Thanks have a nice day.
253:13 - Hello friends welcome to my new data structures and algorithms in java tutorial series video.
253:19 - In this tutorial we will discuss how to find length of a singly link list in java.
253:27 - So friends let's suppose we are given a singly link list having 4 nodes with data as 10,
253:32 - 1, 8, 11.
253:36 - Now in this singly link list head is pointing to the first node and as you can see the last
253:41 - node is pointing to null and we also know there are 4 nodes into this singly link list.
253:47 - So in order to find the length of this singly link list below is the algorithm for it.
253:53 - So let's see the demonstration of this algorithm step by step.
253:58 - So in the first step what we will do we will create an integer variable count which will
254:03 - hold the actual count of the number of nodes in the singly link list.
254:07 - So friends initially the value of count will be 0.
254:11 - So it would look something like this moving ahead.
254:18 - So friends now we will define a list node by name current which will point to the head.
254:24 - So it would look something like this that as head is pointing to this first node now
254:28 - current will also point to the first node moving ahead.
254:35 - So friends in order to find the length of this singly link list we need to traverse
254:39 - each node one by one and we need to increment the count by one.
254:45 - So friends in order to traverse each node one by one we will provide a while loop and
254:49 - in while loop we will provide a condition that current is not equal to null.
254:55 - So when the current is equal to null we can come to know that list has reached its end
254:58 - and there are no more nodes left to be traversed.
255:02 - So here you can see current is pointing to this first node therefore it is not equal
255:07 - to null therefore the condition in while block comes out to be true.
255:14 - So in the first step what we will do is increment the value of count by one moving ahead.
255:27 - So friends as current is pointing to first node so we have already counted this node.
255:32 - So now it is time to move to its next node.
255:35 - So here you can see current is pointing to this first node and current next is pointing
255:40 - to the second node.
255:42 - So in order to traverse current to its next node what we will do is simply assign the
255:46 - value of current dot next to current.
255:50 - So it would look something like this.
255:58 - So friends here we simply assign the value of current next to current.
256:02 - So therefore now current is pointing to the second node having data as one moving ahead.
256:10 - So now we will again check whether current is equal to null or not.
256:13 - So here you can see this current is pointing to the second node having data as one therefore
256:18 - it is not equal to null.
256:21 - So the condition in while block comes out to be true.
256:26 - In the first step we will simply increment the count by one moving ahead and as we have
256:37 - traversed this node now it is time to move to its next node.
256:41 - So here you can see current is pointing to the second node and its next is pointing to
256:47 - this third node.
256:49 - So in order to make current traverse to this third node what we will do is simply assign
256:53 - the value of current dot next to current.
256:56 - So current dot next is pointing to third node therefore we will assign this value to
256:59 - current.
257:00 - So it would look something like this.
257:03 - We will now again check whether current is equal to null or not.
257:11 - So as current is pointing to its third node therefore its not equal to null.
257:18 - We will again increment the count by one and then we will simply move current to its
257:29 - next node by assigning current dot next value to current.
257:33 - So it would look something like this.
257:40 - Now again current is not equal to null therefore condition in while block comes out to be true.
257:46 - We will increment the count by one and then we will simply traverse current to its next
258:00 - node by assigning current dot next value to current.
258:04 - So here you can see current is pointing to its last node and its next is pointing to
258:08 - null and as we are assigning current dot next value to current therefore now current will
258:14 - point to null.
258:15 - So it would look something like this.
258:17 - We will check whether current is equal to null or not.
258:25 - So here you can see now current is equal to null therefore condition in while block comes
258:29 - out to be false and we also know that we have reached to the end of the singly linked list.
258:36 - So now there are no more nodes left to be traversed.
258:40 - So in the final step we will simply return the value of count which is nothing but four
258:46 - and we also know there are four nodes one two three and four.
258:51 - So friends let's go to eclipse and see the working of this algorithm.
258:57 - So friends in our previous tutorial we created one class by name singly linked list.
259:04 - So this class demonstrated how we can implement a singly linked list in Java.
259:08 - We also created one display method which actually printed the singly linked list on
259:13 - the console and in the main method we also created few nodes what we actually saw in
259:19 - the slide.
259:21 - So if I run the code now.
259:29 - So you can see the singly linked list has four nodes with the values 10 1 8 11 and finally
259:37 - its points to null.
259:38 - So there are four nodes in a singly linked list.
259:42 - So friend in order to find the length of the singly linked list we will first create a
259:46 - method and we will give it a name as length.
259:59 - So this length method will return an integer value which will be nothing but the count
260:03 - of the number of nodes in the singly linked list.
260:07 - So in the first step what we will do we will provide a condition and here we will check
260:12 - that if head is equal to null then we will simply return 0 because in a singly linked
260:19 - list if head is pointing to null then we can come to know that the singly linked list is
260:23 - empty.
260:25 - Moving ahead we will create an integer variable count and we will assign a value of 0 to it.
260:34 - So this count variable will be actually holding the value of number of nodes in the singly
260:38 - linked list.
260:40 - Moving ahead we will create a list node by name current and we will assign the value
260:49 - of head to it.
260:51 - So the current is pointing to head node and then in order to traverse each and every node
260:58 - of a singly linked list we will provide a while loop and inside this while loop we will
261:04 - provide a condition that if current is not equal to null so if current is not equal to
261:10 - null we know that there are nodes in the singly linked list and if current is equal to null
261:14 - then we can come to know that we have reached the end of the singly linked list.
261:19 - So in the first step we will increment the value of count by 1 because as we are in the
261:24 - while loop we are actually traversing a particular node of a singly linked list so we are incrementing
261:30 - the count by 1 and after incrementing the count by 1 we will simply traverse current
261:38 - to its next node by assigning the value of current dot next to current and finally when
261:46 - current is equal to null we know that we already traversed this singly linked list completely
261:51 - and there are no more nodes left to be traversed.
261:54 - So we will simply return the value of count.
261:59 - So friends in the main method let's test the working of this length method.
262:05 - So here we will simply print the value of length.
262:17 - We will call the length method and if I run the code so friends here you can see that
262:33 - we had a singly linked list with the 4 nodes 10, 1, 8, 11 and finally we printed the length
262:40 - of the singly linked list which is nothing but 4.
262:44 - So friends in this tutorial we saw how we can find the length of a singly linked list
262:48 - in Java.
262:49 - I hope you like this video thanks have a nice day.
262:54 - Hello friends welcome to my new data structures and algorithms in Java tutorial series video.
263:00 - Friends in this tutorial we will discuss how to insert node at the beginning of a singly
263:04 - linked list in Java.
263:08 - So friends here you can see below is the algorithm to insert a node at the beginning of a singly
263:12 - linked list in Java.
263:15 - Friends let's suppose initially singly linked list is empty therefore when singly linked
263:20 - list is empty we know that head points to null because there are no nodes into the singly
263:25 - linked list.
263:29 - So friends let's suppose you want to insert a node into a singly linked list whose data
263:33 - is 11.
263:34 - So we pass in a value to this method let's say 11.
263:38 - Now we want to insert this node at the beginning of a singly linked list.
263:43 - So here is the algorithm for it.
263:46 - So let's see the demonstration of this algorithm step by step.
263:50 - So when we call this method we pass in the value as 11.
263:55 - So friends as you want to insert this node at the beginning of a singly linked list what
263:59 - we do is first we actually create this new node and in our previous tutorial we also
264:04 - saw that how we can create a new list node.
264:07 - Actually create a new list node by passing in the value into the constructor.
264:12 - So here a new list node will be created by name new node whose value will be 11.
264:19 - So it would look something like this.
264:23 - So here you can see the new node is pointing to this list node whose data is 11 and whose
264:28 - next is pointing to null.
264:31 - So friends now we want to insert this new node to the beginning of the singly linked
264:35 - list where currently head is pointing to null.
264:39 - So in the next step so friends as you want to insert this new node to the beginning of
264:45 - this singly linked list we know that head always points to first node and if you want
264:50 - to insert the node to the beginning then we are inserting the node just before the head.
264:57 - So in the first step what we do is currently new node next points to null.
265:01 - We assign the value of head to new nodes next.
265:05 - So it would look something like this.
265:09 - That as head is pointing to null new node next is also pointing to null and friends
265:14 - here you can see as head is the first node we are inserting it just before that.
265:20 - So in order to insert this node just before the head we have to point new node next to
265:24 - head moving ahead.
265:30 - So in the last step what we do is as we have inserted this node at the beginning of the
265:33 - singly linked list we know that now head should point to this node because we know that head
265:38 - points to the first node of a singly linked list.
265:42 - So we simply assign the value of new node to head.
265:45 - So currently head points to null and new node points to this list node.
265:50 - So therefore now head will point to this list node.
265:53 - So it would look something like this.
266:00 - So friend after we have inserted this new list node to the beginning of this singly
266:03 - linked list.
266:05 - Now our singly linked list has this one node.
266:07 - Now let's suppose we want to insert one more node having value as head.
266:13 - So we call this algorithm again.
266:16 - In the first step we simply create a new list node by passing in the value as head.
266:21 - So it would look something like this.
266:24 - That new node is pointing to a list node having data as head and whose next is pointing to
266:28 - null.
266:29 - So friends now we want to insert this new node at the beginning of this singly linked
266:32 - list.
266:35 - So by that we mean that we want to insert this node just before the head.
266:40 - So in order to insert this new node just before the head there has to be some link between
266:43 - these two.
266:45 - So in the next step what we do is as new node next is pointing to null we simply assign
266:51 - the value of head to new nodes next.
266:54 - So it would look something like this.
266:58 - That new node next now points to head and which also makes sense because we are inserting
267:03 - this new node at the beginning of this singly linked list which is nothing but just before
267:07 - the head.
267:09 - So we are doing a head and the last step what we do is as we have inserted this new
267:14 - node in the beginning head should point to this node.
267:19 - So we simply assign the value of new node to head.
267:22 - So it would look something like this.
267:28 - So friends after we insert this new node having the data as head the linked list has now two
267:33 - nodes and here you can also see that whatever the node is inserted it is now at the beginning
267:39 - of this singly linked list.
267:41 - So friends let's suppose we insert one more node to this singly linked list with the value
267:47 - as 1.
267:49 - So this algorithm again get executed.
267:53 - In the first step we will create a new list node.
267:56 - So it would look something like this.
267:59 - That new node is pointing to a list node having data as 1 and whose next is pointing to null.
268:06 - Using a head as you want to insert this new node at the beginning of this singly linked
268:11 - list we have to make a connection from this node to the head node because we want to insert
268:18 - it just before the head.
268:20 - So what we do is whatever the value is there in the head we simply assign it to new nodes
268:24 - next.
268:26 - So here you can see head is pointing to a node having data as 8 and new nodes next is pointing
268:31 - to null.
268:32 - So now new node next will point to a node having data as 8 moving ahead.
268:42 - And as we have inserted this new node at the beginning of this singly linked list we know
268:47 - that head should point to this node now.
268:50 - So we simply assign the value of new node which is nothing but the node having data
268:53 - as 1 to head.
268:55 - So it would look something like this.
269:02 - So friends here we saw the demonstration of this algorithm by inserting 3 nodes at
269:06 - the beginning of this singly linked list.
269:09 - First we inserted 11 which became the first node of the singly linked list.
269:13 - Then we inserted 8 and then we inserted 1.
269:17 - So friends now let's go to Eclipse and see the working of this code.
269:24 - So friends in our previous tutorial we created one class by name singly linked list and we
269:29 - implemented the singly linked list into this class.
269:33 - We also implemented a display method which was actually printing each and every node
269:38 - of this singly linked list.
269:41 - So friends let's write a method which will insert a node into the beginning of this singly
269:45 - linked list.
269:48 - So first we will create a method insert first.
269:58 - So we have created one method by name insert first because we are inserting this node to
270:03 - the beginning of this singly linked list and this method takes in an integer value which
270:10 - we actually want to provide to the list node which we want to add to the beginning of this
270:14 - singly linked list.
270:16 - So in the first step what we do is we create this list node
270:27 - and to the constructor of list node we pass in the value.
270:32 - So after this step a new node is created.
270:36 - Having data is whatever the value we have passed.
270:40 - So in order to insert this new node to the beginning of the singly linked list what we
270:45 - do is to new nodes next.
270:52 - We provide a value which is stored in the head and in the last step what we do is we
271:00 - simply now point head to this new node.
271:08 - So friends this is the method which insert the node to the beginning of the singly linked
271:12 - list.
271:13 - Now let's test its working.
271:18 - So first we will insert a node having value as 11 and we will simply print the singly
271:26 - linked list on the console.
271:32 - So here you see singly linked list has one node having data as 11.
271:38 - Now let's say we insert 8 and we also insert a node having value as 1 and if I run this
271:47 - code now.
271:51 - So friends here you can see the singly linked list contains 3 nodes now.
271:56 - First we inserted 11 and then we inserted 8 to the beginning of the singly linked list.
272:02 - So 8 came before 11 and finally we inserted a node having data as 1 which came just before
272:09 - the 8.
272:11 - So friends this is how we insert the node to the beginning of the singly linked list
272:14 - in java.
272:15 - I hope you like this video thanks have a nice day.
272:21 - Hello everyone welcome to my new data structures and algorithms in java tutorial series video.
272:28 - In this tutorial we will discuss how to insert a node at the end of a singly linked list
272:33 - in java.
272:37 - So friends below you can see the algorithm to insert a node at the end of a singly linked
272:41 - list in java.
272:44 - So here in this tutorial we will see the demonstration of this algorithm step by step.
272:51 - Here the algorithm basically insert the node to the end of the singly linked list.
272:57 - So let's suppose at that start that singly linked list is empty.
273:01 - So if the singly linked list is empty we know that head will point to null because there
273:06 - are no nodes into the singly linked list.
273:11 - So now let's suppose we want to insert a node having data as 11.
273:16 - So to the method we will pass the value as 11 and this code will be executed.
273:23 - So in the first step what we do is in order to insert this value into the singly linked
273:27 - list we first actually create a list node by passing in the value to its constructor.
273:35 - So it would look something like this that a new list node is created whose data is 11
273:43 - and whose next is pointing to null.
273:46 - So now we will insert this new node into the singly linked list at the end.
273:53 - So first here in the algorithm we check that whether head is equal to null or not because
273:57 - if head is equal to null then we know that singly linked list is empty and there are
274:01 - no nodes.
274:04 - So therefore currently singly linked list is empty because head is pointing to null.
274:08 - So the condition in if block comes out to be true.
274:14 - And in the if block we simply assign the value of new node to head.
274:18 - So new node is pointing to a node having data as 11 and we want to insert this new node
274:23 - into the singly linked list at the end.
274:27 - But here as the singly linked list is empty therefore in the first step what we do is
274:31 - we simply assign the value of new node to head.
274:35 - So here as head is pointing to null after this assignment head will point to this node
274:40 - having data as 11.
274:41 - So it would look something like this and we will simply return from this method.
274:54 - So friends here we inserted one node into the singly linked list at the end.
275:00 - So initially the singly linked list was empty but now it has one node where head is pointing
275:05 - to this node.
275:09 - Moving ahead let's say we want to insert one more node having value as 8.
275:16 - So we will pass this value into this method and the first step will simply create a new
275:22 - list node by passing in the value to its constructor.
275:26 - So it would look something like this.
275:29 - That new node is pointing to the node having data as 8 and whose next is pointing to null.
275:37 - Now we want to insert this new node to the end of the singly linked list.
275:41 - It's nothing but just after the node having data as 11.
275:47 - So friends now we want to insert this new node to the end of the singly linked list
275:51 - and here you can see that singly linked list has only one node.
275:55 - Therefore this node having the data as 11 is the last node of the singly linked list.
276:00 - So now after this node we have to insert this new node.
276:06 - So we again check whether head is equal to null or not.
276:09 - So currently you can see the head is pointing to the node having data as 11.
276:13 - Therefore the condition in if block comes out to be false.
276:19 - So here we simply create a temporary node by name current and we will assign the value
276:23 - of head to it.
276:25 - So it would look something like this.
276:27 - That current is now pointing to the node having data as 11 and head is also pointing to this
276:33 - node.
276:34 - Moving ahead.
276:39 - So friends now we actually provide a while loop.
276:42 - So why we are providing this while loop is because in order to insert a new node to the
276:46 - end of the singly linked list we need to traverse from head to the end node.
276:51 - So once we reach the end node we can simply assign the value of the last node next to
276:57 - point to this new node.
277:00 - Therefore we start from the head node as current is pointing to head and we iterate in the
277:05 - while loop till current dot next is null.
277:09 - So friends when current dot next will be equal to null.
277:12 - Therefore we can come to know that that is the last node of the singly linked list.
277:17 - So friends in the while loop we provide a condition that current dot next is not equal
277:21 - to null.
277:23 - So here if you see current is pointing to the node having data as 11 and its next is
277:28 - pointing to null and we also know that currently in the singly linked list there is only one
277:33 - node having data as 11 and its next is pointing to null.
277:40 - So therefore the current is pointing to the last node.
277:43 - So therefore the condition in while loop comes out to be false because current dot
277:46 - next is equal to null.
277:51 - So as the singly linked list has only one node therefore this node is the first and
277:55 - also the last node of the singly linked list.
277:59 - So as we are on the last node of the singly linked list in order to insert this new node
278:03 - to the end of the singly linked list what we do is we simply assign the value of new
278:07 - node to current next.
278:10 - So here you can see new node is pointing to the node which we want to insert and current
278:15 - next is pointing to null.
278:17 - So if we assign the value of new node to current next it would look something like this.
278:25 - That current next is now pointing to a node which we want to insert into a singly linked
278:29 - list at the end.
278:34 - So friends when this method gets executed we know that we have inserted this new node
278:38 - to the end of the singly linked list.
278:42 - Now let's suppose we want to insert one more node having value as 1.
278:49 - So this code will be executed again.
278:52 - In the first I will simply create a new list node by providing in the value as 1.
278:58 - So it would look something like this.
279:01 - That new node is pointing to a list node having data as 1 and whose next is pointing to null.
279:07 - We check whether head is equal to null or not.
279:11 - So here you can see head is pointing to a node having data as 11 therefore it's not
279:15 - equal to null.
279:21 - So friends in order to insert this new node to the end of the singly linked list we have
279:26 - to start from the head and we have to reach till the last node of the singly linked list.
279:31 - So in order to perform this step we simply create a temporary node by name current and
279:37 - we start it from the head by assigning the value of head to current.
279:40 - So it would look something like this.
279:43 - That current is pointing to this first node having data as 11.
279:50 - Now we will simply provide a while loop and traverse this current to the last node of
279:54 - the singly linked list by providing a condition that current.next is not equal to null.
280:01 - So in the first step we see current is pointing to a node having data as 11 and its next is
280:06 - pointing to a node having data as 8.
280:10 - Therefore current.next is not equal to null.
280:12 - So the condition in while block comes out to be true.
280:19 - So in the while block we simply traverse current to its next position by assigning current.next
280:25 - value to current.
280:27 - So here you can see current is pointing to this node having data as 11 and its next is
280:31 - pointing to a node having data as 8.
280:35 - So we will assign the value of current.next to current.
280:39 - So it would look something like this.
280:43 - That current has simply traversed to its next node because we have assigned the value of
280:47 - current.next to current.
280:50 - Moving ahead we will again check whether current.next is equal to null or not.
280:55 - So here you can see current.next is equal to null and here we also know that singly
281:01 - linked list has two nodes.
281:03 - So the node having data as 8 is the last node of the singly linked list.
281:07 - So we have traversed the current to the last node and now we can simply insert this new
281:12 - node to the end of the singly linked list.
281:16 - So here the condition in while block comes out to be false because current.next is now
281:20 - pointing to null.
281:24 - And in the last step we simply assign the value of new node to current.next.
281:29 - So new node is pointing to the node which we want to insert and current.next is pointing
281:33 - to null.
281:34 - So if we assign this value to current.next it would look something like this.
281:40 - That current.next is now pointing to the node having data as 1.
281:47 - So friends once this method gets executed we know that our singly linked list has now
281:50 - three nodes.
281:52 - So here we started by inserting a node having data as 11 then we inserted a node having
281:58 - data as 8 and then we inserted a node having data as 1.
282:02 - So you also saw that we are actually inserting this node to the end of the singly linked
282:06 - list.
282:09 - So friends this was a demonstration of the algorithm.
282:11 - Now let's go to Eclipse and see the working of this algorithm.
282:17 - Hello everyone.
282:19 - In our previous tutorial we actually discussed how we can insert the node at the end of the
282:24 - singly linked list in Java.
282:27 - So in this tutorial we will actually write the code and test the working of the code.
282:32 - So friends in our previous tutorial we actually created one class by name singly linked list.
282:38 - So friends in this class we actually wrote the code for the implementation of the singly
282:42 - linked list.
282:45 - So now let's write the code to insert the node at the end of the singly linked list
282:49 - in Java.
282:53 - So here I will be creating one method as public void insert last because you want to insert
283:06 - the node at the end of the singly linked list.
283:09 - So we will provide a value to this method.
283:15 - So here in the first step as we discussed in the slide that first we will create a new
283:20 - node and we will pass the value into the constructor
283:33 - of this list node.
283:36 - So after this step a new node is created and now our task is to insert this new node to
283:43 - the end of the singly linked list.
283:46 - So here in the first step we actually make a check that whether head is equal to null
283:53 - or not.
283:56 - So if head is equal to null we know that singly linked list is empty and there are no nodes
283:59 - into the singly linked list.
284:03 - So we simply assign the value of new node to head and we simply return from the method.
284:14 - So here if the singly linked list is empty we simply assign the value of new node to
284:18 - head because after the insertion of this new node this would be the only node into the
284:24 - singly linked list.
284:27 - And if the singly linked list is not empty then we will create a temporary node by name
284:34 - current and we will assign a value of head to it.
284:40 - So here in order to insert this new list node to the end of the singly linked list we need
284:44 - to start from the head and we need to reach to the end of the singly linked list.
284:49 - So in order to start from the head and reach to the end of the singly linked list we create
284:54 - a temporary list node by name current and we start from the head.
285:00 - And then we will provide a while loop and to this while loop we will provide a condition
285:07 - as current.next is not equal to null.
285:18 - And inside this while loop we will simply iterate current to its next position.
285:27 - So once we reach to the last node of the singly linked list we know that its next points to
285:31 - null and as we want to insert this new list node to the end of the singly linked list
285:37 - after while loop we simply assign value of new node to current next.
285:52 - So friends here we started from the head node and we reached to the last node by providing
285:57 - this while loop and we traversed current from first node to the last node of the singly
286:01 - linked list and once we reached to the last node of the singly linked list we simply assigned
286:06 - the value of new node to current next and so the current next refers to this new node
286:12 - and this new node is part of the singly linked list.
286:17 - So in our main method let's test its working.
286:24 - So we will simply call insert last.
286:36 - So here we have called insert last 3 times but first we are inserting the value 11 and
286:42 - then we are inserting a value 8 and then we are inserting a value of 1 and then finally
286:48 - we are displaying the singly linked list on the console.
286:51 - So if I run this code now.
287:01 - So friends here you can see first we inserted 11 and then we inserted 8.
287:06 - So 8 came just after 11 and then we inserted 1.
287:12 - So 1 came after 8.
287:15 - So it is nothing but inserting the node at the end of the singly linked list.
287:23 - So friends in this tutorial we actually saw how we can insert a node at the end of a singly
287:28 - linked list in Java.
287:30 - I hope you like this video.
287:33 - Thanks have a nice day.
287:39 - Hello everyone.
287:40 - So in this video we will discuss that how we can insert a node in a singly linked list
287:44 - at a given position.
287:49 - So here you can see that in this problem we want to implement a method which will insert
287:54 - a node in a singly linked list at a given position.
287:58 - In this position we are assuming to be valid and it will start from 1.
288:04 - So for example here you can see that we are given let's say with this singly linked list
288:09 - and now let's say if you want to insert any node at a given position.
288:13 - So here we are assuming that position to be valid it means that position should lie from
288:19 - 1 to whatever is the length of the singly linked list.
288:24 - And here we are starting it from 1 which means if you want to insert a node at position
288:30 - 1 it would be the first node and if you want to insert at position 5 then this would be
288:36 - the last node and in case if you want to insert in between of these nodes the position would
288:43 - be the number where you want to insert.
288:46 - So let's say if you want to insert at position 3 and we are given with this singly linked
288:51 - list so here you can see this is position 1, 2 and 3.
288:55 - So what we are trying to do here is we will insert node here and this node will get shifted
289:01 - ahead of the node which you want to insert here.
289:06 - So let's go ahead and see the demonstration of this algorithm step by step.
289:12 - So before we start in case if you are new to my channel then please subscribe to my
289:17 - channel so that you never miss any update.
289:21 - So now here you can see this is the algorithm to insert a node at a particular position.
289:28 - Now let's suppose if we are given with this singly linked list having only two nodes.
289:33 - So we will apply this algorithm on this singly linked list and let's say if you want to insert
289:39 - a value 8 at position 1.
289:44 - So the second parameter is position and this is the value which you want to insert.
289:50 - So here you can see that whatever the value we have passed which is 8 here it's nothing
289:55 - but our data.
289:56 - So in the first step what we are doing is we are creating a list node having data as
290:01 - 8 because we want to insert this node at position 1.
290:09 - So it would look something like this that node is pointing to a list node having value
290:15 - as 8 and its next is pointing to null.
290:20 - Now here you can see that there are two cases in if and else.
290:25 - So if position is 1 it means you want to insert this node at the beginning of singly linked
290:30 - list which is just before our head.
290:35 - So currently this if block condition comes out to be true.
290:40 - Now as you want to insert this node before head what we have to do is as node is pointing
290:47 - to this list node its next should point to head because we want to insert this node before
290:53 - head so this nodes next should point to head.
290:57 - So in the first step we are doing that we are assigning the value of head which is this
291:02 - node to nodes next.
291:06 - So currently node next is pointing to null so after this assignment nodes next will point
291:11 - to head.
291:13 - So it would look something like this that now node next is pointing to head moving ahead.
291:23 - So here you can see that node next is pointing to head but as head is pointing to the node
291:30 - having value as 10 which is our second node we need to reassign this head to this node
291:35 - because in order to insert a node before head which is the position 1 after insertion head
291:42 - should point to that node or else when this method will get exit this node wont be part
291:48 - of our singly linked list so we need to assign head to this node so that this node comes
291:53 - into the singly linked list.
291:56 - So we are simply assigning the value of node to head so head is pointing to the second
292:00 - node now it will point to the node which you want to insert and here you saw that after
292:09 - inserting the node at the beginning this was our position 1 initially at position 1
292:16 - was this node which shifted towards right and this node came into position 1.
292:24 - Moving ahead now lets suppose if you are given with this 3 nodes and you want to insert a
292:32 - value 7 at position 3.
292:37 - So here you can see this is position 1 this is position 2 and this is position 3 so we
292:45 - want to insert node here and once we insert node here this one will be shifted a node
292:52 - ahead because we want to accommodate 7 between 10 and 1 because this is the third position
293:01 - so lets see how we can do that at the first step we will create the node with the data
293:07 - as 7 we check whether position is equal to 1 or not so position is not equal to 1 so
293:17 - the else part will be executed.
293:20 - So friends now idea behind this algorithm is we want to insert a node at position 3
293:26 - so this is the position 3 which means we want to insert this node between this node
293:32 - and this node so that once this node is inserted our new node is at position 3 so in order
293:40 - to insert this node at position 3 what we have to do is we need to traverse somehow
293:45 - to position 2 and then we can break this link and instead of pointing to node 1 we can point
293:52 - to our node 7 and node 7 will point to 1 and by this way our node will be inserted
294:00 - between 10 and 1 and will occupy position 3 so lets see how.
294:07 - So here we will create a list node previous because we want to reach somehow to this node
294:12 - which would be previous to our node after insertion so we will start from the head so
294:20 - previous will point to head and in order to reach to this node we will keep the track
294:27 - using the count variable so value of count will be 1 at the start which signifies that
294:33 - we are already at this position and then in order to traverse to a node previous to our
294:42 - position 3 we will provide a condition as count should be less than position minus 1
294:48 - so position minus 1 will be 2 and here you can see that we have already taken up this
294:54 - place so count is 1 so currently count is less than position minus 1 which is 1 is less
295:01 - than 2 so this condition comes out to be true so we will simply traverse previous to its
295:09 - next node by assigning previous dot next to previous so currently previous is pointing
295:15 - to this node its next is pointing to this node so we will assign previous next value
295:22 - to previous so it would look something like this that now previous will point to its next
295:28 - node moving ahead will increment value of count because we have traversed previous to
295:36 - its next node count becomes 2 now here you can see 2 is not less than 3 minus 1 which
295:45 - is 2 and we also know that we have reached to position 2 and now we can simply use its
295:51 - next pointer to simply insert this node into the singly linked list at position 3 so this
295:58 - while loop condition comes out to be false now here what we will do is as we want to first
296:06 - break this link so at the first step what we do is we simply create a list node current we will
296:12 - assign a value of previous dot next to it so as we want to break this link so we can't directly
296:18 - break this link because if we break this link the nodes after that will be removed from the
296:23 - singly linked list because there would be no reference so at the first step we are simply
296:27 - creating a temporary list node by name current and we are assigning previous dot next to it so
296:33 - that whatever the nodes are after that will be hold by current so previous next is this node so
296:43 - now current will point to this node so for now we need to perform two steps in order to insert node
296:51 - between 10 and 1 the first thing we need to do is as node next is pointing to null and we know
296:59 - that after its insertion it should point to this node because that way it will be inserted in
297:04 - between of node 10 and 1 so at the first step what we are doing is as current is pointing to this
297:11 - node we will assign the value of current to nodes next so here node next is pointing to null so
297:19 - after this assignment there will be a linkage from node next to current so it would look something
297:25 - like this moving ahead and at the last step what we do is we simply break this link and we can
297:35 - safely break this link because the rest of the list is being hold by current so how we can break
297:41 - this linkage previous is pointing to this node its next is pointing to this node so if we assign
297:49 - nodes value which is this value to previous next so it would look something like this that now
297:59 - previous next is pointing to node by this assignment and why we have performed this step is because we
298:07 - want to insert this node in between 10 and 1 so there was one linkage between 10 and 1 so we
298:13 - break that linkage we assigned previous next to node and node next to current so here you can see
298:22 - that if we stretch this singly linkage ahead so it would look something like this that 7 will come
298:28 - in between 10 and 1 and here you can see that that is the position 3 where we actually wanted to
298:35 - insert our node this is position 1 2 and this would be over 3 so it is nothing but inserting
298:42 - a node somewhere in the middle of the singly linked list so friend 1 last case remains is we
298:50 - want to insert node at the last so that will also be inserted via position so here you can see let's
298:57 - say we are given with the singly linked list having only two nodes 8 and 10 so this is position 1 and
299:04 - this is position 2 now if you want to insert a node at the third position so it would be nothing
299:09 - but inserting the node at the end of the singly linked list and here we are assuming that position
299:16 - should be valid so if we call insert 7 comma 3 7 is our data and 3 is our position at the first step
299:26 - will create the list node having data 7 and its next pointing to null we check whether we want to
299:34 - insert it position 1 or not so currently we want to insert it position 3 so this condition comes out
299:40 - to be false now in the else part we perform the same steps which we saw in our previous slide if
299:49 - you want to insert it position 3 we need to somehow traverse to position 2 so that we can use this link
299:56 - to insert this node so we start previous from the head and in order to keep the track of the
300:06 - position and where to insert the node will create an integer variable count starting from value 1
300:12 - because we have already taken up this value in the while loop we provide the condition as count
300:20 - should be less than position minus 1 position minus 1 is 2 and as count value is 1 therefore
300:28 - the condition in while loop will come out to be true in the first step will simply traverse
300:34 - previous to its next node by assigning previous next value to previous so it would look something
300:40 - like this will increment count so count becomes 2 and now here the condition in while loop comes
300:51 - out to be false because position minus 1 is 3 minus 1 which is 2 and 2 is not less than 2 so
301:00 - this will signify that previous is one step behind our position so here you can see previous is
301:07 - pointing to position 2 and why we need a previous position is because as it is a singly linked list
301:14 - we need to somehow use previous next pointer to simply accommodate our newly created node inside
301:22 - that so at the first step what we are doing is we are simply assigning previous next value to a
301:28 - temporary list node current so previous next is pointing to null so current will point to null
301:35 - now as you want to insert this node what we saw in our previous steps node next should point to
301:42 - current so after this assignment it would look something like this that node next is pointing
301:49 - to null so friends here you can see as we are inserting this node at the end of the singly
301:54 - linked list these steps are pretty much generic to accommodate both cases inserting in between
302:01 - and inserting at the end now at the last step we are simply assigning value of node to previous
302:08 - next so previous next is pointing to null so it means we want to reassign this value to this node
302:16 - because we want to insert this node at position 3 so it would look something like this so now head
302:25 - is pointing to node 1 node 1 is pointing to second node and second node is pointing to third node
302:31 - which is our position 3 and this node is pointing to null because we have inserted this node at the
302:37 - end of the singly linked list so it would look something like this so here we discuss the cases
302:44 - where we want to insert the node at a particular position of the singly linked list I hope the
302:50 - information provided in this video is useful to you and in case if you find this useful then please
302:56 - like this video and in case if you are new to my channel then please subscribe to my channel
303:01 - so that you never miss any update thanks have a nice day. Hello everyone so in our previous video
303:13 - we discussed that how we can insert a node at a given position in a singly linked list so in this
303:19 - video we will code the algorithm and will test its working so here in our singly linked list
303:25 - class which has an instance variable head of type list node here I will be creating one method
303:38 - public void insert now this insert method will take two things one is the position where we want
303:51 - to insert and let's say there is the value which you want to insert for that particular node now
303:58 - here we are assuming that this position is valid and it is not crossing the boundaries of our singly
304:04 - linked list so those edge cases you can handle it by comparing the value of the position that
304:12 - whether it is less than zero or it is greater than the length of our singly linked list and
304:17 - basically you can assign a default value to position and proceed ahead with the algorithm
304:23 - or you can simply throw an exception so here we are assuming that position is a valid position and
304:29 - starting from one so for example if we are given with the singly linked list let's say one having
304:38 - this three nodes so one would be our position one four would be at position two and five would be at
304:45 - position three so let's say if you want to insert a value six at position two so after this method
304:52 - gets executed it would become something like one at position two it will come six then four and then
305:01 - five so it means we have inserted value six between one and four because one is at position one and
305:10 - after our insertion six should come at position two so this method will perform three cases if
305:17 - position is one it will insert at the beginning of the singly linked list and it will also insert
305:23 - in between or at the end of the singly linked list so let's see the code for that so assuming the
305:29 - position to be a valid position at the first step we will create the node which you want to insert
305:40 - whose value would be the value which we have passed to our method now after creating this
305:46 - node which you want to insert we will provide a if else part in the if part will check whether
305:54 - position is one or not so if position is one it means you want to insert the node at the beginning
306:03 - of the singly linked list so in the if part what we do is as head is pointing to the first node
306:09 - which is also position one so now head should point to a newly created node after the node
306:16 - gets inserted so in the first step what we do is as node next is pointing to null we want
306:24 - to point it to head because we want to insert this node before head so node next should point
306:31 - to head and after node next is pointing to head in order to make node part of our singly linked
306:38 - list and to insert at position one we need to assign the nodes value to head so now head will
306:48 - point to node which would be at position one and which would become the part of our singly linked
306:53 - list so this is the case one and for the rest of the cases we'll see in the else part so in the
307:03 - else part let's say if you take this example and we want to insert a node at position two so here
307:09 - you can see that initially the linked list let's say it's one four and five and if you want to
307:15 - insert a node at position two so it would become something like this after the insertion so here
307:22 - what we are doing is this linkage we are breaking between one and four and we are assigning it from
307:29 - one to six and then six to four so there are two assignments one is we are reassigning this linkage
307:39 - from one to four to one to six and then from six to four so there are two assignments which we need
307:46 - to do now as it is a singly linked list in order to reassign this value we need to somehow reach to
307:53 - node one which is previous to the position where we want to insert the node so let's say if we want
308:00 - to insert node at position two we need to somehow reach to position one and using its next we need
308:07 - to assign it to our node which you want to insert so in the else part we'll create a temporary node
308:15 - at previous because we want to somehow reach to a node previous to this position where we actually
308:23 - want to insert our newly created node so we'll start from head and as you have already started
308:30 - from head we'll create a integer variable count we'll assign it a value one because this count
308:39 - will help us in traversing to position minus one so in a while loop we will provide a condition
308:53 - as count should be less than position minus one and inside this while loop till this condition
309:03 - fails we will keep incrementing previous to its next position by assigning previous dot next to
309:12 - previous and we'll simply increment count by one one position so when previous will reach to
309:22 - position minus one this while loop will terminate and after this while loop gets terminate what we
309:28 - do is we create a temporary list node by name current and we assign a value as previous
309:37 - dot next to it so here let's say if we have reached here so two current we are assigning
309:44 - previous next which is value four because we need to reassign it to six if we break this linkage
309:52 - and reassign it directly then four and five will be removed from the singly linked list because
309:58 - there is no reference to them so at the first step we are simply creating this temporary reference
310:03 - so that the rest of the singly linked list is intact now after assigning previous dot next
310:09 - value to current we can simply remove this linkage and assign it to our node which we want to insert
310:17 - so here what we do is we do previous dot next and we'll assign a value of node to it so now this
310:28 - linkage is gone and it will point to six now we need to do one more assignment
310:35 - as this node next should point to four because we want to insert node six in between one and four
310:42 - so that it comes to position two so for that what we do is we do node dot next
310:52 - and assign a value current to it because we know that current is pointing
310:58 - to previous next which was this node so now six next will point to this node
311:05 - and this way with this three step you can see that we have inserted our node in between
311:10 - node one and four and after this assignment you can see that six is now inserted at position
311:17 - which we wanted which is position two in this case so from this is the code to insert a node
311:24 - in a singly linked list at a given position so now let's test it's working in the main method
311:29 - so here in the main method i will comment this part and let's say after creation of singly linked
311:41 - list head is pointing to null because here you can see that at the start head is pointing to null
311:49 - so here what we do is let's say we insert a node at position one value as three
312:00 - and then let's say i print it on the console the singly linked list using the display method
312:07 - so if i run the code now
312:12 - so here you can see it inserted at position one which is the first position
312:18 - having only one node three pointing to null now let's say what we do is
312:22 - at position two we assign five and if we run the code so here you can see at position one was three
312:39 - so position two we got value five and now what we do is
312:47 - let's say at position one we insert value two so now here you can see at position one
312:59 - three is already there and if we are doing this it means two will come before three
313:06 - so if i run the code now
313:11 - so here you can see two came before three which was
313:17 - our this case so now let's see the else part
313:25 - let's say i insert a value four
313:33 - between one and two so we'll do two and if i run the code now
313:41 - so here you can see initially singly linked list was two three and five
313:49 - and when we did that four came in between two and three which is the position two
313:56 - which we actually wanted now here after this insertion you can see there are four nodes
314:02 - two four three five and let's say if you want to insert at the end so the position would be
314:08 - value five because four nodes are already there so here what we do is
314:17 - at position five we want to insert value seven let's say if i run the code
314:28 - so you can see seven inserted at the end of the singly linked list which is position five
314:32 - so friends here we saw different use cases at the first step the singly linked list became
314:41 - something like this
314:47 - and when we inserted five at position two it became
314:50 - something like this
315:01 - and then we inserted value two at position one so three got shifted ahead and our singly linked
315:07 - list became something like this i'll just copy this part so it would be two
315:14 - two it became something like this because two inserted at position one and rest of the
315:22 - singly linked list shifted by one position and then we inserted four at position two
315:28 - so it became something like this it was like this so at position two four came
315:37 - and rest of the list nodes were shifted by one position and here you can see that we had
315:46 - this four nodes already so at the position five we inserted seven so it became something like this
315:53 - i'll copy this seven
316:00 - so which is our this case
316:09 - so friend this is how we actually insert a node in a singly linked list at a given position
316:24 - i hope you have find this information useful and in case if you find this information useful
316:29 - then please like this video and if you are new to my channel then please subscribe to my channel
316:34 - so that you never miss any update thanks have a nice day
316:42 - hello everyone so in this video we will discuss that how we can delete the first node of a singly
316:49 - linked list so let's see the code and it's working step by step using an animation
316:55 - so here you can see that let's say we are given a singly linked list having three nodes
317:04 - with data as 10 1 and 11 where head is pointing to the first node and let's say in our singly
317:11 - linked list class we have created this head as an instance variable and we have written one of
317:18 - the method in that class which will manipulate this singly linked list so here you can see that
317:24 - this is the code to delete the first element of the singly linked list so let's see the
317:30 - demonstration of this method that how it manipulates the singly linked list and deletes the first node
317:38 - so when we call delete first method you can see it has a return type of list node
317:43 - so what it will do it will delete the first node and it will return from this method
317:48 - so when we call delete first the first step we check is whether head is equal to null or not
317:57 - because if head is equal to null it means head is pointing to null and there are no nodes to
318:02 - delete so we simply return null so currently you can see that head is pointing to a node
318:09 - having value as 10 so therefore this condition comes out to be false
318:13 - and the execution point reaches here now here what we do is we create a temporary variable
318:24 - which will also point to the first node of the singly linked list because head is
318:28 - always pointing to the first node now why we are creating this temporary variable is because when
318:34 - we delete this node we need to return it from this method so we are creating this temporary variable
318:41 - of type list node and whatever the reference value head is holding we are simply assigning
318:46 - it to the temporary variable so as head is pointing to this first node after this assignment
318:56 - there will be a temporary list node which will also point to this node moving ahead
319:03 - now if the temporary list node is pointing to the first node of the singly linked list
319:07 - after its deletion the linked list will have only two nodes and head should point to the second
319:15 - node now because when we delete the first node the linked list remains with the two nodes
319:22 - and the second node becomes our new head so we need to traverse this head to the second node
319:30 - so how we will do that we will simply assign the value head.next to head
319:34 - so head is pointing to this node its next is pointing to the second node
319:41 - so once we assign head.next to head it would look something like this
319:48 - that now head has simply traversed the second node and as head has traversed the second node
319:54 - we can safely delete this first node moving ahead
319:58 - so here you can see that head is pointing now to the second node and this will be our newly
320:06 - singly linked list because you have deleted the first node but if we return this temporary list
320:10 - node directly from this method these two nodes will also get returned along with this temporary
320:17 - list node because there is still a linkage here so what we do is in order to break this linkage
320:26 - we simply assign null value to temp.next so temp is pointing to this node and its next is pointing
320:32 - to the second node so we need to break this linkage so after assigning null it would look
320:37 - something like this you can see we have completely separated the first node from the singly linked
320:45 - list so at the last step we simply return this temporary list node and after deletion of the
320:55 - first node now our linked list has only two nodes with a new head pointing to the second
321:02 - node which has now become the first node of the singly linked list so friends let's say if you
321:09 - want to perform delete first again so we call delete first again on this singly linked list
321:15 - having two nodes so it would look something like this we check whether head is equal to null or
321:21 - not so head is pointing to this node therefore condition in if block comes out to be false
321:29 - we again create a temporary list node which will point to the first node of the singly linked list
321:36 - because we are assigning the value of head to it
321:43 - after assigning this value we simply traverse head from this node
321:46 - to its next because we want to delete this node
321:54 - so by assigning head.next to head head will not point to the second node of the singly linked list
322:02 - then we'll simply break this linkage here by assigning null value to temps next
322:12 - and finally we'll return the temp
322:17 - so now our singly linked list has only one element
322:22 - so by calling this delete first two times we have deleted two nodes which were at the
322:27 - beginning of the singly linked list so let's say we want to delete this node also
322:32 - so we'll call delete first again we check whether head is equal to null or not so your head is
322:38 - pointing to this node therefore it's not equal to null so this condition comes out to be false
322:44 - we create a temporary list node pointing to head something like this
322:55 - and then we'll simply traverse head to its next because we want to delete this node
323:00 - so by assigning the value head.next to head what will happen head is pointing to this node
323:05 - and its next is pointing to null because this is the only node left in our singly linked list
323:10 - so now head will point to next which is null
323:20 - we simply assign null to temp.next to break this linkage but as it is already pointing to null
323:27 - it would look something like this
323:31 - and we can return this temporary node because we have deleted it completely
323:35 - so now our singly linked list has no elements and head is pointing to null
323:42 - so if we call delete first again we first check whether head is equal to null or not so here you
323:48 - can see now head is equal to null so therefore this condition comes out to be true
323:55 - and as there are no nodes left to be deleted we simply return null
324:00 - so friends this was the algorithm to delete the first node of a singly linked list
324:06 - we saw that singly linked list had three elements at the start we called this method
324:12 - delete first four times to delete this all the nodes from the singly linked list
324:19 - so now let's go to eclipse and see the demonstration of this algorithm step by step
324:23 - i hope you like this video thanks have a nice day
324:29 - hello everyone so in this video we'll write the code to delete the first node of a singly
324:35 - linked list so here you can see that we have the singly linked list class having an instance
324:41 - variable head of type list node so this head is responsible for holding complete list
324:48 - in our previous lecture we also saw the different operations such as length where we can
324:56 - get to know the length of the singly linked list and even we can display the data which is being
325:01 - present in the singly linked list we also discussed about the insert first method and insert last
325:08 - method so let's say if i run this code now so here you can see that we have inserted four nodes
325:19 - eleven eight one ten and then it's null so here we have inserted this four nodes and we have
325:25 - displayed the singly linked list here so let's write the code and see that how we can delete
325:31 - the first node of a singly linked list so here i'll be creating one method as public list node
325:46 - delete first so here you can see that after deleting the first node we'll simply return it
325:51 - from this method so as we discussed in our previous video that in delete first the first
325:58 - condition we check is we see whether head is equal to null or not so if head is equal to null
326:10 - then we simply return null which means that singly linked list is empty and there are no
326:16 - nodes left to be deleted we can even throw an exception from here but for time being i'm
326:21 - returning null and then we also discuss that after if condition we create a temporary variable
326:32 - and we point it to the head so here you can see that why we have assigned the value of head to
326:37 - temp because after deleting the first node we have to return this list node from this method
326:44 - and also head points to the first node of a singly linked list so for example let's say
326:49 - we want to delete the first node from the singly linked list so head points to 11
326:55 - and once we delete 11 head should point to 8 now because there are three more elements left
327:01 - so head should point to 8 so here after assigning head to this temporary variable
327:08 - now we can simply move head to its next position
327:14 - by simply assigning head.next to head
327:21 - so here as head was pointing to 11 now it will point to 8
327:27 - so now after placing head to its correct position we can simply delete the first node by assigning
327:33 - null value to temp.next in order to break the linkage between this temporary node and the rest
327:44 - of the list and finally we can return the deleted node so this is the code now let's test it's
327:57 - working so here after display what we'll do is
328:07 - we will simply print the deleted nodes data so here what we'll do SSL.
328:13 - we will call delete first method so this will return us the list node which we have deleted
328:20 - and then we can simply print its data and then after deleting the data what we can do is
328:30 - we can again print the singly linked list and if i run the code now
328:39 - so here you can see that we removed the first node which is 11 and we printed its data here
328:46 - and then after deleting the first node the singly linked list was left with 8 1 and 10
328:53 - so similarly let's say if i remove one more node and if i run the code now
329:03 - so here you can see that when we called delete first for the first time 11 was removed then we
329:10 - called it second time so 8 was removed which got printed here and finally when we did display
329:17 - so the linked list was printed as 1 and 10 because we have removed 11 and then 8
329:23 - so friend this is how we actually delete the first node of a singly linked list
329:29 - i hope you like this video thanks have a nice day
329:31 - hello everyone so in this video we will discuss about how to delete last node of a singly linked
329:41 - list so here you can see that this is the algorithm to delete the last node of a singly linked list
329:50 - so let's say we are given a singly linked list having these three nodes and we want to delete
329:54 - the last node of the singly linked list so here the singly linked list can contain n number of
329:59 - nodes and here if we take this example where head is pointing to a node having value as 10
330:06 - 10 is pointing to 1 1 is pointing to 11 and finally 11 is pointing to null so there are three nodes
330:13 - and if we apply this algorithm when we call delete last first 11 will be deleted
330:20 - and we will be left with two nodes and if we again call delete last then one will be deleted
330:26 - and we will be left with one node if we again call delete last then the only node left will
330:32 - be removed and simply returned from this method so in our previous video we saw that how we can
330:38 - delete the first node of a singly linked list so there as head pointed to the first node it was
330:43 - very easy to delete the first node of the singly linked list but here as we want to delete the last
330:49 - node we need to somehow traverse to the second last node and remove this link to delete the
330:56 - last node from the singly linked list so in order to achieve that what we do is we create two pointers
331:04 - one by name current which travels to the last node and one pointer by name previous which travels
331:12 - to the second last node so as current travels to the last node previous travels to the second
331:18 - last node and why we need the second last node because in order to free the last node we need to
331:24 - break this linkage here so we need to traverse somehow to the second last node break this link
331:31 - to make this node free so this is the algorithm for that now let's see the demonstration of this
331:37 - algorithm step by step so when we call delete last for the first time we first check whether head is
331:45 - equal to null or not so head is pointing to this node so this condition is false and we also check
331:51 - whether head dot next is equal to null or not now why we perform this check is because let's say if
331:57 - the linked list has only one single node so this node next will point to null and this will be the
332:03 - only node in the singly linked list so we don't have to delete anything we simply have to return
332:08 - the head because this is the only node which we want to return from this method so currently
332:14 - head dot next is also not equal to null therefore this both the condition comes out to be false
332:23 - and now as we discussed we create two pointers current and previous so we start current
332:30 - from the head by assigning the value head to it so it would look something like this
332:39 - and as head is pointing to the first node its previous node will simply point to null
332:45 - moving ahead now friend as you want to delete the last node we need to provide a while loop so that
332:53 - we can traverse current to the last node of the singly linked list and previous to the second
333:00 - last node so here if you see in the while loop we are providing condition that iterate till current
333:07 - dot next is not equal to null so here when current will reach to the last node its next will point to
333:14 - null so this while loop will terminate when current dot next becomes null so as current is pointing
333:23 - to this first node and its next is not equal to null therefore this condition comes out to be true
333:28 - and while loop executes so before moving current to its next node what we do is we simply assign
333:39 - current's value to previous so that previous is one node behind the current when current travels
333:44 - to the second node so in the first step we simply assign the value of current to previous so it would
333:49 - look something like this now as current is pointing to the first node previous will also point to this
333:56 - first node and in the second step we simply move current by one position by assigning current's
334:03 - next value to current so current next is pointing to the second node so now current will point to
334:10 - the second node so here you can see we have traversed current to the second node and previous
334:16 - is just one node behind it so this is all we do in the while loop till current reaches to the last
334:23 - node and previous reaches to the second last node so let's see how we again check current dot next
334:31 - is equal to null or not so current next is not equal to null this condition comes out to be true
334:40 - and before moving current to its next position we make sure previous is at current's position
334:47 - by assigning current's value to previous so it would look something like this
334:55 - then we simply move current to its next position by assigning current dot next to current so current
335:00 - dot next is pointing to the third node so after this assignment current will point to this node
335:10 - moving ahead now friends here you can see that we have these three nodes but in singly
335:16 - linked list there can be n number of nodes so the only idea to delete the last node of the singly
335:22 - linked list is we need a reference to the second last node of the singly linked list so that we can
335:30 - remove this linkage so now here you can see current has reached to the last node and previous
335:35 - is on the second last node so here the condition current dot next not equal to null comes out to be
335:42 - false because current next is pointing to null so this while loop terminates which makes sense
335:50 - because we have traversed till the last node using the current pointer and we also know its second
335:56 - last position using this previous pointer so after this while loop the next step we do is
336:05 - we assign a null value to previous next and why we do so because we want to break this link
336:12 - so that this last node can be freed up so previous is pointing to the second last node
336:18 - its next is pointing to the last node and we want to delete the last node so we break this link by
336:23 - assigning null value to previous next so it would look something like this
336:30 - and finally we return the current
336:36 - so after the deletion of the third node we are left with two nodes so let's say we again call
336:41 - this algorithm head is pointing to the first node so it's not null and head dot next is pointing to
336:48 - the second node which is also not null so this condition comes out to be false
336:55 - we again create current in previous nodes by assigning head to current and null to previous
337:02 - so it would look something like this current points to the first node and previous points to null
337:12 - and then we provide a while loop because we want to traverse current to the last node and previous
337:17 - to the second last node so first we check whether current dot next is equal to null or not
337:23 - so current next is this second node it's not equal to null so the condition in while loop
337:28 - comes out to be true and while loop starts execution before moving current to its next
337:37 - we assign current value to previous so that it is just behind the current so it would look
337:43 - something like this let now previous is pointing to this node because current is pointing to this
337:50 - node and now we'll simply traverse current to its next position by assigning current dot next
337:57 - to current so current is pointing to this node its next is pointing to the second node
338:03 - so after this assignment it would look something like this
338:05 - and again in while loop we'll check whether current dot next is equal to null or not
338:15 - so here you can see that this singly linked list contains only two nodes and current is actually
338:20 - on the last node and previous is on the second last node and as current next is pointing to null
338:27 - current will be pointing to the last element of the singly linked list
338:31 - so this condition comes out to be false and while loop exits
338:37 - and now we'll simply assign null value to previous next because we want to break this link
338:43 - so that this node can be freed up so it would look something like this
338:50 - that null is assigned to previous next
338:57 - finally we return current
339:00 - so now we are left with only one node so let's call this algorithm again
339:09 - so here you can see head is pointing to first node which is not null so this condition is false
339:15 - but head dot next is pointing to null head dot next is pointing to null which signifies that
339:22 - singly linked list has only one element because head is pointing to the first node and its next
339:29 - is pointing to null so therefore this list has only one node and if we want to delete that
339:37 - we don't have to do anything we simply return head
339:45 - so friend this was the algorithm where we discussed that how we can delete the last
339:51 - node of the singly linked list we also discussed that how current and previous pointers help us in
339:58 - deleting the last node because in order to delete the last node we somehow need to travel
340:04 - to the second last node and once we travel to the second last node we simply assign null value to
340:12 - its next so that the last node can be freed up and can be returned from this method so friends
340:19 - now let's go to eclipse and see the demonstration of this algorithm i hope you like this video
340:25 - thanks have a nice day
340:28 - hello everyone so in our previous video we saw the demonstration using an animation
340:35 - and we discussed that how we can delete the last node of a singly linked list
340:40 - so in this video we will see that how we can code a method to delete the last node of a singly linked
340:46 - list and in one of our previous videos we also saw that how we can delete the first node
340:52 - so let's say i just comment out
340:57 - the delete first method and if i run the code now
341:05 - you can see we have inserted these four nodes using insert last method and the singly linked list
341:11 - contains 11 8 1 and 10 which are four nodes and which got displayed using the display method
341:18 - now let's say we write the code to delete the last element of a singly linked list
341:26 - so here when we call delete last for the first time 10 will be removed because it is the last
341:32 - element of the singly linked list so here i'll create a method as public list node delete last
341:44 - and after deleting the last node we'll simply return it from this method
341:53 - so in our previous video we discussed that the first thing we do is
342:00 - we simply check that whether head is equal to null or not and we also check that head.next
342:09 - is equal to null or not now why we do it because this condition head equals equals null
342:20 - will signify that singly linked list is already empty and there are no nodes to be deleted and
342:27 - head.next why we do it because if head.next is null it means the singly linked list is only one
342:34 - element so what we do is we simply return head so if the first condition is true null is returned
342:43 - and if the second condition is true the head is returned because this is the only node
342:48 - in the singly linked list so this is the if condition and after that what we do is in order
342:54 - to delete the last node we need to somehow traverse to the second last node and remove the linkage
343:00 - so how we can achieve that in our previous video we discussed that we can create
343:08 - two pointers
343:12 - one is the current which will start from head
343:20 - and other is previous
343:21 - which will be always be previous to current and why we do so because once current reaches to the
343:31 - last node previous is already at the second last node and we can simply remove the linkage
343:38 - by using this previous node and finally return the last node which got deleted
343:46 - so here at the start current points to head and previous points to null
343:49 - null and then we need to provide a while loop so that we can reach to the last node of the singly
343:57 - linked list so the condition we provide here is we simply check whether current next is equal to
344:06 - null or not so if current next is equal to null it signifies that we have reached to the last node
344:15 - of the singly linked list because last nodes next points to null so inside this value what we do is
344:24 - we move current by one position and before moving current to one position ahead we simply assign
344:31 - current's value to previous so that previous always remains one node behind the current
344:38 - so that when current reaches the last node previous is at the second last node
344:43 - and once we get the location of the second last node we can simply remove the last node from the
344:49 - singly linked list by simply putting previous.next equals null so this breaks the chain of the singly
344:57 - linked list from the last node so here what we do is we do previous and assign the value current to it
345:09 - and after this assignment we simply move current to its next position by assigning current.next to
345:19 - current and this while loop goes till current reaches the last position and previous reaches
345:28 - the second last position so after this while loop terminates one last step we do is we do previous
345:36 - dot next equals null because this will break the chain between the singly linked list and the last
345:44 - node because previous is pointing to the second last node and its next is pointing to the last
345:50 - node and we want to delete the last node so we simply assign null value to previous next so this
345:56 - will break break the chain and finally we simply return the current because you have deleted this
346:08 - node so we simply return it from this method so now let's test it's working
346:18 - so here we have this list of four nodes 11 8 1 10 so let's remove the last node of the singly
346:24 - linked list which is 10 so i'll just uncomment this part and instead of delete first i'll do
346:34 - delete last because we are removing the last element and then i'll simply print the singly linked list
346:42 - again if i run the code so here you can see that initially the list contains four nodes
346:52 - then we call the delete last which removed the last node and returned
347:01 - from this method and then we simply printed its data which came out to be 10 so here you can see
347:07 - the 10 is the last node of the singly linked list and after that i again printed the singly linked
347:12 - list which came out to be 11 8 and 1 because 10 is already removed so similarly let's say if i
347:22 - remove one more data and if i run the code now so here you can see first 10 got removed by this
347:38 - method and then when we called again delete last one was removed so the singly linked list now has
347:44 - only 11 and 8 10 and 1 are removed so for in this video we saw that how we can delete the last node
347:53 - of a singly linked list i hope you like this video thanks have a nice day
347:58 - hello everyone so in this video we will discuss that how we can delete a node from a singly linked
348:09 - list at a given position in our previous videos we saw that how we can insert a node in a singly
348:16 - linked list at a given position so now we'll see that how we can delete a node from a given
348:22 - position in a singly linked list so here you can see let's say we want to implement a method
348:29 - to delete a node at a given position so for example let's say if we are given with this
348:34 - singly linked list and we need to write a method delete which will take in a position and we are
348:41 - assuming the position to be valid which means it should lie in the boundaries of the singly linked
348:46 - list and which should start from one so let's say in this singly linked list if you want to delete
348:53 - a node at position one then that would be this node which is the first node of a singly linked
348:58 - list so we are assuming that it should start from one and let's say if you want to delete a position
349:05 - three so this is position one position two portion three so this is the node which you want to delete
349:12 - and we are assuming the position to be valid here so let's say our singly linked list has four nodes
349:18 - and if we pass position as six then either we need to throw an exception or we can assign a
349:23 - position to a value which points to the last node of the singly linked list so based on these two
349:29 - assumptions let's see the algorithm so before we start in case if you are new to my channel then
349:37 - please subscribe to my channel so that you never miss any update so let's say if you are given
349:44 - with this singly linked list having three nodes so there arise three cases where we can delete
349:51 - a node from the singly linked list one would be if we provide the position as one then we are
349:57 - telling that we want to delete the first node of the singly linked list and let's say if we
350:02 - provide position two then we are saying that we need to delete the second node which is between
350:09 - node one and node three and as we are assuming that we are starting from position one
350:15 - with first node here node having data as eight will be position one this would be position two
350:21 - and we want to delete this node and after this deletion node having values eight will not point
350:26 - to this node it will point to node one and the third case would be let's say if we want to delete
350:33 - the last node so we'll pass the position as three this is position one position two and
350:39 - position three so this node will be deleted and the second last node which is this node will point
350:44 - to null after this deletion so let's see these three cases so let's say if you want to delete
350:53 - the first node so we simply provide a position as one
350:59 - so in the code we simply check whether position is equal to one or not so if position is equal to
351:04 - one then if part will be executed and in order to delete this node which is being referred by head
351:11 - what we simply do is we simply assign value of head dot next to head so head dot next is the
351:18 - second node so we'll simply assign head dot next value to head so now head will point to the second
351:25 - node so it looks like this so as we are deleting the first node head is pointing to that node so
351:33 - we can't directly delete this node because if we directly delete this node then the rest of the
351:38 - nodes will also get removed so first we do is we simply assign head dot next value to head so that
351:45 - the rest of the singly linked list is being referred by head because after deleting this node
351:51 - our singly linked list will become tan one and null so once this assignment is done
351:59 - this node is being not referred by any other node so this will be garbage collected
352:05 - so it looks something like this that now our singly linked list becomes head is pointing
352:11 - to node having value as tan and node having value as tan is pointing to a node having value as one
352:18 - moving ahead now let's say if we are given with this singly linked list having four nodes
352:26 - and let's say if i want to delete any node in between of the singly linked list so let's say
352:31 - if we call delete method with value as three which means we want to delete the node at position three
352:39 - which is this node now friend as it is a singly linked list in order to delete this node
352:46 - we need to somehow traverse to its previous node so how we can traverse to this previous node is
352:52 - let's see the algorithm we check whether position is equal to one or not so
352:57 - position is equal to three so this condition comes out to be false in the else part as you
353:04 - want to delete the node at position three we need to somehow reach to position two
353:10 - so what we do is we simply create a temporary list node by name previous
353:14 - we'll assign a value head to it so it will simply start from the first node
353:20 - and our task is to make it reach to a node having value as position minus one so here
353:27 - as we have already started with head we will create a count variable having value as one
353:34 - because this count variable will help us reaching previous to a node just previous to a position
353:41 - from where we want to delete this node which is this position so we need to provide a while loop
353:49 - and in this while loop we provide a condition as count should be less than position minus one
353:54 - so position value is three and if we do minus one it becomes two
353:58 - so one is less than two so the condition in while loop comes out to be true
354:05 - and inside this while loop we simply traverse previous to its next position
354:09 - by assigning previous.next to previous so previous next is pointing to this node
354:16 - so after this assignment previous will point to its next node via this reference
354:20 - so it would look something like this
354:26 - and as we have incremented previous to by one position will increment count by one
354:32 - so count becomes two
354:36 - now we'll again check whether value of count which is two is less than
354:40 - position minus one or not so three minus one is two so two is not less than two
354:45 - so this condition comes out to be false and while loop will terminate and here you can see
354:50 - that as you want to delete the third position we have reached to position two via this while loop
354:57 - so after this while loop now our task is to delete the node at position three
355:04 - now as you want to delete this node and after its deletion this node next should point to this node
355:12 - because we don't want to remove this node along with this node we only want to remove this node
355:18 - so our task is to break this link and create a link from this node to a node after the node
355:24 - which you want to delete so at the first step what we do is we can't directly remove this link here
355:31 - because if we remove this link then this complete singly linked list will be garbage collected
355:38 - and in order to reach this node we also need a pointer to this node as well because if we
355:44 - have pointer to this node then we can use its next value to reach this node because we want to
355:49 - somehow assign previous next value which is this value to this node so at the first step what we
355:57 - are doing is we are creating a temporary list node having value is current and we are assigning
356:03 - previous next value which is this node so it would look something like this that current is pointing
356:10 - to previous next and after this it becomes very easy to delete this node as we discussed
356:20 - previous next should not point to this node it should point to this node the node next to
356:27 - our current so what we do is we simply assign value current dot next to previous dot next
356:35 - so here you can see current next is pointing to this node and previous next is pointing to current
356:42 - so we need to break this link and we want this link to point to current next because if we break
356:50 - this link and we assign it to this node then this node can be freed up easily so when this
356:55 - assignment will be done current next value which is this node will now get referred by previous
357:03 - next so it would look something like this that this link will go away and previous next will
357:10 - now point to current next so it would look something like this now previous next is pointing
357:17 - to current next because we want to free this node from the singly link list and after this
357:25 - assignment when this method will get complete we know that current was part of this method as a
357:32 - local variable so now current will be simply garbage collected because there won't be any
357:37 - reference to this node after this method gets over so it would look something like this
357:42 - that it would be deleted and now if we rearrange it it would look something like this that now node
357:49 - 10 is pointing to node 1 so this was the case when we deleted a node which was between the singly
357:57 - link list so now let's say if we are given with this singly link list and we want to delete the
358:02 - last node which is at position 3 so we'll call delete method we'll pass the position as 3
358:09 - and the algorithm remains the same at the first step we check whether position is equal to 1 or
358:15 - not so position is equal to 3 so this condition comes out to be false now as we want to delete
358:23 - the node at position 3 we somehow need to traverse to position 2
358:29 - so for that we create a temporary list node previous which starts from head
358:36 - we create an integer variable count which starts from 1
358:43 - so now in order to reach to a node which is previous to node which we want to delete
358:48 - we simply provide a while loop so now here you can see this count variable will help this previous
358:56 - to reach to a position which is just before the node which you want to delete so we provide
359:03 - condition as count should be less than position minus 1 because we have initialized already
359:08 - count by 1 and previous is already pointing to head so here you can see that value of count is 1
359:16 - if we do position minus 1 we get 3 minus 1 which is 2 so 1 is less than 2 so this condition comes
359:22 - out to be true and inside this while loop we simply traverse previous.next node by assigning
359:31 - previous.next value to previous so previous is pointing to this node and its next is pointing to
359:38 - this node so after this assignment previous will point to second node via this link
359:46 - we will increment count by 1 count becomes 2
359:55 - and now here you can see this condition comes out to be false because 2 is not less than 2
360:01 - so this value will terminate and we know that we have reached
360:06 - to a node which is just previous to node which we want to delete which is at position 3
360:10 - so at the first step what we are doing is we are simply creating a list node current
360:18 - which will hold the value of previous.next so previous.next is this node which we want to
360:25 - delete so current will point to this node and now using previous and current will simply break this
360:33 - link and will assign this link to current.next because we want to free this node so we can only
360:41 - free this node if we break this link so here what we do is we simply assign value of current.next
360:48 - which is null to previous.next so this link will go away and previous.next will point to current.next
360:59 - so after this method gets over here you can see current was a local variable
361:07 - so this node won't be referred by any other node so this will be simply garbage collected
361:13 - and our singly linked list will become a list having two nodes 8 and 10 and the last node will
361:19 - be removed so friends in this video we saw that how we can delete a node from a given position
361:26 - in a singly linked list i hope you have find this information useful and in case if you have
361:33 - find this information useful then please like this video and if you are new to my channel then please
361:38 - subscribe to my channel so that you never miss any update thanks have a nice day
361:47 - hello everyone so in our previous video we discussed about that how we can delete a node
361:52 - from a singly linked list at a given position so in our last video we saw the animation of the
361:59 - algorithm step by step now in this video we'll actually code the algorithm and we'll test its
362:05 - working so in our singly linked list class which has a head of type list node as an instance
362:11 - variable here we have coded many methods which are part of singly linked list
362:23 - now here i will be coding the method as delete which will take in a position
362:28 - and based on that position that particular node will be deleted from the singly linked list
362:34 - so let's say i give the method name as public void delete
362:41 - which takes in a position so friends here you can even return the list node which you just
362:48 - deleted via this method but i am keeping it as void and here we are assuming that position
362:59 - is valid
363:00 - and starting from one so let's say for example our linked list has few nodes such as three
363:14 - four seven eight and let's say nine
363:21 - now here you can see the linked list has five nodes three four seven eight and nine
363:32 - so three is at position one four at position two seven at position three eight at position four
363:40 - and nine at position five so let's say if we want to delete the node from position one so this node
363:47 - will be removed and then linked list will have this these nodes if we want to delete a node
363:53 - which is in between then let's say if you want to delete node as three so seven will be deleted
364:00 - and the remaining list will be three four eight and nine here four will simply point to eight
364:06 - and seven will be removed from the singly linked list and let's say if we want to delete the last
364:12 - node so here you can see as there are five nodes and if we pass the position as five
364:17 - then nine will be deleted so let's see the algorithm so based on our assumptions
364:24 - that position is valid and starting from one we provide a fls condition
364:31 - the first step we check whether if position is equal to one which means if position is equal to
364:38 - one it means that we are simply removing the first node of the singly linked list so here
364:45 - as head is pointing to the first node after its removal head should point to the second node
364:52 - so we'll simply assign head dot next value to head so for example here if you see head is pointing
365:01 - to node three and if you want to delete the node from position one then after node three
365:08 - gets deleted our singly linked list will become four seven eight nine because head will now point
365:14 - to four so we can simply do head equals to head dot next which will assign the next value which
365:22 - is this value to head so this is the first case so in the else part we will see that how we can
365:32 - remove a node from a singly linked list which is in between of these nodes or at the end of the
365:38 - singly linked list so both these cases will be covered in else part so here let's suppose if
365:44 - you want to delete the fourth node which is at position four now the idea behind this algorithm
365:50 - is which we also discussed in our previous video when we did for the insert
365:58 - here what we do is in order to remove eight from the singly linked list we need to break this
366:04 - linkage from seven to eight and instead of seven pointing to eight seven should now point to nine
366:13 - and once seven will point to nine eight will be removed from the singly linked list so in
366:18 - order to break this linkage we need to first reverse to this node which is just behind this
366:25 - node because we need to use this reference remove this reference link and make sure that seven now
366:32 - points to nine so in order to reach the previous node from eight what we do is we simply create
366:40 - a temporary list node previous
366:46 - and we started from the head and then we'll provide a while loop so that we can reach
366:51 - to this node so how we can reach to this node is we will create a counter variable
367:00 - and as previous is already pointing to head we'll assign it with one
367:04 - and now using count and position we will reach to this node
367:12 - so in the while loop we provide condition as
367:19 - count should be less than position minus one so when count is less than position minus one this
367:28 - while loop will keep on iterating and with each iteration we'll simply traverse previous to its
367:34 - next position by assigning previous.next to previous and we'll simply increment count by one
367:48 - so friends when previous will reach to node seven the value of count will become three
367:54 - and here you can see we pass the value of position as four because we want to delete eight
367:59 - so four minus one is three so three is not less than three
368:04 - so after this value will terminate in order to assign sevens next to nine because we want to
368:10 - break this linkage here what we do is we first reach to eight and how we can reach to it is
368:17 - here you can see previous is already pointing to seven because we have reached
368:21 - to seven in this while loop so here we'll create a temporary node current
368:32 - and we provide the values previous.next so this is the previous and if we do .next we will reach
368:39 - here so current will point to node having value as eight and now as we want to point seven next to
368:47 - nine what we simply do here is to previous.next which is currently pointing to eight
368:57 - we will assign the value as current.next because current next is pointing to nine
369:06 - so now sevens next will point to nine instead of eight via this line so after this line
369:14 - nine this link will be gone and there will be link from seven to nine so eight once this method
369:22 - gets terminated eight will be garbage collected so this is the code to delete a node from a
369:28 - singly linked list from a given position so in our main method now let's test it's working
369:37 - so here in our previous video we discussed about the insert method so let's say if i run the code
369:45 - so
369:49 - you see the currently the linked list has five nodes two four three five seven so we'll use
369:57 - the same linked list and we'll delete the first node the node in the middle and the last node
370:04 - so here if i do delete one which is at position one so this is the singly linked list which we
370:15 - saw while running the program so two will be removed so let's run it so here you can see it
370:27 - printed four three five seven because two got removed and now let's say
370:37 - let's say now linked list has four three five seven and we want to remove
370:42 - node five which is at position three because two is already removed
370:48 - and we are removing five which is at position three so we'll call delete with position three
370:55 - so now it should print four three seven because five will be removed
371:05 - so here you see it printed four three seven
371:09 - now we have four three seven and let's say we want to remove the last node which is seven
371:14 - so four is at position one three is at position two and the last node seven is at position three
371:20 - so we'll again call delete with position three and if i run it should print four and three
371:31 - so here you can see it printed four and three so friend this is how we can delete a node from
371:39 - a singly linked list from a given position and here we are assuming that position should be
371:46 - valid that it should lie into the boundaries of our singly linked list
371:52 - so friends i hope you have liked this information and in case if you like this information then
371:56 - please like this video and if you are new to my channel then please subscribe to my channel so
372:02 - that you never miss any update thanks have a nice day hello friends welcome to my new data structures
372:10 - and algorithm in java tutorial series video friends in this tutorial we will discuss
372:15 - how to search an element in a linked list in java
372:20 - so friends in our previous tutorial we discussed how to create a singly linked list
372:25 - and also we discussed about the few of the concepts associated with the linked list
372:30 - so in this tutorial we will discuss how to search an element in a singly linked list through a java
372:35 - program so here you see that there is a simple linked list having say four nodes with the data
372:41 - as 10 8 1 11 and we are giving a head which is pointing to the first node so let's say
372:49 - suppose we want to search for a key having a data with a value 1 so looking at the linked list we
372:55 - can see that the third node has a data with a value 1 so in order to search this key there is
373:01 - an algorithm for it which can search this key into this singly linked list so let's demonstrate
373:07 - this algorithm quickly so in order to search this key into the singly linked list what we'll do
373:14 - we'll first create a node which will name as current and this current will point to the head
373:21 - so which is the first node of our linked list now moving ahead so idea behind this algorithm is
373:27 - we will traverse the singly linked list completely till the end and we'll check for the data and
373:33 - we'll match it with the search key and if it is if they are equal then we'll return true and if
373:38 - they are not then we'll return false in a while loop we'll place a condition where the current
373:44 - is not equal to null till then loop this so currently we see this current is pointing to
373:51 - the first node so it's not null so we'll it will go into the while loop and it will check that
373:59 - whether current.data is equal to the search key so currently the current.data points to 10
374:07 - because the data inside this first node is 10 so we'll check that whether 1 is equal to 10 or not
374:14 - so it's not equal to 10 so this condition comes out to be false and
374:20 - we'll go to next step so we will just traverse the current to its next so if we if you see this
374:27 - current points so first and its next points to the second node so we'll traverse the current to
374:32 - the second node moving ahead so again in while loop we'll check whether current is equal to null or
374:41 - not so here current points to the second node so it's not null so it enters the while loop
374:48 - and then we'll check whether current.data is equal to the search key or not
374:52 - so here current.data points to 8 and we'll check that whether 1 is equal to 8 or not
375:00 - 1 is not equal to 8 so this condition comes out to be false and we'll go to the next step
375:08 - so the next step is so what we'll do we'll just traverse the current node to its next so
375:15 - if you see the current points to the second node and its next which is this points to the third
375:20 - node so we'll traverse it to the third node and then again we'll execute the condition in while
375:29 - loop we'll see that current is not equal to null because it's points to the third node
375:34 - and we'll go inside the loop and here we'll check whether current.data is equal to search key or not
375:40 - so current.data which is equal to 1 here we see that search key and current.data are equal
375:49 - so we have actually found our element so what we'll do so we'll just
375:57 - we'll just return true and we'll print a message as that search key found
376:05 - so similarly if we see the negative condition that whether suppose we want to make a search
376:10 - for the key having a value 12 so looking into the list we see that 12 is not inside this linked list
376:17 - so we'll see the algorithm of it so first we'll create a current node which will point to the
376:23 - head so below we'll check whether this current is equal to null or not
376:31 - and similarly we'll see whether this current.data is equal to search key or not so for the first
376:38 - iteration it's not equal so we'll simply traverse the current to the second node
376:47 - we'll again check whether current is equal to null or not
376:51 - so we see this current is not equal to null so this while loop executes
376:57 - and current.data is also not equal to search key so
377:01 - we'll just traverse the current to the third node
377:11 - and similarly we'll again check whether current is equal to null or not
377:15 - so as current points to third node so it's not equal to null
377:21 - so the while loop executes and we'll check whether current.data is equal to search key or not
377:26 - so one is not equal to 12 so again this condition fails and we'll just
377:35 - so we'll just traverse the current to its next node which is the fourth node
377:44 - and again we will check whether current is equal to null or not so it's not equal to null
377:49 - we'll check current.data is equal to search key or not so current.data is 11 and search key is
377:55 - 12 so they are not equal so we'll traverse the current to its next so now here you see that
378:04 - last node's next point to the null so the current dot next is null so we'll assign null to this
378:10 - current so it will be something like this so now current points to null and if we now execute the
378:18 - while loop so we'll see that whether current is equal to null or not so current is equal to null
378:24 - so this while loop condition breaks out and will simply return false that search key not found
378:34 - so friend this was all about a demo now we'll see how we can code this in java so we'll go to our
378:39 - eclipse initially in our previous tutorials we we created a singly linked list which say if i run
378:47 - the program so this singly linked list was something like this 10 8 1 and 11 and then null
379:02 - so in this tutorial we'll first code the algorithm so we'll create a public method public
379:07 - and we'll give a return type as boolean and we'll create a method say find
379:13 - and to this method we'll give list node the head and
379:23 - integer say search key
379:27 - so basically this method takes in a head and the search key so our first thing will be if say
379:34 - let's say if head is equals to null so suppose we have a linked list where head points null so
379:45 - we'll just return false and then we'll say code whatever we discussed into the slide so we'll
379:56 - create a current node and make it point to head so now we'll give a while loop so inside this while
380:04 - loop will say current not equals to null so we'll iterate till current equals null so inside this
380:15 - while loop will provide a condition which what we discussed in the slide as
380:29 - when current.data equals search key then just return true
380:37 - and after if we'll just traverse the current to its next node so current
380:41 - to current will provide current dot next value and if the current reaches the end
380:50 - and the search keys not found will just simply return false
380:56 - so into our main method what we'll do we'll create a if condition
381:02 - and let's say here we'll say singly linked list dot find and to find will provide head and
381:13 - provide a value one so one is into the singly linked list so we'll provide a value one
381:18 - and we'll set out as
381:20 - search key found or we'll say else
381:37 - search key not found so we saw that the linked list which we created in our previous tutorial has the
381:45 - value as 10 and 1 and 11 so first we are considering the positive case
381:51 - we know that one is in the list so we'll just run the java program
382:00 - so you see it prints the search key found because one is in the singly linked list
382:07 - now let's say suppose you want find whether the linked list contains the value 12 or not
382:13 - so we know that it doesn't contain the value 12 so if i run it
382:21 - so it prints search key not found
382:26 - so friends in this tutorial we'll discuss how you can search an element in a linked list
382:29 - through a java program hope you like this video please like comment share and subscribe my youtube
382:36 - channel you can also visit my blog the link is provided in the description thanks have a nice day
382:42 - hello friends welcome to my new data structures and algorithm in java tutorial series video
382:50 - friends in this tutorial we will discuss how to reverse a singly linked list in java
382:56 - so friends suppose we have a linked list with node say 10 8 1 11 and we provide this linked list
383:03 - as an input so after its reversal the linked list becomes something as 11 1 8 10
383:12 - so basically it reverses the list so here 10 8 1 11 gets reversed and becomes 11 11 1 8 10
383:22 - so let's see this algorithm through a demo so here we see a singly linked list having four
383:27 - nodes say 10 8 1 11 and where head points to the first node so in order to reverse this singly
383:34 - linked list here is the algorithm so we'll see how this algorithm makes this singly linked list
383:40 - reverse so the first step of execution would be we'll create a list node by the name say current
383:47 - and a value of head will be assigned to it so so currently head points to the first node so
383:53 - similarly the current will point to the first node which is 10 and moving ahead
383:59 - then we'll create one more node which will point to null so the name of this node would be previous
384:06 - moving ahead
384:10 - we'll create a node by the name next and we'll assign a null value to it
384:18 - so the basic idea of this algorithm is to traverse each node one by one and and apply some logic
384:24 - to reverse the position of the nodes so in order to traverse each node one by one we'll
384:29 - apply a while loop and in while loop we'll place a condition that till current becomes null we will
384:34 - iterate this while loop so here we'll see this current points to first node and it's not null
384:41 - so this while loop executes
384:45 - and then what we'll do here we see this next point to null so we'll assign the current's next
384:52 - node to it so if you see current points to the first node and its next point to the second node
384:58 - so we'll assign current's next value to the next node so then it will become something like this
385:08 - moving ahead
385:12 - here you see the current next which is this pointer it points to the second node and previous
385:19 - points to the null so idea is to break this pointer and provide it a null value so we what
385:25 - we have done is we will do current dot next and we'll assign a null value to it so it will look
385:31 - something like this so moving ahead
385:38 - and to our previous node we'll assign a value which current holds so it will be the first node
385:46 - so it will become something like this moving ahead
385:50 - and then to simply current will assign the value which is in the next
385:59 - so after the first iteration if i rearrange this nodes it would look something like this
386:09 - so this is the condition with the first while loop now we'll again execute the while loop and we'll
386:14 - see that current is equal to null or not so current points to the second node which is not null
386:19 - so this while loop executes then we'll perform the same steps so here we'll provide the current's
386:26 - next value to the next node so here current next is the third node
386:33 - we'll assign current next value to the next node and similarly
386:40 - to current next we'll provide the value which is present in the previous so
386:44 - so here if you see that current next pointer points to the third node so we'll remove this
386:49 - link and we'll assign it what the previous holds so here previous points to the first node
386:54 - so we'll do something like this
386:58 - so the current next now points to the previous which is the first node so moving ahead
387:05 - to this previous now we'll assign the value current
387:08 - and so moving ahead now we'll simply assign whatever the value present in the next to the
387:16 - current so the current traverses to the third node
387:24 - we'll again iterate the while loop and we'll check whether current is equal to null or not
387:28 - so here current points to the third node which is not equal to null so this loop executes
387:33 - and similarly now we'll assign current next value to the next so it will look something like this
387:42 - moving ahead and to current next we'll assign to the previous so it becomes something like this
387:52 - moving ahead will make previous point to current
387:56 - and finally we'll make current to point to the value which next points
388:05 - so it will traverse the fourth node and again we'll check whether current is equal to null or not
388:12 - so it's not equal to null so now next points to current next so
388:21 - so here current next points to null therefore the next value pointing to null
388:25 - moving ahead and to currents next we'll assign the previous node value so it will look something
388:33 - like this and will traverse previous to point to current so it will look something like this
388:46 - so finally we'll assign current the value of next which is null so now we'll again execute while
388:53 - loop and we'll see whether current equals null or not so here current equals null so therefore
388:58 - this condition comes out to be false and the while loop breaks out so the last step would be
389:06 - to return the previous so this previous becomes our new head so if you see the initially head
389:12 - pointed to 10 and then 8 1 11 and now as previous becomes our new head so now the linguist is
389:19 - reversed so the first node is 11 second is 1 third is 8 and fourth is 10 and then it points to null
389:26 - so here previous becomes our new head and we exit our algorithm so friends let's go to eclipse and
389:33 - see demonstration of this algorithm so friends in our previous tutorial we created one singly
389:39 - linked list so here if i just remove this part and if i run this job program so you see we
389:49 - initially we have created a singly linked list having the nodes as 10 8 1 11 and they are
389:55 - interconnected so let's reverse the singly linked list so in order to reverse the singly linked
390:01 - what we'll do we'll create a method whose return type is the list node and we'll give a method
390:12 - name as reverse so this reverse method will take the head of the singly linked list so we'll say
390:22 - list node head now the first step would be we'll simply check whether head points to null
390:30 - so if it points to null we'll return the head so if
390:38 - head equals null so we'll simply return head
390:44 - and moving head will code our algorithm so we'll create a list node say current
390:54 - and assign a value of head to it then we'll create a list node previous and assign a null value to it
391:05 - we'll create a list node next and assign a null value to it and now we'll create a while loop
391:17 - so the condition and while loop would be
391:22 - current not equals null so here while loop execute till current becomes null
391:28 - so here to our next we'll assign the value as current dot next
391:39 - and to current dot next we'll assign value as previous
391:47 - to previous we'll assign the value
391:50 - which current holds and finally to our current we'll assign the value which next variable holds
392:01 - and the last step would be to simply return previous
392:08 - because previous becomes our new head so we'll return the previous
392:12 - so this is the algorithm so let's see its demonstration so here i will
392:22 - call the reverse and provide the head
392:29 - and list node
392:31 - so whatever is the return from this reverse method will be our head of the reverse list
392:43 - so we'll simply display it now
392:54 - so we'll run this program now
392:55 - so here you see initially the list was 10 8 1 11 and last node was pointing to null
393:05 - and now it becomes 11 1 8 10 where 10 points to null so so this is how we can reverse a singly
393:14 - linked list in java so friends hope you like this video please like comment share and subscribe my
393:20 - youtube channel you can also visit my blog the link is provided in the description thanks have a nice
393:26 - day hello friends welcome to my new data structures and algorithm in java tutorial series video
393:33 - friends in this tutorial we will discuss how to find nth node from the end of the linked list
393:39 - in java so friends given a linked list and a value of n we need to find the nth node from
393:46 - the end of the list if suppose this is the linked list having the nodes as 10 8 1 11 and 15
393:54 - so they are total five nodes and given the value of n is equal to 2 so it means we have to find
394:00 - the second node from the end of the list so if you see the second node from the end of the list is
394:05 - say 1 2 so 11 is the second node from the end of the list so if this is the input then you can see
394:14 - the output would be the second node from the end which is 11 now let's see the demo of the algorithm
394:19 - and it's working so friends here is the linked list having the nodes as 10 8 1 11 and 15 and
394:28 - suppose we are given the value of n is 2 it means we have to find the second node from the end of
394:35 - the list here you can see that this is the algorithm for it so let's see the demo of the
394:41 - algorithm so first we'll create a main pointer which will be pointing to the head and if you
394:48 - see the head points to the first node therefore there would be a main pointer which will point
394:54 - to the first node moving ahead now we'll create a reference pointer which will also point to the head
395:03 - so this is the reference pointer which will point to the first node
395:10 - we will create an integer variable by name count and we'll assign the value zero to it
395:14 - so currently count is zero
395:20 - so friends the idea behind this algorithm is in order to find the nth node from the end of the
395:25 - list what we'll do we have taken these two pointers both of which are pointing to head
395:31 - so if we take the reference pointer we'll make this reference pointer to move n positions so
395:37 - when this reference pointer has traversed the n positions then we'll move main pointer reference
395:42 - pointer together till reference pointer encounters null so when that reference pointer will encounter
395:48 - null the main pointer would be the nth position from the end of the list so let's see how this
395:54 - algorithm works when the value of n is true so currently this while loop will work till the
395:59 - value of count is less than n so currently if you see the value of n is true and the count is zero
396:06 - therefore the count is less than n so it will execute the while loop
396:12 - and now we will just traverse the reference pointer to its next position so here we will
396:18 - assign the reference pointer's next value to the reference pointer so reference pointer points to
396:22 - first node and its next point to the second node therefore assign the reference pointer next value
396:28 - to the reference pointer so it will look something like this
396:30 - moving head will increment the value of count
396:46 - and now again this while loop will execute because count is less than n
396:54 - and similarly we'll move the reference pointer to its next that is assigning the
396:58 - reference pointer next value to the reference pointer
397:07 - and then we'll increment the value of count so now count becomes 2
397:18 - so now the value of count is not less than n if you see the value of n is 2 and count is 2
397:24 - and 2 is not less than 2 therefore the condition in while loop is comes out to be false therefore
397:30 - the while loop breaks out and our execution reaches the second while loop so at this point
397:36 - the reference pointer has moved the two positions from the head and in this while loop what we'll
397:42 - do will move both pointers the reference pointer and the main pointer together till reference
397:47 - pointer encounters the null value so the condition inside it would be this while loop will execute
397:53 - till reference pointer is not equal to null so currently the reference
397:56 - pointer is not equal to null therefore the condition in while loop comes out to be true
398:04 - so first we'll simply traverse the reference pointer to its next value
398:12 - moving head
398:15 - and now we'll move the main pointer to its next value so we'll assign the main
398:19 - pointer's next value to the main pointer
398:30 - again the reference pointer is not equal to null
398:33 - so this while loop will execute will traverse the reference pointer to its next value
398:44 - and similarly we'll move the main pointer to its next value
398:48 - that is by assigning the main pointer's next value to the main pointer
399:00 - so again this while loop condition will be evaluated and you can see the reference
399:03 - pointer is not equal to null therefore this while loop will execute now reference pointer
399:09 - will move to its next value and similarly the main pointer will move to its next value
399:27 - so now once again the boolean value in the while loop will be evaluated and currently if you see
399:32 - the reference pointer points to the null therefore the condition in while loop comes out to be false
399:37 - and this while loop breaks and finally if you see the main pointer is at the second position
399:44 - from the end of the list therefore we'll return this main pointer because this is the second
399:49 - note from the end of the list so friend this was the demonstration of the algorithm let's move to
399:55 - eclipse and see it's working so friends in my previous tutorial i have created this singly
400:01 - linked list class having an instance variable which stores the head and having an inner class
400:07 - which is the list node if you want to see it's working then you can watch my previous tutorials
400:13 - so so in this tutorial we'll write a method which will fetch the anet node from the end of the list
400:20 - so first we'll create a method and the return type of it would be list node let's say we give
400:27 - the name of the method get anet node from end so this method will be taking a value of n
400:42 - now first we'll check if
400:49 - head is null
400:50 - null then just return null
400:58 - then we'll check that if
401:03 - let's say value of n is less than equal to zero so value of n is less than equal to zero
401:09 - then we can throw an exception say throw new you can throw a legal legal argument exception
401:17 - and we'll pass the string as say invalid value n equals
401:36 - moving ahead so first we'll create a list node having name as main pointer
401:43 - and we'll assign the value of head to it
401:48 - similarly we'll create another node which is the reference pointer
401:54 - and we'll assign the value of head to it
401:59 - then we'll create a integer variable count having value as zero
402:07 - now we'll create the while loop which we saw in the slide so while
402:13 - and we'll give condition as count will less than n and we'll simply traverse the reference
402:23 - pointer to its next value
402:30 - that is we'll assign the reference pointer next to reference pointer
402:34 - and we'll increment the count by one and here now let's suppose the
402:41 - linked list has three nodes and if we provide the value of n as say five therefore this reference
402:47 - pointer might reach to a null value so before this we can even if we can check that if
402:54 - if reference pointer is null then we can simply throw an exception
403:13 - we can throw an illegal argument exception we can give string as
403:17 - n is greater than the number of nodes in list so here if suppose reference pointer comes out to
403:35 - be null then the value of n is surely greater than the total number of nodes in the list
403:41 - moving ahead
403:46 - we'll create another while loop
403:51 - and in this while loop we'll provide the condition as
403:56 - ref pointer should not be equals to null and we'll simply
404:02 - and here we'll simply assign the reference pointer next value to the reference pointer
404:13 - and we'll traverse the main pointer to its next value
404:24 - and finally we'll just return the main pointer
404:29 - because this will be pointing to the nth node from the end of the list
404:34 - so if you see that this is the code for getting the nth node from the end of the list
404:39 - and if you go to the main method then i here then here there is a list having five nodes
404:45 - with the value as 10 8 1 11 15 and if i run this it will print the list so here it's 10 8 1 11 15
404:57 - so there are total five number of nodes so let's say if i do nth node
405:08 - so i just created a list node by the name nth node from end and if i call this method
405:17 - okay the nth node from end and if i pass the value as say 2
405:21 - and if i print and here if i print at nth node from end is
405:37 - dot data so now if i run the program
405:43 - you can see it prints 11 because 11 is the second node from the end of the list
405:50 - and suppose if i provide the value as say negative value say minus 1
405:59 - then it throws an exception saying that illegal argument exception say invalid value of n which
406:06 - say invalid value of n which is equals to minus 1
406:13 - and suppose the total number of nodes are five and if i give the value of six which
406:17 - and i wanted six node from the end of the list and if i run this
406:25 - so you can see it will throw illegal argument exception saying that
406:28 - six is greater than the number of nodes in the list so friend this was the working of the algorithm
406:34 - which we saw in the slide hope you like this video please like comment share and subscribe
406:40 - my youtube channel thanks have a nice day hello friends welcome to my new data structures
406:46 - and algorithm in java tutorial series video friends in this tutorial we will discuss how
406:52 - to remove duplicates from sorted linked list in java so suppose we are given a sorted linked list
406:59 - so if you see then the linked list has five nodes having the data is 1 1 2 3 3 so this is
407:06 - a sorted linked list but you can see that there are duplicates into it so you can see one is
407:12 - duplicate and the three is duplicate so in this tutorial we will discuss how to remove these
407:18 - duplicates from the sorted linked list and if you see the output then the output would be
407:24 - like one two three and all the duplicates will be removed so let's move ahead and see
407:31 - the demo of the algorithm so here if you see we are given the linked list which is sorted
407:37 - and having nodes as 1 1 2 3 3 and this is the algorithm which will remove the duplicates from
407:45 - this sorted linked list so let's see working of this algorithm so in order to remove the
407:52 - duplicates from the sorted linked list first we'll do we'll create a list node which will point to
407:57 - the head moving ahead so the basic idea behind this algorithm is we will traverse the linked list
408:07 - through this current pointer and we'll check whether this data of this current node is equal
408:12 - to data of its next node and if they are equal it means we have encountered a duplicate and we will
408:19 - write the logic to remove that duplicate node so here if you see we'll iterate this completely
408:24 - based on this condition so the condition would be the current should not be null and current dot
408:31 - next should not be null so here if suppose the current node reaches this last node so current
408:38 - dot next will be null it means there is no more nodes to traverse therefore this condition is
408:44 - required so let's see how this algorithm works so first this condition will be checked there
408:50 - whether current is equal to null or not so current is not equal to null because it is pointing to the
408:56 - first node and current dot next should not be null so current dot next is also not null because
409:02 - it is pointing to the second node therefore this while loop condition comes out to be true
409:07 - and it will encounter a if statement and here we will check whether current node data is equal to
409:16 - current's next data current data is one and current's next data is also one therefore they are equal
409:26 - so this if statement condition comes out to be true and we have encountered a duplicate
409:30 - so here if log will be executed
409:37 - and in order to remove this duplicate what we'll do
409:42 - we will assign current next next to the current next so here if you see current next points the
409:48 - second node so we have to remove the second node therefore we have to break this point
409:52 - and we have to assign it to the second node so this is the statement for it
409:57 - we will assign current next next to current next so it would be something like this
410:06 - so now current next points to current next next and as this node has no reference therefore
410:13 - this would be garbage collected so moving ahead
410:17 - so now again the condition in while loop will be evaluated so here current is not null and
410:28 - current's next is also not null therefore the condition in while loop comes out to be true
410:35 - and while loop will be executed so now we'll check whether current's data is equal to current
410:41 - next data so current data is one and current next data is two so they are not equal
410:49 - therefore the if block condition comes out to be false and the else will be executed
410:58 - so it means that both the nodes like current and current next are different nodes
411:04 - and they are not duplicate therefore we'll simply traverse the current to its next node
411:11 - and now once again the while loop condition will be evaluated so current is not null and
411:24 - current's next is also not null therefore the while loop will be executed
411:32 - and now we'll check whether current's data is equal to current next data
411:36 - so current data is two and current next data is three
411:41 - so they are not equal so it means that data into both the nodes are different
411:47 - so else condition will be executed
411:51 - and we will assign current next to current so we will simply traverse the current to its next node
411:56 - so now once again the while loop condition will be evaluated and here you can see current
412:11 - is not null and current next is also not null therefore the while loop condition comes out to
412:16 - be true and now it will be evaluated whether current's data is equal to current next data
412:24 - so current data is three and current next data is also three
412:28 - so they are equal it means that we have encountered a duplicate here
412:32 - and we have to now remove this node having the value as three
412:40 - therefore in order to remove this node we have to first break this pointer
412:44 - and we have to assign this pointer to current next next so current points to three and its next
412:52 - points to three and its next points to null therefore we'll assign current next next to
412:56 - current next so it would be something like we'll remove this pointer and we'll assign
413:03 - current next to current next next which is null and as this node has no reference to it therefore
413:10 - this would be garbage collected and now once again the while loop condition will be evaluated
413:21 - so current is not null but current dot next is null so if you see current next points to null
413:29 - therefore this while loop condition comes out to be false and
413:33 - it makes sense because we don't have any more node true traverse
413:37 - therefore this while loop condition breaks out
413:41 - and if you see then we have removed the duplicates from the sorted linked list
413:46 - so head points to one one points to two and two points to three and three points to null
413:53 - so the output would be something like this so friend this was the demo of the algorithm
414:00 - now let's go to eclipse and see the working of the code
414:05 - so friends in my previous tutorials i have created a class by name singly linked list
414:09 - so in this class we have this instance variable which holds the head of the linked list
414:16 - and it is private inner class list node which will be holding the nodes in the singly linked list
414:24 - and if you want to see the working of this code then you can watch my previous tutorials
414:31 - so here we have simply created a singly linked list and we have
414:34 - inserted few nodes having the data as one one two three three and if i run this class
414:42 - so it will print the linked list as one one two three three so this is the singly linked list
414:48 - which we saw in our slide and it has duplicate as one and three
414:55 - so let's write the code to remove this duplicate from sorted linked list
415:04 - we will give return type as void remove duplicates
415:14 - so this is the method where we'll write the code to remove the duplicates from
415:18 - sorted linked list so first we'll provide if conditions say
415:22 - if head is null then simply return from this method
415:37 - and next we'll code the algorithm which we saw in the slide so
415:42 - we'll create a list node by name current and we'll assign the value head to it
415:52 - then we'll create a while loop and we'll provide the condition as current not equal to null
416:02 - and current dot next not equal to null and inside this value we'll provide if block as
416:13 - if current data is equal to current dot next dot data so this is the condition to check
416:29 - whether adjacent nodes are duplicates or not so if they are duplicate then we'll simply
416:35 - remove the duplicate node by current dot next and we'll assign the value to it as current
416:40 - dot next dot next and we'll provide a else block as so suppose the adjacent nodes are
416:53 - not same then we'll simply iterate current to its next version by assigning current's
417:00 - next value to current so friends this is the code to remove the duplicates from sorted singly linked
417:08 - list now in the main method i will simply call the remove duplicates and let's again
417:19 - print the linked list so if i run the code now
417:28 - so here you can see initially the linked list was 1 1 2 3 3 and after removing the duplicates
417:35 - it became 1 2 3 so friends this was the code to remove the duplicates from sorted linked list
417:44 - i hope you like this video please like comment share and subscribe my youtube channel
417:49 - thanks have a nice day hello friends welcome to my new data structures and algorithm in
417:56 - java tutorial series video friends in this tutorial we will discuss how to insert a
418:03 - node in a sorted singly linked list in java so friends let's suppose we are given as
418:09 - sorted singly linked list having four nodes say 1 8 10 and 16 and suppose we want to add a node
418:19 - having data as 11 to it friends here we want to insert this node such a way that the sorting
418:25 - order is maintained in the linked list therefore in order to insert this new node into this sorted
418:33 - singly linked list then here is the algorithm for it so currently you see the head points to first
418:40 - node having data as 1 then it goes to 8 10 16 and we want to insert the node having data as 11
418:50 - and we want to insert in such a way that after insert the sorting order is maintained in the
418:55 - list so let's see the working of this algorithm step by step so in order to insert a new node
419:04 - in a sorted singly linked list first we'll create a list node by name current which will point to
419:09 - the head so here if you see the head points to the first node therefore the current will also point
419:16 - to the first node then we'll create a temporary node which will point to null
419:30 - so this while loop will execute till current is not equal to null and
419:33 - current data is less than new nodes data so we'll see this algorithm step by step and
419:41 - after we complete this value you will come to know that why these conditions are needed
419:47 - so here if you see current should not be null so current is pointing to first node
419:51 - and it is not null and current data so current data is 1 here and new node data is 11 so 1
420:03 - is less than 11 therefore this while loop condition comes out to be true
420:06 - so in first step what we'll do we'll assign the value of current to temp
420:15 - so current points to the first node therefore when we assign the current's value to the temp
420:20 - it it becomes something like this so now temp points to the first node
420:30 - and then we'll traverse the current to its next node by assigning current.next value to current
420:36 - so current points to first node and next point to the second node therefore we'll simply assign
420:41 - the current's next value to current so it would be something like this
420:47 - so now current points to the second node moving ahead
420:53 - now again current is not equal to null and current data which is 8 is also less than
421:01 - new node data which is 11 therefore this while loop condition comes out to be true
421:09 - and we'll assign current's value to the temp so it would look something like this
421:19 - and then we'll simply traverse current to its next position by assigning current.next value to current
421:24 - moving ahead
421:32 - so again current is not equal to null and current.data which is 10
421:42 - is also less than new nodes data which is 11 therefore this while loop condition comes out to
421:47 - be true and we'll simply assign current's value to the temp so it would look something like this
422:00 - and then we'll simply traverse current to its next position by assigning current.next value to current
422:06 - moving ahead so now current is not equal to null and if you see current data
422:19 - so current data is 16 and new node data is 11 therefore current data is not less than new nodes
422:26 - data therefore this while loop condition comes out to be false and this while loop breaks
422:31 - so if you see we have traversed current to the node which is just greater than the value of new
422:39 - node and we have also kept a temporary node which is just behind the current node so the idea behind
422:47 - keeping this temporary node is once this while loop breaks out then we need to insert new node
422:55 - just between 10 and 16 because 11 is the value between 10 and 16 so in order to put the node
423:02 - between 10 and 16 we need this temp node because this pointer will now be pointing to new node
423:10 - and new node next which is pointing currently to null will point to current so in order to insert
423:16 - this new node into sorted singly linked list what we'll do first we'll first make new node next
423:24 - point to current so new node next currently points to null so instead of pointing to null
423:31 - now we want to insert it between 10 and 16 therefore this next should point to 16 and if
423:38 - you see current points to 16 so we'll simply assign the value of current to new nodes next
423:43 - so this is the step for it so it would look something like this
423:52 - so new node next points to 16 which is also referenced by current moving ahead
424:03 - now in order to insert the node between 10 and 16
424:06 - temp next points to 16 therefore we need to break this link and we need to assign this link to new
424:14 - node so what we'll do we'll assign new nodes value to temp.next so temp.next currently pointing to
424:22 - current will break this link and we'll assign it to new node so it would look something like this
424:29 - and finally when we align this linked list it would look something like this
424:40 - so you see we have inserted 11 just between 10 and 16 and also after insert the linked list
424:46 - has maintained its sorted order therefore we'll simply return the head
424:53 - so friend this was the demonstration of the algorithm now let's go to Eclipse and see
424:59 - the working code so friends in my previous tutorials i have created a singly linked list
425:06 - class which has an instance variable of type list node which is actually the head of our linked list
425:13 - it also has a say inner class by name list node which helps us in storing the data in the linked
425:20 - list so in order to know more about its working please watch my previous tutorials
425:26 - so in this tutorial we will simply write a method which will insert a node in a sorted
425:32 - singly linked list so i'll just create a method public and i will give a return type to it as
425:39 - list node so let's argue method name is insert in sorted list this method will take an argument
425:53 - of integer by name value so this value will be stored as a part of node into the sorted
426:02 - singly linked list so first we'll create a list node for this value so i'll give the name to it
426:09 - as new node and then we'll give a condition as if
426:26 - head is null then simply return this new node
426:31 - here
426:37 - moving ahead we'll create a list node current which is saw in slide and we'll assign a value
426:45 - head to it then we'll create a list node by name temp we'll assign null to it
426:55 - so first we'll create a while loop so in this while loop we'll provide a condition as current
427:08 - not equal to null and
427:13 - current dot data is less than new node dot data so we'll iterate till current is not null and
427:24 - current data is less than new nodes data so in while loop first step would be we'll assign
427:30 - the value of current to temp and we'll simply traverse current to its next value
427:41 - so basically these are the two statements which we'll be providing into the file loop
427:46 - and after while loop gets executed we know that that current now points to a node which is just
427:52 - greater than the new nodes data and temp points to the node which is just lesser than the new
427:57 - nodes data therefore first step would be to new node next we'll assign the value of current
428:08 - and then to temp next we'll assign the value of new node and finally we'll just return head
428:22 - so friend this is the method by which we can insert a node into sorted singly linked list
428:28 - so here if you see in the main method currently there are four nodes by data is 1 8 10 16 so they
428:35 - are the same what we saw in the slide so if i print this singly linked list
428:42 - you can see it print as 1 8 10 16 and null so therefore currently this is in sorted order
428:50 - and let's suppose i call the method insert in sorted list and give the value as 11
428:59 - so friends once this method is executed it will insert 11 into sorted singly linked list
429:07 - so i will just print it again
429:12 - and if i run the program
429:16 - so currently it was a sorted linked list and after insertion of 11 the sorting order is still
429:21 - maintained so this is the algorithm by which we can insert a node into sorted singly linked list
429:29 - so friends i hope you like this video please like comment share and subscribe my youtube channel
429:35 - thanks have a nice day
429:38 - hello friends welcome to my new data structures and algorithm in java tutorial series video
429:44 - friends in this tutorial we will discuss how to remove a given key from singly linked list in
429:49 - java so here if you are given a singly linked list having five nodes say 1 8 10 11 and 16
429:57 - where head points to the first node and if suppose we want to delete a key having the data
430:04 - as 11 so currently if you see the fourth node has data as 11 therefore we need to write an algorithm
430:11 - which could delete this fourth node from the singly linked list if you see below the algorithm
430:17 - for it so let's go over to the algorithm step by step so first we'll create a list node by the name
430:25 - current and it will point to head so here current points to the head
430:35 - then we'll create a list node by name temp and it will point to null so this temporary node points
430:42 - to null then we'll traverse the linked list in a while loop and we'll iterate the linked list in
430:51 - such a way that current should not be null and current data is not equal to key so here current
430:57 - points to first node and it's not null and current data which is 1 is not equal to the key 11
431:07 - therefore the condition in while loop comes out to be true
431:13 - so in first step what we'll do we'll simply assign the value of current to temp so current points to
431:20 - first node therefore now temp will point to the first node and in next step we'll simply traverse
431:31 - current to its next position by assigning current next value to current so current points to first
431:36 - node and its next points to second node therefore we'll assign current next value to current
431:41 - moving ahead here current is not equal to null and current data so current data is 8
431:55 - and it's not equal to 11 therefore the condition in while loop comes out to be true
432:02 - so here we'll simply assign the value of current to temp
432:05 - and current points to second node therefore the temp will point to the second node now
432:11 - and we'll simply traverse current to its next position by assigning current dot next value to
432:20 - current moving ahead now again current is not equal to null and current data which is 10
432:35 - is not equal to 11 therefore the condition in while loop comes out to be true
432:41 - we'll simply assign current value to temp and here if you see current points to third node
432:47 - therefore temp will now point to the third node
432:53 - and now we'll simply traverse current to its next position by assigning current dot next value to
432:58 - current moving ahead so if you see current is not equal to null but current data
433:11 - so current data is 11 which is equal to key therefore condition in while loop comes out
433:17 - to be false because current dot data is equal to key therefore the while loop breaks out and
433:23 - and we have traversed the current to the node which we want to delete
433:30 - so here we will check whether if current is equal to null and if current is equal to null it means
433:35 - that we have traversed complete linked list and we haven't found the key therefore we'll simply
433:40 - return from the method and if you see current is not null therefore the condition comes out to be
433:48 - false so finally in order to remove this node which is pointed by current and having value as
433:57 - 11 we need to break this link so the temporary node which we have created earlier was used to
434:04 - hold the previous node position so that once we found the node having the
434:08 - value as key we can simply delete it through the temporary node so currently if you see temp dot
434:15 - next point to this current node so we need to simply remove this link but if we remove this link
434:20 - then the node after current will also be removed therefore we need to assign temp's next value
434:29 - to current's next value so if you see temp next points to current and current next point to the
434:36 - node having value 16 therefore we'll simply assign current next value to temp next
434:43 - so it would look something like this first this link will be removed
434:48 - and when we assign current next to temp next it would look something like this
434:54 - so now you can see temp next points to the current next node
435:02 - and once this method get executed then as current is a list node on the stack
435:08 - it would be garbage collected and finally when we rearrange the link list it would look something
435:14 - like this so friends this was the demo of the algorithm so let's go to eclipse and see the
435:21 - working code we'll also see few of the edge cases there so friends in my previous linked list
435:29 - tutorials i've created a class by name singly link list and this class has an instance variable list
435:35 - node by name hand which holds the data into our singly link list and it has also a private inner
435:43 - class by name list node so this class is responsible for holding the data into the singly link list
435:49 - and if you want to see the working of this code you can watch my previous tutorials
435:57 - so in this tutorial we will simply code the algorithm which we saw in the slide
436:02 - so let's create a method public void delete node
436:10 - so i've just created a method by name delete node and it will take a integer values a key
436:21 - so based on this key we'll remove that node which holds the value of key
436:28 - so in first line we'll just create a list node by name current and we'll assign the value head to it
436:35 - then we'll create a list node by name temp and assign a null value to it
436:47 - we need to code an edge case which we not saw in the slide so that edge case first if suppose head
436:53 - data matched with the key then we need to handle it separately so we can write if
437:00 - so in if condition we can say if let's say current is not equal to null
437:10 - and current dot data equals key so it means that we are handling the case where
437:20 - head data is matching with the key so in that case we need to simply shift the head by one node
437:26 - so to head we'll assign the value as current dot next and we'll simply return from the method
437:39 - so moving ahead we'll now create a while loop which we saw in the slide
437:44 - and the condition would be current should not be equal to null and current dot data
437:53 - should not be equal to key so in first step we'll simply assign temp the value of current
438:01 - because this temporary node will hold the position of the previous node to current
438:05 - and now we'll simply traverse current to its next node
438:13 - and after the while loop we'll give a check whether if current
438:19 - is equal to null that means we haven't found the key in the singly linked list so we'll simply return
438:30 - and suppose if current is not equal to null then then current points to the node we're having the
438:36 - data equal to key therefore we need to remove that node so the temp node is just the node
438:43 - previous to current so we'll assign current dot next value to temp next
438:54 - so what this will do temp dot next currently point to current but as we need to delete this current
439:00 - node we'll simply assign current next value to temp next now in our main method let's see it's
439:05 - working so i've created a linked list which we saw in the slide and if i run the program now
439:14 - you can see the linked list has five nodes as 1 8 10 11 16
439:21 - now let's say we'll delete the node having the key as 11
439:29 - and we'll again print the linked list
439:34 - so if i run the code now
439:36 - so here you can see initially there are five nodes and after deleting the node having the key
439:46 - as 11 you can see the linked list become as 1 8 10 16 and the node which was in between 10 and 16
439:55 - was removed so for this was the tutorial based on deleting a node with a specific key
440:03 - i hope you have liked this video please like comment share and subscribe my youtube channel
440:08 - thanks have a nice day
440:12 - hello friends welcome to my new data structures and algorithm in java tutorial series video
440:18 - friends in this tutorial we will discuss how to detect a loop in a linked list in java
440:23 - let's suppose we are given a linked list having six nodes say 1 2 3 4 5 6 and which contains a loop
440:35 - so here if you see the head points to the first node first node points to the second
440:41 - second points to third points to fourth points to fifth, fifth point to sixth and six points to
440:47 - third therefore you can see that this linked list contains a loop as three points to four, four points
440:54 - to five, five points to six and six points to three and again it goes on and if you see below
441:00 - is the algorithm to detect whether a linked list contains a loop or not so let's see the demonstration
441:06 - of this algorithm step by step now in the first step we are simply creating the reference of list
441:13 - node by name fast pointer which is pointing to head so it looks something like this so here you
441:20 - see as head points to this first node now fast pointer will be referring to this first node
441:26 - moving ahead
441:30 - we'll also create one slow pointer which will refer to the head
441:35 - so it would look something like this moving ahead
441:38 - now friends we are encountering here a while loop so the basic idea behind this algorithm is
441:48 - in order to detect this particular loop in a linked list so what we are doing here is
441:54 - we know that fast pointer and slow pointer both are pointing to head so therefore they are at the
441:59 - start position now the basic idea behind this algorithm here is we will move slow pointer one
442:05 - step and we will move fast pointer two steps and if suppose the linked list doesn't contain
442:11 - the loop then we know that the last node should point to null therefore we are traversing fast
442:17 - pointer two steps and slow pointer one step because if linked list contains a loop then
442:23 - there will be a situation as slow pointer is moving slowly and fast pointer is moving fast
442:28 - so the fast pointer will never encounter null value and there will be a situation where
442:32 - fast pointer will meet the slow pointer because of the loop nature so here in while loop we are
442:39 - placing a condition as fast pointer should not be null and fast pointer next should not be null
442:45 - now here we know that as the linked list contains a loop therefore the fast pointer will never be
442:50 - null and we are checking that fast pointer next is not equal to null because as we are traversing
442:57 - fast pointer by two positions we need to make sure that fast pointer next is also not equal to
443:02 - null and in while loop you can see we are assigning a value of fast pointer next next to fast pointer
443:09 - as we are traversing it two steps so we need to make sure that fast pointer next should not be
443:13 - null because if it is null then we will encounter null pointer exception therefore the condition
443:20 - we are placing is fast pointer should not be equal to null and fast pointer next also should not be
443:25 - equal to null so currently if you see fast pointer is pointing to the node first having data as one
443:32 - and its next is also not null therefore the condition in while loop comes out to be true
443:42 - so in the first step what we are doing we are just traversing fast pointer to two steps
443:47 - so here if you see we are assigning fast pointer next next value to fast pointer
443:53 - so here fast pointer is pointing to the first node its next is pointing to the second node
443:58 - and its next is pointing to the third node therefore here we are simply traversing fast
444:03 - pointer by two positions so it would look something like this so we have simply traversed fast pointer
444:11 - by two positions moving ahead now here we are simply traversing slow pointer by one position
444:22 - so we are assigning slow pointer next value to slow pointer so slow pointer is currently
444:27 - pointing the first node and its next is pointing to the second node so we are simply traversing
444:33 - it by one position so it would look something like this and then we are simply checking that
444:44 - with a slow pointer is equal to fast pointer or not so we are doing this step is because there
444:49 - will be a situation where fast pointer will traverse all the nodes and again meet the slow
444:54 - pointer because the linked list contains a loop and there is no end to the linked list
445:00 - so currently slow pointer is pointing to the node second and fast pointer is pointing to the node
445:04 - third therefore they are not equal so the condition in if block comes out to be false
445:12 - and now we'll again check that whether fast pointer is equal to null or not
445:15 - and its next is equal to null or not so fast pointer is pointing to third node
445:20 - therefore it's not equal and fast pointer next is pointing to fourth node therefore it's not equal
445:27 - so the condition in while loop comes out to be true
445:32 - and then in the first step we are simply traversing fast pointer by two positions
445:37 - so here if you see fast pointer next is pointing to the fourth node and its next is pointing to
445:42 - fifth node so we are simply traversing fast pointer from third position to fifth position
445:49 - by assigning fast pointer next next value to fast pointer
445:54 - so it would look something like this moving ahead
446:01 - then we are simply traversing slow pointer by one position
446:04 - by assigning slow pointer next value to slow pointer so it would look something like this
446:09 - moving ahead
446:17 - now we are again checking whether slow pointer is equal to fast pointer or not
446:21 - so you can see slow pointer is pointing to third node and fast pointer is pointing to fifth node
446:26 - therefore they are not equal hence the condition in if block comes out to be false
446:33 - now we'll again check the condition in while loop so fast pointer is currently pointing to
446:38 - fifth node therefore it's not null and fast pointer next which is sixth node is also not
446:44 - null therefore condition in while loop comes out to be true
446:50 - so in the first step we are simply traversing fast pointer by two position
446:55 - and here you can see we are assigning fast pointer next next position to fast pointer
447:00 - so fast pointer next is six and its next is three so we are simply traversing the fast
447:07 - pointer from fifth position to third position so it would look something like this
447:15 - moving ahead
447:20 - now here we are simply traversing slow pointer by one position by assigning slow pointer next
447:25 - value to slow pointer so slow pointer is pointing to third node and its next is pointing to fourth
447:31 - node so we are simply traversing it by one position so it would look something like this
447:38 - moving ahead
447:41 - we are again checking whether slow pointer is equal to fast pointer or not
447:45 - so fast pointer is pointing to third node slow pointer is pointing to fourth node
447:50 - therefore they are not equal so the condition in if block comes out to be false
447:59 - and now we are again checking in the while loop that fast pointer is equal to null or not
448:04 - so fast pointer is pointing to third node therefore it's not equal
448:07 - and fast pointer next which is fourth node which is also not null
448:11 - therefore the condition in while loop comes out to be true
448:18 - now we are simply traversing fast pointer by two positions by assigning fast pointer next
448:23 - next value to fast pointer so here fast pointer is currently pointing to third node and its next
448:30 - is pointing to fourth node and its next is pointing to fifth node so we are simply traversing fast
448:36 - pointer from third position to fifth version so it would look something like this moving ahead
448:48 - now we are simply traversing slow pointer by one position by assigning the slow pointer next value
448:53 - to slow pointer so slow pointer is pointing to fourth node and its next is pointing to fifth
448:59 - therefore we are simply traversing it by one position so it would look something like this
449:06 - moving ahead
449:11 - and now we are checking whether slow pointer is equal to fast pointer or not
449:15 - so friends here slow pointer is equal to fast pointer therefore we are very much sure that
449:19 - this linked list contains a loop so the condition you see in the if block comes out to be true
449:29 - and we simply return true because we have identified that this linked list contains a loop
449:37 - so friends here we saw the demonstration of the algorithm now let's go to eclipse and see the
449:41 - working code so friends in my previous tutorial i had created one class by name singly linked list
449:49 - now this class has a list node by name head which is an instance variable and we also created one
449:56 - inner class by name list node you can watch my previous tutorials in order to understand more
450:02 - about how to implement a singly linked list so in this tutorial we will write a code which we
450:07 - saw in the slide and see it's working so first i will create one method as public
450:21 - boolean and let's say i give method name as contains loop
450:35 - so basically i will write the code inside this method contains loop and it will return
450:40 - me back a boolean value that's whether the linked list contains a loop or not
450:44 - so in the first step we'll create a pass pointer reference variable
450:54 - and we'll assign the value of head to it in the second step we'll create a slow pointer
451:03 - and we'll assign the value of head to it
451:04 - moving head now we'll create one while loop
451:12 - which we saw in the slide and we'll provide condition as fast pointer should not be equal
451:20 - to null and fast pointer next should not be equal to null and in the while loop
451:31 - we'll traverse fast pointer by two positions so we're simply assigning fast pointer next
451:39 - to next value to fast pointer
451:45 - so we are simply traversing fast pointer by two positions
451:49 - and then we are simply traversing slow pointer by one position so we are assigning slow pointer
451:57 - next value to slow pointer
452:02 - and then we are providing an if check that if slow pointer is equal to fast pointer
452:14 - then simply return true and it means we have identified that the linked list contains a loop
452:21 - and after the while loop if suppose we haven't found any loop then we simply return false
452:33 - so friend this is the algorithm which detects whether the linked list contains a loop or not
452:39 - now we'll also create one more method which will actually create a linked list
452:44 - having a loop so public void create a loop in linked list
453:02 - so in this method we'll create few nodes we'll assign them in such a way that it will create
453:06 - a loop inside a linked list so friends in the slide we saw an example where the linked list
453:13 - contains six nodes and which was forming a loop so i will simply replicate that example here
453:19 - so for that i will create list node say first equals new list node and i give value as one
453:32 - now i will create five more list nodes
453:34 - so i'll just give them values two three four five six and i'll change the name as second
453:50 - third fourth fifth sixth
453:59 - now as we saw in the slide that head points to the first node therefore we'll simply assign
454:06 - value of first to head and we also know that first next was second second next is third
454:20 - third next is fourth fourth next is fifth fifth next
454:40 - is sixth and in order to create a loop the example we saw in the slide was sixth node
454:51 - next refer to the third node so here we simply assign value of third to six next so six
454:58 - dot next and we'll assign value of third to it so this will create a linked list containing a loop
455:08 - where first is pointing to second second is pointing to third third is pointing to fourth
455:12 - fourth is pointing to fifth fifth is pointing to sixth and sixth is pointing to third
455:17 - so it will create a loop now in the main method let's test the working of this algorithm
455:26 - so in the first step we have simply created an instance of singly linked list
455:30 - now in the second step i will call this method create a loop in linked list so create
455:37 - so after this method they executed the head will be pointing to a linked list containing a loop
455:45 - so in the third step we'll simply print the output of contains loop on the console so here
455:52 - so here we'll simply call contains loop method and whatever the outcome of contains loop is
456:05 - we'll simply print it on the console so currently you can see the linked list which we have created
456:10 - in this create a loop in linked list method has a loop so the contains loop method should return
456:16 - true so if i run the code so you can see it return true because the linked list which we
456:25 - created in this method had a loop now here suppose i don't assign the value of third to six dot next
456:32 - so if i come in this line then we know that this linked list is not containing a loop so if i run
456:38 - the code now you can see it returned false because here we have break the link in the linked list
456:47 - which was actually making a loop so friends this was the algorithm to detect whether a linked list
456:53 - contains a loop or not i hope you like this video thanks have a nice day
457:02 - hello everyone so in our previous video we discussed about that how we can detect a loop
457:08 - in a singly linked list now in this video we will see that how we can find the starting point of
457:14 - that loop so for example so here you can see the let's suppose we are given with this singly linked
457:20 - list which contains six nodes one two three four five and six but here you can see that from three
457:28 - it goes to four and from four it goes to five from five it goes to six and from six it again
457:37 - goes back to three so here you can see that there is a loop in this singly linked list
457:43 - so in our previous video we saw an algorithm where we detected the loop in a singly linked
457:49 - list so this is the code for that now in this video we will see that how we can find the starting
457:55 - point of that loop so currently if you take this example then three is the starting point of that
458:01 - loop because from three loop starts and ends at three only so our task is to find the starting
458:09 - node from where the loop starts so from this algorithm contains two parts one is the detection
458:16 - of the loop and the second part is to actually find the starting point of the loop so the first
458:23 - part of detecting the loop we discussed in our previous video so in this video we will see that
458:30 - how we can find the starting node of the loop in a singly linked list so friend let's see the
458:37 - demonstration of this algorithm step by step but before we begin in case if you are new to my
458:44 - channel then please subscribe to my channel so that you never miss any update so friends here
458:51 - you can see this is the first part which we already discussed in our previous video where what we did
458:56 - was we created two pointers one was the fast pointer another was the slow pointer we started
459:04 - both the pointers from the head and in order to detect that whether the singly linked list
459:09 - contains a loop what we did was we moved fast pointer two steps and we moved slow pointer one
459:17 - step so why we actually do that is because in case if the singly linked list doesn't have the loop
459:25 - the fast pointer is moving twice the speed of slow pointer so fast pointer will reach to the
459:31 - end of the singly linked list but if the singly linked list contains the loop then as slow pointer
459:37 - is moving slowly fast pointer will cross over this loop perform n number of cycles and it will
459:45 - meet slow pointer in one of these nodes because there is no end to the singly linked list once
459:52 - the point reaches beyond the starting of this loop so in our previous video in this while loop
459:59 - if slow pointer meets fast pointer we actually returned a boolean value true stating that we
460:06 - detected a loop in this singly linked list and we actually returned from this method
460:12 - but in this algorithm when we find a slow pointer is meeting to fast pointer inside this loop
460:19 - then we actually called yet another method which provides us the starting node of the loop
460:26 - so this demonstration of detecting the loop and finding the meeting point of slow pointer
460:31 - and fast pointer as we already discussed in our previous video so here i will be quickly demonstrating it
460:39 - so here we will start fast pointer and slow pointer from head
460:48 - now in while loop we are providing two conditions that fast pointer not equal to null and fast
460:54 - pointer next is not equal to null so why we are providing this condition is because if fast
461:00 - pointer equals null then it means the singly linked list doesn't have any loop and there is
461:06 - an end to this singly linked list because we are traversing fast pointer inside this while loop
461:12 - and at some point fast pointer is pointing to null it means that we have reached to the end of
461:17 - the singly linked list and the next condition fast pointers next should also be not equal to
461:23 - null because here if you see in this line we are traversing fast pointer two places by assigning
461:31 - fast pointers next next so here if fast pointers next becomes null then we'll encounter a null
461:38 - pointer exception here so here we are providing this condition to simply check that whether fast
461:44 - pointer next also should not be equal to null so currently fast pointer is not equal to null
461:49 - its next is also not equal to null so this condition comes out to be true
461:58 - in the first step we are moving fast pointer by two nodes by assigning fast pointer next
462:04 - next value to fast pointer so fast pointer next will make it reach here and its next will make
462:11 - it reach here so it would look something like this moving ahead and as we discussed that we
462:21 - are moving slow pointer by one position so we are simply assigning slow pointers next value to slow
462:26 - pointer so slow pointer will come here moving ahead currently slow pointer is not pointing to fast
462:38 - pointer because here you can see fast pointer is pointing to three slow pointer is pointing to two
462:44 - therefore the condition in if block comes out to be false
462:50 - we again reach to the while loop where we'll check whether fast pointer is equal to null or not
462:55 - so fast pointer is not equal to null and its next is also not equal to null
462:59 - so the condition in while loop comes out to be true now we move fast pointer by two steps
463:06 - by assigning fast pointer next next so fast pointer will reach to node five
463:17 - and slow pointer will reach to node three
463:26 - slow pointer is not equal to fast pointer this condition is false
463:30 - fast pointer is not equal to null and its next is also not equal to null
463:40 - we move fast pointer by two steps by assigning fast pointer next next to fast pointer
463:49 - so fast pointer will reach to node three
463:55 - and we'll move slow pointer by one step so it will reach node four
464:00 - this condition is false because slow pointer is pointing to four and fast pointer is pointing
464:09 - to three fast pointer is not equal to null and its next is also not equal to null
464:18 - we move fast pointer by two steps by assigning fast pointers next next value
464:25 - so fast pointer next is four and its next is five
464:30 - so it came here
464:34 - we'll move slow pointer by one step
464:39 - so slow pointer will reach here
464:45 - so friends now here you can see that slow pointer is met to fast pointer at this node
464:52 - so it means we have detected a cycle inside this singly link list by using two pointers fast
464:58 - pointer and slow pointer so friend this algorithm is also known as fluid cycle detection algorithm
465:06 - now when we get the meeting point of slow pointer and fast pointer we go into the if condition
465:13 - and here we will call a method as get starting node and we'll pass the slow pointer there
465:20 - so now it would look something like this that call will reach to this method
465:25 - where we'll still have the reference to slow pointer which is pointing to the meeting point
465:32 - of slow pointer and fast pointer so friends the idea behind this algorithm to find the starting
465:39 - node of the loop is at the first step what we do we again create a temporary list node
465:47 - we start it from the head and we already have reference to the meeting point of slow pointer
465:53 - and fast pointer so now what we do is we simply provide a while loop we move slow pointer by one
466:03 - step and we move temporary node by one step and in the while loop we provide the condition
466:10 - that perform these steps till slow pointer is equal to temp so when slow pointer will be equal
466:17 - to temp this while loop will terminate and when slow pointer will equal to temp at whichever node
466:25 - this condition comes out to be true that will be our starting node of the loop so here we will
466:32 - move slow pointer by one step and we will move temp by one step so currently here you can see
466:39 - slow pointer is not equal to temp because slow pointer is pointing to five and temp is pointing
466:45 - to node one so this condition comes out to be true now inside this while loop as we discussed
466:53 - we move both the pointers one one step so first we move the temporary node by assigning temp dot
467:02 - next to temp so now temp will come here and then we'll assign slow pointers next value to slow
467:13 - pointer so slow pointer is pointing to five its next is pointing to six so now slow pointer will
467:19 - point to six we check whether slow pointer is equal to temp or not so slow pointer is not equal
467:28 - to temp because temp is pointing to two and slow pointer is pointing to six so the condition in
467:36 - the while block comes out to be true we move temp by one step so it will reach three
467:49 - we move slow pointer by one step by assigning slow pointers next to slow pointer so it will reach here
468:00 - we check whether slow pointer is equal to temp or not so here you can see
468:04 - that slow pointer is equal to temp because they are pointing to the same node
468:08 - so this condition comes out to be false
468:14 - and at the last you can see that we have actually found the starting node of this loop which is three
468:21 - so wherever temp and this slow pointer will meet that node will be our starting node of the loop
468:28 - so from this method we'll simply return this node which is three
468:34 - so from this algorithm is floyd's cycle detection algorithm so now one question comes to our mind is
468:42 - that when we found the meeting point of the fast pointer and slow pointer
468:46 - and we created two pointers temp and slow pointer and made them move one one step
468:53 - in this while loop and when they actually met we are simply saying that that is our starting
468:59 - node of the loop but what's the proof that this cycle detection algorithm given by floyd works
469:06 - so friends in our next video we will see that why this algorithm works because currently we
469:13 - have simply demonstrated the algorithm and we have found our starting point of the loop
469:20 - but we don't have any proof that whether this algorithm actually works or not
469:25 - so in our next video we will see that why floyd's cycle detection algorithm works
469:32 - so friends i hope you have liked this video and in case if you are new to my channel
469:36 - then please subscribe to my channel so that you never miss any update thanks have a nice day
469:42 - hello everyone so in our previous video we discussed about the floyd's cycle detection
469:52 - algorithm where we saw that how we can detect a loop in a singly linked list and how we can find
470:00 - the starting node of the loop so friends here if you see that in one of our previous video
470:07 - we saw the algorithm of finding a loop in a singly linked list where we use these two
470:16 - pointers fast pointer and slow pointer and we made fast pointer move two steps and slow pointer
470:23 - by one step and we provided this condition that fast pointer should not be equal to null
470:28 - and fast pointer next should not be equal to null so in case if the singly linked list doesn't
470:33 - had this loop then fast pointer must have reached to the end of the singly linked list
470:40 - but if the singly linked list contains a loop then inside this while loop there will be a
470:45 - point that fast pointer will meet slow pointer because of the loop so here we return true if
470:52 - the singly linked list had the loop or else we returned false so now in this video our task is
470:58 - to find the starting node of the loop so here you can see i will simply copy this method
471:15 - and as the algorithm of the first part remains the same here we need to return back
471:23 - the starting node of the loop
471:28 - we can give any name but here i am giving start node in a loop and here when the fast
471:38 - pointer will meet slow pointer so in our previous video where we saw the animation this meeting
471:45 - point is very important so let's say if there is no loop so here we simply return as null
471:52 - and if there is any loop because slow pointer is meeting to the fast pointer then we'll call one
471:59 - method here which will return as the starting node of the loop and we'll pass the slow pointer to it
472:10 - because this meeting point is very important so i will create one method
472:16 - so friends now here in order to get the starting node of the loop what we do is
472:26 - as we already have this meeting point so this becomes our first node
472:33 - and we also create one temporary node
472:37 - and we point it to the head so now here we have two nodes one is the slow pointer
472:43 - and other is the temporary node where temporary node is pointing to the head of the singly link
472:49 - list and slow pointer is pointing to the meeting point of slow pointer and fast pointer which we
472:57 - saw here and that point will be inside the loop so friends here now what we do is we move slow
473:06 - pointer by one step and we move temporary node by one step and that we do in the while loop
473:12 - so we make them move one one step till they meet and wherever they meet
473:18 - that node where they meet will be our starting node of the loop so here in while loop
473:27 - we provide the condition that keep on iterating and moving temporary node and the slow pointer
473:36 - by one one step till slow pointer is equal to temp so if they are not equal to each other
473:44 - then we are simply moving temp by one position and similarly we are moving slow pointer
473:55 - by one position and when temp and slow pointer value will point to each other
474:03 - this condition will come out to be false and at the end will simply return
474:10 - the temporary node so this temporary node will be our starting node of the loop
474:21 - so this is what floyd cycle detection algorithm states that wherever this temporary node and
474:27 - slow pointer will meet that node will be our the starting node of the loop so friends why this
474:35 - algorithm works we will discuss in our upcoming video but for timing you just think that this
474:41 - algorithm works so here now we'll call this method and we'll test it's working
474:48 - so here you can see that in one of our previous video we already created a loop
474:54 - using create a loop in linked list method where first point to second, second pointed to third,
475:02 - third pointed to fourth, fourth pointed to fifth, fifth pointed to sixth and here you can see sixth
475:09 - pointed to third it means there is a loop and this is the same example which we discussed in
475:14 - our previous slide as well so here we know that there is a loop in a singly linked list if we
475:21 - call create a loop in singly linked list so from head this singly linked list will start and there
475:28 - will be a loop so i'll just comment this part so here i have simply uncommented and we are simply
475:41 - calling create a loop in linked list and let's say we also call the contains loop method
475:51 - so that will return us a boolean value so first i will simply run that part and here you can see
475:58 - that it returned true so it means there is a loop in that singly linked list now what we'll do
476:08 - here we know that the starting point of the loop is list node third having data as three
476:13 - so after we figure out that there is a loop what we do is we simply call
476:25 - the method start node in a loop here what we do is we simply print the data of the returning node
476:32 - so here you can see it printed three which is the data of the node from where the loop starts
476:49 - so friends here the only idea we need to remember is after finding the meeting point of slow pointer
476:54 - and fast pointer we keep the slow pointer at that position only and we create a temporary pointer
477:02 - which will start from the head and in the while loop we simply move both the pointers by one one
477:08 - step and keep checking that whether temp is equal to slow pointer or not so when temp will equal to
477:16 - slow pointer this while loop will terminate and that node where this both the pointers will meet
477:23 - will be our starting node of the loop so friend currently we haven't seen that why this algorithm
477:31 - in our next video we will see the mathematical proof that why this algorithm works
477:38 - which is named as fluid cycle detection algorithm so friends i hope you have liked this video
477:44 - and in case if you are new to my channel then please subscribe to my channel
477:48 - so that you never miss any update thanks have a nice day
477:52 - hello everyone so in this video we will discuss that why fluid cycle detection algorithm works
478:05 - so friends in our previous video we saw that how we can detect a loop in a singly linked list
478:11 - and we also saw that how we can find the starting node of that loop so the algorithm which we saw
478:19 - it was just a code which usually works but there was no proof that why this algorithm works
478:25 - so in this video we will see that why a fluid cycle detection algorithm works
478:32 - so friend let's suppose we are given with this singly linked list so here you can see
478:37 - that singly linked list contains nine nodes one two three four five six seven eight nine
478:45 - and if you see that from the sixth node the loop starts
478:49 - and the last node points to the sixth node so therefore this loop starts from here
479:02 - so basically in order to detect that whether this singly linked list contains a loop
479:06 - what we do is we simply create two pointers one is the slow pointer
479:13 - another is the fast pointer and usually started from the head now what we do as the name suggests
479:20 - the fast pointer moves two steps and slow pointer moves one step when we perform these steps in
479:27 - iteration that fast pointer moves two steps then slow pointer move one step so friend if this
479:33 - singly linked list doesn't contain loop then fast pointer will reach to the end of the singly linked
479:38 - list where last node next will point to null and if there is a loop then fast pointer will
479:45 - keep on traversing here and slowly slow pointer will enter the loop and fast pointer will meet
479:51 - the slow pointer somewhere in the loop so first let's see how it works we moved fast
479:57 - pointer by two steps slow pointer by one step we moved fast pointer by two steps
480:05 - slow pointer by one step fast pointer by two steps slow pointer by one step
480:14 - now here from here fast pointer reached here because this is the first step this is the
480:18 - second step slow pointer by one step fast pointer by two steps so friends here you can see that
480:25 - that slow pointer is still completing this tail of the singly link list but the fast
480:31 - pointer has already completed one circle and based on number of nodes and the size of the
480:37 - loop there can be possibility that when slow pointer will enter the loop fast pointer must
480:43 - have completed x number of cycles.
480:46 - So here you can see now we will move slow pointer then we move fast pointer by two steps
480:51 - so it will reach here, slow pointer here.
480:55 - Now as we started our Algorithm with fast pointer we are moving fast pointer by two
481:00 - steps and then our iteration will end with slow pointer with one step so slow pointer
481:05 - will reach here then we will again do a while loop and fast pointer will reach here and
481:12 - then our iteration will end when slow pointer will reach here.
481:15 - So friends here you can see whenever iteration will end with the slow pointer we see that
481:21 - Now slow pointer and fast pointer are meeting at this node.
481:25 - So front there could be a possibility that based on number of nodes and the size of loop
481:32 - there could be a possibility that before meeting the slow pointer fast pointer must have completed
481:37 - this cycle x number of times and similarly slow pointer must have completed this cycle
481:42 - let's say y number of times before meeting at this node.
481:47 - So the first part of the algorithm is detecting this loop.
481:51 - In case if fast pointer meets slow pointer then we know that there is a loop.
481:54 - So this is the first part of floyd cycle detection algorithm.
481:59 - The other part is to find the starting node of this loop.
482:04 - So after finding the meeting point of fast pointer and slow pointer what we do is we
482:09 - keep slow pointer here and we move a temporary pointer from the head.
482:15 - And now this time we move slow pointer one step and temp also by one step.
482:22 - So what this algorithm will tell us is if we move both the pointers one step when temp
482:27 - will reach the start of the node slow pointer also will reach to that particular node.
482:32 - And basically in code when they meet to any node that node will be our starting point
482:38 - of the loop.
482:40 - So let's see how we move temp by one step, we move slow pointer by one step.
482:45 - If we again move temp by one step, slow pointer by one step, we move temp by one step, slow
482:53 - pointer by one step, then again we move temp by one step and slow pointer by one step.
483:00 - So friends here you can see that based on number of nodes here in the tail and in the
483:06 - loop you saw that slow pointer started from here and it completed one cycle and reached
483:12 - to the same point here.
483:14 - And now if we move temp by one step it will reach here and if we move slow pointer by
483:20 - one step it will reach here.
483:24 - So this algorithm tells that at whichever node these two pointers will meet that would
483:29 - be our starting point of the loop or the starting node of the loop.
483:34 - So now there are two parts of the algorithm one is of detecting the loop that is the meeting
483:39 - point of the slow pointer and fast pointer and other is the finding of this starting
483:45 - node.
483:46 - So here if we draw this singly linked list let's say something like this that this is
483:53 - a tail and this is the loop and let's say they meet at this point.
484:01 - So here you can see we are denoting this tail with the value m and fast pointer comes
484:08 - inside the loop it goes and performs few cycles and reach here and slow pointer also performs
484:15 - a lesser number of cycles and finally meet it here or it could be possible that slow
484:21 - pointer doesn't complete any cycle and simply meets here.
484:25 - So we are giving this distance as k and the complete length of this loop let's say we
484:31 - are denoting it by n so this is the current picture from where we will start our proof.
484:39 - So let's say we are assuming that fast pointer and slow pointer meet here if they meet here
484:45 - then this singly linked list must be containing a loop at the start we are simply assuming
484:51 - that let's say they meet here.
484:54 - So the distance travelled by fast pointer would be let's say we denote it by df so the
484:59 - fast pointer will start from here it moves m distance and there could be possibility
485:06 - that fast pointer travels this loop let's say x number of times and once it performs
485:13 - a loop it will come to the starting point only and then it goes k distance and meet
485:18 - the slow pointer so we can simply write the distance travelled by fast pointer as m plus
485:26 - the n is the length of this loop and cf is an integer which can be like 1,2,3,4,5.
485:33 - So we are not sure that how many cycles fast pointer will perform so we are denoting it
485:38 - by a constant cf which would be an integer so it can make one cycle it can make two cycles
485:45 - it can make three cycles so in order to calculate distance we are multiplying n by cf plus k
485:52 - so if the cycle starts from here it will reach back here and then it goes k distance
486:00 - so this is the k distance and similarly distance travelled by slow pointer let's say we denoted
486:06 - ds it would be m plus let's say this slow pointer also performs some of the cycles around
486:17 - this loop and we don't know how many cycles it performs so we denote it by cs so this
486:22 - is also a constant basically an integer value multiplied by the length of the loop plus
486:30 - so if it starts looping from here then it performs one loop or let's say cs loops and
486:36 - then it will travel k distance and meet the fast pointer here so plus k so now as we know
486:42 - that both the pointers are starting at same point and meeting at this point so the time
486:47 - both the pointers will be same and as fast pointer is moving two steps and slow pointer
486:53 - is moving one step so the distance travelled by fast pointer will be twice the distance
486:58 - travelled by slow pointer so let's say distance travelled by slow pointer is x so if fast
487:05 - pointer is moving twice the speed of slow pointer then the distance travelled by fast
487:11 - 2x. So if we substitute these values in the x and 2x it would be something like this.
487:18 - x will be equal to m plus ncs plus k and 2x will be m plus ncf plus k. So here the constants
487:29 - are different cf and cs which are nothing but the integer values. So m plus n into cf
487:36 - plus k. Now what we do is, we simply subtract x from 2x. So we simply subtract this equation
487:46 - from this equation. So what we get is, this x will get cancelled out with this x. So only
487:53 - one x will remain. So here you can see m will cancel out, k will cancel out and if we do
488:02 - n into cf minus n into cs taking n common, it would look something like this. n into
488:09 - cf minus cs. So this would be the equation which will be coming out. So here you can
488:15 - see that based on what equation came out, if we closely observe this equation then here
488:20 - you can see that this x is equal to n into cf minus cs. So here you can see n is constant
488:27 - because this length of the loop will remain the same. And cf minus cs are nothing but
488:33 - integers. So there will be a value for cf and cs when multiplied by n will give us a
488:40 - distance x. So here you can see that if we substitute some of the values in the left
488:46 - hand side and in the right hand side, let's say for cf and cs and x and n. So you will
488:51 - find that this equation is solvable. So which proves that this equation is derived when
488:59 - we assume that they will meet at this point. And if they are meeting at this point then
489:05 - there will be a loop inside this singly linked list. So you can try to substitute many values
489:10 - here and you will see that you will find the solution of these equations. So this proves
489:16 - our first point that how we detect that there is a loop in a singly linked list. Now we
489:24 - will see that let's say this is the meeting point and if we move the slope pointer by
489:28 - one step and temporary pointer one step then why they actually meet at the starting point
489:34 - of the loop. So this will be our second part of the algorithm which we need to prove. So
489:40 - here we go via same analogy that distance travelled by fast pointer is df m plus ncf
489:46 - plus k and distance travelled by slope pointer will be m plus ncs plus k. Now here what we
489:54 - do is this is also we discussed that distance travelled by fast pointer will be twice the
489:58 - distance travelled by slope pointer. So which means df will be twice ds because fast pointer
490:06 - is moving twice the speed of slope pointer. So the distance travelled by fast pointer
490:11 - will be twice the distance travelled by slope pointer. So if we substitute these values
490:18 - we will get m plus ncf plus k equals two into m plus ncs plus k. Now we will multiply two
490:25 - inside this and we will get 2m plus 2ncs plus 2k. Now what we do is we will take m
490:36 - this side so if we take it this side it will become minus m minus k and here we have 2m
490:43 - and 2k so 1 1m and k will be subtracted and here if we take 2ncs here so it will be ncf
490:52 - minus 2ncs. So this equation after solving it will look something like this that ncf
491:00 - minus because we are taking this side so it will become minus 2ncs. This m we took it
491:07 - here so it became 2m minus m so it gave m and k we took it here so it became 2k minus
491:13 - k which gave us a value k. So friends here you can see that m is the length of the tail
491:21 - of the singly linked list and k is the distance from the starting node to a point where the
491:28 - fast pointer and slope pointer meet and n is the length of the loop. So friends here
491:35 - you can see it will take n common so it would look something like this and here you can
491:40 - see from the starting point till this point this value is k and total value of this loop
491:46 - is n. So if we denote this small semicircle as or the arc as let's say r like this. So
491:58 - over this equation what we do is we take k this side so it becomes n into cf minus 2cs minus k.
492:06 - So friends to k what we can write is so here you can see that k plus r will be equal to n
492:16 - because k is till this point and r is till this point and if we add them we will get n.
492:22 - So what would be the value of k it would be n minus r so if we denote n minus r instead of k
492:31 - it would look something like this n minus r came here now we will multiply minus into this
492:38 - bracket so it would look something like this minus n plus r and now if we take n common from
492:46 - these two terms we will get something like this cf minus 2cs minus n so we are taking n common so
492:55 - it will become minus 1 bracket plus r equals m. So friends here you can see that this n is the
493:05 - length of the loop and cf minus 2cs minus 1 here cf is an integer cs is also an integer and minus
493:14 - 1 is a constant so what does equation denotes so here you can see m which would be a distance by
493:22 - the temp and it will reach the starting point and here you can see that if you are starting slow
493:28 - pointer here then this equation if we travel this much part n into some integer value so that would
493:36 - be the number of loops where n will be multiplied by let's say some integer value or it can come
493:43 - out to be 0 so for timing let's suppose this equation comes out to be 1 so it means if you
493:51 - are starting slow pointer here it will perform one loop and will reach the same point and let's say
493:57 - if this equation comes out to be 0 so it will stay at this point only because this complete part
494:02 - will be 0 and if we take this value that 2 3 4 and if you are starting it from here so it will
494:09 - travel like this but it will always reach to this point only because it is starting from this point
494:14 - so this part is telling us that if we are starting the slow pointer here and whatever the value this
494:24 - equation comes in the bracket it will always make it reach to the this point only and here you can
494:31 - see if we travel plus r after making few cycles by this equation slow pointer will reach here only
494:38 - and if it travels plus r then it will meet the temporary because here you can see m is equal
494:44 - to some loops plus r if temp will move m steps the slow pointer will has moved some number of
494:53 - cycles and it would have reached here and then it would have moved plus r so it would have meet
494:59 - m here so which means that based on our values here from this point if slow pointer travels
495:08 - let's say 1 cycle 2 cycles 3 cycles it will reach here only and meanwhile m would have reached
495:16 - somewhere here because they are moving at same speed 1 1 step and finally when it would have
495:23 - traveled r it would have made it somewhere here which would be the starting node of our loop so
495:30 - this equation tells that m is equals to some loops by the slow pointer plus r so if we are
495:39 - starting from this meeting point the slow pointer it would have performed some loops and it would
495:46 - have reached here only and then based on our this length which is r if would have traveled r then
495:53 - it would have reached the starting point of the node and it would have met temp so this equation
495:59 - is telling that if we are dividing our loop in k and r terms and the total length of this loop
496:06 - is n so we need to simply prove that slow pointer if it is starting from here then whatever distance
496:15 - it travels it should meet the temporary node when temp has performed m steps so here you can see when
496:24 - temp has performed m steps which is this part of the equation that would be equal to and into an
496:31 - integer multiple so it would be it is starting from here it makes few cycles it reached to the
496:37 - same point and then it is traveling simply plus r so if it is traveling plus r it would reach to
496:43 - the starting point of the loop and where it will simply meet m because m is equal to this equation
496:48 - so from this proves that from the meeting point of the slow pointer and fast pointer if we travel
496:55 - slow pointer by one step and temp by one step so wherever they will meet that will be our starting
497:03 - point of the loop so from this proves that why Floyd cycle detection algorithm works in case
497:11 - you find this information useful then please like this video and if you are new to my channel then
497:17 - please subscribe to my channel so that you never miss any update thanks have a nice day
497:26 - hello everyone so in this video we will discuss that how we can remove a loop from a singly link
497:33 - list so friends in our previous videos we saw that how we can detect a loop in a singly link
497:40 - list and after detecting the loop we also saw that how we can find the starting node of the loop
497:47 - and we demonstrated both the algorithms using Floyd cycle detection algorithm and we also saw
497:54 - the proof of Floyd cycle detection algorithm that why it works so based on similar concept
498:00 - we will see that how we can remove the loop from the singly link list so before we start in case
498:07 - if you are new to my channel then please subscribe to my channel so that you never miss any update
498:12 - so friends here you can see that suppose we are given with this singly link list which is having
498:19 - a loop starting from node 3 so here 3 is pointing to 4 4 is pointing to node 5 and 5 is pointing to
498:28 - node 6 and node 6 is again pointing to node 3 so here you can see that there is a loop and our task
498:35 - is to remove this loop so the only way in which we can remove this loop is if somehow we reach to
498:41 - this node and we break this link and once we break this link and if we assign it to null then it will
498:49 - become a singly link list which will not have any loop so friends the idea behind this algorithm is
498:56 - it's very much similar to what we discussed in our previous videos that we create two pointers we
499:03 - name them fast pointer and slow pointer both starting from the head from here and then we
499:10 - provide a while loop so inside this while loop what we do is we move fast pointer by two steps so here
499:19 - you can see we are assigning fast pointer next next so for example if suppose fast pointer is here
499:25 - its next is this node and its next is this node so we are moving fast pointer by two steps and we
499:32 - are moving slow pointer by one step so once they will reach inside this cycle and if the singly link
499:39 - list contains a cycle there will be a situation when slow pointer and fast pointer will point to
499:46 - the same node which will prove that there is a loop in the singly link list so this idea we have
499:53 - already discussed in two of our videos so the first part is to find that meeting point of slow
499:59 - pointer and fast pointer so we will quickly go over the algorithm to find the meeting point of
500:05 - slow pointer and fast pointer so here we are starting both fast pointer and slow pointer from
500:15 - head and we are providing a condition in while loop as fast pointer should not be equal to null
500:23 - and fast pointer next should not be equal to null because here we are traversing fast pointer by
500:29 - two steps we have to provide this check because if fast pointer next comes out to be null then here
500:36 - we will get a null pointer exception so we are providing this safe check here so currently fast
500:43 - pointer is not equal to null and next is also not equal to null so we will quickly go over this
500:48 - demonstration because we have already seen it in our previous videos we have moved fast pointer by
500:58 - two steps and we will move slow pointer by one step and after we perform one iteration we simply
501:07 - check that whether they are pointing to the same node or not so currently they are not
501:19 - so after second iteration this is the situation and still they are not pointing to the same node
501:40 - still slow pointer and fast pointer are pointing to different nodes
501:48 - so friends now here you can see that both slow pointer and fast pointer are pointing to node 5
501:58 - it means that there is a loop and our if condition slow pointers equals fast pointer comes out to be
502:10 - true now which will signify that there is a loop so in the second part of the algorithm which is
502:16 - what we want to remove the loop so here now we will call remove loop method and we will pass in
502:24 - the slow pointer and once this method will end this loop will be removed and we will simply return
502:31 - from this method so here as we have passed slow pointer so it will still point to node 5 because
502:41 - this is the meeting point of the fast pointer and slow pointer so friends in one of our previous
502:50 - video we discussed that how we can find the starting node of this loop where what we did was
502:57 - we created a temporary variable we started it from head and then we had moved temp by one step slow
503:07 - pointer by one step and where they would have met that was our starting point of the loop and we
503:14 - also proved the algorithm mathematically that why moving temp by one step and slow pointer by one
503:19 - step in a while loop will make them meet at the starting point of the node so this algorithm we
503:26 - proved in our previous videos so you can watch those videos so here we'll apply the same analogy
503:33 - we start from the head which would be our temporary variable and slow pointer from the meeting point
503:41 - of slow pointer and fast pointer now here we are providing a while loop so when we were actually
503:50 - finding the starting node of the loop our while loop condition was that perform the iteration
503:56 - till slow pointer meets the temporary node and inside this while loop we were moving both the
504:02 - pointers one one step but now here you can see that as singly link list contains a loop and we
504:10 - want to break this link so we don't have to go till the starting point we have to go a node before
504:17 - that and we have to remove this link so the only way to reach node 6 is instead of comparing slow
504:26 - pointer with temp here we are simply comparing slow pointers next to temp next because we know
504:33 - that when slow pointer will reach at node 6 temp will reach at node 2 and the both pointers next
504:41 - will point to the starting node of the loop so therefore we have to break this while loop at
504:47 - dead point because we have reached slow pointer to a node which is just before the starting point
504:53 - of the loop so let's see how so currently slow pointers next is not equal to temp next because
505:02 - temp next is pointing to node 2 and slow pointer next is pointing to node 6 so the condition in
505:08 - while block comes out to be true we move temp by one step so temp goes to its next node where we
505:20 - assign temp dot next value to temp and similarly we will move slow pointer by one step by assigning
505:28 - slow pointer next to slow pointer so slow pointer next is node 6 so now slow pointer will point to
505:35 - node 6 now friends here we again check whether slow pointers next is equal to temp next or not
505:45 - so slow pointer next is node 3 and temp next is also node 3 so therefore this condition comes
505:53 - out to be false because slow pointer next is equal to temp next so this is the only minor difference
506:00 - between finding the starting point of the loop and finding a node before the starting point of the
506:06 - loop and why we need a node before the starting point of the loop because we need to break this
506:11 - link and the only way to break this link is if we have reference to this node so therefore here
506:19 - the only difference between the two algorithm is this condition if you want to find the starting
506:25 - point of the loop then this while loop condition becomes slow pointer not equal to temp and if you
506:33 - want to find a node before that then you have to provide this condition that slow pointer next is
506:39 - not equal to temp dot next so here this condition comes out to be false and while loop will terminate
506:45 - so at the end in order to break this link what we'll do is we simply assign null value to slow
506:52 - pointers next so it would look something like this the slow pointer next is pointing to node 3 so
507:00 - this link will go away and now it will point to null so friend after this assignment you can see
507:07 - that our singly linked list which had a loop in between not will end with a null value so friend
507:16 - this was the demonstration of the algorithm step by step I hope you have find this information
507:21 - useful and in case you have find this information useful then please like this video and if you are
507:27 - new to my channel then please subscribe to my channel so that you never miss any update thanks
507:33 - have a nice day
507:38 - hello everyone so in our previous video we discussed about but how we can remove a loop
507:44 - from a singly linked list we saw an animation of the algorithm so in this video we'll write
507:51 - the code for that and we'll test its working in the main method so here in our singly linked list
507:57 - class which has this instance variable head of type list node so here inside this class I have
508:05 - demonstrated so many algorithms related to singly linked list so here you can see the last algorithm
508:14 - we discussed was how to find the starting node of the loop where we first created the loop then we
508:26 - simply check that whether there is any loop or not and once we found that there is a loop we wrote
508:33 - the algorithm for finding the starting node of the loop and we printed its data on the console
508:42 - so here you can see that we used a simple example which we also saw in our previous slide
508:48 - that we have created six nodes first second third fourth fifth sixth where all the nodes are
508:54 - connected to each other and the last node is connected to node third so node six was connected
509:01 - to node third which created the loop in the singly linked list so head pointed to first node
509:07 - first pointed to second second pointed to third third pointed to fourth fourth pointed to fifth
509:15 - fifth pointed to sixth and sixth pointed back to third so there was a loop and the starting point
509:22 - of that loop was node third so if I run the code now which we already discussed in our previous
509:28 - videos so here you can see the starting point of that loop was at node three where we printed
509:37 - its data on the console so in this video we'll look into algorithm where we'll simply break the
509:43 - loop which means that from node six to node third will break this link and then sixth node will
509:51 - point to null so let's code the algorithm so friends here you can see that this algorithm
509:59 - of removing the loop from the singly linked list has two parts one is to detect the loop
510:06 - and part two is to actually remove the loop so here in our previous videos we already discussed
510:12 - that how we can detect a loop in a singly linked list using floyd cycle detection algorithm
510:18 - and we also saw the proof for that algorithm so here when fast pointer will meet the slow
510:24 - pointer then instead of going and finding the starting node what we'll do is we will remove
510:30 - the loop so the first part of algorithm is pretty much the same i'll paste the code here
510:39 - and instead of returning the list node as we are not returning anything we will make it void
510:45 - we'll name the method as remove loop and rest of the part remains same till
510:57 - the cycle is detected where fast pointer is equal to slow pointer which we already discussed in our
511:01 - previous videos we'll remove this return null and here instead of going and finding the starting
511:09 - node of the loop what we'll do we'll simply create a method as remove loop and we pass
511:16 - in the slow pointer and once we remove the loop we'll simply return from this while loop
511:23 - or we can break the while loop so here i'll be creating one private method as
511:29 - remove loop which will take in a list node
511:43 - slow pointer which is we are calling this method from here
511:48 - and inside this method we'll actually write the code to remove the loop
511:55 - we also discussed that how we can find the starting node of the loop
511:59 - so the idea of finding the starting node of the loop and to remove the loop is pretty much the same
512:05 - with only small changes so i'll copy this part
512:14 - so here we have this slow pointer which is nothing but the meeting point of fast pointer
512:20 - and slow pointer and we pass slow pointer into this method so we have this slow pointer here
512:26 - and inside this remove loop method we are creating this temporary variable
512:30 - which will start from head so friends when we discussed that how we can find the starting node
512:37 - what we did was we made slow pointer move one step and we made temporary pointer move one step
512:44 - inside this while loop and when they met so temp became equal to slow pointer so at whichever
512:52 - node this both pointer met that node was our starting node of the loop and we proved this
512:58 - algorithm in our previous videos so similar concept is applied here here the only change we do is
513:08 - we simply check whether temp dot next
513:13 - should not be equal to slow pointers next so why we have provided this condition is
513:18 - here this condition will make us reach to the starting point of the loop but we don't want to go
513:25 - tell the starting point of the loop we have to just go a node before that because as it is a
513:31 - singly linked list in order to break this chain we have to go a node before the starting point of the
513:38 - loop and once we reach there we can simply break the chain by assigning
513:44 - something like slow pointer dot next equals null so from this condition is important if we remove
513:54 - this dot next from both the sides then this value will make slow pointer and temporary pointer to
514:01 - reach to the starting point of the loop but we don't want to go to the starting point of the loop
514:05 - we have to go just before that so wherever these both the pointers are we are simply comparing its
514:12 - next value so if both the pointers next value becomes equal then we know that slow pointer is
514:21 - just before the starting point of the loop and once this condition comes out to be false we know
514:27 - that slow pointer is just before the starting point of the loop so friends here you can see
514:33 - that why this condition is important if we don't provide dot next value in both these pointers
514:39 - then this while loop will make us reach to the starting point of the loop and we don't want to
514:45 - reach to the starting point of the loop because if we reach to the starting point of the loop
514:50 - then we won't able to break the cycle so what we do is we simply try to reach a node before
514:55 - the starting point of the loop so here instead of comparing temp with slow pointer we are simply
515:01 - comparing both the pointers next so that when slow pointer will be a node before
515:08 - the starting point of the loop its next will point to the starting point of the loop
515:13 - and temp next will also point to that node so this condition will come out to be false which
515:20 - means our slow pointer will be a node before the starting point of the loop and then at the last
515:26 - step we'll simply assign null value to slow pointers next so this will break the cycle
515:32 - of the loop which is inside the singly linked list so here what we do is in the main method
515:41 - we simply call the remove loop method so this will take this singly linked list which contains
515:47 - the loop and then we'll simply call display method which will print the singly linked list
515:56 - and if the singly linked list will contain a loop
516:01 - then here you can see that display method will keep on running
516:05 - because it won't break because there won't be any null value and this will keep on going
516:11 - but here as we know that we are removing this loop here if i run the code now
516:15 - so here you can see that from third node it pointed to fourth then fifth then sixth and sixth
516:28 - again pointed to node three which we saw here six next is pointing to third but when we've called
516:35 - remove loop method here the loop was removed and when we printed the singly linked list on the
516:42 - console this step made the sixth next to null instead of pointing to three so it simply removed
516:57 - the cycle from the singly linked list and it printed it on the console where the last node
517:03 - was now six pointing to null so friend this was all about that how we can remove a loop from a
517:12 - singly linked list i hope you have find this information useful and in case if you find this
517:18 - information useful then please like this video and if you are new to my channel then please
517:24 - subscribe to my channel so that you never miss any update thanks have a nice day
517:37 - hello everyone so in this video we are going to discuss that how we can merge two sorted
517:43 - singly linked list so let's see what this problem is and how to solve this
517:47 - so here if you see that we are given with two sorted singly linked list
517:55 - the first singly linked list has three nodes one four and eight and the first node is being
518:00 - referenced by head one similarly the singly linked list two has nodes three six and seven
518:07 - the first node being referenced by head two now if you see both this singly linked list are sorted
518:14 - in ascending order now our task is to merge them in such a way that resulting singly linked list
518:20 - is also sorted so here you can see that when we merge these two singly linked list
518:26 - the resulting singly linked list has six nodes three from list one and three from list two
518:35 - so total nodes are six and here if you see that we have merged it in such a way that the resulting
518:42 - singly linked list is also sorted and that too in ascending order so at the start we have one
518:48 - then three four six seven eight so one is added by list one three from list two four from list one
518:59 - six seven from list two and finally eight being the largest value from list one so the resulting
519:07 - singly linked list is also sorted so let's move ahead and see the demonstration of the algorithm
519:13 - step by step so here you can see that we are given with two singly linked list which are sorted
519:21 - let's say they are referred by a and b and we are calling this merge method and this merge
519:26 - method will return us the head of the merged sorted singly linked list so here if we visualize
519:33 - this merge method on the call stack let's say we have the stack memory and heap memory
519:40 - so stack memory usually have the calls to our methods so let's say after certain calls
519:47 - there is a merge call and we pass a and b as our list so here if you see
519:53 - that whatever the nodes a will hold and b will hold they will hold in the heap memory
520:04 - so these are the objects which are of type list node and a and b are references to these objects
520:13 - so in heap memory it will look like this and now we need to merge these two lists in such a way
520:19 - that the resulting singly linked list is also sorted so just keep this thing in mind because
520:26 - it will be useful later so here is the algorithm to merge two sorted singly linked list a and b
520:34 - so friends before we start if you want to master data structures and algorithms
520:40 - you can subscribe to my channel and click the bell icon so that you never miss any update
520:44 - let's say we call this merge method we pass two lists a and b so here you can see a and b
520:54 - are usually on the stack and they are and they are referencing these objects on the heap
521:00 - and a and b both the singly linked list are sorted in ascending order now our task is to
521:06 - merge these two sorted singly linked list such that the resulting singly linked list is also sorted
521:11 - so at the start what we do is we first create a dummy node so this dummy list node will refer
521:20 - a list node on the heap with a value as zero so this dummy list node can have any value
521:26 - this value doesn't contribute in our algorithm so we can provide any value so it would look
521:32 - something like this that dummy is on the stack and it is referencing one list node in the heap
521:39 - memory having value as zero and next pointing to null so this is a concrete object in the heap
521:46 - now why we are creating this dummy list node we will see later
521:49 - so one such usage of dummy is when we will compare the values of these two lists
521:55 - so one by one we will take out the nodes and add it to this dummy list node so instead of null
522:02 - one one value will keep on coming and at the end after this value will terminate
522:07 - and this logic will end all the list node of both the list will be added to the list
522:14 - being referred by this dummy node so here dummy list node will hold our final list
522:20 - which we will be returning it from this method merge method so it will hold our
522:25 - result list which is merged and sorted
522:37 - the second point of creating this dummy list node is it will help us in avoiding errors
522:45 - like null pointer exceptions
522:46 - so we will see this point later that how it helps in preventing null pointer exception
522:59 - so for timing you can just think that we have created one dummy list node now this list node
523:04 - will keep on adding one one node from both the list such that when the both the list will be
523:10 - exhausted all the list nodes will become part of this list referred by this dummy node moving
523:17 - ahead now here you can see that as we have created this dummy node this dummy node will refer to
523:24 - this node and our task is to merge these two sorted singly linked list by taking one one
523:31 - element and adding it after the dummy node so dummy node stays at this place what we do is
523:38 - we create a tail list node and which will point to dummy so it looks like this now this tail will
523:46 - help us in adding the nodes after the dummy node and after adding one one node the tail will move
523:53 - ahead and it will keep on adding till all the nodes are exhausted so that we will see in the
523:59 - while loop how it does now we are providing a while loop where the conditions are a should
524:06 - not be equal to null and b should not be equal to null so here you can see this and operator tells
524:14 - that if any of the list is exhausted or their references a and b reach to the end of the list
524:21 - we have to break from this while loop and why we are doing this is because so here if i take an
524:28 - example let's say a is referring to one four and then eight and b to three and six so if i see the
524:34 - resulting list it will be like this one then three then four then six so once six will be
524:44 - placed here you can see this b list will have its all the nodes in the resulting list
524:52 - and let's say after eight we have like nine eleven fifteen so after six b has got exhausted
525:02 - so it means that after six there are no more nodes which can be compared with the rest of
525:09 - the elements of a like eight nine eleven and fifteen so what we do is we simply break from
525:16 - this while loop because one of the lists got exhausted so there would be a point when either
525:22 - of the lists can get exhausted we will see this when we will execute the while loop so currently
525:28 - a is not equal to null b is not equal to null so the condition in while block comes out to be true
525:35 - so the while block will execute now we provide if and else condition and here what we are doing is
525:43 - as we want to merge these two sorted singly link lists such that the resulting list is also
525:50 - sorted what we do is we compare the data of a and b and we check which data is less
525:59 - so in this if condition we are checking that a data whether it is less than equal to b is data
526:05 - or not so here you can see one is less than three we are comparing one with three so one is less than
526:13 - three so this condition comes out to be true which means we are starting from the first node
526:22 - of both the list and we have found one node whose value is smaller among all the elements in the
526:31 - both the list because they are sorted in ascending order so your list node which is data as one
526:37 - being referred by a will be the first node of our resulting sorted singly link list one should come
526:45 - at the start so here you can see now what we do is tail is actually pointing to this dummy node
526:52 - and our task is to add this much node into the dummy list currently here you can see tails next
527:01 - is pointing to null so if we assign a to tails next it would look something like this the tail
527:09 - next which is pointing to null it will now point to a list node which is being referred by a
527:17 - so here this assignment will add this list node having data as one into this list whose head is
527:25 - dummy so we are taking the help of tail pointer to add this node so after we add this node
527:36 - we know that we have used one value of list a so we simply traverse a to its next node
527:45 - because the next comparison should be between three and four because we have compared one and three
527:52 - one was lesser than three so we added this list node into this list so now we simply move a to
527:59 - its next node so there are two reasons why we are moving it to its next node one is
528:06 - in the next iteration of while loop now we will compare four with three so therefore we need
528:12 - a reference to this node and the second point we will see in the next iteration
528:18 - so after this assignment a dot next a next which is node four we will assign that value to a so
528:26 - a will come to this node now like this and here in this step as tail has added one node here
528:35 - now the other node will come after one because this node is added and we have to add more nodes
528:42 - and tail will help us in doing that so we also traverse tail ahead by assigning tail dot next
528:48 - to tail so tail next is node one so now tail will reach here like this because next node will be
528:55 - added after one now a is not equal to null b is not equal to null so the condition in while
529:02 - block comes out to be true now we again compare the data of a and b so here we are simply comparing
529:11 - in this if block is whether four is less than equal to three or not
529:16 - so four is actually greater than three so this condition comes out to be false
529:22 - and the else block will be executed i'll just remove this so in the else block we know that
529:29 - among four and three three was the lesser value so now we have to add this node after one
529:37 - and how we can do that is b is referring to this list node and now we have to add this list node
529:44 - after one so we are taking the help of tail we assign b to tails next here if you see tails
529:52 - next is pointing to this node now so we have to break this link and point it to this node
530:00 - so by this assignment
530:04 - the first thing it will happen is this link will go away
530:09 - and as tail next was pointing to this node now tail next will point to b which is node three like
530:16 - this and also friends in previous while loop we moved a to its next so one reason was
530:28 - that we are comparing four with three the other reason is we have removed this reference from here
530:35 - and now it is pointing to this node so as soon as we remove this reference we need something
530:42 - to hold this two list nodes from the stack which is being done by a so therefore this is
530:48 - the another reason we are moving a to its next and now after this assignment
530:53 - we do the same this value is used up and now it is part of this list so here you can see dummy is
531:02 - pointing to list node having value is zero it is pointing to a node having value as one and one is
531:09 - pointing to a node having value as three so now we have used this value so we move b to its next
531:15 - node so by assigning b dot next to b so b next is this node when we will assign b dot next to b
531:23 - b will come here like this i will remove this and similarly we also moved tail ahead because
531:32 - the next node will be added after three now so we have to somehow reach here and we can only reach
531:39 - here is by assigning tails next to tail so tails next which is node three we will assign it to tail
531:46 - so tail will come here now like this a is not equal to null b is not equal to null so the condition
531:55 - in while block comes out to be true now a dot data which is four b dot data which is six so we are
532:02 - comparing four and six and we are checking whether four is less than equal to six or not
532:08 - so this condition comes out to be true because four is less than six
532:12 - and as four is less than six the next node after three would be four so in the first step what we
532:22 - are doing is tail is pointing to node three tails next is pointing to six so first we need to remove
532:29 - this link and how we can remove this link is to tails next we are assigning a so tails next
532:37 - we remove this node and we assign a which is node four so it would look something like this
532:45 - after this assignment we have used four also so we move a to its next node by assigning a dot next
532:52 - to a a dot next is eight so a will come to it via this reference and as we have added four here
533:03 - the next node will come after four and we are adding node based on our tail so we have to move
533:08 - tail also one node ahead so we are assigning tail dot next to tail so tail will come here
533:15 - like this via this assignment a is not equal to null b is not equal to null so the condition
533:23 - in while block comes out to be true and now we are comparing a data and b data we are comparing
533:32 - six and eight and here we are checking whether eight is less than equal to six or not in this
533:39 - if block so this condition comes out to be false because eight is greater than six so we execute
533:47 - the else part so here this if condition is telling that between six and eight six is smaller so six
533:55 - should be added first to the sorted singly link list which we want to merge so therefore that
533:59 - happens in the else block so this if block is dealing with a list and else block is dealing
534:05 - with b list and here we are doing the same thing we need to add this node referred by b after four
534:14 - and after four means tails next value so we are assigning b to tails next so first we are
534:20 - removing this node like this and after this assignment tails next will point to b like this
534:30 - and then we will move b to its next because we have used six also now so b will move to its next
534:38 - and here you can see b next was null so now b is referring to null
534:44 - we have added six now so the next node will be added after six so tail should come here
534:51 - and tail will only come here when we will assign tails next to tail so tail is pointing to four
534:57 - its next is pointing to six so when we will assign tail dot next to tail tail will point to six
535:04 - like this so friends here you can see that when we are traversing this while loop there will be a
535:11 - moment that one of the list will become empty both the list cannot become empty because as we are
535:18 - adding one one node from each of the list there will be a point when one of the list will become
535:23 - empty so it could be b or a any list can become empty so if any of the list becomes empty we
535:32 - break from this while loop like this and after this while loop we have this if else block now
535:39 - why we have provided this if else block is b got exhausted but there could be a chance that in a
535:46 - there could be elements left so currently here we have only one element there could be a possibility
535:52 - that its next should point to let's say nine then 10 20 like this so our task is to add this
536:01 - remaining nodes as well after six because tail is pointing to six and eight should come after six
536:08 - via this tail node so we check that which list got empty so here in this if block we are checking
536:15 - that which list got empty whether it was a or b so here you can see b is actually pointing to
536:22 - null it means b got exhausted a is not equal to null a is actually referring to a node so this
536:29 - condition comes out to be false and the else part will be executed so you can see if a got exhausted
536:37 - b comes into picture and we assign all the nodes of b to tails next if b got exhausted
536:44 - then we are adding all the nodes of a to tails next so here b got exhausted and we need to put
536:52 - let's say this node into the list so at the last step what we do is we assign a to tails next
537:00 - tail is pointing to six its next is pointing to null so if we assign a to it this will go away
537:08 - and there will be a link from tails next to a like this via this assignment and here you can see
537:16 - as we need to merge these two sorted singly link list in such a way that the resulting list is
537:22 - also sorted we don't have to do anything with the rest of the elements of a let's say it had nine
537:29 - ten twenty like this because they are already sorted so why are this reference all the nodes
537:35 - will be part of now this complete list so our task will be done here
537:43 - so here you can see this dummy list node has built one chain
537:47 - which is actually our resulting list so here you can see it goes like this
537:51 - so here one thing to note here is this dummy list node was created by us therefore we don't
538:10 - have to include this so therefore at the end we are returning dummy dot next dummy is pointing
538:16 - to this list node it was actually a dummy list node which we created here so at the end we need
538:22 - to return dummy dot next so dummy next is this node so we are returning a list node which is
538:32 - holding this list like this from this method so the method which is calling this merge
538:40 - will get a list node let's say if it is called like this
538:49 - so our head
538:53 - will be pointing to one and it goes like three four six and eight and so on
539:05 - so this head will be in the stack and this will be in the heap all the nodes so we are returning
539:11 - dummy dot next because we have to discard this dummy because all the nodes which we added
539:17 - using our tail were after the dummy node so we have to discard this so here if you see if i
539:24 - if we hold this pointer and if we stretch it i this nodes will be stretched out and it will look
539:31 - like this so dummy was our node which we created it has no significance we return dummy dot next
539:38 - so dummy next is this so this is our final sorted singly linked list which actually has all the
539:47 - elements of a and b so from here you can see that we use dummy list node and we saw that it helped
539:55 - us in building up this list because this is one concrete node in the heap and this is on the stack
540:03 - so dummy is referencing one concrete node on the heap and then we are simply adding the rest of the
540:09 - nodes after dummy so this was the one case where we are actually creating this dummy list node
540:16 - the other thing we saw was that it helped us in avoiding null pointer exceptions
540:21 - so here let's say if we are not using this dummy list node so here we are not using this line
540:29 - instead of this dummy list node we have to create one head
540:32 - which we can return from this method so we have to do something like this
540:37 - like this instead of this and this tail instead of dummy it should point to head
540:53 - and instead of dummy dot next we should return head because this list node head will be holding
541:02 - the merged sorted singly linked list but here you can see that once we execute this line
541:09 - and we are not creating this dummy list node so it would look something like this
541:14 - after this line head will point to null and when we will execute this line we are assigning value
541:23 - of head to tail because this tail will help us in adding of the nodes in this while loop
541:30 - so here it would look something like this tail will refer to a value which is being held by
541:37 - head via this assignment so tail will also start from null now here you can see in this while block
541:44 - we have provided if and else block and let's say when we compare one and three for the first time
541:50 - we know that one is less than three so this condition would have been true because a data
541:55 - is less than b data so here you can see when this line would have been executed
542:00 - here we are assigning a to tails next but when this line will be executed tail is pointing to
542:07 - null and if we are doing this dot next it means we are accessing a variable which is being referred
542:15 - by tail so there should have been one concrete object in the heap on that we have to call next
542:22 - but here tail is pointing to null so here you can see it will give us a null pointer exception
542:27 - because tail is pointing to null it doesn't have any object in the heap on which we can call next
542:35 - similarly here also we would have got an error so we will get null pointer exception
542:42 - so this is one of the uses we are creating this dummy list node because we need this concrete
542:48 - object so that we can use tail and add this remaining nodes so this is one important thing
542:54 - to remember that we usually create this dummy list node to avoid the null pointer exceptions
543:01 - now let's say if we are told that we don't have to use this dummy list node we want to merge this
543:08 - to sorted singly linked list using the normal nodes so we can also solve the problem that way
543:14 - this dummy list node is actually helping us in avoiding these errors and the checks
543:22 - but what if we want to merge these two lists without the dummy nodes so how we can approach
543:27 - that is now here you can see that head is starting from null now what if head starts from a
543:35 - concrete list node in the heap and it doesn't start from null so if i just remove this line
543:42 - so you can think before this assignment of head to tail we have to write some logic
543:48 - to handle this condition so that these errors are avoided what we need to do is the things
543:54 - which we are doing in while loop in one shot that we are comparing all the nodes using this
544:01 - if and else condition what we do is for the first time we just check for one of the nodes
544:08 - so this check which we are doing in the while block we have to do for the first comparison so
544:15 - that we can get one concrete node in the heap so we have to write some extra logic so what we do is
544:22 - here you can see before while block and this tail assignment we have to write some logic like this
544:30 - here you can see this conditions are very much similar to this while block
544:34 - so here what we are doing is as we need one concrete object in the heap and we don't have
544:40 - to use this dummy object what we do is to get one of the concrete objects from this two list
544:48 - we do the first comparison out of this while block here we do a.data and check whether it
544:54 - is less than b.data and if a.data is less than b.data so currently one is less than three
545:01 - so what we do is we simply treat this node as our starting node and we directly assign
545:10 - head to it via this assignment and as we have used this node so we simply traverse a
545:19 - to this node by assigning a.next to a so this if and else block is very much similar conditions
545:27 - but for getting one of the concrete nodes we do this one check out of this while block
545:34 - and rest of the code is pretty much the same this a not equal to null and b not equal to null
545:40 - a not equal to null will start from this node so when we had created this dummy list node
545:46 - this code we don't have to write and all the logic would have been compared in this while block
545:53 - so first node of a and first node of b would have been checked in the while block
545:57 - but if we don't want to use this dummy list node we somehow need a concrete node so for getting
546:04 - this first node we are doing this check outside the while block here so that we can get a concrete
546:11 - head so rest of the logic is similar once we get head here tail will point to head like this
546:20 - and now in the while block if we do tail.next we actually have a concrete object here we had
546:27 - a null object but here now we have a concrete object so therefore this error won't come
546:33 - and at the end we can simply return head so friend this is how we actually merge two sorted
546:39 - singly linked list so that resulting list is also sorted you need to be very careful
546:46 - while merging this two lists using this dummy node it will make your code easy and simple
546:53 - to write but if you don't want to use this dummy node the first thing you need to do is
546:59 - to identify the actual starting point of the head which is our resulting list so we have to do this
547:06 - comparison first to get our first head and then we can provide this while block and do the similar
547:15 - stuff which we already discussed and at the end instead of doing dummy.next we are returning head
547:22 - so friends i hope you must have liked this video in case if you're new to my channel then please
547:27 - subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice
547:33 - day hello everyone so in our previous video we saw an animation in which we discussed that how
547:41 - we can merge two sorted singly linked list so in this video we will actually code the algorithm
547:47 - and we will test its working in the main method so friends before we start in case if you're new
547:52 - to my channel then please subscribe to my channel and click the bell icon so that you never miss
547:57 - any update so here in our previous videos we have created one class as singly linked list
548:04 - so in the same class we will actually code the algorithm
548:11 - so here let's say i give the method name is public
548:22 - merge so this merge method will take two list node a
548:32 - and b so these two list nodes represent two sorted singly linked list and now our task is
548:41 - to merge these two sorted singly linked list and return it back from this method so here as we need
548:48 - to merge these two sorted singly linked list the first step we do is we create a dummy list node
548:56 - and we provide a dummy value to it now this dummy list node will actually hold our merge sorted
549:07 - singly linked list and in our previous video we have saw that why we are creating this dummy list
549:13 - node it is actually providing us a concrete object in the heap so that we can avoid the null point
549:18 - and exceptions now as this dummy list node will hold our merged sorted singly linked list
549:25 - we will create a list node let's say by name tail and this tail will actually point to this
549:34 - dummy list node so the dummy list node will actually hold the complete list and we will
549:39 - use this tail list node and we will add one one element from the both the list using this tail
549:45 - pointer we will see that later now after that we will provide a while loop now as we need to
549:55 - merge these two sorted singly linked list we have to compare their respective elements with each
550:00 - other so that we will do in the while loop so the condition we provide is a should not be equal to
550:07 - null and we should not be equal to null so here as we are comparing one one element from both the
550:16 - list with each other there will be a time that either a or b get exhausted so if any of the
550:23 - list get exhausted we will exit from the while loop now inside this while loop as we are merging
550:29 - these two sorted singly linked list and we want the resultant list also sorted let's say if i
550:35 - give an example
550:55 - so here let's say a has three nodes one three five and b has three nodes two four and six
551:01 - now when we will merge these two sorted singly linked list the resultant list
551:09 - will be like
551:19 - it will also be sorted so here in this while loop what we are doing is
551:24 - we are comparing the elements of both the list first we compare one with two we know that one
551:29 - is less than two so one will be inserted first then after inserting one we move to three and
551:36 - then we compare two with three and we know that two is less than three so the next element comes
551:42 - as two so we move to four and then we compare three with four three is less than four so three
551:48 - will come here and we keep on doing that till one of the list get exhausted so here we provide a
551:56 - condition because we need to find the smallest element among the both the list for the current
552:03 - iteration so here what we do is we simply compare a data and see whether it is less than
552:13 - or equal to b's data so if a's data is less than equal to b's data it means
552:19 - two tails next we will assign a and then we will simply move a to its next node so here
552:30 - when we compared one with two one is less than two so we added one to the resultant list
552:37 - via this assignment and then we move to three so we did a equal to a dot next and similarly
552:45 - if b's data is less than a's data what we do is we simply add b
552:54 - two tails next and then we move b to its next node
553:01 - so here one is less than two so we added one and we moved to three and in the next iteration we
553:07 - compared two with three so two was less than three so we added two here and then we moved
553:13 - two four so that in the next iteration we compare three with four and why we are doing
553:18 - this comparison because we need to get this list and it should be sorted so in this while loop we
553:25 - are comparing each and every element of a and b and whichever element is less we are simply adding
553:32 - that node into tails next and then we are simply moving the respective references to its next node
553:39 - so that we can compare the next element and here we also need to move tail to its next node
553:48 - so here let's say first we added one so initially tail must have been here so we have used tail dot
553:54 - next and added one so the two will come after one so we have to move tail also ahead so that
554:01 - in the next iteration if we do tail dot next two will come here and then we'll simply move tail
554:07 - to two and we keep on moving tail ahead till there are nodes in a and b so this step is also
554:14 - important that we need to move tail also ahead so that in the next iteration we are adding a
554:19 - different element to tails next so after this while loop there will be two possibilities
554:25 - either a will get exhausted or b will get exhausted so here let's say if i copy this part
554:32 - so let's say instead of five we have like this and here we have
554:49 - so here you can see in the result list
554:51 - first we will add one then two will come then three
555:03 - four so after four a will get exhausted and as we need to merge these two sorted
555:11 - singly linked list these elements should also become the part of the result list
555:17 - so one property here to notice as both the list are sorted and as one of the list get exhausted
555:23 - we can directly append the rest of the list after four so we can directly do this
555:31 - after the while loop like this and this will actually merge both the list and will also
555:37 - be sorted so here what we do is we simply check if a is equal to null because here in the while
555:47 - loop as we are moving a to its next and b to its next either a will get exhausted first that a will
555:55 - point to null or b will get exhausted that b will point to null so if a is equal to null then here
556:02 - we saw that we have directly appended b to the result list so here what we do is
556:13 - we do b
556:19 - else if b is equal to null
556:22 - we directly append a and after this if else block we know that we have merged both the list
556:32 - so at the end what we do is we need to return the head of this resultant list so we will simply do
556:40 - dummy dot next and we will return it so why we are doing dummy dot next here you can see
556:49 - this dummy is a list node we created and whatever the nodes we added we added after this dummy
556:57 - using tails next we started with dummy node and we used tails next and added the nodes
557:04 - so the actual head would be dummies next because the first node was inserted in tails next
557:09 - and tail was pointing to dummy so at the end we need to return dummies next
557:13 - so friend this is the algorithm to merge two sorted singly linked list
557:19 - now let's test its working in the main method
557:24 - so in the main method we will create two singly linked list
557:34 - and we will add few nodes to it
557:36 - we do insert last and let's say if we add the nodes in the sorted form so we first add one
557:53 - and let's say we add four and eight so this node should be in sorted form
558:00 - first node will be one then it will be four and then it will be eight
558:06 - now we'll create one more singly linked list
558:20 - and here let's say if i give value as three five eight
558:26 - let's say nine
558:38 - fourteen
558:43 - so here after eight this list will get exhausted
558:47 - and we can directly place the remaining list via this if else block
558:51 - so if i do dot display
559:02 - so currently if i run the code
559:08 - so here you can see we have this two singly linked list which are sorted one four eight
559:16 - three five eight nine fourteen and eighteen like this
559:21 - so now we'll call the merge method and as we need to pass the head of a and b what we'll do
559:33 - dot head
559:39 - so we have passed the head of both the list because this method is taking a list node
559:45 - and this method will return us a list node representing a singly linked list which is
559:52 - merged and sorted so here we will create one more singly linked list we'll give a name as result
560:02 - and let's say whatever list node this merge method will return we will simply add it to results
560:08 - head like this and we will simply do result dot display so when we will merge this two sorted
560:18 - singly linked list this head will actually hold that list and then here we are calling the display
560:24 - method to print the contents of the final list so if i run the code now
560:29 - so here you can see that the resultant list which we got is the combination of these two lists
560:41 - and it is also sorted so one three four five eight eight because we have two eight here
560:50 - then nine fourteen eighteen so after this list got exhausted eight nine fourteen and eighteen
560:57 - were directly added here so friend this was all about that how we can merge two sorted singly
561:04 - linked list here we have used the idea of dummy pointers which we have discussed in greater detail
561:10 - in our previous video and using a tail we are adding one one node in this while loop after
561:17 - comparing a's data and b's data and at the end if any of the list got exhausted we are simply
561:24 - appending the opposite list to tails next and at the end we are returning dummy dot next because
561:32 - this dummy we actually created to get a concrete object and all the nodes were added just after
561:39 - the dummy node so at the end we simply return dummies next so friends i hope you must have
561:45 - liked this video in case if you are new to my channel then please subscribe to my channel
561:49 - and click the bell icon so that you never miss any update thanks have a nice day
561:56 - hello everyone so in this video we are going to discuss a problem that how we can add
562:01 - two singly linked list so let's move ahead and see what this problem is and how to solve this
562:08 - so here in this problem we are given with this two singly linked list which are non-empty so we have
562:14 - this two singly linked list a and b they actually represent a number which is a positive number
562:21 - the digits are stored in reverse order and each of their nodes contains a single digit so as this
562:27 - is a number each node in the list have a single digit and this complete number is stored in
562:33 - reverse order so if you want to know the number you have to read it from end so here the number is
562:39 - three four three so three four three for this list it would be four six five
562:50 - because they are stored in reverse order now our task is to we need to add these two numbers
562:56 - and return the sum as a linked list like this so here you can see if we add these two numbers using
563:03 - a plain maths here you will get eight four and six will give ten so zero will come here and one
563:10 - will be carried over four and three will give seven seven plus one eight so our answer would be eight
563:16 - zero eight so we need to return eight zero eight which is the sum of these two numbers
563:22 - in the form of a singly linked list here we are given that two numbers does not contain any leading
563:28 - zero so for example here we won't have something like this because those are leading zeros
563:35 - the zero can only come so here let's say if we are given a singly linked list like this
563:44 - so this is a valid singly linked list because the complete number is zero
563:49 - so now let's move ahead and see the demonstration of this algorithm step by step
563:53 - so friends before we start in case if you are new to my channel then please subscribe to my channel
564:00 - and click the bell icon so that you never miss any update so here we are given this method add
564:07 - we pass two singly linked list a and b like this now we need to do the sum of these two numbers
564:15 - and return the sum in the form of singly linked list only where each node will have only one digit
564:20 - so here you can see the numbers are stored in reverse order so the number we are trying to add
564:26 - is nine four seven because the number is stored in reverse order we are adding 65 to it like this
564:37 - so seven plus five will give twelve two will come here one will be carried over here
564:42 - six plus four will give ten ten plus one will be eleven so one will come here and another one will
564:48 - be carried over nine plus one will give ten so our answer is one zero one two so here this one
564:54 - zero one two should be returned in the form of a singly linked list where each digit should be in
564:59 - the respective nodes so for the results singly linked list we have to first create a dummy list
565:05 - node which will have a dummy value zero so friends in our previous videos we have discussed the idea
565:12 - of dummy list node that why we actually create this dummy list node it basically helps us in
565:17 - avoiding the null pointer exceptions and also it actually provides a concrete object in the heap
565:23 - or else what we need to do is we need to write some extra logic to just evaluate the first list node
565:29 - and then proceed from there on so in order to learn more about dummy list node you can watch
565:34 - my previous videos to it so here at the step one we will create a dummy list node
565:41 - so friends in this algorithm what we are trying to do is we will take one one single digit from
565:47 - both the list we will add them and whatever will be the sum that sum we will create a list node and
565:53 - add just after the dummy list node so currently dummy's next is pointing to null but after we do
565:59 - the sum of each node from both the list whatever their sum will be we will create a list node and
566:05 - we will add to this dummy list so for that we are creating a tail list node like this it is
566:12 - referring to dummy list node we will use this tail to add the list node into this singly link list
566:18 - one by one so that stuff we will be seeing in the while loop moving ahead so here you can see
566:27 - that one list node can have only one digit so the maximum value this list node will have
566:32 - is from 0 to 9 and let's say if we are adding 7 plus 5 so we'll get answer as 12 so we can only
566:40 - store one digit so usually when we do plain maths what we do is we store two here and one is carried
566:47 - over so this one we will be keeping track via carry so at the start carry is zero because we
566:53 - haven't started our addition so carry is zero now we will provide a while loop where the conditions
567:02 - are a is not equal to null or b is not equal to null so in this while loop what we are doing is
567:09 - we are taking one node from both the list and we will do their sum but there could be a chance
567:14 - that one list gets exhausted before the other and as we need to do the sum of this complete two
567:20 - singly link list the condition we provide is a should not be equal to null or b should not be
567:26 - equal to null so even if b is equal to null let's say b reached here and a reached here
567:32 - so b is equal to null but a is not equal to null so therefore this while loop will run one more time
567:37 - to take the sum of this last digit and add that sum into our result list
567:45 - so even if one list is not empty this while loop will keep on running
567:48 - so at the start a is not equal to null and b is not equal to null so the condition in while loop
567:54 - comes out to be true now here what we are doing is even if one condition comes out to be true
568:01 - the while loop will execute so there could be a chance that a is not equal to null but b is
568:06 - equal to null or a is equal to null but b is not equal to null so we need to take this value 7 plus 5
568:15 - but before taking those values we need to check whether a and b are actually pointing to null or
568:20 - not so here we have used a ternary operator where we are checking whether a is not equal to null
568:26 - so if a is not equal to null we take a is value but if a is equal to null then we take the value
568:32 - 0 because 0 won't affect the sum so this ternary operator condition states that if a is not equal
568:39 - to null so currently a is not equal to null so we will take the value a dot well which is 7
568:46 - and that will be assigned to x like this
568:53 - similarly we have to take this value because we are adding the first digits
568:58 - so we are first checking whether b is equal to null or not so if b is not equal to null it means
569:04 - there is a digit we need to add so we are simply taking b dot well which is 5 and that will be
569:10 - assigned to y like this so here we have taken out the values in x and y and now what we do is
569:20 - we do the sum so at the start we have a carry as 0 so here carry is 0 we are taking the first
569:27 - digit 7 which is x second digit 5 which is our y and we are doing the sum of these three numbers
569:35 - so 0 plus 7 plus 5 will give 12 so sum will become 12 like this
569:43 - so from here you can see we need to store this sum in such a way that only one digit can come
569:49 - in the list node and when we actually do the maths we get sum as 12 we put 2 here and we carry
569:55 - your 1 to the next digit so how we can perform this mathematical addition is we take the help
570:01 - of division and modulus operator so if we take sum as 12 the maximum value each node can have
570:09 - is single digit so if we take sum as 12 if we divide it by the first two digit number which is 10
570:18 - we'll get 1 and if we do 12 mod 10 this will give us remainder which is 2 so here you can see
570:26 - we can use these properties where we take the remainder like this which is our 2 and we can
570:32 - take the carry by dividing it by 10 so here we are first evaluating carry for the next addition
570:40 - so sum is 12 if we do divided by 10 carry will become 1 because we need to put 2 here
570:46 - and send 1 to the next addition and now as we are putting 2 here this
570:54 - property will help us in taking out 2 from the sum so we are doing sum mod 10
571:01 - which will give us 2 and that 2 will be our single digit and we need to return this result
571:07 - in the form of a singly linked list so we will create this list node and we have to add it
571:12 - in the dummy list so we'll take the help of tail so to tail next which is null we'll create a list
571:18 - node provide a value as 2 and add it to tails next so after executing this line tail next
571:25 - was pointing to null so now it will point to a list node having value as 2 which is our first
571:32 - value of the addition moving ahead now after putting 2 if we look into the digits the next
571:40 - digit will become 1 so that will come after this 2 so in the next iteration we will be using tail
571:47 - to put 1 so for that we have to move tail to the next node so that we can still use this condition
571:54 - tail.next and add the new list node so after adding 2 we'll move the tail to its next node
572:00 - by assigning tail.next to tail so it would look something like this because in the next iteration
572:07 - we are doing the sum of the second digits and we will put after 2 using the tails next
572:16 - so friend after we perform the sum of first two digits we need to move a to its next and b to its
572:24 - next to take the next two digits so for that we have to first check whether a or b are actually
572:30 - pointing to null or not so if a is not equal to null we can safely go towards its next by assigning
572:36 - a.next to a so at the first step it would look something like this a will now come to its next
572:44 - because a next is pointing to this node so now a will point to this node
572:50 - similarly we will move b to its next because b is also not equal to null so it would look
572:56 - something like this b next is this node so now b will point to this node
573:01 - i will remove everything
573:08 - so here you can see a is not equal to null a is pointing to the second node
573:12 - b is not equal to null b is also pointing to the second node so the condition in while
573:17 - loop comes out to be true so first we will evaluate x we first check whether a is not
573:23 - equal to null so a is not equal to null so we simply do a.well it means we are taking
573:28 - this value out 4 and assign to x so x becomes 4 then we will evaluate whether b is equal to null
573:39 - or not so b is not equal to null so we will take b.well and assign to y so we'll assign 6 to y
573:48 - like this and we know that after the first addition the carry was 1 so we will do the sum
573:55 - of carry x and y so here if you see 9 4 7 6 5 if we are adding it we get 2 and 1 as our carry
574:08 - 4 plus 6 is 10 plus 1 will give 11 so 1 will come here and 1 will be our carry 9 plus 1 will give 10
574:17 - 0 will come here and 1 will be our carry so the addition will give 1 0 1 2 so we have done with
574:24 - the first addition which is 2 here 1 became our carry and x and y are actually denoting 4 and 6
574:33 - so we are doing some of these three digits now 1 plus 4 plus 6 so carry plus x plus y
574:39 - so sum will become 11 so if you look at the sum we can only store one digit and another one will
574:48 - be the carry over so first we will evaluate the carry for the next addition so 11 divided by 10
574:55 - will give the value as 1 because when we will divide 11 by 10 we get value as 1 so our carry will
575:02 - become 1 and the digit we want to store here is will be given by the remainder so 11 mod 10
575:12 - whatever value it gives here it is 1 so that will be stored here and how it can be stored
575:18 - we have to store in the form of a list node so some mod 10 will give the remainder as 1 so we
575:25 - will create this new list node and we will assign it to tails next so tails next is pointing to null
575:31 - so this will go away and 1 will come here which is this one moving ahead so now we have to move
575:41 - tail to this node because when we will perform the third addition that node will come after this
575:47 - one so tail should go to this node so we will assign tail dot next to tail so tail next is
575:54 - pointing to this node so now tail will come to this node via this assignment
576:03 - we are done with processing of second nodes so now we have to move a and b to its next node
576:09 - so first we will check whether a is equal to null or not so if a is not equal to null we can
576:15 - safely move to its next node by assigning a dot next to a so a dot next is this node
576:21 - so now a will come to this node b is not equal to null so we will assign b dot next to b
576:30 - so b dot next is pointing to null so now b will point to null
576:39 - so friends here you can see the singly linked list b got exhausted and we have reached to the
576:45 - end of the singly linked list but as we are performing the sum of these two singly linked
576:49 - list we have to take the sum of this nine as well so here b is equal to null so this condition
576:57 - comes out to be false but a is not equal to null because there is one more node left so this
577:02 - condition comes out to be true and there is a or so therefore the condition in while loop comes
577:08 - out to be true a is not equal to null so we will take a dot well which is 9 we will assign it to x
577:17 - x become 9 here you can see b is actually equal to null so we can't do b dot well because this
577:25 - will give us null pointer exception because b is not pointing to null so therefore what we do is
577:30 - if b is not equal to null we take b dot well if b is equal to null we take the value of y as 0
577:38 - this because when we will do sum of x plus y plus carry y will be 0 and it won't affect the sum
577:46 - so here if we do 1 plus 9 plus 0 so it won't affect the sum
577:53 - so therefore we need to put this check that if b is equal to null we take the value of y as 0
577:59 - like this and now we will do sum of carry plus x plus y so carry was 1 x is 9 y is 0
578:09 - if we do their sum we get sum as 10 now we get the sum as 10 so we put 0 here and 1 will be our
578:19 - carry over which is here so first we will evaluate the carry by doing 10 divided by 10 so the answer
578:25 - will be 1 so carry will become 1 like this and then we have to take this value 0 so if we do
578:34 - sum mod 10 which is 10 mod 10 we get remainder as 0 so this will become 0 we will create a list node
578:44 - and we will add it to tails next like this so via this assignment we are adding this new list node
578:52 - having value is 0 this using tails next
578:59 - we will move tail to its next like this
579:07 - and here you can see that with this addition we have used this value and this value so a is not
579:14 - equal to null we have to move to its next so a is not equal to null here we assign a dot next to a
579:20 - so now a will point to null we check whether b is equal to null or not so actually b is equal to
579:28 - null so we don't perform this b dot next to b because b is already pointing to null
579:37 - so now here you can see a is equal to null and b is equal to null so therefore both the
579:44 - condition in while loop comes out to be false because a is equal to null and b is equal to null
579:50 - so this while loop will terminate
579:54 - so friends one thing to note here is we have simply done the sum of first three digits
579:59 - 2 1 and 0 but the actual addition result is 1 0 1 2 so this one which was our carry over
580:06 - so we will check here whether carry is greater than 0 or not so if carry is 0 we do nothing but here
580:13 - value of carry is 1 which is greater than 0 so we have to add one more node to tails next
580:20 - to encounter for this carry also so currently carry is greater than 0 we will create a list
580:26 - node by passing in the value as carry which is 1 and we are simply assigning it to tails next
580:32 - so tails next is pointing to null so now it will point to a node having value as 1 which is the
580:39 - value of over carry so friends here you can see that we have done the sum of these two singly
580:46 - linked list the digits were in reverse order so our sum is also in reverse order so 9 4 7 if we
580:54 - add to 65 so 9 4 7 if we add to 65 we get answer as 1 0 1 2 so here at the end we simply return
581:08 - dummy dot next because this dummy is pointing to a list node which actually we created so this is
581:14 - a dummy value so we'll simply return dummy dot next which is a list starting from this list node
581:22 - so it would look something like this that we have dummy list like this and we are returning dummy
581:28 - dot next so the method which called this add method will get like this this would be our answer
581:36 - 2 1 0 1 so friends this was all about that how we can add two singly linked list i hope you must
581:43 - have liked this video in case if you're new to my channel then please subscribe to my channel
581:48 - and click the bell icon so that you never miss any update thanks have a nice day
581:57 - hello friends welcome to my new data structures and algorithm in java tutorial series video
582:02 - so friends in this tutorial we will discuss how to represent doubly linked list in java
582:11 - so friends in my previous tutorials i discussed about singly linked list
582:16 - so in this tutorial i will be discussing about doubly linked list
582:22 - so friends when we discussed about singly linked list so it was a one-way linked list
582:27 - it had only two things one was the data and other was the pointer to next list node
582:34 - but if you see in doubly linked list it is actually a two-way linked list
582:39 - so if you see a doubly linked list we have this list node which has basically three things one
582:45 - is the actual data which it holds and another is the next pointer so this next pointer points to
582:51 - the node which is just after it and it also has a previous pointer which points to a node
582:58 - just before it so this way it's a two-way linked list so in doubly linked list suppose if we are
583:05 - given any particular node then we can use that node to navigate the list in both forward and
583:12 - backward direction if you would have watched my previous tutorial on singly linked list then we
583:17 - saw that we could only move in forward direction in singly linked list so it's not possible to move
583:23 - in backward direction when we are using the singly linked list but with doubly linked list we can
583:28 - move forward and backward in the both direction and one other difference between singly linked
583:33 - list and doubly linked list is like a node in singly linked list can only be deleted if we
583:38 - have a pointer to its previous node but in doubly linked list we can delete the node even if we
583:43 - don't have pointer to its previous node so as you saw the singly linked list moves in forward
583:48 - direction so in order to break any chain or any node in between the singly linked list we usually
583:55 - need a pointer to its previous node to delete the node after it but in doubly linked list as we have
584:01 - these two pointers which helps us in traversing forward and backward then we don't need any pointer
584:07 - to its previous node so for doubly linked list implement the list node with a slight different
584:17 - way than singly linked list so the list node in singly linked list had data and a pointer to
584:25 - the next list node but in doubly linked list the list node has data a pointer to the next list
584:32 - node and a pointer to the previous list node so you can see this is how we represent a list node
584:37 - in doubly linked list so if you want to represent a doubly linked list then it's something like
584:47 - usually we have this head and tail pointers so the head points to the first node and the tail
584:53 - points to the last node so you can see each list node has data a pointer to its next node
585:01 - and a pointer to its previous node so usually the head points to the first node and its previous
585:07 - is null and the tail points to the last node whose next pointer points to null so it's like a two-way
585:13 - linked list where each node has one next and one previous so this is how they form a chain where
585:21 - each node refer to other node next to it and a node previous to it so the traversing becomes easier
585:27 - in forward and backward direction so let's say suppose we have a pointer to this third node then
585:32 - if you want to traverse to the forward then we can use this next pointer and traverse forward
585:38 - and if suppose if you want to traverse backwards then we can use this previous pointer to traverse
585:43 - backwards so this is a basically an advantage of doubly linked list over singly linked list
585:49 - so friends in this tutorial we discussed about how to represent a doubly linked list in java
585:54 - and in my next tutorial i will be discussing the way to implement the doubly linked list in java
585:59 - i hope you like this video please like comment share and subscribe my youtube channel
586:04 - thanks have a nice day hello friends welcome to my new data structures and algorithm in
586:10 - java tutorial series video friends in this tutorial we will discuss how to implement doubly
586:17 - linked list in java so friends in my previous tutorial i discussed how to represent a doubly
586:24 - linked list so here if you see a doubly linked list has basically a head and a tail pointer
586:31 - so the head points to the first node and the tail points to the last node so we also discussed
586:36 - that list node has a next pointer which points to the node after it and has a previous pointer
586:43 - which points to the node just before it and we also discussed that a doubly linked list is a
586:48 - two-way linked list that is it we can traverse the doubly linked list in both forward and a backward
586:55 - direction so a list node which has a next pointer and previous pointer help us in traversing in
587:01 - forward and backward direction so this is a basically an advantage over singly linked list
587:08 - we also saw that how to represent list node in doubly linked list so a list node in singly
587:13 - linked list had only data and a next pointer which points to the node after it but in doubly
587:18 - linked list the list node has data a next pointer which points to the list node just after it
587:25 - and also a previous pointer which points to the list node just before it
587:31 - so friends let's go to eclipse and see how we can implement a doubly linked list
587:35 - so friends in my previous tutorials i discussed about singly linked list
587:43 - so in this tutorial we will see how to implement a doubly linked list in java
587:47 - so here i have just created a class by name doubly linked list so this class will hold
587:52 - the implementation for doubly linked list so in order to implement a doubly linked list
587:57 - we need list node class so we'll create an inner class
588:04 - by name list node
588:09 - so basically this list node class will hold the pointers to next and the previous nodes
588:15 - so as we discussed in the slide that list node contains three things
588:18 - private int data so it contains data and this data can be any generic type as well
588:29 - but here i will be taking it as integer
588:36 - it holds a pointer to the next list node
588:39 - and it also holds the pointer to its previous node
588:52 - so the three things are data a pointer to the next node a pointer to the previous node
588:59 - we'll also create one constructor
589:02 - so this constructor will take the data part
589:17 - and we'll simply assign data to this dot data so this is how we represent our list node
589:25 - and we also saw in the slide that doubly linked list had a head pointer and a tail pointer
589:31 - so we'll create two instance variable of list node one is head
589:40 - another one is tail
589:46 - so basically the head will hold the first node of the doubly linked list
589:50 - and the tail will hold the last node of the doubly linked list here we also create
589:56 - a integer variable by name length so this integer variable will hold the length of doubly linked list
590:10 - so it will just return the count of number of nodes in the doubly linked list
590:16 - so we'll also create one constructor for doubly linked list class
590:19 - so here we'll assign the values of these three instance variables
590:31 - so this dot head equals signal this dot tail
590:40 - so basically when we initialize doubly linked list the list is empty so the head and tail will
590:54 - point to null and length of the doubly linked list is zero we'll also create one method by name
591:02 - is empty so this method will return a boolean value which will signify whether our doubly linked list is
591:13 - empty or not so we can simply return length so suppose the length of doubly linked list is zero
591:27 - therefore the list is empty so it will return true we can also return something like head is
591:35 - null so even if head is null then the list is empty so we can use either of the two statements
591:45 - we'll also create one more method which will return back as the length of doubly linked list
591:56 - so friend this is how we represent a doubly linked list in java so in this tutorial i just created an
592:05 - inner class list node two methods is empty and length so in my upcoming tutorial we will discuss
592:12 - how we can insert the node in doubly linked list and how we can delete the node in doubly linked list
592:19 - so friends i hope you like this video please like comment share and subscribe my youtube channel
592:25 - thanks have a nice day
592:28 - hello friends welcome to my new data structures and algorithm in java tutorial series video
592:34 - friends in this tutorial we will discuss how to print elements of a doubly linked list in java
592:41 - so let's say we are given a doubly linked list having four nodes say 1 10 15 and 25 and as you
592:48 - can see head points to the first node which is 1 and tail points to the last node which is 25
592:55 - and each node in doubly linked list has one next and one previous pointer so the next pointer
593:00 - points to the node just after it and previous pointer points to node just before it
593:08 - so friends in doubly linked list we can traverse the list in forward and as well as in backward
593:13 - direction so below is the algorithm to traverse a doubly linked list in forward direction
593:19 - so let's see demo of its working so first we'll create a list node by name temp and
593:25 - we'll assign the value of head to it so as head points to first node now temp will point to the
593:33 - first node moving ahead so friends the basic idea behind this algorithm is we have this temporary
593:41 - node so using this temporary node we'll visit each and every element of doubly linked list and
593:47 - we'll print the data on the console so this while loop helps us in traversing the doubly linked list
593:55 - and also printing the data so we'll traverse this temporary list node till it becomes null
594:02 - so currently a stamp points to the first node
594:06 - and it's not null therefore the condition in while loop comes out to be true
594:11 - we'll print the data associated with this temporary node
594:21 - and then simply we'll move temporary node to its next node by assigning the temp dot next value
594:27 - to temp so currently you see temp points to first node at its next point to the second node
594:34 - therefore we'll assign the temp dot next value to temp so it will look something like this
594:39 - moving ahead
594:48 - now it's temp points to second node and it's not null therefore condition in while loop comes out
594:53 - to be true so we'll print the data associated with it
594:59 - and then we simply move temp to its next node by assigning temp dot next value to temp
595:15 - moving ahead
595:21 - now as the temp is pointing to third node and it's not null therefore condition in while loop comes
595:26 - out to be true so we'll simply print the data associated with this node which is 15
595:40 - and we'll simply traverse the temp to its next node by assigning temp dot next value to temp
595:57 - now here temp points to the fourth node and it's not null therefore condition in while loop comes
596:02 - out to be true we'll print the data associated with the fourth node which is 25
596:14 - and we'll simply assign the value of temp dot next to temp so temp dot next points to null so we'll
596:22 - assign null value to temp so it will look something like this
596:34 - now if you see temp points to null therefore the condition in while loop comes out to be false
596:40 - and therefore the while loop breaks out now as we have reached the end of the list therefore
596:46 - we are simply printing the null
596:51 - so friend this was the algorithm to traverse the w-link list in forward direction
596:56 - now let's see how we'll traverse this w-link list in backward direction
597:02 - so below is the algorithm to traverse the w-link list in backward direction
597:08 - now we'll create a temporary node but this time it will point to the tail because we need to
597:13 - print the elements in backward direction so now time points to the last node which is tail
597:23 - we will traverse this temporary node till it becomes null
597:29 - now here we'll print the data associated with this temporary node which is 25
597:37 - so in order to traverse the w-link list backward we will assign
597:41 - the value of temp previous nodes to temp so it would look something like this
597:49 - moving ahead
597:54 - now as temp points to third node therefore it's not null
597:58 - so the condition in while loop comes out to be true
598:03 - we'll simply print the data associated with this temporary node
598:11 - and then we'll assign temp dot previous value to temp so we'll move one node backwards
598:25 - now as temp points to the second node therefore it's not null
598:28 - so the condition in while loop comes out to be true
598:33 - we'll print the data associated with this temporary node which is 10
598:41 - and we'll assign temp dot previous value to temp so we are traversing temp one step backwards
598:56 - so here temp points to first node which is not null
598:59 - therefore condition in while loop comes out to be true
599:04 - we'll print the data associated with this temporary node which is 1
599:11 - and then we'll simply assign temp previous value to temp so it will look something like this
599:25 - so currently temp points to null therefore this condition in while loop comes out to be false
599:30 - and while loop breaks out
599:34 - so in the last step we'll print null because temp is currently pointing to null
599:38 - so friends this was the algorithm to traverse the wlinklist backwards
599:44 - so let's move to eclipse and see the working code
599:52 - so friends in my previous tutorial i had created one class by name wlinklist
599:57 - and in this wlinklist i had created few instance variable
600:02 - one was pointing to the head of the linklist and another was pointing to the tail of the wlinklist
600:09 - i also created an integer variable which stored the length of the wlinklist
600:15 - and i also created one inner class which was actually list node class
600:20 - which had data a pointer to next node and a pointer to previous node
600:28 - so friends let's write a method which could print the wlinklist in forward direction
600:32 - so public public void display forward
600:46 - so here i have created method name is display forward so it will display the
600:51 - wlinklist in forward direction so first we'll say if
600:55 - head is null then return
601:05 - so here if suppose the head is null so wlinklist is empty therefore we'll simply return
601:12 - moving ahead first we'll create a temporary node by name temp and we'll assign the value of head to it
601:21 - then we'll create a while loop
601:27 - and we'll traverse the temporary node in a loop till it becomes null
601:33 - so inside this while loop we'll print temp.data
601:54 - and we'll simply traverse temp to its next node by assigning temp.next value to temp
602:04 - and at last we'll simply print null
602:12 - so friend this is the algorithm to traverse the wlinklist in forward direction
602:19 - so now we'll write a method to traverse the wlinklist in backward direction
602:23 - so let's create a method public
602:33 - so we'll give a condition as if
602:41 - if tail is null then simply return so here tail is null then we'll simply return from this method
602:54 - moving ahead we'll create a list node temp
602:58 - which will point to tail then we'll create a while loop
603:07 - and we'll traverse this temp node till it becomes null
603:13 - so i'll just copy this complete part
603:22 - and here instead of traversing to the next node we'll just traverse to previous node
603:29 - so friend this is the code to display the wlinklist in backward direction
603:34 - so now let's see it's working
603:39 - so here in the main method i have created one method which inserts the node into wlinklist
603:47 - so this is the method where insert the node into wlinklist
603:51 - so this algorithm i will be covering in my next tutorial
603:54 - so for now just think that this method insert the node into wlinklist
604:01 - so currently i have inserted four nodes 1, 10, 15, 25
604:06 - so let's first print this wlinklist in forward direction so i'll do dll.display forward
604:16 - and if i run the code
604:17 - so you can see it prints 1, 10, 15, 25 and null so this is what it displays in forward direction
604:31 - now let's display the wlinklist in backward direction so we will call display backward
604:37 - and we'll run the code
604:38 - so here you see it simply prints the wlinklist in backward direction as 25, 15, 10, 1 and then null
604:52 - so friends in this tutorial we simply discussed how to traverse the wlinklist in forward and
604:57 - backward direction and print the data in the nodes on the console
605:03 - so friends i hope you like this video please like comment share and subscribe my youtube channel
605:08 - thanks have a nice day hello friends welcome to my new data structures and algorithm in
605:13 - java tutorial series video friends in this tutorial we will discuss how to insert node
605:19 - at the beginning of a wlinklist in java so friends let's suppose we are given a wlinklist
605:27 - having four nodes say 1, 10, 15 and 65 so here you see head points to the first node and tail
605:35 - points to the last node and if we want to insert a node at the beginning of wlinklist we usually
605:41 - manipulate the head pointer and in that case tail pointer doesn't play any much role the only case
605:49 - where tail points comes into picture when the list is empty so when the list is empty usually head
605:56 - and tail both points to null and when we want to insert a node at the beginning of wlinklist
606:02 - therefore after this insertion the wlinklist has only one node so therefore head and tail both
606:09 - points to that node so we need to consider that case so in the algorithm if you see if the list
606:15 - is empty then the tail pointer comes into picture so we'll see the demonstration of this algorithm
606:22 - in next slide so friends below is the algorithm to insert a node into a wlinklist at the beginning
606:29 - so let's see the demo of this algorithm so currently if you see there in wlinklist
606:38 - we have this head node and tail node so the head points to the first node and the tail points to
606:42 - the last node so currently the list is empty therefore head and tail points to null and let's
606:49 - say we want to insert a node having a value 1 so first we'll create a new node and we'll assign
606:57 - the value to it the new node variable will point to a node which has data as 1 and whose next and
607:05 - previous points to null moving ahead we'll check whether wlinklist is empty or not so currently
607:15 - as head and tail points to null so list is empty therefore the condition and if statement comes
607:21 - out to be true and in order to insert this new node at the beginning of a wlinklist will first
607:31 - assign the value of new node to tail so currently tail points to null so after this statement it
607:38 - will point to the node to which the new node points so here if you see new node next points to
607:52 - null therefore we'll assign the value of head to new nodes next pointer so here head points to null
608:01 - therefore new node next will also point to null
608:06 - moving ahead and then we'll simply assign new nodes value to head so as head points to null
608:14 - we'll simply now make it point to the new node so here as list was empty so after insertion of
608:23 - this new node both tail and head will point to it because this is the only node in the wlinklist
608:30 - now let's say we want to insert a node having a value 10 into a wlinklist having the first node as 1
608:44 - so here first we'll create a new list node having the value as 10
608:50 - so this would look something like this that new node points to a list node having the data as 10
608:55 - now we'll check whether wlinklist is empty or not so currently it's not empty because head
609:04 - and tail is pointing to the list node having data as 1 therefore the condition in if block
609:10 - comes out to be false and the else part will be executed so as we want to insert this new node
609:20 - at the beginning of this wlinklist so in order to insert this new node into the beginning of wlinklist
609:29 - we will assign the value of new node to heads previous so if you see the head points to the
609:35 - node having value as 1 and it previous points to null therefore we'll simply break this pointer
609:41 - and we'll assign this previous pointer to the new node so it would look something like this
609:51 - so in the first step we assigned head previous to the new node
609:58 - and in order to make it a two-way linked list or a wlinklist we need to assign new nodes next
610:05 - to the head so here we assign the value of head to new nodes next
610:11 - because in wlinklist the nodes refer to each other so the node which comes first refer to
610:18 - other through the next pointer and the node which comes after refer to first one through the
610:23 - previous pointer so here in the else part we saw that head dot previous referred to new node
610:30 - and here we saw that new nodes next refer to now the head so moving ahead so in the last step we'll
610:38 - simply assign the value of new node to head so here currently head points to a list node having
610:43 - data as 1 but as we have inserted is new node into the beginning therefore now head should
610:49 - point to this new node
610:55 - so friend this was the algorithm to insert a node into the beginning of wlinklist
611:01 - so friends let's move to Eclipse and see the working code
611:07 - so friends in my previous tutorial I created one class by name wlinklist
611:12 - head of type list node which points to the first node of a wlinklist and tail which points to the
611:19 - last node of a wlinklist and a length which which return us back the actual size of the wlinklist
611:26 - then we also created one inner class by name list node which had the data a pointer to next
611:32 - node and a pointer to the previous node and in my last tutorial I discussed how to print
611:39 - the elements of this wlinklist and forward and backward direction
611:45 - so in this tutorial we will write the code to insert a node at the beginning of a wlinklist
611:51 - so public void insert first
612:00 - so this method takes in a integer value so this integer value will be a part of the new
612:06 - node which we want to insert into wlinklist so first we'll create a list node by name new node
612:19 - and we'll simply assign the value to it
612:23 - moving ahead we'll create a fblock and here we'll provide a condition as
612:31 - is empty so here we are checking whether the wlinklist is empty or not
612:41 - so currently when we initialize the wlinklist head and tail points to null and the length is zero
612:47 - so is empty method returns us a boolean value and checks whether the wlinklist is empty or not
612:53 - so if the wlinklist is empty then first step will do is we assign new node value to tail
613:06 - and in the else part and if suppose the list is not empty
613:10 - then we'll assign the new nodes value to heads previous so head previous
613:18 - and then we'll simply point the new nodes next pointer to head
613:32 - and as the node is inserted now head will point to the new node
613:40 - so we'll simply assign the value of new node to head
613:42 - after we insert the node into the beginning of this wlinklist we'll simply increment
613:49 - the length by one now in main method let's run this code so first i've created
613:57 - and stands out wlinklist so initially head and tail points to null and length is zero so if i
614:05 - call insert first and i pass value as one and then i simply say display it forward
614:18 - and display it backward and so if i run the code
614:27 - node is inserted with the value of one and we have printed it both forward and backward so
614:33 - it prints out the same because head and tail points to the first node
614:38 - and if suppose i insert one more node as insert first and provide a value as 10
614:48 - and now i run the code
614:51 - so you see initially there was one node having data as one so when we inserted the new node at
614:58 - the beginning of a wlinklist so now it printed out 10 and 1 in the forward direction
615:05 - so you see the currently head is pointing to 10 and tail is pointing to 1
615:13 - so friends in this tutorial we saw how to insert a node into a beginning of a wlinklist
615:19 - i hope you like this video please like comment share and subscribe my youtube channel
615:23 - thanks have a nice day
615:28 - hello friends welcome to my new data structures and algorithm in java tutorial series video
615:33 - friends in this tutorial we will discuss how to insert node at the end of a wlinklist in java
615:42 - so friends suppose we are given a wlinklist having four nodes say 1 10 15 and 65
615:48 - so usually in wlinklist head points to the first node and tail points to the last node
615:54 - so if you want to insert a node at the end of wlinklist usually we do the manipulation with
615:59 - the tail pointer and in that case head pointer doesn't play any much role the only case in which
616:07 - head pointer comes into picture is when the list is empty so the list is empty then head and tail
616:14 - both points to null and after we insert a node at the end of wlinklist so the list contains
616:21 - only one node therefore the head and tail both needs to point to that particular node
616:27 - so here in this algorithm we need to cover that case when the list is empty
616:31 - so when the list is empty then head pointer comes into picture
616:36 - so we'll see the demonstration of this algorithm in next slide
616:38 - so friends below is the algorithm to insert a node at the end of a wlinklist
616:46 - so let's see a demo of this algorithm step by step
616:51 - so let's say currently the wlinklist is empty therefore head and tail both will be pointing to
616:57 - null and let's say we want to insert a list node and to this wlinklist having a value of 1
617:04 - so in step 1 we'll first create a list node and we'll provide value to it
617:13 - so here if you see the new node will point to this list node having data as 1
617:19 - and the pointers to next and previous node will point to null moving ahead
617:27 - then we'll provide a statement and in this if we'll check whether the list is empty or not
617:33 - so currently the list is empty because head and tail both are pointing to null
617:38 - therefore the condition in if block comes out to be true and this statement will be executed
617:47 - so as we want to insert this new node at the end of a wlinklist
617:52 - and currently this wlinklist is empty therefore when we'll insert this new node
617:57 - so this would be the only node in the wlinklist and we know that head points to the first node
618:02 - so therefore we'll assign new nodes value to head
618:08 - so you will see that now head points to new node moving ahead
618:18 - so as this wlinklist currently has one node and we also know that head points to the first node
618:24 - and tail points to the last node but this wlinklist has only one node therefore head and tail will
618:31 - point to this node so the last statement would be we need to assign new nodes value to tail
618:37 - so currently tail is pointing to null and after this statement tail will point to this new node
618:46 - so friends after the insert of this list node at the end of the wlinklist
618:51 - we see head and tail both point to this node because this is the only node in the wlinklist
618:56 - now let's say we want to insert one more node having the value as 10 so this algorithm will
619:03 - be executed again so in order to do that we need to first create a list node having the value as 10
619:11 - so it would look something like this the new node points to a list node having the data as 10
619:16 - and the next and previous pointers pointing to null moving ahead
619:22 - and in this if block will check whether this wlinklist is empty or not so if you see head and tail
619:28 - points to this node having the data as 1 so list is not empty therefore the condition in the if block
619:34 - comes out to be false and the else part will be executed so in order to insert this new node at
619:44 - the end of the wlinklist we know that wlinklist has currently one node and if we want to insert
619:51 - this new node it would come just after this first node therefore in order to insert this new node
619:56 - into wlinklist first we need to point tail next pointer to this new node and then we need two
620:03 - points new nodes previous to tail node because the adjacent nodes in wlinklist refer each other
620:10 - so therefore in the first step what we do we assign new nodes value to tail next
620:15 - so currently new node points to the node which we want to insert and tail node next points to null
620:23 - therefore when we assign new node value to tail next it would look something like this
620:33 - so now tail node next will point to this new node moving ahead
620:36 - and after this step we need to point new nodes previous to the tail node
620:46 - so in this step we'll assign the value of tail to new nodes previous so it would look something like
620:51 - this so currently the adjacent nodes in wlinklist are referring to each other such that the first
620:59 - node is pointing to the node which we wanted to insert and the node which we wanted to insert
621:04 - is referring it back so moving ahead so the final step is we need to assign new nodes value to tail
621:12 - so if you see in a wlinklist the head points to the first node and the tail points to the last
621:17 - node so initially there was only one node therefore head and tail pointed to the same node
621:22 - but after the insertion of this new node tail should point to this new node
621:27 - so in order to do that we need to assign new nodes value to tail and it would look something like this
621:34 - so friends this was a demonstration of inserting a list node at the end of wlinklist
621:41 - now let's go to eclipse and see the working code
621:47 - so friends in my previous tutorial i had created this wlinklist class
621:51 - and in the last tutorial we saw how to insert the node at the beginning of a wlinklist
621:57 - so in this tutorial we will code how to insert a node at the end of a wlinklist
622:02 - so for this first i will create a method public void insert last
622:12 - and this method will take an integer value now in the first i will create this new node
622:22 - based on the value we are passing to the method
622:32 - and the first step will be we'll provide a if check that whether the list is empty or not
622:43 - and if the list is empty we need to assign new node value to the head
622:54 - so friends if the list is not empty then we need to insert this new node
622:58 - at the end of wlinklist so we know that the tail points to the last node in the wlinklist
623:05 - so in order to insert this node we need to use tail dot next pointer
623:12 - and to tail dot next we'll assign value of new node therefore a tail node next will point to
623:19 - now new node and similarly to new node previous we will assign the value of tail
623:31 - so in the else part we are doing this because this new node and the tail will refer each other
623:37 - and once they refer each other the new node is a part of wlinklist
623:42 - and finally in the last step we'll reassign tail to point this new node so it would be tail
623:50 - we'll now point to new node and at the last we'll increment the length of wlinklist by 1
623:59 - so friend this is the code for inserting a list node at the end of wlinklist
624:04 - so let's test this method in the main method so here i have created one instance of wlinklist
624:09 - class now let's say i insert say 1 and then i print the wlinklist say in the forward direction
624:21 - and if i run the program
624:27 - so you will see as the initially the wlinklist was empty therefore when we inserted a new node
624:32 - it by default became the first node and got inserted at the very beginning of wlinklist
624:38 - now let's say if i insert
624:44 - value 10 now when i run this program so when we'll print this wlinklist so this
624:51 - time should insert after the node having data as 1
624:57 - so you see the 10 got inserted at the last position so initially there was node having data
625:02 - as 1 but when we inserted 10 it got inserted at the end of wlinklist
625:09 - so friends if suppose i insert one more node
625:15 - say having value as 15 and if i now run the program
625:23 - so you see the 15 got inserted at the end of wlinklist so initially there was
625:29 - node having data as 1 then we inserted 10 and then we inserted 15
625:36 - so friends this was a tutorial to demonstrate how to insert a list node at the end of wlinklist
625:43 - i hope you like this video please like comment share and subscribe my youtube channel
625:47 - thanks have a nice day
625:52 - hello friends welcome to my new data structures and algorithm in java tutorial series video
625:58 - friends in this tutorial we will discuss how to delete first node in a wlinklist in java
626:08 - so friends let's suppose we are given a wlinklist having three nodes say 1 10 15
626:17 - and if you see below is the algorithm to delete the first node in a wlinklist
626:22 - so friends as you know that in wlinklist head points to first node
626:27 - and tail points to the last node so in order to delete the first node in a wlinklist
626:32 - we usually manipulate the head pointer because and if you see as tail points to the last node
626:38 - in a wlinklist therefore tail node doesn't play any much role in deletion of the first node
626:44 - but there is a case where tail nodes comes into picture when there is only a single node
626:50 - so if a wlinklist contains only one node then head and tail node both points to that particular
626:55 - node therefore the tail node comes into picture because we need to delete that particular single
627:00 - node so the only place where tail node comes into picture when head is equal to tail that is the
627:07 - wlinklist has only one node and both head and tail points to it so we'll see the demonstration of
627:13 - this algorithm step by step so suppose we need to delete the first node so in the algorithm first
627:21 - step would be we need to check whether the list is empty or not so if the list is empty it means
627:26 - there is no node to delete therefore we may throw no such element exception so if we take our
627:33 - example then this wlinklist has three nodes therefore the wlinklist is not empty so the
627:39 - condition in its statement comes out to be false so the first step would be we need to create a
627:46 - temporary node which will point to head as we want to delete the first node then we will
627:51 - create a temporary node which will point to the head moving ahead now we'll check whether head is
628:01 - equal to tail or not so currently head points to the first node and the tail points to the third
628:06 - node therefore they are not equal so the condition comes out to be false and the if part will be
628:12 - executed so friends we need to remove this first node now so in order to delete this first node
628:21 - from the wlinklist we need to do two things first we need to break this next pointer which is
628:27 - pointed by the temporary node so if you see temp next points to the second node so we need to remove
628:33 - this and if you see second node points back to temporary node and we need to break this link
628:39 - so these two links we need to break so in the else part we'll first break the link which is
628:45 - pointed by the second node to the temporary node so in order to break this link we noted head points
628:52 - to this first node which we want to remove and its next points to the second node so here what
628:57 - we'll do we'll say head dot next so when we do head dot next we reach to the second node
629:03 - and if we do dot previous then this is the link so currently this previous points to the
629:09 - first node and when we assign null so this link breaks up so so it would be something like this
629:18 - so what we are doing in this line is we are traversing from head to its next and then to
629:23 - its previous so from head we traverse to its next node and then we traverse back to previous
629:28 - so we broke this link here and we assigned a null value to it so we removed one link
629:35 - moving ahead so friends now we know the temporary node points to head which is the first node which
629:40 - we want to delete therefore when the first node is removed head will be pointing to the second
629:45 - node because after its removal second node will become our new head therefore we need to traverse
629:52 - this head to its next node so to head will assign the value of head dot next so currently
629:58 - head points to the node which we want to delete and head next points the second node and once
630:04 - this node is removed we know that now head will point to the second node because second node
630:08 - becomes the head of the doubly linked list so in order to do that we need to traverse head to its
630:14 - next position by assigning head dot next value to head so it would look something like this
630:23 - moving ahead and we know that temporary node refers to second node so we need to break this
630:30 - link as well so to break this link we'll simply do temp dot next equals null so temp dot next point
630:38 - to second node and we'll assign a null value to it so it would look something like this
630:44 - so now you see temporary node is an individual node where previous points to null and
630:49 - next points to null so in the last step we'll simply return the temp because this is the first
630:57 - node which we deleted so friends now doubly linked list contains two nodes where head points to the
631:06 - first node and tail points to the second node now suppose if we again call this algorithm to delete
631:11 - the first node then it would be something like first we will check whether list is empty so list
631:17 - is not empty so friends will create one temporary variable which will point to head and as we know
631:24 - that head points to the first node of a doubly linked list therefore in order to delete this
631:30 - first node we'll point the temporary node to the head moving ahead we'll check whether head is
631:36 - equal to tail or not so head is not equal to tail because head points to first node tail points to
631:42 - the second node so the else part will be executed now here we'll do the same thing
631:50 - we'll first take this previous link which is pointed by the second node to the first node
631:56 - so in order to reach this node we'll use head dot next and to assign null value to
632:02 - previous we'll use head dot next dot previous so when we'll do head dot next we reach here
632:08 - and we'll we'll do dot previous this is the link and we'll assign a null value to it so it would
632:15 - look something like this now we have removed one link moving ahead and now we'll simply traverse
632:24 - head to its next node because now once this node is removed we know that head should point to the
632:29 - next node in the doubly linked list because because now that node will become our new head
632:35 - so we'll simply traverse head to its next position by assigning head dot next value to head
632:44 - moving ahead
632:47 - and we'll simply assign a null value to temp dot next because we need to remove this link as well
632:53 - so so not temp dot next points to null
632:56 - and in the last step we'll simply return the deleted node
633:08 - so friends now you see doubly linked list has only one node where head and tail both points
633:14 - to that particular node so when we will call this below algorithm again to delete the first node
633:21 - then first it will be checked that whether the list is empty or not so currently list has one
633:25 - node therefore it's not empty then we'll create a temporary node which will be pointing to head
633:34 - because head points to the first node in the doubly linked list moving ahead
633:42 - we will check whether head is equal to tail or not so currently if you see head and tail both
633:46 - points to that particular node therefore they are equal so the condition in if statement comes out
633:52 - to be true therefore if block will be executed so friend this is the only node left in the doubly
634:00 - linked list and we want to remove that therefore we need to remove this both pointers head and tail
634:05 - because they are referring to this node so in the first step we'll assign a null value to tail
634:12 - so it would look something like this so now tail would be pointing to null
634:16 - and then we'll simply assign head dot next value to head so it simply means we are assigning null
634:26 - value to head so now head will be pointing to null and we'll simply assign null value to
634:36 - temp dot next but if you see temp dot next is pointing to null value only therefore we just
634:42 - simply return the temporary node in the last step so friends you saw there was only one node
634:51 - remaining and we removed that node as well now if you see tail and head both points to null
634:57 - so if we call this algorithm again so it will be checked whether list is empty or not so if you
635:03 - see head and tail both points to null therefore the doubly linked list is empty therefore if we
635:08 - call this algorithm then an exception will be thrown so we can throw an exception saying that
635:14 - there is no such element left so friends this was the demonstration of the algorithm
635:20 - now let's go to eclipse and see the working code
635:25 - so friends in my previous tutorial i created one class by named doubly linked list and we
635:31 - implemented the doubly linked list into that class so this class has basically a head node
635:36 - and a tail node and an integer variable by name length which stores the size of the doubly linked
635:43 - list you can watch my previous tutorials to understand those concepts so in this tutorial
635:50 - we'll just code a method which will delete the first node in a doubly linked list so i'll create
635:58 - a method as public list node delete first now this method will return us back the deleted node
636:14 - so the return type is list node so first we'll provide a if check
636:18 - and in if block we'll provide a condition as whether doubly linked list is empty or not
636:29 - so if doubly linked list is empty we'll throw an exception
636:32 - moving ahead then we'll create a list node by name temp and we'll assign a value of head to it
636:54 - as head points to the first node of a doubly linked list therefore we'll assign value of head to this
636:59 - temporary node and then we'll check if head is equal to tail or not so when head is equal to tail
637:13 - it means doubly linked list has only one node so in that case we'll assign
637:21 - null to tail because we need to break the reference of tail pointing to that particular
637:26 - node which we want to delete and if head is not equal to tail then in else block we'll write
637:36 - head.next.previous and we'll assign a null value to it
637:44 - we are assigning a null value to head.next.previous because we need to
637:49 - break the previous link which is coming from the second node
637:52 - and then we'll simply assign head.next value to head
638:02 - now we also need to break the next link which temporary node is pointing to the second node
638:07 - therefore we'll do temp.next and assign a null value to it and finally this temporary node is
638:15 - removed therefore we know that size of length is reduced by one therefore we'll do length
638:24 - so here we are decrementing the length by one because we have removed one node and in the last
638:30 - I will simply return the temporary node because this temporary node is pointing to the first node
638:37 - of doubly linked list so friend this is the algorithm to remove the first node in a doubly linked list
638:45 - now let's test it's working so friend in my previous tutorial we saw how to insert
638:50 - the nodes in doubly linked list so here I have added three nodes by data as 1 10 and 15
638:56 - and if I print the doubly linked list in the forward direction
639:02 - so you can see one points to 10 10 points to 15 and 15 points null so totally there are three
639:08 - nodes now let's delete the first node in the doubly linked list so we'll call delete first
639:20 - and let's display the doubly linked list again so I'll call it display forward
639:26 - and if I run the code so you see initially doubly linked list had nodes as 1 10 and 15
639:35 - and the node having data as 1 was the first node so when we call delete first
639:40 - the node at first base got removed and the doubly linked list became 10 15
639:47 - now let's say I again call delete first
639:53 - and if I run the program
639:58 - so you see when delete first was called first time one was removed and when we called delete
640:03 - first again so 10 was removed because 10 became our new head and finally if I
640:12 - call delete first again and I run the program so you see all the nodes are removed and nothing
640:20 - got printed because because in display forward we have kept a condition if head is null then
640:29 - simply return so when all the three nodes got removed head pointed to null and nothing was
640:34 - printed but if I call delete first again as head and tail both are pointing to null and if I call
640:42 - delete first again so you can see we are getting an exception as no such element exception because
640:51 - list is empty and there is no element left to be removed so friends this was the tutorial to
640:59 - remove the first node in a doubly linked list I hope you like this video please like comment
641:04 - share and subscribe my youtube channel thanks have a nice day
641:10 - hello friends welcome to my new data structures and algorithm in java tutorial series video
641:15 - friends in this tutorial we will discuss how to delete last node in a doubly linked list in java
641:24 - so friends let's suppose we are given a doubly linked list having three nodes with data as 1
641:30 - 10 and 15 so here you see below is the algorithm to delete the last node in a doubly linked list
641:38 - so friends the basic idea behind this algorithm is as we want to delete the last node in a doubly
641:44 - linked list we will use basically this tail pointer to remove the last node in a doubly
641:49 - linked list because in a doubly linked list head points to first node and a tail points to the last
641:55 - node and we want to remove the last node in a doubly linked list therefore we'll manipulate
642:00 - and play with this tail pointer to remove the last node from the doubly linked list
642:07 - so head pointer doesn't play much role in deleting the last node from a doubly linked list
642:14 - The only case where head pointer comes into picture is when there is only one node in
642:19 - a doubly linked list because if there is only one node in a doubly linked list then head
642:24 - and tail both will point to that particular node and if you want to remove that single
642:29 - node from a doubly linked list we need to manipulate head pointer as well.
642:35 - So friends let's see the demonstration of this algorithm.
642:40 - So the first step we will check whether the list doubly linked list is empty or not.
642:43 - So doubly linked list is empty which will throw an exception saying that there are no
642:47 - more elements left to be removed.
642:50 - So currently doubly linked list has three nodes therefore the list is not empty.
642:54 - So the condition in a block comes out to be false.
642:59 - Now as you want to remove the last node from a doubly linked list we will create one temporary
643:04 - node which will be pointing to the tail.
643:08 - So now temp points to a tail because when we remove the last node from a doubly linked
643:12 - list it will be removed using this temporary node.
643:16 - Moving ahead so here in the block we will check whether head is equal to tail or not.
643:23 - So currently head points to the first node and tail points to the third node therefore
643:26 - they are not equal.
643:28 - So the condition comes out to be false and the else part will be executed.
643:38 - Now friends in order to remove this last node from a doubly linked list we need to
643:43 - remove this two pointers because once we remove this two pointer this node will be freed and
643:47 - it will be removed from the doubly linked list.
643:51 - So first we will remove this next pointer because this last node is being referred by
643:55 - the second last node.
643:57 - So we need to remove this link.
644:00 - So in order to remove this link we need to traverse to the second last node and then
644:05 - assign a null value to its next node.
644:08 - So in order to traverse to the second last node we will use this tail pointer will first
644:15 - go to its previous by calling tail.previous and then to its next we will assign a value
644:22 - of null.
644:25 - So in this line what we are doing we are assigning a null value to tail.previous.next.
644:31 - So it simply means we are first traversing to the previous and to the next we are assigning
644:36 - the value as null.
644:38 - So it would look something like this.
644:41 - So this link will be removed and then it will point to the null value.
644:48 - Moving ahead so friends once we remove this last node of a doubly linked list we see tail
644:55 - points to red node.
644:57 - So after its removal tail should point to the second last node because that second last
645:02 - node upon removal becomes the last node of the doubly linked list.
645:08 - Therefore we need to traverse tail to its second last node.
645:13 - So we will simply assign tail.previous value to tail.
645:17 - So it would look something like this.
645:23 - Moving ahead and then we will simply break this link and we will assign a null value
645:29 - to it.
645:30 - So we know that temporary node is pointing to this last node and we need to assign a
645:34 - null to its previous therefore we will simply assign a null value to tail.previous.
645:41 - So it would look something like this.
645:49 - So in the final step we know that the last node which is pointed by temporary node has
645:55 - been removed from doubly linked list will simply return this temporary node.
646:03 - So friends after removal of this last node only two nodes are left.
646:07 - So it is pointing to the first node and tail is pointing to the last node.
646:11 - Now if you want to again remove the last node from this doubly linked list we call this algorithm
646:16 - again we check whether list is empty or not.
646:21 - So list is not empty and as we want to remove this last node we will create one temporary
646:28 - node and we will assign the value of tail to it.
646:33 - Moving ahead we will check whether head is equal to tail or not.
646:38 - So head is not equal to tail because head points to first node and tail is pointing
646:42 - to the second node.
646:44 - Therefore the else part will be executed and in the else part we will do the same as we
646:51 - need to remove this link.
646:53 - So we will traverse a node back and we will assign a null value to its next.
646:59 - So we will simply do tail.previous.next and assign a null value to it.
647:05 - So tail points to the second node and when we do tail.previous we are reaching to the
647:11 - first node and then to its next we are assigning the null value.
647:15 - So it would look something like this.
647:19 - So the link which was referring to this node we have removed it.
647:24 - Moving ahead and as we know that this is the last node of the doubly linked list because
647:30 - once the last node is removed the tail should point to its previous node because dead becomes
647:35 - the last node in the doubly linked list.
647:37 - Therefore we will simply assign tail.previous to tail.
647:40 - So it would look something like this.
647:47 - So now head and tail both are pointing to the first node.
647:50 - Moving ahead and we need to break this link and that link is referred by Tams.previous.
647:59 - So we will simply assign null value to Tams.previous.
648:03 - So it would look something like this.
648:10 - So as we know that this node is freed therefore we will simply return this temporary node.
648:19 - So friends now in doubly linked list only one node is left where head and tail both
648:23 - are pointing to that particular node.
648:26 - So let's call this algorithm again.
648:28 - So first we will check whether list is empty or not.
648:31 - So list has one node therefore it's not empty.
648:35 - Then as we know that there is only one node left and we want to delete the last node therefore
648:41 - this is the only node that needs to be removed.
648:45 - So we will simply create one temporary node and we will assign the value of tail to it.
648:50 - Moving ahead now here is the case where head is equal to tail because both are pointing
648:56 - to this first node.
648:58 - Therefore in order to remove this node we need to break this both links because head
649:03 - is pointing to this node and tail is also pointing to this node and we need to break
649:07 - this both link so that this node can become free to be removed.
649:15 - So in the if part we will simply assign a null value to head.
649:22 - So we have removed one link moving ahead and then we will simply traverse tail to
649:29 - its previous node by assigning tail dot previous to tail.
649:33 - So you see tail previous is pointing to null therefore we are simply assigning a null
649:37 - value to tail.
649:39 - So it would look something like this.
649:42 - So now tail will point to null and now we will simply assign a null value to temp previous.
649:50 - So you see temp previous is already pointing to null therefore we do nothing.
649:59 - And simply in the last I will return this temporary node.
650:06 - So you see now head and tail both are pointing to null and there are no nodes left in the
650:11 - list therefore the list is empty.
650:14 - So if you call this algorithm again then first I will check whether list is empty or not.
650:18 - Now we know that list is empty and there are no nodes left to be removed therefore
650:23 - we can throw and no such element exception because there are no nodes left to be removed.
650:34 - So friends this was the demonstration of the algorithm.
650:36 - Now let's go to Eclipse and see the working code.
650:42 - So friends in my previous tutorial I had created one class by name wlinklist and we implemented
650:48 - a wlinklist into that class.
650:51 - So this class has head and tail node and it also has an integer variable by name length
650:58 - which stores the size of the wlinklist.
651:01 - So if you want to understand the working of wlinklist you can watch my previous tutorials.
651:07 - So in this tutorial we will discuss how to delete the last node of a wlinklist.
651:13 - So first I will create the method as public list node delete last.
651:26 - So this method will remove the last element and will simply return it back therefore the
651:30 - return type is of list node.
651:34 - So first we will provide a if check as if a wlinklist is empty or not.
651:44 - So if it is empty then we will simply throw a exception say no such element no such element
651:55 - exception.
651:59 - Moving ahead will create a list node by name temp and will assign a value of tail to it
652:09 - because we need to remove the last node for the wlinklist therefore we are using this
652:14 - tail pointer to remove that last node.
652:18 - And we will provide an if check if head is equals tail then we will simply assign null
652:31 - value to head because when head is equal to tail there is only one node left in the wlinklist
652:39 - so we need to break both the reference head and tail in order to free that node.
652:44 - So we will simply assign a null value to head and in the else part we will do tail.previous.next
652:58 - and assign null value to it moving ahead then we will simply traverse tail to its previous
653:05 - node because once the last node is removed now tail will point to the node just before
653:12 - it and we will assign null to temp.previous because we need to break that link as well.
653:26 - And finally as we delete this node we need to reduce the length of wlinklist by 1 therefore
653:33 - we decrement the length by 1 and last we will simply return the temp.
653:40 - So friends we saw the algorithm to remove the last node of a wlinklist now lets test
653:46 - its working in main method.
653:54 - So in my previous tutorial we just discussed how to remove the first node of a wlinklist
653:59 - so here I will just call delete last so here if you see we have inserted 3 nodes by data
654:06 - as 1, 10 and 15 and first we are removing the last node so if I run the code you see
654:17 - first it printed 1, 10, 15 and null so when we call delete last so it printed 1, 10 and
654:25 - 15 got removed and if I call this method again and then I run the program.
654:36 - So you see we called delete last 2 times so in the first time 15 got removed and the
654:40 - second time 10 got removed and if I call it again so if I called it again so 1 was also
654:54 - removed and nothing got printed because in display forward we have kept in condition
655:04 - that if head is null then simply return and we know that we inserted 3 nodes and we removed
655:11 - 3 nodes so list got empty and head pointed to null therefore display forward printed
655:16 - nothing and if I call delete last 1 more time then as we know that list is empty and there
655:25 - are no nodes left to be removed therefore you see an exception was thrown because there
655:33 - was no node left to be removed so friends in this tutorial we will discuss how to remove
655:40 - the last node of a doubly linked list I hope you like this video please like comment share
655:45 - and subscribe my youtube channel thanks have a nice day hello friends welcome to my new
655:54 - data structures and algorithm in java tutorial series video friends in this tutorial we will
655:59 - discuss how to represent a circular singly linked list in java so friends what is a circular
656:08 - singly linked list so if you see this is how we represent singly linked list and this is how we
656:16 - represent a circular singly linked list so the structure wise circular singly linked list is very
656:23 - much similar to singly linked list and here you can see in singly linked list we have these nodes
656:29 - which form a chain and we keep a head node which points to the first node and the last nodes next
656:36 - point to the null so the only difference between singly linked list and circular singly linked
656:42 - list is that in circular singly linked list the last node points to the first node and not null
656:47 - so here if you see in singly linked list the last node next is pointing to null but in circular
656:53 - singly linked list the last nodes next is pointing to the first node again and not null so therefore
657:02 - this property makes circular singly linked list circular in nature where if you see 1 points to 8
657:09 - 8 points to 10 10 points to 16 16 again points to 1 so therefore it's a circular in nature and one
657:17 - more difference is like in singly linked list we keep the track of the head node which is pointing
657:22 - to the first node but in circular singly linked list we keep the track of the last node so in
657:29 - circular singly linked list we keep the track of the last node because it helps us in insertion
657:34 - and deletion of the nodes in constant time so here if you see as head points to the first node
657:41 - and suppose if we want to insert a node in a singly linked list at the end so we need to traverse
657:48 - each and every node in the singly linked list to reach the last node and then add the particular
657:53 - node but here in circular singly linked list we are keeping the track of the last node and if
658:00 - suppose we want to insert a node at the end so we can directly use this last pointer and add the
658:06 - node at the end and suppose if you want to insert a node at the beginning then we know that a
658:12 - circular singly linked list is circular in nature therefore when we do last dot next we reach to the
658:17 - first node so we can directly add node at the beginning in constant time so friend this is
658:24 - how we represent a circular singly linked list where we keep the track of the last node and
658:28 - last node next points to the first node so friends let's see a demonstration of circular
658:37 - singly linked list below you can see that circular singly linked list has three nodes having data as
658:43 - one eight and ten and the node having data as ten has been referred by the last node and you can
658:49 - see it's a last node in a circular singly linked list where its next is pointing to the first node
658:54 - so let's see a small demo how we can create this circular singly linked list so suppose we
659:02 - initialize a circular singly linked list so we know that the list is empty so therefore the last
659:07 - will point to null so when the list is empty the last node is pointing to null now let's
659:17 - suppose we are inserting this node having the data as one so it's a simple node having data as one
659:25 - and next is pointing to null so if you want to insert this node into the circular singly linked
659:31 - list and as the list is empty we'll simply assign the value of time into last so that last points
659:38 - to this node so it would look something like this so now the last node is pointing to the node
659:47 - having data as one and we also know that circular singly linked list has property that last next
659:54 - points to the first node of a circular singly linked list but here if you see there is only
659:59 - one node so basically this node is the last node of a circular singly linked list and also the first
660:05 - node so last next should point to this node only so it would look something like this so when we
660:15 - insert a node into a empty circular singly linked list last points to that particular node
660:21 - and and its next points to the node itself now let's suppose you want to add one more node having
660:28 - data as eight so here you can see the temp is pointing to this node having data as eight and
660:35 - its next is pointing to null so in order to insert this node into the circular singly linked list
660:42 - having data as one and last is pointing to one so what we do is when we insert this node with a
660:51 - value eight we know that its next should point to the first node so therefore what we do is we
660:58 - simply break this link and we point it to the first node so it would look something like this
661:07 - as temp next is pointing to the first node and here if you see the first node is pointing to
661:14 - the second node therefore we need to break this link and we need to point it to the second node
661:20 - so it would look something like this so now you can see that node one is pointing to node eight
661:28 - and node eight is again pointing to node one so they are circular in nature and one last step we
661:35 - need to do is as we have inserted is node eight and we know that this is the last node therefore
661:41 - we'll simply assign the value of temp to last so it would look something like this so after
661:48 - the insertion of node having data as eight the circular singly linked list looks like this where
661:55 - node having data as eight is pointed by the last node and its next points to the first node
662:01 - therefore its maintain a circular property and let's suppose we want to add one more
662:08 - node having data as ten so here if you see the node next is pointing to this first node
662:15 - so in the first step what we'll do will simply remove this link and we'll point it to the first
662:21 - node so it would look something like this so now temp next is pointing to the first node
662:28 - and here you can see that second node is pointing to the third node so but here second
662:37 - node is pointing to the first node so we need to simply break this link and we need to point it
662:42 - to the third node so it would look something like this and one last step we need to do is when we
662:52 - have inserted is node having data as ten we know this is the last node therefore we simply need to
662:57 - refer the value of temp to the last so it would look something like this so friends here if you
663:07 - see we inserted three nodes and we knew that node one is the first node and node having data as ten
663:14 - is the last node and here the last node is pointing back to this first node so therefore we saw how
663:21 - circular singly linked list is created and and how they maintain a circular property so friends
663:28 - in this tutorial we discuss how we can represent a circular singly linked list in Java in my next
663:34 - tutorial we will see how we can implement circular singly linked list in Java I hope you liked this
663:40 - video please like comment share and subscribe my youtube channel thanks have a nice day hello
663:48 - friends welcome to my new data structures and algorithm in Java tutorial series video friends
663:54 - in this tutorial we will discuss how to implement a circular singly linked list in Java so friends
664:01 - in my previous tutorial we discussed how we can represent a circular singly linked list we discussed
664:07 - that it's very similar to singly linked list with a slight difference that in singly linked list the
664:12 - last node points to null but in circular singly linked list the last node points to the first node
664:18 - which makes this data structures circular in nature we also discussed that we use head node
664:26 - to keep the track of singly linked list but in circular singly linked list we usually keep the
664:31 - track of the last node so friends in my previous tutorial we discussed about the circular singly
664:37 - linked list representation so in this tutorial we will discuss how we can implement a circular
664:43 - singly linked list in Java so let's go to Eclipse and see the working code so friends in order to
664:53 - implement a circular singly linked list I have created one class by name circular singly linked
664:59 - list so in this class we will write the code for circular singly linked list implementation now here
665:08 - we will first create few instance variable so private so here we have created an instance variable
665:20 - of type list node by name last so this list node will help us in keeping the track of the last node
665:27 - of a circular singly linked list we will also create one more instance variable so here we have
665:38 - created an integer variable by name length so this length variable will hold the size of this circular
665:45 - singly linked list and inside this circular singly linked list will create a private class
665:53 - of list node so as this is very similar to singly linked list which we saw in our previous slide so
666:05 - I will just code what's required in list node so here list node contains the data part and a
666:24 - reference to the next list node will create one constructor now this constructor will take the
666:37 - data part moving ahead will create a constructor for this circular singly linked list class
666:52 - so friends when we initialize circular singly linked list we know that last points to null
667:07 - and as the list is empty therefore length would be zero so here we also create one more method
667:18 - public int length so when we call this method it should return us back the size of circular
667:30 - singly linked list so we simply return length will also create one boolean method by name is empty
667:48 - now this method will return us back whether the circular singly linked list is empty or not so
667:55 - we'll simply return that when length is 0 then return true and when length is not 0 then simply
668:06 - return false so let's say in our main method I create the instance of circular singly linked list
668:28 - so friends here we will write one more method which can create the circular singly linked list
668:33 - so we'll simply create one method as public void create circular linked list so here we'll first
668:50 - create few nodes say first let's say I give data as one I'll copy this let's say I give data as five
669:10 - ten fifteen and I will change the name is second third so friends we have created this four nodes
669:28 - now we'll interconnect them so first should point to second so we'll do first dot next and assign
669:39 - a value of second to it and similarly second dot next and assign a value of third to it and
669:50 - similarly third dot next and assign a value of fourth to it now friends here you see first point
670:01 - to second second point to third and third point to fourth but fourth is pointing to null therefore
670:08 - in order to make this linked list circular will simply do fourth dot next and assign first
670:17 - to it so therefore now fourth node will point to first node again so it will make it in circular
670:23 - in nature and in last what we'll do the instance variable which we created last it should point to
670:31 - the last node therefore we'll assign the value of fourth to last so friend this is how we represent
670:40 - a circular singly linked list in Java and if you if you want to call this method we can simply do
670:49 - csl.create so this will create a circular singly linked list of four nodes where first will point
670:57 - to second second will point to third third will point to fourth and fourth will again point to
671:01 - first and we can track those changes using the last list node so friend this is how we implement
671:11 - a circular singly linked list in Java I hope you like this video please like comment share and
671:16 - subscribe my youtube channel thanks have a nice day hello friends welcome to my new data structures
671:24 - and algorithm in Java tutorial series video friends in this tutorial we will discuss how to
671:31 - traverse and print a circular singly linked list in Java so friends in my previous tutorial we
671:40 - discussed how we can represent a circular singly linked list and we also saw how we can implement
671:45 - the circular singly linked list in Java so in this tutorial we will discuss how we can traverse and
671:51 - print the elements of a circular singly linked list in Java so here you see below is the algorithm
671:58 - to traverse the circular singly linked list and print the elements data so here let's see an
672:04 - example when the circular singly linked list is completely empty and last is pointing to null so
672:11 - friends we know that when the circular singly linked list is empty therefore there are no
672:16 - elements and last will point to null so here when the last points to null we know that there
672:22 - are no nodes inside the circular singly linked list to traverse therefore we are keeping one
672:28 - condition as when the last points to null then simply return so here we know that last is pointing
672:35 - to null so we will simply return from it so friends let's see a demonstration of the algorithm
672:44 - with the circular singly linked list having four nodes say 1 8 10 and 16 where 16 is the last node
672:53 - and its next is pointing to this first node now let's see how we can traverse each element inside
673:00 - this circular singly linked list and print the data with their respective node so here first
673:08 - we'll check whether last is null or not so as last is pointing to this fourth node therefore
673:14 - it's not null so the condition in a block comes out to be false so we move ahead now friends as
673:23 - we know that we are keeping the track of this last node which is the fourth node and suppose
673:30 - if we want to traverse each and every node and print the data so we need to start with the first
673:36 - node and then we can print the data accordingly but as here we are only keeping the track of the
673:43 - last node so therefore in order to reach this first node we know that the last node next points
673:49 - to the first node and we need to traverse circular singly linked list from the first to the last
673:55 - node so therefore we'll create this first node and we'll assign the value of last dot next to it
674:00 - so it would look something like this moving ahead so friends we know that circular singly linked
674:10 - list is basically circular in nature where first node points to second second point to third third
674:17 - points to fourth and fourth points to the first again so we need to provide a while loop to
674:23 - traverse each and every node and we need to take a special care while placing the condition in while
674:29 - loop because if we place some wrong condition then we know that as it's circular in nature
674:34 - therefore this while loop may enter into an infinite loop so here as we want to traverse
674:41 - each and every node and print the data into the respective node so we'll traverse till we have
674:47 - reached the last node so the condition in while loop will put as will iterate till first is not
674:53 - equal to last because when first is equal to last we know that we have traversed each and every node
674:59 - so currently first is pointing to this first node and last is pointing to this fourth node
675:04 - therefore first is not equal to last so the condition in while loop comes out to be true
675:10 - so in the first step we'll simply print a data associated with this first node moving ahead
675:22 - so friends as we have traversed this node now we need to just move to its next node so in order
675:32 - to move this first node to its next we'll simply assign the value of first dot next to first so
675:38 - here if you see first is pointing to this first node and its next is pointing to the second node
675:44 - therefore we are simply assigning the value of first dot next to first so it would look something
675:49 - like this so it simply traverses first to its next version by this statement moving ahead
675:58 - now again first is not equal to last therefore condition in while loop comes out to be true
676:07 - so we'll simply print the data associated with the first node moving ahead now as we have
676:20 - traversed the second node so we'll move to the next node so in order to move this first to its
676:25 - next we'll simply assign first dot next value to first so first dot next points to the third node
676:31 - so after this statement it would look something like this moving ahead
676:45 - now again first is not equal to last therefore the condition in while loop comes out to be true
676:52 - so in first step we'll simply print a data associated with this third node and in the
677:04 - second step we'll simply traverse first to its next by assigning first dot next value to first
677:10 - so it would look something like this moving ahead so friends now here you see first and
677:26 - last both are pointing to this fourth node therefore first is equal to last so the condition
677:32 - in while loop comes out to be false so therefore the while loop breaks out so friends here you
677:39 - can see that we had this pointer to this last node and we started traversing and printing of
677:45 - the elements from the first node so here if you see the circular singly linkage has four nodes
677:50 - and we have traversed three nodes by printing one eight and ten and then in the while loop when we
677:59 - traverse to the last node we know that condition in while loop came out to be false as first is
678:04 - equal to last therefore we have reached to this node but we haven't printed a data for this last
678:10 - element so therefore in the last step we'll simply print a data associated with this fourth node so
678:18 - when we print the data associated with fourth node we are sure that we have traversed all the nodes
678:22 - and we have print the data associated with the respective nodes so friends we saw the demonstration
678:29 - of the algorithm now let's move to Eclipse and see the working of the code so friends in my
678:38 - previous tutorial I created one class by name circular singly linked list and we saw the
678:43 - implementation of circular singly linked list in that tutorial we basically created few instance
678:48 - variable by name length and last so this last node was used to keep the track of the last node in
678:54 - circular singly linked list we also saw how we can create a circular singly linked list and we
679:05 - added this four nodes one five ten and fifteen and we made this linked list circular by assigning
679:12 - this fourth node again to the first so friends in this tutorial we will write the code to traverse
679:20 - and print the elements of a circular singly linked list so we'll create a method as public
679:26 - void we give the name as display so this method will simply traverse each and every element in a
679:39 - circular singly linked list and print the data with the respective node so here first we'll
679:45 - provide a condition as if last equals null so it means that if circular singly linked list is empty
679:54 - or not so if circular singly linked list is empty then we'll simply return and do nothing
680:01 - moving ahead we'll create a list node by name first and we'll assign the value of last dot next to it
680:11 - so this thing we are doing because we need to traverse the circular singly linked list from
680:19 - first position to the last position and we know that last dot next points to first so we are simply
680:25 - creating a list node by name first and we are assigning the value of last dot next to it and
680:30 - then we'll create a while loop so inside this while loop we will traverse each and every node
680:40 - of circular singly linked list using this first node so the condition we provide in while loop is
680:46 - we will traverse this first till it becomes last and in the while loop we'll simply first print the
680:56 - data associated with the first node and in the next step we'll simply traverse first to its next
681:08 - node by assigning first dot next value to first so here in this while loop what we are doing is we
681:15 - are printing the data associated with the first node and then we are simply traversing first to
681:21 - its next node by assigning first dot next value to first so when we are reaching to the last node
681:26 - we need to print the data associated with the last node as well so we'll simply print first dot data
681:35 - now in main method let's see the demonstration of this display method so here first we'll create
681:44 - the instance of circular singly linked list and then we'll create the circular singly linked list
681:50 - by calling create circular linked list method so in this method we are simply creating four nodes
681:55 - where first is pointing to second second is pointing to third and third is pointing to fourth
682:03 - and as fourth is the last node therefore fourth will point again back to the first node and in
682:09 - the last step we are simply assigning the value of fourth to last because we are holding this
682:15 - circular singly linked list through this last instance variable now let's say we are calling
682:22 - this display method and if I run the code so friends here you see it prints one five ten
682:32 - fifteen which are actually the four nodes in our circular singly linked list so friends in
682:40 - this totally we discussed how we can traverse a circular singly linked list and print the data
682:45 - associated with respect to nodes I hope you like this video please like comment share and subscribe
682:51 - my youtube channel thanks have a nice day hello friends welcome to my new data structures and
682:59 - algorithm in Java tutorial series video friends in this tutorial we will discuss how to insert
683:06 - note at the beginning of a circular singly linked list in Java so friends in my previous
683:12 - tutorial we discussed about circular singly linked list so here if you see below is the algorithm to
683:18 - insert a node at the beginning of a circular singly linked list so here if you see when the
683:25 - circular singly linked list is empty the last node points to null because there are no nodes
683:30 - inside the circular singly linked list and you see the length is zero so friends let's see the
683:37 - demonstration of this algorithm let's suppose we want to insert a node at the beginning of a circular
683:42 - singly linked list so in the first step what we are doing is we are creating a list node by
683:49 - name temp and we are passing in the data which we actually want to insert so it looks something
683:55 - like this so your temp variable is pointing to this list node having data as one and whose
684:03 - next is pointing to null moving ahead now in the second statement we usually check whether
684:12 - this circular singly linked list is empty or not so we provide a condition that whether last is equal
684:18 - to null or not so here if you see last is pointing to null therefore the circular singly linked list is
684:24 - empty so the condition comes out to be true so in order to insert this temporary node into the
684:35 - circular singly linked list at the beginning the first step we do is we assign the value of temp
684:40 - to last so it looks something like this and after this step temp and last both point to this
684:52 - particular node as the circular singly linked list is empty and we want to insert this node at the
684:58 - beginning so when we insert this particular node we know that the circular singly linked list has
685:04 - only one node the last node points to that particular node so therefore we have assigned
685:11 - the value of temp to last moving ahead now after the if else block what we do is we simply assign
685:22 - the value of temp to last dot next now why we are doing this step is because here we know that we
685:29 - are basically inserting a node at the beginning of a circular singly linked list and we also know
685:34 - that circular singly linked list has property that the last node usually refers to the first node
685:39 - and as we are inserting a node at the beginning we know that the last next should point to this
685:45 - particular node and here if you see when we are inserting a node into an empty circular singly
685:51 - linked list we know that after an insertion there is only one node which is the first and the last
685:56 - node both and we want to make the last dot next point to first node so in order to do that what
686:03 - we are doing is we are assigning last dot next value to the node itself and here we know that
686:09 - temp is pointing to this particular node so it looks something like this so this link is gone
686:16 - and then it will refer to itself because temp is pointing to this node only so after this step
686:24 - last next will point to the node itself and here if you see it is also fulfilling the property of
686:32 - circular singly linked list as last node is pointing to the first node and since this is the
686:38 - only dot in the circular singly linked list therefore last node and the first node is the
686:43 - node itself therefore here it is referring to itself moving ahead so after we insert the node
686:52 - in a circular singly linked list we usually increment the length by one because we know
686:56 - that now circular singly linked list has size one so now the value stored in the length will
687:04 - be one so when the method get executed circular singly linked list looks like this so friends
687:15 - let's insert one more node into the circular singly linked list having the length as one
687:19 - so usually in the first step we create this temporary list node having the data which we
687:28 - want to pass so let's say we are taking a node having data as eight and the temporary node is
687:33 - pointing to it and its next is pointing to null so this node we want to insert at the beginning
687:38 - of this circular singly linked list therefore we need to insert the node just before the node
687:45 - having the data as one so let's see the demonstration step by step so in the first
687:53 - step we usually check whether the circular singly linked list is empty or not so we make
687:59 - an if check that whether last is pointing to null or not so your last is pointing to this node
688:04 - therefore the circular singly linked list is not empty so the condition comes out to be false so
688:10 - therefore the else block will be executed so in the else block what we do is we assign the
688:20 - value last dot next to temp dot next so here if you see last dot next is pointing to the node
688:28 - itself and temp dot next is pointing to null so why we are doing this step is because we want to
688:35 - insert the node at the beginning so therefore this node should come just before this so when
688:42 - this node will be inserted this would be the first node and this would be the last node and
688:46 - as this would be the first node its next should point to this node so in order to do that we need
688:53 - to break this link and we need to assign this link to last dot next so here if you see last dot next
688:59 - is pointing to the last node itself and we want to insert this node just before this therefore we
689:06 - need to assign the value of last dot next to temp dot next so it looks something like this
689:11 - so now temp dot next is pointing to last dot next moving ahead and then what we do is we simply
689:27 - assign the value of temp to last dot next so friends in this step what we are doing is once
689:34 - we insert this node this node would be the part of circular singly linked list and this would be
689:39 - the first node and we also know that circular singly linked list is property that last node
689:44 - will always point to the first node therefore last next should point to this node because that is
689:53 - the circular singly linked list property so in order to do that we are simply assigning the
689:58 - value of temp last dot next so it would look something like this and as we want to insert
690:07 - this node at the beginning of a circular singly linked list we know that last dot next should
690:12 - point to this node because after insertion this node will become our first node we increment the
690:20 - length by one so after the method is executed we know that circular singly linked list has two
690:30 - nodes and length is two now friends let's suppose we want to insert one more node so in the first
690:40 - step will create the last node by name temp so here it would look something like this the temp
690:48 - is pointing to the node having data as 10 and its next is pointing to null now this node we want to
690:54 - insert at the beginning therefore we know that this node should come just before it and once
690:59 - this node is inserted this node will become our first node so let's see the demonstration of
691:05 - algorithm so first we'll check whether list is empty or not so as last is pointing to the node
691:13 - having data as one therefore the list is not empty so in the else block we are simply assigning
691:23 - value of last dot next to temp next so friends as we want to insert this temporal node at the
691:30 - beginning of a circular singly linked list and the first node is having the data as 8 therefore
691:38 - when we want to insert this temporal node just before that then we need to make this pointer
691:42 - point to this particular node and in order to reach this particular node we know that we are
691:48 - keeping the track of the last node and when we do last dot next we are reaching to the first node
691:53 - therefore we are simply assigning the value of last dot next to temp next so it would look
692:00 - something like this now your temp dot next is pointing to the first node of a circular singly
692:07 - linked list moving ahead and the last step we do is as you want to insert this temporary node so
692:18 - once this node is inserted we know that this would become our first node and we know that
692:23 - circular singly linked list has property that last node next should point to the first node
692:27 - therefore here we are simply assigning the value of temp to last dot next so it would look something
692:34 - like this and the final step we are incrementing the length by one currently the circular singly
692:45 - linked list has three nodes where first node has data is 10 second node has data is 8 and the last
692:52 - node has data is 1 and last next is pointing to the first node so after the method is executed
693:01 - the circular singly linked list looks like this so friends here we inserted three nodes having
693:08 - data as 1 8 and 10 at the beginning of a circular singly linked list now let's go to Eclipse and
693:15 - see the working code so friends in my previous tutorial we discussed about circular singly linked
693:24 - list and its implementation we created one class by name circular singly linked list so in this
693:32 - tutorial we will write a method which will insert the node at the beginning of a circular singly
693:36 - linked list so let's say I give the name of method is public void insert first so here I
693:54 - have created one method by name insert first so this method will take the data part which is of
694:00 - integer type so in the first step we'll create a list node by name temp and here we pass the data
694:14 - into the constructor so therefore in this step we are simply creating a list node of the data
694:21 - which we have passed into the method now in the next step we are providing a if check
694:28 - that last is equal to null or not so if the circular singly linked list is empty therefore
694:40 - in the if statement we are simply assigning the value of temp to last so last equals temp
694:47 - moving ahead and if the circular singly linked list is not empty then we are simply assigning
694:56 - value of last dot next to temp dot next and after the if else block we are assigning the
695:09 - value of temp to last dot next so last dot next equals temp and then we are simply incrementing
695:19 - the size of circular linked list by one so friend this is the code for insertion of a node into the
695:26 - beginning of a circular singly linked list so here we first create the list node then we check
695:33 - whether the list is empty or not so if the circular singly linked list is empty then we
695:37 - simply assign the value of this temporary node to last and if the circular singly linked list is
695:43 - not empty then we simply assign the value of last dot next to temp dot next which we saw in the
695:49 - slide and the last step we usually assign the value of temp to last dot next and then we
695:55 - increment the length by one now in the main method let's test the working of this insert first method
696:02 - so in my previous tutorial in the main method we created the instance of circular singly linked
696:11 - list and let's say using that instance we call insert first and we provide the data as 10 and
696:21 - finally we call the display method so if I run the code so you see it printed value as 10
696:32 - now let's say I call this method again and provide data as 15 and if I run the program
696:42 - so you see it printed 15 and then 10 so here when the circular singly linked list was empty
696:49 - we call insert first and pass value as 10 so the node having data as 10 was the only node
696:56 - into the circular singly linked list and when we inserted 15 so here we are inserting 15 at
697:02 - the beginning of a circular singly linked list so this circular singly linked list had only node
697:07 - having data as 10 so when we inserted 15 it got inserted just before the node having data as 10
697:14 - so if you want to insert one more node say of data 25 so this 25 will be inserted just before
697:23 - the node having data as 15 so if I run the code so you see it printed 25 15 and then 10
697:33 - so friends in this tutorial we discussed how to insert a node at the beginning of a circular
697:40 - singly linked list in Java I hope you like this video please like comment share and subscribe my
697:46 - youtube channel thanks have a nice day hello friends welcome to my new data structures and
697:53 - algorithm in Java tutorial series video friends in this tutorial we will discuss how to insert
698:01 - node at the end of a circular singly linked list in Java so friend let's suppose we are given an
698:08 - empty circular singly linked list so when the circular singly linked list empty we know that
698:14 - the last node points to null and in order to understand what this last node is you need to
698:20 - watch my previous tutorials so in this tutorial we will be discussing how to insert a node at the
698:26 - end of a circular singly linked list in Java so let's see the demonstration of this algorithm step
698:32 - by step so we also know that when the circular singly linked is empty length is zero now in
698:41 - order to insert a node in a circular singly linked list at the end the first step we do is
698:46 - we basically create a node and will pass the data so here we have created one node having the data
698:54 - as one and which is being referred by this temp node and whose next is pointing to null now we
699:01 - want to insert this node at the end of a circular singly linked list so moving ahead so the first
699:10 - step we check is whether the last is equal to null or not so if the last is equal to null then
699:15 - we know that circular singly linked is empty so therefore the condition in if log comes out to
699:21 - be true so here the first step we do is we simply assign the value of temp to last now as the
699:32 - circular singly linked list is empty so therefore there are no nodes and as we want to insert this
699:38 - temporary node at the end of the circular singly linked list so when we insert this
699:43 - temporary node into the empty list we know that after its insertion this would be the only node
699:48 - in the circular singly linked list therefore last should point to this node so in the first step we
699:55 - are simply assigning value of temp to last so it would look something like this moving ahead
700:02 - now in the second step we are assigning value of last to last.next so why we are doing this
700:12 - step is we need to fulfill circular singly linked list property that last next should point
700:18 - to first node and as we know that this is the only node in the circular singly linked list
700:24 - therefore the last and the first node is the node itself so we are assigning value of last to last
700:30 - next so it would look something like this so this link is gone and now this last.next will
700:37 - refer to the node itself so it would look something like this and in the last step we will simply
700:48 - increment the length by one because we have successfully inserted the node at the end of
700:54 - a circular singly linked list so friends once this algorithm executed we know that initially
701:00 - circular singly linked list was empty and now it contains only one node so it is referred by last
701:06 - because this is the only node and its next is pointing to the first node which is the node itself
701:12 - so now if we call this algorithm again and we want to insert one more node so let's the
701:18 - demonstration of the algorithm now in the first step we will simply create the list node and
701:23 - provide the data which we have passed into the method so it would look something like this the
701:31 - temp is pointing to the node having data as it and whose next is pointing to null now let's say we
701:37 - want to insert this node at the end of a circular singly linked list so let's see the demonstration
701:43 - step by step so we check whether last is equal to null or not so now the last is pointing to one
701:51 - node therefore it's not equal to null therefore the condition in if block comes out to be false
701:56 - so the else part will be executed so in the else block the first step we do is we assign the value
702:04 - of last.next to temp.next so here why we are doing this step is as you want to insert this temporary
702:12 - node at the end of a circular singly linked list we know that after its insertion that the node
702:18 - which is referred by temp would be the last node so if it is a last node then its next should point
702:24 - to the first node and how to reach the first node we know that currently the node which is referred
702:30 - by last its next is the first node therefore we are simply assigning last.next value to temp.next
702:38 - so it would look something like this so this link will be removed and it would refer to the first
702:46 - node and in order to reach the first node we know that last.next refers to first node therefore
702:52 - temp.next will now refer to the node even data as one so it would look something like this so
702:59 - currently you see we have two nodes where temporary.next is pointing to this first node so moving ahead
703:07 - and in the second step we are assigning value of temp to last.next now here you can see last.next
703:17 - is referring to itself and we know that when we insert this node last.next should refer to this
703:23 - node because then it will form a chain so we are simply assigning value of temp to last.next so it
703:30 - would look something like this so now this link will be gone and now it should refer to this
703:36 - temp node so moving ahead and in the last step we are simply assigning value of temp to last now
703:48 - we are doing this step is because we have inserted the node at the end of a circular singly linked
703:53 - list and we know that we are keeping track of this last pointer so after this temporary node
703:59 - is inserted into circular singly linked list we know that this becomes the last node therefore
704:04 - we need to assign the value of temp to last so that last refers to the last node of a circular
704:10 - singly linked list so it would look something like this so in the final step we will simply
704:19 - increment the length by one the circular singly linked list has two nodes and we can also see
704:27 - that the last next is referring to this first node now friends let's suppose we want to insert
704:35 - one more node into this circular singly linked list so we'll execute this algorithm again and
704:41 - we'll pass the data into the method so let's see the demonstration of this algorithm step by step
704:47 - so in the first step we'll simply create a list node and we'll refer it to by temporary variable
704:54 - so here you can see we have simply created a temporary node having data as 10 and whose
705:01 - next is pointing to null and now we want to insert this node at the end of the circular
705:06 - singly linked list so let's see the demonstration of this algorithm step by step now the first step
705:15 - will check whether last is equal to null or not so currently last is pointing to the second node
705:20 - therefore it's not null so the condition and if block comes out to be false so the else part
705:26 - will be executed so the first step in else part we do is we simply assign the value of last.next
705:34 - to temp.next so here you can see last.next is pointing to this first node and temp.next is
705:42 - pointing to null and as we want to insert this node at the end of a circular singly linked list
705:48 - we know that after its insertion this temporary node becomes the last node therefore its next
705:54 - should point to the first node and in order to reach this first node we know that last next is
706:01 - referring to it therefore we'll simply assign value of last.next to temp.next so it would look
706:07 - something like this so now you can see temp.next is pointing to this first node moving ahead
706:17 - in the second step we simply assign value of temp to last.next so here in order to insert this
706:27 - node at the end of a circular singly linked list we know that initially this list contains two
706:32 - nodes and in order to insert this third node we need to break temp.next link which is referring
706:39 - to first node and we need to assign it to the temp node because then this third node will be a part
706:44 - of a chain so in this step we are simply assigning value of temp to last.next so it
706:50 - would look something like this so this link is broken and now it will point to this temporary
706:58 - node moving ahead in the final step we know that as we have inserted this node which is at the last
707:09 - position we'll simply assign value of temp to last so it would look something like this
707:18 - now in the last step we'll simply increment the length by one so friends here you can see the
707:27 - length of the circular singly linked list is of size 3 as you have three nodes where data is 1,
707:33 - 8 and 10 and the last node next is pointing to the first node so friend this was the demonstration
707:40 - of the algorithm now let's go to Eclipse and see the working code so friends in my previous
707:46 - tutorial I created one class by name circular singly linked list and we implemented circular
707:52 - singly linked list into the class so in this tutorial we will simply write a method which
707:57 - would insert a node at the end of a circular singly linked list so I'll create one method as
708:04 - public void insert last and to this method I will pass an integer value which will actually hold
708:21 - the data of the list node so in the first step we'll simply create the list node by name temp
708:27 - and we'll pass the data into the constructor and then we'll provide an if else block so in the if
708:40 - we'll provide a condition is whether list is empty or not so we'll simply check whether last is equal
708:49 - to null or not or we can also call is empty method which we have discussed in my previous
708:57 - tutorials so friends if the list is empty then we'll simply assign value of temp to last and in
709:07 - the second step we'll simply assign value of last to last dot next which we discussed in the slide
709:15 - and in the else part so in the first step what we do is we assign the value of last dot next to
709:28 - temp dot next in the second step we assign the value of temp to last dot next and finally we assign
709:43 - the value of temp to last and as we discussed in the slide once we insert the node at the end of
709:51 - the circular singly linked list we increment the length by one so length plus plus so friend this
710:01 - is the code to insert the note at the end of a circular singly linked list now let's test this
710:06 - method into the main method so in the main method I have created an instance of circular singly linked
710:10 - list so let's add few note at the end of the circular singly linked list so here we will add
710:16 - the notes which we saw in the slide so insert last and let's say I provide data as one and if
710:28 - I print the circular singly linked list by calling display method you can see when I run the code
710:34 - it prints one because initially circular singly linked list is empty and when we insert one note
710:43 - at the end of the circular singly linked list we only get this one note now let's insert one more
710:50 - note and I provide data as eight and when I run this code you can see it printed one and then
711:01 - eight so therefore it inserted eight at the end of the circular singly linked list now let's say
711:08 - I insert one more note having data as ten and if I run this code you can see it printed ten so
711:21 - friends here we inserted three notes at the end of the circular singly linked list so first we
711:26 - inserted one and then we inserted eight so eight was inserted at the last position and finally we
711:33 - inserted ten so you can see the ten is inserted just after eight and which is the last note so
711:41 - friends in this tutorial we discussed how to insert a note at the end of a circular singly linked list
711:45 - I hope you like this video please like comment share and subscribe my youtube channel thanks
711:51 - have a nice day hello friends welcome to my new data structures and algorithm in Java
711:57 - tutorial series video friends in this tutorial we will discuss how to remove first note from a
712:04 - circular singly linked list in Java so friends let's suppose we are given a circular singly linked list
712:11 - having three nodes say one eight and ten whose length is three so friends in our previous tutorial
712:18 - we discussed that we are keeping the track of the last node of the circular singly linked list
712:23 - through the last instance variable so friends below is the algorithm to remove the first node
712:29 - from a circular singly linked list in Java so let's see the demonstration of this algorithm step by
712:34 - step so the first thing we here we do is we check whether the circular singly linked list is empty
712:40 - or not so if you see circular singly linked list has three nodes and length is three therefore it's
712:47 - not empty so the condition and if block comes out to be false moving ahead now in order to remove
712:55 - the first node from a circular singly linked list we know that we are keeping the track of the last
713:00 - node and in the circular singly linked list last node next points to the first node so therefore
713:06 - here we are creating a temp node and we are assigning the value of last dot next to it so
713:11 - this temp will point to the first node because in the circular singly linked list last next points
713:16 - to the first node so it would look something like this moving ahead so here we are providing an
713:26 - if else block and in the if block we are checking that whether last dot next is equal to last or
713:30 - not so this condition comes into picture when the circular singly linked list has only one node
713:36 - left so in this case last next points to the last because the circular singly linked list has only
713:42 - one element where first and the last node is the node itself so here you can see last next is
713:49 - pointing to this first node and therefore it's not equal to last so the condition and if block
713:54 - comes out to be false and the else part will be executed so in the else part the first step
714:03 - we do is we assign the value of temp dot next to last dot next now friends as we want to remove
714:09 - this first node we need to do two things first we need to break this link which is being referred
714:15 - by last dot next to the first node so in order to remove this link what we are doing we are simply
714:22 - assigning the value of temp dot next to last dot next so friends here if you see when we remove this
714:28 - first node from a circular singly linked list the node having the data as 8 becomes the first node
714:33 - because this node is removed and we also know the circular singly linked list has property that last
714:39 - next points to the first node so in this step we are simply assigning the value of temp next to last
714:47 - dot next now why we are doing this step is because once the first node is removed the second node
714:53 - becomes the first node so therefore last dot next should point to the second node so when this step
714:59 - is executed it looks something like this that last dot next is removed and we will assign the
715:06 - value of temp dot next to last dot next so it would look something like this so we are breaking the
715:12 - link of last dot next to the first node and then we are assigning it to the second node because
715:17 - when the first node is removed the second node becomes our new first node moving ahead and after
715:26 - the fls block we simply assign the value of null to temp dot next so friends as we are removing
715:32 - this first node and returning it from the method therefore we need to break this link as well so
715:38 - in order to break this link we are simply assigning null value to temp dot next so it would look
715:44 - something like this moving ahead and then we are decrementing the length by one because we know
715:53 - that we have removed this node from the circular singly linked list so initially the length was
715:58 - three so now it will become two moving ahead and then we are simply returning this temp node
716:07 - because we have already removed it from the circular singly linked list so it would look
716:12 - something like this so friends as soon as we have removed this link we know that we are currently
716:18 - left with two nodes and here you can see the node having the data as eight becomes our new first
716:23 - node and you can also see last next is pointing to this node therefore if we again call this
716:30 - algorithm and we want to remove the first node of a circular singly linked list the algorithm goes
716:35 - as follows so again first we check whether the circular singly linked is empty or not so here
716:41 - you can see circular singly linked list has two nodes therefore it's not empty so the condition
716:46 - in if block comes out to be false and the first step we are simply creating a temp node and
716:52 - assigning the value of last dot next to it so friends here as we track the last node of the
716:57 - circular singly linked list and we want to remove the first node therefore in order to reach the
717:02 - first node what we do we simply do last dot next so this value we are assigning for temp node and
717:09 - it would look something like this so here you can see last dot next is pointing to this first node
717:15 - and we are assigning that value to temp so now temp will point to the node having data as eight
717:22 - moving ahead and then in the if block we are checking that whether last dot next is equal
717:28 - to last or not so currently last dot next is pointing to this first node therefore last dot
717:34 - next is not equal to last so the condition in if block comes out to be false and the else part will
717:40 - be executed so friends in the else part what we are doing we are simply assigning the value of
717:49 - temp dot next to last dot next so in order to remove the node having data as eight we need to
717:56 - first break this link which is being referred by last dot next and we also know that when we remove
718:02 - this particular node from the circular singly linked list we are left with only one node so
718:06 - therefore last dot next should point to that particular node so friends here we are assigning
718:11 - the value of temp dot next to last dot next so we know that we have to remove this link and when we
718:17 - remove this particular node having data as eight we know that now 10 will become our first and the
718:23 - last node both therefore we are simply assigning the value of temp next which is the node having
718:28 - data as 10 to last next so it would look something like this so here you can see the link is
718:36 - removed and then we are assigning temp next to last next so it would look something like this
718:45 - so friends here we have removed the link which is referring to this particular node which we
718:49 - want to remove moving ahead and then we are simply assigning the value of null to temp dot next
718:58 - because as we are returning this complete node we need to break this link so it would look something
719:02 - like this so now temp dot next instead of pointing the node having data as 10 it is now pointing to
719:09 - null and as we have removed this node from the circular singly linked list we will decrement
719:16 - the length so now length is one because we have only one node left and in the final step we are
719:24 - simply returning the temp so it would look something like this so friends after the method
719:31 - is executed we are left with only one node which is the first and the last node both because we
719:37 - are keeping the track of the last node and when the circular singly linked list has only one
719:41 - element left we know that that particular node is the last node and if it travels to its next
719:47 - then it will refer to itself because this is the first node and the last node both
719:51 - and if we call this algorithm again in order to remove this last node from the circular singly
719:56 - linked list so the demonstration of the algorithm is as follow so first we check whether the list
720:02 - is empty or not so currently circular singly linked list has one node therefore it's not empty
720:08 - so the condition in if block comes out to be false
720:12 - and as we want to remove the first node of the circular singly linked list we assign the value
720:17 - of last dot next to temp but here you can see we are only left with one node therefore the last
720:23 - dot next is pointing to that particular node only so after this line gets executed it would
720:29 - look something like this so here you can see temp is pointing to last dot next which is the node
720:36 - itself moving ahead and now we are checking whether last dot next is equal to last or not
720:45 - so as we discussed earlier this condition will come only into picture when we are left with one
720:49 - node so currently here you can see last next is pointing to the last node itself
720:56 - therefore the condition in if block comes out to be true so the if block will be executed
721:04 - so friend in this step we are assigning null to last because in order to remove this node
721:10 - we have to break this link if you break this link then this node will be freed up
721:15 - so when this statement will be executed it would look something like this
721:20 - that now last will point to null and as we have broke this link now this node can be removed
721:26 - easily so after the if statement the last step we do is we simply assign the value of null to
721:34 - temp dot next so currently here you see temp next is pointing to temp itself therefore we need to
721:41 - break this link so here temp next is pointing to null moving ahead and then we are simply
721:52 - decrementing the length by one because we have successfully removed the node
721:57 - so now length becomes zero and as here you can see last is now pointing to null
722:03 - and in the final step we are simply returning the temp so it would look something like this
722:07 - so friends after we remove all the elements now if you again call this algorithm
722:17 - so in the first step we will check whether the circular singly linked is empty or not
722:22 - so here you can see the length is zero and last is pointing to null therefore the circular singly
722:27 - linked list is empty so the condition in if block comes out to be true and as we know that when the
722:35 - circular singly linked list is empty there are no nodes left to be removed so therefore we can
722:40 - throw a no such element exception because there are no nodes left to be removed so friends here
722:48 - we saw the demonstration of the algorithm now let's go to eclipse and see the working code
722:54 - so friends in my previous tutorial we created one class by name circular singly linked list
723:00 - and we implemented the code for the circular singly linked list into that particular class
723:05 - so in order to understand the working of circular singly linked list you can watch my previous
723:09 - tutorials and here you can see we are keeping the track of the last node through the instance
723:15 - variable list node so in this tutorial we will write the code to remove the first node from the
723:20 - circular singly linked list so here let's suppose we give the method name is public
723:30 - list node remove first
723:42 - so friends here i have given the method name is remove first and whose return type is of
723:46 - list node so this method will remove the first node from the circular singly linked list and
723:50 - will return it back to us so in the first step as we saw in the slide we are checking
723:56 - that whether circular singly linked list is empty or not so is empty
724:04 - so if the circular singly linked list is empty we will throw no such element exception
724:18 - and here we provide a string as
724:20 - circular singly linked list is already empty
724:33 - and if the circular singly linked is not empty then the first step we do is
724:39 - we create a temp list node and we'll assign the value of last dot next to it
724:44 - and then we'll provide an if else block so in the if block we provide a condition as
724:54 - that whether last dot next is equal to last or not
725:00 - so if the last dot next is equal to last then we'll simply assign null value to last
725:06 - because we know that this condition comes into picture when there is only one node left into
725:11 - the circular singly linked list and in that case if we want to remove that particular node
725:16 - we need to simply assign the null value to last because this last is referring to that particular
725:21 - node and in the else part we are simply assigning temp next value to last dot next
725:34 - and after if else block we are simply assigning null value
725:43 - to temp next and then we are reducing the length by one
725:52 - and in the final step we are simply returning the temp node
725:57 - so friends this is the algorithm to remove the first node from the circular singly linked list
726:02 - now let's test it's working in the main method so friends in my previous tutorial we discussed how
726:08 - we can insert the node into the circular singly linked list so we inserted three nodes in my
726:13 - previous tutorial with the data as one eight and ten and we also created one display method which
726:20 - could display the entire circular singly linked list so if i run the code now
726:26 - you can see it printed 1 8 and 10 because there are three nodes in the circular singly linked list
726:35 - 1 8 and 10 now let's say we are removing the first node from the circular singly linked list
726:44 - and we are calling the display method again
726:50 - now if i run the code again
726:55 - so here you can see initially it printed 1 8 and 10 because we have three nodes in the
727:00 - circular singly linked list and when we removed the first node so one got removed and it printed
727:05 - 8 and 10 now let's again call remove first method and if i run the code now
727:17 - so you can see it removed 1 and then it removed 8 and it finally printed 10
727:23 - and if i call again remove first and if i run the code
727:32 - so you can see in the second line it printed nothing because it removed all the nodes from
727:36 - the circular singly linked list and when we call display so here you can see in display method
727:43 - we are initially keeping a condition whether last is equal to null and if last is equal to null then
727:49 - we are simply returning from the method so therefore it printed nothing because
727:53 - when we have removed all the nodes from the circular singly linked list we know that last
727:57 - point to the null and now if i call again remove first and if i run the code
728:08 - so you can see it gave an exception as no such element exception
728:12 - and it printed messages circular singly linked list is already empty
728:15 - so friends in this tutorial we discussed how to remove the first node from the circular
728:21 - singly linked list in java so friends usually we never return the list node from a method
728:27 - and we actually return the data part of the node which you want to remove
728:32 - so here if you are calling remove first so it should remove the node but it should return
728:37 - us back the data part of it so the code is similar what we need to do is we need to change
728:42 - the return type to int because the data is of integer type and here after pointing the first
728:48 - node by going through last dot next we create an integer variable which stores the data of the
728:54 - first node so we simply assign tam dot data to result integer variable so initially we were
729:02 - making tam dot next point to null we were doing this step because we are only returning back the
729:08 - list node so now when we are returning back the data part of it we don't require this step
729:15 - because this node will be automatically garbage collected by java and in the last step we are
729:20 - simply returning back the result so friends initially we removed the first node from the
729:24 - circular singly linked list and we returned it back and after some modification we are
729:29 - returning back the integer value so let's test the working of this method
729:34 - so here we will just print the data which this remove first will return us back so here we will
729:44 - call remove first so here you can see there are three nodes one eight and ten and then we are
729:54 - removing the first node so therefore it should print the value as one because one is the first
729:59 - node of the circular singly linked list and if i run the code
730:06 - so here you can see initially it printed the three nodes with data as one eight and ten
730:12 - and then it removed the first node which is one and it printed it on the console
730:17 - and when we did display again there were two nodes left which is eight and ten
730:24 - so friends in this tutorial we discussed how to remove the first node from the circular singly
730:28 - linked list in java i hope you like this video please like comment share and subscribe my youtube
730:34 - channel thanks have a nice day hello friends welcome to my new data structures and algorithm
730:42 - in java tutorial series video friends in this tutorial we will discuss how to represent a stack
730:49 - in java so friends what is a stack so stack is a linear data structures used for storing the data
730:58 - structure we call it a linear data structure because it can be represented by a linked list
731:03 - or an array in which the nodes are adjacent to each other therefore it's a linear data structure
731:12 - so the basic property of a stack is that it's an ordered list in which we insert and delete
731:18 - the node at one end which is called a stop so here if you see if suppose we are given a list
731:26 - and the first node is pointed by top so we make this list restrictive in nature in the way that
731:34 - we can insert and delete the node at one end which is represented by top
731:38 - and if you see this restrictive property makes it a leafo data structure so what is a leafo data
731:45 - structure the last element inserted is the first one to be deleted so here if you see when we
731:53 - insert a node in the stack at the beginning so that element becomes the first candidate to be
731:58 - deleted because we are only allowed to remove and add the nodes at one end which is represented by
732:05 - the top moving ahead so friends let's see a demo of how stacks looks and how the elements are stored
732:16 - and removed so initially if you see when the stack is empty so that top node points to null
732:28 - and usually we use push and pop operation to add and remove the elements
732:32 - from the stack so suppose if you want to push an element having the data as 10
732:39 - so it would look something like this
732:41 - and once we push the element into the stack the top node points to that particular node inserted
732:54 - so suppose we want to push now node 15
732:59 - so when the node is pushed into the stack the top points to that particular node
733:05 - and now suppose we want to push 20
733:12 - so when the node is inserted top points to the last node inserted
733:22 - if you see the stack is basically a one-way list
733:27 - so here you can think that we are inserting node at the one end and the other end is
733:30 - blocked so there is only one end to push the elements and pop the elements
733:36 - so basically if you see when we insert a 20 the top pointed to that element
733:43 - so now if you want to pop an element we know that there is only one end where this
733:47 - nodes will be removed so as we pop 20 so now top will point to the node just before it
733:57 - and let's say if you want to again pop an element
734:06 - so now top will point to the node just before it
734:11 - and finally if we again pop an element so you can see the 10 got removed and now top points to again
734:19 - null so friend this is how the stack works as you saw it's a last in first out data structure
734:26 - so you saw the element which was inserted the last was the first one to be removed
734:33 - so friends this is how we actually represent the stack
734:37 - i hope you like this video please like comment share and subscribe my youtube channel
734:41 - thanks have a nice day
734:47 - hello friends welcome to my new data structures and algorithm in java
734:51 - tutorial series video friends in this tutorial we will discuss
734:57 - how to implement a stack in java
735:01 - so friends in my previous tutorial i discussed how to represent a stack
735:06 - we saw that it is a leafo data structure which means that element which got inserted last
735:12 - would be the first one to be removed and we also discussed that the elements are inserted and
735:18 - removed at the one end which is represented by top
735:23 - so friends in this tutorial we will discuss how to implement a stack in java
735:28 - we will discuss few of the methods which it implements such as push
735:32 - which actually inserts an element into the stack
735:36 - and we will also discuss pop method which removes the last node inserted from the stack
735:42 - so friends in this tutorial we will implement a stack using a linked list
735:45 - so friends as you know that linked list is represented by a list node
735:50 - where it contains two things one is the data and other is the pointer to the next list node
735:56 - so when we implement a stack last we usually keep two instance variables one is top and another one
736:02 - is length so in our previous tutorial we discussed that this top node is used to insert and remove
736:11 - the elements from the stack and here the instance variable length which represent
736:17 - the size of the stack so friends let's see the demonstration of this algorithm
736:23 - so friends when we initialize a stack first top points to null and the length is zero
736:30 - so here you can see top is pointing to null
736:36 - and as the stack is empty the length is zero
736:41 - now suppose we want to add an element having data as 10
736:45 - so we'll call this push method and pass the data into it
736:50 - so when we call push and pass data as 10 we know that data is 10
736:56 - so let's see the execution of this method step by step
737:02 - so in order to push an element into a stack we first create a temporary list node
737:08 - having a data which we have passed as an argument
737:12 - so it would look something like this that we have created a list node having data as 10
737:20 - and it's next pointing to null and you see the name of the list node is stamp
737:24 - and it's pointing to that particular node moving ahead
737:29 - now in order to insert this node into the stack the first step we do is
737:39 - we assign the value of top to temp.next so friends here you see temp points to this node
737:46 - and its next points to null and when the stack is empty we know the top is also pointing to null
737:54 - so in the first step we are simply assigning a null value to temp next
738:00 - so it would look something like this
738:04 - so after this step temp next is pointing to null and top is also pointing to null
738:09 - moving ahead
738:14 - and then we'll assign the value of temp to top
738:17 - so here you see top points to null and when we'll assign the value of temp
738:22 - so temp is pointing to this node so after this step top will point to the temporary node
738:29 - so it would look something like this
738:36 - and in the final step as we know that we have inserted this temporary node
738:41 - will increment the length of the stack by one
738:43 - so here you see when this method gets executed
738:54 - the stack looks something like this the top is pointing to a node having the data
738:58 - which we passed into the push method and its next is pointing to null
739:06 - and therefore the stack has one element therefore the length is one
739:09 - now suppose we again call push method and pass data as 15
739:18 - so let's see execution of this method step by step when length is one and top is already pointing
739:23 - to a node so here when we have called push 15 so the data is 15
739:34 - so here we'll create a temporary node and this temporary node will hold the data which we
739:38 - passed into this push method so here you see we have created this temporary node having data as
739:45 - 15 and its next pointing to null moving ahead
739:54 - so friends the next step is we'll assign the value of top to temp.next
739:58 - so currently temp.next is pointing to null so in order to insert this node into the stack
740:05 - we are assigning the value of top to temp.next so we are doing something like this
740:12 - we are removing this link and we are pointing it to top so in this step we are assigning the
740:19 - value of top to temp.next so now temp.next is pointing to top moving ahead
740:26 - so as this node is now inserted now top should point to this node
740:34 - so therefore we are assigning the value of temp to top so it would look something like this
740:44 - so now top is pointing to the temporary node moving ahead
740:48 - and we'll simply increment the length by one because now the stack has two elements
741:02 - so friends after this method gets executed the stack looks something like this
741:09 - so here you see the top is pointing to the node which we inserted last
741:13 - so friends this is how we insert an element into the stack
741:22 - now let's see the pop operation in which we remove the last inserted element so
741:29 - so we'll take the previous example we know that first we inserted 10 and then we inserted 15
741:35 - so in the pop the last element inserted will be the first one to be removed
741:40 - so let's see how this pop method works
741:45 - so in order to remove the last inserted node so what we'll do we'll simply capture
741:50 - top.data into integer variable by name result
741:56 - so we are storing the data inside this node into the integer variable result moving ahead
742:05 - now as we want to remove this last inserted node we need to break this link
742:10 - so once this node is removed top should point to its next element
742:15 - so for that we'll simply assign top.next value to top so it would look something like this
742:23 - and as this node is not referred by top it would be garbage collected moving ahead
742:32 - now we have removed the node from the stack so we need to decrement the length by one
742:36 - so now length becomes one
742:44 - so we'll simply return the value 15 from this method
742:49 - now you see the stack contains only one element and the length is one now if we again call the
742:54 - pop method so first we'll store the data inside this list node which is being pointed by the top
743:02 - top so we are simply assigning top.data into an integer variable result
743:12 - and as we need to remove this node we'll simply break this link
743:16 - and assign top to its next so we are simply assigning top.next value to top so top.next
743:22 - is pointing to null so we are simply assigning a null value to top so it would look something like
743:28 - this and as this list node is not referred by top so it would be removed
743:40 - we'll decrement the length by one because the node is now removed from the stack
743:50 - and finally we'll return the result
743:52 - so friends here you can see when the stack is empty the length is zero and top points to null
744:01 - so friends here we saw the demonstration of how to implement a stack in java
744:07 - so let's go to eclipse and see the working code
744:13 - so friends in order to implement a stack in java i'll just created one class by name stack
744:18 - so in this class we will implement the stack functionality
744:23 - so as we saw in the slide that stack contains few instance variables
744:28 - so we'll create one instance variable of type list node by name top so private list node top
744:40 - and we'll also create an integer variable by name length which will store the size of the stack
744:45 - so try weight and length
744:53 - so friends as you can see we are implementing a stack using a linked list
744:58 - which is represented by list node so we'll create a inner class of type list node
745:09 - so friends in our previous tutorials we discussed how we can represent a list node in java
745:14 - so a list node contains two things one is the data so private and data
745:23 - and other is pointer to next list node so private list node next
745:33 - we'll also create one constructor
745:34 - so this constructor takes the data part
745:50 - so friends here we are implementing the stack using a linked list so we have created a list node
745:56 - now once we initialize the stack we know that top points to null and length is zero
746:02 - so we'll create one constructor for this stack class public stack
746:13 - and here we'll assign a null value to top and length as zero
746:24 - friends we will also create one method by name length which will return us back the length of
746:29 - the stack so public and length return length
746:44 - we'll create one boolean method by name is empty which will return us a boolean value
746:50 - whether the stack is empty or not so public boolean is empty
747:03 - so here we'll simply return a boolean value which will represent whether the stack is empty or not
747:09 - so in order to know that our stack is empty we'll simply check whether length is zero or not so if
747:15 - the length is zero we'll simply return true that stack is empty and if the length is not zero then
747:22 - we'll simply return a value of false that stack is not empty so we'll simply return length equals
747:30 - zero moving ahead so friends first we'll code the push method so public void push
747:46 - and in this push method we'll pass the data so this data will be inserted into the stack
747:53 - so in order to insert this data into the stack we'll first create a list node
747:56 - and we'll give name as temp and we'll create this list node
748:05 - and inside the constructor we'll pass the data moving ahead and on the next step we'll simply
748:12 - assign value of top to temp.next and then we'll simply assign the value of temp to top
748:22 - so top equal temp and finally as the data is inserted we'll increment the length
748:31 - by one so friend this is the push method now we'll implement the pop method so public
748:40 - int pop
748:48 - so friend this method will return us back the value of last inserted node into the stack
748:54 - so here first we'll put an if check
748:59 - and the check would be is empty
749:02 - so friends if suppose the stack is empty then we can't pop an element from the stack
749:12 - so if this stack is empty we'll throw an exception
749:21 - we'll throw empty stack exception because we know that stack is empty and we cannot pop an
749:26 - element from an empty stack so friends if the stack is not empty then the first step we'll do
749:34 - we'll create an integer variable by name result and we'll assign the value of data stored in that
749:41 - top list node so we'll do top.data and as we have stored the data inside the top
749:50 - you can simply traverse to next node by assigning top.next value to top
749:59 - and finally the top has moved to its next node so that node will be garbage collected
750:05 - and we can simply reduce the length of the stack by one and finally will return the result
750:14 - so friend this is how we pop an element from a stack the stack also contains one more method
750:25 - by name peak so what this peak method does is it simply return us back the value which top holds
750:34 - so it is nothing but returning a value of a last inserted node into the stack
750:37 - so we'll create a method by name peak so public int peak so we'll also provide a if check here
750:52 - that if the stack is empty we will throw empty stack exception
751:00 - and if the stack is not empty then we can return
751:03 - top.data because we know that top points to the last inserted node into the stack
751:12 - and if we do top.data we'll get the value stored in that particular list node
751:19 - so friend this is how we implement a stack in java now let's see the demonstration of these methods
751:28 - so in the main method first we'll create a stack
751:34 - so when we do new stack we know that top is pointing to null and length is zero
751:47 - so let's say we push few elements into the stack so stack.push
751:56 - and let's say we give data as 10
752:03 - and 15 and 20
752:10 - so friends here in stack we have pushed 10 15 and 20 and we know that initially top pointed to null
752:17 - and as we inserted the data 10 it pointed to 10 then as we pushed few nodes at 10 15 and 20
752:28 - so we know that top points should last inserted node so so if we print
752:38 - tag.peak so if we are printing the peak value of the stack we know that it prints the
752:45 - value of last inserted node so if i run the program you see it prints 20
752:55 - because 20 is the element which we last inserted
753:01 - and suppose i want to pop an element so so i will do stack.pop
753:08 - so we know the top points to the last inserted node so when we do a pop 20 will be removed
753:15 - and if i print stack.peak and run the code
753:20 - so you can see it prints 15 the next time when we do stack.pop the last inserted element
753:32 - is the first element to be removed so the 20 is removed and stack contains
753:37 - 10 and 15 and 15 is at the peak position so it printed 15
753:42 - and if i simply copy paste this and run the code
753:54 - so you can see the third time it printed 10 because we removed 15 as well
754:00 - so here if you see we have implemented push and pop in such a way
754:04 - that it is resembling a lethal data structure which is the element inserted last is the first
754:10 - to be removed so friends in this tutorial we saw how we can implement a stack in java
754:19 - i hope you like this video please like comment share and subscribe my youtube channel
754:24 - thanks have a nice day
754:29 - hello everyone so in this video we are going to discuss that how we can implement a stack with
754:34 - an array in our previous video we saw how we can represent a stack and we also saw that how we can
754:41 - implement a stack using a linked list so in this video we will see that how we can implement a stack
754:47 - with an array so friends before we start in case if you're new to my channel then please subscribe
754:53 - to my channel and click the bell icon so that you never miss any update so in our previous videos
755:00 - we saw that stack is a lethal data structure which means last in first out now if this is
755:07 - a stack then here in this data structure there is only one end where the elements are inserted
755:15 - via push method and from the same end the elements are popped out using pop method
755:22 - so therefore the element which is last inserted it's first one to be removed
755:26 - so for example if we insert three then two and then one so first we inserted three then we inserted
755:34 - two and then we inserted one so the last element which got inserted was one so this would become
755:41 - the first element to be popped out so in this video we will see the implementation of push
755:48 - pop and peek method with the help of an array and we will see that how we can implement the stack
755:57 - using an array so if we are implementing a stack using an array we need to provide
756:03 - the capacity to it so as the internal data structure is array this capacity will tell
756:10 - that we need an array of three elements which also signifies its stack at the start can only hold
756:17 - three elements so internally it would look something like this that an array will be created
756:24 - of three elements having a default value of zero so currently it's an int array
756:31 - therefore the default values are zero if it is an integer array then the default values would be null
756:40 - in our previous videos we also discussed that values are inserted into the stack using the top
756:46 - variable so here top is an integer variable which will traverse this array and basically insert the
756:54 - elements based on the indexes so at the start top is actually pointing to minus one it means
757:00 - the stack is empty so now let's see how we can perform push and pop operation
757:07 - so let's suppose we want to push element eight so usually what happens is we can insert eight
757:13 - into this array at 0th index first index and second index now at the start top is pointing
757:20 - to minus one now whenever we do push we first increment top by one so currently value of top
757:27 - is minus one when we increment it by one it becomes zero and as it is pointing to 0th index
757:35 - what we do is we simply assign value eight like this so eight comes here and if we see the visual
757:44 - representation of stack it looks something like this that this is a stack the element is pushed
757:51 - into the stack and top is pointing to this element now similarly let's say if you push four so the
757:59 - first thing we do is we increment top by one so top becomes one and four is inserted at index one
758:07 - like this so four comes here and here it looks something like this that four is pushed into the
758:15 - stack and now top is pointing to four so basically when we perform push we do top plus plus
758:23 - and then we perform array of top and we assign the value
758:33 - which is our data which we have passed into our push method so we perform these two steps
758:38 - in the push operation now let's say if we want to push three so first we increment top
758:45 - it becomes two and at array of two we assign three so three comes here
758:52 - and in the stack it looks something like this the three is pushed and top is pointing to this three
759:00 - now let's say if we push one more element with the data as one so here you can see that initially
759:06 - when we created stack we provided a capacity of three it means the stack can hold only three
759:12 - elements now if we want to insert one more element we know that there is no more place
759:18 - into the stack so usually before these two steps we perform a check that whether stack
759:24 - is full or not so if stack is full we throw an exception so usually how we check whether
759:30 - stack is full or not we do array dot length and we compare it with the size of the stack
759:41 - so there is a method size now here if you see array dot length will be three
759:48 - and if we calculate the size of the stack the size of the stack is nothing but number of elements
759:54 - into the stack so we know that number of elements are three and array dot length is also three
760:00 - so how we evaluate this size function is whatever the value is hold by top which is two we do
760:06 - something like top plus one so usually this size method will return top plus one so here
760:13 - value of top is two if we do plus one we get three so array dot length is three and size is also three
760:23 - so it means the stack is full and we can't insert more elements to it so we throw an exception
760:28 - now let's suppose our stack has three elements eight four three and now we want to pop it
760:39 - so we know that we pushed elements like this and we know that the last inserted element will be
760:45 - first to be removed via pop method so when the pop method is called to whichever index top is
760:51 - pointing that element was last inserted so now this will be the first one to be removed so we
760:58 - store this value into a temporary variable and at the end we return this value and what we do is
761:03 - we simply decrement top so we do top minus minus so it looks something like this that initial value
761:11 - of top was two now it becomes one now here either we can provide a value zero or we can left this
761:19 - element as it is because whatever the insertion and deletion we are doing into this array is based
761:25 - on top so either we assign this value to zero or if it is an integer array
761:34 - then we can also assign a value of null to it and here in the stack it looks like three is popped
761:39 - out and now top is pointing to four now let's say if we again call pop so now top is pointing
761:48 - to index one and the value is four so now this four will be removed so we first store this four
761:54 - into a temporary variable and then we simply decrement top so top comes here and it looks like
762:02 - four is popped out and top is pointing to eight
762:09 - and similarly if we call pop again then eight will be removed and we will decrement top
762:14 - so now top will become minus one and eight will be popped out so here you can see if the value
762:22 - of top is less than zero it means stack is empty and if we again call pop method then we
762:29 - also check at the start whether value of top is less than zero or not if it is less than zero
762:35 - then we throw an exception that stack is empty and there are no more elements to be popped out
762:41 - so now let's move ahead and see the implementation of stack using an array step by step
762:46 - so this is the code we have a class stack and as we discussed we have two variables
762:54 - top and the integer array and via this integer array we are implementing stack
762:59 - we have a constructor which takes in a capacity and this capacity is assigned to initialize our
763:06 - integer array and usually if we don't provide any value to our stack constructor then the
763:12 - by default capacity is 10 so let's see the demonstration of this algorithm step by step
763:19 - so we will create a new stack we pass in the value as three
763:23 - which would be our capacity so the constructor will be called capacity is three
763:30 - and we know that at the start when the stack is empty top is pointing to minus one
763:37 - so value of top is minus one
763:41 - and we will initialize the array with our capacity of three so it looks something like this
763:48 - that it has capacity to hold three elements with index zero one and two
763:55 - and if we visualize the stack it looks something like this
764:00 - so when we initialize stack at the start the stack looks something like this
764:05 - now let's discuss the push method so let's suppose we call push method and we need to push
764:11 - a value eight so the data is eight which we need to push into the stack
764:20 - now before pushing eight into the stack we first check whether our stack is full or not
764:25 - so by full we mean that internally it's an array and let's say the capacity of array is three
764:31 - so we check whether this array already contains three elements or not because if the array has
764:36 - three elements then we can't push it into the array so how we check whether stack is full or not
764:42 - we call its full method now its full method returns a boolean value which is true or false
764:48 - which says that the stack is full or not and inside this method how we check whether stack
764:54 - is full or not we simply compare array's length which is three so array
765:02 - dot length is three because the array contains the capacity of holding three elements
765:07 - so array dot length is three and in the implementation of stack we also provide
765:12 - the size method now this size method will actually give us an information that how many
765:17 - elements are currently into the stack so when we will call the size method it actually returns
765:23 - an integer value and what we actually return is top plus one we are returning top plus one
765:29 - because let's suppose we have filled all the elements into the array so top will be here
765:37 - and if top is at this index so the value of top will be two but if we see the size of the stack
765:44 - is it is actually holding three elements so we simply return top plus one which actually tells
765:50 - what is the size of the stack so we simply return top plus one which says that how many
765:55 - elements are currently into the stack so currently value of top is minus one if we add plus one the
766:03 - value is zero it means currently in the stack there are no elements so it returns zero
766:11 - so three is not equal to zero it means this condition will be false and false will be
766:18 - written from this method so the condition in if block comes out to be false that stack is not full
766:26 - so now we can push this data into the stack now the first thing we do is as top is pointing to
766:32 - minus one and we are inserting the elements into the stack using an array so the first place to
766:38 - insert is at zero index so at the start first we will increment top so value of top will become
766:45 - zero top will point to the zeroth index and then using array of top
766:55 - we will assign the data so here array of zero we will assign a value eight so eight will come here
767:06 - like this and if we visualize the stack it looks that eight is pushed into the stack
767:13 - and top is pointing to it
767:20 - now let's say if you again push a value four
767:24 - so the data is four we check whether stack is full or not
767:31 - so array dot length is three and then we will evaluate the size
767:36 - and currently we know that stack has one element which is eight so when we will do top plus one
767:42 - value of top is zero so zero plus one will give one it states that the size of the stack currently
767:49 - is one because there is one element so three is not equal to one so false value will be written
767:57 - from here and the if block won't get executed because is full will return false value
768:04 - now we will increment top because the next value we need to insert is here current value of top is
768:10 - zero so when we will increment it will become one and now to array of top
768:24 - we assign the data so array of one we assign the value as four so four will come here
768:32 - and if we visualize the stack it would look something like this that four is pushed into
768:37 - the stack and top is pointing to four now now let's say if you want to push a value three
768:47 - so data is three
768:52 - we check whether stack is full or not so array dot length is three
768:57 - and size of the stack is two which is top plus one so value of top is one one plus one is two
769:09 - which states that stack has two elements so this method will return two
769:16 - and three is not equal to two so this method will return a false value
769:20 - so this if block won't get execute now the next value should come here
769:27 - because this space is occupied so we increment top top becomes two
769:35 - and at the second index we insert data which is three so three comes here so if we visualize stack
769:42 - it looks that three is pushed like this and top is pointing to it
769:50 - so now let's push one more element with the data as one so the push method will be called with the
770:00 - data as one now here you can see the initial capacity of the array was three and stack has
770:08 - three elements it means the array is completely occupied so when we will call is full method
770:14 - to check whether stack is full or not array dot length is three and when we will call size
770:21 - method we know that current size of the stack is three it simply returns top plus one so value of
770:28 - top is two so it returns two plus one which is three so the size method will return three
770:35 - and here we are comparing three with three so via this comparison we come to know that
770:41 - the stack has three elements and the capacity of our array is also three it means that stack is
770:48 - full so from is full method true will be written which signifies that stack is full so we can't
770:55 - push one into the stack and this if block will be executed so we simply throw an exception
771:02 - that stack is full like this and we can't push one into the stack
771:11 - so now let's look into the implementation of pop method now let's suppose our current stack
771:17 - has three values eight four three the demonstration we saw in our previous slide so value of top is
771:24 - two so when we will call pop method usually with the help of top we actually push into the array
771:31 - and with the help of top we actually pop the elements from the array so in this stack it
771:36 - looks like that we are inserting element from one end and we are removing it from the same end
771:41 - and whatever the element was inserted last will be the first one to be removed
771:45 - so basically top is actually helping us in maintaining leafo property that the element
771:50 - inserted last is first one to be removed so three was inserted last because top is pointing to three
771:58 - so when we will call pop the first thing we check is whether stack is empty or not
772:05 - because if stack is empty there are no elements which we can pop so how we check whether stack
772:11 - is empty or not we call is empty method and we simply check whether top is less than zero or not
772:19 - so when we saw that initially when stop is pointing to minus one the stack was empty the
772:25 - array actually had three values to be inserted because the capacity of array was three
772:31 - so currently value of top is two and it is not less than zero
772:35 - so therefore is empty method will return false let stack is not empty
772:40 - so this block won't get executed and now as we need to pop three from the stack because three was
772:48 - the last element inserted into the stack what we do is we create a temporary variable by name
772:55 - result and we assign value of array top which means that we are assigning it a value which is
773:01 - being hold by second index because value of top is two so we are assigning value three to result
773:11 - and after assigning this value now we can simply decrement top so top becomes one
773:18 - and it looks like that three is popped out from the stack and top is pointing to the element
773:27 - previous to it which is four and at the end we simply return result so value three is written
773:35 - from this method now if we again call pop so now four will be removed we check whether stack is
773:46 - empty or not so value of top is one one is not less than zero so the stack is not empty
773:54 - so a false value will be returned and this if block won't get executed first we will hold the
774:00 - value from the array index one because value of top is one so four is assigned to result
774:07 - then we will decrement top and top becomes zero so it looks like this and if we visualize the stack
774:19 - it looks like four is popped out and top is pointing to eight now which is index zero
774:27 - and we simply return value four that four is popped out from the stack
774:31 - let's say if we again call pop now eight will be removed we check whether stack is empty or not
774:44 - so value of top is zero zero is not less than zero so false value will be returned
774:51 - so this if block won't get executed we first hold the value of the zero index which is eight
774:58 - because top is pointing to zero so result will have value eight
775:06 - we decrement top, top becomes minus one like this and it looks like eight is popped out from the
775:15 - stack and top is actually pointing to minus one and simply at the end we return result as eight
775:25 - that eight is popped out from the stack now here stack is empty so if we again call pop method
775:34 - we first check whether stack is empty or not so here you can see value of top is minus one
775:41 - so top is actually less than zero which signifies that stack is empty so true will be returned
775:48 - and this if block will get executed and we simply throw a runtime exception that stack is empty
775:55 - which signifies that there are no more elements to be popped from the stack
776:02 - so we actually saw pop method which actually removed the element from the stack
776:06 - but there is one more method peak now what this method does is whatever the values hold by top
776:12 - which actually is our last element inserted into the stack so if we don't want to remove this
776:17 - element and we just want to see what is the peak element or what is the last element inserted into
776:22 - the stack we usually call peak method so when we call stack.peak so let's say current condition
776:29 - of the stack is like this that there are two elements eight and four and four was last element
776:35 - inserted into the stack so when we will call peak the first thing we check whether stack is empty or
776:41 - not so value of top is one and one is not less than zero so false will be returned that stack has
776:50 - two elements so this if block won't get execute so here instead of removing the element from the
776:57 - stack we are just returning the value stored at the top index which is at index one and the value
777:05 - is four so this peak method will give us information that which element was inserted last
777:11 - so value four will be returned from this peak method and the element will stay in the stack
777:16 - it won't get removed it is just giving us an information that which is the last element
777:22 - inserted into the stack which is our peak element so friend this was all about implementation of
777:28 - stack using an array i hope you must have liked this video thanks have a nice day
777:35 - hello friends welcome to my new data structures and algorithms in java
777:39 - tutorial series video friends in this tutorial we will discuss
777:44 - how to reverse a string using a stack in java
777:49 - so friends below you can see an algorithm which would reverse a string using a stack in java
777:56 - so friends let's see the demonstration of this algorithm step by step
778:01 - so friends let's suppose we are given a string whose value is a b c d so here we will see the
778:08 - demonstration of the algorithm which would reverse this string using a stack in java
778:15 - so in the first step what we do is we actually create a stack
778:20 - now this stack will hold only the character values
778:25 - so an empty stack is created moving ahead now as we are given with this string a b c d
778:34 - we will first convert it into an character array so in the string class there is a method
778:39 - 2 char array which returns back a character array so it would look something like this
778:47 - that we are now having a character array whose length is 4 and whose values are a b c and d
778:55 - moving ahead
778:56 - so friends here we know that a stack is a leafo data structure which means last in first out
779:04 - and we also discussed in our previous tutorial
779:07 - and how we can represent a stack and we also discussed the push and the pop methods of the
779:12 - stack so the general idea behind the working of stack is the element which goes into the stack
779:18 - last becomes the first one to be removed so in this step what we are actually doing we are
779:25 - providing a for loop which will iterate over each and every character of this char array
779:31 - and then it will simply push it into the stack so in the first iteration the value of c will become
779:38 - a and then we'll simply push the character a into the stack so it would look something like this
779:49 - that now a is into the stack and similarly now c becomes b
779:59 - we will push b into the stack moving ahead now c becomes the character c
780:10 - and we'll simply push the c into the stack
780:12 - and finally c becomes the last value which is d
780:23 - and we will push it into the stack
780:29 - so now as you traverse each and every character of this
780:32 - char array there are no more elements left to be traversed
780:35 - so friends here now in the stack we have four elements the first element which we inserted was
780:44 - a then we inserted b then we inserted c and the last element we inserted is the d
780:52 - so friends now we'll again provide a for loop which will iterate from the value i equal to 0
780:58 - to a value lesser than string dot length so initially value of i is 0
781:06 - and here we can see that the length of the string is 4 so currently i is less than 4
781:15 - so now what we do is we'll pop the elements from the stack
781:18 - and then we'll simply assign it to the respective index from 0 to 3
781:23 - so friends as soon as we call stack.pop the element which is last inserted which is nothing
781:31 - but d will be popped out so it would look something like this so now d is popped out
781:37 - and the value will be assigned to the char array at index 0 which is this position
781:43 - so now it becomes d moving ahead now we'll increment the i so i becomes 1
781:55 - and still the value of i is less than 4
782:00 - now we'll again pop the element from the stack which is nothing but value c
782:07 - and we'll assign it to the char array at index 1
782:10 - so the value index 1 becomes c
782:14 - moving ahead now value of i becomes 2 2 is less than 4
782:24 - we now pop an element from the stack
782:28 - and this value we will assign to the char array at index 2
782:32 - so now at index 2 we will assign the value b moving ahead
782:40 - we'll now increment the i so i becomes 3 and 3 is less than 4
782:48 - so we'll pop an element from the stack
782:52 - so now value a is popped out and it will be assigned to this char array at index 3
782:58 - because value of i is 3 so value of this char array at index 3 becomes a
783:03 - moving ahead now i becomes 4 and so 4 is not less than 4
783:13 - so therefore the condition in for loop comes out to be false
783:19 - and also friends here you can see that using this stack we have actually reversed this
783:23 - char array and the last step will simply return this string by passing in the char array
783:29 - so now it will return a string having a value as dcba
783:37 - so friends in this tutorial we saw how we can reverse a string using a stack
783:42 - in java now let's go to eclipse and see the working of this code
783:47 - so friends in our previous tutorial we actually saw the demonstration of the algorithm
783:51 - to reverse a string using a stack now in this tutorial we'll actually code the algorithm
783:57 - and test the working of it so here i have created one class by name string reverse
784:04 - and inside this class i will create one static method
784:09 - which will return a string and whose name would be reverse
784:17 - now this reverse method will take in a string which we actually want to reverse
784:21 - so friends in our previous tutorial we discussed how we can reverse a string using a stack
784:29 - so here we will create an instance of stack
784:34 - and this stack will hold the character type elements will name it as stack
784:42 - and we will import it from java.util package
784:54 - in the next step what we do is as we are given this string we'll first convert it into character array
785:04 - we'll give name as char and we'll call to char array method of string class
785:11 - which will actually convert this string into an character array and we'll assign it to this
785:16 - char array now we'll simply iterate over this char array one by one
785:28 - and then we'll simply push the character into the stack so stack dot push
785:34 - so whatever the string we have passed this for loop will iterate each and every character
785:42 - of this string and it will push it onto the stack so in the next step we'll again create a for loop
785:50 - now this for loop will iterate from value i equal to zero to i less than string's length
786:04 - and inside this for loop what we'll simply do is we will pop the elements from stack
786:14 - and we will assign it to char's array at the respective index from zero to string length minus
786:20 - one so friends as we know that stack is a leafo data structure so the element which is inserted
786:27 - last will be the first to be popped out so as we have inserted all the character elements one by
786:33 - one into the stack so now when we'll pop it out it will be coming out in the reverse order
786:38 - and then we are simply storing it into the char array and finally we'll simply return
786:48 - a new string by providing this char array into its constructor so after this method
786:55 - gets executed whatever the string we have passed the character inside this string gets reversed
787:01 - so in the main method let's test the working of this code so first we'll create a string
787:10 - we'll give it a value as abcd which we actually discussed in the slide
787:15 - and then we'll simply print this string on the console so this would be before reverse
787:31 - and then we'll print the string after reverse
787:41 - so we'll simply call the reverse method
787:46 - and pass the string to it so whatever the value will be returned from this reverse method
787:52 - it will be printed on the console so let's run this code
788:01 - so friends here you can see before reversing the string it was abcd
788:07 - and after reversing the string it became dcda
788:12 - so friend in this tutorial we saw the algorithm to reverse a string using a stack in java
788:18 - i hope you like this video thanks have a nice day
788:24 - hello everyone so in this video we are going to discuss a problem next greater element
788:30 - so let's see what this problem is and how to solve this
788:36 - so in this problem we are given an array of integers and for each element in the array
788:41 - we need to find its next greater element in that array so the next greater element is the first
788:47 - element towards right which is greater than the current element so let's see it by an example
788:53 - let's suppose we are given an array of integers 4 7 3 4 8 1 now for each element we need to find
789:03 - its next greater element and the next greater element is the first element towards its right
789:10 - which is greater than the current element so here for element 4 it will see in the right direction
789:18 - and it will see which is the first element in right which is greater than 4 so here
789:26 - it sees that 7 is the first greater element than 4 so in the output array we are storing 7 here
789:32 - for index 0 for index 1 we have 7 so 7 sees in this direction and it checks which is the first
789:42 - greater element whose value is greater than 7 so 3 is not greater 4 is not greater but 8 is greater
789:49 - so we store 8 here
789:55 - now for 3 it will look in this direction and it will see that 4 is greater than 3 and it's the
790:02 - first greater element so we simply store 4 here here we are storing it in the respect to indexes
790:12 - now 4 will see in this direction and it will see that 8 is
790:16 - the first element which is greater than 4 so we store 8 here
790:26 - 8 will see in this direction and here 8 will find that no element is greater than 8
790:32 - in the remaining array so we simply store minus 1
790:36 - and similarly with 1 there are no elements left so therefore we directly store minus 1
790:45 - so here for each index we are taking that particular value and we are finding the first
790:52 - element in the right direction which is greater than the current element so we are looking for
790:59 - the first element towards right so for example so for element 4 the first element which is greater
791:07 - than 4 is 7 8 is also greater than 4 but the first element is 7 so we store 7 here which corresponds
791:15 - to this particular index and similarly for 3 4 is the first element which is greater than 3
791:23 - 8 is also greater but 4 is the first greater element so the problem is actually to find the
791:30 - next greater element in the array for any particular index and that should be the first
791:36 - element towards right which is greater than the current element so let's move ahead and see the
791:42 - demonstration of the algorithm step by step so friends before we start in case if you are
791:49 - new to my channel then please subscribe to my channel and click the bell icon so that you never
791:53 - miss any update and i would request you to watch this video till the end so here is the algorithm
792:00 - where the method name is next greater element it takes in an array and it returns an array
792:06 - so the array which is written stores the next greater element of each and every element in the
792:12 - array so let's say we call the next greater element we pass in the array and let's say we
792:20 - pass the array having six elements 4 7 3 4 8 1 not the first step we create the result array
792:31 - we need to return this result array so we are creating a new result array of the same length
792:38 - as of the given array so we call new int we pass array dot length so the result array also has six
792:46 - elements so friends in order to solve this problem of finding the next greater element towards right
792:55 - we take the help of stack data structure so we initialize the stack like this now this is
793:02 - the leafo data structure the element inserted last will be the first one to be removed so we
793:12 - will see that how we can use the stack data structure and find the next greater element
793:17 - for each and every element in the array so friends in this problem we need to iterate each and every
793:27 - element but we will iterate the array from the last index and go till the zeroth index
793:34 - so here we are traversing the array in this direction because this direction will help
793:38 - us in finding out the next greater element towards right so at the start the value of i will be array
793:47 - dot length minus one so array dot length is six because there are six elements if we do minus one
793:55 - we are starting from the fifth index so i will start from the fifth index
794:04 - so friends here you can see that as we are starting from the last index
794:08 - there is no greater element towards its right so therefore we first check whether our stack
794:16 - is empty or not because in the stack we will store some elements which will figure out that
794:22 - which is the greater element towards the right and which is the first greater element towards
794:26 - the right so at the first step we are checking whether stack is empty or not so you will
794:32 - understand this step more clear when we reach to the middle of the array so at the start stack is
794:39 - empty so this condition comes out to be false because stack is empty and then we provide a
794:49 - fls we check whether stack is empty so stack is empty which signifies that there is no greater
794:58 - element for this index to its right so for one there is no element towards its right which is
795:05 - greater than one so we directly store minus one into the result array at index i which is this
795:13 - index so minus one comes here and at the end we just push one onto the stack so why we are pushing
795:24 - one onto the stack is because let's say at index four there could have been value as zero so for
795:32 - zero one would have been its next greater element so we can't discard this one directly we need to
795:40 - push it on the stack for the rest of the elements to compare so we simply push array of i which is
795:50 - one into the stack so one comes into the stack we will decrement i so i becomes four four is
796:02 - greater than equal to zero so this condition is true now here we are checking whether stack is
796:08 - empty or not so stack is not empty so this condition comes out to be true so if stack is
796:15 - not empty that on the stack there could be an element which is greater than the current element
796:21 - we will see how so if this condition is true in the block we are providing a while loop
796:29 - and in the while loop we are providing two conditions with an end that stack should not
796:34 - be empty which is true so here stack.peak is one and the current element at array of i is eight
796:44 - so one is less than equal to eight and stack is not empty so therefore this condition comes
796:52 - out to be true so the while loop will execute so here this condition signifies that for eight
797:05 - eight will see that there is no element in the stack which is greater than eight so therefore
797:11 - it simply removes one from the stack it does stack.pop and why does stack.pop because it
797:20 - sees that in the stack whichever element is present it is actually lesser than the current
797:26 - element which is eight so it discards one because for the rest of the array eight would be the next
797:37 - greater element but one cannot be the next greater element so let's say four four seven is the next
797:44 - greater element for seven eight could be the next greater element but for any of the element
797:50 - one cannot be the next greater element because we have found one element which is actually greater
797:56 - than one which is eight so therefore it discards the element one by popping it out so one gets
798:05 - popped out as it's a while loop it again checks whether stack is empty or not so stack is empty
798:15 - so this condition comes out to be false and this while loop will terminate
798:21 - and for element eight we first check whether stack is empty so here stack is empty which signifies
798:29 - for the value eight there is no next greater element towards its right so therefore this
798:36 - condition is true and into the result array at index i we store minus one because for eight
798:47 - there is no greater element towards its right and then we will simply push eight onto the stack
798:54 - because eight could be the next greater element for the remaining array
799:06 - we will decrement i i becomes three three is greater than equal to zero
799:15 - so for element at index three which is four
799:18 - we check that whether stack is empty or not so if stack is not empty it means there could be a
799:25 - chance that the next element will lie in the stack so this condition comes out to be true
799:32 - stack is not empty and then we will provide a while loop we first check whether stack is empty or not
799:39 - so stack is not empty so this condition is true and we will do stack dot dot
799:47 - we will do stack dot p which will return us the value eight because eight is the topmost element
799:53 - so stack dot p returns eight we will check whether it is less than or equal to the current element
800:00 - which is four so this condition comes out to be false because eight is not less than equal to four
800:10 - so this file loop will terminate so if the while loop terminates at this condition it signifies
800:17 - that there is one element on the stack left and stack is not empty so this if condition also
800:24 - comes out to be false because there is element on the stack which means that four was not able to
800:33 - pop out eight and it was able to find an element which is the first greater element towards its
800:41 - right so whatever is at the top of the stack we will directly store into the result array
800:49 - so at the index of result array we will store stack dot p which is eight so eight comes here
800:57 - directly so for value four eight is the first next greater element towards its right moving ahead
801:06 - we will keep eight as it is on the stack we will not touch it because four was not able to remove
801:13 - it because if we remove it then for seven we will not able to find which is the first next greater
801:22 - element towards its right so we will keep eight on the stack and we will push four on the stack like
801:29 - this and why we are putting four on the stack is because let's say for three though eight is
801:41 - the next greater element towards its right but four is the first next greater element towards its
801:46 - right so therefore we need to still put four on the stack and we don't have to discard it
801:52 - we will decrement i, i becomes two, two is greater than equal to zero
802:06 - we check whether stack is empty or not so stack is not empty so this condition comes out to be true
802:14 - we provide a while loop the first condition is stack should not be empty so stack is not empty
802:20 - so this condition is true and stack.p which is four
802:28 - we will check whether four is less than equal to the current element which is three
802:36 - so this condition comes out to be false so therefore this while loop will terminate
802:41 - so which signifies that three could not pop four out of the stack which signifies that if stack is
802:53 - not empty then whatever is at the top will be the first next greater element for this index
803:03 - which is two so we directly store stack.peak at index two which is four so as three was not able
803:13 - to pop four out so this is the topmost element if we do stack.peak we will get four and we directly
803:22 - store four here so for three four is the first greater element towards its right
803:35 - and then we push three on the stack because let's say if instead of seven if the value would have
803:43 - been two so for two three would have been the first greater element towards its right
803:51 - so we can't discard three so we simply push it on the stack
804:01 - we'll decrement i, i becomes one one is greater than or equal to zero
804:08 - stack is not empty in the while loop the first condition is stack is not empty which is true
804:15 - stack has three elements stack.peak which is three
804:21 - we check whether it is less than or equal to the current element seven so yes this condition is
804:28 - also true so what seven is actually doing it is actually popping out the elements which are
804:35 - lesser than it so that it reaches to an element which is actually greater than it
804:40 - so this while loop does that this both condition comes out to be true
804:47 - so first it pops out three because three is lesser than seven and for seven it could not
804:55 - be the first greater element towards its right so it pops it out stack is not empty and stack.peak
805:05 - which is four now is less than equal to seven so this condition is also true
805:18 - so for seven it will pop four also out of the stack because four cannot be the
805:24 - next greater element of seven towards its right so four gets popped out
805:30 - stack is still not empty and stack.peak which is eight
805:42 - is less than equal to seven so this condition is false now because eight is greater than seven
805:49 - so this while loop will terminate leaving only eight into the stack
805:52 - and if there is some element on the stack, stack is still not empty which means that for
806:04 - index one and element seven we have found one next greater element towards its right
806:11 - which is stack.p which is eight so we directly put eight here into the result array
806:17 - like this using this assignment operator
806:24 - so friends here we saw that seven actually popped out three and four from the stack
806:30 - because if we go beyond seven whatever element we encounter for those elements seven could be the
806:40 - next greater element three and four cannot be the next greater element eight could be a possibility
806:46 - which is already in the stack which we have stored it here but three and four cannot be the
806:51 - possibility for the remaining elements towards its left so we directly discard three and four
807:03 - and we simply push seven on the stack because seven can be a possibility for the remaining
807:09 - elements that it can become the next greater element for the remaining elements
807:13 - we will decrement i, i becomes zero and zero is equal to zero so this condition is still true
807:26 - stack is not empty so this condition is true
807:30 - we provide a while loop stack is not empty and stack.p which is seven
807:36 - is less than equal to four so this condition is false because seven is not less than or equal to
807:45 - four so this while loop will terminate and if stack would have been empty it means for four
807:58 - there would have been no element on its right which would have been greater than four but stack
808:04 - has two elements so therefore whichever element is on the top which is seven we will simply
808:11 - assign it to the result array at the higher index so for four seven is the first greater element
808:20 - towards its right eight is also greater than four but seven is the first element
808:27 - which this stack help us to figure out so we directly assign seven here
808:35 - and then we simply push four on the stack as there are no more elements left for i to travel
808:42 - but still we push four on the stack we will decrement i so when we will decrement i
808:51 - i will become minus one it will reach here so minus one is not greater than or equal to zero
808:57 - so this for loop will terminate because this condition comes out to be false
809:03 - and at the end we will simply return the result array
809:12 - so friends here you saw that how we can solve the next greater element problem
809:16 - using a stack now as stack is last in first out it actually help us in finding out the next
809:22 - greater element towards right for any particular index so friends i hope you must have liked this
809:29 - video in case if you're new to my channel then please subscribe to my channel and click the bell
809:34 - icon so that you never miss any update also please like this video and share it with your
809:41 - friends and colleagues thanks have a nice day hello everyone so in this video we are going to
809:48 - discuss a problem of valid parenthesis so in this problem we are given a string as now this string
809:58 - only contains the brackets which are opening and closing brackets so we can have round square and
810:06 - curly brackets we need to determine whether the input string is valid or not so an input string
810:12 - is valid if open brackets must be closed by same type of brackets open brackets must be closed in
810:19 - correct order so let's say we are given with an input string like this
810:27 - and we need to find out whether this input string is valid or not so the input string is valid if
810:34 - open brackets must be closed by same type of brackets so here you can see this is opening
810:40 - curly bracket this is opening round bracket open brackets must be closed in correct order so here
810:46 - we have opening curly bracket and then we have opening round bracket so if we go ahead we have
810:52 - a closing round bracket so this much part is valid because this opening round bracket is closed by
811:00 - same type of bracket and this is also in correct order and at the end we have one curly bracket
811:06 - so this opening curly bracket is being closed by the same type of bracket and dead to in proper
811:13 - order so this complete string is valid now let's say we are given an input string like this
811:21 - this is opening curly bracket but it is closed by a different type of bracket which is the square
811:27 - bracket so this is not a valid string now let's say if you have input string like this
811:34 - we have a opening curly bracket it is followed by opening round bracket
811:39 - and then we have a closing round bracket so this much part is valid because this closing round
811:44 - bracket is being matched with the opening round bracket but after that we don't have any character
811:50 - so we are left with one opening curly bracket it doesn't have its closing bracket of same type
811:57 - so therefore this is an invalid string now let's say if we have string like this
812:02 - so at the start only we have a closing curly bracket so therefore we can directly say that
812:08 - it's an invalid string because our input string is valid where open brackets must be closed by
812:14 - the same type of brackets and these open bracket must be in correct order so this is an invalid
812:20 - because at the start only we have a closing curly bracket so how we can solve this problem is we can
812:27 - use a stack data structure now let's see the demonstration of this algorithm step by step
812:34 - using a stack so friends before we start in case if you're new to my channel then please subscribe
812:40 - to my channel and click the bell icon so that you never miss any update so here we have a method
812:47 - is valid which takes the input string and returns a boolean value true or false which states that
812:54 - this string is valid or not so first we will see the negative scenarios where we are actually
813:00 - returning false one is here here and here if stack is not empty so if we call is valid method
813:10 - with passing in one closing curly bracket followed by a opening curly bracket so s will be
813:17 - this string we will first create a stack so here stack is leafo data structure where element which
813:26 - goes last will be the first one to be removed so you can watch my stack tutorial to understand
813:31 - more about this data structure so here the main idea is to iterate each and every character of
813:38 - this string so first we'll convert this string into character array and then we will iterate it
813:43 - through the variable c so when we will call two char array method we get something like this
813:51 - we get a character array where each character is stored at a particular index now this for loop
813:57 - will start with the closing curly bracket so c becomes the closing curly bracket
814:03 - so here as we know that the string is valid we must have opening brackets at the beginning
814:12 - and whenever we encounter any opening brackets we simply push it on the stack
814:17 - so currently here you can see that we have a closing curly bracket so this if block conditions
814:23 - comes out to be false because c is not equal to any of this opening bracket
814:28 - so the else part will be executed now in the else part the first thing we simply check is
814:36 - whether stack is empty or not so why we are checking whether stack is empty because it
814:41 - simply signifies that there is no character in the stack which is opening bracket and we have reached
814:48 - to the else block and we have found that stack is empty it means whatever value c will have
814:54 - it must be the closing bracket so therefore we can directly return false
815:01 - and which is actually true because c value is closing curly bracket because if we have
815:06 - opening bracket then that must be pushed on the stack and stack must have some elements in it
815:13 - but if c is not equal to the opening bracket so in the else part the first step we check is whether
815:19 - stack is empty or not because if stack is empty then we have one closing bracket and there is no
815:26 - element on the stack which we can pop out and match it with the closing bracket so we can return
815:32 - false you can understand more on this in our upcoming examples so currently we return false
815:39 - because the input string is not valid it is actually getting started from the closing bracket
815:44 - now let's say if we are given with this string
815:53 - so as becomes the opening curly bracket and a closing square bracket we create the stack
816:02 - we create the char array so for the first iteration c value will be the opening curly bracket
816:08 - so here you can see that for the first step till zero index the condition holds good because we
816:17 - have a opening bracket so c is actually equal to a opening curly bracket so we simply push c on the
816:27 - stack so this opening curly bracket comes on the stack now c moves to the next character
816:34 - which is closing square bracket c is not equal to any of these opening brackets so the else part
816:44 - will be executed now stack is not empty so this condition comes out to be false and the else part
816:51 - will be executed so friends the main idea behind pushing the opening bracket onto the stack is
816:58 - in the else part we will first pick the topmost element so when we will call stack.peak whichever
817:05 - element is on the top of the stack that value will be returned from this method so currently top will
817:12 - point to the opening curly bracket like this and why we are actually looking into the topmost
817:19 - element on the stack is because we need to check whether this opening bracket is actually
817:25 - close by the same type of bracket or not so here you can see now we provide three conditions here
817:32 - separated by a or so if any of the condition comes out to be true then this if block will be
817:38 - executed so here simply the condition is if on the top of the stack we have a round bracket
817:45 - and the currently visiting element which is c is closing round bracket it means it's a match
817:52 - and similarly with the other two brackets so therefore we are looking for the topmost element
817:58 - in the stack because we have to match the brackets of the same type in correct order
818:05 - so here you can see top is equal to the opening curly bracket but c is equal to closing square
818:12 - bracket so therefore no condition comes out to be true so this overall if condition comes out to be
818:18 - false so the else part will be executed and we can return false because for this opening
818:27 - curly bracket the element which is next to it is closing square bracket which makes it a invalid
818:34 - string so therefore we can return false directly moving ahead let's say we are given with this
818:44 - string so s holds this string we will create a stack we will generate the char array
818:54 - like this so the first c value will be the opening curly bracket
819:03 - in the first if condition we are checking that if we have a opening bracket then we simply push it
819:09 - on the stack so c is actually equal to the opening curly bracket so we push it on the stack
819:17 - now we have pushed something on the stack so in the next iteration c will become
819:25 - the opening round bracket
819:31 - now c is equal to opening round bracket so we know that we need to push it on the stack
819:35 - so this opening round bracket comes like this
819:42 - now c moves to the third character which is the closing round bracket
819:51 - so c is not equal to any of the opening bracket so this if condition comes out to be false
819:58 - in the else part we first check whether stack is empty or not so if stack is empty it means we are
820:04 - straight away getting one closing bracket and it is not having any of its opening bracket before
820:11 - that so we can directly return false if the stack is empty so currently on the stack we have two
820:17 - elements so the else part will be executed first we will check out for the top element by calling
820:23 - stack.peak so if we see the top of the stack we will have a opening round bracket so top will be
820:30 - equal to opening round bracket now here you can see that top is equal to opening round bracket
820:38 - and c is equal to closing round bracket so therefore it's a match here you can see it's
820:43 - a match so the element on the stack which is top is this and the current element c is this
820:51 - so it means we have found one matching brackets which are opening and closing and are in correct
820:57 - order so therefore the first if condition comes out to be true and the overall if condition
821:03 - comes out to be true because we have a or operator here so it means we have found one match which is
821:10 - the correct match so we can simply pop this element out because it's matching pair we have
821:15 - already found so it gets popped out so now here you can see that we have visited all the
821:24 - elements of this char array so this for loop will terminate and here you can see at the end
821:33 - what we return is we check whether if stack is empty or not because if stack is empty it means
821:40 - we have found all the proper matching brackets and the string is valid but here you can see in the
821:46 - stack we are left with one opening curly bracket for which we didn't find its same type of bracket
821:54 - so therefore stack is not empty so stack.empty returns false so we can directly return false
822:00 - stating that this input string is not valid
822:06 - now here we will see one more example which is a proper valid string so as becomes this
822:14 - we create a stack
822:20 - we create the char array like this and in the for loop c will point to the opening curly bracket first
822:32 - so this condition is true so we can push c on the stack
822:38 - so this opening curly bracket is on the stack
822:40 - the next element is the opening round bracket so c becomes opening round bracket
822:52 - c is equal to opening round bracket so we can push it on the stack like this
823:02 - now we'll move to the next character
823:03 - so c becomes the closing round bracket so this overall condition is false because c is
823:13 - not equal to any of the opening bracket
823:18 - stack is not empty so this condition comes out to be false
823:23 - now first we will see the topmost element on the stack by calling stack.peak
823:29 - so top will become equal to closing round bracket like this
823:35 - and then we will provide a if condition we will check whether top is equal to any of the opening
823:41 - bracket so currently it's opening round bracket and the current element which is c whether it's
823:49 - the same type of closing bracket so your c is equal to closing round bracket like this
823:55 - so this much string is valid so the first condition comes out to be true
824:02 - so we simply pop this element out because its matching bracket has been found
824:12 - moving to the next character
824:15 - now c becomes the closing curly bracket
824:20 - this condition is false because we have a closing bracket
824:22 - stack is not empty
824:27 - we will first see the topmost element on the stack by calling stack.peak
824:31 - so top will be equal to the opening curly bracket like this
824:37 - so the first condition is false because top is not equal to opening round bracket
824:44 - and c is not equal to closing round bracket
824:47 - the second condition comes out to be true because top is equal to the opening curly bracket
824:53 - here and c is equal to closing curly bracket so it looks something like this
824:59 - this is our top and this is our currently element which is c so it's a match of the same type of
825:07 - brackets so this much part is valid so this condition comes out to be true so the overall
825:13 - if condition comes out to be true so we will simply pop this element out
825:23 - now we have visited all the elements in this char array so this for loop will terminate
825:30 - and here you can see at the end stack is empty so stack dot is empty material return true
825:38 - so therefore it means that this is actually a valid string
825:43 - so friend this was all about the problem valid parenthesis where we can figure out
825:48 - that whether brackets are actually balanced or not that is the opening brackets is being matched
825:54 - with the closing bracket of the same type and also in the correct order
826:00 - so friends i hope you must have liked this video in case if you are new to my channel
826:04 - then please subscribe to my channel and click the bell icon so that you never miss any update
826:09 - thanks have a nice day
826:14 - hello friends welcome to my new data structures and algorithm in java
826:18 - tutorial series video friends in this tutorial we will discuss how to represent a queue in java
826:28 - so friends what is the queue so here queue is a data structure which is used for storing the data
826:35 - and it's an ordered list in which insertion are done at one end called as rear and deletion
826:40 - are done at other end which is called as front so friends if you see an example below then this
826:46 - is a linked list where the first node is referred by the front variable and the last node is referred
826:52 - by the rear variable so here queue follows a basic structure where insertion are done at one end which
827:00 - is called as rear so whatever we insert in the queue we insert at the end which is referred by
827:06 - the rear and whatever the deletions are done we use the front variable to make the delete
827:13 - so basically is a type of linked list where we keep two pointers one is front and one is rear
827:20 - and usually the front points to the first node and rear points to the last node
827:24 - and this linked list follows a certain pattern in which whenever you want to insert an element
827:31 - we basically insert at the end and whenever you want to delete any element we usually use the front
827:37 - end so friends queue is also called as fifo list which is first in first out list so here what we
827:45 - do is the first element inserted is the first one to be deleted so friends queue is a list which
827:51 - follows certain restrictions that whenever we want to insert an element we will use the rear end
827:58 - and whenever you want to remove an element we will use the front end so therefore we can see it's a
828:04 - first node so it means this node was inserted first and if you see whatever the nodes coming
828:10 - after that follow a sequence of removal therefore it's termed as fifo which is first in first out
828:16 - so the node inserted first will be the first one to be removed
828:21 - so let's quickly see the demonstration how queue works
828:27 - so friends queue is a list which follows certain restrictions that we will enter the nodes from
828:32 - one end and we will exit the node from other end so therefore so therefore it forms a fifo list
828:40 - where the element inserted first would be the first to be removed
828:43 - so let's see a quick demonstration so initially if you see queue is empty and there are no nodes
828:52 - so when a queue is empty front points to null and the rear points to null
829:01 - now if you want to insert any element into a queue we basically use an in queue operation
829:06 - now let's say we use an in queue operation and we want to insert a node having data as 20
829:14 - so here if you want to insert this node having data as 20
829:18 - then we know that there is only one end where we can insert
829:23 - so it looks something like this
829:28 - and once this node is inserted
829:33 - the front and the rear both points to this particular node
829:37 - and as in previous slide we discussed front points to the first node and the rear points
829:41 - to the last node so friends currently the queue is only one node therefore front and rear are both
829:47 - pointing to this particular node because this is the first and the last element both
829:55 - now let's suppose we want to insert one more element having data as 10
830:01 - so it would look something like this
830:04 - that elements are inserted at one end and we basically use the rear end to insert the element
830:10 - so when we insert an element now rear will point to the node which was last inserted
830:18 - moving ahead now let's say we want to insert a node having data as 15
830:24 - so it would look something like this
830:29 - so when the node is inserted now rear points to that particular node
830:32 - so friends here currently queue is three nodes 20 10 and 15 where 20 is the first node
830:44 - therefore it's been referred by front node and 15 is the last node therefore it is being referred
830:50 - by the rear node now let's say we want to remove an element so in order to remove an element we use
831:00 - the dq operation so friends as we know that queue follows a basic restriction that the
831:07 - nodes are inserted at one end and they are removed from the other end so in order to achieve that
831:12 - what we do whenever we insert any element we usually insert it using the rear end and whenever
831:18 - we remove an element we use the front end so let's see when we call this dq operation
831:24 - so the node which is referred by the front will be removed first so it would look something like
831:31 - this and once the node is removed now front will point to the node just after it and suppose we
831:42 - again call dq operation so it would look something like this and now front will point to the node 15
831:55 - and we again call a dq operation so it would look something like this
832:05 - and now as there are no element into the queue therefore front end real both will point to null
832:12 - so friends here we saw that when we inserted three nodes
832:16 - 20 was the first node so therefore 20 became the first node to be removed
832:22 - so therefore it follows a fifo structure that the node which was inserted first
832:27 - was the first one to be removed so basically queue follows these restrictions that that
832:33 - whenever a node is inserted first it becomes the first one to be removed
832:38 - so friends this is how we represent a queue so in my next tutorial we will see how we can
832:43 - implement a queue in java i hope you like this video please like comment share and subscribe my
832:49 - youtube channel thanks have a nice day hello friends welcome to my new data structures and
832:56 - algorithm in java tutorial series video friends in this tutorial we will discuss
833:03 - how to implement a queue in java
833:07 - so friends in my previous tutorial we discussed what is a queue
833:12 - and we know that it's a linear data structure used for storing the data
833:16 - and here we also saw that it's an ordered list in which insertion are done at one end which is
833:22 - called as rear and deletion are done at other end which is called as front
833:27 - so in my previous tutorial we discussed how we can use this front and rear end to insert
833:33 - and remove the elements from a queue and we also discussed that queue is a fifo list
833:40 - which is first in first out that a node inserted first will be the first one to be deleted
833:47 - so friends in this tutorial we will discuss how we can implement a queue
833:51 - so basically when we implement a queue we usually keep two list node by the name front and rear
834:00 - we insert using the rear list node and we remove using the front list node
834:05 - so friends let's go to eclipse and see the implementation of a queue
834:13 - so friends here i have created one class by name queue
834:18 - having an empty main method so in this class we will implement how a queue works
834:27 - so friends in order to implement a queue we need to create few instance variables
834:32 - so as we discussed in slide so queue contains a front node and a rear node
834:38 - so those two nodes are basically of type list node
834:43 - so here we'll create one list node and we'll give name it as front
834:53 - we'll also create one more list node
834:55 - and we'll give it a name as rear
835:04 - and we'll also create one integer variable
835:10 - now this integer variable will store the size of the queue
835:16 - so friends as we discussed in slide that queue is basically a list therefore internally it uses
835:21 - list nodes so here we will create one inner class of type list node so private class list node
835:36 - and friends as we discussed in our previous tutorials how we can represent a list node
835:41 - so in a list node we basically keep two things one is the data part and other is the reference
835:47 - to the next list node so private int data and other is the reference to next list node
836:06 - we will also create one constructor public list node
836:12 - now this constructor will take in a data part so int data
836:23 - and we'll simply assign this data to this dot data
836:33 - and this dot next will have null value
836:38 - so friends here we saw a queue has two list nodes one is represented by front another is
836:46 - represented by rear below we'll create one method as public int length
836:59 - now this method will return us back the length of the queue
837:02 - we will also create one boolean method public
837:10 - boolean and we will give it a name as is empty
837:19 - so friend this method will return us a boolean value that whether a queue is empty or not so
837:25 - we'll simply return length is equal equal zero so if length is zero then this method will return
837:34 - us true and if length is greater than zero then this method will return us false so friend this
837:42 - is how we implement a queue using the front and rear list node in my next tutorial i will
837:48 - demonstrate how we can insert an element into a queue and how we can remove an element from a queue
837:53 - so friends i hope you like this video please like comment share and subscribe my youtube channel
837:59 - thanks have a nice day
838:03 - hello friends welcome to my new data structures and algorithm in java tutorial series video
838:10 - friends in this tutorial we will continue with the implementation of a queue in java
838:16 - and in this tutorial we will discuss how to insert an element in a queue in java
838:23 - so friends in this tutorial we will discuss how to insert an element into a queue
838:28 - and if you see below is the algorithm to insert an element into a queue
838:33 - in our previous tutorials we discussed that queue is a type of a linked list
838:38 - which has some restrictions that it is considered as fifo list which is first in first out list
838:45 - so by first in first out we mean the element inserted first would be the first one to be removed
838:51 - and in this tutorial we will discuss how to insert an element into a queue
838:55 - so let's see the demonstration of this algorithm step by step
839:00 - so friends when we initialize a queue we know that the queue is empty and there are no elements
839:05 - so when a queue is empty and there are no elements
839:09 - so in this situation the front node and the rear node both points to null
839:13 - so here you can see currently queue is empty so therefore front is pointing to null and rear is
839:20 - pointing to null and we also know that as queue is empty and there are no nodes so the length is also
839:27 - zero so friends let's suppose we want to insert an element having the data as 10 so we will call
839:34 - incue function so let's see the demonstration how this method works now as we call the incue method
839:42 - and we pass the value of 10 into it we know that the data is equal to 10
839:49 - so currently data is pointing to 10 moving ahead
839:55 - now in order to insert an element into a queue what we do we first create a temporary list node
840:01 - having the data which we have passed into the method so it would look something like this
840:06 - now here you can see that it is a basically list node having data as 10 where temp is pointing to
840:14 - this node and its next is pointing to null so this is the node that we want to insert into a queue
840:23 - moving ahead now in the first step we check whether the queue is empty or not
840:29 - so currently if you see front is pointing to null and rear is also pointing to null
840:34 - and length is zero so therefore the queue is empty so the condition in if block comes out to be true
840:46 - now in the if block what we do in order to insert this temporary node into the queue
840:51 - we simply assign the value of temp to front so it would look something like this
840:56 - so now front is pointing to this node having data as 10 so friends in our previous tutorial
841:05 - we discussed that when a queue is empty and if we want to insert an element then after an insertion
841:10 - we know that the queue is only one element therefore front and rear both point to that
841:15 - particular node so here we simply check that whether queue is empty and if it is empty
841:21 - then we'll simply assign the value of temp to front so you can see now front is pointing to
841:27 - this particular node moving ahead now after the if else block we simply assign the value of temp
841:37 - to rear so friends here we know that after the insertion of this node queue is one element so
841:43 - if the queue is one element then we know that front and rear both point to that particular node
841:49 - because the queue contains the only node which is first and the last node both
841:54 - so therefore in this step it would look something like this
841:59 - that rear is pointing to the node having data as 10 and front is also pointing to the node
842:04 - having data as 10 moving ahead now in the last step as we have inserted this node into the queue
842:13 - we noted length of this queue is one so therefore we will increment the length by one
842:21 - because this queue contains now one element moving ahead
842:27 - so when this method is executed the queue looks something like this the front and rear both point
842:34 - to this particular node and whose next is pointing to null and we also know that length is one
842:40 - now suppose if you want to insert one more node having data as 15 so let's see the algorithm once
842:49 - again so in the first step we know that data is 15 moving ahead
842:58 - so friends in order to insert the node having data as 15 first will create a temporary list
843:04 - node which has data as 15 and whose next will point to null so it would look something like this
843:11 - so here you can see temp is pointing to this list node whose data is 15 and whose next is null
843:17 - moving ahead
843:20 - now in the fblog we will check whether queue is empty or not so currently queue has one node
843:25 - therefore it's not empty so the else part will be executed
843:35 - so in the else part what we do we simply assign the value of temp to rear.next
843:41 - now friends in our previous tutorial we know that whatever the nodes we want to insert
843:45 - into a queue we always use the rear end of it this is because queue follows some restrictions
843:52 - that the nodes are inserted at one end and they are removed from the other end so in this case
843:57 - if you are inserting a node then we are always using the rear end so therefore we are assigning
844:02 - the value of temp to rear.next so currently if you see rear next is pointing to null and if you want
844:09 - to insert this node having data as 15 we need to remove this link and we need to point this link
844:15 - to this temp node therefore we are assigning temp value to rear.next so it would look something
844:22 - like this now first this link will be removed and then we'll create one link from first node
844:30 - to second node so it is nothing but we are assigning value of temp to rear next moving ahead
844:39 - so friends we know that we are inserting an element at the rear end and this rear node will
844:44 - point to the last element of the queue so currently we have inserted this node into the queue
844:50 - but we are not pointing rear to this node because this is the last node so in order to do that we
844:56 - are simply assigning value of temp to rear so it would look something like this
845:03 - so now as you can see front is pointing to the first node and rear is pointing to the last node
845:09 - and this is the property which queue follows moving ahead
845:15 - now as we are inserted this node into the queue we know that the queue has now two elements
845:21 - therefore we'll increment the length by one so now length becomes two
845:29 - and finally when this method is executed the queue looks something like this that front is
845:35 - pointing to the first node and rear is pointing to the last node and we have inserted this node
845:41 - using the rear end moving ahead now let's suppose we want to insert one more element having data as
845:49 - 20 so in the first step we know that data is 20 moving ahead now in order to insert data as 20
846:01 - we will first create a temporary list node so now this temp node is pointing to a list
846:08 - node having data as 20 and who's next is pointing to null moving ahead
846:15 - so the if log we will check whether queue is empty or not so currently queue is not empty because
846:20 - length is two and we have two nodes already in the queue so the else part will be executed
846:31 - so in the else part what we do we simply assign the value of temp to rear dot next
846:36 - so we are doing this step is because we want to insert this node into the queue and we know that
846:42 - the elements are inserted into queue at one end which is called as rear end
846:47 - so therefore we are assigning value of temp to rear next so currently rear next is pointing to null
846:55 - and in order to insert this node into the queue we'll we have to remove this link
847:00 - and we have to assign this link to temp node so therefore we are simply assigning value of temp
847:06 - to rear dot next so it would look something like this so first this link will be gone
847:12 - and then we'll assign the value of temp to rear next so it would look something like this
847:19 - moving ahead and now as we have inserted the node into the queue we know that the node with
847:26 - the data 20 is the last node so therefore we'll simply assign the value of temp to rear
847:32 - because we know that rear points to the last node in the queue so it would look something like this
847:40 - moving ahead and in the final step we'll increment the length by one because now we have three nodes
847:48 - so the length becomes three and once this method gets executed
847:57 - queue looks something like this that front points to the first node and rear points to the last node
848:03 - and we also know that length is three because we have three nodes into the queue
848:07 - so friends this was the demonstration of how to insert an element into a queue
848:12 - now let's go to eclipse and see the working code
848:18 - so friends in my previous tutorial i had created one class by name queue
848:22 - and into that queue we created two list nodes one by name front and one by name rear
848:28 - and we also created one integer instance variable by name length so basically list node front will
848:35 - point to the first element into the queue and list node rear will point to the last element
848:40 - into the queue and as we are discussing the in queue operation we know that we are inserting
848:46 - the element from the rear end and we also discussed that queue has few methods by name
848:52 - length which was actually returning the length of the queue and when boolean method is empty
848:58 - which was returning true if the list is empty and false if the list is not empty
849:04 - so in this tutorial we will simply see how we can insert an element into a queue
849:07 - so we'll create one method as public void in queue
849:21 - and this method takes in a integer data
849:26 - now friends in the first step we'll create the temporary list node
849:30 - and we'll pass the data into the constructor
849:41 - so in the first step we are creating a temporary node which we discussed in the slide
849:46 - moving ahead we'll provide an if else block so in the if we'll check that is queue empty or not
849:56 - so if the queue is empty we are simply assigning the value of temp to front
850:06 - and if the queue is not empty then we are simply assigning the value of temp to rear.next
850:18 - moving ahead after if else block we are simply assigning the value of temp to rear
850:26 - as we discussed in the slide and in the last step we are incrementing the length by one
850:34 - so friend this is the enqueue operation which we discussed in the slide
850:39 - and in this class i will also create one constructor for the queue so public queue
850:50 - so when we initialize any queue we know that
850:52 - front is pointing to null and rear is also pointing to null and length is zero
851:13 - so friends in order to demonstrate how enqueue operation works
851:17 - i will create one more method which will actually print the elements of the queue
851:22 - so here i create one method as public void print
851:32 - and in the print method we'll check if if queue is empty
851:40 - it means it has no node to print so therefore we'll simply return from the method and if the
851:47 - queue is not empty then we'll traverse each element into the queue and we'll print it on
851:52 - the console so in order to print the elements on the console we'll first create a list node
851:58 - current and we'll assign the value of front to it so here as we know that we are implementing
852:05 - a queue with a linked list therefore we are printing the element from the first node to
852:10 - the last node so therefore in order to traverse each and every node we are first initializing
852:16 - the current with the value of front and then we are providing a while loop
852:23 - and inside this while loop we are traversing the current till it becomes null so in the first step
852:32 - we are simply printing the elements on the console so current dot data
852:39 - and then we are simply incrementing current to its next position by assigning
852:50 - current dot next to current and after the current encounters a null value
852:58 - then we are simply printing null
853:00 - so friends let's test the working of in queue method in the main method
853:11 - so here first i will create an instance of queue
853:18 - and when we create an instance of queue we know that queue is empty
853:22 - therefore front and rear both points to null so friends let's insert few elements into the queue
853:30 - so we'll call in queue method and we'll pass the value as 10 and let's say i print
853:38 - the queue on the console so if i run the code now
853:47 - so you can see it printed 10 and null so as the queue was empty when we inserted
853:53 - node having data as 10 so this was the only node so therefore it printed 10 and null
853:59 - now let's insert one more node
854:03 - and if i give the data as 15 and if i run the code now
854:10 - so you see it printed 10 then 15 and then null so here you see queue as two nodes where the first
854:16 - node is pointing 10 and second node is pointing 15 and here you can see we are inserting the
854:22 - node at the one end which is the rear end so therefore first 10 was inserted and then 15 got
854:28 - inserted so if i insert one more node say 20 and if i run the code now
854:42 - so you can see that using the rear end we are inserting the element at the end
854:46 - so friends currently queue has three elements with the data as 10 15 and 20
854:54 - and in this tutorial we'll discuss how to insert an element into a queue
854:58 - so friends in my next tutorial i will discuss how we can remove an element from the queue
855:04 - and we'll discuss the dequeue operation i hope you like this video please like comment share
855:10 - and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data
855:18 - structures and algorithm in java tutorial series video friends in this tutorial we will continue
855:24 - with the implementation of the queue in our previous tutorial we discussed how to add an
855:31 - element in a queue in java so in this tutorial we will discuss how we can remove an element
855:36 - from a queue in java so friends in my previous tutorial i added three elements into the queue
855:44 - by data as 10 15 and 20 so in this tutorial we will discuss how we can remove an element
855:50 - from a queue which is nothing but the dequeue operation so here i will take the same example
855:57 - and you can see that queue has three elements where front is pointing to the first node
856:02 - and rear is pointing to the last node and length is three
856:08 - so here you can see this is the algorithm for a dequeue operation
856:11 - now let's see the demonstration of this algorithm step by step
856:17 - now in the first step we will check that whether queue is empty or not
856:22 - so currently if you see length is three and we know that the queue contains three nodes
856:27 - therefore queue is not empty so the condition in if block comes out to be false
856:35 - now friends as we want to remove an element from a queue so here you can see the return type of
856:40 - dequeue method is integer type we are actually removing an element from the queue and we are
856:45 - sending back the data part of it so in order to store the data somewhere we are creating an
856:52 - integer variable by name result and we are storing front.data into it
856:58 - so friends in my previous tutorial we discussed that queue is a list with few restrictions where
857:04 - the elements are inserted at one end which is the rear end and elements are removed at one end which
857:10 - is the front end so friends the restriction which we impose on a list makes it a queue
857:16 - and therefore the queue is called as FIFO list which is first in first out so here you can see
857:22 - by first in first out we mean the element inserted first would be the first one to be removed
857:28 - so in my previous tutorial we discussed when we inserted the elements into the queue
857:33 - we inserted first 10 then we inserted 15 and then we inserted 20 using the rear end
857:40 - now in order to remove an element we know that 10 was inserted first so now 10 would be removed
857:46 - first so this is nothing but a FIFO property first in first out so let's see how we can use
857:53 - the front end to remove the nodes which are inserted first so here after this name gets
857:58 - executed results hold the value of 10 because the node 10 was the node first inserted into the queue
858:06 - therefore this node will be removed first moving ahead now friends in order to remove this node
858:15 - from a queue we know that it is being referred by this front node and if you break the link from
858:21 - front to this node then this node can be removed easily so in order to do that what we are doing
858:29 - we are simply assigning the value of front dot next to front so here you are simply assigning
858:35 - front next value to front so that once this node is removed 15 becomes our new front so therefore
858:42 - we are simply assigning the value of front dot next to front so it would look something like this
858:51 - moving ahead then we are checking whether the front is equal to null or not
858:58 - so currently you can see front is pointing to the second node therefore it's not null
859:03 - so the condition in if block comes out to be false moving ahead
859:07 - so friends as we have removed the reference of front from this node therefore this node will be
859:15 - garbage collected and you can see once this node is removed we will decrement the length by one
859:22 - so currently the length is three and after the removal of this node length becomes two
859:28 - so we simply decrement the length by one moving ahead and in the final step we'll simply return
859:36 - the value of stored in the result
859:41 - so friends when the dequeue method is executed the queue has two elements and length is two
859:47 - now friends let's suppose we call dequeue method once again
859:54 - so here first we check whether the queue is empty or not so currently queue has two nodes
859:59 - therefore it's not empty and then we'll simply store front dot data into the result
860:07 - so it would look something like this that we are storing the data into the list node which is being
860:12 - pointed by the front so now result contains the value of 15 moving ahead
860:20 - now in order to remove this node from a queue we have to break this link because if front is
860:26 - referring to this node then this node would not be removed so in order to break this link we are
860:31 - simply assigning front dot next value to front so it would look something like this
860:42 - moving ahead then we are checking whether front is equal to null or not
860:48 - so front is pointing to this third node therefore it's not equal so the condition in if block comes
860:52 - out to be false and here as we have removed the link of front to this node so now this node has
861:00 - no reference to it therefore it will be removed easily we know that now queue has only one element
861:06 - therefore we will decrement the length by one moving ahead and in the final step we'll simply
861:15 - return the value stored in the result which is 15
861:24 - so friends when the dq method is executed queue has only one element where front and rear both
861:31 - point to that particular element because this is the only element left now if we suppose call dq
861:38 - again so first we'll check whether queue is empty or not so currently queue has length
861:46 - one that means it has one node therefore it's not empty so the condition in if block comes out to be
861:52 - false then we'll simply store the value of front dot data into result because we want to return
862:00 - this value so now result will hold the value as 20 moving ahead
862:08 - now friends we need to take an special care when we remove the last element from a queue
862:13 - because if the queue contains only one element and if we want to remove that particular element
862:18 - then we need to break two links one is of front and other is of rear because if any of the link
862:25 - is referring to this node then this node would not be removed so therefore here we are simply
862:31 - assigning the value of front dot next to front so it would look something like this
862:38 - so now front is assigned with its next value which is null
862:42 - moving ahead now we'll check whether front is pointing to null or not so currently if
862:49 - you see front is pointing to null therefore the condition in if block comes out to be true
862:56 - and as we discussed that we need to break both the links in order to free this node
863:01 - so therefore we'll simply assign the value of null to rear so now this link will be removed
863:07 - so it would look something like this
863:12 - so now front and rear both are pointing to null
863:17 - so friends as this node is having no reference therefore this node will be freed easily
863:22 - so once this node is removed we'll decrement the length by one because we know there are no
863:27 - elements left so we'll simply decrement the value of length by one so now length becomes zero because
863:34 - we have removed all the nodes so in the final step we'll simply return the value 20
863:45 - so friends once this method gets executed this node gets freed up
863:49 - and as we know that now front and rear both pointing to null therefore
863:57 - the list is empty and length is zero so friends if we again call dq method
864:06 - then the first step we'll check whether q is empty or not so here you can see front is pointing to
864:12 - null rear is pointing to null and we also know the length is zero therefore q is empty so there
864:18 - are no elements left to be removed so the condition in a block comes out to be true
864:24 - and we'll simply throw in no such element exception because there are no elements left to be removed
864:34 - so friends in this slide we discussed the demonstration of the dq method
864:38 - now let's go to eclipse and see the working code
864:41 - so friends in my previous tutorial i created one class by name q we created few instance variable
864:50 - of type list node one of which was front another was rear we also created an integer variable
864:57 - which actually stored the length of the q and then we have created few methods one was length
865:05 - is empty and inq so basically we created inq method which could insert the elements into the
865:12 - q and here if you see and we also saw that we have added three elements and when we printed the q
865:21 - it printed something like 10 15 20 so so i will take the same list and we'll perform dq operation
865:32 - on it so first let's write the dq method so public we know that the return type of it would
865:41 - be integer so int tq now the first step we do is we check whether the q is empty or not so is empty
865:57 - now if the q is empty we know that there are no more elements left to be removed therefore
866:06 - we throw an exception as no such element exception
866:14 - and we pass a string as q is already empty
866:29 - moving ahead now we know that when we remove an element from a q we are returning the data part
866:36 - so therefore we'll create an integer variable by name result and we'll store front data to it
866:46 - moving ahead now as we have got the data of the front node we'll simply traverse front to its
866:53 - next value by assigning front next to front and then we simply check whether front is equal to
867:05 - null or not so if front is equal to null we know that we have to make rear also null which we saw
867:12 - in the slide moving ahead now as we are removed the node from a q we have to decrement the length
867:21 - by one and finally we are returning the result so friend this is the code for dq method whose
867:31 - demonstration we saw in the slide now let's test the working of this method so initially we have
867:38 - inserted three nodes now let's say i dq one node and then i print the q again so if i run the code
867:55 - so you can see when we inserted three nodes first 10 was inserted then 15 got inserted then
868:05 - 20 got inserted so the insertion was at the rear end now when we are doing a dq
868:11 - 10 was removed because we are removing a node from the other end which is the front end
868:16 - so thus q is a fifo list where we insert the node at one end which is the rear end and where we
868:21 - removed the node from the other end which is the front end so now as you can see 10 was the first
868:27 - element to be inserted therefore it got removed first now if i call dq again
868:40 - so here you can see 15 also got removed and if i call dq once again
868:52 - so here you can see nothing got printed because we have removed all the elements from the q
868:57 - and when we printed the list we can see when the list is empty we are simply returning from the
869:05 - print method so therefore nothing got printed and now as list is empty if i call dq one more time
869:14 - and if i run the code we get an exception saying no such element exception as q is already empty
869:24 - so friend this was the working of dq method so friends apart from this inq and dq method
869:31 - q also has two more methods by name first and last so when we call the first method
869:37 - we get the value stored at the node which is being referred by front and when we call the last
869:44 - method we get the value stored in the list node which is being referred by the rear so here we
869:51 - simply create public int first so here first we simply check that whether q is empty because if q
870:03 - is empty then we know that front and rear both points to null therefore we check whether q is
870:13 - empty or not and after this check we simply return value stored in the front so we simply return
870:22 - front.data and you also write one more method say last which is very similar we'll first check
870:32 - whether the q is empty or not and if the q is not empty then we'll simply return rear.data
870:44 - so friends let's test the working of first and last method so here i will just remove this thing
870:50 - so we inserted three nodes by values 10 15 and 20 so if i run the code
870:55 - so you can see front is pointing to a node having data as 10 and rear is pointing to a
871:06 - node having data as 20 as so for simply print q.first and q.last
871:25 - and if i run the code so you see it printed 10 and 20 because 10 is being referred by front
871:36 - and 20 is being referred by rear so friends in this tutorial we discussed about the dq operation
871:43 - we discussed about the few of the methods like first and last so this was basically all about
871:49 - the implementation of q i hope you like this video please like comment share and subscribe
871:55 - my youtube channel thanks have a nice day hello everyone so in this video we are going to see
872:03 - a problem that how we can generate binary numbers from one to n
872:11 - so here you can see that the question is generate binary numbers from one to n using a cube so
872:18 - binary numbers can be generated by various ways but here we will take a q data structure and we
872:25 - will generate the binary numbers from one to n where n will be the value provided to us so let's
872:32 - say value of n is 3 so the output would be a resultant array of string type and the binary
872:40 - numbers from one to n will be 1 1 0 1 1 so binary number 1 corresponds to 1 1 0 corresponds to 2
872:52 - 1 1 corresponds to 3 and similarly if n is 5 then we need to return like 1 2 3 4 and 5 so from 1 to
873:05 - n so these are the values and decimal number system and its corresponding binary numbers are
873:12 - 1 1 0 1 1 1 0 0 1 0 1 so here first we will see the conceptual overview that how we can generate
873:22 - the binary numbers from 1 to n so let's say we are provided with the value of n is 5 so the binary
873:29 - numbers we need to return is 1 1 0 1 1 1 0 0 1 0 1 so this value corresponds to 1 this to 2
873:43 - this is 3 this is 4 and this is 5 so you can watch the videos and understand how this conversion
873:52 - happens from a binary number to a decimal number so here let's take one example let's say we are
873:59 - given with this binary number 1 0 1 so this is at zeroed spot this is at 1 and this is at 2
874:07 - so what we do is this is binary number which is having 0 and 1 which is two numbers so we simply
874:16 - take this digits value multiplied by 2 and do their sum and we will get the decimal number
874:24 - so to convert this number into a decimal number what we do is
874:29 - we take this digit value which is 1 with multiplied with 2 to the power this value
874:37 - we do sum we take 0 multiplied with 2 to the power 1
874:46 - we take 1 multiplied with 2 to the power 2 so this gives us 4 this gives us 0
875:01 - and 2 to the power 0 is 1 so 1 into 1 gives 1
875:06 - so this gives value as 5 so you can google the stuff or watch the videos there there are programs
875:13 - where we can convert from one number system to another number system
875:22 - so currently our problem is
875:26 - that we are given with a value of n and we need to generate the numbers from 1
875:32 - to 5 so we need to generate something like this 1 1 0 1 1 1 0 0 1 0 1
875:38 - so how we can do is so here you can see that at the start we directly have one number 1
875:46 - and its binary representation is also 1 so the first number is we already know it's it would
875:51 - be 1 now here as we need to return the generated binary number in the form of string what we do is
876:00 - if i append 0 to it and if i append 1 to it i will get 1 0 here and 1 1 here so if you see closely
876:16 - if we are appending 0 we will get our next number if we are appending 1 we will get our
876:21 - third number so the first number we know that it will be 1 if we append 0 we will get the second
876:28 - number if we append 1 we'll get the third number now what about this fourth and fifth so here
876:38 - we do the same steps if we append 0 and if we append 1 so to 1 0 it becomes 1 0 0
876:47 - and if we append 1 we'll get 1 0 1 now let's say if you would have have n equal to 7
876:53 - so the next number would have been 1 1 0 for 6 1 1 1 for 7 so how this number would have come
877:05 - we would have taken 1 1 appended 0 appended 1 so this would have given 1 1 0 1 1 1 so this is how
877:16 - the binary numbers are generated but the main problem is for the first digit we know that this
877:22 - is 1 we can append 0 and 1 and we get 1 0 1 1 but how about other numbers how we will get this 1 0
877:32 - and 1 1 in sequence so that we can append 0 and 1 to 1 0 and get the next elements and then append
877:41 - 1 1 with 0 and 1 to get the rest of the elements that also in sequence and this chain can go on
877:50 - like this so we need to maintain a certain order like this should come first then 1 0 should come
878:03 - then 1 1 should come and then when we are doing 1 0 we should append like this then we pick 1 1
878:10 - we append like this and here also we'll go in this direction only we take 1 0 0 we'll append 0
878:18 - and 1 we take 1 0 1 will append 0 and 1 to get the next binary numbers so this similar kind of
878:27 - structure or the sequence can be maintained via queue so here in a queue which is first in first
878:39 - out so the element which is inserted first will be first one to be removed so here we are directly
878:45 - putting 1 and then we remove 1 so when we remove 1 we have that element we can append
878:54 - 0 and 1 we will get 1 0 and 1 1 so first we will put 1 0 then we will put 1 1
879:03 - so in the next iteration we will take 1 0 out
879:06 - we will append 0 and 1 and into the queue we'll put 1 0 0 first like this
879:17 - and then 1 0 1 and then in the next iteration we'll pull out 1 1
879:28 - so while pulling out 1 1 we are actually getting the generated numbers but for the
879:33 - rest of the numbers we will append 0 we'll get 1 1 0 we'll put it into the queue we'll append 1
879:40 - 2 1 1 and we will put 1 1 1 into the queue so this chain goes on and the numbers are generated
879:47 - so let's see the demonstration of this algorithm step by step so here is the algorithm
879:54 - let's say we call generate binary numbers which is this method we pass in the value of
879:58 - n as 4 so we need to generate four numbers from 1 to 4 so the first number will be 1 then it will
880:08 - be 1 0 then 1 1 and then 1 0 0 so let's see the demonstration of this algorithm that how we can
880:16 - generate these four numbers so n is 4 first we will create a result array because this is the
880:24 - result array which we need to return from this method and this is of string type so the length
880:31 - of this array would be n so result array will have four elements because we need to return
880:38 - this four generated binary numbers we know that we need to use queue so we will initialize queue
880:47 - so queue is an interface and its concrete type is a linked list so it looks something like this
880:55 - so for the first number we can directly offer 1 into the queue because we need to generate the
881:01 - binary numbers from 1 to n so we directly put a string 1 into the queue because this queue is of
881:08 - string type so 1 comes into the queue like this and now in order to fill the result array
881:20 - we are providing a for loop which will go from zero index to
881:23 - a index n minus 1 which is value of n is 4, 4 minus 1 which is 3 which is the last index
881:31 - which is third index so i will start from the zero index
881:39 - and as we discussed we already know the first element so we simply pull the element from the
881:45 - queue and provide it into the result array like this add index i so when we will pull the queue
881:54 - it only has one element so one was entered first so this will be the only element to get exit first
882:03 - because queue is fee for data structure first and first out the element which enters first
882:10 - will be first to be removed so one will be pulled out and simply provided to the
882:16 - result array at zero index because i is pointing to zero so this gets pulled out and one comes here
882:26 - so this is nothing but a string like this because we have created an array result
882:33 - of string type so for timing i am just demonstrating it like this without double quotes
882:41 - and we know that once we get our first element like this we can append zero
882:50 - and we can append one to get the next two elements which is our n1 and n2 so string
882:56 - n1 can be generated by appending zero so n1 becomes one zero one appending zero will give one zero
883:05 - and one appending one will give one one so n1 becomes one zero and n2 becomes one one
883:16 - one appending with one will give one one so n2 becomes one one and we know that after generating
883:25 - n1 and n2 we will put them into the queue in the respective sequence n1 will go first
883:32 - and then n2 will go so first we will offer n1 so one zero will go into the queue
883:42 - and then we offer n2 which is one one
883:48 - so now our queue has two elements one zero and one one
883:54 - so after placing the first element at its correct position
883:57 - in the result array we will increment i, i becomes one which points to index one
884:06 - now in order to fill the result array at particular index which is one
884:11 - we know that we need to pull the element out because we know that the next element is one zero
884:16 - which we need to put it into the result array so whatever elements we are putting into the queue
884:22 - they are in proper sequence so the next element will be one zero so this number will be generated
884:29 - one zero we will pull that out and put it into the result array at index one
884:37 - one zero comes out we get string one zero here and so here you can see that after we are getting
884:46 - this string out we know what that string is so now for the next elements
884:54 - we can append zero and one so we get one zero zero and one zero one and we can put this two
885:02 - element directly into the queue so first we will generate n1 and n2 so result of i will give one
885:09 - zero we will append zero so n1 will become one zero zero and n2 will become one zero plus one
885:21 - will give one zero one like this and then we will simply offer n1 and n2 into the queue
885:31 - because we need to put them in proper sequence so that this binary number generation is done
885:37 - in proper order so one zero zero which is n1 it will go into the queue
885:47 - and then we will offer n2 which is one zero one so this will go into the queue
885:56 - now this element is generated properly so we will increment i now i will point to two
886:05 - which is the second index to fill this value we'll first pull the element from the queue which is
886:13 - one one and assign it to the result array at index two so one one will come out
886:22 - and one one will come here so here in order to create space we will simply shift this i. So
886:29 - these are still in queue but we have just shifted it so that space is created here
886:33 - for the other elements to go in so we have identified one element one one here
886:43 - so we got one one we know that to generate the further elements we will append zero
886:51 - and append one so this will give one one zero and this will give one one one
886:57 - we will generate both of these numbers n1 and n2 so n1 becomes one one plus zero which will give
887:09 - one one zero and n2 will become one one plus one one one one and then we will offer both the
887:21 - elements into the queue so first one one zero will go and then one one one will go
887:36 - we have filled this position so we will increment i so i will now point to the third index
887:43 - and now we can fill this we will simply pull the element from the queue which is the first element
887:50 - which got entered first so one zero zero got entered first before this rest of the three
887:56 - elements so one zero zero will be pulled out and it will be assigned to the result array here
888:03 - at the third index like this so friends here the algorithm is actually ended because we have
888:11 - generated the integers from one to n so this is one this is two this is three and this is four
888:19 - one two four because value of n is four but in order to demonstrate how these further numbers
888:26 - are generated we'll simply see the rest of the algorithm so whatever the number we just pulled
888:32 - out which is one zero zero it will help us in generating the further elements so one zero zero
888:41 - which is this part i am showing it here we will append zero we will append one
888:49 - so n1 becomes one zero zero plus zero so one zero zero zero like this
888:56 - and n2 becomes one zero zero plus one which will give us one zero zero one
889:03 - and here we have got one zero zero zero like this and similarly we will offer both the elements
889:10 - into the queue so one zero zero zero will be our n1 and then we will offer n2 which is one zero zero
889:20 - one like this so this binary number addition will go on like this but here now when we will
889:31 - increment i i will become four and four is not less than four so this for loop will terminate
889:41 - and though we have elements in the queue but we have figured out all the elements from one
889:47 - to n so we will simply return the result so this result will be a string array having one one zero
889:54 - one one one zero zero the four elements from one to n which is four so friend this was all about
890:02 - the algorithm that how we can generate binary numbers from one to n using a queue so your queue
890:08 - plays a very significant role because this data structure is first in first out the element which
890:15 - got inserted first will be the first to be removed so this property makes us easy to generate these
890:21 - binary numbers by just appending zero and one so friends i hope you must have liked this video
890:28 - in case if you're new to my channel then please subscribe to my channel and click the bell icon
890:33 - so that you never miss any update thanks have a nice day hello friends welcome to my new data
890:40 - structures and algorithm in java tutorial series video friends in this tutorial we will discuss
890:47 - how to represent a binary tree in java
890:52 - so friends first we will discuss what is a tree data structure so here you can see that we are
890:56 - given a tree a tree is a non-linear data structure which is used for storing the data
891:03 - and it is made up of nodes and edges without having any cycle so here you can see
891:09 - that we represent a tree through nodes and edges so here you can see the nodes are connected
891:16 - to other nodes through edges so friends tree is basically a non-linear data structure
891:23 - without having any cycle so you can see that nodes are connected to each other but they never form a
891:28 - cycle so here if suppose six is pointing to nine so therefore you can see that it will form a cycle
891:36 - so therefore this representation is not a tree because in a tree you will find nodes
891:41 - having edges to other nodes but you will never find a cycle and you can always think of a tree
891:46 - in the form of a hierarchical structure and also you can see that each node in a tree can point to
891:53 - n number of nodes in a tree so here you can see the node having data as one is pointing to the
891:58 - three nodes by data as two nine and three so there can be n number of nodes in a tree which
892:04 - can be referred by any node so usually a tree is way of representing the hierarchical structure
892:11 - where the parent node is called as root so whenever we represent a tree
892:15 - usually the first node which is the parent of all other nodes is generally referred as root
892:21 - and you can see that it has many levels of additional nodes so
892:25 - so friends in the tree you can see that one is the parent of all the nodes below it and
892:31 - it's generally referred by the root because this is the root of the tree
892:34 - and whatever the edges are coming out from this root it's pointing to the other nodes
892:41 - and here you can see that this structure can go to many levels and also a node who is not pointing
892:47 - to any other node is generally called as leaf so here you can see that node one is a parent of two
892:54 - nine and three node two is parent of four and five and node four has no child therefore this
893:01 - is called as leaf node similarly five is a leaf node six is a leaf node seven is a leaf node nine
893:08 - is a leaf node because they don't have any children's moving ahead so friends what is
893:15 - the binary tree so friends the binary tree is a special kind of a tree where each node has zero
893:22 - one or two children's and not more than that can have zero children's one children or at max two
893:28 - children's so here in the below diagram you can see as root is the parent of all the nodes
893:35 - it's having two children's with data two and three the node two which is parent two four and
893:42 - five has two children's four and five and at the last you can see node four which is a leaf node
893:48 - has zero children's so friends similarly a node can have one children and the other children can
893:54 - point to null so friends the binary tree is basically represented by a tree node so here
894:00 - you can see a tree node consists of three things one is the data part which actually holds the data
894:06 - as you can see the data is like one two three six seven four five and it is a pointer to the left
894:13 - node and a pointer to the right node so these pointers are basically of type tree node itself
894:19 - so here you can see the node having data as one is a basically a tree node
894:24 - and whose left is pointing to the node two and whose right is pointing to the node three
894:29 - so therefore a binary tree having a tree node consists of only three things
894:35 - one is the data part one is the pointer to the left tree node and one is the pointer to the
894:40 - right tree node so basically the way we represent a binary tree in the graphical form is something
894:46 - like this that it contains the data which you can see here and two edges coming out of it
894:51 - so here you can see this is the left edge and this is the right edge and we represent this
894:56 - edge through the left and right pointers moving ahead so as we discussed in our previous slide
895:04 - that a binary tree is basically represented internally through a tree node so friends the
895:09 - structure of tree node is something like it contains data it contains pointer to the right
895:14 - tree node and a pointer to the left tree node in an actual tree and below you can see the java
895:20 - code for representing a tree node so it contains the data and here i have taken this data in the
895:26 - form of integer and which can be any generic type and it contains a tree node left which actually
895:32 - points to the node which is just left to this particular node and one tree node right which
895:38 - actually points to a tree node which is just right to it and basically it has one constructor
895:44 - which takes in a data part so whenever we initialize a tree node we usually pass the
895:48 - data which we want to store into it so usually when a node tree node is created so data which
895:54 - we pass into the constructor is stored in the data variable and left and right at the time of
895:59 - initialization usually points to null and later on we make them refer to the other tree nodes
896:04 - moving ahead so let's quickly see a demo how we can create a binary tree
896:12 - so when we initialize a binary tree the root is actually pointing to null and this root is also
896:18 - a type of tree node now let's say we have created one tree node having data as one and whose left
896:25 - and right is both pointing to null and which is referred by this temporary variable
896:30 - so let's say we want to insert this temp into the binary tree
896:34 - so what we do we simply assign the value of temp to the root so it looks something like this
896:44 - so when we insert one tree node usually root points to that particular node because this is
896:48 - the only node into the tree now let's say we create one more node having data as two
896:55 - and whose left and right both pointing to null which is referred by this temporary node
897:00 - and if we want to insert this node into the tree we know that root is already pointing to the node
897:04 - having data as one so one thing we can do here is we can either point root left to this particular
897:11 - node or root right to this particular node so either way we can do so let's say we assign
897:16 - temporary node value to root left so it would look something like this
897:25 - so now here you can see this is a binary tree having two nodes where root is pointing to the
897:31 - node having data as one and whose left is pointing to a node who having data as two
897:36 - and here you can also see that root right is pointing to null and left and right of root
897:42 - two is pointing to null now let's say we want to insert one more node having data as three
897:49 - now here we can insert this node into a binary tree at three places one is at the roots right
897:55 - another two places are nodes two left and right so basically we can place this node three into
898:02 - these three places which is pointing to null so let's say we insert it at roots right so it would
898:08 - look something like this so now here you can see root is having data as one and whose left and right
898:17 - both are pointing to a node having data as two and three and suppose we want to insert one more
898:22 - node then we can insert it into at the four places now so those four places would be two's left two's
898:28 - right then three's left and three's right because those four positions are pointing to null
898:35 - so friends in this tutorial we discussed how to represent a binary tree in java
898:39 - and we also discussed the structure of tree node so friends in my next tutorial i will be discussing
898:45 - how to implement a binary tree in java i hope you like this video please like comment share
898:51 - and subscribe my youtube channel thanks have a nice day hello friends welcome to my new data
898:59 - structures and algorithm in java tutorial series video friends in this tutorial we will discuss
899:06 - how to implement a binary tree in java
899:08 - so friends in my previous tutorial we discussed how we can represent a binary tree in java
899:16 - and we also discussed the structure of tree node in a binary tree so friends in my previous
899:20 - tutorial we discussed that binary tree consists of a root node which is of type tree node
899:26 - and usually this root node keep the hold of all the nodes in a binary tree
899:31 - we also discussed that a tree node consists of a data part and it contains two pointers one is
899:36 - left pointer and one is right pointer so this left pointer is pointing to the left tree node
899:42 - and the right pointer is pointing to the right tree node so friends this is how we store the
899:47 - data into tree node and we usually use left pointer and the right pointer to hold the left
899:52 - tree node and the right tree node and below you can see the java code to represent a tree node
899:58 - so here you can see it has three things one is the data part one is the pointer to the left
900:02 - tree node and one is the pointer to the right tree node and here you can see we can store
900:08 - any generic type of data into a tree node and below is the constructor of tree node
900:13 - where we actually pass the data. So this data part whenever we initialize a tree node gets
900:18 - stored into the data variable. So friends let's go to Eclipse and see the implementation of a
900:23 - binary tree in Java. So friends here I have created one class by name binary tree which
900:31 - is having a main method. So let's implement a binary tree into this class. So friends in our
900:38 - previous slide we discussed that a binary tree consists of a root node which is our type tree
900:42 - node. So first we'll create an instance variable of type tree node and we'll give name to it as
900:52 - root because this root node will hold all the other nodes of a binary tree
900:58 - and in order to represent this tree node we'll create an inner class by name tree node so private
901:06 - class tree node. So as we discussed in our previous tutorial that as it is a binary tree
901:15 - therefore it will have two pointers one is pointing to the left tree node and another
901:20 - is pointing to the right tree node. So therefore we'll create two pointers of type tree node
901:28 - as left and right
901:39 - and this tree node along with holding the left tree node and right tree node
901:42 - it will also hold the data. So we are creating an integer type
901:48 - and which will actually store the data. So this can be any generic type
901:54 - not supposedly of integer type. We can store any data into this tree node. So in this tutorial
902:00 - I am taking the integer data moving ahead. Now below we'll also provide one constructor
902:13 - and this constructor will take in the data part which we want to store.
902:18 - So when we initialize a tree node we usually store the data into the data variable
902:29 - moving ahead we'll create one method as public void and we'll create a binary tree into it
902:37 - create binary tree. So in order to create a binary tree first we'll create few nodes.
902:47 - So let's say we are giving the nodes name as first
902:56 - and let's say I give the value to data as one
903:01 - and I will just create few nodes.
903:07 - Let's say I give the name as second
903:09 - third fourth fifth and let's say I provide data as two three four and five.
903:30 - Now when we call this create binary tree it will first create this five tree nodes.
903:33 - Now in order to store this five nodes into the binary tree first thing we do is
903:41 - we assign the value of first to root. So now root will be holding the tree node having data as one
903:49 - and let's say to first left we are assigning the value of second
903:56 - and to first right we are assigning the value of third.
904:06 - So friends here root will point to the node having data as one
904:10 - and its left will point to a node having data as two and one's right will point to the node
904:15 - having data as three. So here we have simply assigned the value of first to root and then
904:21 - we are assigning the value of second to first left and value of third node to first right.
904:27 - So after these three statements here you can see
904:32 - root will point to first
904:36 - and then after these two statements it would look something like this
904:39 - second
904:51 - so your first left will point to the second and first right is pointing to third. Moving ahead
904:58 - now let's say we assign the value of fourth to second left so we assign
905:03 - value fourth to second left and we assign value fifth to second right.
905:21 - So friends this is how we create a binary tree with the few nodes and after these four or five
905:26 - statements the binary tree looks like this. So friends the binary tree which we created
905:33 - after those four five lines of execution the binary tree will look something like this
905:37 - that we initially created five nodes with the data as one two three four five and then we have
905:44 - assigned the value of first to root. So therefore now root is pointing to the node having data as one
905:50 - and then we assign the value of second to first left. So now first left is pointing
905:57 - to the node having data as two and we assign third node to the first right therefore first
906:03 - right is pointing to the node having data as three. We also assigned the value of fourth
906:09 - and fifth node to two's left and two's right so therefore it looks something like this.
906:16 - So this is how we actually implement a binary tree where we insert the node using the left
906:20 - and the right pointers of a tree node. So friends in this tutorial we discussed how to implement
906:25 - a binary tree in java and in my next tutorial we will discuss how we can traverse each and every
906:31 - node of a binary tree in java. I hope you like this video please like comment share and subscribe my
906:38 - youtube channel. Thanks have a nice day. Hello friends welcome to my new data structures and
906:46 - algorithm in java tutorial series video. Friends in this tutorial we will discuss recursive pre-order
906:53 - traversal of a binary tree in java. So friends what is a pre-order binary tree traversal?
907:03 - So friends in order to traverse each and every node of a binary tree
907:07 - we apply these three steps on the each node of a binary tree.
907:12 - So what we do is we visit that particular node and then we traverse its left sub tree
907:19 - and then we traverse its right sub tree. So here if you take an example of this tree then
907:26 - we start with the root node and we apply these three steps on the root node.
907:32 - So what we do we first traverse this node and then we traverse its complete left sub tree
907:39 - and then we traverse its complete right sub tree. So once we process this node
907:45 - we first go to its left sub tree and there we encounter a node having data as 2.
907:52 - So on this node we again apply these three steps that we visit this node and then we visit its left
907:58 - sub tree and then we visit its right sub tree. So after we process the node having data as 2
908:06 - we then go to its left sub tree and then we encounter a node having data as 4.
908:11 - So we apply these three steps on the node 4. We first visit this node and then we traverse
908:18 - with left sub tree and then to its right sub tree. So here you can see node 4 has no left sub tree
908:26 - and no right sub tree therefore we are done with the processing of this node
908:32 - and then we return back to the node having data as 2. So we have processed this node 2,
908:37 - we have processed the node 4. So now on the third step we visit the right sub tree.
908:44 - So we go to the node 5 and then we apply these three steps on the node 5.
908:49 - We first visit this node then we visit its left sub tree and then we visit its right sub tree.
908:55 - So as node 5 is having no left sub tree and right sub tree therefore we are done with the processing
908:59 - of the node 5 and once we are done with the node 5 then we are sure that we have processed the right
909:06 - sub tree of the node 2. So therefore we have processed 2 then 4 and then we have processed 5.
909:13 - So we are done with the left sub tree and then we again go back to the root node 1
909:18 - and as we have visited the left sub tree of it we now will visit the right sub tree for the node 1.
909:25 - So then we go to the right sub tree of the node 1 and when we reach to the node 3 we apply these
909:31 - three steps now for the node 3. So first we visit this node and then we visit its left sub tree and
909:38 - then we visit its right sub tree. So after processing the node 3 we go to 6 and we apply
909:45 - these three steps. We visit this node we then go to its left sub tree and then go to its right sub
909:50 - tree. Now as node 6 is having no left sub tree and no right sub tree then we are done with the
909:56 - processing of this node and then we return back to the node 3. So once we return back to the node 3
910:03 - we have processed its left sub tree and now the step remains to process its right sub tree.
910:09 - So when we reach to the node 7 we first process this node and then we traverse the left sub tree
910:16 - of it and the right sub tree of it. So as node 7 has no left sub tree and no right sub tree
910:22 - therefore we are done with the processing of the node 7 and then we reach to the node 3.
910:30 - And since we already processed this node then we reach to the node 1. So friends in pre-order
910:36 - traversal we first process the node and then we process it left sub tree and then we process it
910:42 - right sub tree and this we do recursively for each and every node. So let's see the demonstration of
910:48 - pre-order binary tree traversal. So friends suppose we want to traverse a tree whose root
910:55 - is 9 and whose left is a node having data as 2 and its left is having data as 4 and the right of
911:02 - node having data as 2 is null and the root 9 also has the right sub tree having the data as 3 and
911:08 - whose left and right sub trees are both pointing to null. So let's see the demonstration of this
911:14 - algorithm that how we can process the nodes of a binary tree in pre-order traversal. So here you
911:21 - can see that below is the algorithm for it and as we are applying this pre-order traversal to each
911:28 - and every node recursively. So here we know that the method name is pre-order and inside this
911:35 - method we are again calling this method to process the left and the right sub tree. So friends when
911:42 - we are doing a pre-order traversal we are calling this method recursively and in order to understand
911:48 - this method recursively here we are maintaining a call stack which has method call line number
911:54 - and the root. So in the method call we'll just keep the track of the method that which method is
912:00 - being called and we'll also keep the information of the root that which current node is being
912:05 - processed and we'll come to know about line number when we are demonstrating the algorithm.
912:12 - So let's call the pre-order method and we'll pass the root as 9.
912:18 - So when the execution point comes to pre-order
912:23 - we know that the call stack will now execute this pre-order method
912:26 - and we are keeping the track of the root. So currently the root is being pointed by the data
912:31 - as 9. So then we check that whether root is equal to null or not. So friends why we are providing
912:40 - this condition is because this is considered as our base case and as we are calling this
912:45 - pre-order method recursively we need a point to exit this recursion that when root is equal to
912:52 - null then we simply return from that method. So currently you can see root is pointing to 9
912:59 - here. So therefore it's not equal to null. So the condition in if block comes out to be false
913:06 - and then as we discussed in our previous slide that first we visit the node and then we visit
913:12 - this left subtree and then we visit the right subtree. So we'll first visit the node and we'll
913:18 - print the data associated with that node. So the output is 9. So we have processed this node
913:27 - moving ahead. So now we are calling the pre-order method to traverse the left subtree
913:34 - for this root. So the value we are passing to this pre-order is root left. So currently you see
913:41 - root left is pointing to the node having data as 2 and as we are maintaining this call stack.
913:47 - So when we call this pre-order method we'll keep the track of this line numbers
913:52 - so that once we return it back we know that from which line we need to execute the method.
913:58 - So currently from line 6 we are calling this pre-order therefore we'll keep the track of
914:02 - this line number. So here we have stored the number as 6 and now we'll again call pre-order
914:11 - method and we'll pass the root.left to it which is nothing but the node 2. So now root will be the
914:19 - node 2 and here pre-order is again called with the root as node 2. So now we are again executing
914:28 - pre-order with the root as 2. So we'll check whether root is equal to null or not.
914:34 - So currently root is not equal to null. So as we discussed in our previous slide that once we reach
914:42 - to the left subtree we process this node and then we go to its left subtree and then to its right
914:48 - subtree. So now we are processing the node 2. So the output would be 2 because we are just printing
914:55 - the data part of it. Moving ahead and now we'll again call pre-order method recursively and then
915:04 - we'll pass root.left to it. So currently root is pointing to the node having data as 2 and its left
915:10 - is pointing to the node having data as 4. So as we are calling this pre-order again we'll keep the
915:17 - track of the line number. So we are placing the line number as 6 because we know that we are leaving
915:24 - this pre-order at line 6 and we are again calling this pre-order.
915:30 - So the point of execution again reaches to pre-order and this time the root is roots left
915:36 - so which is 4. So a new root becomes the node having data as 4
915:46 - and as we are again executing this pre-order we know that in the call stack this method will be
915:51 - called again and this time the root is being 4. So we'll again execute this pre-order recursively.
916:00 - We'll first check whether root is equal to null or not. So currently root is pointing to 4 therefore
916:05 - it's not null and here we simply process this node. So the output would be 4
916:15 - and after we process this node we know that now we have to traverse its left subtree
916:21 - and then its right subtree. So first we are processing its left subtree so we are simply
916:26 - calling pre-order again and we are passing roots left. So currently here you can see root left is
916:31 - pointing to null so therefore we'll now call this pre-order by passing a value null and as we are
916:38 - leaving this pre-order now here we'll keep the track of the line number. So we are calling this
916:47 - pre-order again and now the root would be null because we are traversing root left. So currently
916:53 - root is pointing to 4 and its left is pointing to null. So therefore our new root becomes null
917:00 - and there will be one more method on the stack with the name pre-order and the root would be null.
917:07 - So we'll again execute the pre-order method. So we'll check whether root is equal to null so
917:13 - currently if you see root is equal to null so we have reached our base case. So this base case will
917:19 - help us in exiting the recursion and as we know that we are left with no more nodes in the left
917:26 - subtree to traverse therefore we'll simply return from this method. So when we return
917:34 - this method gets executed so it gets removed from the call stack
917:38 - and now as this method is removed from the call stack call goes to the pre-order method
917:46 - which was executed just before it. So we'll now start executing this pre-order
917:54 - and as we know that we have left this pre-order at the line number 6 so we'll now start from the
917:59 - line number 6 and we also know that when we left this pre-order method at that moment the root was
918:07 - 4 so once the call reaches to this pre-order root will be pointing to 4. So friends here we have
918:14 - first traverse the node 4 then we process it left subtree and now we'll go to its right subtree so
918:21 - that thing will do recursively. So in the line 7 now we'll simply go to its right subtree
918:30 - so as root is 4 and as right is pointing to null therefore we'll call pre-order with a null value
918:36 - and as we are calling this pre-order method with a value as null we are leaving this pre-order
918:41 - method so we'll update the line number that from line number 7 we have again called this pre-order
918:46 - method. So now this pre-order will be called with a value of null so it's nothing but the roots right
918:55 - so one new root becomes roots right so now root will be pointing to null and we also know there
919:02 - will be one more method on the stack with the root value of null moving ahead so we'll check
919:10 - whether root is equal to null or not so currently root is equal to null therefore we'll simply
919:15 - return from this method so this method gets removed from the call stack and the execution
919:22 - point goes to the method which called it. So now we'll again start executing this pre-order
919:29 - method from the line number 7 and we also know that we have left this pre-order when the root
919:36 - was pointing to node 4 so we simply traverse to the node 4 and this would become our root
919:45 - and then we'll start again executing from the line 7. So once we reach the line 8 we know that
919:52 - we are done with the processing of this pre-order method and whose root is 4 so therefore this
919:59 - method will be removed from the stack and the execution point will go to a method which called
920:06 - this method so if the execution reaches the pre-order for the root node 2 and we also know
920:13 - that we have left this pre-order from the line number 6 so we'll start executing from the line
920:18 - number 6 and we also know that when we left this pre-order at that moment root node was 2
920:26 - so here the root will now point to the node 2 moving ahead
920:34 - and from the line 7 we'll now call the pre-order and we'll pass the roots right
920:39 - because we are applying this pre-order traversal to each and every node that we are first traversing
920:44 - the node then we are processing its left subtree and then we are processing its right subtree
920:49 - so as here you can see we have processed this node 2 and we also processed its left subtree
920:55 - which is node 4 so now we are left with the processing of the right subtree so therefore
921:00 - we are again calling this pre-order and we are passing the value of roots right so here roots
921:06 - right is null so therefore we again call this pre-order method and we'll pass the null value to it
921:12 - and as we are leaving this pre-order method and we are calling the new pre-order method so we'll
921:18 - just keep the track of the line number so it signifies that we are leaving this pre-order
921:24 - from the line number 7 so here now we are calling pre-order with the value as null
921:33 - so therefore we know that there would be one more method on the call stack
921:36 - whose current root would be null so therefore now root will point to null
921:46 - and we'll start executing this pre-order method
921:50 - so then we'll check whether root is equal to null or not so currently root is equal to null
921:55 - therefore we have reached our base case condition and we'll simply return from this method
922:01 - so when we return from this method this method will be removed from the call stack
922:07 - and the execution point will now reach to a method which called this method
922:14 - and as we have reached to this pre-order method we know that we had left this method from the line
922:18 - number 7 so therefore the execution will start from the line number 7 and we also know that
922:24 - when we left this pre-order method at that time root was pointing to the node 2 so therefore
922:28 - this root will now point to 2 and then we'll simply start executing this pre-order method
922:40 - so once we reach the line number 8 so therefore this method will be removed from the stack
922:46 - and the execution point will reach to a method previous to it
922:52 - and we also know that we had left this method from the line number 6
922:56 - therefore we'll start executing from the line number 6 and we also know that we had left this
923:02 - pre-order method at that moment root was 9 so therefore now root will reach to 9
923:09 - so friends for the root 9 we have processed the left subtree completely so now it's the
923:14 - time to process the right subtree so therefore we start the execution from line number 6
923:20 - and here we know that we will again call pre-order method and this time we'll pass
923:28 - roots right which is the node 3 and as we are leaving this pre-order method
923:34 - we'll keep the track of the line number
923:39 - so now pre-order will be called with the root pointing to the node 3
923:44 - and we also know that there will be now one more method on the stack
923:48 - so now pre-order will start executing with a root having data as 3 so therefore
923:55 - now root will point to the node having data as 3 moving ahead
924:02 - we'll check whether root is equal to null or not so currently root is not equal to null
924:10 - so therefore we'll simply process this node and then we'll start processing the left subtree
924:15 - in the right subtree so we'll simply print the data for this root node which is 3
924:25 - and then we'll process the left subtree of it so we are again calling this pre-order method
924:30 - and this time we are passing roots left so it's nothing but we are passing roots left which is null
924:37 - and as we are leaving this pre-order method we'll keep the track of the line number
924:42 - which is 6
924:46 - so now the execution point reaches to pre-order and this time the root is null
924:51 - so therefore root will point to null and we also know that there will be one more method on the call
924:57 - stack and the root will be null so we'll execute pre-order with the root as null
925:06 - so we'll check whether root is equal to null or not so currently root is equal to null
925:11 - so we have reached our base case so we'll simply return from this method
925:16 - now as we return from this method the pre-order method on the call stack with the root as null
925:22 - will be removed from the call stack and the execution point will reach to a method which
925:28 - had called this method so we'll again start executing pre-order method and we know that
925:35 - we had left this pre-order from the line number 6 therefore the execution point will start from
925:39 - the line number 6 and we also know that when we had left this pre-order method at that time root
925:46 - was pointing to 3 so now root will point to 3 moving ahead from the line 7 we'll now again call
925:59 - roots right because we have traversed the left subtree for the root 3 now we'll process its right
926:04 - subtree so we'll again call pre-order method and we'll pass roots right which is null
926:12 - so when we are leaving this pre-order we'll keep the track of the line number
926:18 - so when we call this pre-order method we had passed roots right which is null
926:24 - so therefore for this pre-order now root will point to null
926:28 - and we also know that there will be one more method on the call stack
926:37 - with a root as null so then we'll check whether root is equal to null or not so currently root
926:43 - is equal to null therefore we have reached our base case so we'll simply return out from this
926:47 - method so when we return from this method this method will be removed from the call stack and
926:54 - the execution point will reach to a method which called this method
927:02 - so now we'll again start executing this pre-order method
927:06 - and we know that we had left this method from the line number 7 so we'll start from the line
927:10 - number 7 and we also know that when we had left this pre-order method root was pointing to 3
927:17 - so therefore root will reach to 3 moving ahead
927:24 - now once you executed all the statements from this pre-order this pre-order will be removed
927:29 - from the stack and the execution point will go to a method which called this method
927:38 - and the point which we have left this pre-order was at line number 7
927:42 - so therefore the execution point will start from the line number 7
927:45 - and we also know that at that moment the root was 9 so therefore now the root will point to 9
927:57 - and finally we are done with this pre-order therefore this method will be removed from the
928:01 - stack so friend in this slide we saw the demonstration of how pre-order traversal works
928:09 - that it first visits the node and then it recursively calls pre-order to process the
928:14 - left subtree and then to process the right subtree and this goes on for each and every node
928:20 - so here you can see the output is 9 2 4 3 so we have visited 9 then we visited 2
928:27 - then we visited 4 and then we finally visited 3 so friends here we saw the demonstration
928:34 - of the algorithm now let's go to Eclipse and see the working code
928:37 - so friends in my previous tutorial we discussed how to implement a binary tree in Java
928:45 - so I had created one class binary tree and we have implemented the binary tree in Java
928:51 - so here we had created an instance variable of type tree node which was actually root
928:57 - because this root will hold all the nodes of a binary tree
929:01 - and we had also discussed how we can create a binary tree by creating the few nodes
929:07 - so here let's write a code for pre-order traversal of a binary tree
929:14 - so public void will give the method name as pre-order
929:25 - now this method as we know will take in a root which we saw in the slide
929:31 - and as we are going to call this pre-order method recursively will first provide a base case
929:41 - so the base case would be if root is equal to null then simply return from this method
929:53 - and if root is not equal to null
929:54 - then simply visit the node
930:03 - so we'll print root.data
930:06 - and once the processing of node is done we will again call pre-order method
930:14 - and we'll pass root left
930:19 - and in the last line we'll again call pre-order method
930:22 - and we'll pass root.write to it
930:28 - so here after processing of a node we are recursively processing the left sub tree
930:34 - and the right sub tree in a pre-order fashion
930:38 - so friend this is the code for pre-ordered binary tree traversal
930:44 - now let's test is working in main method
930:46 - so first we'll create a binary tree which we actually saw in the slide
930:52 - so here in my previous tutorial I had created few nodes
930:56 - so I'll just remove one of the node and I give the data which we saw in the slide as 9, 2, 3 and 4
931:04 - so we also saw that root was pointing to 9, 9 left was second and 9 right was holding a node
931:12 - having the data as 3 and we also know that node 2 left pointed to node 4
931:18 - and we'll just simply remove this line
931:21 - so here we have created a binary tree which we discussed in the slide
931:24 - where root is pointing to 9 and whose left is pointing to 2 and whose right is pointing to 3
931:31 - and then again 2's left is pointing to 4
931:36 - now after creating this binary tree let's test the working of this pre-order method
931:43 - so in the main method we'll first create the instance of binary tree
931:55 - and then we'll simply call create binary tree
932:00 - now once we call this create binary tree
932:03 - the binary tree will be created and the root will hold the actual binary tree for us
932:08 - and then we'll simply call pre-order and we'll pass the root of the binary tree
932:22 - so when I run this code
932:28 - so here you can see it printed 9, 2, 4, 3 which we actually discussed in the slide
932:33 - so friends in this tutorial we discussed the pre-order binary tree traversal
932:40 - I hope you like this video please like comment share and subscribe my youtube channel
932:44 - thanks have a nice day
932:49 - hello friends welcome to my new data structures and algorithm in java tutorial series video
932:54 - friends in this tutorial we will discuss iterative pre-order traversal of a binary tree in java
933:00 - so friends in my previous tutorial we discussed what is the pre-order binary tree traversal
933:07 - so in pre-order tree traversal we performed the three steps for each and every node of a binary
933:13 - tree that we first visit that particular node and then we visit this left sub tree and then
933:19 - we visit this right sub tree and this we do for each and every node so in my previous tutorial
933:25 - we discussed the recursive pre-order binary tree traversal and in this tutorial we will discuss
933:30 - iterative pre-order binary tree traversal we also discussed that we apply these three steps
933:37 - to each and every node of a binary tree that we visit that particular node and then we visit
933:42 - this left sub tree and then we visit this right sub tree so friends in my previous tutorial we
933:48 - used the recursion in order to traverse the binary tree now in this tutorial as we are not
933:53 - using the recursion and we are using the iterative way therefore we need to use an
933:59 - additional data structure which could hold the information of the nodes so friends when we use
934:05 - recursion and we call the method recursively so it internally used a stack so in the iterative
934:11 - way we will use the stack data structure so friends below is the algorithm for iterative
934:17 - pre-order traversal of a binary tree and as we are using the iterative version of this algorithm
934:23 - we are creating a stack which could hold the additional information for us so that when we
934:28 - backtrack to a particular node we can fetch it from the stack easily and we also know that stack
934:34 - is a leafo data structure which means the last and first out so the node inserted last would be
934:40 - the first node to be removed and if you want to know more about stack data structures you can
934:45 - watch my previous tutorial so in this tutorial let's take this example that we want to traverse
934:51 - the nodes of this binary tree so let's see the demonstration of this algorithm step by step
934:57 - so basically when we execute this algorithm we start with the root
935:01 - and the first step we check is whether root is equal to null or not
935:04 - so currently you see the root is pointing to the node having data as one therefore it's not null
935:12 - and then we'll create a stack which could hold the three nodes for us
935:15 - so here you can see we have created one stack now this stack will hold the tree nodes for us
935:23 - so on the first step we'll simply push the root node moving ahead
935:32 - so friend as this is the iterative version of the algorithm we are using a while loop
935:36 - and we are placing a condition that iterate till the stack is empty
935:41 - so currently you can see stack is not empty because we have pushed one node
935:45 - therefore the condition in while block comes out to be true and while loop executes
935:53 - so in this line as we know that stack has only one element so therefore this element will be popped
935:58 - out and we'll assign this pop node to a temporary node so it would look something like this
936:04 - so first the node will be popped out so as the three node with the data as one was popped out
936:10 - now this time will point to that particular node moving ahead
936:18 - so friends in pre-order tree traversal we first process a node and then we process its left sub
936:24 - tree and then we process its right sub tree so in the first step we'll simply print this node
936:30 - so the output would be one moving ahead
936:36 - so friends we have processed this node and now we will process its left sub tree
936:41 - and then its right sub tree so in order to do that we are first putting the right node
936:48 - on the stack and then we are putting the left node on the stack because when we pop it out
936:52 - we'll first pop out the left node and then we'll pop out the right node
936:56 - and in order to do that we are first checking that whether temp right is equal to null or not
937:02 - so currently temp right is not equal to null therefore we'll push the node having data as
937:08 - three on the stack so you can see three is now on the stack and then we'll check whether temp left
937:20 - is equal to null or not so currently temp left is not equal to null therefore we'll push
937:26 - the node having data as two on the stack
937:32 - so friends as stack is a leafo data structure it means the node inserted last would be the first
937:38 - one to be removed and we also know that in pre-order tree traversal we first visit the
937:43 - node and then we visit the left sub tree so basically in order to traverse the left sub
937:47 - tree first we push the right node on the stack and then we push the left node therefore when we pop
937:54 - it out we'll pop out the node having data as two now we'll again check in the while loop whether
938:00 - stack is empty or not so currently stack is not empty therefore condition in while loop comes out
938:05 - to be true and then we'll simply pop an element from the stack and we'll assign it to the temporary
938:13 - node so the node is popped out so it means now temp will point to the node having data as two
938:26 - and in the next step we'll simply print the data for the temporary node
938:31 - so two is printed and hence we have processed this node and now we want to process its left
938:36 - sub tree first and then its right sub tree so on the stack we'll first put the node
938:41 - which is pointed by temp right and then we'll put the node which is pointed by temp left
938:49 - we'll check whether temp right is equal to null or not so currently temp right is pointing to
938:53 - the node having data as five therefore it's not null therefore we simply push the node having data
939:01 - as five on the stack and then we'll check whether temp left is equal to null or not
939:08 - so here you can see temp left is pointing to the node having data as four
939:12 - therefore we'll push the node four on the stack
939:19 - and then we'll again execute the while loop and we'll check whether stack is empty or not
939:23 - so currently stack is not empty therefore the while loop executes
939:30 - and now in the first step we'll simply pop an element which is on the top of the stack
939:34 - so here we know that four is on the top of the stack so it will be popped out
939:38 - and now temp will point to the node four
939:44 - moving ahead
939:49 - and then we'll simply print the data associated with this node
939:54 - which is four and then we'll simply check whether temp right is equal to null or not
940:00 - so currently temp right is equal to null therefore the condition in if block comes out to be false
940:08 - and then we'll check whether temp left is equal to null or not
940:11 - so here you can see temp left is also equal to null therefore the condition in if block comes
940:17 - out to be false and then again in while loop we'll check whether stack is empty or not
940:23 - so currently you see stack has two nodes therefore it's not empty so the while loop executes
940:29 - and the first step will simply pop the top element and will assign its value to the temporary node
940:36 - so currently you see node having data is five is the top element
940:40 - therefore will pop it out and now the temp will point to the node having data is five
940:48 - moving ahead
940:52 - now we'll simply print the data associated with this temporary node which is five
940:56 - moving ahead
940:59 - we check whether temp right is equal to null or not so currently temp right is equal to null
941:05 - therefore the condition in if block comes out to be false
941:09 - we then check whether temp left is equal to null or not so here you can see temp left is also null
941:15 - therefore the condition in if block comes out to be false and then we'll again execute the while loop
941:22 - then we'll again execute the while loop with the condition that stack is empty or not
941:26 - so currently stack has one node therefore it's not empty
941:32 - so in the first step we'll simply pop an element from the stack
941:36 - and we'll assign its value to the temporary node so here you can see when we do stack.pop
941:42 - the node three will pop out and then the temp will point to that particular node
941:48 - so it would look something like this
941:52 - so now temp is pointing to the node having data as three moving ahead
941:59 - now we'll simply print the data associated with this temporary node
942:04 - so the output we see three and then
942:10 - we check whether temp right is equal to null or not so currently temp right is not equal to null
942:15 - therefore the condition in if block comes out to be true
942:17 - so in the if block we simply push temp right which is the node seven on the stack
942:27 - and then we'll check whether temp left is equal to null or not
942:30 - so temp left is pointing to six which is not null therefore the condition in if block comes out to
942:36 - be true and we'll simply push temp left on the stack which is six
942:42 - and then while loop will again check the condition whether stack is empty or not
942:49 - so currently stack has two elements therefore it's not empty
942:55 - so in the first step we'll simply pop an element from the stack
942:58 - so the top element is a node having data as six so this node will be popped out
943:04 - and its value will be assigned to the temp so currently temp is pointing to the node having
943:09 - data as three and after this step temp will point to the node six because because when we do stack
943:16 - dot pop six will be popped out so it would look something like this
943:22 - so now temp is pointing to six
943:27 - we'll simply print its data on the console which is six
943:34 - and then we'll check whether temp right is equal to null or not
943:37 - so currently temp right is pointing to null therefore the condition in if block comes out
943:42 - to be false and then we'll check whether temp left is equal to null or not
943:48 - so temp left is equal to null therefore the condition in if block comes out to be false
943:55 - and then in while loop will again check whether stack is empty or not
943:58 - so currently stack is not empty because there is one node
944:01 - and in the first step we'll simply pop the element from the stack and assign its value to temp
944:10 - so when we pop an element from stack we know that seven will be popped out
944:15 - so therefore temp will now point to seven so it would look something like this
944:25 - and then we'll simply print the data associated with this node on the console which is seven
944:31 - and then we'll check whether temp right is equal to null or not
944:38 - so currently temp right is equal to null therefore condition in if block comes out to be false
944:45 - and then we'll again check whether temp left is equal to null or not
944:48 - so temp left is also equal to null so therefore the condition in if block comes out to be false
944:54 - and finally we'll check whether stack is empty or not so currently you see as we have processed
945:02 - all the nodes of a binary tree so the stack is empty therefore the condition in while block
945:07 - comes out to be false so friends using and stack we saw how we can perform pre-order traversal of
945:15 - a binary tree so here we discussed about the demonstration of the algorithm now let's go to
945:20 - eclipse and see the working code so friends in my previous tutorial we created one class
945:28 - by name binary tree and we implemented binary tree into it now this class has an instance
945:35 - variable of type tree node which is the actual root of our binary tree we also discuss about
945:42 - the recursive pre-order tree traversal and in this tutorial we will see the iterative version of it
945:48 - so therefore i'll just comment this code
945:53 - and below i will create a method as public void pre-order
946:05 - and in this method we'll write a code which would perform the iterative pre-order tree traversal
946:11 - so in the first step we'll check
946:12 - whether root is equal to null or not
946:20 - so if the root is equal to null so it means there are no nodes into the binary tree
946:24 - so therefore we'll simply return from the method and in the first step we'll simply create a stack
946:30 - so here we will import the stack from java.util package
946:44 - and as we discussed in slide we'll just push the root on the stack
946:53 - and after that we'll provide a while loop
946:55 - and inside this while loop will check whether stack is empty or not
947:05 - so if the stack is not empty then the while loop will be executed
947:10 - and in the first step we'll create a temporary node and we'll pop the element from the stack
947:18 - and we'll assign it to the temporary node
947:24 - and as we have popped an element from the stack we'll simply print it straight out on the console
947:38 - and in the next step we'll check
947:39 - that whether temp right is equal to null or not so if temp right is not equal to null
947:52 - then we'll simply then we'll simply push temp right on the stack
947:58 - and we will do this step for the temp left as well
948:14 - so here if temp left is not equal to null
948:18 - then we'll simply push temp left on the stack
948:23 - so friend this is the iterative version of pre-order tree traversal
948:26 - now let's test is working on the main method
948:30 - so in the main method we have created is binary tree and the end we have called create binary
948:35 - tree so it will create a binary tree with few nodes which we discussed in our previous tutorial
948:46 - and the last i will simply call the pre-order method and when i run this code
948:51 - so you can see it printed 9243 and it printed the same what we discussed in our previous tutorials
949:01 - when we had called the recursive version of the pre-order tree traversal
949:08 - so friends in this tutorial we discussed about the iterative version of pre-order tree traversal
949:13 - i hope you like this video please like comment share and subscribe my youtube channel
949:18 - thanks have a nice day
949:22 - hello friends welcome to my new data structures and algorithm in java tutorial series video
949:29 - friends in this tutorial we will discuss recursive in-order traversal of a binary tree in java
949:36 - so friends what is in-order binary tree traversal
949:40 - so here you can see that in-order binary tree traversal has basically three steps
949:47 - and we apply these three steps to each and every node of the binary tree
949:51 - so the basic step involved in in-order binary traversal is we first visit the left sub tree
949:57 - for a particular node and then we visit the node and after visiting that node we go to its right
950:03 - sub tree and these three steps we apply on each and every node of the binary tree
950:09 - so let's take an example of the below binary tree now let's suppose we want to visit each
950:14 - and every node of this binary tree so we start with the root so here you can see root is pointing
950:20 - to node one now we apply these three steps on the node one so here you can see basically the step
950:28 - two is involved in the processing of the node which we are currently pointing to so here before
950:32 - processing the node one what we do we first traverse its left sub tree so here you can see
950:40 - this is the complete left sub tree which we want to traverse before we process this node
950:45 - and after we process this complete left sub tree we then visit this node and after visiting this
950:51 - node we go to its right sub tree so here when we are at node one then before processing this node
950:58 - we go to its left sub tree now as you go to its left sub tree we encounter the node two
951:05 - so when we encounter the node two we apply these three steps over the node two
951:12 - and before processing the node two we first traverse its left sub tree then we process
951:17 - the node and then we go to its right sub tree so here before processing the node two we go to its
951:23 - left sub tree first so once we reach the node four we apply these three steps on the node four
951:30 - So before processing the node 4, we traverse to its left subtree then we process the node
951:36 - and then we go to its right subtree.
951:39 - So here you can see node 4 has no left subtree therefore we are done with the processing
951:43 - of the left subtree and after we are done with the processing of left subtree we actually
951:49 - visit the node.
951:50 - So the first element we visit is the node 4 and after we are done with the node 4 we
951:56 - go to its right subtree and we know that node 4 has no right subtree therefore we are done
952:01 - with the processing of the node 4 completely.
952:05 - So the call returns back to the node 2 and from the node 2 perspective we have actually
952:10 - visited its complete left subtree.
952:13 - So now is the chance to visit the node 2.
952:16 - So we actually visit a node 2 and then we go to its right subtree.
952:21 - So when we reach to the node 5 we actually apply these 3 steps now on node 5.
952:26 - We traverse its left subtree then we visit the node and then we go to its right subtree.
952:32 - So here you can see node 5 has no left subtree therefore we are done with the processing
952:36 - of the left subtree.
952:39 - So then we process the node 5 and after we process the node 5 we go to its right subtree
952:44 - and we know that node 5 has no right subtree therefore we are done with the processing
952:48 - of the node 5.
952:50 - So friends after the node 5 is processed the call returns back to the node 1 and from
952:55 - the node 1's perspective we have completely traversed the left subtree now.
953:00 - So now is the chance to visit the node 1.
953:03 - So we visit the node 1 and then we go to its right subtree.
953:08 - So once we reach to the node 3 we apply these 3 steps over the node 3.
953:13 - So before processing of the node 3 we first go to its left subtree then we visit the node
953:18 - and then we go to its right subtree.
953:21 - So when we reach to its left subtree we encounter a node having data as 6.
953:26 - So we apply these 3 steps now over node 6 we visit its left subtree then we process
953:32 - the node and then we visit the right subtree.
953:36 - So here as node 6 has no left subtree therefore we are done with the processing of the left
953:41 - subtree and then we actually visit the node and after visiting the node we go to its right
953:46 - subtree.
953:48 - And as node 6 has no right subtree therefore we are done with the processing of the node
953:52 - 6 completely.
953:54 - Then our call goes back to the node 3 and we know that we have completely visited its
953:59 - left subtree.
954:01 - So now we can visit the node 3.
954:04 - So once we visit the node 3 the third step is involved is we go to its right subtree.
954:10 - So as we go to its right subtree we encounter a node having data as 7.
954:15 - So on this node 7 we now apply these 3 steps.
954:19 - We first visit the left subtree of it then we visit the node and then we visit the right
954:24 - subtree.
954:25 - So friend as we know that node 7 has no left subtree therefore we are done with the processing
954:32 - of the left subtree for the node 7 and then we actually visit the node 7 and then we go
954:37 - to its right subtree.
954:39 - So here we can see node 7 has no right subtree therefore we are done with the processing
954:44 - of the node 7.
954:46 - So here we have visited each and every node and to each and every node we applied these
954:50 - 3 steps that before processing the node we actually visited its complete left subtree
954:57 - then we visited the node and then we went to its right subtree.
955:02 - So friend these are the steps involved in order binary tree traversal.
955:07 - Now let's go ahead and see the demonstration of the algorithm.
955:11 - So friend let's suppose we want to traverse this binary tree where root is pointing to
955:15 - the node 9 whose left is pointing to node 2 and whose left is pointing to node 4 and
955:22 - node 4 has no left and right subtree therefore they are pointing to null.
955:27 - Node 2 has no right subtree therefore is pointing to null and here node 9 right is pointing
955:32 - to the node 3 which have no left subtree and the right subtree.
955:38 - So friends below you can see the algorithm for the in order binary tree traversal and
955:43 - here you can see the method name is in order which takes in a root and in the method we
955:48 - are actually again calling the in order method therefore these calls are recursive in nature.
955:54 - So in order to understand this recursion we are using this calls track where we are keeping
956:00 - the information for the current executing method and we are also keeping the track of
956:05 - the root node which is getting executed in the particular method call and we are also
956:10 - keeping the track of the line number whose significance we will see once we demonstrate
956:14 - the algorithm.
956:16 - So let's see the demonstration of this algorithm step by step.
956:21 - Now when we call in order method and we pass the root so currently you see root is pointing
956:27 - to the node 9 so we know that this method will be part of our call stack.
956:34 - So it would look something like this that now this method will be part of our call stack
956:38 - and this method will be executed with the root as 9 because currently root is pointing
956:44 - to 9 we move ahead and we check whether root is equal to null or not.
956:49 - So friends why we are providing this condition as this is the base case for our recursion
956:55 - because in the in order method we are again calling the in order method recursively.
956:59 - So friends in order to break this recursion we need to provide a base case and if we don't
957:04 - provide this base case then this method will call each other recursively.
957:08 - So in order to stop this we are providing this base case.
957:12 - So currently you see root is pointing to the node 9 therefore it's not null.
957:18 - So the condition in a block comes out to be false.
957:23 - So in the first step what we do is so what we discuss in the slide that before processing
957:27 - of a node we will first traverse this left sub tree.
957:32 - So we again call the in order method and this time we are passing roots left because
957:37 - we want to process the left sub tree now.
957:40 - So here you can see root left is the node 2 therefore this in order method will call
957:46 - the in order method again with the root as 2.
957:50 - So friends here we are leaving this method and now we are entering to this method again.
957:55 - So we will keep the track of the line number that at the line 5 we left this method so
958:01 - that once this method is processed we again return back to this method and will start
958:05 - executing from the line 5.
958:08 - So therefore we will keep the information for the line number whenever we leave any
958:12 - particular method.
958:14 - So here we keep the track of the line number which is 5 that we are leaving this in order
958:19 - method at the line 5 and we are calling this in order method again with a root 2.
958:27 - So friends this method will be called again and this time the root will be the node 2.
958:33 - So here now root instead of pointing to 9 it will point to 2 and we also know that we
958:41 - have left this method in order method so there will be one more method on the stack.
958:48 - So now this in order method will start executing with the root as 2.
958:53 - So let's see the working we will first check whether root is equal to null or not.
958:58 - So currently root is pointing to the node 2 therefore it's not null.
959:04 - So friends as we discussed in the slide before processing any node we have to process it
959:08 - left sub tree first.
959:10 - So in order to visit the node 2 we will first have to visit its left sub tree.
959:15 - So here we again call in order method and we pass root left so here you can see root
959:20 - is pointing to the node 2 and we will call in order method and we will pass the root
959:24 - dot left which is node 4 and as we are leaving this method we will keep the track of the
959:30 - line number.
959:35 - So here now in order method will start executing with the root as 4.
959:40 - So currently root is pointing to the node 2 so now it will point to node 4 and here
959:48 - you can see there would be one more method coming on the stack.
959:55 - Now this in order method will start executing with the root as 4 moving ahead we will check
960:02 - whether root is equal to null or not.
960:04 - So currently root is pointing to the node 4 therefore it's not null.
960:11 - And here before processing the node 4 we have to first process its left sub tree therefore
960:15 - we are again calling the in order method and we are passing root left so currently
960:21 - root is pointing to the node 4 so now we are calling this in order method and we are passing
960:26 - the null value to it.
960:30 - And here we will keep the track of the line number that as we are leaving this method
960:36 - and we are calling this method so we are keeping the track of the line number.
960:43 - So friends now in order method will be called again and this time the root will point to
960:47 - null.
960:48 - So here you can see currently root is pointing to 4 and as we discussed that we are going
960:52 - to root left so now root will point to null and we also know that once this method gets
961:01 - start executing there will be one more method on the call stack.
961:07 - Now here you can see this in order method has root as null.
961:12 - Moving ahead we will check whether root is equal to null or not.
961:16 - So currently you see root is equal to null therefore we have reached our base case which
961:22 - makes sense because when we encounter a null value it means there are no nodes to be traversed.
961:28 - So we simply return from this method and once we return from this method we know that this
961:36 - method will be removed from the call stack and the execution point will go to the method
961:43 - which called this method.
961:47 - So now execution point reaches here so friends we know that at line 5 we left this method
961:54 - so we will start executing from the line 5 itself.
961:58 - So our execution point will now start from the line 5 because we have processed this
962:03 - information earlier and we also know that when this method was getting executed root
962:08 - was pointing to 4 so when step of execution reaches here root will point to 4.
962:17 - Moving ahead so friends here you can see for the node 4 we have processed left sub tree
962:25 - now is the time to process the actual node.
962:29 - So therefore we simply print root's data on the console.
962:33 - So on the output you can see 4 will be printed because root's data is 4.
962:40 - Moving ahead and we also saw in the slide that after we process the node we then go
962:47 - to its right sub tree.
962:49 - So in order to go its right sub tree we again call the inorder method and this time we pass
962:54 - root's right so currently root is pointing to the node 4 and its right is pointing to
962:59 - null therefore we will again call the inorder method and will pass the null value to it
963:06 - and here as we are leaving this method on the line 7 we will keep the track of the line
963:11 - number so now it will be 7 and we also know that once we call this method so now inorder
963:22 - method will be called again and this time with root's right which is null.
963:27 - So friend currently root is pointing to node 4 and when we call this inorder method with
963:32 - a null value therefore now root will point to null and we also know that there will be
963:39 - one more method on this call stack with the root as null.
963:47 - So let's execute this method in the first step we will check whether root is equal to
963:52 - null or not so currently root is equal to null therefore the condition comes out to
963:58 - be true and will simply return from this method.
964:03 - So once we return from this method we know that this method will be removed from this
964:07 - call stack and the method which called it the execution point will go there.
964:16 - So now the execution point reaches to this method and we also know that we left this
964:21 - method from the line number 7 so therefore the execution point will start from the line
964:26 - 7 and we also know that when we left this method root was pointing to node 4 so therefore
964:34 - now root will point to node 4 again and then will start executing from the line 7.
964:46 - So when we reach the line 8 we know that we have completely processed this inorder method
964:52 - so therefore this method will be removed from the call stack and the call will go to the
964:58 - method which had called this method.
965:02 - So now call will go to this inorder method and we know that we had left this method from
965:07 - the line number 5 therefore the execution point will start executing after the line
965:13 - 5 and we also know that when we are executing this inorder method at that time root was
965:22 - pointing to node 2 so therefore now root will point to the node 2 and will start executing
965:30 - after line 5.
965:33 - So here we can see that before processing the node 2 we have completely visited its
965:37 - left subtree so now is the time to process the node itself therefore we simply print
965:43 - its data on the console.
965:47 - So you can see 2 gets printed on the console and after we process the node we know that
965:54 - now we have to go to its right subtree.
965:58 - So we again call inorder method and we pass root right value which is null and we also
966:04 - know that as we are calling this inorder method we will update the line number here.
966:13 - So now the execution point reaches to this inorder method and we know that there will
966:18 - be one more method on the call stack with the root as null.
966:24 - So here you can see root is pointing to node 2 so now this root will point to null and
966:33 - will start executing this inorder method.
966:37 - So in the first step we check whether root is equal to null so here you can see root
966:41 - is equal to null therefore we will simply return from this method and we are returning
966:46 - from this method that because we have already processed its right subtree.
966:51 - So once we return from this method we know that now this inorder method will be removed
966:54 - from the call stack completely and now the execution point will reach to this inorder
967:01 - method and will now start executing this inorder method from the line number 7.
967:10 - So we will start executing from the line number 7 and as we know that when we were
967:14 - executing this inorder method root was pointing to 2.
967:18 - So now root will point to 2 and then we simply execute this inorder method.
967:27 - So once we reach to the end of this method we know that now this method will be removed
967:30 - from the call stack and the execution point will reach here.
967:38 - So we will start from the line number 5 and we also know that when we are executing this
967:45 - method root was pointing to 9.
967:48 - So therefore now root will point to 9 and then we will simply execute the steps.
967:58 - So friends here you can see before we processed node 9 we completely traversed left subtree
968:04 - and after we traverse its left subtree completely now we are visiting the node.
968:09 - So we are simply printing its data on the console moving ahead and once we are done
968:18 - with the process of this node we have to process its right subtree.
968:22 - So therefore we are again calling inorder method and we are passing the value root right
968:26 - to it.
968:27 - So here you can see root right is the node 3 and as we are calling this new method we
968:33 - are updating the line number.
968:39 - So point of execution reaches to the inorder method with a root as 3.
968:46 - So now root is pointing to 3 and we also know that as this is a new method on the stack
968:52 - there will be one entry on the call stack.
968:56 - So here now this inorder method will start executing with a root as 3.
969:03 - So we first check whether root is equal to null or not.
969:05 - So currently root is pointing to 3 therefore it's not null.
969:11 - And then for the root 3 we apply the inorder traversal again.
969:15 - We first visited its left subtree.
969:18 - So in order to visit its left subtree we are calling inorder method and we are passing
969:22 - root left value to it.
969:24 - So here you can see root left is pointing to null therefore we are calling this inorder
969:28 - method with the value as null.
969:31 - And as we are leaving this method and we are calling this new method we will update the
969:35 - line number.
969:39 - So then execution point will reach to this inorder method with a root as null.
969:44 - So we know that there will be one more method on the call stack with a root as null.
969:52 - And now root will point to null.
969:58 - Moving ahead we check whether root is equal to null or not.
970:03 - So currently root is equal to null.
970:08 - Therefore we simply return from this method and this method will be completely removed
970:12 - from the call stack.
970:16 - And as this method is removed from the call stack the execution point reaches to this
970:21 - inorder method which actually called the inorder method with a null value.
970:27 - And from which line we have to start we have to start the execution from line number 5.
970:32 - And we also know that when we were executing this inorder method root was pointing to 3.
970:38 - So now root will point to 3.
970:44 - So friends now in this step as we have processed the left subtree completely then now we will
970:49 - process the node itself.
970:51 - So we are simply printing the data on the console.
970:59 - And then as we have to process its right subtree now.
971:02 - So we are calling inorder method and we are passing root's right which is the null value.
971:09 - And before calling this new method we are updating the line number.
971:17 - So when the point of execution reaches the inorder method root is null.
971:23 - So there will be one more method on the stack with the root as null.
971:27 - So now this root will point to null.
971:33 - And we will start executing this method.
971:36 - So in the first step we will check whether root is equal to null or not.
971:40 - So currently root is equal to null.
971:41 - Therefore we will simply return from this method.
971:46 - And when we return we know that this method will be removed completely from the call stack.
971:52 - And the point of execution reaches here.
971:57 - So we know that we will execute this method from the line number 7.
972:02 - And we also know that at that moment root was pointing to 3.
972:06 - So now root will point to node 3.
972:10 - And then we will start executing from the line 7.
972:14 - So when we reach to the line 8 we know that we have completely executed this inorder method.
972:19 - So this will be removed from the call stack.
972:24 - So friends now the execution point reaches to this inorder method.
972:30 - And we will start executing from the line 7.
972:34 - And we also know that when we are executing this method root was pointing to 9.
972:40 - Therefore we will simply traverse root to 9.
972:46 - And then we simply process all the steps for this inorder method.
972:49 - So now this will be removed from the stack.
972:54 - So friends as we know there are no methods left on the call stack.
972:57 - Therefore we have successfully executed the inorder binary tree traversal.
973:02 - And the output you can see is 4293.
973:07 - So friends this was the demonstration of the algorithm.
973:09 - Now let's go to Eclipse and see the working code.
973:14 - So friends in my previous tutorial I had created a class by name binary tree.
973:18 - And I have implemented binary tree into that class.
973:22 - You can watch my previous tutorial inorder to understand its working.
973:27 - So in this tutorial we will simply write the code for inorder binary tree traversal.
973:36 - So let's say I give the method name as public void inorder.
973:47 - And as we discussed in the slide this inorder method takes in a root.
973:55 - Now in the first step we check if root is equal to null then we will simply return from
974:05 - this method.
974:07 - Because this is the base condition as we are as we are calling this inorder method recursively
974:12 - we have to provide a base case so that we can get exit from this recursion.
974:20 - And as we discussed in our slide that before visiting any node we will first visit its
974:26 - left sub tree.
974:30 - So we will call inorder method and we will pass root left to it.
974:38 - And after we process its left sub tree we will visit the node.
974:47 - So we simply print root's data on the console.
974:57 - And in the last step we will again call inorder method and we will process root's right sub
975:03 - tree by calling root's right in the inorder method.
975:08 - So friend this is the algorithm for the inorder binary tree traversal.
975:13 - Now let's test its working.
975:20 - Now in my previous tutorial I had created one binary tree and this is the same tree
975:24 - which we discussed in the slide.
975:29 - Use this create binary tree method so here in the main method we will call create binary
975:34 - tree and then we will call the inorder method and here we will pass the root.
975:49 - Now if I run the code.
975:57 - So here you can see it printed 4293 which is the same output which we saw in the slide.
976:05 - So friends in this tutorial we discussed the recursive way of inorder binary tree traversal.
976:11 - I hope you liked this video.
976:12 - Please like, comment, share and subscribe my YouTube channel.
976:16 - Thanks have a nice day.
976:19 - Hello friends welcome to my new data structures and algorithm in Java tutorial series video.
976:25 - Friends in this tutorial we will discuss iterative inorder traversal of a binary tree in Java.
976:33 - So friends in my previous tutorial we discussed about the recursive inorder tree traversal.
976:39 - So steps involved in inorder tree traversal are as follows that before visiting any particular
976:44 - node we first visit its left subtree then we actually visit the node and then we visit
976:49 - its right subtree and this steps is applied over each and every node.
976:56 - So friends if we apply inorder tree traversal over this tree then what we need to do is
977:01 - before visiting the node 1 we have to actually traverse its left subtree then we have to
977:06 - visit the node and after visiting the node we have to traverse its right subtree.
977:12 - So when we start with the node 1 we have to go to its left subtree first because as
977:17 - we go to its left subtree there is no way we can reach to the node 1 again therefore
977:23 - we need an additional data structure which can hold this node so that once we complete
977:27 - the visiting of left subtree we can pull the element out of that additional data structure
977:31 - and we can visit it and after visiting it we can go to its right subtree.
977:37 - So the additional data structure that we use here is stack.
977:41 - So here you can see we are using stack which is the leafo data structure which means the
977:45 - element inserted last into the stack would be the first one to be removed.
977:49 - In order to know more about the stack you can watch my previous tutorials.
977:54 - Before visiting this node we actually put it on the stack and then we go to its left
977:58 - subtree and this we do for each and every node and once we actually visit the left subtree
978:05 - of any node then we pop the element out of the stack we visit that node and then we go
978:09 - to its right subtree.
978:11 - So let's see the demonstration of this algorithm step by step.
978:15 - So let's suppose we are given with a binary tree having 6 nodes and where root is pointing
978:20 - to the node 1.
978:23 - So let's apply this algorithm over this binary tree and let's see how we can traverse each
978:27 - and every node of a binary tree using the in order tree traversal.
978:34 - So basically in the first step we check whether root is equal to null or not so if root is
978:38 - equal to null we simply return because there are no nodes in the tree to be traversed.
978:45 - So currently you see root is pointing to node 1 therefore it's not null.
978:49 - So the condition in if block comes out to be false.
978:54 - So after the if block what we actually do is we actually create a stack.
978:59 - Now this stack will hold the tree nodes for us.
979:03 - So it would look something like this moving ahead.
979:10 - So in the next step what we do is we create a temporary tree node and we assign the value
979:15 - of root to it.
979:17 - So now the temp will point to root so it would look something like this that is temporary
979:22 - node is pointing to root moving ahead.
979:30 - So friends in order to traverse this binary tree using in order tree traversal we actually
979:35 - use a while loop and inside this while loop we are actually placing two conditions.
979:41 - So we are iterating this while loop till stack is empty and temp becomes null.
979:46 - So currently you can see stack is empty.
979:51 - So the condition comes out to be false but you can also see the temp is actually pointing
979:56 - to a node therefore it's not null.
979:58 - So the second condition comes out to be true and as there is a or operator between these
980:03 - two conditions therefore the overall condition comes out to be true.
980:07 - So the while loop executes.
980:12 - So in the while loop we actually encounter an if else block.
980:15 - So in the if block we check whether temp is equal to null or not.
980:18 - So currently you can see temp is pointing to the node 1 therefore it's not null.
980:23 - So the condition in if block comes out to be true.
980:30 - So in the if block the first step we do is we actually push the temporary node on the
980:34 - stack which makes sense because before visiting this node we have to first visit its left
980:40 - sub tree.
980:42 - So therefore we are actually pushing this temporary node on the stack so that once we
980:46 - are done with the left sub tree then we can pop this element out and then we can visit
980:50 - this node and after visiting this node we can go to its right sub tree.
980:55 - So when we push the temporary node on the stack it looks something like this that now
980:59 - node 1 is on the stack moving ahead and in the next step we simply traverse the temp
981:09 - to its left because we have to first visit the left sub tree therefore we need to traverse
981:14 - temp to its left.
981:17 - So we are assigning the value of temp.left to temp so here temp.left is the node 2 therefore
981:24 - now temp will point to the node 2 so it would look something like this.
981:31 - The temp is now pointing to the node 2 moving ahead.
981:39 - In the while loop we will again check whether stack is empty or not and then we will check
981:43 - whether temp is pointing to null or not.
981:46 - So currently you can see stack is not empty and temp is pointing to the node 2 therefore
981:51 - its not null.
981:53 - So the condition in while block comes out to be true and then the if log will check
981:59 - whether temp is equal to null or not.
982:02 - So here you can see temp is pointing to the node 2 therefore its not null so the condition
982:07 - in if log comes out to be true and then we will simply push that node 2 on the stack
982:17 - because before visiting the node 2 we have to first visit its left sub tree completely
982:22 - therefore we will push the node 2 on the stack so it would look something like this that
982:28 - now node 2 is on the stack and then we will simply traverse temp node to its left which
982:36 - is the node 4 so it would look something like this.
982:41 - Now temp is pointing to the node 4 and then again in the while block we will check whether
982:49 - stack is empty or not and temp is equal to null or not.
982:53 - So currently stack is not empty and temp is pointing to node 4 so therefore the condition
982:58 - in while block comes out to be true and then in if log will check whether temp is equal
983:05 - to null or not so currently temp is pointing to node 4 therefore its not equal to null
983:11 - so the condition in if log comes out to be true.
983:17 - So then in the first step what we do is we simply push the temp on the stack because
983:22 - before visiting the node 4 we have to first traverse its left sub tree completely therefore
983:27 - we are pushing the node 4 on the stack so it would look something like this.
983:32 - Now node 4 is on the stack moving ahead and in the next step we will simply traverse temp
983:41 - by assigning temp.left value to temp which makes sense because before visiting this node
983:47 - we have to first visit its left sub tree therefore not temp has to move to its left sub tree.
983:53 - So now temp will point to a node which is left to node 4 and here you can see it is
983:58 - pointing to null so therefore now temp will point to null.
984:04 - Moving ahead we will again check whether stack is empty or not and temp is equal to null
984:12 - or not so currently you can see temp is equal to null but stack is not empty therefore the
984:18 - condition in while block comes out to be true and then in the if log will check whether
984:24 - temp is equal to null or not so here you can see temp is equal to null therefore the
984:29 - condition in if log comes out to be false.
984:34 - So the else block will be executed and here we can see that node 4 left is pointing to
984:42 - null therefore there is no node to be visited so therefore we have visited its left sub
984:47 - tree completely so now is the turn that we can visit the node 4.
984:52 - So in order to do that we will simply pop the first element from the stack and will
984:57 - assign that temp to that node so here you can see as stack is a leafo data structure
985:03 - so the last element inserted is the first one to be removed so when we do a pop the
985:08 - node 4 will be popped out and value of node 4 will be assigned to temp so therefore once
985:15 - the node 4 is popped out temp will now point to the node 4 so it would look something like
985:21 - this right now node 4 is popped out and whatever the value it holds it will be assigned to
985:29 - temp so now temp will point to node 4 so it would look something like this moving ahead
985:40 - so here for the node 4 we have visited its left sub tree completely so now is the time
985:45 - to visit the node 4 so on the console we are simply printing the data associated with the
985:50 - temporary node so here node 4 becomes the first node to be traversed so on the output
985:57 - 4 will be printed moving ahead and as we have visited node 4 now will simply traverse to
986:06 - its right sub tree so we are simply assigning value of temp.right to temp so here temp.right
986:13 - is pointing to null so therefore now temp will point to null moving ahead so in the
986:25 - while block we will check whether stack is empty or not so currently stack is not empty
986:29 - and temp is equal to null or not so currently temp is equal to null but stack is not empty
986:36 - therefore the condition in while block comes out to be true and we will check whether temp
986:42 - is equal to null or not so currently temp is equal to null therefore condition in if
986:46 - block comes out to be false and the else block will be executed so here you can see for the
986:56 - node 4 as its left is pointing to null and its right is pointing to null it means there
987:01 - are no nodes on the left and the right side for the node 4 to be traversed therefore for
987:07 - the node 2 we have completely visited its left sub tree because we have printed the
987:11 - output 4 which means we have traversed this node so here what we are doing is we are again
987:17 - popping the element from the stack and we are assigning it to temp so when we pop an
987:22 - element from the stack we know that it's node 2 so it would look something like this that
987:28 - node 2 is popped out and its value will be assigned to temp so it means now temp will
987:32 - point to node 2 and which makes sense because we have completely traversed the left sub
987:40 - tree for the node 2 so now it's time to traverse the node 2 so the next step will simply print
987:48 - the data associated with the temporary node which is 2 so on the console we simply print 2
987:54 - and then we will simply traverse temp to its right so here as we have visited the left sub
988:05 - tree for the node 2 and we also visited the node 2 now is the time we go to its right sub tree
988:11 - therefore we are simply assigning temp.right value to temp so it would look something like
988:17 - this so now temp is pointing to the node 5 because it is on the right of the node 2 moving
988:25 - ahead now in the while loop we will check whether stack is empty or not so currently stack is not
988:32 - empty and temp is also pointing to node 5 therefore the condition in while block comes
988:37 - out to be true and then in if block we will check whether temp is equal to null or not so
988:44 - currently temp is not equal to null because it is pointing to the node 5 therefore the condition
988:49 - in if block comes out to be true so what we do is we simply push the node 5 on the stack because we
988:58 - cannot visit this node till we visit its left sub tree completely therefore we need a way to
989:03 - store this element on the stack so we are simply pushing the temporary node on the stack so now
989:11 - node 5 is on the stack and then we simply go to its left because we need to traverse its left
989:20 - first so now temp is pointing to null in the while block we will check whether stack is empty or not
989:33 - so stack is not empty but temp is pointing to null so the overall condition comes out to be true so
989:41 - the while block executes in the if block will check whether temp is equal to null or not so
989:48 - temp is equal to null therefore the condition in if block comes out to be false and the else block
989:53 - will be executed so as node 5 has no left sub tree therefore simply means that we have visited
990:02 - its left part now we will actually visit the node so we simply pop the element from the stack so
990:08 - when we pop the element from the stack we know so we know that 5 was inserted last therefore it
990:13 - would be first one to be removed and when we remove the node 5 we assign its value to temp
990:19 - so now temp will point to the node 5 so it would look something like this so now temp is pointing
990:28 - to the node 5 and then we will simply visit the node 5 so on the console we print the data
990:38 - associated with the temporary node which is 5 moving ahead and once we have visited this
990:48 - node now it's time to go to its right sub tree so now temp will point to null moving ahead
990:57 - in the while block we will check whether stack is empty or not so currently stack is not empty
991:06 - but temp is pointing to null so the overall condition comes out to be true because stack
991:12 - is not empty so the while block executes in the block will check whether temp is equal to
991:20 - null or not so temp is equal to null therefore the condition in a block comes out to be false
991:25 - and the else block will be executed so here you can see we have completely visited the node 5
991:35 - and this node 5 is actually right to the node 2 therefore we have completely visited a left sub
991:41 - tree for the node 1 so when we pop an element from the stack one gets popped out and now temp
991:49 - will actually point to the node 1 so node 1 is popped out and its value will be assigned to
991:58 - temp so now temp will point to node 1 moving ahead so friends here you can see for the node 1 you
992:11 - completely visited its left sub tree by printing 4 2 and 5 so now we can actually visit this node
992:18 - so therefore we simply print the data associated with this temporary node which is 1 so 1 gets
992:26 - printed on the console therefore we have visited this node and the next step as we have visited
992:34 - this node now we'll simply go to its right sub tree therefore we simply assign temp right to temp
992:41 - so here you can see temp right is pointing to the node 3 therefore now temp will point to the node
992:47 - 3 again in the while block will check whether stack is empty or not so here you can see stack
992:59 - is empty so the first condition comes out to be false but here you can see temp is pointing to
993:05 - the node 3 therefore it's not equal to null so the second condition comes out to be true so here
993:11 - the overall condition comes out to be true and the while block executes so here we will check
993:19 - whether temp is equal to null or not so currently temp is pointing to the node 3 therefore it's not
993:23 - equal to null so the condition in if block comes out to be true and here before visiting the node
993:34 - 3 we have to first visit its left sub tree completely therefore we need a way to store this
993:40 - element on the stack so we simply push the temporary node on the stack so it would look
993:46 - something like this now 3 is on the stack and then we'll simply go to its left sub tree because
993:57 - this left sub tree we need to visit first before actually visiting the node 3 so we are simply
994:03 - assigning temp dot left value to temp so here you can see temp left is pointing to the node 6 so
994:09 - therefore not temp will point to the node 6 in the while block we will again check whether
994:22 - stack is empty or not so currently stack is not empty so the first condition comes out to be true
994:27 - and temp is actually pointing to the node 6 therefore the second condition also comes out
994:32 - to be true so the overall condition comes out to be true and while block executes so the first
994:41 - step will check whether temp is equal to null or not so currently temp is pointing to node 6
994:45 - therefore it's not equal to null so the condition in if block comes out to be true and then we'll
994:55 - simply push the node 6 on the stack because you can't visit this node till we process its left
995:01 - sub tree completely therefore we are storing the node 6 on the stack so after pushing the
995:08 - node 6 on the stack we simply go to its left sub tree so not temp will point to the left of
995:17 - the node 6 which is null moving ahead now currently stack is not empty but temp is pointing
995:33 - to null therefore the overall condition comes out to be true we check whether temp is equal to null
995:41 - or not so temp is equal to null therefore condition and if block comes out to be false and the else
995:47 - block will be executed so here as node 6 has no left sub tree therefore we are done with the
995:57 - processing of the left sub tree for the node 6 so now is the time that we can visit the node 6 so
996:04 - what we do is we simply pop the element from the stack because we know that we have actually stored
996:09 - this element on the stack so we pop this element from the stack and we'll assign it to temp so it
996:15 - would look something like this so now temp is pointing to the node 6 moving ahead and then
996:27 - we are simply printing the data associated with node 6 so 6 gets printed on the console
996:32 - and as we have visited this node now is the time to go to its right sub tree so therefore
996:43 - not temp will point to null so in the while block we'll check whether stack is empty or not so
996:56 - currently stack is not empty so this condition comes out to be true but temp is pointing to
997:02 - null so the overall condition comes out to be true so the while block executes we check whether
997:09 - temp is equal to null or not so here temp is equal to null therefore the condition in a block comes
997:15 - out to be false so the else block will be executed so friends here you can see for the node 6 we
997:25 - have actually visited its left sub tree we have visited the node and we have visited its right sub
997:31 - tree so therefore we have completely visited is node 6 and here you can see node 6 is to the left
997:38 - of node 3 so now you actually traverse the left sub tree for the node 3 so therefore now we can
997:45 - visit the node 3 so in order to reach to node 3 we know that we already stored this node on the
997:51 - stack so we simply pop this element from the stack and we'll assign it to temporary node so it would
997:59 - look something like this that node 3 gets popped out and its value is assigned to temp so therefore
998:05 - not temp will point to node 3 and then we'll simply print the value associated with this temporary
998:16 - node which is actually 3 so 3 gets printed on the console and as you have visited the node 3
998:27 - completely now we need to visit its right sub tree therefore we are simply assigning temp right to
998:32 - temp so now temp will actually point to null so now again we'll check the condition in while loop
998:42 - so first we check whether stack is empty or not so currently stack is empty so the first condition
998:49 - comes out to be false and then we'll check whether temp is equal to null or not so here you can see
998:54 - temp is equal to null therefore the second condition comes out to be false so overall both
999:00 - the conditions are coming out to be false so the while loop terminates and here you can see we have
999:08 - actually visited all the nodes of this binary tree and we have printed the data associated with those
999:13 - nodes which is 4 2 5 1 6 3 so friends this was a demonstration of the algorithm and let's go to
999:24 - Eclipse and see the working code so friends in my previous tutorial we actually created one class by
999:32 - name binary tree and we actually implemented the binary tree into this class so friends in order to
999:39 - understand binary tree more you can watch my previous tutorials so in my last tutorial we
999:48 - actually discussed the recursive version of the in order tree traversal but in this tutorial we
999:53 - will discuss the iterative way for the in order tree traversal so here I will just comment this
1000:01 - code and below I will create the method as in order now this in order method will take in a root
1000:18 - so let's code the algorithm which we saw in the slide so the first step will check that whether
1000:29 - root is equal to null or not so if root is equal to null will simply return from this method because
1000:37 - there are no nodes in the binary tree to be traversed and the first step will create a stack
1000:43 - which will hold the tree nodes for us and as we discussed in the slide we'll create a temporary
1001:01 - node and we'll start it from the root so tree node temp and we'll simply assign the value of root to it
1001:10 - and now we'll simply provide a while loop and we also saw that we have placed two condition on that
1001:23 - that whether stack is empty or not so the first condition is we are checking whether
1001:31 - stack is empty or not and then we are providing an or and the second condition we provide is
1001:38 - temp should not be equal to null so in the while loop we'll simply provide an if else block so in
1001:55 - the if block will first provide a condition that temp should not be equal to null and if temp is
1002:03 - not equal to null then we simply push the temp on the stack and then we traverse temp to its left
1002:14 - and if temp is equal to null then we simply pop an element from the stack and we will assign its
1002:31 - value to the temporary node once we pop the element from the stack we'll simply print it
1002:38 - on the console so temp.data and as we have printed the data on the console then we'll simply traverse
1002:51 - temp to its right so friend this is the code for iterative in order tree traversal now let's test
1003:02 - is working in the main method so here first we have initialized the binary tree and then we have
1003:09 - created a binary tree with few nodes so here in create binary tree we have actually created few
1003:17 - nodes which we also discussed in our previous tutorials you can watch my previous tutorial in
1003:22 - order to understand how this binary tree is created and after creating the binary tree with few nodes
1003:30 - we'll simply call the in order method and we'll pass the route to that method so if I run this
1003:39 - code now so here you can see it prints four two nine three because in the create binary tree the
1003:51 - root is nine and root left is second which is two and roots right which is three so so here nine
1003:59 - left is two and nine right is three and here you can see second left is fourth now the fourth node
1004:06 - is pointing to the second slab so nine is at the root its left is two and its left is four so
1004:13 - therefore so on the console it printed four then it printed two and then nine and then three because
1004:20 - as nine is on the root in order to process this node we have to first visit is left sub tree so
1004:26 - on its left is the node two and before processing the node two we have to go to its left sub tree
1004:32 - so which is four so four gets printed first then we print the node two and then we actually print
1004:39 - the root node and then we go to its right sub tree so we simply print three so friends in this
1004:48 - tutorial we discuss the iterative version of the in order tree traversal I hope you liked this
1004:53 - video please like comment share and subscribe my youtube channel thanks have a nice day
1005:02 - hello friends welcome to my new data structures and algorithm in Java tutorial series video
1005:07 - friends in this tutorial we will discuss recursive post-order traversal of a binary tree in Java
1005:14 - so friends what is post-order binary tree traversal basically there are three steps
1005:21 - involved in doing the post-order binary tree traversal and all these three steps are applied
1005:27 - over each and every node of a binary tree so if we take an example of a binary tree shown in
1005:32 - the slide then basically we start with the root node and we apply these three steps over the root
1005:39 - node so what actually we do is in order to visit this particular node first we actually visit its
1005:47 - left sub tree completely then we visit its right sub tree completely and then we actually visit the
1005:52 - node so here if we want to visit the node one then we have to first visit its left sub tree
1005:58 - completely and then we have to visit its right sub tree completely and then we can visit the
1006:04 - node and these three steps are applied over each and every node so suppose we are on node 2 so in
1006:12 - order to visit this node what we have to do first we have to visit its left sub tree completely then
1006:17 - we need to visit its right sub tree completely and then we can visit the node so therefore here
1006:22 - before visiting the node 2 we have to first visit the node 4 then we have to visit the node 5 and
1006:28 - then we can visit the node 2 so here basically these three steps are applied on each and every
1006:34 - node of a binary tree in order to do post-order binary tree traversal so friends in this tutorial
1006:42 - we are discussing the recursive post-order binary tree traversal below you can see the
1006:47 - algorithm for the post-order binary tree traversal so we will demonstrate this algorithm using this
1006:54 - binary tree here and we will see how we can apply this algorithm on this binary tree and whatever
1007:00 - the output comes out it will be displayed here so friends as this algorithm is recursive in nature
1007:06 - here you can see post-order method is again internally calling the post-order method therefore
1007:11 - this is the recursive nature algorithm so in order to understand the recursive nature of this
1007:17 - post-order method we will maintain a call stack so that we come to know that which method is
1007:22 - currently being executed and what is the root that is being processed we will come to know about line
1007:28 - number when we will actually discuss the post-order method so friends let's see the demonstration of
1007:34 - this algorithm step by step so friends here you can see the root is pointing to the node 9 and when
1007:42 - we call this post-order we actually pass the root node so to this post-order we are actually passing
1007:48 - the root node as 9 so friends when the point of execution reaches this post-order method we know
1007:54 - that on the call stack there will be one method by the name post-order and we also know that we
1008:00 - have passed the root as 9 so therefore on the call stack there will be one method by name post-order
1008:06 - which will start its execution moving ahead so friends the first step we actually check whether
1008:14 - root is equal to null or not so if root is equal to null we simply return from that method and here
1008:20 - you can see that this condition will act as our base case because as we are calling this post-order
1008:26 - method and internally again calls the post-order method we need to provide a base case to stop the
1008:32 - execution of this post-order method because if we don't provide the base case post-order method
1008:38 - we'll again call post-order method and it will go on calling each other infinitely so this is
1008:44 - the base case which is required in order to break the recursion and we will see its significance
1008:49 - later in that demonstration so currently as you can see root is pointing to 9 therefore
1008:56 - it's not equal to null so therefore the condition in if block comes out to be false
1009:04 - and at the line number 5 we see it calls post-order method again
1009:09 - and this time we are passing roots left which is the node 2 so friends as we discussed in
1009:16 - our previous slide that in order to visit a particular node we have to first visit its left
1009:21 - subtree completely then we have to visit its right subtree completely and then we can visit the node
1009:27 - so therefore before visiting the node 9 we have to first visit its left subtree completely
1009:32 - so we are again calling the post-order method and we are passing root.left to it
1009:37 - which is nothing but the node 2 so here you can see when we had called this post-order method
1009:43 - there was one method on the call stack and inside this we are calling this post-order method again
1009:50 - so when we call this post-order method we are leaving this post-order method
1009:54 - so in order to keep the track of this post-order method we will update the line number here
1010:00 - so it would look something like this that from line number 5 we are leaving this post-order
1010:05 - method and we are again calling the post-order method with the root as 2 so once this line gets
1010:12 - executed we know that post-order method will be called again and this time this post-order
1010:17 - method will be called with the root as 2 so therefore the line of execution reaches to the
1010:24 - post-order method again and we know that root will now point to the node 2
1010:28 - so now this method starts execution with a root as 2 therefore we know that there will be one
1010:36 - more method on the call stack so here now this post-order method will start its execution
1010:44 - with a root as 2 moving ahead we will check whether root is equal to null or not so here
1010:52 - root is pointing to the node 2 therefore it's not null so the condition in if block comes out to be
1010:57 - false and at the line number 5 we are again calling the post-order method and this time
1011:05 - we are passing root.left so here root left is nothing but the node 4 so why we are doing this
1011:12 - step is because because in order to process this node 2 we know that we have to first visit this
1011:17 - left subtree completely then we have to visit the right subtree completely and then only we
1011:22 - can visit this node and we also discussed in our previous slide that all the three steps
1011:27 - are applied to each and every node of the binary tree so therefore before traversing the node 2
1011:33 - we have to first visit this left subtree completely so therefore we are calling this post-order
1011:39 - method again with a root as 4 and we also know that we are leaving this post-order method so
1011:46 - we will update the line number here which is nothing but 5
1011:54 - so now point of execution reaches to this post-order method with the root as 4
1012:01 - and we also know that now root will point to the node 4
1012:06 - and as this method will start its execution there will be one more method on the call stack with
1012:10 - a root as 4 so here now this post-order method will start its execution with a root as 4
1012:23 - so in the first step we will check whether root is equal to null or not so currently
1012:27 - root is pointing to the node 4 therefore it's not null so the condition in if block comes out to be
1012:32 - false and then on the line number 5 we are again calling post-order method with the value as root
1012:41 - dot left so friends in order to process the node 4 we have to first visit its left subtree completely
1012:48 - then we have to visit its right subtree completely and then only we can visit the node 4 therefore
1012:53 - we are again calling the post-order method and this time we are passing the value as root dot left
1012:58 - so here root is pointing to node 4 and its left is pointing to null therefore now we are calling
1013:04 - this post-order method with a null value and we also know that we are leaving this method
1013:10 - from the line number 5 therefore we'll update the line number here as 5
1013:17 - so the point of execution will reach to this post-order method with a root as null
1013:23 - so therefore now root will point to null
1013:25 - and we also know that there will be one more method on the call stack
1013:31 - by the name post-order and whose root will be null
1013:37 - so now this post-order method will start its execution with a root as null
1013:45 - so here first we'll check whether root is equal to null or not
1013:48 - so currently you can see root is pointing to null therefore the condition in if block
1013:52 - comes out to be true so therefore we have reached our base case so we'll simply return
1013:57 - from this method so friends as we return from this method we know that this post-order method
1014:04 - is executed completely therefore this method will be removed from the call stack
1014:12 - so friends when this method is removed from the call stack the call goes to its previous
1014:16 - method which actually called this method with a root as null and we also know that we had left
1014:22 - this post-order method from the line number 5 so the point of execution reaches to this node
1014:28 - and we'll start our execution from the line number 5
1014:33 - because at this line number we have actually left this method so therefore we'll start our execution
1014:38 - from this line and we also know that when we had left this method at that moment root was pointing
1014:44 - to node 4 so therefore now root will point to node 4
1014:52 - moving ahead
1014:55 - so friends at the line number 6 we are again calling the post-order method
1014:58 - but this time we are passing it a value as root.right which actually makes sense because
1015:04 - in order to traverse this node 4 we have to first visit this left subtree completely
1015:09 - then we have to visit this right subtree completely and then we can visit the node
1015:13 - so therefore on the line number 5 we have completely visited the left subtree for the node 4
1015:20 - so now is the time to visit its right subtree so therefore we are again calling the post-order
1015:25 - method and we are passing the values root.right so here root is pointing to node 4 and its right
1015:31 - is pointing to null therefore we know that now we'll call this post-order method with a null value
1015:37 - and we also know that as we are leaving this post-order method from the line number 6 we
1015:44 - need to update the line number here so the line number becomes 6
1015:52 - so friends point of execution reaches to this post-order method and this time the root will
1015:56 - be null and we also know that once this method starts its execution there will be one more
1016:01 - method on the call stack with the root as null so it would look something like this
1016:08 - so we know that root is null so therefore now root will point to the null
1016:16 - moving ahead we will check in the flog whether root is equal to null or not so currently you
1016:22 - can see root is equal to null so therefore we'll simply return from this method
1016:26 - and as we return from this method we know that this method is executed completely
1016:34 - so this would be removed from the call stack
1016:39 - and the point of execution reaches to the post-order which actually called this method
1016:47 - and we also know that we had left this post-order method from the line number 6
1016:51 - therefore the execution will start from the line number 6
1016:57 - and we also know that when we had left this method root was pointing to the node 4
1017:02 - so therefore now root will point to node 4
1017:07 - moving ahead
1017:10 - so friends on line number 7 we will simply print the data associated with this root
1017:16 - so friends in order to process the node 4 what we have actually done is
1017:21 - we have first visited its left subtree completely then we visited its right subtree completely
1017:27 - so after doing this stuff we are actually visiting the node 4
1017:31 - so we are simply printing its data on the console which is 4
1017:39 - moving ahead
1017:43 - so friends at the line number 8 this post-order method on the call stack will complete its
1017:48 - execution so this would be removed from the call stack completely and the point of execution will
1017:56 - reach here and we also know that we had left this post-order method from the line number 5
1018:05 - so the point of execution reaches to the line number 5 and we also know that at that time
1018:10 - root was pointing to node 2 so here now root will point to node 2
1018:19 - and we'll start our execution with this post-order method
1018:21 - so friends in the line number 6 we are again calling the post-order method and this time we
1018:28 - are passing root.write to it so here you can see root is pointing to node 2 so we'll pass root.write
1018:35 - which is null to this post-order method so friends here you can see we are calling this post-order
1018:41 - method again with the root as null because root.write is nothing but null value and we also know that
1018:48 - we are leaving this method so we'll update the line number here and we know that line number is 6
1018:55 - so now line number changes to 6
1019:01 - so root is pointing to the node 2 therefore now it will point to its write which is null
1019:08 - now this method will start its execution so therefore there will be one more entry on the
1019:12 - call stack with the root as null moving ahead we'll check whether root is equal to null or not
1019:21 - so currently root is equal to null so therefore we'll simply return from this method
1019:28 - so when we return from this method we know that this post-order method is executed completely
1019:34 - so therefore it will be removed from the call stack
1019:36 - and once it's removed from the call stack the point of execution reaches to this post-order method
1019:48 - and we also know that we have left this method the line number 6
1019:52 - so we'll start its execution from the line number 6
1019:57 - and we also know that when we had left this method root was pointing to node 2
1020:03 - so here root is pointing to null so now it will point to node 2
1020:09 - moving ahead and at the step 7 we'll simply print the data associated with the root which
1020:16 - is nothing but 2 so friends here you can see before processing of the node 2 we first completely
1020:24 - visited its left subtree and we printed node 4 and then we visited its complete right subtree
1020:30 - which was actually null and then we actually visited the node 2
1020:35 - so it printed something like this 4 and then 2 moving ahead
1020:42 - so at line number 8 we know that this post-order method
1020:45 - has been executed completely so therefore this would be removed from the call stack
1020:52 - and the point of execution reaches to this post-order method
1020:55 - and we also know that when we had left this post-order method from the call stack
1021:02 - the line number was actually 5 so we'll start our execution from the line number 5
1021:08 - and we also know that root at that time pointed to the node 9
1021:12 - so therefore now root will point to node 9
1021:18 - and our execution starts from line number 5
1021:20 - so friends here you can see that we are on node 9 and in order to visit this node we have to
1021:29 - first visit its left subtree completely which you are actually done and then we have to visit its
1021:35 - right subtree completely so now we'll start to move to its right and then we can process this
1021:40 - node 9 so we are again calling the post-order method and this time we are passing the value
1021:46 - as root.write because we have to now visit its right subtree completely so therefore you can see
1021:52 - root's right is nothing but node 3 so we will be again calling this post-order method with a root
1021:58 - as 3 and we also know that we are leaving this method post-order from the line number 6
1022:05 - so therefore we'll update the line number here
1022:07 - so now point of execution again starts post-order method and this time with the root as 3
1022:21 - so now root is pointing to the node 3 and we also know that there
1022:24 - would be one more method on a call stack with a root as 3
1022:30 - so friends now let's start the execution of this post-order method with a root as 3
1022:38 - in the first step we'll check whether root is equal to null or not
1022:40 - so currently root is pointing to node 3 therefore it's not null
1022:47 - and at the line number 5 we will again call post-order method and this time we are passing
1022:52 - root's left which is nothing but the null value so here before processing of node 3
1022:59 - we know that we have to first process its left subtree and then we have to process its right
1023:03 - subtree so in order to process its left subtree we are calling this post-order method again
1023:10 - with roots left which is nothing but the null value
1023:14 - so friends we are leaving this post-order method at line number 5 so we will update the line number
1023:19 - here and then point of execution will call this post-order method again with root as null
1023:29 - so now root will point to null and we also know that there will be one more method on a call stack
1023:38 - with a root as null so now let's execute this post-order method with a root as null
1023:48 - so here we check whether root is equal to null or not so currently root is equal to null
1023:52 - therefore we'll simply return from this method
1023:54 - so once we return from this method we know that this method is executed completely
1024:03 - so it will be removed from the call stack and point of execution will reach to this post-order method
1024:12 - and we know that we had left this post-order method from the line number 5
1024:15 - so therefore we'll again start our execution from the line number 5
1024:19 - with a root as 3 so currently root is pointing to null so now it will point to 3
1024:26 - so we are starting now line number 5 and our root will point to node 3
1024:32 - moving ahead so the line number 6 we will call post-order method again and we'll pass the value
1024:39 - as root.right because in order to traverse this node we have to traverse this left subtree first
1024:46 - which we have already done so now is the time to traverse this right subtree
1024:51 - and after traversing right subtree we can actually visit this node 3
1024:56 - so in order to visit this right subtree we are calling this post-order method again
1025:00 - and we are passing the null value to it and we also we are leaving this method
1025:05 - at line number 6 so we'll update the line number here
1025:08 - so now point of execution will start the execution of this new post-order method
1025:18 - with the root as null so root is pointing to node 3 now it will point to null
1025:26 - and we also know that there will be one more method on the call stack with the root as null
1025:32 - so let's start the execution of this post-order method with the root as null
1025:39 - so we'll check whether root is equal to null or not so currently root is equal to null
1025:43 - therefore we have actually visited the right subtree for the node 3 so we'll simply return
1025:49 - from this method and as we return from this method this post-order method will be removed
1025:56 - from the call stack and point of execution will reach to this post-order method
1026:00 - and we know that we have left this post-order method from the line number 6 with a root as 3
1026:10 - so we'll start the execution from the line number 6 and we know that
1026:14 - at that time root was pointing to 3 so now root will point to node 3
1026:20 - so friends we have visited the left subtree for the node 3 and we also visited the right subtree
1026:26 - for the node 3 so now we can actually visit the node 3 so on the line number 7
1026:32 - we will simply print the data associated with this root which is nothing but 3
1026:38 - moving ahead
1026:42 - and once we reach the line number 8 we know that we have successfully executed
1026:47 - this post-order method so this method will be removed from the call stack
1026:51 - and the point of execution will reach to this post-order method
1026:59 - and we also know that we had left this post-order method from the line number 6
1027:03 - and at that time the root was actually 9 so we are starting on the line number 6
1027:10 - and we know that we had left this method when the root was pointing to 9
1027:15 - so therefore now root will point to 9
1027:18 - and moving ahead
1027:23 - so friends here you can see for the node 9 we have completely visited its left subtree
1027:30 - and we have printed 4 and 2 then we actually visited the right subtree completely and we
1027:35 - printed 3 so now is the time to visit the node 9 so we are simply printing the data on the console
1027:43 - for the root which is pointing to node 9 so now 9 will be printed on the console
1027:52 - and on the line number 8 we know that we have completely executed this post-order method
1027:56 - so this would be removed from the call stack
1028:01 - and once this is removed from the call stack we know that there are no more methods left to be
1028:05 - traversed so here we have actually successfully executed this recursive post-order traversal
1028:11 - to this binary tree and we have printed its each and every node on the console as 4 2 3 9
1028:18 - so friends this was the demonstration of the algorithm now let's go to eclipse and see the
1028:22 - working code so friends in my previous tutorial i had created one class by name binary tree
1028:30 - and we actually implemented the binary tree into this class so in order to understand the
1028:36 - implementation of this binary tree you can watch my previous tutorials
1028:41 - so in this tutorial we will actually code recursive post-order traversal of a binary tree
1028:51 - so here i will create one method as public void post order
1029:00 - so this is the same method which we discussed in the slide
1029:04 - so this method takes in a root which is our type tree node
1029:12 - so first we'll provide the base case
1029:16 - which is we will check whether root is equal to null or not
1029:20 - so if root is equal to null then we'll simply return from this method
1029:26 - so this is nothing but the base case because we are calling this post-order method recursively
1029:30 - so friends as we discussed in our slide that in post-order tree traversal
1029:37 - before visiting any node we will first visit is left sub tree
1029:42 - and then we'll visit is right sub tree and then we can visit the actual node
1029:47 - so first we'll visit the left sub tree by calling root dot left
1029:55 - and then we'll visit its right sub tree by calling root dot right
1030:12 - and after visiting the left sub tree and the right sub tree we'll actually visit the node
1030:18 - so we'll simply print root dot data on the console
1030:30 - so friend this is the code for recursive post-order binary tree traversal
1030:34 - so now let's test it's working on the main method
1030:39 - so here in the main method we'll first initialize this binary tree class
1030:42 - and then we'll create the binary tree so in create binary tree method we are actually creating
1030:51 - the binary tree with few nodes and these are the same nodes which we discussed in the slide
1030:56 - and we also discussed this method in my previous tutorials so you can watch my previous tutorials
1031:01 - in order to understand how we have created this binary tree with a few nodes
1031:05 - so after creating this binary tree we'll actually call the post-order method
1031:17 - and we'll also pass the root into it so if i run the code now
1031:26 - so you can see it printed four two three nine which is the same output which we discussed in
1031:31 - the slide so for in this tutorial we discussed about the recursive post-order binary tree
1031:37 - traversal i hope you like this video please like comment share and subscribe my youtube channel
1031:44 - thanks have a nice day
1031:49 - hello everyone so in this video we will discuss about the iterative post-order traversal of a
1031:55 - binary tree so in our previous videos we discussed about the recursive post-order traversal of a
1032:00 - binary tree and in this lecture we will see the iterative approach to traverse the binary tree
1032:07 - using the post-order so here you can see let's say we are given with this binary tree
1032:15 - and we want to traverse this binary tree using the iterative post-order traversal
1032:21 - so in our previous video when we discussed about the recursive approach to traverse the binary tree
1032:26 - we discussed that in order to traverse a binary tree using post-order what we do is before
1032:32 - visiting the root we visit all its element on the left subtree then we visit all its element
1032:40 - on the right subtree and then we actually visit the root and usually these three steps we perform
1032:47 - on each and every node of a binary tree when we do the traversal in a recursive way
1032:52 - so in case you want to learn more about that you can watch my previous video
1032:58 - so the only thing we need to remember here is when we do post-order traversal
1033:03 - on every node we need to first traverse all its elements on the left side then we need to visit
1033:11 - all its elements on the right side and then we can actually visit the node so for example if we
1033:18 - are on node 2 then we can't directly visit the node 2 we need to visit first the node 4 then we
1033:25 - need to visit node 5 and then only we can visit the node when we are performing the post-order
1033:30 - traversal so in this video we will discuss the iterative approach where we are not performing
1033:36 - any recursion so when we perform post-order traversal using the iterative way we usually
1033:43 - take the help of a stack so stack is nothing but a LIFO data structure which means last in first out
1033:51 - where the last element inserted will be the first one to be removed so we will use the stack data
1033:57 - structure to traverse this binary tree using the post-order traversal so let's see the demonstration
1034:04 - of this algorithm step by step so at the first step what we do is we create a tree node current
1034:18 - which simply points to the root and in the middle of this algorithm we are also creating
1034:25 - one temporary tree node we will see their advantages later in the algorithm so in the
1034:31 - first step we are simply creating the current and pointing it to root
1034:38 - then we are actually creating the stack data structure
1034:42 - so this is our stack data structure and we are using the stack class present in java
1034:50 - so as you want to perform this post-order traversal we need to visit each and every
1034:55 - node of this binary tree and as you are following a iterative approach we are providing a while loop
1035:02 - where we are providing the two conditions first is the current is not equal to null
1035:08 - or stack is not empty so here you can see current is pointing to a node having value as 1
1035:15 - therefore this condition comes out to be true because current is not equal to null
1035:20 - so the overall condition of this while loop comes out to be true
1035:24 - because any of this condition if comes out to be true this while loop will execute
1035:32 - so here you can see in the first step what we are checking is that if current is not equal to null
1035:37 - then we simply go inside this if block or else we perform this logic so why we are providing this
1035:44 - condition here is let's say current is pointing to a node having data as 1 and let's suppose we
1035:51 - want to visit this node so if the current is not equal to null then we can't directly visit this
1035:56 - node we need to first visit all the elements of its left sub tree and then we need to visit all
1036:02 - the nodes of its right sub tree and then only we can visit this node so current will be null at
1036:08 - this location and when current will be null then we can simply decide now can we visit the node or
1036:15 - not so here as current is not equal to null so there can be a possibility that this node has a
1036:22 - left sub tree so what we do is we simply push node 1 into the stack
1036:29 - and then we simply traverse to its left by assigning current's left to current so current
1036:39 - is pointing to node 1 its left is pointing to node 2 so now current will point to node 2
1036:49 - we again check where current is equal to null or not so current is not equal to null so the first
1036:55 - condition comes out to be true and we don't evaluate the second condition because of this
1036:59 - or operator so this while loop will execute we check whether current is equal to null or not
1037:08 - so current is not equal to null so this condition also comes out to be true because
1037:14 - there can be a possibility that node 2 has a left sub tree
1037:18 - so what we do is we simply push the current on the stack so 2 will be on the stack
1037:28 - and then we simply visit current to its left so current will now point to 2's left which is 4
1037:41 - and similarly current is not equal to null so this condition comes out to be true
1037:48 - here current is not equal to null because it is pointing to node 4
1037:54 - so we simply push current onto the stack because there can be a possibility
1038:00 - that there is a left sub tree or a right sub tree so 4 is on the stack
1038:09 - and we go to its left by assigning current's left to current
1038:12 - so current will point to its left which is null value
1038:20 - so friends here you can see now current is actually pointing to null
1038:24 - now if the current is pointing to null so this null can be on the left side of this node
1038:29 - or on the right side of its node so if the current is on the left side of the node
1038:35 - then we know that we need to visit the right side also before visiting this node
1038:40 - but if the current is on the right side of the node then we know that we have already visited
1038:45 - left we have already visited right now we can visit this node so in the post-order we discussed
1038:51 - in order to visit any node we need to visit all its left children then we need to visit all its
1038:56 - right children so if current is pointing to a null then there can be two possibilities
1039:04 - that this null value can be on the left side and this null can be on the right side
1039:09 - so if the null is on the left side we need to visit the right sub tree for this node
1039:16 - and if the current is on the right side then we know that we have already visited left
1039:20 - and we have already visited right then we can simply visit the node
1039:26 - so here current is equal to null so this condition comes out to be false
1039:30 - but our second condition the stack is not empty so this condition comes out to be true
1039:37 - and overall condition comes out to be true so while loop will execute
1039:43 - this if check will fail because current is actually pointing to null
1039:48 - so now we'll go to the else part so in the first step what we do is
1039:54 - we create a temporary variable and we assign a value stack.peak.write
1039:59 - so here you can see in the stack whichever is the last element inserted is the peak of the stack
1040:09 - so when we do stack.peak we are simply pointing to this node 4 and if we do .write then we are
1040:17 - actually pointing to nodes.write so here this is 4 and write will be null
1040:24 - so we will see why we are creating this temporary variable
1040:27 - so for timing you can see that temp is pointing to null
1040:35 - now here we are given two conditions that whether temp is equal to null or temp is not equal to null
1040:41 - so why we have provided this condition is because let's say if current is pointing to null
1040:46 - then we need to somehow check that whether this null value is on the left side of node 4
1040:53 - or on the right side of the node 4 so in order to verify that thing we created this temporary node
1041:01 - so as current is pointing to null so this can be any left or right child of a node
1041:06 - and we also know that this node will be already present on the stack and if you want to know
1041:12 - that whether we are on the left side or on the right side what we do is we simply go to this
1041:18 - node and go to its right so here temporary variable is doing that for us so here why we
1041:26 - are providing this check here is if temp is equal to null so this will signify that whatever the
1041:33 - value was on the stack its right is actually pointing to null and there are no nodes left
1041:39 - to be traversed on the right side of this node so what we can simply do here is
1041:44 - poll this element out because we are not sure that as current is pointing to null
1041:53 - and temporary is pointing to null which means that we have traversed the left subtree
1041:58 - and the right subtree for this node so now we can simply poll this node out and we can simply visit
1042:05 - it so we'll poll this element out and our temp will point to four
1042:13 - and in the next step we'll simply visit the temp so we are simply printing the data of the temp
1042:19 - which is four here so friends why we actually do all this stuff is when current actually reaches
1042:27 - to any null value then we need to be sure that whether it's on the left side or on the right
1042:32 - side so we simply create a temporary variable to simply pick the right side of a node present
1042:39 - in the stack and if the temp is equal to null then it simply signifies that there are no nodes
1042:46 - on the right side and we have already visited the left side so now it's time to visit the
1042:51 - actual node so we have visited four here moving ahead so for now here we provide a while loop
1043:01 - and why we provide is while loop because the first thing we are checking is stack is not empty
1043:05 - so as we have recently pulled an element out of it so there can be a chance that stack becomes empty
1043:11 - so stack should not be empty and the second condition is very important which is the core
1043:17 - of this algorithm is we are simply checking whether temp is stack dot peaks right so here
1043:24 - you can see so as we have recently visited this node here so there can be a possibility
1043:31 - and we need to be sure that whether this node is on the left of two or on the right of the two
1043:38 - because if it is on the left of two then we can't directly visit two we need to go to its right
1043:44 - and visit node five but if it is on the right side then we can simply visit the node two
1043:51 - so here stack peak is node two this and it's right which is this value is node five so we are
1044:02 - simply checking whether this node which we visited just now its value is equal to its parents right
1044:09 - or not so if this value comes out to be true then we know that that parent right is actually
1044:17 - the node which we just now visited so we can simply visit the parent now but here you can see
1044:22 - temp is pointing to four and stack peak which is the node two is pointing to right therefore they
1044:28 - are not equal which means that whatever the node we have visited just now it's on the left side not
1044:34 - on the right side of node two so this value will terminate and our call will reach to this
1044:44 - while loop again so friends here why we have provided this while loop it will be clear when
1044:49 - we reach here so for timing you can just think that we have provided a while loop here
1044:56 - so moving ahead here you can see current is pointing to null but stack is not empty
1045:01 - so the overall condition comes out to be true
1045:06 - current is equal to null so we go in the else now on the first step what we do is
1045:13 - we simply assign the stack peaks right value so stack peak is node two this node and its right is
1045:20 - node five so temp will point to five so friends why we are assigning this value now here is
1045:28 - as current is pointing to null and we have recently visited node four
1045:33 - and we also verified here that node is at the left of two so there can be a possibility
1045:40 - that node two might have a right subtree and in post-order traversal after visiting the left
1045:46 - part we need to visit the right part and then only we can visit the parent so here we are simply
1045:53 - assigning the value of stack dot peak dot right so two's right is five so temp will point to five
1046:01 - and here we will check whether temp is equal to null or not so your temp is not equal to null
1046:06 - which signifies that the right part there is a node which also can have left and right children
1046:13 - so and we can't directly visit this node because there might be a possibility that it contains
1046:18 - left and right children so here if the this condition comes out to be false and we go in
1046:26 - the else part where we'll assign the current to the temp so why we are assigning current to temp
1046:33 - because this five can be treated like any other node which can have the left and right children
1046:41 - so as we started by pointing current to root it is similar to that step that this node can have a
1046:48 - left or a right children so we need to perform all those steps again on this node
1046:57 - so here current is not equal to null so this condition comes out to be true
1047:04 - and if the current is not equal to null so this is the same case which we discussed here
1047:09 - that current is not equal to null there can be a chance that this node have a left children
1047:15 - so what we do is we first push the five on the stack and then we go to its left
1047:23 - by assigning current's left to current so current will point to null
1047:28 - so as current is pointing to null so this condition is false but our second condition
1047:36 - is true because stack is not empty and here you can see current is equal to null so this condition
1047:45 - also comes out to be false and we go into the else part in the first step we are assigning
1047:52 - stack peak's right value to temp so stack peak is node 5 this node and its right is this value
1048:01 - so we are assigning null to temp and then we are simply providing this check because
1048:11 - if temp is null then we know that current is already pointing to null which is the left part
1048:17 - and temp is also pointing to null which is the right part so it signifies that its parent
1048:22 - has no left and right children so we can simply visit the parent now so in the first step what
1048:29 - we do is we poll the topmost element which is the which is the node 5 and we'll assign it to temp
1048:37 - so first this will poll out and temp will point to 5
1048:40 - so we can safely visit this node because we have already visited its left and right children
1048:48 - so 5 will be visited here
1048:52 - and then we are providing this while loop which we will discuss when we reach here
1048:57 - so just for timing thing that we are providing this while loop to check
1049:02 - whether the node which we have visited is on the left or on the right side of its parent
1049:09 - so currently stack dot peak is 2 which is parent to 5 and if we see here dot right
1049:17 - is this value only and temp is also pointing to this node so this condition temp equal equal
1049:23 - stack dot peak dot right is actually true because we are on the right side of the parent
1049:31 - and we have already visited this node so now we can simply poll this element out and we can
1049:37 - simply visit because we have already visited its left part and the right part so this while loop
1049:43 - condition will come out to be true we are polling 2 out and temp will point to node 2
1049:55 - and then we are simply printing the data of this node by visiting it so 2 will be printed
1050:01 - so as it is a while loop we are again checking that whatever node we visited just now is it
1050:09 - on the left side or on the right side of its parent so the first condition stack should not
1050:15 - be empty because we have recently polled an element out so there can be a possibility the
1050:19 - stack is empty so here stack is not empty and the second check verifies that whatever the value we
1050:27 - have here which is the parent to this node so here we are simply verifying that this temp is on
1050:34 - its left or on its right side so temp is actually on the left side so this condition comes out to
1050:43 - be false so our execution point reaches to this while loop where here you can see current is equal
1050:52 - to null but stack is not empty so here current is equal to null so this condition comes out to
1051:01 - be false in the else part we will assign stack.peak.right value to temp so stack.peak is 1
1051:12 - and its right is node 3 so temp will now point to node 3
1051:20 - moving ahead we check whether temp is equal to null or not so temp is not equal to null so this
1051:26 - condition comes out to be false so if this condition would have come out to be true
1051:32 - and temp would have point to null then we could have visited this node directly
1051:37 - but as temp is not equal to null so there can be a possibility that this node can have left or right
1051:44 - children so we simply go to the else part and we assign the value of temp to current so now current
1051:52 - will point to this node because we have figured out that there can be a possibility that 3 can have
1051:58 - left or right childrens so current will point to 3 so now this is the same situation which we saw in
1052:07 - this start that current is not equal to null and if current is not equal to null there can be a
1052:17 - possibility that there could be a left children of it so we are simply pushing the current onto the
1052:25 - stack so 3 will be on the stack and then we go to its left by assigning current left to current
1052:35 - so current will now point to null
1052:40 - so as current is equal to null but stack is not empty this overall condition comes out to be true
1052:48 - so we check whether current is equal to null or not so current is equal to null
1052:55 - so in the else part we will assign stack's peak right value to temp so stack peak is
1053:04 - node 3 and its right is 6 so not temp will point to 6
1053:11 - and here we check whether temp is equal to null or not but here you can see temp is not equal to null
1053:16 - so there can be a possibility 6 can also have left or right children
1053:21 - so in the else part we simply assign current to 6
1053:30 - current is not equal to null
1053:34 - and in the if check also current is not equal to null
1053:38 - and there can be a possibility that 6 can have left children so we push 6 on the stack
1053:44 - and we go to its left by assigning current left to current so current will point to null now
1053:53 - which is the left of 6
1053:57 - current is equal to null but stack is not empty so this condition comes out to be true
1054:03 - and overall condition comes out to be true because of this or operator
1054:08 - here the if condition comes out to be false because current is pointing to null
1054:11 - and then we simply assign stack.peak.right to temp
1054:19 - so stack peak is node 6 this node and its right is this node so temp will now point to null
1054:30 - and here we are providing this check that if temp is equal to null which means that
1054:36 - current is pointing to null and whatever its parent is its right is also pointing to null
1054:42 - so we can safely visit this node which is the parent so how we can safely visit that node is
1054:48 - first we'll pull that element out of the stack so 6 will be pulled out and temp will point to 6
1054:59 - we will visit this node so 6 will be visited
1055:06 - now friends here we encountered a while loop and we discussed that why we are providing this
1055:11 - while loop is because the first check is stack should not be empty so stack has two nodes
1055:17 - therefore it's not empty now as we have recently visited this node so after visiting this node
1055:25 - we need to be very much sure that whether this node was at left or was at right to its parent
1055:32 - which is 3 we can access 3 by stack's peak which is by getting this value
1055:42 - and if we call.right if we call.right then we'll reach here only so if temp is equal to this value
1055:51 - only then we know that we are actually on the right side of temp's parent which signifies that
1056:00 - we have already visited the left part we have completely visited the right part and now we can
1056:07 - simply visit the parent so here we pull the parent out and temp will point to 3
1056:20 - we visit 3
1056:21 - and we again encounter the while loop so friends here you can see that this
1056:29 - while loop is provided because if this is the condition here then here you can see
1056:36 - that stack is not empty and as we have visited 3 so this 3 can also be the right child of
1056:44 - its parent so therefore we are providing this while loop let's say if this chain goes on
1056:50 - like this and there are no left nodes so this while loop will simply make us traverse back
1056:57 - because all these nodes are on the right side of its parent which we already visited
1057:03 - so that's why we are providing this while loop so here again we are simply checking whether temp
1057:08 - is pointing to its parent's right or not so here stack.peak will give us 1 its right will give us
1057:18 - node 3 and temp is also pointing to node 3 so this while loop condition will come out to be true
1057:25 - and we can simply pull 1 out because we have visited all the left subtree of the node 1
1057:30 - and we have recently visited all the nodes on the right subtree of 1 so we can simply pull the 1 out
1057:40 - temp will point to 1 and we can simply visit node 1 now so node 1 will be visited here
1057:49 - and finally we again check whether stack is empty or not so here you can see we have recently pulled
1057:56 - 1 element out so stack is empty so this condition comes out to be false and the while loop will
1058:03 - terminate and once the while loop will terminate our call will go reach here so here you can see
1058:11 - current is equal to null this condition is false and our stack is also empty which signifies that
1058:19 - we have completely visited this binary tree using the postorder traversal so this whole condition
1058:26 - will come out to be false so friends here you can see that using a stack we visited all the
1058:35 - nodes of this binary tree using the postorder traversal so this was the sequence first 4 was
1058:42 - visited then 5 got visited because before visiting 2 we need to visit its left part
1058:50 - then we need to visit the right part and then we can actually visit the node so 2 was visited after
1058:55 - that now we can't directly visit 1 because we need to traverse all the nodes of its right subtree
1059:02 - so we reached here we saw that 3 didn't have any left part so we can't visit 3 directly we went to its
1059:12 - right we saw that 6 left and right both are null so we simply visited 6 then after we visited 6
1059:19 - which was on the right side we safely visited 3 and 3 was also on the right side so we safely
1059:26 - visited 1 so this is the postorder traversal of a binary tree so friends this was all about this
1059:34 - video and in case you have liked this video then please like comment share and subscribe my channel
1059:40 - thanks have a nice day
1059:44 - hello everyone so in our previous lecture we discussed that how we can do postorder traversal
1059:51 - of a binary tree using the iterative approach so in this video we'll code the algorithm and we'll
1059:58 - test its working so here you can see in intelliJ I have created one class as binary tree so this
1060:06 - class we created in our previous videos which has a root of type tree node so this is the private
1060:14 - class inside this binary tree which simply has left and right children
1060:21 - we discussed other traversal algorithms such as pre-order in order
1060:30 - and we also saw recursive and iterative approaches
1060:36 - so in this video we'll see the postorder traversal of a binary tree using the iterative approach
1060:42 - so here I will be creating one method as public void I'll give a name as postorder
1060:56 - so here when we discussed postorder traversal using the recursive approach
1061:00 - we saw that before visiting the nodes data we need to visit first its left subtree
1061:09 - then we need to visit its right subtree and then only we can visit the nodes data
1061:14 - so this was a recursive approach which got implied on each and every node of the binary tree
1061:21 - so when we perform the iterative approach we usually use the while loop and we traverse each
1061:26 - and every node of the binary tree keeping the postorder traversal in mind and the data structure
1061:35 - will help us doing this is the stack data structure which is the leafo data structure
1061:41 - which is also known as the last in first out so the last element inserted inside that data structure
1061:47 - will be the first one to be removed so we discussed this algorithm step by step in our
1061:52 - previous video using an animation so now let's code the algorithm and test its working
1061:59 - so in postorder method the first thing we do is we create
1062:07 - a tree node current which starts from the root of the binary tree whose traversal we need to do
1062:16 - in the second step we create a stack which will hold our tree nodes we give it a name as stack
1062:29 - and we are using java.utils stack class we can also use our stack which we discussed in our
1062:35 - previous videos but here i will be using the java.utils stack now in order to perform the
1062:43 - postorder traversal we need to provide a while loop and inside that while loop we provide a
1062:51 - condition as current should not be equal to null or
1063:03 - stack should not be empty so here you can see that current is pointing to root
1063:10 - and we need to go inside this while loop to traverse each and every node of the binary tree
1063:15 - using postorder so the first condition we provide is current should not be equal to null
1063:20 - and when current is equal to null then the logic we apply will see later in the algorithm
1063:26 - and the other thing is the stack should not be empty so here you can see in this while loop
1063:38 - we provide a condition as current
1063:42 - not equal to null so if current is not equal to null then it signifies that we can't visit
1063:49 - the current directly we need to first go to its left subtree and visit that then we have to go
1063:56 - to its right subtree and visit that and then only we can visit that particular node so if current
1064:01 - is not equal to null so there is a possibility that current might have a left subtree so the
1064:08 - first step we do is we simply offer or you can say push the current on the stack and after
1064:19 - pushing current on the stack we simply go to its left by assigning current's left value to current
1064:28 - and if current is equal to null then we provide else part where what we do is we create a temporary
1064:39 - node and we assign the stack's peak values right to it so friends here if the current is pointing
1064:51 - to null then we need to follow these steps to identify that whether that current is actually
1064:58 - the left child of the parent or at the right child of the parent because if it is the left
1065:04 - child of the parent then we can't visit parent directly we need to go to its right first but if
1065:10 - it's the right child of the parent then we can simply visit the parent so if the current is equal
1065:16 - to null in order to identify that the first thing we do is we take its parent which is on the stack
1065:25 - and we'll simply assign the right value to temp so here after getting this temp
1065:32 - there are basically two conditions one is what if the temp is also null
1065:38 - so this check basically signifies that if temp is pointing to null and as we have moved to parents
1065:48 - right and temp is pointing to null it means that there are no right children of the parent
1065:56 - so we can simply visit the parent because when we do post-order traversal in order to visit the
1066:02 - parent we first visit its left subtree and then we visit its right subtree and then only we can
1066:08 - visit the parent and as we are on the right part and that is coming as null it means that we have
1066:14 - visited the right part and now we can safely visit the parent so here what we do is
1066:20 - we simply pop the element from the stack and assign it to the temp so once the temp is pointing
1066:34 - to parent what we do is we simply visit the parent by printing its data on the console
1066:44 - and after visiting the node we again provide a while loop and inside that while loop we provide
1066:56 - the condition stack should not be empty because we have recently popped an element from the stack
1067:05 - so stack can be empty so here we are providing this one condition that stack should not be empty
1067:10 - till this point and so here as we have visited this node now this node can be a children
1067:20 - of its parent and it can be on the left side or on the right side so there are also now two
1067:26 - conditions coming up here if the temp is on the left side then we know that we need to go
1067:32 - to the parents right now because we have visited the temp here but if the temp is on the right side
1067:39 - then we know that we have once we have visited the right side we can simply visit the parent
1067:45 - so here we need to provide one more condition as
1067:49 - if temp is equal to stack.peak.write so this condition signifies that whatever
1068:00 - the peak value is on the stack it would be parent to temp and if its right value is equal to temp it
1068:07 - means the temp is on the right side so if it is on the right side then we can simply again
1068:17 - pull the element from the stack assign it to temp and we can simply visit that
1068:24 - and also friends as here we are popping out an element and visiting it
1068:37 - we need to provide this in while loop because there can be a chance that whatever we are
1068:42 - visiting it's actually coming out to be the right of the parent so once this condition
1068:48 - comes out to be true and we pop the parent from the stack there can also be a chance that whatever
1068:54 - we visited here will also be on its right of its parent so we need to provide this while loop
1069:02 - because whenever we are visiting any element by printing it on the console here or here
1069:08 - we need to simply perform this check that what we visited was at the right of its parent or was it
1069:15 - at the left of its parent so if it is on the right of its parent which is this condition
1069:20 - then we'll simply keep on popping the element out and simply printing its data because in the post
1069:26 - order traversal this is the main step that once the right children of any node is visited then
1069:32 - only we can visit the parent so here this condition is signifying that only so this was
1069:38 - the part in the if condition and let's say if the temp is not equal to null it means that when we
1069:48 - peek the parent element and we went to its right that was not null so before visiting right
1069:54 - directly there can be a possibility that right also has left or right children so therefore
1070:01 - these two checks are important if temp is null then we are sure that right is already visited
1070:08 - we pop the element out we print its data and then we again check it for its parent
1070:12 - but if the temp is not equal to null then we know that we need to visit the right part also
1070:20 - and once we go to its right part the right part can also have its own left and right children
1070:27 - so here now our condition becomes something like this what we did here
1070:32 - so here what we do is we simply assign the value of temp because it is not equal to null to current
1070:46 - so friend this was all about this algorithm now let's test it's working in the main method
1070:55 - so friends here you can see that in our previous videos we created a binary tree
1071:00 - with these hard coded values so where root was pointing to one one had two children's
1071:08 - left and right as second and third these two
1071:13 - second had two children's left and right as fourth and fifth these two and third noted
1071:19 - left and right as sixth and seventh so these two nodes so here one is at the root
1071:26 - second and third are its left and right children
1071:30 - four and five are left and right children of two and six and seven are left and right children of
1071:35 - three so this was the hard coded binary tree so here after creating this binary tree what we can do
1071:42 - is we can simply call the post order and we can run the program
1071:59 - so friends here you can see it printed four five two six seven three one here in this binary tree
1072:08 - before visiting one which was the root we need to visit two and three so two was at left so when
1072:16 - we reach to two we can't visit two directly because two also has left and right children which is
1072:22 - four and five so when we reached to four we found that four didn't have any left and right children
1072:30 - so the first thing we visited was four because this was the left of two and then we visited
1072:37 - five because five was right of two and after visiting the left and right children we visited
1072:43 - two here and once we visited two we know that we have visited all the left children of the actual
1072:50 - root so now it was time to go to its right binary tree so when we went to one's right we found
1072:58 - three so we can't visit three directly because three has a left and right children which is six
1073:05 - and seven so when we went to six we found that six didn't have any left and right children
1073:12 - so we safely visited six and then we safely visited seven because seven was right to three
1073:21 - so after visiting six and seven which was the left and right children of three now we can safely
1073:27 - visit three and once we visited three we were pretty much sure that we have visited all the
1073:34 - nodes of the right sub tree of the actual root which was one so finally we visited one so friend
1073:41 - this was all about the post-order traversal and in this video we demonstrated about the iterative
1073:50 - approach using the stack data structure so here in case you find any difficulty you can watch
1073:58 - my previous video to this which had all the things in animation so that it becomes more
1074:03 - clear to you and in case you have liked this video then please like comment share
1074:10 - and subscribe my channel thanks have a nice day
1074:17 - hello friends welcome to my new data structures and algorithm in java tutorial series video
1074:21 - you friends in this tutorial we will discuss level order traversal of a binary tree in java
1074:31 - so friends what is the level order traversal
1074:34 - so here we use this traversal technique to visit the nodes of a binary tree level by level
1074:40 - so here you can see the root is at level 0 2 and 3 are at level 1 4 5 6 are at level 2
1074:48 - so in this traversal technique we first visit the level 0 then we visit the level 1 and then
1074:55 - we visit the level 2 so when we actually visit the node and print it data on the console so it
1075:02 - will be like first one will be printed then 2 then 3 then 4 5 and 6 so here when we do a level order
1075:14 - traversal of a particular level then we actually store the elements of its next level on additional
1075:20 - data structure which is nothing but the queue so here suppose we are visiting the node 1
1075:26 - then on the queue we put the node 2 and node 3 so that after visiting the node 1 we can pull
1075:34 - the node 2 and node 3 and we can visit them and while we are visiting the node 2 we put 4 and 5
1075:42 - on the queue and when we are visiting the node 3 we put node 6 on the queue so therefore it goes
1075:49 - level by level and the additional data structure which we use to store this element is a queue
1075:57 - so basically in this traversal we are using queue because it is a fee for data structure
1076:01 - which is nothing but first in first out so the element inserted first will be the first to be
1076:06 - removed we will see its significance when we demonstrate the algorithm so let's start the
1076:13 - execution of this algorithm step by step so let's suppose we are given this binary tree where root
1076:19 - is pointing to the node 1 so when this algorithm starts we first check whether root is equal to null
1076:25 - or not so if root is equal to null then we simply return from the method because there are no nodes
1076:30 - in the binary tree to be traversed and here you can see as root is pointing to the node 1 therefore
1076:37 - the condition in if block comes out to be false and in next step what we do we first initialize
1076:44 - the queue data structure so here you can see the queue data structure where nodes are entered from
1076:50 - one end and they are removed from the other end so this property makes queue a fee for data structure
1076:57 - that is the element inserted first is the first one to be removed
1077:02 - and in order to know more about the queues you can watch my previous tutorials on the queue data
1077:06 - structure and in this tutorial we will use the java implementation of the queue which is nothing
1077:13 - but a linked list so we will initialize the queue by creating the instance of the linked list
1077:18 - so after creating the queue what we first do is we offer the root node to the queue
1077:28 - here offer is nothing but the in queue operation where we add the element to the queue
1077:33 - so in the first step what we do is we offer the root node to the queue
1077:38 - so it would look something like this as root is pointing to node 1 therefore in the first step
1077:44 - what we do is we basically add node 1 into the queue so it would look something like this
1077:51 - that is the node 1 is in the queue moving ahead
1077:57 - so friends in order to traverse this binary tree using the level order traversal we basically use
1078:02 - a while loop and inside this while loop we place a condition s that we will iterate this while loop
1078:08 - till queue is empty so currently you can see queue is having one node which is node 1 therefore
1078:15 - it's not empty so the condition in while block comes out to be true
1078:23 - so in the first step what we do is we actually poll the element from the queue
1078:27 - and we assign it to the temporary node so here you can see queue is having one tree node
1078:33 - having data as one so when we perform a poll operation on the queue node 1 will be removed
1078:40 - and its value will be assigned to temp so it would look something like this
1078:47 - so node 1 is removed from the queue
1078:51 - and temp is now pointing to the node 1 so whatever the value we pulled from the queue
1078:56 - we simply assigned it to the temporary node moving ahead
1079:03 - so after polling the node from the queue we simply print its data on the console
1079:09 - so one got printed on the console it means we have visited the node 1
1079:16 - and as we discussed earlier that when we visit any particular level we store the elements of
1079:20 - its next level on the queue so here we first check that whether temp dot left is equal to null or
1079:27 - not so temp is pointing to node 1 and its left is pointing to node 2 therefore the condition
1079:33 - in if block comes out to be true because temp dot left is not equal to null
1079:44 - so in the if block we simply offer temp dot left element to the queue which is nothing but the node
1079:49 - 2 so it would look something like this that now node 2 is on the queue moving ahead
1080:01 - we then check whether temp dot right is equal to null or not so here you can see temp dot right
1080:06 - is pointing to node 3 therefore it's not equal to null so the condition in if block comes out to be
1080:11 - true and here we simply offer temp dot right which is the node 3 on the queue
1080:23 - so now node 3 is also on the queue moving ahead
1080:29 - now in the while loop we check whether queue is empty or not so currently queue has two nodes
1080:33 - therefore it's not empty so the condition in while block comes out to be true
1080:37 - and then we simply poll an element from the queue and we'll assign it to temp node
1080:46 - so here you can see when we do a poll on the queue the element which was inserted first
1080:51 - would be the first to be removed so therefore node 2 will be removed first
1080:55 - and temp will point to the node 2 so it would look something like this
1080:59 - that node 2 is removed from the queue and its value will be assigned to the temp
1081:08 - so it means the temp is pointing to the node 2 moving ahead
1081:15 - and then we'll simply print the data associated with the temporary node which is nothing but the 2
1081:22 - so 2 will be printed on the console moving ahead
1081:29 - and when we are visiting the node 2 of any particular level then we have to add its left
1081:34 - and right element on the queue so here first we will check whether temp dot left is equal to null
1081:39 - or not so currently temp dot left is pointing to node 4 therefore it's not null so the condition
1081:45 - in if block comes out to be true and then we will offer temp dot left to the queue which is nothing
1081:54 - but the node 4 so now node 4 will be part of the queue moving ahead and then we will check
1082:05 - whether temp dot right is equal to null or not so temp dot right is nothing but the node 5
1082:11 - and it's not equal to null so the condition in if block comes out to be true
1082:18 - and we'll simply add the node 5 on the queue
1082:25 - moving ahead we again check whether queue is empty or not so currently queue has 3 nodes
1082:32 - therefore it's not empty so the condition in while block comes out to be true
1082:40 - and then we'll simply poll the element from the queue so when we perform a poll operation
1082:46 - the element which was inserted first is first to be removed so here you can see node 3 is the first
1082:51 - element so now it will be removed from the queue and its value will be assigned to the temporary
1082:56 - node so it would look something like this so node 3 is removed and its value is assigned to
1083:07 - the temporary node so now temp is pointing to the node 3 moving ahead and then we'll simply
1083:15 - print the data associated with the temporary node which is nothing but 3 so 3 gets printed
1083:21 - on the console and then we'll simply check whether temp dot left is equal to null or not
1083:29 - so here you can see temp dot left is nothing but node 6 therefore it's not equal to null
1083:34 - so the condition in if block comes out to be true
1083:41 - and then we'll simply store the node 6 on the queue
1083:45 - moving ahead and then we'll check whether temp dot right is equal to null or not
1083:56 - so here you can see temp dot right is equal to null so therefore the condition in if block
1084:01 - comes out to be false because we are not storing the null value on the queue
1084:09 - we again check whether queue is empty or not so currently queue has 3 nodes therefore it's not
1084:13 - empty and the first step is simply poll the element from the queue and we'll assign it to
1084:22 - the temporary node so here node 4 will be removed from the queue and temp will now point to the
1084:29 - node 4 so it would look something like this so now temp is pointing to the node 4
1084:39 - and now we'll simply print the data associated with the temporary node which is nothing but
1084:47 - 4 so 4 will be printed on the console
1084:53 - and then we'll simply check whether temp left is equal to null or not
1084:57 - so temp left is equal to null therefore the condition in if block comes out to be false
1085:03 - and we'll check whether temp right is equal to null or not
1085:06 - so temp right is also equal to null therefore condition in if block comes out to be false
1085:14 - and then again in while loop we'll check whether queue is empty or not
1085:18 - so currently queue has two nodes therefore it's not empty so the condition of while block comes
1085:23 - out to be true and in the first step we'll simply poll the first element from the queue
1085:30 - which is nothing but node 5 and we will assign it to the temporary node
1085:35 - so it would look something like this
1085:40 - so now temp will point to the node 5
1085:45 - moving ahead then we'll simply print the data associated with the temporary node
1085:51 - which is nothing but 5 so now 5 will be printed on the console moving ahead
1085:57 - coming right and then we'll check whether temp left is equal to null or not
1086:02 - so currently you can see temp left is equal to null therefore the condition
1086:07 - in if block comes out to be false
1086:12 - and then we'll check whether temp right is equal to null or not
1086:15 - so here temp right is equal to null therefore the condition in the if block comes out to be false
1086:23 - and then we go to while loop and we'll check whether queue is empty or not
1086:26 - currently queue has one node left therefore it's not empty so the condition
1086:31 - in while block comes out to be true so we'll simply pull the element from the
1086:37 - queue which is nothing but the node 6 and we'll assign it to temporary node so
1086:43 - it would look something like this so the node 6 is removed and our temp will
1086:49 - point to the node 6 moving ahead so finally we will print the data associated
1086:58 - with the temporary node which is nothing but 6 so we have printed the data
1087:04 - associated with the node 6 moving ahead we will check whether temp left is equal
1087:11 - to null or not so currently temp left is equal to null therefore the condition in
1087:16 - if block comes out to be false and then we'll check whether temp right is equal
1087:22 - to null or not so temp right is equal to null therefore the condition in if block
1087:27 - comes out to be false and finally we will again check whether queue is empty
1087:32 - or not so currently here you can see queue is empty so therefore the condition
1087:37 - in while block comes out to be false because queue is empty so there are no
1087:42 - more nodes left to be traversed so therefore this while loop terminates and
1087:48 - we know that we have visited all the nodes of this binary tree level by level
1087:54 - so here you can see we first traversed node 1 then we visited node 2 then 3
1088:00 - then 4 then 5 then 6 so friend this is the algorithm for the level order
1088:07 - traversal of a binary tree now let's go to Eclipse and see its working code so
1088:15 - friends in my previous tutorial I created one class by name binary tree
1088:18 - and we implemented the binary tree into this class so you can watch my previous
1088:24 - tutorial to know more about how we have implemented the binary tree so in this
1088:30 - tutorial I will be coding the algorithm for level order traversal of a binary
1088:33 - tree so here I will be creating one method as public void and I will give
1088:43 - the name to its level order so in this method we will be coding the level order
1088:51 - traversal of a binary tree so in the first step we'll check whether root is
1089:00 - equal to null or not so if root is equal to null then we'll simply return from
1089:06 - this method because there are no nodes in a binary tree to be traversed and
1089:13 - then we'll initialize a queue which will hold the tree nodes for us and here we
1089:29 - are using the Java implementation of the queue so we'll import it from the Java.util
1089:35 - package
1089:43 - so after we create the instance of this queue we'll simply offer the root node
1090:02 - now we'll create a while loop and inside this value will place a condition s that
1090:10 - we iterate this while loop till queue is empty so inside this value will first
1090:18 - create a tree node by name temp and to this temporary node will poll the
1090:26 - element from queue and will assign its value to the temporary node and after
1090:34 - polling the element from queue will simply print its data on the console so
1090:41 - we'll do temp.data so after printing the data associated with the temp node we
1090:52 - will store its left and right node on the queue so we'll first check that
1090:59 - whether temp left is equal to null or not so if it is not equal to null then
1091:08 - we'll simply offer it to the queue
1091:20 - and similarly we'll do this for the temp right so I will just copy it and I will
1091:27 - make it to temp right so friend this is the algorithm for the level order
1091:36 - traversal of a binary tree now let's test is working in the main method so in
1091:42 - the main method we'll first create the instance of this binary tree class and
1091:47 - then we'll actually create the binary tree so here you can see I have created
1091:54 - this binary tree with the few nodes so this is the binary tree which we
1091:58 - discussed in the slide and in order to know more about this create binary tree
1092:03 - method you can watch my previous tutorials so after creating this binary
1092:08 - tree we will then call the method level order and if I run the code now
1092:25 - so here you can see it printed one two three four five six seven which we
1092:32 - actually discussed in the slide that it prints level by level so friends in this
1092:39 - tutorial we discussed about the level order traversal of a binary tree I hope
1092:44 - you like this video please like comment share and subscribe my youtube channel
1092:47 - thanks have a nice day hello everyone so in this video we will discuss that how
1092:57 - we can find the maximum value in a binary tree and we'll discuss an
1093:02 - algorithm which is recursive in nature
1093:06 - so here you can see let's say we are given with this binary tree having nodes
1093:11 - as four three seven five and eight and four is at the root so let's say we want
1093:18 - to find the maximum value inside this binary tree so looking at this binary
1093:23 - tree we know that eight is the maximum value but how to find whether eight is
1093:28 - the maximum value in this binary tree is using this algorithm which is recursive
1093:33 - in nature because here you can see the method name is find max which takes in a
1093:38 - root and inside that it again calls find max so your find max method is
1093:45 - calling itself at two places at line number six and line number seven so
1093:52 - therefore this algorithm is recursive in nature so here the idea behind finding
1093:57 - the maximum value in a binary trees let's say we know the value of fruit and
1094:02 - we know what's the maximum value in the left subtree and what's the maximum value
1094:09 - in the right subtree so we can simply compare the maximum value of the left
1094:15 - subtree with the roots value and then we can compare with the maximum value of
1094:20 - the right subtree and we can come to know what's the maximum value among
1094:25 - these three values so this idea can be applied on each and every node
1094:31 - recursively so for example if you want to find the maximum value of this binary
1094:36 - tree having three nodes as three five and eight we can simply take the roots
1094:41 - value then we need to calculate the maximum value of the left subtree and
1094:46 - the maximum value of right subtree and we need to simply compare these three
1094:51 - values and we will get the maximum value till this node so this algorithm is
1094:57 - recursive we need to apply these three steps on each and every node and using
1095:03 - this algorithm will also traverse each and every node because in order to find
1095:07 - which is the maximum value among this binary tree we need to traverse each and
1095:11 - every node so let's the demonstration of this algorithm step by step so that the
1095:16 - idea of finding the maximum value inside this binary tree will be more clear to
1095:21 - you also here you can see as this algorithm is recursive in nature when
1095:28 - find max will get executed it will internally call again the find max so
1095:33 - in order to keep the track of these methods we will create a table which will
1095:38 - be nothing but our call stack so let's see how this algorithm and this call
1095:43 - stack works together so the first step we are calling the find max method and
1095:50 - we are passing in the root of the binary tree whose maximum value we need to
1095:56 - calculate so on the call stack you will find one find max method whose root is
1096:04 - pointing to a node having value as 4 so here you can see that this table has five
1096:11 - values line number root result left and right so as the algorithm is recursive
1096:17 - in nature when we will leave this find max method and we will again call find
1096:21 - max will simply keep the track of the line number here we will keep the track
1096:25 - of the root result left and right which we will see later how they are important
1096:34 - moving ahead so here as the algorithm is recursive in nature we need to provide a
1096:41 - base case so that we can exit from the algorithm if we don't provide this base
1096:46 - case then this find max will again call find max and it will go on because there
1096:52 - will be no end so we need to provide this base case that if the root is null
1096:56 - here then we can simply return the minimum value from here so for example
1097:04 - if the root is pointing to null so we will simply return the minimum integer
1097:10 - value because null can signify that this is the minimal value as the return type
1097:16 - is integer we need to return a value so we simply return the minimum value of
1097:21 - the integer because the minimum value of integer won't affect the maximum value
1097:26 - of this binary tree so here currently we are providing a check that if root is
1097:31 - equal to null then simply return the integers minimum value so currently root
1097:38 - is pointing to 4 therefore this condition comes out to be false
1097:45 - also friends we discussed the idea that how we can find the maximum value of any
1097:50 - node and its left and right children is finding the maximum value of this left
1097:55 - sub tree finding the maximum value of its right sub tree and comparing it with
1098:00 - the roots value so here this three line will do that in the result we are simply
1098:06 - storing the roots value so here in the result it will be coming as 4 moving
1098:13 - ahead so now we'll traverse to the left of this binary tree in order to find the
1098:21 - maximum value of the left sub tree so we are simply again calling the find max
1098:26 - method but this time we are passing in root start left so root is pointing to
1098:32 - 4 and its left is pointing to 3 so 3 will be our new node and here you can
1098:37 - see we are leaving this find max method at line number 6 so we'll simply keep
1098:42 - the track of line number here so that when this find max will end we know that
1098:48 - where to start this find max so we'll simply store the line number which is 6
1098:54 - and we will again call the find max method passing in roots left node so on
1099:02 - the call stack it would look that find max method is called
1099:10 - we have left this find max method here at line number 6 and we are again called
1099:14 - find max and this time the root is roots left which is 3 so now root will
1099:20 - point to 3
1099:23 - moving ahead root is not equal to null
1099:32 - again we will apply the algorithm recursively on this node so first we
1099:36 - will store the roots data so which is 3
1099:44 - now in order to find the maximum value till this node is we need to find the
1099:49 - maximum value of its left subtree we need to find the maximum value of its
1099:53 - right subtree and we need to compare those value with the roots value so
1099:57 - first we'll go to the left of this root so we will call find max again and this
1100:04 - time we'll pass roots left which is 5 but we are leaving this find max method
1100:10 - so we'll keep simply keep the track of this line number so which is 6
1100:18 - so now find max will be called again with roots left which is 5 so one new
1100:25 - root will become 5
1100:31 - root is not equal to null so this condition comes out to be false and now
1100:38 - we'll apply our algorithm recursively to this node we'll first store the roots
1100:44 - data in the result which is 5 and then we will again call find max method to
1100:53 - simply calculate what's the maximum value of its left subtree and we are
1100:58 - leaving this find max method at line number 6 so we'll simply store line
1101:01 - number 6 here
1101:08 - so there will be one more method on the call stack but this time the roots value
1101:12 - will be null because 5's left is null here we are calling roots left so roots
1101:19 - left is null so now root will point to null
1101:27 - here we'll check whether root is equal to null or not so here you can see that we
1101:31 - have encountered a base case that root is equal to null so here
1101:38 - we will simply return the minimum value of the integer because as roots left is
1101:44 - null so there are no more nodes to traverse and we will simply return the
1101:50 - least value of the integers which is integers min value whose value is this
1101:57 - because this value is negative in number therefore it won't affect the maximum
1102:01 - value of this binary tree and as the left child is null so we can simply
1102:08 - return the minimum value of the integer so we are returning the integers min
1102:12 - value so here you can see that we are leaving this find max method here and
1102:18 - once we leave this find max method here this call will go to this method because
1102:23 - this find max method had called this find max method and we also know that we
1102:28 - had left at line number 6 so we'll start our execution from line number 6 and as
1102:34 - we are returning the integers min value so this find max method will get that
1102:39 - value so it would look something like this
1102:45 - this method will be removed from the call stack execution point will reach
1102:50 - here we will start our execution from line number 6 because we had left this
1102:56 - method at line number 6 and here you can see whatever the value this find max
1103:01 - method returned we will simply store in this integer variable left so which was
1103:08 - the integers min value so in the left we will simply store the minimum value of
1103:14 - the integer so I am simply denoting it by IMV here and when we were executing
1103:20 - this find max method here you can see root was pointing to 5 so again root
1103:26 - will point to 5 and we will proceed ahead with this method so here you can
1103:37 - see we have this roots value which is 5 we have calculated the maximum value of
1103:42 - the left now we will calculate the maximum value of the right so we'll
1103:46 - again call the find max method but this time we'll pass the roots right value so
1103:52 - here you can see that we will again have to leave this method at line number 7
1103:57 - this time and we will call find max method again passing in roots right
1104:02 - which is null so it would look something like this line number is updated here
1104:10 - find max method will be called and there will be one more method on the call
1104:15 - stack with root as null so now root will point to null and why this root is
1104:22 - pointing to null because we have called find max method by passing roots right
1104:26 - which is roots right is null so here now root is equal to null so we'll simply
1104:35 - return the minimum value and this method will be removed from the call
1104:39 - stack and the execution point will reach again on this method and we'll start our
1104:47 - execution from line number 7 so this method returned the integer minimum
1104:53 - value which will be stored in the right here and when we have left this find max
1105:01 - method root was pointing to 5 so now root will again point to 5 and the
1105:09 - execution will continue from here so you can see now we have got all the three
1105:14 - values to compare the roots value the maximum value of its left subtree and
1105:22 - the maximum value of its right subtree so now we can simply perform this
1105:27 - comparison for this node so here we'll check whether left is greater than
1105:32 - result or not so left value is the minimum value of the integer so therefore
1105:38 - this condition comes out to be false because value of left is integers
1105:43 - minimum value and result value is 5 so 5 is greater than left so this condition
1105:50 - will come out to be false
1105:53 - we'll check whether right is greater than result or not so right value is also
1105:58 - integer minimum value so this condition also comes out to be false and here you
1106:06 - can see that among this node the maximum value is of the root which is 5 so we'll
1106:11 - simply return 5 from this find max method so now here you can see this find
1106:18 - max method will be removed from the call stack and the return value will be 5
1106:22 - so this method will be removed from the call stack the execution point will
1106:29 - reach here and we know that we have left this find max method at line number 6
1106:33 - so we'll start execution from line number 6 this find max return the value
1106:39 - as 5 so this 5 will be stored in the left variable here and when we left this
1106:47 - find max method root was pointing to 3 so now root will point to 3
1106:55 - moving ahead
1106:58 - so friends for root 3 we have already calculated the maximum value of its
1107:03 - left subtree which is 5 here now we need to simply calculate it for right subtree
1107:09 - so we'll again call find max method and this time we'll pass roots right which
1107:16 - is 8 so we will be leaving this method at line number 7 here
1107:28 - and there will be one more method on the call stack with now new root as 8 so
1107:34 - root will point to 8 now
1107:37 - we check whether root is equal to null or not so root is not equal to null we
1107:45 - will store roots data which is 8 and now similarly we'll perform this recursive
1107:55 - algorithm for the root 8 now so here you can see friends these three steps we
1108:01 - need to perform on each and every node so what we did for 5 now we'll again do
1108:07 - it for 8 so we'll simply go fast here because we already seen what happens
1108:13 - when the nulls are encountered so first we'll update the line number which is 6
1108:19 - and there will be a find max method in the call stack because now we are going
1108:27 - to roots left so roots left is null so this find max will be called with null value
1108:33 - root will point to null and root is equal to null so we'll simply return the
1108:43 - integers minimum value and this method will be removed from the call stack and
1108:48 - integers min value will be returned to this find max method so it would look
1108:54 - something like this we'll start execution from line number 6 where root
1109:01 - will now point to 8 and the integers minimum value which was written from
1109:07 - this find max method will be stored in the left here
1109:12 - and similarly now we'll go to roots right so we'll update the line number
1109:19 - here
1109:23 - so find max method will be called again with the root as null
1109:30 - root will be pointing to null
1109:34 - and here root is equal to null so we'll simply return the minimum value of the
1109:38 - integer so this method will be removed from the call stack and this method will
1109:44 - start execution from line number 7 now where root will now point to 8 because
1109:53 - when we left this find max method root was pointing to 8 so root will point to
1109:57 - 8 now
1109:59 - and the integers minimum value which was written from this find max method will
1110:04 - be stored in the right now and now as we have got these three values to compare
1110:12 - we will check whether left is greater than 8 or not because we need to find the
1110:17 - maximum value so left is not greater than 8 so this condition comes out to be
1110:22 - false
1110:25 - right is also not greater than result because right is storing the integers
1110:29 - minimum value and 8 is greater than this value so this condition also comes out
1110:35 - to be false and we'll simply return 8 from this method because we have found
1110:44 - the maximum value of this right subtree which is 8 so we'll simply return 8 from
1110:50 - this find max method
1110:54 - so this method will be removed from the call stack and the execution point will
1110:58 - reach to this method where we had left at line number 7
1111:05 - so we'll start from here
1111:08 - and here root value was 3 so now root will point to 3
1111:14 - and we know that from the right we return the value which is maximum as 8
1111:19 - so 8 will be stored in the right here
1111:25 - so friends here you can see for this small binary tree we got the three values
1111:30 - 5 was the maximum in the left subtree 8 was the maximum in the right subtree and
1111:38 - we'll simply compare it with the root
1111:41 - which is the result value so here we'll perform the comparison
1111:46 - so we'll check whether left is greater than result or not so this condition comes
1111:51 - out to be true because left value is 5 which is greater than 3
1111:57 - so we'll simply update the value of result with the maximum value which is 5
1112:02 - so this will become 5
1112:06 - we'll check whether right's value is greater than result or not so value of
1112:11 - right is 8 which is greater than result which is 5
1112:16 - so this condition also comes out to be true
1112:20 - so we'll simply update the maximum value which is 8
1112:23 - into the result
1112:27 - so this will become 8
1112:30 - and then we'll simply return 8
1112:32 - so from this find max method we are returning 8
1112:36 - which is the maximum value among these three nodes
1112:41 - so this method will be removed from the call stack
1112:46 - and this method will start execution from line number 6
1112:50 - where root was pointing to 4
1112:52 - so root will now point to 4
1112:56 - and the value which this find max method return
1112:59 - which was 8 will be stored in the left
1113:04 - so here you can see
1113:06 - that for the actual root of the binary tree
1113:08 - we figured out what's the maximum value in the left subtree
1113:12 - which is 8
1113:14 - so now we need to simply find the same for the right subtree
1113:18 - we'll start our execution from line number 6 again
1113:24 - and now we'll simply go to its right subtree
1113:27 - by calling the find max method and passing in the root's right value
1113:31 - which is 7
1113:34 - so this method will be removed from the call stack
1113:38 - and we'll simply store the line number 7
1113:40 - because we need to keep the track of this recursive nature algorithm
1113:44 - so line number will be updated as 7
1113:50 - there will be one more method find max
1113:52 - having the root point to 7
1113:56 - because we have left
1113:58 - from line number 7 passing in root's right value
1114:01 - so root was 4 and its right value is 7
1114:04 - so 7 will be our new root
1114:06 - for this find max method
1114:09 - and friend similarly
1114:12 - we will apply this algorithm recursively on this node now
1114:16 - what we seen with 5 and 8
1114:18 - so we'll simply quickly go over this algorithm
1114:23 - root is not equal to null
1114:25 - we'll store the root's value in the result field
1114:28 - which is 7
1114:31 - we'll recursively go
1114:33 - to the left subtree now here
1114:36 - by passing in root's left
1114:40 - as we are leaving at line number 6
1114:42 - we'll store line number 6
1114:46 - there will be new method on call stack
1114:49 - with root pointing to null now
1114:52 - because we are going to its left now
1114:54 - so this root will be null
1114:58 - and we'll simply return the integer minimum value
1115:01 - from this find max method
1115:06 - we'll start our execution
1115:09 - from where we left
1115:11 - at line number 6
1115:13 - where root was pointing
1115:15 - to 7
1115:19 - and the value which this find max return was integer minimum value
1115:23 - so we'll simply store in the left
1115:27 - and similarly for the right
1115:29 - it will perform the same
1115:31 - we update the line number here
1115:34 - we'll leave this method
1115:36 - we again call find max
1115:37 - with root's right
1115:39 - which is null
1115:40 - so there will be one more method on the call stack
1115:43 - having value of root as null
1115:45 - so root will point to null
1115:50 - we'll simply return the integer's minimum value
1115:52 - because root is equal to null
1115:57 - so this method will again come on the call stack
1115:59 - and we'll start execution from line number 7 now
1116:04 - so here root will now again point to 7
1116:08 - and this method had written integer's minimum value
1116:11 - which we'll simply store in the right
1116:13 - here
1116:16 - and now we'll simply compare
1116:18 - this three value 7
1116:20 - left and right
1116:21 - and we know that 7 is the maximum value
1116:24 - so these two conditions will come out to be false
1116:27 - because left is not greater than result
1116:29 - and right is also not greater than result
1116:32 - so this both the condition will come out as false
1116:35 - and we'll simply return 7
1116:38 - from this find max method because
1116:40 - 7 is the maximum value
1116:42 - of the right subtree
1116:44 - for the actual root
1116:46 - so this method will return 7
1116:51 - execution point will reach here
1116:54 - we had left at line number 7
1116:56 - so we'll start executing from line number 7
1116:59 - where root was actually pointing to 4
1117:01 - so root will point to 4
1117:04 - and the find max method which got executed
1117:06 - before this find max method had written
1117:08 - value as 7
1117:10 - so 7 will be stored in the right
1117:15 - so here you can see
1117:16 - for this complete binary tree
1117:18 - now we have actually got all the three values
1117:22 - the root's value
1117:24 - the maximum value of the left subtree
1117:27 - and the maximum value of the right subtree
1117:30 - so we'll simply compare these three values
1117:32 - and get the maximum value of this binary tree complete
1117:37 - so we'll check whether left is greater than result or not
1117:40 - so value of left is 8
1117:42 - which is greater than result
1117:44 - which is 4
1117:46 - so we'll simply update
1117:48 - the value of left
1117:50 - into result
1117:52 - so result becomes 8 now
1117:56 - we compare whether value of right is greater than result or not
1117:59 - so right value is 7
1118:01 - which is not greater than 8
1118:03 - so this condition comes out to be false
1118:07 - and finally we'll return the value 8
1118:09 - which is the maximum value among this binary tree
1118:13 - so this method will terminate here
1118:17 - and on the call stack this will get removed
1118:21 - returning the maximum value of this binary tree which is 8
1118:27 - so friends here you saw a very long demonstration of this algorithm
1118:31 - where we applied this algorithm recursively
1118:35 - on each and every node
1118:37 - to find what's the maximum value of the binary tree
1118:41 - so friends the complexity is involved in this recursive nature
1118:45 - which we demonstrated using the call stack
1118:48 - and once you understand how this call stack works
1118:51 - you can simply code the algorithm related to binary tree recursively
1118:57 - now let's go to intelligence C
1118:59 - the working of this code
1119:01 - so friends I hope you have liked this video
1119:03 - and in case you have liked this video
1119:05 - then please like, comment, share and subscribe my channel
1119:08 - thanks have a nice day
1119:15 - hello everyone
1119:17 - so in this video we'll see the demonstration of the algorithm
1119:20 - and how we can find the maximum value in a binary tree
1119:25 - so in our previous video we saw
1119:27 - the demonstration of the algorithm step by step
1119:30 - so in this video we'll simply code the algorithm
1119:32 - and see it's working
1119:34 - so here you can see in our previous videos
1119:36 - we created one class as binary tree
1119:40 - which had a root as an instance variable
1119:42 - of type tree node
1119:44 - so this is the class of tree node
1119:46 - which we created in our previous videos
1119:49 - and we saw different algorithms
1119:54 - so here let's say we are given this binary tree
1120:01 - and let's say we provide a maximum value
1120:04 - in this binary tree as 8
1120:06 - and rest of the value we keep as it is
1120:10 - now we want to write an algorithm
1120:12 - where we can find the maximum value
1120:14 - of this binary tree
1120:16 - so friends here in case if you find any difficulty
1120:19 - you can watch my previous videos
1120:21 - where we have demonstrated each and every line of this code
1120:24 - step by step
1120:26 - and we have demonstrated all these algorithms
1120:28 - step by step
1120:31 - so let's code the algorithm to find the maximum value
1120:34 - of a binary tree
1120:36 - so here we have created one method at find max
1120:42 - whose return type is integer
1120:45 - because we want to return the maximum value of a binary tree
1120:49 - so here we will simply return
1120:53 - find max
1120:55 - we will pass in the root
1120:57 - because we need to pass a root
1120:59 - to find the maximum value of a particular binary tree
1121:03 - which we also saw in our previous video
1121:06 - so here we will create a method as public
1121:10 - whose return type will be integer
1121:13 - find max
1121:16 - and this is the method
1121:19 - which will take
1121:21 - the root
1121:23 - of the binary tree
1121:25 - and will simply return
1121:27 - the maximum value of this binary tree
1121:31 - so here this is our binary tree
1121:33 - whose maximum value is 8
1121:37 - so let's see the code to find the maximum value of this binary tree
1121:41 - so as we discussed in our previous video
1121:43 - that this algorithm is recursive in nature
1121:45 - the first thing we provide is the base case
1121:49 - we simply check whether root
1121:51 - is equal to null or not
1121:55 - so if root is equal to null
1121:57 - we will simply return
1122:03 - the minimum value
1122:05 - because as root is null
1122:07 - it simply signifies that
1122:09 - we can simply return the minimum value
1122:11 - of the integer
1122:13 - so here we need to find the maximum value
1122:15 - of this binary tree
1122:17 - and if root is coming out as null
1122:19 - then we need to return an integer value
1122:21 - so we can safely return
1122:23 - the minimum value of the integer
1122:25 - because beyond that there won't be
1122:27 - any minimum value
1122:29 - and our task is to find the maximum value
1122:31 - so this minimum value won't
1122:33 - affect the maximum value of this binary tree
1122:35 - so after providing
1122:37 - this if check for the base case
1122:40 - the first step is
1122:42 - to store the roots value
1122:49 - so we are creating an integer value result
1122:51 - and we are storing the roots
1122:53 - value into this result
1122:57 - and also we discussed the basic idea behind
1122:59 - this algorithm is
1123:01 - in order to find the maximum value of a binary tree
1123:03 - we simply compare
1123:05 - the roots value
1123:07 - to the maximum value
1123:09 - of its left subtree
1123:11 - and also
1123:13 - we will compare this value
1123:15 - with the maximum value of its right subtree
1123:17 - so when we compare
1123:19 - these three values we come to know
1123:21 - what's the maximum value of a binary tree
1123:23 - so this algorithm is very
1123:25 - recursive in nature and this is applied
1123:27 - on each and every node of the
1123:29 - binary tree
1123:31 - so where we simply store the roots value
1123:33 - then we go to its left subtree
1123:35 - to find the maximum value of the left subtree
1123:37 - once we get that value
1123:39 - then we go to its right subtree
1123:41 - and we find the maximum value
1123:43 - of the right subtree
1123:45 - and after we get these three values
1123:47 - we compare them with each other and we get
1123:49 - the maximum value of the complete binary tree
1123:51 - so here
1123:53 - after getting the roots value
1123:57 - we simply try to get the maximum value
1123:59 - of the left subtree
1124:01 - by calling the findMax method
1124:03 - recursively
1124:05 - providing roots
1124:07 - left value
1124:09 - so here we are simply providing
1124:11 - the roots left
1124:13 - which is the left subtree of this root
1124:15 - and whatever the value
1124:17 - this findMax method will return
1124:19 - will simply store in the left variable
1124:21 - and similarly we do it
1124:23 - for the
1124:25 - right subtree
1124:27 - we call
1124:29 - findMax recursively
1124:31 - providing roots right value
1124:35 - so in order to see how this recursive
1124:37 - nature works
1124:39 - you can watch my previous tutorial where we
1124:41 - demonstrated this recursive nature
1124:43 - with an animation
1124:45 - so you can watch that
1124:47 - and here after finding
1124:49 - all these three values
1124:51 - will simply compare it with each other
1124:53 - so the first step will compare
1124:55 - whether left
1124:57 - value
1124:59 - is greater than result or not
1125:03 - so if left is greater than result
1125:05 - we simply update
1125:07 - the result
1125:09 - with the left
1125:11 - because at the last we need to send the result
1125:13 - and which should be the maximum value
1125:15 - so first we are comparing left with result
1125:20 - and then we are comparing
1125:24 - right with result
1125:26 - so if the value of right is greater than
1125:28 - result we are simply
1125:30 - updating
1125:32 - the value of right to result
1125:34 - and at the last
1125:36 - we are simply
1125:38 - returning result
1125:40 - so here you can see that we are comparing
1125:42 - all these three values here
1125:46 - if left is greater than result
1125:48 - we are storing the greater
1125:50 - value in the result
1125:52 - and then we are again comparing
1125:54 - whether right is greater than result or not
1125:56 - and if right is greater than result
1125:58 - then we are storing the value of right
1126:00 - into result
1126:02 - and finally
1126:04 - we are returning result because this will be the maximum
1126:06 - value among these three values
1126:08 - so here you can see this is the algorithm
1126:12 - to find the maximum value
1126:14 - of a binary tree
1126:16 - so lets test its working
1126:18 - in the main method
1126:20 - so first we are creating this binary tree
1126:22 - with these values
1126:24 - where we know that 8 is the maximum value
1126:30 - and here we are simply
1126:32 - printing
1126:34 - the maximum value
1126:36 - by calling the findMax method
1126:38 - which internally will call
1126:40 - this findMax method
1126:42 - providing in the root
1126:44 - which is
1126:46 - this root
1126:48 - and this root is
1126:50 - being created here
1126:52 - with this createBinaryTree method
1126:56 - so after we create this binary tree
1126:58 - with these hard coded values
1127:00 - and when we will call
1127:02 - the findMax method
1127:04 - we will get the maximum value of this
1127:06 - binary tree
1127:12 - so here you can see it printed 8
1127:14 - because 8 was the maximum value
1127:16 - of this binary tree
1127:18 - now lets say if i update any value
1127:20 - to 10
1127:22 - and if i
1127:24 - run the code again
1127:30 - you can see answer came as 10
1127:32 - because 10 is the maximum value of this binary tree
1127:36 - so friends here we saw the algorithm
1127:38 - to find the maximum value
1127:40 - of any binary tree which was
1127:42 - basically recursive in nature
1127:44 - where we compared the three values
1127:46 - one was the root value
1127:48 - we compared it with the maximum value
1127:50 - of its left subtree
1127:54 - and we compared it with the maximum value
1127:56 - of its right subtree
1127:58 - here
1128:00 - and finally we returned the result
1128:02 - which was the maximum value
1128:04 - of the complete binary tree
1128:06 - and this algorithm we applied
1128:08 - on each and every node of the binary tree
1128:10 - because this is recursive
1128:12 - in nature
1128:14 - and in order to see the complete animation
1128:16 - of this recursive nature
1128:18 - you can watch my previous video
1128:22 - so friends this was all about this video
1128:24 - i hope you have liked this video
1128:26 - and in case you have liked this video
1128:28 - then please like, comment, share and
1128:30 - subscribe my channel
1128:32 - thanks have a nice day
1128:44 - how to represent a binary search tree
1128:46 - in java
1128:52 - in our previous tutorial we actually
1128:54 - discussed about the binary tree
1128:58 - we saw that each and every node in the binary
1129:00 - tree had two children
1129:02 - one was the left child and one was
1129:04 - the right child
1129:06 - so a binary search
1129:08 - tree is a special type of binary
1129:10 - tree in which the data is organized
1129:12 - in an ordered manner
1129:14 - which helps us in faster search and insertion
1129:16 - of the data
1129:20 - so how binary search tree helps
1129:22 - us in faster search and insertion of data
1129:24 - we will see later
1129:26 - first we will discuss the three
1129:28 - properties which makes it a binary search
1129:30 - tree
1129:32 - so here in the diagram you can see
1129:34 - a binary search tree which satisfies
1129:36 - these three properties
1129:38 - so the property
1129:40 - one says the left sub tree
1129:42 - of a node contains only nodes
1129:44 - with values lesser than the nodes
1129:46 - value
1129:48 - so what does it mean
1129:52 - let's suppose if we take a node having
1129:54 - data as 6
1129:56 - so all the nodes to its
1129:58 - left like 4, 2, 5
1130:00 - they have values lesser
1130:02 - than 6
1130:04 - so if you see
1130:06 - there are three nodes to the left
1130:08 - of 6
1130:10 - and if you compare the values of
1130:12 - these three nodes with 6
1130:14 - you will find that 4 is less than 6
1130:16 - 2 is less than 6
1130:18 - and 5 is less than 6
1130:20 - so all the nodes
1130:22 - to left of a particular node
1130:24 - should have values lesser than
1130:26 - the nodes value
1130:30 - and similarly if you go to right of any
1130:32 - particular node then all the
1130:34 - values should be greater than
1130:36 - the nodes value
1130:38 - so if we take the example of node
1130:40 - having value as 6 and if we go to
1130:42 - its right we see there are
1130:44 - three nodes having data as 8, 7
1130:46 - and 9
1130:48 - all the values are greater than
1130:50 - the nodes value
1130:54 - so here in the binary search tree
1130:56 - we are keeping the data in ordered form
1130:58 - that from a particular
1131:00 - node if we go to its left
1131:02 - we will only find the values
1131:04 - lesser than the nodes value
1131:06 - and if we go
1131:08 - to its right we will only find the nodes
1131:10 - having values greater than
1131:12 - the particular node
1131:16 - so from the third property says
1131:18 - the left and the right sub tree
1131:20 - each must also be a binary search tree
1131:24 - so from here we saw that node 6
1131:26 - is following these two properties that
1131:28 - all the values to its left are
1131:30 - lesser than the nodes value
1131:32 - and all the values to its right are
1131:34 - greater than the nodes value
1131:36 - and in a binary
1131:38 - search tree these two properties
1131:40 - should be true for each and every node of the binary
1131:42 - search tree
1131:44 - so for example if we take a node
1131:46 - having value as 4
1131:48 - then we can see that to its left
1131:50 - there is only one node and
1131:52 - its value is 2 which is less than 4
1131:54 - and if we go
1131:56 - to its right then there is only one node
1131:58 - whose value is 5
1132:00 - which is greater than 4
1132:02 - so 4 also satisfies these two
1132:04 - properties
1132:06 - and similarly if you are on node 2
1132:08 - then it doesn't have any left and
1132:10 - right check therefore it also
1132:12 - satisfies these two properties
1132:16 - and if these two properties are satisfied
1132:18 - by all the nodes of a tree then
1132:20 - that tree is called as binary search tree
1132:24 - so here in this diagram you can see that it is a binary
1132:26 - search tree
1132:28 - so suppose if I change a value here
1132:30 - and I make it a value as 8
1132:32 - so here you can see
1132:34 - that node
1132:36 - with a value as 4
1132:38 - if we go to its left we are getting
1132:40 - a value lesser than the nodes value
1132:42 - and if we are going to its right
1132:44 - then we are getting a value
1132:46 - greater than nodes value
1132:48 - so 4 satisfies
1132:50 - these two properties
1132:52 - but if we go to the parent of 4
1132:54 - here you can see the value is 6
1132:56 - and we know that all the nodes
1132:58 - of a left subtree should be lesser
1133:00 - than the nodes value
1133:02 - so here you can see 4 to 8
1133:04 - should all be less than
1133:06 - the nodes value but 8 is
1133:08 - greater than 6 therefore this is
1133:10 - not a binary search tree because
1133:12 - these two properties should be true for
1133:14 - each and every node
1133:16 - and if you are on a particular node
1133:18 - then we take all the nodes
1133:20 - of its left subtree and right
1133:22 - subtree and we compare it
1133:24 - with the nodes value
1133:26 - so here you can see 4 and
1133:28 - 2 are lesser than 6 but 8
1133:30 - is not lesser than 6 therefore
1133:32 - it is not a binary search tree
1133:34 - and similarly
1133:36 - if I take a
1133:38 - value of 5 here
1133:40 - then you can see
1133:42 - that if here at node 8
1133:44 - then if we go to its left
1133:46 - we see that value
1133:48 - of 5 is lesser than 8
1133:50 - and if we go to its right
1133:52 - then we have node 9
1133:54 - and value of 9 is greater than 8
1133:56 - so 8 satisfies these two properties
1133:58 - but if we go to the parent of
1134:00 - 8 which is nothing but 6
1134:02 - so here you can see
1134:04 - that it is not a binary search tree
1134:06 - because
1134:08 - from property 2 the right
1134:10 - subtree of a node contains only the nodes
1134:12 - with values greater than the nodes value
1134:14 - so if we see the
1134:16 - right subtree from the node 6
1134:18 - we see it has
1134:20 - 3 nodes and all these
1134:22 - 3 nodes should have values greater than
1134:24 - 6 but here you can
1134:26 - see 8 and 9
1134:28 - have values greater than 6 but 5
1134:30 - is lesser than 6 therefore
1134:32 - this tree is not a binary search
1134:34 - tree
1134:36 - so from all these 3 properties
1134:38 - if satisfied by each and every node of a binary
1134:40 - tree then it becomes a binary
1134:42 - search tree
1134:44 - below these 3
1134:46 - properties makes the search and insertion
1134:48 - of data faster because
1134:52 - let's suppose if we want
1134:54 - to search for a value 5
1134:56 - in this binary search tree
1134:58 - then we simply check
1135:00 - the value 5
1135:02 - with the root of the tree
1135:04 - so here you can see
1135:06 - that 5 is not equal to 6
1135:08 - and as it is a binary
1135:10 - search tree we know that 5 must be
1135:12 - lying somewhere to the left of this
1135:14 - tree because it
1135:16 - satisfies these 3 properties and we
1135:18 - know that the left subtree of a node contains
1135:20 - only values lesser than
1135:22 - the nodes value
1135:24 - so we know that 5 must be lying somewhere to the left
1135:26 - of node 6
1135:28 - so from node 6 we traverse
1135:30 - left and we reach to 4
1135:32 - and also here you
1135:34 - can see when we are traversing to node
1135:36 - 4 we are simply discarding
1135:38 - all the nodes of the right subtree
1135:40 - because we also
1135:42 - know that 5 can never lie to the right
1135:44 - of 6
1135:46 - so let's suppose if we had
1135:48 - a binary search tree having many
1135:50 - nodes then we
1135:52 - could have simply discard half of the nodes
1135:54 - and we would have continued our search
1135:56 - to either right
1135:58 - or to left of the search tree
1136:00 - so friends
1136:02 - if we compare 5 to 4
1136:04 - then we know that 5 is greater than 4
1136:06 - so 5 must be lying somewhere
1136:08 - to the right to 4
1136:10 - and then we simply
1136:12 - traverse to its right and we discard
1136:14 - the left subtree of the node
1136:16 - 4
1136:18 - and finally we found the node having data
1136:20 - as 5
1136:22 - so friends when we want to insert a data
1136:24 - into binary search tree
1136:26 - we usually follow these 3 properties
1136:28 - only
1136:30 - so let's say if we want to insert a node
1136:32 - having data as 10
1136:34 - then we simply start from the
1136:36 - root node we check the value
1136:38 - of root to the data which
1136:40 - we want to insert so here if we compare
1136:42 - the value 6 with 10
1136:44 - then we know that 10 is greater than 6
1136:46 - therefore it should be
1136:48 - inserted to its right
1136:50 - so we traverse to its
1136:52 - right and we see there
1136:54 - is one more node so we
1136:56 - compare this value
1136:58 - with the value which we want to insert
1137:00 - so here 10 is greater than 8
1137:02 - therefore we know that
1137:04 - 10 must be inserted to its right
1137:06 - so we simply traverse
1137:08 - to its right and we find there is
1137:10 - one more node having data as 9
1137:12 - so we check that
1137:14 - whether 10 is greater than 9 or not
1137:16 - so here 10 is greater than
1137:18 - 9
1137:20 - so we go to its right and we find that there is
1137:22 - no node because
1137:24 - 9's right is pointing to null
1137:26 - so we simply insert node
1137:28 - at that place
1137:30 - so friends this is how
1137:32 - search and insertion of data gets
1137:34 - faster in binary search tree
1137:36 - because in each iteration we discard
1137:38 - half of the tree
1137:40 - as we know that we either want to traverse to
1137:42 - right or to left
1137:44 - so friends this is the usefulness of
1137:46 - binary search tree
1137:48 - moving ahead
1137:52 - so friends if we see the
1137:54 - structure of tree node
1137:56 - in a binary search tree then it is very similar
1137:58 - to binary tree
1138:00 - that this tree node is nothing but the inner
1138:02 - class of binary search tree
1138:05 - which has basically the three properties
1138:07 - one is the data property
1138:09 - to hold the data
1138:11 - and other two properties
1138:13 - are nothing but the references to the left sub tree
1138:15 - and the right sub tree
1138:17 - we also provide a constructor
1138:19 - to this tree node class
1138:21 - which takes in a data part
1138:25 - so whenever we want to create a new tree node
1138:27 - we simply pass in the data property
1138:29 - and left and right property
1138:31 - actually points to null
1138:35 - so friends lets go to eclipse and see the implementation
1138:37 - of binary search tree
1138:44 - hello friends
1138:46 - in this section we will discuss how we can implement
1138:48 - a binary search tree
1138:52 - so friends here I have created one class by name
1138:54 - binary search tree
1138:56 - which is having a main method
1139:01 - and we also discussed in our previous tutorial
1139:03 - that binary search tree is nothing but a binary tree
1139:07 - so friends the initial implementation of binary search tree
1139:09 - is very similar to binary tree
1139:14 - in binary search tree class
1139:16 - we will create an instance variable
1139:18 - of type tree node
1139:21 - which would be nothing but the root of the binary search tree
1139:27 - so here we can see the type is of tree node
1139:30 - so we will create an inner class
1139:35 - we will give it a name as tree node
1139:42 - so friends here binary search tree is a type of binary tree
1139:46 - therefore the implementation which we saw in the binary tree
1139:48 - is very much similar to binary search tree
1139:51 - that we have created by inner class by name tree node
1139:56 - also friends in our previous tutorial we discussed
1139:58 - that a tree node consists of three parts
1140:02 - one is the data part
1140:04 - so private
1140:06 - int data
1140:09 - so this property will hold the data of the tree node
1140:13 - here I have taken the type of this data as integer
1140:15 - so it can be any generic type as well
1140:22 - also friends we know that binary search tree
1140:24 - is a type of a binary tree
1140:27 - where each tree node has two children
1140:30 - one is the left children and one is the right children
1140:32 - so we will create
1140:36 - a tree node
1140:38 - and we will give it a name as left
1140:43 - and we will create one more tree node
1140:48 - and we give it a name as right
1140:52 - so basically a tree node has two children
1140:54 - one is the left and one is the right
1140:57 - inside this tree node class we will also provide a constructor
1141:00 - so public
1141:04 - tree node
1141:08 - and this constructor will take the data part
1141:13 - so we will initialize the data of this tree node
1141:16 - with a value which we have passed into the constructor
1141:21 - and also friend whenever the new tree node is created
1141:23 - the left and right points to null
1141:27 - so friend this is how we actually represent a binary search tree in java
1141:32 - in our upcoming tutorial we will actually see
1141:34 - how we can insert
1141:35 - and how we can search
1141:37 - a node into a binary search tree
1141:40 - so friends I hope you like this video
1141:43 - thanks have a nice day
1141:48 - hello friends welcome to my new data structures
1141:50 - and algorithms in java tutorial series video
1141:54 - friends in this tutorial we will discuss
1141:56 - how to insert a value in a binary search tree in java
1142:01 - and also friend in this tutorial we will discuss
1142:03 - the recursive approach to insert
1142:05 - a value in a binary search tree
1142:12 - so friends below you can see the code
1142:14 - to insert a node into a binary search tree
1142:18 - so here the insert method takes in a root node
1142:20 - and the value which you want to insert
1142:24 - also friends here you can see insert method
1142:26 - internally calls insert again
1142:30 - therefore its nothing but a recursive call
1142:33 - so in order to keep the track of this recursion
1142:35 - we will use the call stack
1142:38 - and based on this call stack
1142:40 - we will see the demonstration of this algorithm step by step
1142:44 - so friend lets suppose
1142:46 - currently binary search tree has no nodes
1142:49 - and when the binary search tree is empty
1142:51 - we know that root will point to null
1142:54 - now lets suppose we want to insert
1142:56 - a value phi
1142:58 - into this binary search tree
1143:03 - so here you can see
1143:05 - on the call stack there will be one insert method
1143:09 - and currently as root is pointing to null
1143:11 - therefore here we can keep the track of the root
1143:13 - which is pointing to null
1143:16 - and we can also keep the track of its left and right tree node
1143:19 - which are also null
1143:22 - and the last column will have the value
1143:24 - which we want to insert
1143:26 - moving ahead
1143:29 - so friend in first I will see
1143:31 - that whether root is equal to null or not
1143:33 - because as we are going into this recursion here
1143:36 - we have to provide a base case
1143:38 - so that we can come out of this recursion
1143:41 - so our base case condition would be
1143:43 - to check whether root is equal to null or not
1143:47 - so currently here you can see
1143:49 - binary search tree is empty
1143:51 - therefore root is equal to null
1143:53 - so the condition in if block comes out to be true
1143:58 - and inside this if block
1144:00 - as you want to insert this value phi
1144:02 - therefore first we will create a tree node
1144:04 - and provide the value as phi
1144:06 - so it would look something like this
1144:10 - friends in our previous tutorial
1144:12 - we discussed that when we create a new tree node
1144:15 - we actually pass the value
1144:17 - into the constructor of tree node
1144:20 - so in this tree node
1144:21 - the data is the actual value which is 5
1144:25 - and as it is a new tree node
1144:27 - therefore left and right are pointing to null
1144:31 - and also friends
1144:32 - as we are creating this tree node
1144:34 - we are assigning it to the root
1144:36 - so it would look something like this
1144:39 - that root will point
1144:41 - to a tree node having data as 5
1144:45 - and also friends here will
1144:47 - provide the value as 5
1144:49 - that root is now pointing to 5
1144:51 - moving ahead
1144:55 - and then we will simply return the root
1144:58 - so here insert button will come to an end
1145:01 - and it will be removed from the call stack
1145:06 - so friends when binary search tree was empty
1145:08 - we have inserted one node having data as 5
1145:10 - now lets suppose we want to insert one more value
1145:15 - the value which we are inserting is 3
1145:21 - and here we also know that root is now pointing to
1145:23 - a node having data as 5
1145:26 - so on the call stack it would look something like this
1145:29 - that root is 5
1145:31 - its left and right are null
1145:35 - and the value which we want to insert is 3
1145:40 - so on the first step we will check whether root is equal to null or not
1145:43 - so here you can see root is not equal to null
1145:45 - therefore the condition in if block comes out to be false
1145:52 - so friends in our previous tutorial we actually discussed
1145:54 - what is the binary search tree
1145:56 - we discussed the 3 properties
1145:58 - which binary search tree follows
1146:01 - property 1 was lets suppose if we are on a particular node
1146:05 - which has some value
1146:06 - and if you try what shows left
1146:09 - then all the nodes value to its left
1146:12 - would have values lesser than the nodes value
1146:16 - and if you go to its right
1146:17 - then all the nodes value would be greater than the node value
1146:22 - and these 2 properties should be true for each and every node
1146:25 - of the binary search tree
1146:29 - so friends when we insert a new node
1146:31 - we actually check for these 2 properties
1146:35 - so here you can see we have provided an if block
1146:38 - and inside this if block we have provided condition as
1146:41 - that whether value is less than root.data value
1146:45 - so here you can see root.data is nothing but 5
1146:49 - and the value which we want to insert is 3
1146:52 - so here you can see the value is actually less than root.data value
1146:57 - so here if you want to insert
1146:59 - a new tree node having value is 3
1147:02 - then we can only insert
1147:04 - into the left subtree of the root
1147:07 - because value is less than root.data
1147:10 - so therefore the condition in if block comes out to be true
1147:16 - so friends here you can see we are again calling the insert method
1147:20 - and we are passing the value as root.left
1147:23 - and the value which we want to insert
1147:26 - so on the call set there will be a new insert method
1147:30 - and as there would be a new insert method
1147:33 - we will be leaving this insert method and we will again
1147:35 - calling the insert method
1147:38 - so we need to keep the track of the previous insert method
1147:41 - so we know that we have given the line numbers here
1147:45 - and we know that we are leaving this insert method
1147:48 - at line number 7
1147:50 - so we will simply put a value of 7
1147:52 - in the line number column
1147:56 - and we will call the insert method
1147:58 - and this time we will pass root.left
1148:01 - as a new root
1148:04 - so it would look something like this
1148:10 - that there would be a new insert method on the call stack
1148:14 - and here we know that root.left is null
1148:18 - therefore for this insert method
1148:20 - root will be null
1148:21 - and left and right would be null
1148:23 - and the value which we want to insert is 3
1148:26 - so here root will be pointing to null now
1148:33 - and we will again check whether root is equal to null or not
1148:36 - so here you can see root is equal to null
1148:40 - and then we will create a new tree node
1148:43 - and we will pass the value into its constructor
1148:45 - and we will assign it to the root
1148:47 - so it would look something like this
1148:49 - a new tree node is created
1148:52 - having the value as 3
1148:53 - and left and right are pointing to null
1148:56 - so now root will point to this tree node
1149:01 - moving ahead
1149:02 - so here now root is pointing to 3
1149:08 - and finally we will simply return from this insert method
1149:13 - so friend as soon as we return from this method
1149:16 - this insert method
1149:17 - will be removed from the call stack
1149:20 - and the execution point will reach
1149:22 - to the insert method which was executed just before that
1149:27 - and we also know that we have left at line number 7
1149:29 - so we will start the execution from line number 7
1149:33 - so it would look something like this
1149:38 - so now we are starting again
1149:40 - this insert method from line number 7
1149:43 - and when we had left this insert method
1149:45 - root was pointing to 5
1149:48 - so here
1149:50 - root is now pointing to 5
1149:54 - and as we had written root
1149:56 - which was nothing but 3
1149:58 - it will be assigned to roots left
1150:01 - so here you can see root is pointing to 5
1150:03 - and roots left is pointing to null
1150:06 - therefore whatever we return from previous insert method
1150:08 - it will be assigned to roots left
1150:11 - so it would look something like this
1150:15 - moving ahead
1150:18 - now root left is 3
1150:23 - and then finally we will simply return the root
1150:27 - so the execution of this insert method will be complete
1150:29 - and it will be removed from the call stack
1150:35 - so friends here we have inserted 2 nodes
1150:39 - now let's suppose we want to insert a value 7
1150:43 - so it would look something like this
1150:47 - first insert method will be created on the call stack
1150:50 - having root as 5
1150:52 - whose left is 3
1150:54 - and whose right is null
1150:57 - and the value which you want to insert is 7
1151:01 - we will check whether root is equal to null or not
1151:04 - so here you can see root is pointing
1151:06 - to a node having data as 5
1151:08 - therefore it's not null
1151:13 - and using the binary search tree properties
1151:15 - we will check that whether value
1151:18 - which we want to insert is less than root.data or not
1151:24 - so here you can see root.data is nothing but value 5
1151:29 - and here we are inserting a value 7
1151:32 - therefore the condition in if block comes out to be false
1151:36 - we are inserting a value 7 which is greater than the roots value
1151:41 - therefore it must be inserted
1151:43 - to the right sub tree of the root
1151:46 - so now else block will be executed
1151:52 - now here we want to insert the value to roots right
1151:58 - therefore we are again calling the insert method
1152:02 - and this time we are passing in a value as root.right
1152:06 - so here you can see root is pointing
1152:08 - to a node having data as 5
1152:10 - and its right is pointing to null
1152:12 - and as you want to insert a new node to its right
1152:16 - therefore we are simply calling the insert method
1152:19 - and we are passing root.right
1152:21 - with a value which you want to insert
1152:24 - and also here we are again calling the insert method
1152:27 - we are leaving this previous insert at line number 9
1152:32 - so we will simply put a value of 9 into the line number column
1152:38 - that we are leaving this insert method at line number 9
1152:42 - so now on the call set there would be a new insert method
1152:49 - and as we have passed in root.right
1152:51 - so here you can see root.right is null
1152:54 - so we are executing this insert method with root as null
1152:58 - and left and right are null
1153:00 - and the value which you want to insert is 7
1153:03 - and friends as this insert method is getting executed
1153:06 - root is pointing to null
1153:09 - so root is pointing to null
1153:13 - we are checking whether root is equal to null or not
1153:15 - so here root is equal to null
1153:20 - and as you want to insert this new tree node having value as 7
1153:24 - we will simply create a new tree node
1153:26 - and pass a value 7 to its constructor
1153:28 - and then we will assign it to the root
1153:30 - so it would look something like this
1153:34 - the root will now point to a tree node
1153:37 - having data as 7 and whose left and right are pointing to null
1153:42 - so here root becomes 7
1153:47 - and finally we simply return the root
1153:50 - so when we return the root
1153:52 - execution of this insert method gets completed
1153:56 - so it would be removed from the call stack
1154:00 - and the execution point reaches to insert method
1154:03 - which was getting executed just before this insert method
1154:06 - and we know that we had left this insert method at line number 9
1154:14 - so we will start our execution from that point
1154:19 - so friends here once the insert method gets executed
1154:23 - we had return the value 7
1154:26 - and once the execution starts from line number 9
1154:28 - we know that at that point
1154:30 - root was pointing to 5
1154:33 - so root will point to 5
1154:36 - and we also know that we have written node 7 from the insert method
1154:40 - so therefore simply assign whatever you return from the insert method
1154:43 - to root.right
1154:45 - so here root is pointing to node 5
1154:47 - and its right is pointing to null
1154:50 - therefore node 7 will now point to root's right
1154:54 - so it would look something like this
1154:59 - so here now right will become 7
1155:02 - and then we will simply return from this insert method
1155:08 - so this insert method will be removed from the call stack
1155:13 - so friends here we inserted 3 nodes
1155:16 - now lets suppose we want to insert one more node
1155:18 - having value as 1
1155:22 - so in the first step we will call the insert method
1155:25 - providing in the root and the value as 1
1155:29 - so here root is pointing to 5
1155:33 - and left is pointing to 3
1155:35 - and right is pointing to 7
1155:37 - and the value which we want to insert is 1
1155:41 - in the first step we are checking whether root is equal to null or not
1155:44 - so root is not equal to null
1155:49 - so friends as it is a binary search tree
1155:52 - we are checking whether value
1155:54 - which we want to insert is less than
1155:56 - root's value or not
1155:58 - so here you can see 1 is less than 5
1156:01 - therefore we are sure that the value 1
1156:03 - will be inserted somewhere to its left sub tree
1156:08 - so therefore the condition in if block comes out to be true
1156:11 - because 1 is less than 5
1156:18 - and here we are again calling the insert method
1156:21 - by passing in root.left and the value
1156:25 - so here root.left is nothing but 3
1156:28 - and as we are leaving this insert method
1156:30 - we will keep the track of the line number
1156:34 - so we are providing value as 7
1156:40 - so now the insert method will be called
1156:42 - with root.left
1156:44 - which is nothing but node 3
1156:47 - so for this insert our root will become 3
1156:51 - so here you can see
1156:53 - there will be a new insert method
1156:55 - where root will be 3
1156:58 - and left and right are null
1157:00 - and the value which we want to insert is 1
1157:04 - so here now root will point to 3
1157:10 - we will check whether root is equal to null or not
1157:12 - so root is not equal to null
1157:16 - and then we will check whether value
1157:18 - which we want to insert
1157:20 - is less than root.data or not
1157:22 - so here 1 is less than 3
1157:26 - so we know that 1 should lie to the left sub tree
1157:28 - of the root having value as 3
1157:36 - therefore we are again calling insert method
1157:38 - by passing in to the value as root.left
1157:40 - so here root.left is nothing but null
1157:43 - and as we are leaving this insert method
1157:45 - we will keep the track of the line number
1157:47 - which is nothing but 7
1157:54 - so here a new insert method will be on the call stack
1157:57 - having root as null
1157:59 - because here we are passing root.left
1158:01 - so root.left is nothing but null
1158:06 - so now root will point to null
1158:10 - moving ahead
1158:12 - we will check whether root is equal to null or not
1158:14 - so here you can see root is equal to null
1158:18 - and then we will create a new tree node
1158:20 - by providing it the value as 1
1158:23 - and that tree node will assign to the root
1158:26 - so it would look something like this
1158:28 - that now root is pointing
1158:30 - to a node having data as 1
1158:32 - and whose left and right are pointing to null
1158:36 - so now root is pointing to 1
1158:41 - and then we will simply return the root
1158:44 - so we are simply returning
1158:46 - the tree node having data as 1
1158:49 - so when we return this tree node
1158:53 - we know that this insert method is completed
1158:57 - execution point reaches here
1158:59 - and we will start our execution from line number 7
1159:04 - so at line number 7
1159:06 - when we had left this insert method
1159:08 - root was pointing to 3
1159:11 - so now root will point to 3
1159:16 - and we know that to root left
1159:18 - we have assigned the value
1159:20 - which we had returned from the insert method
1159:23 - so root.left is null
1159:25 - and the value which we
1159:27 - returned from the insert method was nothing but
1159:29 - 1
1159:32 - so therefore now root.left will point
1159:34 - to the tree node having data as 1
1159:37 - so here left will now become 1
1159:40 - and it would look something like this
1159:47 - and finally we will simply return root
1159:50 - so when we return root
1159:52 - this insert method will be completed
1159:54 - and it will be removed from the call stack
1159:59 - and the execution point reaches
1160:01 - to the insert method
1160:03 - and we will again start execution
1160:05 - from the line number 7
1160:07 - and at that point root was pointing to 5
1160:10 - so therefore now root will point to 5
1160:15 - and as we have returned tree node
1160:17 - having value as 3
1160:19 - that would be assigned to root.left
1160:21 - so here root is pointing to a node
1160:23 - having data as 5
1160:25 - we will simply assign the value 3
1160:27 - to root.left
1160:30 - so it would look same
1160:33 - and finally we will simply return the root
1160:36 - so the insert method will be completed
1160:38 - and it will be removed from the call stack
1160:42 - so friends here we inserted
1160:44 - 4 nodes into binary search tree
1160:48 - by applying the properties of binary search tree
1160:52 - that suppose if we are on a particular node
1160:55 - then all the values
1160:57 - of the nodes to its left
1160:59 - would be lesser than the nodes value
1161:01 - and all the values
1161:03 - to its right subtree
1161:05 - would be greater than the nodes value
1161:09 - so here you can see
1161:11 - 3 and 1 are lesser than 5
1161:13 - therefore they lie on the left subtree
1161:15 - of this node
1161:17 - and here you can see 7 is greater than 5
1161:20 - therefore it is lying
1161:22 - on the right subtree
1161:25 - now friends lets go to Eclipse
1161:27 - and see the working of this code
1161:34 - hello friends
1161:35 - in our previous tutorial we actually discussed
1161:37 - how we can insert a node
1161:39 - into a binary search tree
1161:41 - so in this tutorial we will actually code
1161:43 - how to insert a node
1161:45 - into a binary search tree
1161:49 - so first we will create an insert method
1161:51 - so public
1161:54 - void insert
1161:59 - and to this insert method
1162:01 - we will actually pass the value
1162:03 - which we want to insert
1162:07 - and insert is insert method
1162:11 - we will simply call the insert method
1162:15 - which we actually discussed in the slide
1162:17 - so we will pass root
1162:19 - and the value which we want to insert
1162:25 - and here we will create a method as
1162:27 - public
1162:30 - whose return type would be tree node
1162:33 - name would be insert
1162:39 - taking in parameters as root
1162:44 - and the value which we want to insert
1162:48 - friends in our previous tutorial we actually discussed
1162:50 - the recursive way
1162:52 - to insert a node into a binary search tree
1162:56 - so here we will first provide a base case
1163:00 - that if root is equal to null
1163:05 - then we will simply
1163:07 - create a new tree node
1163:15 - by passing in the value
1163:18 - and then we will simply return
1163:20 - the root
1163:24 - so this would be our base case
1163:27 - and if root is not equal to null
1163:33 - then we provide the condition which binary tree satisfies
1163:37 - that if value
1163:40 - which you want to insert is less than
1163:42 - root's value
1163:46 - then we simply traverse
1163:48 - to its left
1163:50 - and we will again call insert method
1163:58 - by passing in root left
1164:02 - and the value which we want to insert
1164:06 - and if value is greater than root's value
1164:09 - then in the else part
1164:12 - we simply traverse
1164:16 - to the right subtree
1164:18 - by calling insert
1164:23 - and providing the values
1164:26 - root.right
1164:28 - and the value which we want to insert
1164:32 - so whatever the insert method will return
1164:34 - we will simply assign it to the root's left
1164:37 - and in the else part whatever the insert method will return
1164:40 - we will simply assign to root's right
1164:44 - and finally we will simply return
1164:48 - root
1164:51 - so for example in our previous tutorial we actually saw
1164:53 - how this insert method works step by step
1164:57 - now let's test this working into the main method
1165:02 - so first we will create
1165:06 - the instance of binary search tree
1165:08 - and then we will insert few nodes
1165:20 - which we actually saw into the slide
1165:24 - so with the value as 5
1165:29 - 3
1165:33 - 7
1165:36 - and 1
1165:40 - so friends after inserting this 4 nodes
1165:42 - we will simply print it on the console
1165:44 - whether they are inserted in the right order or not
1165:47 - so friends in order to print the nodes on the console
1165:51 - I will code the algorithm for in order tree traversal
1165:55 - which we actually discussed in our previous tutorial
1165:58 - when we discussed about the binary tree
1166:02 - so in order
1166:06 - so here it simply will call in order
1166:11 - by passing in the root
1166:16 - so here we will provide
1166:23 - in order method
1166:26 - which will have the root
1166:31 - so we had also discussed that
1166:34 - will first
1166:37 - so friends we also discussed
1166:39 - that in order traversal
1166:42 - we first check
1166:46 - whether root is equal to null or not
1166:50 - so root is equal to null will simply return
1166:55 - and in this traversal
1166:58 - we also discussed that first we visit
1167:00 - the left subtree of the root
1167:09 - then we actually visit
1167:13 - the root
1167:22 - and finally we visit
1167:25 - the right subtree
1167:30 - also friends here you can see that first we are going to the left of the root
1167:39 - then we are actually printing the root strata
1167:42 - and then we are going to its right
1167:45 - so friends binary search tree also follows one property
1167:49 - that if we do the in order traversal
1167:51 - of a binary search tree
1167:53 - then the nodes will be printed
1167:55 - in sorted form
1167:58 - so lets see how
1168:01 - so will simply call
1168:05 - in order
1168:06 - which will internally call the in order
1168:08 - and will pass root into it
1168:11 - so if I run the code now
1168:21 - so friends here you can see it printed 1357
1168:27 - and also you can see that numbers are in sorted order
1168:31 - because if we perform in order traversal on the binary search tree
1168:35 - we get the traversal in sorted order
1168:39 - so friends which actually proves that
1168:41 - whatever we inserted into the binary search tree
1168:44 - followed these three properties
1168:49 - friends I hope you like this video
1168:51 - thanks have a nice day
1168:58 - hello friends welcome to my new data structures
1169:01 - and algorithms in java tutorial series video
1169:05 - friends in this tutorial we will discuss
1169:07 - how to search a given key in a binary search tree
1169:12 - also in this tutorial we will see
1169:14 - how we can search a given key in a binary search tree using recursion
1169:22 - so friends lets suppose we are given a binary search tree
1169:25 - and we want to search a particular value
1169:27 - inside this binary search tree
1169:31 - so below you can see the algorithm
1169:33 - to search a given key in a binary search tree
1169:39 - also friends the method which we are going to call is search method
1169:44 - and here inside this search we are again calling search method
1169:48 - therefore in this algorithm we are basically using recursion
1169:51 - so friends in order to keep the track of this recursion
1169:57 - we are basically maintaining a call stack
1170:01 - whose significance we will see while demonstrating
1170:03 - the algorithm step by step
1170:09 - friends lets suppose we want to search a key 5
1170:11 - into this binary search tree
1170:15 - so in the first step we will simply call this search method
1170:18 - by providing it a root
1170:21 - which is the root of the binary search tree
1170:23 - and the key which we want to search
1170:28 - so friends when the search method will start its execution
1170:31 - on the call stack it would look something like this
1170:35 - that there would be a search method on the call stack
1170:39 - and as we are passing the root which is nothing but 6
1170:43 - and the key which we want to search is 5
1170:47 - so here we are simply keeping the track of these values
1170:51 - moving ahead
1170:56 - so friends as we are searching a particular tree using this recursion
1171:00 - we have to provide a base case
1171:03 - so that we can come out of the recursion
1171:06 - so here the base case would be
1171:08 - we are simply checking in the vlog that
1171:10 - whether root is equal to null or root.data is equal to key or not
1171:15 - so currently you can see root is not equal to null
1171:17 - it is pointing to a node having data as 6
1171:21 - and we also know that root.data
1171:25 - which is value 6
1171:27 - is not equal to key which is 5
1171:29 - therefore the condition in if block comes out to be false
1171:35 - so friends in our previous tutorial
1171:37 - we actually discussed what is a binary search tree
1171:41 - so friends the binary search tree
1171:43 - is nothing but a binary tree
1171:45 - which follows some properties
1171:48 - so the first property says that
1171:51 - let's suppose we are on a particular node
1171:53 - and if we traverse to its left subtree
1171:56 - we will find the nodes
1171:58 - having values lesser than the node value
1172:02 - so let's suppose we are on node 6
1172:05 - if we traverse to its left subtree
1172:07 - we are seeing the nodes having values 4, 2 and 5
1172:10 - so these all three values are lesser than 6
1172:14 - and similarly for any node if we go to its right subtree
1172:17 - we will find the values greater than the node value
1172:22 - so let's suppose if we take an example of node 6
1172:25 - if we go to its right subtree
1172:27 - we are finding there are three nodes
1172:29 - having values 8, 7 and 9
1172:31 - so all these three values are greater than 6
1172:35 - also friends these two properties
1172:37 - should be true for each and every node of the binary search tree
1172:41 - and using these three properties
1172:43 - we are actually searching a particular key
1172:45 - in the binary search tree
1172:49 - so here in the fblog we are simply checking
1172:51 - that whether value of key is less than root.data or not
1172:54 - so here you can see
1172:56 - root.data is nothing but value 6
1172:58 - and the key which we are searching is 5
1173:02 - so by the binary search tree property
1173:04 - we know that 5 must be lying somewhere
1173:06 - to the left subtree of node 6
1173:10 - so here the condition in fblog comes out to be true
1173:19 - so friends here we know that 5 must be lying to the left subtree of node 6
1173:25 - therefore we are calling search method again
1173:27 - by passing in the values root.left
1173:29 - and the key which we want to search
1173:33 - also friends when we call this search method
1173:35 - we are actually leaving this search method
1173:39 - and we are again calling the search method
1173:42 - so therefore in order to keep the track of the previous search
1173:46 - we will store the line numbers
1173:51 - so it means that we are leaving
1173:53 - this search method at line number 6
1173:55 - and we are again calling search
1173:57 - by providing root.left
1173:59 - and the key which we want to search
1174:04 - so friends this search method will be called again
1174:09 - and this time the root will become root.left
1174:14 - which is nothing but 4
1174:18 - so here on the call stack there would be one more search method
1174:25 - so as we call this search method by passing root.left
1174:29 - which was nothing but value 4
1174:31 - so root became 4
1174:34 - so here root will now point to 4
1174:39 - moving ahead
1174:43 - we will again check whether root is equal to null or not
1174:46 - so here you can see root is not equal to null
1174:49 - because root is referring to a node having value as 4
1174:53 - we will also check whether root.data is equal to key or not
1174:57 - so here you can see root.data which has value 4
1175:00 - is not equal to key which is 5
1175:03 - therefore the condition in if block comes out to be false
1175:08 - and then we will again check whether key is less than root.data or not
1175:12 - so here you can see root.data is 4
1175:14 - and the key which we are searching is 5
1175:17 - so therefore 5 is greater than 4
1175:21 - so the condition in if block comes out to be false
1175:26 - so the else part will be executed
1175:29 - so friends as here key is greater than root.data
1175:32 - we know that 5 must be lying somewhere to the right sub tree of the node 4
1175:37 - so therefore in the else block
1175:42 - we will simply call the search method again
1175:44 - by passing in root.right
1175:47 - and the key which we want to search
1175:51 - and also friends as we are leaving this search method
1175:53 - we have to keep the track of the previous search method
1175:57 - so first we will store the line number
1175:59 - so it would look something like this
1176:02 - that we are leaving this search method at line number 8
1176:06 - and we are calling this search method again
1176:08 - by passing root.right as the new root
1176:11 - and the key which we want to search
1176:13 - so it would look something like this
1176:17 - on the call stack there would be one more search method
1176:23 - and as we are calling it by root.right
1176:25 - we know that root.right is nothing but
1176:27 - node having data is 5
1176:29 - so here root is 5
1176:32 - so root will now point to 5
1176:41 - then we will check whether root is equal to null
1176:44 - so here you can see root is pointing to node having data is 5
1176:47 - therefore it is not equal to null
1176:49 - and we will again check whether root.data is equal to key or not
1176:53 - so here you can see key is nothing but 5
1176:55 - and root.data is also 5
1176:58 - therefore root.data is equal to key
1177:00 - so the condition in if block comes out to be true
1177:07 - so friend it means that we have found our key
1177:10 - so in the line number 3 we are simply returning the root
1177:13 - which is nothing but the key which we found
1177:18 - so this is the tree node which we have actually found
1177:21 - and we are returning this tree node
1177:23 - from this search method
1177:27 - so friends after this line gets executed
1177:30 - this search method will be removed from the call stack
1177:33 - and the execution point will go to its previous search method
1177:42 - and we also know that we had left the previous search method at line number 8
1177:46 - so we will start our execution from that point
1177:53 - also friends when we had left this search method
1177:55 - we know that root was pointing to 4
1177:59 - therefore now root will point to 4
1178:05 - and from the line number 8 we will simply return
1178:08 - whatever the value we got from this search method
1178:11 - which was nothing but a tree node as in data is 5
1178:16 - so therefore this search method will be executed completely
1178:19 - and it will be removed from the call stack
1178:22 - and the execution point will reach to this search method
1178:29 - and we know that we left this search method at line number 6
1178:33 - so we will start our execution from line number 6
1178:38 - and also friends when we had left this search method
1178:40 - get temp root was pointing to 6
1178:43 - therefore now root will point to 6
1178:48 - and finally we will return what we actually got from the previous search
1178:52 - which was nothing but the tree node having data as 5
1178:55 - so we will simply return 5
1178:59 - and this search method will be removed from the call stack
1179:09 - so friends this is how we actually search for a particular value in a binary search tree
1179:14 - now let's suppose if we want to search one more value which is not in the binary search tree
1179:19 - so let's say we want to search a key having value as 10
1179:23 - so we know that 10 is not in the binary search tree
1179:26 - so let's see how this algorithm works
1179:30 - in the first step we will call the search method
1179:33 - by passing in the root
1179:35 - and the key which we want to search
1179:37 - so on the call stack it would look something like this
1179:41 - that root is 6
1179:42 - and the key which we want to search is 10
1179:46 - moving ahead
1179:49 - we check whether root is equal to null or not
1179:52 - so root is pointing to 6 therefore it's not equal to null
1179:56 - we will also check whether root.data is equal to key or not
1179:59 - so here you can see root.data which is 6
1180:02 - is not equal to 10
1180:05 - therefore condition in if block comes out to be false
1180:12 - and then using the three properties of binary search tree
1180:15 - we will see whether 10 is lying into this binary search tree or not
1180:20 - so in the first step we will check whether key is less than root.data or not
1180:25 - so here you can see 10 is not less than 6
1180:30 - therefore we know that 10 might lie somewhere to its right sub tree
1180:36 - so the condition in if block comes out to be false
1180:39 - and the else part will be executed
1180:41 - so here as we know that 10 might lie somewhere to the right sub tree of 6
1180:50 - therefore we again call search method
1180:53 - by passing in root.write
1180:56 - so root is pointing to 6
1180:58 - and root.write is pointing to 8
1181:01 - and as we are leaving this search method
1181:03 - we will keep the track of the line number which is 8
1181:06 - and then we will simply call the search method
1181:12 - by passing in root.write and the key which we want to search
1181:18 - so on the construct there would be one more search method
1181:21 - and this time root will become 8
1181:25 - so root will point to 8
1181:31 - moving ahead
1181:34 - we will check whether root is equal to null or not
1181:37 - so root is not equal to null because it is pointing to a node having value as 8
1181:43 - we also check whether root.data is equal to key or not
1181:46 - so root.data is 8 and key which we want to search is 10
1181:50 - therefore 8 is not equal to 10
1181:52 - so the condition in if block comes out to be false
1181:58 - we again check whether key is less than root.data or not
1182:02 - so root.data is 8
1182:04 - and the key which we want to search is 10
1182:06 - so 10 is not less than 8
1182:09 - therefore we know that 10 might lie to the right sub tree of 8
1182:15 - so the condition in if block comes out to be false
1182:17 - and the else part will be executed
1182:23 - so here we will again call the search method
1182:25 - by passing in root.write
1182:27 - so here root is pointing to 8
1182:29 - and its write is 9
1182:31 - and as we are leaving this search method
1182:33 - we will keep the track of the line number
1182:40 - so on the call stack there would be a new search method
1182:44 - and this time root will become 9
1182:48 - because we are passing root.write
1182:50 - as root is pointing to 8
1182:52 - its write is pointing to 9
1182:56 - so here our new root will become 9
1182:59 - we will again check whether root is equal to null
1183:06 - so here root is not equal to null
1183:08 - because root is pointing to a node having value as 9
1183:13 - we will also check whether root.data is equal to key or not
1183:16 - so root.data is 9
1183:18 - and the key which we want to search is 10
1183:21 - therefore root.data is not equal to key
1183:24 - so the condition in if block comes out to be false
1183:29 - we will again check whether key is less than root.data or not
1183:33 - so here 10 is not less than 9
1183:35 - therefore the condition in if block comes out to be false
1183:38 - and the else part will be executed
1183:44 - because we know that 10 must be lying somewhere to the right subtree of 9
1183:49 - so here you can see we are again calling search method
1183:52 - and we are leaving this search method at line number 8
1183:55 - so we will keep the track of the line number
1183:58 - and we will call the search method by passing in root.write
1184:02 - so here you can see root is pointing to 9
1184:05 - and its write is pointing to null
1184:08 - because there is no write child to node 9
1184:15 - so on the call stack there would be one more search method
1184:20 - so value of root would be null
1184:22 - so root will point to null
1184:25 - moving ahead
1184:30 - we will again check whether root is equal to null or not
1184:33 - so here you can see root is equal to null
1184:36 - therefore condition in if block comes out to be true
1184:40 - so friends condition in this if block is
1184:42 - nothing but our base case because
1184:44 - after 9 there are no nodes
1184:46 - into this binary search tree
1184:49 - therefore by some way we need to exit this recursion
1184:54 - so friends here we know that 10 is not lying into this binary search tree
1184:58 - and also root is pointing to null
1185:01 - therefore in the if block we simply return root
1185:07 - which would be nothing but null
1185:13 - and as we are returning null
1185:15 - it signifies that key was not found into this binary search tree
1185:20 - so here this search method is executed completely
1185:24 - so it will be removed from the call stack
1185:27 - and the execution point will reach to this search method
1185:32 - and we know that we had left
1185:34 - this search method line number 8
1185:36 - so we will start our execution from line number 8
1185:39 - and when we had left this search method
1185:42 - root was pointing to 9
1185:44 - so therefore root will point to 9
1185:49 - also from what we had returned from his previous search
1185:51 - which was nothing but null
1185:54 - we will simply return null from this search method
1185:59 - so it will be removed from the call stack
1186:03 - and the execution point will reach to this search method
1186:06 - and we will start our execution from line number 8
1186:11 - and when we had left this search method
1186:13 - root was pointing to 8
1186:15 - so now root will point to 8
1186:19 - and also friends from this search model
1186:21 - we will simply return the null value
1186:25 - so this search model will be removed from the call stack
1186:29 - and then the execution point will reach to this search method
1186:33 - and we will start our execution from line number 8
1186:37 - and when we had left this search method
1186:39 - root was pointing to 6
1186:41 - so now root will point to 6
1186:46 - and also friends on this line will simply return
1186:49 - the value which we got from its previous search
1186:51 - which was nothing but null
1186:55 - so this method will be removed from the call stack
1187:00 - and at last we will simply return null
1187:04 - which would signify that value was not found into the binary search tree
1187:11 - so in this tutorial we saw the demonstration
1187:13 - of how to search a particular key into the binary search tree
1187:18 - now let's go to Eclipse and see the working of this code
1187:25 - hello friends
1187:28 - in our previous tutorial we actually saw the demonstration
1187:32 - of how to search a particular key into a binary search tree
1187:36 - in this tutorial we will actually code the search algorithm
1187:39 - and we will test its working
1187:42 - so friends in our previous lectures we actually created a class by name binary search tree
1187:48 - we also saw how we can insert a value into a binary search tree
1187:53 - so friends in this tutorial we will actually code
1187:55 - how to search a given key in a binary search tree using recursion
1188:03 - so here first we will create a method
1188:07 - whose return type would be the tree node
1188:11 - and we will give the name as search
1188:18 - this search method will take in
1188:21 - the key which we want to search
1188:25 - and inside this search method we will simply call
1188:29 - search
1188:33 - by passing in the root
1188:35 - which holds the complete binary search tree
1188:38 - and the key which we want to search
1188:41 - and we will again create one more method
1188:43 - whose demonstration which we actually saw in our previous tutorial
1188:52 - so the name of the method is search
1188:58 - it will have two parameters
1189:02 - one would be the root of the binary search tree
1189:05 - and other would be the key which we want to search
1189:09 - so in this search method
1189:11 - as we are using the recursion we have to first provide a base case
1189:16 - so our base case would be
1189:19 - if root is equal to null
1189:23 - or
1189:25 - root.data is equal to key
1189:30 - then we will simply return the root from this method
1189:36 - so here
1189:38 - this would be our base case
1189:41 - because this case will help us in getting exit from this recursion
1189:47 - and if root is not equal to null or root.data is not equal to key then
1189:52 - we simply check
1189:58 - that whether key is less than root.data or not
1190:04 - so if key is less than root.data
1190:07 - we know that key must be lying somewhere to the left sub tree of the root
1190:12 - therefore we will simply call the search method
1190:18 - by passing in root.left
1190:21 - and the key which we want to search
1190:27 - and also whatever is written from this search method will simply return
1190:32 - here
1190:34 - and in else part
1190:37 - if key is greater than root.data then we know that key must be lying to the right sub tree of the root
1190:46 - so therefore we will call the search method
1190:51 - recursively by passing root.right
1190:56 - and the key which we want to search
1190:59 - and whatever will be written from this method will simply return here
1191:06 - so friends here we are calling this search method recursively
1191:10 - by using the binary search tree properties
1191:13 - so there can be a two case where we are actually finding our key
1191:18 - then we are simply returning the root
1191:20 - and if you are not finding the key then we are simply returning null
1191:24 - so the null signifies that key was not found in the binary search tree
1191:29 - also friends we saw the demonstration of this algorithm step by step in our previous tutorial
1191:34 - now in the main method lets test its working
1191:38 - so here in the main method we have created one binary search tree
1191:43 - by inserting few values is 5 3 7 1
1191:48 - and then we are simply printing this binary search tree
1191:52 - so if I run the code now
1191:58 - you can see its printing the value of binary search tree
1192:01 - using this inorder tree traversal
1192:04 - and it prints 1 3 5 7
1192:09 - so friends in this binary search tree
1192:12 - we know that it has 4 values 5 3 7 1
1192:15 - so lets suppose we search for value 3
1192:18 - so we will provide a if block
1192:23 - and we will call the search method
1192:27 - by passing in the value as 3
1192:32 - so if this search method does not return null
1192:38 - then we know that we have found our value
1192:41 - so we will simply print down the console
1192:46 - as key found
1192:57 - so if I run the code now
1193:04 - you see it prints key found because 3 is present into this binary search tree
1193:10 - now lets say if we want to search any value which is not present into this binary search tree
1193:16 - so here we will simply call search method
1193:19 - by providing us value as lets say 10
1193:22 - and we know that 10 is not present into this binary search tree
1193:26 - so we will simply print
1193:31 - key not found
1193:36 - if I run the code now
1193:41 - you see it printed key not found
1193:47 - so friends in this tutorial we actually saw
1193:50 - how we can code an algorithm to find a key into a binary search tree
1193:55 - and we also tested its working
1193:59 - I hope you like this video
1194:01 - thanks have a nice day
1194:03 - hello everyone
1194:05 - so in this video we are going to discuss a problem
1194:08 - validated binary search tree
1194:10 - so lets see what this problem is and how to solve this
1194:14 - so in this problem we are given a root of a binary tree
1194:18 - now our task is to determine whether it is a valid binary search tree or not
1194:24 - or bst
1194:26 - so a binary search tree if it follows these 3 properties then its a valid bst
1194:32 - so the properties are lets say if you are on any particular node
1194:36 - the left subtree of a node contains only nodes with keys less than the nodes key
1194:42 - so it means here node key is 4
1194:45 - and if we look towards its left
1194:48 - then all the nodes
1194:50 - which are on its left should have value lesser than 4
1194:55 - so for example if we take 6
1194:59 - if we look towards its left
1195:02 - it has 3 elements
1195:04 - so the left subtree which is 4, 2, 5
1195:08 - should contain only the nodes with keys less than the nodes key
1195:12 - so 4 is less than 6, 2 is less than 6, 5 is less than 6
1195:16 - and similarly the right subtree of a node
1195:20 - which is on this side
1195:22 - should contain only nodes with keys greater than the nodes key
1195:28 - so 8 should be greater than 6, 7 should be greater than 6
1195:32 - and 9 should be greater than 6
1195:34 - so for 6
1195:37 - the left should be lesser
1195:41 - and the right should be greater
1195:45 - and these 2 properties should be true for all the nodes
1195:48 - so here both the left and right subtrees must also be binary search trees
1195:55 - so what we saw on 6
1195:57 - the same property should hold for 4, 8, 2, 5, 7 and 9
1196:04 - that if we go towards its left
1196:07 - all the nodes towards left of a node should be less than the nodes value
1196:12 - and if we go towards right
1196:15 - all the nodes which are towards the right
1196:18 - should have value greater than the nodes value
1196:21 - so this property makes a valid BST
1196:24 - moving ahead
1196:26 - so here let's say we are given with this binary tree
1196:29 - and we need to find whether it's a valid BST or not
1196:32 - so here you can see
1196:34 - if from 6 we look in this direction
1196:36 - the left subtree has 3 nodes
1196:40 - 4, 2 and 8
1196:42 - and we know that the nodes in the left subtree
1196:45 - should be less than the nodes value
1196:48 - 4 is less than 6, 2 is less than 6
1196:51 - but here you can see 8 is not less than 6
1196:54 - so therefore it is not a valid BST
1196:57 - so here you can see
1196:59 - that for node 4
1197:01 - in the left subtree we have only 1 node
1197:04 - and it is less than 4
1197:06 - in the right subtree
1197:08 - we have only 1 node
1197:09 - which is 8 and 8 is greater than 4
1197:12 - so for 4 it is a valid BST node
1197:15 - but if we check all these conditions at this node
1197:18 - 8 is greater than 6
1197:21 - and we know that all the nodes of the left hand side should be
1197:24 - lesser than the nodes value
1197:26 - so therefore it's not a valid BST
1197:28 - till this much point
1197:31 - it was a valid BST
1197:33 - because left nodes were lesser than the nodes value
1197:36 - and the right nodes were greater than the nodes value
1197:39 - from here then it is not a valid BST
1197:41 - because 8 is greater than 6
1197:43 - it should be less than 6
1197:45 - so friends how we can solve this problem is
1197:48 - that when we are at node 8
1197:50 - its parent is 4
1197:52 - and 8 lies towards its right
1197:55 - so 8 is greater than 4
1197:57 - so this part is valid but
1197:59 - but here if you see
1198:01 - the parent of 4 is 6
1198:03 - so therefore 8 should lie
1198:05 - between 4 and 6
1198:07 - so this thing you can consider as a range
1198:10 - that 8 should lie between 4 and 6
1198:12 - but how we can propagate this information
1198:14 - to where it is
1198:16 - with each node
1198:18 - we assign a min or a max value
1198:21 - now this min and max value will tell that
1198:23 - that particular node value
1198:25 - should lie between min and max
1198:28 - so now lets assign these values to
1198:30 - these nodes
1198:32 - so if you see for 6
1198:34 - as it is a root node
1198:36 - the minimum range should be minus infinity
1198:39 - and maximum range should be infinity because
1198:42 - for 6 there are no constraints
1198:44 - so it should be like this
1198:48 - that 6 should be greater than minus infinity
1198:51 - and lesser than infinity
1198:53 - so this is the range for 6
1198:57 - so if we go towards the left
1198:59 - lets say we are on node 4
1199:01 - so what could be the possible range for 4
1199:04 - so for this node having value as 4
1199:07 - to be a valid BST node
1199:09 - it should be less than 6
1199:11 - because 4 if it is lying on the left side
1199:13 - the maximum value
1199:15 - for 4 would be
1199:17 - it should be less than 6
1199:19 - and the minimum value would be
1199:21 - minus infinity only
1199:23 - because 4 can be greater than minus infinity
1199:25 - the only constraint is
1199:27 - for the max value
1199:29 - that it should be less than 6
1199:31 - so for 4
1199:33 - the range would be minus infinity to 6
1199:36 - so this was for this node
1199:38 - lets say if we are going in right
1199:40 - and we encounter 8
1199:42 - so we know that in a valid BST
1199:44 - if we are going towards right
1199:47 - all the nodes value should be greater than nodes value
1199:50 - so 8 should be greater than 6
1199:52 - so it means the minimum value 8 can go is
1199:55 - just greater than 6
1199:57 - and the maximum value it can be like 100
1200:00 - 200
1200:02 - anything
1200:04 - so here when it is going in the right
1200:06 - the min value for 8 would be
1200:08 - 6
1200:10 - and the max can be anything
1200:12 - so friends if you closely observe
1200:14 - if we are going on left
1200:16 - the min remains same
1200:18 - and max changes
1200:20 - because of the BST constraint
1200:22 - and if we are going on the right
1200:24 - max remains the same
1200:26 - but min changes
1200:28 - so we need to keep the range in such a way that
1200:31 - if you go towards left
1200:33 - subtree
1200:35 - min remains same
1200:37 - so here min was same
1200:39 - so we are propagating such a value
1200:41 - that whatever min we have here
1200:43 - we are just transferring it as it is
1200:45 - and max changes to parent value
1200:47 - so we pass 6 here
1200:49 - if you go towards right subtree
1200:51 - here you can see max remains the same
1200:54 - so whatever max was here
1200:55 - it must be same here
1200:57 - but min changes to parent value
1200:59 - so min changes to the parent value which was 6
1201:03 - so these two properties we need to keep in mind
1201:06 - while assigning the ranges
1201:08 - so now let's see the ranges of the rest of the elements
1201:11 - so for 2
1201:13 - we are going towards left
1201:15 - so min remains same
1201:17 - and max changes to parent value
1201:19 - so min remains same which is minus infinity
1201:22 - and max changes to 4
1201:24 - which is true as well because 2 should be less than 4
1201:27 - so this is the range
1201:29 - and let's say if we are going in this direction
1201:32 - which is on the right side
1201:34 - so if we go towards right subtree
1201:36 - max remains same
1201:38 - so this infinity will remain same because this is the max value
1201:41 - and min changes to parent value
1201:43 - so for 9 min will become 8
1201:46 - which makes sense because 9 should be greater than 8
1201:49 - because it lies on the right subtree
1201:51 - so min changes to parent value
1201:54 - so 8 comes here
1201:56 - and infinity remains the same which is our max
1201:59 - so friends one tricky part comes in this direction
1202:02 - let's say we are going in this direction
1202:05 - now if you see we are going in the right side
1202:07 - so if you go towards right subtree
1202:10 - max remains same
1202:12 - so for 4 if you look max is 6
1202:15 - so we know that for 8
1202:17 - the max will remain the same which is 6
1202:20 - and min changes to parent value
1202:25 - so min would be parent value which is 4
1202:30 - so it should be like this
1202:33 - from 4 we are going on the right subtree
1202:36 - and if we are going on the right side
1202:38 - max remains the same
1202:41 - so here max was 6
1202:43 - so we pass 6 as it is
1202:45 - min changes to parent value
1202:47 - and min changes to 4
1202:49 - so here why this range is important
1202:52 - here you can see we have transferred 6
1202:54 - towards 8
1202:56 - so that we can validate whether 8 is lying between 4 and 6 or not
1202:59 - so currently 8
1203:01 - though it is greater than 4
1203:03 - but it is greater than 6 as well
1203:06 - it should lie between 4 and 6
1203:08 - therefore we can directly return
1203:10 - a false value saying that
1203:12 - this is not a valid VST
1203:15 - so we will see the code for this
1203:17 - but to understand we are simply passing down the ranges
1203:21 - and we are checking whether that particular node
1203:24 - is actually lying between these ranges or not
1203:27 - so for any range it should be like this
1203:31 - but here 8 is greater than 4
1203:34 - but this condition is false because 8 is not less than 6
1203:38 - it is greater than 6
1203:40 - so therefore this node makes this binary tree
1203:43 - an invalid binary search tree
1203:45 - and now for 7 we are going towards left
1203:48 - so min remains same
1203:50 - here if you see min is 6
1203:52 - and max changes to parent value
1203:54 - so parent value is 8
1203:56 - so max becomes 8
1203:58 - so for 7 it would be like 6, 8
1204:02 - and here you can see 7 is lying between 6 and 8
1204:05 - so friends now let's go ahead and see the demonstration of the algorithm
1204:09 - that how we can figure out whether a binary tree is a valid VST or not
1204:15 - so here you can see that this is the algorithm
1204:19 - so friends before we start
1204:22 - if you want to master data structures and algorithms
1204:25 - then you can subscribe to my channel and click the bell icon
1204:28 - so that you never miss any update
1204:31 - so here you can see that this is valid method is returning a boolean value
1204:36 - stating that whether this tree node which is being referred by root
1204:41 - whether it is a valid VST or not
1204:43 - and here you can see this is valid method
1204:46 - is getting called here and here recursively
1204:49 - so in order to demonstrate the recursion
1204:52 - we are maintaining a call stack here
1204:54 - where we denote the method call
1204:56 - and we store the state of the elements
1204:59 - like root, min, max, left, right
1205:02 - so when any particular method will relieve the call stack
1205:06 - we store the state of that method
1205:08 - and when it comes back
1205:10 - we start our execution by applying those values back to the variables
1205:15 - and then we proceed ahead
1205:17 - so friends here you can see we discussed about the min and max value
1205:21 - and here you can see that when we are going towards left
1205:25 - here we are calling is valid method again
1205:27 - we are going towards left
1205:29 - so min remains the same
1205:31 - and max changes to root's value which is the parent value
1205:35 - and when we are going towards right
1205:37 - we are calling is valid with root.right
1205:40 - here you can see max remains the same
1205:42 - but min changes to the parent value which is root.well
1205:46 - so these two properties we need to keep in mind
1205:49 - and in this if block
1205:51 - we are basically checking that whether this root
1205:55 - or the node value
1205:57 - whether it is lying between those values or not
1206:00 - so if it is less than equal to min
1206:02 - we know that it should be greater than min
1206:04 - so we can directly return false
1206:07 - or if root.well becomes greater than max
1206:10 - then we can return false because root.well should be less than max
1206:14 - so this root.well should be like this
1206:17 - min
1206:24 - max
1206:26 - and here if root.well is less than or equal to min
1206:29 - we can return false because it should be greater than min
1206:32 - and if root.well is greater than equal to max
1206:35 - we can return false because it should be less than max
1206:38 - and as we are calling this method recursively
1206:41 - we are providing a base case that if root reaches to null let's say here
1206:46 - so this null doesn't change the bst property for 1
1206:50 - so we can directly return true from here
1206:53 - so now let's call is valid method
1206:55 - we pass in the root
1206:57 - so for root we know that it should lie
1207:02 - like this
1207:04 - from minus infinity to infinity
1207:06 - so for an integer value
1207:08 - we are providing here a long
1207:10 - min and long max
1207:12 - so we call is valid method with long's min value
1207:15 - and long's max value
1207:17 - because these two values will be
1207:19 - like minus infinity
1207:21 - and infinity to 5
1207:23 - because 5 is an integer and long
1207:25 - is a data type which is greater than integer
1207:28 - and we are taking long's extreme values
1207:31 - and max value
1207:33 - because the root doesn't have any constraint
1207:35 - so we can provide the minimum and the maximum value of long
1207:40 - so is valid method will be called
1207:42 - and there will be one method on the call stack
1207:45 - root as 5
1207:47 - min as min which is long rod min value
1207:50 - I have written it like this
1207:52 - max would be long rod max value
1207:55 - like this
1207:57 - and left and right would be the boolean values
1207:59 - which we will be receiving from here and here
1208:02 - and we will see that later
1208:04 - moving ahead
1208:06 - root is not equal to null
1208:08 - so this condition comes out to be false
1208:11 - so here you can see 5 is not less than equal to min
1208:14 - and 5 is not greater than equal to max
1208:17 - so here min is the long min value
1208:20 - which is in the negative infinity
1208:22 - so 5 is actually between this
1208:25 - so both the conditions come out to be false
1208:32 - so for 5 this range is valid
1208:40 - and now we are going towards the left of 5
1208:43 - so we are going in this direction now
1208:45 - to node 2
1208:47 - so here you can see this is valid method will be removed from the call stack
1208:50 - and we are leaving this is valid method at line number 8
1208:53 - so first we update line number 8 here
1208:56 - and then we are calling this is valid method
1208:58 - here you can see we are passing
1209:00 - root.left because we want to go in this direction
1209:03 - and when we are going on the left side
1209:05 - we know that min remains the same
1209:07 - and max changes to parent value
1209:10 - so for 2 min will be minus infinity
1209:14 - and max would be the parent's value which is 5
1209:17 - so now we will call this is valid method with the respective values
1209:22 - so there will be one more method on the call stack
1209:25 - like this
1209:27 - we have passed root.left
1209:29 - so root will point to node 2
1209:32 - we know that min remains the same
1209:34 - and max changes to parent's value
1209:37 - which is 5
1209:39 - root is not equal to null
1209:41 - so this condition comes out to be false
1209:44 - so here root.well which is 2
1209:46 - it is not less than equal to min
1209:49 - it is actually greater than min
1209:50 - so this condition is false
1209:52 - root.well which is 2
1209:54 - is it greater than max which is 5
1209:58 - so this condition is also false
1210:00 - therefore overall condition comes out to be false
1210:03 - we signify that
1210:07 - 2 is between minus infinity and 5
1210:11 - so therefore this if block condition comes out to be false
1210:15 - and for 2 also these conditions are true
1210:19 - so now we go towards its left
1210:22 - so we are again leaving this is valid method at line number 8
1210:26 - so we will update line number 8 here
1210:28 - we pass root.left which is 1 now
1210:31 - min remains the same which is minus infinity
1210:34 - but max changes to parent's value
1210:37 - which is the current root's value which is 2
1210:42 - so there will be one more method on the call stack
1210:45 - now root becomes 1
1210:47 - so root will come here
1210:49 - min remains same and max changes to parent's value which is 2
1210:54 - root is not equal to null so this condition comes out to be false
1210:58 - root.well which is 1
1211:04 - so it lies between minus infinity to 2
1211:07 - because max is 2
1211:09 - so this condition is true therefore
1211:11 - here root.well which is 1
1211:13 - it is not equal to minus infinity
1211:16 - and 1 it is not greater than equal to 2
1211:19 - so therefore both this condition comes out to be false
1211:25 - and we reach here
1211:27 - so here if I just put the ranges
1211:29 - for 2 it would be
1211:31 - like this
1211:33 - and for 1 it would be
1211:37 - like this
1211:39 - so till this point everything is fine
1211:41 - now we will go towards its left
1211:43 - so we are going to call is valid method again
1211:46 - and root.left so root.left is null now
1211:49 - min remains same and max changes to 1
1211:53 - so we are leaving this is valid method at line number 8 now
1211:59 - and there will be one more method on the call stack
1212:02 - here now root will be null
1212:05 - so root is pointing to null
1212:07 - so whenever we encounter this null cases
1212:10 - we know that it is our base case so we directly return true
1212:14 - so root is equal to null
1212:16 - so we return true
1212:18 - so now you can see this is valid method will be removed from the call stack
1212:22 - and execution point will reach here
1212:25 - with a value as true
1212:30 - so this got removed from the call stack
1212:33 - execution point reached here
1212:35 - and we had left is valid method at line number 8
1212:39 - so we start from line number 8
1212:41 - and this is valid method return true
1212:44 - so that true will be assigned to left
1212:46 - so left will have true
1212:48 - like this
1212:50 - and when we left is valid method
1212:52 - root was pointing to 1
1212:54 - so root will come back to 1
1212:56 - like this
1212:58 - I will remove this thing
1213:01 - so now you can see if from the left side
1213:04 - we would have got a false value
1213:06 - there is no point in going towards the right
1213:09 - we can directly return false
1213:11 - because if any of the value
1213:13 - states that this is not a valid BST
1213:16 - then overall tree would be not a valid BST
1213:19 - so first we check whether left is true or not
1213:22 - so if left is true then only we go towards the right
1213:25 - so currently left is true
1213:28 - so for this node we are done with the left part
1213:31 - now we go towards its right
1213:33 - so there will be one more method on the call stack
1213:36 - which is valid
1213:38 - we pass root.right
1213:40 - and here you can see one changes
1213:42 - towards the right
1213:44 - max remains the same
1213:46 - but min changes to root's value
1213:48 - so here first we will update the line number here
1213:50 - because we are leaving this method
1213:52 - so 10 comes here
1213:54 - now when we will call is valid method
1213:56 - max remains the same
1213:58 - it means 2 remains the same
1214:00 - and min changes to parent's value
1214:03 - so currently parent value is 1
1214:05 - so we will see how it looks
1214:09 - there is a is valid method on the call stack
1214:11 - with root will be now null
1214:13 - because we have went towards its right now
1214:16 - by calling it with root.right
1214:18 - here you can see when we go towards right
1214:21 - max remains the same
1214:23 - these values are same
1214:25 - and min changes to parent's value
1214:28 - so if we move ahead
1214:30 - root is pointing to null
1214:32 - so this is our base case
1214:34 - so we directly return true from here
1214:36 - so this method will be removed from the call stack
1214:41 - and execution point will reach here
1214:44 - and it starts the execution at line number 10
1214:47 - with root as 1
1214:49 - so this is valid method return the value of true
1214:53 - so we can assign it to right now
1214:55 - like this
1214:57 - and when we had left is valid method
1214:59 - root was at 1
1215:01 - so root comes back to 1
1215:03 - so friends here you can see
1215:04 - that for this one node
1215:07 - from left we got true
1215:09 - and from right also we got true
1215:11 - it means this particular node is a valid vst node
1215:16 - so we can directly return the value of right
1215:19 - because left is we have checked it is already true
1215:22 - so now this is valid method will be removed from the call stack
1215:26 - and execution point will reach here
1215:29 - we will start from line number 8
1215:31 - like this
1215:33 - and this is valid method return the value of true
1215:36 - and this method we received the value true
1215:39 - from here
1215:41 - so that will be assigned to the left
1215:43 - so left will become true
1215:45 - and in this is valid method
1215:47 - root is at node 2
1215:49 - so root will come back to node 2
1215:54 - we check whether the left side of true returned true or not
1215:58 - so which is true
1216:00 - so this condition is true
1216:02 - so therefore node 2 decides to go towards its right
1216:06 - to do the same steps
1216:08 - so here now we will again call is valid method
1216:10 - we pass root.right
1216:12 - so root.right is 7
1216:14 - when we are going to write max remains the same
1216:17 - which is 5
1216:19 - but min changes to root value
1216:21 - so currently root value is 2
1216:23 - so therefore first we update the line number here
1216:26 - because we are leaving this is valid method
1216:29 - at line number 10
1216:30 - so 10 comes here
1216:32 - now is valid method will be executed again
1216:36 - root will become 7
1216:38 - because we are going towards the right
1216:41 - max remains the same
1216:43 - and min changes to roots value because we are going to the right
1216:50 - root is not equal to null
1216:52 - so this condition comes out to be false
1216:54 - root.well is not less than min
1216:57 - so here you can see root.well is 7
1217:00 - and min is 2
1217:03 - so 7 is greater than 2
1217:05 - and 7 should be lesser than 5
1217:07 - because 5 is max
1217:09 - so this condition is false
1217:11 - because 7 is greater than 5
1217:13 - so here you can see root.well is 7
1217:16 - min is 2
1217:18 - so here 7 is not less than equal to 2
1217:21 - so this condition is false
1217:25 - but here you can see 7
1217:27 - should be greater than equal to max which is 5
1217:30 - so this condition became true
1217:33 - so therefore this overall condition came out to be true
1217:36 - and we know that 7 is not in this range
1217:39 - from 2 to 5
1217:41 - and this condition came out to be true because root.well which is 7
1217:45 - we are checking whether it is greater than 5 or not
1217:48 - so it has over passed the max value
1217:50 - which shouldn't be the case
1217:52 - so we directly return false now
1217:54 - because 7 should be less than 5
1217:56 - but here we found that 7 is greater than max
1217:58 - so this condition came out to be true
1218:01 - so we return false
1218:03 - so this method will be removed from the call stack
1218:05 - by returning a false value
1218:09 - execution point reaches here
1218:11 - we start from line number 10 here
1218:14 - and this method returned a false value
1218:17 - so to write we assign false like this
1218:20 - and when we left this is valid method
1218:23 - root was at 2
1218:25 - so root will come back to 2
1218:26 - like this
1218:28 - so from here we received true
1218:30 - and from here we received false
1218:32 - so when we will proceed ahead
1218:34 - from left we received true
1218:36 - and from right we are receiving false
1218:38 - so therefore if any of the value came out to be false
1218:42 - we directly return false stating that
1218:44 - this binary tree is not a valid BST
1218:47 - so we return false
1218:49 - so this is valid method
1218:51 - will be removed from the call stack
1218:53 - by returning false
1218:56 - and execution point will reach here
1218:58 - we had left at line number 8 here
1219:01 - and the previous is valid method returned a false
1219:05 - so we return false to root 5
1219:08 - so to the left we assign false
1219:10 - and root will come back to 5
1219:12 - from here
1219:14 - so we first check whether from left only we received false or not
1219:18 - so for node 5
1219:20 - the left subtree returned a false value
1219:24 - so it should not go towards its right
1219:26 - it should directly return false
1219:29 - because left we received false
1219:31 - so we directly return false
1219:34 - stating that this binary tree is not a valid BST
1219:38 - so when we will return false
1219:40 - this method will also be removed from the call stack
1219:43 - like this
1219:45 - so our algorithm will end
1219:47 - and we simply return false value
1219:49 - so now let's say instead of 7 we had 3
1219:52 - like this and root was here
1219:54 - so this was the previous state which we already discussed
1219:58 - let's say when we are on this part
1220:00 - root is at 3
1220:02 - the min value should be 2
1220:04 - and the max value should be 5
1220:06 - so for 7 we had the same conditions
1220:09 - root is not equal to null
1220:12 - so we check whether root.well which is 3
1220:16 - is it less than min
1220:18 - so this will be false because 3 is greater than min
1220:21 - we check whether root.well is it greater than min
1220:24 - or max
1220:26 - so this condition is also false because 3 is not greater than max
1220:29 - which is 5
1220:31 - previous to that here it was 7
1220:33 - so therefore we had returned false
1220:36 - but now we have 3
1220:38 - and 3 lies between 2 and 5
1220:41 - so therefore both the conditions came out to be false
1220:45 - so why I am demonstrating it with 3 is
1220:48 - just to complete the algorithm for a positive BST
1220:51 - so this tree is actually a valid BST
1220:54 - so now we go towards the left of this root which is 3
1220:58 - and this is our base case
1221:00 - so we will go quickly over this
1221:02 - we first update the line number here
1221:05 - because we are leaving this is valid method
1221:10 - root will come to null
1221:12 - and min max will be 2 and 3
1221:16 - root is equal to null so we return true
1221:20 - so this method will return true
1221:22 - and it will be removed from the call stack
1221:25 - execution point will reach here
1221:28 - we start from line number 8
1221:30 - this method return true
1221:32 - so to left we assign true
1221:36 - and root came back to 3
1221:40 - left is true
1221:42 - so we go towards its right
1221:45 - which is also our base case
1221:47 - so we first update the line number here 10
1221:49 - and this valid method will be on call stack
1221:54 - with new root as null
1221:56 - because we are going towards the right
1221:59 - so root comes here
1222:02 - root is equal to null
1222:04 - so we return true directly
1222:07 - we start from line number 10
1222:10 - and this is valid method return a true value
1222:13 - so true comes here
1222:15 - and root goes back to 3
1222:16 - and root goes back to 3
1222:20 - and whatever the value right has
1222:23 - we directly return that value
1222:25 - because if we are going towards right
1222:27 - it means left is already true
1222:29 - so if right would have been false
1222:31 - we would have written false
1222:33 - if right would have been true
1222:35 - we are returning true
1222:37 - so this is valid method will be removed from the call stack
1222:39 - and will return true
1222:43 - so we reach here
1222:44 - this is valid method from line number 10 here
1222:47 - and here this is valid method return true
1222:50 - so we update true here
1222:52 - and at that moment root was at 2
1222:54 - so root comes back to 2
1222:56 - so here from this null
1222:58 - we got true
1223:00 - from here we got true
1223:02 - so both came out to be true
1223:04 - so we returned a true value
1223:06 - which we stored here
1223:08 - so now this is valid method
1223:10 - will be removed from the call stack
1223:12 - returning the value of right which is true
1223:14 - will return true
1223:17 - and this is valid method will be executed from line number 8
1223:21 - because 5 at call is valid and passing in root.left
1223:24 - which was this
1223:26 - and this is valid method return true
1223:28 - so we assign true to left
1223:30 - root comes back to 5
1223:39 - left value is true
1223:41 - so for this node
1223:42 - it sees that
1223:44 - its left sub tree
1223:46 - complete left sub tree return
1223:48 - value is true
1223:50 - so now it checks by going towards the right
1223:52 - so it will call is valid again
1223:54 - passing in root.right
1223:56 - when we are going to the right
1223:58 - max remains the same
1224:00 - and min changes to parents value
1224:02 - which is root.well
1224:04 - so here when we go towards the right
1224:06 - we reach 6
1224:08 - so for 6
1224:10 - max remains the same which would be
1224:12 - long.max value
1224:14 - but min will change to the
1224:16 - parents value which is root value
1224:18 - which is 5
1224:20 - which makes sense because 6 should be greater than 5
1224:22 - and it can be lesser than any of the max value
1224:25 - so max remains the same
1224:27 - and min changes to root.well
1224:29 - so first we update line number
1224:31 - here which is 10
1224:36 - and we will go quickly over this 3 nodes now
1224:39 - so root comes here
1224:42 - root is not equal to null
1224:44 - 6 is between 5
1224:46 - and max
1224:49 - so both the condition comes out to be false
1224:53 - now we go to the left of 6
1224:56 - by calling is valid method
1224:58 - passing in root.left
1225:00 - when we are going to the left
1225:02 - min remains the same
1225:03 - which is 5
1225:05 - but max changes to root.well
1225:07 - so it should be 6 now
1225:11 - so there will be one more method on the call stack
1225:13 - with root as null
1225:15 - we know that we have went to the left
1225:17 - so min remains the same
1225:19 - and max changes to
1225:21 - root's value which is 6
1225:23 - root is equal to null
1225:25 - so we return true
1225:27 - and max changes to
1225:29 - root value which is 6
1225:31 - root is equal to null
1225:34 - directly
1225:38 - we start from line number 8
1225:40 - so left will receive true
1225:44 - root comes back to 6
1225:47 - left is true
1225:49 - so now we go to the right of 6
1225:52 - we update line number here
1225:54 - which is 10
1225:59 - there will be one more is valid method on the call stack
1226:02 - with root as null
1226:04 - because we have went to root.right now
1226:07 - and as we are going to the right
1226:09 - we know that max remains the same
1226:12 - and min becomes the root's value
1226:14 - like this
1226:18 - so root is equal to null
1226:20 - so it is our base case
1226:22 - so we return true directly
1226:26 - execution point will reach here
1226:28 - it will start from line number 10
1226:30 - so this method returned a value true
1226:33 - we stored in the right
1226:35 - and root came back to 6
1226:39 - and now we can directly return whatever the value right will hold
1226:43 - so currently it is true
1226:45 - so we will pass true to
1226:47 - this is valid method
1226:49 - and this method will be removed from the call stack
1226:52 - so now this is valid method
1226:54 - will be starting from 10
1226:56 - because we had left at line number 10
1226:59 - and this method returned a value of true
1227:03 - so right will have true
1227:05 - root will come back to 5
1227:08 - and then here you can see
1227:10 - from the left we received true
1227:14 - from the right also we received true
1227:17 - like this
1227:19 - so for 5 as it is a root of this binary tree
1227:23 - it sees that from its left side it received true
1227:27 - and from the right it received true
1227:29 - and 5 being the root node
1227:31 - it is also in the boundaries of
1227:33 - long dot min value and long dot max value
1227:36 - so therefore it directly returns true
1227:38 - which is stored in the right
1227:41 - so this method will be removed from the call stack
1227:44 - stating that this is a valid BST
1227:47 - so friends I hope you must have liked this video
1227:50 - in case if you are new to my channel
1227:52 - then please subscribe to my channel
1227:54 - and click the bell icon
1227:56 - so that you never miss any update
1227:57 - thanks have a nice day
1228:01 - hello everyone
1228:03 - welcome to my new data structures and algorithms in java
1228:06 - tutorial series video
1228:10 - in this tutorial we will discuss
1228:12 - an interview coding problem
1228:14 - search in a row and column wise sorted matrix
1228:20 - so friends in an interview we are given a problem
1228:23 - that given a row and column wise nxn sorted matrix
1228:27 - write a program to search a key in a given matrix
1228:31 - so what do we mean by row and column wise sorted matrix
1228:35 - so here you can see
1228:37 - we are given a 4x4 matrix
1228:40 - so by 4x4 matrix we mean that it has 4 rows
1228:44 - and 4 columns
1228:47 - and here you can see that each row
1228:50 - is sorted
1228:52 - and each column
1228:54 - is sorted
1228:56 - so for an example the row at 0th index
1228:59 - you can see the value is 10
1229:02 - 20 30 40
1229:04 - and the last row
1229:06 - we have value as 32 33 39 51
1229:10 - and all these rows
1229:12 - are sorted in ascending order
1229:16 - and similarly if you see the columns
1229:18 - then those are also sorted
1229:20 - so for example
1229:22 - 0th index column has value as 10
1229:25 - 27 32
1229:27 - and similarly if you take 2nd index column
1229:30 - the values are 30 35 37 39
1229:33 - so this is a matrix
1229:35 - in which each row is sorted
1229:37 - and each column is sorted in ascending order
1229:40 - and we are given a value
1229:42 - and we need to write a program to search that value
1229:45 - inside this matrix
1229:49 - so friends lets suppose we are given this 4x4 matrix
1229:52 - which is sorted row wise and column wise
1229:55 - so here as the matrix is 4x4
1230:02 - the value of n is 4
1230:04 - and lets suppose we want to search for a key as 32
1230:07 - now this key is present into the matrix
1230:10 - and we want to write a program which could search this key
1230:13 - into this sorted matrix
1230:15 - so friends here you can see the algorithm for it
1230:19 - now lets see the working of this algorithm step by step
1230:22 - friends there is an inefficient solution
1230:27 - that is using 2 for loops
1230:30 - and what we do is we compare 32 with each and every value
1230:34 - of this matrix
1230:36 - and see whether the element is present in the matrix or not
1230:40 - so friends this is an inefficient approach because
1230:43 - because the time complexity of this solution is O of n square
1230:48 - and here as we are given this matrix is sorted
1230:50 - row wise and column wise we can use that property
1230:54 - to write an efficient code
1230:57 - so lets see a demo of this algorithm
1231:02 - so here we are simply calling this search method by passing in the 4x4 matrix
1231:07 - the value of n and the key which we want to search
1231:11 - so friends here we know that this matrix is sorted row wise and column wise
1231:16 - therefore we start our searching from the top right corner of the matrix
1231:21 - lets say we start from 0,3
1231:25 - having a value of 40
1231:27 - so what we do is
1231:29 - we compare 32 with 40
1231:31 - and see that whether 32 is equal to 40 or not
1231:35 - so if it is equal to 40 we simply print that we have found our element at 0,3
1231:40 - and here as 32 is less than 40
1231:43 - so the idea behind this algorithm is
1231:46 - if we go to the left of 40
1231:49 - we will find all the numbers lesser than 40
1231:52 - and if we go below 40 then we will find the numbers greater than 40
1231:57 - so friends as this is a row wise and column wise sorted matrix
1232:01 - so for each and every element in this matrix this property holds true
1232:05 - that if we go a step left we get the number lesser than the current number
1232:11 - and if we go one step below then we will get a number greater than the current number
1232:16 - so lets suppose if we are at index 2,1
1232:19 - so value is 29
1232:22 - if we go one step left we will get the value lesser than 29
1232:26 - and if we go one step down we will get the value greater than 29
1232:31 - and this property is true for each and every value in the matrix
1232:36 - so we will use this idea and search for the particular key in the matrix
1232:39 - so in step 1 we will create an integer value i which will be pointing to 0
1232:48 - so this value i will be pointing towards a particular row of a matrix at a particular index
1232:56 - so currently it is referring to 0th index row moving ahead
1233:01 - and then we will create one more integer variable by name j
1233:05 - and we will assign the value of n-1 which is nothing but 4-1
1233:13 - so friends j will point to the columns index
1233:17 - so friends we will start our search from the top right corner of the matrix
1233:21 - so therefore we have initialized i to 0 and j to 3
1233:25 - and we will start our search from the index 0,3 having a value of 40
1233:29 - so friends as we want to search for value 32 inside this matrix we are providing a while loop
1233:40 - and in this value we are providing the boundary conditions of the matrix
1233:44 - so that value of i and j do not cross over the matrix boundary
1233:48 - so as i started from value 0 we will iterate it to a value lesser than n
1233:54 - and we are also providing a boundary condition for j that it has started from 3
1234:00 - it should go till index 0
1234:03 - so currently you see i is less than 4 and j is greater than 0
1234:11 - so the condition in while block comes out to be true
1234:14 - so here we have provided a vlog and inside this vlog we are checking that value at matrix i, j is equal to x or not
1234:26 - so value at i, j which is nothing but 40 we are checking whether it is equal to 32 or not
1234:34 - so the condition in vlog comes out to be false
1234:37 - and then we are again providing an vlog and we are simply checking that whether value at i, j is greater than x or not
1234:49 - so here you can see 40 is greater than 32
1234:53 - therefore the condition in vlog comes out to be true
1235:00 - so friends as this matrix is sorted row wise and column wise
1235:04 - so friends when we compare 40 with 32 we know that 40 is greater than 32
1235:09 - therefore we also know that 32 must be lying one step left to 40
1235:13 - so we are simply decrementing the value of j
1235:17 - so it could become something like this
1235:21 - the value of j becomes 2
1235:24 - moving ahead
1235:25 - then we are again checking that whether i is less than n and j is greater than equal to 0 or not
1235:35 - so here you can see i is less than n because the value of i is 0
1235:40 - so it is less than 4
1235:42 - and j is greater than equal to 0 because value of j is 2 and 2 is greater than 0
1235:49 - so the condition in while block comes out to be true
1235:53 - we will again compare the value at i, j index with x
1235:59 - so here you can see the value at 0, 2 is 30
1236:04 - so we will simply compare the value of 30 with 32
1236:08 - so the matrix value at 0, 2 which is 30 is not equal to 32
1236:16 - therefore the condition in if block comes out to be false
1236:19 - and then we will simply check that whether value at i, j is greater than x or not
1236:26 - so here you can see the value at i, j is less than x because 30 is less than 32
1236:35 - therefore the condition in if block comes out to be false
1236:38 - and else part will be executed
1236:40 - so for 32 is greater than 30 therefore it must be lying somewhere below 30
1236:50 - so we simply increment i by 1 to go one step down
1236:55 - so value of i is 0
1236:58 - so now it will become 1
1237:00 - moving ahead
1237:01 - we again check whether i is less than n and j is greater than 0 or not
1237:11 - so i is holding value 1 and it is less than 4
1237:15 - and j is holding value 2 which is greater than 0
1237:19 - therefore condition in while block comes out to be true
1237:25 - in the first if block we check whether the value at matrix i, j is equal to x or not
1237:32 - so here the value at i, j which is nothing but 35 is not equal to x which is 32
1237:42 - therefore the condition in if block comes out to be false
1237:47 - we then check that whether value at matrix i, j is greater than x or not
1237:52 - so here you can see the value at i, j which is 35 is greater than 32
1237:59 - therefore the condition in if block comes out to be true
1238:04 - and as 35 is greater than 32 we know that 32 must be lying somewhere to the left of 35
1238:12 - therefore we simply go one step left to 35 which is nothing but decrementing the j by 1
1238:20 - so it would look something like this
1238:23 - that value of j becomes 1
1238:25 - moving ahead
1238:30 - now again we check in the while block whether value of i is less than n and j is greater than or equal to 0 or not
1238:38 - so here you can see the value of i which is 1 is less than 4
1238:43 - and value of j which is 1 is greater than 0
1238:47 - therefore the condition in while block comes out to be true
1238:54 - we again check in the if block that whether value at i, j is equal to x or not
1239:00 - so here you can see value at i, j which is 25
1239:05 - so 25 is not equal to 32
1239:07 - therefore the condition in if block comes out to be false
1239:12 - and then we will again check that whether the value at i, j is greater than x or not
1239:18 - so currently 25 is not greater than x
1239:21 - so the condition in if block comes out to be false
1239:26 - and else part will be executed
1239:30 - so friends as 32 is greater than 25
1239:33 - we know that this value might lie somewhere below 25
1239:39 - so we will simply move one step down by decrementing the value of i
1239:46 - so i becomes 2
1239:47 - so i becomes 2
1239:49 - moving ahead
1239:53 - we will again check whether i is less than n
1239:56 - and j is greater than equal to 0 or not
1239:59 - so here you can see 2 is less than 4
1240:01 - and 1 is greater than 0
1240:03 - therefore the condition in while block comes out to be true
1240:10 - we check the value of matrix at i, j is equal to x or not
1240:14 - so here you can see
1240:16 - the value at i, j which is nothing but 29
1240:19 - is not equal to 32
1240:21 - therefore the condition in if block comes out to be false
1240:26 - and then we simply check that whether
1240:28 - value at matrix i, j is greater than x or not
1240:32 - so here you can see value at i, j which is 29
1240:36 - is less than x which is 32
1240:39 - therefore the condition in if block comes out to be false
1240:42 - and else part will be executed
1240:45 - so friends we will go one step down because 32 is greater than 29
1240:50 - so here as this matrix is row and column is sorted matrix
1240:54 - we know that 32 might lie below 29
1240:58 - so we simply go one step down
1241:00 - by incrementing the value of i
1241:04 - so i becomes 3
1241:07 - moving ahead
1241:11 - in the while loop we will again check whether i is less than n or not
1241:15 - so here you can see
1241:17 - value of i is 3 and it is less than 4
1241:21 - and we also check whether j is greater than equal to 0 or not
1241:24 - so here you can see j is greater than 0
1241:28 - so the condition in while block comes out to be true
1241:34 - then in the if block we check whether value at matrix i, j is equal to x or not
1241:39 - so the value at i, j is nothing but 33
1241:44 - and we know that it is not equal to 32
1241:47 - therefore the condition in if block comes out to be false
1241:53 - then we simply check that whether value at matrix i, j is greater than x or not
1241:58 - so here you can see
1242:00 - the value at i, j which is 33 is greater than 32
1242:04 - therefore condition in if block comes out to be true
1242:06 - now as this value 33 is greater than 32
1242:12 - we know that value must be lying to the left of 33
1242:17 - so we simply go one step left by decrementing the value of j
1242:25 - so j becomes 0
1242:31 - and then again in while loop we check whether i is less than n
1242:34 - and j is greater than or equal to 0
1242:37 - so here you can see value of i is 3 and it is less than 4
1242:42 - and value of j is 0
1242:44 - which is equal to 0
1242:46 - therefore condition in while block comes out to be true
1242:51 - now we simply check that whether value at matrix i, j is equal to x or not
1242:55 - so here you can see the value of matrix at 3, 0
1242:59 - which is 32
1243:01 - is actually equal to 32
1243:05 - therefore condition in if block comes out to be true
1243:10 - so friends here we know that we have found our value
1243:15 - so therefore we simply print on the console that x is found at 3, 0
1243:21 - so in the console we are simply printing that x is found at 3, 0
1243:27 - and then we will simply return from this method
1243:31 - so friends in this tutorial we saw the demonstration of the algorithm
1243:35 - now let's go to eclipse and see the working of this code
1243:41 - hello everyone
1243:44 - so friends in our previous tutorial we saw the demonstration of the algorithm
1243:49 - to search for a value in row and column by sorted matrix
1243:54 - now in this tutorial we will actually write that code and test its working
1244:00 - so here i have created one class by name sorted matrix
1244:04 - and inside this class i have created one main method
1244:08 - and here i have initialized the matrix which we discussed in our previous tutorial
1244:12 - which is row and column by sorted matrix
1244:15 - now let's write a program to search for a key in this row and column by sorted matrix
1244:23 - so i will give the name of this method as public void search
1244:31 - and this method takes in 3 arguments
1244:38 - one is the matrix
1244:42 - one is the value of n
1244:45 - as it is a 4x4 matrix therefore value of n will be 4
1244:50 - and one will be the value which we want to search
1244:53 - we are denoting it by x
1244:57 - so in order to search in a row and column by sorted matrix
1245:00 - we are using 2 pointers i, j
1245:03 - so we are initializing i to 0
1245:09 - and j to n-1
1245:16 - because we are simply starting our search from the top right corner of the matrix
1245:23 - so here value of i will be iterating over the indexes of the rows
1245:27 - and value of j will be iterating over the indexes of the columns
1245:32 - moving ahead
1245:34 - we will provide a while loop
1245:39 - and inside this while loop
1245:42 - we have to iterate over the matrix using the values of i and j
1245:46 - therefore we are simply providing the boundary condition
1245:49 - so that i and j do not cross over the matrix boundary
1245:52 - so here i should be less than n
1245:57 - and j should be greater than equal to 0
1246:02 - which we actually discussed in our previous tutorial
1246:06 - in the first step we are providing an if block
1246:11 - and inside this if block we are simply checking
1246:15 - that value of matrix at i, j
1246:22 - is equal to x or not
1246:24 - so if the value at matrix i, j is equal to x
1246:28 - then we know that we have found our element
1246:31 - so we simply print
1246:35 - x found at
1246:39 - i
1246:43 - comma j
1246:46 - and then we will simply return from this method
1246:49 - because we have found our element
1246:51 - and if the value at i, j is not equal to x
1246:55 - then we simply check that whether that value is greater than x or less than x
1247:00 - so matrix i
1247:05 - is greater than x or not
1247:09 - so here if the value at matrix i, j is greater than x
1247:13 - and as it is a row and column with sorted matrix
1247:16 - we have to go one step left
1247:17 - so in order to go one step left
1247:20 - we simply decrement the value of j by 1
1247:24 - and if the value at matrix i, j is less than x
1247:28 - which is the else part
1247:31 - then we know that we have to traverse one step down
1247:35 - because value of x will be lying somewhere down
1247:38 - to the value of matrix i, j
1247:40 - so we will simply increment the value of i by 1
1247:43 - also friend if you don't find any value
1247:47 - then after this while block
1247:49 - we will simply print
1247:54 - value not found
1247:56 - so friend this is the code
1247:58 - to search a value in a row and column with sorted matrix
1248:01 - now let's test it working
1248:04 - so in the main method we have already created a matrix
1248:08 - which is row and column with sorted matrix
1248:10 - so first we will create the instance of
1248:13 - the sorted matrix class
1248:24 - and then we will simply call the search method
1248:27 - by passing in the matrix
1248:30 - the value of n which is matrix.length
1248:35 - and let's say we want to search for a value 32
1248:40 - which we discussed in our previous tutorial
1248:42 - so if i run the code now
1248:47 - so here you can see
1248:49 - that it prints that x is found at 3, 0
1248:53 - so we have simply printed the indices of the matrix
1248:55 - where we have found this value
1248:58 - now let's suppose
1249:00 - if we search for a value which is not present in the matrix
1249:04 - say we give value is 100
1249:06 - and if i run the code now
1249:10 - so you can see in the second edit printed
1249:13 - that value not found
1249:18 - so friend in this tutorial we actually coded an algorithm
1249:21 - to search for a key in a row and column with sorted matrix
1249:26 - so friend i hope you like this video
1249:28 - thanks have a nice day
1249:31 - hello everyone
1249:33 - so in this video we will be discussing
1249:35 - a famous interview problem
1249:36 - print a given matrix in spiral form
1249:41 - so here you can see
1249:43 - that we are given with a matrix
1249:45 - now let's say we are given with an integer matrix
1249:48 - having the values as 1,2,3,4
1249:50 - and so on
1249:52 - now we need to print this matrix in spiral form
1249:55 - now what is the spiral form?
1249:58 - so the spiral form is something like this
1250:00 - so here you can see that it basically
1250:03 - traverse in clockwise direction
1250:06 - and it goes something like this
1250:09 - so we need to print this matrix in this form
1250:13 - so first we need to print
1250:15 - it from left to right
1250:17 - then from top to bottom
1250:19 - then from right to left
1250:21 - and then from bottom to top
1250:23 - and once we are done with the outer matrix
1250:25 - here you can see the spiral curve
1250:28 - goes inside
1250:30 - so then we will go to the inner matrix
1250:32 - so here we will first reverse it
1250:34 - like this
1250:36 - left to right
1250:38 - then top to bottom
1250:40 - then right to left
1250:42 - and then from bottom to top
1250:44 - and after traversing it like this
1250:46 - we will traverse the inner matrix
1250:49 - like this
1250:51 - and we keep on doing this till
1250:54 - there are no more elements left to be traversed
1250:57 - and this matrix can be of any length
1250:59 - and can have any inner boxes
1251:01 - so if we print this matrix
1251:03 - it would look something like this
1251:05 - 1 2 3 4
1251:08 - 8 12 16
1251:11 - 15 14 13
1251:13 - 9 5
1251:15 - 6 7
1251:17 - 11
1251:19 - and 10
1251:21 - now lets see the demonstration of this algorithm step by step
1251:25 - now here you can see this is the algorithm to traverse the matrix in spiral form
1251:29 - so if you see this algorithm looks quite complex
1251:32 - once you get an idea
1251:34 - it becomes very easy
1251:36 - so before we start
1251:38 - in case if you are new to my channel
1251:40 - then please subscribe to my channel
1251:42 - and click the bell icon
1251:44 - so that you never miss any update
1251:46 - so here
1251:48 - lets say we call the spiral print method
1251:51 - we pass in the matrix which we saw in our previous slide
1251:54 - so that matrix was 4 x 4
1251:57 - it has 4 rows and 4 columns
1252:00 - so we are passing that information as well
1252:03 - so here it would look something like this
1252:06 - that we have this 4 x 4 matrix
1252:12 - having row index from 0 to 3
1252:15 - and column index from 0 to 3
1252:18 - so this value r is 4 is denoting that it is
1252:22 - 4 rows
1252:24 - and c equal to 4 is denoting its 4 columns
1252:27 - so for timing you can think
1252:29 - its something like this here
1252:30 - that its in outer boundaries of this matrix
1252:34 - and it is basically denoting
1252:36 - the number of rows and number of columns
1252:39 - but here these numbers are denoting the indexes
1252:42 - from 0 to 3
1252:44 - moving ahead
1252:46 - now we will create 3 pointers
1252:49 - i, k and l
1252:51 - so here i
1252:53 - if you see it will be our normal iterator
1252:56 - which will help us in printing the matrix in spiral form
1253:00 - so this is the generic iterator
1253:03 - k will basically help us in traversing the rows
1253:08 - and l will help us in traversing the columns
1253:11 - so we will see its significance later
1253:14 - so for timing we are starting from 0th row
1253:18 - and 0th column
1253:20 - so therefore these 2 variables will help us in traversing rows and columns from 0
1253:25 - so k is 0 and l is 0
1253:31 - so this 0 is basically the index
1253:34 - so k is pointing to 0th row
1253:36 - so this is the row
1253:38 - and l is pointing to 0th column
1253:41 - so this is the column
1253:43 - so now we will see how these 2 variables help us in traversing the matrix in spiral form
1253:51 - so friends in our previous slide we saw
1253:53 - that how we can traverse the matrix in spiral form
1253:58 - first we need to traverse the outer matrix
1254:01 - then we need to traverse the inner matrix
1254:03 - and we need to go on like this
1254:05 - till there are no more elements left to be traversed
1254:07 - we provide a while loop
1254:09 - and these are the boundary checks that k should be less than r
1254:13 - because k could travel from 0 to 3
1254:16 - so therefore it should be less than r
1254:18 - which is 4
1254:20 - and l should be less than c
1254:22 - so l should be less than c because
1254:25 - this is the boundary of the column
1254:28 - and this is the boundary of row
1254:30 - once this condition comes out to be true
1254:32 - you can see
1254:36 - that we have 1 for loop
1254:38 - 2nd for loop
1254:41 - 3rd for loop
1254:44 - and 4th for loop
1254:46 - now why this 4 for loops
1254:48 - so it's very simple
1254:50 - the 1st for loop signifies that we need to go from left to right
1254:56 - the 2nd for loop will help us in traversing top to bottom
1255:02 - the 3rd for loop will help us in traversing from right to left
1255:08 - and the last for loop will help us in traversing from bottom to top
1255:15 - so we need to print the matrix in spiral form
1255:17 - so it's like going from left to right
1255:20 - top to bottom
1255:22 - right to left
1255:24 - and bottom to top
1255:26 - so this will help us in traversing the outer matrix
1255:29 - so this while loop will help us go to the inner matrix
1255:33 - and perform these steps again
1255:35 - and it will go on till these conditions are satisfied
1255:40 - and once these conditions are not satisfied
1255:43 - we know that we have traversed the matrix in spiral form
1255:46 - so let's see the demonstration of these 4 for loops along with the outer while loop
1255:53 - so initially both these conditions are true
1255:56 - now our task is to print 1st row
1256:00 - so here you can see this is the 1st row we need to print
1256:04 - so if you see this 1st row is being referred by or pointed by k
1256:10 - and once we print 1, 2, 3, 4
1256:14 - we are going to this direction
1256:16 - so when we go to this direction
1256:19 - you can see the row remains same
1256:22 - and what changes is the column
1256:25 - so if you want to print 1 we need 0, 0
1256:29 - if you want to print 2, 0, 1
1256:32 - 0, 2 for 3
1256:34 - 0, 3 for 4
1256:36 - so here you can see the column is actually changing
1256:38 - so when we go this side
1256:40 - column changes
1256:42 - so this for loop you can see
1256:45 - as we want to print from the 1st element or from the 1st column
1256:50 - to the last column
1256:52 - with row remains the same
1256:54 - so the column varies
1256:56 - and this column will vary from
1256:58 - l equal to 0
1257:00 - to the last value of the column
1257:02 - so here l will help us in starting that from which column we need to print
1257:06 - so currently this matrix we are printing is from the start
1257:09 - so this is the outer matrix
1257:12 - but once we traverse this matrix once
1257:15 - we need to go to the inner matrix
1257:18 - so that time this l will help us to start from 6
1257:23 - and we need to perform this logic again
1257:26 - so here this l help us in keeping the traverse
1257:30 - of which column is actually printed
1257:33 - and this k will help us in traversing that which row is actually printed
1257:36 - so we will see their advantage later
1257:39 - so here you can see that we are starting from l
1257:42 - which is 0
1257:44 - and will go till i is less than c
1257:47 - so i is less than c we need to go till this point
1257:50 - so here now it's very simple
1257:54 - that i is starting from 0
1257:56 - from here
1257:58 - and we need to print from left to right
1258:00 - keeping the row constant
1258:03 - and varying the column based on the i
1258:06 - so after providing the valid range for i
1258:11 - here you can see that we are keeping the k constant
1258:15 - because row is the same
1258:17 - what varies is the i
1258:19 - so we will quickly go over this for loop
1258:22 - and will print the first 4 elements
1258:24 - because i is travelling from 0 to less than c
1258:28 - so currently c is 4
1258:30 - so i will go from 0 to 3
1258:32 - so let's see how
1258:34 - so 1 will be printed
1258:37 - i will get incremented
1258:45 - 2 will be printed
1258:49 - i will get incremented
1258:55 - 3 will be printed
1258:59 - i becomes 3
1259:04 - and then 4 will be printed
1259:10 - so now here you can see when we will do i plus plus
1259:14 - i will become 4
1259:16 - so 4 is not less than 4
1259:19 - which is the value of c
1259:21 - here you can see
1259:23 - so it means we are done with printing the first part
1259:26 - going from left to right
1259:31 - so this thing is done
1259:33 - we have printed 1 2 3 4
1259:36 - now here you can see
1259:38 - that as this row is already printed
1259:41 - we don't have to print this row again
1259:43 - we need to go to this side
1259:45 - from 6 to 7
1259:47 - so what we need to do is
1259:49 - we need to now increment k by 1 position
1259:51 - because we are done with this row
1259:54 - so k becomes 1
1259:57 - and now it signifies that
1259:59 - this is our range to print
1260:01 - because we have already printed
1260:03 - the first row
1260:06 - and here you can see
1260:08 - that this k also help us in starting of the top to bottom
1260:12 - it won't print 4 again because
1260:14 - here you can see
1260:16 - that when we go top to bottom
1260:18 - we are starting from k
1260:20 - so i will start from this
1260:22 - k equals to 1
1260:24 - and here you can see
1260:26 - that when we go from top to bottom
1260:28 - you can see
1260:30 - that we need to print 8 12 16
1260:33 - so here you can see the column remains the same now
1260:36 - what varies is the row
1260:38 - so here i will simply write r
1260:41 - so basically you need to think that
1260:43 - if we are going from left to right
1260:45 - column varies
1260:47 - if we are going from top to bottom
1260:49 - row varies
1260:51 - so this i will start from k
1260:54 - because we need to print 8
1260:56 - and we don't have to print 4
1260:58 - so we have already printed 4
1261:00 - so we have incremented k by 1
1261:01 - so now i will start from
1261:03 - k equal to 1
1261:05 - and it will go till
1261:07 - i is less than r
1261:09 - so here you can see i is less than r
1261:11 - because now row varies
1261:13 - and here you can see the column remains the same
1261:16 - so in order to print this column
1261:18 - its value is 3
1261:20 - which is c minus 1
1261:22 - so let's see how it goes
1261:24 - so i starts from k
1261:25 - k
1261:29 - so here i is 1
1261:31 - so now here you can see
1261:33 - the row is actually varying
1261:35 - here column was varying
1261:37 - here row is varying
1261:39 - and column here remains the constant
1261:41 - so we need to print the last column
1261:43 - so how we can get the last column is
1261:45 - we simply do c minus 1
1261:47 - so this will help us in getting the last column
1261:51 - so now i starting from 1
1261:53 - so we are first printing
1261:55 - because c minus 1 is 3
1261:57 - then we will print
1261:59 - 2 comma 3
1262:01 - then 3 comma 3
1262:03 - so we will see how it goes
1262:06 - so now 8 will be printed
1262:08 - value of i is 1
1262:10 - and c minus 1 is 3
1262:12 - so 1 comma 3 will be printed
1262:14 - which is 8
1262:19 - we will increment i
1262:21 - i becomes 2
1262:23 - so it means it has now reached here
1262:26 - then we will print 12
1262:30 - which is 2 comma 3
1262:37 - we will increment i
1262:39 - i becomes 3
1262:43 - and at the end we will simply print 16
1262:49 - we will increment i
1262:51 - so i will become 4
1262:53 - so here you can see
1262:55 - 4 is not less than 4
1262:59 - so this for loop will exit
1263:03 - and here you can see
1263:05 - that we have printed now this part
1263:09 - left to right is printed
1263:11 - top to bottom is printed
1263:13 - and after printing
1263:15 - here you can see
1263:17 - that we have completed with this column
1263:19 - so in the next iteration of while loop
1263:22 - we need to start from here
1263:24 - so for example we need to start from this column
1263:27 - not from this column
1263:29 - so we need to decrement c now
1263:31 - because c is pointing to 4
1263:33 - now we need to decrement it because
1263:35 - once everything will be finished
1263:37 - and this while loop will again come
1263:39 - here you can see
1263:41 - we are printing c minus 1
1263:43 - so if c remains at the 4
1263:45 - 3 will be again printed
1263:48 - so c becomes 3 now
1263:50 - and here you can see
1263:52 - now we are simply providing one check
1263:54 - that if k is less than r
1263:56 - then only
1263:58 - go from right to left
1264:00 - so here this condition we will look into later
1264:02 - so for time being just think that
1264:04 - we have only this for loop
1264:07 - so currently k is actually less than r
1264:10 - but we will see the importance of this condition later
1264:14 - so for time being just think that k is less than r
1264:17 - because k value is 1
1264:19 - 4
1264:21 - now here you can see
1264:23 - we are done from left to right
1264:25 - top to bottom
1264:27 - now we need to go from
1264:29 - right to left
1264:31 - and we know that what varies
1264:33 - in this direction is the column
1264:35 - so here
1264:37 - we need to print now 15
1264:39 - then 14
1264:41 - then 13
1264:43 - so here you can see the column is actually varying from 2
1264:45 - then 1 then 0
1264:47 - and what is constant here is
1264:49 - whatever is from left to right
1264:51 - or from right to left
1264:53 - the row remains the same
1264:55 - column varies
1264:57 - and if we go from top to bottom
1264:59 - or bottom to top
1265:01 - the row varies and columns remains the same
1265:03 - so here now we are going from
1265:05 - right to left
1265:07 - so column is actually varying from 2
1265:09 - then 1 then 0
1265:11 - and here you can see the row is same
1265:13 - which is 3
1265:15 - so here now our i will start from c-1
1265:17 - because we need to print
1265:19 - this part not this
1265:21 - so i will start from c-1 which is 2
1265:26 - 2
1265:28 - it means this column
1265:30 - and row is constant
1265:32 - and here you can see this i will traverse till
1265:35 - i is less than equal to l
1265:37 - so here you can see if l would have been here
1265:40 - it means that we are printing this smaller part of the matrix
1265:43 - because this l
1265:45 - will help us in providing the range
1265:47 - that which column we need to print
1265:49 - so currently why we are going till
1265:51 - i is greater than equal to l
1265:54 - because we need to print all the
1265:56 - column values corresponding to this row
1265:58 - and here you can see
1266:00 - that after each iteration we are decrementing i
1266:02 - because we are printing 2
1266:04 - then 1 then 0 index
1266:08 - so we are going from right to left
1266:10 - so row remains constant
1266:12 - so how we can get this value is
1266:14 - we simply do r-1
1266:15 - so this is the row which we need to print
1266:18 - and column varies from 2 to 0
1266:21 - which is provided by l
1266:23 - so we will simply print 15 now
1266:28 - we will decrement i
1266:31 - i becomes 1
1266:34 - we will now print 3,1
1266:38 - which is 14
1266:39 - we will decrement i
1266:41 - i becomes 0
1266:43 - we will print 3,0 now
1266:45 - which is 13
1266:49 - we will decrement i
1266:51 - it will become minus 1
1266:53 - it means i has gone out of the
1266:55 - boundaries of the matrix
1266:57 - so this condition comes out to be false
1266:59 - so we are going to do r-1
1267:01 - so we are going to do r-1
1267:03 - so we are going to do r-1
1267:05 - so we are going to do r-1
1267:07 - so this condition comes out to be false
1267:09 - because l is 0
1267:11 - then i should be greater than equal to l
1267:17 - so here you can see
1267:19 - after this for loop completes
1267:21 - we are done with this part
1267:23 - 15,14,13
1267:28 - and here we are done with this row
1267:30 - so now we will simply decrement r
1267:32 - because in the next
1267:34 - iteration of these 4 loops
1267:36 - we will simply go
1267:38 - to the inner matrix
1267:40 - so this row is already printed
1267:42 - so we will simply do r-minus
1267:44 - so r becomes 3
1267:48 - and this is the similar condition
1267:51 - what we provided here
1267:53 - we will discuss this both condition later
1267:56 - so for timing thing that l is less than c
1268:00 - because l is 0 and c is pointing to 3
1268:03 - so this condition is true
1268:07 - now here we need to go from
1268:10 - bottom to top
1268:12 - so we know that row will vary
1268:14 - and column will remain the same
1268:16 - so we need to print this column
1268:18 - and print here you can see that
1268:20 - how this k is helping to prevent
1268:22 - traversing this one again
1268:24 - because we need to print this column
1268:26 - which is 9 and 5
1268:28 - so here
1268:30 - like we did here
1268:32 - provided a range
1268:34 - here you can see
1268:35 - starting i from r-minus 1 which is 2
1268:38 - because we need to print this now 9
1268:41 - and it will go till k
1268:44 - so this k will help us
1268:46 - to only print 5
1268:48 - and it won't allow us to go beyond that
1268:50 - to print 1
1268:52 - so this is the advantage of
1268:54 - these conditions here
1268:57 - so i will start from 2 because r-minus 1 is
1269:00 - 3 minus 1
1269:02 - which is 2
1269:03 - so here
1269:05 - i is starting from
1269:07 - the second index row
1269:11 - and here you can see
1269:13 - that we know that column is constant
1269:15 - and this column is being denoted by l
1269:17 - and the row varies
1269:19 - so row is actually varying
1269:21 - by this iterator i
1269:23 - so first we will print
1269:25 - 2, 0
1269:27 - which is 9
1269:30 - then we will decrement
1269:31 - i by 1
1269:33 - i will become 1
1269:36 - so i has become 1
1269:39 - now we will print
1269:41 - 1, 0
1269:43 - because value of l is 0
1269:46 - so 5 will be printed
1269:52 - so here you can see now i become 0
1269:57 - here so we don't need to print this
1269:59 - so therefore this k will help us in
1270:02 - not going to this row
1270:04 - because i should be greater than or equal to k
1270:07 - but here i is not greater than or equal to k
1270:11 - its value is 0
1270:13 - so this for loop will exit
1270:15 - and once this for loop will exit you can see
1270:18 - that now we have printed this part
1270:20 - so after this
1270:22 - 4 for loops
1270:24 - we are done with the outer matrix
1270:27 - so now we need to go to inner matrix
1270:29 - so this for loop will help us going to the inner matrix
1270:33 - but before going that
1270:35 - as we have printed this column
1270:37 - now we need to simply shift l by 1 position
1270:40 - because we need to start again from here now
1270:43 - so we need to shift l by 1 position
1270:46 - by doing l++
1270:48 - so l will become 1
1270:51 - so here you can see that how this l and k are helping us
1270:55 - in traversing this matrix in spiral form
1270:58 - we are done with this column
1271:00 - so now when this value will come again into picture
1271:04 - we will simply start from inner matrix
1271:07 - and this complete matrix
1271:09 - will not be touched based on this conditions
1271:13 - so lets see how
1271:15 - so here you can see k is still less than r
1271:19 - so this condition is true
1271:21 - and l is less than c
1271:23 - so this condition is also true
1271:24 - so now you can see that initially we started k equal to 0 and l equal to 0
1271:32 - r was pointing to 4 and c was pointing to 4
1271:36 - and we printed the outer matrix like this
1271:39 - so now you can see
1271:41 - after the previous complete iteration
1271:44 - we shifted everything by 1 position
1271:47 - we shifted k by 1 position
1271:49 - we shifted l by 1 position
1271:52 - we reduced r by 1 position
1271:54 - and we reduced c by 1 position
1271:57 - so now you can see that as we have reduced the dimensions of k, r, l, c
1272:03 - it means that we are telling that we are done with the outer matrix
1272:08 - and we are now starting from the inner matrix
1272:11 - so here you can see k is pointing to 1
1272:14 - it means it is starting from here now
1272:16 - l is starting from this column because we need to print this
1272:20 - and similarly r and c
1272:23 - so now at the start
1272:26 - we need to print now 6 and 7
1272:29 - so here we know that column varies
1272:32 - so from which column we need to start
1272:34 - this will help us
1272:36 - we need to start from the first column because we need to print 6
1272:40 - and rho remains the same
1272:43 - so i is starting from l
1272:46 - so here you can see the advantage that this l is actually providing us the range
1272:51 - and it will go till less than c
1272:54 - so this i will go and print 6 and 7
1273:00 - because it is going till less than c
1273:04 - so less than c is 2
1273:06 - it means 6 and 7 will be printed because column is varying
1273:11 - and rho is constant which is k
1273:14 - so this is the similar thing now
1273:16 - so the only idea is we need to keep the track of the ranges
1273:20 - rest everything is very much same
1273:23 - so we will simply print now 6
1273:26 - then we will increment i
1273:30 - i becomes 2
1273:32 - so now we will simply print 1,2
1273:34 - here 1,2
1273:39 - so 7 will be printed
1273:43 - we will increment i
1273:45 - so i becomes 3
1273:47 - so 3 is not less than 3
1273:49 - so this condition comes out to be false now
1273:54 - and for loop will terminate
1273:57 - and our condition is we need to only print 6,7 not the 8
1274:01 - so here c is helping us to keep within the boundaries of inner matrix
1274:06 - so we are done with this part
1274:09 - and here you can see rest everything is same
1274:12 - we are done printing this rho now
1274:15 - so we will simply increment k by 1
1274:17 - which means we need to print now this rho
1274:23 - now we will go from top to bottom
1274:26 - so rho varies and k is pointing to 2
1274:29 - so i will start from 2
1274:31 - because we need to print 11 now
1274:36 - so i is starting from 2
1274:38 - here
1274:40 - and here you can see the column remains the same
1274:43 - so this is the only column
1274:45 - or only element inside this column we need to print
1274:48 - because rest everything is printed
1274:50 - so we simply print c-1
1274:53 - which is the second column
1274:55 - and i is travelling from k to less than r
1275:00 - so after printing 11
1275:02 - when we will increment i
1275:05 - it will reach to 3
1275:07 - which will make us equal to r
1275:10 - so therefore i will be equal to r
1275:12 - and we will break from this for loop
1275:15 - so this only 11 will be printed here now
1275:19 - so here we will print 2, 2
1275:22 - so 11 will be printed
1275:27 - we will increment i
1275:29 - so i will become 3
1275:31 - but here you can see this condition is not getting satisfied
1275:35 - which makes sense because we don't have to print now
1275:38 - 15
1275:39 - we are done with the printing of the inner matrix
1275:44 - so this part is done
1275:46 - and as we have printed this column
1275:49 - so we will simply shift c by 1 position here
1275:52 - we do c minus minus
1275:56 - and this condition k is less than r still holds true
1276:00 - because k is less than r
1276:02 - we will discuss this later
1276:04 - and now you can see
1276:06 - we need to go to from right to left
1276:09 - so column varies
1276:11 - so here you can see this column will vary from
1276:14 - c minus 1 which is this part
1276:18 - c minus 1 which is 1
1276:20 - and it will go till l
1276:22 - because l will help us to stop going beyond the particular column
1276:28 - so it will help us only print 10 now
1276:31 - because our i is starting from c minus 1 which is 1
1276:35 - and we need to only print this simple value
1276:37 - which is 10
1276:39 - so i is 1 and it is greater than equal to 1
1276:46 - so this is the part
1276:48 - and here we know that when we go from right to left
1276:52 - only column varies
1276:54 - row remains the same
1276:56 - so here we are simply printing r minus 1
1276:59 - comma i
1277:01 - so r minus 1 will give us
1277:04 - this row
1277:05 - and i is actually pointing to 1 so we are simply printing 2 comma 1 now
1277:09 - which is 10
1277:13 - we will decrement i
1277:15 - i will become 0
1277:17 - so here you can see now
1277:19 - this condition comes out to be false
1277:21 - because i is not greater than equal to l
1277:25 - so here you can see
1277:27 - we have printed 10
1277:29 - and this part is completed
1277:31 - so now we will do r minus minus
1277:33 - because we are done with this row
1277:37 - so r becomes 2
1277:40 - so here k and r both are pointing to 2
1277:44 - and here you can see l is less than c
1277:47 - we will see this both conditions later
1277:51 - now here you can see we have completely traversed the matrix
1277:55 - so this for loop will wont start because
1277:58 - i equals to r minus 1
1278:01 - so if we do r minus 1
1278:04 - i will start from 1
1278:07 - which is this
1278:09 - but we are actually done with printing this complete row
1278:14 - so here this condition
1278:17 - help us in exiting from this for loop because
1278:21 - this is the actual range of the rows
1278:24 - i should be greater than equal to k
1278:27 - but here you can see value of i is 1
1278:30 - and value of k is 2
1278:33 - so this condition comes out to be false because
1278:35 - 1 is not greater than equal to 2
1278:39 - so we will simply increment l now
1278:42 - so l becomes 2
1278:44 - and this inner 4 for loop will end
1278:48 - and this while loop will now exit because
1278:52 - here you can see k is equal to r
1278:55 - and c is also equal to l
1278:57 - it means we have completely traversed this matrix
1279:00 - in spiral form
1279:05 - so friends now we need to see why we are providing these conditions
1279:11 - i will demonstrate one condition and rest
1279:14 - will be pretty much same for the column
1279:17 - so let's suppose we are given with a matrix like this
1279:20 - that it has only 1 row and 2 columns
1279:24 - ok
1279:26 - so we will simply quickly go over this
1279:29 - k is 0
1279:31 - l is 0
1279:33 - this both condition comes out to be true
1279:37 - now we need to print 1 and then 2 because
1279:40 - at the start we need to go from left to right
1279:43 - and column varies
1279:45 - so i starts from l
1279:48 - and goes till less than c
1279:51 - so this is pretty much normal step
1279:53 - 1 will be printed
1279:58 - and then 2 will be printed
1280:06 - so this is actually printed and we are done with the problem
1280:11 - but here if we do k++
1280:14 - so k is pointing to 0
1280:16 - so now k is pointing to 1
1280:21 - here we will start from i equal to 1
1280:25 - because we are done with printing this row
1280:27 - now we need to start from the next row
1280:30 - and we need to go from top to bottom
1280:34 - so here r varies
1280:36 - and i starts from k
1280:38 - and goes till r minus 1
1280:40 - so this for loop won't get executed because
1280:43 - k and r are pretty much same
1280:46 - pointing to 1
1280:49 - so what we do is we do c minus minus
1280:52 - because we are done with printing the last row
1280:54 - because it is already printed
1280:57 - so we simply go c minus minus
1280:59 - so c comes here
1281:02 - so let's suppose if this condition
1281:05 - wouldn't have been provided
1281:07 - here we can see k is equal to r now
1281:10 - and if we don't provide this condition
1281:13 - let's say this for loop starts executing
1281:15 - then we need to go from
1281:18 - right to left
1281:20 - so when we go from right to left we start from c minus 1
1281:24 - so c minus 1 is
1281:26 - i will start from 0
1281:28 - and it will go till i is greater than equal to l
1281:31 - so here you can see l is pointing to 0
1281:34 - so this condition comes out to be true
1281:38 - so this is where this problem starts
1281:41 - if this condition comes out to be true
1281:44 - then it will simply print
1281:47 - r minus 1 which is
1281:49 - r pointing to 1
1281:51 - if we do minus 1 we get 0
1281:54 - and i value is 0 so it will actually print
1281:57 - 1
1281:59 - which is we don't want that
1282:02 - because why we don't want that is because
1282:05 - we are already done with this row
1282:07 - so therefore
1282:09 - when we go from right to left
1282:12 - it is very much important that we need to think that
1282:15 - ok is the matrix completely traversed
1282:18 - because here you can see matrix is completely traversed
1282:21 - so here this condition will help us
1282:25 - preventing to print 1 again
1282:29 - after printing 1 and 2 we should simply exit
1282:33 - and these two condition will help us doing that
1282:36 - because there could be a possibility
1282:39 - that we are given with this matrix only
1282:42 - so these are the few edge cases which we need to provide
1282:47 - so this condition is also pretty much same let's say
1282:50 - if we are given a matrix like this
1282:52 - here it was
1282:54 - 1 row 2 column
1282:56 - here it will be
1282:58 - 2 row 1 column
1283:00 - so this condition will help us in
1283:02 - preventing let's say 1, 2
1283:05 - so like 1, 2, 1 again
1283:08 - similar to that stuff
1283:10 - so friend this was all about
1283:13 - traversing a matrix in a spiral form
1283:16 - it is a very complex question but if you understand this figure
1283:23 - C varies, R varies, C varies, R varies
1283:28 - and they vary from range K, L, R and C
1283:34 - so if you understand these two points
1283:37 - you can traverse the matrix in spiral form pretty much easily
1283:41 - using this simple for loops
1283:43 - I hope you must have liked this video
1283:45 - and in case if you are new to my channel
1283:47 - then please subscribe to my channel
1283:49 - and click the bell icon
1283:50 - so that you never miss any update
1283:53 - thanks have a nice day
1283:57 - hello friends welcome to my new data structures
1284:00 - and algorithms in java tutorial series video
1284:03 - friends in this tutorial we will discuss
1284:05 - about the introduction to priority queue
1284:08 - and binary heap in java
1284:12 - so friends what is a priority queue
1284:14 - so here you can see
1284:16 - priority queue is a data structure that allows us to find
1284:18 - minimum or maximum element among a collection of elements
1284:22 - in constant time
1284:25 - so here priority queue data structure holds the collection of elements
1284:29 - and it helps us in finding the minimum or the maximum element
1284:33 - in a constant time
1284:35 - that means from the collection of elements
1284:37 - we can find the minimum or the maximum element
1284:40 - very fast in constant time
1284:44 - so usually priority queue supports these three operations
1284:47 - one is the insertion operation
1284:49 - where we actually insert a particular key into the priority queue
1284:54 - so the second operation is delete max or delete min
1284:57 - so here you can see
1284:59 - whenever we call delete max or delete min
1285:01 - what it does is
1285:03 - if we call delete max
1285:05 - it return and remove the largest key from the priority queue
1285:09 - and whenever you call delete min
1285:11 - it removes the smallest key from the priority queue
1285:14 - and return it back
1285:16 - also friends if you don't want to remove the largest and the smallest key from the priority queue
1285:20 - then we use the third operation which is the get max and get min
1285:24 - so it simply returns the largest and the smallest key without actually removing it from the priority queue
1285:31 - and also friends we will discuss more about the priority queue in our upcoming tutorial
1285:35 - moving ahead
1285:39 - so friends in our last slide we saw about the priority queue
1285:42 - so now we will discuss about the binary heap
1285:45 - so here you can see
1285:47 - the binary heap is a data structure that helps us in implementing the priority queue operations efficiently
1285:53 - so whatever the three operations we discussed in our last slide
1285:57 - about the insertion of key
1286:00 - delete max or min
1286:02 - and get max or get min
1286:04 - those operations are efficiently implemented with the help of binary heap
1286:10 - also friends the binary heap is a complete binary tree
1286:14 - in which each node value is greater than or less than the values of its children
1286:21 - so why it is a complete binary tree we will discuss later
1286:25 - below you can see that there are two binary heaps
1286:28 - one is the min heap and other is the max heap
1286:32 - and why we call it as a min heap because each node value is less than equal to the values of its children
1286:40 - so here you can see if you take an example of node having value 0
1286:45 - then its children which is 7 and 3 have values greater than the parent
1286:51 - so here in the min if the parent value is less than or equal to the value of its children
1286:58 - also here you can see if you take a node having value 7
1287:02 - then both its children which is 9 and 8 have values greater than 7
1287:07 - and if you take an example of 3
1287:10 - then both its children having values 5 and 6 have values greater than its parent
1287:16 - so here this property is true for each and every node of the binary heap
1287:21 - and here you can see in the max heap each node value is greater than or equal to the values of its children
1287:29 - so here if you take the node having value is 9
1287:32 - then its children have values lesser than the parent
1287:36 - and similarly if you take the node having value is 3
1287:40 - then its both children is having values lesser than the parent
1287:45 - similarly 6 which is the parent to 5 and 4 its value is greater than both 5 and 4
1287:53 - therefore by this definition a binary heap is a complete binary tree
1287:58 - in which each node value is greater than equal to which is the max heap
1288:02 - or less than equal to which is the min heap then the values of its children
1288:08 - so here you can see the binary heap has 2 types which is the min heap and the max heap
1288:15 - so in the min heap each node value is less than or equal to then the values of its children
1288:20 - and in the max heap each node value is greater than or equal to than the values of its children
1288:27 - moving ahead
1288:29 - so as we discussed in the previous slide that binary heap is a complete binary tree
1288:35 - so what do we mean by complete binary tree
1288:38 - so here as per the definition a complete binary tree is a binary tree where all levels are completely filled
1288:45 - except last level and last level has nodes in such a way that left side is never empty
1288:53 - so what do we mean by this definition is below you can see a binary tree
1288:59 - so here at the level 1 we have a node having value as 0
1289:04 - so this node will be having a left child and a right child
1289:08 - so at the level 2 we have these 2 nodes which is 7 and 3
1289:13 - and till level 2 you can see it is completely filled because a node can have only 2 children
1289:20 - but as soon as we go to level 3 here we see that 7 has 1 left child and 1 right child
1289:27 - similarly 3 has only left child and there is no right child
1289:31 - so here you can see a binary tree is completely filled except the last level
1289:36 - so this is the last level
1289:38 - so here you can see all the levels are completely filled except the last level
1289:43 - so here we can see there is no node therefore it is not completely filled
1289:47 - and also it has one more property that the last level has nodes in such a way that left side is never empty
1289:54 - so here you can see whatever the nodes the last level is having
1289:59 - they are in such a way that left side is never empty
1290:03 - so by the left side we mean that in example 2 you can see that level 1 is complete
1290:09 - level 2 is complete but level 3 is not complete
1290:13 - and also the last level is not completely filled
1290:17 - but here you can see by the second property it says that last level has nodes in such a way that left side is never empty
1290:24 - so here you can see one left side is empty
1290:27 - so therefore it is not a complete binary tree
1290:29 - so we call it an incomplete binary tree
1290:32 - those last level is not completely filled but there is one missing left node
1290:37 - and similarly here you can see that all the levels are completely filled
1290:43 - and the last level is not completely filled but it has nodes in such a way that the left side is never empty
1290:51 - so friends here you can imagine complete binary tree in such a way that if we go from left to right then we always get a node
1290:58 - so here at the level 1 there is one node so level 1 is completely filled
1291:04 - as we go to level 2 there can be at most 2 nodes
1291:09 - so here you can see if we go from left to right we are getting 7 and 3
1291:14 - so those are completely filled
1291:17 - if we go to third level
1291:19 - if we go from left to right then we are always getting a node
1291:23 - now there is no right child of 3 but still it is a complete binary tree because
1291:29 - because there are no gaps if you are traversing from left to right
1291:33 - and similar if we talk about incomplete binary tree
1291:37 - and if we go from left to right then here we can see that 3 has no left child therefore the first node is null
1291:44 - so it doesn't satisfy the property of complete binary tree
1291:48 - also friends in our upcoming tutorial we will also discuss more about the complete binary tree
1291:54 - because this is the main property which helps us in creating a binary heap
1292:04 - hello friends welcome to my new data structures and algorithms in java tutorial series video
1292:11 - friends in this tutorial we will discuss how to represent a binary heap in java
1292:24 - so friends in our previous tutorial we actually discussed about the introduction to binary heap
1292:29 - so in this tutorial we will actually see how we can actually represent a binary heap in java
1292:36 - so friends in our previous tutorial we actually discussed that binary heaps are nothing but complete binary tree
1292:42 - and we also discussed that there are two types of binary heap
1292:47 - one is the main heap and other is the max heap
1292:50 - so friends diagrammatically we represent a binary heap in the form of a binary tree
1292:57 - that there is one parent who has two children
1293:01 - and similarly the other levels have their own children
1293:06 - but when it comes to storing these elements binary heaps usually are implemented using the array
1293:14 - so here you can see a max heap in which each node value is greater than or equal to the value of the children
1293:21 - so 9 is greater than 3 and 6
1293:24 - 3 is greater than 2 and 1
1293:26 - 6 is greater than 5 and 4
1293:29 - so in order to represent the binary heap we basically implement it through the arrays
1293:35 - also here you can see the max heap is having 7 elements as 1, 2, 3, 4, 5, 6, 7
1293:43 - so we usually store these elements into an array
1293:47 - so in order to store these 7 elements into this array
1293:52 - we usually create an array of 7 plus 1 elements
1293:56 - because the first entry of array we always take it as empty
1294:01 - so here you can see that we never store any element at the 0th index
1294:07 - and here you can see that we start storing these elements from index 1
1294:11 - so usually we keep the first entry of this array as empty
1294:17 - also friends we store these elements into an array by traversing this binary tree
1294:22 - level by level from left to right
1294:28 - so here you can see at level 1 if we are traversing from left to right
1294:32 - we only encounter 1 node which is 9
1294:36 - so we store 9 into an array at the 1st index
1294:41 - moving ahead
1294:43 - then we go to level 2
1294:46 - and at level 2 from left to right we first encounter 3
1294:51 - so we store 3 at index 2
1294:56 - and similarly then we encounter 6
1295:01 - so we store it at index 3
1295:07 - and similarly if we go to level 3
1295:11 - from left to right first we encounter 2
1295:13 - so 2 we store at index 4
1295:18 - and similarly the other elements
1295:28 - also friends in the last tutorial we discussed that binary heaps are complete binary tree
1295:33 - that all the levels are filled
1295:36 - and if all levels are not filled then only the last level
1295:40 - is the level which is not filled
1295:43 - and the elements are arranged in such a way that the left side is not empty
1295:47 - so here you can see why we are taking it as complete binary tree
1295:52 - so let's suppose if 2 is not present
1295:55 - so when we store these elements from left to right in an array
1295:59 - so you can see that here in an array we will get
1296:03 - an empty whole which will store a null value
1296:07 - so whenever we are representing a binary heap using an array
1296:10 - we don't want that any value inside is binary heap
1296:14 - to be an empty or null
1296:17 - so therefore the binary heap are nothing but complete binary tree
1296:20 - where each level is filled completely
1296:23 - and if all the levels are not complete
1296:26 - then it is the only last level which is not complete
1296:29 - and all the nodes are as left as possible
1296:32 - so friends binary heap has these 2 properties
1296:35 - one is that it should be complete binary tree
1296:38 - and second it should follow the heap order property
1296:41 - so the heap order property is what we discussed that each node
1296:45 - should have values greater than or less than the values of its children
1296:51 - and if the values are greater than its children then it's a max heap
1296:54 - and if the values is less than its children then it's a main heap
1296:58 - which we already discussed in our previous tutorial
1297:02 - also friends if we represent these indexes here
1297:05 - then it would look something like this
1297:07 - that we have filled this array from left to right
1297:11 - level by level
1297:14 - moving ahead
1297:17 - also friends in our previous slide we discussed that how we can represent
1297:21 - a binary heap in the form of an array
1297:24 - so here you can see this max heap is represented in the form of an array
1297:29 - so whenever we perform any calculation over this array
1297:32 - we are basically provided a particular index
1297:36 - and we need to calculate basically its parent or its child
1297:40 - using some formula
1297:42 - so here you can see
1297:44 - if we are at node having value as 9
1297:47 - so in the array
1297:49 - it is at first index
1297:53 - and if we look for its children
1297:55 - then it has 2 children
1297:57 - one is having value as 3
1297:59 - and other is having value 6
1298:01 - and they are at index 2 and 3
1298:05 - so 1 has 1 children at index 2
1298:09 - and 1 has other children at index 3
1298:18 - similarly if we take a node having value as 3
1298:21 - then here we can see that it is at index 2
1298:27 - and if we look for its children
1298:29 - then they are at index 4 and 5
1298:32 - which means that index 4 which has value 2
1298:36 - and index 5 which has value 1 are children
1298:39 - of index 2
1298:41 - whose value is 3
1298:44 - so here you can see 3 is parent to 2 and 1
1298:47 - in which 3 is at index 2
1298:50 - 2 is at index 4 and 1 is at index 5
1298:53 - so here value at index 2 is parent to value at index 4
1298:58 - and also
1299:00 - value at index 5
1299:05 - similarly if we take the node having value as 6
1299:09 - then here we can see 5 and 4 are children to 6
1299:13 - if we take this representation into an array
1299:17 - then 5
1299:19 - is 1 children
1299:21 - of 6
1299:23 - and 4 is the other children
1299:24 - so friends here you can see that how this binary heap
1299:30 - is represented into this array
1299:33 - and how we can represent this parent-child relationship
1299:36 - into this array
1299:38 - but in order to calculate this parent and child of a particular index
1299:42 - there is a formula
1299:44 - so we always have the children of first index
1299:48 - is 2
1299:50 - and 3
1299:52 - we saw the children of second index
1299:55 - which is this node
1299:57 - is 4 and 5
1300:01 - and we also saw the children of third index
1300:04 - which is this
1300:06 - has children at 6 and 7
1300:09 - so if we are given any particular index
1300:12 - let's say kth index
1300:14 - and we want to find its children
1300:17 - then the children of kth index would be
1300:20 - 2 times k
1300:22 - and 2 times k plus 1
1300:24 - so here children of 1 is 2 into 1
1300:28 - and 2 into 1 plus 1
1300:30 - children of second index is
1300:33 - 2 into 2 which is 4
1300:35 - and 2 into 2 plus 1 which is 5
1300:39 - children of third index is
1300:41 - 3 into 2 which is 6
1300:44 - and 3 into 2 plus 1 which is 7
1300:46 - so friends this is the formula
1300:49 - which we use in order to find
1300:52 - the children of any particular index
1300:55 - we simply substitute
1300:57 - that particular index value here
1300:59 - and we get the values of its children
1301:03 - so friends this was the formula to calculate the children
1301:06 - of any particular index
1301:08 - now let's say if we are given any particular index
1301:11 - and we want to find its parent index
1301:13 - then here you can see
1301:15 - the parent of 7 index is 3
1301:17 - so here the parent
1301:19 - of 7 index is 3
1301:23 - parent of 6 index is 3
1301:25 - so parent of 6 index is also 3
1301:29 - parent of 5th index is 2
1301:32 - so this is the 5th index
1301:34 - and its parent is at 2
1301:37 - so friends in order to find the parent of kth index
1301:39 - the formula would be
1301:41 - simply k by 2
1301:45 - so you can see that if you are at 7 index
1301:47 - and you want to go to its parent
1301:49 - then what we simply do is
1301:51 - we do 7 by 2
1301:53 - which gives us a value of 3.5
1301:56 - and as we are dealing with the integer values
1301:59 - this integer value is rounded off to 3
1302:02 - so 7 by 2 gives 3.5
1302:05 - and if we take the integer value of it
1302:07 - it round off to 3
1302:11 - similar the parent of 6 index is 3
1302:13 - which is evaluated as 6 by 2 which is 3
1302:19 - and parent of 5th index is 2
1302:22 - is being evaluated as 5 by 2
1302:25 - which gives us a value of 2.5
1302:27 - and if we round it off we get 2
1302:30 - so friends in this slide we discussed that whenever we represent a binary heap
1302:35 - in the form of an array
1302:37 - and if we are at any particular index
1302:39 - then we can traverse to its parent
1302:41 - or to its child using these formulas
1302:45 - if we want to traverse to its child
1302:47 - we simply multiply it by 2
1302:49 - which will traverse it to the left child
1302:52 - and if we add a 1 to it
1302:54 - we simply go to its right child
1302:57 - and similarly if we are at any particular index
1302:59 - and if we want to go to its parent
1303:01 - we simply divide that index by 2
1303:04 - and we will reach to its parent index
1303:07 - so friends in this tutorial we actually discussed about the representation of a binary heap
1303:12 - and we also discussed that we are actually representing
1303:15 - a binary heap in the form of an array
1303:18 - where this first element of the array is left as empty
1303:22 - and we start our insertion of these elements from the index 1
1303:27 - and we also discussed that how we can actually calculate
1303:30 - the children of any particular index
1303:33 - and also the parent of any particular index
1303:37 - I hope you liked this video
1303:39 - thanks have a nice day
1303:40 - hello friends welcome to my new data structures and algorithms in java tutorial series video
1303:51 - friends in this tutorial we will discuss
1303:55 - how to implement max heap in java
1304:00 - so friends in our previous tutorial we actually discussed that binary heaps
1304:04 - are of basically two types
1304:06 - one is the min binary heap
1304:08 - another is the max binary heap
1304:11 - so here you can see a max heap is a complete binary tree
1304:16 - in which each node value is greater than or equal to the values of its children
1304:21 - so here if we take any particular node let's say 9
1304:26 - so its value will be always greater than or equal to the values of its children
1304:32 - so here you can see 9 is greater than 3 and 6
1304:36 - so this property should hold true for each and every node
1304:40 - is max binary heap
1304:42 - so if we take an example of node having value as 3
1304:46 - then 3 is greater than 2 and 1
1304:49 - and similarly if we take an example of 6
1304:52 - then 6 is greater than 5 and 4
1304:56 - and also in a binary tree the last level has the leaf nodes
1305:01 - so therefore the property holds true for them as well
1305:04 - also friends in a max heap you can see that the maximum value is always at the top
1305:10 - which we also call as the root of the binary tree
1305:14 - so here in the max heap the root always has the maximum value
1305:21 - and if we represent this max heap in a form of an array then it would look something like this
1305:27 - that as this max heap has 7 elements
1305:30 - we will first create an array of length 8
1305:34 - because the first element we always keep it as empty
1305:37 - and we start insertion from the index 1
1305:41 - we also discussed in our previous tutorial that how we actually insert this value inside an heap
1305:49 - so we go level by level from left to right
1305:52 - so at level 1 we have only the root node which is 9
1305:57 - so 9 is placed at an index 1
1306:03 - similarly at level 2 we have 3 and 6
1306:10 - 3 is placed at index 2
1306:14 - and 6 is placed at index 3
1306:21 - and at level 3 we have 4 nodes
1306:24 - 2, 1, 5 and 4
1306:27 - so 2 is placed at index 4
1306:31 - 1 is placed at index 5
1306:37 - 5 is placed at index 6
1306:41 - and 4 is placed at index 7
1306:47 - so friends here you can see the maximum value of this binary tree is at the root which is 9
1306:54 - and if we represent this max heap in an array
1306:58 - then here you can see at index 1 we will always get the maximum value
1307:04 - moving ahead
1307:05 - so friends here you can see the code for the implementation of the max priority queue
1307:13 - so this is the initial implementation
1307:16 - and there are many more methods which we will discuss in our upcoming tutorials
1307:21 - and here you can see this max priority queue is nothing but our max heap
1307:26 - where it has the integer array which we discussed in our previous slide
1307:31 - so we give it as a name of heap
1307:34 - and we actually store the size of this max priority queue in the integer variable n
1307:40 - so friends here you can see in the main method the first step we do is
1307:45 - we basically create an instance of max priority queue
1307:49 - and to its constructor we are actually passing the capacity that how many elements
1307:54 - this max priority queue will hold
1307:56 - so here you can see in the constructor
1307:59 - the value which we are passing is nothing but the capacity of the max priority queue
1308:04 - so this is nothing but the initial capacity of the max priority queue
1308:10 - so when this line get executed
1308:13 - the call reaches to this point
1308:16 - and we know that we have passed the value as 3
1308:20 - so the capacity is 3
1308:23 - now as we have this instance variable
1308:25 - which is an integer array by name heap
1308:29 - and the integer variable n which holds the size of this max priority queue
1308:34 - and also friends here you can see that this integer array can be any generic type array
1308:40 - but for the simplicity of understanding
1308:43 - I am using here as an integer array
1308:46 - so here in the constructor the first step we do is
1308:49 - we actually create an array
1308:52 - having length as capacity plus 1
1308:55 - so it would look something like this
1308:58 - now capacity is 3
1309:00 - and we have initialized this array with a length of capacity plus 1 which is 4
1309:07 - so why we actually do capacity plus 1 is because we discussed in our previous tutorial that
1309:13 - that the first element in an array we always keep it as empty
1309:18 - so we actually don't use the index 0
1309:21 - we always keep it as empty
1309:23 - and we place our elements starting from index 1
1309:27 - so here you can see as we are not using this zeroth index
1309:31 - now the array can hold a capacity of 3
1309:35 - so therefore we are initializing this integer array with a length of capacity plus 1
1309:41 - moving ahead
1309:44 - now as we have initialized this max priority queue here
1309:48 - the initial value of n would be 0 because there are no elements currently into this heap
1309:55 - so n is 0
1309:58 - and also friends here we have provided two methods
1310:01 - one is the isEmpty method which returns a boolean value
1310:05 - which tells that whether priority queue is empty or not
1310:08 - so here you can see if the value of n is equal to 0
1310:13 - then we know that there are no elements into this heap
1310:15 - and max priority queue is empty
1310:18 - so we simply return true if value of n is 0 or else we return false
1310:25 - and the second method we provide is size
1310:28 - we simply return the value of n
1310:30 - so here if we call the size method
1310:34 - it will print 0 because currently the value of n is 0
1310:40 - and then if we simply call isEmpty method to check whether priority queue is empty or not
1310:45 - we simply return true because n is equal to 0
1310:51 - so friends this is a basic and initial implementation of a max priority queue
1310:55 - there are more other methods which we will discuss in our upcoming tutorial
1311:01 - so the only understanding we need to see is that a max priority queue basically implemented through an array
1311:08 - which we give here name as heap
1311:10 - and we simply create an integer value n which keeps the track of the number of elements currently into this heap array
1311:18 - so friends this was the demonstration of this few methods
1311:22 - now let's go to Eclipse and see the working of this code
1311:31 - hello friends
1311:33 - in our previous tutorial we actually discussed how we can implement a max priority queue in Java
1311:40 - and in our previous tutorial we actually saw an animation to basically implement a max priority queue
1311:47 - and in that tutorial we actually implemented the max priority queue at a very basic level
1311:54 - and which we will enhance in our upcoming tutorial
1311:57 - so friends let's see the code to implement a max priority queue in Java at a very basic level
1312:05 - so friends in this tutorial I have created one class by name maxPQ
1312:10 - which is nothing but max priority queue which has a main method
1312:16 - so friends in our previous tutorials we also discussed that we represent a max priority queue in a form of an array
1312:23 - so first we will create an integer array
1312:29 - and we will give it a name as heap
1312:34 - and the second instance variable will give it an integer variable by name n
1312:44 - so this will store the size of the max heap
1312:49 - moving ahead we also discussed that we will provide a constructor
1313:03 - so this constructor will take the initial capacity of the heap
1313:10 - so inside this constructor we also saw that first we will create an integer array
1313:17 - whose size will be capacity plus 1
1313:25 - so why we are taking its capacity plus 1 is because index 0 is kept as empty
1313:37 - and we simply initialize the value of n to be 0
1313:41 - because when we initialize this max priority queue there are no elements into this heap
1313:47 - so the value of n is 0
1313:52 - we will also provide a method which will return a boolean value
1313:57 - and the name of the method would be isEmpty
1314:01 - which will return a boolean value that whether this max priority queue is empty or not
1314:11 - so we simply return n equal equal 0
1314:17 - so if the value of n is 0 it will return true
1314:21 - and if value of n is not 0 then we know that there are elements into this heap array
1314:27 - also we will provide one more method
1314:30 - whose return type would be an integer value
1314:34 - which would be nothing but the size of this max priority queue
1314:41 - so we will simply return the value of n
1314:44 - so whenever we call this size method it will return us back the size of this max heap
1314:50 - that how many elements currently this max heap has
1314:53 - so friend in the main method
1314:57 - will first initialize this priority queue
1315:08 - let's say with capacity 3
1315:15 - and then will print
1315:19 - its size
1315:23 - and will also check that whether is currently empty or not
1315:29 - so here you can see when we initialize this max priority queue
1315:35 - the value of n is 0
1315:37 - so the size return is 0
1315:39 - so it will print 0
1315:43 - and if we check whether this max priority queue is empty or not
1315:47 - so n is equal to 0 so it would return true
1315:52 - if I run this code now
1316:00 - so here you can see it printed 0 and true
1316:05 - so friend in this tutorial we actually discussed the basic
1316:09 - and a very initial implementation of this max priority queue
1316:12 - in our upcoming tutorial we will see the operation
1316:16 - a priority queue supports such as insertion, get max and delete max
1316:21 - I hope you like this video thanks have a nice day
1316:29 - hello friends welcome to my new data structures and algorithms in java tutorial series video
1316:36 - friends in this tutorial we will discuss
1316:39 - bottom up 3 ep5 in max heap
1316:42 - so friends in our previous tutorial we saw the initial implementation of a max heap in java
1316:55 - now in this tutorial we will actually discuss what happens when we insert a particular element into this max heap
1317:03 - so here you can see that a max heap is a complete binary tree
1317:07 - in which each node value is greater than or equal to the values of its children
1317:14 - so here you can see the node having value as 9 has 2 children 3 and 6
1317:22 - so 9 has a value greater than both 3 and 6
1317:26 - and similarly if we take a node having value as 3
1317:30 - it has 2 children 2 and 1
1317:33 - so both these values 2 and 1 are less than 3
1317:38 - so here you can see in max heap each node is having value greater than the values of its children
1317:46 - so friends this property is called as heap order property of a max heap
1317:51 - that each node value is greater than or equal to the values of its children
1317:57 - so friends let's suppose we are given a particular max heap having this 7 elements
1318:03 - now let's suppose if we insert any particular element into this heap
1318:07 - so after inserting that particular element into this max heap it may not satisfy this above property
1318:15 - so friends let's suppose we are given any particular max heap having this few elements
1318:20 - so in this max heap we know that the maximum value is always at root
1318:26 - so friends let's suppose if we insert an element into this max heap having value greater than 9
1318:33 - so friends as we discussed that heap is a complete binary tree
1318:37 - and here you can see all the levels are filled
1318:40 - so when we insert a new node it will be inserted into this level 4 to the left of 2
1318:47 - and let's suppose we insert a value of 15
1318:52 - so once we insert this value as 15
1318:55 - the heap order property which we discussed that each node value should be greater than
1319:00 - or equal to the value of its children will break
1319:04 - because 2 will be parent to 15 but its value is lesser than 15
1319:09 - so it will break the heap order property of this max heap
1319:14 - so friends what we do is after inserting that particular value
1319:18 - we perform bottom up re-eap5 technique
1319:22 - so in this technique what we do is simply adjust the location of elements
1319:27 - so that it satisfies this heap property
1319:30 - so friends let's see a demo that how we can perform bottom up re-eap5 in a max heap
1319:40 - so let's say we are given this max heap having 7 elements
1319:45 - and let's say we insert 10
1319:48 - so here you can see all the levels are filled completely
1319:52 - and as heap is a complete binary tree
1319:55 - the value 10 will be inserted to the left of 2 at level 4
1320:00 - so it would look something like this
1320:03 - because in a complete binary tree all the levels are filled completely except the last level
1320:09 - and the last level is filled in such a way that leftmost side is not empty
1320:15 - so 10 will be inserted to the left of 2
1320:19 - so friends as it is a max binary heap
1320:22 - we know that the maximum element always lies at the root of this binary tree
1320:27 - but here you can see as we have inserted a value 10 which is greater than 9
1320:32 - therefore the heap order property is not being satisfied
1320:37 - because as we discussed that each node in a max heap should have values greater than the values of its children
1320:44 - but here you can see if we compare 2 and 10
1320:49 - then the value 2 is less than 10
1320:52 - therefore it is breaking the heap order property of max heap
1320:56 - so friends in order to satisfy the heap order property of this max heap what we do is
1321:01 - we simply adjust the locations of these nodes such that heap order property is satisfied
1321:07 - so here you can see as 10 is greater than 2
1321:11 - so what we do is
1321:14 - we simply shift up the value 10
1321:17 - and we swap it with the 2
1321:20 - so it would look something like this
1321:23 - that 10 is swapped with 2
1321:27 - so friends once we swap this value
1321:32 - we know that 10 is now greater than 2
1321:35 - so at this position 10 is satisfying the heap order property of this max heap
1321:41 - but here you can see after this swap we simply traverse through this node
1321:46 - and then we again see that whether it has any parent or not
1321:50 - so here you can see 10 has a parent whose value is 3
1321:53 - so then we compare these 2 values
1321:56 - because here you can see 3 is less than 10
1322:00 - so still the heap order property is not being satisfied
1322:04 - so what we do is we simply shift up 10
1322:07 - and we swap it with the 3
1322:09 - so it would look something like this
1322:14 - so value 10 is being swapped with 3
1322:19 - so once we perform this swap we again traverse through 10
1322:23 - and we check that whether it has any parent or not
1322:25 - so it has a parent
1322:27 - then we compare the parent to his children
1322:31 - so here we will simply compare 9 and 10
1322:34 - so here you can see
1322:36 - the value of 9 is less than 10
1322:39 - so still the heap order property of this heap is not being satisfied
1322:46 - so what we do is we simply perform a shift up
1322:49 - and we will simply swap these 2 values
1322:55 - so friends once this swap is done
1322:58 - we simply traverse through 10
1323:00 - and we again check whether it has any parent or not
1323:03 - so here you can see that 10 doesn't have any parent
1323:07 - then we also see that heap order property is satisfied
1323:11 - because the root has the maximum value among the other nodes
1323:18 - now friends let's suppose we want to insert a value as 8
1323:22 - so as it is a complete binary tree
1323:24 - the other value will be inserted to the right of 3
1323:29 - so we simply insert 8 to the right of 3
1323:34 - so after we insert this value 8
1323:36 - we simply compare it with its parent
1323:40 - and here we see that 3 is less than 8
1323:43 - therefore the heap order property is not being satisfied
1323:46 - so what we do?
1323:48 - we simply perform a shift up
1323:50 - and we simply swap these 2 values
1323:56 - and once we perform this swap
1323:59 - we simply reach to 8
1324:01 - and then we again compare it with its parent
1324:04 - so here 9 is greater than 8
1324:09 - therefore the heap order property is satisfied because
1324:12 - in maxheap the value of parent should be greater than the value of its children
1324:18 - so 9 is greater than 8
1324:20 - so therefore the value 8 is at its correct position
1324:27 - moving ahead
1324:30 - friends in our upcoming tutorial
1324:32 - we will see that how we can insert a value in maxheap
1324:36 - and we will see the demonstration of the code step by step
1324:39 - so the example we will take in our upcoming tutorial
1324:43 - will be like this
1324:45 - and let's suppose the maxheap is empty
1324:48 - so first we are inserting 4
1324:51 - so as 4 is the only element into this maxheap
1324:55 - therefore the heap order property is maintained
1324:59 - then we insert 5
1325:01 - so as level 1 is filled completely
1325:04 - 5 will be inserted at level 2 to the left of 4
1325:10 - because we know that maxheap is nothing but a complete binary tree
1325:14 - so 5 will be inserted to the left of 4
1325:17 - so once we insert 5
1325:19 - we will simply check its value to its parent
1325:22 - and as it is a maxheap we know that each node is having value greater than the value of its children
1325:29 - so here we simply compare 4 and 5
1325:32 - and we know that 4 is less than 5
1325:35 - therefore the heap order property is not maintained
1325:39 - so we will simply shift up 5 and we will swap it with the 4
1325:45 - so now 5 is at correct position
1325:49 - and we know that among these 2 values 5 is the largest value
1325:54 - which is at the root of this binary tree
1325:57 - moving ahead
1326:00 - let's say we insert 2
1326:02 - so 2 will be inserted to the right of 5
1326:05 - because left is already occupied by 4
1326:10 - so once we insert 2
1326:11 - we will simply compare the value 2 with its parent
1326:18 - and as 5 is greater than 2
1326:20 - therefore it is satisfying the heap order property
1326:28 - now let's say we insert 6
1326:30 - so here you can see the level 2 is filled completely
1326:34 - so now 6 will be inserted at level 3 to the left of 4
1326:41 - and then we will compare these 2 values
1326:45 - and as 4 is less than 6
1326:48 - therefore we will perform a shift up
1326:51 - and we will simply swap 6 and 4
1326:58 - so once we perform the swap
1327:00 - we will reach to this node
1327:02 - and then we will again compare it with its parent
1327:05 - so here now we will compare 5 and 6
1327:08 - and we know that 5 is less than 6
1327:11 - so we will perform a shift up
1327:14 - and we will simply swap these 2 values
1327:21 - so friends here you can see 6 is at its correct position
1327:26 - because it is the largest value among the other 3 values
1327:32 - now let's say we insert 1
1327:34 - so 1 will be inserted to the right of 5
1327:38 - and then we will compare it with its parent
1327:43 - and here we can see that 5 is greater than 1
1327:46 - so no swap will be done
1327:52 - and let's say we insert 3
1327:55 - so now 3 will be inserted to the left of 2
1328:00 - we will compare 3 with its parent
1328:03 - whose value is 2
1328:05 - and we know that 2 is less than 3
1328:10 - therefore we will perform a shift up
1328:13 - and we will simply swap these 2 values
1328:19 - and also friends there we will compare 3 with 6
1328:22 - and we know that 3 is at its correct position
1328:25 - therefore no swap will be done
1328:29 - so friends this is how we perform bottom up reepify
1328:31 - in order to maintain the heap order property
1328:35 - of min or max heap
1328:37 - so friends usually in most of the cases
1328:40 - whenever we insert any new value in a heap
1328:43 - the heap order property breaks
1328:45 - so after inserting a new element
1328:48 - we simply perform a bottom up reepify technique
1328:52 - in which we simply change the locations of the element
1328:55 - so that they maintain a heap order property
1328:58 - and we also give different names to this technique
1329:02 - we call it bottom up reepify
1329:04 - we also call shift up
1329:06 - we can also call swim
1329:08 - because the elements usually swim from bottom to top
1329:12 - when we insert a new element
1329:15 - so in our upcoming tutorial
1329:17 - we will actually see the code
1329:19 - to insert an element into a max heap
1329:22 - and we will look the demonstration of that code step by step
1329:26 - I hope you like this video
1329:28 - thanks have a nice day
1329:33 - hello friends
1329:35 - welcome to my new data structures
1329:37 - and algorithms in java tutorial series video
1329:40 - friends in this tutorial we will discuss
1329:43 - how to insert in a max heap in java
1329:51 - so friends in our previous tutorial
1329:53 - we actually discussed about what is a max heap
1329:56 - that it is a complete binary tree
1329:58 - in which each node value is greater than
1330:01 - or equal to values of its children
1330:05 - and we also discussed that the maximum value
1330:08 - of this max binary heap is at root
1330:13 - and if we look into its array representation
1330:20 - we also discussed that how we actually place
1330:22 - these values inside this heap array
1330:29 - so we simply put these values
1330:32 - level by level
1330:34 - from left to right
1330:44 - so here you can see
1330:46 - in this heap array if we return the value at index 1
1330:49 - we will always get the maximum value
1330:52 - of this heap
1330:54 - also friends we discussed in our previous tutorial
1330:56 - that priority queue helps us in getting
1330:59 - the maximum value among the collection of elements
1331:02 - in constant time
1331:04 - so if we simply return the value at index 1
1331:07 - we get the maximum value of this max binary heap
1331:11 - and similarly for the min binary heap
1331:14 - if we return the value at index 1
1331:17 - we will get the smallest value among the collection of elements
1331:20 - so let's see how we can insert a value in max heap
1331:27 - so friends in our previous tutorial we actually discussed
1331:30 - the basic implementation of the max priority queue
1331:34 - so in this tutorial we will actually see how we can insert a value
1331:37 - into this max priority queue
1331:39 - through this insert method
1331:42 - so in our previous tutorial we also discussed
1331:45 - that when we call this max priority queue
1331:47 - and let's say we provide a capacity of 3
1331:52 - so it would create an integer array
1331:54 - having length 4 because we are initializing this heap array
1331:57 - with length as capacity plus 1
1332:00 - as we are not using the zeroth index
1332:03 - of this heap array
1332:05 - and we start inserting from index 1
1332:07 - therefore here you can see the initial capacity
1332:10 - of this heap array is 3
1332:15 - so here heap.length is 4
1332:18 - so here you can see currently there are no elements into this heap array
1332:22 - so the value of n is 0
1332:24 - which we already discussed in our previous tutorial
1332:29 - also friends in our previous tutorial we actually saw a demonstration
1332:33 - of how we can insert few elements in max heap
1332:36 - so friends we will insert the same elements into this heap array
1332:40 - and we will see the demonstration of this code step by step
1332:42 - so let's say first we insert a value as 4
1332:51 - so the insert method will be called
1332:53 - and the value which we want to insert is 4
1332:56 - so x will become 4
1333:00 - moving ahead
1333:02 - so from then we provide a if check
1333:05 - that whether n is equal to heap.length minus 1 or not
1333:09 - so here you can see heap.length is 4
1333:12 - and if we do a minus 1 we get 3
1333:16 - so here we are simply checking that value of n is equal to 3 or not
1333:21 - because if value of n is equal to 3
1333:24 - then we know that we have utilized all the capacity of this heap array
1333:29 - and there is no more additional space left to insert the value 4
1333:35 - so here you can see currently value of n is 0
1333:38 - and it is not equal to heap.length minus 1
1333:42 - which is 3
1333:44 - so the condition in if block comes out to be false
1333:49 - in the next step as we are inserting 4 into this heap array
1333:54 - first we will increment the size of this max priority cube by 1
1333:59 - that we are about to insert one element into this max priority cube
1334:06 - also friends as we are not utilizing the index 0
1334:09 - so what we will do?
1334:12 - we will simply insert x at index 1
1334:15 - so it would look something like this
1334:18 - so we are simply assigning the value of x to heap at index 1
1334:23 - because value of n is 1
1334:25 - so 4 is inserted
1334:27 - also friends we discussed that whenever we insert any value in a max heap
1334:32 - we then perform a bottom of reepify
1334:36 - which we also called as swim
1334:38 - so here now we will actually call a method swim
1334:42 - by passing in the value stored in n which is 1
1334:49 - so here swim method will be called
1334:54 - and here you can see that as we are passing the value of n as 1
1334:59 - so k will become 1
1335:00 - so friends then in swim method we actually provide a while loop
1335:08 - so what we do in this while loop?
1335:11 - we simply check the newly inserted value with its parent
1335:15 - and as it is a max priority cube
1335:18 - we simply check that its value is lesser than or greater than to its parent
1335:23 - and if it is greater than its parent then we simply swap them
1335:27 - and if it is lesser than its parent
1335:30 - then nothing
1335:32 - so this is the condition we actually provide into this while loop
1335:36 - so the first condition we provide is k should be greater than 1
1335:40 - because here you can see k value is 1
1335:43 - and here you can see that as there is only one element into this heap array
1335:48 - there is no parent to index 1 because it is the root of the heap
1335:53 - so the condition in while block comes out to be false
1336:01 - so 4 is inserted into this heap array
1336:04 - and it is placed at its correct position
1336:09 - now lets say we insert 5
1336:12 - so x becomes 5
1336:16 - we check that whether n is equal to heap dot length minus 1 or not
1336:21 - so n is not equal to 3
1336:24 - because heap dot length is 4
1336:26 - and 4 minus 1 is 3
1336:28 - so the condition in if block comes out to be false
1336:34 - now as we are inserting 5 we will first increment the value of n by 1
1336:40 - so n becomes 2
1336:44 - so as we have incremented n by 1
1336:47 - we will simply insert 5 at index 2
1336:50 - by simply assigning the value of x to heap at index 2
1336:59 - moving ahead
1337:02 - so for an as you have inserted 5
1337:05 - now we simply perform the bottom of reefify by calling this swim method
1337:10 - and inside this swim we will simply pass the value of n
1337:14 - so value of k becomes 2 because n is 2
1337:25 - now friends here you can see as we discussed in our previous tutorial
1337:30 - that 4 is at root and 1 of its left child is 5
1337:35 - so friends as we have inserted 5
1337:38 - in while loop we will simply check that whether value of k is greater than 1 or not
1337:41 - so here you can see k is greater than 1 because value of k is 2
1337:46 - and in our previous tutorial we also discussed
1337:50 - that in order to calculate the parent of any index
1337:54 - we simply do k by 2
1337:56 - and why we are doing this k by 2
1337:59 - because we need to compare this newly inserted value with its parent
1338:04 - so here you can see value of k is 2
1338:08 - if we do k by 2 we will get 1
1338:12 - which signifies that 4 is parent to 5
1338:16 - and then we will simply check that whether value at parent is less than its children or not
1338:23 - so friends as it is a max priority queue
1338:26 - k by 2 is nothing but 1 and the value at index 1 is 4
1338:32 - which is parent to 5
1338:35 - so we will simply compare these 2 values
1338:38 - and we will simply check that parent is less than its children or not
1338:43 - so here you can see 4 is less than 5
1338:47 - therefore it is breaking the heap order property
1338:50 - so the condition in while block comes out to be true
1338:54 - and in order to maintain this heap order property
1338:57 - we will simply swap these 2 values
1339:00 - so it would look something like this
1339:02 - that first we will assign 5 to this temporary variable
1339:09 - and then we will simply assign the value at index k by 2 to k
1339:15 - which is nothing but value at index 1 to value at index 2
1339:20 - so it would look something like this
1339:24 - moving ahead
1339:26 - and then we will simply assign the value of 5
1339:29 - to the index k by 2 which is 1
1339:32 - so it would look something like this
1339:37 - and as we have swapped these 2 values
1339:40 - now we will traverse to 5 again
1339:43 - in order to check that whether it is at its correct position or not
1339:47 - because then we again compare with its parent
1339:50 - so in order to reach to this index again
1339:53 - we simply assign the value of k by 2 to k
1339:56 - which is nothing but traversing k to its parent
1339:59 - by assigning k by 2 to k
1340:02 - so here you can see the value of k by 2 is 1
1340:05 - so k will become 1
1340:12 - and then again in while loop we will check whether k is greater than 1 or not
1340:17 - so here you can see that 5 is at its correct position
1340:20 - because among these 2 values 5 is the largest value
1340:22 - and it is placed at the top of this heap
1340:26 - which is nothing but at index 1
1340:29 - therefore the condition in while loop comes out to be false
1340:37 - now let's say we insert 2
1340:40 - so x becomes 2
1340:44 - we check whether 2 is equal to heap.length-1 or not
1340:49 - so heap.length is 4
1340:52 - and heap.length-1 becomes 3
1340:55 - so n is not equal to 3
1340:57 - so the condition in if block comes out to be false
1341:02 - and as we are inserting 2
1341:04 - we will simply increment the value of n by 1
1341:07 - so n becomes 3
1341:11 - and to the third index of this heap array
1341:14 - we will simply assign the value as 2
1341:19 - and then we will simply perform
1341:21 - the bottom of rep5 at this index
1341:24 - which is nothing but 3
1341:29 - so k becomes 3
1341:33 - now k is greater than 1 which is true
1341:37 - now we have to compare 2 with its parent
1341:40 - so we simply do k by 2
1341:43 - so if we do k by 2
1341:45 - it becomes 1
1341:47 - because 3 by 2 will give us 1.5
1341:49 - and as we are using it as integer
1341:52 - it will be round off to 1
1341:55 - so here parent is at index 1
1341:59 - and child is at index k which is 3
1342:02 - so we will simply compare these 2 values
1342:05 - and we will simply check that parent value is less than the child value or not
1342:10 - so here because if 5 is greater than 2
1342:13 - therefore the condition in this while block comes out to be false
1342:19 - so now let's say we insert 6
1342:22 - so x becomes 6
1342:26 - and now here you can see value of n is 3
1342:29 - and heap.length is 4
1342:32 - if we do minus 1
1342:34 - it becomes 3
1342:36 - and here you can see 3 is equal to 3
1342:38 - so friends here it signifies
1342:40 - that parent value of n is 3
1342:42 - and parent value of n is 3
1342:44 - and parent value of n is 3
1342:46 - and parent value of n is 3
1342:48 - that this heap array is failed completely
1342:51 - and there are no more space left to insert 6
1342:55 - so the condition in if block comes out to be true
1342:59 - so what we do is
1343:03 - so we will simply call resize method
1343:06 - by passing in a value which is twice of heap.length
1343:10 - which is nothing but 8
1343:12 - so friends in our array section we actually discussed how we can resize an array in java
1343:18 - so you can watch that tutorial to understand more about this resize method
1343:22 - so what this method actually does is
1343:24 - it will resize this heap array to a size double of its current length
1343:31 - so once this method gets executed
1343:34 - it will look something like this
1343:36 - that heap array has now length of 8
1343:40 - which is double of its previous length
1343:43 - so we actually perform this resize method because
1343:46 - we want to insert more elements into this heap array
1343:51 - so then we will simply increment n by 1
1343:58 - and now we will simply insert the value x at index 4
1344:03 - so it would look something like this
1344:08 - and then we will simply perform bottom up reepify at index 4
1344:13 - so k becomes 4
1344:18 - now here in the while block k is greater than 1 which is true
1344:23 - and now we have to compare this newly inserted value with its parent
1344:28 - that whether it is satisfying the heap order property or not
1344:31 - so in order to know the parent of 6
1344:35 - we take its index which is at 4
1344:38 - and we divide it by 2
1344:40 - so k by 2 becomes
1344:43 - 2
1344:45 - so here the value at index 2 which is 4
1344:48 - is actually parent to value at index 4 which is 6
1344:53 - so now we will simply compare these two values
1344:56 - and we will check that whether value at parent is less than the valued child or not
1345:03 - so here you can see 4 is less than 6
1345:06 - therefore it is not satisfying the heap order property
1345:10 - so the condition in while block comes out to be true
1345:15 - so friends now we know that we have to swap these two values
1345:19 - so we will simply perform swap
1345:23 - we will assign 6 to a temporary variable
1345:29 - and then we will assign the value at index k by 2 to k
1345:34 - which is nothing but assigning value 4 at index 4
1345:38 - so it would look something like this
1345:43 - and finally whatever the value is stored in temp
1345:46 - we are simply assigning it to heap at index 2
1345:52 - and also friends in our previous tutorial we discussed
1345:55 - that whenever we insert a new value in a heap
1345:59 - we keep shifting it up till it reaches to its correct position
1346:03 - so here you can see that we have swapped 6 and 4
1346:06 - and 6 is at index 2
1346:09 - so friends after we perform this swap
1346:12 - 6 is at index 2
1346:15 - so friends after we perform this swap
1346:18 - we simply traverse to this index
1346:21 - by assigning a value of k by 2 to k
1346:24 - so here you can see k by 2 is 2
1346:27 - and if you assign it to k it becomes 2
1346:36 - and also here you can see k is 2
1346:39 - which is greater than 1
1346:41 - which means that there is a parent to 6
1346:44 - so we need to compare it with its parent
1346:47 - so here its parent is at k by 2
1346:50 - if we do k by 2
1346:52 - we get the value 1
1346:54 - so the value at index 1 is parent to 6
1346:58 - so we will simply compare 5
1347:01 - with 6
1347:02 - and we will check whether 5 is less than 6 or not
1347:06 - so here you can see 5 is less than 6
1347:09 - so the condition in while block comes out to be true
1347:13 - and as we are inside this while loop
1347:15 - we will simply swap these two values
1347:18 - using this temporary variable
1347:22 - so at first step we will simply assign
1347:25 - the value at index 2 to 10th
1347:27 - and then we will assign the value at index 1 to index 2
1347:34 - so it becomes 5
1347:37 - and finally we will assign the value
1347:40 - stored in this temporary variable to index 1
1347:47 - and after we perform this swap
1347:50 - we will simply traverse to its parent
1347:52 - by assigning k by 2 to k
1347:55 - so k by 2 is 1
1347:57 - so k will become 1
1348:03 - now as k is equal to 1
1348:05 - it is not greater than 1
1348:07 - so therefore we know that 6 is now at its correct position
1348:10 - because among these 4 values
1348:12 - 6 is the largest value
1348:14 - and we know that in max heap
1348:16 - the value at index 1 is the maximum
1348:19 - among the other values
1348:21 - so the condition in while block comes out to be false
1348:25 - now let's say we insert 1
1348:30 - so x becomes 1
1348:34 - so here value of n is 4
1348:38 - and it is not equal to heap dot length minus 1 which is 7
1348:42 - so the condition in if block comes out to be false
1348:46 - now as we are inserting 1
1348:49 - we will first increment the value of n by 1
1348:55 - and at index 5
1348:58 - we will simply assign the value which we want to insert
1349:01 - so it looks something like this
1349:06 - and then we will simply perform the bottom up
1349:09 - reepify at index 5
1349:13 - so k becomes 5
1349:18 - and here k is greater than 1
1349:20 - so here as we have inserted 1
1349:22 - now we will compare this value
1349:24 - with its parent
1349:26 - so we know that this value is at index 5
1349:29 - so if we do k by 2
1349:32 - we will reach to its parent
1349:34 - so 5 by 2 will give us 2.5
1349:38 - and as we are taking it as integer it will round off to 2
1349:42 - so k by 2 becomes 2
1349:45 - so if you see
1349:47 - the value at index k by 2 which is 2 is 5
1349:51 - so here we are simply comparing 5
1349:55 - because we know that 1 is child of 5
1349:58 - so here we are simply checking that whether value at parent
1350:02 - is less than child or not
1350:04 - so 5 is greater than 1
1350:06 - therefore condition in while block comes out to be false
1350:13 - and by this we mean that 1 is at its correct position
1350:16 - because it is child to 5
1350:18 - and 5 value is greater than 1
1350:21 - which satisfies the heap order property
1350:25 - now let's say we want to insert 3
1350:29 - so x becomes 3
1350:32 - the condition in if block comes out to be false
1350:35 - because 5 is not equal to 7
1350:39 - we will increment the value of n by 1
1350:42 - as we are inserting 3 now
1350:46 - so n becomes 6
1350:48 - so at index 6 we will simply insert 3
1350:54 - and then we will simply perform the bottom up
1350:58 - reepify at index 6
1351:00 - so we will call swim method and pass the value as 6
1351:05 - so value of k will become 6
1351:11 - now here whatever the value we inserted at index 6
1351:15 - we will simply compare it with its parent
1351:18 - that whether it is less than its parent or not
1351:21 - so here k is greater than 1
1351:22 - because value of k is 6
1351:25 - so first we will evaluate the parent of 3
1351:28 - so we will take its index
1351:30 - we will divide it by 2
1351:32 - so k by 2 becomes 3
1351:34 - so the value at third index is 2
1351:38 - so 2 is parent of 3
1351:40 - so we will simply compare these 2 values
1351:43 - and we will check whether parent value is less than child or not
1351:47 - so here you can see 2 is less than 3
1351:49 - so the condition in while block comes out to be true
1351:53 - so once the condition comes out to be true
1351:56 - in the while block we simply swap these 2 values
1351:59 - so it would look something like this
1352:02 - we will assign 3 to this temporary variable
1352:08 - then we simply assign the value at index 3
1352:11 - to value at index 6
1352:13 - by simply assigning the value at index k by 2 to k
1352:19 - so it becomes 2
1352:23 - and finally we simply assign the value 3
1352:26 - to value at index 3
1352:29 - so it becomes 3
1352:33 - so friend as the value of k was 6
1352:35 - and we swapped 3 and 2
1352:38 - so 3 reached to its parent
1352:40 - so now we will simply assign the value of k by 2 to k
1352:44 - because we need to again compare 3 with its parent
1352:47 - so once we do k by 2 to k
1352:50 - k becomes 3
1352:52 - and in while block we again check whether k is greater than 1 or not
1353:02 - so k is greater than 1
1353:04 - and we will simply compare 3 with its parent
1353:08 - so first we will evaluate its parent by taking its index which is 3
1353:13 - dividing it by 2
1353:15 - which will give us 1.5
1353:17 - and as we are taking it as integer
1353:19 - it will round off to 1
1353:21 - so the value of heap at index k by 2 is nothing but value at index 1
1353:28 - because 6 is parent to 3
1353:30 - and we will simply check whether 6 is less than 3 or not
1353:34 - so here you can see 6 is greater than 3
1353:36 - so the condition in while block comes out to be false
1353:39 - which means that 6 is at its correct position
1353:42 - and also the 3 which is at its correct position
1353:45 - so friends here we saw the demonstration of how to insert a value in a max heap
1353:55 - and we saw the demonstration step by step
1353:58 - we also saw that how we can perform bottom up reepify
1354:02 - in case the heap order property is not being satisfied by inserting a new element
1354:08 - so friends in our next tutorial we will code this insert method
1354:12 - and we will test its working
1354:14 - I hope you like this video thanks have a nice day
1354:22 - hello friends
1354:24 - in our previous tutorial we actually discussed
1354:27 - that how we can insert a value in max priority queue
1354:31 - so in this tutorial we will actually code the insert method
1354:35 - which will perform the insertion into this max priority queue
1354:39 - so friends in our previous tutorial we actually created one class
1354:43 - in a max pq
1354:45 - which had an integer array which was nothing but our heap
1354:49 - and we provided a constructor which took the initial capacity of this max priority queue
1354:55 - we also provided 2 methods
1354:58 - isEmpty and size
1355:00 - so isEmpty tells us whether max priority queue is empty or not
1355:05 - and size method will tell us that how many elements are there into this max priority queue
1355:11 - so in this tutorial we will actually code about the insertion in this max priority queue
1355:19 - so we will create a method as public void insert
1355:28 - so this insert method
1355:32 - will take in a value which we want to insert
1355:36 - so here I am taking the argument as x
1355:40 - so inside this insert method first we will check
1355:46 - that whether this heap array can accommodate a new value or not
1355:50 - so we will simply check that whether value of n
1355:55 - is equal to heap.length
1355:59 - minus 1 or not
1356:02 - so if the value of n which is the size of this max priority queue
1356:06 - is equal to
1356:08 - heap.length minus 1
1356:10 - it means the integer array failed completely
1356:13 - and there is no space to insert the new element
1356:17 - so if this condition comes out to be true
1356:20 - we simply
1356:23 - resize this array dynamically
1356:26 - and as initial length is heap.length
1356:29 - we will simply resize this array
1356:32 - to twice of its current length
1356:34 - so we will simply pass 2 into
1356:38 - heap.length
1356:41 - so then we will create a method resize
1356:51 - so this resize method
1356:53 - will take the new capacity
1356:57 - of the array
1357:01 - so here if the if condition comes out to be true
1357:04 - it means that heap array has failed completely
1357:06 - so into the resize method what we do
1357:09 - we first create a new array
1357:12 - with whatever the capacity we pass to this resize method
1357:15 - after creating this new array
1357:18 - we simply copy each and every element
1357:20 - from this heap to this temporary array
1357:23 - and then we finally reassign this heap
1357:26 - to this newly created array
1357:30 - so here first we will create
1357:33 - a new temporary array
1357:35 - whose length would be
1357:38 - the capacity
1357:41 - which we have passed
1357:44 - after creating this temporary integer array
1357:47 - we will copy
1357:50 - each and every element
1357:53 - from this heap to this temporary array
1357:58 - so we will start from
1358:01 - 0
1358:02 - 0
1358:08 - and we will traverse till heap.length
1358:17 - and inside this for loop
1358:19 - we will simply copy
1358:22 - the value
1358:24 - at particular index
1358:26 - i
1358:28 - to this temporary array
1358:30 - and after copying the contents
1358:33 - of this integer array
1358:38 - we will simply reassign
1358:42 - temp to heap
1358:44 - so now heap will point to an array
1358:46 - which is of length twice
1358:48 - of its current length
1358:50 - so after the resize method gets executed
1358:53 - the integer array heap
1358:55 - will now have more spaces
1358:57 - to insert new elements
1358:59 - so here after if block
1359:02 - the first thing we do is
1359:04 - as we are inserting a new element
1359:06 - we will increment the size of this max priority queue
1359:09 - by 1
1359:11 - and then we will simply insert
1359:13 - the value x
1359:15 - into this heap array
1359:18 - so we will simply assign
1359:20 - the value of x
1359:22 - at index n
1359:26 - and after this insertion
1359:27 - we know that now we have to perform
1359:29 - bottom of vpy
1359:31 - by creating
1359:33 - a new method swim
1359:35 - and by passing it
1359:36 - the value n
1359:38 - because now we have to perform
1359:40 - the bottom of vpy at index n
1359:42 - so here we will create
1359:44 - a new private method
1359:47 - swim
1359:55 - which will take the argument
1359:57 - that here this new index
1359:59 - have been inserted
1360:01 - so inside this swim method
1360:04 - we will provide a while loop
1360:08 - because in this while loop we will simply
1360:11 - compare this newly inserted value
1360:13 - to its parent
1360:15 - and we will check that whether parent is less than
1360:17 - this newly inserted value or not
1360:20 - so the first condition we provide is
1360:22 - whether k is greater than 1 or not
1360:25 - because if k is equal to 1
1360:26 - then we know that
1360:28 - currently heap has only one element
1360:30 - and if value of k is greater than 1
1360:32 - then we know that there are more than
1360:34 - 1 elements into this heap
1360:38 - so then we will compare
1360:41 - the value at parent index
1360:43 - which is k by 2
1360:45 - with value at kth index
1360:50 - and if both the condition comes out to be true
1360:53 - we simply swap these two values
1360:55 - so here
1361:03 - so using this temporary variable
1361:05 - we will swap these two values
1361:24 - and after we perform this swap
1361:31 - we will simply traverse
1361:33 - to its parent
1361:35 - by assigning k by 2 to k
1361:41 - because we need to
1361:45 - continue
1361:48 - shifting up
1361:52 - till new value
1361:55 - inserted
1361:57 - is at
1361:59 - correct position
1362:04 - that means whatever the value we inserted
1362:06 - is at its correct position
1362:08 - so that the heap order property
1362:10 - of heap is satisfied
1362:14 - so friend this is how we actually insert
1362:16 - a new value
1362:18 - into the max priority queue
1362:21 - now in the main method
1362:23 - let's test it working
1362:26 - so I will just remove this
1362:30 - so let's say the initial capacity
1362:32 - of this max priority queue is 3
1362:35 - so here we will insert few values
1362:38 - which we discussed in our previous slide
1362:42 - so first we will insert
1362:46 - 4
1362:52 - then we will insert
1362:55 - 5
1362:58 - then we will insert 6
1363:00 - then we will insert 1
1363:02 - and then we will insert 3
1363:11 - and then we will simply print
1363:18 - the size of the priority queue
1363:20 - the size of the priority queue
1363:22 - if I run the code now
1363:30 - so here you can see the size it printed is 6
1363:33 - because we have inserted 6 elements
1363:38 - and also if you print this heap array
1363:41 - so here
1363:45 - I will create one method as
1363:49 - print max heap
1363:56 - so inside this print max heap method
1363:59 - I am just excluding the edge cases
1364:01 - so I am simply providing a for loop
1364:05 - which will iterate
1364:07 - from i equal to 1
1364:10 - because into this heap array
1364:12 - the value at 0th index
1364:14 - is empty
1364:16 - so we are starting from 1
1364:18 - and we will simply traverse
1364:20 - i to a value n
1364:22 - which is nothing but the size of the max priority queue
1364:28 - and inside this for loop
1364:30 - we will simply print
1364:37 - the value at i at index of this heap
1364:45 - and in the main method
1364:47 - we will simply call print max heap
1364:52 - and if I run the code now
1364:58 - you see it printed 6 5 3 4 1 2
1365:02 - which is the same output which we discussed
1365:05 - in our previous tutorial
1365:07 - and here you can see that as it is the max priority queue
1365:11 - the value set which is largest among the other values
1365:14 - is at index 1
1365:16 - so in this tutorial
1365:18 - we actually discussed
1365:20 - how we can insert a value
1365:22 - into this max priority queue
1365:24 - in our upcoming tutorial
1365:26 - we will see how we can delete
1365:28 - a particular element from the max priority queue
1365:31 - I hope you like this video
1365:33 - thanks have a nice day
1365:36 - hello everyone
1365:38 - so in this video we are going to discuss
1365:40 - top down reepify
1365:42 - in max heap
1365:44 - so this technique is also called as sync
1365:49 - so in this technique
1365:51 - we are simply doing the reepify
1365:53 - in one of our previous video we saw the bottom up reepify
1365:57 - and in this video we will be looking into top down reepify
1366:01 - so when we are inserting an element in a binary heap
1366:05 - we usually do bottom up reepify
1366:08 - and when we are deleting the max element from the heap
1366:11 - we usually do top down reepify
1366:21 - so friends here you can see that we are given with a max binary heap
1366:25 - now a max binary heap as we already discussed
1366:28 - in our previous videos
1366:30 - that it's a complete binary tree
1366:32 - in which each node value is greater than equal to
1366:35 - the values of its children
1366:38 - so for example 9 is greater than 3 and 6
1366:41 - 3 is greater than 2 and 1
1366:43 - 6 is greater than 5 and 4
1366:46 - so this is the one of the property
1366:48 - which max binary heap satisfies
1366:51 - the other thing is it should be complete binary tree
1366:56 - as we already discussed that a complete binary tree
1366:59 - is a binary tree where all levels are completely filled
1367:03 - so for example here you can see there are three levels
1367:06 - 1, 2, 3
1367:08 - so here all the levels are completely filled
1367:11 - except the last level
1367:13 - and last level has nodes in such a way that
1367:16 - left side is never empty
1367:18 - so here all the levels of a complete binary tree
1367:21 - should be filled
1367:23 - so here you can see this level is filled
1367:25 - in the second level it can have only two children
1367:28 - so this level is also filled
1367:30 - and in the last level
1367:32 - this side is not filled
1367:34 - so except the last level
1367:37 - should be filled
1367:39 - and the node should be filled
1367:41 - in such a way that left side is never empty
1367:45 - so here this is the complete binary tree
1367:47 - because the elements are filled
1367:49 - from the left side
1367:51 - like this
1367:53 - but here you can see
1367:55 - that this is the incomplete binary tree because
1367:57 - all the levels are filled
1367:59 - except the last level
1368:01 - but this is not a complete binary tree because
1368:04 - the left side is empty
1368:06 - because there could be one element
1368:08 - coming up here
1368:10 - so the insertion of nodes
1368:12 - or the element should be such a way
1368:14 - that it should be from the left side
1368:16 - and the left side is never empty
1368:19 - so if suppose here could have been one more element
1368:22 - let's say 6
1368:24 - so this is also a complete binary tree because
1368:27 - all the levels are filled
1368:29 - and now next element would be inserted
1368:31 - from here
1368:33 - from the left side
1368:35 - and if any of the element is not filled
1368:38 - from the left side
1368:40 - then this would be incomplete binary tree
1368:43 - so here you can see
1368:45 - when do we actually require top down re-epify
1368:48 - so when we delete an element from heap
1368:51 - there may be a case
1368:53 - that it may not satisfy the heap properties
1368:56 - so deleting an element
1368:58 - we mean
1369:03 - delete max
1369:05 - from the max binary heap
1369:11 - and delete min
1369:13 - from the min binary heap
1369:15 - so when we delete the max element from heap
1369:18 - let's say if we want to remove the max element
1369:21 - which is at the root
1369:23 - at index 1
1369:25 - so if we want to remove this element
1369:28 - after its removal
1369:30 - there arise a problem
1369:32 - that this max heap
1369:33 - may not satisfy the heap properties
1369:36 - thus we perform top down re-epify technique
1369:39 - in which we adjust the locations of the element
1369:42 - to satisfy the heap property
1369:44 - so now let's move ahead and see
1369:46 - how we can perform this technique
1369:51 - so let's say we are given with this max binary heap
1369:54 - where the elements are stored
1369:56 - in an array
1369:58 - starting from index 1
1370:00 - which we have already discussed in our previous videos
1370:03 - now let's say when we call delete max
1370:06 - so we want to remove this element 9
1370:11 - but if we directly remove this element 9
1370:14 - the heap property of this max heap will not get satisfy
1370:19 - so what do we do is
1370:21 - before removing 9
1370:23 - we simply store its value
1370:26 - in some variable let's say max
1370:28 - now after storing the value because
1370:31 - we need to return this value
1370:33 - from the delete max
1370:35 - so we are storing it in a max variable
1370:40 - now after getting its value
1370:42 - what we do is
1370:44 - we simply take the last element which is filled
1370:47 - in the max heap
1370:49 - and we simply swap both the elements
1370:52 - so here 9 will be swapped by 4
1370:56 - so 4 comes here
1370:58 - and 9 comes here
1371:00 - now after this swap
1371:02 - we can easily remove 9
1371:04 - because this is the last element
1371:07 - so 9 gets removed
1371:09 - but as we swapped it with the 4
1371:12 - the heap order property is not getting satisfied
1371:15 - because in the max heap
1371:17 - the root element
1371:19 - should be greater than or equal to
1371:21 - the values of its children
1371:23 - so 4 is greater than 3
1371:25 - but it is not greater than 6
1371:27 - so therefore heap order property is breaking here
1371:30 - so now the third step we apply is
1371:33 - we do top down reepify
1371:42 - now in this technique what we do is
1371:44 - as the root element
1371:46 - or the parent element should be greater than
1371:49 - or equal to the values of its children
1371:52 - the heap order property is not getting satisfied
1371:55 - at this location
1371:57 - so the children
1371:59 - x1 which is 2 and 3
1372:01 - we will first compare
1372:03 - 3 and 6 together
1372:06 - and we will find which is the max element
1372:09 - among these two values
1372:12 - so we will compare 3 and 6
1372:16 - so 6 is greater than 3
1372:19 - it means
1372:21 - now we need to compare the parent
1372:23 - value with 6
1372:25 - as parent value should be greater than
1372:27 - both the values of its children
1372:30 - we are simply comparing the parent element
1372:32 - with the max of
1372:34 - the values of its children
1372:36 - so here we are not comparing 4 with 3
1372:39 - because we have already compared 3 with 6
1372:43 - and as 6 is greater than 3
1372:45 - now we will simply compare 4 with 6
1372:49 - so here you can see
1372:53 - 6 is greater than 4
1372:54 - it means parent value is smaller than
1372:58 - the value of its children
1373:00 - therefore what we do is
1373:03 - we simply perform a shift down
1373:06 - which is top down
1373:08 - or we can also call sink
1373:13 - what do we do in this technique is
1373:15 - now we simply swap 6 with 4
1373:18 - so 6 comes here
1373:20 - and 4 goes here
1373:22 - so here you can see
1373:25 - now the parent value is greater than
1373:28 - both of its children
1373:30 - so after doing this
1373:32 - what we do is
1373:34 - as we perform
1373:36 - the shift down
1373:38 - the parent element
1373:40 - is at its correct position
1373:42 - and then we simply traverse to this position
1373:45 - and then we perform the same steps again
1373:48 - because there could be a possibility
1373:50 - that 4 may not still satisfy the heap order property
1373:54 - so what do we do is
1374:00 - when reaching 4 we see that it has only 1 children
1374:04 - therefore it doesn't have the other children
1374:07 - so we can directly compare 4 with 5
1374:11 - so here 5 is greater than 4
1374:13 - it means the heap order property currently is not getting satisfied
1374:17 - so we simply do a shift down
1374:21 - so 5 comes here and 4 comes here
1374:25 - and after performing shift down we reach here
1374:28 - and now you can see it doesn't have any children
1374:32 - it means 5 is placed at its correct position
1374:36 - 6 is placed at its correct position
1374:39 - and 4 is also placed at its correct position
1374:42 - so now you can see that maxi property is getting satisfied
1374:46 - and all the elements are at its correct position
1374:49 - and at the end we simply return the value 9
1374:54 - now let's see one more example
1374:59 - let's say we are given with this max heap
1375:02 - where all the levels are filled completely
1375:05 - except the last level
1375:07 - and it is also getting filled from the left hand side
1375:10 - now let's say we call delete max
1375:13 - so the first step we do is
1375:15 - we simply store value 10
1375:19 - in the max variable
1375:21 - the second step we do is
1375:24 - we take the last element of the max heap
1375:27 - and we simply swap it with the root element
1375:34 - so 3 comes here, 10 comes here
1375:37 - so after we perform this swap
1375:40 - we can now easily remove this element
1375:46 - and as 10 is removed
1375:49 - one problem it has created is like
1375:52 - the heap order property may or may not get satisfied
1375:56 - so after we perform this swap
1376:00 - we are at this position
1376:02 - and we need to place the maximum value
1376:06 - among these 3 values
1376:08 - because 3 is the parent
1376:10 - 9 and 6 are its children
1376:12 - and whichever value is the greater among these 3
1376:16 - should come here
1376:18 - so here we have to compare 3 with 9
1376:19 - and 3 with 6
1376:21 - or what we do is
1376:23 - we simply compare
1376:25 - both the children's value
1376:28 - which is 9 and 6
1376:30 - and whichever value is greater
1376:32 - so here 9 is greater
1376:35 - so we simply compare 9 with 3
1376:37 - because if
1376:39 - let's say here would have been 11
1376:41 - for example
1376:43 - so if 11 is greater than 9
1376:45 - it will also be greater than 6 because
1376:47 - we have compared these 2 values already
1376:50 - so currently its 3
1376:52 - so now 9 is greater than 3
1376:55 - therefore what we do is
1376:57 - we do a shift down
1377:00 - 9 comes at this position
1377:02 - and 3 comes at this position
1377:04 - so we are doing a swap
1377:06 - and after doing the swap
1377:08 - we reach here
1377:10 - and then we try to compare this index value
1377:13 - which is 3 with its children
1377:17 - so here you can see now we simply compare
1377:19 - 1 and 2
1377:21 - and whichever value is greater among these 2
1377:24 - which is 2
1377:26 - we simply compare it with 3
1377:29 - so here you can see 3 is greater than 2
1377:32 - therefore there won't be any shift down
1377:35 - because 3 is now at its correct position
1377:38 - because it is greater than both of its children
1377:41 - so we don't do anything
1377:43 - and the process ends here
1377:45 - and this max value will be returned
1377:48 - so why we are comparing these 2 children is because
1377:51 - we need to compare parent with a greater value
1377:54 - among these 2
1377:56 - because if 3 is greater than 2
1377:58 - then 3 will also be greater than 1
1378:01 - so that's why first we compare both the children's value
1378:04 - and whichever value is greater among both the children
1378:08 - we simply compare that value with the parent's value
1378:11 - and if the parent's value in max if
1378:14 - if it is less then we do a shift down
1378:17 - and if it is more
1378:19 - like the current scenario
1378:21 - then we don't do anything
1378:23 - because 3 is at its correct position
1378:27 - now let's see one last example
1378:31 - let's say we are given with this max heap
1378:33 - currently all the heap properties are getting satisfied
1378:39 - let's say we call delete max
1378:42 - so first we store the value 9
1378:44 - then we swap this value
1378:46 - with the last value of the max heap
1378:49 - so 0 will come here
1378:51 - and 9 will come here
1378:54 - like this
1378:56 - and after doing this swap
1378:58 - we can safely remove this
1379:00 - element with value 9
1379:04 - so now here you can see
1379:06 - after this swap
1379:08 - we are starting from
1379:10 - the very root node
1379:12 - and there might be a case that heap order property
1379:15 - is not getting satisfied
1379:17 - so what do we do is
1379:19 - first we compare both its children
1379:21 - which is 3 and 6
1379:23 - and we figure out which is the max element
1379:27 - so if we compare 3 and 6
1379:29 - so 6 is greater than 3
1379:33 - so now we compare 6 with
1379:35 - its parent value
1379:37 - so 6 is greater than 0
1379:38 - so 6 is greater than 0
1379:40 - it means that whatever value
1379:43 - is at index 1
1379:45 - is not satisfying the heap order property
1379:48 - because in the max heap
1379:50 - the parent value should be greater than both of its children
1379:53 - so we do shift down
1379:56 - so 6 comes here
1379:58 - and 0 comes here
1380:00 - and then we reach here
1380:03 - now again there could be a possibility
1380:05 - that after this swap
1380:06 - this value 0 is still not satisfying the heap order property
1380:10 - so what do we do is
1380:12 - we simply compare
1380:14 - both the children first
1380:16 - and whichever is the max
1380:20 - in this case it is 5
1380:22 - so we compare 0 with 5
1380:26 - as 5 is greater than 0
1380:28 - therefore the value of children is greater than the parent
1380:31 - so it is not satisfying the heap order property
1380:34 - so we do a shift down
1380:37 - 5 comes here and 0 comes here
1380:42 - and then finally we reach here
1380:44 - and here we see
1380:46 - that it doesn't have any children
1380:48 - so therefore now 0 is at its correct position
1380:53 - 5 is at its correct position
1380:55 - and 6 is at its correct position
1380:57 - so here 6 is greater than 3 and 5
1381:00 - 5 is greater than 0 and 4
1381:02 - and at the end we simply return 9
1381:07 - so friends in this video we saw
1381:10 - that when we perform a delete max operation in a binary heap
1381:15 - there could be a possibility
1381:18 - that heap order property is not getting satisfied in a binary heap
1381:23 - therefore we do
1381:26 - top down
1381:27 - top down
1381:32 - reepify
1381:34 - which is also known as sync
1381:38 - or
1381:42 - shift
1381:44 - down
1381:46 - where we are simply shifting down the elements
1381:49 - till it reaches at its correct position
1381:52 - so friends this was all about top down reepify
1381:55 - when we perform delete max
1381:58 - in our next video we will actually see the implementation of
1382:02 - the algorithm step by step
1382:04 - I hope you must have liked this video
1382:07 - in case if you are new to my channel then please subscribe to my channel
1382:11 - and click the bell icon so that you never miss any update
1382:14 - thanks have a nice day
1382:18 - hello everyone
1382:20 - so in this video we are going to discuss
1382:22 - that how to delete the maximum element in a max heap
1382:26 - in our previous video we saw the top down reepify technique
1382:31 - when we actually deleted the maximum element from a binary max heap
1382:37 - and in our previous video we also saw that
1382:40 - a max heap is a complete binary tree
1382:43 - in which each node is greater than or equal to
1382:46 - the values of its children
1382:48 - so here you can see
1382:51 - that 9 being parent to 3 and 6
1382:54 - has values greater than both of its children
1382:57 - 3 is having value greater than both of its children
1383:00 - 6 is having value greater than both of its children
1383:04 - so its a max binary heap
1383:07 - and when we want to delete the maximum element from the max heap
1383:11 - the maximum value is usually at the top
1383:15 - which is also the root of our binary tree
1383:22 - so here max heap is usually demonstrated in the form of a binary tree
1383:27 - but the data is actually stored in the form of an array
1383:31 - where index 0 is empty
1383:35 - we usually take index 0 as empty because
1383:38 - it helps us in evaluating the children of any parent
1383:43 - we also saw the formula for evaluating the children
1383:46 - of any parent given at index i
1383:50 - which is 2i and 2i plus 1
1383:57 - so this is child 1 and this is child 2
1384:05 - so this is what we actually discussed in our previous videos as well
1384:09 - so usually we fill this array from left to right
1384:13 - level by level
1384:15 - so this is level 1
1384:17 - so 9 comes here
1384:21 - then we go to level 2
1384:24 - the first element we see is 3
1384:26 - so 3 comes here
1384:30 - 6 comes here
1384:33 - then we go to level 3
1384:36 - 2
1384:39 - 1
1384:43 - 5
1384:45 - and 4
1384:48 - so this is what we actually discussed in our previous videos as well
1384:53 - so if we mark these indexes at each element
1384:58 - it would look something like this
1385:00 - 1, 2, 3, 4, 5, 6, 7
1385:04 - now in order to access the maximum value in this max heap
1385:08 - we take the value stored at index 1
1385:11 - which is heap of 1
1385:13 - and then we perform delete operation on the top of it
1385:17 - and after we perform delete operation we also do the top down re-epify
1385:22 - so let's see it via an example which we already discussed in our previous video
1385:27 - let's suppose we are given with this max heap
1385:30 - and we want to delete the max
1385:32 - so first thing we do is we simply store
1385:35 - the maximum value which is at heap
1385:38 - max
1385:41 - and then we actually pick the last element
1385:44 - and we swap it with the element which we want to delete
1385:48 - so 9 and 4 are swapped
1385:51 - 4 comes here
1385:52 - 9 comes here
1385:54 - and then we can safely remove 9
1385:57 - but here you can see when 4 reaches here
1385:59 - it doesn't satisfy the heap order property
1386:02 - the value of 4 should be greater than both of its children
1386:05 - but here you can see 4 is greater than 3
1386:07 - but 4 is not greater than 6
1386:10 - so therefore here what we do is
1386:13 - we compare 4 with its children
1386:16 - either we compare 4 with both of its children
1386:19 - or we can first compare both the children's
1386:22 - and take the maximum value out of them
1386:24 - and then compare that maximum value with the parent's value
1386:29 - so first we compare both the children's value
1386:33 - so 6 is greater than 3
1386:38 - so as 6 is greater than 3
1386:41 - now we compare the parent's value with 6
1386:46 - so 6 is greater than 4
1386:48 - it means that heap order property is not satisfied
1386:52 - and we perform a swap
1386:54 - we take 6 here and 4 here
1386:57 - by doing shift down
1386:59 - or top down repify
1387:01 - so 6 comes here
1387:03 - 4 comes here
1387:05 - and after we do swap
1387:07 - 6 is at its correct position
1387:10 - then we actually go
1387:13 - towards one of the children
1387:15 - from which we did the swap
1387:18 - and we again perform these steps
1387:21 - as 4 doesn't have the right child
1387:25 - so we directly compare 4 with its left child value 5
1387:29 - so 5 is greater than 4
1387:32 - so therefore we do a shift down
1387:35 - 5 comes here
1387:37 - and 4 comes here
1387:39 - and here you can see
1387:41 - after we do this swap
1387:43 - 5 is at its correct position
1387:45 - then we simply traverse to 4
1387:48 - and perform the same steps again
1387:50 - but here you can see 4 doesn't have a left or a right child
1387:53 - therefore 4 is also at its correct position
1387:56 - so therefore now heap order property is satisfied by all the values
1388:01 - of this max heap
1388:03 - and at the end we simply return 9
1388:06 - so now lets see the implementation of this algorithm step by step
1388:10 - so this binary tree
1388:12 - now we will see the implementation in the form of an array
1388:16 - so lets say we have this binary heap
1388:19 - and we know that it is starting from index 1
1388:22 - which has the maximum value
1388:24 - in this binary max heap
1388:26 - the value of n
1388:28 - which is the total number of elements is
1388:30 - 7
1388:32 - we have already discussed this in our previous videos
1388:36 - so value of n is 7
1388:38 - now we call delete max
1388:43 - so the first step we do is
1388:45 - we simply store the value 9 in max
1388:48 - because at the end we need to return this value
1388:51 - and as we are going to delete the max
1388:54 - we first store it in the max variable
1388:56 - which is 9
1388:58 - so 9 is stored in max
1389:03 - and we also discussed that after we store the value
1389:06 - in max variable
1389:08 - we perform a swap with the last element
1389:11 - and the root element which we are trying to delete
1389:14 - so we pass 1 and n
1389:17 - so in the swap method we are using this temporary variable
1389:21 - and then we simply perform a normal swap
1389:24 - so we will go over this quickly
1389:26 - so a is 1 and b is 7
1389:32 - we are swapping 9 and 4 using the temp variable
1389:36 - so first we are storing 9 in temp
1389:42 - then we are storing 4
1389:44 - into heap of a which is 1
1389:49 - and at the end we are storing temp value
1389:51 - at heap of b which is 7
1389:54 - so 9 comes here
1389:58 - so after this method gets end
1390:00 - 9 is here and 4 is here
1390:03 - so now we can decrement the value of n
1390:07 - because we need to remove 9 completely
1390:10 - so total number of elements
1390:13 - should become 6 now
1390:17 - so n comes here
1390:20 - and then here we can see we are having 4 here
1390:24 - so 4 is not actually satisfying the heap order property
1390:27 - if we see the children of 4
1390:31 - it is at index 2 into i
1390:34 - and 2 into i plus 1
1390:37 - which is at index 2 and index 3
1390:42 - 4 is greater than 3 but 4 is not greater than 6
1390:46 - and in the max heap parent should be greater than both of its children
1390:51 - so these formulas we have already discussed in our previous video
1390:54 - that how we can evaluate the children of a parent
1391:01 - so now we actually do this top down reepify using this sync method
1391:07 - we pass the value of the index from where we need to do this reepify
1391:12 - so currently the index value is 1
1391:15 - so we will call sync method now
1391:18 - so the call will reach the sync method
1391:22 - so this is the sync method
1391:25 - where we have passed the value as 1
1391:28 - so k will become 1
1391:30 - which is the index from where we need to start
1391:34 - our top down reepify
1391:38 - now here we need to perform this top down reepify
1391:42 - till the heap order property satisfied or
1391:45 - there are elements left
1391:47 - such that we compare the parent with its respective children
1391:52 - so this is the condition for that
1391:54 - we are doing 2 into k less than equal to n
1391:58 - so k is at index 1
1392:00 - its children will be
1392:03 - at 2k index
1392:05 - which is 2
1392:07 - and total number of element is 6
1392:12 - so 2 is less than 6
1392:14 - it means that element 4 has some children
1392:18 - so this while loop will execute
1392:21 - and this condition comes out to be true
1392:25 - so at the first step what we do is
1392:27 - the j represents one of the children of k
1392:31 - which is given by formula 2 into k
1392:35 - where k is the index of parent
1392:37 - which you can see here
1392:39 - if we do 2 into k
1392:42 - we get index 2
1392:44 - so value of j will become 2
1392:46 - because j is one of the child of k
1392:52 - so friend when we saw the animation
1392:54 - we first compared both of the children
1392:57 - of the parent
1392:59 - and whichever was the max
1393:01 - we took that particular children
1393:03 - and compared it with the parent's value
1393:05 - so here
1393:07 - so first we check whether the parent
1393:14 - has actually a right child or not
1393:17 - because by this condition
1393:19 - parent does have a left child
1393:22 - because 2k value is less than equal to
1393:25 - the number of elements we have
1393:28 - here j less than n
1393:32 - denotes that there is also a right child
1393:34 - of this parent
1393:36 - so how we can understand this is
1393:38 - let's say if we take this example here
1393:40 - so currently this element will be removed
1393:57 - because n is pointing to 6
1393:59 - so 1, 2, 3, 4, 5, 6
1394:04 - so this is the present condition
1394:06 - so for example here k value is 1
1394:08 - which is the parent index
1394:10 - let's say k points to here
1394:12 - at 3
1394:14 - if we do 2 into k
1394:16 - we will reach to one of its children
1394:18 - so 2 into 3
1394:20 - we reach here
1394:22 - which is the child 1
1394:24 - so this condition tells us that
1394:26 - there is one child
1394:28 - to this parent
1394:31 - and here you can see
1394:33 - value of j is 2k
1394:35 - which is 6
1394:37 - if 6 is less than 6
1394:41 - which is the total number of elements
1394:44 - it means there is also one right child
1394:47 - currently 6 is not less than 6
1394:51 - therefore we are sure that there is no right child here
1394:56 - if we take k value is 3
1394:59 - so therefore this condition tells us that
1395:02 - whether we have a right child or not
1395:03 - because we need to compare both the left child value
1395:07 - we have to take one of the maximum value among those
1395:10 - and then we have to compare it with the parent's value
1395:13 - so currently value of k is 1
1395:16 - the index of its first child is at 2
1395:19 - and index of its next child is at 3
1395:22 - so 3 is less than 6
1395:25 - therefore we know that
1395:27 - for k equal to 1
1395:29 - it has both left and right children
1395:32 - so this condition is very important
1395:35 - so currently this condition comes out to be true
1395:39 - then we check whether heap of j
1395:42 - which is value 3
1395:44 - is less than heap of j plus 1 or not
1395:48 - it means we are now comparing
1395:50 - 3 and 6
1395:53 - which are actually children
1395:55 - of 4 present at index 1
1395:58 - this and this we are comparing
1396:01 - so 3 is less than 6
1396:04 - therefore this condition comes out to be true
1396:08 - now why we are incrementing j is because
1396:11 - j is actually telling
1396:13 - the position of the element
1396:15 - which is the maximum child to which
1396:18 - we need to compare with the parent
1396:22 - so j points to 3
1396:24 - which tells that 6 is the maximum child
1396:27 - value among these 2 children
1396:29 - and now whatever we want to compare
1396:31 - we need to compare parent with this value
1396:34 - at j
1396:36 - you will understand more this in next iteration
1396:41 - so now we calculate whether
1396:43 - the parent value is greater than
1396:45 - or equal to the child value or not
1396:48 - so here 4
1396:50 - is compared with 6
1396:53 - heap of k is compared with heap of j
1396:56 - so 4 is not greater than or equal to 6
1396:59 - so this condition comes out to be false
1397:03 - and if this condition comes out to be false
1397:06 - it signifies that heap order property is not getting satisfied
1397:09 - so then we perform a swap
1397:11 - between 4 and 6
1397:14 - so we will quickly go over this method
1397:17 - 6 will come here and 4 will come here
1397:25 - so 6 has come here and 4 has come here
1397:47 - so now 6 is at its correct position
1397:50 - it is parent to 3 and 4
1397:52 - and its value is greater than both of its children
1397:55 - now when we discussed that after we do shift down
1397:59 - in our previous example
1398:01 - we actually reach
1398:03 - to the position
1398:05 - which actually did this swap
1398:08 - so our next k value
1398:10 - we assign the value j
1398:12 - so k becomes 3
1398:19 - now when we did this swap
1398:21 - 6 came here and 4 came here
1398:23 - and then we moved to the next position
1398:25 - we moved to 4
1398:27 - because this 4
1398:29 - we still need to figure out whether
1398:31 - this might or might not satisfy the heap order property
1398:34 - because there are more elements left in the heap
1398:37 - so we first check whether
1398:39 - k has any left child or not
1398:42 - so if 2 into k is less than equal to n
1398:45 - which is 3 into 2
1398:47 - 6
1398:49 - it is less than equal to n
1398:51 - which is 6
1398:53 - so therefore it must have a left child
1398:55 - and what would be the index of the left child would be
1398:58 - 2 into k
1399:00 - which is 6
1399:06 - so j points to index 6
1399:09 - now we actually check with this condition whether
1399:12 - k also have a right child or not
1399:15 - so 2 into k plus 1
1399:18 - will give us the right child
1399:21 - 6 plus 1
1399:23 - 7
1399:24 - but here you can see
1399:26 - 2 into k which is j
1399:28 - and if we do plus 1 we will get the right child
1399:31 - 7 is
1399:33 - not less than
1399:34 - 6
1399:35 - therefore it doesn't have a right child
1399:38 - 3 only has a left child
1399:41 - which is 5
1399:45 - and it doesn't have a right child
1399:48 - so this condition is important
1399:50 - so this overall condition will come out to be false
1399:52 - because j is not less than n
1399:55 - j is actually equal to n
1399:59 - now we compare
1400:01 - the parent value
1400:03 - with the child value
1400:05 - because j is pointing
1400:07 - to the only child
1400:09 - of index 3
1400:13 - so 4 is less than 5
1400:16 - this condition comes out to be false
1400:19 - and then we perform a swap
1400:22 - between 4 and 5
1400:27 - so a is 3
1400:29 - and b is 6
1400:31 - we are swapping 4 and 5
1400:38 - 5 comes here
1400:42 - and 4 comes here
1400:50 - now after this swap
1400:52 - we take k
1400:54 - to its one of the child
1400:56 - from which we compared
1400:58 - so we are simply assigning j value to k
1401:02 - so k will become 6
1401:08 - now here you can see 2 into k is not less than n
1401:11 - because if we do 2 into k
1401:14 - which is 2 into 6
1401:16 - which will give us 12
1401:18 - and value of n is 6
1401:20 - therefore this condition comes out to be false
1401:23 - which also signifies that we have completely performed
1401:26 - the top down reepify
1401:28 - 6 is at its correct position
1401:32 - 5 is at its correct position
1401:35 - and 4 is also at its correct position
1401:38 - because it doesn't have any left or right children
1401:42 - so this sync method will end
1401:46 - and call will reach here
1401:50 - and this is our array
1401:52 - when we perform the sync operation
1401:56 - and after we perform sync operation
1401:59 - we can simply delete this element
1402:02 - by assigning a null value to heap n plus 1
1402:06 - n is pointing to this index which is 6
1402:09 - so n plus 1 will point to here
1402:11 - so we are making it null now
1402:14 - and here
1402:16 - as we are doing delete max
1402:18 - there will be a time when most of the elements will be deleted
1402:21 - from this heap array
1402:23 - so we are simply comparing whether n is greater than 0
1402:27 - and if n is equal to heap dot length minus 1
1402:31 - by 4
1402:33 - which is like 1 fourth of the heap dot length
1402:36 - if n is equal to that
1402:38 - then we simply resize the array
1402:40 - by half of it
1402:42 - so we will see the demonstration of this resize later
1402:46 - so currently n is greater than 0
1402:49 - but n is not equal to heap dot length which is
1402:52 - 9 minus 1 by 4
1402:56 - 8 by 4
1402:58 - 2
1403:00 - value of n is 6
1403:02 - and it is not equal to 2
1403:05 - therefore this condition comes out to be false
1403:07 - and we return
1403:09 - the maximum value which is 9
1403:11 - and we have also removed 9 from this heap
1403:16 - so friend let's suppose
1403:18 - we keep on deleting the elements like this
1403:21 - so this array will have more and more null values
1403:24 - and let's say we call delete max and we want to remove 3
1403:28 - so we have performed these steps
1403:31 - and we need to remove 3
1403:33 - and let's say we have also performed sync
1403:36 - so this will be the array
1403:39 - and now if we assign null
1403:41 - to the heap of n plus 1
1403:43 - as we want to remove 3
1403:45 - this will become null
1403:47 - so in this case we are simply seeing the condition
1403:52 - that this if block comes out to be true
1403:55 - let's say we keep on removing the elements
1403:58 - so there will be null values in the array
1404:01 - so n is greater than 0
1404:03 - and n is actually equal to heap dot length minus 1
1404:07 - divided by 4
1404:09 - so heap dot length is 9
1404:12 - minus 1 by 4
1404:15 - which will give us 8 by 4
1404:17 - 2
1404:19 - and value of n is equal to 2
1404:22 - this means both the conditions are true
1404:26 - so now here what we do is
1404:28 - we call the resize method
1404:30 - which we have already seen in one of our previous video
1404:34 - where we are simply providing
1404:36 - the new length of our heap
1404:39 - where we are simply saying create a new heap
1404:42 - of half of its current length
1404:44 - which is 9 by 2
1404:47 - which gives out to be 4
1404:49 - so we are removing this additional space
1404:52 - which we have occupied
1404:53 - we are freeing it up
1404:54 - and we are creating a new array
1404:56 - which has the size
1404:58 - half of the current heap's length
1405:01 - so when this method will get executed
1405:04 - our heap array will become something like this
1405:08 - that we have resized the heap
1405:11 - to heap dot length
1405:13 - by 2
1405:15 - which is 4
1405:17 - so we have removed the unwanted occupied space
1405:21 - so this resize method we have already discussed
1405:24 - in one of our previous video
1405:26 - you can watch that video
1405:28 - and at the end we simply return 3
1405:31 - so friend this was all about
1405:33 - that how we can delete the maximum element
1405:35 - in a max heap
1405:37 - using delete max method
1405:39 - we saw the implementation of delete max
1405:41 - and also the top down reepify method
1405:44 - which is sync
1405:46 - I hope you must have liked this video
1405:48 - in case if you are new to my channel
1405:50 - then please subscribe to my channel
1405:52 - and click the bell icon so that you never miss any update
1405:55 - thanks have a nice day
1406:00 - Hello friends
1406:02 - welcome to my new data structures and algorithms
1406:05 - in java tutorial series video
1406:08 - friends in this tutorial we will discuss
1406:11 - linear search algorithm in java
1406:17 - so friends here we are given an array
1406:20 - of let's say n elements
1406:22 - and we are given an element x
1406:24 - which we want to search into this array
1406:28 - so below you can see the algorithm
1406:30 - to search for an element x
1406:32 - into this array
1406:34 - so this search method takes in the array
1406:36 - into which we want to search an element
1406:38 - here we also pass the value of n
1406:41 - which is nothing but the number of elements
1406:43 - in an array
1406:45 - and we also pass the value of x
1406:47 - which we want to search into this array
1406:51 - so let's suppose if we are given this array
1406:53 - which has 7 elements
1406:55 - and we want to search an element x
1406:57 - having the value as 10
1407:00 - so let's see the demonstration of this algorithm step by step
1407:07 - so here you can see the number of elements into this array is 7
1407:13 - and the value which you want to search is denoted by x
1407:16 - which is 10
1407:18 - moving ahead
1407:22 - so friends how this algorithm works is
1407:25 - is we start from the leftmost element of the array
1407:28 - and one by one we will compare x
1407:31 - with each and every element of array
1407:34 - so here if x matches to any of the elements
1407:37 - then we simply return the index of array
1407:41 - and if x doesn't match with any of the elements in the array
1407:44 - we simply return minus 1
1407:48 - so here in order to compare x with each and every element of this array
1407:52 - we provide a for loop
1407:55 - which basically start from the leftmost element
1407:58 - and traverse till the last index of the array
1408:03 - so here in this for loop we are iterating i from 0
1408:05 - to a value less than n which is nothing but 7
1408:09 - so i will travel from 0 to less than n which is 6
1408:15 - and then we will compare each and every element of array with x
1408:21 - so at the start of our loop
1408:23 - i become 0
1408:27 - so this i is nothing but the index value of the array
1408:30 - so we will start from the leftmost element
1408:35 - and the for loop will provide a condition that value at index i
1408:39 - is equal to x or not
1408:41 - so here you can see
1408:43 - the value at index 0 is 5
1408:46 - and 5 is not equal to 10
1408:49 - therefore the condition in if block comes out to be false
1408:56 - so here we are incrementing i by 1
1408:58 - so i becomes 1
1409:05 - so now in the if block we are again comparing that value at i at index
1409:09 - is equal to x or not
1409:11 - so value of i is 1
1409:13 - and if we take the value at index 1 is 1
1409:17 - and if we compare it with x then 1 is not equal to 10
1409:21 - so the condition in if block comes out to be false
1409:27 - so after the increment now i will become 2
1409:29 - and we will use this i to point to the second index of the array
1409:40 - and the if block will again check
1409:43 - that the value of array at i at index is equal to x or not
1409:48 - so here you can see
1409:50 - the value of array at second index is 9
1409:53 - and 9 is not equal to 10
1409:56 - therefore condition in if block comes out to be false
1409:59 - will then increment i by 1
1410:04 - so i becomes 3
1410:08 - moving ahead
1410:11 - so here in the if block we again check that whether value at i at index is equal to x or not
1410:18 - so value of i is 3
1410:21 - so value of array at third index is 2
1410:24 - and 2 is not equal to 10
1410:26 - therefore condition in if block comes out to be false
1410:29 - and after increment i becomes 4
1410:40 - now in the if block we again check that value of array at i at index is equal to x or not
1410:45 - so here you can see the value of array at fourth index is 10
1410:50 - and if we compare it with x then both values are equal
1410:56 - so the condition in if block comes out to be true
1410:59 - and here we have found our element at index 4
1411:03 - so the if block will execute
1411:08 - and will simply return the value of index where we have found the element
1411:12 - which is nothing but 4
1411:17 - so friend this is how the linear search algorithm works in java
1411:22 - also friend if we had searched any value which was not given in this array
1411:27 - then after this for loop we would have simply returned minus 1
1411:31 - because we haven't found the value into this array
1411:35 - so friend this was the demonstration of the algorithm
1411:38 - now let's go to eclipse and see the working of this code
1411:44 - hello friends
1411:45 - in our previous tutorial we actually saw the demonstration of the linear search algorithm
1411:51 - so now in this tutorial we will actually code the linear search algorithm
1411:54 - and will test its working
1411:57 - so here first we will create a search method
1412:00 - so public whose return type would be the integer
1412:05 - because we are returning the index where we have found our search
1412:10 - so i will give the name as search
1412:17 - now this search method will take
1412:20 - the array
1412:22 - into which we want to search for a particular element
1412:27 - it takes the value of n which is nothing but the number of elements of this array
1412:33 - and integer x which is nothing but the value which we want to search
1412:39 - so friend here this search method will return back as an integer value
1412:43 - which is nothing but the index where we have found our search
1412:47 - and if we haven't found our search then it will return back as minus 1
1412:52 - so here we will provide a for loop which will iterate over each and every element of this array
1412:58 - and inside that for loop we will compare each and every element with the x
1413:02 - and if it is equal then we will simply return the index
1413:06 - so we will provide a for loop
1413:11 - which will start from 0
1413:13 - and which will go to a value lesser than n
1413:21 - so inside this for loop we will simply provide a if condition
1413:27 - we will compare
1413:31 - value with iid index
1413:34 - with x
1413:37 - and if the condition in if block comes out to be true
1413:40 - we will simply return the index value where we have found our element
1413:47 - and if the for loop executes completely and we haven't found our element
1413:52 - we will simply return
1413:55 - minus 1
1413:57 - which indicate that we haven't found our element
1414:00 - so friend this is the code whose demonstration we saw in our previous tutorial
1414:04 - now in the main method let's test its working
1414:10 - so here we have actually created an array with few elements
1414:14 - so first we will create the instance of linear search class
1414:29 - and then we will simply call the search method
1414:33 - we will pass in the array
1414:36 - and the number of elements would be the length of the array
1414:41 - and let's say we want to search for a value 10
1414:45 - so we will pass 10
1414:48 - so whatever the integer value it returns
1414:51 - we will simply print it on the console
1414:59 - if I run the code now
1415:06 - so here we can see it printed 4
1415:10 - which means we have found our element at index 4
1415:15 - now let's suppose if we want to search a value which is not present in this array
1415:19 - so if I search for value as 50
1415:23 - and if I run the code now
1415:29 - so here we can see it return minus 1
1415:32 - which states that we haven't found our element into this array
1415:36 - so friends here in this tutorial we actually coded the linear search algorithm
1415:41 - and we tested its working
1415:44 - I hope you like this video
1415:46 - thanks have a nice day
1415:49 - hello friends welcome to my new data structures and algorithm in java tutorial series video
1415:55 - friends in this tutorial we will discuss binary search in java
1416:01 - so friends what is a binary search
1416:04 - binary search is a divide and conquer algorithm
1416:07 - so here if you see that suppose if we are given an array which is sorted
1416:13 - so here you can see the numbers are sorted in ascending order
1416:17 - so friends let's suppose we have to search an element in a sorted array
1416:21 - so what we can do is either we can perform a linear search
1416:24 - that we can compare the elements with an array with an element we want to search
1416:28 - so this linear search will go on with the each and every element
1416:32 - that we first check with the number at 0 to index then 1 then 2 then 3
1416:37 - and it goes on till the end of the array
1416:40 - but here if the array is sorted then instead of doing a linear search we can do a binary search
1416:45 - so what we can do is we can repeatedly divide an array into half
1416:49 - and with the each division we know that we are dividing the array into two halves
1416:54 - so we usually compare the element we want to search with the middle element
1416:58 - and if suppose the element we want to search is less than the middle element
1417:02 - then we can ignore the other half and we can search in the first half
1417:06 - and if the element we want to search is greater than the middle element
1417:10 - then we can ignore the first half and we can search in the last half
1417:14 - so below you can see the algorithm for the binary search
1417:17 - now let's see the demonstration of this algorithm step by step
1417:22 - so suppose we are given an array
1417:24 - having 9 elements and here you can see the array is sorted
1417:30 - so suppose we want to search a key having the value of 65
1417:34 - now we know that 65 is in the array
1417:37 - and we want to search it using the binary search
1417:40 - so what we can do is
1417:42 - so the first step what we do is we create an integer variable
1417:46 - by name low and we assign a value of 0 to it
1417:49 - so here you can see low is having value of 0
1417:56 - so here it means that we are pointing at the first element of an array
1418:00 - at the index 0
1418:02 - moving ahead
1418:06 - and then we create an integer variable by name high
1418:10 - and we assign it a value of say numbers dot length minus 1
1418:14 - so here what we are actually doing in the first step we created
1418:18 - an integer variable low and we are pointing it to the first index
1418:21 - and then we are creating an integer variable high
1418:24 - which will point to the last index of an array
1418:27 - which is 8
1418:29 - so here if you see there are total 9 elements in an array
1418:32 - and when we do numbers dot length we get 9
1418:35 - and when we do minus 1 we get the 8
1418:38 - so it just means that high is having value as 8
1418:41 - and it is pointing to the last element of an array
1418:48 - so friend as the array is sorted and we are applying binary search over it
1418:52 - so we are using this while loop and inside this while loop
1418:56 - in each iteration we will divide the array into two halves
1418:59 - and we will search for the key 65
1419:03 - so the condition we are placing in the while loop is
1419:06 - we will iterate till low is less than equal to high
1419:09 - so currently you can see low is pointing to the 0th index
1419:13 - and high is pointing to the 8th index
1419:17 - therefore low is less than high
1419:20 - so the condition in while block comes out to be true
1419:28 - so in the first step what we are actually doing is
1419:31 - we are actually finding the middle element of the array
1419:34 - so in order to find the middle element
1419:37 - the formula we are using here is
1419:39 - we are doing high plus low and we are dividing it by 2
1419:43 - so currently high is having a value as 8
1419:45 - and low is having a value of 0
1419:48 - so when we will do 8 plus 0 by 2
1419:51 - we get mid as 4
1419:54 - so here mid will point to the index 4
1419:57 - which is nothing but the middle element of this array
1420:02 - moving ahead
1420:06 - so friends here you can see as mid is pointing to the middle element of an array
1420:11 - we know that array is divided into two parts
1420:14 - from low to middle and from middle to high
1420:18 - so first we will check whether the value at mid position is equal to key or not
1420:23 - so if the element is equal to key then we have found our key
1420:27 - and we will simply return the value of index
1420:30 - so currently you can see the value at mid is 59
1420:33 - and if we compare it with the key
1420:36 - then 59 is not equal to 65
1420:39 - therefore the condition in if block comes out to be false
1420:43 - and then we will check that whether key 65 is less than 59 or not
1420:51 - so here you can see 65 is not less than 59
1420:55 - therefore the condition in if block comes out to be false
1420:59 - and the else block will be executed
1421:05 - so friends here you can see as array sorted
1421:08 - and we have identified that key 65 is greater than the middle value
1421:14 - therefore we know that 65 would be somewhere in the last half
1421:18 - so now we can ignore the first half
1421:21 - and we can directly search into the last half
1421:24 - so this is how this algorithm works
1421:26 - we actually divide using this middle element
1421:29 - and we compare it with the middle value
1421:32 - and if the value is greater than the middle value we search in the last half
1421:36 - and if it is less than the middle value then we search in the first half
1421:40 - so now the overhead of searching in first half is gone
1421:44 - and we can directly perform our search in the last half
1421:47 - so what here actually we do is
1421:49 - currently low was pointing to the zeroth index
1421:52 - and now we know that our key will be lying between the index 4 and 8
1421:58 - so therefore to the low we are assigning the value as mid plus 1
1422:02 - so it would look something like this
1422:06 - that now low will be having value as 5
1422:10 - and it will point to the 5th index
1422:14 - moving ahead
1422:24 - now in while block we will check whether low is less than equal to high or not
1422:28 - so currently low is having value as 5
1422:31 - and high is having value as 8
1422:33 - therefore 5 is less than 8
1422:35 - so the condition in while block comes out to be true
1422:40 - so now in the first step we will again find the middle index
1422:44 - so we apply the formula as high plus low divided by 2
1422:48 - so currently you can see high is 8 and low is 5
1422:52 - so when we do 8 plus 5 we get 13
1422:55 - and when we divide it by 2 we get 6.5
1422:59 - and when we take it as integer variable the value is rounded up to 6
1423:05 - so now mid will hold the value as 6
1423:10 - so friends here you can see we have again divided the array into two halves
1423:14 - using this middle index
1423:19 - so in the first step we will check whether the value at mid is equal to key or not
1423:25 - so currently here you can see that value at mid which is 75
1423:30 - is not equal to our key which is 65
1423:33 - therefore the condition in if block comes out to be false
1423:40 - and then we check whether our key is less than this middle value or not
1423:44 - so if key is less than this middle value then we know that we have to search into the first half
1423:50 - and if key is greater than the middle value then we know that we have to search in the last half
1423:56 - so currently key which is 65 is less than 75
1424:00 - therefore the condition in if block comes out to be true
1424:02 - so friends here we know that as key 65 is less than 75
1424:12 - so therefore it must be lying somewhere between the low index and the middle index
1424:17 - which is nothing but the first half
1424:19 - so now our high will become mid minus 1 because we have to search in the first half
1424:24 - so therefore here you can see mid is 6
1424:27 - so when we do mid minus 1 high will store the value as 5
1424:33 - so friends here the key 65 was less than the mid value
1424:39 - therefore we know that it must be lying somewhere between the low index and the middle index
1424:44 - so therefore we assign the value of mid minus 1 to high
1424:48 - so that now we can search in the first half of an array
1424:51 - moving ahead
1424:52 - we will again check whether low is less than equal to high or not
1425:04 - so currently low is having value as 5 and high is also having value as 5
1425:09 - so therefore the condition in while block comes out to be true
1425:15 - and we will again find the middle index by the formula high plus low and then we will divide it by 2
1425:21 - so here you can see high is having value 5 and low is also having value as 5
1425:26 - so when we do high plus low we get value as 10 and when we divide it by 2
1425:31 - we get value as 5
1425:35 - so now value of 5 will be assigned to the mid here
1425:40 - and now mid will point to the 5th index
1425:43 - so friends in the if block we will check that whether the middle value is equal to key or not
1425:54 - so here you can see the middle value which is 65 is equal to the key 65
1425:59 - therefore the condition in if block comes out to be true
1426:02 - so it means that we have found our key
1426:05 - so we can simply return the index position
1426:08 - which is nothing but the 5th index
1426:14 - and if we don't find any value in an array till low is less than or equal to high
1426:19 - then we can come to know that element is not in the array
1426:23 - and then we can simply return the index as minus 1
1426:27 - so friends let's go to Eclipse and see the working code
1426:31 - so friends here I have created one class by name binary search
1426:35 - so inside this class I will be creating the method which can actually perform the binary search
1426:41 - so let's create a method as public int
1426:45 - so this method will return us back an integer value
1426:48 - and I will name it as binary search
1426:56 - and this method will take two things
1426:59 - one is the integer array
1427:02 - which is actually sorted array
1427:05 - another would be the key
1427:07 - which we want to search in the sorted array
1427:11 - so in the first step what we do is
1427:14 - we create an integer variable by name low
1427:17 - and we will assign a value of 0 to it
1427:21 - which is nothing but the 0th index of an array
1427:24 - and we will also create an integer variable by name high
1427:28 - and we will assign it a value of last index of an array
1427:32 - so we will simply do nums dot length minus 1
1427:37 - so now high will be pointing to the last index of an array
1427:42 - and then we will provide a while loop
1427:47 - and in the while loop we will provide a condition as low
1427:51 - should be less than equal to high
1427:54 - so we will iterate in the while loop till low is less than equal to high
1427:59 - so in the first step what we do is we actually divide the array
1428:03 - and we find the middle index
1428:05 - so we will create an integer variable by name mid
1428:09 - and we will assign it a mid value
1428:12 - by applying the formula as high plus low
1428:16 - divided by 2
1428:20 - so this formula will return us back the middle index of an array
1428:24 - after finding the middle index
1428:28 - we will simply check that value stored at the middle index
1428:35 - is equal to our key or not
1428:39 - so if the mid value is equal to key
1428:42 - then we know that we have found our key
1428:44 - and we can simply return the mid index
1428:48 - and if suppose the value of middle index is not equal to our key
1428:51 - then we can provide an if else block
1428:59 - so in the if block we will provide a condition as
1429:02 - that if key is not equal to the middle value
1429:05 - then it must be less than mid value or greater than mid value
1429:09 - so if key is less than the mid value
1429:17 - then we know that key lies in the first half of an array
1429:21 - so we will simply assign the value mid minus 1 to high
1429:27 - and in the else block we will simply assign
1429:30 - mid plus 1 value to low
1429:33 - because we know that if key is greater than the middle value
1429:37 - then we can ignore the first half and we can start searching in the last half
1429:42 - so at that time low will become mid plus 1
1429:46 - so in the while loop if we find our key
1429:49 - then we can simply return the mid index
1429:51 - and if we didn't find our key then we can simply return
1429:54 - minus 1
1429:56 - which is nothing but the negative index
1429:59 - so friend this is the code for binary search
1430:03 - now lets test its working in the main method
1430:06 - so here first we have initialized the binary search class
1430:10 - and then I have created one sorted array which we discussed in the slide
1430:14 - so friend lets search for a key having value as 65
1430:18 - so here I will be providing system.out.print talent statement
1430:25 - and here we will print the index
1430:27 - so we will use this binary search instance
1430:30 - and we will call binary search method
1430:34 - and inside this method we will pass this sorted array
1430:37 - and lets say we want to search for the key as 65
1430:40 - so friend here we know that 65 is in the sorted array
1430:44 - so if I run the code now
1430:48 - you can see it returned 5
1430:50 - which means that we have found our key at the 5th index
1430:53 - so here you can see 0,1,2,3,4 and 5th index
1430:58 - so it is actually returning the 5th index where we have actually found our key
1431:03 - and lets say if I provide the value as say 100
1431:08 - and we know that 100 is not in this sorted array
1431:12 - so if I run the code now
1431:16 - so here you can see it returned minus 1
1431:19 - which is the negative index because
1431:21 - it didnt find 100 in this sorted array
1431:24 - so it finally returned minus 1
1431:27 - so friends in this tutorial we discussed about the binary search in java
1431:31 - I hope you like this video
1431:33 - please like, comment, share and subscribe my youtube channel
1431:36 - thanks have a nice day
1431:39 - hello everyone
1431:41 - so in this video we are going to discuss
1431:44 - search insert position problem
1431:46 - so lets see what this problem is and how to solve this
1431:51 - so here in this problem we are given a sorted array
1431:54 - of distinct integers
1431:56 - so the array is sorted and we dont have duplicates
1432:00 - we are given a target value
1432:02 - and we need to return an index
1432:04 - if the target is found
1432:08 - if target is not found in the array
1432:11 - so as the array is sorted
1432:13 - then we have to return the index
1432:15 - where it would be
1432:17 - if it were inserted in order
1432:19 - so here this problem is a search and insert problem
1432:23 - so we are given with a sorted array
1432:26 - which doesnt have duplicates
1432:28 - and we are given with a target value
1432:30 - we need to first search the target value in the array
1432:33 - and if the target is found we need to return that index
1432:36 - and if the target is not found
1432:39 - then we need to return that particular index
1432:42 - where the target value should lie
1432:44 - so for example if we are given an input array
1432:46 - which is 1 3 5 7
1432:48 - so this is sorted array in ascending order
1432:51 - and the target value is given as 5
1432:53 - so if i put index is on top of the number
1432:57 - you can see 5 lies as index 2
1433:00 - so we return 2
1433:02 - now lets say if we are given with the same array
1433:05 - and target value is 2
1433:07 - so 2 is not found in the array
1433:09 - but if you see
1433:11 - as the array is sorted
1433:13 - and if we would have wanted to place 2 somewhere in the between
1433:16 - and if the array is still sorted
1433:18 - you can see it can lie between 0 and 1
1433:21 - so 1 is at 0 index
1433:24 - after that 2 would have come
1433:26 - so 2 would have come at this place
1433:28 - and 3 would have shifted ahead
1433:30 - so 2 would have come at first index
1433:33 - so we would return output as 1
1433:36 - now lets say if we are given with this input array
1433:41 - these are the indexes
1433:43 - and target is 8
1433:44 - so here you can see 8 is not found in this array
1433:47 - so the probable position for inserting 8 would be
1433:50 - after 7
1433:52 - so this sorted array goes from 0 to 3
1433:55 - 3rd is the last index
1433:57 - and we can only insert 8 after 7
1433:59 - which is the 4th index
1434:01 - so we return the value as 4
1434:04 - similarly
1434:07 - so this was the extreme case
1434:10 - where we need to put 8 outside the boundaries of the array
1434:14 - in this direction
1434:16 - now lets say if we are given with this array and target is 0
1434:19 - so here you can see 0 is not found in this array
1434:23 - and 0 can only lie before 1
1434:26 - but before 1 we have index minus 1
1434:29 - so this minus 1 is not a valid index in an array
1434:34 - so our target would lie at 0 index only
1434:38 - and the rest of the elements will get shifted in this direction
1434:42 - why we not added 0 at minus 1 index
1434:45 - because minus 1 index doesn't belong
1434:48 - the array should start from 0 index
1434:51 - so the only place to put target is at 0 index
1434:54 - so we return the output as 0
1434:57 - and the rest of the elements can shift here
1435:01 - but here when the target was 8
1435:04 - 2 index 4 was not in the array
1435:07 - but 4 is a valid index
1435:08 - an array can have a size where index 4 can belong
1435:13 - but an array cannot have an index minus 1
1435:17 - so therefore these two are some of the cases we need to handle
1435:21 - and we need to run the algorithm in log of n time
1435:25 - because we can directly search in the array in O of n time
1435:30 - and we can place the element at that particular index
1435:34 - because the array is sorted
1435:35 - so we need to use an algorithm which runs in log of n time
1435:39 - so lets move ahead and see that
1435:41 - so friends before we start
1435:43 - in case if you are new to my channel
1435:45 - then please subscribe to my channel
1435:47 - and click the bell icon so that you never miss any update
1435:50 - so here this is the algorithm
1435:52 - where the method name is search insert
1435:55 - it takes in an array and a target
1435:57 - and returns the index
1435:59 - that where this target should belong
1436:01 - so here as we need to run the algorithm in log of n time
1436:05 - we basically take the help of binary search
1436:09 - and try to figure out the proper index
1436:13 - for this target
1436:15 - now why we are applying this binary search is
1436:18 - first the given array is sorted
1436:22 - and second we need to find the target in the array
1436:26 - and return that index
1436:28 - so one is the search part which we need to do in log of n time
1436:31 - so here why the search is in log of n time is because
1436:35 - when we try to run the binary search on a sorted array
1436:40 - what happens is each time if the value is not found
1436:43 - half of the array is discarded because as the array is sorted
1436:47 - we keep on discarding the half of the array
1436:50 - with every iteration of while loop
1436:52 - so we will see that later
1436:54 - and if you see the time complexity of binary search
1436:57 - it is log of n
1436:58 - so we will see that how we can apply the binary search
1437:02 - and try to figure out the index for the target
1437:06 - so most of the algorithm is pretty much same as our binary search
1437:11 - but there are some things to understand
1437:13 - that how we can figure out the index of a target
1437:17 - if it is not found in the array
1437:20 - so let's say we call search insert
1437:23 - we pass in the array
1437:25 - and we pass the value of target as 66
1437:28 - so target becomes 66
1437:30 - now our task is to find 66 in this sorted array
1437:34 - if we found an index here
1437:37 - then we simply return the index of the array
1437:41 - where we found the target
1437:43 - and if not then we need to find that particular index
1437:47 - where this target would lie
1437:51 - so at the start
1437:53 - as we need to apply this binary search on complete array
1437:56 - we take two pointers low and high
1437:59 - low starts from 0 index
1438:03 - and high starts from the last index which is array.length-1
1438:08 - which is 8
1438:10 - so if we do array.length we get 9
1438:13 - and if we do minus 1
1438:15 - we get 8
1438:18 - so high starts from 8th index
1438:22 - so now we apply the binary search and we provide a while loop
1438:25 - where the condition we provide is low should be less than equal to high
1438:29 - so once low crosses high we need to stop this algorithm
1438:33 - so currently value of low is 0
1438:35 - and high is 8
1438:37 - so this condition comes out to be true
1438:41 - so friends how this binary search works
1438:44 - you can also watch my videos on binary search
1438:47 - but here I will explain
1438:49 - that as the array is sorted
1438:51 - we don't directly search each and every element of the array
1438:55 - because that would take O of n time complexity
1438:58 - because we are comparing target with each and every value
1439:03 - and as array is sorted we can use that property
1439:06 - what we can do is
1439:08 - we can try to find a mid element
1439:11 - and we simply compare that mid element with target
1439:14 - so let's see how
1439:16 - so in order to find the mid index
1439:19 - we use this formula
1439:21 - we do low
1439:23 - plus
1439:24 - high minus low
1439:27 - by 2
1439:29 - so here in binary search we also do something like low plus high
1439:33 - by 2
1439:35 - but here we are using this type of approach because
1439:38 - this formula will actually avoid the integer overflow condition
1439:43 - so let's say if you are given with a very huge array
1439:46 - which actually touches the boundaries of integer range
1439:50 - so if we do the addition of low and high
1439:52 - there could be a possibility that the range of integer is overflowed
1439:57 - so we will get undesired value
1440:00 - and so this part where we are doing low plus high would fail
1440:04 - and our binary search will not work properly
1440:07 - so therefore what we do is
1440:09 - we apply this part where we are doing high minus low
1440:13 - so here high would be a very large number
1440:16 - and low would be a number which is lesser than high
1440:19 - so when we are doing subtract we are going back into the integers range only
1440:24 - and when we are dividing it by 2 we are going further down
1440:28 - and then we can safely add it with low
1440:31 - to get the value of mid index
1440:39 - so if we do low which is 0 plus
1440:43 - high which is 8 minus 0 by 2
1440:46 - so 8 by 2 will give 4
1440:50 - which would be our mid index
1440:53 - so mid value would be 4
1440:55 - this
1440:58 - now the significance of taking the mid index is
1441:02 - we directly see what value is at mid
1441:05 - so here it is 59
1441:07 - we check whether it is equal to our target or not
1441:10 - so here we can say 59 is not equal to 66 which is our target
1441:14 - so therefore this if condition comes out to be false
1441:18 - and then we check whether target is less than the value at mid index
1441:23 - so here 69 is not less than 59
1441:27 - so this condition also comes out to be false
1441:30 - so here you can see the basic idea is
1441:33 - after calculating mid
1441:35 - we take the value at mid index
1441:38 - and there could be 3 possibilities
1441:41 - that this value is equal to target
1441:43 - this value is less than target
1441:45 - or this value is greater than target
1441:47 - so here we know that the array is sorted
1441:51 - so if target is less than array of mid
1441:55 - and as array is sorted we know that
1441:58 - the target might lie
1442:01 - in this range
1442:03 - and here target is greater than array of mid
1442:06 - here you can see 66 is greater than 59
1442:09 - so we are sure that 66 might lie in this
1442:12 - range because the array is sorted
1442:15 - 66 can't lie in this direction
1442:17 - because array sorted all the numbers
1442:21 - before 59 will be lesser than 59
1442:24 - and all the numbers in this direction will be greater than 59
1442:28 - so our chances that 66 might lie in this direction
1442:36 - so therefore what we do is
1442:38 - as 66 is greater than 59 we know that it might lie in this direction
1442:42 - so here in binary search we can safely discard this much array
1442:46 - because with this comparison we are sure that
1442:49 - target will never lie in this index
1442:52 - it can only be found in this index
1442:55 - because it is actually greater than the mid value
1442:58 - so therefore we bring this low
1443:01 - to this point
1443:03 - because if array of mid is not equal to target
1443:06 - we then perform our search
1443:08 - from 5th to 8th index
1443:11 - so high will be at the same position
1443:14 - we bring low to this direction
1443:16 - so what we do is
1443:18 - the new value of low would be mid plus 1
1443:21 - so mid is 4
1443:23 - and if we do plus 1 we reach 5th index
1443:26 - so low becomes 5
1443:29 - it will point to 5th index
1443:34 - so now our search will continue
1443:37 - from index 5 to 8
1443:38 - and we will discard this much array
1443:41 - so at every step
1443:43 - when we evaluate mid and perform this check
1443:46 - after that we actually discard half of the array
1443:49 - so therefore this algorithm runs in log of end time
1443:52 - because at every step
1443:54 - we are discarding half of array
1443:57 - because the possibility of target
1443:59 - could be either in this direction of mid
1444:02 - or in this direction of mid
1444:04 - if it is not equal to mid
1444:06 - so therefore the algorithm runs in log of end time
1444:08 - moving ahead
1444:15 - now we are trying to search 66 in this range
1444:19 - so low is less than equal to high
1444:22 - we first evaluate the mid index
1444:24 - so low would be 5
1444:26 - plus high would be 8
1444:28 - minus 5
1444:30 - by 2
1444:32 - so this will give 3 by 2
1444:33 - and this would give 1
1444:40 - so mid would be 6th index
1444:45 - like this
1444:47 - so it will point to the 6th index
1444:51 - so friendship array of mid
1444:54 - here it is 75
1444:56 - if it would have been 66
1444:58 - then we would have found our target
1445:00 - and problem states that if we are finding our target
1445:03 - then we should return the index of that spot
1445:06 - where the target belongs
1445:09 - but here you can see that array of mid is 75
1445:12 - it is not equal to our target which is 66
1445:16 - so therefore this condition comes out to be false
1445:20 - and now we check whether target is less than
1445:23 - the value at mid index
1445:25 - so if we compare 66 we get it is less than 75
1445:29 - which is our value at mid index
1445:31 - which is 75
1445:33 - so this condition comes out to be true
1445:36 - so here as the array sorted
1445:39 - and 66 is less than 75
1445:41 - we know that it must lie somewhere in this direction
1445:44 - if 66 would have been greater than 75
1445:47 - we would have discarded this spot
1445:50 - and we would have searched in this spot
1445:52 - but as 66 is less than 75
1445:55 - now we can safely discard this spot
1445:57 - so how we can discard this spot is
1446:00 - as high is pointing to 8
1446:02 - now in the next
1446:04 - search high should go
1446:06 - from mid-1
1446:08 - so therefore we assign mid-1 to high
1446:12 - so high becomes 5
1446:15 - which is at 5th index
1446:17 - and here you can see by doing this
1446:20 - we have discarded
1446:22 - half of the array
1446:24 - and now we are searching in
1446:26 - this spot
1446:27 - moving ahead
1446:31 - low is actually equal to high
1446:33 - so therefore this condition in while loop comes out to be true
1446:41 - so first we will evaluate the mid index
1446:44 - so low and high both are pointing to 5th index
1446:48 - so 5 plus 5 minus 5 by 2
1446:54 - and the answer would be 5
1446:57 - so mid will become 5
1446:59 - which will point to the 5th index
1447:02 - like this
1447:04 - now first we check whether value
1447:07 - in the array at mid index
1447:09 - whether it is equal to target or not
1447:12 - so 65 is not equal to 66
1447:14 - so therefore this condition comes out to be false
1447:17 - and then we check whether target is less than
1447:20 - the value of array at mid index or not
1447:23 - so our target is 66
1447:25 - and the value of array at mid index is 65
1447:29 - so therefore 66 is greater than 65
1447:32 - so this condition comes out to be false
1447:35 - so it means the new value of low would be mid plus 1
1447:39 - because this value is less than target
1447:42 - so we need to search in this direction
1447:45 - so the new value of low would become mid plus 1
1447:49 - which is 6 because value of mid is 5
1447:52 - so low will point to the 6th index now
1448:02 - so from now here you can see value of low is greater than high
1448:06 - high is at 5th index and low is at 6th index
1448:09 - so therefore this value will terminate
1448:13 - and here you can see that one critical step is
1448:16 - if we have found a target
1448:18 - we simply return the mid index
1448:20 - but if we haven't found a target
1448:23 - and the binary search ends here
1448:25 - at whatever index low will be
1448:28 - that will be our actual index to insert the target
1448:32 - so here 66 was greater than 65
1448:36 - and as there are distant integers
1448:38 - the probable index for inserting 66 would be
1448:42 - this
1448:44 - which is being pointed by low
1448:46 - and then rest of the elements can shift ahead
1448:49 - so we simply return the index
1448:51 - that it is the value
1448:53 - which is being assigned to low
1448:55 - when the binary search ends
1448:57 - so why we are only returning low
1448:59 - but not high
1449:01 - so we will see it by an example
1449:03 - so for this this step is very important
1449:06 - that we always return the index value of low
1449:10 - and that would be our actual value
1449:12 - where this target might lie
1449:14 - so now we will see
1449:16 - that why we are actually only returning low
1449:17 - and not high
1449:19 - so friend let's say if we are given with only one element
1449:22 - let's say the value would have been 4
1449:25 - it would have been at 0th index
1449:28 - and let's say the target value would have been 5
1449:31 - so we know that answer would have been 1
1449:34 - because at 0 we have 4
1449:36 - so 5 will lie at index 1
1449:39 - so at the start
1449:43 - low will point to 0
1449:47 - and high will also point to 0
1449:49 - because array.length is 1
1449:51 - 1-1 will give 0
1449:53 - and low is actually equal to high
1449:55 - so this condition is true
1449:57 - the mid would have been 0 plus
1450:00 - 0-0 by 2 which is 0
1450:03 - so this would have been our mid
1450:06 - this condition would have been false because
1450:09 - 4 is not equal to 5
1450:11 - so target which is 5
1450:14 - is not less than 4
1450:16 - so this condition would have been false
1450:18 - so here you can see
1450:20 - then the else part would have been executed
1450:22 - it must lie in this direction
1450:24 - so therefore we do low equal to mid plus 1
1450:28 - so when we do mid plus 1
1450:30 - low becomes
1450:32 - 1
1450:35 - which is at first index
1450:37 - so therefore after this statement
1450:39 - in the while loop
1450:41 - low value is 1
1450:43 - and high value is 0
1450:46 - and we know that
1450:48 - we have to return 1
1450:50 - because 5 will lie after 4
1450:52 - so this is the one case
1450:56 - so let's say now our target is 3
1451:00 - so we know that 3 will lie
1451:03 - before 4 here somewhere
1451:06 - but here you can see index of 4 is already 0
1451:09 - and 3 can't lie in minus 1 index
1451:12 - because this index is not an array
1451:15 - so therefore answer would have been 0 only
1451:18 - because 3 will lie here
1451:20 - and 4 will shift ahead
1451:27 - so here low is
1451:31 - and high is at 0 index
1451:34 - low is equal to high
1451:36 - so this condition is true
1451:38 - the mid would be 0 plus 0 minus 0 by 2
1451:41 - which is 0
1451:43 - so mid comes at 0th index only
1451:46 - the value at mid index which is 4
1451:49 - is not equal to target
1451:51 - because 4 is greater than target
1451:53 - so here you can see
1451:55 - target is actually less than
1451:57 - array of mid
1451:59 - 3 is less than
1452:01 - 4
1452:02 - so therefore this condition would have been true now
1452:05 - and high would have become
1452:07 - mid minus 1
1452:09 - so it means as the array sorted
1452:10 - 3 must lie in this direction
1452:13 - so therefore high will become
1452:15 - mid minus 1
1452:17 - so mid is 0
1452:19 - and if we do minus 1
1452:21 - high will reach
1452:25 - at a value minus 1
1452:27 - so in the next iteration of while loop
1452:30 - this condition comes out to be false because
1452:32 - value of high is less than low
1452:34 - because low is
1452:36 - referring to 0 index and high is referring to minus 1
1452:39 - this condition would have been false
1452:41 - and here you can see at the end
1452:43 - we are actually returning the value of low
1452:45 - which is our answer
1452:47 - that 3 will lie at 0 index only
1452:50 - so therefore we need to keep a note that
1452:53 - low will be the answer
1452:55 - that where this target might lie
1452:58 - if it is not found in the sorted array
1453:01 - and this is pretty much similar to the binary search algorithm
1453:05 - but this step is very critical to understand
1453:08 - so friend this was all about the search insert problem
1453:11 - I hope you must have liked this video
1453:14 - in case if you are new to my channel
1453:16 - then please subscribe to my channel and click the bell icon
1453:19 - so that you never miss any update
1453:21 - thanks have a nice day
1453:26 - hello everyone
1453:28 - so friend in this section of course
1453:30 - we will be discussing about various sorting algorithms
1453:34 - and in this lecture we will discuss
1453:36 - what is bubble sort algorithm
1453:40 - so we will be looking into the demonstration of bubble sort algorithm
1453:44 - and later we will look into its implementation
1453:52 - so here what is bubble sort
1453:55 - so if you see bubble sort is also called as sinking sort
1453:59 - now what do we mean by sinking sort
1454:02 - so here let's say we are given an unsorted array
1454:07 - which has some random numbers
1454:10 - and if we apply the algorithm on those random numbers
1454:14 - so usually the algorithm works in various iterations
1454:18 - and with each iteration
1454:21 - the largest element tends to sink at the end of the array
1454:25 - and when they sink to the end of the array
1454:28 - they are usually placed
1454:29 - at the correct position
1454:32 - and after every element is placed at its particular position
1454:36 - at the end we get a sorted array
1454:42 - so how does this algorithm work is
1454:45 - as we are given few numbers
1454:47 - which are unsorted
1454:49 - so usually this algorithm
1454:52 - it repeatedly compares the pair of adjacent elements
1454:56 - and swap them if they are in wrong order
1454:59 - so when the few numbers are given which are unsorted
1455:02 - we start with the first two numbers
1455:05 - and we compare them to check whether they are in correct or wrong order
1455:10 - and if they are in wrong order we simply swap them
1455:14 - and then we move to the next two numbers
1455:17 - so let's look into an example where we are given an unsorted array
1455:24 - so here inside this array there are six numbers
1455:27 - which are unsorted
1455:29 - and now let's say we want to sort them in ascending order
1455:34 - so now what do we do is
1455:35 - we compare the adjacent elements repeatedly
1455:39 - so in the first pass
1455:41 - we compare the first two numbers
1455:44 - and as we want to sort this array in ascending order
1455:48 - we simply compare that the number on the left
1455:52 - is greater than the number on the right or not
1455:56 - so if the number on the left is greater than
1455:58 - the number on the right
1456:00 - then we know that they are in wrong order
1456:02 - so here three is greater than one
1456:05 - so we know that they are in wrong order
1456:08 - so what do we do is
1456:09 - we perform a swap
1456:11 - so after performing the swap between these two numbers
1456:17 - one comes to the left
1456:18 - and three goes to the right
1456:21 - and after performing the swap
1456:23 - we simply move to the next adjacent elements
1456:29 - we compare three with five
1456:32 - and three is less than five
1456:34 - so therefore they are in correct order
1456:36 - so we perform no swap
1456:39 - and then we simply move ahead with the next two numbers
1456:46 - now here you can see five is greater than two
1456:48 - so therefore they are in wrong order
1456:51 - so we perform a swap
1456:55 - and after we perform a swap
1456:58 - two goes to the left
1456:59 - and five goes to the right
1457:02 - and then we move to compare the next two adjacent elements
1457:08 - here we see five is less than six
1457:10 - so therefore they are in correct order
1457:13 - so we do no swap
1457:16 - and at the last
1457:19 - six is greater than four
1457:21 - so therefore we perform a swap
1457:22 - because they are in wrong order
1457:23 - so four goes to the left
1457:29 - and six goes to the right
1457:33 - so after the first pass completes
1457:35 - you can see
1457:39 - that six, which is the largest element among the array
1457:43 - tends to sink at the end of the array
1457:46 - and here you can see being the largest element
1457:49 - six is actually at its correct position
1457:54 - so now with the first pass
1457:56 - the first number got its correct position
1458:00 - now we again perform the steps
1458:02 - with the second pass
1458:05 - but this time
1458:07 - as six is at its correct position
1458:10 - we don't include six
1458:12 - in our comparison
1458:15 - so now our new array is from index zero to four
1458:19 - so initially it was from zero to five
1458:21 - as we got one of the number correctly sorted
1458:25 - for the second pass
1458:26 - our array becomes from zero to four
1458:31 - so we start comparing the first two elements
1458:34 - now one is less than three
1458:36 - therefore we perform no swap
1458:41 - now three is greater than two
1458:44 - so it means they are in wrong order
1458:47 - so we simply perform a swap here
1458:51 - so two goes to the left
1458:54 - and three goes to the right
1458:56 - moving ahead
1458:59 - we compare three with five
1459:02 - three is less than five
1459:04 - therefore no swapping is done
1459:09 - and then we compare five with four
1459:12 - so five is greater than four
1459:14 - therefore we perform a swap because they are in wrong order
1459:21 - so four goes to the left
1459:23 - and five goes to the right
1459:27 - and as we don't include this element
1459:30 - after completion of the second pass
1459:32 - you can see
1459:34 - the second largest element
1459:36 - among this list
1459:38 - which is five
1459:40 - is correctly placed at the second last position
1459:43 - just before the six
1459:46 - so when here you can see
1459:48 - that this algorithm
1459:50 - needs to make the largest element sing at the end of the array
1459:55 - so similarly this algorithm continues
1459:58 - but here you can see
1460:00 - the numbers are now in one, two, three, four
1460:04 - so by looking at the array
1460:06 - the numbers are already sorted
1460:08 - but there is no way
1460:10 - for the algorithm to know that the numbers are sorted
1460:14 - because the algorithm has to make the comparisons
1460:17 - so in order to make
1460:19 - the algorithm know
1460:21 - that the array sorted what we do is
1460:23 - we simply keep the track of the swapping
1460:27 - so let's see how we can do it in the third pass
1460:32 - so we compare the first two elements
1460:36 - one is less than two
1460:37 - so therefore they are in correct order
1460:39 - so no swapping is done
1460:42 - so here we perform no swap
1460:46 - two is less than three
1460:49 - so therefore there is no swap
1460:54 - three is less than four
1460:56 - so therefore there is no swap
1460:59 - so from here you can see
1461:01 - in the third pass
1461:03 - we didn't perform any swap
1461:05 - so at the end of the third pass
1461:08 - we simply check that whether we had performed any swap or not
1461:12 - so if we haven't performed any swap
1461:14 - we can come to know that array is already sorted
1461:19 - so friend usually with each iteration or with each pass
1461:22 - we simply keep the track of swapping
1461:25 - and if in any particular pass
1461:28 - no swapping is done
1461:30 - then we can directly come to know that
1461:32 - the array is already sorted
1461:34 - and we simply break from the algorithm
1461:38 - so friend this is the demonstration
1461:40 - of the bubble sort algorithm
1461:44 - in our next lecture we will see
1461:46 - the demonstration of the code
1461:49 - and then we will write the implementation of it
1461:52 - in eclipse and see its working
1461:55 - I hope you like this video
1461:57 - thanks have a nice day
1462:02 - hello everyone
1462:04 - so in our previous lecture we discussed about what is bubble sort
1462:08 - and we saw its demonstration
1462:10 - with an example
1462:13 - so in this lecture we will see
1462:14 - the demonstration of the code
1462:16 - using an animation
1462:18 - so here let's say we are given an unsorted array
1462:25 - having 5 elements
1462:27 - as 5 1 9 2 10
1462:31 - now we want to sort this array in ascending order
1462:34 - by applying the bubble sort algorithm
1462:37 - so here you can see
1462:39 - that this is the bubble sort algorithm
1462:42 - so friends in our previous lecture we saw the demonstration of the algorithm
1462:47 - where we discussed that we start comparing the adjacent elements
1462:54 - and if they are in wrong order we simply swap them
1462:57 - and usually when we complete one particular iteration
1463:01 - the largest element tends to sink at the bottom of the array
1463:05 - or at the end of the array
1463:08 - and we also discussed that with each iteration
1463:11 - we keep the track of the swapping
1463:14 - and if no swap is done
1463:16 - in any particular iteration
1463:18 - we simply come to know that the array is already sorted
1463:23 - so let's see the demonstration of this algorithm step by step
1463:27 - so here
1463:30 - the number of elements are 5
1463:33 - with an index from 0 to 4
1463:37 - so at the first step what we do is
1463:39 - we simply create a boolean variable
1463:41 - we give it a name as isSwapped
1463:44 - now this boolean variable will keep the track of the swapping
1463:48 - in each iteration that whether the swap is done or not
1463:52 - so here you can see at the last step what we simply check
1463:56 - that if the swap is not done
1463:58 - then we come to know that the array is already sorted
1464:02 - so we simply break from this algorithm
1464:04 - so we will see its usage inside this algorithm
1464:09 - so here we have created the boolean variable isSwapped
1464:13 - so from here you can see there are two for loops
1464:20 - one is the outer for loop
1464:22 - and other is the inner for loop
1464:25 - so usually the outer for loop
1464:27 - basically keep the track of each and every iteration
1464:31 - and the inner for loop
1464:33 - will simply help us in performing the comparison with the edges and elements
1464:40 - so let's see the usage of these two for loops
1464:44 - so with the outer for loop we start with i equal to 0
1464:51 - and this for loop will loop till i is less than n-1
1464:56 - so here you can see 5-1 which gives 4
1465:02 - so this for loop will travel 4 times
1465:05 - as it is starting from 0, it will go from 0, 1, 2, 3
1465:11 - so with total 4 iterations
1465:13 - so usually this outer for loop what it tracks is
1465:16 - here you can see there are 5 numbers
1465:19 - and we also discussed that with each iteration
1465:23 - the largest element tend to go to its correct position
1465:27 - by syncing at the end of the array
1465:30 - and once it syncs to the end of the array
1465:33 - we simply don't include that element in the next iteration
1465:38 - so here as the outer for loop will travel 4 times
1465:41 - with each time we get a number
1465:44 - sorted at its correct place
1465:47 - so here there are 5 numbers
1465:50 - so with 4 iterations we will get the 4 numbers
1465:53 - sorted correctly at their position
1465:56 - and as the 5th number is the only number left
1465:59 - it will be already sorted to its correct position
1466:02 - so therefore we iterate this for loop from 0 to less than n-1
1466:09 - so currently value of i is 0
1466:12 - and it is less than 4 which is n-1
1466:16 - so the condition in for loop comes out to be true
1466:23 - and as we want to track that whether any swap has been performed
1466:28 - with each and every iteration
1466:30 - with this iteration we start with is swerved as false
1466:38 - and moving ahead now we encounter the inner for loop
1466:42 - which simply compares the edges and elements
1466:45 - and perform the swap
1466:48 - so here you can see the inner for loop
1466:51 - starts from j equal to 0
1466:54 - and here it goes till j is less than n-1 minus i
1467:00 - now here you can see that the outer for loop is controlling the inner for loop
1467:05 - now why we are doing it is
1467:08 - with each iteration the largest element will sink
1467:12 - to the end of the array
1467:15 - and once those elements are sinking to the end of the array
1467:18 - we don't have to include those elements
1467:21 - so as the outer for loop is incrementing one by one
1467:25 - the j will traverse only to those positions
1467:29 - which are still unsorted
1467:32 - so let's see it via demonstration
1467:35 - so currently j is less than 5 minus 1 minus 0 because i is 0
1467:42 - so the condition in for loop comes out to be true
1467:45 - and for loop executes
1467:50 - and here inside this for loop we are simply providing an if-lock
1467:54 - where we are simply comparing the edges and elements
1468:00 - j and j plus 1
1468:02 - and as we are sorting this in ascending order
1468:05 - we are simply checking
1468:10 - that the value at jth index is greater than value at j plus 1th index or not
1468:17 - so it means we are simply comparing these two elements
1468:21 - now here you can see 5 is greater than 1
1468:25 - so therefore they are in wrong order
1468:28 - so we simply perform a swap
1468:30 - so here the condition in if-lock comes out to be true
1468:34 - and here inside the if-lock we are performing the swap
1468:40 - so usually how we perform a swap is
1468:43 - we create a temporary variable
1468:46 - and we store one of the values inside the temporary variable
1468:52 - so here we are storing the value at jth index
1468:56 - to the temporary variable
1468:58 - because in the next step we will override this value
1469:01 - and we actually need this value in the later computation
1469:08 - so as we want to swap these two elements
1469:11 - now we are taking the value at j plus 1th index
1469:15 - and we are assigning it to the jth index
1469:21 - so it becomes 1
1469:23 - and at the last step
1469:25 - as we have stored this value into the temporary variable 5
1469:30 - we simply assign the temp to the array at the j plus 1th index
1469:37 - so here you can see
1469:39 - we have swapped both the numbers using the temporary variable
1469:46 - and then we mark a swapped variable with a value true
1469:51 - because we have performed one swap in this iteration
1469:55 - so it becomes true
1470:00 - moving ahead
1470:07 - now we will increment j by 1
1470:10 - so j becomes 1
1470:12 - and 1 is less than 5 minus 1 minus 0 which is 4
1470:17 - so the condition in for loop comes out to be true
1470:20 - and here as j is 1
1470:26 - so it will simply point to the first index
1470:30 - and j plus will point to the second index
1470:33 - because now we want to compare these two elements
1470:38 - and here as 5 is less than 9
1470:40 - therefore they are in correct order
1470:44 - so we perform no swap
1470:47 - as the condition in if block comes out to be false
1470:50 - there is no swapping
1470:57 - we will increment j by 1
1470:59 - so j becomes 2
1471:02 - and 2 is less than 4
1471:05 - so the for loop executes
1471:11 - now the value of j is 2
1471:13 - therefore now we will compare 9 with 2
1471:21 - so here you can see
1471:23 - as 9 is greater than 2
1471:26 - therefore they are in wrong order
1471:28 - so here we need a swap
1471:31 - so the condition in if block comes out to be true
1471:34 - because 9 is greater than 2
1471:40 - so now we will simply swap using the temporary variable
1471:43 - which we saw in our previous steps
1471:46 - so we store 9 in the temporary variable
1471:51 - then we store 2 at the place of 9
1472:00 - and then we store the value stored in a temporary variable
1472:04 - at the third index
1472:06 - on the place of 2
1472:09 - so here we have simply performed a swap
1472:12 - between these two elements
1472:16 - and we assign value true to a swapped variable
1472:20 - which is already true
1472:28 - we will increment j by 1
1472:30 - so j becomes 3
1472:32 - and 3 is less than 4
1472:39 - now we are simply comparing the jth index with j plus 1th index
1472:43 - which is the third index with fourth index
1472:45 - comparing 9 with 10
1472:48 - so here you can see
1472:50 - 9 is less than 10
1472:52 - so therefore
1472:54 - no swapping is done
1472:56 - and the condition in if block comes out to be false
1473:00 - so we simply skip this part
1473:08 - we will increment j by 1
1473:10 - so j becomes 4
1473:12 - and j becomes 4
1473:13 - so j becomes 4
1473:15 - so now here you can see
1473:17 - value of j is 4
1473:19 - and 4 is not less than 4
1473:21 - therefore the condition in for loop comes out to be false
1473:24 - and this for loop exits
1473:32 - and just after the for loop
1473:34 - we have completed our one iteration completely
1473:37 - so we simply check that whether
1473:40 - in this iteration
1473:41 - we performed any swap or not
1473:44 - because if we haven't performed any swap
1473:47 - in this iteration
1473:49 - then the algorithm comes to know that
1473:52 - the array is already sorted
1473:54 - but here you can see the value of we swapped is true
1473:58 - so therefore this if condition comes out to be false
1474:04 - so here you can see
1474:06 - the outer for loop
1474:08 - has performed its one iteration completely
1474:11 - with the value of i equal to 0
1474:14 - so after the first iteration of the for loop
1474:17 - you can see the largest element
1474:20 - which is the 10
1474:22 - has basically sink to the end of the array
1474:25 - and here now you can see 10
1474:28 - being the largest element is at its correct position
1474:35 - so now we will increment i by 1
1474:41 - and 1 is less than 4
1474:44 - therefore the condition in for loop comes out to be true
1474:50 - so for now next pass starts
1474:53 - so we simply assign the value false to the swapped variable
1475:02 - and now the second pass starts
1475:05 - so we start comparing it from the first two elements
1475:08 - with j equal to 0
1475:12 - so from here you can see
1475:14 - the value of i is 1
1475:16 - and value of i is basically controlling the inner for loop
1475:21 - and why it is controlling because
1475:23 - with the first iteration
1475:25 - we have found our one element
1475:28 - which is sorted
1475:30 - and it is at its correct position
1475:32 - so therefore when we are starting our next pass
1475:36 - we don't want to include this element
1475:38 - so our array has now become from 0
1475:41 - to our index
1475:43 - so therefore we are subtracting 1
1475:46 - from this condition
1475:48 - because value of i is 1
1475:50 - so it means
1475:51 - the inner for loop will simply compare
1475:54 - these elements from 0, 1, 2, 3
1475:58 - and it will not touch the fourth element
1476:01 - using this condition
1476:04 - so currently you can see
1476:07 - j is 0
1476:08 - and j is less than
1476:10 - 5 minus 1 which is 4
1476:12 - minus 1 which is 3
1476:14 - so 0 is less than 3
1476:20 - and we simply perform the comparison
1476:23 - what we did in our previous steps
1476:26 - we compare the value at jth
1476:28 - and j plus 1th index
1476:32 - so here as 1 is less than 5
1476:35 - therefore they are in correct order
1476:37 - so no swap is done
1476:40 - and the condition in if block comes out to be false
1476:49 - now we will increment j by 1
1476:51 - so j becomes 1
1476:53 - 1 is less than 3
1476:58 - now we simply compare
1477:01 - the elements at index 1 and 2
1477:04 - because value of j is 1
1477:10 - here 5 is greater than 2
1477:12 - so therefore they are in wrong order
1477:14 - so we simply perform a swap
1477:17 - because condition in if block comes out to be true
1477:23 - so we simply store 5
1477:25 - into the temporary variable
1477:31 - and then we migrate this value
1477:33 - which is stored at the j plus 1th index
1477:36 - we simply assign it to the
1477:38 - jth index
1477:41 - so it becomes 2
1477:43 - using this step
1477:48 - and at the last we simply assign the value stored at the temporary variable
1477:53 - to array at j plus 1th index
1477:57 - so it becomes 5
1477:59 - so we have performed a swap here
1478:04 - so as we have performed a swap
1478:06 - we simply assign the value true
1478:08 - to a swapped variable
1478:17 - we will increment j by 1
1478:19 - so j becomes 2
1478:21 - 2 is less than 3
1478:27 - now we compare
1478:29 - the second index
1478:31 - with the 3rd index
1478:33 - using array of j
1478:35 - is less than 1
1478:41 - so 5 is less than 9
1478:43 - therefore they are in correct order
1478:45 - so no swap is done
1478:50 - we will increment j by 1
1478:53 - so j becomes 3
1478:55 - now here you can see 3 is not less than 3
1478:58 - therefore the condition in for loop comes out to be false
1479:01 - and for loop exits
1479:06 - and here we simply check
1479:08 - whether a swapped is equal to false or not
1479:11 - but here a swapped is true
1479:13 - because we had performed one swap here
1479:17 - so therefore the condition in if block comes out to be false
1479:23 - and friends here you can see
1479:25 - with the completion of the second iteration of the outer for loop
1479:30 - the second largest element which is 9
1479:33 - is at its correct position
1479:35 - which is the second last position
1479:39 - so here bubble sort makes the largest element
1479:42 - tend to sing at the end of the array
1479:45 - the second largest element tend to sing at the second last position
1479:49 - and similarly it goes on like this
1479:53 - so now we will again execute for loop
1479:55 - with i equal to 2
1479:57 - by incrementing the value of i
1480:02 - so i becomes 2
1480:04 - 2 is less than 4
1480:11 - we assign false to a swapped variable
1480:15 - because with this inner for loop we are starting our new iteration
1480:21 - so here you can see as these two elements
1480:24 - are basically sorted
1480:26 - so we are using the value of i which is 2
1480:29 - to control the inner for loop
1480:32 - in this condition here
1480:34 - so j is starting from 0
1480:37 - and it will go till
1480:39 - which is 5 minus 1 which gives 4
1480:43 - minus 2 which gives 2
1480:46 - so 0 is less than 2
1480:52 - so now we will again start comparing these two elements
1480:58 - and as 1 is less than 2
1481:00 - therefore they are at correct order
1481:02 - so no swapping is done
1481:07 - and also friend here you can see the importance of this Boolean variable
1481:11 - because if you see the array is already sorted
1481:15 - but the algorithm doesn't know this
1481:18 - so here when the j was equal to 0 we didn't perform any swap
1481:22 - and the swapped value remained false
1481:26 - now we will increment j by 1
1481:27 - so j becomes 1
1481:29 - 1 is less than 2
1481:33 - so we simply compare the elements
1481:35 - at index 1 and 2
1481:41 - so 2 is less than 5
1481:43 - therefore they are in correct order
1481:45 - so no swapping is done
1481:48 - so this Boolean variable still remains false
1481:50 - will increment j by 1
1481:52 - so j becomes 2
1481:54 - and here you can see 2 is not less than 2
1481:58 - so therefore this for loop will terminate
1482:01 - because the condition in for loop comes out to be false
1482:06 - and friends here you can see at the last step
1482:09 - we are simply comparing
1482:11 - that whether a swapped is false or not
1482:13 - so here is 7
1482:14 - value is false
1482:16 - which tells us that array is already sorted
1482:20 - and we don't want to continue this algorithm further
1482:23 - because we were keeping the track of the swapping
1482:27 - so in this step
1482:29 - the condition in if block comes out to be true
1482:32 - and we simply break this for loop
1482:36 - so in this step
1482:38 - the condition in if block comes out to be true
1482:41 - and we simply break this for loop
1482:44 - so friends here we saw the demonstration of the bubble shot algorithm
1482:50 - so in our next lecture we will see the demonstration of this algorithm in eclipse
1482:54 - I hope you like this video
1482:57 - thanks have a nice day
1483:02 - hello everyone
1483:04 - so friends in this lecture we will code the bubble shot algorithm
1483:07 - and we will simply test its working
1483:10 - so in eclipse
1483:12 - I have created one class as bubble shot
1483:14 - and inside that I have created one method print array
1483:17 - so this method will simply take the array
1483:21 - and will simply print its content on the console
1483:25 - so we have already discussed this algorithm
1483:29 - in our previous lectures when we discussed about the arrays
1483:33 - so I will be using this print array method
1483:36 - to simply demonstrate that whether our array is sorted or not
1483:41 - so inside this class I have provided a main method
1483:44 - where I have created an unsorted array
1483:48 - which we already discussed in our previous slide
1483:51 - and at the first step what we are doing is
1483:54 - we are simply calling the print array method
1483:57 - and providing this array
1484:00 - to simply see the contents of this array
1484:05 - before performing the sort
1484:11 - so here you can see the array is not sorted
1484:15 - so let's write an algorithm
1484:17 - to sort this array
1484:21 - so in this lecture we will see
1484:23 - about the bubble shot algorithm
1484:25 - so we will create a method as public void
1484:28 - we will give it a name as sort
1484:35 - and to this sort method
1484:38 - we will pass the integer array
1484:42 - which is the unsorted array
1484:45 - so when inside this method
1484:48 - the first step we do is
1484:50 - we simply calculate the value of n
1484:52 - which is the number of elements inside this array
1484:57 - so we simply do array.length
1485:02 - and as per the algorithm which we discussed
1485:05 - in our previous lecture
1485:07 - we will first create
1485:09 - a boolean variable isSwapped
1485:15 - so we have created this variable
1485:18 - to keep the track that in any particular iteration
1485:21 - we perform any swap or not
1485:23 - so if we have performed any swap
1485:26 - then we are ensure that array is sorted or not
1485:29 - also in any of the iteration
1485:32 - if we haven't performed any swap
1485:34 - then we can come to know that
1485:36 - the array is already sorted
1485:39 - moving ahead
1485:41 - we first provide a for loop
1485:44 - which starts from zero
1485:53 - and goes till n-1
1486:01 - and also friend we discussed that value of i
1486:04 - will basically control the inner for loop
1486:07 - because as we are comparing the adjacent elements
1486:10 - we need to stop at a point
1486:13 - where we don't want to compare further
1486:17 - so here with the start of any iteration
1486:20 - we simply
1486:23 - provide a value false
1486:26 - to a swapped variable
1486:32 - and now we will provide
1486:34 - the inner for loop
1486:38 - where j
1486:40 - will start from zero
1486:43 - and j will traverse till n
1486:46 - minus 1
1486:48 - minus i
1486:51 - j++
1486:53 - so friend we already discussed
1486:56 - that why we are providing this condition here
1486:58 - is because
1487:00 - we need to control the inner for loop
1487:04 - by the outer for loop value
1487:06 - which is the i
1487:08 - so we are simply providing i here
1487:10 - now inside the inner for loop
1487:12 - our basic comparison will start
1487:14 - so we simply start with comparing the adjacent elements
1487:18 - that if
1487:27 - the value of index j
1487:29 - if it is greater than value
1487:32 - at index j plus 1
1487:36 - then we know that they are in wrong order
1487:39 - so we simply perform a swap
1487:43 - so inside is if block
1487:45 - in order to perform swap
1487:47 - we create a temporary variable
1487:50 - and we simply store
1487:52 - the value at the jth index
1487:56 - so that we can use this value
1487:58 - to perform the proper swap
1488:01 - so after we take out the value at the jth index
1488:04 - what we do is
1488:06 - now we can simply store
1488:08 - the value at j plus 1th index
1488:14 - to the jth index
1488:16 - because we need to perform a swap
1488:20 - and the final step
1488:24 - we simply store the value
1488:27 - present in the temporary variable
1488:30 - to the array at j plus 1th index
1488:35 - so in these three steps
1488:37 - we are simply performing the swap
1488:40 - of the values present in the jth
1488:43 - and the j plus 1th index
1488:45 - because they are in wrong order
1488:47 - as value at the jth index is greater than value at j plus 1th index
1488:53 - so after we perform swap
1488:59 - we simply assign a value true
1489:02 - to a swap variable
1489:05 - to keep the track
1489:07 - that inside this for loop
1489:09 - when we compare the adjacent elements
1489:12 - we did perform a swap
1489:17 - so after every iteration
1489:20 - here what we do is
1489:24 - we simply check
1489:27 - that whether we perform any swap or not
1489:31 - so if we didn't perform the swap
1489:37 - we know that array is already sorted
1489:40 - because all the adjacent elements are at its correct position
1489:44 - so we simply break
1489:46 - from this algorithm
1489:49 - and if we had performed any swap
1489:51 - then the value would have been true
1489:53 - so we are unsure till this point
1489:56 - that whether array is sorted or not
1489:58 - but if the value it hold its false
1490:00 - then we are sure that array is already sorted
1490:02 - so when this is the bubble sort algorithm
1490:07 - which we already discussed in the previous lecture
1490:10 - and in this lecture we have simply provided the code for it
1490:14 - so now let's test its working
1490:18 - so here what we do is
1490:20 - we simply call the sort method
1490:23 - we provide the array
1490:28 - and after we have performed the sorting
1490:32 - we simply print the array again
1490:36 - so if I run the code now
1490:43 - so from here you can see initially
1490:45 - the array was 5 1 2 9 10
1490:49 - which is the content of array before sorting
1490:52 - and then we perform the sort on this array
1490:56 - and after performing the sort
1490:58 - we simply printed the array again
1491:00 - and we found that array sorted
1491:03 - with all elements to its correct position
1491:06 - 1 2 5 9 10
1491:09 - so the array sorted in ascending order
1491:14 - in this tutorial we saw
1491:16 - the demonstration of the bubble sort algorithm
1491:20 - we tested its working in the main method
1491:25 - so friends I hope you like this video
1491:27 - thanks have a nice day
1491:29 - hello everyone
1491:35 - so friends in our previous lecture we discussed about the bubble sort algorithm
1491:40 - so in this lecture we will discuss
1491:43 - about the insertion sort algorithm
1491:49 - so let's discuss this algorithm in detail
1491:54 - so here if you see insertion sort is a simple sorting algorithm
1491:59 - works the way we sort playing cards in our hands
1492:04 - so when we play with the deck of cards
1492:07 - usually most of the games are involved
1492:10 - where we keep few cards in our hand
1492:14 - and what we generally do is we keep them in proper order
1492:19 - so how do we manage to keep them in proper order is
1492:22 - we use the insertion sort algorithm
1492:25 - so let's say we have this deck of cards
1492:27 - which is lying in front of us
1492:30 - and let's say we pick few random cards
1492:33 - from the top of the deck
1492:35 - so usually what we do is
1492:37 - when we pick up the first card
1492:40 - we simply keep it in our hand because it is already sorted
1492:44 - and when we pick the second card
1492:46 - the card which we have picked
1492:48 - we simply compare it with the card which we have in our hand
1492:52 - and based on the comparison
1492:54 - we either keep that card before or after the first card
1492:59 - the deck of cards which is lying in front of us
1493:02 - are basically in random order
1493:04 - or you can say they are basically unsorted form
1493:07 - and the cards which we have in our hand
1493:10 - are basically kept in sorted form
1493:14 - so when we pick up the third card
1493:17 - from the random cards
1493:19 - now the card which we have picked
1493:21 - we simply compare it with the cards which we have in our hand
1493:24 - so we compare the third card with second
1493:28 - and then with the first card
1493:30 - and based on the order which we are following
1493:33 - we simply place the third card
1493:35 - either after the second card
1493:37 - or in between first and second card
1493:39 - or just before the first card
1493:42 - so similarly let's say we have this unsorted array
1493:46 - so using the insertion sort algorithm
1493:48 - we divide the given array into two parts
1493:51 - one is the sorted part
1493:53 - and the other is the unsorted part
1493:57 - so how the algorithm works is
1493:59 - from the unsorted part
1494:01 - we take the first element
1494:04 - and place at its correct position in the sorted array
1494:08 - so here we are simply picking one element from the unsorted array
1494:13 - and based on some logic we are simply putting that element
1494:16 - into the sorted array at its correct position
1494:18 - so this is done by shifting all the elements which are larger than the first element by one position
1494:26 - so here let's say we are sorting the array in ascending order
1494:31 - so the first element which we pick from the unsorted part
1494:36 - we simply compare the element with each and every element in the sorted array
1494:42 - and all the elements which are larger than the first element
1494:45 - we simply shift them by one position
1494:51 - and as soon as we encounter any element which is smaller than the first element
1494:56 - we simply store this first element just after that
1495:01 - and this process is repeated till unsorted array is not empty
1495:07 - so friend let's see the demonstration of insertion sort algorithm with an example
1495:12 - we will take an unsorted array
1495:14 - we apply the algorithm mentioned here
1495:17 - and we will see that how we can sort the array
1495:21 - so friend here you can see that we have this array
1495:24 - from index 0 to 5
1495:26 - so basically there are 6 elements
1495:30 - with the value as 3, 1, 5, 2, 6, 4
1495:34 - now let's say we want to sort this array in ascending order
1495:39 - so how do we start this algorithm is
1495:42 - we simply pick the first element
1495:45 - so here it is 3
1495:47 - and as we have picked the element 3
1495:50 - we know that there is only one element
1495:53 - so it's already sorted
1495:55 - so basically this algorithm starts from the second element
1495:59 - because the first element is already sorted
1496:03 - so friends in our previous slide we discussed
1496:06 - that we divide the array in two parts
1496:08 - one is the sorted part and other is the unsorted part
1496:12 - so when we start our algorithm from the second element
1496:18 - so the elements to the left are basically sorted
1496:22 - and the elements to the right are basically unsorted
1496:27 - so now what we do is from the unsorted part
1496:30 - we simply pick the first element
1496:34 - which is 1
1496:35 - and what do we do is we simply store this element
1496:39 - let's say to a temporary variable
1496:42 - so as soon as we store this element to a temporary variable
1496:46 - what do we do is we simply provide a whole here
1496:50 - that this part is empty
1496:53 - so after providing this empty space what do we do is
1496:56 - we simply compare 1
1496:59 - with the element
1497:01 - in the sorted array
1497:03 - now as we are sorting this array in ascending order
1497:06 - we simply compare that whether 1 is less than 3 or not
1497:11 - so here 1 is less than 3
1497:14 - so therefore 1 should come before 3
1497:17 - here you can see there is no space
1497:19 - so what do we do is
1497:22 - as we discussed in our previous slide
1497:25 - we simply shift the elements which are larger than
1497:29 - 1 by 1 position
1497:36 - so here we will simply shift 3 to this empty space
1497:41 - so after we perform this shift
1497:44 - are there any other elements in the sorted array or not
1497:48 - so here you can see there was only 1 element 3
1497:52 - there are no other elements
1497:54 - so we simply place 1 at its correct position
1497:59 - so after placing 1 at its correct position
1498:03 - you can see
1498:08 - that now
1498:10 - our sorted array has 2 elements
1498:13 - 1 and 3 in sorted form
1498:17 - so now we simply pick the first element from the unsorted array
1498:21 - so we simply pick 5
1498:24 - we store it into a temporary variable
1498:27 - and we create an empty space here
1498:30 - now what do we do is
1498:33 - we compare 5 with 3
1498:36 - and we know that 3 is smaller than 5
1498:40 - therefore 5 has to be placed after 3
1498:44 - which is this spot only
1498:47 - so there is no shift because
1498:50 - the element to which we are comparing
1498:53 - in the sorted array
1498:54 - is already small
1498:57 - from the element which we picked from the unsorted array
1499:00 - so the position of 5 will not change
1499:04 - 5 will be stored at its own position
1499:08 - and here you can see
1499:10 - that as 3 was less than 5
1499:12 - we didn't compare 1 with 5 because
1499:15 - as this is a sorted array
1499:17 - 1 will be by default
1499:19 - smaller than 5
1499:21 - so after placing 5 at index 2
1499:29 - now our sorted array has 3 elements
1499:32 - 1, 3, 5
1499:34 - and from the unsorted array we simply pick
1499:37 - the first element which is 2
1499:41 - we store this 2 into a temporary variable
1499:44 - and we create an empty space here
1499:47 - now what we do is
1499:49 - we compare 2 with 5
1499:52 - so 2 is less than 5
1499:55 - so we know that 2 must be lying somewhere before 5
1499:59 - but here you can see in sorted array there is no space left
1500:03 - so what do we do is
1500:05 - we simply shift the larger element by 1 position
1500:09 - and as here is the empty space
1500:12 - we can simply shift it here
1500:14 - so 5 comes here
1500:19 - and the empty space comes here
1500:25 - so friends here we are not sure that whether
1500:28 - this is the correct position of 2 or not
1500:30 - so what do we do is
1500:32 - we simply compare 2 with this element
1500:35 - which is 3
1500:37 - so here you can see 3 is also
1500:39 - greater than 2
1500:41 - so we know that 2 must be lying somewhere
1500:43 - before 3
1500:45 - so what do we do is
1500:47 - we simply shift 3 by a position
1500:52 - and as here is the empty space
1500:55 - 3 comes here
1500:57 - and the empty space goes here
1501:03 - so friends we are still not sure whether 2
1501:06 - must be placed here or not
1501:08 - so we simply compare 2 with 1
1501:11 - and here you can see that 1 is smaller than 2
1501:14 - so therefore we are sure that
1501:16 - 2 must be lying after 1
1501:19 - and the position after 1 is empty
1501:21 - so we simply store 2
1501:23 - at this empty position
1501:28 - so friends after this step
1501:33 - now we have 4 sorted elements
1501:36 - and 2 unsorted elements
1501:40 - so we simply pick the first element
1501:41 - from the unsorted part
1501:43 - which is 6
1501:45 - we store 6 in the temporary variable
1501:48 - we create a empty space here
1501:50 - and we compare 6
1501:52 - with 5
1501:55 - so as 6 is greater than 5
1501:57 - we know that it must be lying after 5
1502:01 - so after 5 we have this empty space
1502:04 - so 6 will be stored at its own position
1502:11 - so now our sorted part is
1502:13 - 5 elements
1502:15 - 1, 2, 3, 5 and 6
1502:18 - which are sorted
1502:20 - and in our unsorted part
1502:22 - we have now only 1 element left
1502:24 - so we simply pick
1502:26 - the first element which is 4
1502:29 - we store it into a temporary variable
1502:32 - and we create an empty space here
1502:35 - now we compare 4 with 6
1502:37 - so we have 6 elements
1502:38 - now we compare 4 with 6
1502:41 - so 4 is smaller than 6
1502:44 - so it must be lying before 6
1502:46 - but there is no space left here
1502:49 - so we simply shift 6 by 1 position here
1502:56 - so 6 comes here
1502:58 - and we have empty spot here
1503:03 - so now we are not sure whether
1503:05 - we simply put 4 here or not
1503:09 - so we simply compare 4 with an element
1503:11 - just before the empty spot
1503:13 - which is 5
1503:15 - so that we are sure
1503:17 - that whether 4 can be placed here or not
1503:20 - so as 5 is greater than 4
1503:23 - therefore we know that 4 must be lying
1503:25 - before this element
1503:27 - but here there is no space
1503:30 - so we simply shift
1503:32 - 5 by 1 position
1503:34 - to this empty spot
1503:39 - and the empty spot reaches here
1503:42 - now we are still not sure
1503:44 - whether we need to place 4 here or not
1503:47 - so we simply compare 4 with 3
1503:50 - now as 4 is greater than 3
1503:52 - we know that it must be lying
1503:54 - after 3
1503:56 - and here you can see after 3 we have this empty space
1503:59 - so we simply store 4
1504:01 - to this empty space
1504:02 - so then after this step you can see
1504:09 - the complete array sorted
1504:11 - so here we saw the insertion sort technique
1504:14 - where we divided the array into 2 parts
1504:17 - one was the sorted part
1504:19 - and other was the unsorted part
1504:22 - and with each step we simply picked
1504:25 - the first element of the unsorted part
1504:27 - and we simply placed it into its correct position
1504:30 - in the sorted part
1504:32 - and this we did
1504:34 - till the complete array was sorted
1504:38 - so in this lecture we saw the basic demonstration
1504:41 - of insertion sort technique
1504:44 - in our next lecture we will see
1504:46 - the working of the code step by step
1504:48 - using an animation
1504:51 - I hope you like this video
1504:53 - thanks have a nice day
1504:54 - hello everyone
1505:01 - so friends in our previous lecture we discussed about the insertion sort
1505:06 - and we saw the demonstration of the sorting algorithm
1505:10 - now in this lecture we will see
1505:13 - the demonstration of insertion sort algorithm step by step
1505:19 - so friends here you can see
1505:21 - that this is the algorithm to perform insertion sort
1505:26 - so let's say we are given an array having 5 elements
1505:30 - which contains values as 5, 1, 9, 2, 10
1505:35 - so here you can see the values are in unsorted form
1505:41 - so let's see the demonstration of this algorithm step by step
1505:44 - to sort this array in ascending order
1505:48 - so here
1505:50 - the number of elements inside this array are 5
1505:54 - which are ranging from index 0 to 4
1506:00 - so friends while performing the insertion sort
1506:03 - the first thing we encounter is the for loop
1506:07 - so here you can see this for loop goes from i equal to 1
1506:11 - and it goes till i is less than n
1506:15 - so friends in our previous lecture we discussed that when we perform insertion sort
1506:20 - we usually divide the array into two parts
1506:23 - one is the sorted part
1506:25 - and the other is unsorted part
1506:28 - so here you can see that when we start sorting this array
1506:33 - all the elements are in unsorted part
1506:36 - and no element is in sorted part
1506:39 - so what we do is we simply pick one element
1506:42 - which is the first element of the unsorted part
1506:45 - so let's say we pick 5
1506:48 - and as soon as we pick 5
1506:50 - as 5 is the only element
1506:53 - which we want to sort
1506:55 - therefore we directly place 5 to the sorted part
1506:59 - because we don't have to compare 5 with any element
1507:02 - so instead of doing this stuff
1507:04 - we directly start from i equal to 1
1507:07 - which is this position
1507:09 - because 5 is already sorted
1507:11 - into its correct position
1507:14 - so usually this algorithm starts from i equal to 1
1507:17 - so here you can see
1507:19 - that 5 is in sorted part
1507:22 - and all other elements are in unsorted part
1507:25 - so we always start from i equal to 1
1507:32 - and as i having value as 1 is less than 5
1507:35 - therefore the condition in for loop comes out to be true
1507:43 - so friends here when we perform insertion sort
1507:46 - one rule of thumb is
1507:48 - we always pick the first element
1507:51 - of the unsorted part
1507:53 - and we try to put it in sorted part
1507:56 - by comparing one with all the elements in the sorted part
1508:00 - and placing it into its correct position
1508:04 - so when we perform this comparison in the sorted part
1508:07 - all the elements which are larger than
1508:10 - this first element
1508:12 - we simply shift them by one position
1508:15 - so that there is an empty space
1508:16 - where we can simply put this element
1508:20 - so here you can see the space are already occupied
1508:23 - with some numbers
1508:25 - so when we perform a shift
1508:27 - there can be a chance that some numbers can be overridden
1508:30 - so what we do is
1508:32 - we simply store this value
1508:35 - which we want to compare
1508:37 - with the elements in the sorted part
1508:39 - we simply store it into a temporary variable
1508:43 - here
1508:44 - moving ahead
1508:48 - so friends now we want to compare this element
1508:51 - with the elements present in the sorted part
1508:54 - so here you can see
1508:56 - as we have picked the first element of the unsorted part
1508:59 - if we go one position back
1509:01 - we will get the elements of the sorted part
1509:05 - so we simply do i-1
1509:08 - and to access the elements of the sorted part
1509:11 - we simply store it in the j variable
1509:15 - so here j becomes zero
1509:20 - so usually the elements of the unsorted part are accessed via i
1509:25 - and the elements of the sorted part are accessed via j
1509:33 - so friends now we provide a while loop
1509:36 - because we want to compare this element
1509:39 - with each and every element in the sorted part
1509:42 - and all the elements which are greater than
1509:45 - this element
1509:47 - we simply shift it by one position
1509:50 - so that there can be a space
1509:52 - where we can simply put this element
1509:55 - and as we are sorting this in ascending order
1509:58 - so here the condition we provide in while loop is
1510:02 - that j should be greater than equal to zero
1510:05 - because inside this while loop we are decrementing j by 1
1510:09 - so we have to provide this condition
1510:12 - that j should be greater than equal to zero
1510:15 - because we don't want to go outside of this array
1510:19 - and also why we are decrementing j by 1 is
1510:22 - we need to compare this element
1510:25 - with each and every element in the sorted part
1510:28 - so that we can put this element into its correct position
1510:32 - so the first condition is j should be greater than equal to zero
1510:34 - so here j is equal to zero
1510:37 - therefore this condition comes out to be true
1510:41 - and then we provide one more condition as
1510:44 - the element at jth index
1510:46 - is greater than
1510:48 - temp or not
1510:50 - so here you can see the value of j is zero
1510:53 - so the element at index 0 is 5
1510:57 - and here you can see 5 is greater than 1
1511:01 - so we know that as we are sorting
1511:04 - this array in ascending order
1511:07 - one should be placed before 5
1511:10 - so therefore this condition in while loop comes out to be true
1511:14 - and we want to find out the correct position of 1
1511:18 - so what do we do is
1511:21 - in the first step
1511:23 - as 5 is greater than 1
1511:26 - and as we discussed in our previous slide
1511:29 - that all the elements which are greater than 1
1511:32 - we have to shift by one position
1511:34 - so how we perform shift is
1511:37 - as we have already stored 1
1511:40 - into this temporary variable
1511:42 - therefore it's like a hole here
1511:45 - and we can shift 5 here
1511:47 - so we simply assign the value stored at jth index
1511:52 - which is 5
1511:54 - 2 value at j plus 1th index
1511:57 - so j is zero and j plus 1
1512:00 - is 1
1512:02 - so we are simply storing 5
1512:04 - to this place
1512:08 - so here now 5 has been shifted to this position
1512:15 - and after this shift we simply decrement j by 1
1512:19 - because now we want to compare 1 with an element just before 5
1512:23 - so we simply decrement j by 1
1512:26 - so as j is zero
1512:29 - j becomes minus 1
1512:31 - so here it means
1512:34 - that now j is pointing to minus 1
1512:37 - which is an index
1512:39 - which is out of this array
1512:45 - so friend as here you can see
1512:47 - that in our sorted part there was only one element 5
1512:50 - so we compare that element with 1
1512:54 - and there are no more elements to compare
1512:57 - so therefore this condition
1512:58 - where j is greater than equal to zero
1513:01 - comes out to be false
1513:02 - because j is equal to minus 1
1513:05 - so the condition in while loop comes out to be false
1513:08 - and while loop exits
1513:12 - and at the end
1513:14 - we have found a position where we need to store 1
1513:17 - so that position is j plus 1
1513:20 - because as j is pointing to minus 1
1513:23 - so it means j at travel till minus 1 position
1513:26 - to basically shift the largest elements
1513:29 - by 1 position
1513:31 - so when we do j plus 1
1513:34 - here we are simply storing
1513:37 - the value 1
1513:39 - at index 0
1513:41 - because as j is minus 1
1513:43 - j plus 1 becomes 0
1513:45 - so we are simply storing 1
1513:47 - at 0th index
1513:56 - so friend after performing this all steps
1513:59 - now here you can see
1514:01 - that 1 and 5
1514:03 - are basically
1514:05 - 2 elements which are sorted
1514:07 - so therefore
1514:09 - with each for loop iteration
1514:11 - we will get one element
1514:13 - which will be now part of the sorted array
1514:16 - so here
1514:19 - now 1 and 5 are part of sorted array
1514:22 - and rest of the elements are part of unsorted array
1514:25 - sorted array
1514:27 - so here now we will increment i by 1
1514:30 - so i becomes 2
1514:36 - so friend as we already discussed
1514:39 - that we simply pick the first element
1514:42 - of the unsorted part
1514:44 - in order to make this element
1514:46 - to be placed in its correct position in the sorted array
1514:49 - so we simply start with storing
1514:52 - the value at i at index
1514:53 - into a temporary variable
1514:56 - and why we are storing into this temporary variable
1514:59 - is because we want to create a whole here
1515:02 - so moving ahead
1515:05 - now in order to access the sorted array
1515:08 - we simply do i minus 1
1515:12 - so the value of j is 1
1515:16 - in while loop we simply check whether j is greater than
1515:19 - or equal to 0 or not
1515:20 - so j is greater than 0
1515:25 - so this condition comes out to be true
1515:28 - and then we simply check
1515:30 - that the value stored at jth index is greater than
1515:33 - temp or not
1515:35 - so here you can see
1515:37 - value of j is 1
1515:40 - so the value at first index is 5
1515:43 - and 5 is not greater than 9
1515:47 - so therefore this condition comes out to be false
1515:50 - and the while loop exits
1515:54 - so here you can see that as we are sorting this array
1515:58 - in ascending order
1516:00 - we want a correct position for 9
1516:03 - in the sorted array
1516:05 - so as there are only two elements which are sorted
1516:08 - 1 and 5
1516:10 - when we compared 9 with 5
1516:12 - we found that
1516:14 - 5 was not greater than 9
1516:16 - so therefore the correct position of 9 would be after 5
1516:20 - so here this while loop exits
1516:25 - and at the end we simply store the value 9
1516:29 - in the array at jth index
1516:32 - so value of j is 1
1516:34 - when we do plus 1 we get 2
1516:37 - so we simply store the value 9
1516:40 - as index 2
1516:48 - so now you can see
1516:50 - that 3 elements 1, 5, 9
1516:53 - are properly sorted
1516:56 - so therefore 9 will be now part of this sorted array
1517:02 - we increment i by 1
1517:04 - i becomes 3
1517:10 - and now we simply pick
1517:12 - the first element of the unsorted array
1517:15 - so we simply store
1517:18 - the value 2
1517:20 - as a temporary variable
1517:24 - because now we want to place this 2
1517:27 - into its correct position
1517:29 - in the sorted array
1517:31 - so when we perform these steps
1517:33 - we need to shift some of the elements
1517:36 - by one position
1517:38 - so that we can place 2
1517:40 - to its correct position
1517:43 - so when we shift this element by one position
1517:46 - we need to create a space here
1517:48 - so what do we do is
1517:49 - we simply store this value
1517:51 - somewhere into the temporary variable
1517:53 - because we need to refer this
1517:55 - while comparing
1517:57 - it with the elements in the sorted array
1518:02 - so in order to access
1518:04 - the sorted array we simply do
1518:06 - i-1
1518:08 - so j will keep the track
1518:11 - of the sorted array
1518:16 - so now we will perform the comparison
1518:19 - that j is greater than or equal to 0
1518:22 - so value of j is 2
1518:24 - therefore this condition is true
1518:27 - so now we will compare
1518:29 - this 2 stored in this temporary variable
1518:33 - with the element stored at jth index
1518:35 - which is 9
1518:37 - so here you can see
1518:38 - 9 is greater than 2
1518:40 - therefore the condition in while loop comes out to be true
1518:46 - and as 9 is greater than 2
1518:48 - we know that 2 must come before 9
1518:51 - so for 2 coming before 9
1518:53 - we need to create a space here
1518:56 - so what do we do is
1518:58 - we simply shift this value by one position
1519:01 - by storing
1519:03 - the value at jth index
1519:05 - into j plus 1th index
1519:08 - so j is 2
1519:10 - so this value 9
1519:12 - we are storing in j plus 1th index
1519:15 - which is the 3rd index
1519:18 - so 9 comes here
1519:20 - with a shift
1519:22 - and as we have already stored this value at temporary variable
1519:25 - we can overwrite this part
1519:27 - so 9 goes to the 3rd index
1519:33 - so now we have compared it with 9
1519:35 - so we simply decrement j by one position
1519:39 - because there can be more elements
1519:41 - which can be greater than 2
1519:45 - so j becomes 1
1519:47 - and as j is greater than 0
1519:52 - this condition comes out to be true
1519:56 - and the value stored at jth index
1519:59 - which is 5
1520:01 - is also greater than 2
1520:03 - therefore the condition in while loop comes out to be true
1520:08 - and we simply shift 5 by 1 position
1520:11 - by assigning
1520:13 - the value at jth index
1520:15 - to value at j plus 1th index
1520:18 - so we are simply shifting 5 by 1 position
1520:21 - because value of j is 1
1520:23 - so this value
1520:25 - we are assigning it to j plus 1
1520:28 - which is the 2nd index
1520:35 - and then we will decrement j by 1
1520:40 - because there can be more elements
1520:42 - which can be greater than 2
1520:45 - so j becomes 0
1520:49 - now here as j is greater than or equal to 0
1520:52 - this condition comes out to be true
1520:55 - but the value stored at jth index which is 1
1520:59 - is not greater than 2
1521:02 - therefore we know that
1521:04 - this value 2 will be stored
1521:06 - somewhere after 1
1521:09 - and as we have already shifted 5 to its correct position
1521:13 - this position is actually a space
1521:15 - where we can store 2
1521:18 - so here this condition comes out to be false
1521:25 - and at the last step
1521:27 - as j is pointing to 0
1521:29 - we know that we need to store 2 after 1
1521:33 - so we simply store this temp value
1521:36 - to j plus 1th index
1521:39 - which is the 1st index
1521:43 - so 2 comes here
1521:45 - which is actually 2's correct position
1521:54 - now after this 4 loop ends
1521:56 - 1 2 5 9
1521:59 - will become part of the sorted array
1522:05 - we will simply increment i by 1
1522:07 - so i becomes 4
1522:13 - and now we simply want to
1522:15 - put 10 to its correct position in sorted array
1522:19 - so we simply store 10
1522:21 - into this temporary variable
1522:23 - moving ahead
1522:28 - so now as we want to compare
1522:30 - the value stored at temporary variable
1522:33 - with the elements in sorted array
1522:36 - we need to access the sorted array
1522:38 - so we simply do i minus 1
1522:40 - and we store it into j
1522:43 - so j becomes 3
1522:46 - which is the last element of the sorted array
1522:52 - so as j is greater than or equal to 0
1522:56 - this condition comes out to be true
1523:00 - but the value stored at jth index
1523:03 - which is 9
1523:05 - is not greater than 10
1523:08 - so therefore this condition comes out to be false
1523:13 - and we simply store
1523:17 - this value 10
1523:20 - in this array at jth index
1523:23 - because 9 is at its correct position
1523:26 - and as it is less than 10
1523:28 - therefore 10 should be stored
1523:30 - just after that
1523:32 - so we simply store 10
1523:34 - to jth index
1523:43 - so friends here you can see
1523:45 - that not 10 will also be part of the sorted array
1523:48 - and as there are no more elements left to be compared
1523:52 - because when we increment i by 1
1523:55 - i becomes 5
1523:58 - and as 5 is not less than 5
1524:00 - therefore the condition in for loop comes out to be false
1524:03 - and this for loop exits
1524:10 - so friends here you can see
1524:11 - that we have sorted this array
1524:13 - into ascending order
1524:15 - storing in the form as 125910
1524:20 - so friends in this lecture we discussed about
1524:23 - the certain sort algorithm
1524:25 - by demonstrating
1524:27 - the algorithm step by step
1524:30 - where we actually divided the array into two parts
1524:33 - the sorted part
1524:35 - and the unsorted part
1524:37 - and with each iteration
1524:39 - we picked the first element of the
1524:41 - sorted part
1524:43 - and we compare this element
1524:45 - with each and every element in the sorted part
1524:47 - to place the element
1524:49 - into its correct position
1524:51 - and how we place the element
1524:53 - in its correct position is
1524:55 - is by shifting all the larger elements
1524:58 - which was greater than this first element
1525:00 - of the unsorted array
1525:02 - so friends this is the demonstration
1525:04 - of the algorithm step by step
1525:06 - now lets go to eclipse
1525:08 - and see the implementation of this algorithm
1525:09 - and its working
1525:11 - i hope you like this video
1525:13 - thanks have a nice day
1525:18 - hello everyone
1525:20 - so friends in our previous lecture we saw
1525:23 - the demonstration of the
1525:25 - insertion sort algorithm step by step
1525:27 - so in this lecture we will code the algorithm
1525:30 - and we will test its working
1525:33 - so here i have created one classes
1525:35 - insertion sort
1525:37 - this classes method has print array
1525:40 - which simply prints
1525:42 - the contents of this array
1525:44 - on the console
1525:46 - which we already discussed in our previous lecture
1525:50 - so here lets say
1525:52 - we want to sort this array
1525:54 - having 5 elements that is 5, 1, 2, 9 and 10
1525:59 - so when we will print these elements
1526:01 - on the console
1526:03 - lets say if i run the code
1526:10 - so here we can see it printed 5, 1, 2, 9 and 10
1526:15 - so here the array you can see is not in sorted form
1526:20 - so lets write the code
1526:22 - to sort this array using the insertion sort
1526:26 - so here i will be creating one method as public
1526:31 - void
1526:33 - lets say i give the name of the method as sort
1526:36 - so this method will take
1526:38 - the array
1526:40 - which we want to sort
1526:43 - in the first step what we do is
1526:46 - we simply compute
1526:48 - the number of elements
1526:50 - inside the array
1526:54 - by storing
1526:56 - the length of the array
1526:58 - by storing
1527:00 - the length of the array
1527:02 - by storing
1527:03 - the length of the array
1527:05 - to the integer variable n
1527:08 - and then as we discussed in our previous lecture
1527:11 - that we start our algorithm
1527:13 - with a for loop
1527:16 - where value of i
1527:19 - will be starting from 1
1527:22 - and not from 0 because
1527:24 - the first element
1527:26 - inside this array
1527:28 - when we pick to sort
1527:31 - we know that its already sorted
1527:33 - so we simply start from the second element
1527:36 - so i starts from 1
1527:41 - and it goes till i is less than n
1527:48 - so friends we also discussed
1527:50 - that when we perform insertion sort
1527:52 - we usually divide the array into two parts
1527:55 - one is the sorted part
1527:57 - and the other is unsorted part
1528:00 - so here the value which is tracked by i
1528:03 - is usually
1528:08 - the unsorted part
1528:10 - and the value which j tracks
1528:12 - which we will see later
1528:14 - is usually the sorted part
1528:17 - so here by providing this for loop
1528:20 - with each iteration
1528:22 - we simply pick one element
1528:24 - and we place that element
1528:26 - into its correct position
1528:28 - by applying the insertion sort
1528:30 - so we simply store
1528:33 - the first element
1528:35 - of the unsorted part
1528:37 - into the temporary variable
1528:44 - and after we store this
1528:46 - now we simply access the sorted part
1528:55 - so here you can see
1528:57 - that as i starting from 1
1528:59 - so the element which is stored at the 0th index
1529:02 - is already sorted
1529:04 - and we can access it via j
1529:07 - so now j will basically keep the track of
1529:11 - the sorted part
1529:17 - we provide a while loop
1529:22 - where we provide two conditions
1529:24 - that j
1529:26 - should be greater than
1529:28 - or equal to 0
1529:31 - and as you want to compare
1529:33 - the value stored into the temporary variable
1529:36 - with each and every element stored in the sorted part
1529:40 - we provide another condition as
1529:42 - the element stored at the jth index
1529:47 - is greater than temp or not
1529:49 - so if this is true
1529:51 - inside this while loop what we do is
1529:54 - we simply shift all the larger elements
1529:57 - which are greater than temp
1529:59 - by one position
1530:01 - and how do we do it
1530:08 - we simply take
1530:10 - the value stored at jth index
1530:13 - and we transfer it to the j plus 1th index
1530:17 - so here we are simply
1530:22 - shifting
1530:27 - larger elements
1530:34 - to temp by one position
1530:36 - and after shifting the elements
1530:38 - we simply decrement the value of j by 1
1530:44 - because inside this while loop
1530:46 - we need to compare the temporary variable
1530:49 - with each and every value
1530:51 - of the sorted part
1530:54 - so friend while we are shifting all the larger elements
1530:58 - by one position
1531:00 - which are actually larger than
1531:02 - value stored into this temporary variable
1531:04 - is because we need to find
1531:06 - the correct position
1531:08 - of the value stored into this temporary variable
1531:12 - so after we perform the shift by one position
1531:15 - we decrement the value of j by 1
1531:18 - and then we again compare it with the
1531:21 - value stored into the temporary variable
1531:25 - and this loop goes on till
1531:27 - greater than or equal to zero
1531:29 - so this is basically a boundary check
1531:32 - that we don't go to the out of the boundaries
1531:35 - of the array
1531:37 - and after this while loop
1531:40 - we simply store
1531:47 - the value stored into this temporary variable
1531:50 - into its correct position
1531:53 - which is at j plus 1th index
1531:55 - because here we will exit the while loop
1531:58 - with these two conditions
1532:01 - and as we have already decremented j by 1
1532:04 - we note at the correct position
1532:07 - for the value stored into this temporary variable
1532:10 - would be at j plus 1th index
1532:13 - so friend after this for loop completes
1532:16 - for one iteration
1532:18 - our sorted part increases
1532:20 - by one value
1532:22 - and with each iteration
1532:25 - the sorted part increases
1532:27 - and the unsorted part decreases
1532:29 - and finally when this for loop exits
1532:32 - all the elements of the unsorted part
1532:35 - now becomes part of the sorted part
1532:40 - so friend this is the insertion sort algorithm
1532:44 - we discussed this algorithm
1532:46 - in greater detail in our previous lecture
1532:49 - and in this lecture we have simply coded
1532:51 - the algorithm
1532:53 - so now we will test its working
1532:56 - so here we will call
1533:00 - the sort method
1533:03 - we pass in the array
1533:06 - and after the sort happens
1533:09 - we will simply print the array again
1533:16 - so this print array will be called before sort
1533:19 - and this print array will be called after sort
1533:21 - so if I run the main method now
1533:27 - so here you can see the array is already sorted
1533:30 - initially it printed 5 1 2 9 10
1533:33 - which was the unsorted array
1533:35 - and then it printed 1 2 5 9 10
1533:39 - which is the sorting of the array in ascending order
1533:45 - so friend in this lecture we saw the code for the insertion sort
1533:49 - and we tested its working in main method
1533:52 - I hope you like this video
1533:55 - thanks have a nice day
1534:01 - hello everyone
1534:03 - so in this video we will discuss about the selection sort algorithm
1534:08 - we will first understand what is selection sort
1534:11 - and we will see a small demonstration of selection sort algorithm
1534:14 - so here as we are performing selection sort
1534:19 - we are basically sorting the elements of an array
1534:23 - into ascending order
1534:26 - so let's say we are given with this array
1534:29 - with 5 elements
1534:31 - as 3 1 5 2 6
1534:34 - we know these elements are unsorted
1534:36 - and we want to sort them in ascending order
1534:39 - using selection sort algorithm
1534:40 - so in this algorithm what we do is
1534:45 - we first divide this array into 2 parts
1534:48 - one is the sorted part and other is the unsorted part
1534:52 - so here you can see at the start all the elements are unsorted
1534:58 - so our sorted part and unsorted part looks like this
1535:02 - that all the elements currently are unsorted
1535:05 - and there are no elements in the sorted part
1535:11 - now what we do inside this algorithm is
1535:14 - let's say we are given with this boundary
1535:17 - what we do is we start with this boundary
1535:20 - and we find which is the minimum element
1535:24 - among these all the elements in the unsorted part
1535:27 - so once you find out which is the minimum element among these elements
1535:32 - we simply swap it with the left most element of this boundary
1535:38 - and as soon as we swap them
1535:41 - we know that the minimum element which we found is at its correct position
1535:45 - so for example here you can see
1535:48 - when we pick the minimum element
1535:51 - and swap it with the left most element of the unsorted part
1535:54 - which is this boundary
1535:56 - after swap the element now becomes part of the sorted array
1536:01 - so for example
1536:03 - among these 5 elements
1536:04 - if we find out which is the minimum element
1536:08 - we can find that one is the minimum element
1536:11 - so what we do is
1536:13 - we see which is the left most element which is 3 here
1536:16 - and we simply swap these 2 values
1536:19 - so it would look something like this
1536:22 - that these elements are swapped
1536:25 - and we also know that as one was the minimum element
1536:28 - among these all the elements
1536:30 - one is at its correct position
1536:32 - if we actually sort this array completely
1536:35 - it simply signifies that
1536:37 - now one is the part of the sorted array
1536:40 - and these 4 elements are part of the unsorted array
1536:45 - so this finding of minimum element in the unsorted part
1536:49 - and swapping it with the left most element of the unsorted part
1536:54 - is repeated
1536:56 - till all the elements are part of the sorted array
1536:59 - and there are no elements left in the unsorted part
1537:02 - so the idea behind this algorithm is very simple
1537:05 - we divide the array into 2 parts
1537:08 - sorted part and unsorted part
1537:10 - from the unsorted part
1537:12 - we pick the minimum element
1537:14 - and we swap it with the left most element of the unsorted part
1537:18 - so the element which is next to this boundary
1537:21 - we simply swap the minimum element with this
1537:24 - and after we perform this swap
1537:26 - we know that the minimum element which we figured from this array
1537:30 - is at its correct position
1537:32 - so at the each pass
1537:34 - 1 1 element from the unsorted part becomes
1537:37 - the element of the sorted part
1537:40 - and at the last we only get the sorted part
1537:44 - so let's see the demonstration of this algorithm
1537:47 - with a small example
1537:48 - so let's suppose we are given with this array
1538:01 - having 6 elements
1538:03 - index from 0 to 5
1538:05 - and they are unsorted
1538:07 - so let's say if we want to sort them in ascending order
1538:12 - here length of this array is 6
1538:15 - so the first step we do is
1538:16 - we divide this array into 2 parts
1538:19 - sorted and unsorted part
1538:21 - so initially all the elements are unsorted
1538:25 - so therefore
1538:27 - the sorted part has no elements
1538:29 - and the unsorted part has all the elements
1538:33 - now let's see what happens when we perform the first pass
1538:37 - so here what we do is
1538:39 - we simply start from the unsorted part
1538:43 - and we find that there is 1 element 3
1538:47 - so let's say we are assuming that 3 is the minimum element of this complete array
1538:53 - now what we do is
1538:57 - we go to its next element and we compare 3 with 1
1539:02 - and we check that whether 1 is less than 3 or not
1539:06 - so here 1 is less than 3
1539:08 - so which means that
1539:10 - our assumption is wrong and 1 will become our new minimum
1539:17 - so 1 becomes our new minimum
1539:20 - and simply we go on like this
1539:24 - we check whether 5 is less than minimum
1539:27 - so 5 is not less than minimum
1539:30 - we move ahead
1539:32 - we check whether 2 is less than minimum
1539:35 - so 2 is not less than 1
1539:37 - so we move ahead
1539:39 - and 4 is also not less than 1
1539:41 - 6 is also not less than 1
1539:47 - so here you can see after we completed the first pass
1539:52 - we found that 1 is the minimum element among all the elements
1539:57 - so now what we do is
1539:59 - we simply swap this 1 with the leftmost element of the unsorted part
1540:05 - so the element next to this boundary we simply swap it with that
1540:09 - so here we will simply swap 3 and 1
1540:17 - so 1 comes here and 3 comes here
1540:20 - and after first pass
1540:22 - 1 is at its correct position
1540:25 - so therefore
1540:28 - now our sorted part has 1 element
1540:31 - and unsorted part has the rest of the elements
1540:35 - now we will simply do the second pass
1540:37 - and we perform the same steps
1540:40 - at first we consider 3 is the minimum element
1540:46 - we compare it with each and every element next to it
1540:52 - so 5 is not less than 3
1540:54 - we move ahead
1540:58 - so here 2 is less than 3
1541:00 - so 2 will become our new minimum
1541:08 - we move ahead
1541:11 - 6 is not less than 2
1541:17 - and 4 is also not less than 2
1541:21 - so after second pass
1541:24 - we found that 2 is the minimum element among the unsorted part
1541:29 - now after we found out that 2 is the minimum element
1541:32 - what we do is we simply swap it with the leftmost element of the unsorted part
1541:37 - so we will simply swap it with 3
1541:43 - so 2 comes here and 3 goes here
1541:46 - and we also know that 2 is at its correct position now
1541:51 - so therefore
1541:54 - now our sorted part has 2 elements
1541:57 - and unsorted part has rest of the elements
1542:02 - so we will go with the third pass now
1542:05 - we assume 5 is the minimum element
1542:10 - and we compare it with the rest of the elements
1542:13 - we check whether 3 is less than 5
1542:16 - so yes 3 is less than 5
1542:19 - so therefore 3 will become our new minimum
1542:27 - we compare whether 6 is less than 3
1542:32 - so it is not
1542:34 - so we move ahead
1542:37 - we check whether 4 is less than 3
1542:40 - so 4 is not less than 3
1542:43 - so after the third pass
1542:46 - we came to know that 3 is the minimum element
1542:49 - among these elements which are part of the unsorted array
1542:53 - so after finding this minimum element
1542:55 - we simply swap it with the leftmost element of the unsorted part
1542:59 - so leftmost element is the 5
1543:03 - so we will simply swap 3 with 5
1543:06 - and now our sorted part has 3 elements
1543:09 - and unsorted part has the rest of the elements
1543:13 - we will continue with the fourth pass
1543:16 - we will assume 5 is the minimum element
1543:19 - among the elements in the unsorted part
1543:23 - we compare it with the rest of the elements
1543:27 - 6 is not less than 5
1543:29 - so we move ahead
1543:31 - and we move ahead
1543:32 - 6 is not less than 5
1543:34 - so we move ahead
1543:37 - 4 is less than 5
1543:39 - so 4 will become our new minimum
1543:46 - so after this pass
1543:48 - among these 3 elements in the unsorted part
1543:51 - we came to know that 4 is the minimum element
1543:54 - and we will simply swap it with the leftmost element of the unsorted part
1543:59 - so we will simply swap 5 and 4
1544:02 - now our sorted part has 4 elements
1544:05 - and unsorted part has the rest of the elements
1544:08 - so our fifth pass will start
1544:11 - we assume 6 is the minimum element
1544:16 - and we compare it with the rest of the elements
1544:19 - so there is only one element which is 5
1544:22 - so we check whether 5 is less than 6
1544:25 - so we compare it with the rest of the elements
1544:28 - so there is only one element which is 5
1544:30 - so 5 is less than 6
1544:33 - so 5 will become our new minimum
1544:40 - and after the fifth pass
1544:42 - we found that among these two elements
1544:45 - 5 was the minimum
1544:47 - so we will simply swap 5 with the leftmost element of the unsorted part
1544:54 - so 5 will come at this place
1544:57 - and 6 will go at this place
1544:58 - after the swap
1545:01 - and once we perform the swap
1545:04 - the minimum element which we swapped becomes part of the sorted array
1545:10 - so from here you can see
1545:12 - that after the fifth pass
1545:14 - 5 came to its correct position
1545:16 - and we are left only with one element
1545:19 - so by default this element at its correct position
1545:22 - so we don't have to perform
1545:24 - these steps on the last element
1545:26 - because it is already at its correct position
1545:29 - so the only thing to consider here is
1545:32 - if the length of array is 6
1545:34 - then there are at least 5 passes
1545:37 - which is n-1
1545:40 - which is the length-1
1545:43 - so if there are 6 elements
1545:45 - we have to perform 5 passes
1545:47 - to get the array in sorted form
1545:52 - so this was the basic idea behind the selection sort algorithm
1545:57 - we usually do 3 steps
1545:59 - first we divide the array into 2 parts
1546:03 - sorted and unsorted
1546:05 - at the start all the elements are in unsorted part
1546:09 - and then we apply the selection sort
1546:12 - in different passes
1546:14 - so with each pass what we do is
1546:17 - we simply find the minimum element
1546:20 - of the unsorted part
1546:22 - and simply swap it with the leftmost element of the unsorted part
1546:27 - and after this swap the minimum element which we just found
1546:30 - becomes part of the sorted array
1546:32 - and this process is repeated
1546:35 - till all the elements are part of the sorted array
1546:39 - so friend this was the basic demonstration of the selection sort algorithm
1546:44 - in our next video we will see
1546:46 - the complete animation of the selection sort algorithm step by step
1546:51 - I hope you have liked this video
1546:53 - and in case you have liked this video
1546:56 - please like, comment, share and subscribe my channel
1546:59 - thanks have a nice day
1547:05 - hello everyone
1547:07 - so in our previous video we saw a basic introduction to selection sort
1547:12 - and we also saw a demonstration that how selection sort is applied on an array
1547:18 - having unsorted elements
1547:20 - and once the algorithm is applied all the elements become sorted
1547:26 - so here let's suppose we are given with this array
1547:29 - where the elements are unsorted
1547:33 - so in selection sort what we actually do is
1547:36 - we divide the array into two parts
1547:38 - one is the sorted part and other is the unsorted part
1547:42 - so at the start all the elements are part of unsorted part
1547:54 - and we have this boundary here
1547:56 - so what we actually do
1547:58 - we simply find out the minimum element in the unsorted part
1548:02 - so here let's say the minimum element among all this element is one
1548:06 - so what we do is
1548:08 - we pick one and we simply swap it with the leftmost element of the unsorted part
1548:15 - and once we swap them
1548:20 - so it would look something like this
1548:22 - and we know that one is at its correct position
1548:24 - because we want to sort the elements in ascending order
1548:28 - so after the swap is done
1548:31 - the element now becomes part of the sorted array
1548:34 - so the boundary goes here
1548:38 - that we have now one element in the sorted part
1548:41 - and rest of the elements in the unsorted part
1548:45 - so this process is repeated for each and every element on the unsorted part
1548:50 - till this boundary reaches to the end of the array
1548:54 - so when all the elements are sorted
1548:57 - the unsorted part has zero elements
1549:00 - and all the elements are in sorted part
1549:02 - so in our previous video we saw step by step demonstration of the algorithm
1549:08 - now we will see the step by step demonstration of the actual code
1549:14 - so here you can see this is the algorithm
1549:17 - to perform the selection sort on an array
1549:20 - and this algorithm will sort the elements into ascending order
1549:24 - so let's say when we call sort method and pass in an array
1549:30 - so let's suppose this is our array
1549:33 - having 5 elements
1549:35 - 5, 1, 10, 2 and 9
1549:38 - now here you can see there index from 0 to 4
1549:43 - moving ahead
1549:46 - in the first step what we do is
1549:48 - we simply store the length of the array
1549:51 - in an integer variable n
1549:54 - so value of n is 5 because we have 5 elements
1549:58 - moving ahead
1550:01 - also friends in our previous video we discussed
1550:04 - that we divide this array into 2 parts
1550:06 - the unsorted part and the sorted part
1550:09 - so when we start the algorithm
1550:11 - the sorted part has zero elements
1550:14 - and unsorted part has all the elements
1550:16 - so here basically what we do
1550:18 - we find the minimum element
1550:20 - in the unsorted part
1550:22 - and once we find that out
1550:24 - we simply swap it with the leftmost element
1550:27 - of the unsorted part
1550:29 - and once the element is swapped
1550:31 - now that element becomes part of the sorted array
1550:34 - and this boundary will get shift by one position
1550:38 - so here you can see this outer for loop
1550:41 - goes from i equal to 0
1550:43 - to a value i less than n minus 1
1550:47 - so here basically i
1550:48 - will keep the track of this boundary
1550:51 - and here you can see it will start from 0
1550:54 - and it will go to less than n minus 1
1550:57 - which is 4
1550:59 - so it will go till 3
1551:01 - here
1551:03 - so why we traverse i to less than n minus 1 because
1551:06 - when we are on the last pass
1551:08 - the last element goes to its correct position
1551:12 - and we don't perform this algorithm on the last element
1551:15 - because we know that
1551:16 - that element is at its correct position
1551:19 - so we will see the demonstration of the algorithm
1551:22 - and it will be more clear to you
1551:24 - so currently we will start with i equal to 0
1551:27 - and 0 is less than 4
1551:30 - so the condition in for loop
1551:33 - will be true and the for loop will execute
1551:38 - so here whatever the value i is holding
1551:42 - it will be simply the indexes of this array
1551:45 - so it can be symbolically represented like this
1551:49 - so in selection sort
1551:51 - our first task is to find the minimum element
1551:54 - among the unsorted part
1551:56 - so here you can see we first assume that let's say
1551:59 - whatever the value i is holding
1552:02 - we treat it as the minimum value
1552:05 - so here we create an integer variable
1552:07 - and we store the value of i
1552:11 - so min will also become 0
1552:12 - which signifies that we are assuming
1552:15 - that value 5 is the minimum element
1552:18 - among these all the elements
1552:25 - and now we provide the inner for loop
1552:28 - now this inner for loop is for actually finding the minimum value
1552:31 - so here this is our assumption
1552:33 - and in order to find the minimum value among all these elements
1552:37 - we need to compare this minimum value
1552:39 - with all the elements of this array
1552:42 - once we find any value which is less than the minimum value
1552:46 - our min will point to that value
1552:49 - so let's see how
1552:51 - so here this for loop will start from i plus 1
1552:55 - because here you can see
1552:57 - we are assuming that 5 is our minimum value
1553:00 - and i is pointing to it
1553:02 - so we start
1553:04 - this inner for loop will j equal to i plus 1
1553:08 - so here you can see value of j will become 1
1553:11 - which is 0 plus 1
1553:13 - so this signifies that we are starting from this value
1553:16 - because we need to compare now 5 with each and every value
1553:20 - of this array
1553:22 - so j starts from i plus 1
1553:25 - and it will go till j is less than n
1553:28 - so less than n will become 4
1553:31 - because we want to compare it with each and every element
1553:34 - so last index of j would be 4
1553:37 - so let's move ahead and see how it works
1553:41 - so in the first step we are simply comparing
1553:44 - that whatever we assume to be the minimum value
1553:48 - is the value at jth index less than
1553:51 - the index value which min is holding
1553:54 - so here you can see the value at array of min would be 5
1554:00 - and array of j would be 1
1554:04 - so now we will simply compare these two values
1554:07 - and here we are checking
1554:08 - that whether 1 is less than 5 or not
1554:12 - so here you can see this condition comes out to be true
1554:18 - so as we have found a minimum value
1554:21 - now what we will do?
1554:23 - we will simply update the minimum to this value
1554:26 - so whatever the value j is holding which is 1
1554:30 - now min will point to this value
1554:34 - holding a value as 1
1554:35 - so min becomes 1
1554:40 - and symbolically it will point to an index 1
1554:45 - moving ahead
1554:49 - will increment j by 1 because now we need to
1554:52 - compare this 1 with rest of the elements
1554:56 - so j becomes 2
1555:02 - now we will compare these two values
1555:06 - and we check whether 10 is less than 1 or not
1555:11 - so 10 is not less than 1
1555:13 - so this condition comes out to be false
1555:18 - we will increment j by 1
1555:21 - so j becomes 3
1555:27 - now we will compare these two elements
1555:32 - that value of array at min index is 1
1555:36 - and value of array at jth index is 2
1555:39 - so we will now compare these two values
1555:42 - so here you can see 2 is not less than 1
1555:45 - so this condition comes out to be false
1555:50 - we will increment j by 1 so j becomes 4
1555:56 - and now we will simply
1555:59 - compare 1 with 9
1556:02 - and we will simply check here
1556:03 - whether 9 is less than 1 or not
1556:06 - so 9 is not less than 1
1556:08 - so therefore this condition comes out to be false
1556:13 - and now we will increment j by 1 so j will become 5
1556:19 - which means that j is now out of these boundaries
1556:23 - and this condition here you can see
1556:26 - j should be less than n
1556:29 - so j value is 5
1556:30 - and 5 is not less than 5
1556:33 - so therefore this for loop will terminate
1556:41 - and we simply reach here
1556:43 - so here you can see
1556:45 - that we have found out the minimum value among this element which is 1
1556:50 - and in selection sort what we do is
1556:52 - we simply swap it with the leftmost element
1556:55 - of the unsorted part
1556:57 - which is being hold by the value i
1557:00 - so here we are performing this swap using this temporary variable
1557:04 - so in the first step
1557:06 - we are storing the value 1 into the temporary variable
1557:10 - so temp becomes 1
1557:14 - and then we are simply swapping
1557:16 - the value at i at index which is 5
1557:19 - into this index
1557:23 - so 5 will come here
1557:27 - and at the last step we are simply assigning value stored at temp
1557:30 - into the i at index which is this
1557:35 - so we have simply swapped these elements
1557:40 - and after we perform this swap
1557:44 - we know that one is at its correct position
1557:47 - because we need to sort all the elements in ascending order
1557:53 - so now this one will go into the sorted part
1557:56 - and rest of the elements will be still in the unsorted part
1558:01 - so the call will reach here in the outer for loop
1558:04 - will increment i by 1
1558:06 - so i will become 1
1558:10 - so now i will point to this index
1558:13 - which is 1
1558:17 - in the first step we are assuming that let's say this is our minimum value
1558:21 - among all the elements
1558:23 - so we are simply assigning value of i to min
1558:27 - moving ahead
1558:30 - now as we need to find the minimum element
1558:33 - from the unsorted part
1558:35 - we need to provide this inner for loop
1558:37 - which will start from j equals to i plus 1
1558:41 - so i is pointing to index 1
1558:43 - so j will start with index 2
1558:48 - and the value of j which is 2 is less than 5
1558:53 - so this condition comes out to be true
1558:56 - so now we are again we are simply performing this check that whether
1559:01 - 10 is less than 5 or not
1559:04 - by taking in the value at jth index and the value at min index
1559:09 - so min is pointing to index 1
1559:11 - and j is pointing to index 2
1559:12 - so we are taking these two values
1559:14 - and we are comparing that whether 10 is less than 5 or not
1559:19 - so this condition comes out to be false because 10 is not less than 5
1559:26 - we will increment j by 1
1559:27 - so j becomes 3
1559:29 - so still you can see
1559:31 - 3 is less than 5
1559:33 - so this condition comes out to be true
1559:39 - now we will compare these two values
1559:43 - we check whether 2 is less than 5 or not
1559:45 - so yes 2 is less than 5
1559:47 - so this condition comes out to be true
1559:52 - and as this condition comes out to be true
1559:54 - and we need to find the minimum element
1559:56 - among these elements
1559:58 - so now our min will point to this index
1560:02 - because we have found a minimum value
1560:06 - moving ahead
1560:09 - will increment j by 1
1560:11 - so j becomes 4
1560:14 - and 4 is less than 5
1560:17 - so this condition comes out to be true
1560:19 - now here we check
1560:21 - that whether 9 is less than 2 or not
1560:23 - so 9 is not less than 2
1560:25 - so this condition comes out to be false
1560:31 - j becomes 5
1560:35 - so now this condition
1560:37 - 5 is not less than 5
1560:39 - so this 4 loop will terminate
1560:45 - and we have found our minimum element
1560:47 - which is 2
1560:49 - so we will simply swap it with the
1560:51 - leftmost element
1560:53 - of the unsorted part
1560:55 - which is being tracked by the value i
1560:57 - so we are simply swapping
1560:59 - 5 with 2
1561:01 - using these 3 steps
1561:03 - so we will quickly go over these 3 steps
1561:05 - 10 will have value 2
1561:07 - with this statement
1561:13 - we will transfer 5 to this position
1561:15 - by assigning
1561:17 - the array value at i.e. index
1561:19 - to the array value at min index
1561:23 - so this becomes 5
1561:25 - and at last we will store
1561:27 - the value of temp into the
1561:29 - i.e. index
1561:31 - so this becomes 2
1561:39 - so friends here you can see
1561:41 - after we perform this swap
1561:43 - 2 will also become part of the
1561:45 - sorted part
1561:47 - with each pass
1561:49 - the sorted array is increasing
1561:51 - and the unsorted part is decreasing
1561:55 - so now we will increment
1561:57 - i by 1
1561:59 - so i becomes 2
1562:03 - and 2 is less than 4
1562:05 - so this condition comes out to be true
1562:09 - so now we need to find the minimum element
1562:11 - among this unsorted part
1562:13 - so we are assuming that
1562:15 - whatever the value i is holding currently
1562:17 - it's the minimum value
1562:19 - so we are simply assigning value of i to min
1562:23 - so value of min will become 2
1562:27 - and now we need to compare
1562:29 - 10 with
1562:31 - rest of the elements
1562:33 - so for that we need to provide this inner for loop
1562:35 - where j will start
1562:37 - from i plus 1 because we need to compare
1562:39 - this with other elements
1562:41 - so i is already pointing to
1562:43 - this element so we will start j
1562:45 - by i plus 1
1562:47 - so j becomes 3
1562:51 - now we will simply compare
1562:53 - these two values
1562:57 - and here we are finding that whether 5 is less than
1562:59 - 10 or not so this condition comes
1563:01 - out to be true
1563:03 - so we have found our
1563:05 - minimum element
1563:07 - after this comparison
1563:09 - so we will simply update min to
1563:11 - this value 3
1563:17 - and we continue with our for loop
1563:19 - we will increment j by 1
1563:21 - j becomes 4
1563:23 - and 4 is less than
1563:25 - 5 so this
1563:27 - condition comes out to be true
1563:33 - now we will simply check whether 9 is less than 5 or not
1563:35 - so 9 is not less than 5
1563:37 - so this condition comes out to be false
1563:43 - we will increment j by 1
1563:45 - so j becomes 5
1563:47 - which is out of bounds
1563:49 - of this array
1563:51 - and here 5 is not less
1563:53 - than 5 so this condition comes
1563:55 - out to be false and our for loop will terminate
1564:01 - so here you can see we have found our minimum
1564:03 - element which is 5
1564:05 - now we will simply swap it with the
1564:07 - leftmost element of the unsorted part
1564:09 - which is being
1564:11 - tracked by value i
1564:13 - so we are simply performing this swap
1564:15 - where 5 will come to this position and
1564:17 - 10 will come to this position
1564:19 - so
1564:31 - so here after we perform swap
1564:33 - now 5 is at its correct
1564:35 - position and now this will become
1564:37 - part of the sorted array
1564:41 - we will increment i by 1
1564:43 - so i becomes 3
1564:45 - and 3 is also less than 4
1564:47 - so this condition comes out to be true
1564:53 - now at the first step we assume that 10 is the minimum value
1564:55 - so we simply assign the value
1564:57 - of i to min
1564:59 - which is 3
1565:03 - so it will point to the
1565:05 - third index
1565:07 - and now we need to find the
1565:09 - minimum element
1565:11 - from the unsorted part
1565:13 - so only 2 elements are left
1565:15 - so we will start our inner for loop with j
1565:17 - equal to i plus 1
1565:19 - so j will start with 4
1565:23 - 4 is less than 5
1565:25 - so this condition comes out to be true
1565:29 - and here we will simply compare that value
1565:31 - at jth index which is 9
1565:33 - is less than value
1565:35 - at min index which is 10
1565:37 - or not so 9 is
1565:39 - less than 10 so this
1565:41 - condition comes out to be true
1565:43 - and we have found our minimum element
1565:45 - among these 2 elements
1565:47 - so min will be updated to 4
1565:51 - by assigning the value of j which is 4
1565:55 - to min
1566:01 - we will increment j by 1
1566:03 - so j becomes 5
1566:07 - which means that 5 is
1566:09 - not less than 5 so this
1566:11 - condition comes out to be false
1566:17 - and then as we have found our minimum element
1566:19 - we will simply perform a swap with
1566:21 - the leftmost element of the unsorted part
1566:23 - which is being tracked by i
1566:25 - so 9 will come to this
1566:27 - position and 10 will come to this position
1566:29 - using this temporary variable
1566:35 - so first 10 will come here
1566:38 - and then whatever the value
1566:40 - we stored here which is 9 will come here
1566:48 - so after this swap
1566:50 - we know that 9 is at its correct position
1566:52 - so this will be part of the sorted array
1566:56 - so friends here you can see
1566:58 - that at the end there were
1567:00 - only 2 elements
1567:02 - and as we sorted the second
1567:04 - last element
1567:06 - the unsorted part was left with 1 element
1567:08 - so this algorithm should not be applied
1567:10 - to this element because
1567:12 - this is already sorted because
1567:14 - this is at its correct position only now
1567:17 - so therefore we provided this condition
1567:19 - that i should go to less than
1567:21 - n-1
1567:23 - so here if we increment now i by 1
1567:25 - i becomes 4
1567:29 - so i will come to this point
1567:31 - but here you can see
1567:33 - 4 is not less than 4
1567:35 - which makes sense because
1567:37 - now i is pointing to the last element
1567:39 - and if it is the only element left
1567:41 - then we are sure that
1567:43 - the last element
1567:45 - is actually sorted
1567:53 - so friends here we saw the demonstration
1567:55 - of the selection sort algorithm
1567:57 - step by step
1567:59 - and once this algorithm gets finished
1568:01 - we found all the elements
1568:04 - sorted into the ascending order
1568:06 - so now lets go to intelligent
1568:08 - and code this algorithm and test its working
1568:11 - so friends i hope you have liked this video
1568:14 - and in case you have liked this video
1568:16 - then i would request you to please like
1568:18 - comment share and subscribe my channel
1568:21 - thanks have a nice day
1568:27 - hello everyone
1568:29 - so in our previous video we discussed about
1568:31 - the selection sort algorithm
1568:33 - and we saw the demonstration of the algorithm
1568:35 - step by step
1568:37 - using an animation
1568:39 - now in this video we will code the algorithm
1568:41 - into this sort method
1568:43 - where we simply pass in the array
1568:45 - which we want to sort
1568:47 - and we will simply apply the selection sort
1568:49 - and test its working
1568:51 - in the main method
1568:53 - so currently we are given with this array
1568:55 - 5 1 2 9 10
1568:57 - and if i run the
1568:59 - main method
1569:03 - so here we will see
1569:05 - that we are simply printing
1569:07 - the array now
1569:09 - using this print array method
1569:11 - so 5 1 2 9 10
1569:13 - got printed
1569:15 - now lets code the algorithm
1569:17 - in this sort method
1569:19 - so in the first step what we do is
1569:23 - we create an integer variable n
1569:25 - which will hold the length
1569:27 - of the array
1569:29 - because we will use this value of n
1569:31 - in the algorithm
1569:33 - while we provide the for loops
1569:37 - now at the first step
1569:39 - we provide a for loop
1569:41 - which starts from integer
1569:43 - i equal to 0
1569:47 - to a value
1569:49 - less than n
1569:51 - minus 1
1569:53 - minus 1
1569:55 - i plus plus
1569:57 - so in our previous video
1569:59 - we discussed that we are actually dividing
1570:01 - the array into two parts
1570:03 - the sorted part and the unsorted part
1570:05 - so basically
1570:07 - this i will keep the track of the sorted
1570:09 - and the unsorted part
1570:11 - so at the start all the
1570:13 - elements are part of the unsorted part
1570:15 - so therefore the value of i will be 0
1570:19 - and the value of i will go to
1570:21 - less than n minus 1
1570:23 - so here we can see we have these 5
1570:25 - elements
1570:27 - so the value of n will be 5
1570:29 - and if we do minus 1 it will be 4
1570:31 - so i will go from 0
1570:33 - to 3
1570:35 - now why this i will go from 0 to 3
1570:37 - is because
1570:39 - if we see the indexes
1570:41 - it starts from 0
1570:43 - and 3 will come to this point
1570:45 - so when we compare
1570:47 - these last two elements
1570:49 - we sort them
1570:51 - then we know that both the elements will be at its correct
1570:53 - position
1570:55 - so this algorithm should not go further
1570:57 - ahead because if i will
1570:59 - come to this point
1571:01 - then we know that this is already sorted
1571:03 - so we are keeping track of the
1571:05 - i till less than n minus 1
1571:07 - and which we already discussed in our
1571:09 - previous video in great detail
1571:11 - so you can watch that video
1571:13 - now inside this for loop
1571:15 - as we want to find the minimum element
1571:18 - in the unsorted part
1571:20 - so what we do is we assume that
1571:23 - that min is pointing
1571:25 - to index 0
1571:27 - at the start
1571:29 - and we are assuming that the first element
1571:31 - is the minimum element
1571:33 - and after that we need to provide a for loop
1571:39 - now this for loop will start
1571:41 - with j equals to
1571:43 - i plus 1
1571:45 - and this will go till
1571:47 - less than n
1571:49 - j
1571:51 - plus plus
1571:55 - so here you can see that we are assuming
1571:57 - the value hold by an array at
1571:59 - i at index is the minimum value
1572:01 - so this is our
1572:03 - assumption and in order to find
1572:05 - the minimum element among
1572:07 - the unsorted part
1572:09 - we need to provide this for loop
1572:11 - where we will compare all the elements
1572:13 - with the value
1572:15 - hold by the min index
1572:17 - and as the min is pointing
1572:19 - to the i at index
1572:21 - we are starting this inner for loop
1572:23 - with j is i plus 1
1572:25 - and j will go till less than n
1572:27 - because we need to compare
1572:29 - this minimum value with each and
1572:31 - every element of the array
1572:33 - so j will go till the last index
1572:35 - and inside this for loop
1572:37 - will provide a condition as
1572:43 - if value at jth index
1572:45 - is less than
1572:47 - value at min index
1572:51 - then we know that
1572:53 - we have found one more element
1572:55 - which is less than the
1572:57 - value at min index
1572:59 - so what we do is we simply
1573:01 - update
1573:03 - the min value to point to j
1573:05 - because we have found a
1573:07 - new minimum value
1573:09 - so now min will
1573:11 - point to jth index and this for loop
1573:13 - will go on
1573:15 - till all the elements are compared with the
1573:17 - min value
1573:19 - and after this for loop will terminate
1573:21 - we know that we have found our minimum
1573:23 - value whose index
1573:25 - is being hold by the min
1573:27 - integer
1573:29 - so after the for loop we will simply
1573:31 - swipe this minimum value
1573:33 - with the leftmost element
1573:35 - of the unsorted part
1573:37 - which is being hold by the value i
1573:39 - because we already discussed
1573:41 - that we divide the array into two parts
1573:43 - the sorted part and the unsorted part
1573:45 - and i will keep
1573:47 - the track of that boundary
1573:49 - so at the start i will point to 0
1573:51 - which would be the leftmost
1573:53 - element of the unsorted part
1573:55 - so we will simply swipe
1573:57 - this minimum value
1573:59 - with the value
1574:01 - stored at the ith index
1574:03 - and we will use this temporary variable
1574:09 - so we first store the
1574:11 - value at minimum index
1574:13 - which would be our minimum value
1574:15 - into the temp
1574:27 - and then we will assign
1574:29 - the value at ith index
1574:31 - to value at min index
1574:35 - and at the last
1574:39 - whatever the value
1574:41 - stored in temp
1574:43 - will assign to
1574:45 - ith index
1574:47 - so here you can see
1574:49 - after we perform this swipe
1574:51 - one element reaches
1574:53 - to the sorted part
1574:55 - and then we increment the i by 1
1574:57 - so i becomes 1
1574:59 - and the rest of the algorithm is repeatedly
1575:01 - performed on an array
1575:03 - till we get all the elements
1575:05 - into the sorted part
1575:07 - so in order to understand the selection sort
1575:09 - using an animation you can
1575:11 - watch my previous video
1575:13 - so this is the code for the selection sort
1575:15 - now lets test its working
1575:17 - so after
1575:19 - printing the array we will call
1575:21 - the sort method
1575:23 - we pass in the array
1575:25 - and once this method gets executed
1575:29 - we will simply print
1575:31 - the array again
1575:33 - if i run the
1575:35 - main method
1575:39 - so here you can see initially array was
1575:41 - 5 1 2 9 10
1575:43 - and after we performed the selection sort it became
1575:45 - 1 2 5 9 10
1575:47 - which is in ascending order
1575:51 - so friend this was all about the selection sort algorithm
1575:55 - i hope you have liked this video
1575:57 - and in case you have liked this video
1575:59 - then please like, share, comment
1576:01 - and subscribe my channel
1576:03 - thanks have a nice day
1576:33 - and how we can merge two sorted arrays
1576:35 - in java
1576:39 - so before we start
1576:41 - in case if you are new to my channel
1576:43 - then please subscribe to my channel
1576:45 - so that you don't miss any update
1576:47 - so here lets
1576:49 - suppose we are given with this two arrays
1576:51 - array 1 and array 2
1576:53 - and here if you see
1576:55 - both these arrays are sorted in ascending
1576:57 - order
1576:59 - so array 1 has 4 elements
1577:01 - 3 5 10
1577:03 - and they are sorted in ascending order
1577:05 - and same with array 2
1577:07 - having elements as 4 6
1577:09 - 11 and 15
1577:11 - now our task is to merge these two array
1577:13 - in such a way that
1577:15 - the resultant array is also sorted
1577:17 - so the idea behind this algorithm
1577:19 - is we create a resultant array
1577:21 - whose length is
1577:23 - the length of array 1
1577:25 - plus the length of array 2
1577:27 - so in this case
1577:29 - array 1 has length 4
1577:31 - and array 2 has length 4
1577:33 - so our resultant array
1577:35 - will have length 8
1577:37 - because we need to merge all the
1577:39 - elements of array 1 and array 2
1577:41 - into this result array
1577:45 - so in this algorithm, as this both the
1577:47 - arrays are sorted in ascending order
1577:49 - what we do is, we simply
1577:51 - compare the elements of array 1 with array 2
1577:53 - and whichever the element
1577:55 - is smaller, we simply put
1577:57 - it into the result array
1577:59 - so how do we perform this algorithm
1578:01 - is, we take 3 pointers
1578:03 - 1 pointer
1578:05 - will start from array 1
1578:07 - 2nd pointer will start
1578:09 - from array 2
1578:11 - and there will be 3rd pointer
1578:13 - which will start from
1578:15 - our result array
1578:17 - so the 3 pointers we create is
1578:19 - i which will point to the zeroth index
1578:21 - of array 1
1578:23 - j which will point to the zeroth
1578:25 - index of array 2
1578:27 - and k which will
1578:29 - point to the zeroth index
1578:31 - of result array
1578:33 - so here as both the arrays
1578:35 - are sorted, we simply compare
1578:37 - the elements stored
1578:39 - at the ith index of array 1
1578:41 - with the elements stored at the jth
1578:43 - index of array 2
1578:45 - and whichever of them is smaller
1578:47 - we simply put it into the kth index
1578:49 - of result array
1578:51 - so here in first step
1578:53 - we compare
1578:55 - 2 with 4
1578:57 - because i and j are pointing
1578:59 - to an index having value
1579:01 - as 2 and 4
1579:03 - so here we see
1579:05 - 2 is less than 4
1579:07 - so therefore we simply
1579:09 - update this value
1579:11 - to kth index of the result array
1579:13 - so it would look something
1579:15 - like this, 2 will come
1579:17 - to this position
1579:19 - now here as we have filled this value
1579:21 - here, so we simply increment
1579:23 - i by 1
1579:29 - and as we have filled this position, we also
1579:31 - increment k by 1
1579:35 - so now we will again compare
1579:37 - the value at ith index
1579:39 - with the value at jth index of both the arrays
1579:43 - so we will compare now 3 with 4
1579:45 - so here you can see
1579:47 - 3 is less than 4
1579:49 - so we simply update the value
1579:51 - 3
1579:53 - into this position
1579:59 - and as we have used
1580:01 - the value 3, we simply increment
1580:03 - i by 1
1580:07 - and we have filled this position
1580:09 - so we increment k also by 1
1580:13 - so now we will again
1580:15 - perform this comparison
1580:18 - we compare 5
1580:20 - with 4
1580:22 - so now here you can see
1580:24 - 4 is less than 5
1580:26 - so therefore we put this value 4
1580:28 - into this kth index
1580:33 - because our task is to merge
1580:35 - 2 sorted arrays and the result array
1580:37 - should also be sorted
1580:39 - so therefore we perform this check
1580:41 - and whichever is the minimum value
1580:43 - we simply put it into the
1580:45 - result array
1580:47 - so now we have used the value
1580:49 - stored at jth index
1580:51 - so we will simply increment
1580:53 - j by 1
1580:55 - and we have filled this value
1580:57 - so we will increment k also by 1
1580:59 - so here you can see
1581:01 - wherever we are finding
1581:03 - any lowest value in array 1
1581:05 - or in array 2
1581:07 - we are simply incrementing
1581:09 - that pointer
1581:11 - and why we are not incrementing the other pointer
1581:13 - that value still needs to be
1581:15 - filled inside this array
1581:17 - so now as we have incremented
1581:19 - j by 1
1581:21 - we will compare 5 and 6
1581:23 - because those values are
1581:25 - preferred by i and jth index
1581:29 - and here we know that 5 is less than 6
1581:31 - so we will simply update 5 value
1581:33 - at the kth index
1581:37 - and as we have used this value
1581:39 - we will increment i by 1
1581:43 - we have occupied with this position
1581:45 - so we will increment k also by 1
1581:49 - now we will compare
1581:51 - 10 with 6
1581:53 - so here you can see
1581:55 - 6 is smaller than 10
1581:57 - so 6 value will be updated here
1582:01 - and as we have used this
1582:03 - value 6
1582:05 - we will increment j by 1
1582:07 - and we have
1582:09 - filled this position so we will also increment
1582:11 - k by 1
1582:15 - now we will compare 10 with 11
1582:19 - so here you can see 10 is less than 11
1582:21 - so value 10 will be updated
1582:23 - here
1582:29 - we will increment i by 1
1582:31 - so here you can see
1582:33 - now as we are incrementing i by 1
1582:35 - i will be crossing
1582:37 - the boundaries of array 1
1582:40 - so now there is no more element left
1582:42 - in the array 1 to be compared with the elements
1582:44 - in the array 2
1582:46 - it means all the elements of array 1
1582:48 - are filled into the result array
1582:50 - and we are only left with the
1582:52 - elements of array 2
1582:54 - which are already sorted
1582:56 - so now our task is
1582:58 - to simply put these values
1583:00 - into its respective positions here
1583:02 - because we don't have to compare
1583:04 - these values with any other value
1583:06 - because these are already sorted
1583:08 - in ascending order
1583:10 - so as we incremented i by 1
1583:12 - after filling the value 10 here
1583:14 - we will increment k also by 1
1583:18 - and now we will simply copy the remaining
1583:20 - elements of array 2
1583:22 - into this result array
1583:24 - using the jth pointer
1583:26 - so the first step we will simply
1583:28 - copy 11 here
1583:30 - then we will increment j by 1
1583:32 - and we will also increment
1583:34 - k by 1
1583:36 - and we will simply copy 15
1583:38 - into this kth index
1583:40 - we will increment j by 1
1583:42 - so j has reached out of these
1583:44 - boundaries now for array 2
1583:46 - and we will also increment k by 1
1583:48 - so k has also reached
1583:50 - to its end
1583:52 - so which signifies both these array elements
1583:54 - are now part of this result array
1583:56 - and as both the arrays were sorted
1583:58 - in ascending order you can see the
1584:00 - result array is also sorted in ascending order
1584:02 - so here this is the idea
1584:04 - of how we can merge two sorted arrays
1584:06 - by simply
1584:08 - using 3 pointers
1584:10 - i, j and k
1584:12 - i will traverse array 1
1584:14 - j will traverse array 2
1584:16 - and k will traverse our result array
1584:18 - we will simply compare the values
1584:20 - stored at ith and jth index
1584:22 - of their respective arrays
1584:24 - and whichever
1584:26 - the value is small
1584:28 - will simply update it into the result array
1584:30 - at the kth index
1584:32 - and after we update these values
1584:34 - whichever value we took
1584:36 - either from array 1
1584:38 - or from array 2
1584:40 - will simply increment that respective pointers
1584:42 - and as we are filling up their
1584:44 - positions in the result array
1584:46 - we will also increment the kth pointer
1584:50 - so friend this was all about
1584:52 - the demonstration of how we can merge two sorted arrays
1584:54 - and create
1584:56 - a resultant array which is also
1584:58 - sorted
1585:00 - in our next video we will look
1585:02 - into the animation of
1585:04 - the actual algorithm which is
1585:06 - involved in merging these two arrays
1585:10 - so friend in case you have found this video informative
1585:12 - then please like, comment, share
1585:14 - and subscribe my channel
1585:16 - thanks have a nice day
1585:22 - hello everyone
1585:24 - so in our last video we discussed
1585:26 - about that how we can merge
1585:28 - two sorted arrays in java
1585:30 - we discussed about the idea
1585:32 - that how we can merge two sorted arrays
1585:34 - so in this video we will see
1585:36 - the step by step demonstration
1585:38 - of the algorithm
1585:40 - but before we start
1585:42 - in case if you are new to my channel
1585:44 - then please subscribe to my channel
1585:46 - so that you never miss an update
1585:50 - so here you can see that this is the algorithm
1585:52 - to merge two sorted arrays
1585:54 - array 1 and array 2
1585:56 - into a result array
1585:58 - and simply return the result array
1586:00 - from this method merge
1586:02 - so let's see the demonstration
1586:04 - of this algorithm step by step
1586:06 - so initially when we
1586:08 - call this merge method we pass in
1586:10 - the two sorted arrays
1586:12 - array 1 and array 2
1586:14 - and we also pass the length of these
1586:16 - two arrays with a
1586:18 - variable as n and m
1586:20 - so n will correspond to the
1586:22 - length of array 1
1586:24 - and value m will correspond to the length
1586:26 - of array 2
1586:28 - so when we call merge method
1586:30 - here you can see that for this example
1586:32 - we are taking two arrays
1586:34 - which are sorted in ascending order
1586:36 - having length as 3
1586:42 - so let's say we are providing this two sorted arrays
1586:44 - having length as 3
1586:46 - and here you can see the elements
1586:48 - are sorted in ascending order
1586:50 - in both the arrays
1586:52 - and now our task is to merge these two arrays
1586:54 - into a result array
1586:56 - and return that result array from this method
1586:58 - so the length of this array
1587:00 - are denoted by n and m
1587:02 - having value as 3
1587:06 - so in the first step
1587:08 - as we want to merge these two arrays
1587:10 - all the elements should be part of the result array
1587:12 - so first we create
1587:14 - that array by name result
1587:16 - and the length of that array
1587:18 - would be n plus m
1587:20 - because we need to merge
1587:22 - these two sorted arrays
1587:24 - and our result array should contain
1587:26 - all the elements of both these arrays
1587:30 - so after this length gets executed
1587:32 - we are provided with this array
1587:34 - whose length is 6
1587:36 - moving ahead
1587:40 - and as we discussed in our last video
1587:42 - the idea behind this algorithm is
1587:44 - we create three pointers
1587:46 - i, j and k
1587:48 - we will initialize it with zero value
1587:52 - now what these pointers are
1587:54 - the pointer i
1587:56 - will traverse array 1
1587:58 - starting from 0th index
1588:00 - so we have provided value 0
1588:04 - pointer j
1588:06 - will traverse array 2
1588:08 - starting from 0th index
1588:10 - and pointer k
1588:12 - will traverse the result array
1588:14 - starting from 0th index
1588:18 - so here you can see
1588:20 - the purpose of these three pointers
1588:22 - are different
1588:24 - so in this algorithm
1588:26 - at any instant we are comparing
1588:28 - the value stored at ith index
1588:30 - with the value stored at jth index
1588:32 - and whichever the value is
1588:34 - smaller
1588:36 - we are simply updating into the result array
1588:38 - ith kth index
1588:40 - so these two pointers are used for comparison
1588:42 - and this pointer is used to fill this array
1588:44 - and the filling of this array is
1588:46 - sequential
1588:48 - where we place in elements 1 by 1
1588:50 - and will increment k 1 by 1
1588:52 - and similar to this comparison
1588:54 - also sequential
1588:56 - we are finding the minimum value
1588:58 - at each iteration
1589:00 - and we are simply updating into the result array
1589:02 - so here
1589:04 - at the start of this algorithm
1589:06 - we are providing this while loop
1589:08 - now why we have provided this while loop
1589:10 - is because
1589:12 - we need to compare
1589:14 - the value stored at ith index
1589:16 - and value stored at jth index
1589:18 - so it simply means
1589:20 - i will traverse the array 1
1589:22 - and j will traverse array 2
1589:24 - so in order to perform
1589:26 - this traversal in comparison
1589:28 - we are providing this while loop
1589:30 - and inside this while loop we have provided
1589:32 - two conditions
1589:34 - one is i should be less than
1589:36 - the length of array 1
1589:38 - and j should be less than
1589:40 - m which is length of array 2
1589:42 - now why we have provided this condition
1589:44 - is because
1589:46 - as we are comparing and incrementing values
1589:48 - of i and j
1589:50 - which you can see here
1589:52 - so there can be a chance that j
1589:54 - goes out of bounds
1589:56 - for array 2
1589:58 - and i goes out of bounds
1590:00 - for array 1
1590:02 - so when any of this pointer
1590:04 - will exhaust its respective arrays
1590:06 - will simply exit this while loop
1590:08 - because there are no more elements left to be compared
1590:10 - between these two arrays
1590:12 - because one array is already exhausted
1590:14 - so therefore we have provided this true condition
1590:16 - so at the start
1590:18 - i is pointing to 0
1590:20 - j is also pointing to 0
1590:22 - i is less than 3
1590:24 - and j is also less than 3
1590:26 - so therefore this while loop condition
1590:28 - comes out to be true
1590:32 - now in the while loop we are comparing
1590:34 - that whether value at ith index
1590:36 - for array 1
1590:38 - is less than value stored at jth index
1590:40 - for array 2 or not
1590:42 - so here you can see
1590:44 - so we are comparing 2 with 3
1590:46 - so here you can see
1590:48 - 2 is less than 3
1590:50 - so this condition comes out to be true
1590:52 - so therefore if block will be executed
1590:56 - now as we have found
1590:58 - a minimum value among these two values
1591:00 - and we want to merge
1591:02 - these two sorted arrays
1591:04 - into this result array
1591:06 - in sorted form
1591:08 - then what we do is
1591:10 - we simply update the value
1591:12 - at ith index for array 1
1591:14 - into this result array
1591:16 - at kth index
1591:18 - so 2 will come here
1591:20 - moving ahead
1591:24 - now as we have used this value
1591:26 - so we will increment i by 1
1591:28 - so currently i is 0
1591:31 - i will become 1
1591:35 - and after this if else
1591:39 - we will increment k by 1
1591:41 - because we have filled this position here
1591:44 - so now we need to go to next position
1591:46 - to get the next element
1591:49 - so k becomes 1
1591:53 - we will check both these two conditions
1591:56 - so 1 is less than 3
1591:58 - and value of j is 0
1592:00 - so 0 is also less than 3
1592:02 - so this both the condition comes out to be true
1592:08 - now we will again compare value at ith index
1592:10 - for array 1 with value at jth index
1592:12 - for array 2
1592:14 - so which is we are comparing
1592:16 - 5 with 3
1592:18 - now here you can see 5 is not less than 3
1592:20 - so therefore this condition comes out to be false
1592:24 - and else part will be executed
1592:28 - so in the else part
1592:30 - as 3 is less than 5
1592:32 - we will simply update value of 3
1592:34 - to the result array
1592:36 - so here we are assigning value
1592:38 - stored at jth index for array 2
1592:40 - into result array at kth index
1592:42 - so 3 will come here
1592:50 - now as we have used the value 3
1592:52 - we will increment j by 1
1592:55 - so j becomes 1
1592:58 - and we are not touching i because
1593:00 - we need to still get this value 5
1593:03 - and store it somewhere into the result array
1593:06 - so i will simply point to the same index
1593:11 - we will increment k by 1 because
1593:13 - we have filled ith position
1593:15 - so for the new value
1593:17 - we will simply go to its next index
1593:20 - so k becomes 2
1593:25 - 1 is less than 3
1593:27 - and 1 is less than 3
1593:29 - so this both the condition
1593:31 - comes out to be true
1593:35 - we will compare value at ith index for array 1
1593:37 - with the value at jth index
1593:39 - for array 2
1593:41 - so here we are comparing 5 with 4 now
1593:44 - and here you can see
1593:46 - 5 is not less than 4
1593:48 - so this condition comes out to be false
1593:51 - and in the else part
1593:53 - as we have found
1593:55 - the minimum value as 4
1593:57 - we simply update 4
1593:59 - into the result array
1594:01 - by this assignment
1594:07 - and as we have used this value
1594:09 - we will increment j by 1
1594:14 - and we have filled this position
1594:16 - so we will increment k by 1
1594:19 - k becomes 3
1594:23 - here still i is less than n
1594:25 - and j is also less than m
1594:27 - 1 is less than 3
1594:29 - and 2 is also less than 3
1594:31 - so this both condition comes out to be true
1594:36 - we will now compare 5 with 9
1594:38 - because those are the values pointed by
1594:40 - i and jth index
1594:42 - and here you can see
1594:44 - 5 is less than 9
1594:47 - so therefore this if block condition
1594:49 - comes out to be true
1594:51 - so now it's time to update value 5
1594:53 - into the result array
1594:57 - and as we have updated value 5
1595:01 - we will increment
1595:03 - i by 1
1595:06 - so i becomes 2
1595:09 - and as we have filled this position
1595:11 - we will increment k by 1
1595:13 - k becomes 4
1595:16 - so still this while loop condition comes out to be true
1595:18 - because
1595:20 - i is less than n
1595:22 - and j is also less than m
1595:26 - we compare these two values
1595:28 - 7 and 9
1595:30 - we found that 7 is less than 9
1595:32 - so therefore this condition comes out to be true
1595:37 - so we simply update value
1595:39 - stored at ith index in array 1
1595:41 - into the value
1595:43 - 8th caret index for result array
1595:46 - so 7 comes here
1595:50 - and then we will simply increment
1595:52 - i by 1
1595:54 - so i becomes 3
1595:56 - so here you can see now i has
1595:58 - crossed the boundary for array 1
1596:02 - we have used this position
1596:04 - so we will increment k by 1
1596:06 - k becomes 5
1596:10 - so for now here you can see
1596:12 - that array 1 is already exhausted
1596:15 - so this condition i is less than n
1596:17 - where 3 is not less than 3
1596:20 - so therefore this overall condition
1596:22 - will come out as false
1596:24 - and this while loop will terminate
1596:26 - so here you can see
1596:28 - whenever any of the array gets exhausted
1596:30 - we will simply break from this while loop
1596:35 - and then our execution point will reach here
1596:37 - where we are encountering 2 while loops
1596:40 - so friends here you can see
1596:42 - that there can be a chance
1596:44 - that array 1 gets exhausted first
1596:46 - or array 2 gets exhausted first
1596:50 - so when this while loop will terminate
1596:52 - we are not sure that which array gets exhausted first
1596:54 - so therefore we have provided these 2 while loops
1596:58 - so here let's say for example
1597:00 - array 2 gets exhausted first
1597:02 - so if array 2 gets exhausted first
1597:04 - there can be left over elements
1597:06 - in array 1
1597:08 - which need to go into the result array
1597:11 - so we are providing this while loop
1597:13 - where we are simply traversing i
1597:15 - to complete the array 1
1597:17 - get those elements from array 1
1597:19 - and simply fill it in the result array
1597:22 - because as both the arrays are sorted
1597:24 - we are simply copying
1597:26 - the left over elements from the respective array
1597:29 - into the result array
1597:31 - so this while loop
1597:33 - is when array 2 will get exhausted
1597:35 - and this while loop is when
1597:37 - array 1 will get exhausted
1597:40 - so currently for this example you can see
1597:42 - array 1 got exhausted
1597:44 - so this while loop
1597:46 - will not get executed because the condition here is
1597:48 - i should be less than n
1597:50 - so 3 is not less than 3
1597:52 - so therefore this while loop
1597:54 - won't get chance to execute because
1597:56 - because array 1
1597:58 - is already traversed completely
1598:02 - and we know that
1598:04 - there are left over elements in array 2
1598:06 - because j is less than m
1598:08 - 2 is less than 3
1598:10 - so whatever elements are left over
1598:12 - in array 2 will simply get copied
1598:14 - into the result array
1598:16 - because those elements are already sorted
1598:21 - so we will simply store value 9
1598:23 - into the result array
1598:25 - by this assignment
1598:29 - and after doing this assignment
1598:31 - here for this small example you can see
1598:33 - that there was only one element
1598:35 - so we simply updated one element here
1598:37 - but let's say there are many elements
1598:39 - and as this arrays are sorted
1598:41 - so we can simply copy those left over elements
1598:45 - directly into the result array
1598:47 - because there are no elements left
1598:49 - for array 2 to get compared with array 1
1598:51 - because array 1 is already exhausted
1598:53 - and same thing goes
1598:55 - when array 2 gets exhausted
1598:57 - and there are left over elements in array 1
1598:59 - so these two for loops are important
1599:01 - because
1599:03 - they simply copy the left over elements
1599:05 - from their respective arrays
1599:07 - to the result array
1599:09 - and there can be multiple elements
1599:11 - which are left over
1599:13 - so therefore we are providing this while loop
1599:15 - so at the last step
1599:17 - of this while loop we are incrementing j by 1
1599:19 - and k by 1
1599:21 - because we have migrated value 9
1599:23 - into result array
1599:25 - so j will now get incremented by 1
1599:27 - j becomes 3
1599:29 - which means now j has
1599:31 - crossed the boundary of array 2
1599:34 - and we will also increment
1599:36 - k by 1
1599:38 - so k becomes 6
1599:40 - so which means k has traversed
1599:42 - the result array completely
1599:44 - by filling out each and every position
1599:49 - so now we will again compare whether j is less than m or not
1599:51 - so here you can see 3 is not less than 3
1599:54 - so therefore this condition comes out to be
1599:56 - false
1599:58 - which signifies that we have
1600:00 - completely migrated all the elements
1600:02 - of array 2 to result array
1600:06 - so friends finally
1600:08 - here you can see that we have merged
1600:10 - these two sorted arrays
1600:12 - into a result array which is also sorted
1600:14 - so finally we will return result
1600:16 - from this algorithm
1600:22 - so friends in this video we discussed
1600:24 - the algorithm that how we can merge
1600:26 - two sorted arrays
1600:29 - so in case if you find this information useful
1600:31 - then please like, comment, share and subscribe my channel
1600:34 - thanks have a nice day
1600:40 - hello everyone
1600:42 - so in our previous video we discussed
1600:44 - step by step demonstration
1600:46 - of how we can merge two sorted arrays
1600:50 - in this video we will actually code the algorithm
1600:52 - and we will test its working
1600:55 - but before we start
1600:57 - in case if you are new to my channel
1600:59 - please subscribe to my channel so that
1601:01 - you never miss an update
1601:04 - so here I have created one class
1601:06 - is merged sorted arrays
1601:08 - which is having a method as print array
1601:10 - which takes in an array
1601:12 - and print its elements
1601:14 - on the console
1601:16 - so we have discussed this print array method
1601:18 - in our previous videos
1601:20 - so I will simply use this print array method
1601:22 - to demonstrate how we can merge
1601:24 - two sorted arrays
1601:26 - in java
1601:29 - so here you can see
1601:32 - I will be creating one method as public
1601:34 - whose return type would be
1601:36 - an integer array
1601:38 - because we want to merge two arrays
1601:40 - which are sorted
1601:42 - and we want to return back the merge sorted array
1601:44 - having elements of array 1 and array 2
1601:48 - so the method name I will be giving as merge
1601:52 - this method will take four things
1601:56 - one would be the array 1
1602:00 - other would be array 2
1602:04 - the length of array 1
1602:07 - and length of array 2
1602:09 - which is being denoted by n and m
1602:12 - so here you can see
1602:14 - that array 1 and array 2 are already sorted arrays
1602:17 - and we want to merge them together
1602:20 - so at the first step what we do is
1602:24 - as we want to merge them
1602:26 - we will simply merge them in the
1602:28 - result array
1602:30 - so we will create a result array
1602:33 - now the size of this array would be
1602:35 - n plus m
1602:37 - because we want to accommodate
1602:39 - the elements of array 1
1602:41 - and elements of array 2
1602:43 - into the result array
1602:45 - so the idea behind this algorithm is
1602:47 - we create three pointers
1602:49 - i
1602:51 - which will start from 0
1602:53 - so this pointer will traverse
1602:56 - array 1 from start to finish
1603:03 - we will create one more pointer
1603:05 - which will start from 0
1603:07 - and it will traverse
1603:09 - array 2
1603:11 - and we will create one more pointer
1603:15 - k which will start from 0
1603:17 - and which will traverse
1603:19 - result array
1603:21 - so here why we have created
1603:23 - this three pointer is because
1603:25 - pointer i will traverse
1603:27 - array 1
1603:29 - elements 1 by 1
1603:31 - and j will traverse elements of array 2
1603:33 - 1 by 1 and we will simply compare those two
1603:35 - values stored at i and jth
1603:37 - index
1603:39 - and based on our comparison
1603:41 - whichever value will be small
1603:43 - will simply store it into the result array
1603:45 - at kth index
1603:47 - and after we store this value
1603:49 - whichever value of that particular array
1603:51 - we get as a small
1603:53 - will simply increment
1603:55 - pointer of that array
1603:57 - and after filling the result array
1603:59 - at kth index will also increment k by 1
1604:01 - so here
1604:03 - in order to perform that
1604:05 - we provide a while loop
1604:07 - and inside that while loop
1604:09 - we provide two conditions
1604:11 - one is
1604:13 - i should be less than n
1604:15 - and
1604:17 - j should be less than m
1604:19 - so these are
1604:21 - nothing but
1604:23 - boundary conditions
1604:25 - where we are simply
1604:27 - checking that whether i
1604:29 - is in the boundaries of array 1
1604:31 - and j is in boundaries of array 2
1604:33 - and we have provided
1604:35 - this n condition because
1604:37 - in this while loop we are comparing
1604:39 - the value stored at ith index
1604:41 - with the value stored at jth index
1604:43 - for their respective arrays
1604:46 - and in case any of this array gets exhausted
1604:48 - which means that either i
1604:50 - will cross over array 1
1604:52 - or j will cross over
1604:54 - array 2
1604:56 - we simply break from this while loop
1604:58 - so inside this while loop
1605:00 - we are providing a condition as if
1605:06 - value at ith index
1605:08 - of array 1
1605:09 - is less than
1605:12 - value at jth index
1605:14 - for array 2
1605:16 - so here it signifies if
1605:18 - array 1 element
1605:20 - at ith index
1605:22 - is less than
1605:24 - array 2 element
1605:26 - at jth index
1605:28 - so if this is the condition
1605:30 - then after this comparison
1605:32 - this value
1605:34 - is the smallest value
1605:36 - and as we want to merge these
1605:38 - two sorted arrays
1605:40 - into a result array
1605:42 - and that also should be in sorted form
1605:44 - so therefore
1605:46 - we simply update
1605:49 - the smallest value
1605:51 - at the kth index
1605:55 - which means storing
1605:58 - array 1 element
1606:02 - into result
1606:05 - and after we store array 1 element
1606:08 - we have occupied the ith position
1606:11 - into the result array
1606:13 - so we will increment i
1606:15 - so that we can go to its next index
1606:18 - and similarly
1606:19 - if this condition is false
1606:21 - then in the else part
1606:25 - we do the opposite of it
1606:33 - we store
1606:35 - the value at jth index for array 2
1606:40 - into result
1606:43 - because here we know that if this condition is false
1606:46 - then value stored at jth index for array 2 will be smaller
1606:49 - than this value
1606:51 - so we are storing that value
1606:53 - into the result array
1606:55 - and as we have used
1606:57 - the value stored at jth index
1606:59 - we will simply increment j by 1
1607:02 - so after storing
1607:03 - the minimum value
1607:05 - among these two values
1607:07 - into the result array
1607:09 - we have filled the kth position in the
1607:11 - result array
1607:13 - so we will also increment k by 1
1607:16 - so that k travels to an unfilled position
1607:18 - so that
1607:19 - when this while loop will be executed again
1607:22 - we are left with the
1607:24 - unfilled position
1607:27 - so after this while loop gets terminated
1607:29 - there can be two possibilities
1607:34 - either
1607:35 - array 1
1607:37 - got exhausted
1607:39 - or
1607:41 - array 2 got exhausted
1607:49 - if array 2 got exhausted
1607:51 - which means that all the elements of array 2
1607:53 - are now part of our result array
1607:55 - and whatever left over elements
1607:57 - are there in array 1
1607:59 - we simply copy it into the result array
1608:03 - so for that we will use the while loop
1608:09 - we provide the same condition as
1608:11 - i should be less than n
1608:13 - because we are simply copying
1608:15 - the left over elements
1608:17 - of array 1 now
1608:21 - so we copy this
1608:26 - and we will increment k also by 1
1608:29 - after filling the position
1608:32 - so here this while loop
1608:34 - signifies that
1608:35 - array 2 got exhausted
1608:39 - and similarly we don't know
1608:41 - that which array got exhausted in this above
1608:43 - while loop
1608:45 - so we need to provide the same
1608:47 - while loop for the array 2 as well
1608:51 - we provide the condition as j
1608:53 - should be less than m
1608:55 - this will signify that array 1
1608:57 - got exhausted first
1609:01 - we will increment j by 1
1609:03 - and we will keep rest as it is
1609:05 - so friends here you see
1609:07 - that why we have provided these 2 while loops
1609:09 - is because we don't know
1609:11 - whether array 1 got exhausted first
1609:13 - or array 2 got exhausted first
1609:15 - so if array 2 got exhausted first
1609:17 - we are simply copying the left over elements
1609:19 - of array 1
1609:21 - into result
1609:23 - and if array 2 got exhausted first
1609:25 - we are simply copying the left over elements
1609:27 - of array 1 into result
1609:30 - and if array 1 got exhausted first
1609:32 - we are copying
1609:34 - the left over elements of array 2
1609:36 - into the result
1609:38 - using this while loop
1609:40 - and why we are simply copying these elements
1609:43 - from the respective arrays because
1609:45 - those elements are already sorted
1609:47 - and we don't have to compare it
1609:49 - with any other elements
1609:51 - whatever the comparison we need to do
1609:53 - we have done it in this while loop
1609:57 - so at the end
1609:59 - we will simply return the result
1610:01 - array
1610:03 - so friends this is the code
1610:05 - for merging 2 sorted arrays
1610:07 - now let's test it working in the main method
1610:11 - so here i will be creating 2 arrays
1610:16 - array 1
1610:20 - let's say i provide the value as 0
1610:22 - comma 1 comma 8
1610:24 - comma 10
1610:26 - these 4 values
1610:28 - and here you can see these are sorted
1610:30 - in ascending order
1610:32 - and similarly
1610:34 - i create array 2
1610:36 - let's say i provide value as 2
1610:38 - 4
1610:40 - 11
1610:42 - 15
1610:44 - and let's say 20
1610:46 - so these values are also sorted
1610:48 - in ascending order
1610:50 - now let's print both this array
1610:52 - on the console
1611:01 - if i run the code now
1611:07 - so here you can see it is simply printing
1611:10 - both the arrays on the console
1611:16 - now we will call our merge method
1611:19 - we pass in array 1
1611:23 - array 2
1611:27 - length of array 1
1611:30 - which is denoted by n
1611:33 - and length of array 2
1611:36 - which is denoted by m
1611:40 - so this method will return
1611:42 - as the result array
1611:45 - so we will store it into the result variable
1611:47 - and finally
1611:50 - we will print
1611:52 - the result array
1611:55 - if i run the code now
1612:00 - so here you can see
1612:02 - that it returned 0 1 2 4 8 10
1612:05 - 11 15 20
1612:08 - it merged these 2 sorted arrays
1612:11 - and returned
1612:13 - as the result array which is also
1612:15 - in sorted form
1612:19 - so friends this was all about the
1612:21 - code
1612:22 - and working of the algorithm
1612:25 - now why this algorithm is important
1612:27 - because the similar approach
1612:29 - is usually used
1612:31 - when we actually perform the merge sort
1612:34 - which we will be looking into our upcoming lectures
1612:36 - so there we will simply use this idea
1612:39 - and we will perform
1612:41 - the sorting of array using merge sort
1612:45 - so friends if you find this information useful
1612:47 - then please like comment
1612:49 - and share this video
1612:51 - and incase if you are new to my channel
1612:53 - then please subscribe to my channel
1612:55 - so that you don't miss any new update
1612:59 - thanks have a nice day
1613:03 - hello everyone
1613:05 - so in this video we will be looking into
1613:07 - a sorting technique
1613:09 - we call it merge sort
1613:11 - so before we start
1613:13 - incase if you are new to my channel
1613:15 - then please subscribe to my channel
1613:17 - and click the bell icon
1613:19 - so that you never miss any update
1613:21 - so what is merge sort
1613:23 - so here you can see
1613:25 - that merge sort is a divide
1613:27 - and conquer algorithm
1613:29 - so divide and conquer algorithm
1613:31 - is very widely used algorithm
1613:33 - to solve the problem
1613:35 - now as per the Wikipedia
1613:37 - here you can see
1613:39 - divide and conquer
1613:41 - recursively breaks down a problem
1613:43 - into two or more sub problems
1613:45 - of the same or related type
1613:47 - until this becomes
1613:49 - simple enough to be solved directly
1613:51 - so when we divide
1613:53 - a complex problem
1613:55 - into two or more
1613:57 - smaller sub problems
1613:59 - and we keep on doing it
1614:01 - till those smaller problems are easily solved
1614:03 - and after breaking this complex problem
1614:05 - into smaller sub problems
1614:07 - what we do is
1614:09 - we solve those smaller sub problems
1614:11 - we take their solutions
1614:13 - and then combine them to give a
1614:15 - solution to the original problem
1614:17 - so basically we divide
1614:19 - a large problem
1614:21 - into various smaller sub problems
1614:23 - and we keep on doing it
1614:25 - till those sub problems are
1614:27 - simple enough to solve
1614:29 - and once we solve them
1614:31 - we have their solutions
1614:33 - so what we do is we take their solution
1614:35 - and we combine them so that
1614:37 - we get the solution to our
1614:39 - original problem
1614:41 - so at this step when we are combining the solution
1614:43 - of smaller sub problems and getting
1614:45 - the solution to our original
1614:47 - problem is actually the conquer
1614:49 - part of it
1614:51 - so let's see how this divide and conquer
1614:53 - algorithm fits into merge sort
1614:57 - so when we are given an array and we want to
1614:59 - sort them what we do is
1615:01 - we first apply the divide part
1615:03 - now in this step
1615:05 - what we do is we take the middle point of the array
1615:07 - and divide the array into
1615:09 - two halves
1615:11 - and once we divide the array into two halves
1615:13 - now the algorithm is carried out recursively
1615:15 - on these two halves
1615:17 - and it goes on till
1615:19 - there are no more halves of arrays
1615:21 - to divide so we keep on
1615:23 - dividing it till there is only one single
1615:25 - element left
1615:27 - which is not further divided
1615:29 - so after this divide step
1615:31 - ends
1615:33 - what we do is
1615:35 - we then conquer
1615:37 - and how we conquer is in this step
1615:39 - from the bottom we
1615:41 - take those smaller half arrays
1615:43 - we sort them and merge
1615:45 - the divided arrays
1615:47 - and get the sorted array
1615:49 - so we will see this divide and
1615:51 - conquer with an example
1615:53 - to make it more clear
1615:55 - so for timing we divide an array
1615:57 - into two halves
1615:59 - and we keep on dividing them
1616:01 - into two halves till
1616:03 - there is only single elements
1616:05 - are left and those are not
1616:07 - pretty much divided
1616:09 - so when we pick those single elements
1616:11 - those are already sorted
1616:13 - so we simply merge them
1616:15 - and get the sorted array
1616:17 - and we keep on doing this
1616:19 - till the complete array is sorted
1616:21 - so lets see these two steps with an example
1616:23 - so
1616:25 - first we will see the divide part
1616:27 - so now lets say we are given with this array
1616:29 - and we want to sort it
1616:31 - in ascending order
1616:33 - so in the divide part what we do is
1616:35 - here we can see that there are
1616:37 - 7 elements
1616:39 - 2, 10, 5, 3, 6, 4
1616:41 - and 11
1616:45 - now we simply evaluate the mid
1616:47 - position so here is
1616:49 - 3 so how we
1616:51 - evaluate this mid position is we will see later
1616:53 - but here we can see
1616:55 - that as there are 7 elements
1616:57 - from 0 to 3
1616:59 - we break it down into
1617:01 - one array and from
1617:03 - 4 to 6 we break it down into other array
1617:05 - so here you can see now
1617:07 - this was our original problem
1617:09 - to solve we break it
1617:11 - down into two smaller
1617:13 - sub problems
1617:15 - and after breaking it down into two
1617:17 - smaller sub problems
1617:19 - we do it recursively again
1617:21 - into these smaller sub parts
1617:23 - so here what we do is
1617:25 - after breaking it down into two parts
1617:27 - we take this part
1617:29 - and we further break it down
1617:31 - into two parts
1617:33 - so this algorithm is pretty much recursive
1617:35 - in nature
1617:37 - and now as this algorithm is recursive
1617:39 - we take this
1617:41 - smaller half
1617:43 - and we break it down into
1617:45 - two halves so here you can see
1617:47 - that after breaking this
1617:49 - 0 and 1 we are left
1617:51 - with single single element
1617:53 - 2 and 10 so here algorithm
1617:55 - decides that ok we can't break
1617:57 - 2 and 10 further down so what
1617:59 - we do is the divide part is done
1618:01 - for this piece
1618:03 - so then we
1618:05 - conquer so in mer sort
1618:07 - a single element is already sorted
1618:09 - and in the
1618:11 - conquer step this is
1618:13 - the smallest solution we have
1618:15 - that lets say if the array had only
1618:17 - one element it would have been sorted
1618:19 - so now in the conquer
1618:21 - part we actually merge them
1618:23 - so in one of our previous videos
1618:25 - we have discussed that how we can
1618:27 - merge
1618:29 - two sorted arrays
1618:35 - so this is the first sorted array
1618:37 - and this is the second sorted array
1618:39 - so in the conquer step
1618:41 - we merge them and we merge
1618:43 - them in such a way that
1618:45 - we compare their respective elements
1618:47 - one by one and we try
1618:49 - to merge them so here
1618:51 - we compare 2 with 10 and
1618:53 - we simply merge them
1618:55 - to get the sorted array
1618:57 - so after merging those two
1618:59 - sorted arrays we are left
1619:01 - with
1619:03 - a larger sorted array
1619:05 - so here 2 and
1619:07 - 10 are actually sorted
1619:09 - now this conquer is
1619:11 - done for this particular step
1619:13 - the algorithm then
1619:15 - tries to break this part
1619:17 - because as this is a recursive algorithm
1619:19 - it breaks it like this
1619:21 - first it breaks in 4
1619:23 - then 2 then 1
1619:25 - 1 and after merging
1619:27 - the smaller subunits
1619:29 - it takes the next
1619:31 - unit and break it down into
1619:33 - smaller pieces
1619:35 - so it breaks 5 and 3
1619:37 - like this
1619:39 - so 5 and 3 cannot be broken down
1619:41 - further so now it conquers
1619:43 - it so here it simply
1619:45 - compares 5 and 3
1619:47 - and we get 3 and 5
1619:49 - because 3 is smaller so 3 comes
1619:51 - here and 5 comes here
1619:53 - so here you can see that this is
1619:55 - the first sorted array
1619:57 - and this is the second sorted array
1619:59 - and now
1620:01 - we simply merge these two parts
1620:03 - because these are solved problems
1620:05 - of our smaller sub problems
1620:07 - so in the conquer step we actually
1620:09 - merge them
1620:11 - so after merging
1620:13 - these two sorted arrays
1620:15 - it looks something like this
1620:17 - so 2 is compared with 3 it comes here
1620:19 - then 10 is compared with 3
1620:21 - so 3 is smaller so 3 comes here
1620:23 - then 5 is compared with 10
1620:25 - 5 is smaller so 5 comes here
1620:27 - and then 10 goes here
1620:29 - and this step
1620:31 - is done
1620:33 - so now algorithm will pick this part
1620:35 - and try to break it down
1620:37 - using the divide step
1620:39 - so it will break it down like this
1620:41 - 6 and 4 and 11
1620:43 - because there are 3 elements
1620:45 - and here it will
1620:47 - now first pick this part
1620:49 - so it will break 6 and 4
1620:51 - like this
1620:53 - and then it will merge
1620:55 - 6 and 4
1620:57 - so which will become 4 and 6
1620:59 - so the only thing to keep in mind
1621:01 - is in the conquer step
1621:03 - of merge sort what we are doing is
1621:05 - we are merging
1621:08 - two sorted arrays
1621:15 - and the result is a large
1621:19 - sorted array
1621:23 - so here you can see that
1621:25 - this was sorted array this was sorted array
1621:27 - we merged it in such a way that
1621:29 - we got a larger
1621:31 - sorted array similarly with
1621:33 - this we got larger sorted array
1621:35 - and as
1621:37 - this part was actually sorted
1621:39 - and this part was also sorted
1621:41 - so we merged these two sorted arrays as well
1621:43 - so we got
1621:45 - this sorted array
1621:47 - and similarly we did here
1621:49 - so after sorting 4 and 6
1621:51 - as 11 is the only
1621:53 - element left
1621:55 - so it goes like this
1621:57 - it comes here
1621:59 - and then we have 2
1622:01 - sorted arrays
1622:03 - and we merge it
1622:05 - so we get 4, 6, 11
1622:07 - and now here you can see
1622:09 - the algorithm sees that we have one sorted array
1622:11 - we have another sorted array
1622:13 - now we can simply merge
1622:15 - these two pieces together
1622:17 - like this
1622:19 - 2, 3, 4, 5, 6, 10, 11
1622:21 - so here you can see
1622:23 - that the final array which got sorted
1622:27 - is actually our original problem
1622:29 - which we wanted to sort
1622:31 - so friends here I will just go back
1622:35 - so we will go through this one more time
1622:37 - we saw that this was the problem given to us
1622:39 - and we wanted to sort it
1622:41 - using merge sort
1622:43 - so here we evaluated
1622:45 - the midpoint of the array
1622:47 - and we break it down
1622:49 - into 2 smaller sub problems
1622:51 - recursively
1622:53 - so recursively
1622:55 - how it goes is
1622:57 - it breaks it down like this
1622:59 - and recursively it goes to here
1623:01 - it break it down like this
1623:03 - and then it again recursively
1623:05 - go here
1623:07 - then it break it down 2 and 10
1623:09 - and it sees that
1623:11 - ok it can't be further broken down
1623:13 - so it tries to merge it
1623:15 - so why it tries to merge it
1623:17 - because this is the
1623:19 - sorted array having only single element
1623:21 - and the single elements are already sorted
1623:23 - so it treats
1623:25 - it as 2
1623:27 - smaller sub arrays which are sorted
1623:29 - and it tries to merge it
1623:31 - in the conquer step
1623:33 - so it merge it like this
1623:35 - 2 and 10
1623:37 - so one thing is important you watched my previous
1623:39 - video where we actually saw the algorithm
1623:41 - how we can merge
1623:43 - 2 sorted arrays
1623:45 - and the resultant array is also sorted
1623:47 - so we will get this sorted array
1623:49 - so this recursion ends here
1623:51 - it then goes
1623:53 - to this side
1623:55 - it takes 5 and 3, breaks it down like this
1623:59 - it merges 5 and 3
1624:01 - which gives 3 and 5
1624:03 - so this part is done
1624:05 - so once this part is done
1624:07 - it sees that ok
1624:09 - I have got one larger
1624:11 - array here and here
1624:13 - and both are sorted
1624:15 - so it tries to merge them
1624:17 - so we will get 2, 3, 5, 10
1624:19 - and after doing
1624:21 - this part completely
1624:24 - it then goes recursively
1624:26 - to this part
1624:28 - it breaks 6, 4, 11
1624:30 - into 2 parts
1624:32 - 6 and 4 on one side and 11
1624:34 - on other side
1624:36 - it recursively sees that ok
1624:38 - I can break this down further
1624:40 - it breaks it down 6 and 4
1624:42 - like this
1624:44 - it merge them
1624:46 - it becomes 4 and 6
1624:48 - and then it goes to this side
1624:50 - it sees that ok
1624:52 - 11 is only the single element left
1624:56 - so it comes here
1624:58 - and it sees that ok
1625:00 - I have got
1625:02 - 2 sorted arrays like this
1625:04 - so in the concur step
1625:06 - I will simply merge them
1625:08 - so when we will merge them
1625:10 - we will get 4, 6, 11
1625:12 - and as we have done this step
1625:14 - the algorithm sees that ok
1625:16 - this is the one sorted array
1625:18 - this is the other
1625:21 - like this
1625:23 - so friend this is the basic idea behind
1625:25 - divide and conquer algorithm
1625:27 - when we are dealing with merge sort
1625:29 - in our upcoming videos
1625:31 - we will see
1625:33 - all these steps in greater detail
1625:35 - we will see the demonstration of the algorithm step by step
1625:38 - so that this idea becomes more clear to you
1625:41 - but how it is actually done
1625:43 - I hope you must have liked this video
1625:46 - in case if you are new to my channel
1625:48 - then please subscribe to my channel
1625:50 - and click the bell icon
1625:52 - so that you never miss any update
1625:54 - thanks have a nice day
1625:58 - so friends before going into the actual algorithm of merge sort
1626:02 - so before we start
1626:04 - in case if you are new to my channel
1626:06 - then please subscribe to my channel
1626:08 - and click the bell icon
1626:10 - so that you never miss any update
1626:12 - we saw that in divide step
1626:14 - we saw that we break the array
1626:16 - into two parts
1626:18 - or into two sub problems
1626:20 - and that we do recursively
1626:22 - so at a high level
1626:24 - I will simply show you the code
1626:26 - so this code we will be discussing
1626:28 - in a greater detail
1626:30 - with an animation in our upcoming video
1626:32 - but just for understanding
1626:34 - that how it works
1626:36 - so when we break the array
1626:38 - into two parts
1626:40 - we are not actually breaking the array from here
1626:44 - let's say from 0 to 3
1626:46 - it goes like this and from 4 to 6
1626:48 - it goes like this
1626:50 - we are breaking it based on the three pointers
1626:52 - let's say low
1626:54 - high and mid
1626:56 - so usually array remains the same
1626:58 - and we have something like
1627:00 - let's say low points here
1627:02 - mid points here
1627:04 - and high points here
1627:08 - so from low to mid
1627:12 - we consider that this is the
1627:14 - sub problem
1627:16 - and from mid plus 1
1627:18 - to high we consider it as a
1627:20 - different problem
1627:22 - but the array structure remains the same
1627:24 - it's only the pointers
1627:26 - which decides which is the left
1627:28 - part and which is the right part
1627:30 - so here you can see in the sort method
1627:32 - this method gets called
1627:34 - two times
1627:36 - recursively so one is
1627:38 - for going into the left side
1627:40 - and one is
1627:42 - going to the right side
1627:44 - after breaking it
1627:46 - based on the mid element
1627:48 - and as this sort is recursive in nature
1627:50 - so here you can see
1627:52 - usually at the start low
1627:54 - points to 0
1627:56 - and higher points to the last index
1627:58 - and let's say if we calculate mid
1628:00 - so here it will be
1628:02 - 0 plus
1628:04 - 6 minus 0
1628:06 - by 2
1628:08 - which will give us
1628:10 - 3
1628:12 - so mid comes out to be 3
1628:14 - so for example let's say we calculate
1628:16 - mid as 3
1628:18 - so this division here
1628:20 - is done based on
1628:22 - calling of these two sorts
1628:24 - so what we do is
1628:26 - so when we call this sort
1628:28 - we pass the ranges from low
1628:30 - to mid
1628:32 - so low to mid
1628:34 - so it looks like that we are doing like this
1628:36 - and for the right sub array
1628:38 - it says from mid plus 1 to high
1628:40 - so this is the mid
1628:42 - plus 1 to high
1628:44 - so it looks like this
1628:46 - but the array remains like this only
1628:48 - it's actually the logical division
1628:50 - based on low, mid and high
1628:52 - pointer and this we do
1628:54 - recursively so when we call
1628:56 - this we actually get this
1628:58 - and it again
1629:00 - does the same thing again
1629:02 - and here you can see it again recursively
1629:04 - calls this so this is
1629:06 - low
1629:08 - and this is mid
1629:10 - and this is mid plus 1
1629:12 - and this is high
1629:14 - so it goes on like this
1629:16 - till we can't divide them further
1629:18 - so this condition
1629:20 - low less than high
1629:22 - help us in preventing that
1629:24 - so here if you see
1629:26 - low
1629:28 - and high
1629:30 - point to the same
1629:32 - so we simply return from this
1629:34 - and once we return from this
1629:36 - it goes here
1629:38 - then this sort is called
1629:40 - like this
1629:42 - and here similarly
1629:44 - this condition help us to
1629:46 - make it come back
1629:48 - so after these two steps
1629:50 - and we actually merge
1629:52 - the two sorted arrays
1629:54 - so these are the sorted arrays
1629:56 - and you can watch my previous
1629:58 - tutorial that how we can actually merge
1630:00 - the two sorted arrays
1630:02 - but in merge sort
1630:04 - we actually take the help of
1630:06 - a temporary array which help us
1630:08 - in merging the two sorted arrays
1630:10 - so this
1630:12 - we will discuss in a greater detail
1630:14 - in our upcoming videos
1630:16 - but here we will simply see a
1630:18 - high level view of merge how it is
1630:20 - actually done
1630:22 - so here you can see that we
1630:24 - saw that
1630:26 - at the last step we take this
1630:28 - sorted array
1630:30 - we take this sorted array
1630:32 - this is the left
1630:34 - array
1630:36 - and this is the right array
1630:42 - and we usually merge it
1630:44 - so we do something like this
1630:46 - we compare the elements
1630:48 - in the respective arrays and we fill out
1630:50 - the array like this and
1630:52 - this is our answer
1630:54 - that we get a sorted array
1630:56 - so this is done via merge method
1631:02 - now let's see how we can take
1631:04 - the help of temporary array and merge
1631:06 - it
1631:08 - so this is the same thing which we saw
1631:10 - in our previous slide deck
1631:12 - so this is the left part
1631:16 - and this is the right part
1631:20 - so these are distinguished based on these colors
1631:22 - so usually how we merge
1631:24 - it we create a temporary array
1631:26 - of the equal length
1631:28 - and then we first copy
1631:30 - all these elements like this
1631:32 - so here it looks
1631:34 - something like this
1631:40 - so after we copy every element like this
1631:42 - now what we do is
1631:44 - this array is our
1631:46 - original array
1631:48 - we have took every element in the temporary array
1631:50 - now we create
1631:52 - the pointers which
1631:54 - traverse to left part and the right part
1631:56 - and based on our comparison
1631:58 - the original array is actually filled
1632:00 - so I will just remove this
1632:04 - so here we take
1632:06 - i for this left part
1632:08 - and j
1632:10 - for this right part
1632:12 - and how we actually fill is
1632:14 - in the original array we start from
1632:16 - here let's say
1632:18 - k
1632:20 - so we compare 2 and 4
1632:22 - denoted by i and j
1632:24 - so 2 is less than 4
1632:26 - so we know that 2 will take this position
1632:28 - like this
1632:30 - and we are done with this part
1632:34 - so we increment i
1632:36 - and we also increment k because we are done with this
1632:38 - filling
1632:40 - now we compare 3
1632:42 - with 4
1632:44 - and 3 takes this place
1632:46 - we are done with this
1632:48 - increment so we increment i
1632:50 - we don't increment j because
1632:52 - these values are not filled up
1632:54 - and you can watch my previous
1632:56 - video where we actually
1632:58 - saw that how we can merge
1633:00 - 2 sorted arrays so this is the
1633:02 - first sorted array, this is the second sorted array
1633:04 - and the concept remains
1633:06 - the same when we do the merge
1633:08 - sort so after filling
1633:10 - 3
1633:12 - we increment k
1633:14 - and then we again compare
1633:16 - 5 and 4
1633:18 - so 4 is smaller
1633:20 - so 4 takes this place
1633:22 - so we are done with this element
1633:24 - so we increment j
1633:26 - and here
1633:28 - similarly we do the
1633:30 - filling so in the
1633:32 - next iteration
1633:34 - 5 is less than 6
1633:36 - so 5 comes here
1633:38 - we increment
1633:40 - i
1633:42 - we increment k
1633:45 - 6 is smaller than 10
1633:47 - so 6 comes here
1633:49 - we increment j
1633:53 - then 10 comes here
1633:57 - and here you can see
1633:59 - after filling 10
1634:02 - this element also
1634:04 - gets filled
1634:06 - so now there are no more elements left in the
1634:08 - left part
1634:11 - and here you can see
1634:13 - that we have only left with 11
1634:16 - so this goes out of the boundary
1634:19 - and whatever the values are left in the right part
1634:21 - we simply
1634:23 - put it here
1634:25 - because they are already sorted
1634:27 - so anything which comes after 11 will be
1634:29 - let's say 12, 14
1634:31 - x, y, z but it will be greater than 11
1634:33 - so they will come directly like this
1634:35 - so we simply copy the elements
1634:37 - in the
1634:39 - left over part of the
1634:41 - original array
1634:43 - so it goes like this
1634:45 - so this is the
1634:47 - merge at a high level
1634:49 - using the temporary array
1634:51 - so from there are 2
1634:53 - cases which we need to see
1634:55 - so the case 1 is
1634:57 - when the left array is exhausted
1634:59 - so here you can see
1635:01 - after filling 2
1635:03 - 3, 5
1635:05 - into the respective position
1635:07 - and even 10
1635:09 - here
1635:11 - now your left array is exhausted
1635:15 - so we don't touch this now
1635:17 - because everything is filled up here
1635:19 - and here you can see
1635:21 - as we copied all the elements
1635:23 - like this
1635:27 - in the original array
1635:29 - if you see
1635:31 - 6, 7 and 8
1635:33 - whatever the values are
1635:35 - here
1635:37 - those are actually sorted
1635:39 - and when we actually copied into the temporary
1635:41 - array
1635:43 - it came it like this only
1635:45 - so here you can see
1635:47 - we don't push it back like this
1635:51 - because the right array values
1635:53 - are already present in the original array
1635:55 - in the same order
1635:57 - 11, 12, 17
1635:59 - so we do nothing here
1636:01 - once the left array is sorted
1636:03 - we do nothing because right array
1636:05 - is already having the elements here
1636:07 - which are already sorted
1636:11 - now case 2 comes
1636:13 - when right array is exhausted
1636:15 - so here you can see
1636:17 - 4, 5
1636:19 - 6, 10
1636:21 - 11
1636:23 - these are all exhausted till this point
1636:25 - so after putting
1636:27 - 11
1636:29 - j goes out of this array
1636:31 - and k comes to this part
1636:33 - and k comes to this part
1636:35 - because we need to fill 2 more elements
1636:37 - and our
1636:39 - right array is exhausted
1636:41 - so here you can see
1636:43 - when the right array is exhausted
1636:45 - we have to do something
1636:47 - to push left array
1636:49 - elements
1636:51 - into this 7 and 8 position
1636:53 - so how we do that
1636:55 - we provide a small code
1636:57 - which is like this
1636:59 - so here you can assume that mid is this point
1637:01 - and i
1637:03 - will go till
1637:05 - mid
1637:07 - and we simply copy the left
1637:09 - over elements into the
1637:11 - respective places using the
1637:13 - i in kth index
1637:15 - so here you can see
1637:17 - in the original array
1637:19 - at kth index we are assigning
1637:21 - temp of i
1637:23 - so this is the temp
1637:25 - and this is the i
1637:27 - so 12 will go to
1637:29 - array of k
1637:31 - like this
1637:33 - and then we increment both i and k
1637:35 - so k will go here
1637:37 - and i will go here
1637:41 - and this while loop will continue
1637:43 - and will simply put 15
1637:45 - at this position
1637:47 - by this assignment
1637:51 - so after that
1637:53 - this while loop will terminate
1637:55 - so friends here
1637:57 - we need to keep
1637:59 - this 2 cases in mind
1638:01 - that if left array is exhausted
1638:03 - we do nothing
1638:05 - because when we copied the element
1638:07 - into a temporary array
1638:09 - when the left array got exhausted
1638:11 - the right array left over elements
1638:13 - were already present in the
1638:15 - original array
1638:17 - and dead to in sorted form
1638:19 - but in case 2 if right array is exhausted
1638:21 - so here
1638:23 - if this array is already
1638:26 - exhausted and all these elements
1638:28 - are present here
1638:30 - and there are elements
1638:32 - left over in the
1638:34 - left part so we need to provide
1638:36 - some additional code like this
1638:38 - to put it into
1638:40 - the respective places
1638:42 - so we will see this algorithm
1638:44 - in much greater detail
1638:46 - in our upcoming video
1638:48 - because that is very complex algorithm
1638:50 - so i just demonstrated
1638:52 - at a high level
1638:54 - how it looks
1638:56 - so when we will discuss that algorithm
1638:58 - we will see all the
1639:00 - details of sort method
1639:02 - merge method
1639:09 - and how this sort method
1639:11 - recursively calls itself
1639:13 - and basically divides the array
1639:15 - into 2 halves
1639:17 - and later when the 2 halves
1639:19 - are no longer divided further
1639:21 - then how we actually merge them
1639:23 - so friends i hope till this point
1639:25 - you must have got a high level idea
1639:27 - of how merge sort works
1639:29 - in our upcoming video
1639:31 - we will see a detailed animation
1639:33 - of merge sort algorithm
1639:35 - which will make this idea
1639:37 - more clear to you
1639:39 - you can watch this video
1639:41 - 2 to 3 times so that you can
1639:43 - get an idea of the merge sort
1639:45 - at high level
1639:47 - i hope you must have liked this video
1639:49 - and in case if you are new to my channel
1639:51 - then please subscribe to my channel
1639:53 - and click the bell icon
1639:55 - so that you never miss any update
1639:57 - thanks have a nice day
1640:01 - hello everyone
1640:03 - so in our previous video
1640:05 - we saw at a high level
1640:07 - that how merge sort works in java
1640:09 - so in this video
1640:11 - we will be looking into the algorithm
1640:13 - and we will also see
1640:15 - the step by step
1640:17 - animation of the algorithm
1640:19 - before we start in case if you are new to my channel
1640:21 - then please subscribe to my channel
1640:23 - and click the bell icon
1640:25 - so here if you see
1640:27 - at a high level
1640:29 - we are going to sort this array
1640:31 - having 5 elements
1640:33 - so you just need to keep that at a high level
1640:35 - how this algorithm works
1640:37 - so that when we demonstrate actual algorithm
1640:39 - you can relate to it
1640:41 - so here we see the array as 5 elements
1640:43 - so we divide
1640:45 - the array into 2 parts
1640:47 - based on the mid index
1640:49 - so we evaluate the mid index
1640:51 - let's say here it comes as 2
1640:53 - so how we break it
1640:55 - we usually consider
1640:57 - this as low
1640:59 - this would be mid
1641:01 - and this would be high
1641:03 - and this would be high
1641:05 - so low to mid
1641:09 - is the left sub array
1641:11 - mid plus 1
1641:13 - to high
1641:15 - is the right sub array
1641:17 - so here we can see
1641:19 - that we break it down logically
1641:21 - using these 3 pointers
1641:23 - like this
1641:25 - low to mid
1641:27 - is 1 side
1641:29 - and mid plus 1
1641:31 - to high
1641:33 - on the other side
1641:35 - so now after dividing the array into 2 parts
1641:37 - we recursively
1641:39 - break the left part further down
1641:41 - so here
1641:43 - this will be our low
1641:45 - this will be mid
1641:47 - and this will be high
1641:49 - so we break it down
1641:51 - into these 2 parts
1641:53 - low to mid
1641:55 - in the left
1641:57 - and mid plus 1 to high
1641:59 - on the right part
1642:01 - and this algorithm goes recursively
1642:03 - and we divide now these 2 elements
1642:05 - so it will be divided something like this
1642:07 - 9, 5
1642:09 - and here we see
1642:11 - we can't further divide 9
1642:13 - and 5
1642:15 - because these are the single elements
1642:17 - so these are nothing but
1642:19 - our algorithms base case
1642:21 - that we can't divide them further
1642:23 - so here you can see
1642:25 - when the division ends
1642:27 - for this part
1642:29 - now is the time to conquer it
1642:31 - so here this left sub array
1642:33 - is actually sorted because it has only
1642:35 - 1 element
1642:37 - and the right is also sorted
1642:39 - so now we have 2 sorted arrays
1642:41 - and we try to merge them
1642:43 - and we merge them in such a way that
1642:45 - the resultant array is also sorted
1642:47 - so we simply do the comparison
1642:49 - and we come up with
1642:51 - 5 and 9
1642:53 - so this is the merge step
1642:55 - so after merging the left
1642:57 - side, now we go to the right side
1642:59 - so we pick 2
1643:01 - 2 can't be divided further down
1643:05 - so then here you can see we have
1643:07 - left sub array
1643:09 - and right sub array
1643:11 - both are sorted
1643:13 - so we try to merge them
1643:15 - so after merging it becomes
1643:17 - 2, 5, 9
1643:19 - and after doing this part
1643:23 - as this is the recursive algorithm
1643:25 - we first go to the left and then
1643:27 - we go to the right
1643:29 - so here you can see for this point we have completed
1643:31 - all the left side
1643:33 - so now we go and perform the same steps
1643:35 - on the right side
1643:37 - we break it down into 2 parts
1643:39 - then we go to the left
1643:41 - and then we go to right
1643:43 - so when we go to right, we can't further break it down
1643:47 - so here the single element is already sorted
1643:49 - we try to break
1643:51 - the right side
1643:53 - we find that it has only 1 element
1643:55 - so we can't divide them further down
1643:57 - so what we do is
1643:59 - we try to merge them
1644:01 - so when we merge them
1644:04 - it becomes 3, 4
1644:06 - and here you can see
1644:08 - now we have this 2
1644:10 - sub array which are sorted
1644:12 - so we try to merge them
1644:14 - so 2, 5, 9 and 3, 4
1644:16 - we apply the logic of merging of
1644:18 - 2 sorted arrays
1644:20 - and at the end we will get
1644:22 - 2, 3, 4, 5, 9
1644:24 - so just keep in mind that we will perform
1644:26 - these steps
1644:28 - when we will demonstrate the actual algorithm
1644:30 - so that you can relate
1644:32 - that how at high level
1644:34 - this algorithm works
1644:38 - so here you can see
1644:40 - that this is the merge sort algorithm
1644:42 - where we have this sort method
1644:44 - and this is the array which we want to sort
1644:46 - in our previous video
1644:48 - we also saw that
1644:50 - how we can use this
1644:52 - temporary array
1644:54 - to merge 2 sorted arrays
1644:56 - into the original array
1644:58 - so here when we will call this method
1645:02 - so let's suppose we want to sort this array
1645:04 - having 5 elements
1645:06 - 9, 5, 2, 4, 3
1645:08 - so here
1645:10 - this temp array
1645:12 - is actually of equal length
1645:14 - of our original array
1645:16 - and at the start it mostly contains the default value
1645:18 - which is 0
1645:20 - so for timing
1645:22 - I just made it empty
1645:24 - and here you can see
1645:26 - that we want to sort this complete array
1645:28 - from 0
1645:30 - to 4th index
1645:32 - so we provide low
1645:34 - and a high value
1645:36 - so usually at the start low is 0
1645:38 - and high is
1645:40 - array.length-1
1645:42 - so this array is of length 5
1645:44 - and if we do
1645:46 - minus 1
1645:48 - we get the last index
1645:50 - so low will point to the 0th
1645:52 - index
1645:54 - and high will point to the 4th index
1645:56 - and here you can see
1645:58 - that as it is a recursive algorithm
1646:00 - this sort method
1646:02 - internally calls
1646:04 - itself again
1646:06 - with some different values
1646:08 - so we need to keep the track of the
1646:10 - sort method here
1646:12 - in the call stack
1646:14 - so we need to keep the track of
1646:16 - these 4 things
1646:18 - one is the line number
1646:20 - so let's say if we are leaving
1646:22 - this sort method
1646:24 - and calling this sort
1646:26 - so we keep the track of the line number
1646:28 - because when this
1646:30 - sort method will end
1646:32 - we need to return back to this method
1646:34 - so this line number will help us
1646:36 - that where we actually left
1646:38 - and which sort method we left
1646:40 - so we keep the track
1646:42 - of the line number here
1646:44 - and 3 fields low
1646:46 - mid and high
1646:48 - so these 3 fields are very important
1646:50 - because they help us
1646:52 - in dividing the array
1646:54 - and at the end they also help
1646:56 - us in merging the array
1646:58 - to make the array in sorted form
1647:04 - so here at the start
1647:06 - there will be one
1647:08 - sort method
1647:10 - so here we saw that low is 0
1647:12 - and high is 4
1647:14 - so here
1647:16 - low should be less than high
1647:18 - so this is nothing but our base case
1647:20 - because as we are calling this
1647:22 - algorithm recursively
1647:24 - we need to provide a base case
1647:26 - so that we come out of the recursion
1647:28 - so in the simple
1647:30 - terms let's say
1647:32 - if we have this
1647:34 - array
1647:36 - 5 3
1647:38 - and using this
1647:40 - 2 sort method
1647:42 - if we break it down like this
1647:44 - 5 and 3
1647:46 - so here
1647:48 - we can see at this
1647:50 - moment of time low
1647:52 - and high will point
1647:54 - to the same index
1647:56 - so when we will call this
1647:58 - sort recursively on this element
1648:00 - you will find that low
1648:02 - is actually equal to
1648:04 - high so therefore we can't
1648:06 - divide this array further so we actually return
1648:08 - and similarly
1648:10 - with 3 we
1648:12 - return and once we
1648:14 - return then we know that 5
1648:16 - and 3 are 2
1648:18 - left and right array so we
1648:20 - simply call the merge method
1648:22 - and merge them and this
1648:24 - we do recursively for each and
1648:26 - every array which we have divided
1648:28 - so we will see later
1648:34 - so for timing this is the base case
1648:42 - so currently low is 0 and
1648:44 - high is 4 so this condition
1648:46 - comes out to be true
1648:48 - in our
1648:50 - previous video we saw that merge
1648:52 - sort is
1648:54 - divide
1648:56 - and conquer algorithm
1648:58 - so this division
1649:00 - goes on till
1649:02 - our base case is reached
1649:04 - and once we encounter the
1649:06 - base cases then we try
1649:08 - to conquer
1649:10 - and by conquer we mean
1649:12 - we try to sort
1649:14 - 2 sorted arrays
1649:16 - which we also
1649:18 - discussed in our previous video
1649:20 - so this merge method help us in doing that
1649:24 - so here we need to divide this now in 2 parts
1649:26 - and how we can do that
1649:28 - so we try to
1649:30 - figure out the mid element
1649:32 - and how we can figure out the mid element is
1649:34 - by using this
1649:36 - formula
1649:38 - so here we do low plus
1649:40 - high minus low by 2
1649:42 - so here low is
1649:44 - 0
1649:46 - plus
1649:48 - high is 4
1649:50 - minus 0
1649:52 - by 2
1649:54 - which will give us value is 2
1649:56 - it means
1649:58 - this index
1650:00 - so usually when you see
1650:02 - the merge sort code you will find that
1650:04 - this is somewhat
1650:06 - different here we do
1650:08 - something like low
1650:10 - plus high
1650:12 - by 2
1650:14 - so basically in the text books
1650:16 - most of the time you find this low plus
1650:18 - high divided by 2 which give us
1650:20 - the mid element
1650:22 - so why we actually do this here
1650:24 - and not this
1650:26 - is because here you can see this low
1650:28 - and high are basically integer values
1650:34 - so usually they have a particular range
1650:36 - and if we cross
1650:38 - that particular range
1650:40 - we actually get the garbage values
1650:42 - so if we do low
1650:44 - plus high
1650:46 - like this
1650:48 - so in most of the cases
1650:50 - this works but if low
1650:52 - value and high values are
1650:54 - at the very end
1650:56 - of the integer value
1650:58 - and if we do some of it we will actually get some
1651:00 - garbage value
1651:03 - so therefore if our array
1651:05 - is very huge
1651:07 - this condition gives us the garbage values
1651:09 - so we try to avoid this
1651:15 - and we use low plus high
1651:17 - minus low by 2 because
1651:19 - if we do high minus low
1651:21 - we will come back into the integer range only
1651:24 - so basically this
1651:26 - we use to avoid the overflow
1651:29 - of integer value
1651:31 - so now here you can see
1651:33 - that we have calculated mid as 2
1651:37 - so mid becomes 2
1651:39 - here you can see mid is pointing to
1651:41 - index 2
1651:46 - so now what it suggest is
1651:48 - from low
1651:50 - to mid
1651:52 - this would be our left part
1651:55 - and from mid plus 1 to high
1651:57 - this would be our right part
1652:00 - so now we are breaking this array into 2 parts
1652:03 - using this
1652:05 - 3 variables which are low, mid and high
1652:08 - so we are not actually breaking the complete array
1652:10 - we are simply
1652:12 - dividing the array based on these 3 values
1652:14 - so from low to mid
1652:16 - this is our left part
1652:18 - from mid plus 1
1652:20 - to high
1652:21 - this is our right part
1652:23 - and we know that we have to call this
1652:25 - algorithm recursively
1652:27 - because we need to still break it down
1652:29 - further
1652:31 - till they are not further divided
1652:33 - so here you can see
1652:35 - after calculating the mid
1652:37 - we are now going into the left side of it
1652:39 - to divide it further
1652:41 - so we will divide these 3 elements
1652:43 - further
1652:45 - so here you can see
1652:47 - that we are going from low to mid
1652:49 - and as we are leaving this short method
1652:51 - at line number 4
1652:54 - so first we will update the line number here
1652:59 - and then we will call the short method
1653:06 - so this short method will be called
1653:08 - so here you can see we pass mid as 2
1653:10 - so this mid
1653:12 - for this short method became high
1653:15 - so now there will be one more method on the call stack
1653:19 - which is high
1653:21 - as 2 because we have called
1653:23 - the short method from 0 to 2
1653:25 - because now we need to further
1653:27 - break it down
1653:29 - this left array
1653:31 - so initially there was complete array
1653:33 - now we are trying to break this
1653:35 - left array further down
1653:39 - so high as 2
1653:41 - and here
1653:43 - for this short method
1653:45 - high will come to this point
1653:48 - low is less than high
1653:51 - we again calculate the mid point
1653:53 - so here mid point would be
1653:55 - 0 plus
1653:57 - 2 minus 0
1653:59 - by 2 which is 1
1654:01 - so mid becomes 1
1654:05 - we update the mid here
1654:07 - it looks something like this
1654:09 - so now what it suggests is
1654:11 - this boundary
1654:18 - again divides
1654:20 - the array into 2 parts
1654:22 - so from low to mid
1654:24 - we have left
1654:27 - and mid plus 1 to high
1654:29 - we have right
1654:36 - so now again recursively
1654:38 - we try to break the left part
1654:40 - from low to mid
1654:42 - so here we are again leaving this method
1654:44 - at line number 4
1654:46 - so we will update the line number 4 here
1654:50 - and here mid is 1
1654:52 - so for the next short method
1654:54 - this mid becomes the high
1655:00 - so now there will be one more method
1655:02 - on the call stack
1655:04 - with high as 1
1655:09 - and for this short method
1655:11 - high will come to this position
1655:14 - so low is less than high
1655:19 - now we again compute the mid element
1655:21 - so here
1655:23 - 0 plus
1655:25 - 1 minus 0
1655:27 - by 2
1655:29 - which will give us 0
1655:31 - so now mid becomes 0
1655:35 - we update it here
1655:37 - so mid points to 0
1655:39 - I will just remove this
1655:43 - so now we have calculated the mid
1655:45 - it means
1655:47 - we again have 1 boundary
1655:49 - from low to mid
1655:51 - which is the 1 element
1655:53 - and mid plus 1
1655:55 - to high which is the other element
1655:59 - so here you can see
1656:01 - that now we are again calling short because
1656:03 - currently our array is of 2 elements
1656:05 - and we can still further break it down
1656:07 - to 1 1 element
1656:09 - from low to mid
1656:11 - which is the 0
1656:13 - and mid plus 1 to high
1656:15 - which is 1
1656:17 - to 1
1656:19 - so we are leaving this short method
1656:21 - at line number 4
1656:31 - so this mid is 0
1656:33 - so here you can see
1656:35 - low is 0
1656:37 - and high becomes 0 because
1656:39 - we have called this short method with
1656:41 - mid value is 0
1656:43 - and this mid value
1656:45 - for this short method becomes our new high
1656:47 - so we will simply point high to
1656:49 - 0
1656:51 - as high is 0
1656:53 - so here you can see
1656:55 - that now we have
1656:57 - reached our base case
1656:59 - because we can't divide
1657:01 - this single element further
1657:03 - so at the start
1657:05 - we had this full complete array
1657:07 - then we had
1657:09 - this small array
1657:11 - and then we had
1657:13 - this small array
1657:15 - and now we are actually having this array
1657:17 - so we can't divide 9 further
1657:19 - down
1657:23 - so it means we have reached our base
1657:25 - case and we have to return
1657:27 - from here so as we want to
1657:29 - return from this short method
1657:31 - the call will reach to this short method
1657:33 - and we need to begin from line
1657:35 - number 4 again
1657:37 - so we will see how
1657:41 - so this execution
1657:43 - point reached here
1657:45 - and we know that we had left
1657:47 - its previous short method at line number
1657:49 - 4 so we will start from there
1657:51 - and when we
1657:53 - had left this short method
1657:55 - low, mid and high
1657:57 - pointed to 0, 0 and
1657:59 - 1 so we again
1658:01 - provide them their own values
1658:04 - high becomes 1
1658:07 - mid becomes 0
1658:09 - so it was something like this
1658:11 - when we left
1658:13 - so now we move ahead
1658:15 - so here we are done
1658:17 - breaking this
1658:19 - left part
1658:21 - now this two short method
1658:23 - actually help us in getting the left
1658:25 - part of the array
1658:27 - and
1658:29 - right part of the array
1658:32 - and then we merge both
1658:34 - of them here to make a sorted
1658:36 - array
1658:38 - so usually this left and right part
1658:40 - are also sorted
1658:42 - which we will see later
1658:44 - and in the merge method
1658:46 - we are actually merging
1658:48 - two sorted arrays
1658:49 - so we will see how
1658:51 - so now we need to break 5
1658:53 - or mid plus 1 to
1658:55 - high further down
1658:57 - so we need to leave this short method
1658:59 - now and we need to call
1659:01 - this short again and we are
1659:03 - leaving at line number 5
1659:05 - so we update line number 5
1659:09 - and there will be one more
1659:11 - method on the call stack
1659:13 - with values as
1659:15 - low will be 1
1659:17 - and high will be 1
1659:19 - because when we had left
1659:21 - this short method
1659:23 - mid was pointing to 0
1659:25 - and when we called this short again
1659:28 - we provided mid plus 1 so it means
1659:30 - our new low
1659:32 - becomes 1
1659:34 - and high remains the same
1659:39 - so it looks something like this
1659:41 - for this short method
1659:43 - that low is pointing to 1 and high is pointing to 1
1659:46 - like this
1659:48 - and here you can see we can't divide
1659:50 - 5 further down
1659:52 - so this is our base case
1659:54 - so now we have to return from this method
1659:57 - and once we return from this method
1659:59 - the execution point will reach here
1660:03 - and that method will be removed from the call stack
1660:06 - so we had left at line number 5
1660:08 - so we start from there
1660:10 - and when we left
1660:12 - this short method
1660:14 - low pointed to 0, mid pointed to 0
1660:16 - and high pointed to 1
1660:18 - so we provide them their own values
1660:20 - like this
1660:26 - so we move ahead
1660:28 - so friends here you can see
1660:30 - that in this algorithm
1660:32 - we are actually recursively going down and down
1660:34 - and we are dividing the array
1660:36 - into 2 parts
1660:38 - so at the end we are only left with
1660:40 - single single elements
1660:42 - which cannot be divided further
1660:44 - which are actually encountering our base case
1660:46 - so after
1660:48 - this 2 short method
1660:50 - now it's time to merge
1660:52 - both left part
1660:54 - which we got from this short
1660:56 - and the right part which we got from this short
1660:58 - so here you can see
1661:00 - 9 and 5
1661:02 - you can think of it
1661:04 - a small array having only 1 element
1661:06 - and when array is only 1 element
1661:08 - that array is
1661:10 - considered as sorted
1661:12 - because there is only 1 element
1661:14 - so now this merge method
1661:16 - will take this left part
1661:18 - and the right part
1661:20 - because they have only single single element
1661:22 - and compare these 2 elements
1661:24 - in such a way that
1661:26 - both these elements become sorted
1661:28 - so that we will see in the
1661:30 - merge method
1661:32 - so we are leaving this
1661:34 - short method at line number 6 now
1661:36 - so we will update line number 6 here
1661:38 - so we will update line number 6 here
1661:40 - so we will update line number 6 here
1661:46 - and here we have this merge method
1661:48 - we pass the array
1661:50 - the temporary array
1661:52 - low
1661:54 - mid and high
1661:56 - so because we require all these 3 values
1661:58 - to actually come to know that
1662:00 - from low to mid
1662:02 - we have left part
1662:04 - mid plus 1 to high we have the right part
1662:06 - so these are the 3 values
1662:12 - so in our previous video we saw that
1662:14 - how we are actually doing the merge
1662:16 - first we are actually copying
1662:18 - all the elements from the original array
1662:20 - to temporary array
1662:22 - and how we are copying it
1662:24 - we are only copying that much part
1662:26 - which we want to merge
1662:28 - so from low to high
1662:30 - so here low is 0
1662:32 - and high is 1
1662:34 - it means we are only copying
1662:36 - this and this element
1662:38 - so it looks something like this
1662:40 - we will traverse this for loop quickly
1662:48 - so 9 comes here
1662:50 - and 5 comes here
1663:08 - and this for loop ends
1663:14 - so now we have copied the elements
1663:16 - like this here
1663:18 - we will now merge these 2 sorted arrays
1663:20 - which is having only single elements
1663:26 - left and right
1663:28 - so here we actually take 3 pointers
1663:30 - one will point to the
1663:32 - left sub array
1663:34 - so here i will point to the left sub array
1663:36 - j will point to the
1663:38 - right sub array
1663:40 - because we know that it is
1663:42 - starting from mid plus 1
1663:44 - and k will help us
1663:46 - in merging these 2 sorted arrays
1663:48 - back into the original array
1663:50 - so we will see now
1663:52 - so i is 0
1663:54 - it is pointing to this left
1663:56 - sub array
1663:58 - so you can think that this array is like this
1664:00 - left and right
1664:02 - j is 1
1664:04 - so j is pointing to
1664:06 - the right sub array
1664:10 - and k is 0
1664:12 - so k will
1664:14 - basically start from low
1664:16 - because we are merging
1664:18 - these 2 sorted arrays based on this range
1664:20 - so when we copied this
1664:22 - element from any particular
1664:24 - range we need to put it
1664:26 - back into that range only
1664:28 - so we are starting from k equals
1664:30 - to whatever the value low
1664:32 - has so currently it is
1664:34 - pointing to the 0th index
1664:38 - so here in our
1664:40 - previous videos we actually discussed
1664:42 - how we can merge 2 sorted arrays
1664:44 - so the idea behind
1664:46 - this algorithm
1664:48 - or this merge method is
1664:50 - pretty much the same
1664:52 - here i will go
1664:54 - till it is less than equal to mid
1664:56 - so i will traverse the left part
1664:58 - and j will traverse
1665:00 - the right part
1665:02 - so these are
1665:04 - the last indexes
1665:06 - of these 2 small arrays
1665:08 - so currently
1665:10 - both the conditions come out to be true because
1665:12 - 0 is less than equal to
1665:14 - mid and j is
1665:16 - less than equal to
1665:18 - high
1665:20 - so here you can see
1665:22 - we have 2 small arrays
1665:24 - of single single
1665:26 - element which are
1665:28 - inherently sorted
1665:30 - and now we need to merge it
1665:32 - in such a way that final
1665:34 - array also is sorted
1665:36 - so how we do that is
1665:38 - we are taking 10 value with i.e. index
1665:40 - and 10 value with jth index
1665:42 - which is 9 and 5
1665:44 - and we are checking whether
1665:46 - 9 is less than 5 or not
1665:48 - so 9 is not less than 5
1665:50 - so this condition comes out to be false
1665:52 - and the else part will be executed
1665:54 - so it means that
1665:56 - this position among these 2 values
1665:58 - whichever is the smaller will
1666:00 - place it there so currently
1666:02 - 10 value with jth index is smaller
1666:04 - which is 5 so 5 goes
1666:06 - to the kth index
1666:08 - of original array
1666:10 - so it goes like this
1666:14 - and here we have
1666:16 - placed 5 at its correct position
1666:18 - so we simply increment
1666:20 - j
1666:22 - j becomes 2
1666:24 - but we know that
1666:26 - currently there was only 1 element
1666:28 - but there could be a possibility
1666:30 - that we are trying to merge a
1666:32 - very huge array which is
1666:34 - equally among the left
1666:36 - and the right part
1666:38 - but currently we have only this 1 element
1666:42 - and as we have
1666:44 - filled this position we will increment k
1666:48 - so k becomes 1
1666:52 - now here you can see
1666:54 - this condition comes out to be false
1666:56 - because j has crossed the
1666:58 - limits of high
1667:00 - as j value is 2
1667:02 - greater than 1
1667:04 - so this while loop will terminate
1667:08 - and here you can see once the while loop
1667:10 - gets terminate
1667:12 - we have only placed 5 here
1667:14 - we need to place 9
1667:16 - at its correct position
1667:18 - so we are providing this small
1667:20 - loop and we also
1667:22 - discussed in our previous video that once
1667:24 - the right array is exhausted
1667:26 - we need to provide
1667:28 - this small while loop so that
1667:30 - all the elements of the
1667:32 - left sub array are directly copied back
1667:34 - so they are copied
1667:36 - back with this condition which was
1667:38 - similar to here
1667:40 - that i should be less than equal to mid
1667:42 - so currently i is
1667:44 - less than or equal to mid
1667:50 - and using this while loop we are simply
1667:52 - copying back the
1667:54 - element from the ith index to the
1667:56 - kth index
1667:58 - so now 9 goes here
1668:06 - and after placing
1668:08 - 9 to correct position
1668:10 - we have used this 9 so we will increment
1668:12 - i
1668:14 - i becomes 1
1668:16 - we have filled this position so we will increment k also
1668:22 - k becomes 2
1668:24 - and here you can see
1668:26 - that we have merged this left and right
1668:28 - sub array
1668:32 - so here now this condition comes out to be false
1668:34 - so here you can see
1668:36 - after this merge method ends
1668:42 - we sorted
1668:44 - left
1668:46 - and right
1668:48 - both were two sorted
1668:50 - arrays and we merged them
1668:52 - so we got the
1668:54 - result array of two
1668:56 - elements which are now sorted
1668:58 - so now we will leave this method
1669:00 - and we will go back to the
1669:02 - sort method where we actually left
1669:06 - so the point will reach here back
1669:08 - we had left at line number 6
1669:10 - which was this part
1669:12 - so now here you can see
1669:14 - so when we had left
1669:16 - low, mid and high pointed to 001
1669:18 - based on the values we
1669:20 - kept here
1669:22 - so it was something like this
1669:24 - so here you can see now this sort
1669:26 - method will end because there are no
1669:28 - more lines to execute
1669:30 - and also you will find it
1669:32 - after this merge method ends in the
1669:34 - original array
1669:36 - vf5 and 9
1669:38 - actually sorted into
1669:40 - the range of low to high
1669:44 - so this method will end now
1669:46 - and once this method will
1669:48 - end
1669:52 - it will reach to this point because
1669:54 - we had left this sort
1669:56 - at line number 4
1669:58 - so we again
1670:00 - start execution from line number 4
1670:02 - we provide the
1670:04 - respective values to low, mid and high
1670:08 - so when we had left
1670:10 - this sort, this was our
1670:12 - condition
1670:14 - so now we move
1670:16 - ahead with our execution
1670:18 - so here you can see
1670:20 - this sort method
1670:22 - actually
1670:24 - sorted the
1670:28 - left part
1670:30 - so here you can see
1670:32 - if this is the
1670:34 - line
1670:36 - this array
1670:38 - which is our left is sorted now
1670:40 - so now we try to go to the right part
1670:42 - using this sort method
1670:44 - so we provide mid
1670:46 - plus 1 and high
1670:48 - so mid plus 1 is the range
1670:50 - for the right part
1670:52 - and it goes still high
1670:54 - so now we will again leave this method at line number 5
1671:02 - so this sort method will
1671:04 - be called again
1671:06 - with low as mid plus 1
1671:08 - so when we will leave this method
1671:10 - mid was pointing to 1
1671:14 - so in the call
1671:16 - stack there will be
1671:18 - sort method
1671:20 - where low will be node 2
1671:22 - which is like this here
1671:24 - and high will point to 2 because
1671:26 - the high remains at its own
1671:28 - position
1671:30 - mid was 1, previous to it
1671:32 - so for this method it became mid
1671:34 - plus 1
1671:36 - so mid plus 1 is 2
1671:38 - and this 2
1671:40 - became our low
1671:42 - for this sort method
1671:44 - so it means now we are going
1671:46 - to the right side
1671:48 - recursively
1671:50 - to divide that array further down
1671:52 - so here you can see we only have this
1671:54 - one element
1671:56 - so we have encountered our base case
1671:58 - so we return from here
1672:00 - we reach here
1672:04 - we had left at line number 5
1672:08 - and we have
1672:10 - line number 5
1672:12 - so we start from line number 5
1672:14 - and now here you can see
1672:16 - we provide these
1672:18 - values to their respective
1672:20 - variables
1672:22 - low was 0
1672:26 - mid was 1
1672:28 - which is at index 1
1672:32 - and this was our line
1672:34 - which divided the left and right
1672:36 - so this is the left
1672:38 - and this is the right
1672:42 - so here you can see
1672:44 - when we had called merge method
1672:46 - previous to that
1672:48 - we actually merged 2 small
1672:50 - arrays having single element
1672:52 - 5 and 9
1672:54 - and whatever was the result
1672:56 - that was sorted
1672:58 - then we went to the right
1673:00 - and we found that the right
1673:02 - part has only one element so it is already
1673:04 - sorted
1673:06 - so this merge method will take
1673:08 - a bigger
1673:10 - sorted array
1673:12 - and will try to merge
1673:14 - with the right sub array
1673:18 - so this merge method will be called
1673:24 - this is our temporary array
1673:26 - high is 2, mid is 1
1673:28 - and low is 0
1673:30 - so from low to mid
1673:32 - so from low
1673:36 - to mid
1673:38 - this is the left part
1673:40 - which is sorted
1673:42 - and from mid plus 1
1673:44 - to high
1673:46 - this is our right part
1673:48 - now we are actually merging a slightly bigger array
1673:50 - so we will go over this merge
1673:52 - method quickly
1673:54 - we copy the elements
1673:56 - from the original array
1673:58 - to the temporary array
1674:00 - from low to high
1674:02 - so 5, 9, 2
1674:04 - we copy to temp at the respective
1674:06 - positions
1674:08 - so we will go over this
1674:10 - for loop quickly
1674:14 - 5 comes here
1674:24 - 9 comes here
1674:34 - 2 comes here
1674:42 - and this for loop will end
1674:52 - so friends here you can see
1674:54 - that now we have a left part
1674:56 - and the right part
1674:58 - which are sorted and we need to merge
1675:00 - these two sorted arrays
1675:02 - and after merging it we need to transfer it back
1675:04 - to the original array
1675:06 - so this is the boundary
1675:08 - for left
1675:12 - and this single element is in the right
1675:16 - so it's very much similar
1675:18 - to what we discussed previous to it
1675:20 - i will be traversing
1675:22 - the left part and j will be traversing
1675:24 - the right part so j will
1675:26 - start from mid plus 1, mid plus
1675:28 - 1 is 2
1675:30 - and i will start from 0
1675:32 - like this
1675:34 - and k will start from the low
1675:36 - which is 0
1675:42 - so now we will again merge these
1675:44 - two sorted arrays based on this
1675:46 - while loop provided here
1675:48 - so i is less than mid and j is
1675:50 - less than equal to i
1675:52 - so both the conditions come out to be
1675:54 - true
1675:56 - now we compare
1675:58 - the element at ith index
1676:00 - with the jth index
1676:02 - which is 5 and 2
1676:04 - so 5 is not less than 2
1676:06 - so this condition comes out to be false
1676:08 - and into the original array
1676:10 - we first place the smallest
1676:12 - element which is
1676:14 - temp of j
1676:16 - so temp of j is 2
1676:18 - so 2 goes here
1676:22 - and after using this
1676:24 - we increment j
1676:26 - so j points to 3
1676:32 - and after filling this position
1676:34 - we increment k
1676:40 - now here you can see
1676:42 - that the right array is exhausted
1676:44 - because j
1676:46 - value is 3
1676:48 - and 3 is greater than 2
1676:50 - so this condition comes out to be false
1676:52 - so here you can see that
1676:54 - we actually placed
1676:56 - all the elements of the right sub array
1676:58 - into the original array
1677:00 - but the left sorted
1677:02 - array still remains and as it
1677:04 - is already sorted we will simply copy it
1677:06 - back to the respective
1677:08 - kth position
1677:10 - using this while loop
1677:12 - so i is less than equal
1677:14 - to mid
1677:16 - we copy 5
1677:18 - to the kth index which is 1
1677:20 - so 5 comes here
1677:22 - then we will increment
1677:24 - both the pointers because
1677:26 - we have filled this position
1677:28 - and we have used this element
1677:30 - so i becomes 1
1677:38 - and k comes to 2nd index
1677:42 - i is less than equal to mid
1677:46 - we copy 9
1677:48 - to index 2
1677:52 - we filled this position
1677:54 - so k comes here
1677:56 - and as we have used this position
1677:58 - so i comes here
1678:00 - so now this value will terminate
1678:02 - because
1678:04 - value of i is 2
1678:06 - 2 is greater than 1
1678:08 - so this condition comes out to be false
1678:16 - so friend here you can see
1678:18 - now slowly we are merging the array
1678:20 - and we are actually getting
1678:22 - a bigger sorted array
1678:24 - so it started with single single element
1678:26 - then we got 2 elements
1678:28 - 5 and 9
1678:30 - and now we are getting 3 elements
1678:32 - 2 5 9
1678:34 - so we go back to the
1678:36 - sort method where we left
1678:38 - so here we left at line number 6
1678:44 - where these were the
1678:46 - default values for low, mid and high
1678:48 - low, mid and high
1678:50 - and this was the boundary
1678:52 - so here you can see now
1678:54 - we have sorted
1678:56 - the left part and the right part
1678:58 - in such a way that now they are
1679:00 - completely sorted with
1679:02 - this much range
1679:06 - so this merge method is ended
1679:08 - all will reach here
1679:12 - so this is the line number
1679:14 - where we left this sort method
1679:16 - and the respective values are 0
1679:18 - 2 and 4
1679:22 - so high was pointing
1679:24 - to 4th index
1679:26 - mid was pointing to the second index
1679:28 - when we actually left
1679:30 - at the first sort
1679:32 - so now here you can see
1679:34 - we have completely sorted
1679:36 - the left side of it
1679:40 - now we simply go to the right side
1679:42 - using this sort method
1679:45 - which is going from mid
1679:47 - plus 1 so this range
1679:49 - is mid
1679:50 - plus 1
1679:51 - 2 high
1679:52 - so when we will call this
1679:54 - sort method again, mid plus 1
1679:56 - becomes our low
1679:57 - so here
1679:58 - we will first update the line number
1680:05 - there will be one more method on the
1680:07 - call stack
1680:08 - where low will be 3
1680:10 - because mid plus 1 is
1680:13 - 2 plus 1
1680:15 - which became our new low
1680:17 - for the right part
1680:20 - and high is actually 4 only
1680:26 - so we are simply placing this
1680:28 - into the respective indexes
1680:30 - for this sort method
1680:34 - low is less than high
1680:36 - we calculate the mid
1680:38 - now here you can see
1680:40 - first we did this
1680:42 - for the left part
1680:44 - and we keep on breaking it
1680:46 - till we got a single element
1680:48 - now we are simply doing it for the
1680:50 - right part
1680:52 - so now low is 3
1680:54 - plus
1680:55 - 4 minus 3
1680:57 - by 2
1680:59 - so this will give us value as 3
1681:03 - because 1 by 2 is 0
1681:07 - and 3 plus will give us 3
1681:09 - so this will give us 3 now
1681:13 - so here you can see now
1681:15 - we have got our 2 boundaries
1681:17 - low to mid is the left part
1681:20 - and mid plus 1 to high is the right part
1681:26 - so first we will go to the left part
1681:28 - and try to divide the array
1681:31 - we will update line number
1681:33 - we will call the sort method
1681:39 - with low as 3
1681:41 - and when we had left
1681:43 - this sort method
1681:45 - mid was actually pointing to 3
1681:47 - so for this sort method
1681:49 - here this mid becomes our high
1681:52 - so value is 3
1681:57 - so it looks something like this
1682:00 - so we have reached our base case
1682:02 - and we can't divide
1682:04 - 4 further down
1682:06 - which is at index 3
1682:08 - so we return back
1682:11 - I will just remove this
1682:16 - so we had left at line number 4
1682:18 - so we start execution from here
1682:20 - low, mid and higher pointed to 3
1682:22 - 3 and 4
1682:24 - like this
1682:30 - so here
1682:32 - this 4
1682:34 - cannot be divided further
1682:36 - and as this left part is only one element
1682:39 - it is inherently sorted
1682:41 - and now we go to the right part
1682:43 - via this sort method
1682:46 - we update the line number
1682:48 - and here
1682:50 - we are leaving with mid plus 1
1682:53 - which will become our new low
1682:55 - so mid plus 1 is 4
1683:01 - so in this sort method
1683:03 - low became 4
1683:05 - and high is actually
1683:07 - at its own position 4
1683:11 - so it looks something like this
1683:16 - this is our base case because low is actually equal to high
1683:18 - it means we can't
1683:20 - take 3 further down
1683:22 - so we return
1683:24 - we had left at line number 5
1683:26 - so we start
1683:28 - execution from line number 5
1683:30 - and at that moment
1683:32 - low, mid and higher were 3
1683:34 - 3, 4
1683:36 - so we will assign those values back to them
1683:38 - 3
1683:44 - so here you can see
1683:46 - for the right
1683:48 - this is single element array
1683:50 - which is the left
1683:52 - and this is the right
1683:54 - both are sorted
1683:56 - so we simply merge them to make it a bigger array
1683:58 - which is also sorted
1684:00 - so we will call the merge method
1684:06 - so this was the condition when we left
1684:08 - the sort and came for the merge
1684:12 - so it was 3, 3 and 4
1684:15 - so here you can see
1684:17 - we are not touching now this part because
1684:19 - this left part is already sorted
1684:22 - so therefore we have provided
1684:24 - this low, mid
1684:26 - and high because
1684:28 - now we will copy
1684:30 - the elements from the original array to the temporary array
1684:32 - from low to high
1684:34 - which is from 3 to
1684:36 - 4th index
1684:38 - so only these two elements will be copied here
1684:41 - we will see it quickly
1684:46 - 4 will be copied here
1684:55 - and 3 will be copied here
1684:57 - because we are simply assigning
1684:59 - the value at the ith index
1685:01 - of the original array to
1685:03 - temp array
1685:05 - and this for loop will end
1685:09 - so now our task is to
1685:13 - merge
1685:15 - these two sorted arrays
1685:17 - this is the left
1685:19 - and this is the right
1685:21 - via this temp array
1685:23 - so i will be traversing the left part
1685:27 - j will be traversing from mid plus 1
1685:29 - which is the left part
1685:31 - j will be traversing
1685:33 - from mid plus 1
1685:35 - which is the right part
1685:37 - and k which will start from
1685:39 - the low which is the index 3
1685:41 - because we don't have to touch this part now
1685:43 - we have to only sort
1685:45 - in this range
1685:47 - like this
1685:51 - so here i is 3
1685:53 - j is 4 because
1685:55 - j starts from mid plus 1
1685:57 - and k is 3
1685:59 - j will traverse to the left part
1686:01 - j will traverse to the right part
1686:03 - and k will help us in merging them
1686:05 - to the original array
1686:09 - so i will just remove this stuff
1686:13 - so here you can see
1686:15 - i is less than mid
1686:17 - and j is less than equal to i
1686:19 - so the while loop will execute
1686:23 - we compare
1686:25 - the ith index value
1686:27 - with the jth index value
1686:29 - which is 4 and 3
1686:31 - so 4 is not less than 3
1686:33 - so the else part will be executed
1686:35 - it means
1686:37 - we take 3
1686:39 - which is temp of j
1686:41 - and we put it into the original array
1686:43 - at its correct position
1686:45 - because we need to sort
1686:47 - this two smaller arrays
1686:49 - so 3 comes here
1686:51 - we have used this element
1686:57 - and we have filled this position
1686:59 - so we will increment j
1687:01 - j becomes 5
1687:03 - which is now out of the boundary
1687:05 - for this smaller
1687:07 - right array
1687:09 - we will increment k
1687:11 - k becomes 4
1687:15 - and here you can see
1687:17 - the right array is exhausted completely
1687:20 - so we will break from this while loop
1687:23 - and then we have provided this while loop
1687:25 - because we need to
1687:27 - still place the elements
1687:29 - of the left sub array
1687:31 - back into the original array
1687:33 - and as the left array is already sorted
1687:35 - we simply copy it back to the original array
1687:37 - via this assignment
1687:41 - so i is less than or equal to mid
1687:43 - we assign
1687:45 - temp of i2
1687:48 - kth index of array
1687:50 - 4 comes here
1687:52 - then we will increment i
1687:54 - and k
1687:56 - because we have used this element
1687:58 - i becomes 4
1688:02 - and we have filled this position
1688:04 - so we are incrementing k also
1688:09 - so this while loop will terminate now
1688:11 - because we are done with our task
1688:13 - of placing both the elements
1688:15 - into their correct position
1688:17 - within their range
1688:19 - and here you can see
1688:20 - initially it was 4 3
1688:22 - and now
1688:23 - it is 3 4 which is sorted
1688:25 - in this particular range
1688:28 - so we go back
1688:33 - and we had left at line number 6
1688:37 - so here you can see current status of array
1688:39 - is something like this
1688:41 - 2 5 9 3 4
1688:44 - so the left part is sorted
1688:46 - the right part is sorted
1688:48 - and these were the values
1688:50 - for low, mid and high when we left
1688:55 - so now this sort method will end
1688:57 - because there are no more execution steps
1688:59 - so now call will reach to the
1689:01 - previous sort method
1689:08 - we had left at line number 5
1689:10 - and at that moment
1689:12 - low, mid and high were 0 2 and 4
1689:14 - so this is the very starting
1689:16 - point where we left the first sort method
1689:22 - so this was the condition
1689:26 - so now here you can see
1689:28 - we have a larger
1689:30 - left array
1689:32 - and a larger right
1689:34 - array
1689:35 - and both are actually sorted
1689:37 - so 2 5 9
1689:39 - and 3 4
1689:41 - into their respective ranges
1689:43 - they are sorted
1689:44 - it means
1689:45 - we have 2 sorted arrays
1689:52 - and using this merge method
1689:54 - we will merge these 2 sorted arrays
1689:56 - in such a way
1689:58 - that the resultant array is also sorted
1690:00 - so here one thing
1690:02 - this step
1690:04 - at every point when we called
1690:06 - merge method we did
1690:08 - merging of 2 sorted arrays
1690:10 - so at the start we had only 1 1 element
1690:13 - then we got 2 elements
1690:15 - then it became 3
1690:17 - like this
1690:20 - and here it became 2
1690:22 - and now finally we are merging
1690:24 - a left array of 3 elements
1690:26 - and right array of 2 elements
1690:28 - so let's see this merge method now
1690:34 - we have updated the line number 6 here
1690:40 - so these are the values for low, mid and high
1690:43 - 0 to 4
1690:45 - and this is our current
1690:47 - original array
1690:49 - so now here you can see
1690:51 - from low to high
1690:53 - we copy all the elements
1690:55 - to the temporary array because
1690:57 - in the merge we actually do
1690:59 - the merging based on this
1691:01 - ranges
1691:03 - here low is 0 and high is 4
1691:05 - it means from 0 index to 4
1691:07 - we will copy every element
1691:09 - to the temporary
1691:11 - so we will quickly go over this for loop
1691:19 - 2 comes here
1691:27 - 5 comes here
1691:29 - 9 comes here
1691:31 - so these are simple assignments
1691:33 - 5 comes here
1691:35 - 9 comes here
1691:39 - so these are simple assignments
1691:59 - so now this for loop will end
1692:03 - so here why we are copying this element
1692:05 - into a temporary array
1692:07 - because this temporary array
1692:09 - is helping us
1692:11 - with this actual merge
1692:13 - which we are doing here
1692:15 - and it is helping us putting the elements
1692:17 - into their correct position in the original array
1692:19 - so here
1692:21 - the left array is from low
1692:23 - to mid
1692:25 - so 0 to 2
1692:27 - is the left array so this is the boundary
1692:29 - for left and right array
1692:31 - and mid plus 1
1692:33 - to high is the right array
1692:35 - so I will traverse the left array
1692:37 - and j will traverse the right array
1692:39 - which we already discussed in our
1692:41 - previous merge method
1692:45 - i is 0, j is mid plus 1
1692:47 - which is 3 and k
1692:49 - is 0 because we need to
1692:51 - merge this element
1692:53 - from the low to
1692:55 - high
1692:57 - so we are starting k with low
1692:59 - i, j comes here
1693:01 - and k comes here
1693:03 - and here you can see
1693:05 - this is the boundary
1693:07 - for left and the right
1693:09 - sorted arrays
1693:13 - so we will quickly go over this step
1693:15 - because we have already discussed what it does
1693:17 - i is less than
1693:19 - equal to mid and j is also less than equal to high
1693:23 - we compare the i-th
1693:25 - and j-th index
1693:27 - value which is 2
1693:29 - and 3
1693:31 - so 2 is less than equal to 3
1693:33 - so this condition comes out to be true
1693:35 - so we are simply
1693:37 - copying now 2
1693:39 - to k-th index because this is the smaller
1693:41 - value among these two
1693:45 - so it becomes 2
1693:47 - and here we have used
1693:49 - this value
1693:51 - so we will increment i
1693:53 - i will become 1
1693:58 - we have filled this position
1694:00 - so we will increment k
1694:07 - 1 is less than
1694:09 - 2
1694:11 - and 3 is less than 4
1694:13 - so both the condition comes out to be true
1694:17 - we will compare
1694:19 - i-th and j-th index values
1694:21 - which is 5 and 3
1694:23 - and here 5 is not less than 3
1694:25 - so this condition comes out to be false
1694:29 - we put the smaller value
1694:31 - at the k-th index of the original array
1694:33 - by this assignment
1694:35 - so 3 comes here
1694:40 - we have used this value
1694:42 - so we will increment j
1694:44 - j becomes 4
1694:48 - we have filled this value
1694:50 - so we will increment k
1694:53 - both these conditions are still true
1695:00 - we will compare 5 and 4
1695:04 - 5 is not less than 4
1695:06 - so this condition comes out to be false
1695:09 - so we will simply put
1695:11 - the j-th value at k-th index
1695:13 - of the original array
1695:15 - so 4 comes here
1695:19 - we have used this value
1695:21 - so we will increment j
1695:23 - j becomes 5
1695:27 - we have filled this position
1695:29 - so we will increment k
1695:34 - so from here you can see
1695:36 - now this condition is true but this condition is false
1695:38 - because 5 is not less than equal to 4
1695:42 - it means
1695:44 - the right array is exhausted
1695:46 - completely
1695:48 - so this value will terminate
1695:52 - and once the right array is exhausted
1695:54 - we know that
1695:56 - whatever the elements are left in the
1695:58 - left array
1696:00 - those are actually sorted
1696:02 - in their respective array
1696:04 - so we simply copy them 1 by 1
1696:06 - to the original array
1696:08 - using this small while loop
1696:10 - so i is less than equal to mid
1696:14 - we copy temp
1696:16 - value at i-th index into the original array
1696:18 - at k-th index
1696:20 - so we are simply assigning
1696:22 - 5 to this position
1696:27 - we have used this value
1696:29 - we will increment i
1696:31 - i becomes 2
1696:33 - we have filled this position
1696:35 - so we will increment k
1696:39 - and similarly we will place the last value
1696:42 - at its corresponding index
1696:47 - so 9 comes here
1696:50 - this value is used
1696:53 - i becomes 3
1696:56 - this is filled
1696:58 - so k becomes 5
1697:02 - so now this while loop will terminate because
1697:04 - value of i is 3
1697:06 - and 3 is not less than equal to 2
1697:11 - so this merge method will end
1697:13 - and here you can see
1697:15 - now finally we have sorted complete array
1697:17 - 2 3 4 5 9
1697:21 - so we go back to the method call
1697:23 - where we left
1697:25 - the sort and we call the merge
1697:31 - so execution point will reach here
1697:33 - at line number 6
1697:35 - and these values
1697:37 - will be pointing to
1697:39 - 0 2 4
1697:41 - and friends here you can see the original array
1697:44 - is now
1697:46 - properly sorted
1697:48 - 2 3 4 5 9
1697:50 - and there are no more lines
1697:52 - to be executed after that
1697:54 - so this sort method will end
1697:56 - so
1697:58 - all the method in the callstack has ended
1698:00 - and we have got our sorted array
1698:05 - so friends this was the complex
1698:07 - animation of this merge sort
1698:09 - which i depicted
1698:11 - based on this callstack
1698:13 - i hope you must have got some idea
1698:15 - of how it works internally
1698:18 - so friends i hope you must have liked this video
1698:20 - in case if you are new to my channel
1698:22 - then please subscribe to my channel
1698:24 - and click the bell icon
1698:26 - so that you never miss any update
1698:28 - thanks have a nice day
1698:33 - hello everyone
1698:35 - so in our previous video
1698:37 - we saw the demonstration
1698:39 - of the merge sort algorithm
1698:41 - via an animation
1698:43 - step by step
1698:45 - we will actually code the algorithm
1698:47 - and will test its working in the main method
1698:49 - so before we start
1698:51 - in case if you are new to my channel
1698:53 - then please subscribe to my channel
1698:55 - and click the bell icon so that you never miss any update
1698:59 - so here if you see
1699:01 - i have created one classes merge sort
1699:03 - which is having print array method
1699:05 - which we have already discussed
1699:07 - that it is used to print the
1699:09 - elements of an array
1699:11 - on the console
1699:13 - we will be creating
1699:15 - the method as sort
1699:21 - and as we discussed in our previous video
1699:23 - that this sort method
1699:25 - will take
1699:27 - the original array
1699:32 - one temporary array
1699:34 - which will basically help us in
1699:36 - sorting the original array
1699:38 - we will take the range
1699:41 - from low to high
1699:43 - so usually at the start
1699:45 - low is zero
1699:47 - and high is actually pointing to the last index
1699:49 - of the array
1699:51 - because we want to sort the complete array
1699:53 - now in this method
1699:55 - we provide a condition as
1700:00 - low should be less than high
1700:02 - now this is basically a base case
1700:06 - because this sort method
1700:08 - is actually recursive in nature
1700:10 - we will see later
1700:12 - so in this algorithm
1700:14 - we are actually dividing the array
1700:16 - into two parts
1700:18 - the left part and the right part
1700:20 - and we will keep on dividing them
1700:22 - till the left and the right part
1700:24 - contain only single element
1700:26 - because they can't be divided further
1700:28 - and when low
1700:30 - will be equal to high
1700:32 - it means we are having only single element
1700:34 - so we need to return from this method
1700:36 - because we can't divide the array further down
1700:38 - so when low is
1700:40 - less than high
1700:42 - now we will divide the array into two parts
1700:44 - so for that we need to
1700:46 - figure out the mid index
1700:48 - so here we
1700:50 - evaluate mid
1700:52 - so we use the formula low
1700:54 - plus
1701:00 - high minus low divided by two
1701:02 - so here you can see
1701:04 - these are nothing but indexes
1701:06 - we can use this formula
1701:08 - which will evaluate as the
1701:10 - mid index
1701:12 - so this formula also takes care of the
1701:14 - integer overflow condition
1701:18 - let's say our array is huge
1701:20 - which we have already discussed in our
1701:22 - previous video
1701:24 - if the array is very small
1701:26 - and it fits into the integer size
1701:28 - we can also use this formula
1701:30 - low plus high
1701:34 - divided by two
1701:36 - because here you can see
1701:38 - why we are using this formula is because
1701:40 - these are two integer values
1701:42 - and if we are doing addition
1701:44 - of it let's say low
1701:46 - and high are at any particular
1701:48 - value of integer
1701:50 - when we do sum of it
1701:52 - it crosses the integer limit
1701:54 - so therefore we will
1701:56 - get some garbage value
1701:58 - so therefore on the safe side we do this
1702:00 - we do minus
1702:02 - of both the ranges so that
1702:04 - the overall value is
1702:06 - still in the integer range
1702:08 - so after evaluating the mid
1702:10 - now as this is a recursive algorithm
1702:12 - we will call short
1702:14 - again
1702:16 - so we break it
1702:18 - down the array into two parts
1702:22 - and the range would be
1702:24 - for the left it will be
1702:26 - low to mid
1702:32 - and for the right
1702:34 - it will be from mid
1702:36 - plus one
1702:38 - to high
1702:40 - so here you can see this is a recursive algorithm
1702:42 - and it keeps on dividing
1702:44 - till there are only single
1702:46 - elements left
1702:48 - which can't be broken further down
1702:50 - so after getting to that point
1702:52 - as single elements we treat them
1702:54 - that they are already sorted
1702:56 - because there is only one element
1702:58 - from there on we try to merge them together
1703:00 - and this merging
1703:02 - keeps on going till the
1703:04 - final array is sorted
1703:06 - so in the merge method
1703:08 - we pass the array
1703:10 - we pass the
1703:12 - temporary array
1703:14 - we pass low
1703:16 - mid
1703:18 - and high
1703:20 - why we are passing all the three
1703:22 - values is because in the merge
1703:24 - based on
1703:26 - low to mid that will be our left
1703:28 - sorted sub array
1703:30 - from mid plus one
1703:32 - to high will be our right
1703:34 - sub array which is sorted
1703:36 - and we are simply merging two
1703:38 - sorted arrays to get a bigger
1703:40 - sorted array
1703:42 - so we will code the merge method now
1703:48 - so here you can see
1703:50 - we have this original array
1703:52 - and we have this temporary array
1703:54 - we know the range that it
1703:56 - goes from low to high
1703:58 - low to mid is our left
1704:00 - sub array, mid plus one to
1704:02 - high is our right sub array
1704:04 - so before merging the two sorted
1704:06 - arrays we can't
1704:08 - directly merge them in the original array
1704:10 - so in order to merge
1704:12 - the two sorted arrays
1704:14 - we take the help of this temporary array
1704:16 - what we do is
1704:18 - we provide a for loop
1704:24 - which starts from low
1704:28 - and goes till high index
1704:32 - so what we are doing is now we are simply copying
1704:34 - the elements of the original array
1704:36 - into the temporary array
1704:38 - so this is what we discussed in our previous
1704:40 - video in greater detail
1704:42 - so here we do temp of i
1704:48 - array of i
1704:50 - now we have got our range
1704:52 - from low to high
1704:54 - in our temporary array
1704:56 - and we also know that
1704:58 - from low to mid
1705:00 - we have the left sub array
1705:02 - which is sorted
1705:04 - from mid plus one to high
1705:06 - we have a right sub array which is sorted
1705:08 - and now we need to merge
1705:10 - these two sorted arrays such that
1705:12 - the resultant array is also sorted
1705:14 - so in one of our previous videos
1705:16 - we saw that how we can merge
1705:18 - two sorted arrays so we will apply
1705:20 - the same algorithm here
1705:22 - so for more understanding you can watch
1705:24 - that video
1705:26 - so here we will create now
1705:28 - three variables
1705:30 - i
1705:32 - j
1705:34 - and k
1705:36 - so here
1705:38 - i will traverse
1705:46 - left sorted sub array
1705:48 - j will traverse
1705:56 - right sorted sub array
1705:58 - and k
1706:00 - will merge
1706:02 - both arrays
1706:04 - into original array
1706:08 - which is
1706:10 - this
1706:12 - so if i is traversing
1706:14 - the left sorted sub array
1706:16 - we know that it should start from the low
1706:18 - because from low to mid
1706:20 - we have the left part
1706:22 - and j
1706:24 - should start from
1706:26 - mid
1706:28 - plus one
1706:30 - because we know that the right
1706:32 - sorted sub array is from mid
1706:34 - plus one to high
1706:36 - and we also know that as we are
1706:38 - merging the two sorted arrays
1706:40 - within a range
1706:42 - from low to high
1706:44 - k should also start from low
1706:46 - and it will go till high
1706:48 - so after creating these three pointers
1706:50 - we will now compare
1706:52 - each and every element
1706:54 - of the left and the right sub array
1706:56 - and whichever element is small
1706:58 - we try to fit in that element
1707:00 - into the original array
1707:02 - at kth index
1707:04 - so this is the basic idea behind
1707:06 - merging two sorted arrays
1707:08 - such that
1707:10 - the resultant array is also sorted
1707:12 - so we have provided while loop
1707:18 - and the condition we provide is
1707:20 - i
1707:22 - should go till mid
1707:24 - and
1707:26 - j
1707:28 - should go till high
1707:30 - and if any of this condition breaks
1707:32 - the while loop will terminate
1707:34 - so here
1707:36 - what this condition suggests is
1707:38 - when we are merging
1707:40 - the two sorted arrays
1707:42 - there will be a point where either
1707:44 - left array
1707:46 - will get exhausted
1707:48 - or the right array gets exhausted
1707:50 - so whichever gets exhausted
1707:52 - this condition will break
1707:54 - respectively and we will
1707:56 - come out of the while loop
1707:58 - so inside this while loop
1708:00 - now we will try to compare
1708:02 - the left array's
1708:04 - ith index value
1708:06 - with right array's
1708:08 - jth index value
1708:10 - and as these two arrays are already sorted
1708:12 - that's why we are doing the comparison
1708:14 - with the respective
1708:16 - indexes
1708:18 - so we do
1708:20 - if temp of i
1708:22 - is less than
1708:24 - equal to
1708:26 - temp of j
1708:28 - so here it means
1708:30 - whichever value is present at the
1708:32 - ith index
1708:34 - left sub array value is small
1708:36 - so at the original array
1708:38 - at kth index
1708:40 - we will put
1708:42 - temp of i
1708:44 - and after placing the temp of i
1708:46 - we know that left array is
1708:48 - one element is at its correct position
1708:50 - so we will increment i
1708:54 - and else
1708:56 - we do the other way round
1708:58 - array of
1709:00 - k
1709:04 - temp of j
1709:06 - and we will increment
1709:08 - j by one position
1709:10 - because we have taken up
1709:12 - one element from the right sub array
1709:14 - and here you can see
1709:16 - we are actually filling
1709:18 - the original array
1709:20 - at kth index
1709:22 - so after this if else block
1709:24 - as kth index is filled up
1709:26 - so we also increment k by
1709:28 - one position to fill in
1709:30 - up the next element
1709:32 - so this value will again
1709:34 - go on like this
1709:36 - till any of the array is exhausted
1709:38 - so here you can see
1709:40 - that now there are two cases
1709:42 - which can arise
1709:44 - either the left array gets exhausted
1709:46 - or the right array gets exhausted
1709:48 - so here when the left
1709:50 - array gets exhausted
1709:52 - all the elements of the
1709:54 - right sub array we don't copy it back to the original array
1709:56 - because those elements
1709:58 - are already at their correct position
1710:00 - in the original array because
1710:02 - when we are copying the elements
1710:04 - from the original array
1710:06 - to temporary array and as
1710:08 - both the arrays are sorted
1710:10 - so the elements of the right sub array
1710:12 - which are left over
1710:14 - will usually be at their
1710:16 - correct position in the original array
1710:18 - so these two cases we discussed
1710:20 - in greater detail in our previous video
1710:22 - now we only need
1710:24 - to keep in mind is if the right array
1710:26 - gets exhausted first
1710:28 - then we need to write some logic
1710:30 - to put in the left
1710:32 - array's left over elements
1710:34 - into the original array
1710:36 - so for that
1710:38 - we provide a while loop
1710:42 - and the condition is exactly the same
1710:46 - because this i
1710:48 - is pointing to an index
1710:50 - from where the left over elements are
1710:52 - starting and we can simply copy
1710:54 - it back to the original array
1710:56 - so what we do is
1711:00 - we can simply copy it something like this
1711:02 - temp
1711:04 - of i
1711:06 - k++
1711:10 - and i++
1711:12 - so it is a simple loop
1711:14 - which is copying the elements
1711:16 - at i at index of temporary array
1711:18 - into the original array at kth index
1711:20 - and after copying it we are incrementing
1711:22 - both the pointers
1711:24 - so once this method will end
1711:26 - the smaller left and right
1711:28 - sub array will be sorted
1711:30 - and then as it is a recursive
1711:32 - algorithm working like this
1711:34 - so it keeps on merging
1711:36 - the left and the right sub array
1711:38 - till the point all the elements
1711:40 - are sorted
1711:42 - in ascending order
1711:44 - so now let's test its working in the main
1711:46 - method
1711:48 - so here we have created this array
1711:50 - 95243
1711:53 - here we will call
1711:56 - the sort method
1711:58 - we will pass the array
1712:00 - which is our original array
1712:02 - and we need to pass a
1712:04 - temporary array
1712:06 - so which is of length
1712:08 - same as our original array
1712:10 - so we will do new int
1712:16 - array.length
1712:18 - we pass the low as 0
1712:20 - and high as
1712:22 - array.length
1712:24 - minus 1
1712:26 - because at the start
1712:28 - low is at the zeroth index
1712:30 - and high is at the last index
1712:32 - which is array.length minus 1
1712:34 - and after doing the sort
1712:36 - we will print the array
1712:38 - and we will see whether
1712:40 - these 5 elements are sorted or not
1712:42 - if i run the main method
1712:44 - so here we can see it sorted as
1712:46 - 23459
1712:48 - now let's suppose if i put one value here as
1712:50 - minus 1
1712:52 - if i call it again
1712:56 - so here we can see it
1712:58 - it sorted in ascending order
1713:00 - so friend this is all about
1713:02 - the merge sort algorithm
1713:04 - so friend this is all about
1713:06 - the merge sort algorithm
1713:08 - so friend this is all about
1713:10 - the merge sort algorithm
1713:12 - so friend i hope you
1713:14 - must have liked this video
1713:16 - in case if you are new to my channel
1713:18 - then please subscribe to my channel
1713:20 - and click the bell icon so that you
1713:22 - never miss any update
1713:24 - thanks have a nice day
1713:26 - hello everyone
1713:28 - so in this video we are going to
1713:30 - discuss that how we can sort an array
1713:32 - having zeros, ones
1713:34 - and twos
1713:36 - so we need to sort an array in such a way that
1713:38 - zeros are at the start
1713:40 - ones in the middle
1713:42 - and twos at the end
1713:44 - so this problem is also known as
1713:46 - Dutch national flag problem because each number
1713:48 - basically corresponds to one of
1713:50 - the colors in the flag
1713:52 - so for example zeros
1713:54 - let's say given as red
1713:56 - one to white and two to blue
1713:58 - so when we sort an array
1714:00 - having zeros, ones and twos
1714:02 - zeros are at
1714:04 - the start, ones are at the middle
1714:06 - and two are at the end
1714:08 - so therefore this problem is also
1714:10 - known as Dutch national flag
1714:12 - problem
1714:14 - so in this problem we are given
1714:16 - an array containing only zeros
1714:18 - ones and twos
1714:20 - so let's say if we take this example
1714:22 - we have zero, one
1714:24 - one, two, zero, one
1714:26 - two, so these are
1714:28 - currently random numbers
1714:30 - and when we actually sort them
1714:32 - we get zero
1714:34 - at the start
1714:37 - one in the middle
1714:39 - and two at the end
1714:41 - so it looks like Dutch national flag
1714:43 - like this
1714:45 - now our task is to sort the array in
1714:47 - O of n
1714:49 - time complexity
1714:51 - and O of 1 space complexity
1714:53 - because if we sort this array
1714:55 - using the language specific sort method
1714:57 - then the time complexity
1714:59 - will be n log n
1715:03 - but as we know that there are only three types
1715:05 - of numbers, zeros, ones and twos
1715:07 - we can leverage this idea
1715:09 - and achieve O of n
1715:11 - time complexity
1715:13 - so let's see how
1715:15 - so friends before we start the discussion
1715:17 - in case if you are new to my channel
1715:19 - then please subscribe to my channel
1715:21 - and click the bell icon
1715:23 - so that you never miss any update
1715:25 - so friends here you can see
1715:27 - that this is the piece of code
1715:29 - which actually does the
1715:31 - sorting in O of n time
1715:33 - here we have one while loop
1715:35 - which does all the trick
1715:37 - so in this video
1715:39 - in order to demonstrate
1715:41 - at a high level that how this
1715:43 - algorithm works, I have just mentioned
1715:45 - the code here
1715:47 - in our next video we will see the demonstration
1715:49 - of this code step by step
1715:51 - so let's see at a high level how
1715:53 - this algorithm will work
1715:55 - now for example we are given an array
1715:57 - of seven elements
1715:59 - from index zero to six
1716:01 - and the numbers are
1716:03 - zeros, ones and twos
1716:05 - so two zero, two two, zero
1716:07 - one one
1716:09 - now we need to sort this array in such a way that
1716:11 - zeros are
1716:13 - at the start
1716:15 - ones in the middle
1716:17 - and twos at the end
1716:19 - so this is start
1716:21 - this is middle and this is
1716:23 - end
1716:25 - so friends the basic idea behind this algorithm
1716:27 - is we actually use three
1716:29 - pointers
1716:33 - which is i
1716:35 - j and k
1716:37 - so here in this
1716:39 - algorithm each pointer
1716:41 - has a special task to perform
1716:43 - so at the start
1716:45 - i starts from zero, j starts from
1716:47 - zero and k starts from the last
1716:49 - index
1716:51 - so i starts from zero
1716:53 - j starts from zero
1716:55 - and k starts from the
1716:57 - last index
1716:59 - now here you can see that after that we are providing
1717:01 - a while loop where the condition
1717:03 - we are providing is i should be less than
1717:05 - equal to k
1717:07 - so here i is our main
1717:09 - pointer which will actually traverse the array
1717:11 - in this
1717:13 - direction
1717:15 - and when it traverses in this direction, k
1717:17 - also traverses in this direction
1717:19 - and this loop will go till
1717:21 - i is less than
1717:23 - or equal to k
1717:25 - once i crosses k
1717:27 - this while loop will terminate
1717:29 - and our array will be sorted
1717:31 - in zeros, ones and twos
1717:33 - format
1717:35 - so here the i is our
1717:37 - main iterator of the array
1717:39 - now its main job is
1717:41 - here we can see
1717:43 - at the start we have to provide zeros
1717:45 - in the middle, ones and at
1717:47 - the end twos
1717:49 - so whenever i
1717:51 - will encounter zero
1717:53 - here it is encountering zero
1717:55 - so we know that we have to throw zero
1717:57 - to the start
1717:59 - so basically when zero will be encountered
1718:01 - it will be
1718:03 - thrown to j
1718:05 - and whatever will be j will hold
1718:07 - it will come at the place of i
1718:09 - so zeros
1718:11 - will be at the start
1718:13 - and j will help us
1718:15 - in achieving that
1718:17 - when two will be encountered
1718:19 - i will throw
1718:21 - two to end
1718:23 - and to the end we have k
1718:25 - so it will throw it to the
1718:27 - k
1718:29 - and take its value to the i-th index
1718:31 - so this will
1718:33 - achieve this part
1718:35 - when i will encounter one it will do
1718:37 - nothing, it will simply traverse
1718:39 - ahead because one
1718:41 - is already in the middle
1718:43 - so this is the crux of the algorithm
1718:45 - that we have three pointers
1718:47 - and three numbers
1718:49 - when i will encounter zero
1718:51 - it will swap that number with j
1718:53 - when i will
1718:55 - encounter two it will swap it with
1718:57 - k and when i
1718:59 - will encounter one it
1719:01 - will just move ahead and keep one
1719:03 - at that position only
1719:05 - so here you can see
1719:07 - at the start the numbers are in unsorted
1719:09 - form so we usually
1719:11 - draw four regions
1719:13 - like this
1719:15 - one region is for zeros
1719:17 - other region is for ones
1719:19 - and the third region is for
1719:21 - twos and one region
1719:23 - is just to mark
1719:25 - which are the unknown elements
1719:27 - till now or
1719:29 - unvisited elements till now
1719:31 - so at the start
1719:33 - all the elements are unknown
1719:35 - so they are
1719:37 - marked as unknown
1719:39 - and their range is from
1719:41 - i to k
1719:43 - so from i
1719:45 - to k so every number is
1719:47 - unknown so every number
1719:49 - has tick
1719:51 - now slowly when i will move
1719:53 - ahead it will try to encounter
1719:55 - these numbers and try to
1719:57 - explore them so these
1719:59 - tick will come in these three
1720:01 - regions marking
1720:03 - for the zeros, ones
1720:05 - and twos
1720:07 - at the start from i to k all numbers are
1720:09 - unknown
1720:11 - from start which is the zeroth index
1720:13 - to j-1
1720:15 - so j is actually pointing
1720:17 - to zero index if we do
1720:19 - minus one will reach here
1720:21 - so currently there is no such
1720:23 - area or range
1720:25 - from j to i-1
1720:29 - j to i-1
1720:31 - which is also unknown area
1720:33 - from k plus 1 to
1720:35 - end which is the last index
1720:37 - so if we do k plus 1 we will go out of this
1720:39 - so this is also the unknown area
1720:41 - so at the start all the elements
1720:43 - are unknown and all the regions
1720:45 - are unfilled now we will
1720:47 - slowly move ahead and try to fill
1720:49 - each and every region
1720:51 - so let's see how we can remove this
1720:53 - unknown elements and fill
1720:55 - the zeros, ones and
1720:57 - twos and one thing
1720:59 - to remember zeros,
1721:01 - ones and twos will be filled in a
1721:03 - proper order
1721:05 - zeros at the start, ones in the middle
1721:07 - and twos at the end so we will see
1721:09 - it later here
1721:11 - so here you can see
1721:13 - at the start, array of i
1721:15 - is two
1721:17 - so this condition is false, this condition
1721:19 - is also false
1721:21 - and this condition is true because array of i
1721:23 - is equal to two
1721:25 - so now what i will do, here we saw
1721:27 - that whenever i will encounter
1721:29 - two, it will simply swap
1721:31 - two with the value
1721:33 - which k is holding
1721:35 - or index k is holding
1721:37 - when we will do swap
1721:39 - for two and one
1721:41 - which is being referred by i and k
1721:43 - in the swap method
1721:45 - we will simply swap them
1721:47 - so one will come here and two will come here
1721:49 - so here our
1721:51 - one task is done successfully that we have
1721:53 - placed two
1721:55 - at its proper position here
1721:59 - so one two is at its proper
1722:01 - position and we know that when
1722:03 - this while loop will run
1722:05 - one element has become known now
1722:07 - and which is that element which
1722:09 - has become known is
1722:11 - this, that two is at
1722:13 - its correct position
1722:15 - also friends as we have filled this position
1722:17 - we will move k to this direction
1722:19 - because for the other
1722:21 - two which is here for example
1722:23 - it should come here right
1722:25 - so k will move
1722:27 - to this position
1722:29 - and it keeps on moving in this position
1722:31 - as many as twos are encountered
1722:33 - because we need to swap
1722:35 - two with the value of the
1722:37 - kth index
1722:39 - so we do k minus minus
1722:41 - so k comes here
1722:43 - now here you can see
1722:45 - as k is here
1722:47 - we know that from k plus one
1722:49 - to the last index
1722:51 - we have two
1722:53 - so here we will see this range at every
1722:55 - moment of this while loop
1722:57 - and we will figure out
1722:59 - where this take will go
1723:01 - so if you see here
1723:03 - k plus one
1723:05 - k plus one is this index
1723:07 - to the last
1723:09 - to the end which is the
1723:11 - same index
1723:13 - we have to mark
1723:15 - twos because one number is known
1723:17 - so this take will go away
1723:19 - and this take will come here
1723:21 - which says that
1723:23 - from i to k
1723:25 - still the numbers are unknown and
1723:27 - only one number was known which is placed
1723:29 - at its correct position
1723:31 - we have provided take here
1723:33 - now here one thing to
1723:35 - notice when we do this swap
1723:37 - two will come here
1723:39 - and at this position
1723:41 - there could be zero, one or two
1723:43 - any of the three number
1723:45 - so we are not sure which number is
1723:47 - actually getting swapped here
1723:49 - so i will be
1723:51 - at the same position only
1723:53 - we will only move k
1723:55 - so this is the one difference
1723:57 - so in the next iteration of while loop
1723:59 - here you can see
1724:01 - now this condition will be false
1724:03 - and this condition will be true
1724:05 - because area of i is one
1724:07 - so we discussed
1724:09 - when we encounter one we will simply
1724:11 - move ahead because
1724:13 - ones will be in the middle
1724:15 - so we will simply increment i
1724:19 - so i will come here
1724:21 - and as i will come here
1724:23 - here you can see
1724:25 - that unknown is from
1724:27 - i to k which is
1724:29 - this portion now
1724:31 - because this number is known
1724:33 - from start to j-1 we have zeros
1724:35 - so j is still here
1724:37 - j-1 is out of this
1724:39 - area
1724:41 - from j to i-1 we have to
1724:43 - mark 1
1724:45 - so j to i-1
1724:47 - which is this part
1724:49 - we have to mark 1
1724:51 - so this element is known
1724:53 - so it will go away
1724:55 - and mark will come here because we have found
1724:57 - 1
1724:59 - and we have placed at its correct position
1725:01 - in this range
1725:03 - so these ranges are important
1725:05 - it will help us in
1725:07 - traversing the array and also
1725:09 - relocating
1725:11 - the values of zeros, ones and twos
1725:13 - moving ahead
1725:17 - now here you can see
1725:19 - array of i is 0
1725:21 - so this condition will come out to be true
1725:23 - so here we have discussed
1725:25 - that whenever i will encounter 0
1725:27 - it will throw it to j and take its value
1725:29 - so here
1725:31 - 0 and 1 will be
1725:33 - swiped by this method
1725:35 - 0 comes here
1725:37 - 1 comes here
1725:39 - so here you can see now 1 has actually
1725:41 - changed its position
1725:43 - initially 1 was here we have
1725:45 - marked here now 1 has actually
1725:47 - changed the position
1725:49 - so here what we will do
1725:51 - we will increment i and j both
1725:53 - so why we are incrementing i
1725:55 - because here we saw that
1725:57 - whenever we encounter i as 1
1725:59 - we simply move ahead
1726:01 - and if you see this range
1726:03 - 1 is always
1726:05 - 1 step behind the i
1726:07 - so range is from j to i-1
1726:09 - so whenever i will point to 1
1726:11 - it will simply move ahead
1726:13 - so this is the range
1726:15 - that 1 is
1726:17 - behind the i
1726:19 - so we will do i++
1726:21 - and j++
1726:23 - so why we are doing j++ because we have
1726:25 - placed 0 at its correct
1726:27 - position now another 0 should
1726:29 - come here so we are doing j++
1726:31 - so j comes here
1726:33 - and now if you
1726:35 - again look into this
1726:37 - ranges from i to k
1726:39 - these are
1726:41 - still unknown
1726:43 - and 1 number is known which we placed here
1726:45 - and we took 1 and placed here
1726:47 - so from start to
1726:49 - j-1
1726:51 - start to j-1
1726:53 - we have zeros
1726:55 - so 1 tick will come here because
1726:57 - we have identified 1 0
1726:59 - so this
1727:01 - will go away it will come here
1727:03 - and also here you can see
1727:05 - that from j to i-1
1727:07 - j to
1727:09 - i-1
1727:11 - this portion is actually our 1
1727:13 - so now this tick will go away
1727:15 - and it will come here
1727:17 - because we have swabbed
1727:19 - 0 and 1 so 0
1727:21 - is now at the start
1727:23 - 1 is in the middle and 2
1727:25 - is at the end and in the middle
1727:27 - we have unknown elements
1727:29 - so this is how this algorithm works
1727:31 - let's see further iterations
1727:35 - now array of i is 2
1727:37 - so this condition comes out to be true
1727:39 - so we know that what we need to do
1727:41 - we need to simply
1727:43 - swap this value with k
1727:45 - so 1 will come here
1727:47 - and 2 will go there
1727:49 - 1 comes here, 2 goes there
1727:51 - and then we will decrement
1727:53 - k because
1727:55 - the next 2 value should come here
1727:57 - so this position is
1727:59 - filled and 1 more number
1728:01 - is now known
1728:03 - so if we mark
1728:05 - again from k plus 1
1728:07 - to end we will mark 2
1728:09 - so k plus 1
1728:11 - this range will be marked
1728:13 - as true
1728:15 - so this tick will go away
1728:17 - and there will be 1 tick here
1728:19 - in the middle we have unknowns
1728:21 - also friend one more thing
1728:23 - that here why we are moving i
1728:25 - when array of i is 0
1728:27 - and we are not moving
1728:29 - i when array of i is 2
1728:31 - because when we are swapping it with
1728:33 - array of k
1728:35 - we don't know what value it will be
1728:37 - 0, 1, 2, any value
1728:39 - but when we are swapping it with array of j
1728:43 - which is here
1728:45 - we are sure that
1728:47 - there will be only 1 single value
1728:49 - 1
1728:51 - because we have started traversing i from
1728:53 - the middle and whenever we are encountering
1728:55 - 2 we are throwing it here
1728:57 - and whenever we are encountering 1
1728:59 - we are simply moving i ahead
1729:01 - so we are leaving 1 behind
1729:03 - so that will be the only value which will
1729:05 - it will be swiped
1729:07 - so therefore it makes no sense to keep i
1729:09 - in the same place
1729:11 - so we move i also with it
1729:13 - but here we don't know whether it is 0
1729:15 - 1 or 2 which is being
1729:17 - swiped
1729:19 - so therefore we are keeping i at the same place
1729:23 - so now in this iteration array
1729:25 - of i is 1
1729:27 - which is this condition
1729:29 - so we simply move i
1729:31 - i comes here
1729:33 - this element is known
1729:35 - because 1 should be in the middle
1729:37 - so this
1729:39 - thing will go away
1729:41 - because unknown is from i to k
1729:43 - and i to k is this range
1729:45 - this element is known
1729:47 - we have to put this element here
1729:49 - from j to i-1
1729:51 - j to i-1
1729:53 - which is these 2 numbers
1729:55 - so 1 tick comes here
1729:57 - now in the next iteration
1730:01 - array of i is 2
1730:03 - so what we do is we simply
1730:05 - swap and move k
1730:07 - in this direction
1730:09 - so we are simply swapping
1730:11 - 0 and 2
1730:13 - so 0 comes here and 2 comes here
1730:15 - and then we are decrementing k
1730:17 - because we have filled
1730:19 - 2 at its proper position
1730:21 - so we are moving k here
1730:23 - so k comes here
1730:25 - this element is known
1730:27 - it will go away
1730:29 - and it will come here
1730:31 - because from k plus 1 to end
1730:33 - we have to provide 2
1730:35 - so these are 2s
1730:37 - k plus 1 to end
1730:39 - now only 1
1730:41 - element is unknown
1730:43 - so in the next iteration
1730:45 - i is still equal to k
1730:47 - and array of i is 0
1730:49 - so we will simply swap this 0
1730:51 - with the jth element
1730:53 - here
1730:55 - so 0 comes here
1730:57 - 1 comes here
1730:59 - this is the proper place of 0
1731:01 - so we increment j
1731:03 - and as we have placed
1731:05 - 1 here we have also seen
1731:07 - that whenever we encounter 1
1731:09 - at the i-th position we simply move ahead
1731:11 - so we are also moving
1731:13 - i ahead
1731:15 - so i comes here
1731:17 - and j comes here
1731:19 - so now every element is known
1731:21 - so this tick will go away
1731:27 - and where this tick will come
1731:29 - it will come here because
1731:31 - we have just placed 0 at its correct position
1731:33 - so we will mark this as true
1731:35 - and as we have swapped
1731:37 - 0
1731:39 - and 1
1731:41 - so this tick will go away
1731:43 - and it will come here
1731:45 - so it would look something like this
1731:48 - so now if we match the range
1731:50 - we will see that unknown are from i to k
1731:52 - so i has actually
1731:54 - crossed the boundaries so every
1731:56 - element is known now
1731:58 - so its blank
1732:02 - from start to j-1
1732:04 - this is start
1732:06 - this is j
1732:08 - minus 1 will reach here
1732:10 - so this is actually our zeros
1732:12 - which is being
1732:14 - marked properly
1732:16 - from j to i-1
1732:18 - we have marked once
1732:20 - so j
1732:22 - to i
1732:24 - minus 1
1732:26 - so this
1732:28 - is the place for once
1732:30 - we have marked it properly
1732:32 - from k plus 1 to end
1732:34 - we have marked 2
1732:36 - so k is here, k plus 1 is
1732:38 - this
1732:39 - to end
1732:40 - we have all the 2's
1732:42 - which is what we have ticked here
1732:45 - so friend this is how this algorithm works
1732:47 - basically
1732:49 - we need to keep the track of 3 pointers
1732:52 - i is actually doing main work
1732:54 - it is encountering different values
1732:56 - at different positions
1732:58 - when it encounters 0
1733:00 - it swaps it with j
1733:02 - when it encounters 2
1733:04 - it swaps it with k
1733:06 - and when it encounters 1
1733:08 - it does nothing it simply moves ahead
1733:10 - so you need to go through this algorithm
1733:12 - few times
1733:13 - to understand how these regions are getting plotted
1733:16 - and how these 0's, 1's and 2's are actually
1733:19 - segregated that way
1733:21 - in our next video
1733:23 - we will actually see the detailed demonstration
1733:25 - of this algorithm step by step
1733:27 - but to demonstrate this in high level
1733:30 - i will just use these regions
1733:32 - so that when we encounter this
1733:34 - algorithm step by step
1733:36 - we can directly
1733:38 - come to know that which element is here
1733:41 - so friends i hope you must have liked this video
1733:44 - in case if you are new to my channel
1733:46 - then please subscribe to my channel
1733:48 - and click the bell icon so that you never miss any update
1733:51 - thanks have a nice day
1733:54 - hello everyone
1733:56 - so in this video we are going to discuss
1733:58 - the algorithm step by step
1734:00 - that how we can sort an array
1734:02 - of 0's, 1's and 2's
1734:04 - in our previous video
1734:06 - we saw at a very high level
1734:08 - that how this algorithm works
1734:10 - in order to understand this video
1734:12 - you need to watch that video first
1734:15 - so lets see the demonstration of this algorithm step by step
1734:21 - so friends before we start
1734:23 - in case if you are new to my channel
1734:25 - then please subscribe to my channel
1734:27 - and click the bell icon so that you never miss any update
1734:30 - here you can see that we are given with a algorithm
1734:33 - where the method name is 3 number sort
1734:36 - which takes in an array
1734:38 - now this array consists of
1734:40 - 0's, 1's and 2's
1734:42 - and we need to sort that array
1734:44 - in a linear time
1734:46 - so lets see the demonstration of this algorithm step by step
1734:51 - now lets suppose we are given with this array
1734:53 - having 7 elements
1734:55 - 2, 0, 2, 2, 0, 1, 1
1734:58 - and we need to sort this array
1735:00 - in such a way that 0's are at the start
1735:02 - 1's in the middle
1735:04 - and 2's at the end
1735:06 - so when we will call 3 number sort method
1735:09 - we will pass in the array
1735:11 - so friends in our previous video we discussed
1735:14 - that we can solve this problem
1735:16 - using 3 pointers
1735:21 - i, j and k
1735:25 - we also discussed that i is the main iterator
1735:28 - which will traverse from 0 to
1735:30 - a value less than or equal to k
1735:34 - and we also discussed that how this 3 pointers help us in
1735:37 - sorting the array
1735:40 - so at the very beginning i starts from 0
1735:46 - j also starts from 0
1735:51 - and k starts from the last index
1735:55 - which is 6th index
1735:59 - now as we need to sort this array in linear time
1736:02 - we have provided a while loop
1736:04 - and the condition in while loop is
1736:06 - i should be less than or equal to k
1736:08 - so here i will travel in this direction
1736:12 - k will travel in this direction
1736:15 - and when i will cross k
1736:17 - this while loop will terminate
1736:19 - now at the start value of i is 0
1736:22 - and k is 6
1736:24 - so this condition comes out to be true
1736:33 - so inside this while loop
1736:35 - we have provided 3 conditions
1736:37 - array of i
1736:39 - which is the value at ith index
1736:41 - it can be equal to 0
1736:43 - it can be equal to 1
1736:45 - or it can be equal to 2
1736:47 - so any of this condition will come out to be true
1736:50 - now here what we do is
1736:53 - when i will encounter 0
1736:58 - it will throw it to j
1737:01 - and take ith value
1737:04 - so j is mostly behind i
1737:06 - and when we encounter 0
1737:08 - we know that 0 should be at the beginning
1737:10 - because we need to sort the array
1737:12 - in such a way that zeros are at the beginning
1737:14 - so it is the responsibility of i and j
1737:17 - to put 0 at the beginning
1737:20 - so whenever i will encounter 0
1737:23 - it will throw it to j and take ith value
1737:27 - whenever i will encounter 2
1737:31 - it will throw it to k
1737:34 - and take ith value
1737:36 - so here k is at the last index
1737:38 - and we know that we need to place 2 at the end
1737:41 - so i will throw 2
1737:43 - to k and take ith value
1737:46 - and whenever i will encounter 1
1737:49 - it will do nothing it will simply move
1737:51 - one step ahead because
1737:53 - the 1 is already in the middle
1737:56 - so j keeps the track of
1737:58 - placing 0 at the beginning
1738:01 - k keeps the track of
1738:03 - placing 2 at the end
1738:05 - and i whenever encounter 1
1738:07 - simply move ahead and do nothing
1738:10 - so here at the start array of i
1738:13 - is 2
1738:16 - so therefore this condition comes out to be false
1738:20 - this condition also comes out to be false
1738:24 - and this condition comes out to be true
1738:28 - so we know that whenever i will encounter 2
1738:31 - it will simply throw the 2
1738:33 - to k and take ith value
1738:35 - it means we are swapping the value
1738:37 - with the kth index
1738:40 - so we will call swap method
1738:42 - we will pass the positions of i and k
1738:45 - and here it will swap them
1738:49 - so i will be demonstrating swap directly
1738:51 - this we have seen many times in our previous videos
1738:55 - so when we will swap i and k
1738:58 - 1 will come here
1739:00 - and 2 will go there
1739:02 - it means we have swapped
1739:04 - value with ith index with value with kth index
1739:06 - we have thrown 2 at the end
1739:11 - and after placing 2 at the end
1739:13 - we know that this 2
1739:15 - is actually at its correct position
1739:19 - so now we decrement k
1739:21 - because the next 2 will come here
1739:24 - so we do k minus minus
1739:26 - so k becomes 5
1739:30 - moving ahead
1739:32 - i is still less than equal to k
1739:36 - now array of i is 1
1739:38 - so this condition comes out to be false
1739:42 - this condition comes out to be true
1739:45 - and whenever we encounter 1
1739:47 - we do nothing, we simply move i
1739:49 - by 1 position because
1739:51 - we don't have to touch 1
1739:53 - it's already in the middle range
1739:56 - so we move i 1 position ahead
1739:58 - i becomes 1
1740:02 - moving ahead
1740:05 - i is still less than equal to k
1740:11 - now here you can see array of i is 0
1740:13 - so this condition comes out to be true
1740:17 - so when array of i encounter 0
1740:20 - or i encounter 0
1740:22 - it will simply swap it with j
1740:24 - and take its value
1740:28 - so when we will swap it with j
1740:32 - 0 will come here and 1 will come here
1740:36 - so here now 0 is at its correct position
1740:41 - because we need to arrange 0 at the start
1740:44 - so after placing 0 at its correct position
1740:47 - the next 0 should come here
1740:51 - so what we do is
1740:53 - we increment j and i both
1740:56 - and as i is pointing to 1
1740:58 - we know that we need to simply traverse
1741:00 - i also by 1 position
1741:03 - so we do i plus plus
1741:05 - i becomes 2
1741:09 - and we do j plus plus
1741:11 - j becomes 1
1741:13 - so now next 0 will come here
1741:18 - i is still less than equal to k
1741:21 - now array of i is 2
1741:23 - so this condition comes out to be false
1741:27 - this condition also comes out to be false
1741:31 - now this condition comes out to be true
1741:35 - so it means we need to throw this 2 to k
1741:37 - and take its value
1741:40 - so when we will perform swap
1741:43 - 1 will come here
1741:45 - and 2 will go there
1741:48 - and now 2 is at its correct position here
1741:52 - so we will decrement k
1741:55 - so k becomes 4
1741:58 - also friends here who can see that
1742:00 - when we are swapping with k
1742:02 - we are only decrementing k
1742:04 - we are not moving i ahead
1742:06 - because when we are swapping it with k
1742:09 - whatever value is here
1742:11 - there could be 3 possibilities
1742:13 - it can be 0
1742:15 - it can be 1
1742:16 - or it can be 2
1742:18 - so we are not sure that what value
1742:20 - we will encounter here
1742:22 - so therefore we are keeping i at the same position
1742:25 - but when we are swapping it with j
1742:28 - we know that there could be 2 possibilities
1742:30 - 0 or 1
1742:32 - so when we encounter 1
1742:33 - we know that we have to move i
1742:35 - by 1 step
1742:36 - but when we encounter 0
1742:38 - it means that i and j are pointing to the same index
1742:42 - and when we will do swap
1742:44 - 0 will come at same position only
1742:46 - and then we will move both the pointers together ahead
1742:50 - so the maximum time the value which we swap
1742:52 - between i and j is 1
1742:55 - so therefore after this swap
1742:57 - when i will see that here it is 1
1742:59 - it will simply move ahead by 1 position
1743:02 - but with k we don't do this because
1743:04 - we can get 3 possible values
1743:06 - 0, 1 and 2
1743:08 - and we are not sure that what value
1743:10 - it is getting swapped with
1743:14 - now again i is less than or equal to k
1743:21 - array of i is 1
1743:23 - so this condition comes out to be false
1743:26 - now this condition comes out to be true
1743:28 - because array of i is equal to 1
1743:30 - and we know that when we encounter 1
1743:32 - we simply move i by 1 position
1743:34 - because 1 is already in the middle area
1743:40 - so we simply increment i by 1 position
1743:44 - i becomes 3
1743:48 - i is still less than or equal to k
1743:51 - now array of i is 2
1743:53 - so this condition is false
1743:55 - this condition is false
1743:58 - and this condition will be true
1744:01 - so when we encounter 2
1744:03 - we simply throw it to k and take its value
1744:07 - so 2 will come here
1744:09 - and 0 will come here
1744:11 - like this
1744:13 - now this 2 is at its correct position
1744:17 - so we will decrement k
1744:20 - k becomes 3
1744:24 - now here i is equal to k
1744:26 - so this condition is still true
1744:30 - array of i is 0
1744:32 - so this condition will be true
1744:36 - when we will encounter 0
1744:38 - we need to throw it to j and take its value
1744:41 - so that 0s are at the start
1744:44 - so when we will do swap
1744:47 - so 0 will come here
1744:49 - and 1 will come here
1744:52 - it means 0 is now at its correct position
1744:58 - and as we have encountered 1 here
1745:00 - we first move i by 1 position
1745:03 - so i becomes 4
1745:07 - we have placed 0 at its correct position
1745:09 - so we will move j also by 1 position
1745:12 - j becomes 2
1745:15 - so friends here you can see now this condition comes out to be false because
1745:19 - i is actually greater than k
1745:22 - so this while loop will terminate
1745:25 - and here you can see that we have sorted the array in
1745:29 - 0s
1745:30 - 1s and 2s
1745:32 - form
1745:33 - where 0s are at the start
1745:35 - 1s in the middle
1745:37 - and 2s at the end
1745:39 - so friends this is all about the algorithm
1745:42 - we usually take the help of 3 pointers
1745:45 - i, j and k
1745:47 - i and j starts from 0th index
1745:49 - k starts from the last index
1745:52 - when i will encounter 0
1745:54 - it will simply swap it with j
1745:56 - because j's responsibility is to place 0s at the start
1746:01 - when i will encounter 2
1746:03 - it will simply swap it with k
1746:05 - because the responsibility of k is to put 2 at the end
1746:09 - and when i will see 1
1746:11 - i's responsibility is to
1746:13 - place 1s in the middle
1746:15 - and as i is already in the middle
1746:17 - it will simply move ahead
1746:19 - so friends i hope you must have liked this video
1746:22 - in case if you are new to my channel
1746:24 - then please subscribe to my channel
1746:26 - and click the bell icon so that you never miss any update
1746:29 - thanks have a nice day
1746:33 - hello everyone
1746:34 - so in this video we are going to discuss
1746:37 - about a basic introduction to quicksort
1746:40 - in this video and in upcoming few videos
1746:43 - we will discuss completely about quicksort
1746:46 - so quicksort is a sorting technique
1746:48 - where we get a collection of elements
1746:50 - and we sort them in ascending or descending order
1746:54 - so in quicksort
1746:58 - here if you see
1747:00 - when we discussed merge sort
1747:02 - we saw that it was a divide and conquer algorithm
1747:05 - so by divide and conquer we mean
1747:07 - that let's say if we are given
1747:09 - a complex problem
1747:10 - we try to divide that complex problem
1747:12 - into smaller sub problems
1747:14 - and when those smaller sub problems
1747:16 - are not further divided
1747:18 - we try to conquer them
1747:20 - and when we conquer each and every
1747:22 - smaller sub problems
1747:24 - we reach to the solution of our original problem
1747:27 - so quicksort is also a divide and conquer algorithm
1747:31 - it involves three steps
1747:33 - the first step is
1747:35 - the pivot selection
1747:37 - so in pivot selection what we do is
1747:39 - we pick an element from the array
1747:41 - and mark it as pivot
1747:43 - now this pivot element
1747:45 - can be the first element
1747:47 - last element or any random element
1747:49 - we just take any element
1747:51 - and mark it as pivot
1747:53 - so here
1747:55 - let's suppose we are given this array
1747:57 - and we want to sort this array
1747:59 - using quicksort
1748:04 - so as we discussed
1748:06 - the first thing we do is
1748:08 - we take a pivot element
1748:10 - now this pivot element can be the first element
1748:12 - any random element
1748:14 - or the last element
1748:16 - so we can take any element as pivot
1748:18 - in this tutorial we will take
1748:20 - the last element as our pivot
1748:26 - so here the last element
1748:28 - which is at index 8
1748:30 - the value is 3
1748:32 - so this is our pivot
1748:35 - so this is the first step
1748:37 - we take a pivot
1748:39 - and we can take any element
1748:41 - as our pivot
1748:43 - now after taking a pivot
1748:46 - what we do is
1748:48 - whatever the element we have taken as pivot
1748:50 - now we actually partition the array
1748:53 - so by partitioning we mean
1748:55 - that we reorder the array
1748:57 - such that all elements
1748:59 - greater than pivot
1749:01 - comes after the pivot
1749:05 - and all the elements smaller than pivot
1749:09 - comes before the pivot
1749:12 - the elements equal to pivot
1749:14 - can go either side of the pivot
1749:17 - so whatever the pivot we took
1749:19 - which we saw in our previous slide
1749:21 - it was 3
1749:24 - so then we partition the array
1749:26 - in such a way that all the elements which are greater than pivot
1749:29 - comes after the pivot
1749:31 - and all the elements which are smaller than pivot
1749:33 - comes before the pivot
1749:35 - so we are actually reordering the array
1749:39 - and the elements which are equal to pivot
1749:41 - can go on either side
1749:43 - it can go on the left side or on the right side
1749:46 - so why we are doing this partitioning is
1749:48 - this is the important step
1749:50 - after we perform the partitioning
1749:52 - the pivot
1749:54 - is actually at its correct sorted position
1749:57 - now what it means is
1749:59 - let's say 3 is the pivot
1750:01 - and these are the remaining elements
1750:05 - so all the elements greater than pivot
1750:07 - should come
1750:09 - after the pivot
1750:11 - and all the elements which are smaller than pivot
1750:13 - should come before the pivot
1750:17 - so here 3 is the pivot
1750:19 - so now we will check
1750:23 - 9 is greater than pivot
1750:25 - it comes here
1750:27 - because as it is greater than 3
1750:29 - we know that all the elements which are greater than pivot
1750:32 - will go after the pivot
1750:34 - minus 3 is smaller than 3
1750:38 - it comes here
1750:41 - 5 is greater than 3 it comes here
1750:44 - 2 is lesser than 3 it comes here
1750:46 - 6 is greater than 3 it comes here
1750:49 - 8 comes here
1750:52 - minus 6 comes here
1750:55 - 1 comes here
1750:58 - and 3 is the pivot
1751:00 - so it is at this position
1751:03 - so here you can see
1751:05 - these are all the elements which are smaller than pivot
1751:07 - and these are all the elements which are greater than pivot
1751:11 - we are not concerned about the order
1751:13 - of the elements
1751:15 - here it is minus 3 then it is 2
1751:17 - then it is minus 6
1751:19 - so we are not concerned about the order
1751:21 - here it is 9, 5, 6, 8
1751:23 - like this
1751:25 - we are only concerned about the partitioning of this array
1751:27 - in such a way that
1751:31 - this is the left part
1751:33 - which is smaller than pivot
1751:37 - and this is the right part
1751:39 - which is greater than pivot
1751:41 - so why we are actually doing this partition
1751:43 - here you can see
1751:45 - I will just remove this
1751:53 - so when we actually partition the array
1751:55 - based on what we discussed
1751:57 - here you can see that 3 was our pivot
1751:59 - all the smaller elements
1752:03 - are just before the pivot
1752:05 - and all the greater elements
1752:07 - are just after the pivot
1752:09 - and it can be in any order
1752:11 - but here you can see
1752:13 - that after this partitioning
1752:15 - one unique property
1752:17 - with this pivot is
1752:21 - let's say
1752:23 - this is low
1752:25 - index
1752:27 - and this is high index
1752:29 - and this is
1752:31 - any jth element
1752:33 - so after this partition
1752:35 - in this array
1752:37 - from low to j-1
1752:39 - which is
1752:41 - this portion
1752:43 - is less than equal to
1752:47 - array of j
1752:49 - which is our pivot
1752:51 - which is less than equal to
1752:53 - j plus 1 to
1752:55 - high like this
1752:57 - so when we do this partition
1752:59 - this
1753:01 - holds true
1753:03 - and if you see when we sort this array
1753:05 - so this is the sorted array
1753:09 - so the elements are arranged
1753:11 - in ascending order
1753:13 - but here you see
1753:15 - that the difference between this partitioning
1753:17 - and this sorted array
1753:19 - is the pivot
1753:21 - after the partitioning
1753:23 - and after the sorting
1753:25 - doesn't change its position
1753:27 - it's actually at its correct position
1753:29 - after the first partition
1753:31 - so here if you see
1753:35 - 3 was our pivot
1753:37 - after partitioning
1753:39 - came at index 4
1753:41 - and if we sort this array
1753:43 - you will see that
1753:45 - in the sorted array
1753:47 - the pivot doesn't change
1753:49 - its index
1753:51 - it will still be at index 4
1753:53 - so this is one critical
1753:55 - information about quicksort
1753:57 - let it partitions the array
1753:59 - and all the elements
1754:01 - which are smaller than pivot
1754:03 - comes to the left
1754:05 - and all the elements which are greater than pivot
1754:07 - comes to the right
1754:09 - but this pivot after partition
1754:11 - is actually at its correct position
1754:13 - even after the array is sorted
1754:15 - so this is the second step
1754:17 - of quicksort
1754:19 - the partitioning step
1754:21 - moving ahead
1754:23 - now here you saw
1754:25 - does this pivot
1754:27 - and this partitioning
1754:29 - it is actually
1754:31 - the divide part of the algorithm
1754:33 - where we are actually reordering the array
1754:35 - in the partitioning step
1754:37 - and now how we will conquer this
1754:39 - is based on this recursion step
1754:41 - whatever we did above
1754:43 - now we recursively
1754:45 - apply the above steps
1754:47 - on the sub array formed
1754:49 - on the left side of the pivot
1754:51 - and on the right side of the pivot
1754:53 - so these two steps
1754:55 - we will apply
1754:57 - on all the elements which are lesser than pivot
1754:59 - and on all the elements which are
1755:01 - greater than pivot recursively
1755:03 - so this step which we discussed
1755:05 - that after this partitioning the pivot
1755:07 - is at its correct sorted position
1755:09 - we don't touch the pivot
1755:11 - after the partitioning
1755:13 - we take the left part of the pivot
1755:15 - we take the right part of the pivot
1755:17 - and we apply
1755:19 - the above steps recursively
1755:21 - on the left side
1755:23 - and on the right side
1755:25 - so here
1755:27 - pivot in the sorted array
1755:29 - is at its correct position
1755:31 - like this
1755:33 - but when we do the first partition
1755:35 - this one particular element is sorted
1755:37 - here you can see in the sorted array
1755:39 - pivot doesn't
1755:41 - change its position
1755:43 - and it is at its correct position
1755:45 - so we can think from the first
1755:47 - partition we have sorted
1755:49 - one element
1755:51 - and now when we were discussing the recursion part
1755:53 - the third step
1755:55 - what we do is
1755:57 - we take the left side of the
1755:59 - partition
1756:01 - we take the right side of the partition
1756:03 - we leave the partition
1756:05 - as it is at its correct
1756:07 - position
1756:09 - now we apply the same steps
1756:11 - of choosing a pivot
1756:13 - and then partitioning
1756:15 - on the left side of the array
1756:17 - and on the right side of the array
1756:19 - so this we keep doing recursively
1756:21 - till all the elements
1756:23 - are at its correct position
1756:25 - first partition gives
1756:27 - one sorted element
1756:29 - if we do this recursively
1756:31 - with the left part
1756:33 - and with the right part
1756:35 - there will be a time that all the elements
1756:37 - will be properly sorted
1756:39 - and they will be at its correct position
1756:41 - so the recursion step is important
1756:45 - so these are the three important steps
1756:47 - in quicksort
1756:49 - pivot selection
1756:51 - partitioning and then
1756:53 - doing the recursion
1756:55 - of these two steps
1756:57 - on the left side of the pivot
1756:59 - and on the right side of the pivot
1757:01 - and when this recursion will end
1757:03 - all the elements will be properly sorted
1757:05 - and they will be at its correct position
1757:07 - so this was the
1757:09 - basic introduction of the quicksort
1757:11 - at a high level
1757:13 - in our next video we will see
1757:15 - how we do this pivot selection
1757:17 - and the partitioning
1757:19 - and after that we will see that
1757:21 - this recursion helps us in sorting
1757:23 - the array, taking the help
1757:25 - of these first two steps
1757:27 - and applying them recursively
1757:29 - so friends I hope you must have liked
1757:31 - this video, in case if you are new
1757:33 - to my channel then please subscribe to my
1757:35 - channel and click the bell icon
1757:37 - so that you never miss any update
1757:39 - thanks have a nice day
1757:41 - hello everyone
1757:43 - so in this video we are
1757:45 - going to discuss that what is
1757:47 - quicksort partitioning
1757:49 - in the part one of this video we discussed
1757:51 - a basic introduction
1757:53 - about quicksort
1757:55 - so in this video we will be discussing
1757:57 - what is quicksort partitioning
1758:01 - so friends in our previous video
1758:03 - we discussed that quicksort
1758:05 - is a divide and conquer algorithm
1758:07 - which basically involves three steps
1758:09 - pivot selection
1758:11 - partitioning and recursion
1758:13 - in pivot selection
1758:15 - we actually pick an element
1758:17 - and mark it as pivot
1758:19 - the pivot element can be the first
1758:21 - element, last element or any random
1758:23 - element from the array
1758:25 - and the second step is the partitioning
1758:27 - step where we reorder the
1758:29 - array such that all the
1758:31 - elements greater than pivot
1758:33 - comes after the pivot and
1758:35 - all the elements smaller than pivot comes
1758:37 - before the pivot and the elements
1758:39 - which are equal can go on either side
1758:41 - of the pivot so usually
1758:43 - in the partitioning step
1758:48 - we actually get a left part
1758:55 - and a right part
1758:57 - and in the middle we have pivot
1758:59 - so once the partitioning is done
1759:01 - pivot is somewhere in the middle
1759:03 - also we discussed that
1759:05 - after this partitioning the pivot
1759:07 - is at its correct sorted position
1759:09 - so here you can see
1759:11 - at whatever index pivot comes
1759:13 - after the partition
1759:15 - if we sort this complete array
1759:17 - the pivot will lie at the same
1759:19 - index only so it means
1759:21 - after the partitioning
1759:23 - one of the element is sorted
1759:25 - so in the recursion step
1759:27 - we apply this pivot
1759:29 - selection and partitioning
1759:31 - recursively in the left side
1759:33 - and in the right side
1759:35 - and we keep on doing that till
1759:37 - the complete array is sorted
1759:39 - so in this video we will see
1759:41 - that how we do pivot selection and partitioning
1759:44 - so let's say we are given
1759:46 - with this array
1759:47 - so here we can choose any
1759:49 - element as our pivot
1759:51 - but here we choose the last element
1759:53 - as our pivot
1759:54 - so 3 is the pivot
1759:56 - and as we discussed in our previous video
1759:58 - that after we partition
1760:00 - and reorder the array in such a way that
1760:02 - all the elements smaller than 3
1760:04 - comes before 3
1760:06 - and all the elements greater than 3
1760:08 - comes after the 3
1760:10 - so it would look something like this
1760:12 - that this part
1760:14 - is the left part
1760:20 - and this is the right part
1760:22 - and this is our pivot
1760:24 - so if you see when this array
1760:26 - will get sorted completely
1760:30 - so this is the sorted array
1760:32 - so here you will see
1760:34 - get the pivot
1760:36 - after the partition was at 4th index
1760:38 - and once the array got sorted
1760:40 - completely it was still
1760:42 - at the same index
1760:44 - because when we partition the array
1760:46 - in such a way that
1760:48 - this condition holds true
1760:50 - which we discussed in our previous video as well
1760:52 - after the partition
1760:54 - the pivot
1760:56 - is actually at its sorted position
1760:58 - so now let's see how this partitioning happens
1761:02 - so here is the algorithm
1761:04 - to partition the array
1761:06 - so friends before we start
1761:08 - if you are new to my channel
1761:10 - then please subscribe to my channel and click the bell icon
1761:12 - so that you never miss any update
1761:14 - also please like this video
1761:16 - and watch it till the end
1761:18 - so here you can see
1761:20 - that let's suppose we are given with this array
1761:22 - of 9 elements
1761:24 - 9, minus 3, 5
1761:26 - 2, 6, 8
1761:28 - minus 6, 1
1761:30 - and 3
1761:32 - so when we will call partition
1761:34 - we are actually partitioning complete array
1761:36 - it takes low
1761:38 - and a high pointer
1761:40 - so low actually starts from the 0th index
1761:42 - and high starts from the last index
1761:44 - because we need to partition
1761:46 - the complete array
1761:52 - so low starts from 0
1761:54 - and high starts from 8
1761:58 - so when we do partition of the array
1762:00 - the first thing we need is the pivot
1762:02 - so we can select the pivot
1762:04 - as the first element
1762:06 - last element
1762:08 - or any of the random element
1762:10 - in this array
1762:12 - so here we will choose
1762:14 - the last element as our pivot
1762:16 - so array
1762:18 - value at high index
1762:20 - which is the 8th index
1762:22 - will give us our pivot
1762:24 - so pivot is 3
1762:26 - this value
1762:28 - which is at array of high
1762:30 - which is at array of high
1762:34 - now after this pivot selection what we do is
1762:36 - we reorder this array
1762:38 - in such a way that all the elements
1762:40 - smaller than pivot
1762:42 - comes in the left part
1762:44 - then comes the pivot
1762:46 - and all the elements greater than pivot
1762:50 - comes at the right part
1762:52 - so this reordering is done
1762:54 - by two variables
1762:56 - i and j
1762:58 - both are starting from low
1763:00 - which is the
1763:02 - starting index
1763:04 - of our array
1763:06 - or the starting range of the array
1763:08 - from where we need to do the partitioning
1763:10 - so i starts from low
1763:12 - which is 0 index
1763:14 - and j starts from the low
1763:16 - which is 0
1763:18 - and j starts from low
1763:20 - which is 0 index
1763:24 - so friends now we actually traverse
1763:26 - each and every element
1763:28 - of this array
1763:30 - and we provide a while loop where condition is
1763:32 - i will traverse till it is less than equal to
1763:34 - high
1763:36 - so friends the basic idea behind this algorithm is
1763:38 - why we are creating two pointers
1763:40 - if you see closely
1763:42 - then we have these four pointers
1763:44 - so usually from low
1763:46 - to
1763:48 - j-1
1763:50 - we actually have smaller
1763:52 - elements
1763:54 - and equal elements
1763:56 - to pivot
1763:58 - means all the smaller
1764:00 - elements to pivot comes
1764:02 - from low to j-1
1764:04 - including the elements which are equal to pivot
1764:06 - from j to
1764:10 - i-1
1764:12 - we will have all the greater
1764:14 - elements
1764:16 - to pivot
1764:18 - elements to pivot
1764:24 - and from i
1764:26 - to high
1764:28 - the elements are yet to
1764:30 - be traversed
1764:36 - so after every execution of while loop
1764:38 - you can see these conditions
1764:40 - and you can figure out that
1764:42 - how this ranges works
1764:45 - so at the start from i to high
1764:47 - every element is yet to be traversed
1764:49 - and low to j-1
1764:51 - and j to i-1
1764:53 - goes beyond the array
1764:55 - so therefore there are no elements
1764:57 - in these ranges
1764:59 - currently i is less than equal to high
1765:01 - so this condition is true
1765:04 - now we are trying to explore the first element
1765:06 - which is 9
1765:08 - so here what we do is
1765:10 - in one of our previous videos
1765:12 - we saw that 3 numbers sort
1765:14 - or how we can sort 0 and 1
1765:16 - we apply the small part of the same logic here as well
1765:19 - so what we do is
1765:21 - this 9 which is at array of i
1765:24 - and this 3 which is our pivot
1765:26 - there can be 2 possibilities
1765:31 - array of i
1765:33 - can be less than equal to pivot
1765:35 - or array of i can be greater than pivot
1765:45 - so if array of i is greater than pivot
1765:47 - it means whatever value we have here
1765:50 - it is actually greater than pivot
1765:52 - so here you can see
1765:54 - we know that greater elements
1765:56 - lies from the range j to i-1
1765:59 - so when array of i is greater than pivot
1766:01 - what we do is
1766:03 - we simply move
1766:06 - i by one step
1766:08 - and if array of i is less than pivot
1766:12 - we perform a swap
1766:15 - between i and j
1766:18 - and then we move j
1766:24 - and i simultaneously
1766:26 - so you will understand why we are doing this
1766:28 - once we perform
1766:30 - few of these iterations
1766:33 - so at the start, array of i
1766:35 - which is 9
1766:36 - is greater than pivot
1766:38 - so this condition comes out to be false
1766:42 - so if array of i is greater than pivot
1766:44 - we simply traverse i
1766:46 - ahead
1766:49 - i becomes 1
1766:51 - and we reach
1766:53 - to index 1
1766:55 - so you can see that why we actually traversed i
1766:58 - one step ahead
1767:00 - when pivot
1767:01 - was lesser than array of i
1767:03 - 9 was greater than 3
1767:05 - so greater elements should lie
1767:07 - from j to i-1
1767:09 - so here you can see j
1767:11 - to i-1
1767:13 - so this element
1767:16 - so this is the only range
1767:18 - which can help us to figure out that
1767:20 - it has the greater elements to pivot
1767:22 - you will understand more
1767:24 - about these two ranges
1767:26 - and these two points when we
1767:28 - traverse ahead
1767:30 - now i is less than equal to i
1767:32 - so this condition is true
1767:35 - array of i
1767:38 - is minus 3
1767:40 - minus 3 is less than equal to pivot
1767:42 - so this condition comes out to be true
1767:47 - so when array of i is less than equal to pivot
1767:50 - we simply swap the value with i and jth index
1767:53 - so after we perform swap
1767:55 - we will see why we are actually doing that
1767:57 - so these three steps
1767:59 - i will be going somewhat fast
1768:01 - because we have already discussed
1768:03 - how we can do this swapping
1768:07 - so minus 3 will come here
1768:09 - and 9 will come here
1768:15 - now after this swap minus 3 has came here
1768:17 - 9 has came here
1768:19 - so here when array of i encounters
1768:21 - a value lesser than pivot
1768:23 - it simply throws it
1768:25 - into this direction
1768:27 - from low to j minus 1 we need to put
1768:29 - the smaller and the equal
1768:31 - elements to the pivot
1768:33 - so how i can throw it in this direction
1768:35 - is by swapping it with j
1768:37 - and after we perform this swap
1768:39 - we increment j and i both
1768:41 - because this value
1768:43 - is placed
1768:45 - at its proper position that it is lesser
1768:47 - than the pivot
1768:49 - so now we will increment j also
1768:51 - so j becomes 1
1768:53 - and as these two elements are already
1768:55 - explored we will increment i as well
1769:01 - i becomes 2
1769:04 - now our execution point reaches here
1769:06 - and here you can see
1769:08 - that from low to j minus 1
1769:10 - we have smaller
1769:12 - and equal elements to pivot
1769:14 - so from low to j minus 1
1769:16 - which is this element
1769:18 - this range are the smaller elements
1769:20 - to pivot
1769:22 - from j to i minus 1
1769:24 - this element
1769:26 - is in the range of the
1769:28 - greater elements to pivot
1769:30 - so what these two conditions are still
1769:32 - holds good
1769:34 - i is still less than
1769:36 - or equal to high
1769:38 - so this condition comes out to be true
1769:40 - and the while loop will execute
1769:42 - now 5
1769:44 - is greater than pivot
1769:46 - so this condition comes out to be false
1769:48 - and once this condition comes out to be
1769:50 - false
1769:52 - and once this condition comes out to be false
1769:54 - we know that we need to simply traverse
1769:56 - i ahead
1769:58 - i becomes 3
1770:02 - so now here you can see
1770:04 - this part
1770:08 - is smaller elements range
1770:10 - and this
1770:14 - and these two elements
1770:16 - 9 and 5
1770:18 - are greater than pivot
1770:22 - so it is separated by j and i
1770:24 - in such a way that
1770:26 - from low to j minus 1
1770:28 - we have smaller elements
1770:30 - from j to i minus 1
1770:32 - we have larger elements
1770:34 - so therefore when array of i is greater than pivot
1770:36 - we simply traverse i ahead
1770:38 - we do nothing
1770:40 - and when array of i is less than equal to pivot
1770:42 - it means we have found one
1770:44 - element lesser than pivot
1770:46 - so we simply throw it to the
1770:48 - starting range
1770:50 - and we simply shift the larger element range
1770:52 - i ahead
1770:54 - so here initially 9 was here
1770:56 - which was the larger
1770:58 - or the greater elements to pivot
1771:00 - when we did the swap
1771:02 - 9 actually shifted in this direction
1771:04 - so that there could be a
1771:06 - place for the elements
1771:08 - which are smaller than pivot to come
1771:10 - in this direction
1771:12 - so now similarly we will do this for the rest of the elements
1771:14 - from i to high
1771:16 - the elements are yet to be traversed
1771:18 - currently i is less than equal
1771:20 - to high so this condition comes out
1771:22 - to be true
1771:24 - 2 is less than
1771:26 - equal to pivot
1771:28 - so this condition is true
1771:30 - so now here you can see
1771:32 - we know that 2 should lie
1771:34 - somewhere in this range
1771:36 - at the starting range
1771:38 - and j keeps the track of the
1771:40 - smaller elements from low
1771:42 - to j minus 1
1771:44 - so at j we have one greater
1771:46 - element and we need to put
1771:48 - 2 somewhere here so that
1771:50 - this 2
1771:52 - comes at its proper position
1771:54 - but here we already have 9
1771:56 - so therefore we do this swap
1771:58 - so that 9 can come here and this
1772:00 - range of the greater element is
1772:02 - still maintained in the middle somewhere
1772:04 - and it simply shifts in this
1772:06 - direction
1772:10 - so i will
1772:12 - remove everything
1772:16 - so now we will do this swap
1772:18 - 2 will come here and 9 will come here
1772:28 - 2 came here and 9 came here
1772:30 - so the range of greater
1772:32 - elements simply shifted in this direction
1772:34 - because we need to create a
1772:36 - space so that smaller
1772:38 - elements can come in this direction
1772:40 - we will increment j
1772:42 - now
1772:47 - we will increment i
1772:49 - because this element
1772:51 - which was here
1772:53 - is actually being traversed
1772:57 - so from low
1772:59 - to j minus 1 we have smaller
1773:01 - elements range
1773:03 - from j
1773:05 - to i minus 1
1773:09 - we have larger elements range
1773:11 - or greater elements range
1773:13 - i is still less than
1773:15 - equal to high
1773:17 - so this condition is true
1773:19 - 6 is greater
1773:21 - than pivot
1773:23 - so this condition comes out to be false
1773:27 - it means 6
1773:29 - is at its proper range
1773:31 - we don't have to touch this
1773:33 - we will do i plus plus
1773:35 - so i simply moves ahead
1773:37 - i becomes 5
1773:40 - now this element
1773:42 - also got
1773:44 - into the range of greater elements
1773:46 - because from j to i minus 1
1773:48 - we have
1773:50 - the greater elements to pivot
1773:52 - i is still less than high
1773:54 - so this condition is true
1773:56 - so the while loop will execute
1774:00 - now array of i which is 8
1774:02 - is greater than pivot
1774:04 - so this condition is true
1774:06 - therefore this condition comes out
1774:08 - to be false
1774:12 - and as array of i is greater than pivot
1774:14 - we do nothing
1774:16 - we simply traverse i
1774:18 - i hit
1774:20 - i becomes 6
1774:22 - and this element
1774:24 - becomes part of our
1774:28 - greater elements range
1774:32 - from j to i minus 1
1774:34 - i is still less than equal to high
1774:36 - this condition is true
1774:42 - now minus 6 is less than 3
1774:44 - so therefore array of i is less than equal to pivot
1774:46 - now we need to throw this pivot
1774:48 - in the left direction
1774:50 - and we know that j is actually
1774:52 - keeping the track of that
1774:56 - so this condition is true
1774:58 - first we perform swap between i and j
1775:00 - so that
1775:02 - this minus 6 comes in this range
1775:04 - and we simply shift
1775:06 - one of the greater elements
1775:08 - in this direction
1775:10 - so we will perform this swap
1775:12 - using a temp variable
1775:20 - so minus 6 came here
1775:22 - and 5 came here
1775:28 - so after placing a smaller element
1775:30 - at this spot we will increment j
1775:36 - j becomes 3 because
1775:38 - for the next smaller element
1775:40 - this would be the right place
1775:42 - so we increment j as well
1775:46 - and as we have already traversed
1775:48 - whatever the value was here
1775:50 - at this index we will also increment i
1775:52 - so i become 7
1775:56 - so here you can see
1775:59 - this range
1776:01 - from low to j-1
1776:03 - we have smaller elements
1776:05 - from j to i-1
1776:11 - we have greater elements to pivot
1776:13 - value of i is 7
1776:15 - so 7 is less than equal to
1776:17 - i which is 8
1776:20 - now 1 is less than equal to 3
1776:22 - so this condition comes out to be true
1776:25 - we need to throw this
1776:27 - 1 because it is lesser than or equal to pivot
1776:29 - in this direction
1776:31 - so that it can come in this range
1776:33 - we simply swap
1776:35 - i and j
1776:44 - so 1 came here and 9 came here
1776:46 - so you can see
1776:48 - when we are actually encountering
1776:50 - a value lesser than pivot
1776:53 - we are doing this swap
1776:55 - and putting that at the starting range
1776:57 - and whatever value
1776:59 - j is pointing from j to i-1
1777:01 - we have greater elements
1777:03 - so at j we have 1 greater elements
1777:05 - so we are simply shifting
1777:07 - the range which is greater
1777:09 - than the pivot
1777:11 - just ahead
1777:12 - so 9 came here
1777:14 - but still if you see
1777:16 - the ranges intact
1777:18 - all the elements which are greater than pivot
1777:20 - are in sequence
1777:22 - the order will not be maintained
1777:24 - but the range will be maintained
1777:28 - so now after using this spot
1777:36 - we will increment j
1777:38 - j becomes 4
1777:43 - and we will increment i
1777:45 - because this element is traversed
1777:47 - and it got shifted here
1777:50 - so we simply traverse i ahead
1777:52 - i becomes 8
1777:58 - so here you can see from low to j-1
1778:00 - this range
1778:02 - is of smaller elements
1778:04 - j to i-1
1778:07 - this range
1778:09 - is of greater elements
1778:14 - now for the last time
1778:16 - this while loop will execute
1778:18 - i is equal to i
1778:22 - so here you can see
1778:24 - that now we are actually encountering the pivot itself
1778:26 - and this is one critical step
1778:28 - because we need to put
1778:30 - this pivot at its correct position
1778:32 - somewhere
1778:34 - between the range of smaller
1778:36 - and greater elements to pivot's range
1778:38 - so this equal to condition
1778:40 - does that
1778:42 - and it is very important
1778:44 - so currently array of i
1778:46 - is equal to pivot
1778:48 - so 3 is equal to 3
1778:50 - which is the pivot
1778:52 - and we can place this 3
1778:54 - because smaller
1778:56 - and equal elements to pivot will lie
1778:58 - from low to j-1
1779:00 - and j is at the spot which can take lesser
1779:02 - or equal values to the pivot
1779:04 - so 3 at index i
1779:06 - will be swapped with j
1779:16 - so 3 comes here
1779:18 - which is our pivot
1779:20 - and 6 comes here
1779:22 - which is the value greater than
1779:24 - to pivot
1779:26 - so after placing an element
1779:28 - which is less than equal to pivot
1779:30 - at its correct position using j
1779:32 - we will increment j
1779:34 - so that next element can come here
1779:36 - but as there are no elements
1779:38 - but still we do this j++
1779:40 - so j becomes 5
1779:42 - and we will increment i
1779:44 - because we are done with this element
1779:50 - so i becomes 9 which
1779:52 - goes out of the boundaries of this array
1779:56 - so this condition comes out to be false
1779:58 - because value of i is 8
1780:00 - and i is 9
1780:02 - so i is actually greater than
1780:04 - i so this value will terminate
1780:06 - and here you can see
1780:08 - that in quickshot pivot
1780:10 - partitioning
1780:12 - when we do this
1780:14 - partitioning
1780:16 - at the end we need to return
1780:18 - the index of the partition
1780:20 - that from which index the partition
1780:22 - is happened
1780:24 - so here we can see that from low to j-1
1780:26 - we have smaller and equal elements
1780:28 - to pivot
1780:30 - so i will redraw this
1780:34 - low
1780:36 - to j-1
1780:38 - smaller and equal elements
1780:40 - to pivot
1780:42 - j to i-1
1780:44 - so i value is 9
1780:46 - so j
1780:48 - to i-1
1780:50 - which is still 8
1780:52 - these are the elements greater than pivot
1780:54 - and from i to i
1780:56 - we have traversed all the elements
1780:58 - so if you observe closely
1781:00 - j is actually pointing to a place
1781:02 - where the next
1781:04 - smaller elements to pivot will come
1781:06 - so we will simply return j-1
1781:08 - because we know that
1781:10 - from low to j-1
1781:12 - we have elements smaller and equal
1781:14 - to pivot so 3 comes here
1781:16 - which is at index 4
1781:18 - so we will return
1781:20 - the index of the pivot
1781:22 - so in this partition whatever value we
1781:24 - return is actually the index
1781:26 - of the pivot after the
1781:28 - partitioning which is j-1
1781:30 - so index 4
1781:32 - will be returned
1781:34 - this is how we do partitioning
1781:36 - and this partition method
1781:38 - is very frequently used in the
1781:40 - quick sort
1781:42 - similar kind of logic
1781:44 - is used
1781:46 - when we do sorting of 0 and 1
1781:48 - or putting e1
1781:50 - or odd integers
1781:52 - in certain sequence
1781:54 - or we sort
1781:56 - the 3 elements 0, 1 and 2
1781:58 - so for 0 and 1
1782:00 - this code is pretty much similar
1782:02 - so this partitioning logic
1782:04 - which you are seeing here is very
1782:06 - important for many of the algorithms
1782:08 - and this traversal
1782:10 - with this range
1782:14 - is very important to understand because
1782:16 - the same logic applies to
1782:18 - many of the algorithms
1782:20 - so we will see the partitioning logic
1782:22 - how it applies to quick sort
1782:24 - in our next video
1782:26 - we will see that how this
1782:28 - recursion happens
1782:32 - where we apply the same logic
1782:34 - of partitioning in the
1782:36 - left side of the array
1782:38 - which have smaller elements
1782:40 - and the right side of the pivot which have
1782:42 - the greater elements
1782:44 - so friends I hope you
1782:46 - must have liked this video
1782:48 - in case if you are new to my channel
1782:50 - then please subscribe to my channel and click
1782:52 - the bell icon so that you never
1782:54 - miss any update
1782:56 - thanks have a nice day
1782:58 - hello everyone
1783:00 - so in this video we are going to discuss
1783:02 - about quick sort recursion
1783:04 - in part 2 video of quick sort
1783:06 - we discussed that how we can partition an array
1783:08 - so in this video we will see
1783:10 - that how we can perform
1783:12 - quick sort recursion
1783:14 - so in the previous video
1783:16 - we discussed about the pivot selection
1783:18 - that we pick an element
1783:20 - and mark it as pivot
1783:22 - the pivot can be any random element
1783:24 - it can be first element, last element
1783:26 - or any random element
1783:28 - now based on what we choose
1783:30 - as our pivot
1783:32 - we do the partitioning
1783:34 - we reorder the array
1783:36 - such that all elements
1783:38 - greater than pivot
1783:40 - comes after the pivot
1783:42 - all elements smaller than pivot
1783:44 - comes before the pivot
1783:46 - the elements equal to pivot can go
1783:48 - on either side of the pivot
1783:50 - and once this partitioning is done
1783:52 - based on the reorder
1783:54 - of the array, the pivot
1783:56 - is actually at its correct
1783:58 - sorted position
1784:00 - so this we already discussed in our previous video
1784:04 - so in this video we will be looking into the
1784:06 - recursion part, where after
1784:08 - partitioning the array
1784:10 - we perform these two steps
1784:12 - the pivot selection and partitioning
1784:14 - recursively
1784:16 - on the sub array
1784:18 - formed on the left side of the pivot
1784:20 - which has the smaller elements
1784:22 - to pivot
1784:26 - and on the sub array formed
1784:28 - on the right side of the pivot
1784:30 - which has the
1784:34 - greater
1784:36 - elements to pivot
1784:40 - so here about two steps
1784:42 - we perform recursively
1784:44 - on the left side of the pivot
1784:46 - and on the right side of the pivot
1784:48 - so let's see at a high level
1784:50 - how this recursion looks
1784:52 - so let's see
1784:54 - we want to sort this array using
1784:56 - quicksort
1785:00 - so here you can see that this is a small
1785:02 - piece of code which does the sorting
1785:04 - it takes in an array
1785:06 - and it takes in a range
1785:08 - that from which index to which
1785:10 - index we need to
1785:12 - do the sorting
1785:14 - and here you can see that the first step
1785:16 - we are doing is the partition step
1785:18 - and once we get the partition index
1785:20 - now we have
1785:22 - two arrays
1785:24 - one is on the left side of the partition
1785:26 - and one is on the right side of the partition
1785:28 - so we recursively call
1785:30 - the sort method
1785:32 - which is the same method
1785:34 - from low to P-1
1785:36 - which is the left part
1785:40 - and from P plus 1
1785:42 - to high which is the
1785:44 - right part
1785:46 - and this happens recursively
1785:48 - because the method is calling itself again and again
1785:50 - after the partition
1785:52 - we are actually rearranging the array
1785:54 - in the partition method in such a way
1785:56 - that the element present
1785:58 - at the partition index
1786:00 - which is the position of our pivot
1786:02 - that element is correctly sorted
1786:04 - and placed at its proper
1786:06 - position so with one partition
1786:08 - we can get one element
1786:10 - and place that element at its correct
1786:12 - position such that that particular
1786:14 - element is sorted
1786:16 - and we will keep on doing this recursion
1786:18 - till low is less than high
1786:20 - so this is our base case
1786:22 - so at a high level
1786:26 - let's see how this recursion looks
1786:28 - in our next video
1786:30 - we will see the step by step demonstration
1786:32 - of this quick sort algorithm
1786:34 - but for time being we can
1786:36 - just see at a high level
1786:38 - that how this recursion looks like
1786:40 - so here at the start
1786:42 - we need to sort this complete array
1786:44 - so this will be our low
1786:46 - and this will be our high
1786:52 - now low is less than high
1786:54 - we call the partition method
1786:56 - so in the partition method
1786:58 - we take the last element as our pivot
1787:00 - like this
1787:06 - so 3 is our pivot
1787:08 - now after this partition method will end
1787:10 - we get the index
1787:12 - of the element 3 that where it belongs
1787:15 - so in our previous video we saw
1787:17 - that how we can perform this partition
1787:19 - and we took the same example
1787:21 - so in the first partition
1787:23 - you will see that
1787:25 - 3 comes at index 4
1787:27 - and in the partition
1787:29 - the arrays rearrange in such a way that
1787:31 - all the elements
1787:33 - lesser than pivot
1787:35 - comes on the left side
1787:37 - all the elements greater than pivot
1787:39 - comes on the right side
1787:42 - so here we are doing the logical division
1787:44 - of the array
1787:45 - and we are partitioning into 2 parts
1787:47 - left and right
1787:49 - so we are not breaking the array
1787:51 - its just for the demonstration purpose
1787:53 - that it looks like this
1787:55 - if you see the index from 0 to 3
1787:57 - we have smaller elements
1787:59 - from 5 to 8 we have elements
1788:01 - greater than the pivot
1788:03 - so this
1788:05 - is the pivot index
1788:07 - now after we get the pivot index
1788:09 - if we sort this array directly
1788:11 - you will see that
1788:13 - in the sorted array
1788:15 - 3 will be always at index 4
1788:17 - it means when we perform this partition
1788:19 - one of the element is sorted
1788:21 - and it is placed at its correct position
1788:23 - so once it is placed
1788:25 - at its correct position
1788:27 - we don't touch this element now
1788:29 - what we do is
1788:31 - we call the sort method
1788:33 - on the left side recursively
1788:35 - so it goes deep down like this
1788:37 - and the range we took is
1788:41 - low to p-1
1788:43 - so p is the pivot
1788:45 - and this is p-1
1788:47 - so now we will call the sort
1788:49 - by taking this left side
1788:51 - only these 4 elements
1788:53 - and this will happen recursively
1788:55 - low should be less than high
1788:57 - this should be our base case
1788:59 - so here when this sort method
1789:01 - will be executed for this left array
1789:03 - you can see that
1789:05 - this sort method will be executed again
1789:07 - low will be the same
1789:09 - but high will become p-1
1789:11 - so this would be our high
1789:17 - low is less than high
1789:19 - now we will again call partition method
1789:21 - we will pass in the array
1789:23 - we will pass in low and high
1789:25 - so now in the partition method
1789:27 - only these 4 elements will be reordered
1789:29 - because we are providing the range
1789:31 - of low and high in the partition
1789:33 - at the start low and high
1789:35 - were the complete range of the array
1789:37 - from 0 to 8
1789:39 - now this partition method
1789:41 - will only partition 0 to 3
1789:43 - so in the partition method
1789:45 - we will first choose the pivot element
1789:47 - which we have discussed
1789:49 - that we choose the last element
1789:51 - now we need to do the reordering
1789:53 - such that all the elements
1789:55 - lesser than 1 should come on the one side
1789:57 - and all elements greater than
1789:59 - one should come on the other side
1790:01 - so here we will see that
1790:03 - the partition method will reorder the array in such a way
1790:05 - that it looks like this
1790:07 - this much part
1790:09 - are the elements
1790:11 - which are lesser than pivot
1790:13 - and this much part
1790:15 - are the elements which are greater than pivot
1790:17 - which is 1
1790:19 - but here we will see
1790:21 - the index which we get is 2
1790:23 - because it returns the final
1790:25 - position of the pivot so index 2
1790:27 - will return here in the
1790:29 - first partition index 4 was written
1790:31 - so based on this p-1
1790:33 - we took the left side
1790:35 - of the array and we did the partition again
1790:37 - so now here if you see
1790:39 - if we sort this array
1790:41 - completely you will find that
1790:43 - 3 is at 4th index
1790:45 - which is sorted
1790:47 - and after the second partition
1790:49 - 1 will be at 2nd index
1790:51 - so this element is also sorted
1790:53 - so now we don't touch 1
1790:55 - here if you see
1790:57 - we again go on the left side
1790:59 - from low
1791:01 - so this was our low
1791:03 - and this is our p
1791:05 - and this is our
1791:07 - high
1791:09 - so we again call sort method
1791:11 - from low to p-1
1791:13 - which is we are taking the
1791:15 - left side of the array
1791:17 - so when this sort method will be called again
1791:19 - low will be at the same spot
1791:21 - but high will become this spot
1791:28 - so it means
1791:30 - now we are actually picking up this
1791:32 - 2 elements
1791:34 - and we are trying to sort them
1791:36 - and we are trying to apply this logic
1791:38 - so this will be our low
1791:41 - and this will be our high
1791:44 - low is less than high
1791:46 - so it means we have 2 elements
1791:48 - so we can again do the partitioning
1791:50 - of the array from low to high
1791:52 - so in the partition method
1791:54 - we will take the last element as our pivot
1791:58 - and now we will partition the array
1792:00 - in such a way that all the elements
1792:02 - lesser than minus 6
1792:04 - will go on the left side
1792:06 - and all the elements greater than minus
1792:08 - 6 will go on the right side
1792:10 - so this partition method will
1792:12 - reorder only these 2 elements now
1792:14 - because we are providing the ranges
1792:16 - and it will touch
1792:18 - the array into these ranges only
1792:20 - so it looks like this
1792:22 - so as there are no elements
1792:24 - which are smaller than minus 6
1792:26 - so minus 6 will be
1792:28 - the only element on the left side
1792:30 - which is at index 0
1792:32 - and minus 3 is greater than
1792:34 - minus 6 so this will lie on the right side
1792:36 - so from here you can see
1792:38 - that now
1792:40 - this is our low
1792:42 - and this is our pivot
1792:44 - index
1792:48 - so after we get the pivot index
1792:50 - we will again call sort
1792:52 - on this one element
1792:54 - we will try to sort its left part
1792:56 - from p minus 1
1792:58 - so p is at 0 index
1793:00 - if we do p minus 1
1793:02 - it will go minus 1
1793:04 - so here if you see when we partition the array
1793:06 - pivot was at 0th index
1793:08 - it is the only element now
1793:10 - so on the left side of pivot
1793:12 - we have no elements
1793:14 - so if we call sort method again
1793:16 - passing in low as 0
1793:18 - and high as p minus 1
1793:20 - so it will take the value
1793:22 - of the new high
1793:24 - as minus 1
1793:26 - so here we will reach the base case
1793:28 - and we will simply return from this method
1793:30 - because low value is 0
1793:32 - and high value is minus 1
1793:34 - so therefore we can't
1793:36 - further divide minus 6
1793:38 - and at whichever index
1793:40 - minus 6 will be there
1793:42 - that will be the properly sorted
1793:44 - position for the element minus 6
1793:46 - so now this method is done
1793:48 - because when we call sort again
1793:50 - we will reach this base case
1793:52 - and we will return
1793:54 - so this method will be done
1793:56 - so now this sort method will be executed
1793:58 - and we go to the right side of the pivot
1794:00 - it means now we are taking in
1794:02 - the elements which are greater than minus 6
1794:04 - which is the only element
1794:06 - minus 3
1794:08 - so p plus 1
1794:10 - p plus 1
1794:12 - will be our new low
1794:15 - this will be our low
1794:17 - and high will remain
1794:19 - the same index
1794:21 - so here if you see
1794:23 - we will again encounter the base case
1794:25 - low is actually equal to high
1794:27 - so it means we can't divide
1794:29 - from low to high further down
1794:31 - so based on this base case
1794:33 - this sort method will end
1794:34 - and the call will reach here again
1794:36 - and the sort method which we call from here
1794:38 - this will also get end
1794:40 - so minus 3 will be also
1794:42 - at its correct sorted position
1794:44 - like this
1794:46 - so here
1794:48 - with these two sort methods
1794:50 - we are going in this direction
1794:52 - and then we are going in this direction
1794:54 - so with this sort
1794:56 - we went to this direction
1794:58 - this is sorted
1795:00 - and with this sort we went to this direction
1795:02 - which is sorted
1795:04 - so we will return back
1795:06 - to the left side
1795:08 - and here you can see when we will return back here
1795:10 - when we had called sort on this part
1795:12 - we went in this direction
1795:14 - and as we are returning back from here
1795:16 - so we will return
1795:18 - from here like this
1795:20 - and now when these two elements are sorted
1795:22 - we will go in this direction
1795:24 - to sort the greater elements
1795:26 - to this pivot
1795:28 - because we are doing this algorithm recursively
1795:30 - so first the left side is
1795:32 - done
1795:34 - and once that left side is done
1795:36 - we go on the right side
1795:38 - so this side is done completely here
1795:40 - now we go on this side
1795:42 - so here 2 is the only element left
1795:44 - so this will be sorted
1795:46 - because the base case will be fulfilled
1795:48 - for this element
1795:50 - low and high
1795:52 - will be at the same spot
1795:54 - because
1795:56 - this is our P
1795:58 - and if we are going on the right side
1796:00 - we do P plus 1
1796:02 - so P plus 1
1796:04 - will be the index 3 which will be our low
1796:06 - and high is already at index 3
1796:08 - so this is sorted
1796:10 - like this
1796:12 - so now execution point will reach
1796:14 - back here
1796:16 - and here you can see left side is now properly
1796:18 - done
1796:20 - so it will go back here
1796:22 - and now we perform the same steps
1796:24 - recursively on the right side
1796:26 - of the elements which are greater than
1796:28 - 3
1796:30 - which is our index 4
1796:32 - so now we perform the same step on this right side
1796:34 - so if we are going on the right side
1796:36 - we are doing P plus 1
1796:38 - we are going on the right side
1796:40 - the low will be from P plus 1 to high
1796:42 - so this is P
1796:46 - this will be our low
1796:48 - and this will be our high
1796:50 - because this high
1796:52 - has not changed its value
1796:54 - so now we will partition it again
1796:56 - based on what we saw here
1796:58 - so 6 will be our
1797:00 - pivot
1797:03 - and now when we will partition it
1797:05 - it would look something like this
1797:07 - so 6 is properly sorted
1797:10 - now we go on the
1797:12 - left side first
1797:14 - so 5 is the only element left
1797:16 - so it will encounter the base case
1797:18 - this is our P
1797:20 - and this is our low
1797:22 - so for the left side if we do P minus 1
1797:24 - to take all the elements
1797:26 - which are lesser than
1797:28 - 6 this will become
1797:30 - our high
1797:32 - and as high is equal to low
1797:34 - we will return from the recursion
1797:36 - and 5 will be at its
1797:38 - correct position
1797:40 - so we go back like this
1797:42 - and then we try to sort
1797:44 - the right side so we call the
1797:46 - recursion again
1797:48 - by taking P plus 1
1797:50 - to high
1797:52 - so this was high
1797:54 - like this
1797:56 - and if we do P plus 1
1797:58 - this will be our low now
1798:00 - so now we are actually partitioning
1798:02 - two elements
1798:04 - so we take 9 as the pivot
1798:06 - we do the partition
1798:08 - so our pivot lies at the
1798:10 - 8th index
1798:12 - there is only 1 an event which is lesser than pivot
1798:14 - which is on the left side of the array
1798:16 - and there are no elements
1798:18 - which are greater than pivot
1798:20 - so after the partition at whichever
1798:22 - position the pivot lies
1798:24 - this is the properly sorted
1798:26 - position for element 9
1798:28 - and we are left with only
1798:30 - one element so if we first go on the left side
1798:32 - like this
1798:34 - we take
1798:36 - from low
1798:38 - to P minus 1
1798:40 - because if we do P minus 1
1798:42 - we will get the left side range
1798:44 - so this will become our new
1798:46 - high
1798:48 - and as this is the only element left
1798:50 - low is equal to high so we can't
1798:52 - divide or partition this piece
1798:54 - of sub-array further
1798:56 - so 8
1798:58 - will be also at its correct position
1799:00 - like this
1799:02 - so if I remove everything
1799:12 - so here you can see that we are
1799:14 - performing the recursion
1799:16 - on this array recursively
1799:18 - and we are doing the partitioning
1799:20 - and with each partition
1799:22 - 1 1 element is getting sorted
1799:24 - in place at its correct position
1799:26 - so if you try to combine all these indexes
1799:28 - you will see that if we
1799:30 - sort this array, the array would look like
1799:32 - if I just plot it here
1799:34 - it will look like
1799:36 - first minus 6
1799:38 - minus 3
1799:40 - then 1 2
1799:42 - 3 5
1799:44 - 6 8
1799:46 - and 9
1799:48 - so if you see that this would be our finally
1799:50 - sorted array and if you see
1799:52 - the indexes of all the
1799:54 - elements
1799:56 - from 0 to 8 you will see
1799:58 - that at 0 we have minus 6
1800:00 - like this
1800:02 - at index 1 we have minus 3 sorted
1800:04 - index 2 we have
1800:06 - 1
1800:08 - at index 3 we have 2
1800:10 - index 4 we have
1800:12 - 3
1800:14 - at the 5th index we have 5
1800:16 - 6th index 6
1800:18 - 7th index
1800:20 - we have 8
1800:22 - and at the 8th index we have 9
1800:24 - so here you can see that how this recursion
1800:26 - and this partitioning
1800:28 - is helping us to perform
1800:30 - the quick sort
1800:34 - so friends here if you see
1800:36 - at the start we took complete
1800:38 - array
1800:40 - we took a pivot
1800:42 - we did the partitioning
1800:44 - all the elements
1800:46 - lesser than pivot were on this side
1800:48 - and all the elements greater than pivot
1800:50 - were on this side
1800:52 - then we recursion we took the left part
1800:54 - we took the pivot
1800:56 - and we did the same steps like this
1800:58 - then we took the left part again
1801:00 - we did the same step and
1801:02 - finally we got
1801:04 - minus 6 and minus 3 at
1801:06 - 0 and 1 index
1801:08 - which are sorted
1801:10 - this left and right part and sorting them
1801:12 - this left part
1801:14 - was done properly then we picked
1801:16 - the right part
1801:18 - of this pivot and this was
1801:20 - sorted and after
1801:22 - we sorted this all the
1801:24 - elements were done
1801:26 - for the first
1801:28 - left sub array then we
1801:30 - went to the right part
1801:32 - and we did the same
1801:34 - steps again we first
1801:36 - went on left then we went on the right
1801:38 - we first went on the left then we went
1801:40 - on the right and at the end
1801:42 - you see all the
1801:44 - elements are at their
1801:46 - proper indexes
1801:48 - so if we sort this array
1801:50 - you will get this array
1801:52 - so friends this was all about
1801:54 - the quicksort recursion
1801:56 - if you didn't understand
1801:58 - any of the recursion logic
1802:00 - here in our next video
1802:02 - we are going to see
1802:04 - the step by step demonstration
1802:06 - of the quicksort algorithm
1802:08 - there it will make sense that
1802:10 - how this recursion is happening
1802:12 - where this sort
1802:14 - method is again calling
1802:16 - this sort method two times
1802:18 - after partitioning
1802:20 - we go on the left side first
1802:24 - and then we go
1802:26 - on the right side
1802:28 - so we will understand this recursion
1802:30 - in our next video with a
1802:32 - detailed demonstration
1802:34 - I hope you must have liked this video
1802:36 - in case if you are new to my channel
1802:38 - then please subscribe to my channel
1802:40 - and click the bell icon
1802:42 - so that you never miss any update
1802:44 - thanks have a nice day
1803:04 - so this is the quicksort algorithm
1803:06 - and we will see the step by step demonstration
1803:08 - of the algorithm
1803:10 - so friends before we start
1803:12 - in case if you are new to my channel
1803:14 - then please subscribe to my channel and click the bell icon
1803:16 - so that you never miss any update
1803:18 - so in quicksort algorithm
1803:20 - we have this sort method
1803:22 - which takes in an array which you want to sort
1803:24 - and we pass
1803:26 - basically a range that from
1803:28 - low to high we need to sort
1803:30 - so at the start
1803:32 - let's say we want to sort this array
1803:34 - having six elements
1803:36 - five, two, zero
1803:38 - one, six, three
1803:40 - so when we will call
1803:42 - sort method we will pass in the array
1803:44 - the low will be zero
1803:46 - and high will be array.length
1803:48 - minus one which is the
1803:50 - last index
1803:52 - so low is zero
1803:54 - which is pointing to zero index
1803:56 - high is five which is pointing
1803:58 - to the last index
1804:00 - so we are telling that we need to sort this array
1804:02 - completely from zero index
1804:04 - to fifth index
1804:06 - and here you can see
1804:08 - that this sort method
1804:10 - is recursively calling this sort
1804:12 - method again here
1804:14 - and here
1804:16 - so in order to demonstrate the recursion
1804:18 - we are using this call stack
1804:20 - which will have the method calls
1804:22 - and the state of the method
1804:24 - stored in low, p
1804:26 - and high so when this
1804:28 - sort method will be called there will be
1804:30 - one method on the call stack
1804:32 - by name sort
1804:34 - low is at zero index
1804:36 - high is at fifth index
1804:38 - and p is the
1804:40 - index of the pivot which we will
1804:42 - be calculating here
1804:44 - moving ahead
1804:46 - so here we know that quicksort
1804:50 - is divide and conquer
1804:52 - algorithm
1804:54 - so here we actually divide this complex problem of sorting
1804:56 - into smaller sub problems
1804:58 - which means that we are dividing
1805:00 - this array into two parts
1805:02 - and we keep on dividing
1805:04 - the array into this recursive
1805:06 - sort methods
1805:08 - based on range low and high
1805:10 - so when low
1805:12 - will be equal to high
1805:14 - or low
1805:16 - will be greater than high
1805:18 - when low will be equal to high
1805:20 - so it will be something like
1805:22 - this that low is
1805:24 - equal to high, it means we can't
1805:26 - further break down the array
1805:28 - because it has only one element
1805:30 - so therefore when this
1805:32 - condition will arrive
1805:34 - we need to simply break from this recursion
1805:36 - because this sort method
1805:38 - is recursively calling this sort
1805:40 - and it keeps on going
1805:42 - so when low will be equal
1805:44 - to high or greater than high
1805:46 - then we need to tell recursion that
1805:48 - we have reached our base case
1805:51 - and we need to stop the recursion
1805:56 - so currently low is less than high
1805:58 - low is zero and high is five
1806:00 - so this condition comes out to be true
1806:04 - so friends in our previous video we discussed
1806:06 - that how we actually
1806:08 - do the quicksort
1806:10 - we first do the pivot selection
1806:12 - where we pick up a random element
1806:14 - from an array and then we actually
1806:16 - partition the array
1806:18 - in such a way that
1806:20 - the elements which are smaller than the pivot
1806:22 - usually lie on the left side
1806:24 - and the elements which are greater
1806:26 - than pivot usually lie on the right side
1806:28 - and the equal elements
1806:30 - can go on either side
1806:32 - so here this is the first step
1806:34 - we actually call the partition method
1806:36 - we pass the array
1806:38 - we pass the range
1806:40 - from low to high
1806:42 - so currently we are telling that we need to
1806:44 - partition this complete array
1806:46 - and in this partition method
1806:48 - we actually do the pivot selection
1806:50 - and reordering of the array
1806:54 - so this method we have discussed
1806:56 - in our previous videos in a greater
1806:58 - detail you can watch that video
1807:00 - to get more understanding
1807:02 - but here also we will see that
1807:04 - how this partition works
1807:06 - so when we will call partition method
1807:08 - we are leaving this sort method
1807:10 - so the execution point
1807:12 - will leave the sort method
1807:14 - and the partition method will be
1807:16 - on the call stack
1807:18 - so before we leave this sort method
1807:20 - we need to store the state of
1807:22 - this sort method that low
1807:24 - was at zero and high was at
1807:26 - fifth index
1807:28 - and as we are leaving this sort method
1807:30 - we need to keep the track of line number
1807:32 - because once this partition method
1807:34 - will end we need to begin
1807:36 - this sort method from line
1807:38 - number three only because we are
1807:40 - leaving this sort method at line number
1807:42 - three so here we will
1807:44 - update the line number three
1807:46 - like this which tells that
1807:48 - we are leaving this sort method at
1807:50 - line number three and when we will
1807:52 - come back to this sort method we will start
1807:54 - our execution from line number three
1807:56 - and when we will start our execution
1807:58 - low will be at zero
1808:00 - and high will be at five
1808:02 - so we are simply storing the state here
1808:08 - so now we will see this partition method
1808:10 - with this array
1808:12 - low as zero and high as five
1808:14 - so we are partitioning
1808:16 - this complete array
1808:18 - we have discussed this method in greater detail
1808:20 - in our previous videos
1808:22 - you can watch that video
1808:24 - so that once we go through it again
1808:26 - you will get more better understanding
1808:30 - so first we do the pivot selection
1808:32 - we can choose any random element
1808:34 - from the array as our pivot
1808:36 - we can choose the first element
1808:38 - or any element in the middle
1808:40 - or the last element
1808:42 - so here we choose
1808:44 - the last element as our pivot
1808:46 - which is denoted by
1808:48 - the end of this range
1808:50 - so pivot becomes array of high
1808:52 - which is three
1808:54 - so this is our pivot
1808:56 - and after this pivot selection
1808:58 - our job is to
1809:00 - do this partition
1809:02 - elements lesser than three
1809:04 - will go on one side
1809:06 - which is on the left side
1809:08 - elements greater than three
1809:10 - will go on the right side
1809:12 - and the elements which are equal to pivot
1809:14 - can go on either side
1809:16 - so when we perform the partition
1809:18 - we take the help of two variables
1809:20 - i and j
1809:22 - here i and j both starts from low
1809:24 - currently low is pointing to zero index
1809:26 - so we are not starting i and j from
1809:28 - zeroth index
1809:30 - we always start it from the low index
1809:32 - because currently as we are partitioning complete array
1809:34 - pointing to zero
1809:36 - there could be a chance
1809:38 - that we only need to partition
1809:40 - these three elements
1809:42 - so at that moment
1809:44 - low will be at third index
1809:46 - so we need to partition of third index
1809:48 - to fifth index
1809:50 - so therefore we create
1809:52 - two pointers i and j
1809:54 - both starting from low
1809:56 - i is zero
1809:58 - because low is pointing to zero
1810:01 - j is zero
1810:05 - now as we need to partition
1810:07 - we need to provide a while loop
1810:09 - where we traverse each and every element
1810:11 - of the array
1810:12 - using the iterator i
1810:14 - it goes till it is less than equal to high
1810:16 - so this is very important algorithm
1810:18 - and it is used in many problems
1810:20 - here what we do is
1810:22 - we have these four pointers
1810:24 - and once we partition the array
1810:26 - it looks something like this
1810:30 - smaller
1810:33 - and equal elements to pivot
1810:38 - are on the left side
1810:42 - then we have the pivot
1810:47 - and then we have the
1810:50 - elements greater than pivot
1810:52 - so this is the ranges
1810:54 - and if we use these four
1810:56 - pointers
1810:58 - the range varies like this
1811:00 - from low to j-1
1811:02 - we have smaller elements
1811:04 - or equal elements to pivot
1811:06 - from j to i-1
1811:08 - we have the
1811:10 - elements greater than pivot
1811:12 - and we have discussed this in greater detail
1811:14 - in our previous videos as well
1811:16 - from high to high
1811:18 - we have elements yet to be traversed
1811:20 - so at the start we need to traverse every element
1811:22 - so from low to j-1
1811:24 - and from j to i-1
1811:26 - we don't have any elements
1811:28 - because all the elements are yet to be traversed
1811:30 - therefore we have provided this condition
1811:32 - that this while loop will run
1811:34 - till i is less than equal to high
1811:36 - so we will see how this algorithm works
1811:38 - and also we need to keep
1811:40 - this if condition in mind
1811:42 - so here
1811:44 - when we are partitioning we need to compare
1811:46 - each and every element with the pivot
1811:48 - and if it is less than pivot
1811:50 - the first thing we do is
1811:52 - we simply swap the values
1811:54 - at i and jth index
1811:56 - in the array because as this element
1811:58 - is less than equal to pivot
1812:00 - it should come at the starting range
1812:02 - because we need to partition it that way
1812:04 - so we will see how this three
1812:06 - steps work and if the element
1812:08 - is greater than pivot
1812:10 - we do nothing we simply
1812:12 - leave the element there and we traverse
1812:14 - i ahead
1812:16 - so this condition is true
1812:18 - i is less than equal to high
1812:20 - so in the if condition we check
1812:22 - whether array of i is less than equal to pivot
1812:24 - or not
1812:26 - so we are simply checking
1812:28 - whether 5 is less than 3 or not
1812:30 - so 5 is greater than 3
1812:32 - so this condition comes out to be false
1812:34 - so when array of i is greater
1812:36 - than pivot which is our
1812:38 - case we simply
1812:40 - leave that element there
1812:42 - and simply traverse i ahead
1812:46 - so i becomes 1
1812:48 - i is still
1812:50 - less than equal to high
1812:52 - now array of i
1812:54 - which is 2
1812:56 - 2 is less than 3
1812:58 - so this condition comes out to be true
1813:00 - and once this condition
1813:02 - comes out to be true we know that
1813:04 - we need to swap the values
1813:06 - at i and jth index
1813:08 - it means we need to swap 5 and 2
1813:10 - so here why we are doing this swap is
1813:12 - we need to partition the array
1813:14 - in such a way that smaller
1813:16 - element should come
1813:18 - at the starting range
1813:20 - then our pivot
1813:22 - should come
1813:24 - and then the element greater
1813:26 - than pivot should come
1813:28 - so when array of i
1813:30 - is less than equal to pivot
1813:32 - we simply throw
1813:34 - the element which is
1813:36 - at ith index to jth index
1813:38 - and take its value
1813:40 - so when we will do this swap
1813:42 - i will go over these steps quickly
1813:44 - 5 will come here and 2 will go there
1813:54 - so 2 came here
1813:56 - and 5 came here
1813:58 - and we know that now we need to increment
1814:00 - j and i both
1814:02 - so why we are incrementing j is because
1814:04 - j has placed one of the
1814:06 - smaller elements here
1814:08 - so this space is occupied
1814:10 - so j moves ahead
1814:12 - so j moves ahead
1814:14 - j becomes 1
1814:20 - and we will simply traverse
1814:22 - i also ahead because
1814:24 - this element is also explored
1814:28 - so i becomes 2
1814:32 - so friends one thing to note here is
1814:34 - irrespective of any of this condition
1814:36 - is met
1814:38 - we simply traverse i ahead in both the cases
1814:40 - so therefore it is
1814:42 - written here
1814:44 - now i is less than equal to i
1814:46 - array of i
1814:48 - which is 0
1814:50 - it is less than 3
1814:52 - so this condition comes out to be true
1814:54 - so we need to
1814:56 - throw 0 to j
1814:58 - and take its value
1815:00 - by doing this swap
1815:02 - so 0 goes here and 5 comes here
1815:11 - so friends here you can see
1815:13 - that as 5 is greater than pivot
1815:15 - the elements which are greater than pivot
1815:17 - they are actually shifting in this direction
1815:19 - but the elements which are lesser than pivot
1815:21 - we are simply throwing it
1815:23 - to j to put it
1815:25 - at that particular index
1815:27 - and j actually holds
1815:29 - one of the greater elements to pivot
1815:31 - because from j to i-1
1815:33 - we have the elements greater than pivot
1815:35 - so j is actually pointing
1815:37 - to one of the greater elements than pivot
1815:40 - and once this swap is done
1815:42 - we are simply taking a greater element
1815:44 - and shifting it ahead
1815:47 - and by doing this swap
1815:49 - we are creating one space here so that
1815:51 - the elements which are lesser than pivot
1815:53 - can come here
1815:55 - so therefore we do the swap
1815:57 - we throw whatever the element
1815:59 - is at the i-th index to j
1816:01 - and take its value
1816:03 - so this spot is filled now properly
1816:05 - so we will increment j
1816:09 - so j becomes true
1816:13 - we will increment i
1816:15 - i becomes 3
1816:19 - this condition is still true
1816:21 - i is less than equal to i
1816:23 - 1 is less than 3
1816:25 - so this condition is true
1816:27 - so we perform these steps again
1816:29 - so we are performing this swap
1816:31 - using the stem variable
1816:33 - so 5 comes here
1816:35 - and 1 goes there
1816:40 - and after filling this position
1816:42 - with a value smaller than pivot
1816:44 - we move j ahead
1816:46 - so j becomes 3
1816:50 - and we have explored
1816:52 - the array till this point
1816:54 - so we move i also ahead
1816:56 - i becomes 4
1816:58 - so friends here you need to
1817:00 - keep watch on these two ranges
1817:02 - from low to j
1817:04 - minus 1
1817:06 - we have the elements smaller than pivot
1817:08 - which is true
1817:10 - from j to i-1
1817:12 - we have elements greater than pivot
1817:14 - so this is j
1817:16 - i-1
1817:18 - so 5 is actually greater than pivot
1817:20 - so this both the conditions are
1817:22 - true when we are doing these steps
1817:24 - now i is still less than equal to i
1817:27 - so this while loop will execute
1817:29 - array of i which is 6
1817:32 - is actually greater than pivot
1817:34 - so this condition comes out to be false
1817:39 - so when array of i is greater than pivot
1817:41 - we know that this element is greater than pivot
1817:44 - and it is at its proper position
1817:47 - so we don't touch this element
1817:49 - we simply move i ahead
1817:52 - like this
1817:54 - so still you can see from j
1817:56 - to i-1
1817:58 - we have elements
1818:00 - greater than pivot
1818:02 - so therefore when we encounter
1818:04 - a value greater than pivot
1818:06 - we simply move ahead
1818:07 - and when we encounter a value
1818:09 - lesser than or equal to pivot
1818:11 - we simply throw it
1818:13 - into this direction so that we can
1818:15 - perform a swap between i and j
1818:17 - now i is actually equal to i
1818:19 - so this
1818:21 - loop will run one more time
1818:23 - and now here you can see
1818:25 - our pivot and array of i
1818:27 - are the same elements
1818:29 - so why we are running it one more time
1818:31 - is because
1818:33 - smaller than or equal to pivot
1818:35 - so we have got a value
1818:37 - equal to pivot so we need to
1818:39 - make it lie in the range of
1818:41 - low to j-1
1818:43 - so j is holding a value
1818:45 - greater than pivot
1818:47 - so we do this swap here
1818:51 - so 5 comes here
1818:55 - and 3 goes there
1818:59 - so it means
1819:01 - our pivot has landed
1819:03 - into its correct position
1819:05 - then we will increment j
1819:07 - j becomes 4
1819:13 - and we will increment i
1819:15 - i becomes 6
1819:19 - so as i has become 6
1819:21 - this value will terminate because
1819:23 - value of i is 5
1819:29 - so from this partition method
1819:31 - does two things
1819:33 - first it returns the
1819:35 - index of the pivot which is
1819:37 - j-1
1819:41 - which is 3
1819:43 - and second it takes in the original
1819:45 - array and reorders it
1819:47 - in such a way that all the elements
1819:49 - smaller than pivot are on the
1819:51 - left side and all the elements
1819:53 - greater than pivot are on the other side
1819:55 - so when this method will
1819:57 - end we will return
1819:59 - j-1 which is the index
1820:01 - of this pivot from where
1820:03 - this partition has happened
1820:05 - so the execution point
1820:07 - will reach to this sort method
1820:09 - and the array has been reordered
1820:11 - we have left this sort method
1820:13 - at line number 3 so we will start
1820:15 - from line number 3
1820:17 - this partition method has
1820:19 - written a value of p
1820:21 - which is the index of pivot
1820:23 - which was 3 so value
1820:25 - of p will be 3
1820:27 - like this here
1820:29 - so this is
1820:31 - what we saw in the partition
1820:33 - that all elements
1820:35 - smaller than pivot are on this
1820:37 - side and greater than pivot
1820:39 - are on this side
1820:41 - so friends here you can see
1820:43 - that if i sort this array directly
1820:45 - the sorted array would
1820:47 - look like 0, 1,
1820:49 - 2, 3,
1820:51 - 5 and 6
1820:53 - and here you can see that
1820:55 - once this partition is done
1820:57 - when we are putting all the smaller
1820:59 - elements before the pivot
1821:01 - and all the greater elements after
1821:03 - the pivot so when we
1821:05 - sort this array completely
1821:07 - you can see that the index of the pivot
1821:09 - remains the same
1821:11 - 3 is at index 3
1821:13 - and after sort also
1821:15 - it will be at the index 3
1821:17 - because here it's 0, 1, 2,
1821:19 - 3, 4,
1821:21 - 5 index so it remains
1821:23 - at the 3rd index only
1821:25 - so this is one important step in the partitioning
1821:27 - that after the partition pivot
1821:29 - is actually at its sorted
1821:31 - position
1821:39 - so now what we do is we don't touch
1821:41 - this pivot because
1821:43 - it lies at its proper
1821:45 - sorted position
1821:47 - now our task is to
1821:49 - perform this pivot
1821:51 - selection and partitioning
1821:53 - on the left side of the pivot
1821:55 - and on the right side
1821:57 - of the pivot
1821:59 - and dead to recursively
1822:01 - so this sort method will keep on
1822:03 - calling itself
1822:05 - till the base case is reached
1822:07 - so now we call the sort
1822:09 - method again and this time
1822:11 - we only take
1822:13 - these 3 elements
1822:15 - and we try to sort them
1822:17 - so here we are calling this sort method
1822:19 - we are passing in this array
1822:21 - low value will be 0 only
1822:23 - high value will
1822:25 - become p-1 because we are
1822:27 - calling this sort method with p-1
1822:29 - it means we are
1822:31 - taking in this range
1822:33 - this is p
1822:35 - so this will be p-1
1822:37 - so when this sort method will again
1822:39 - gets called our high will become
1822:41 - p-1
1822:43 - so as we are leaving this sort method
1822:45 - and we are calling this sort method
1822:47 - so first we will update the line number
1822:49 - here and we are storing
1822:51 - the state of the low, p
1822:53 - and high so we update line
1822:55 - number 4 here
1822:57 - and we leave this sort method and again
1822:59 - call the sort method
1823:05 - so this sort method will be called
1823:07 - with low as 0
1823:09 - and high as
1823:11 - p-1 so this was
1823:13 - our p previously
1823:15 - p-1 which is 2
1823:21 - so here now we are doing the
1823:23 - sort from low to p-1
1823:25 - so this is the
1823:27 - range of our
1823:29 - array which we need to sort now
1823:33 - so high becomes 2
1823:37 - p-1 which is 2
1823:39 - so our new high becomes 2
1823:41 - low is
1823:43 - less than high
1823:47 - so now we will partition only
1823:49 - the left side of the pivot
1823:51 - which is these 3 elements
1823:53 - so we will leave at line number 3
1823:55 - this sort method
1823:59 - so this partition method will be executed
1824:01 - again and now we are not
1824:03 - taking in complete array
1824:05 - we are taking the array from
1824:07 - range low to high which is 0
1824:09 - to 2 index
1824:11 - like this so this partition
1824:13 - method will only touch these
1824:15 - 3 elements
1824:17 - so first we select the pivot
1824:19 - which is the last element
1824:21 - of this range
1824:23 - so array of high will become
1824:25 - our pivot so 1 becomes our pivot
1824:31 - we start the partitioning
1824:33 - with a value of i and j
1824:35 - low which is 0
1824:41 - and as we have already discussed
1824:43 - how this algorithm works
1824:45 - we will go over this quickly
1824:47 - we need to keep
1824:49 - these ranges into mind
1824:51 - and these 2 conditions
1824:53 - into mind
1824:55 - so i is less than equal to high
1824:57 - this value will execute
1824:59 - array of i which is 2
1825:01 - it is greater than pivot
1825:03 - so we do nothing, we simply move ahead
1825:05 - we do
1825:09 - i++
1825:11 - i becomes 1
1825:15 - i is still less than high
1825:19 - now array of i which is 0
1825:21 - it is less than equal to pivot
1825:23 - it means we need to throw it
1825:25 - to j and take its value
1825:27 - so we do this
1825:29 - why i swap
1825:31 - so 2 comes here and 0 goes there
1825:35 - so 0 goes there
1825:37 - and as j is filled
1825:39 - this position properly
1825:41 - we will increment j
1825:43 - j becomes 1
1825:47 - we will also increment i
1825:49 - i becomes 2
1825:53 - i is actually equal to i
1825:55 - so this loop will run one more time
1825:57 - to put this
1825:59 - i is actually equal to i
1826:01 - so this loop will run one more time
1826:03 - to put this pivot
1826:05 - at its correct position
1826:07 - now 1 is equal to pivot
1826:09 - so we do this
1826:11 - swap again
1826:15 - so 2 comes here and 1 goes there
1826:23 - then we increment j
1826:25 - j becomes 2
1826:29 - and we increment i
1826:31 - so i becomes 3
1826:35 - and this while loop will terminate
1826:37 - because value of i is 2
1826:39 - and j is 3
1826:41 - so 3 is not less than
1826:43 - equal to 2
1826:45 - so here you can see
1826:47 - that now we need to return the
1826:49 - index of the pivot which is at
1826:51 - j-1 which is this
1826:55 - and here you can see
1826:57 - that when we did partition
1826:59 - of these 3 elements
1827:01 - these are actually elements which are
1827:03 - lesser than pivot which is 1
1827:05 - and these are the elements which are greater than pivot
1827:07 - which is 2
1827:09 - so currently it has only 1 1 element
1827:11 - so we have reordered
1827:13 - the array and we are
1827:15 - returning the pivot as 1
1827:19 - so execution point will reach here
1827:21 - we know that we have
1827:23 - left at line number 3
1827:25 - so we start from here
1827:27 - this method returned
1827:29 - the value of pivot
1827:31 - as 1
1827:33 - so p becomes 1
1827:37 - like this
1827:41 - so friends we know that after doing this partition
1827:45 - we recursively call the sort method again
1827:47 - and this time we go
1827:49 - from low to p-1
1827:51 - which is the left side
1827:53 - and then we go
1827:55 - from p plus 1 to high
1827:57 - which is on the right side
1827:59 - so first we go on the
1828:01 - left side so here you can see
1828:03 - this recursion is happening
1828:05 - till the array is getting
1828:07 - divided so now when we will
1828:09 - leave this sort method we will first
1828:11 - update the line number here which is
1828:13 - 4 and then we will call
1828:15 - this sort method where low
1828:17 - will be 0 and
1828:19 - the value of high we pass is p-1
1828:21 - so p-1
1828:23 - minus 1 will be 0
1828:25 - so this value will go to
1828:27 - high and this value will
1828:29 - go to low in the next sort
1828:31 - method so we have
1828:33 - updated the line number
1828:35 - and we have called this
1828:37 - sort method again
1828:39 - so it looks like this
1828:41 - that this low which was
1828:43 - 0 is 0
1828:45 - p-1 which is
1828:47 - 0 index
1828:49 - so high becomes 0
1828:53 - so it looks like this
1829:01 - so friends here you can see now low
1829:03 - and high are pointing to the same
1829:05 - index it means
1829:07 - that we have left with only one
1829:09 - element and we can't divide
1829:11 - this array further down or partition
1829:13 - this array further down because
1829:15 - we have only left with one element
1829:17 - so therefore we have reached our
1829:19 - base case
1829:22 - so low is equal to
1829:24 - high so this sort
1829:26 - method will end
1829:28 - and this sort method will be removed from
1829:30 - the call stack and the execution
1829:32 - point will reach here back
1829:35 - so it looks like this
1829:37 - this method
1829:39 - was removed from the call stack
1829:41 - and execution point reached here
1829:43 - we know that we left this
1829:45 - sort method at line number 4
1829:47 - so we start from line number 4
1829:49 - and when we had left this sort method
1829:51 - low was at 0
1829:53 - p was at 1
1829:55 - high was at 2
1829:57 - so we position them back to their
1829:59 - respective indexes
1830:01 - high was at 2
1830:03 - p was at 1
1830:06 - and here you can see
1830:08 - that we are done with this left part now
1830:13 - so this sort method is done
1830:16 - and now we go on the right side
1830:18 - so we call this sort method again
1830:20 - now this time we are
1830:22 - passing the value of low as
1830:24 - p plus 1
1830:26 - so p is 1
1830:28 - and p plus 1 is 2
1830:30 - so when we go on the right side
1830:32 - the value of low changes
1830:34 - and when we go on the left side
1830:36 - the value of high changes
1830:38 - here you can see
1830:40 - if we are going on the left
1830:42 - value of high changes
1830:44 - if we are going on the right
1830:46 - value of low changes
1830:48 - so now we will leave this sort method
1830:50 - we first update the line number here
1830:52 - that we are leaving at
1830:54 - line number 5
1830:56 - and we are calling this sort method
1830:58 - with p plus 1 as our low
1831:00 - which is 2
1831:02 - and high as 2
1831:06 - so there will be one more method on the call stack
1831:10 - with low as 2
1831:12 - and high as 2
1831:14 - so something like this
1831:20 - moving ahead
1831:22 - here you can see that now we are actually
1831:24 - partitioning
1831:26 - the elements which are greater than pivot
1831:28 - which is only this element
1831:30 - 2
1831:32 - which is only one element
1831:34 - as low is equal to high
1831:36 - it means we have reached our base case
1831:38 - and we are telling
1831:40 - to this sort method that please stop the recursion
1831:43 - so this method will be removed from the call stack
1831:45 - because we can't divide 2 further down
1831:50 - and the execution point will reach here
1831:52 - so when this sort method was left
1831:54 - we are left at line number 5
1831:56 - so we start from line number 5
1831:58 - and at that moment
1832:00 - value of low, p and high
1832:02 - as 0, 1 and 2
1832:04 - so we give them their respective
1832:06 - indexes
1832:12 - so it was like this
1832:14 - and now after executing line number 5
1832:16 - there are no more lines
1832:18 - left to be traversed
1832:20 - so this sort method will also end
1832:22 - and the execution point will reach to this sort method
1832:24 - because this sort method
1832:26 - was actually being called by this sort method
1832:30 - so this method will be removed from the call stack
1832:35 - and when we had left this sort method
1832:37 - we had left at line number 4
1832:39 - so we start from line number 4
1832:42 - and at that moment value of low was 0
1832:44 - p was 3
1832:45 - and high was 5
1832:47 - so we give them their respective
1832:49 - indexes
1832:56 - so this was the state
1832:58 - when we had left this sort method
1833:00 - so here
1833:01 - this sort method is done
1833:03 - it means
1833:04 - so it means that when we had done our first partition
1833:06 - the pivot came out to be index 3
1833:08 - and in this sort method
1833:10 - we went to the left side of the pivot
1833:13 - and we did the sorting
1833:15 - and here you can see these 3 elements are sorted
1833:19 - so we had done with this method
1833:21 - now our task is to go on the right side
1833:24 - call sort method again
1833:26 - recursively
1833:28 - we pass the value of
1833:30 - low as p plus 1
1833:32 - because we need to now go in this direction
1833:35 - and high remains the same
1833:41 - so here we are leaving this sort method
1833:43 - we will update line number here which is 5
1833:45 - and we are calling this sort method
1833:49 - passing in low value as p plus 1
1833:51 - which is 4
1833:58 - so it looks like this
1834:00 - low becomes p plus 1 which is 4
1834:04 - so it looks like this
1834:10 - low is less than high
1834:12 - it means we have 2 elements
1834:14 - it means we can divide this
1834:16 - 2 elements further down
1834:19 - so we call the partition method again
1834:22 - we pass in the range from low to high
1834:25 - we are telling we need to partition the array
1834:27 - of these 2 elements only
1834:30 - so this is our range
1834:32 - so when we are calling this partition method
1834:34 - we first update the line number here
1834:37 - and we have stored the state already
1834:39 - in low and high
1834:41 - so line number 3 comes here
1834:43 - we leave this sort method
1834:47 - we call this partition
1834:50 - we need to partition from
1834:52 - low to high
1834:55 - that is in this range
1834:57 - we are not touching this side
1834:59 - because we have already
1835:01 - done the sorting and partitioning of these
1835:03 - elements
1835:05 - so we are now only touching these 2 elements
1835:08 - array of high will be our pivot
1835:10 - so first we are doing the pivot selection
1835:13 - so 5 becomes our pivot
1835:17 - we create 2 pointers
1835:19 - i and j
1835:20 - which start from 4th and next
1835:27 - and then we perform the same step
1835:29 - which we have discussed already
1835:31 - we provide a while loop
1835:33 - and the condition is i should be less than equal to high
1835:35 - we need to keep 4 things in mind
1835:39 - these 2 ranges
1835:41 - and these 2 conditions
1835:43 - so array of i
1835:45 - which is 6
1835:47 - it is greater than pivot
1835:49 - so we simply traverse ahead
1835:51 - we do nothing
1835:53 - we do i++
1835:55 - i becomes 5
1836:01 - i is equal to
1836:03 - high so this condition is true
1836:07 - now array of i is 5
1836:09 - and 5 is our pivot as well
1836:11 - so therefore when array of i is equal to pivot
1836:13 - we need to throw
1836:15 - whatever value is at
1836:17 - ith index to j and take its value
1836:19 - so we first perform the swap
1836:24 - so 6 comes here and 5 goes there
1836:34 - we have placed 5 at its correct position
1836:36 - which is our pivot position
1836:38 - so we increment j
1836:45 - and then we increment i
1836:50 - so now this while loop condition comes out to be false
1836:53 - because value of i is 6
1836:55 - and high is 5
1837:00 - so we simply return
1837:02 - the pivot index which is at j-1
1837:04 - so j-1
1837:06 - which is the 4th index
1837:08 - so we return 4 from this partition method
1837:10 - and we have also
1837:12 - reordered the array in such a way that
1837:14 - all the elements lesser than pivot
1837:16 - are on its left side
1837:18 - so currently
1837:20 - there are no elements which are lesser than pivot
1837:22 - because we are not touching
1837:24 - this
1837:26 - side
1837:28 - we are touching from low and high
1837:30 - so from low to j-1
1837:32 - low to j-1
1837:34 - we have elements smaller than or equal to pivot
1837:36 - which is true
1837:38 - and from j
1837:40 - to i which is 6
1837:42 - minus 1 which is only this element
1837:44 - having
1837:46 - a value greater than pivot
1837:48 - so we simply return index 4 from here
1837:52 - so the execution point will reach here
1837:54 - we had left
1837:56 - this sort method at line number 3
1837:58 - so we start it from line number 3
1838:00 - the partition method
1838:02 - return the value as 4
1838:10 - we have placed 4 here
1838:12 - so p becomes 4
1838:14 - now we go
1838:16 - on the left side of the pivot
1838:18 - from low to p-1
1838:20 - so here you can see
1838:22 - low and p are pointing to the same
1838:24 - element
1838:26 - so when we call this sort method
1838:28 - we first update the line number
1838:30 - which is 4
1838:32 - and then
1838:34 - there will be one sort method
1838:36 - on the call stack
1838:44 - so here when we had left this sort method
1838:46 - we called
1838:48 - this sort method from low to
1838:50 - p-1
1838:52 - so when we did p-1
1838:56 - our high became
1838:58 - 3 so here you can see
1839:00 - that low is actually greater
1839:02 - than 3 so it means we have reached
1839:04 - our base case and
1839:06 - which makes sense because there are no elements
1839:08 - on the left side of the pivot
1839:10 - to be divided further down
1839:12 - so we simply return from
1839:14 - this method
1839:16 - and the execution point
1839:18 - will reach here we had left at
1839:20 - line number 4 so we start
1839:22 - from line number 4
1839:25 - and low p and 5
1839:27 - had values as 4, 4, 5
1839:29 - so we give them their respective
1839:31 - values
1839:34 - 4, 4
1839:36 - and 5
1839:38 - and now we go on the right side
1839:40 - of the pivot which is at
1839:42 - p plus 1 to high
1839:44 - so p plus 1 is
1839:46 - index 5
1839:48 - so first we update the line number here
1839:50 - because we are leaving
1839:52 - this sort method
1839:54 - and then we are calling
1839:56 - sort so there will be one more method
1839:58 - on the call stack
1840:02 - with p plus 1 as our
1840:04 - new low
1840:06 - which is 5
1840:10 - and high remains 5 only
1840:14 - so it looks like this
1840:18 - so here we can't divide
1840:21 - this 6 further down
1840:23 - it means we have reached our base case
1840:25 - low is actually
1840:27 - equal to high so this if block
1840:29 - will not be executed
1840:31 - so the condition in if block
1840:33 - comes out to be false and we simply
1840:35 - leave this method
1840:37 - so this method will be removed from
1840:39 - the call stack
1840:41 - and the execution point will reach here
1840:43 - we had left this sort
1840:45 - method at line number 5 so we start
1840:47 - from line number 5
1840:49 - and at that moment low
1840:51 - p and high were at 4 4
1840:53 - and 5th index
1840:55 - so we reassign them their indexes
1841:01 - like this
1841:03 - and as there are no more steps
1841:05 - left to traverse for this sort method
1841:07 - so this sort method will also
1841:09 - be removed from the call stack
1841:11 - and the execution
1841:13 - point will reach here
1841:15 - so when we had left this sort method
1841:17 - we had left at line number 5
1841:19 - so we start from line number 5
1841:21 - and at that moment low
1841:23 - p and high were at 0
1841:25 - 3 and 5th index
1841:27 - like this
1841:29 - and also friend zero can see
1841:31 - that after line number 5
1841:33 - we have no statement to execute
1841:35 - so this sort method will also
1841:37 - be removed from the call stack
1841:41 - so friend zero can see
1841:43 - after every method got removed
1841:45 - from the call stack
1841:47 - we have actually performed the
1841:49 - sorting of the array
1841:51 - we have used the quick sort
1841:55 - and we have sorted the array
1841:57 - so friend this was all about the step by step
1841:59 - demonstration of quick sort algorithm
1842:01 - where this sort method
1842:03 - recursively calls this sort
1842:05 - method one is when it
1842:07 - goes on the left side of the
1842:09 - pivot which is the smaller elements
1842:11 - and one when it goes on the right
1842:13 - side of the pivot which are
1842:15 - the greater elements to pivot
1842:17 - in this partition method we do the pivot
1842:19 - selection and reordering of
1842:21 - the array in such a way that
1842:25 - smaller
1842:27 - or equal elements
1842:29 - are on the left side
1842:31 - then our pivot comes
1842:33 - and then
1842:35 - the elements
1842:37 - greater than pivot comes
1842:39 - so this
1842:41 - steps we do recursively
1842:43 - till all the elements are sorted
1842:45 - so friend this was all about
1842:47 - quick sort algorithm I hope you must have
1842:49 - liked this video in case if you
1842:51 - are new to my channel then please subscribe
1842:53 - to my channel and click the bell icon
1842:55 - so that you never miss any update
1842:57 - thanks have a nice day
1843:01 - hello everyone so in this
1843:03 - video we will be discussing a coding
1843:05 - problem squares of a sorted
1843:07 - array in java
1843:09 - so if you see
1843:11 - in this problem we are
1843:13 - given an integer array which is
1843:15 - sorted in ascending order so here
1843:17 - you can see this is the input
1843:19 - minus four minus one zero
1843:21 - three and ten so
1843:23 - it's sorted in ascending order
1843:25 - now what we need to do is
1843:27 - we need to return an array of integers
1843:29 - such that
1843:31 - we need to square them
1843:33 - and whatever is the outcome
1843:35 - we need to simply return that
1843:37 - array so for example the output
1843:39 - would be zero one nine
1843:41 - sixteen and hundred
1843:43 - so how this output came is
1843:45 - after squaring each
1843:47 - and every number you will see
1843:49 - the array will become minus four
1843:51 - into
1843:53 - minus four will give us sixteen
1843:55 - minus one into
1843:57 - minus one will give one
1843:59 - zero into zero will give zero
1844:01 - three into three
1844:03 - will give nine
1844:05 - ten into ten
1844:07 - will give hundred so this
1844:09 - is the array which will
1844:11 - be generated after we
1844:13 - square each and every element
1844:15 - now the complexity part is
1844:17 - we need to sort this
1844:19 - array and return from
1844:21 - the method so after we sort
1844:23 - this part it will become zero
1844:25 - one nine sixteen hundred
1844:27 - so friends the brute force
1844:29 - approach would be we simply
1844:31 - square the array so
1844:33 - it will become like this sixteen one
1844:35 - zero nine hundred
1844:37 - and then we again use arrays
1844:39 - dot sort we pass in the
1844:41 - array and we get this result array
1844:43 - but this is a brute force approach
1844:45 - which is not very efficient
1844:47 - so if you see
1844:49 - at the last time if we sort the array
1844:51 - the time complexity will be
1844:53 - n log n
1844:55 - so which is not good we need to
1844:57 - see that whether can we
1844:59 - do it in o of n
1845:01 - because this operations
1845:03 - are constant and if
1845:05 - we iterate each and every
1845:07 - element once we get
1845:09 - o of n time complexity
1845:11 - so let's see the
1845:13 - algorithm and its demonstration
1845:15 - step by step
1845:17 - so here is the algorithm
1845:19 - so here you can see it is only taking one
1845:21 - for loop and we are not
1845:23 - sorting the array anywhere
1845:25 - so let's see the demonstration
1845:27 - of this algorithm step by step
1845:29 - but before we start
1845:31 - in case if you are new to my channel
1845:33 - then please subscribe to my channel
1845:35 - and click the bell icon
1845:37 - so that you never miss any update
1845:41 - so we will call this method
1845:43 - we pass in the array
1845:45 - so let's say if we take
1845:47 - this array minus four
1845:49 - minus one zero three and ten
1845:51 - so the length of the array
1845:53 - is five
1845:55 - so at the start
1845:57 - we simply calculate the length
1845:59 - of the array by doing array.length
1846:01 - and we store it
1846:03 - in integer variable n
1846:05 - so n will become five
1846:09 - now as you want to square each and
1846:11 - every element and return
1846:13 - this array all together
1846:15 - in a sorted form
1846:17 - we will first create our result array
1846:19 - so this result array
1846:21 - will store all these elements
1846:23 - squares in sorted form
1846:27 - so we will create this new array
1846:29 - we pass in the length as five
1846:31 - so it will look something like this
1846:33 - so these are the default values
1846:35 - of the integer array
1846:39 - so here the idea is we take
1846:45 - two pointers
1846:47 - i and j
1846:49 - so i will start from zero
1846:53 - and j will start from
1846:55 - n minus one
1846:57 - which is the last index
1847:01 - so it would look something like this
1847:03 - that i is pointing to zero index
1847:05 - and j is pointing to
1847:07 - the last index which is four
1847:11 - so here if you see when we do the
1847:13 - squares of any negative number
1847:15 - we usually get the result in
1847:17 - positive side of the numbers
1847:19 - so therefore this problem becomes complex
1847:21 - because if suppose
1847:23 - our array had only positive numbers
1847:25 - then this problem would
1847:27 - have been straight forward
1847:29 - we just do the squares
1847:31 - and as the array is already sorted
1847:33 - the squares would have been in sorted form
1847:35 - but here as we are including these negative numbers
1847:37 - here you can see
1847:39 - three is greater than minus four
1847:41 - but if we take the squares
1847:43 - of both the numbers
1847:45 - minus four into minus four
1847:47 - we will get sixteen
1847:49 - and three into three
1847:51 - we will get nine
1847:53 - so before doing squares
1847:55 - minus four is less than three
1847:57 - but after doing square
1847:59 - this number sixteen
1848:01 - is actually getting greater than nine
1848:03 - so it means
1848:05 - when we will return the result
1848:07 - of the squares in sorted form
1848:09 - this minus four
1848:11 - square will come
1848:13 - after three squares
1848:15 - because nine
1848:17 - will come before sixteen
1848:19 - this algorithm becomes very tricky
1848:21 - to find the exact position
1848:23 - of these negative numbers
1848:25 - among the positive numbers
1848:27 - so what we do is
1848:29 - we try to fill this result array
1848:31 - from the end
1848:33 - so here we create
1848:35 - a for loop
1848:37 - where k starts from n minus one
1848:39 - so k is starting
1848:41 - from four because value
1848:43 - of n is five
1848:45 - so it means we will try
1848:47 - to fill this result array
1848:49 - from the last
1848:51 - why we are doing it from the last because
1848:53 - this is the extreme point
1848:55 - where we are sure that what value will come
1848:57 - so for example
1848:59 - this array sorted
1849:01 - so here will be the smallest number
1849:03 - and can be negative
1849:05 - and here will be the largest number
1849:07 - so if we do
1849:09 - square of these both numbers
1849:11 - and we try to compare them
1849:13 - we will get one value for sure
1849:15 - which will be greater than overall all the numbers
1849:17 - squares
1849:19 - and we can simply put it here
1849:21 - so let's say for example
1849:23 - if we take minus four and ten
1849:27 - so minus four into minus four
1849:29 - will give sixteen
1849:31 - ten into ten
1849:33 - will give hundred
1849:35 - so if we compare sixteen with hundred
1849:37 - we are very much sure that hundred is
1849:39 - greater than sixteen
1849:41 - and any number in the array
1849:43 - will get bigger than hundred
1849:45 - because we are actually comparing
1849:47 - the extremities of this array
1849:49 - so here let's say if it
1849:51 - would have been minus eleven
1849:53 - if we would have done the square
1849:55 - we would have got one twenty
1849:57 - one and ten square is hundred
1849:59 - so we are very much sure that
1850:01 - if we are comparing the extremities
1850:03 - we will get
1850:05 - a square which will be the largest
1850:07 - among all the numbers
1850:09 - and we can safely put it in the
1850:11 - last index
1850:13 - so this idea will be more clear when we will
1850:15 - actually see the demonstration of this
1850:17 - algorithm
1850:19 - so I will just remove this
1850:25 - so here k's value is four
1850:27 - and it is greater than
1850:29 - or equal to zero
1850:31 - so this condition is true
1850:33 - so here you can see
1850:35 - why we created these two pointers
1850:37 - and we pointed at the extremities
1850:39 - because as the array is sorted
1850:41 - in ascending order
1850:43 - the element square
1850:45 - won't be necessarily sorted
1850:47 - in ascending order
1850:49 - so here what we do is
1850:51 - we take the absolute value
1850:53 - of the value at ith index
1850:55 - and the absolute value
1850:57 - at the jth index
1850:59 - so what this absolute method returns is
1851:01 - let's say if the value is minus four
1851:03 - it will give us four
1851:05 - let's say if the value is minus one
1851:07 - let's say if the value is ten
1851:09 - it will give us ten
1851:11 - so it gives the absolute value without
1851:13 - the sign of it
1851:15 - so here we are actually comparing
1851:17 - the numbers
1851:19 - without their sign
1851:21 - and why we are doing it because
1851:23 - this negative sign
1851:25 - when we do square
1851:27 - this becomes minus
1851:29 - into minus becomes positive
1851:31 - and we actually do the square of the number
1851:33 - which will give us sixteen
1851:35 - so it's plus sixteen
1851:37 - so this minus doesn't play
1851:39 - any role in the square part
1851:41 - but as these numbers are sorted
1851:43 - and we can encounter
1851:45 - negative values as well
1851:47 - so therefore we are comparing the absolute
1851:49 - values of the
1851:51 - start and the end
1851:53 - so here if you see
1851:55 - the mat.absolute value of i
1851:57 - will be four
1851:59 - and j will be ten
1852:01 - is not greater than
1852:03 - ten so this condition comes out to be false
1852:07 - so the else part will be executed
1852:09 - so this actually
1852:11 - signifies that we
1852:13 - can safely take ten
1852:15 - do its square and place it
1852:17 - into the end of the result
1852:19 - array because we are very much sure
1852:21 - that this value can
1852:23 - be safely placed here because we have
1852:25 - compared it with the extreme
1852:27 - left value
1852:29 - so here we do
1852:31 - ten into ten which is
1852:33 - hundred
1852:35 - and we simply put it into the
1852:37 - result array at kth index
1852:41 - now after placing it
1852:43 - we know that we have used this
1852:45 - value
1852:47 - so we will simply decrement j
1852:49 - so j becomes three
1852:53 - now we will simply decrement
1852:55 - k because we have used this place
1852:57 - and k
1852:59 - is still greater than
1853:01 - or equal to zero
1853:05 - so friends here you can see the importance
1853:07 - of doing mat.absolute
1853:09 - we are actually discarding this
1853:11 - negative signs and
1853:13 - as the array sorted we are
1853:15 - comparing the extremities of
1853:17 - i and jth index and
1853:19 - whichever will be the greater number
1853:21 - that square will
1853:23 - come directly here
1853:25 - so here mat.absolute of
1853:27 - array of i will be
1853:29 - four
1853:31 - and mat.absolute of array
1853:33 - of j will be three only
1853:35 - so four is greater
1853:37 - than three so this condition
1853:39 - comes out to be true
1853:41 - so we simply assign
1853:43 - the square of
1853:45 - this value minus four
1853:47 - into the result
1853:49 - array at kth index
1853:51 - so minus four into
1853:53 - minus four will give us sixteen
1853:55 - so we will simply assign sixteen here
1853:59 - and as we have used this
1854:01 - minus four will
1854:03 - increment i
1854:07 - so i will point to
1854:09 - index one
1854:13 - we will decrement k because
1854:15 - we have used this spot
1854:19 - k is greater than or equal to zero
1854:23 - now we will do mat.absolute of
1854:25 - minus one which will give us one
1854:27 - and mat.absolute of
1854:31 - three which will give us three
1854:33 - so this condition comes
1854:35 - out to be false because one is
1854:37 - not greater than three
1854:39 - so we can safely
1854:41 - put three's square
1854:43 - here which will be nine
1854:49 - we have used this spot
1854:52 - so we will decrement j now
1854:55 - so j becomes two
1854:59 - we will decrement k
1855:01 - because we have
1855:03 - filled this spot
1855:05 - k becomes one
1855:07 - and one is greater than
1855:09 - or equal to zero
1855:13 - now we do mat.absolute of
1855:15 - minus one which will give us one
1855:17 - and mat.absolute of
1855:19 - zero which will
1855:21 - give us zero so one is greater
1855:23 - than zero
1855:25 - so this condition comes out to be true
1855:27 - and what we do is
1855:29 - we simply assign
1855:31 - minus one into minus one
1855:33 - which is one
1855:35 - into this spot
1855:41 - we have used this spot
1855:43 - so we will increment i
1855:46 - i becomes two
1855:49 - we will decrement
1855:51 - k
1855:53 - because we have used this spot
1855:57 - so k is equal to zero
1855:59 - so this condition still comes out to be true
1856:03 - and here we are left
1856:05 - with only one element
1856:07 - so zero is not
1856:09 - greater than zero
1856:11 - because mat.absolute value of zero
1856:13 - is zero
1856:15 - so this if-lock condition comes out
1856:17 - to be false
1856:19 - and we simply assign
1856:21 - zero into zero
1856:23 - which is zero
1856:25 - to this spot
1856:27 - so it becomes zero
1856:29 - now we have used this spot
1856:31 - so we will
1856:33 - decrease j
1856:35 - so j becomes one
1856:37 - which we will point here
1856:39 - we will decrement k
1856:41 - because we have used this spot
1856:43 - so k becomes minus one
1856:45 - it means
1856:47 - it has gone
1856:49 - outside of the boundaries of the array
1856:51 - therefore this condition
1856:53 - will come out to be false
1856:57 - and here you can see
1856:59 - at the end
1857:01 - we will simply return the result
1857:03 - so this is the result
1857:05 - where we have squared each number
1857:07 - and after squaring each number
1857:09 - you can see the result array
1857:11 - is still sorted
1857:13 - and we have used this algorithm
1857:15 - without using
1857:17 - arrays.sort
1857:23 - so the time complexity of this algorithm
1857:25 - is O of n
1857:27 - so we will simply
1857:29 - return the result
1857:31 - so friends I hope you must have liked this video
1857:33 - in case if you are new to
1857:35 - my channel then please subscribe to my channel
1857:37 - and click the bell icon
1857:39 - so that you never miss any update
1857:41 - thanks have a nice day
1857:45 - hello everyone
1857:47 - so in our previous video we saw a problem
1857:49 - squares of a sorted array
1857:51 - we saw the animation of the algorithm
1857:53 - step by step
1857:55 - so in this video we will actually code the algorithm
1857:57 - and we will test its working
1857:59 - in the main method
1858:01 - so before we start
1858:03 - in case if you are new to my channel
1858:05 - then please subscribe to my channel
1858:07 - and click the bell icon so that you never miss any update
1858:11 - so here in our array util class
1858:17 - I will be creating one method as public
1858:21 - static
1858:23 - we will give a name to this method as sorted
1858:27 - squares
1858:31 - so this method will take in an array
1858:36 - and what this method will do is
1858:38 - it will do the square of each and every element of the array
1858:42 - and whatever the array it will return
1858:44 - that array will also be sorted
1858:48 - and this array is already sorted
1858:51 - so in our animation video we saw that
1858:53 - we can solve this problem using
1858:55 - two pointer technique
1859:01 - so here first
1859:03 - we will create an integer variable n
1859:07 - this will store the length of the array
1859:11 - then we will create
1859:13 - one pointer i
1859:15 - which will start from the
1859:17 - zero index
1859:19 - and one pointer j
1859:21 - which will start from the last index
1859:23 - so the last index will point to array.length
1859:26 - minus one
1859:28 - now as we want to return a sorted array
1859:30 - so we will create a result array
1859:34 - the size will be
1859:36 - the same
1859:38 - as our input array
1859:41 - now here what we will do is
1859:43 - we will provide a for loop
1859:47 - and inside that for loop
1859:49 - we will try to fill this result array
1859:51 - from the end
1859:53 - so here
1859:55 - we will start from k equals to n minus one
1859:59 - because n minus one is the last index
1860:02 - and it will go to
1860:05 - when k is greater than or equal to zero
1860:08 - k minus minus
1860:10 - so from k and minus one
1860:12 - it will go to zero
1860:14 - and with each iteration it will get
1860:16 - decrement by one position
1860:18 - so friends here you can see
1860:20 - that this array is actually sorted array
1860:23 - so if i take this example
1860:25 - so here you can see that this array can contain
1860:33 - negative values
1860:35 - so if the array contain only positive values
1860:38 - this problem would have been very easy
1860:40 - we would have just done the
1860:42 - square of each and every number
1860:44 - and simply place it into the
1860:46 - result array at their respective indexes
1860:49 - but as this array contains the negative elements also
1860:52 - so here for example
1860:54 - let's say it was given something like this
1860:57 - so we can't directly do the square of
1860:59 - each and every number
1861:01 - and put it into the respective position
1861:03 - because this will result something like this
1861:06 - minus four into minus four will give sixteen
1861:09 - minus one into minus one will give one
1861:12 - zero into zero will give zero
1861:15 - and three into three will give nine
1861:17 - so here you can see we can't directly
1861:19 - just square the numbers
1861:21 - and put it into the respective position
1861:23 - because this array is not sorted
1861:26 - and we want to return the sorted array
1861:29 - so one thing is
1861:31 - we just square and at the end we just do the
1861:33 - sorting explicitly and return
1861:36 - but that would be a very bad algorithm
1861:39 - time complexity wise because we are actually using
1861:42 - the sorting technique
1861:44 - so in this algorithm
1861:46 - using this for loop
1861:48 - we will try to sort this array properly so that
1861:51 - it would look something like this
1861:53 - that zero should come here then one
1861:56 - then nine
1861:58 - and then sixteen
1862:00 - so usually
1862:02 - in order to do that what we can do is
1862:04 - we try to compare the absolute
1862:07 - extreme values
1862:09 - so whichever value is greater we do their square
1862:12 - and we simply put it into the last index
1862:15 - and similarly we go on doing like this
1862:18 - so for example
1862:20 - if we do the absolute value of minus four we will get four
1862:23 - and we see that four is greater than three
1862:26 - so it means if we do four into four
1862:29 - or minus four into minus four we will get sixteen
1862:32 - and we can safely place sixteen at the end
1862:35 - and after filling this position we just come to this position
1862:38 - and after using this
1862:40 - minus four we just shift here
1862:43 - so in the next iteration
1862:45 - we simply compare the absolute value of
1862:47 - minus one which will give us one
1862:49 - and we will compare one with three
1862:51 - and we see that three is greater than one
1862:53 - so we simply do three square
1862:56 - and we put nine at this position
1862:59 - and similarly we keep on doing like this
1863:02 - so here the main idea is
1863:04 - to take the absolute values
1863:06 - of the extreme values
1863:08 - try to compare them
1863:10 - and whichever is the greater
1863:12 - do their square
1863:14 - and put it into the result array
1863:17 - at the index which is starting from
1863:19 - the last index
1863:21 - which is n minus one
1863:23 - so here we provide a condition as
1863:25 - if
1863:28 - math dot absolute
1863:30 - of array
1863:32 - of i
1863:34 - so we have created these two pointers
1863:36 - one would be at the start
1863:38 - and other would be at the end
1863:40 - if it is greater than
1863:44 - math dot absolute
1863:47 - array of j
1863:49 - so what we can do is
1863:51 - if the absolute value of
1863:53 - i-th index is greater than
1863:55 - absolute value of j-th index
1863:57 - then in our result
1863:59 - at k-th index
1864:01 - we will assign
1864:05 - array of i
1864:07 - into
1864:09 - array of i
1864:12 - so we are doing the square
1864:14 - of this number
1864:16 - and we are assigning it to the
1864:18 - result array
1864:20 - after doing that
1864:21 - we know that
1864:22 - we have used for example
1864:24 - we have used this position of the i
1864:26 - so we simply increment i
1864:30 - because we need to now
1864:32 - take another value
1864:33 - because we are done with this value
1864:35 - let's say for example
1864:37 - and else
1864:40 - then we can simply assign
1864:46 - array of j into
1864:50 - array of j
1864:52 - and as we are assigning array of j
1864:54 - and it is basically starting from the last index
1864:57 - so it signifies that we have used this value
1864:59 - for example
1865:00 - and now we need to go
1865:02 - one step
1865:03 - before to it
1865:05 - so what we do is
1865:06 - we do
1865:07 - j-minus
1865:10 - and after the first iteration of for loop
1865:12 - in our result array
1865:14 - let's suppose if we take this example
1865:16 - sixteen got occupied at this place
1865:19 - so we are doing k-minus because
1865:21 - now we need to fill this position
1865:23 - we have filled this position
1865:25 - now we need to fill this
1865:26 - and with each iteration we will fill
1865:28 - one-one position
1865:30 - and at the end
1865:31 - we will simply return
1865:33 - the result
1865:37 - so from this is the algorithm
1865:40 - now we will test
1865:41 - it's working in the main method
1865:49 - so here
1865:50 - I will be using this array
1865:52 - which we discussed in our slide as well
1865:55 - here we will get the result array
1865:59 - we will call sorted squares
1866:01 - we pass in the array
1866:04 - and at the end
1866:05 - we will simply print the array
1866:09 - and if I run the main method
1866:15 - so here you can see
1866:16 - that we got the answer at
1866:17 - zero, one, nine, sixteen, hundred
1866:21 - so this zero
1866:22 - came from this zero
1866:25 - this one
1866:26 - came from minus one
1866:28 - nine came from three
1866:31 - sixteen came from minus four
1866:34 - and hundred came from ten
1866:37 - and how it came
1866:38 - we simply squared them
1866:40 - and using this for loop
1866:42 - we actually placed them at their
1866:44 - respective position so that
1866:46 - the final array is also sorted
1866:51 - so friends I hope you must have liked this video
1866:54 - in case if you are new to my channel
1866:56 - then please subscribe to my channel
1866:58 - and click the bell icon
1866:59 - so that you never miss any update
1867:01 - thanks have a nice day
1867:04 - hello everyone
1867:05 - so in this video we are going to discuss a problem
1867:08 - rearrange sorted array
1867:10 - in max min form
1867:12 - so lets see what this problem is
1867:14 - and how to solve this
1867:17 - so in this problem we are given
1867:19 - a sorted array of integers
1867:21 - in ascending order
1867:23 - now we need to rearrange the array in such a way that
1867:26 - the first position
1867:28 - will have the largest number
1867:30 - which is the right most number
1867:32 - the second will have the smallest
1867:34 - second will have the smallest
1867:36 - which is the first number
1867:38 - the third will have the second largest
1867:41 - so the 3rd number will be
1867:43 - second largest
1867:45 - and it will go on
1867:46 - so the 4th number will be
1867:48 - 2nd smallest
1867:49 - and here it will be
1867:50 - 3rd largest
1867:52 - 3rd smallest
1867:54 - and then 4th those
1867:56 - so the 1st constraint is
1867:58 - that we can't create a new array and do this rearrangement. We need to solve this problem
1868:05 - in O of 1 extra space. So here if we create a new array of same size which would be our
1868:11 - result array, then this problem becomes simple because then we can create one pointer here
1868:16 - and one pointer here and we can alternatively put the elements in the array and return.
1868:23 - So the space complexity of the problem will become O of n because we are creating a new
1868:28 - array and then we are putting the elements in maximum form. So if we are using O of 1
1868:34 - extra space, it means we need to modify the same array and return it back. So let's see
1868:39 - how we can solve this problem in O of 1 extra space. Let's suppose we are given with this
1868:45 - array which is sorted 2, 3, 5, 6, 8, 9 and our output array will become like this 9,
1868:53 - 2, 8, 3, 6, 5. So 9 is the largest, 2 is the smallest, 8 is the second largest, 3 is the second
1869:02 - smallest and so on. So as the array is sorted, we know that we can get the largest element.
1869:08 - If we start from this index which is the max index, so this pointer max index will help us
1869:16 - in giving the largest, then second largest, then third largest and so on. And the smallest
1869:23 - elements will be given by min index. So here both these pointers will help us in giving
1869:32 - largest and smallest numbers, second largest and second smallest number. So min index will
1869:39 - travel in this direction and max index will travel in this direction. And here we will
1869:44 - have iterator i which will travel 1 1 element in this direction because we have to solve
1869:51 - this problem in O of 1 extra space, we can't create a new array and simply put the elements
1869:57 - in alternate fashion. So somehow we need to modify the original array only. So we create
1870:03 - this pointer which will travel in this direction and try to fill the elements in this form.
1870:09 - Also friends here you can see in the output array, 9 being the largest. So if I write
1870:14 - here largest, if you see the indexes of the largest elements, 9 is at 0, then comes the
1870:26 - second largest 8 which is at 2, third largest at 4. So for this simple array if I write the indexes
1870:32 - it would be 0, 2, 4. And for the smallest it is 1, 3 and 5. So the indexes would be 1, 3 and 5.
1870:42 - So here if you see we need to arrange this array in max min form and to place the elements in
1870:48 - respective indexes, we have this idea that the largest numbers will be placed at even indexes
1870:56 - and the smallest number will be placed at odd indexes. So this is one thing we need to keep in
1871:02 - mind. So this iterator when it will travel in this direction at whichever index it is, we will first
1871:08 - deduce that whether it is an even index or odd. If it is an even index, then we will take the
1871:13 - help of max index, take that value and somehow place it at the index denoted by i. And if the
1871:21 - i is at odd index, then we will take the help of min index, take that value and somehow place it
1871:27 - where i belongs. So I will write here max index, min index. So we need to keep this information in
1871:40 - mind that the largest will be at even index and will be placed with the help of max index which
1871:47 - will be starting from the last index, the smallest will be at odd index, the numbers will be provided
1871:54 - by min index starting from the zeroth index, min index after placing one one smallest element
1872:00 - will travel in this direction and max index after placing the largest element will travel in this
1872:06 - direction. So if you closely observe between these two arrays, you will see we need to arrange the
1872:15 - array in max min form. So at the start when i will be at zeroth index here, we know that we need to put
1872:22 - nine at the first spot. So as we can't create a new array, we need to put nine somehow here. But here
1872:30 - you can see we have already two because two will lie in this index after the output. But two will
1872:38 - see there is a three. And if you see three will lie in this index here. And when we'll place three
1872:47 - here, it will see that it has six, because six will lie in this index here. And it has eight, so eight
1872:54 - will lie in this index. And similarly, if you see, we can't directly replace the elements, because it
1873:02 - has already one element which we need to place it at its correct index so that it looks in max min
1873:08 - form. So friends, a trick to solve this problem is instead of storing nine directly here, what we can
1873:14 - do is we take nine, we take two, we apply some formula and generate, let's say an integer, let's
1873:22 - say we combine nine and two in such a way based on such formula, and we get a number x. So we will
1873:29 - store x here instead of nine. So why we are storing these numbers? So as we are storing a combination
1873:37 - of number based on a formula. Now let's say if I take an example, here, we have eight. Now this eight,
1873:46 - we need to somehow place it index two here, like this. So let's say to this number, I denote it as
1873:54 - a. And this number, let's say I denote it as b. So we'll take b and a and apply some formula and
1874:03 - generate a number x. So this x we will store here. Instead of eight directly, we will store a number
1874:11 - x which will be a combination of b and a five and eight. Now why we are storing both the numbers is
1874:17 - in the output array, it should come here, but five will be lost. So we need to prevent both the
1874:23 - numbers. Because if I put a directly here, then five will be lost. And we can't figure that what
1874:30 - we need to place at this index, because five should come here in the output area. So this x
1874:37 - we store in such a way, we will see the formula later, this x we store in such a way that it will
1874:43 - help us in giving a back and b back. So that after storing x here, in the resultant area at this
1874:51 - index will somehow deduce a and when we reach here, we take that x and we can somehow deduce b,
1874:59 - so that we can place five directly here. So this is very important that we are using some formula here
1875:07 - and storing a number x and this x will help us in generating a and b back. So here what we do is,
1875:14 - as the array sorted, the last index will be the maximum value, we will take a variable which is
1875:20 - greater than our largest number. So here what we can do is we can simply do nine plus one.
1875:26 - Let's say 10. We are going to last index, we are taking that value and adding one, we will see why
1875:34 - we are doing that. So friends, the formula we use to store two numbers is let's say if the i is an
1875:41 - even index, we need to store the largest number. And that largest number will be given by max index
1875:48 - here. And the max we have is 10. So let's say if we are at index zero, and we need to place nine
1875:56 - here, like this. So if I use this formula, so add this index, what we will store, we will store the
1876:04 - whatever the value here we have, which is the two, which is important for us because this is our,
1876:09 - let's say b. So we take two, we take the number which we are shifting, which is nine, we do modulus
1876:20 - by 10, which is nine divided by 10 will give us a remainder. And we do multiply by 10.
1876:29 - Now here you can see, it will give us to the remainder is nine into 10. The number is 92.
1876:38 - So at area five, we are storing the number 92. It was two, and we are storing 92. So here if I write
1876:46 - number 92. So you can see this number is our x. And how we can deduce a and b back is 92.
1876:56 - The max which we took, let's say if I divide 92 by 10. So we will get nine, which is our a.
1877:07 - And if I do 92 mod 10, we'll get the remainder, which is two. So you can see this largest number
1877:14 - which you are taking, it is generating a number, which is storing our both the integers, the number
1877:22 - which you are shifting here, and the number which is already here. So we can deduce nine into back.
1877:27 - So now let's see how this algorithm will move ahead. So this mod, you will understand when
1877:33 - we reach here. So now I will come here. And we assume that max index somehow has placed this
1877:42 - value here. So the max index will now come back to index four to take the second largest value
1877:52 - like this. So now I is at odd index. So now we will use the formula for odd index,
1877:58 - we will take the help of min index, the formula is pretty much same, only the value in array
1878:04 - for max index and min index is changing here. So now you can see that this step will be more
1878:09 - clear to you why we are doing this modulus. So at index one, we need to put the smallest number,
1878:17 - we are taking this formula. So we take the value here, which is three, because we don't want to
1878:23 - lose this value. And here you can see, we'll take the value at min index. So currently,
1878:29 - if I take the value at min index, it is not two, two is gone, we have 92. So I will simply write
1878:37 - 92 mod 10 into 10. Now you will understand why we are doing first mod is because there could be a
1878:47 - chance that we get an overridden value. So here we have 92. And we know that from x we can deduce
1878:55 - our overridden value, which was two, and the number which is transferred here. So 92 divided
1879:02 - by 10 will give 992 mod 10 will give remainder which is two. So here therefore we are first
1879:11 - taking this remainder so that first we get the original value. And even if this value is not
1879:16 - overridden, let's say it was two only. So two mod 10, this will again give us two only. So here,
1879:27 - so here this formula is important that we are doing mod with the max value.
1879:31 - First to deduce our original number. And then we are simply multiplying it by 10. So that
1879:37 - something like this can happen. So three plus two into 10. The remainder is two. So it will give 23.
1879:47 - So here this number 23 is suggesting that
1879:52 - that we will store 23 here. And now this value is overridden. 23 comes here. And what it is
1879:59 - telling is it is storing two numbers, the number which is getting shifted here, and the number
1880:06 - which was already here. So we'll go over this quickly now, because we have a fair amount of
1880:12 - idea what we are doing. So for two, it is an even so we use this formula. So we take the value five
1880:20 - plus we are using this formula. Value at max index is eight. So we are doing eight mod 10
1880:31 - into 10. So here you can see that this value is not overridden. So therefore, even if we do mod
1880:37 - 10, we get the same value back. So five plus eight into 10, which is 85. So we are storing 85 here
1880:47 - for this index i. And then I will come here. And this max index will come here.
1880:56 - And as we have used this two also here, so we will move the min index to here.
1881:01 - So now as i is at three, which is odd index, we need to take the smallest value,
1881:11 - we move min index in this direction, because we assume that we have placed two here somehow,
1881:18 - the step which we did previous 285, while we placed 23 here. So min index, use this value,
1881:25 - and it shifted here. Now at this spot, what we do is we are taking this formula because
1881:31 - value of i is three. So here we take six, 23, like this, the remainder will be three,
1881:49 - it will give 36. So here,
1881:51 - now this value will become 36. This has been overridden. And this has also been overridden.
1882:00 - So these are the now original values at these spots. Now after taking the help of min index,
1882:06 - min index will come here. We will move i ahead. And now value of i is four, we will take the
1882:18 - largest number. And we'll use this formula. So eight plus the value at max index is 36
1882:29 - mod 10 into 10. So this will give us eight plus six into 10. It will be 68.
1882:40 - So we are storing 68 here. So this eight will be overridden with 68. So this value will be
1882:47 - overridden and max index will come here because it has used this value. I will go here. And at
1883:00 - the last index being an odd index, we will take that value nine, because we are using this formula,
1883:08 - we are taking the value nine, then plus value at min index, which is 85, because min index is
1883:15 - pointing to index two. So 85 mod 10 into 10, nine plus five into 10. So this will give us 59.
1883:29 - So we are storing 59. So I just remove this now everything. So now instead of these numbers,
1883:37 - we have a combination of numbers. So let's say if I denote this number as x, and we need to get back
1883:44 - b and a. So we know that will give us a, will give us b. We know this formula already. So now
1883:56 - we will iterate this array one more time. And now what we do is we need to store nine here,
1884:02 - which is our a. So what we do is 92 divided by 10 will give nine. So nine comes here. Here
1884:14 - 23 divided by 10. Two comes here. And similarly 85 divided by 10 will give eight,
1884:23 - 36 divided by 10 will give three, 68 divided by 10 will give six, 59 divided by 10 will give five.
1884:33 - So this is how this combination numbers will give us output array, which is our answer. So
1884:39 - friends, these are the formulas we need to keep in mind. And now let's move ahead and see the
1884:44 - demonstration of this algorithm step by step. So we have method arrange max min, which takes in an
1884:51 - array. And here you can see that we are not creating any additional array. So this problem
1884:56 - is solving over one space complexity. So friends, before we start, if you want to master algorithms
1885:04 - and data structures, then you can subscribe to my channel and click the bell icon so that you
1885:10 - never miss any update. So we call arrange max min, we pass in the array. So this is our original
1885:19 - array, which is here. And this is our resultant array, which is our output array. So here as we
1885:28 - will modify this array, this number will be getting overridden. So to understand what the
1885:34 - previous number was, you can refer this array, because this is our original array. Moving ahead,
1885:41 - we create a max index, starting from the last index, array dot length minus one,
1885:47 - array dot length is six minus one will give five. So max index will start from here, because this
1885:54 - max index will give us the largest, then second largest, then third largest, and so on.
1886:01 - We'll create a min index starting from zero. This min index will give us smallest, then second
1886:08 - smallest, and third smallest, and so on. So as the array sorted, we have created two pointers,
1886:15 - starting from very extreme ends. And then we will evaluate a max value, which you already discussed,
1886:23 - that we simply take the value at the last index, which is the maximum,
1886:28 - because this array sorted, we do plus one. So max will become 10.
1886:36 - And now we will apply the for loop where we are traversing i in this direction,
1886:43 - starting from zero and going till fifth index via this condition. So currently, I will start
1886:50 - from zero index, zero is less than array dot length, which is six. So friends in our previous
1886:57 - slide, we discussed that first we evaluate whether this i is at even index or at odd index. So if i
1887:05 - divided by two, if it gives remainder as zero, it means it is an even index. And if i mod two
1887:13 - doesn't give us a remainder zero, it means it's an odd index. So currently value of i is zero,
1887:20 - so i mod two will give remainder as zero, which means that we are at even index.
1887:26 - And as we are at even index, we know that we need to place the largest numbers,
1887:34 - which will be given by max index at odd index, we will put the smallest numbers
1887:42 - that will be given by main index. So here we are using the same formula. So as i is at zero index,
1887:53 - we are taking the help of max index to take the maximum value and place it here.
1887:58 - So we will store a modified number here, which is the combination of this and this number.
1888:03 - So we will take two plus
1888:07 - value at max index, which is nine mod 10, which is our max
1888:14 - into 10. So this will give us 92. So we store 92 here.
1888:23 - And then we decrement max index, assuming that max index has placed nine at its proper spot.
1888:30 - So the max index will come at index four, like this. We will increment i,
1888:40 - i comes at index one. Now i mod two will give remainder as one. So therefore we know that one
1888:47 - is an odd integer. So the else part will be executed. So now here we will take the help
1888:54 - of main index to get us the smallest numbers. The formula is pretty much the same, which we
1888:59 - already discussed in our previous slide. Here we will take this number, which is three.
1889:06 - We will take the number at main index, which is 92. We will do mod 10, multiply by 10.
1889:16 - We are doing mod 10 is because we need to get back the original number, which was two.
1889:21 - So 92 mod 10 will give us two, because we need to put two here somehow. So in the output array,
1889:29 - here two will come here. So at this index, we need to place two. So therefore from 92,
1889:36 - first we are deducing two via this modulus. So three plus two into 10. This will give us 23.
1889:47 - So 23 will come here. So now we assume that main index
1889:53 - has taken two and somehow placed it at its correct spot. So this value and this value,
1890:02 - we assume that we have used up. So we increase main index value so that we can get a second
1890:08 - smallest value now. Main index becomes one. We will increment i. i comes at index two,
1890:18 - i mod two, which is two mod two, which will give us zero. So it means two is even index.
1890:28 - So we apply the formula. We take this value, five plus. Now we take the value of max index,
1890:35 - because we need to put eight somehow here. So eight mod 10, five plus 80. It will give us 85.
1890:50 - So 85 comes here. Now we will decrement max index because this value is used up.
1890:57 - Max index becomes three. So it means we have used up this value now.
1891:06 - We will increment i. i comes at third index, which is odd index. So this condition will fail
1891:14 - because three mod two will give us remainder as one, which is not equal to zero. And here
1891:20 - we will take the help of main index and take the second smallest value now.
1891:24 - So we will take this value, which is six. We take 23. We will do mod 10 because at index three,
1891:38 - you see the number we are shifting is now three should come here in the resultant array.
1891:43 - So first we need to deduce this three back. So 23 mod 10 will give remainder as three,
1891:48 - which was our original number here. And then we do multiply by 10.
1891:53 - So this will give us six plus 30, 36. So 36 comes here.
1892:02 - And now we assume that we have placed three here properly somehow.
1892:07 - So this number will be used up and main index will come to this spot. So we'll increment
1892:13 - main index like this. We will increment i. i comes to this spot.
1892:26 - The value of i is four, which is an even index. So this condition comes out to be true.
1892:31 - We take the value eight and here we will take the help of max index because we need to put
1892:36 - the max value here. So first we will deduce what number we need to shift. So we'll take 36,
1892:44 - 10 into 10. This will give us six into 10, 68 plus 60 will give 68. So 68 comes here
1892:56 - and then we have used this six also. So we will decrement max index now.
1893:04 - It will come at index two now. We will increment i.
1893:08 - i becomes five. Five is still less than six. Five mod two will give a remainder as one.
1893:18 - So therefore the else part will be executed. And here we'll take help of main index.
1893:26 - So at main index the original value was five and we know that five needs to become here.
1893:33 - So first we need to deduce five out of 85. So we'll use this formula. We take nine here plus,
1893:42 - so this formula will help us in getting five back. So we'll take 85 mod 10 into 10.
1893:51 - This will give nine plus five into 10 which is 59. So 59 comes here.
1893:59 - And then we will increment min index
1894:06 - because we have used this value also. So now when we will increment i,
1894:13 - i will become six and six is not less than six. So therefore this formula will terminate now
1894:19 - which makes sense because we have used up all the values.
1894:22 - So now this is our modified array. At the start we have taken this array which was our original
1894:29 - array. We transformed it into this array and now our task is to transform this array into
1894:37 - this array. So for that we are using this for loop and we have already discussed how we can do that
1894:43 - is let's say we take 92. We know that we have stored both the numbers. The number which was
1894:51 - getting shifted here and the number which was already here. We can deduce both the numbers.
1894:57 - So let's say if i denote 92 as x. So here x will give us a via x by max which is our 10 here
1895:09 - and x will give b via x mod max. So if i take 92 if i do 92 by 10 we'll get nine which is our a.
1895:23 - If i do 92 mod 10 it will give us two which is our b and our task is to store the largest element
1895:32 - we know that we can get it via division. So we iterate this array back from i equal to zero
1895:40 - it will go till the last index so we'll go over this formula quickly because it is very simple.
1895:46 - So i is zero. Now at the same spot we are taking 92 dividing it by max which is 10
1895:55 - and storing it back at the same index only. So here it will come 92 divided by 10
1896:01 - will give 9 like this. Moving ahead i becomes 1. 23 divided by 10 will give 2.
1896:14 - We increment i again. i becomes 2. 85 divided by 10 will give 8.
1896:22 - We increment i. i becomes 3. 36 divided by 10 will give 3.
1896:35 - We'll increment i. 68 divided by 10 will give 6.
1896:45 - We'll increment i. 5 is still less than 6 because the array dot length is 6.
1896:52 - So this for loop will execute one more time for the last index 59 divided by 10 will give 5.
1897:02 - And now when we'll increment i it will go beyond the boundaries of array so this for loop will
1897:07 - terminate. And here you can see after this for loop will terminate our algorithm will also end
1897:14 - and here you can see that now we have got our output array which is in max min form
1897:20 - and one thing to notice we have modified the same array which we received so therefore we have used
1897:26 - o of 1 extra space. So friends in order to understand this problem more you need to go over
1897:33 - this video two three times to understand these formulas which is helping us to store two numbers
1897:39 - instead of one and then here we are deducing one of the number out of it. So this x is giving
1897:47 - b year and a year. So friends i hope you must have liked this video in case if you are new to my
1897:54 - channel then please subscribe to my channel and click the bell icon so that you never miss any
1897:59 - update. Thanks have a nice day. Hello friends welcome to my new data structures and algorithm
1898:06 - in java tutorial series video. Friends in this tutorial we will discuss about the introduction
1898:12 - to graphs. So friends what is a graph?
1898:19 - So friends below you can see a figure it represents a graph.
1898:22 - Here it contains few nodes say one two three four five and these five nodes are connected
1898:30 - through some lines. So a graph is a non-linear data structure used for storing the data. So we
1898:36 - can store the data inside a graph but it's not a linear data structure like arrays and linked list.
1898:42 - So friends it is a set of vertices. So here you can see one two three four five are nothing but
1898:50 - vertex of the graphs and it also has a collection of edges that connects a pair of vertices.
1898:57 - So here you can see two vertex are connected by an edge.
1899:01 - So in a graph if we take any two vertex and if you want to connect them we just provide an edge.
1899:07 - So here you can see between this five vertex there are six edges one two three four five and six.
1899:18 - So in simple terms we can represent a graph as
1899:20 - set of vertices and a collection of edges that connects a pair of vertices.
1899:28 - So friends why graphs are important. So here you can see
1899:33 - so friends here you can see a graph which is nothing but social networking site
1899:38 - so in computer applications graphs help us to implement social networking sites such as
1899:42 - Facebook and Twitter and we can term it as social networking graph.
1899:48 - So friends here in this social networking graph the names of people which you can see here is
1899:53 - Ankit, John, Bill, Kathy and Max. We can see them as the vertices of this social networking graph.
1900:01 - So if you consider the example of Facebook then friendship between two people
1900:05 - can be represented as an edge of the graph. So here you can see Bill is friend to Kathy
1900:11 - and Kathy is friend to Bill. So therefore there is a link between them which is nothing but
1900:15 - friendship link. So we can represent this graph where people are the vertices
1900:22 - and the friendship link between them is nothing but the edge.
1900:29 - Another application of the graphs would be the web content over the internet.
1900:32 - So friends let's suppose we are having few web pages as google.com, udemi.com, youtube.com,
1900:38 - twitter.com and facebook.com and let's suppose from google.com there is an edge
1900:45 - to udemi.com. So this edge is nothing but a link and similarly let's say from udemi
1900:52 - there is one link which can take us to facebook.com and from facebook to twitter
1900:56 - and from youtube to twitter and vice versa. So here we can take these web pages as the vertices
1901:03 - of this graph and the links as the edge between these vertices. So friends in computer application
1901:10 - this web content can be represented as a graph where web pages are nothing but the vertices
1901:16 - and the edge which connects between them is nothing but the link.
1901:19 - So friends this was the introduction to graph. In our upcoming tutorial we will discuss the graphs
1901:24 - into further detail. I hope you like this video. Thanks have a nice day. Hello friends
1901:32 - welcome to my new data structures and algorithms in java tutorial series video.
1901:37 - Friends in this tutorial we will discuss how we can represent an undirected graph.
1901:43 - So one of the way in which we can represent a graph is adjacency matrix.
1901:49 - So friends first of all what is an undirected graph. So here in the figure you can see five
1901:54 - nodes 0 1 2 3 4. So these nodes are nothing but the vertices of the graph and you can see here an
1902:02 - undirected edge. So here between the vertex 3 and vertex 4 there is an undirected edge. So what is
1902:08 - an undirected edge. The undirected edge doesn't have any direction. So if suppose we are on vertex
1902:15 - 3 then we can go to vertex 4 and if suppose we are on vertex 4 then we can go to vertex 3
1902:23 - and as such there is no direction between the two vertices.
1902:26 - So a graph which has these two edges are termed as undirected graph. So if we take an example
1902:33 - then social networking graph which we discussed in our previous tutorial is nothing but an
1902:38 - undirected graph. So let's suppose the social networking graph there is a set of vertices
1902:45 - which is nothing but the names of people. So let's suppose John is a friend to Max.
1902:51 - So here John and Max are nothing but the vertices of the graph and the friendship between them is
1902:56 - nothing but the edge of the graph. So here if John is friend to Max then it implies that Max
1903:03 - is also friend to John. So it is nothing but an undirected graph. So here John is friend to Max
1903:09 - is same as Max is friend to John. So the social networking graph can be seen as an undirected
1903:15 - graph where edges are undirected they don't have any direction. Moving ahead so friends graph can
1903:22 - be represented by a two dimensional array which is nothing but a matrix. So let's suppose we are
1903:29 - given this undirected graph where 0 is connected to 1, 1 is connected to 2, 2 is connected to 3
1903:35 - and 3 is connected to 0. So in order to represent this graph in a data structure we usually use the
1903:41 - matrix which is nothing but a two dimensional array. So friends here if you see there are four
1903:47 - vertices. So therefore we create a 4 cross 4 matrix. So this 4 cross 4 matrix goes from indices
1903:55 - 0 to 3 and this matrix is nothing but a 0 1 matrix. So why we call it a 0 1 matrix because in
1904:02 - order to represent an edge between two vertices we just provide a 1 which signifies that there
1904:09 - is an edge between the two vertices. So friends here you can see from 0 to 1 there is an edge.
1904:16 - So when we want to represent an edge in matrix we follow this rule that a first vertex is the row
1904:23 - and the second vertex to which this edge is going is the column. So if I take an example
1904:30 - then between 0 and 1 there is an edge. So in the graph we can represent it as
1904:36 - from 0th row to 1th column there is an edge which is nothing but 1.
1904:41 - Similarly if we are at node 1 and if you want to go to node 0 then there is an edge.
1904:48 - So from the first row to 0th column there is an edge and as it is an undirected graph
1904:54 - therefore we can go both ways from 0 to 1 and 1 to 0. So let's suppose if you want to go from 3 to 2
1905:02 - so from the third row second column there is an edge which can be represented as 1
1905:09 - and similarly it is an undirected graph therefore from 2 we can go to 3.
1905:13 - So from the second row to third column there is an edge. Also here you can see that from node 3
1905:21 - to node 1 there is no edge therefore from the third row to first column there is no edge
1905:30 - therefore we have represented it as 0 because it signifies there is no edge between 3 and 1.
1905:37 - So in the matrix wherever you want to represent an edge we usually put 1 and wherever we want to
1905:44 - represent a no edge then we put 0. So friends here we use the matrix to represent an undirected
1905:51 - graph. I hope you like this video thanks have a nice day. Hello friends welcome to my new data
1905:59 - structures and algorithm in java tutorial series video. Friends in this tutorial we will discuss
1906:06 - the adjacency matrix implementation of an undirected graph.
1906:12 - So friends in our previous tutorial we discussed what is an adjacency matrix
1906:16 - and how we can represent an undirected graph into it. So friends in this tutorial we will see
1906:22 - how we can implement an adjacency matrix to represent an undirected graph through a
1906:28 - demonstration. So friends let's suppose we are given an undirected graph with four vertices as
1906:35 - 0 1 2 3 where 0 and 1 are connected through an edge 1 and 2 are connected through an edge
1906:43 - 3 and 2 are connected through an edge and 0 and 3 are connected through an edge.
1906:49 - So friends using this code here we can actually represent this undirected graph into a form of
1906:54 - matrix. So let's see this demonstration step by step. So in our previous tutorial we discussed that
1907:02 - using a matrix we can represent that a graph. So here in our java class graph we are having
1907:08 - this adjacency matrix and in the constructor we are initializing this adjacency matrix
1907:15 - with the number of nodes in the graph. There is a method add edge which takes two parameters
1907:21 - let's say u and v. So here suppose if you want to add an edge between 0 and 1
1907:28 - so 0 would be u and 1 would be v. So through this code we can add an edge between u and v.
1907:37 - So you'll see it's demonstration step by step.
1907:42 - So let's suppose in our main method first we initialize the graph with the number of nodes.
1907:46 - So here you can see there are four nodes. So we are passing the number as 4 here.
1907:55 - So now the execution step goes into the constructor of graph
1907:59 - where nodes is having value of 4. So in the constructor we simply initialize an object of
1908:07 - matrix by providing the value of row and column as the value in the nodes which is nothing but 4.
1908:13 - So after execution of this step it will create a two dimensional array
1908:18 - which is nothing but a 4 cross 4 matrix. So it would look something like this.
1908:24 - So here it will be represented as an adjacency matrix which is a 4 cross 4 matrix. Moving ahead.
1908:35 - So friends here you can see that from 0 to 1 there is an edge. So by calling
1908:42 - add edge method we pass 0 and 1 because we want to create an edge between 0 and 1.
1908:51 - Here we simply apply this rule that between a row and a column we just provide a 1 which
1908:57 - represents an edge. So if you want to represent an edge between 0 and 1 so 0 will represent a row
1909:05 - and 1 will be representing as a column. So between 0 and 1 there would be an edge
1909:10 - which will be represented by 1. So let's see how. So as the value of u is 0 and v is 1.
1909:21 - So here in order to represent an edge between 0 and 1
1909:25 - in the matrix 0 comma 1 we provide a value as 1.
1909:29 - So in the matrix 0 and 1 we just provide a value of 1. So it would look something like this.
1909:34 - So this represents an edge between 0 and 1 which is 0 row and 1 column. Moving ahead.
1909:47 - So friends in the second step what we do is as this graph is an undirected graph
1909:52 - there is no direction between the edge. Therefore we can see it something like as there is an edge
1909:56 - between 0 and 1 and we can also see it as there is an edge between 1 to 0.
1910:02 - So friends this information we need to store into the matrix.
1910:06 - So in the first step 0 to 1 we provided a value as 1. So similarly in the second step
1910:13 - from row 1 to 0th column we provide a value as 1. So it would look something like this.
1910:21 - So in an undirected graph basically an edge represents a two points into the adjacency
1910:27 - matrix because if we are at vertex 0 then we can go to vertex 1 because there is an edge
1910:34 - and if we are at vertex 1 then we can go to vertex 0 through this edge. So therefore in the
1910:40 - matrix this edge represents these two points that from 0 to 1 there is an edge and from 1 to 0
1910:49 - there is an edge. Moving ahead. Now we want to add an edge between 1 and 2. So we simply pass
1911:00 - the parameters as 1 and 2. So into the adjacency matrix to row 1 and column 2 we need to provide
1911:10 - a value 1 to represent an edge. So it would look something like this. Moving ahead.
1911:21 - Now similarly we have to provide an edge from row 2 to column 1.
1911:29 - So we provide a value as 1. So this represents an edge between row 2 and column 1.
1911:36 - Moving ahead.
1911:43 - Similarly vertex 2 and vertex 3 are connected through an edge. Therefore
1911:49 - in the matrix from the row 2 and column 3 will provide a value as 1.
1911:58 - Moving ahead. And similarly from the row 3 to column 2 will provide a value as 1.
1912:06 - Because if you want to traverse from third node to node 2 we know that there is an edge and that
1912:11 - can be figured out through this matrix. That we can directly figure it out that from row 3
1912:17 - and column 2 is there any edge or not. So if the value is 1 we can come to know that there is an edge.
1912:23 - Moving ahead.
1912:27 - And the last edge is between vertex 3 and vertex 0.
1912:31 - So it would be represented as row 3 and column 0 which is this value will provide a value as 1.
1912:44 - Moving ahead.
1912:47 - And finally from the row 0 to third column will provide a value as 1.
1912:55 - So friends this is how we can represent an undirected graph into a matrix.
1913:00 - And also one point to note that as it is an undirected graph.
1913:04 - Therefore for each edge there will be two values of 1 into the graph.
1913:10 - Which will be actually demonstrating a two-way graph.
1913:14 - Here from 0 to 1 there is a way and similarly from 1 to 0 there is a way.
1913:18 - So into the matrix we represented it something like from 0 to column 1 there is an edge.
1913:25 - And from one row and 0 column there is an edge.
1913:27 - So friends this is how we can represent a graph in the form of a two-dimensional array.
1913:34 - Which is nothing but a matrix.
1913:37 - In my next tutorial we will actually code this algorithm into the Eclipse.
1913:41 - I hope you like this video. Thanks have a nice day.
1913:46 - So friends here I have created one class by name graph which is having a main method.
1913:51 - So into this class we will code the implementation of graph through adjacency matrix.
1914:01 - So first we will create an integer variable.
1914:08 - And we will give it a name as v.
1914:12 - So this v is nothing but a number of vertices in the graph.
1914:21 - We will also create one more integer variable.
1914:26 - We will name it as e.
1914:30 - So this e would be number of edges in graph.
1914:42 - We will also create a two-dimensional array.
1914:44 - Which would be our adjacency matrix and it would represent a graph.
1914:52 - So it would be a two-dimensional array.
1914:59 - And in the constructor we will initialize these three values.
1915:09 - So this graph constructor takes in number of nodes.
1915:13 - So here if simply we can assign nodes value to v.
1915:20 - And as we are in the constructor of graph therefore value of e would be equal to 0.
1915:28 - Because till now there are no edges into the picture.
1915:36 - And finally we will initialize the matrix with the number of nodes.
1915:46 - So if suppose the graph is four nodes therefore this would be a four cross four matrix.
1915:57 - We will also create an add edge method.
1916:07 - Which will actually add an edge from u to v and vice versa.
1916:16 - Therefore here simply we can do is.
1916:25 - To uth row and vth column will assign a value of one which represents an edge.
1916:33 - And vice versa will do from v to u.
1916:38 - Because it is an undirected graph.
1916:50 - So therefore for every edge in the matrix.
1916:53 - There will be two points which will be representing an edge.
1916:59 - After adding the edge will increment the count of edge by one.
1917:02 - So it would be e plus plus.
1917:04 - So friends in our main method will create a graph and add an edge between few nodes.
1917:20 - So will create an instance of graph.
1917:22 - And will provide a value of four.
1917:25 - So this will actually create a graph of four nodes.
1917:28 - And also it will create an adjacency matrix.
1917:32 - Which is of four cross four.
1917:34 - So will actually create a graph which we saw in our previous tutorial.
1917:42 - Will add an edge from zero to one.
1917:52 - Then from one to two.
1917:58 - Then from two to three.
1918:01 - And finally from three to zero.
1918:10 - So friends here we have added four edges.
1918:13 - Which we actually saw in the slide of our previous tutorial.
1918:18 - Here I will create one method.
1918:22 - Which will give us the string representation of this graph.
1918:25 - And I will name it as two string.
1918:27 - And so first will create a string builder.
1918:45 - Will append v.
1918:51 - Which would be vertices.
1918:52 - E would be our edges.
1919:08 - And then will simply provide a for loop.
1919:11 - Now this for loop will iterate over each and every vertex.
1919:24 - And inside this for loop will append.
1919:38 - And now will provide one more loop.
1919:41 - Which will iterate over the adjacency matrix.
1919:53 - For a particular vertex.
1919:56 - So here will append.
1920:04 - So here we are simply printing the matrix.
1920:08 - So sb.
1920:11 - And finally will return sb.toString.
1920:27 - So here will simply print g.
1920:34 - And if I run this code now.
1920:45 - So friends here you can see.
1920:47 - That there are four vertices as we have passed a value into the graph is four.
1920:52 - And there are four edges because we have created four edges.
1920:56 - From zero to one one to two two to three and three to zero.
1920:59 - And below is the string representation of this graph.
1921:04 - Which is nothing but our adjacency matrix.
1921:06 - So this matrix we discussed in our previous slide.
1921:09 - You can refer that slide.
1921:11 - And you can come to know that.
1921:13 - It represents the same matrix which we discussed.
1921:17 - So friends in this tutorial we saw the implementation of the graph.
1921:21 - Using an adjacency matrix.
1921:25 - I hope you like this video.
1921:26 - Thanks have a nice day.
1921:29 - Hello friends.
1921:32 - Welcome to my new data structures and algorithms in Java tutorial series video.
1921:37 - Friends in this tutorial we will discuss.
1921:40 - The representation of an undirected graph through adjacency list.
1921:46 - Friends in our previous tutorial we discussed about the representation
1921:50 - of undirected graph through adjacency matrix.
1921:54 - So in this tutorial we will discuss one more way to represent an undirected graph.
1921:59 - That is through adjacency list.
1922:01 - So this adjacency list is nothing but an array of linked list.
1922:06 - So friends let's suppose we are given an undirected graph.
1922:10 - Having four nodes zero one two three.
1922:14 - And from zero vertex there is an edge to vertex one.
1922:18 - From vertex one there is an edge to vertex two.
1922:21 - And from vertex two there is an edge to vertex three.
1922:24 - And finally from vertex three there is an edge to vertex zero.
1922:29 - So friends this undirected graph can be represented
1922:32 - as an adjacency list which is nothing but array of list.
1922:36 - So here you can see there are four nodes.
1922:39 - So we create an array of linked list having the size as four.
1922:44 - So here you can see each and every index hold a linked list.
1922:49 - And what this linked list contains.
1922:52 - Friends let's suppose we are on vertex zero.
1922:55 - And there is one edge to vertex one and one edge to vertex three.
1923:00 - So friends these two edges from the vertex zero is represented as.
1923:05 - In the array index zero the linked list which it holds has node one and node three.
1923:13 - So this structure tells us that from node zero there is an edge to one and there is an edge to
1923:20 - node three. Similarly if you can see from vertex two there is an edge to vertex one and vertex three.
1923:28 - So in order to represent this structure at index two we have node three and node one.
1923:33 - So it signifies that from two there is an edge to three and from two there is an edge to one.
1923:40 - Similarly here you can see that from three we have one edge to two which is this edge.
1923:48 - And from three we have one edge to zero which is this edge.
1923:53 - So friends this is one more way to represent an undirected graph that is by using an array of
1923:58 - linked list. So the length of this array is same as the number of vertices in the graph.
1924:05 - So friends in our upcoming tutorial we will discuss more about adjacency list.
1924:11 - We'll see its code and working through animation.
1924:13 - I hope you like this video thanks have a nice day.
1924:18 - Hello friends welcome to my new data structures and algorithms in java tutorial series video.
1924:24 - Friends in this tutorial we will discuss about the implementation of the undirected graph
1924:30 - using adjacency list. So friends in our previous tutorial we discussed about
1924:35 - the representation of an undirected graph through an array of linked list.
1924:39 - We also discussed that how this undirected graph can be represented into an array of linked list.
1924:47 - So friends in this tutorial we will look into the code and see its demonstration step by step.
1924:53 - So here is the code to implement a graph using an array of linked list.
1924:58 - So we'll see the working of this code step by step through animation.
1925:02 - And we will see that how we can represent this undirected graph into an array of linked list.
1925:08 - So let's start. So in the step 1 we initialize a graph and we pass in the number of vertices
1925:15 - the graph can have. So here if you see this undirected graph has 4 nodes.
1925:20 - Therefore we are passing the value as 4.
1925:25 - So into the constructor the value of nodes is 4.
1925:30 - So in the first step what we do is we have taken this instance variable which is nothing
1925:34 - but an array of linked list. So we initialize this array of linked list with the number of nodes.
1925:41 - So it would look something like this.
1925:45 - That here you can see an array of linked list.
1925:48 - So as currently the linked list is not being initialized so they point to null. Moving ahead.
1925:56 - So then we provide a for loop and we iterate over each and every vertex.
1926:01 - And to this array of linked list it will initialize the linked list to each and every index.
1926:07 - So as i starts from 0.
1926:12 - Therefore at 0th index it will initialize a linked list. So it would look something like this.
1926:19 - Currently linked list is empty and head is pointing to null. Moving ahead.
1926:25 - Then i becomes 1.
1926:26 - And similarly at the index 1 it will initialize a linked list.
1926:34 - Moving ahead. i becomes 2.
1926:39 - So in index 2 it will again initialize a linked list.
1926:46 - And similarly at the index 3 it will initialize a linked list.
1926:50 - So now i becomes 4. Therefore the condition for loop comes out to be false because 4 is not less than 4.
1927:03 - So friends here we have created an array of linked list.
1927:07 - And to each index we have a separate linked list.
1927:10 - So here you can see from vertex 0 to vertex 1 there is an edge.
1927:14 - So we will call this edge method and we will pass the value as 0 and 1 stating that there is an edge between 0 and 1.
1927:28 - So friends value of u is 0 and value of v is 1.
1927:32 - And also in our previous tutorial we discussed how we can represent an undirected graph into an array of linked list.
1927:38 - So what we do is as there is an edge from 0 to 1.
1927:42 - Therefore the 0th index linked list we add 1.
1927:46 - So first we get this linked list at the 0th index and add 1 to it.
1927:51 - So it would look something like this.
1927:56 - That at the 0th index linked list we are adding 1.
1928:00 - Moving ahead.
1928:03 - And similarly as this is an undirected graph therefore from vertex 1 there is an edge to vertex 0.
1928:10 - Therefore the linked list at vertex 1 will add the value 0.
1928:13 - So it would look something like this.
1928:16 - So here it represents that from 0 there is an edge to 1.
1928:21 - So the linked list at 0th index has an edge to 1.
1928:25 - And similarly here you can see from the vertex 1 there is an edge to vertex 0.
1928:30 - So it is represented by the linked list at index 1 has a value 0.
1928:35 - Which signifies that there is an edge from 1 to 0.
1928:39 - Moving ahead.
1928:43 - Then we can also see that there is an edge from 1 to 2.
1928:46 - So we call this edge method by passing 1 and 2.
1928:53 - So in the first step what we do is the linked list at index 1 we add the value 2.
1929:00 - So it would look something like this.
1929:04 - Moving ahead.
1929:05 - And similarly the linked list at index 2 we will add value 1.
1929:13 - So at index 2 we will add the value 1.
1929:17 - So it would look something like this.
1929:20 - Moving ahead.
1929:26 - Now there is one more edge from the vertex 2 to vertex 3.
1929:30 - So this can be demonstrated as
1929:32 - to the linked list at index 2 we will add the value 3.
1929:39 - So here to a linked list at index 2 we will add a value 3.
1929:44 - So it would look something like this.
1929:48 - Moving ahead.
1929:51 - And as it is an undirected graph therefore to the linked list at index 3 we will add the value 2.
1929:57 - So it would look something like this.
1930:00 - Moving ahead.
1930:02 - So in the last step there is one more edge from the vertex 3 to vertex 0.
1930:09 - So we will pass the value as 3 comma 0.
1930:15 - So in the first step what we do is the linked list at index 3 we will add the value 0.
1930:22 - So it would look something like this.
1930:25 - Moving ahead.
1930:26 - And similarly the linked list at index 0 we will add the value 3.
1930:36 - So friend this is a code to implement an undirected graph through an array of linked list.
1930:42 - Here you can see that each and every node has been represented by an index of this array.
1930:48 - And in order to represent an edge we simply add those value into the linked list
1930:53 - of that particular index.
1930:54 - So here you can see that from 0 there is 1 edge to 1 and 1 edge to 3.
1931:01 - So at the linked list at 0 index we are adding 1 and 3.
1931:06 - So this is a type of a metadata which can help us to know that okay from 0 there is an edge to 1
1931:12 - and from 0 there is an edge to 3.
1931:15 - And similarly if I take this vertex 2 there is an edge to 1 and there is an edge to 3.
1931:21 - So the linked list at index 2 has 1 and 3.
1931:25 - So friend this is how we actually represent a graph into an array of linked list.
1931:30 - In my upcoming tutorial we will actually code this implementation into Eclipse
1931:35 - and see it's working.
1931:37 - I hope you like this video.
1931:39 - Thanks have a nice day.
1931:43 - So friends in our previous tutorial we actually discussed about the implementation
1931:47 - of an undirected graph through adjacency list.
1931:51 - So in this tutorial we will code that implementation into Eclipse.
1931:55 - So here I have created one class by name graph having a main method.
1932:00 - So here in the graph class we will first create an array of linked list.
1932:05 - We will import the linked list from java.util.
1932:22 - We will also create an integer variable and we will name it as v.
1932:27 - So this integer variable will be having a value of number of vertices in the graph.
1932:31 - So it represents number of vertices.
1932:38 - And similarly we will create one more integer variable and we will name it as e.
1932:43 - So this integer variable will be having a value of number of edges in graph.
1932:52 - We will also create one constructor.
1932:53 - And to this constructor we will pass the number of vertices the graph can have.
1933:03 - So we will give this integer a name as nodes.
1933:09 - So here what we can do is as we represent the number of vertices in the graph.
1933:15 - So we will simply assign the value of nodes to it.
1933:17 - And as this graph is getting initialized so the value of e will be zero.
1933:27 - Because currently there are no edges.
1933:30 - And finally we will create an instance of array of linked list.
1933:33 - So this dot adj equals new linked list.
1933:43 - And we will pass the value of nodes to it.
1933:45 - So after creating an instance of array of linked list currently each and every index
1933:52 - of this array will point to null because the linked list has not been initialized.
1933:57 - So we will provide a for loop.
1934:01 - And we will iterate over each and every vertex.
1934:09 - And we will create a separate linked list for each and every index of the array.
1934:14 - So adj of v.
1934:26 - So friend in this for loop we are iterating over each and every vertex.
1934:30 - And as we have created this array of linked list.
1934:33 - Therefore we need to initialize a linked list for each and every index.
1934:38 - Moving ahead.
1934:38 - We will create a method as ad edge.
1934:49 - So this method takes in a to value.
1934:51 - Let's say we give the name to us as u and v.
1934:57 - So we are calling this ad edge method.
1934:59 - What we are doing is we are creating an edge between u and v.
1935:03 - Friend in our previous tutorial we saw that in order to create an edge between u and v.
1935:08 - We have to provide the value of v into the linked list of
1935:12 - u and similarly we have to provide a value of u into a linked list of v.
1935:17 - So here what we do is.
1935:20 - Into the linked list of u we add.
1935:26 - The value v.
1935:30 - And similarly.
1935:33 - Into the linked list of v.
1935:35 - We add value u.
1935:42 - And finally we increment the value of e by 1.
1935:46 - Because it signifies that an edge has been placed between u and v.
1935:51 - Therefore we are incrementing the e by 1.
1935:54 - So friends in the main method.
1935:58 - We'll first initialize the graph.
1936:02 - With the number of nodes.
1936:05 - So friends in our previous tutorial we saw an undirected graph.
1936:08 - Which had 4 nodes.
1936:11 - So we'll initialize this graph.
1936:13 - With 4 vertices.
1936:14 - So we provide a value as 4.
1936:18 - And then we'll add an edge.
1936:22 - From 0.
1936:24 - To 1.
1936:28 - And then from 1 to 2.
1936:35 - Then from 2 to 3.
1936:41 - And finally from 3 to 0.
1936:47 - So friends here we have created one graph.
1936:49 - Of 4 nodes.
1936:50 - And we have added 4 edges.
1936:54 - So friends in order to test its working.
1936:56 - I'll create one method as.
1937:00 - 2 strings.
1937:05 - So friends this method will return back as a string representation of this graph.
1937:11 - So in the first step I will be creating a string builder.
1937:24 - So to this string builder.
1937:25 - First I will append.
1937:33 - Vertices.
1937:35 - And edges.
1937:47 - And then we'll provide a for loop.
1937:52 - And we'll simply iterate.
1937:55 - Over each and every vertex.
1937:57 - So you have to string builder will append v.
1938:14 - So friends here in the for loop.
1938:16 - We are getting each and every value of vertex.
1938:20 - So friends as we are looping over each and every vertex.
1938:23 - We have the vertex value.
1938:26 - We'll provide one more for loop.
1938:27 - Which will bring back the link list associated.
1938:30 - With that vertex.
1938:31 - And we'll iterate over it and print its content.
1938:34 - So here we'll provide one more for loop.
1938:41 - So in order to iterate over a link list associated with a particular vertex.
1938:44 - What we do is.
1938:50 - We simply pass the value of that vertex.
1938:52 - And we'll get the link list associated with it.
1938:55 - So here if I take an example.
1938:58 - Then we have added an edge.
1939:00 - From zero to one.
1939:02 - And there is one edge from three to zero.
1939:05 - Therefore when we call.
1939:07 - The link list associated with vertex zero.
1939:11 - Will get the two values.
1939:12 - One is the value one and one is the value three.
1939:14 - Because those two values are there in the link list.
1939:19 - So in this for loop will simply append.
1939:22 - The value present in the link list.
1939:24 - For that particular vertex.
1939:32 - And finally we'll append.
1939:36 - One line break.
1939:42 - And we simply return.
1939:47 - The string representation of the string builder.
1939:52 - So for now main method.
1939:54 - Will now sis out.
1939:58 - The value of G.
1940:00 - And we'll run this code.
1940:08 - So for and here you can see the graph is four vertices and four edges.
1940:12 - Because we initialize the graph with four vertex.
1940:15 - Therefore the value of these four.
1940:17 - Which is the number of vertex.
1940:19 - And as we have added four edges.
1940:21 - We are getting the value of the number of edges as four.
1940:28 - And here in the two string representation of it.
1940:30 - What we are doing is.
1940:31 - We are iterating over each and every vertex.
1940:33 - That is from zero one two and three.
1940:38 - And here you can see.
1940:39 - That there is an edge.
1940:41 - From zero to one.
1940:42 - And zero to three.
1940:44 - Therefore from the vertex zero.
1940:47 - There is an edge to one and there is an edge to three.
1940:50 - And similarly.
1940:52 - From vertex three there is an edge to two.
1940:54 - And there is an edge to zero.
1940:59 - There is an edge between two and three.
1941:01 - And three and zero.
1941:03 - So into the linked list of this third index there are values two and zero.
1941:07 - Which represent that there is an edge.
1941:10 - Between three and two and three and zero.
1941:13 - So from this is how we actually represent a graph.
1941:16 - Through an area of linked list.
1941:20 - I hope you like this video.
1941:22 - Thanks have a nice day.
1941:26 - Hello friends.
1941:27 - Welcome to my new data structures and algorithms in Java tutorial series video.
1941:32 - Friends in this tutorial we will discuss.
1941:35 - The breadth first search of an undirected graph.
1941:40 - So friends breadth first search is nothing but a traversal or a searching technique.
1941:44 - Which we apply to the graphs.
1941:46 - To visit each and every node of the graph.
1941:48 - So here breadth first search is also known as level order traversal.
1941:53 - So let's suppose we are given a graph of say five nodes.
1941:57 - Where zero one two three are connected by an edge.
1942:01 - And four is connected to two by an edge.
1942:04 - So therefore what do we mean by level order.
1942:07 - So suppose if you are starting from zero.
1942:10 - Then this is at level one.
1942:12 - So this will be visited first.
1942:13 - And then here you can see that from zero three and one are connected.
1942:20 - So these both nodes are at level two.
1942:22 - So after zero one and three will be visited.
1942:27 - Because they are at level two.
1942:29 - And then you can see that from three there is an edge to two.
1942:32 - And from one there is an edge to two.
1942:35 - So therefore the node two is at level three.
1942:38 - So after visiting one and three two will be visited.
1942:42 - Because it is at level three.
1942:44 - And then here you can see node four is connected to two.
1942:48 - Now this is at level four.
1942:50 - So therefore four will be visited after two.
1942:53 - So zero is at level one.
1942:55 - One and three are at level two.
1942:58 - Two is at level three.
1942:59 - And four is at level four.
1943:02 - So using breadth first search technique we can traverse the graph level by level.
1943:06 - So friends here is the algorithm for it.
1943:10 - So friends in this algorithm we usually use queue data structure.
1943:13 - So this data structure is nothing but FIFO data structure.
1943:17 - Which means first in first out.
1943:19 - So the element inserted into this data structure first will be first to be removed from the queue.
1943:25 - So we are using queue because it will help us in traversing the nodes of a graph level by level.
1943:32 - So friends we apply the same algorithm while we are traversing the tree.
1943:36 - But there is a slight catch in the graph.
1943:38 - Because in the graphs it may contain a cycle which you can see here.
1943:42 - So therefore we need to keep the track of the nodes which are being visited.
1943:46 - So we usually keep the track of the nodes into a boolean array.
1943:50 - So friends let's see the working of this algorithm step by step.
1943:54 - So we'll start with the value zero.
1943:57 - So in this method we'll pass the source node as zero.
1944:00 - So in first step what we do is.
1944:04 - We create a boolean array whose size is equal to the number of vertices in the graph.
1944:10 - So this vertices is nothing but the instance variable which we discussed in our previous
1944:14 - tutorial.
1944:16 - So here you can see in this graph there are five nodes.
1944:20 - Therefore we'll create a boolean array by name visited having a size of five.
1944:25 - So it would look something like this.
1944:26 - And as it is a boolean array so initially all the values inside this array is marked as false.
1944:34 - And we have marked it false because initially we haven't visited any node of the graph.
1944:40 - Moving ahead.
1944:43 - We'll then create a queue data structure.
1944:46 - Now this queue data structure will help us in traversing the nodes of a graph level by level.
1944:52 - So it would look something like this.
1944:54 - So here in our previous tutorial we also discussed how queue data structure works.
1944:59 - So you can watch my those tutorial to get more in depth of how queue works.
1945:04 - So it's simply a fee for data structure where element inside at first will be first to be removed.
1945:11 - Moving ahead.
1945:15 - Now friend as we are starting from zero.
1945:18 - So we will mark the visited index as true that we have visited this node.
1945:22 - In the area we'll make it true.
1945:25 - And here we'll mark it that we have visited this node.
1945:29 - So friends after we visit the node.
1945:33 - We simply put that node into the queue.
1945:35 - So as you have visited zero will put the zero into the queue.
1945:39 - So it would look something like this.
1945:42 - Moving ahead.
1945:45 - So friend as we want to traverse each and every node level by level then we'll apply a while loop.
1945:51 - And we'll check whether queue is empty or not.
1945:53 - So currently you can see queue is not empty because there is one value inside the queue.
1945:59 - So the condition in while block comes out to be true.
1946:04 - So in the first step we simply pull this element out of the queue
1946:08 - which is zero and we'll assign it to the integer variable u.
1946:11 - So it would look something like this.
1946:15 - And it will be assigned to you.
1946:18 - Moving ahead.
1946:21 - We'll simply print this element on the console that it is visited.
1946:26 - So zero is printed on the console.
1946:31 - So here in breadth first search after visiting any particular node.
1946:35 - We then go towards its adjacent nodes.
1946:38 - So here you can see the node adjacent to zero or one and three.
1946:43 - And in our previous tutorial we saw the representation of a graph through adjacency list.
1946:48 - So now we'll apply a for loop which will traverse the adjacent nodes of zero.
1946:55 - So here if you look the adjacency list of graph
1946:58 - then the node adjacent to u would look something like this.
1947:02 - That in the adjacency list zero is connected to one and zero is connected to three.
1947:07 - So here zero is connected to one and zero is connected to three.
1947:11 - So now we'll traverse each and every adjacent nodes of zero.
1947:14 - So we'll start with one.
1947:18 - So here v becomes one.
1947:24 - And the first I will check that whether one is already visited or not.
1947:28 - So here in the array we see that value of index one is false therefore it's not visited.
1947:37 - So in the if block first we'll mark this node as visited
1947:40 - by providing a value of true to index one of this boolean array.
1947:44 - So it would look something like this.
1947:47 - And here we'll mark it as visited.
1947:52 - And after marking the node as visited we'll simply put it into the queue.
1947:57 - So we'll put one into the queue so it would look something like this.
1948:04 - Moving ahead now v becomes three.
1948:11 - We check whether three is visited or not.
1948:13 - So here in the boolean array three is not visited.
1948:18 - So we will first mark three as visited by making the value as true.
1948:26 - That we have visited this node.
1948:29 - And then we'll simply put three into the queue.
1948:36 - Moving ahead now as we have visited all the adjacent nodes of zero therefore this
1948:42 - for loop will terminate.
1948:48 - And we will come back to our while loop and we'll check whether queue is empty or not.
1948:52 - So here you can see queue is not empty.
1948:57 - So we'll pull from the queue.
1949:00 - So one will be pulled out.
1949:02 - So it would look something like this.
1949:05 - And you will have value as one.
1949:07 - We will print one on the console that we have visited it.
1949:17 - So friends now we will actually traverse the adjacent nodes of one which is nothing but zero
1949:22 - and two because they are connected to one.
1949:26 - And if we look the adjacency list of one then it would look something like this.
1949:31 - That one is connected to zero and one is connected to two.
1949:35 - So now in the for loop we'll iterate over these two elements.
1949:38 - So we'll start with zero.
1949:40 - So v becomes zero.
1949:44 - We will check whether zero is visited or not.
1949:47 - So here you can see zero is already visited.
1949:52 - Therefore we'll simply skip this block.
1949:57 - And then now v becomes two.
1949:58 - We check whether two is visited or not.
1950:05 - So here you can see two is not visited.
1950:12 - So we will first mark the value at index two as true that we have visited this node.
1950:18 - And also we are marking it as we have visited this node.
1950:22 - Moving ahead.
1950:25 - And then we'll simply put the two into the queue.
1950:28 - So it would look something like this.
1950:33 - Moving ahead.
1950:35 - Now friends here you can see we have visited each and every adjacent nodes of one.
1950:41 - So therefore the for loop terminates.
1950:48 - And then we'll come back to our while loop.
1950:50 - We check whether queue is empty or not.
1950:52 - So queue is not empty.
1950:53 - We'll poll the first element from the queue which is three.
1951:00 - So it would look something like this.
1951:03 - And we'll assign its value to u.
1951:04 - So u becomes three.
1951:08 - Moving ahead.
1951:11 - We simply print three on the console that we have visited.
1951:18 - And friends then will provide a for loop which will iterate over the adjacent nodes of three.
1951:23 - So here you can see the adjacent nodes of three are zero and two.
1951:28 - So if we see the adjacency list of three then it would look something like this.
1951:33 - That three is connected to zero and three is connected to two.
1951:37 - So now we will visit the adjacent nodes of three and we'll start with zero.
1951:42 - So we become zero.
1951:47 - We check whether zero is visited or not.
1951:50 - So here you can see that zero is visited.
1951:55 - So we simply skip this if block.
1952:01 - Now v becomes two.
1952:06 - And we check whether two is visited or not.
1952:09 - So here you can see two is already visited.
1952:13 - Therefore we simply skip the if block.
1952:15 - So friends there are no more adjacent nodes to three.
1952:18 - So therefore this for loop will terminate.
1952:26 - We'll come back to our while block.
1952:29 - We check whether q is empty or not.
1952:31 - So q is not empty.
1952:35 - We pull the first element from the q which is two.
1952:38 - So it would look something like this.
1952:40 - So it would look something like this.
1952:45 - And we'll assign it to integer variable u.
1952:49 - So u becomes two.
1952:54 - And then we'll simply print the value of u on the console that we have visited it.
1953:02 - So friends now we will actually traverse the adjacent nodes of two.
1953:06 - So here you can see the nodes adjacent to two are three.
1953:10 - One and four because they all are connected by two.
1953:15 - So if you look the adjacency list of value two then it would look something like this.
1953:20 - That two is connected to three.
1953:23 - Two is connected to one and two is connected to four.
1953:27 - So therefore now we'll traverse each and every adjacent nodes of two.
1953:32 - So we'll start with three.
1953:33 - So v becomes three.
1953:36 - Moving ahead.
1953:37 - We will check whether three is already visited or not.
1953:42 - So here you can see in the visited array at index three the value is already true.
1953:48 - And it's already visited.
1953:50 - Therefore we simply skip this if block.
1953:55 - Now v becomes one.
1954:00 - We know that we already visited one.
1954:04 - Therefore we'll skip this if block.
1954:07 - Now v becomes four.
1954:15 - And here we'll check whether we have visited four or not.
1954:17 - So we haven't visited four because the valued index four in the visited array is false.
1954:25 - So in the first step what we'll do we'll mark this value as true that we are visiting it.
1954:33 - Moving ahead.
1954:34 - And then we'll simply offer four into the queue.
1954:40 - So it would look something like this.
1954:47 - So friends now there are no more adjacent nodes left to be traversed.
1954:51 - So this for loop will terminate.
1954:57 - We'll again check whether queue is empty or not.
1954:59 - So queue is not empty.
1955:05 - We'll pull the first element out of the queue which is four.
1955:09 - So it would look something like this.
1955:13 - And we'll simply assign this value to u.
1955:16 - So u becomes four.
1955:22 - We'll print this value on the console.
1955:27 - And then we'll simply traverse the adjacent nodes to four.
1955:31 - So here in the diagram you can see the adjacent nodes to four is only two.
1955:36 - So if you see the adjacency list of index four.
1955:39 - So it would look something like this.
1955:42 - That there is only one node which is adjacent to four.
1955:47 - So v becomes two.
1955:53 - We'll check whether two is visited or not.
1955:55 - So here you can see two is already visited because the value
1955:59 - at index two of the visited array is true.
1956:02 - So we simply skip this if block.
1956:07 - And here we already visited all the nodes adjacent to four.
1956:11 - So therefore this for loop will terminate.
1956:18 - We'll check whether queue is empty or not.
1956:20 - So currently you see queue is empty.
1956:22 - Therefore condition in while block comes out to be false.
1956:24 - So friends here you can see that we have visited each and every node
1956:30 - of this graph using breadth first search algorithm.
1956:34 - And you can see in the output that we have visited all the nodes level by level.
1956:39 - So we started with level one which is zero.
1956:42 - So we visited it.
1956:44 - Then we went to level two where there were one and three.
1956:48 - So we visited those two nodes.
1956:50 - Then we went to level three where the only node was two.
1956:54 - So we visited two.
1956:55 - And then we went to level four where the only node was four.
1956:58 - So we visited four.
1957:01 - So friends this was a demonstration of the algorithm.
1957:04 - Now let's go to Eclipse and see the working of this code.
1957:10 - In our previous tutorial we actually saw the demonstration of breadth first search algorithm
1957:14 - in Java.
1957:16 - So in this tutorial we'll actually code that algorithm and see it's working.
1957:20 - So friends in my previous tutorial I have created one class by name graph and we represented graph
1957:28 - using an adjacency list.
1957:31 - So friends in order to understand more about graph you can watch my previous tutorials.
1957:36 - So in this tutorial we will actually code the breadth first search technique.
1957:43 - So here I will be providing one method.
1957:46 - My name BFS.
1957:50 - And as we know that this method will take a source value.
1957:58 - Which would be nothing but a starting point from where we will actually start our breadth first search.
1958:05 - So in the first step what we do is we actually create a boolean array
1958:08 - which will actually keep the track of the visited nodes.
1958:16 - I'll give the name as visited.
1958:20 - And friends here you can see that to this graph we are actually storing
1958:28 - the number of vertices into this instance variable v.
1958:33 - So the size of this boolean array would be v.
1958:39 - Moving ahead and then we'll simply create a queue.
1958:50 - So we'll import it from java.util package.
1959:01 - Friends moving ahead we'll mark the source node as visited.
1959:10 - By assigning a value true to the visited array at index s.
1959:14 - And then we'll simply offer s into the queue.
1959:24 - Which we actually discussed in our previous tutorial.
1959:28 - Then we'll simply provide a while loop.
1959:32 - And inside this while loop we place a condition that whether queue is empty or not.
1959:39 - So this while loop execute if queue is not empty.
1959:41 - So in the first step what we do we simply poll an element from the queue.
1959:53 - And after polling the element from queue we simply print it on the console.
1960:06 - So friends whatever the element we have pulled from the queue
1960:09 - then we simply traverse its adjacent nodes which we actually discussed in our previous tutorial.
1960:14 - So we'll provide a for loop which will traverse the adjacent nodes to u.
1960:21 - So let's say we give it as v. And in order to get the adjacent nodes to u
1960:29 - we simply bring the adjacency list at index u.
1960:33 - So friends in order to understand this more you can watch my previous tutorial that what
1960:37 - is adjacency list and how we can fetch the linked list associated with any particular index.
1960:45 - Moving ahead we will check that whether v is visited or not.
1960:58 - So if it is not visited then we'll simply
1961:02 - mark it as visited by assigning the value as true.
1961:11 - And then we'll simply offer it to the queue.
1961:18 - So friends in our previous tutorial also we discussed that this boolean array is kept to
1961:23 - keep the track of the visited nodes. We are using this queue which will help us in traversing of
1961:29 - this graph level by level. So what here we do is we actually visit a particular node at level
1961:36 - and after visiting it we'd go to its next level.
1961:40 - So friends this is the algorithm for the breadth first search. Now let's test it's working.
1961:47 - So here you can see we have already created a graph of four nodes. So here we will apply
1961:52 - this breadth first search to the graph which we saw in the slide. So that slide had five nodes.
1961:57 - So I will provide a value of five here and here you can see that there is an edge from zero to one
1962:03 - one to two two to three and three to zero. So we'll provide one more edge
1962:11 - from two to four which we actually saw in the slide.
1962:19 - And then we'll finally call the breadth first search method.
1962:21 - And let's say we are giving the source node as zero. So if I run this code now.
1962:34 - So friends here you can see it printed zero one three two four and we also know that as you
1962:40 - started from zero so this was at level one and from zero one and three were connected which we
1962:47 - actually saw in the previous tutorial. So they printed after that two was connected to one and
1962:54 - three. So then two was printed and finally four was connected to two. So four got printed.
1963:01 - So here you can see that we have traversed each and every node level by level.
1963:09 - I hope you like this video. Thanks have a nice day.
1963:12 - Hello friends. Welcome to my new data structures and algorithms in Java tutorial series video.
1963:22 - Friends in this tutorial we will discuss depth first search of an undirected graph.
1963:31 - So friends in our previous tutorial we actually discussed breadth first search traversal of a
1963:36 - graph. So in this tutorial we'll discuss the iterative way to perform depth first search traversal
1963:42 - of a graph. So friends here you can see that we are given an undirected graph. So by undirected
1963:50 - graph we mean that that edges that don't have any direction. So if you are on any particular
1963:56 - node let's say zero then we can go to one and if you are on one then we can go to zero.
1964:02 - So the edges don't have any direction. Therefore this is an undirected graph.
1964:08 - So you can see the algorithm to perform depth first search of an undirected graph.
1964:14 - So let's see the demonstration of this algorithm step by step.
1964:19 - So friends whenever you perform depth first search on an undirected graph we usually pass
1964:24 - in the source node that from where we need to start the depth first search.
1964:28 - So let's say we start our depth first search from zero. So the value of s will become zero.
1964:39 - So friends whenever we traverse any undirected graph we usually keep the track of its node
1964:45 - through a boolean array which actually tells us that which node is visited and which node is not.
1964:52 - And which node is not because here you can see the graph may contain a cycle and we don't want
1964:58 - to visit any particular node more than once. Therefore we keep the track of each and every
1965:03 - node into this boolean array. So whenever we initialize this array we actually pass
1965:09 - the size as the number of vertices. So here you can see the number of vertices are five.
1965:15 - So this boolean array will look something like this.
1965:17 - That here each index represent a node and at the start each and every value in this
1965:24 - boolean array is false because we haven't visited any of the node till now. Moving ahead.
1965:32 - So friends in order to perform depth first search in an undirected graph
1965:36 - we usually take the help of stack. So the stack data structure is nothing but LIFO data structure
1965:43 - which means last in first out. So the element inserted last into the stack will be the first
1965:48 - one to be removed. For more detailed information about the stack you can watch my previous tutorials.
1965:56 - So here in this step we'll simply create a stack of integers.
1966:02 - So currently stack is empty. Moving ahead.
1966:05 - So here first we push the source node into the stack.
1966:14 - So zero will be on the stack. Moving ahead.
1966:20 - So friends whenever we want to perform depth first search of an undirected graph
1966:24 - we are providing a while loop and inside this while loop we are providing a condition
1966:29 - that whether stack is empty or not. So when the stack is not empty this while loop executes.
1966:35 - So currently you can see stack is having one element.
1966:39 - Therefore stack is not empty. So the condition in while block comes out to be true.
1966:47 - So in the first step what we do we simply pop the element from the stack
1966:51 - and we'll assign it to an integer variable u. So it would look something like this.
1966:57 - That zero will be popped out.
1966:59 - And it will be assigned to integer variable u. So u is having value as zero. Moving ahead.
1967:12 - So then we actually check that whether we have actually visited zero or not.
1967:17 - So here in the visited array at zeroth index we see the value.
1967:22 - So currently you can see the value is false. Therefore we haven't visited this node.
1967:26 - So the condition in if block comes out to be true.
1967:35 - And in the block we simply mark the value at index zero is true.
1967:41 - That we are now about to visit this node.
1967:47 - And we'll simply print it on the console.
1967:49 - So zero is printed on the console. Moving ahead.
1967:58 - So friends in depth first what we do is whenever we visit any particular node
1968:02 - then we look for its adjacent nodes. So here the adjacent nodes of zero are one and three.
1968:10 - And in our previous tutorial we also discussed about the adjacency list.
1968:14 - So the adjacency list of zero would be a linked list having the values as one and three.
1968:22 - So it would look something like this.
1968:26 - The adjacency list of zero will have values as one and three.
1968:31 - Because these two nodes are adjacent to zero.
1968:34 - For more information about the adjacency list you can watch my previous tutorials on graph.
1968:38 - So here we are providing a for loop which will iterate over each and every element
1968:45 - of this adjacency list. So we'll start from one. The value of v becomes one.
1968:56 - And in the for loop we'll check whether we have visited v or not.
1969:00 - So value of v is one and the value at index one is false. Therefore we haven't visited this node.
1969:07 - So the condition in if block comes out to be true.
1969:12 - So in the if block we simply push one on the stack.
1969:17 - Moving ahead after visiting one we go to three. So now v becomes three.
1969:29 - We check whether we have visited three or not.
1969:32 - So here in the visited array at index three the value is false.
1969:36 - Therefore we haven't visited this node. So the condition in if block comes out to be true.
1969:44 - And we'll simply push three on the stack.
1969:48 - Moving ahead.
1969:52 - So friends now we have traversed each and every element of this adjacency list.
1969:56 - So this for loop will terminate and the call will reach back to this while loop.
1970:09 - So in the while loop we'll again check whether stack is empty or not.
1970:12 - So here you can see stack has two elements. Therefore it's not empty.
1970:16 - So the condition in while block comes out to be true.
1970:19 - So the first step will simply pop an element from the stack and will assign it to you.
1970:28 - So you will hold the value as three.
1970:34 - Moving ahead.
1970:37 - We then check whether we have visited the value three or not.
1970:40 - So here you can see in the visited array at index three the value is false.
1970:45 - Therefore the condition in if block comes out to be true.
1970:49 - So in the if block first we mark the valued index three as true.
1970:57 - That we have visited this node.
1971:02 - And then we'll simply print it on the console.
1971:05 - Which signifies that we have visited this node.
1971:10 - So friends after you visited three we look for its adjacent nodes which is zero and two.
1971:16 - So the adjacency list of three will look like that it has value zero and two which are adjacent to
1971:25 - three and will provide a for loop and will iterate over each and every element adjacent to three.
1971:33 - So we'll start with zero. So we become zero.
1971:36 - We'll check whether we have visited zero or not. So here you can see the valued index zero is true.
1971:50 - Therefore we have visited this node. So the condition in if block comes out to be false.
1971:55 - Now V becomes two.
1972:04 - We check whether we have visited two or not. So here you can see the valued index two is false.
1972:10 - Therefore we haven't visited this node. So the condition in if block comes out to be true.
1972:17 - And we'll simply push two on the stack.
1972:20 - Moving ahead, so friends we have visited each and every adjacent nodes to three.
1972:28 - So this for loop will terminate and the call will reach back to this while loop.
1972:38 - We again check whether stack is empty or not. So here you can see stack is not empty because
1972:43 - it contains two elements. So the condition in while block comes out to be true.
1972:50 - In the first step, we'll simply pop an element from the stack and we'll assign it to you.
1972:56 - So here you will become two.
1973:02 - We check whether we have visited two or not. So here you can see
1973:07 - the valued index two is false. Therefore we haven't visited this node.
1973:12 - So the condition in if block comes out to be true.
1973:14 - And in the if block first will mark the valued index two to be true that we have visited this
1973:22 - node now. And then we'll simply print two on the console.
1973:32 - Moving ahead. So friends after visiting this node,
1973:37 - we actually look for adjacent nodes which is three, one and four.
1973:44 - So the adjacency list of node two will look something like this.
1973:49 - That it has three values, three, one and four, because these three nodes are connected to two.
1973:57 - And we will iterate over each and every element of this linked list.
1974:01 - So we'll start with three. So here V becomes three.
1974:04 - We check whether we have visited three or not. So here you can see the valued index
1974:15 - three is true. Therefore, we have visited the node three. So the condition in if block comes
1974:21 - out to be false. And now we will become one.
1974:26 - We check whether we have visited one or not. So here you can see the valued index one is false.
1974:38 - Therefore, we haven't visited one. So the condition in if block comes out to be true.
1974:45 - And we'll simply push one on the stack.
1974:47 - And now we will become four.
1975:02 - We will check whether we have visited four or not. So here you can see the valued index
1975:06 - four is false. Therefore, we haven't visited this node. So the condition in if block comes out to
1975:11 - be true. And we'll simply push four on the stack. So friends, here we have visited each
1975:23 - and every element adjacent to two. Therefore, this for loop will terminate. And the call will
1975:30 - reach back to this while loop. We check whether stack is empty or not. So here you can see stack
1975:40 - is not empty, because it contains three elements. So the condition in while block comes out to be
1975:46 - true. We pop the element from the stack, and we'll assign it to you. So the topmost element on the
1975:55 - stack is four. So four will be popped out. And the value will be assigned to you. So you will have
1976:02 - four. We check whether we have visited four or not. So here you can see that valued index four is
1976:12 - false. Therefore, we haven't visited four. So the condition in a block comes out to be true.
1976:20 - And in the block, first will mark the valued index for to be true that we have visited this node.
1976:26 - And we'll simply print it on the console. So friends, after visiting node four, we'll look
1976:39 - forward to adjacent nodes. So here you can see the adjacency list of four will look something like
1976:44 - this. The linked list will have only one element which is two, because only two is connected to
1976:50 - four. And here we are providing for loop, so that we can iterate each and every element adjacent to
1976:58 - four. So we'll start with two. So here we will become two. And we check whether we have visited
1977:09 - two or not. So here you can see the value at index two is true. Therefore, you already visited this
1977:15 - node. So the condition in a block comes out to be false. And also friends here we have visited
1977:24 - each and every element adjacent to four. Therefore, the for loop will terminate. And call will reach
1977:34 - back to while loop. We again check whether stack is empty or not. So here you can see stack has two
1977:40 - elements, therefore, it's not empty. So the first step will simply pop the element from the stack
1977:49 - and will assign it to you. So the last element inserted in the stack is one, therefore, one will
1977:56 - be popped out. So you will now have value as one. Moving ahead, we check whether you visited one or
1978:06 - not. So here you can see the value at index one is false. Therefore, we haven't visited one. So
1978:12 - the condition in a block comes out to be true. So in the block will simply mark the value at index
1978:20 - one to be true that we have visited this node now. And we'll simply print it on the console.
1978:27 - And then we'll provide a for loop so that we can traverse our adjacent nodes to one.
1978:40 - So friends, after visiting the node one, we'll look for adjacent nodes, which is nothing but
1978:44 - zero and two. So the adjacency list of one will look something like this, that node adjacent to
1978:50 - one is zero and two. So we'll provide a for loop and we will iterate each and every element
1978:56 - adjacent to one. So we'll start with zero. So we become zero.
1979:06 - We'll check whether we have visited zero or not. So here you can see the value at index zero is
1979:11 - true. Therefore, we already visited zero. So the condition in a block comes out to be false.
1979:20 - Now we becomes two.
1979:21 - And we will check whether we have visited two or not. So here you can see the value at index
1979:30 - two is true. So the condition in a block comes out to be false. And also friends, we have visited
1979:40 - each and every node adjacent to one. So this for loop will terminate and the call will reach back
1979:46 - to this while loop. We again check whether stack is empty or not. So here you can see stack has
1979:55 - one element, therefore it's not empty. So the first step will simply pop an element from the stack
1980:02 - and we'll assign it to you. So one will be popped out and you will have value as one.
1980:08 - Then we'll simply check whether we have visited one or not. So here you can see the value at index
1980:17 - one is true. Therefore we have already visited the node one. So the condition in a block comes
1980:22 - out to be false. We again check whether stack is empty or not. So here you can see stack is empty.
1980:33 - So the condition in while block comes out to be false and while block terminates.
1980:38 - So friends, here you can see using this depth first search algorithm, we have visited each
1980:45 - and every node of the graph. So friends in this tutorial, we actually saw the demonstration of
1980:51 - this algorithm. Now let's go to Eclipse and see the working of this code.
1981:00 - Hello friends, in our previous tutorial, we actually discussed the depth first search
1981:04 - algorithm of an undirected graph. So in this lecture, we'll actually code the algorithm and
1981:10 - we'll test its working. So friends in our previous lectures, we actually created one class by name
1981:17 - graph and we have implemented the graph using the adjacency list. We also discussed the breadth first
1981:29 - algorithm. So in this tutorial, we'll actually discuss the depth first search algorithm.
1981:37 - So here we will be creating one method as public void DFS.
1981:48 - And we also know that the depth first search will start from a source node.
1981:52 - So S will represent the source node. So friends in our previous lecture, we actually saw the
1982:03 - demonstration of the depth first search step by step. So friends in the first step will simply
1982:09 - create a Boolean array. We'll give it a name as visited and we'll initialize this Boolean array.
1982:22 - With a size equal to the vertices of the graph. So friends here we have created this Boolean array
1982:30 - which will keep the track of the nodes which we already visited. Because while traversing a graph,
1982:36 - there may come a situation where graph contains a cycle. So in order to visit a particular node
1982:42 - only once, we usually create this Boolean array, which will keep the track of the nodes which are
1982:48 - visited. And then we'll create a stack. So we'll import the stack from java.util package.
1983:12 - So friends, we are using this stack which will help us in performing depth first search.
1983:20 - And its significance we already discussed in our previous lectures.
1983:26 - So after creating the stack, we'll simply push the source vertex on the stack.
1983:37 - And then we'll provide a while loop.
1983:42 - So in this value, we'll provide a condition that whether stack is empty or not.
1983:53 - So this while loop will keep executing with a condition that whether stack is empty or not.
1984:00 - So the stack is not empty, this while loop will keep on executing.
1984:05 - So inside this while loop, as we discussed in our previous lecture, that we pop the element
1984:12 - from the stack, and we'll assign it to you.
1984:19 - And then we simply check that whether you visited you or not.
1984:30 - So if we haven't visited you, so the condition in a block comes out to be true.
1984:34 - So first, we'll mark the value at index u to be true.
1984:44 - That we have visited this node, and we'll simply print u on the console.
1984:56 - So friends, after visiting you, we simply provide a for loop.
1985:04 - Which will iterate over each and every element adjacent to you.
1985:12 - So friends, here after visiting any particular node, we'll look for its adjacent nodes.
1985:17 - And we can get the adjacent nodes to the adjacency list.
1985:22 - And we'll simply iterate each and every element of this adjacency list one by one.
1985:29 - So in the for loop, we simply check.
1985:34 - That whether the adjacent node to you, which is v, has been visited or not.
1985:43 - So if the node is not visited, we simply push it on the stack.
1985:53 - And this we do for each and every element adjacent to the already visited node.
1985:59 - So friends, this is the code to perform depth first search over an undirected graph.
1986:04 - Now let's test it working in the main method.
1986:10 - So here you can see we have created a graph with five nodes.
1986:14 - And we have added the edges between the nodes, say from zero to one, one to two, two to three,
1986:20 - three to zero and two to four. So this is the same graph which we discussed in our previous lecture.
1986:28 - So here in the main method, we simply call the DFS method.
1986:34 - And we'll pass the value of the source node at zero.
1986:38 - That we have to start our depth first search from the node zero.
1986:44 - So if I run the code now.
1986:51 - So friends, here you can see it printed each and every node of the graph in the following order.
1986:58 - First it printed zero, then three, then two, then four, and then one.
1987:04 - So this is the same model which we discussed in our previous lecture
1987:07 - while demonstrating this algorithm step by step.
1987:13 - So friends, this is how we actually perform a depth first search over an undirected graph.
1987:20 - I hope you like this video. Thanks. Have a nice day.
1987:27 - Hello, everyone. So in this video, we will be looking into the recursive depth first search
1987:33 - algorithm to traverse an undirected graph. So in our previous video, we actually saw the depth
1987:39 - first search using the iterative approach. So in this video, we'll see that how recursive
1987:46 - algorithm works. So here you can see that this is the algorithm which is recursive depth first search.
1987:54 - Here you can see this DFS is calling itself here, making it recursive in nature.
1988:00 - So let's see the demonstration of this algorithm step by step.
1988:04 - But before we start, in case if you're new to my channel, then please subscribe to my channel
1988:10 - and click the bell icon so that you never miss any update.
1988:14 - In our previous video, where we discussed about the iterative approach,
1988:19 - we used the stack data structure to traverse the graph.
1988:23 - And in our previous algorithm, where we saw breadth first search and depth first search
1988:30 - iterative, there we were given with a source vertex. And from there, we started our DFS.
1988:38 - But usually the graph is given in form of like this. So here you can see zero, one, two, three,
1988:46 - four, they are connected together. And there is one more node, which is five. So this vertex
1988:53 - is not connected with the rest of the elements. So basically, a graph is provided like that,
1989:00 - that there could be components, which are basically disconnected. So we need to visit this graph,
1989:06 - and it's each vertex. So here, we actually use this for loop, which travels each and every vertex
1989:13 - and help us visiting the vertex using depth first search. So let's see the demonstration of this
1989:21 - algorithm step by step. So here as the algorithm is recursive, we will keep the track of the DFS
1989:28 - method which is getting called on a call stack. And here you can see, when we are calling DFS
1989:36 - on any particular vertex v, after visiting it, we try to traverse its adjacent nodes one by one.
1989:44 - So those adjacent nodes we denoted by W. And if they are not visited, we call the DFS again,
1989:51 - we pass the W value to it, because we want to not traverse the adjacent vertex to v.
1989:58 - So when this DFS will be called, this W will become our new v. So we need to keep that in mind
1990:06 - while traversing our call stack. So at the start, we simply call DFS.
1990:13 - So one method is on the call stack. Now friend as this graph can be connected,
1990:22 - and can form a cycle. So when we perform DFS, this visited array, which is Boolean, help us in
1990:30 - knowing that which which nodes are already visited, or which vertex are already visited.
1990:36 - So this capital v, we already discussed in our previous videos that that this represent a number
1990:42 - of vertexes. So currently we have six vertex from zero to five. So we created a Boolean array of
1990:50 - six elements. We start from v equal to zero. So v is zero.
1991:02 - We first check whether v is already visited or not. So currently, we see at index zero,
1991:08 - v f falls. So therefore it's not visited. So we call DFS. And as we are leaving this DFS at line
1991:16 - number five, we update line number here. So now there will be one more method on the call stack
1991:25 - with vs zero and the visited array you can see here. So when we call DFS on any vertex,
1991:38 - the first thing we do is we mark that vertex as true that we have visited.
1991:45 - So we mark it as true. And here you can see we made it yellow.
1991:50 - And by visiting the node, we mean processing the node. So here, we are simply printing it
1991:59 - on the console. So zero will be printed. Now we look for the adjacent nodes to vertex zero.
1992:08 - So this adjacency list we discussed in our previous videos. So this adjacency list
1992:15 - is an instance variable, which holds all the vertex and their corresponding edges.
1992:22 - So when we do adjacency of zero, it has two elements one and three, because these two
1992:29 - elements are adjacent to zero, and they are connected. So it looks like this. So after
1992:35 - traversing zero, we try to traverse these adjacent nodes. So we can start from any node.
1992:42 - So here we pick three. So here you can see W becomes three.
1992:51 - We check that whether three is visited or not. So here you can see three is not visited.
1992:58 - So we call recursively depth for search on three. So this three which is W, when we will call DFS
1993:07 - again, it will become our new vertex to visit. And here you can see we are leaving this DFS on
1993:13 - line number 15. So we need to update line number here. Because once this DFS will finish,
1993:20 - we should know that from where we need to start this DFS. So we update line number 15 here.
1993:26 - And there will be one more method on the call stack with our new V as three. So you can think
1993:37 - of it something like this, we are going like this. Moving ahead, V becomes three. We mark three as
1993:47 - visited like this. And then we print it on the console. And then we look for the adjacent elements
1994:01 - to three. So if we see the adjacent elements to three, we will get zero and two. So the adjacency
1994:09 - list of three will give us zero and two. Now we need to visit zero and two, because those are adjacent
1994:19 - to three. So we can start with any node. So we pick zero. So W becomes zero.
1994:32 - We check whether zero is already visited or not. So here you can see zero is already visited,
1994:38 - marked as yellow. So this condition comes out to be false.
1994:44 - So now we go with vertex two. So W will become two now.
1994:55 - We check whether two is visited or not. So here you can see two is not visited,
1994:59 - it is marked as false. So this condition comes out to be true. And now we again call DFS
1995:07 - with WS2. We are leaving at line number 15. So first we update line number here.
1995:16 - There will be one more method on the call stack,
1995:21 - where we will become two, because now we need to traverse two.
1995:27 - So we first mark two is visited like this. Then we print it on the console
1995:41 - two. And then we try to traverse its adjacent vertices. So here you can see adjacent to two
1995:50 - is three, one and four. So the adjacency list will give us three, four, one. So we can start
1996:00 - with any node. So we start with three. So W will become three here. We check whether three
1996:09 - is visited or not. So here you can see three is already visited. So this condition comes out to be
1996:16 - false. We then take four, W becomes four. We check whether four is visited or not. So four is
1996:29 - not visited. So then we do the DFS on four. So we call DFS with WS4. We first update the line
1996:40 - number here, because we are leaving this DFS now. So there is one more method on the call stack.
1996:54 - With our new vertex to visit is four. So V becomes four.
1997:01 - We first mark index four as true, because we are about to visit it.
1997:12 - We print it on the console. So four gets printed. And now we check for the adjacent elements to
1997:19 - four. So here you can see the elements connected to four is only two. So its adjacency list
1997:26 - will have only two. So we try to visit two now. So W becomes two. We check whether two is visited
1997:40 - or not. So here you can see two is visited. So this condition comes out to be false.
1997:46 - And here you can see the adjacent elements of vertex four is all visited. So now this
1997:56 - for loop will terminate. And this DFS will also get terminate. And our call will reach to that
1998:05 - DFS which actually called this DFS. Because we are done with the all the adjacent elements of vertex
1998:14 - four. So this method will be removed from the call stack. And the execution point will reach here.
1998:23 - And we know that we had left this DFS at line number 15. So we start our execution from line
1998:30 - number 15. And when we left this DFS, the value of V was two. And the value of W was four.
1998:41 - So it means we were traversing the adjacent elements of two. And we just visited four.
1998:49 - So if we see the adjacency list of two, we visited three already. Then we went to four. So we are
1999:01 - done with four also. So now our time is to visit one. So W will become one in the next iteration.
1999:10 - One. We check whether one is visited or not. So one is not visited. So this condition comes
1999:23 - out to be true. And we call DFS again with W as one. So we update the line number 15 here.
1999:31 - There will be one more method on the call stack with V as one. We mark vertex one as visited.
1999:49 - We print one on the console. So this is also visited. And now we actually check the adjacent
2000:02 - elements of one. So you can see it as zero and two. Zero and two. So we start with zero. W becomes
2000:16 - zero. Zero. So here you can see zero is already visited. So this condition comes out to be false.
2000:27 - Then we go to vertex two. W becomes two. And two is also visited. So this condition comes out to
2000:39 - be false. So here you can see all the elements adjacent to vertex one are visited. So this for
2000:51 - loop will terminate and this DFS method will be removed from the call stack. And execution
2001:00 - point will reach here. So we start this DFS from line number 15. And we were actually traversing
2001:08 - vertex two. And the recent adjacent element we visited was one. So W becomes one and V becomes
2001:17 - two. So if we see the adjacency list of two, we are done with three, four and one. So in the next
2001:28 - iteration, this for loop will terminate because there are no more adjacent elements to vertex two.
2001:36 - So now this DFS will end. And call will reach to its previous DFS. We will start from line number
2001:50 - 15. And we had left this DFS when value of V was three. And the recent adjacent element to three,
2002:00 - which we tried to visit were two. So V is three, W is two.
2002:08 - So if we see the adjacency list of three, here you can see zero, we already visited.
2002:15 - And we went to two and two also we visited. So now this DFS will end for vertex three.
2002:21 - The execution point reached here. We start from line number 15. And when we left this DFS,
2002:33 - we were actually visiting the adjacent elements of vertex zero. And the recent we visited was three.
2002:40 - So V is zero. And W is three. And if you see the adjacency list of zero. So here you can see
2002:53 - the recent element we visited was three. So now we go with the vertex one. So W becomes one,
2003:02 - one. We check whether one is visited or not. So here you can see this visited array is helping us
2003:10 - to not to visit the vertex again, because one is already visited. It is marked as true.
2003:18 - So this condition comes out to be false. So now we are done with the adjacency list of zero.
2003:25 - So this DFS will end. And this method will be removed from the call stack.
2003:30 - And we go back to the starting DFS method, where we left at line number five.
2003:40 - So we start from line number five. And we are done with visiting zero vertex.
2003:49 - So here you can see this for loop will now help us in visiting five. Because when we started with
2003:54 - zero, all these nodes are directly or indirectly connected with zero. So we visited everyone using
2004:02 - the DFS. So this file is not connected to any of these vertices. So using this for loop,
2004:10 - we will visit five as well. So we'll increment V, V becomes one. So vertex one is visited,
2004:20 - so we do nothing. V becomes two. So two is visited, we do nothing.
2004:32 - V becomes three. Three is also visited. So we do nothing.
2004:42 - Four is also visited. And now V becomes five.
2004:50 - So here five is not visited. So we call DFS on vertex five. We update the line number.
2005:04 - And here we call this DFS with five. So here, it should be five. Because we are leaving this
2005:12 - DFS when vertex V was five. So now we call DFS on vertex five. We mark vertex as visited.
2005:26 - This is visited now. We print it on the console. And then we try to visit
2005:35 - the vertex five adjacent elements. So here you can see, there are no adjacent elements to vertex
2005:40 - five. So this for loop will terminate. And this DFS method will be removed from the call stack.
2005:49 - And we go back to the previous DFS at line number five, where V was five.
2005:57 - And then we increment V, it becomes six. So now this for loop will terminate.
2006:03 - And everything will be removed from the call stack.
2006:10 - So you can see, in this order, we visited each and every vertex of the graph.
2006:18 - And here using this for loop, we even visited vertex which were disconnected.
2006:24 - So friend, this was all about the recursive depth first search. I hope you must have liked this
2006:31 - video. In case if you are new to my channel, then please subscribe to my channel and click
2006:36 - the bell icon so that you never miss any update. Thanks, have a nice day. Hello everyone. So in
2006:44 - this video, we are going to discuss that what are connected components in an undirected graph.
2006:51 - So friends, here you can see that we are given a graph having six nodes from zero to five.
2006:57 - Now here if you see that we have three connected components. So one is
2007:04 - having nodes zero, one and three, which is this connected component.
2007:11 - Another connected component is two and four. And the third connected component is
2007:19 - a component having only one node, which is five. So usually with a graph, we are given a graph in
2007:28 - a form of connected components. So one such query comes is that we need to evaluate that in a graph,
2007:35 - how many connected components are there. So in this graph, we have three connected components.
2007:42 - And also one such query comes is we are given with two vertices, let's say zero and two.
2007:47 - And we need to find whether zero and two are connected or not. So here you can see zero is
2007:54 - in the first connected component and two is in the second connected component. Two is connected
2007:59 - with four, zero is connected with one and three. So zero and two are not connected. So such queries
2008:06 - are given. So usually in real world, let's say we can think of this connected components as
2008:12 - a graph of a small region, where this three nodes form a road, this two forms another road.
2008:20 - And there could be a query that whether this road is connected with this road or not. And similarly,
2008:26 - for other applications, we can think as network connections, we just need to query whether this
2008:31 - connection and this connection are connected or not. So such queries can be handled via connected
2008:38 - components. So in this video, we are going to see the algorithm that how we can figure out
2008:44 - the numbers of connected component and how we can figure out whether any node is connected to another
2008:49 - node or not. So here is the algorithm. And here we are using the same graph which we discussed in
2008:56 - our previous slide. So let's see the demonstration of this algorithm step by step. So friends,
2009:02 - before we start, in case if you want to master data structure and algorithm, you can subscribe
2009:07 - to my channel and click the bell icon so that you never miss any update. So here you can see
2009:13 - that to find the number of components and to find whether any of the vertices are connected or not,
2009:20 - we need to process each and every node. So here what we do is we apply the depth first search.
2009:26 - Now this algorithm is recursive in nature. Here you can see depth first search is again calling
2009:31 - here itself. So it's a recursive algorithm. So therefore we will maintain the calls to the DFS
2009:39 - in the call stack. And we need to keep the track of the vertices we are visiting. So at the start,
2009:46 - we call DFS. Now when this method starts execution, there will be one method on the call stack by
2009:52 - name DFS. And now this method will start its execution. So we are storing the state of v,
2010:00 - w and count for this DFS. And this we will do for each and every recursive calls here. Because when
2010:08 - we are calling this DFS from this DFS, this method will store the state into the call stack. And then
2010:17 - it will again call DFS. So once this DFS will end, the method will return to this DFS. And we will
2010:24 - assign back the values of the variables from where this DFS is left. Moving ahead. So friends
2010:33 - here you can see that as we are calling this DFS on an undirected graph, there could be a possibility
2010:40 - that this graph contains a cycle like this. So what happens is we create a boolean array visited.
2010:48 - Now this boolean array will help us to check whether any of the vertices are already visited
2010:54 - or not. Because let's say if we visit zero, then one, and then three, then from three, if we go to
2011:00 - zero, this boolean array will help us knowing that zero is already visited. So in order to keep the
2011:07 - track of visited node, we create a boolean array. And here in our previous videos, we know that
2011:13 - the capital V is nothing but number of vertices. So currently we have six vertices from zero to five.
2011:19 - So this boolean array will have six vertices from zero to five index, and each index corresponds to
2011:28 - a node in a graph. So at the start, all the values of the visited array will be false because no
2011:35 - node is visited as of now. Now we will create yet another array, which we will call component ID.
2011:44 - We will see its significance later. But here you can see this component ID will store
2011:50 - the ID of any particular component in the form of integer. So you can think that as we have three
2011:57 - components here. So this component ID for 301 will store let's say an ID of zero, for example,
2012:07 - for two and four, it will store one, and for five, it will store two. Now this will state that we
2012:12 - have three components, 01 and two, node three belongs to zero component, zero belongs to zero
2012:20 - component, and one belongs to zero component. So that will be evaluated with this component ID.
2012:26 - And similarly, two will belong to component one, four will belong to component one,
2012:31 - and five belongs to component two. So there could be so many nodes in a graph.
2012:36 - So this component ID will denote a group of nodes, which will be represented by an ID.
2012:42 - So we will see its significance later. So this error would look like this, that at the start,
2012:50 - for all the vertices, the value will be zero. Or what we can do is we can also initialize
2012:57 - this array as a wrapper of integer. So every value will be null, stating that the nodes are
2013:03 - belonging to no component at the start. Moving ahead, then we will create a count variable.
2013:10 - Now our task is to first count number of connected components. And our second task is to
2013:22 - return true or false for a query that whether x and y
2013:39 - are connected or not. So we are using this algorithm to figure out these two problems.
2013:46 - So we are creating a count variable, which is suggesting that how many connected components
2013:52 - are there in this graph. So at the start, in this DFS method, count will be zero,
2013:58 - because we are yet to start the processing of this graph. Also from here, you can see,
2014:05 - in this method, we are creating this three things, visited array, component ID array,
2014:11 - and count. So usually for these two queries, we take these three variables at the class level,
2014:19 - so that we can use them directly in any of our methods. But here, for time being,
2014:24 - I have created these three variables in the method itself, so that I can demonstrate the
2014:30 - algorithm that how it works. So these three things you can create outside of the method
2014:35 - at the class level, we can make these variables as instance variables. So for time being,
2014:41 - you can think that these are part of the method itself. And for the actual DFS algorithm, we are
2014:46 - actually passing them directly into the method. Or else if they are at instance level, we don't
2014:52 - need to pass them like this. Now we will start the processing of graph from vertex zero,
2014:58 - and it will go till it is less than the number of vertices, which is six.
2015:02 - We need to go from zero to five. So at the start, v is zero. So we update zero here.
2015:12 - Now the first thing we check is whether v is already visited or not. So here you can see,
2015:17 - as we are starting the processing of the graph, v is not visited. Here valued zero index is false.
2015:24 - So therefore, this condition comes out to be true, which means we can apply the depth first search
2015:31 - on vertex zero now. So here, now this DFS will be removed from the call stack,
2015:36 - and this DFS will be called. So first we update line number here, because we are leaving this DFS
2015:42 - now. So we are leaving at line number seven, so that when this DFS method will finish,
2015:49 - we come back to this DFS, and we start the execution from line number seven itself.
2015:55 - And we assign this value back to v. So now there will be one more method on the call stack,
2016:03 - and the execution point will reach to that DFS with v as zero, count as zero,
2016:10 - because we are passing count zero and v zero. We will see what this w is here,
2016:16 - and visited array and component id array, you can refer here.
2016:20 - Now when we will call DFS on any particular node, what we do is, we first process that node,
2016:30 - and how we can process that node is, we can perform any typical algorithm on that particular node,
2016:36 - and we first mark that node as visited, that we are done visiting this particular node. So in
2016:42 - the visited array, at zero index, we simply assign a value true, stating that we have visited
2016:50 - node zero, like this. We have visited this node, and here what we can do is, we can either process
2016:58 - some algorithm on top of this node, we can print this node, and we can do anything on this node
2017:04 - based on the algorithm we are trying to process. And now what we do is, this count variable,
2017:12 - which we have passed into the DFS here, this count variable will help us in finding the
2017:19 - id of the component. So as we discussed that these three nodes belong to component id is
2017:25 - zero, this two belongs to one, and this belongs to two. So these id can be anything. So here,
2017:32 - what we are doing is, we are taking the count only as our id. So in the component id array,
2017:38 - at vertex zero, we update count as zero, like this. Now after visiting a particular node,
2017:48 - what we do is, we recursively visit its adjacent nodes. So in our previous video, we have discussed
2017:55 - that what this adjacency list is, this is actually a list, we are passing a vertex zero,
2018:02 - because value of v is zero, and we are asking to return its adjacent nodes. So it would look
2018:08 - something like this. I'll remove this. So here this list states that zero is connected to three and
2018:18 - one, and it is denoted in the form of an adjacency list. You can watch my previous videos to
2018:25 - understand more about this. So here, what we are doing is, we are iterating the nodes one by one.
2018:31 - So zero is connected to three and one. So we can process these nodes in any order. So this
2018:38 - for loop will process one node. So at the start value of w will be three. Let's say we are taking
2018:44 - three to visit, like this. Now we need to visit three. So what we do is, first we check whether
2018:54 - we have already visited three or not. So here at index three, we have a false value. It means we
2019:00 - haven't visited three. So now our task is to recursively call DFS with w will become our new v
2019:10 - in the next DFS call. And we are applying this DFS now for vertex three, because we haven't
2019:17 - visited this vertex. So before calling this DFS, we know that we are leaving this DFS at line
2019:24 - number 18. So we'll update line number first here, like this. And then this DFS will be called. So
2019:33 - there will be one more method on the call stack, like this. An execution point will execute this
2019:40 - DFS. Here w was three. When we call this DFS, it becomes our new v. So you can think it is going
2019:48 - like this. So now we are applying this DFS on vertex three. We have passed count as zero as
2019:57 - you're directly propagating the count to this DFS. So v becomes three now. We know that we haven't
2020:05 - visited three. So we will first visit three by marking the index three as true, like this.
2020:13 - That we have visited three now. And in the component ID array at index three, we will assign
2020:21 - the value zero because value of count is zero, like this. Now this zero is actually telling us
2020:28 - that this zero and three are actually connected because their IDs are same. After visiting three,
2020:36 - we will visit its adjacent nodes. So we will iterate the adjacency list of three.
2020:43 - And it has only one node zero because three is connected only to zero. So at the start w will be
2020:49 - zero, like this. And now as we are processing the adjacent nodes of three, we first check whether
2021:01 - zero is already visited or not. So here you can see at index zero, we have value true. It means we
2021:08 - have already visited zero. So this condition comes out to be false. And here you can see
2021:16 - for vertex three, there are no more nodes adjacent to three left to be traversed. So this for loop
2021:23 - will terminate. And after this for loop gets terminated, this DFS method will also get
2021:30 - terminated. And this DFS will be removed from the call stack.
2021:38 - And execution point will reach to this DFS. And here we know that we had left the previous DFS at
2021:44 - line number 18. So we start from line number 18. At that moment, v was at zero. So we will come back
2021:52 - to zero. W was at three. And if you see the adjacency list of zero, we have processed
2022:00 - one of the adjacent nodes of zero, which is three. Now in the next iteration, we will pick one,
2022:09 - and we will apply DFS on one, because we need to visit one and then visit
2022:15 - is adjacent nodes recursively. So w becomes one here.
2022:22 - We check first that whether one is already visited or not. So at index one, we have a value false.
2022:29 - It means one is not visited. So we will call DFS again. And we are leaving this DFS at line
2022:37 - number 18. So we'll update the line number here. 18. There will be one more method on the call
2022:44 - stack. As we have called this DFS with w as one, this w will become our new v here for this DFS.
2022:54 - So it will go like this. And count will go with a value zero only.
2023:02 - The first step we do is we mark the vertex one as visited. So at index one,
2023:08 - we mark it as true, like this, that we have visited one now. In the component ID array,
2023:16 - at index one, we put the value of ID as zero, which suggests that zero, one and three are connected.
2023:26 - Now after visiting one, we will visit its adjacent nodes recursively. So if we call the adjacency
2023:32 - list of one, you will see that it is connected only to zero. So we have only one vertex. So w
2023:42 - will start from zero. We'll first check whether zero is already visited or not. So here you can
2023:51 - see zero is already visited in the visited array. At zeroth index, we have true. So this condition
2023:58 - comes out to be false. And there are no more vertex adjacent to one left to be traversed.
2024:05 - So this for loop will terminate. And this DFS method will also get terminated and removed
2024:12 - from the call stack. So execution point will reach here. We had left the previous DFS at line number
2024:20 - 18. So we'll start from line number 18. At that moment, v was zero and w was one. And v was zero,
2024:29 - it means we were visiting the adjacent nodes of v. We visited three and we visited one recursively.
2024:40 - So now there are no more nodes in the adjacency list of zero to visit. So this for loop will
2024:46 - terminate. And this DFS method will also get and and it will be removed from the call stack.
2024:54 - And execution point will reach to this DFS, which we left at line number seven. So we
2025:00 - start from line number seven. At that moment, v was at zero. So here you can see that after
2025:08 - performing the DFS on any of the node, here we started with zero, it recursively visited
2025:15 - its neighboring nodes. So once this DFS will end, we know that we have visited one component fully.
2025:22 - So now what we do is we simply increment count. So our count becomes one. Now this count is
2025:29 - suggesting that we are done processing of one connected component. And we have found
2025:34 - one connected component. So count becomes one. We will increment v, v becomes one.
2025:46 - Now it means we are going to the vertex v and trying to apply DFS on vertex v. So first we
2025:54 - check that whether one is already visited or not, because there could be a possibility
2025:59 - that its previous vertex or any of its previous vertex must have visited one, because one must
2026:05 - have been connected to that vertex. So here you can see one is already visited. So this condition
2026:12 - comes out to be false. We will increment v, v becomes two. We check that whether two is visited
2026:23 - or not. So here at index two, we have a value false. It means two is not visited. So we can
2026:32 - apply that DFS now on vertex two. So we are leaving this DFS at line number seven.
2026:40 - And we are calling this DFS with v or vertex as two. So there will be one more method on the call
2026:48 - stack with v as two and count as one. First we mark two as visited like this. So here I am just
2027:01 - representing it with a different color. In the component ID at index two, we put one. Now here
2027:12 - this count was increased. So our ID also increased, which also helped us in figuring out that two
2027:18 - belongs to a different component. Now our task is to visit the adjacent nodes of two recursively.
2027:27 - So two is only connected to four. So adjacency list of two will have only node four.
2027:33 - So we'll start with four first. W becomes four. We first check whether four is visited or not.
2027:42 - So four is not visited. So we call this DFS with W as four. So this four will become our new v in
2027:51 - the next DFS call. So first we update line number here because we are leaving this DFS.
2027:56 - And there will be one more method on the call stack. So the W which was in previous DFS becomes
2028:07 - our new v and count is propagated directly. We first mark four as visited here like this.
2028:21 - And in the component ID array add vertex four. We assign a value one. This suggests that two and four
2028:32 - are part of one single component because they have same component ID. Now we'll traverse the adjacent
2028:40 - nodes of four. So adjacency list of four will have only one vertex which is two. So W starts from two.
2028:49 - We first check whether two is visited or not. So here you can see index two we have value true.
2029:00 - So two is already visited. So this condition comes out to be false. And this for loop will
2029:07 - terminate because there are no more nodes adjacent to four left to be traversed. And this DFS method
2029:17 - will end. And execution point will reach to previous DFS. We start from line number 18.
2029:26 - At that moment v was at zero. So v comes back to zero. W was four which suggests that we were
2029:33 - visiting the adjacency list of two which was this. We know that we recently visited four
2029:40 - and there are no more adjacent nodes to two left to be traversed. So this for loop will terminate.
2029:49 - And this DFS will be removed from the call stack. And execution point will reach to previous DFS.
2029:57 - We start this DFS at line number seven. At that moment v was at two. So it suggests that
2030:06 - we just finished one more DFS on one of the vertices which was two. And it must have marked
2030:12 - its connected vertices in the visited array. So we'll increase the count now because we are done
2030:19 - processing the second connected component. So count becomes two. We'll increment v. So v becomes
2030:29 - three. Now we need to apply this DFS again on vertex three. But first we check whether
2030:37 - three is already visited or not. So here you can see three is already visited. So this condition
2030:42 - comes out to be false. We increment v. v becomes four. Four is also visited. So this condition
2030:54 - comes out to be false. We'll increment v. v becomes five. So here you can see vertex five
2031:04 - is not visited. So this condition comes out to be true. So now we'll apply DFS on vertex five.
2031:13 - So we are leaving this DFS at line number seven. So we update line number seven here.
2031:18 - And there will be one more method on the call stack
2031:24 - with v as five and count as two. Now the first thing we do is we mark five as visited
2031:34 - like this. And in the component ID array at index five, we assign a value two because value
2031:42 - of count is two. Now here it suggests that this five belongs to a different component because
2031:49 - value of count has changed. Now we'll visit the adjacent nodes of five. So here you can see
2031:59 - in this connected component, we have only one node and five is connected to no other node.
2032:05 - So therefore this for loop will terminate and this DFS method will also end.
2032:10 - Execution point will reach to this DFS. We start from line number seven and v as five.
2032:21 - So after this DFS is done, we know that we have just visited one more connected component.
2032:26 - So we increase the count. Count becomes three. We'll increment v.
2032:33 - v becomes six and we know that we have only nodes from zero to five. So this for loop will terminate
2032:43 - and this DFS will be removed from the call stack.
2032:49 - So now here you can see, if you see in the visited array, we have visited all the elements
2032:55 - in the component ID array, you can see zero, zero and zero are at indexes zero, one and three,
2033:03 - which suggests that zero, one and three are connected. If you see two and four,
2033:11 - they have a same value one, one, it means they are connected. And here if you see at index five,
2033:16 - we have two, it means it's a connected component having only one vertex. So friends here you can
2033:22 - see that if we take out these three variables as our instance variable, and we can provide one
2033:28 - method as something like public int get count of connected components. So this we can return
2033:42 - the value of count like this. So this will solve our first query. The second query we can provide
2033:49 - a method as public Boolean. And we can give the method name is connected. And to this method,
2034:01 - we pass x and y. So here we can simply return comp ID of x, whether it is equal to
2034:20 - comp ID of y. So let's say if you pass x, y as zero comma two, so this is our x and this is y.
2034:33 - So the value at index x, which is zero, we have zero and value at vertex to have one.
2034:43 - So you can see we are comparing whether zero is equal to one or not. It means
2034:48 - this condition comes out to be false and we return false stating that zero
2034:53 - and two are not connected. Now, for example, if we pass three and one
2035:00 - like this, so three is x and y is one. So comp ID of three
2035:09 - we are checking it with comp ID of one. So this will give value zero
2035:22 - and this will give value zero. So both the values are equal and this condition is true.
2035:30 - So we simply return true stating that three and one are connected and they are part of the same
2035:37 - component. So friends, this was all about the connected components in an undirected graph.
2035:44 - I hope you must have liked this video. In case if you are new to my channel, then please subscribe
2035:49 - to my channel and click the bell icon so that you never miss any update. Thanks have a nice day.
2035:56 - Hello, everyone. So in this video, we are going to discuss a problem
2036:00 - number of islands. Now let's move ahead and see what this problem is and how to solve this.
2036:07 - So here we are given an m cross n matrix like this, which is 2d binary grid. So binary grid,
2036:15 - we mean that we have this matrix having only ones and zeros. Now in which ones represent a land,
2036:22 - so you can think wherever we have one, it actually represents a land and zeros as water.
2036:30 - Like this. Now our task is to return the number of islands. Now what do we mean by island? So as
2036:39 - per the definition in the problem, you can see an island is surrounded by water. So this is the one
2036:45 - thing that an island is surrounded by water and second is found by connecting adjacent lands
2036:52 - horizontally or vertically. So this is a land, this is a land. So one thing is there should be
2036:58 - a connection horizontally or vertically and second day should be surrounded by water
2037:05 - like this. And we may assume all four edges of the grid are surrounded by water. So beyond this grid,
2037:14 - here you can think that there is only water. It means that it has zeros.
2037:21 - So here we have zero, here we have zero, here we have zero. So here these three ones form an island
2037:29 - because these three are connected horizontally and vertically and they are surrounded by water.
2037:36 - This single one forms one island because it is also surrounded by water and this one also
2037:42 - is surrounded by water. So the answer is three. We have three number of islands. We don't have
2037:48 - to consider this diagonal relationship as per the problem we need to look horizontally or vertically.
2037:56 - So here you can see that how we can solve this problem is if you look closely then we are given
2038:02 - with a graph indirectly here. If I plot this one, so this is one node and the node adjacent to it is
2038:10 - also one. So we can think that there is a connection via this edge horizontally like this.
2038:19 - And there is an edge vertically because we need to consider vertical edge also. So this
2038:25 - forms another connection like this. So you can think this island in the form of this graph
2038:32 - and if we look closely to it, it looks like this. One, one, one, like this. So you can also think
2038:44 - that we are given with this five nodes of a graph that they are connected horizontally
2038:50 - and vertically and if there is a vacant space here it means that it is surrounded by water.
2038:56 - So in one of our previous videos we discussed about
2039:06 - connected components. So this forms one connected component, this forms another connected component
2039:13 - and this forms another connected component. And we also discussed that how we can process a
2039:19 - connected component and we also discussed that how we can find the number of connected components.
2039:24 - So this problem is very similar to that. So in the connected components problem we applied
2039:31 - the DFS which is a depth first search. So here also we will apply the same. So the only difference is
2039:38 - there we had these actual nodes connected by edges and here we are taking these edges and
2039:45 - lines horizontally or vertically in the form of edges. So keeping these constraints in mind,
2039:53 - let's move ahead and see the demonstration of this algorithm step by step.
2039:58 - So friends before we start, in case if you want to master data structures and algorithm,
2040:02 - you can subscribe to my channel and click the bell icon so that you never miss any update.
2040:08 - Now this is the algorithm to find the number of islands. We are given with a matrix where we have
2040:14 - only ones and zeros and they are provided in the form of a character. And here we need to return
2040:25 - the number of islands in this grid. So here we have created integer variable number of islands
2040:31 - and at the end we are returning this number of islands. So let's see the demonstration
2040:36 - of this algorithm step by step. We call the number of islands method passing in the matrix
2040:42 - which is our grid. Now let's say we take the same example where we are given with this matrix
2040:49 - and we know that we have three islands here.
2040:54 - One is this island, another is this and the third one is this. Now let's see how we can
2041:02 - find out the number of islands and we also know one property that lands should be connected
2041:10 - vertically or horizontally. So this can be treated as a vertex of graph and this can be treated as
2041:18 - an edge. So this is a horizontal edge and this is a vertical edge. So friends here you can see
2041:27 - that wherever we will find land we need to apply depth first search on top of it
2041:31 - so that we can figure out how much deep that connection is via this property.
2041:39 - Now here we are given this m cross n matrix. So this m cross n represents row and column.
2041:45 - So the number of rows which is m is given by grid.length which is 4. We have 4 rows 1, 2, 3 and 4
2041:55 - with an index of 0, 1, 2 and 3. Similarly we have four columns denoted by n. So this is first column,
2042:05 - second, third and fourth column with an index of 0, 1, 2 and 3.
2042:14 - So friends when we apply depth first search here we know that we need to consider horizontal and
2042:20 - vertical relation. So here let's suppose we are given with this sort of graph.
2042:29 - Let's say here we have this one so it must look like this. So if we are applying depth first
2042:34 - search on top of it we know that once we visit any particular node then we visit its neighboring
2042:41 - nodes recursively. So usually in the graph we can encounter these cycles. So here let's suppose we
2042:48 - have visited this node then we go to this node we visit this and let's say if we are going to this
2042:54 - node and we are visiting then here we are visiting but if we go back here this node we have already
2043:01 - visited. So this is a rough example to just demonstrate that when we return back to this
2043:06 - node we know that we have already visited this node but how we can mark that we have visited
2043:12 - this node because when we will reach to this node then the algorithm will keep on visiting
2043:17 - this node again and again. So we have a cycle so in order to keep the track of the visited nodes
2043:23 - we create a boolean array or here you can see that we have created a visited matrix.
2043:28 - Here as the graph is given in the form of a grid and here each index represents a vertex
2043:34 - so therefore we have to create a matrix of m cross n which will actually help us to figure
2043:40 - out that which nodes are visited and which are not. So it looks something like this it's a boolean
2043:46 - matrix so at the start every node is unvisited being denoted by f which is false.
2043:56 - As we need to return number of islands so we initialize this integer variable with zero
2044:01 - because at the start we haven't found any island so the number of island is zero.
2044:08 - So friends when we apply def first search on a graph we visit each and every node of that graph
2044:14 - so here each index value can be considered as a node of a graph so here you can see that we
2044:21 - have 16 such vertex and they are given in the form of matrix m cross n. So we need to apply
2044:28 - these two for loops to travel each and every vertex and apply the def first search on top of
2044:34 - it to figure out the number of islands. So here i will traverse the rows and j will traverse the
2044:41 - columns m denotes our rows and denotes the columns so at the start i is zero j is zero
2044:54 - so it means that we are on index zero comma zero like this also friends as we need to find the
2044:59 - number of islands we can apply the def first search on the nodes which have values as one
2045:06 - because zeros represent water so when we encounter water we need to skip the water
2045:12 - and once we found even one of the land then we can apply def first search on top of it
2045:17 - with an only condition that this one should not be visited because there could be a possibility
2045:23 - if we are going in this direction then we are coming back then going down and they are going up
2045:28 - so there could be a possibility that we encounter the nodes which are already visited
2045:34 - so which is being tracked by the visited 2d array so the only condition we need to keep in mind is
2045:40 - that in the visited array at zero comma zero we should have false value it means this node
2045:46 - should not be visited and the value of this node should be one if we encounter zero then we will
2045:53 - simply skip this element because this denotes the water so here at the start we found one which is
2046:00 - the land and this land is not visited so therefore we can apply def first search on top of this one
2046:07 - considering the graph horizontally and vertically so when we will apply dfs on top of this grid
2046:15 - at index zero comma zero it would look something like this that this method will now call dfs
2046:21 - method like this so here we have this grid and this visited 2d array we pass the row as zero comma
2046:32 - zero so on the call stack there will be one method dfs having row as zero and column as zero
2046:40 - because we found one and that is not visited so here we are maintaining this call stack because
2046:46 - this algorithm is actually recursive as we are applying the dfs we know that it's a recursive
2046:52 - algorithm where we actually process any node and then we try to process its adjacent nodes recursively
2046:59 - so therefore this algorithm is recursive so in order to keep the track of this method calls
2047:05 - we are maintaining a call stack this is our base case to stop this recursion we will see this later
2047:13 - so now at the start we are processing a value at index zero comma zero in this grid matrix
2047:19 - because we have found one land denoted by one and which is not visited so here you can see this is
2047:26 - our base case now as we will apply the def first search horizontally and vertically in all the
2047:32 - directions because this land can be connected to another land so let's say we have a land here
2047:38 - if above this land we have another one here we have another one and here we have another one
2047:44 - and below we have another one so this land if you see here it is connected like this like this like
2047:50 - this like this so we need to go in four direction to figure out the extent of this island because
2047:57 - we are given in the problem that we need to see in the horizontal and in the vertical direction
2048:02 - so here in the normal dfs where we are given with a vertex we visited a node and then we visited
2048:12 - its adjacent nodes recursively here the adjacent nodes as we discussed will be given by these four
2048:18 - directions which is up left right and down so currently what this base case says that after
2048:30 - processing any node if we are going to a level above let's say if we are going to top of this
2048:37 - one then we are going outside the boundaries of this matrix because beyond zero comma zero
2048:43 - the index doesn't exist in the matrix so here this is the base case that we may go out of the matrix
2048:49 - so if row is less than zero or column is less than zero then we simply return from the dfs method
2048:55 - so this is our base case the another conditions are if row and column goes beyond this or this
2049:02 - then also we need to return and the last two conditions are let's say if we are on this node
2049:08 - and if we go to right so here we are finding a water which is being denoted by zero we only keep
2049:16 - the track of the lands which are connected adjacent and as soon as if we find a water
2049:21 - we simply return back so here if this grid at a row and column if the value is zero then we will
2049:27 - simply return and one last thing is let's say if we have visited this one we went here for this one
2049:35 - also we need to go up so we'll go back to this one but here we know that we just visited this
2049:42 - node and came here and then we are going up so if in the visited 2d array at row and column if we
2049:47 - find any true value then also we need to return because we have already processed the node so
2049:53 - these six conditions are very important because they form our base case we should not go beyond
2050:00 - the boundaries with these first four conditions we should not go in the water with this condition
2050:06 - and we should not go to a land which is already visited so at the start we are within the boundaries
2050:12 - of this matrix because we are at zero comma zero this vertex is not visited and the value is one
2050:18 - which is not zero so therefore all the conditions comes out to be false
2050:24 - so we suggest that we have found one land
2050:30 - and now as per the dfs we will visit this land and in the visited 2d array we will mark it as true
2050:37 - like this so for one property of dfs is after visiting any particular node we visit
2050:46 - its adjacent nodes recursively and we know that in order to find the adjacent nodes to one
2050:53 - as per the problem they should be horizontal or vertical so we need to apply this dfs horizontally
2051:01 - and vertically so it means we have to go in four directions left up right and down
2051:09 - to visit the adjacent nodes of zero comma zero recursively so here if you see if we are in
2051:16 - particular row let's say zero zero here we can travel in any direction so what we are doing is
2051:23 - we are going first to left then up then right and then down so here when we are going left
2051:32 - it means we are going in this direction so currently here you can see that whichever
2051:38 - box is yellow that is our current row and column which is zero comma zero this if you want to go
2051:45 - in the left it means we are going in this direction so when we are going in this direction
2051:50 - to the left row actually remains the same here you can see value of row is zero so it remains
2051:56 - the same as we are going on the left the value of column decreases by one so here we have column zero
2052:03 - here it can be minus one because we are going in this direction similarly if you are going up
2052:09 - let's say we are here and if you are going up here row is two now it becomes one so here row
2052:15 - is actually decreasing but column remains the same so when we go up row decreases column remains
2052:21 - same when we go right let's say if you are here if you are going in this direction so row remains
2052:28 - the same and column actually increases from one to two so we do call plus one and if you are going
2052:35 - down let's say if you are going down from here to here so row was one now it became two because we
2052:42 - have reached here so row is actually increasing and column remains the same so this four direction
2052:48 - we need to keep in mind if we are going on the left column decreases if you are going up row
2052:54 - decreases if you are going on the right column increases if you are going down row increases
2053:02 - so this four direction we need to keep in mind because for any particular land we need to see
2053:08 - its horizontal and vertical adjacent nodes to figure out whether it has land or water so we
2053:16 - need to call this dfs four times because we need to visit a particular row and column in four
2053:22 - directions going left then going up then going right and then going down so first we will go left
2053:30 - where row remains the same and column decreases by one so here you can see that we are leaving
2053:35 - this dfs at line number eight and we are calling this dfs so first we'll update the line number
2053:41 - here eight that we are leaving this dfs at line number eight so once this dfs will end we will
2053:48 - return back to this dfs but we need to keep the track of the line that from where we left this
2053:54 - dfs so this line number eight will help us knowing that we had left this dfs at this line so we'll
2054:00 - start our execution at this line and whatever the value of row and column will be we'll assign
2054:06 - those values back to the row and column so now you can see this method will be called where row
2054:12 - will remain same and column will decrease by one so there will be one more method on the call stack
2054:20 - like this here row remains the same and column decreased by one so it became minus one
2054:27 - it means we are going to the left
2054:33 - so here we went outside the boundaries of this matrix where column became lesser than zero so
2054:40 - it means we have encountered a base case so we simply need to return back to zero comma zero
2054:47 - so this dfs will end because we are now returning back so this method will be removed from the call
2054:52 - stack execution point will reach here we'll start from line number eight and we have visited the
2054:59 - left side and we came back to zero comma zero so we are coming back to zero comma zero and now we
2055:06 - know that we are done with the left we need to go up so when we go up row decreases and column
2055:13 - remains the same so we are leaving this dfs now at line number nine so we update nine here
2055:18 - so there will be one more method on the call stack where row will decrease from zero to minus
2055:25 - one and column remains the same so here you can see now we went to outside the boundaries of this
2055:32 - matrix in in upper direction so now row has become less than zero so therefore we need to return from
2055:39 - this dfs so we will come back to zero comma zero we will start from line number nine here and we
2055:49 - will come back to zero comma zero and now we go towards its right so when we go towards right
2055:58 - column increases so here it will increase from zero to one because we are going to the right
2056:03 - direction and row remains the same so we execute this dfs and we leave this dfs at line number 10
2056:12 - there will be one more method on the call stack where row remains the same and column increases
2056:18 - by one because we are going towards right so now you can see we are going to zero comma one
2056:25 - so we reach to this index which is zero comma one so now we are within the boundaries of this matrix
2056:32 - so first four condition comes out to be false this condition in the visited 2d array we have false
2056:39 - so this comes out to be false and we know that at this index zero comma one we don't have zero
2056:46 - we have one so therefore this condition also comes out to be false so here you can see all
2056:51 - the conditions came out to be false because we are within the boundaries this value is not zero
2056:57 - and it is not visited so it denotes that we have found an adjacent land which is being
2057:05 - denoted by one and it is not visited so first thing we do is we mark this as visited like this
2057:13 - and as we know that how dfs work now for this vertex we will visit is adjacent nodes recursively
2057:20 - so now for value zero comma one we will apply the dfs into four directions so for this node
2057:27 - first we'll go to left we'll update line number eight here we will have one more method on the
2057:33 - call stack and as we are going on the left column decreases so column was one it decreased to zero
2057:41 - row remains the same so it means we have reached back to this land here you can see this node is
2057:50 - within the boundaries of this grid but if you look in the visited 2d array at row zero comma zero
2057:55 - we have already visited this node because we are actually applying the dfs from this node only
2058:01 - we reached to this node and then we are coming back to this node so we have already visited this
2058:06 - node so though this condition is false that we are encountering a land here but we have visited
2058:12 - this land already so we'll simply return from this dfs and this dfs will be removed from the call
2058:19 - stack execution point will reach here and to whichever dfs we were we simply start from line
2058:25 - number eight here we know that we were at zero comma one so we were at zero comma one so we
2058:32 - return back to this node like this and for this node we just went to its left and came back
2058:40 - so now we'll go up so first we update line number here because we are leaving this dfs
2058:46 - so now there will be one more method on the call stack we are going up so row will decrease
2058:53 - so from zero it will become minus one like this it means from zero comma one now we have went to
2059:00 - outside the boundaries of this matrix so it means row is less than zero so we need to return back
2059:08 - because this condition comes out to be true it means we are returning back to zero comma one now
2059:14 - so this method will be removed from the call stack we will reach to this method we simply start our
2059:19 - execution from line number nine here and at that moment row was zero and column was one so we come
2059:26 - back to this zero comma one like this so with this line we went up and then came back so now
2059:34 - we'll go towards right so first we update the line number here which is 10 because we are leaving
2059:41 - this dfs we are going towards right now so there will be one more method on the call stack
2059:49 - as we are going on the right column will increase so from one it becomes two row remains the same
2059:55 - so we are going towards right it means we are going to zero comma two here
2060:03 - and here you can see that we have found a water so we need to simply return from this node because
2060:08 - we have found water and this is actually stopping this land to go beyond that so we have encountered
2060:15 - a water so we'll simply return back this method will be removed from the call stack execution
2060:22 - point will reach here we'll start our execution from line number 10 because we had left at line
2060:27 - number 10 so we come back to zero comma one because when we left this dfs we were at zero
2060:32 - comma one so we came back to zero comma one so we visited left up right so now we'll go down
2060:44 - here first we update line number here which is 11 then we will call this dfs again there will be
2060:51 - one more method on the call stack if we are going down row will increase so from zero become one
2060:58 - column remains the same here so we'll simply return because we have found the water here
2061:06 - which is zero so we simply return back this method will be removed from the call stack
2061:14 - execution point will reach here at line number 11 at that moment we were at zero comma one because
2061:21 - now we are returning to zero comma one back like this so here you can see that for this node
2061:29 - we went to its left up right and down and after that we are done with this node so after 11 this
2061:37 - dfs will end it means this dfs will end so this method will be removed from the call stack
2061:44 - and we go back to its previous dfs that we had left at line number 10 so we start from line
2061:50 - number 10 and the value was zero comma zero so we are actually returning back to zero comma zero
2061:56 - like this because we went to its right when we visited zero comma one here you can see that we
2062:03 - executed dfs we went to right and now we are coming back so we have came back to zero comma zero
2062:10 - so for this node now we need to go down so we'll update the line number here 11
2062:17 - there will be one more method on the call stack
2062:22 - we are going down so row increases so it became one from zero and column remains the same
2062:28 - it means we are going down we came here we are within the boundaries of this matrix
2062:36 - so first four condition comes out to be false this land is not visited because value is false here
2062:43 - and we have actually came to a land so it means all the conditions comes out to be false
2062:49 - it means we are on a valid land which is adjacent to our previous land
2062:54 - so first we mark this land as true so in the visited array at one comma zero we put a value
2063:01 - true like this so we are putting this value true because in case if we return back to this node
2063:07 - we can come to know that we have already visited this node
2063:12 - now friend there could be a possibility that here we have one or here we have one so as we have
2063:18 - reached to a land now we need to apply the dfs to its adjacent nodes as well because let's say here
2063:24 - we have one and then we have one then one one one so this land would have expanded till the
2063:31 - last row and last column so we need to apply this dfs now for this node in the four directions left
2063:39 - up right and down to figure out whether this land is also surrounded by any other land or not
2063:46 - so now first we go to the left so it means we are going in this direction now
2063:51 - so we update line number here eight
2063:52 - there will be one more method on the call stack where column will decrease it becomes minus one
2064:01 - and row remains the same so it means we have went outside the boundaries of this matrix
2064:10 - where column became minus one which is less than zero so this condition comes out to be true
2064:15 - and as it is a or in all the conditions so if any condition comes out to be true we simply return
2064:22 - so we simply return back to one comma zero here so this method will be removed from the call stack
2064:30 - we reach here at one comma zero and we start our execution from line number eight
2064:36 - we just went to the left of one comma zero so we are returning back to this node like this
2064:44 - so now we actually go up so first we update line number here
2064:48 - which is nine and then we are leaving this dfs
2064:53 - so there will be one more method on the call stack
2064:57 - we are going up so row decreases so from one it became zero so it means we have reached here
2065:07 - so friends here you can see that from this node we actually went here so for this node
2065:14 - this one is also adjacent so when we reached here we know that we have already visited this
2065:19 - node so how we can figure this point out is we can simply look in the visited array at zero comma
2065:24 - zero we find a value true so we are in the boundaries of this matrix so first four conditions
2065:31 - comes out to be false but here you can see this condition visited row column this comes out to be
2065:37 - so it means this land is already visited we need to come back so we simply return from this dfs
2065:47 - execution point will reach here we'll start from line number nine
2065:51 - and at that moment we were at one comma zero so we come back to one comma zero
2065:55 - because we are returning from zero comma zero back to one comma zero here and for this node we
2066:02 - just went to up and came back so now we go towards right we update line number 10 here
2066:11 - there will be one more method on the call stack so we are going now towards right here
2066:18 - where value of column will increase so from zero it became one
2066:24 - we reached here so in this dfs we are now at one comma one so we reached here
2066:32 - now here we have encountered a water so this condition comes out to be true so we simply
2066:37 - return because as we are encountering water we need to return back this method will be removed
2066:45 - from the call stack we come back to previous dfs we start from line number 10 so we come back to
2066:53 - one comma zero like this and now we go down we just visited the right now we go down so we first
2067:04 - update line number here which is 11 that we are leaving this dfs at line number 11
2067:11 - and now there will be one more method on the call stack we are going down so row will increase
2067:16 - so from one it became two and column will remain same so with this dfs now we restore two comma zero
2067:24 - here and as we have encountered a water here so this condition comes out to be true
2067:32 - so we simply return back so this method will be removed from the call stack
2067:39 - execution point will reach here we start from 11 and at that moment we were at one comma zero so
2067:46 - we come back to one comma zero here and for this node we visited its left up right and down
2067:57 - and after that this dfs will end so for this node we have visited all the directions
2068:04 - so this will be removed from the call stack we reach back to this dfs we start from line number
2068:10 - 11 and at that moment we were at zero comma zero so we come back to zero comma zero
2068:17 - here so here you can see that we started our dfs with this index zero comma zero
2068:23 - and after traversing recursively all its adjacent node we are returning back to zero comma zero
2068:28 - which means that we have visited left up right and down so the last direction we visited was down
2068:36 - here and we came back so after this line this dfs will end which signifies that we have visited
2068:44 - all the lines connected horizontally and vertically so we'll return from this dfs
2068:50 - so this dfs will be removed from the call stack and we will simply go back to the method which
2068:56 - called this dfs at the start here and this is our condition as of now that we have visited
2069:05 - this one this one and this one and we have found one connected component which is our island
2069:13 - so we'll increase the number of islands value because we have just found one island
2069:18 - so it becomes one moving ahead so now we are done with this node zero comma zero so we'll
2069:25 - increment j j becomes one we go to zero comma one here because there could be a possibility
2069:32 - that from here only another land starts or another island starts so here first we check
2069:40 - that whether the value is one or not so here you can see the value is one but we also check that
2069:45 - whether we have already visited this land or not because in our previous dfs we started here then
2069:51 - we visited this land and then we visited this land so we know that we have already visited this land
2069:57 - because value is true here so therefore this condition comes out to be false because we are
2070:03 - going only to those lands which are not visited here we have just visited this land in our previous
2070:09 - dfs so this condition will prevent going into another dfs call so the condition in if block
2070:16 - comes out to be false now we'll increment j j becomes two so we are on zero comma two
2070:27 - here you can see that we have landed on water so it means we need to skip this element because we
2070:35 - need to identify an island so an island can only be formed by a land which is one so if we are
2070:41 - landing on water it that it means that we need to skip this node and proceed ahead so this condition
2070:47 - comes out to be false because value is zero here so friends here you can see that now we will go
2070:55 - somewhat fast because whenever we encounter zero we'll simply move ahead because this
2071:00 - conditions will come out to be false so we'll increment j j becomes three we'll simply skip
2071:07 - because we have landed on water so now we'll increment j so j will go beyond the boundaries
2071:15 - of this matrix so this condition comes out to be false so this for loop will terminate
2071:21 - and the execution point will reach to the upper for loop because now we need to process the second
2071:27 - row so first we increment i becomes one so now we are processing this row we are done processing
2071:35 - this row so we start from j equal to zero so it means now we are on one comma zero
2071:44 - we noted we have found one land denoted by one so this condition is true but we also know that
2071:50 - we have already visited this land so this condition comes out to be false we'll increment j
2071:58 - j becomes one so now we are processing this value at one comma one so friends here you can see this
2072:07 - zero this zero zero zero zero this phi will be skipped because we are landing on water
2072:15 - and as we are traversing this matrix we will now encounter five waters so we will go over this
2072:22 - somewhat quickly so this is a basic traversal of matrix we have found water so this condition
2072:30 - comes out to be false j becomes two this condition comes out to be false j becomes three
2072:45 - so this condition comes out to be false
2072:52 - so now we are done processing the row one so we go to row two we'll increment i
2072:59 - i becomes two we'll start with j equal to zero so we are at two comma zero now
2073:09 - this condition comes out to be false
2073:10 - j becomes one this condition comes out to be false because we are landing on water so we need
2073:21 - to skip it j becomes two so friend now you can see that we are on a particular land because this
2073:33 - condition comes out to be true and if we go to the visited area i comma j which is two comma two
2073:39 - here we have a false value it means we haven't visited this land so both the condition comes
2073:45 - out to be true so it means as we have found a new land we'll apply dfs on top of it to actually
2073:52 - figure out its adjacent lands horizontally and vertically so this dfs will be called with two
2073:59 - comma two so on the call stack there will be dfs with row is two and column is two like this
2074:07 - so now we'll apply the same algorithm which we applied to this node
2074:12 - we are in the boundaries of the matrix visited is false and the value at this row and column is one
2074:20 - so all the condition comes out to be false so first we mark this land as visited by assigning
2074:27 - a value true to the visited 2d array at two comma two
2074:34 - now we simply go to left of two comma two so when we go left row remains same and column decreases
2074:42 - so we are leaving this dfs so first we update line number here which is eight
2074:48 - now on the call stack there will be one more method by name dfs where row remains the same
2074:55 - and column decreases so we are at two comma one now it means we are going towards the left of two
2075:01 - comma two which is two comma one here we know that we have landed on water so we simply return
2075:11 - so this dfs will end execution point will reach here so this dfs we had left a line number eight
2075:19 - so we start from line number eight we have encountered the water so we simply return
2075:24 - so we come back to two comma two because at this moment row and column were at two comma two
2075:29 - so we come back to two comma two now we go up so first we update the line number here which is nine
2075:40 - there will be one more method on the call stack
2075:44 - if we are going up row decreases column remains same so row became one from two it means
2075:52 - we have went here one comma two here you can see that we have landed on water again so we simply
2076:01 - return so we come back to two comma two now this method will be removed from the call stack
2076:10 - we'll start from line number nine we come back to two comma two and now we are going towards right
2076:16 - so first we update line number 10 here there will be one more method on the call stack
2076:25 - if we are going towards right row remains same and column increases
2076:29 - so from two it became three and we are going to two comma three now here
2076:36 - here you can see that we have again found a water so we simply return to two comma two
2076:41 - we start from line number 10
2076:49 - we return back to two comma two and now we simply go down so first we update line number 11 here
2076:56 - because we are leaving this dfs at line number 11 there will be one more method on the call stack
2077:04 - we are going down so row will increase so from two it became three and column remains the same
2077:11 - we are at three comma two
2077:16 - and here you can see we have found a water so we simply return back to two comma two
2077:24 - this method will be removed from the call stack we return to this dfs at line number 11
2077:30 - so we return back to two comma two and here you can see that we have visited all the adjacent
2077:36 - nodes of this land so this dfs will end now because there are no more lines to execute
2077:44 - so now we'll go back to the method which actually called as dfs at two comma two
2077:49 - so this is the condition so here you can see after we finish visiting all the lands adjacent to
2077:57 - this land horizontally and vertically we know that we have found one more island
2078:01 - so we'll increase the value of number of islands which becomes two
2078:08 - now we'll increment j j becomes three so you can see this is a water water water water
2078:18 - so for the next four iterations we'll simply skip these values so we'll go over this quickly
2078:25 - this condition comes out to be false
2078:27 - now we are done with processing the row two so this for loop will terminate
2078:35 - we'll increment i, i becomes three because now we are processing the last row
2078:42 - we'll start from j equal to zero
2078:46 - this condition comes out to be false
2078:50 - j becomes one
2078:54 - this condition comes out to be false
2078:58 - j becomes two
2079:02 - this condition comes out to be false
2079:06 - and at the end j becomes three
2079:11 - that we have found a land which is actually not visited because value is false
2079:16 - it means that now we can apply dfs on top of this land
2079:22 - so we'll call dfs we pass the value of i and j which is three comma three
2079:27 - there will be one method dfs with row as three and column as three like this
2079:36 - we are within the boundaries of the matrix and we haven't visited this land so all the
2079:42 - condition will come out to be false so we will first mark this land as visited
2079:49 - by assigning a value true in the visited array at row three and column three
2079:53 - and now we'll perform the same steps we go left up right and bottom so we'll go over
2080:03 - this quickly because we know that we are performing the same steps what we did here and here
2080:09 - so we need to keep this thing in mind when we are going to the different directions
2080:14 - so first we are going left so we update line number here
2080:19 - there will be method on the call stack we are going left so column decreases
2080:24 - so from three comma three it became three comma two we have reached here
2080:29 - now this is a water so we'll simply return back to three comma three
2080:37 - we start from line number eight we come back to three comma three
2080:44 - and now we actually go up we update line number here
2080:48 - and there will be one more method on the call stack as we are going up so row will decrease
2080:57 - so it became two comma three now we reached here
2081:03 - this is the water so we return back to three comma three
2081:11 - we start the execution on line number nine we come back to three comma three
2081:16 - because value of row and column is three comma three in this dfs
2081:22 - now we go towards right we update line number 10 here because we are leaving this dfs
2081:30 - and there will be one more method on the call stack we are going towards right so column will
2081:34 - increase so here you can see that we have gone outside the boundaries of this matrix
2081:41 - so value of column is actually equal to grid of zero dot length which is equal to four
2081:48 - it means we are outside the boundaries of this matrix so we'll simply return
2081:55 - we return back to three comma three we start the execution at line number 10
2082:00 - like this
2082:04 - and now we simply go down so we update the line number here 11
2082:11 - as we are going down row will increase
2082:16 - and we have went outside the boundaries of this matrix
2082:21 - so here now value of row is equal to grid dot length which is four so we'll simply return
2082:30 - we start the execution from line number 11 and we return back to three comma three
2082:35 - and after that there are no lines to execute so this dfs will also will be removed from the call
2082:41 - stack and we go back to a method which called is dfs at row and column three comma three
2082:50 - so this is the condition so we know that we have visited one more island
2082:57 - so we'll increase the value of number of islands so it becomes three
2083:01 - will increment j so j will go beyond the boundaries of this matrix so this for loop will terminate
2083:12 - and as we have visited the last row will increment i so i will also go beyond the
2083:18 - boundaries of this matrix it means we have visited a complete matrix and at the end
2083:24 - after visiting all these islands will simply return the value three because there are three
2083:30 - islands this this and this here you can see we have visited this this and this
2083:41 - so friend this was all about it how we can solve the number of islands problem
2083:45 - i hope you must have liked this video in case if you are new to my channel then please subscribe
2083:50 - to my channel and click the bell icon so that you never miss any update thanks have a nice day
2083:56 - hello everyone so in this video we will discuss about hashing data structure and we will see
2084:05 - a basic introduction to hashing so friends before we start in case if you are new to my channel
2084:12 - then please subscribe to my channel so that you never miss any update so what do we mean by hashing
2084:20 - so before discussing that we will see that why we actually need a concept called hashing
2084:27 - so usually when we need to perform any search operation we have few options such as linear
2084:34 - search where what we do is let's suppose we are given with this array of 10 elements
2084:40 - and let's suppose we want to search for a particular element for example let's say 10
2084:46 - so in linear search what we do is the value which we want to search which is 10 we compare it with
2084:53 - each and every element of this array and when we reach here we find that 10 is there in this
2084:59 - array and we simply say the value 10 is found in this array also let's suppose if we want to search
2085:07 - for a value let's say 20 so what we need to do here is we need to compare 20 with each and every
2085:15 - element of this array and after comparing with the last element if we don't find 20 in this array
2085:22 - then we simply return that 20 is not found so here the problem is in case if the key which you
2085:30 - want to search is not present in this list or array then the time complexity basically goes to
2085:37 - O of n because we need to compare the key with each and every element and then only we can come
2085:43 - to know that whether the key is present in this array or not so this is one problem with the
2085:49 - linear search the other form of search we have is binary search now in binary search what we have is
2085:57 - let's say we are given with this array of 10 elements in binary search the array we have
2086:03 - is already sorted so here you can see here the elements are sorted in ascending order
2086:09 - so when the elements are sorted in ascending order we basically use this property to make
2086:15 - this search quicker so for example let's say if we want to search for an element 8
2086:21 - so here we don't compare the key which we want to search with each and every element of this array
2086:27 - as we know that the array is already sorted we take the lower index which is zero we take the
2086:34 - higher index which is nine and using these two indexes we try to find the mid index so here we
2086:41 - simply do nine plus zero divided by two which give us 4.5 and if we take the integer value
2086:49 - the mid value will come to four so what we do is whatever the value is at the index four
2086:56 - which is 10 we simply check that whether eight is less than 10 or greater than 10
2087:03 - we know that eight is less than 10 so it must be lying somewhere to the left of
2087:09 - mid index because here we know that the elements of array are already sorted so what we do here is
2087:16 - we simply discard the right sub array completely because we know that searching in elements after
2087:22 - 10 will never give us eight it will only come before 10 so we simply discard the right sub array
2087:31 - so after discarding the right sub array our array becomes from zero to four
2087:35 - where we take zero as the lower index and four as the higher index we do four plus zero divided by
2087:42 - two we get two as mid index so whatever the value is at mid index which is five
2087:50 - when we compare five with eight we know that eight is greater than five
2087:54 - and as the array elements are sorted we simply discard the left sub array because we know that
2088:00 - eight must be lying to the right of five so now after we discard the left part our array becomes
2088:08 - of three elements from two to four and then we again find the mid index we do four plus two which
2088:16 - is six and if we divide it by two we get three so whatever the value is at third index which is
2088:22 - mid we see it is eight we come to know that we have found our key and here you can see that
2088:30 - compared to linear search binary search works pretty much faster when the array elements are
2088:35 - sorted so friends with binary search with each iteration we simply discard half of the array
2088:44 - because we know that the element which we want to search can be found at three places one is
2088:48 - at the mid index or it can be on the left sub array or on the right sub array so if it is on
2088:56 - the left sub array we simply discard the right sub array and if it is on the right sub array we
2089:01 - simply discard the left sub array so here you can see on each iteration we are discarding half of
2089:08 - the array so the time complexity of binary search comes out to be O of log n which is pretty much
2089:15 - faster than O of n but here the problem still remains which is is there any data structure
2089:24 - or is there any search technique which gives us a time complexity of O of one because searching
2089:31 - an element in linear search takes O of n which is not feasible for the search operation
2089:38 - and for the binary search takes O of log n but here we have this constraint that element
2089:44 - should be sorted which is usually never the case we have always elements in unsorted form
2089:50 - and if we want to sort them we need to apply sorting algorithms whose complexity can reach
2089:55 - to n log n so after we sort the elements then our search becomes faster and we get O of log n
2090:04 - so how can we achieve a time complexity of O of one
2090:09 - so if you see one solution is if we take array data structure now why array because
2090:16 - array can be used to provide O of one searches using indexes so let's suppose if we are given
2090:23 - with these elements 6 1 3 5 9 7 and let's say if we want to search in these elements
2090:32 - and we want that the search should be of O of one time so what we can do is among these elements
2090:39 - we will see which is the highest element which is 9 so what we can simply do is
2090:44 - we can create an array whose last index is 9 which means we create an array of 10 elements
2090:52 - where the last index is 9 and what we do here is we take 6 and we store 6 at sixth index
2091:01 - 1 at first index 3 at index 3 5th index 5 9 at index 9 7 at index 7 so we simply store
2091:16 - all these elements into their respective indexes in an array and let's suppose if we are given
2091:23 - let's search for a value 3 so what we can do is we simply go to third index of array
2091:30 - by accessing the array with index 3 and we see whether 3 is there or not so this operation takes
2091:37 - time complexity of O of one because we can access array elements directly so here at third index we
2091:45 - see that there is a value 3 so our answer is found and let's say if we want to search for 0
2091:53 - so what we do is we go to 0th index and we see there is no value so our answer is not found
2092:01 - so friends here you can see that arrays can give us a time complexity of O of one
2092:07 - when performing the searches using their indexes
2092:12 - so the time complexity of this scenario will be O of one which is pretty much fast
2092:20 - so let's suppose we take one more example let's say we are in a classroom and we
2092:26 - have these 30 students so what we can simply do is we can assign a roll number to each and every
2092:33 - student and we can create a data structure which is array of size 30 where last index is 29
2092:42 - and we can assign the indexes to each and every student and let's suppose we are storing
2092:49 - a student object on each and every index so here when these students are sitting in a classroom
2092:55 - the teacher can directly go to a particular seat let's say 5 and let's say the teacher has a device
2093:02 - where she can directly type 5 and gets the information for the student that the student
2093:06 - name is john these are his marks in particular subject and all of the information for the student
2093:13 - john and similarly if she searches for 29 she can get the information for Tina so here also
2093:22 - we can use array data structure and we can get the time complexity of O of one
2093:27 - so to this type of storage we simply call direct addressing
2093:32 - moving ahead now whatever the example we saw there array was a perfect data structure
2093:39 - for searching in O of one times now where the problem will still arise is let's say
2093:45 - if we want to store other card number which is of 12 digits or you can also take an example of
2093:52 - storing the social security number in an array so here if you see that the other card number
2094:00 - is of 12 digits and it gives an identity of a particular citizen of India based on his other
2094:07 - number so the problem is if we take an array to store the other card number then if you want to
2094:15 - store this big number into an array which is nothing but direct addressing with its index
2094:22 - then there would be a huge array to store all the other card numbers so this is one problem
2094:29 - that we need to create such a huge array where the other card number matches the index of that
2094:35 - array and the second problem is let's say if the other card number is designed with 12 digits
2094:41 - and we have created a huge array to store the other card number and let's suppose
2094:46 - we have only distributed 10 to 12 other card to the people and if we try to store those other
2094:53 - card numbers into the array then after storing we will see that most of the memory of the array
2095:00 - elements will remain unutilized invested so this is the problem with arrays where we can't use
2095:07 - direct addressing because we need to store such a huge number so to basically address these problems
2095:16 - hashing was introduced now what is hashing so here you can see that hashing is a technique
2095:23 - which is used for storing retrieving and removing the information as quick as possible
2095:30 - and how do we perform the hashing is here it is a process of converting
2095:36 - a arbitrary size key into a fixed size value so here what we are simply saying is
2095:43 - let's suppose we have our keys which are huge let's say the other card number or social security
2095:50 - number so what we can do is we can't directly store the key into the respective indexes of
2095:56 - the array because that problem we discussed in our previous slide so what we do is we take
2096:04 - that particular huge key and we try to convert that key into a fixed size value and how we
2096:11 - perform this conversion is this conversion is done by a special function which we call hash
2096:17 - function so we will discuss hash function in our upcoming videos but for time being we can think
2096:24 - the let's say if we have array of thousand elements and we want to store a 12 digit other
2096:30 - card number so what we do is we take the other card number which is of an arbitrary size or a
2096:37 - huge size we pass that number to our hash function and this hash function will give us a fixed size
2096:44 - value let's say if you are taking the size of the array where we want to store the other card number
2096:49 - is of thousand then it will give us a fixed size value between zero to thousand and we can simply
2096:55 - use that fixed value and store that particular other card number so this conversion of a large
2097:03 - key into a fixed small size is done via hash function so we will discuss this hash function
2097:10 - in detail in our upcoming videos so for time being you can simply think that hashing is a technique
2097:17 - which is used for storing retrieving and removing the information as quick as possible and the
2097:23 - operation which hashing supports such as storing retrieving and removing an information have
2097:29 - average runtime complexity of o of 1 so friends in this video we saw that why we actually require
2097:36 - the hashing technique or why we require a hashing data structure because we need
2097:42 - average runtime complexity of o of 1 when we want to store retrieve or remove any particular piece
2097:49 - of information so in our next video we will see that what are hash functions and how it helps
2097:57 - in converting a huge size key into a fixed size value
2098:04 - so friends in case if you find this information useful then please like this video
2098:08 - and if you are new to my channel then please subscribe to my channel
2098:12 - so that you never miss any update thanks have a nice day
2098:16 - hello everyone so friends in our previous video we discussed about what is hashing
2098:28 - so in this video we will see that what are hash functions
2098:33 - so friends before discussing about hash function in case if you are new to my channel
2098:38 - then please subscribe to my channel so that you never miss any update
2098:41 - so in our previous video we saw a basic definition of what is hash function
2098:50 - so a hash function simply takes an arbitrary size key and provides fixed size value also called as
2098:57 - index so here using an hash function we can take a key of any size and once we passed that key to
2099:06 - hash function it returns us back a fixed size value which we also called as index now this
2099:13 - fixed size value is basically small and can be taken up as index and using that index we can
2099:19 - store the key which we want and also by using this hash function we can even retrieve that key
2099:28 - so we'll see the importance of hash function more in our upcoming videos so for this video you
2099:34 - can simply think of hash function is let's suppose we are given key of any size what
2099:41 - we do is we simply pass this key to our hash function and whatever key we passed
2099:50 - hash function return as an index which is of fixed size now using this index value what we
2099:58 - actually do is we simply store this key into a smaller size data structure and we can perform
2100:04 - storing retrieving and removing of this key very fast we will see those implementation details
2100:14 - later in upcoming videos so for timing you can simply think that to our hash function we pass
2100:21 - in a key and it returns back as a smaller fixed size value index we will see its usage in greater
2100:29 - detail in our upcoming videos so friends the hash function can be of any type you can basically
2100:36 - write your own hash function where what you do is you simply take a key and it should return you back
2100:42 - a smaller fixed size value so that you can use that fixed size value and store that huge key
2100:49 - into a data structure so that the retrieval storing and removing of that particular key
2100:56 - becomes faster and how does hash function help us in achieving a time complexity of O of 1
2101:03 - we will see later in upcoming videos so one such typical hash function which is mostly used
2101:10 - in hashing data structure is modular hash function so what this hash function does is
2101:16 - the modular hash function simply takes a key and a size now what it returns is remainder
2101:23 - by dividing key by size so usually the remainder which hash function return us back is used as an
2101:31 - index to store the key in an array of the provided size so here you can assume that key
2101:39 - has a large value which cannot be taken up as an index of an array which we discussed in our
2101:45 - previous video that it creates the problem so what hash function will help us in doing is let's say
2101:51 - we take a smaller size array so when we pass the key and the size hash function will return the
2101:59 - remainder by dividing key by that size and whatever the remainder is returned that remainder
2102:06 - is taken up as an index to store the key in an array of provided size so here you can see
2102:13 - instead of using an array for direct addressing which we discussed in our previous video
2102:18 - here what we do is we simply take an array of smaller size and let's suppose the key has a very
2102:24 - large value now how we can store that key into the array of small sizes we simply take the key
2102:31 - we divide the key by the size and whatever the remainder we get that will be taken up as an index
2102:38 - to store this particular key so let's see how modular hash function help us in storing large
2102:44 - keys into a smaller size array so here we usually take the hash function as h of key which is the
2102:54 - hash function which takes in a key and usually returns us back an index and this hash function
2103:00 - can be any implementation you provide but here we are simply discussing the modular hash function
2103:06 - so here we take the key we do modulus by size which is key mod size now this modulus operator
2103:14 - always returns us back the remainder when we divide the key by size so here let's say these
2103:20 - are our keys which we want to store now here you can see the keys are 5 1 10 26 and 99 so we can't
2103:29 - take an array of length 100 to store only five elements for the direct addressing so what we do
2103:37 - is we simply take a smaller size array let's say of 10 elements now size of this array is 10
2103:44 - now how we store these keys into this array is we take the key we pass into the hash function
2103:51 - so here 5 modulus 10 which is 5 is the key modulus size which is 10 so if we divide 5 by 10
2104:01 - we get remainder as 5 because 5 is not divisible by 10 so the remainder we get is 5 so here we
2104:08 - simply take this key go to the fifth index here this is the index which it returns so we go to
2104:15 - the fifth index and we store 5 now we take 1 so 1 when we divide 1 by 10 we get remainder as 1
2104:29 - so we take this key go to index 1 and store 1 now we take key as 10 so when we divide 10 by 10
2104:40 - we get remainder 0 because 10 is divisible by 10 so here you can see that here 10
2104:46 - cannot fit into this array if we take it as a direct index so this hash function is helping us
2104:53 - to get a smaller index so when we do 10 mod 10 we get 0 so here what we do is we simply go to
2105:00 - the 0th index and we store 10 here similarly if we take a value 26 if we do 26 mod 10 it means if
2105:11 - when we divide 26 by 10 we get the remainder as 6 because 20 gets divisible by 10 and we get
2105:19 - the remainder value as 6 so here we go to sixth index and we store 26 there and similarly when
2105:29 - we take 99 when we do 99 mod 10 or when we divide 99 by 10 we get remainder as 9 so here
2105:39 - we go to ninth index and we store the value 99 so friends here you can see that here instead of
2105:47 - doing the direct addressing of the key with array index we are using a simple hash function
2105:54 - and whatever is the value of key we don't care we simply divide it by the size
2105:59 - and whatever the remainder comes out we simply take that as an index and we store those values
2106:06 - at that particular index so friends here we used the modular hash function to store these key
2106:12 - elements into an array of fixed size so similarly we can search a particular key based on our hash
2106:21 - function so if we take this example let's say if you want to search whether 26 is present or not
2106:28 - so when you are storing this value in this array we used modular hash function so similarly when
2106:36 - we want to search what we do is we take the value which we want to search we pass to our hash
2106:43 - function it returns us back an index we simply go to that index and we simply see that whether
2106:49 - that key is present or not so here in this case 26 goes to the hash function and the hash function
2106:57 - returns the remainder as 6 so we go to the sixth index we see there is a value we compare this
2107:04 - value with the key which we want to search and we see that 26 is present so now here you can see
2107:10 - the hash function is helping us store the keys which are very large in size and here you can
2107:16 - see that for storing 99 we didn't take an array of 100 size elements we simply took an array of
2107:24 - 10 elements and we stored these values in the array so friends here hash function can be implemented
2107:33 - in many different ways so one of the most popular hash function which we saw here was modular hash
2107:38 - function now friends one more problem arises here is as we are mapping large keys into a smaller
2107:47 - fixed size array there could be a possibility that let's say if you want to store one more
2107:53 - value as 109 so when we do 109 mod 10 we get remainder as 9 and when we go to ninth index
2108:02 - for storing 109 we already see that there is a value 99 so now there is a problem that what do
2108:09 - we do with initially stored 99 value because in array we can store only one value at a time
2108:15 - so we will see these problems in greater detail in our upcoming videos the idea which you are
2108:22 - seeing here is using a smaller array and storing the larger size keys this data structure if we
2108:29 - implement in such a way using a hash function such data structure are basically called as hash table
2108:36 - so in our upcoming video we will see what is hash table so friends i hope you find this information
2108:43 - useful and in case if you find this information useful then please like this video and if you are
2108:48 - new to my channel then please subscribe to my channel so that you never miss any update
2108:53 - hello everyone so in this section we will discuss about a basic introduction to hash table
2109:06 - in our previous video we discussed about what is hashing and what are hash functions
2109:11 - so in this video we will look into a data structure which is hash table and we will see
2109:17 - the concepts which we discussed in our previous videos like hashing and hash function and we'll
2109:22 - see how they are used to implement a hash table so before we start in case if you are new to my
2109:29 - channel then please subscribe to my channel so that you never miss any update in one of our
2109:36 - previous video we discussed that array can be used to store retrieve and remove an information
2109:43 - with the time complexity of o of one based on indexes but we also saw that array had a limitation
2109:50 - while implementing the direct addressing strategy via indexes so we introduced the concept of hashing
2109:59 - now based on those concept when we implement a hash table we basically take a generalized
2110:05 - form of an array so internally the data structure for implementing hash table is
2110:10 - pretty much an array but it is used with the concepts of hashing and hash function
2110:15 - now what do we do with the hash table is the data is stored in the form of key value pair
2110:23 - so in our previous video we discussed that how a key is passed to a hash function
2110:27 - and an index is returned so based on the index we store this key value pair
2110:35 - so basically in a hash table we simply put the data in form of key value pair
2110:40 - where we take the key we pass it to the hash function and hash function returns as an index
2110:46 - so this index is nothing but an index of an array where we simply store our key value pair
2110:54 - so this key can be a huge key but our hash function takes that key and returns us back
2111:00 - a fixed and a small value which is nothing but an index of our array
2111:05 - now what we do is we take that index and we store the key value pair in the array
2111:15 - and the primary operations which are supported by hash table are
2111:21 - first is the put which takes in a key and a value
2111:25 - now what does this operation does is it adds the key value pair against a unique key
2111:31 - so here our key is unique and if we try to add a different value with the same key
2111:37 - then that value gets updated and the older value will be removed
2111:41 - so here the key is unique because this key usually goes into this hash function
2111:47 - and based on the hash function calculation our index is returned
2111:51 - and on that index this key value pair is stored
2111:54 - similarly after storing when we do get then the value is returned for that provided key
2112:02 - so here this key goes into the hash function our index is returned and based on this index
2112:09 - whatever the value is stored in the array that value is returned for that provided key
2112:16 - and the third operation is removed where we pass the key
2112:19 - so what it does is it removes the key value pair from the hash table
2112:24 - so these are the three primary operations supported by hash table
2112:28 - and here if you see all these three operations use a hash function
2112:33 - and we will discuss all these three operations in greater detail in our upcoming lectures
2112:38 - these all three operations internally use the hash function which takes in a key
2112:43 - returns as an index and based on the index put get and remove operations are performed
2112:49 - so all these three operations are pretty much fast the average running time of all
2112:56 - this operation is o of one and if you see in our java collection framework
2113:03 - we have a hashmap class which is pretty much same as the hash table class
2113:08 - so if we want to deal with key value pair then we simply use hashmap class
2113:13 - and if we want to deal with only keys then we use hash set
2113:18 - so here if you want to store any data in form of key value pair then we simply take the help of
2113:24 - hashmap class in java which is nothing but an hash table but if you only want to deal with the keys
2113:30 - and not with the value then we simply use the hash set class and the idea behind both the classes
2113:37 - to store the keys remains the same which we discussed here
2113:41 - so for now let's see a simple hash table where we have provided with the hash function as keymod
2113:49 - size and size is nothing but the length of this array so this array is the internal data structure
2113:57 - to implement a hash table so we simply call it a hash table only now let's say if we want to
2114:03 - store these key value pairs in this simple hash table so what we do is let's say key is 5
2114:11 - and the value is john so when we try to store this key value pair in a simple hash table
2114:17 - what we do is we take the key we pass it to hash function and this hash function returns as an
2114:23 - index so we simply go to that index and store this key value pair so for example 5 mod 10
2114:33 - so when we divide 5 by 10 we get remainder as 5 so this is our index which is being returned by
2114:41 - the hash function so here we simply go to the fifth index and we simply store key value pair
2114:51 - so this array can be taken up as array of key value pairs which can be our own type object
2114:57 - which takes key and a value now if you want to store 1 comma tom so 1 divided by 10 gives
2115:05 - remainder as 1 so here we go to the first index and we store 1 comma tom if we want to store
2115:15 - 10 comma james we do 10 mod 10 so we get remainder as 0 so we go to the 0th index
2115:24 - and store 10 comma james there for this key value pair we get 6 as the remainder so we go to the
2115:34 - sixth index and we store 26 comma tina for this key value pair so if we divide 99 by 10 we get
2115:45 - remainder as 9 so we go to the 9th index and we store 99 comma sana there now if we take the last
2115:55 - value 105 mod 10 will give a remainder as 5 so friend this is a simple hash table so now here
2116:04 - you can see if we try to go to fifth index here you can see that we already have this value 5 comma
2116:12 - john now the problem is what should we do with this key value pair so whenever this kind of
2116:19 - situation comes where we are simply storing key value pair in a particular index and we already
2116:25 - encounter a key value pair there this concept in hash table is called as collision because now there
2116:32 - is a collision between these two values that what should we do so friends here you can see that these
2116:38 - kind of situation usually arrives when we implement a hash table because here you can see
2116:44 - the size of this hash table is only 10 and the keys which we are trying to store is more than 10
2116:52 - so usually after storing few values a hash table simply encounters this collision frequently
2116:59 - so this is a simple hash table so in our future video we will see that how this hash table can
2117:04 - be implemented to resolve these collisions and also friend there are strategies to resolve these
2117:10 - collisions which we'll discuss in our upcoming videos so friends i hope you find this information
2117:16 - useful and in case if you find this information useful then please like this video and if you are
2117:22 - new to my channel then please subscribe to my channel so that you never miss any update
2117:28 - thanks have a nice day
2117:34 - hello everyone so in our previous video we discussed about a simple hash table we saw
2117:40 - what hash table does and we also saw that when we use hash function to store the key value pair
2117:47 - in a hash table there will come a situation when there will be a collision so in this video we will
2117:53 - see that how we can resolve that collision using a collision resolution technique which we call as
2118:00 - separate chaining so in our previous video we saw a simple hash table where we had this array of key
2118:09 - value pair and of size as 10 our hash function was key mod size where we divided key by size
2118:18 - and whatever was the remainder we used that remainder as an index
2118:23 - to store these keys with its values in this array so five mod ten gave value as five
2118:32 - so at the fifth index we stored five comma john
2118:37 - at the first index we stored one comma tom
2118:40 - at the zeroth index we stored 10 comma james because when we do 10 mod 10
2118:49 - or when we divide 10 by 10 we get remainder as zero on the sixth index we stored 26 comma tina
2118:59 - on the ninth index we stored 99 comma sana and when we encountered a value as 105
2119:08 - so our hash function returned us a value as five because when we divide 105 by 10
2119:16 - we get five as the remainder so when we went to fifth index we saw that there is already
2119:23 - a value stored five comma john at fifth index so this resulted in a collision which we discussed
2119:31 - in our previous video now in this video we will see that how we can resolve this collision
2119:37 - using a strategy called as separate chaining
2119:42 - so friends what we do in separate chaining is in case if we encounter a collision let's say
2119:50 - when we try to store 105 on the fifth index we already found that value as five comma john
2119:56 - so what we do is when this collision occurs then at the fifth index we simply store both the values
2120:04 - in a list so that list is nothing but a simple linked list where whenever we encounter a collision
2120:11 - we simply add that element in that list which belongs to that particular index so when we try
2120:18 - to store many values which are huge in a small fixed size array then there will be a situation
2120:25 - where we encounter frequent collisions so we simply add those elements into the list
2120:33 - which belongs to that particular index so when this list grows it looks like a chain
2120:39 - so therefore the resolution strategy is separate chaining where with each index we create a
2120:45 - separate chain or linked list to store the values which are getting collided so let's see an example
2120:54 - so friends in our previous videos when we discussed about the linked list we saw that
2120:59 - how we can create a singly linked list doubly linked list and circular singly linked list
2121:05 - so if we take the example of singly linked list we saw that there is a head from where basically
2121:11 - the singly linked list starts and each node basically points to the next node in the list
2121:18 - and the node which is at an end points to null so here instead of taking the array
2121:25 - of key value pair what we do is we take the array of hash nodes so here if you see
2121:33 - let's say if you want to store five comma john we first pass the key into the
2121:40 - hash function we get the index which is five
2121:46 - so instead of directly storing at this index we create a hash node so this hash node is pretty
2121:53 - much similar to the singly linked list list node where we had a data and a reference to the next
2122:01 - node so here we simply add one more value which is the key so here our hash node has three attributes
2122:09 - one is the key other is the value and the third is the reference one next hash node
2122:15 - in this list or chain when some collision occurs
2122:18 - so this terminology you can simply take it as hash node so in our upcoming videos we will discuss
2122:26 - in greater detail what is hash node now let's say if we want to store one comma tom so at the first
2122:34 - index we store one comma tom in a form of a hash node at the zeroth index we will store
2122:44 - ten comma james
2122:45 - and similarly the other values
2122:53 - but when we encounter one zero five comma mary
2122:58 - so our hash function is returned our index is five so here when we go to index five we see that
2123:04 - there is already a hash node available having key as five value as john now here we have encountered
2123:12 - a collision so what we do is as this hash node can be treated and converted into a list
2123:20 - or chain what we do is we can use its next reference and we can simply store
2123:27 - one zero five as key value as mary and its next is pointing to null so here whenever we encounter
2123:37 - a collision we keep on adding those elements in this chain which we also say that it's a form of
2123:44 - a linked list so by separate chaining technique we can resolve these collisions and we can store
2123:52 - the values in the form of a linked list when any collision occurs so we'll see the importance
2123:58 - of this hash node and this linked list in our upcoming videos when we will implement
2124:03 - a hash table using the separate chaining technique so friends i hope you find this
2124:09 - information useful and in case if this information is useful to you then please like this video
2124:15 - and if you are new to my channel then please subscribe to my channel so that you never
2124:19 - miss any update thanks have a nice day
2124:26 - hello everyone so in this video we will discuss that how we can represent a hash node in a hash
2124:32 - table so in our previous video we discussed about one of the collision resolution technique
2124:38 - which was termed as separate chaining and when we discussed about the separate chaining
2124:44 - we saw that how we can remove the collisions via a hash node and create chains where one hash
2124:51 - node is pointing to other hash nodes so let's see the structure and representation of a hash node
2124:57 - in a hash table but before we start in case if you're new to my channel
2125:03 - then please subscribe to my channel so that you never miss any update
2125:09 - so here a hash node class in hash table consists of three data members
2125:16 - now the first one is the key so the key is basically a unique value which help us in storing
2125:22 - the data and here this case simply represents a generic type in java
2125:30 - the second data member is value which is the actual data which is being stored in a hash table
2125:37 - in a location which is being computed by the key and the hash function so here v
2125:44 - simply signifies the generic type it can be any type so k and v can be any type
2125:52 - and the third data member is hash node next so it simply refers to the next hash node in a chain of
2125:58 - hash nodes so chain of hash node is nothing but a list of hash nodes which help us in resolving
2126:05 - the collisions where one hash node simply refer to the other hash node and they form a chain
2126:13 - so here these are the three data members and if we see the symbolic representation of it
2126:19 - then hash node consists of three things the key which is unique and which help us in storing the
2126:26 - value via hash function and the hash node simply points to the next hash node in a list when there
2126:34 - is a collision so here hash node is very much similar to the list node which we discussed in
2126:41 - our singly linked list videos the only difference is in the list node there was value and a reference
2126:49 - to the next node but here in hash node we also store the key so we will see why this key value
2126:55 - pairs are stored and how the primary operation in a hash table are implemented and if we see
2127:02 - a representation of it it looks something like this that it has a key value and a reference to
2127:09 - the next hash node in the list of hash nodes so friend this is how we actually represent a hash
2127:15 - node in a hash table so usually when we implement a hash table then the hash node is nothing but a
2127:23 - private class inside a hash table which help us in implementing the operations which are being
2127:29 - performed by hash table so those operation we will discuss in detail in our upcoming videos
2127:36 - i hope you must have liked this video and in case if you are new to my channel
2127:41 - then please subscribe to my channel thanks have a nice day
2127:47 - hello everyone so in our previous video we actually discussed about that how we can represent
2127:53 - a hash node in a hash table so in this video we will see that how we can implement a hash table
2128:01 - via separate chaining collision resolution technique so here in order to implement a hash
2128:07 - table i will be creating few videos which will be in series so you can consider it as a part one
2128:15 - of how to implement a hash table but before we start in case if you are new to my channel
2128:24 - then please subscribe to my channel so that you never miss any update
2128:27 - so friends in order to implement a hash table we will first look into some of the terminology
2128:35 - which we will be using frequently in upcoming videos to understand different parts of hash table
2128:45 - so here as we already discussed that hash table is nothing but a generalized form of an array
2128:50 - now let's say if you take the example of this array whose length is 10 and having index value
2128:56 - from zero to nine so when implementing a hash table via separate chaining collision resolution
2129:05 - technique we discussed that we actually use the hash node so here in order to store key value pair
2129:14 - we simply take this as an array of hash nodes so to this array we simply call it as buckets
2129:21 - and we denote it something like this that each container at a particular index is termed as
2129:28 - bucket and this array basically stores hash nodes which has key value pair and a reference to the
2129:35 - next hash node and here we will also create a variable which would be number of buckets
2129:44 - so this number of buckets is nothing but the length of buckets array which is also called
2129:50 - as capacity of hash table so for example if we want to store a key value pair let's say our keys
2130:00 - of integer type having value as 10 and a value of string type which takes in a value as james
2130:08 - and if we want to store at 0th index what we do is the 0th index bucket simply points to a hash
2130:15 - node showing key value and has a reference to next node so currently if there is only one element
2130:23 - then the next node will point to null similarly let's say at index 1 if we want to store a key
2130:29 - value so it would look something like this so here you can see that way we are storing this key
2130:35 - value pair is via hash function which we already discussed in our previous video and which we will
2130:41 - be discussing in our upcoming videos also that here you can see the key is 10 and here let's say
2130:48 - if you take the hash function as key mod the number of buckets which is also the length of this array
2130:54 - then we get 10 modulus 10 which will give us a remainder 0 and whatever we get from the hash
2131:01 - function it is nothing but our index so at the 0th index you can see that we have stored
2131:07 - a key value pair like this and similarly at 5th index we are storing a key 5 with a value as john
2131:18 - so here 5 when divided by 10 gives remainder as 5 only so at 5th index we are storing a key as 5
2131:27 - and we usually term it as hash node which we have already discussed
2131:30 - now let's say if we want to store a key of 105 so when we divide 105 by 10 we get remainder as 5
2131:40 - which would be the value returned by our hash function so if we go to index 5 we will see that
2131:46 - there is already a value so there is a collision so in order to resolve this collision we are taking
2131:52 - help of hash nodes because here you can see that the third data member is nothing but a reference
2131:59 - to the next hash node so here we can use the next reference to store this key value pair which also
2132:06 - corresponds to 5th index so here when we store this key value pair in form of a linked list
2132:13 - the first element is simply treated as head and this linked list is also termed as chains
2132:21 - because we are discussing separate chaining collision resolution technique and which is
2132:26 - being implemented via chains so here when a collision is encountered the key value pairs
2132:33 - are stored in a form of chain and this chain can be the way you want to implement you can simply add
2132:40 - the newly inserted node at the end or at the beginning or you can insert in a sorted form
2132:46 - like based on the keys that 5 comes before 105 comes later and then 205 305 something like that
2132:55 - so you can insert multiple key value pair which is also called as hash node in a way which you want
2133:04 - and similarly we can store other values like this also friends here you can see that length
2133:11 - of this array is 10 which is also a value stored by number of buckets and which is also called as
2133:19 - capacity of our hash table but here you can see that this hash table currently has 1 2 3 4 5 and 6
2133:30 - hash nodes so the size of the hash table is 6 because it has hold 6 key value pairs
2133:38 - and the capacity is of 10 so this is the difference between the capacity and size
2133:43 - so when we talk about size you can think of it the number of key value pairs inside a hash table
2133:50 - and when we talk about capacity number of buckets or length of buckets we are simply talking about
2133:57 - the array length so friends these are the few terminologies which are being associated with hash table
2134:03 - so here when we implement a hash table you can see that we have three members here one is the
2134:13 - buckets array which is of type hash node the second value is number of buckets which is also
2134:20 - the capacity of our hash table and the third variable is size which is the number of key value
2134:27 - pairs being stored in a hash table so here you can see that hash table is a constructor
2134:34 - which takes in a capacity so when we create an object of hash table we need to provide
2134:39 - it what's the capacity of our hash table it means we are providing that how many buckets
2134:46 - the hash table will have and here you can see that internally our hash table is using
2134:52 - hash node class so which we already discussed that it has a key and a value and a reference
2134:59 - to the next hash node so here you can see that we are taking key as integer and value as string
2135:04 - so this can be any generic type so for the understanding and demonstration i will be using
2135:10 - the key as integer and the value as string so basically most of the things remain same
2135:15 - when we take any generic type of key and value so here after taking key as integer and value as
2135:22 - string and the third member is a reference to the next hash node which help us in storing
2135:29 - the key value pair in a chain when the collision occurs so here what we do is
2135:37 - at the start we simply call and create an instance of hash table and let's say we pass
2135:43 - capacity of 10 to our hash table so it looks something like this that capacity value is 10
2135:52 - and in the hash table constructor what we do is we assign the capacity to number of buckets
2135:58 - so it becomes 10
2136:02 - and then we create an array of hash node and we provide the capacity
2136:06 - so it looks something like this that internal data structure is array of type hash node
2136:14 - it is being termed as buckets and each compartment here you can see is a bucket
2136:20 - which holds the hash nodes in a form of a chain so here when we create this array at the start
2136:28 - every index or bucket points to null because there are no hash nodes currently into this
2136:34 - array of hash nodes so at the start size remains zero because we currently don't have any key
2136:42 - value pairs inside this hash table so size is zero so friends in this video we saw a initial
2136:50 - implementation of a hash table via separate chaining collision resolution technique
2136:57 - in our upcoming videos we will see that this hash table has many operations where we
2137:04 - put a key value pair we remove a key value pair and we can get a value based on a key
2137:12 - and there are many other operations which we will be looking into our upcoming videos
2137:17 - so this is just a basic and initial implementation of a hash table
2137:22 - so now let's go to our intelligent id and we'll simply code this part into the id
2137:29 - i hope you have find this information useful and in case if you find this information useful
2137:34 - then please like this video and if you are new to my channel then please subscribe to my channel
2137:40 - so that you never miss any update thanks have a nice day
2137:49 - hello everyone so in our previous video we discussed about a initial implementation
2137:54 - of hash table we saw the structure of hash table and we also saw that how it uses hash nodes
2138:02 - internally now in this video we'll simply code for the internal structure of hash table
2138:08 - and in upcoming videos we will see the different operations performed by hash table
2138:14 - and then we'll test its working in the main method so here i have created one class as hash table
2138:20 - now as we discussed hash table will consist of few instance variables one is
2138:26 - this array of hash node which we term as buckets and as it is using the hash node class internally
2138:39 - here we will create a inner class hash node and as we already discussed
2138:50 - that this hash node class will have three members
2138:56 - one would be our key so this can be
2139:07 - generic type the second member would be value and this can also be
2139:17 - any generic type so here for the demo purpose i am using the key as integer and value as string
2139:28 - and the third member would be the reference to the next hash node
2139:42 - and it will have a constructor
2139:47 - which will take two things
2139:54 - key and a value
2140:04 - we will assign the key to this dot key
2140:10 - and value to this dot value
2140:13 - so here the hash table consists of an array of hash node which we called as buckets
2140:21 - it also has an integer variable
2140:27 - number of buckets which is also capacity and it also has
2140:35 - an integer type size which is nothing but number of key value
2140:47 - pairs in hash table or number of hash nodes in a hash table
2140:59 - so basically in a hash table the number of hash nodes represents the size of the hash table
2141:08 - and here we will provide a constructor to our hash table class
2141:19 - so when we will create an instance of hash table
2141:22 - it will simply call the parameterized constructor providing a default capacity
2141:36 - so here we will create one more constructor
2141:45 - which will take a capacity
2141:46 - so here we can provide a customized capacity by calling this constructor
2141:55 - and if we call this constructor it will create a hash table with a default capacity of 10
2142:02 - so here what we'll do is to number of buckets we will assign the capacity
2142:11 - and now number of bucket is holding the capacity so what we'll do
2142:15 - we will create the array of hash node
2142:24 - whose length would be the value stored in the number of buckets
2142:31 - so here when we'll create the instance of hash table let's say with the capacity we provide
2142:36 - so the number of buckets will hold that capacity and the array of hash node will be of size
2142:43 - which represents the number of buckets and usually at the start
2142:48 - when there are no hash nodes in a hash table the size will be zero
2143:03 - so this is what happens when we first initialize or create the instance of hash table
2143:09 - now here you can see that this is the initial implementation of hash table
2143:15 - so in a hash table there are many operations so one of the operation is
2143:22 - that we want to know the size of the hash table that how many key value pairs are there
2143:28 - so we provide a method as size
2143:30 - and here we simply return the size one more method we provide is boolean
2143:44 - we check whether the hash table is empty or not
2143:50 - so we provide the method as is empty and here if
2143:55 - size is equal to zero then we return true stating that hash table is empty and if size is not equal
2144:05 - to zero we are returning false so friends in our upcoming video we will look into the primary
2144:11 - operations of a hash table which is put which basically put a key value pair in a hash table
2144:27 - so the parameters are key and value so this method basically takes in a key value pair
2144:38 - and it simply puts that key value pair in our hash table so we will discuss about this method
2144:46 - in greater detail in our upcoming videos so this is one of the primary operations the other operation
2144:52 - is get so this method
2145:00 - simply takes in a key and returns the corresponding value associated with it
2145:10 - so for time being i am simply returning null to compile this method so here whatever the key
2145:18 - value pairs are stored in hash table so if you want to get any value associated with a key
2145:24 - we simply pass key here and we get its corresponding value and one more method is
2145:36 - remove where we pass the key and that key value pair will be removed
2145:42 - and the value associated with that key will be returned so when we call get the key value pair
2145:50 - remains in the hash table we only get the value out of the hash table but when we do remove
2145:57 - that key value pair is completely removed from the hash table and its corresponding value is
2146:02 - returned so here these are the three main operations which are being performed by hash table
2146:09 - and all these three methods have a time complexity of O of 1 which is the average time complexity
2146:17 - of a hash table so friend this was basic and initial implementation of a hash table
2146:26 - in our upcoming videos we will see
2146:30 - all these primary operations in great detail so friend in case if you find this information
2146:36 - useful then please like this video and if you are new to my channel then please subscribe to my
2146:43 - channel so that you never miss any update thanks have a nice day hello everyone so in our previous
2146:54 - video we saw a basic implementation of a hash table we saw that hash table internally has
2147:01 - an array of hash nodes and we also saw the representation of a hash node which contains
2147:06 - key value and a reference to the next hash node so after creating a basic structure of hash table
2147:15 - in this video we will see that how we can put a key value pair in a hash table
2147:19 - and the strategy which we will be using for collision resolution would be separate chaining
2147:28 - so friends before we start in case if you are new to my channel
2147:31 - then please subscribe to my channel so that you never miss any update
2147:37 - so here you can see that in our previous video we saw a basic structure of hash table
2147:44 - where we can create a hash table by providing in a capacity which also signifies the number
2147:50 - of buckets in a hash table so when we will call this line here you can see the hash table
2147:56 - internally uses an array of hash node which we call as buckets and at the start each hash node
2148:05 - at a particular index points to null so friends when we try to put a key value pair into the
2148:11 - hash table there are various scenarios which comes into picture so the one scenario is when
2148:17 - we take the key and we pass it to our hash function then that hash function return us
2148:22 - an index so what we do is we simply go to that index and see that whether the hash node is
2148:29 - pointing to null value or to any other node so in case if it is pointing to null then we simply
2148:36 - insert key value pair in a form of a hash node and we simply assign that hash node to that
2148:42 - particular index and in case if there are multiple hash nodes already present then what we do is
2148:49 - we first check that whether that key is already present in the sequence of hash nodes or not
2148:56 - and if the key is already present then we simply update the value we don't insert a new key value
2149:01 - pair and one more use case is let's say if there are multiple nodes but the key value pair is not
2149:08 - present so what we do is we simply create the hash node from the key value pair which we want
2149:14 - to insert and we simply insert that hash node at the beginning of the list which is being formed
2149:21 - by the hash node at a particular index so currently you see all the hash node at a
2149:28 - particular index is pointing to null it means that each list which will be getting formed
2149:34 - at a particular index starting node is null because there are no key value pair currently
2149:40 - in this hash table and at the start we have this number of buckets value is 10 because we are
2149:48 - providing the capacity to be 10 and currently as there are no elements so the size is zero
2149:56 - now let's say if you want to put an integer key and a string value so here key is 105 and value
2150:03 - is john so at the start here you can see that key is very long and we need to accommodate this key
2150:11 - somewhere in this small buckets array so that when we put this key value pair
2150:17 - and when we want to find that key value pair it should be pretty much fast
2150:21 - so what we do is we simply pass this key to our hash function so here we will take the example
2150:27 - of modular hash function which will take the key and will simply divide the key by buckets.length
2150:35 - or number of buckets and whatever is the remainder that would be our index which will be written by
2150:43 - this method so we are using this method as our hash function which is nothing but the modular hash
2150:49 - function so if we divide 105 by 10 we get the remainder is 5 so that 5 will be returned from
2150:56 - this method and will be our bucket index now what we do is we simply access the hash node at this
2151:05 - bucket index so we go to the fifth index and we access this hash node so currently you can see it
2151:11 - is pointing to null so which simply means that there are no hash node at this index and as this
2151:18 - is pointing to null it will signify the head is pointing to null because at this index we are
2151:26 - storing a hash node so this hash node has next reference which can store other hash nodes and
2151:33 - if there are many hash nodes then the first hash node is always our head so this is also what we
2151:39 - already discussed when we discussed about the singly linked list where we normally had a list
2151:45 - node with a value and a reference to the next node so here the only difference with hash node is
2151:51 - it has key value pair and a reference to the next hash node so here you can see currently head is
2151:57 - pointing to null which means at this index there is no hash node so what we can do is
2152:04 - we can increment the size because we can directly put this key value pair here
2152:08 - at this point so first we create the hash node with key as 105 value as john and when we create
2152:19 - a new hash node the next always points to null so for us now what we do is whenever we insert
2152:26 - this key value pair or hash node into this buckets array we can use different strategies
2152:33 - one would be that we can insert this node at the beginning of the list or we can insert this
2152:38 - node at the end of the list or we can store this node based on some sorting logic such as the
2152:45 - ascending order of the keys so there are various strategies by which we can insert this node
2152:51 - so here we will be simply inserting this node at the beginning of the list so friends in our
2152:58 - previous videos we have seen that how we can insert a node at the beginning of the list
2153:03 - or a singly linked list so here the concept remains exactly the same now here you can see
2153:08 - as head is pointing to null so at the first step what we do is as you want to insert this node at
2153:14 - the beginning of the list and there could be a possibility that there are already nodes here
2153:20 - as currently there is no nodes but there could be a possibility that head is pointing to a chain
2153:25 - of nodes so at the first step what we do is we simply assign node next value to head because we
2153:32 - want to insert this node at the beginning of the list so if node next is pointing to head
2153:38 - then only this node will be at the beginning of the list but currently head is pointing to null
2153:43 - so node next is already pointing to null and then what we'll do is this hash node which is
2153:50 - pointing to the head will break this link and we'll try to point it to our hash node which
2153:56 - you want to insert so it would look something like this this null value goes away
2154:05 - and this node will be inserted
2154:09 - now let's say we want to insert a key as 21 and a value as tom
2154:15 - so the bucket index would be 1 because 21 mod 10 will give remainder as 1
2154:23 - so we simply access the hash node at index 1
2154:27 - we see it is pointing to null so it is the same case like what we saw here so we simply
2154:34 - increment the size by 1 and then we put the key value pair in the form of hash node
2154:40 - so now here you can see that our hash table has two key value pairs therefore the size is 2
2154:56 - now let's say we want to insert a key value pair as 31 comma sana so here now this case is when
2155:04 - there would be a collision so how this separate chaining strategy comes into picture we'll see
2155:10 - now if we do 31 mod 10 we get remainder as 1 so our bucket index is 1 so we simply go and access
2155:22 - the hash node at index 1 so we see that there is already a hash node at this index so now here is
2155:29 - a collision so the way we insert this key value pair now is we create the separate chains in a
2155:36 - form of list so that's why we have created this hash node which has a next reference so that chain
2155:43 - of nodes can be added with ease so at the first step what we do is to whichever hash node this
2155:50 - index is pointing that would be our head so this is the first step now what we do is as we don't
2155:58 - know that how many nodes are there and there could be a possibility that this key might exist
2156:04 - already in this hash table so what we do is we start from the head we compare its key with the
2156:12 - key which we want to insert and if that key is already present then we simply update its value
2156:19 - we don't add a key value pair in this hash table we simply update the value so that case we will
2156:25 - see later but now here can see head dot key is 21 and the key which we want to insert is 31
2156:33 - so therefore they are not equal so what we do is we move head to its next node because
2156:40 - so let's say if there are five nodes then we need to compare all the five nodes key with a key which
2156:46 - we want to insert because we don't want to insert a key which is already there so we simply move head
2156:53 - to its next node by assigning head dot next to head so now here you can see head is pointing to
2157:02 - null it means that this key is not present and we can safely insert this key value pair at this
2157:10 - index at the beginning of the list and as we are adding this key value pair we'll increment the
2157:18 - size by one and then we'll bring head to its first position again now we'll create our hash
2157:25 - node with this key value pair so key 31 value is sana and its next is pointing to null so here now
2157:34 - we are inserting this node at the beginning of the list so what we saw already here so at the first
2157:39 - step what we do is as we want to insert this node at the beginning of the list we simply assign
2157:46 - the value of head to node next so that node next currently pointing to null should point to head
2157:53 - so it looks something like this that now node next is pointing to head and as node next is
2158:00 - pointing to head now we can safely break this link and we can assign this reference to our
2158:07 - newly created node so it would look something like this this link will go away and now there
2158:14 - will be a reference to this hash node from this index so it would look something like this
2158:21 - so here there is a reference from this index to this node which you want to insert and from this
2158:27 - node there is a reference to the list of nodes which were already there so currently there is
2158:32 - only one node but there could be a chain so when we rearrange this it would look something like this
2158:38 - that node is inserted at the beginning of the list and this node simply shifted by one position
2158:52 - so friends now here you can see let's say if you want to insert a key value pair where key is
2158:56 - already present so here we have these three nodes we are trying to insert key value pair where key
2159:04 - is 21 and value is married so when we will divide 21 by 10 we get remainder as 1 so our bucket index
2159:12 - becomes 1 so we simply access the hash node at this index and the first hash node is our head
2159:21 - and if there is a hash node already present so now our first task is to verify that whether this
2159:26 - key is already present in this hash table or not so the way we do it is we do head.key which is 31
2159:33 - here we compare it with our key so here you can see they are not equal so what we do is
2159:41 - we traverse head to its next node via this reference so now we again compare head.key
2159:48 - so here you can see it's 21 and our key which we want to insert is also 21 so therefore they are
2159:54 - equal so what we do is by this check we came to know that key is already present so we don't
2160:01 - have to insert a new key and increase the size what we do is we simply update the value when we
2160:07 - actually put a key value pair so here instead of tom now the value will become married
2160:20 - so friend this was all about this video in our next video we will see the code
2160:25 - for adding this key value pair in a hash table via animation i hope you must have liked this video
2160:32 - and in case if you are new to my channel then please subscribe to my channel thanks have a nice day
2160:42 - hello everyone so in our previous video we saw a demonstration via an animation that how we can put
2160:49 - a key value pair in a hash table using the separate chaining collision resolution technique
2160:56 - so in this video we will see the code for that and we will see its demonstration step by step
2161:02 - with an animation so friends before we start in case if you are new to my channel
2161:08 - then please subscribe to my channel and click the bell icon so that you never miss any update
2161:13 - so when we create the instance of hash table this is what we discussed that at the start what
2161:21 - happens that all the hash nodes on each index points to null so which means that on each index
2161:27 - we have a list of nodes and the starting node is basically your head which is being pointing to null
2161:35 - and here you can see when we start as we are providing the capacity of 10 it means we are
2161:41 - creating the array of hash node with a length as 10 which is nothing but our number of buckets
2161:48 - and size is zero so let's say if you want to put a key and a value as 105 in john
2161:58 - so we call the put method we take key as 105 and value as john
2162:06 - so in our previous video we discussed the idea that how we can insert this key value pair
2162:11 - there are many use cases which we will be seeing later so each use case at the start what we do is
2162:18 - we take the key and we pass it to our hash function which gives us an index and we take
2162:24 - that index and we try to insert the key value pair in the form of hash node into this buckets
2162:29 - array so here you can see the get bucket index method is nothing but our hash function
2162:35 - so here we are using the modular hash function where we are taking the key we are dividing it
2162:42 - by number of buckets and whatever is the remainder we are returning it from this method which would
2162:48 - be nothing but our bucket index so when we pass 105 as key and if we divide 105 by 10
2162:56 - then we get 5 as the remainder so the bucket index is 5
2163:00 - now what we do is we try to access the hash node at this bucket index so which is 5
2163:12 - so here you can see it points to a hash node having value as null so here you can see it is
2163:18 - referring to a null value so it means at this index there are no hash nodes so we can directly
2163:25 - insert this key value pair and as the starting node is pointing to null we are creating a hash
2163:31 - node by name head which points to the first node at this index which would be null so head is
2163:38 - pointing to null so friends here you can see that on each index there can be multiple hash nodes
2163:45 - which are connected via the next reference which hash node has and when we discuss singly linked
2163:52 - list we saw that the starting node is head so here we are simply referring head as the starting
2163:57 - node of the singly linked list which will be formed by the chain of hash nodes so here why
2164:03 - we need this head is because in this file loop at this particular index there could be a possibility
2164:10 - that let's say there are many nodes so in this file loop we are checking that whether the key
2164:15 - is already present or not so here you can see as head is pointing to null it means that this key
2164:21 - value pair is not present so we exit from the while loop and as key value pair is not present
2164:28 - we can simply add this key value pair in the form of hash node so first we increment the size
2164:35 - so now size becomes 1 and now here you can see that let's suppose at this index
2164:44 - there could have been multiple nodes connected via next reference so in this while loop there
2164:50 - is a possibility that head might travel to some of the nodes to check whether the key is present or
2164:56 - not so after this while loop we bring back head to the first node by again assigning
2165:03 - the hash node at bucket index so head will again point to null
2165:08 - and now as you want to insert the node so first we create the hash node with key value pair which
2165:16 - you want to insert so it would look something like this key is 105 value is john and its next is
2165:24 - pointing to null and it is being referred by node now as you want to insert this node at the beginning
2165:32 - of the list which is starting from head what we do is we simply assign the value of head to node
2165:40 - next because we want to insert this node just before the head which would be the beginning of
2165:46 - the list so node next should point to head so we are simply assigning value head to nodes next
2165:52 - so currently node next is already pointing to null
2165:54 - and now as you want to insert this hash node in this buckets array so at this index whatever
2166:04 - the reference would be we simply assign it to the node so at the bucket index we are simply assigning
2166:10 - the value of node so it would look something like this as node is pointing to this node
2166:16 - now this hash node will point to the node which we want to insert so here you can see that we
2166:23 - have inserted one hash node and from now onwards there would be multiple hash nodes on this index
2166:30 - in case some collision will occur
2166:38 - so let's put one more key value pair where key is 21 and value is tom
2166:45 - so size is already 1 key is 21 value is tom
2166:50 - we first calculate the bucket index from our hash function so when we'll call get bucket index
2166:58 - we pass in the key so 21 when divided by 10 will give remainder as 1 so the bucket index will become
2167:07 - 1 so now what we do is we simply try to access the hash node at this bucket index
2167:16 - so when we call buckets and we pass bucket index as 1 we are accessing this value
2167:23 - so here you can see that the hash node which it refers is null so it means that there are no
2167:30 - nodes in this list here so head will point to null now we will simply check whether 21 is present
2167:41 - in list of nodes at this index or not so currently head is pointing to null
2167:47 - this condition in while loop will come out to be false and we know that this key value pair is not
2167:53 - present so we'll simply increase the size by 1 because now we are simply adding key value pair
2167:59 - into this buckets array so size becomes 2 and we already discussed that head might travel
2168:07 - in this while loop to some of the nodes to simply compare whether 21 is present or not
2168:13 - so we simply bring back head to the starting of the list by again assigning
2168:19 - the hash node at bucket index so head will again point to null
2168:25 - we'll create the hash node with key as 21 value as tom and next pointing to null
2168:32 - and as we want to insert this node at the beginning of the list first we assign the value
2168:39 - of head to nodes next so head is pointing to null so here node next will point to null
2168:49 - and then we'll simply add node into this bucket array by assigning the value of node
2168:56 - at the bucket index so it would look something like this
2169:00 - that now it will point to the node which we want to insert
2169:07 - so friends here you can see that we have added two nodes now
2169:13 - now let's say we want to add one more key value pair where key is 31 and value is sana
2169:19 - so this is the case where we will actually see the collision and we will see the importance of
2169:26 - this next reference so key is 31 and value is sana we calculate the bucket index
2169:36 - 31 divided by 10 will give remainder as 1 so bucket index will become 1
2169:43 - we will access the hash node at this bucket index which is at index 1
2169:49 - and to whichever node it is pointing our head will point to that node because that would be our
2169:55 - starting of this list so head will point to this node
2170:01 - so now we'll see that whether 31 is present in this list of nodes or not which is at this index
2170:09 - so currently you see head is not equal to null so there could be a possibility that this key
2170:14 - and value might exist already in the buckets array so in the while loop we check whether head
2170:23 - dot key which is 21 is equal to 31 or not which is the key which we want to insert
2170:31 - so this condition comes out to be false because 21 is not equal to 31
2170:36 - it means this key value pair is not present for this node so what we do is we simply traverse
2170:44 - head to its next node because there could be possibility that this list can contain
2170:50 - let's say n number of nodes so we have to compare the keys for this n number of nodes
2170:56 - by traversing head 11 position with each iteration so we simply assign head dot next value to head
2171:05 - so head dot next is pointing to null so now head will point to null
2171:09 - we check whether head is equal to null or not so head is equal to null so this condition comes
2171:16 - out to be false which signifies that this key value pair is not present in this buckets array
2171:23 - so we can safely insert a key value pair so this condition comes out to be false and while loop
2171:29 - will terminate so rest of the steps remains the same as we are now inserting this key value pair
2171:36 - we will increment size by one so size will become three
2171:43 - and here you can see that head has already traversed into this list of nodes so we again
2171:48 - bring back head to the starting point of the list by again assigning the hash node at bucket index
2171:55 - which is our first hash node so it would look something like this head comes back to the first
2172:02 - position and why we are bringing head to the first position is because we are trying to insert
2172:10 - this key value pair in the form of hash node at the beginning of the list
2172:15 - so we usually need the head for that which is nothing but our first hash node of the list
2172:21 - so here we are simply creating the node with key value pair
2172:24 - so key 31 value is anna and its next is pointing to null which is being referred by node
2172:34 - and now as you want to insert this node at the beginning of the list
2172:39 - which means let's say there are n number of nodes already here and if we insert this node
2172:44 - our node should come before head which is having key as 21 so the node having key as 31 should
2172:51 - insert before the node having key as 21 which is nothing but our head so what we do is we can't
2172:58 - directly break this link and assign it to our node because if we break this link this chain will go
2173:05 - away so first we need to hold this chain so how we can hold this chain is we assign the value of head
2173:12 - to nodes next because we want to insert this node before the head so node next should point to head
2173:20 - so after this assignment it would look something like this
2173:24 - that node next is pointing to a node to which head is pointing
2173:31 - and then we can simply break this link and assign it to our newly created node
2173:37 - so it would look something like this this link will go away and there will be a link from
2173:44 - this index to the hash node which you want to insert so if we rearrange this structure it
2173:50 - would look something like this that the node which you want to insert is at the beginning
2173:56 - of this list which is just before the our old head so friends now let's see one last use case
2174:08 - where the key is already present so here you can see if we put key as 21 and let's say value
2174:14 - is meri so here if the key is already present we don't put the key value pair in the buckets array
2174:21 - we simply update the value and that we do with the help of this while loop so let's see how
2174:30 - key is 21 value is meri the bucket index will come out to be 1 because 21
2174:36 - divided by 10 will give remainder as 1 so bucket index is 1
2174:43 - so we simply access the hash node at this bucket index which would be nothing but our head
2174:51 - so head will point to this node
2174:55 - we check whether head is equal to null or not so here you can see currently head is not equal to
2174:59 - null so in the while loop we simply check whether key 21 is already present or not
2175:06 - so that is done via this if condition we simply check head.key is equals our key or not so 31 is
2175:14 - not equal to 21 so this condition comes out to be false and we simply traverse head to its next node
2175:22 - by assigning head.next to head so via this reference head has traveled to its next node
2175:29 - because we want to compare each and every key present at this index with our key
2175:36 - because there could be a possibility that 21 is already present in this list
2175:42 - so after this assignment we again check whether head is equal to null or not
2175:47 - so we encounter one more hash node so head is not equal to null
2175:52 - but now here you can see head.key is 21 it is equal to our key 21 so this condition comes out to be true
2176:04 - which means that key is already present in our buckets array so we don't increment size here
2176:10 - what we do is we simply assign the value as meri to head.value so head.value storm
2176:19 - which will be updated by meri so here we are simply updating the value with the recent value
2176:26 - old value is discarded and the size of the hash table remains the same because key is already
2176:32 - present and after updating the value we simply return from this method
2176:38 - so friends here you can see that we saw various use cases that how we can insert a key value pair
2176:51 - in the form of hash node in a hash table we saw that how we can add a key value pair we also saw
2176:58 - that how we can update a key value pair we also saw that what happens when there is a collision
2177:04 - and we also saw the importance of our hash function that it can take a large key
2177:10 - and provide us with a small index so that we can add this key value structure into this buckets
2177:18 - array so friends i hope you must have find this information useful and in case if you find this
2177:25 - information useful then please like this video and if you are new to my channel then please
2177:31 - subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day
2177:42 - hello everyone so in our previous video we saw that how we can put a key value pair in a hash table
2177:49 - we also saw different use cases which comes into picture when we actually put a key value pair in
2177:55 - a hash table so one use case is if the key is not present we simply put the key value pair
2178:02 - and increase the size and the second use case is if the key is present then we don't put the key
2178:09 - value pair we simply go to that key and simply update the value for that key so if the key is
2178:16 - present then we simply update the value we don't add the key value pair in our hash table because
2178:22 - key is already there so here before we start in case if you are new to my channel then please
2178:28 - subscribe to my channel and click the bell icon so that you never miss any update
2178:35 - so here you can see that our hash table internally has an array of hash nodes which we call as
2178:41 - buckets it also has the capacity which is nothing but buckets dot length and it also has size which
2178:49 - is nothing but the number of key value pairs in a hash table or we can say the number of hash nodes
2178:56 - which this array holds we also saw that how internally hash table uses hash node class
2179:04 - so here it has key value pair and a reference to next node so for our implementation we can take
2179:11 - any key value pair but here i have taken key as integer and value as string we also saw about the
2179:18 - size method which returns the number of hash node in our buckets array and if size is equal to zero
2179:25 - is empty method will return true now we'll see the implementation of the put method which takes in
2179:31 - a key and a value and we'll see that how we can put this key value pair in our hash table
2179:39 - so at the start we simply provide simple edge cases where we simply check that if key is equal to null
2179:48 - or value is equal to null then here either we can return from this method or we can throw an exception
2179:58 - let's say i throw illegal argument exception saying key or value is let's say null
2180:11 - so friends here you can provide your own edge cases so this is one of the simple edge cases i'm
2180:15 - providing now here in order to put this key value pair in our hash table the first thing we do is
2180:23 - we try to evaluate bucket where we can put this key and value so for that we will be using
2180:30 - modular hash function so here we first evaluate bucket index so we will call our hash function
2180:39 - whose name is we had bucket index and we pass our key to it because this key can be a very huge key
2180:50 - and in order to accommodate a huge key in simple or small size array we need a hash function
2180:58 - which takes in the key and returns us a smaller index value so that we can use that index and
2181:05 - put this key value pair so here i'll be creating one private method as get bucket index
2181:15 - which will return us back the index value for this key so it will take key
2181:22 - and here i'm using the modular hash function so we'll simply return key mod
2181:28 - divided by number of buckets and whatever is the remainder that will be returned from this method
2181:36 - here we all can also use buckets dot length instead of number of buckets so after getting
2181:45 - the bucket index we will try to access the hash node which is at that bucket index so we do
2181:54 - buckets we provide the index to it and whatever the hash node it will return
2182:00 - it will be the head of the list which this index is holding so that would be our hash node
2182:07 - and it will be head so after getting the head what we do is we can't directly put this key
2182:14 - value pair in our hash table we first try to search each and every element present at this
2182:20 - bucket index which is the list whose first node is referred by this head so what we do is we
2182:27 - simply provide a while loop and we provide the condition as head should not be equal to null
2182:37 - so if head is not equal to null then first thing we do is we try to search for our key
2182:42 - because in case if our key is present then we don't put this key value pair in the hash table
2182:48 - we simply update the value corresponding to this key so if head is not equal to null
2182:54 - we provide a condition we check head dot key equals the key which we have passed to this method
2183:07 - and if it is true what we do is we simply update the value associated with this head node with our
2183:16 - value so here you can see that we are using this head to simply traverse the list at this index
2183:24 - and we are comparing the head key with the key which we have passed so this case handles
2183:30 - if the key is already present in our hash table so after we update the head's value with the new
2183:36 - value we simply return from this method because we don't want to add this key value pair again
2183:43 - so if this condition is false what we do is we traverse head to its next node by assigning
2183:51 - head dot next value to head and this is important because let's say we have found a list of hash
2183:59 - nodes which is being referred by head so we need to compare this key with each and every node
2184:06 - which is being referred by this head so therefore we have provided this while loop
2184:11 - and as soon as we have found our key we are updating its value and returning from the method
2184:17 - without adding this key value pair and if we are not finding it then we are simply traversing it
2184:22 - to its next node so there would be a condition when head will reach the end of the list so at
2184:28 - that moment this while loop will terminate and at that moment while loop terminates it means
2184:34 - that we never found our key so we can now directly add this key so what we do in the first step is
2184:41 - as we are adding this key value pair in the hash table we will increase the size by one
2184:47 - and also from here you can see that we can add this key value pair in the form of hash node
2184:52 - and that hash node we can insert the way we want so here we will be inserting this hash node at
2184:59 - the beginning of the list so in order to get the beginning of the list what we do is there could be
2185:06 - a possibility that in this while loop the head must have traversed so what we do is we simply
2185:12 - do this step again and we make head reach to the first position by again assigning a hash node at
2185:20 - this bucket index so after this step now head is pointing to the first node of the list and we want
2185:28 - to insert this hash node before head so the first step we do is we create the hash node let's say we
2185:36 - give name as node and here we provide the key and the value so here it looks something like this
2185:53 - key value
2186:02 - and its next is pointing to null
2186:07 - so now how we can insert the node at the beginning of the list is
2186:11 - we simply assign head to node.next
2186:16 - here you can see head is pointing to the first node of the list and we want to insert this
2186:24 - node just before that so it means its next should point to head so this is the first step
2186:32 - and the last step is hash node at this bucket index is currently pointing to head
2186:39 - so we need to break that link so here what we do is we do buckets
2186:47 - bucket index and we assign the value of node to it so friends here you can see the hash node at
2186:54 - this bucket index was initially pointing to head and as we inserted our node just before the head
2187:02 - now hash node at bucket index is pointing to node which we want to insert and node next is
2187:07 - pointing to the head in order to keep the rest of the nodes intact so this is how we can put
2187:15 - a key value pair in a hash table now let's see it's working in the main method
2187:21 - so here we'll create a main method
2187:27 - first we will create the hash table
2187:33 - let's say we provide the capacity as 10 which means number of buckets will be
2187:37 - 10 and now what we do is we simply put few values let's say we put
2187:48 - 105 comma let's say tom
2187:55 - we put 21
2187:56 - 21 SANA and now what we do is let's say we do table
2188:07 - dot we print the size so if i run the code now
2188:17 - so here you can see it printed two now what we do here is
2188:26 - we again call table dot put and here we are again providing a key which is already there
2188:36 - and this time we are providing the value as harry so if i run the code now
2188:41 - the size should remain the same so here you can see it came out to be 2
2188:48 - and here if i debug this
2188:56 - so here you can see if you open buckets array that 105 was added at index 5 based on our hash
2189:05 - function where we divided 105 by 10 and remainder was 5 so if i open this you will see the value
2189:13 - as tom and key as 105 and next pointing to null because you only inserted one value
2189:21 - if i open the index one here we will see that we have only one value as next is pointing to null
2189:30 - but here you can see the updated value is harry initially it was SANA now it became harry
2189:36 - and here we simply updated the old value with the new value and let's suppose if we add something
2189:44 - like 31 dinesh and if i rerun it so here you can see 31 divided by 10 will give index one
2190:02 - so if i open index one you can see the 31 is inserted at the beginning of the list
2190:08 - and now you can see initially it was 21 so now 31 got inserted before that
2190:14 - and its next is now pointing to 21 so this is how we actually put a key value pair in our hash table
2190:25 - i hope you must have find this information useful in case if you have find this information
2190:29 - useful then please like this video and if you are new to my channel then please subscribe to my
2190:34 - channel and click the bell icon so that you never miss any update
2190:37 - hello everyone so in our previous video we saw that how we can put a key value pair in a hash table
2190:47 - using the separate chaining collision resolution technique
2190:51 - and in this video we will see that how we can get a value by key in a hash table
2190:59 - so friends before we start in case if you are new to my channel then please subscribe to my channel
2191:05 - and click the bell icon so that you never miss any update
2191:10 - so friends let's suppose we are given with this hash table having buckets array where number of
2191:16 - buckets is 10 which is the length of this hash node array and the size is three because we have
2191:22 - inserted three key value pairs in the form of hash node and where we have detected a collision
2191:28 - there we have inserted the nodes in the form of chains here index one is nothing but our bucket
2191:34 - index which correspond to this list whose index is one which is being generated by the hash
2191:41 - function by providing a certain key so friends here you can see the advantage of searching a
2191:49 - value corresponding to a key in this hash table is it is very much fast so for example let's say if
2191:56 - you want to search for key 105 so here you can see that the number of buckets in the buckets array is
2192:04 - only 10 and we are storing a huge value in this buckets array so after storing these values in
2192:12 - the form of chains there one question arises that how we can get that value because storing is easy
2192:19 - but how we can get a value corresponding to a key and that too very much fast so here as we discuss
2192:27 - the way we put the key value pair into the hash table using the hash function the same way we use
2192:34 - the hash function and deduce the index and try to search for a key so here you can see that size
2192:40 - is three so inside this buckets array there can be thousands of elements in the form of key value
2192:46 - pairs so how hash function help us in searching our particular key value pair fast is let's suppose
2192:56 - if we call table.get and pass in a key as 105 so via this method we are asking that please get us
2193:04 - the value corresponding to this key so here what happens is key is 105 so at the start what we do
2193:13 - is we pass this key to our hash function and hash function provide us with an index and we try to
2193:19 - search only in that particular index so this type of searching makes our data structure very much
2193:26 - efficient in searching so here our hash function is we pass the key so here we can take any hash
2193:34 - function which we like but here i'm taking this modular hash function where we are simply taking
2193:39 - the key we are dividing it by buckets.length or number of buckets and whatever is the remainder
2193:46 - that we are simply returning which will be treated as our index so if we divide 105 by 10 we get
2193:54 - remainder is 5 so our bucket index is 5 so it means that this key can only present in the chain
2194:04 - of nodes corresponding to index 5 so we simply access the hash node at index 5 and to whichever
2194:13 - node it is pointing that would be our head because there could be multiple hash nodes in this list
2194:21 - so the first node is usually our head so we simply point head to it and now our task is to
2194:28 - search for our key so here we do head.key which is 105 we try to compare it with our key and if
2194:37 - they are equal then we simply return its value which is john so friends here you can see there
2194:44 - are so many elements but with just simple hash function we quickly searched for our key
2194:52 - so this is the simple case where our first node became the key which we want to search
2194:57 - so after this let's say we search for 21 so key is 21 if we divide 21 by 10
2195:08 - we get remainder as 1 so our bucket index will come 1 so we directly go to index 1
2195:15 - and we will try to access its first node so head will point to the first node via this link
2195:23 - and here what we do is we simply compare head.key which is 31 with 21 so they are not equal
2195:31 - it means for this node the key is not present but there are other nodes in this chain so what we
2195:37 - do is we simply traverse head to its next node via this reference
2195:45 - so head comes to this position and now we again do head.key we compare 21 with our key
2195:52 - and we see that we have found our key so what we do is we simply return the value as tom
2195:59 - now let's suppose if we want to search for a key which is not present in this hash table
2196:10 - for example if we call table.get and we pass the key as 88 so here we see 88 is not present
2196:18 - so key is 88 when we will divide 88 by 10 we get remainder as 8 so the bucket index becomes 8
2196:26 - we go to the 8th index and try to access the hash node which it refers so here you can see
2196:34 - the head will point to null which simply signifies that this key is not present
2196:40 - in this hash table so we simply return null from this hash table
2196:45 - so from these are the simple use cases where we can get a value by key in a hash table
2196:57 - in our upcoming video we will see the code to get a value corresponding to a key
2197:02 - from the hash table and we will see the demonstration of the code via an animation
2197:09 - i hope you will find this information useful and in case if you find this information useful then
2197:14 - please like this video and if you are new to my channel then please subscribe to my channel
2197:20 - and click the bell icon so that you never miss any update thanks have a nice day
2197:29 - hello everyone so in our previous video we saw an animation that how we can get a value
2197:35 - by key in a hash table so now let's look into the code with an animation
2197:42 - but before we start in case if you are new to my channel then please subscribe to my channel
2197:47 - and click the bell icon so that you never miss any update so here the example which we discussed in
2197:54 - our previous video we will use the same example and we will see that how it works via this code
2198:01 - so let's say if you're calling get method and passing in the key so here key becomes
2198:07 - 1 0 5 and here you can see currently our bucket has three nodes in the form of key value pairs
2198:15 - so the size is 3 so at the first step if you want to get a value corresponding to a key
2198:22 - the first thing we do is we try to find the bucket where that key might belong so how we can do that
2198:29 - is we simply call our hash function we pass the key to it and it will return us back the
2198:35 - and it will return us back the index so when we will call get bucket index passing in the key
2198:43 - it will return us back the index by simply taking in the key dividing it by the bucket's dot length
2198:50 - or number of buckets and whatever is the remainder it will return us back that index
2198:55 - so here we can use any hash function and here i have used this modular hash function
2199:01 - which is taking the mod of key and bucket's dot length and returning us back the remainder
2199:08 - so when 105 will be divided by 10 we get remainder as 5 so the bucket index is 5 for this key
2199:17 - it means that at index 5 this key will be present or it might not present moving ahead
2199:25 - now as we have figured out the index so we try to access the hash node at this index
2199:32 - so we do buckets and we pass in the index so this will return us a hash node
2199:38 - which would be nothing but the head of our list of nodes which can be there on this index
2199:47 - so head will point to this hash node because this is the first hash node in a list of hash nodes
2199:53 - now how we can search for our keys we provide a while loop and why we are providing this
2200:00 - while loop is because here you can see there is only one hash node but there could be a possibility
2200:05 - that there are n number of hash nodes so we need to compare each and every hash nodes key
2200:11 - with the key which we want to search so we are simply checking whether head is equal to null or
2200:16 - not so if head is not equal to null it means that there are nodes present at this index
2200:24 - so we provide a if condition and we simply check whether head dot key which is 105
2200:29 - whether it is equal to the key which we want to search so here you can see this condition comes
2200:35 - out to be true because 105 is equal to the key which we are searching so the if condition comes
2200:43 - out to be true and we simply return head dot value because we have find our key and we want
2200:49 - to return its corresponding value so we simply return head dot value so john will be returned
2201:01 - now let's say if we want to search for a key which is somewhere in between of this list
2201:06 - at a particular index so here we are calling get method key as 21
2201:13 - so at the first step what we are doing is we are calling the hash function get bucket index we are
2201:19 - passing in the key so this method will return as an index where we can search for this key
2201:25 - so when 21 will be divided by 10 we get remainder as 1 so the bucket index will be 1
2201:31 - so now we'll simply access the hash node at this bucket index and that will be our head
2201:39 - so at index 1 we have this hash node so head will refer to it
2201:45 - we provide a while loop because here we are having a list from which we want to search
2201:50 - our key so we simply check whether head is equal to null or not so here you can see head
2201:56 - is not equal to null so this condition comes out to be true we provide a if condition that
2202:02 - if head dot key equals key which means that we have found our key so currently head dot key is
2202:08 - 31 we compare it with 21 so this if condition comes out to be false because 31 is not equal to 21
2202:19 - so we simply move head to its next node by assigning head dot next value to head
2202:25 - so head is pointing to this node its next is pointing to this node
2202:29 - so via this reference we will simply traverse head to its next node
2202:36 - we again check whether head is equal to null or not so head is not equal to null
2202:41 - we check head dot key which is 21 whether it is equal to the key which we are searching
2202:48 - so yes head dot key which is 21 is equal to 21 which we are searching so this condition
2202:54 - comes out to be true and we will simply return the value corresponding to this key which is tom
2203:09 - now friend let's say if we want to search for a key which is not present in this
2203:13 - hash table so we call get method we pass in the key as 88 so key is 88
2203:22 - we calculate the bucket index we divide 88 by 10 and we get the remainder is 8 so the bucket index
2203:30 - will be 8 so we access the hash node via the bucket index which is this node which would
2203:40 - be our head now so head is pointing to null and then we are providing this while loop
2203:46 - because there could be a possibility that it contains the chain of nodes so here you can see
2203:52 - the condition here is head should be not equal to null but here head is equal to null it means
2203:58 - that key which we are searching is not present in this hash table so at the end we are simply
2204:03 - returning the null value which signifies that 88 is not present in this hash table
2204:13 - so friends i hope you find this information useful and in case if you find this information
2204:18 - useful then please like this video and if you are new to my channel then please subscribe to my
2204:23 - channel and click the bell icon so that you never miss any update thanks have a nice day
2204:29 - hello everyone so in our previous video we saw an animation that how we can
2204:38 - get a value via its key from a hash table so in this video we will actually code the algorithm
2204:45 - and we'll test its working in the main method so before we start if you are new to my channel
2204:50 - then please subscribe to my channel and click the bell icon so that you never miss any update
2204:55 - so here in our previous videos we saw a initial implementation of hash table
2205:04 - and we saw that how we can put a key value pair in hash table
2205:10 - which internally uses the hash function which is nothing but create bucket index
2205:16 - and here the hash function which we are using is modular hash function which is using this
2205:21 - modular operator now in this video we will see that how we can get a value by providing its key
2205:30 - so when we saw the implementation of put we provided this h case that key or value if they
2205:37 - are null then we simply throw a legal argument exception saying key or value is null and as we
2205:43 - are not putting any null key or null value when we will do get we simply provide this check again
2205:53 - and here we'll simply check if the key is null then we throw a legal argument exception saying
2206:01 - key is null so this is the simple h case which we are providing
2206:05 - and now how we can get a value associated with this key which we are passing to this method
2206:14 - because in hash table internally it is using buckets array of type hash node so how we can
2206:21 - find our key and return its corresponding value we basically use the hash function which takes
2206:30 - a key and return us back an index and corresponding to that index we try to search our key
2206:37 - so here you can see we first evaluate the bucket index where this key might lie
2206:47 - because there could be a possibility that this key is not present in our hash table
2206:52 - so what we do here is whatever the key we are passing
2206:55 - we call get bucket index method we pass the key to it so this is our hash function
2207:06 - so it will return us back the index where this key might lie so after getting the bucket index
2207:12 - what we do is we try to access the first node of the list which corresponds to this index
2207:22 - so here we simply access buckets we pass the bucket index it will return us back the hash node
2207:34 - which would be the starting node of the list of hash node so we are assigning it to head
2207:40 - now after getting the head our task is to find the key so for that we are providing this while loop
2207:48 - and here we are providing the condition as head should not be equal to null so friends here you
2207:54 - can see this is exactly what we did in put and also we provided while loop where we were simply
2208:03 - searching for that key and if key was found we were simply updating its value so here i will
2208:10 - simply copy this and we'll paste it here so the only change we do here is if we find our key
2208:21 - then what we do is we simply return head dot value because we wanted the value associated
2208:29 - with this key so we searched for the key and we checked that whether any key is matching
2208:36 - to our key or not so in the if block we provided the condition if head dot key is equal to our key
2208:43 - then simply return its value and if it is not then simply move head to its next node by assigning
2208:50 - head dot next to head so friends here when we are accessing the hash node at this bucket index
2208:58 - there could be a possibility that this hash node will point to other hash node and there can also
2209:04 - be possibility those hash nodes point to other hash nodes so we are accessing the head we are
2209:10 - comparing the key if key is matching then we are returning the value and if key is not matching
2209:15 - we are simply going to its next node and doing the same steps again so friends if the key is present
2209:22 - its corresponding value is returned and if it is not then we are simply returning null here
2209:27 - now let's test it's working in the main method here in our previous video we added few keys
2209:33 - along with its values so if i run the code now you will see there would be three keys
2209:43 - so it printed the size of the hash table as three
2209:47 - because the key values pairs are three 105 21 and 31 here this 21 was already present
2209:56 - so when we call put the Sana was replaced with Harry so it simply updated the value
2210:02 - it never inserted a new key value now here what we do is let's say if we do table
2210:11 - dot get and say return me the value associated with key 31 and we print it
2210:18 - so if i run the code now it should print Dinesh so which is corresponding to key 31
2210:30 - so now if we do table dot get and pass the key as 21 if i run the code it should print Harry
2210:40 - because Harry is the upgraded value for key 21 and last let's say if we print a key which
2210:51 - is not present let's say 90 if i run the code now so it should print null so it is returning null
2211:04 - so friends in this video we saw that how we can get a value associated with its corresponding
2211:10 - key i hope you find this information useful and in case if you find this information useful
2211:16 - then please like this video if you are new to my channel then please subscribe my channel
2211:21 - and click the bell icon so that you never miss any update thanks have a nice day
2211:30 - hello everyone so in our previous video we saw
2211:34 - that how we can get a value from a hash table via its key now in this video we will see that how
2211:41 - we can remove a key from a hash table so basically we will see the demonstration of remove method
2211:47 - which takes in a key and it removes that key from the hash table and also returns
2211:52 - its corresponding value back to us so before we start in case if you are new to my channel
2212:01 - then please subscribe to my channel and click the bell icon so that you never miss any update
2212:08 - so let's suppose if we are given with this hash table having three hash nodes where size is equal
2212:14 - to three now let's suppose if we want to remove a particular key so what we do is we are given
2212:20 - with a key we first try to find the index associated with that key via our hash function
2212:26 - then we go to that index and we try to search for that particular key in case if we find that key
2212:33 - then we simply remove that node from the corresponding list of that index and if we
2212:39 - don't find the key we simply return null so here you can see that there are various cases
2212:45 - which needs to be handled while removing a key the first case is what if the key is not present
2212:51 - so we simply return null the second case is let's suppose the key is in the middle somewhere
2212:58 - so when we find that key we can't directly delete this node because if we delete this
2213:04 - node directly then there are other nodes associated with this node which will also get deleted
2213:10 - so what we do is let's suppose if we want to delete this key then whenever node will
2213:15 - reach to this point we compare the key and we find that we need to delete this node
2213:21 - we have to break this link so in order to break this link we need to somehow access this node
2213:28 - and this is accessed via a temporary node which is previous to our current node which we want to
2213:34 - delete so here after we find the key which you want to remove the previous node will help us
2213:41 - in removing this node so what we do is as previous is pointing to this node we have to break this
2213:47 - link and make a link from this node to current's next because we don't want to remove the nodes
2213:54 - after that so we simply assign current's next to previous next so this link will go away and this
2214:02 - link will point to current's next which would be the leftover nodes after we remove this node
2214:10 - so friend this is also one case where the key which we want to remove is in the middle of this list
2214:16 - so for that we simply keep the track of its previous node which we will see later
2214:21 - so let's suppose if we want to remove a key having value as 105 so at the first step we pass this key
2214:30 - to our hash function which takes the key divided by buckets dot length which is the number of
2214:36 - buckets and return us back the remainder of it because here we have this modulus operator
2214:42 - so whatever the remainder is returned that is nothing but our index where we can find that
2214:48 - particular key so if we divide 105 by 10 we get remainder as 5 so the bucket index becomes 5
2214:57 - we simply access the hash node at bucket index 5
2215:03 - so this will be our head so as head is pointing to the first node at the start
2215:10 - we assign a null value to our previous node so this previous will simply track the previous node
2215:17 - to our head we will see why it is needed later in this video so currently previous is pointing to
2215:24 - null now using the head we will simply search for our key which we already discussed in our
2215:30 - previous videos so we do head dot key which is 105 we compare it with our key so here head dot
2215:38 - key is equal to the key which we want to remove it means we have to remove this hash node so what
2215:44 - we do is as previous is pointing to null it means we want to remove the first node of the list
2215:51 - so currently head next is pointing to null so there could be a possibility that there are
2215:56 - n number of nodes after that so it means that we want to remove the first node from the list
2216:03 - so what we do is in order to remove this node we have to first break this link so that there is no
2216:09 - reference to this node and it can be freed up but we can't directly break this link because there
2216:15 - could be nodes after that so these nodes which can be after the head will also be removed so what we
2216:22 - do is so first we decrease the size so size becomes 2 and now what we do is if we do head dot next
2216:32 - we will get the remaining hash nodes in the form of chain and as head dot next is pointing
2216:39 - to the nodes after that if we assign head dot next value to buckets at this index so this
2216:46 - node can be freed up and this reference will point to whatever the head dot next is pointing
2216:52 - so currently it is pointing to null so what we do is if previous is null which means that we
2216:57 - want to remove the first node of the list so here we will assign head dot next value to bucket
2217:04 - index 5 so it would look something like this head dot next is null so this link will be removed
2217:12 - and it will point to null and now we can simply remove this node and we can return head dot value
2217:19 - which is john so it would look something like this now let's say if you want to remove key as 21
2217:34 - so 21 divided by 10 will give remainder as 1 it means the 21 key can be present at index 1
2217:43 - so we access the hash node of index 1 so this would be our head at start we assign null value
2217:51 - to previous now here first we search for our key so we do head dot key which is 31 we compare it
2217:59 - with our key which is 21 so here you can see 31 is not equal to 21 so what we do is before moving
2218:06 - head to its next node in order to search for the key we first assign the value of head to previous
2218:14 - because we need to keep the track of the previous node so that in case if we find a key then we can
2218:20 - use its previous and break the link so that the key which we have searched can be removed easily
2218:26 - so here as head is pointing to this node now previous will point to this node and we will
2218:33 - simply traverse head to its next node via this link now we again compare head dot key which is 21
2218:42 - with our key so here you can see that we have found our key so our task is to now remove this
2218:48 - node but there could be a possibility that after this node there are many other nodes so what we
2218:55 - do is as you want to remove this node first we decrease the size so size will become 1
2219:01 - and we simply check whether previous is pointing to null or not so here you can see previous is not
2219:08 - pointing to null it means that our key is lying somewhere in the between of this list because if
2219:14 - previous would have point to null then we would have sure that head is pointing to the first node
2219:19 - of the list but as previous is pointing to this node so what we do is we simply assign head next
2219:28 - value to previous next so why we do that because we need to first break this link so when this link
2219:35 - will be broken then this node will have no reference so this can be garbage collected
2219:40 - but there is one problem head dot next will refer to other nodes as well so those nodes will also
2219:46 - be removed if we break this link directly so what we do is head dot next will point to the nodes
2219:54 - after that so we simply assign head dot next value to previous next so instead of previous
2220:02 - next pointing to head it will now point to heads next so this node can be freed up so it would
2220:09 - look something like this this link will go away and as head dot next is pointing to null so it
2220:16 - will point to null so now this hash node can be removed easily we will return the value tom
2220:25 - and then we will simply remove it
2220:29 - now friend let's say we are given with these two nodes and we want to remove 31 so what we do is
2220:37 - we do 31 divided by 10 which gives the remainder 1 so bucket index is 1 we simply access the hash
2220:44 - node at index 1 we give it a value as head because this is the first node of the list
2220:51 - we will assign previous a value of null and then we compare 31 which is head dot key with our key
2220:59 - so that we can search for that particular key which we want to remove so here you can see head
2221:04 - dot key is equal to the key which you want to remove it means we want to remove this key
2221:09 - so first we simply decrease the size so it will become 1 because we are removing this key now
2221:15 - and after that we need to break this link so that this node can be freed up but if we remove
2221:22 - this link directly then all the nodes in this list will be removed we only want to remove this node
2221:29 - and keep all the nodes after that intact so what we do is how can we access all the nodes after
2221:36 - that is we simply do head dot next and if we do head dot next we reach to this node so here
2221:44 - we break this link and we assign a value of head dot next to it so now this link will go away and
2221:51 - it will point to this node and the nodes after that so here we are simply assigning head dot
2221:58 - next value to buckets array at index 1 so it would look something like this this link will go away
2222:05 - and it will point to this node and once the method will end this node can be safely removed
2222:12 - and we can simply pass the value associated with this key
2222:20 - so after it gets removed it would look something like this
2222:25 - so here there could have been multiple nodes after that so we have kept that list intact
2222:30 - and we have removed the node from the middle so this is also one of the use case now let's
2222:37 - suppose if we are given with this hash table with two nodes and we want to remove a key which is not
2222:43 - there in this hash table so key is 88 if we divide 88 by 10 we get bucket index is 8
2222:52 - we access the hash node at index 8 so here it is pointing to null which means
2222:58 - that key is not present in this hash table so we simply return null
2223:02 - so from these are the cases which are involved when we actually remove a key from our hash table
2223:12 - i hope you find this information useful and in case if you find this information useful
2223:17 - then please like this video and if you are new to my channel then please subscribe to my channel
2223:23 - and click the bell icon so that you never miss any update thanks have a nice day
2223:32 - hello everyone so in our previous video we saw that how we can remove a key
2223:36 - from hash table via an animation so in this video we'll see the algorithm
2223:42 - via an animation and we'll see that how it works step by step
2223:47 - so before we start in case if you are new to my channel then please subscribe to my channel
2223:52 - and click the bell icon so that you never miss any update
2223:58 - so here you can see that this is the algorithm to remove a key from the hash table so let's see the
2224:04 - demonstration of it step by step we will take the same use cases which we discussed in our previous
2224:09 - video so when we will call table.remove and pass the key as 105 the remove method will be called
2224:18 - with the key 105 now the first step what we do is we search for that key and how we can search
2224:27 - for that keys first we get the bucket corresponding to this key so we call our hash function
2224:34 - get bucket index we pass in the key and it returns us back an index by dividing key by bucket.length
2224:43 - or number of buckets and return us back the remainder because it has this modulus operator
2224:49 - so here if we divide 105 by 10 we get remainder as 5 so this method will return us the bucket index
2224:57 - as 5 now what we do is we have got the bucket index and we know that key 105 will lie
2225:08 - at this bucket index so we simply access the hash node at this index
2225:15 - which is 5 here so the first hash node is nothing but our head and there could be n number of
2225:22 - hash nodes so head will point to the first hash node
2225:28 - now in order to keep the track of the previous hash node we simply assign it with the null
2225:33 - and why we keep the track of the previous hash node we will see later so we are providing
2225:41 - this while loop which is pretty much same what we saw in our previous videos that we are trying
2225:47 - to search the key first so currently head is not pointing to null so this condition comes out to
2225:52 - be true we check whether head.key which is 105 is it equal to the key which we want to remove
2226:02 - so here you can see this if condition comes out to be true
2226:07 - so what we do is as soon as we find the key which we want to remove we simply break from
2226:13 - this while loop because we have found our key and now it's time to remove that key
2226:19 - so when we break from this while loop it will come here and here we encounter one use case
2226:26 - that head could point to null so which we will see later so currently head is pointing to a hash
2226:32 - node which is not null so this condition comes out to be false so now here you can see as we
2226:40 - want to remove this node we will first decrease the size by one so size will become two
2226:48 - and after that we encounter a if else block which is very much important because here if
2226:54 - previous is not equal to null so this is the if condition if previous is equal to null it means
2227:00 - we are trying to remove the first node of the list let's say if we take this example and if
2227:06 - head is pointing to this so previous will point to null so it means we are trying to remove the
2227:12 - first node of this list and if previous is not equal to null it means the key which we have found
2227:18 - is somewhere in the between of this list so that use case we'll see later so currently you
2227:25 - can see previous is pointing to null so our if condition comes out to be false and the else part
2227:32 - will be executed and here we want to remove this node from the list so what we do is and we know
2227:40 - that this is the first node which is being referred by bucket's array at bucket index
2227:45 - so in order to free this node we need to remove this link we will assign head dot next value
2227:51 - to bucket's array at bucket index so the hash node referred by bucket index which is this
2227:58 - instead of pointing to this node it will simply point to head dot next because we want to remove
2228:04 - this node and this node can also have other nodes so we can't directly break this link
2228:10 - we simply assign head dot next value to this index so currently for this use case you can see
2228:16 - head dot next is pointing to null so here we simply break this link and we assign head dot
2228:22 - next which is null so it will point to null and here you can see after this method gets end
2228:29 - first we return the value associated with it which is john and once this method will end
2228:36 - this node will be garbage collected
2228:43 - so it would look something like this now let's suppose if we want to remove a key 21
2228:53 - so first we'll find its corresponding bucket so 21 divided by 10 will give remainder as 1
2229:00 - so the bucket index is 1 so we simply access the hash node at bucket index 1 which is
2229:09 - this node and there could be a list so we assign head to this node because this is the first node
2229:16 - of the list we create a hash node previous and at the start we assign a null value to it
2229:23 - and now as we want to remove the key 21 so we search in this list using this while loop
2229:32 - so currently head is not equal to null if head dot key equals the key which we want to remove
2229:40 - then this if condition will come out to be true so here head dot key is 31 it's not equal to 21
2229:48 - so the condition in if block comes out to be false so this is the key we are comparing it with 21
2229:57 - and as this condition is false we will reach here so usually we search for the key in complete list
2230:04 - so for this node the key didn't match so before going to its next node by assigning head dot next
2230:11 - to head what we do is we simply keep the track of this node because let's say if we find this key
2230:17 - here then we can use the previous node and we can simply remove this link here so that this node
2230:23 - can be freed up so before moving head to its next node we assign the value of head to previous
2230:29 - so it would look something like this and now we simply move head to its next position by assigning
2230:37 - head dot next to head so head dot next is pointing to this node so via this link head will now point
2230:44 - to this node head is not equal to null if head dot key equals the key which we want to remove
2230:55 - so head dot key is 21 and 21 is equal to 21 so this condition comes out to be true and here we
2231:04 - know that we have found our key which we want to remove so we simply break from this while loop
2231:11 - we first simply check whether head is equal to null or not if head is equal to null then
2231:17 - we simply return null so currently head is not equal to null it means we need to remove this key
2231:25 - so we first decrease the size by one size becomes one and now here you can see previous is not equal
2231:35 - to null previous is pointing to this node therefore this condition comes out to be true
2231:41 - so why we provide this check is if previous is equal to null it means we are trying to remove
2231:46 - the first node of the list and if previous is not equal to null it means the key which we have found
2231:53 - is somewhere in the middle of the list because previous is providing that information to us
2231:58 - so in the if part what we do is we need to remove this link and we can't directly remove this link
2232:05 - because head dot next may point to the other nodes so what we do is we simply assign head
2232:12 - dot next value to previous next so it would look something like this that now previous dot next
2232:20 - is pointing to null and why we did that because let's suppose if there are n number of nodes after
2232:26 - that and we want to only remove this key we don't want to touch other nodes so to whatever value
2232:32 - head dot next is pointing previous dot next should point to that node but here it is null so
2232:37 - previous dot next is pointing to null we will return the value tom
2232:46 - and this node will be removed from the hash table
2232:48 - now friend let's suppose if we want to remove a key as 31
2233:00 - so we calculate the bucket index 31 divided by 10 will give remainder as 1
2233:06 - so 1 will get returned from our hash function so bucket index becomes 1
2233:12 - we access the hash node at this bucket index
2233:15 - and to whichever node it is referring that will assign to head so head will point to this node
2233:24 - at the start we do previous equals null
2233:28 - and then we search for our key so we check whether head is equal to null or not
2233:34 - so head is not equal to null so the while loop will start
2233:38 - then we provide a condition to search for that key so if head dot key equals the key which we want to remove
2233:47 - head dot key is 31 and the key which we want to remove is also 31 so this condition comes out to be true
2233:54 - it means we have found our key
2233:59 - we break and then we check whether head is equal to null or not
2234:05 - so head is not equal to null it is pointing to a key which we want to remove
2234:10 - and before removing the key we decrease the size by 1
2234:14 - so size becomes 1
2234:18 - and now here you can see previous is pointing to null so the else part will be executed
2234:25 - and in the else part you can see that why we are doing head dot next
2234:28 - in use case one head dot next was pointing to null but
2234:32 - here you can see there is possibility that head dot next is pointing to other nodes
2234:37 - so we can't directly break this link so to buckets array at bucket index we assign the value
2234:44 - head dot next so now this link will be removed and as we are assigning head dot next to it
2234:51 - this will point to this node because head dot next is this node so it would look something like this
2234:59 - that we are assigning head dot next value which is this node to buckets array at bucket index
2235:07 - so now here you can see this node can be freed up easily by returning the value sana
2235:19 - and if we rearrange it it would look something like this
2235:22 - so here we removed a node and we saw the importance of doing head dot next
2235:29 - because we can't directly break the link this link we need to assign it head dot next
2235:35 - so that it should refer to the remaining nodes of the key which we want to remove
2235:43 - so friends one last use case is this use case
2235:47 - where you want to remove a key which is not there in this hash table
2235:52 - so we will calculate bucket index 88 divided by 10 will give remainder as 8
2236:01 - so bucket index is 8 we access the hash node at this index so here it is pointing to null
2236:10 - which means head will point to null we create previous and we assign a null value to it
2236:17 - here head is pointing to null so it means this condition comes out to be false
2236:26 - and here as head is equal to null it means that size remains the same and key is not present so
2236:33 - we simply return null so in this video we saw that how we can remove a key from a hash table
2236:44 - and we saw the demonstration of the algorithm step by step
2236:48 - i hope you have find this information useful and in case if you find this information useful then
2236:52 - please like this video if you're new to my channel then please subscribe to my channel
2236:58 - and click the bell icon so that you never miss any update thanks have a nice day
2237:02 - hello everyone so in our previous video we saw that how we can remove a key from a hash table
2237:14 - and we saw the working of the code through an animation now in this video we'll actually
2237:20 - code the remove method which takes in a key and return us back the value associated with the key
2237:26 - which we are trying to remove so here in our previous videos we saw how we can put key value
2237:35 - pair how we can get a value corresponding to a key so now we'll see that how we can remove
2237:46 - the key so friend at the start i'll simply copy this part
2237:58 - so here if you're passing key as null then we are simply throwing an exception
2238:02 - saying key is null so this is the illegal argument exception which states that key is null
2238:08 - so this is the simple h case and now in order to remove a key what we do is we pass this key
2238:18 - to our hash function and this hash function will return us a index where we can
2238:27 - search for this key and once we find that key we simply remove it so it will return us back
2238:34 - the bucket index after getting the bucket index we access the hash node at that bucket index
2238:49 - and as that index is pointing to a hash node which is the starting point of the
2238:54 - list corresponding to this bucket index we give a name to it as head
2239:04 - so friends here you can see that these two steps are being used in get method also
2239:11 - and in put method also now what we do is in order to remove a key let's add this index
2239:19 - if i simply copy this part
2239:27 - and here at this index let's say we have this list of hash nodes something like key as 21
2239:44 - value as term
2239:50 - now let's say it has three nodes
2239:56 - something like this
2240:04 - where key 31 is value harry and key 41 is value let's say sana now head is pointing to this node
2240:14 - because this is the first hash node of the list now our task is to remove this key
2240:21 - so let's say if we want to remove the key as 31 and head is pointing to this so first we will
2240:28 - search our key by traversing head to each and every node and if you find the key let's say if
2240:35 - we find the key 31 so somehow we need to access this hash node because this link needs to be
2240:43 - removed in order to free this node and if you free this node directly then all the nodes after
2240:49 - this node will also be removed so what we need to do is as head has traversed to this node
2240:56 - so first we simply keep the track of its previous nodes so wherever head will go we will keep
2241:03 - a reference to its previous node which is very important while removing a key from the hash table
2241:10 - so if head is here and key matches so previous will be here so to previous next we have to break
2241:17 - this link so to previous next we need to assign head next because we need to keep these nodes intact
2241:25 - we will assign head.next value to previous next head.next is this node and the nodes after that
2241:33 - it will be assigned to previous next so this link will go away from this node to this node
2241:42 - and then we can simply remove this hash node so for that what we do is at the start
2241:50 - we create a previous hash node we assign it a value as null because as head is pointing
2241:57 - to this node at start we are doing previous as null
2242:05 - so now what we do is we search for the key
2242:09 - so for that we provide the while loop and here we will use the same while loop
2242:17 - which we did in the get so here we are providing the condition as head should not be equal to null
2242:24 - and if head is equal to null it means we have traversed this complete list and we didn't find
2242:30 - our key and if head is not equal to null what we do is we compare head.key with the key which we
2242:38 - want to remove and after we find our key what we do is we simply break from this while loop
2242:45 - because after this while loop head will point to the key which we want to remove let's say here
2242:51 - 31 so head will point to this key because this condition matches so let's say if we take this
2242:58 - example and if we want to remove a key as 31 so in this while loop head will first check it with 21
2243:05 - this condition comes out to be false then we go to its next node head will come here
2243:11 - it is not equal to null then we'll compare head.key which is 31 with the key which we have passed to
2243:18 - this method so as soon as we find our key head is pointing to this node and here what we do is
2243:26 - before moving the head to its next position what we do is how can we keep the track of
2243:33 - this previous node is we first assign head to previous so previous and head will point to this
2243:41 - node and then we simply traverse head to its next node so previous is a step behind the head
2243:48 - and why we are keeping previous just behind the head is because let's say we have searched for
2243:54 - the key which we want to remove so we break from this while loop and as soon as we break from this
2244:00 - while loop previous is here and head is here so after this while loop what we do is we first check
2244:11 - that if head is equal to null or not so if head is equal to null it means we didn't find any key
2244:21 - in this list because this while loop would have terminated when head would have pointed to null
2244:28 - which is the last node next so if head would have reached here it means we haven't found our key
2244:35 - so we are simply returning the null value and if head is not equal to null then the first thing
2244:44 - we do is we decrement the size by one because now we are about to remove the key so here now two
2244:54 - condition arises one is at the start previous is pointing to null and head is pointing to let's
2245:03 - say 21 and what if if you want to remove 21 only so in that case we are simply removing the first
2245:10 - node of this list and how we can come to know that is the first node only is why are the previous
2245:18 - because if previous is null and after this if block we can come to know that head is not equal
2245:24 - to null so it means head must be pointing to this node only and which means we have to remove this
2245:30 - key so here we provide the if condition and we check that previous is equal to null or not
2245:40 - so if previous is equal to null and if our code has reached here it means head is also not equal
2245:46 - to null which signifies this head is pointing to the first node so in the else part what we do is
2245:55 - we have to remove the first node and it is being referred by this the hash node at bucket index
2246:02 - is the first node so here what we do is we simply reassign this value to something like
2246:11 - we do head dot next so it means that our buckets array at this bucket index was pointing to a
2246:19 - hash node to which our head was also pointing and now we need to remove this node so head is
2246:28 - pointing to this node if we assign head dot next to this then this node will be removed easily
2246:35 - and now our buckets array at bucket index will point to this node because 21 would be removed
2246:42 - so this is the small change which we do if previous is pointing to null
2246:48 - and if previous is not pointing to null now let's say if we want to remove 31
2246:53 - so head will point to this and previous will point to this so now instead of doing this stuff
2247:00 - what we do is we do previous dot next and we assign head dot next to it
2247:09 - so here you can see head dot next remains the same as previous is not equal to null it means
2247:17 - we can't use this stuff because this is only used in case if we want to remove the first node of
2247:24 - the list but if we want to remove let's say a node in the middle then previous will help us
2247:30 - in removing that so head was pointing to this and we want to remove this and previous was pointing
2247:36 - to this so to previous next we assigned head next this value so now this hash node next will point to
2247:48 - this hash node and this hash node can be removed easily so this step does that so after this
2247:56 - reassignment head is still pointing to this so at the end what we do is we simply return
2248:02 - head dot value and once this method will get terminated this head is our local variable so
2248:10 - it will be garbage collected so friends what we did in the remove method we took the key
2248:17 - we evaluated the bucket index where this key might lie the starting hash node we denoted
2248:24 - with head we created previous and at the start we provided a null value to it and now in the while
2248:31 - loop we tried to compare each and every key with the key which we want to remove because if we
2248:38 - don't compare then we'll not able to get which node we want to delete so as soon as we found
2248:46 - the key which we want to delete we break from this while loop and we perform the assignments here
2248:53 - but let's suppose if the key is not found for the first iteration then what we do is
2248:59 - we have to move head to its next node but if we move head to its next node
2249:04 - we can't delete this node we need to keep the track of its previous node as well
2249:10 - so before moving head to its next node we are assigning the value of head to previous
2249:16 - and then we are moving head to its next node so that when we will find any key in the middle
2249:22 - we have reference to a node before that so that we can reassign its next pointer
2249:29 - here you can see we are reassigning it so if the key which we want to remove is at first node
2249:37 - then we simply assign head.next value to bucket array at this bucket index
2249:43 - and if it is somewhere in the middle or end then we have this previous reference we simply assign
2249:49 - head.next to previous next and finally we return head.value and once we return head.value this
2249:55 - method gets terminated and the node gets freed up so now let's test it's working in the main method
2250:03 - so here you can see let's suppose we have this three keys 105 21 31
2250:10 - and if i run the code now you will see size will come as three because there are three hash nodes
2250:21 - or key value pair now what we do is let's say we remove 21
2250:33 - and we print its value on the console
2250:41 - so here you can see it printed harry because harry was associated with key 21
2250:49 - now let's say if we want to remove 31 so now if i run the code
2251:00 - you can see it printed dinesh
2251:05 - and if i print the size of it
2251:07 - so here we have removed two nodes so it should print one so it has printed one
2251:18 - so here you can see only 105 remains in the hash table because we have removed 21 and 31
2251:24 - so here if i simply copy this part
2251:27 - so here before removing these two values we add hash table something like this
2251:40 - this is 3
2251:49 - dinesh 21 harry and let's say if i remove this for time being so this was our hash table at index 1
2252:01 - because we are removing 21 and 31 so if we evaluate the bucket index 21 divided by 10 will
2252:09 - give remainder as 1 so this is for the index 1 we first added 21 using put and then we added 31
2252:18 - so 31 came before 21 because we are inserting the hash node at the beginning of the list
2252:25 - so this was the situation so when we removed 21 had started with this node then it reached here
2252:34 - and previous reached here so 21 matched with our key and at the end what we did
2252:44 - previous next was assigned width heads next which is null and then we removed 31
2252:52 - so this node was removed and when we printed the size it printed one
2252:57 - only this key value pair exists and we removed these two key value pairs
2253:04 - so friends i hope you find this information useful and in case if you find this information
2253:09 - useful then please like this video if you're new to my channel then please subscribe to my channel
2253:16 - and click the bell icon so that you never miss any update thanks have a nice day
2253:24 - hello everyone so in this video we are going to discuss a problem contains duplicate
2253:30 - update so friends before we start in case if you're new to my channel then please subscribe
2253:37 - to my channel and click the bell icon so that you never miss any update so here in this problem we
2253:44 - are given an integer array and our task is to return true if any value appears at least twice
2253:50 - or return false if every element is distinct so let's understand the problem with an example
2253:57 - now let's suppose we are given with this integer array having elements as one two three one now our
2254:04 - task is to return true if any value appears at least twice so here you can see that one appears
2254:11 - at two places therefore we return true and return false if every element is distinct
2254:18 - so here you can see in the second example the array is one two three four so all the elements
2254:23 - are distinct therefore we have to return false so here our task is to check whether the array
2254:29 - contains duplicates or not now let's move ahead and see how we can solve this problem via various
2254:35 - techniques so let's suppose we are given with this array seven three one four one and we know
2254:43 - that one appears at least twice therefore we know that it contains duplicates so the first way to
2254:51 - solve this problem is a very brute force approach where we take each element and compare it with the
2254:57 - rest of the elements in the array and we figure out whether the element is duplicate or not
2255:04 - so when we try to solve this problem we take a pointer i and let's say the value is seven
2255:11 - we take another pointer j and we compare the values at i and jth index
2255:17 - so at the start seven is compared with three they are not equal so j moves to the second index
2255:28 - seven is not equal to one so j moves to third index
2255:34 - seven is not equal to four so j moves to the fourth index seven is not equal to one
2255:41 - so therefore we figure out that seven is unique among these elements so after that i moves to
2255:49 - three and j points to index after i because seven is already being compared with three
2255:58 - in the previous iteration so three is compared with one they are not equal
2256:04 - so j moves to third index three is compared with four they are not equal
2256:09 - so j moves to the fourth index three is not equal to one so therefore we come to know that
2256:17 - three is also unique in this array so we increment i
2256:23 - now i comes to the second index so j starts from the third index
2256:28 - one is compared with four so they are not equal so j moves to the fourth index
2256:34 - now here one is equal to one so therefore we come to know that there are duplicates in this array
2256:41 - and one is appearing at least twice so therefore we return directly true from the method
2256:49 - so if we see via this approach we need two for loops one for i
2256:55 - and one for j so using these two for loops we can figure out whether the
2257:07 - array contains duplicates or not so the time complexity of this method is o of n square
2257:15 - because this approach contains nested loops so this is not very efficient solution
2257:20 - now can we reduce the time complexity from o of n square to less than that
2257:27 - so one thing we can do is we can actually sort this array so when we sort this array in ascending
2257:33 - order the elements will rearrange something like this one one three four and seven and now after
2257:43 - sorting we can use one for loop to check whether the neighboring elements are equal or not
2257:50 - so if they are equal we just return true and after the loop ends if we didn't find any
2257:56 - duplicates then we can return false so via this approach when we are sorting the array
2258:02 - the time complexity comes out to be n log n so this is a better approach and time complexity
2258:10 - now is there any other way where we can reduce this time complexity so we'll look into that
2258:16 - so in order to reduce the time complexity what we can do is we can use an additional data structure
2258:24 - so let's say if we are using a hash set the property of hash set is it only contains unique
2258:30 - elements now what we can do is we can iterate over this array we can take one one element
2258:37 - and we check whether the hash set contains that element or not if it doesn't contain then we
2258:42 - simply add it to the hash set and if hash set contains that value then we are sure that it
2258:47 - contains duplicates so for example the first value is seven we check whether hash set contains seven
2258:54 - or not so it doesn't contain so we put seven into the hash set then we check for three whether the
2259:01 - hash set contains three or not so it doesn't contain so we put three into the hash set then
2259:06 - we take one so one is not in the asset so we put one into the hash set then we take four
2259:13 - four is not in the hash set so we put four into the hash set at last we get one so when we check
2259:20 - whether one is there in the hash set or not we come to another one is already there so therefore
2259:25 - we directly return true that we have found a duplicate now let's say instead of one there
2259:34 - would have been six so we would have checked whether six is there in the hash set or not
2259:39 - so it was not there so we put six into the hash set and after that there are no elements
2259:45 - in this array to be traversed so at the end we would directly return false
2259:52 - that there are no duplicate elements in this array now by doing this the time complexities
2259:57 - we are iterating this array once so time complexity becomes o of n but space complexity
2260:03 - increases because we are using an additional data structure so the space complexity is o of n
2260:10 - but this is a much better approach because the time complexity is reduced
2260:14 - now let's move ahead and see the animation of this algorithm step by step
2260:27 - so this is the code where the method name is contains duplicate we pass in the array
2260:34 - so at first when we call contains duplicate method we pass in the array
2260:41 - now let's say if we are given with this array having values as 1 3 5 4 1
2260:46 - so at the first step what we do is we create a hash set
2260:52 - so this is our set
2260:56 - now as we discussed we just iterate each and every value once
2261:01 - so we provide a for loop where i starts from zero index
2261:06 - like this and i goes till nums dot length so here the array contains five elements
2261:15 - one two three four five so nums dot length is five so it goes from zero index to fourth index
2261:23 - so currently zero is less than five so this for loop executes
2261:27 - now hash set has a method contains when we call this method it actually returns true or false
2261:36 - if the element is present in the hash set returns true and if the element is not present it returns
2261:42 - false so nums of i is nothing but the value at zero index so we check whether set contains one
2261:50 - or not so here you can see set doesn't contain one so set dot contains will return false because
2261:56 - this element is not present so we add this element into the set so one is added into the set
2262:05 - now we increment i so i becomes one
2262:11 - one is less than five
2262:14 - we check whether value three is present in the set or not so set dot contains return false
2262:20 - because three is not present so we simply add three into the set
2262:28 - we increment i so i becomes two and two is less than five so this for loop will execute
2262:38 - now nums of i is nothing but value present at second index which is five
2262:43 - so we check whether set contains five or not so set doesn't have five so it returns false
2262:51 - so we simply add five into the set like this
2262:57 - we increment i i becomes three three is less than five so this for loop will execute
2263:07 - we check whether value at third index which is four present in the set or not
2263:12 - so this actually returns false because four is not present into this set
2263:20 - so we simply add four into the set
2263:25 - we increment i i becomes four four is less than five so this for loop executes
2263:34 - now here value at ith index is one and when we check whether one is present in the set or not
2263:42 - so one is already present in the set so set dot contains return true so it means we have found a
2263:48 - duplicate in this array because one we inserted into the set at the beginning and again we found
2263:55 - a one so set dot contains return true because one is already present in the set so it means that
2264:02 - our array contains a duplicate so this if block is executed so here we directly return true
2264:10 - we state that our array contains the duplicate now let's say if our array doesn't contains
2264:15 - the duplicates so instead of one we put a six
2264:24 - so after placing one three five four into the set the last element would have been six
2264:33 - and if we do set dot contains six so it returns false and if block doesn't get executed
2264:41 - so we simply add six into the set
2264:46 - now when we increment i i becomes five
2264:51 - and five is not less than five so therefore this for loop will terminate
2264:58 - so at the end we directly return false stating that our array doesn't contains
2265:02 - duplicate it contains unique elements
2265:08 - so friends in this video we discussed the problem of contains duplicate
2265:12 - i hope you must have liked this video thanks have a nice day
2265:21 - hello everyone so in this video we are going to discuss about a very important topic which is
2265:27 - intervals so in this video we are going to see a basic introduction to intervals and we will also
2265:33 - see what are overlapping intervals now this is a very important topic for the coding interview
2265:38 - there are questions asked on the concept of overlapping intervals
2265:42 - so let's move ahead and see what are intervals and what are overlapping intervals
2265:47 - so friends before we start in case if you are new to my channel then please subscribe to my channel
2265:52 - and click the bell icon so that you never miss any update
2265:55 - so first we will see a basic introduction to an interval so usually an interval is actually a
2266:02 - range which is represented by two numbers something like five comma eight six comma ten
2266:09 - so an interval is a range where two numbers are involved
2266:14 - now that two numbers are termed as start and end so here five will be our start and eight will be
2266:21 - our end so these two numbers are basically start and end of the interval which actually represent
2266:28 - a range now usually when we talk about interval they are correlated with time now when it is
2266:35 - related with time this start and end can be any unit of time it can be milliseconds seconds minutes
2266:42 - so here let's see the time interval of few tasks let's say task a has a time interval of one comma
2266:47 - three b is time interval of four comma five c is time interval of eight comma ten d is time
2266:53 - interval of nine comma eleven so if we take a time axis like this now here it could be seconds
2267:01 - milliseconds nanoseconds it can be anything so let's say if we want to plot this task
2267:08 - on this time axis and we take it as seconds so it suggests that task a has start time of one
2267:16 - and it has end time of three so if we plot task a on this time axis it would look something like
2267:22 - this that a task starts from one and ends at three so it means if we take it in the form of seconds
2267:29 - task a takes two seconds to complete from one to three if we plot b it starts with four
2267:38 - and ends on five so it takes one second if we plot c so the start is eight and end is ten so it
2267:47 - takes two seconds to complete and if we plot d so it starts at nine and ends at eleven so it also
2267:55 - takes two seconds so usually these time intervals represent a range let's say for a task or for a
2268:02 - process and mostly the coding interview problems are given with these intervals so here we saw that
2268:10 - an interval has two numbers start and end now let's see how we can represent this interval
2268:16 - in form of a code so the interval representation looks something like this
2268:21 - that there is a class interval now this is a custom class
2268:27 - which we will create which has two properties start and end so this start
2268:35 - will represent the starting point of the interval and end will represent the ending point of the
2268:41 - interval so any interval takes only two numbers start and end and if you want to create an interval
2268:47 - we have provided this constructor which takes in a start and end and initialize a particular interval
2268:54 - with these numbers so this is how we actually represent an interval class so now let's move
2268:59 - ahead and see the concept of overlapping intervals so what are overlapping intervals so let's say if
2269:05 - you have interval something like one comma five and another interval as two comma six so if we
2269:13 - plot these intervals it looks something like this this is one this is five and let's say two is here
2269:27 - and let's say this is six so here if you see this is the first interval
2269:32 - with one comma five and this is the second interval with two comma six so now if you closely
2269:41 - look they are actually overlapping in this region from interval two to five so this actually
2269:51 - suggests that these two intervals are actually overlapping with each other in this region two
2269:58 - comma five so for an overlapping intervals we actually require two intervals at minimum
2270:08 - let's say if we denote it by a and b so there will be some relationship between these two intervals
2270:14 - so the first relationship would be that a and b do not overlap so it means a starts
2270:20 - and ends here and b starts and ends here so here if we take an example let's say one comma three
2270:28 - and four comma five so this is one interval and this is another interval but they don't overlap
2270:33 - if we have interval something like one comma three and three comma four then that will overlap
2270:40 - because the end time of first interval is equal to start time of another interval but here
2270:45 - there is a gap between these two so they don't overlap the another thing would be a and b
2270:52 - overlap but b ends after a so it would look something like this that a starts here and ends
2271:00 - here and b starts here and ends here so here b is ending after a and this is our overlapping interval
2271:08 - so if we take an example let's say one comma four and three comma six so here you can see these two
2271:16 - intervals actually represent this condition that a interval starts from one and ends at four
2271:22 - and b starts at three so it means this is one this is four this is three and this is six
2271:29 - here b is ending after a so we can visualize these two intervals like this
2271:35 - the third would be a completely overlaps b so it would look something like this
2271:43 - that a is actually overlapping b completely so if you take an example it could be like
2271:48 - one comma six for a and b could be two comma four so here one six two and four so it says that
2271:59 - a is completely overlapping b so this could be one such case so the fourth case is a and b overlap
2272:07 - a ends after b so this is pretty much same as this but here it looks something like this
2272:13 - here b was ending after a but here a ends after b so these two are pretty much same only the names
2272:22 - of the intervals have changed b completely overlaps a so this is pretty much same as
2272:29 - a completely overlaps b so it would look something like this here a was completely overlapping b
2272:35 - and now here b is completely overlapping a so here we just need to change the order of a and b
2272:41 - so if this was a and this was b so here a would be two comma four and b would be one comma six
2272:49 - rest everything remains the same and the sixth case is b and a do not overlap so this is pretty
2272:55 - much same as a and b do not overlap so it looks something like this so from these are the six
2273:01 - cases where we can demonstrate the overlapping intervals so for a situation where these
2273:07 - overlapping intervals come we at least need minimum of two intervals and there could be
2273:12 - many intervals like a b c d which can overlap with each other but we actually require minimum of two
2273:18 - so friend in this video we covered what are intervals and what are overlapping intervals
2273:24 - in our future videos we will see few problems related to overlapping intervals
2273:29 - i hope you must have liked this video in case if you are new to my channel then please subscribe
2273:33 - to my channel and click the bell icon so that you never miss any update thanks have a nice day
2273:41 - hello everyone so in our previous video we discussed about what are intervals and what
2273:46 - are overlapping intervals so now in this video we will look into a problem of merge intervals
2273:53 - so friends before we start in case if you are new to my channel then please subscribe to my channel
2273:58 - and click the bell icon so that you never miss any update so if you look at the problem
2274:03 - you are given with a list of intervals you need to merge all the overlapping intervals
2274:08 - and return a list of non-overlapping intervals so let's see it via an example let's say we are
2274:14 - given with a list of intervals like two comma six one comma three eight comma ten and this
2274:19 - intervals can be in any random order so we need to merge only those intervals which are overlapping
2274:26 - to each other and at the end we have to return a list of all the non-overlapping intervals
2274:31 - so the output would be one comma six and eight comma ten now how this output came we'll see
2274:37 - in a diagram so let's say we have this time axis and we have this intervals two comma six one
2274:43 - comma three and eight comma ten we will plot these intervals on this time axis so first we
2274:49 - will take two comma six so the start is at two and end is at six so this interval takes four
2274:56 - unit of time now let's say if time axis is in seconds so this will take four seconds
2275:04 - if we plot one comma three it would look something like this one is the start and three is the end
2275:10 - and after that we will plot eight comma ten so it looks like this so this is two seconds interval
2275:18 - and this is also two seconds interval so here if you see this one comma three and two comma six
2275:24 - are overlapping to each other so this is the area where they are overlapping
2275:33 - so it means we have to merge all the overlapping intervals so if we merge these two intervals
2275:40 - together we will get a bigger interval whose start will be one and end will be six so here as these
2275:47 - two are overlapping intervals when we will merge these two you can simply take this first interval
2275:53 - and put it on the top of the second interval and that will be our merged interval so it looks like
2275:59 - this the start will remain the same because this interval came first and the end will actually
2276:06 - depend that which interval has the maximum capture duration so here in this case the first interval
2276:13 - is completed at third second and the second interval is completing at the sixth second so
2276:18 - we will take the max of three and six and it merges to one comma six so this is the merged
2276:23 - interval because these two intervals are overlapping to each other but here if you see eight comma ten
2276:29 - as we have only three inputs eight comma ten is not overlapping with any of these intervals
2276:35 - and we have to return a list of non-overlapping intervals so eight comma ten will remain as it is
2276:41 - like this so therefore our answer is one comma six and eight comma ten if this eight comma ten
2276:46 - would have been six comma ten or five comma ten then our answer would have been one complete
2276:52 - merged interval of one comma ten so let's move ahead and see how we can solve such problems
2276:59 - so for the overlapping interval in our previous video we saw the different use cases that when
2277:05 - two intervals are overlapped with each other what happens so one such condition is a and b do not
2277:10 - overlap so it looks something like this that there is a gap between these two intervals so
2277:16 - we can't merge them now if a and b overlap but b ends after a so it would look something like this
2277:26 - now here one thing we are assuming is a will always come before b so this diagram will make
2277:31 - sense that b ends after a and if a and b overlap it would look something like this
2277:36 - a completely overlaps b so it would look something like this but still a is coming before
2277:44 - b b completely overlaps a in a case that both have same start time so b is completely overlapping a
2277:53 - but a should come either before b or it can start at the same time so therefore we are taking this
2277:59 - assumption and we will come to know later why it's important so this is one such case where b will
2278:05 - completely overlap a but as a should either start at the same time as b or before b this would be
2278:12 - one such use case now we will see all these cases and why they are important so with the first case
2278:20 - when a and b overlaps and b ends after a so this is the case so when we will merge these two
2278:26 - intervals a and b and let's say result we denote it via c now as we are merging these two intervals
2278:32 - a and b here you can see the range of c which is start and end would be a start and b end so here
2278:40 - you can think of any two intervals but one thing is sure both of the intervals either will start at
2278:45 - the same time or one of the interval would be coming first so whichever interval is coming first
2278:50 - its start will become c start and the value of c end will depend on the maximum expansion of any
2278:57 - of this interval so here you can see as b ends after a b's end value will become c's end
2279:04 - and after merge it will look something like this so let's say if a starts from one
2279:09 - and ends at three and b starts from two and ends at five so here you can see this is the overlapping
2279:16 - part so when we will merge these two intervals let's say we put a on the top of b so it will
2279:23 - become something like it starts from one like this and ends at five so this is the merging
2279:30 - we'll see another use case let's say a completely overlaps b so in this case if we merge these two
2279:37 - intervals let's say we put a on top of b so it would look something like this let's see start
2279:43 - becomes a start because this is the start of the interval and as a completely overlaps b
2279:50 - c's end will become a's end like this
2279:55 - so this is one such use case if we look at the third use case where a start is actually equal
2280:01 - to b start and b ends after a so in this case if we merge both these intervals it would look
2280:08 - something like this that if we put a on top of b the c start will be either a dot start or b dot
2280:14 - start it will be same but the end will be b's end because this is the start and this would be
2280:21 - the maximum value till both the interval goes so in all these three use cases one thing to keep in
2280:27 - mind is we are assuming a will either start before b or at the same time of b so c start
2280:35 - will be equal to a start this is sure and c end there will be a condition
2280:49 - that we will take max of a and b end and whichever is the maximum value that will be assigned to c's
2280:59 - end so in this case here you can see a end is three and b end is five so c end becomes five
2281:06 - here you can see a completely overlaps v so a end is greater than b's end so therefore c end becomes
2281:12 - a end and similarly here as b is completely overlapping a so b end is having a greater value
2281:19 - than a ends so whichever is the maximum that gets assigned to c end and that will be our merged
2281:25 - interval now one thing we discussed that a should start before b or at the same time
2281:31 - but if we look into the problem we are given the intervals in random order let's say 10 comma 19
2281:40 - three comma four one comma two and let's say two comma three now we have to merge all overlapping
2281:47 - intervals so one thing we need to keep in mind is we have to first sort all these intervals based
2281:54 - on their start time once we get the start time this condition will come into picture
2282:00 - that one of the interval is starting before the other and once we sorted based on the start time
2282:05 - all the intervals start time will be in ascending order so we can directly compare one with the
2282:10 - other and see if they are overlapping with each other or not so in order to solve this problem
2282:20 - the first thing we need to do is we need to sort the intervals based on the start time
2282:24 - so this condition will come into picture that a dot start will be less than or equal to b dot start
2282:30 - so here a dot start in this case is less than b dot start in this case also it is less than b dot
2282:36 - start but in this case a dot start is equal to b dot start so this condition is important
2282:42 - so when we will sort these intervals the merging becomes easier here if you see let's say if you
2282:49 - want to merge these two elements we know that a dot start is before or equal to b dot start
2282:54 - so c dot start will directly becomes a dot start because a is coming before b but c dot end which
2283:02 - we discussed here its value will be depend on whichever interval is going to greater time span
2283:08 - so it would be max of a dot end and b dot end so here in this case a dot end was smaller than
2283:14 - b dot end so c became b dot end in this case if we merge these two elements then b dot end was
2283:21 - lesser than a dot end so when we merge it become a dot end and similarly here b dot end is greater
2283:27 - than a dot end so therefore on merging c end becomes b dot end because we have to take the
2283:32 - maximum of a dot end and b dot end so these two conditions are very important and once we do the
2283:39 - merging of let's say two intervals we can keep proceeding ahead with all the overlapping intervals
2283:45 - and we can check which are overlapping intervals and we can merge them so friend let's see the
2283:51 - demonstration of this algorithm step by step so we have this merge method which actually merge
2283:56 - the overlapping intervals and we are given with a list of interval and our task is to merge
2284:02 - the overlapping intervals and return a list of all non-overlapping intervals because once we
2284:08 - merge all the overlapping intervals they all become non-overlapping so first we will call
2284:14 - the merge method we pass in the list of intervals so it would look something like this that this is
2284:20 - the list of interval seven comma nine two comma six one comma three and they are in random order
2284:26 - so the first thing we have to check that whether interval size whether it is less than two or not
2284:33 - so if it is less than two it means list has either zero elements or one element it means there is only
2284:39 - one interval or zero interval so we don't have to merge anything we have to simply return the
2284:44 - same list back so this is one h case so currently interval dot size is three therefore it is not
2284:51 - less than two now in order to compare whether all these intervals are overlapping to each other
2284:59 - what we need to do is we have to sort all these intervals based on their start time
2285:04 - so that we can come to know that whether there is any overlap or not so the list has a sort method
2285:10 - which takes in a comparator and comparator has a comparing int method which actually returns a
2285:16 - comparator now in this method this is a static method so in this method we are simply telling
2285:22 - take each interval and sort it based on the start time so this comparing int method will take this
2285:29 - intervals list will sort it based on the start time so the intervals will become something like this
2285:37 - one comma three two comma six seven comma nine so start time so one is less than two
2285:42 - two is less than seven so it has sorted based on the start time moving ahead
2285:47 - now as we need to return a list of all non-overlapping intervals we will create a result
2285:53 - list like this so currently it's empty now as we are sorted the intervals based on the start time
2286:02 - we will compare the adjacent intervals so that we can check whether they are overlapping or not
2286:07 - so in order to compare all these intervals the first thing we do is we simply take the first
2286:12 - interval as it is so this is the time axis and the first interval is one comma three
2286:20 - so if we plot it here it looks something like this
2286:25 - now our task is to compare this one comma three with two comma six and check whether anything is
2286:30 - overlapping or not so for that we will create two variables start and end we will see its
2286:36 - significance later so to the start variable we will assign first dot start because we are
2286:41 - starting with this interval so start becomes one because first dot start is one
2286:49 - end to end variable we will assign first dot end so first dot end is three so we are simply taking
2286:55 - this two intervals start and end as one comma three and now as we have to compare it with other
2287:02 - intervals we will take all these intervals in a for loop and we will start with one because zero
2287:08 - is already taken so this is zero this is one and this is second index so we will start i from one
2287:15 - so it would look something like this that we are now picking up two comma six and i is less than
2287:20 - intervals dot size one is less than three so this condition comes out to be true
2287:27 - now you can think start and end represents first and in the for loop currently we are on two comma
2287:34 - six so this becomes our current interval and this can be treated as previous intervals so from this
2287:40 - list we will get that interval by calling intervals dot get we will pass the value as one so we will
2287:46 - get two comma six so this will be assigned to the current like this and if we plot it here you can
2287:53 - see two comma six now our task is to simply check whether two comma six is actually overlapping with
2288:02 - any of the previous intervals or not so we will check whether current dot start is less than equal
2288:09 - to the end so we are not doing first dot end because there could be many intervals before this
2288:16 - current interval and start and end will represent just the previous interval which are being merged
2288:22 - or non-overlapping we will see its importance later so we are simply comparing current dot start
2288:29 - whether it is less than equal to end so here you can see value of end is three current dot start is
2288:35 - two so this is the start for current it is less than end so it means that there are overlapping
2288:42 - intervals and if you see why this example one comma three is actually overlapping with two comma six
2288:49 - so this condition comes out to be true which means we have to merge these two intervals now
2288:55 - so once you merge these two intervals let's say the result interval is c so we also saw that c dot
2289:02 - start was equal to a dot start which always remains a dot start because a is either starting
2289:11 - before b or at the same time as b so here our start will remain one only it won't get changed
2289:18 - but c dot end will become the max of a dot end and b dot end
2289:30 - so here this is the condition for that that we are simply taking the maximum value of current
2289:35 - dot end which is the current interval and value of end which is the value of its previous intervals
2289:42 - which is three so if we do three comma six max we get six so here you can see our start will
2289:52 - remain the same but end will change to six now because we are merging these two overlapping
2289:57 - intervals so end will become six moving ahead so here you can see one reason of picking start and
2290:10 - end in a different variable is as we have merged these two intervals start became one and end
2290:16 - became six and there could be a possibility that once we move ahead in the array there could be
2290:22 - another intervals like this so here in this case all these intervals will get merged together
2290:30 - so therefore only the end will get expand till the intervals are overlapping and start will
2290:36 - remain the same so therefore we have created these two variables which are doing those things
2290:40 - these two variables are keeping the state of the previous intervals which are merged or which are
2290:46 - yet to merge so now we'll increment i i will become two two is less than three so this condition
2290:55 - comes out to be true now this is our current interval seven comma nine so when we will do
2291:02 - intervals dot get two we'll get seven comma nine as our current interval like this
2291:12 - so now our task is to merge current with previous already merged intervals so we have to check
2291:18 - whether seven comma nine is overlapping with any of the previous intervals or not so that value
2291:24 - is actually hold by start and end so here if we see current dot start is this value and current
2291:29 - dot end is this value so here you can see current dot start is seven and value of end is six so it
2291:41 - means current dot start is not less than or equal to end because value of end is six and current dot
2291:48 - start is seven so here you can see there is a gap between these two intervals therefore they are
2291:55 - not overlapping with each other so this condition comes out to be false so the else part will be
2292:01 - executed and in the else part as we have already found one gap in between these two intervals
2292:08 - and this interval we can now safely merge these two intervals because when we go ahead these two
2292:14 - intervals will not be get affected and we can simply merge them and add it to the result
2292:20 - so in the result we are adding new interval start comma end so we are creating a new interval
2292:25 - of start and end which is one comma six and we are adding it to result so it would look something
2292:33 - like this that it is merged like this and it is added to result list moving ahead so once we have
2292:43 - merged these two intervals and there is a gap between the current and this merged interval
2292:52 - now our task will be to focus from seven comma nine to rest of the elements ahead we have to
2292:58 - forget this merging now because we have already merged these two intervals and there are no more
2293:05 - intervals which can get merged to these two intervals so therefore we have to forget this part now
2293:10 - and as you have started with one comma three at the start because that was the first interval
2293:17 - now we have to start from seven comma nine thinking it is the first interval
2293:25 - so therefore now start will become current start we will assign the value of current dot start
2293:31 - which is seven to start and end will become current dot end which will become nine so this
2293:42 - is now our fresh interval and if there are more intervals after seven comma nine this seven
2293:48 - comma nine will be compared with these intervals and these intervals are already merged and they
2293:54 - are added to the result list so we don't touch them now moving ahead
2294:01 - we will increment i so i will become three
2294:06 - and i is not less than three therefore this condition comes out to be false
2294:12 - and for loop will terminate because there are no more elements left
2294:15 - to be compared with this seven comma nine so this for loop will terminate and one thing to notice
2294:23 - as soon as this for loop will terminate whatever the value start and end will hold
2294:27 - that will hold an actual interval which also needs to be added to the result so here you can
2294:33 - see seven comma nine was the single most interval left and there are no more intervals left which
2294:38 - can be merged with seven comma nine so this seven comma nine also needs to be added to the result
2294:43 - list so at the end we have to add this seven comma nine also to our result list because this
2294:49 - is a non-overlapping interval so we do result dot add new interval and we pass the value of
2294:54 - start and end which is seven comma nine so it would look something like this that this is also
2295:01 - one such non-overlapping interval and our task was to merge all the overlapping intervals
2295:08 - and only return the non-overlapping intervals so one comma three and two comma six got merged to
2295:14 - one comma six and seven comma nine didn't get merged with any of the interval so it came out
2295:20 - as seven comma nine so these two are our answers one comma six and seven comma nine so at the end
2295:27 - we will simply return the list of interval which is our result list
2295:34 - so friend this was all about the problem how to merge and overlapping intervals
2295:40 - and return back all the non-overlapping intervals i hope you must have liked this video
2295:45 - in case if you're new to my channel then please subscribe to my channel and click the bell icon
2295:49 - so that you never miss any update thanks have a nice day hello everyone so in our previous video
2295:56 - we actually saw the problem of merge intervals so in this video we will actually see one more
2296:01 - problem insert interval so friends before we start in case if you're new to my channel then
2296:08 - please subscribe to my channel and click the bell icon so that you never miss any update
2296:13 - so in this problem we are given with a list of non-overlapping intervals which are sorted by
2296:19 - their start time we are also given with a interval which we need to insert into the list at a valid
2296:25 - position in such a way that if that interval overlaps with any of the intervals which are
2296:30 - given in the list then we have to merge all those intervals and return back a list of mutually
2296:36 - exclusive intervals which means we need to return back a list of intervals which are different
2296:41 - and non-overlapping so let's see an example let's say we are given with this list of intervals
2296:47 - 1 comma 3 5 comma 7 8 comma 10 now they are non-overlapping and sorted by their start time
2296:54 - and let's say we are given with this new interval 4 comma 9 our task is to insert this 4 comma 9
2297:00 - into this list in such a way that if this new interval overlaps with any of the interval given
2297:06 - in this list we have to merge it with new interval and return back a list of mutually exclusive
2297:12 - intervals so the output is 1 comma 3 and 4 comma 10 now how this output came let's see via diagram
2297:19 - so this is our time axis and if you plot all these intervals on this time axis it would look
2297:25 - something like this 1 comma 3 5 comma 7 8 comma 10 we have to insert 4 comma 9 so it will go
2297:34 - from 4 to 9 so here you can see this 4 comma 9 doesn't overlap with 1 comma 3 so 1 comma 3
2297:42 - doesn't get affected by insertion of 4 comma 9 because they are not overlapping so 1 comma 3
2297:48 - will be part of our answer because it's mutually exclusive so this is the first part now here you
2297:54 - can see when we will insert 4 comma 9 it will affect 5 comma 7 and also 8 comma 10 so as 4 comma
2298:01 - 9 is completely overlapping 5 comma 7 if we put 5 comma 7 on top of 4 comma 9 that means merging
2298:08 - of these two intervals will not get affected because 4 comma 9 is already overlapping
2298:13 - completely 5 comma 7 but in this case 4 comma 9 is ending at 9 and 8 comma 10 is ending at 10
2298:21 - so if we put 8 comma 10 on top of 4 comma 9 the region will get expanded
2298:28 - till 10 and as 4 is less than 8 so start will remain the same but end will change because
2298:36 - 4 comma 9 is overlapping with 8 comma 10 and when we merge these two intervals
2298:41 - we take the end time of both the intervals and we see which is the maximum so here 10 is the
2298:46 - maximum so the merge interval will be something like this it would be 4 comma 10 so the next
2298:53 - output is 4 comma 10 now let's move ahead and see some of the concepts behind this insertion
2298:59 - and merging let's say we are given with these two intervals we need to insert a so a and b are non
2299:06 - overlapping so it means we can simply insert a without touching b so we simply insert a
2299:14 - now let's say a and b are overlapping so when we will merge these two interval their area will be
2299:20 - from here to here so this is the start of a and this is the end of b so if we take this
2299:28 - interval as c then we have to keep a formula as c start time will become the minimum of a dot start
2299:43 - and b dot start and the end time will become the max of a dot end and b dot end so this condition
2299:54 - comes into picture if they are overlapping so here you can see let's say if we give it a value as 1
2300:00 - 4 3 6 so we know that when we will merge these two intervals the minimum of 3 and 1 so c will
2300:10 - become 1 and maximum of 4 and 6 will be 6 we know that the area of this merging will be 1 comma 6
2300:18 - because we have to accommodate both the intervals so this formula comes handy minimum of a dot start
2300:25 - and b dot start a dot start is 1 b dot start is 3 so minimum is 1 and c's end will become max of a
2300:34 - dot end and b dot end a dot end is 4 b dot end is 6 so c's end will become 6 so this interval will
2300:42 - expand from 1 to 6 so c becomes a dot start which is this and b dot end which is this
2300:52 - similarly here a completely overlaps b so if we apply this formula the c will become a dot start
2300:59 - because a dot start is coming before b dot start and c dot end will become a dot end because it
2301:06 - is coming after b dot end we have to take the max value and if this is the scenario then by applying
2301:13 - this formula c start will become b start and c's end will become a's end so this would be the area
2301:22 - of the c interval and if b completely overlaps a and if we want to insert a so by applying this
2301:29 - formula c start will become b start and c end will become b's end so this is how we actually
2301:38 - insert and merge the intervals together now let's see why an example if we have these four intervals
2301:46 - which are non-overlapping sorted by their start time and we have to insert a new interval 4 comma
2301:52 - 9 so if we plot all these intervals on the time axis it would look something like this
2301:58 - 1 comma 3 5 comma 7 8 comma 10 11 comma 12 our task is to insert 4 comma 9 so here as we want
2302:07 - to insert this new interval from 4 to 9 there will be three region around this 4 comma 9 which will
2302:15 - get affected when we will insert this new interval so one region is just before 4
2302:21 - 4 which is this another region is this between 4 to 9 and the third region is just after 9
2302:34 - so here we are taking the region 1 as just before 4 not even equal to 4 and here just after 9 not
2302:42 - even equal to 9 because if any of the interval touches this boundary like this then they also
2302:50 - need to be merged because they are overlapping with each other and so we need to keep this
2302:55 - condition in mind that in region 1 we have to simply check for less than intervals in region 3
2303:02 - it should be greater than the end time and in this region if they overlap we have to directly
2303:10 - merge them so how we can solve this type of problem is we have to take these three regions
2303:15 - first we have to take all the intervals which are part of region 1 and all the intervals which
2303:20 - are part of region 1 will satisfy this condition that their end time let's say this part is less
2303:27 - than the new interval start time it means they are not overlapping there is a gap so this less
2303:33 - than condition is helpful if they become equal then they actually overlap and we have to merge
2303:39 - them so first we cater for less than condition and we figure out what are all the intervals
2303:44 - which are not touching 4 comma 9 so those intervals we directly take into our result list
2303:51 - because they are not touching 4 comma 9 and they are not overlapping 4 comma 9 so let's say if
2303:57 - there are n number of intervals before 4 so we have to check each interval's end time and check
2304:04 - whether it is less than the new interval start time if it is less than the new interval start
2304:09 - time we know that they belong to this region so after placing all the elements of region 1 we
2304:15 - come to region 2 now here what we check is let's say if we take this example so here if this
2304:20 - interval has to belong in region 2 what we do is we take its start time and we check whether it is
2304:27 - less than or equal to the new interval's end time now here we are checking for this condition less
2304:34 - than or equal to so let's say 5 is less than 9 so it means this interval belongs to region 2 because
2304:42 - we have already excluded the region 1 intervals and if any of the intervals is left if this
2304:48 - condition satisfies that 5 is less than 9 or equal to 9 then this region even if it expands beyond
2304:56 - 4 comma 9 it will still overlap with 4 comma 9 and why we are taking this equal condition is
2305:01 - because let's say instead of 8 comma 10 we have
2305:08 - 9 comma 12 so 9 is the start time and if 9 is equal to new intervals end time so still
2305:17 - it is overlapping with this interval and we have to merge them so it still belongs to region 2
2305:23 - so this is the main condition for region 1 all the intervals end time should be less than
2305:29 - new interval start time so they will completely belong into this area and they will be non
2305:34 - overlapping in this region they will overlap so we have to simply check the interval start time
2305:40 - and we have to check it is less than equal to the new intervals end time if that is the condition
2305:45 - they still overlap and we have to merge them so here if you see 4 comma 9 overlaps 8 comma 10
2305:51 - because 8 is the start time and it lies before 9 because 8 is less than equal to 9 so therefore
2305:58 - when we will insert this interval it will affect 5 comma 7 and 8 comma 10 and we know the formula
2306:03 - that how to merge the two intervals together which we saw in our previous slide so after we
2306:09 - add all these elements into the list whatever elements are remaining these are out of the
2306:15 - boundaries of this 4 comma 9 which is the new interval which we want to insert so we can
2306:20 - directly add them into the list they won't get affected by the insertion of this new interval
2306:28 - so after merging 5 comma 7 is 4 comma 9 and 8 comma 10 with 4 comma 9 it will become something
2306:37 - like this so our overall answer becomes 1 comma 3, 4 comma 10 and 11 comma 12 so the algorithm
2306:44 - is something like this we have to skip and add intervals that come before the new interval
2306:50 - to the result list so all the intervals of region 1 which are coming just before the new interval
2306:55 - we have to simply add onto the list we have to merge all the intervals that overlap with the
2307:00 - new interval so this interval and this interval they are overlapping with this new interval
2307:05 - so we have to merge it with this new interval we have to add that merged interval into the result
2307:11 - so this is the interval which gets merged we add this into the result
2307:16 - and finally we insert the remaining intervals to the result so these are the remaining
2307:21 - intervals, there can be many intervals like this, we have to just insert them to the result
2307:27 - because they are non-overlapping and mutually exclusive.
2307:33 - So this region covers this part, this region covers the overlapping part and this region
2307:39 - covers all the remaining elements.
2307:42 - So all these regions will be captured by a simple while loop in the algorithm.
2307:47 - So let's move ahead and see the algorithm.
2307:50 - So this is the algorithm.
2307:51 - So this while loop is for the region 1 where we simply skip the elements which just come
2307:56 - before the new interval.
2307:58 - This while loop is covering the intervals which are getting overlapped with the new
2308:03 - interval and this while loop is just adding the remaining intervals.
2308:08 - So let's see the demonstration of this algorithm step by step.
2308:10 - We'll call the insert method, we'll pass the list of intervals and a new interval which
2308:16 - you want to insert which is 2,6.
2308:21 - So let's say we have list of intervals as 0,1,3,5,6,7,9,10 and we need to insert 2,6.
2308:30 - So if we plot all these intervals on the time axis, it would look something like this, 0,1,3,5,6,7,9,10.
2308:41 - We need to insert 2,6 which is from time 2 to 6.
2308:47 - Moving ahead.
2308:49 - So here we are just simply checking for the base cases.
2308:52 - That if list is null or empty, we simply return the list.
2308:57 - So currently list is not empty and it is not equal to null.
2309:01 - So for the new interval, you can think that it's a valid interval.
2309:06 - As we have to return the list of mutually exclusive intervals, we will create a result
2309:11 - list which is currently empty.
2309:16 - Now as we need to traverse each and every element of this interval list, we will create
2309:21 - an integer i starting from 0 index.
2309:25 - So first we are picking 0,1.
2309:29 - Now in this while loop we are checking that whether 0,1 when this 2,6 will be inserted
2309:35 - into the list of intervals, will this get affected or not.
2309:40 - So first we check whether i is less than intervals.size.
2309:43 - We are simply checking whether value of i is less than interval.size which is 4.
2309:48 - Because as we are traversing each interval one by one, there would be a time that i will
2309:53 - completely traverse all the elements.
2309:55 - So we need to break from the while loop at that moment.
2309:58 - So currently i is less than intervals.size.
2310:01 - The other condition we check is, we get this interval.
2310:05 - So we do intervals.get i.
2310:08 - So we get 0,1.
2310:10 - And as we discussed, we will check its end time with the new interval start time.
2310:15 - And we check whether this interval's end time is less than new interval start time.
2310:21 - Because if it is less than new interval start time, it means they are not overlapping, there
2310:26 - is a gap between.
2310:28 - So intervals.get i is this interval.
2310:31 - If we do dot end, we get 1.
2310:34 - We check whether 1 is less than newintervals.start.
2310:39 - So new interval.start is 2.
2310:41 - So 1 is less than 2.
2310:44 - So it means this condition comes out to be true.
2310:49 - This signifies that 0,1 doesn't overlap with 2,6.
2310:54 - And we can simply skip this element and add it to the result list because this won't get
2311:00 - affected by insertion of this new interval.
2311:03 - So 0, becomes part of the result.
2311:07 - Now we will increment i.
2311:10 - i will come to the index 1.
2311:15 - So i is less than intervals.size which is 4.
2311:20 - Intervals.get i which is 1 which is 3,5.
2311:24 - Now we are at 3,5.
2311:26 - We check whether this interval's end is less than newintervals.start.
2311:32 - So here this interval.end which is 5.
2311:36 - We check whether it is less than newintervals.start which is 2.
2311:41 - So this condition comes out to be false.
2311:44 - We suggest that all the intervals which were just coming before new interval have already
2311:50 - been part of the result.
2311:52 - And once we reach on this interval, this condition comes out to be false which actually
2311:57 - states that 3,5 will either lie in the area of new interval or beyond that.
2312:02 - But it won't lie here in the region 1 because this condition came out to be false.
2312:07 - So ideally this while loop will terminate which signifies that all the intervals which
2312:12 - were coming before new interval have been added to the result list.
2312:16 - And we can move ahead with another while loop.
2312:20 - i is less than intervals.size.
2312:22 - Now here we actually check for the second region that whether 3,5 is overlapping with
2312:28 - 2,6 or not.
2312:30 - And we already discussed how we can do that is intervals.get i which is this interval.
2312:38 - We simply check its start time which is 3.
2312:41 - We check whether it is less than or equal to newintervals.end.
2312:46 - So 3 is less than or equal to newintervals.end which is 6.
2312:51 - So which is true.
2312:52 - So it means these two intervals are overlapping which is being proved by this condition.
2312:58 - And so the condition in while loop comes out to be true.
2313:02 - So first we will get this interval 3,5 we assign it to current like this.
2313:08 - Moving ahead.
2313:10 - Now as we need to merge 2,6 with 3,5.
2313:14 - So we know the formula that if we merge two intervals let's say a and b and let's say
2313:19 - the result interval is c.
2313:20 - So it becomes c start becomes min of a.start, b.start and c's end will become max of a.end
2313:41 - and b.end.
2313:43 - So here these two are the same conditions and here c is our newinterval only.
2313:49 - We are simply merging 3,5 into the newinterval only.
2313:53 - So newinterval start will become the minimum of current start which is this and newinterval
2314:00 - start which is 2.
2314:03 - So minimum of 3,2 will give 2.
2314:07 - So newinterval.start will become 2 which is already 2.
2314:11 - So this won't get changed.
2314:14 - Now newinterval end will become max of a.end and b.end.
2314:19 - So current.end and newinterval.end we take max of it.
2314:24 - So current.end is 5 and newinterval.end is 6.
2314:30 - So if we take max of it we get 6 which is assigned to newinterval.end.
2314:37 - So newinterval.end doesn't get changed because it is already 6.
2314:41 - So it means we have merged these two intervals and the resulting interval is same 2,6.
2314:48 - Because this newinterval completely overlapped the current interval.
2314:58 - Moving ahead, now we are done with this interval also.
2315:03 - So we will increment i, i reaches to 6,7.
2315:10 - So here i is less than intervals.size.
2315:13 - Now here if we do intervals.get i, we get 6,7.
2315:18 - So friends here you can see that why this less than equal to is important.
2315:23 - This 6,7 is starting where this newinterval is ending.
2315:27 - So it means they are still overlapping because the interval start which is 6 is actually
2315:34 - equal to newinterval.end which is also 6.
2315:38 - So therefore they are overlapping and we have to merge these two intervals as well.
2315:42 - We can't exclude 6,7 because it is just overlapping with 2,6.
2315:48 - So this condition is important.
2315:50 - So the overall condition in while loop comes out to be true.
2315:54 - We do intervals.get i, the interval 6,7 will be assigned to current like this.
2316:01 - And we have to merge these two intervals now.
2316:04 - So we will use the same formula.
2316:05 - The newinterval.start will become the minimum of current.start which is 6 and newinterval.start
2316:14 - which is 2.
2316:18 - So minimum will give 2.
2316:20 - So newinterval.start will become 2 which is already at 2.
2316:27 - Now newinterval.end will become the max of current.end and newinterval.end.
2316:34 - So max of current.end which is 7 and newinterval.end which is 6.
2316:42 - So it will give 7.
2316:44 - So here is the one critical step that newinterval.end will become 7 now.
2316:49 - Because after merging these two elements, the newinterval will expand to 7 like this.
2316:58 - That we have merged these two intervals.
2317:03 - Moving ahead, we will increment i, i becomes 9, 10, i is still less than intervals.size
2317:15 - because value of i is, this is 0, 1, 2, 3, 3 is less than 4.
2317:23 - Intervals.get i which is 3 will give 9, 10.
2317:28 - And here you can see this 9, 10 is actually belonging to the third region.
2317:33 - So therefore it starts if we compare it with newinterval.end.
2317:38 - So 9 is less than equal to newinterval.end which is 7.
2317:44 - So this condition comes out to be false.
2317:47 - It means 9, 10 is the remaining element and it doesn't overlap with 2, 7.
2317:53 - So we can directly add this 9, 10 and all the elements after that via this while loop.
2318:00 - So this condition comes out to be false.
2318:05 - So here you can see that before adding 9, 10 into the result list, we have to also insert
2318:11 - 2, 7 which is our merged interval into the result.
2318:15 - Which is actually merging 2, 6 which was our newinterval with 3, 5 and 6, 7.
2318:22 - So after these three intervals merge, we get 2, 7.
2318:26 - So this is one important step, we have to add this newinterval into the result.
2318:30 - So it will become like this.
2318:35 - And now using this while loop, we will add the remaining interval into the result.
2318:40 - So i is still less than intervals.size.
2318:44 - And as this condition reaches this while loop, we are sure that all the remaining elements
2318:48 - will be non-overlapping with this newinterval.
2318:52 - So we can directly add 9, 10 to the result.
2318:56 - We do result.add and we pass in intervals.get i which is 9, 10.
2319:02 - So it looks something like this.
2319:05 - And then we increment i.
2319:07 - So i goes beyond the boundaries of this interval list.
2319:14 - And now this while loop condition comes out to be false because value of i is 4 and interval.size
2319:20 - is also 4.
2319:22 - 4 is not less than 4.
2319:23 - So this condition comes out to be false.
2319:28 - And at the end, we simply return the result which is 0, 1, 2, 7 and 9, 10.
2319:35 - 0, 1 doesn't overlap with this newinterval and 9, 10 also doesn't overlap with this newinterval.
2319:41 - 3, 5 and 6, 7 were merged with 2, 6 and became 2, 7.
2319:47 - So this was the answer.
2319:49 - So friend, this was all about the algorithm.
2319:51 - I hope you must have liked this video.
2319:54 - In case if you are new to my channel, then please subscribe to my channel and click the
2319:58 - bell icon so that you never miss any update.
2320:00 - Thanks have a nice day.
2320:03 - Hello friends, welcome to my new data structures and algorithms in java tutorial series video.
2320:10 - Friends in this tutorial, we will discuss about the try data structure, we will discuss
2320:16 - about what is a try and what are its real life applications.
2320:24 - So friends, what is a try?
2320:27 - So here you can see the word try actually came from the word retrieval.
2320:33 - So the main purpose of this data structure was to retrieve the stored information very
2320:36 - fast.
2320:39 - So basically in real life application, we actually store the collection of strings inside the
2320:43 - try and whenever we want to get that string, we can retrieve that string very fast.
2320:50 - Below you can see the symbolic representation of a try data structure.
2320:55 - So here you can see that green circles are nothing but the try nodes and multiple try
2321:00 - nodes actually form a try and also you can see the topmost node is actually empty which
2321:08 - is being pointed by the root.
2321:11 - So root actually points to an empty try node and from the root, the other words originate.
2321:19 - So here you can see let's suppose if we store these four words into a try data structure,
2321:25 - then here we actually start from the root which is an empty try node and let's say for
2321:30 - an example as you want to store a word dog, then we simply create three try nodes storing
2321:37 - one alphabet into it and the try node pointing to others in sequence.
2321:44 - So friends here you can see that from root we pointed to node D, then from D we pointed
2321:51 - to node O, from O to G.
2321:56 - So friends after storing G, we know that dog is in the try.
2322:01 - So we mark the last node in yellow color stating that this is the end of the word.
2322:07 - For example if we take head, then from root we point to H, from H we point to A and from
2322:14 - A we point to T. Now as T is the end of the word, we usually mark it in the yellow color.
2322:23 - Moving ahead, friends if we talk about the applications of a try data structure, then
2322:28 - here you can see the one application would be the autocomplete of the words.
2322:33 - So friends you must have searched something on the Google search engine.
2322:38 - So there as soon as you type something, the search engine suggests the complete word to
2322:42 - you.
2322:44 - So this autocomplete feature is basically implemented with the help of tries.
2322:49 - Moving ahead, the other application would be the search contacts in phone.
2322:55 - So friends in your smartphone whenever you want to search any particular contact, you
2322:59 - just type the initial letters of the person name and the application automatically suggests
2323:04 - the name of the persons.
2323:07 - So this application is also implemented with the help of try data structure.
2323:15 - Also friends one more application would be the spell checking.
2323:18 - So here you can see that many editors such as word pages implement this spell check.
2323:25 - So here what happens whenever user types any wrong spelling, the application auto suggests
2323:30 - the correct spelling.
2323:33 - So here you can see the spelling is wrong, therefore the application is suggesting the
2323:37 - correct spelling so that user can select from one of these options and correct the spelling.
2323:45 - So friends this was the introduction to the try and also its applications.
2323:50 - In our upcoming tutorial we will discuss more on how to implement a try in the try
2323:55 - node and other methods which try supports.
2324:00 - Thanks have a nice day.
2324:03 - Hello friends welcome to my new data structures and algorithms in Java tutorial series video.
2324:11 - Friends in our previous tutorial we actually discussed about the try data structure and
2324:15 - also about its usage in real life applications.
2324:19 - So in this tutorial we will actually see how we can represent a try node in Java.
2324:26 - So friends what is a try node?
2324:29 - So friends in our previous tutorial we actually discussed that the try data structure most
2324:34 - of the time store the collection of strings.
2324:38 - So here a try node basically represents a single alphabet of the word.
2324:43 - So here you can see if you take an example of dog.
2324:47 - So this green circle having the word as D is nothing but a try node and let's say in
2324:54 - order to store a word dog which is three alphabet we actually need three try nodes which is
2325:00 - one for each alphabet.
2325:03 - So here you can see the topmost try node is empty which is being referred by root and
2325:07 - all the words which you want to insert into the try originate after that.
2325:14 - So here let's take an example of word head and let's say we want to store the head into
2325:17 - this try data structure.
2325:20 - So from the root we need to create three try nodes storing three alphabets such as H A
2325:25 - and T. So here you can see we have created three try nodes from root there is a link
2325:33 - to H from H there is a link to A and from A there is a link to T and as T is the end
2325:41 - of the word therefore we are marking it in the yellow color.
2325:48 - So friends let's see about the representation of a try node in try.
2325:52 - So a try node class in try consists of two data members.
2325:56 - So here you can see a try node has two data members.
2326:00 - So the first data member is nothing but an array of try node which are nothing but the
2326:05 - children of that particular try node.
2326:09 - So here it's an array which refers to other try nodes in try and also they are called
2326:15 - as the child nodes of a particular try node.
2326:20 - So friends here you can see in the most of the applications we actually store the English
2326:24 - words therefore the size of the array is usually taken as 26 because there are 26 alphabets
2326:31 - in English language.
2326:36 - So here if you take an example of this try node there here you can see that there is
2326:40 - one link to D and there is one link to H and similarly it refers to the other letters of
2326:46 - English alphabets and that referring is done through an array which actually refers to
2326:53 - other try nodes and let's say if you are on a particular try node and it refers to
2327:00 - other try nodes then those are nothing but the children of that try node.
2327:06 - So here the try node array is nothing but the first data member which a try node holds.
2327:12 - So if we talk about the second data member so it is nothing but a boolean value which
2327:17 - signifies that a void has ended or not.
2327:21 - So here you can see in this symbolic representation of try we know that dog is a complete word
2327:30 - so here you can see from D it goes to O and from O it goes to G.
2327:37 - Now we need to pass some information to this node so that we can come to know that this
2327:43 - word is in the try and it is the end of the word.
2327:48 - So usually in the symbolic representation we mark this node in the yellow color stating
2327:53 - that it is an end of the word but in Java we actually create a boolean value.
2328:00 - So this value set as true when a word is inserted completely.
2328:05 - So friends we will discuss more about these two properties in upcoming tutorials so that
2328:09 - we can understand more about the representation of a try node in try.
2328:17 - So friends let's see the demonstration of a try node.
2328:21 - So friends if you take an example of hat so we can see how it gets represented into Java
2328:27 - because here you can see the symbolic representation and here you will see the actual representation.
2328:34 - So at the top there is a root which is empty.
2328:39 - So in Java we represented something like that a try node root points to an empty try node
2328:46 - which has an array of size 26 because we have this 26 alphabets from A to Z.
2328:55 - And when we actually initialize a try root points to an empty try node.
2329:00 - So here you can see the default value of this word is false and also you can see the size
2329:05 - of array is 26 and each index points to a different try node but here when we initialize
2329:11 - this root they all point to null value.
2329:16 - Now let's suppose we want to insert H so in order to insert H we need to create a try
2329:21 - node and from H we need to refer that.
2329:25 - So here it looks something like this that we have created one try node and from H we
2329:33 - are simply pointing to this try node.
2329:37 - So this represents that there is a children to the root whose value is H and its default
2329:45 - value is false because this is not the end of the word and then we actually insert A.
2329:52 - So here you can see that A points to null.
2329:56 - So then we create a try node and we simply provide a link from A to this try node stating
2330:04 - that there is a children which points to A and finally let's say we insert T so it would
2330:11 - look something like this that initially T was pointing to null but then we created
2330:18 - a try node and we simply provided a value of this try node into this index.
2330:25 - So T points to this try node and friends here you can see as this is the end of the word
2330:31 - we simply mark the boolean value to be true.
2330:35 - So friends here you can see if you are storing the English words then each try node will
2330:39 - actually point to the other 26 try nodes so that they can store a particular word.
2330:47 - So here we actually saw that root which is an empty node it points to H, H points to
2330:52 - A and A points to T and also when all the other values of this array points to null
2331:02 - because there are no more words inserted here.
2331:05 - So you can see that all other links points to null and also friends here you can see
2331:10 - that this is an array so 0th index points to A, 1th index points to B, 2nd index points
2331:19 - to C and similarly 25th index points to Z.
2331:24 - So how this mapping is done we will discuss later.
2331:27 - So for now you can keep an information that a particular try node has an array which refers
2331:34 - to other try nodes and whose size is basically 26 if we are taking the English words and
2331:42 - it also has other property which tells that whether a particular word has ended here or not.
2331:49 - So friends in our upcoming tutorial we will actually discuss more about this try nodes
2331:54 - and how this linking is done and how this mapping is done of English alphabet to the
2331:59 - index of an array.
2332:01 - Till then have a nice day.
2332:05 - Hello friends welcome to my new data structures and algorithms in Java tutorial series video.
2332:12 - Friends in our previous tutorial we actually discussed about the representation of a try
2332:15 - node in Java.
2332:18 - So in this tutorial we will actually see how we can implement a try in Java.
2332:25 - Friends in our previous lecture we saw about the representation of a try node in try that
2332:30 - a try node has two data members.
2332:33 - One is the try node array which actually points to the other try nodes and which are also
2332:40 - called as try nodes of that particular try node and we also discussed that if you are
2332:45 - taking the English words then the size of this array is 26 because the English language
2332:50 - contains 26 alphabets.
2332:54 - Also friends the second data member is nothing but a boolean value which indicates the end
2332:58 - of the word.
2333:01 - So we said this value is true when we know that word is inserted completely.
2333:07 - So we will discuss about these two data members in depth in our upcoming lectures.
2333:14 - So friends let's see the implementation of the try class.
2333:19 - So friends here try will be implemented using the try node class which we actually discussed
2333:24 - in our previous tutorial.
2333:27 - You can also see that root try node is at the top of the try which has an empty value
2333:34 - and it has a try node array which actually refers to other try nodes.
2333:39 - So here you can see if you are working with English alphabets then there are 26 links
2333:45 - and these links actually point to other try nodes signifying that there is a letter into
2333:50 - a try or they actually point to null.
2333:55 - So friends in the try class we actually create an instance variable of try node and we give
2333:59 - it a name as root and whenever we initialize this try class we simply create an empty try
2334:05 - node and then using that root try node we actually insert the other try nodes signifying
2334:12 - that there are letters into this try.
2334:17 - Moving ahead friends now here we will discuss about the character and the index mapping
2334:23 - that how it is done.
2334:26 - So friends as here you can see that it is an array of try node and array is indexes.
2334:32 - So in order to store this English alphabets we usually take the values of the index and
2334:38 - we map it to the alphabets.
2334:43 - So here into this array we are not actually storing these values we are actually using
2334:48 - the indexes and we are figuring out the alphabets.
2334:52 - So here you can see A points to 0th index, B points to 1th index, C points to 2nd index
2334:58 - and similarly the rest of the alphabets.
2335:02 - So how this mapping is done let's use demonstration through a code.
2335:07 - So here you can see a char in Java is nothing but a 16 bit value which starts from 0 and
2335:13 - goes till 65,536.
2335:17 - So here we are creating a char value which points to A and let's say if we type pass
2335:25 - it to integer value then it prints 97.
2335:28 - So this 97 is nothing but the ASCII value of this character A and let's say next step
2335:37 - from A we minus the char value A it prints 0.
2335:45 - Similarly let's say we define another value H and if we subtract the char value A from
2335:54 - H it prints 7 because from A H is 7 step ahead and similarly if we define a value Z and on
2336:06 - the console if we print Z minus the char value A it prints 25.
2336:12 - It signifies that Z is 25 values away from A.
2336:16 - So friends here you can see that we can actually map the character with an index value by using
2336:22 - a formula that whatever the letter we pass and if we subtract the value A we will actually
2336:32 - get the index value.
2336:34 - So for example if we pass A and if we minus A from it we get 0.
2336:40 - If we pass H and if we minus A we get value 7.
2336:47 - If we pass Z and if we subtract A then we will get the value 25.
2336:54 - So friends in try as we are referring to this array we are implicitly mapping the index
2337:00 - value to character.
2337:04 - We are not actually storing these characters but any particular index value we are simply
2337:09 - mapping it to a character.
2337:11 - So from this implicit character to index mapping we will be using in our upcoming tutorials
2337:16 - when we will actually insert a word into a try and when we actually search for a particular
2337:21 - word in try.
2337:26 - Also friends in our previous tutorial we actually saw this demonstration.
2337:29 - So let's look it one more time to make it more clear.
2337:34 - So here you can see the root trinode is empty and whatever the values we will be storing
2337:39 - we will be actually storing into the childrens of the root.
2337:43 - We won't be storing any value inside this root because this root is also a type of trinode
2337:49 - which refers to other trinodes through this array which are nothing but the child of this
2337:54 - root.
2337:56 - So let's say we want to insert H so what we do is we simply traverse the H index we see
2338:00 - that its value is null.
2338:02 - So then we create a trinode like this and then we will simply refer its value into this
2338:11 - index moving ahead let's say we want to store A.
2338:18 - So as soon as we have inserted a value H and after that we have to insert A so we use this
2338:24 - link to traverse through this trinode and then we go to A and we see that its pointing
2338:30 - to null.
2338:32 - So then we create a trinode and whatever value it has we simply put it into this index and
2338:40 - similarly after A we go to T so from this trinode after inserting A we simply traverse
2338:47 - through this trinode we go to the index which maps to T and we see that it has null value
2338:53 - so we will simply create one trinode and whatever the value this object will hold into the memory
2339:01 - we will simply store it into this index because here a particular trinode actually refers
2339:08 - to other trinodes so here this trinode is actually referring to this trinode from the
2339:14 - index whose character value is T also when a T is the end of the word which is marked
2339:20 - here as in yellow so what we do is we simply set the boolean value of its word to be true
2339:28 - signifies that we have completely inserted the word hat into this tri so from in this
2339:34 - tutorial we actually saw the implementation of a tri that it is made up of a trinode now
2339:40 - let's go to eclipse and implement a tri hello friends in our previous tutorial we actually
2339:48 - discussed about how to implement a tri we also discussed that how a trinode is represented
2339:54 - into a tri so in this tutorial we actually code the basic implementation of a tri data
2340:00 - structure so here I have created one class by name tri having a main method so let's
2340:08 - start our implementation so friends in our previous tutorial we discussed that a tri
2340:14 - is implemented by a trinode class so first we'll create a inner class and we'll give
2340:22 - the name to it as trinode also friends we discussed that a trinode has two data members
2340:33 - one is trinode array which are nothing but children of this trinode the other data member
2340:47 - is a boolean value we signifies that this trinode is nothing but end of the word so
2340:54 - we'll give it a name as its word we'll also provide a constructor to this trinode and
2341:09 - inside this constructor we will initialize this trinode array with the size as 26 because
2341:24 - here we are storing English words so these words are from A to Z also the value of this
2341:40 - word is by default false so we set its value to be true when this trinode is actually an end of the
2341:50 - word also friend we discussed that a tri contains an instance variable whose type is trinode which
2342:02 - is nothing but the root of the tri data structure so this trinode which is the root will point to
2342:08 - other trinode through this trinode array will also provide it a constructor so whenever we
2342:22 - initialize the tri class we simply create the instance of trinode and we'll assign it to root
2342:34 - so here root is empty so here whenever we initialize the tri class root points to the
2342:44 - trinode which is empty and after that we insert a particular word character by character
2342:50 - which this root points so friend this is how we actually implement a tri using this trinode class
2342:58 - also friends in our upcoming tutorial we'll see that how we can insert
2343:11 - a particular word into this tri
2343:15 - we'll also discuss that how we can search
2343:28 - for a particular value that whether it's there in this tri or not
2343:39 - so friends in our upcoming tutorial we'll actually see how we can insert a word into this tri
2343:43 - and we'll also see that how we can search for a particular word into this tri
2343:50 - so friends i hope you like this video thanks have a nice day
2343:58 - hello friends welcome to my new data structures and algorithms in java tutorial series video
2344:04 - friends in this tutorial we will discuss how to insert a word in tri
2344:08 - so friend let's see a demonstration of how to insert a word in a tri
2344:19 - friends in our previous tutorial we discussed that whenever we initialize a tri class
2344:24 - root points to an empty trinode because in the constructor of the tri
2344:28 - we create a new trinode and we simply assign it to the root
2344:31 - now for example let's say we want to insert a word as cat so here you can see the word cat
2344:41 - has three characters c a and t and as we are using the english alphabets we will initialize
2344:48 - this trinode array with a size of 26 where index 0 will correspond to a index 1 will be corresponding
2344:56 - to b and index 2 will be corresponding to c and similarly index 25 will correspond to z
2345:04 - friends we also know that each character in this word will be represented by a trinode
2345:10 - so using this root so first we will insert c from the root so here what we do we go to index 2
2345:18 - which maps to character c and you will see that whether trinode at index 2 is null or not so
2345:25 - currently as root is empty the trinode at index 2 is null therefore in order to insert
2345:32 - the character c first we will create a trinode and after creating this trinode we will simply
2345:39 - refer it from the index 2 which maps to c also friends once we insert this trinode using this
2345:48 - link we simply traverse to this position and after reaching to this trinode now we will insert a
2345:56 - so what we do is we simply go to the index 0 which maps to a and we'll see there whether it's
2346:01 - null or not so currently you can see that it points to null so in order to insert a
2346:08 - we'll again create a trinode and after creating the trinode we'll simply refer to this trinode
2346:16 - from index 0 which maps to a also friends once we have inserted this trinode
2346:22 - using this link we will simply traverse to this trinode and then we will insert the character t
2346:30 - so when we reach to this trinode we simply traverse to index which maps to t and we'll
2346:35 - see that whether it's null or not so here you can see it points to null so in order to insert t
2346:42 - we'll first create a new trinode and then we will simply refer to this trinode from the index
2346:50 - which maps to t also friends once we insert this trinode using this link we'll simply traverse
2346:57 - to this trinode and after we reach to this trinode we see that there are no more characters
2347:04 - left to be inserted so we also know that this is the end of the word so in order to mark cat
2347:11 - as the end of the word what we do to this trinode we simply assign the value as true
2347:20 - so this value signifies that when you reach to this trinode
2347:24 - this makes end of the word and it also signifies that cat is in the try
2347:34 - friend let us take one more example we'll insert a word sun so when you call the insert method
2347:40 - we'll start from the root and as we want to insert s we simply reach to index which maps to s
2347:49 - and we'll see that whether it's equal to null or not so here you can see it points to null
2347:54 - therefore in order to insert the character s we'll first create a trinode
2348:01 - and we'll simply refer to this trinode through this link from the index which maps to s
2348:06 - and after we insert this trinode we simply traverse to this trinode through this link
2348:13 - and once we reach to this link we'll now insert the character o
2348:19 - so here we go to index which maps to o and we'll see whether it points to null or not
2348:25 - so here you can see it points to null so in order to insert o we'll again create a trinode
2348:31 - and we'll simply refer to this trinode through this link from index which maps to o
2348:39 - and then we'll simply traverse to this trinode and after we reach to this trinode we'll now insert n
2348:47 - so we simply traverse to index which maps to n and we'll see whether it's equal to null or not
2348:53 - so here you can see it points to null therefore in order to insert n we'll again create a trinode
2349:01 - and after we create a trinode we'll simply refer it through this link from index which maps to n
2349:08 - and also friends here you can see now this word has inserted completely
2349:12 - so using this link when we reach to this trinode we'll now simply mark
2349:17 - this boolean value to be true which signifies that this is the end of the word
2349:21 - so moving ahead
2349:27 - now friend let's suppose we want to insert a word so so here you can see we have already inserted sun
2349:35 - and the word so is prefix to sun so let's see how we'll insert so into this trinode
2349:43 - so we'll start from the root we go to index which maps to s
2349:48 - and we'll see whether it points to null or not so here you can see this time it's not pointing
2349:52 - to null and it is pointing to a trinode which signifies that there is a character s into this
2349:58 - tri so we'll not create a new trinode and we'll simply traverse to this trinode and then we'll
2350:05 - insert o so here we'll reach to index which maps to o and we'll see that whether it points to null
2350:12 - or not so here you can see that this index doesn't point to null and it points to a trinode
2350:19 - which signifies that there is a character o into this tri so what we'll do is simply traverse
2350:25 - to this trinode now using this link and once we reach to this trinode we see there are no more
2350:32 - characters left to be inserted so in order to mark this word so that it is present into this tri
2350:40 - what we'll do we'll simply assign a value true
2350:45 - which will signify that this is the end of the word and the word so is present into this tri
2350:52 - so friends this boolean value is very important which let us know that
2350:56 - whether the particular word is present into this tri or not
2351:03 - also friends if we see the symbolic representation of this tri then it looks something like this
2351:09 - that root is empty and from root there are three words c a t t is the end of the word
2351:16 - and sun s o n where n is the end of the word and also so where o is the end of the word
2351:25 - so basically this tri has three words moving ahead
2351:31 - friends whenever we insert into a tri there are few use cases which we will look one by one
2351:38 - so the first use case is let's say we have an empty tri and now we are inserting a completely
2351:43 - new word so when we say an empty tri it means root is pointing to an empty trinode
2351:51 - and let's say we insert a word as cat so from root we will first insert c
2351:59 - so it would look something like this then we'll traverse to c and now we'll insert a
2352:08 - so it would look something like this and then we'll traverse to a and finally we'll insert t
2352:17 - so it looks something like this and then we will traverse to t
2352:21 - and we know that now we have inserted this word completely therefore
2352:26 - we will mark t as the end of the word by making it in yellow color so this was the use case one
2352:34 - now from the second use case is when we want to insert a word into this tri
2352:42 - and this tri contains already many words but the word which you want to insert has no prefix to
2352:48 - this word so the new word which we are inserting is completely altogether new to all the words
2352:54 - inside this tri so here let's suppose we want to insert sun so here you can see that sun doesn't
2353:01 - have any prefix to cat so this is an altogether completely new word into this existing tri
2353:09 - so we'll see how we can insert sun into this tri so we'll start from the root
2353:15 - and first we will insert s so it would look something like this
2353:22 - that there is now another branch which takes in a word s from the root first one and we also
2353:28 - discussed that root has a tri node array which points to all the english alphabets
2353:36 - so in this tri node array from the index which maps to c there is a word
2353:42 - and from the index s we will start inserting our new word
2353:47 - so after we insert s we'll simply traverse to s and then we will insert u
2353:52 - so it would look something like this and after we insert u we simply traverse to u to insert n
2354:02 - so it would look something like this and once we insert n we'll simply traverse to this node
2354:10 - and here we also that we inserted this word completely therefore we'll mark
2354:14 - this node as the end of the word by making it in yellow color
2354:22 - friend use case three is insertion with word which is having a common prefix
2354:30 - so you can see in our trial there is already one word there
2354:35 - and let's say we want to insert a word there so you can see both these words have common prefix
2354:43 - so the letters t h e is also present here t h e so these three letters are
2354:51 - common to this both words so let's see how we can insert there into this tri
2354:57 - so here we'll start from the root and we'll see that whether t is present or not
2355:01 - so here you can see t is already present so we'll simply traverse to t
2355:09 - and once we reach to t we see whether h is present or not so h is already present
2355:15 - so we'll simply traverse to h
2355:19 - after that we'll see that whether e is present or not so here e is present so we'll simply traverse
2355:25 - to e and now we'll see that whether i is present or not so here you can see i is not present
2355:34 - so here from e there would be another branch coming out
2355:38 - we'll create a new tri node i and we'll simply link to this new tri node from e
2355:43 - so it would look something like this
2355:47 - that from e there is a link to a character i and once we insert i we'll simply traverse to i
2355:54 - and we'll finally insert r so we'll check whether r is present or not so here you can
2355:58 - see r is not present so we'll create a new tri node and we'll insert r
2356:05 - and finally we see here that it is the end of the word so we'll simply mark r as the end of the word
2356:11 - also friends one final use case would be that insertion with word already present into the tri
2356:20 - so here let's suppose our tri consists of a word daddy
2356:24 - so it has five nodes which points to d a d d y and let's suppose we want to insert a word dad
2356:33 - so we know that dad is already present into this tri
2356:35 - tri but we need to perform some work to make sure that dad is inserted into this tri
2356:41 - so what we do is we start from the root we see whether d is present or not so d is present
2356:48 - so we'll simply traverse to d we check whether a is present or not so a is present so we'll
2356:55 - simply traverse to a we check whether d is present or not so d is present so we'll simply traverse to d
2357:03 - d and as we know that we have inserted this word completely so one last thing we do is
2357:09 - we simply mark d as the end of the word by making the boolean value is what to be true
2357:18 - so for in this tutorial we actually saw the demonstration of how we can insert a word into
2357:22 - a tri through all the possible use cases in our next tutorial we'll actually see the code to insert
2357:30 - a word into a tri i hope you like this video thanks have a nice day
2357:38 - hello friends welcome to my new data structures and algorithms in java tutorial series video
2357:44 - friends in this tutorial we will discuss how to insert a word in tri
2357:51 - friends in our previous tutorial we actually saw a demo of how to insert a word in tri
2357:56 - by seeing the different use cases so friends in this tutorial we'll actually see
2358:02 - the working of this algorithm step by step so friends below you can see the code to insert
2358:08 - a word into a tri so let's see its demonstration step by step
2358:14 - so friends whenever we initialize a tri we know that root points to an empty tri node
2358:20 - because in the constructor we simply create a new tri node and we'll simply assign it to root
2358:26 - so root will point to an empty tri node now let's say we want to insert a word cat
2358:36 - so here string word will point to cat
2358:41 - so here we are simply seeing the string word in the form of character array
2358:45 - where c is at index 0 a at 1 and t at 2 so we'll see how we can insert
2358:53 - cat into this tri character by character
2358:59 - also friends in our previous tutorials we discussed that we always start from the root
2359:04 - when we are inserting any new word so in the step 1 what we'll do we'll simply create a temporary
2359:09 - node current and whatever the node root points will simply assign it to current so it would
2359:16 - look something like this that current points to a node which root refers moving ahead
2359:26 - friends now we will provide a for loop because we need to iterate each and every character
2359:30 - of this word and we have to insert into this tri so we'll start from the 0th index
2359:38 - and we'll iterate this for loop till index 2 so the condition we place in the for loop is
2359:45 - i should be less than word.length so here word.length will be nothing but 3
2359:51 - so as we are starting from 0 we need to traverse till 2 moving ahead
2360:00 - so in the for loop what we'll do we'll first take the character at index 0
2360:05 - so we'll simply call the charAt method of the string and we will take the character at index 0
2360:12 - because currently the value of i is 0
2360:17 - so the charC will point to character c
2360:23 - also friends in our previous tutorial we discussed that how we are mapping this index
2360:27 - with an actual character and we saw that if we are subtracting a from any particular character
2360:33 - we'll get the index value so here the value stored in c is c and when we'll subtract a from it
2360:41 - we get the index value so here index becomes 2
2360:46 - so in the tri node array index2 maps to character c
2360:52 - so using this current tri node we'll see in the children array which is nothing but
2360:56 - the array of tri node and we'll see the value at index 2
2361:01 - we'll check whether value at index 2 is null or not so here you can see currently value at index 2
2361:09 - which maps to c is null therefore the condition in if block comes out to be true
2361:16 - which means that c is not present into this tri and now we'll insert c into this tri
2361:22 - so the first step we do is we simply create a new tri node
2361:27 - and we'll simply assign it to a temporary tri node
2361:33 - also friends as we have created this new tri node we have to link the tri node at index 2
2361:39 - which maps to c to this tri node so what we do is we simply assign a value of node
2361:44 - to current dot children at index 2 which maps to c so it would look something like this
2361:54 - that now there is a link established from root to this tri node from the index 2 which maps to c
2362:01 - moving ahead
2362:06 - and also friends in our previous tutorial we also discussed that as soon as we insert a tri node
2362:10 - we simply traverse to that particular node so here we'll simply assign the value of
2362:16 - node to current so now current will point to this tri node moving ahead
2362:23 - so after incrementing value of i, i becomes 1
2362:36 - so the character at index 1 is a so value of c becomes a
2362:45 - we will evaluate the value of index by subtracting a from the value stored in char c which is nothing
2362:52 - but a so when we'll do a minus a we get the value as 0 which makes sense because index 0
2363:00 - will map to a character a moving ahead
2363:07 - now as current is pointing to this tri node we will check into its children array that at index 0
2363:13 - whether its value is null or not so currently you can see the value at tri node which is at index 0
2363:19 - points to null therefore condition in block comes out to be true
2363:25 - so in order to insert a we'll first create a new tri node and we'll simply assign it to a temporary
2363:32 - node and in order to insert this tri node in tri what we'll do we'll simply assign the value
2363:40 - of node which is this tri node to current dot children at index 0 so here it would look something
2363:48 - like this that now there would be a link from index 0 to this tri node
2363:57 - then we'll simply traverse to this tri node by assigning value of node to current
2364:02 - so now current will point to this tri node
2364:07 - moving ahead
2364:09 - now after incrementing value of i by 1 it becomes 2
2364:18 - so now we will insert the value at index 2 which is t into this tri
2364:25 - so value of char c will become t
2364:29 - then we will evaluate the index of the character t so we'll simply subtract a from t
2364:38 - so it will give index value as 19
2364:44 - so in the f block we'll again check that value at index 19 is equal to null or not
2364:50 - so here you can see the value at index 19 of this tri node array which maps to t is null
2364:57 - therefore condition in f block comes out to be true
2365:01 - now in order to insert t we'll first create a new tri node
2365:04 - and we'll simply assign it to a temporary node moving ahead
2365:12 - and now we'll assign the value of node to this tri node array at index 19 which maps to t
2365:19 - so it would look something like this
2365:23 - the tri node at index 19 will now point to a newly created tri node
2365:28 - and finally we'll simply traverse current to this newly created tri node by assigning
2365:36 - the value of node to current so it would look something like this
2365:41 - that current will now point to this newly created tri node
2365:50 - now after incrementing the value of i by 1 i becomes 3
2365:54 - so the condition in for loop comes out to be false because 3 is not less than 3
2366:01 - so here we simply take an exit from this for loop
2366:06 - and also friends in our previous tutorial we discussed that the last step we do is
2366:12 - we simply mark the boolean value is word to be true stating that this is the end of the word
2366:18 - so we'll simply assign the value true to current.asword so it becomes true moving ahead
2366:31 - now friend let's suppose we want to insert a string sun so we'll again call the insert
2366:37 - method by passing in word as sun so it would look something like this
2366:42 - so as we are inserting a new word we'll start from the root
2366:50 - so we'll create a temporary node current which will start from the root
2366:57 - and then we'll simply iterate each and every character of this word using this for loop
2367:06 - so in the first step we'll insert s
2367:08 - so c will have value as s
2367:15 - we will evaluate its index position by subtracting a from s so index will become 18
2367:25 - then we'll provide a if block and we'll check that into this tri node array at index 18
2367:32 - what's the value whether it's point to null or not so here you can see currently it is pointing to
2367:37 - null so the condition in if block comes out to be true so in order to insert s we'll first
2367:45 - create a new tri node and we'll assign it to a temporary tri node
2367:54 - and as we are inserting this new tri node into the tri we'll simply assign the value of node
2367:59 - to this tri node array at index 18 which maps to s so it would look something like this
2368:09 - that the tri node at index 18 which maps to s now points to this newly created tri node
2368:16 - moving ahead so after this assignment we'll simply traverse current to this newly created
2368:23 - tri node by assigning the value of node to current so it would look something like this
2368:30 - so that current will now point to this newly created tri node
2368:40 - so after incrementing the value of i by 1 i becomes 1
2368:47 - so now we'll insert o
2368:51 - so value of kse will become o
2368:54 - we will evaluate its index position by subtracting a from o so it would give index as 14
2369:07 - now as current is pointing to this node so we'll check that value of tri node array
2369:14 - at index 14 which maps to o whether it's null or not so currently you can see
2369:20 - this value is pointing to null therefore the condition in a block comes out to be true
2369:28 - now in order to insert o into this tri first we'll create a new tri node
2369:35 - and we'll assign it to a temporary tri node
2369:40 - and as you want to insert this new tri node into tri we'll simply assign the value of node
2369:46 - to this tri node array at index 14 which maps to o so it would look something like this
2369:55 - moving ahead then we'll simply traverse current to this newly created tri node
2370:04 - by assigning the value of node to current
2370:06 - and now after incrementing i by 1 i becomes 2
2370:17 - so now we'll insert the value n
2370:22 - so the value of kse will become n
2370:28 - we will evaluate its index by subtracting a from n so it would give index as 13
2370:37 - so in the if block we'll simply check that value of this children array at index 13 which maps to
2370:44 - n is null or not so currently you can see this value points to null so the condition in if block
2370:51 - comes out to be true so in order to insert n into this tri we'll first create a new tri node
2371:00 - and we'll assign it to a temporary node
2371:06 - and then we'll simply assign this newly created node to the index 13
2371:12 - of this tri node array which maps to n so it would look something like this
2371:20 - and then we'll simply move current to this newly created tri node
2371:24 - by assigning the value of node to current so it would look something like this
2371:28 - so after incrementing the value of i, i becomes 3 so the condition in for loop comes out to be
2371:41 - false and then we'll exit from this for loop
2371:48 - so friend as you inserted the word sun completely into this tri the last step we do is we simply
2371:54 - assign the value true to current dot is word stating that this is the end of the word
2372:02 - so it becomes true
2372:09 - now friend let's suppose you want to insert a word cap
2372:13 - so here you can see that we have already inserted word cat
2372:16 - and cab has a prefix ca which maps to ca of cat so we'll see how we can insert cab into this tri
2372:28 - so we'll call the insert method by passing in word as cab
2372:33 - so word will have the value as cab
2372:38 - we'll start from the root by creating a temporary tri node by name current and we'll assign a value
2372:44 - of root to it so it would look something like this and then we'll provide a for loop
2372:51 - which will iterate over each and every element of the word
2372:57 - so we'll start from c
2373:03 - we'll evaluate its index position by subtracting a from c so index become 2
2373:09 - so into this children array and we will see that whether value at index 2 which maps to c
2373:20 - is equal to null or not so here you can see the value is not null because it is pointing
2373:25 - to a tri node therefore the condition in if block comes out to be false
2373:31 - which tells us that c is already there into this tri so the else part will be executed
2373:40 - so in the else part we'll simply traverse current to a tri node which this tri node array holds at
2373:47 - index 2 which maps to c so it would look something like this moving ahead
2373:59 - now after incrementing i by 1 i becomes 1
2374:04 - so now we'll insert a
2374:10 - we will evaluate its index position by subtracting a from a
2374:14 - which gives index as 0
2374:18 - then in the block we'll check that what's the value of children array at index 0
2374:24 - so here you can see that it is not equal to null and it is pointing to a tri node
2374:28 - therefore the condition in if block comes out to be false and the else block will be executed
2374:33 - and in the else block whatever the value this tri node array at index 0 is referring
2374:39 - will simply traverse current to that tri node so it would look something like this
2374:45 - that current will now point to this tri node
2374:52 - now after incrementing i by 1 i becomes 2
2374:57 - so now we'll insert b
2374:58 - then you will evaluate index position of b by simply subtracting a from b
2375:10 - so it would give index as 1
2375:14 - and now we'll provide an if block and we'll check the value of this tri node array
2375:18 - at index 1 which maps to b whether it's null or not so here you can see
2375:24 - that it is pointing to null so the condition in if block comes out to be true
2375:29 - now in order to insert b we'll first create a new tri node and we'll assign its value to node
2375:42 - and then as we have to insert this tri node into the tri we'll simply assign the value of node
2375:48 - to this tri node array at index 1 which maps to b so it would look something like this
2375:54 - and then we'll simply traverse current to this newly created tri node
2376:08 - so after incrementing i by 1 i becomes 3 so the condition in for loop comes out to be false
2376:16 - because 3 is not less than 3 so this for loop will exit
2376:19 - and in the last step we'll simply assign the value of true to current dot is word
2376:28 - which states that this is the end of the word
2376:33 - moving ahead
2376:38 - so for now let's cover the last use case by inserting a value so here you can see we have
2376:46 - already inserted a word sun and the new word which we are inserting is so so so is already
2376:53 - there into this tri but we need to provide some additional info to this tri so that it can come
2377:00 - to know that so is actually a word so we'll simply call insert method again by providing a word as so
2377:08 - we will start from the root by creating a temporary tri node by name current
2377:20 - we'll provide a for loop which will iterate over each and every value of this word
2377:28 - so first we'll insert s
2377:33 - we'll first evaluate its index position by subtracting a from s
2377:38 - so index become 18
2377:43 - now we'll provide an if block and we'll check the value of this tri node array
2377:48 - at index 18 which maps to c so here you can see that value is not equal to null
2377:54 - so the condition in if block comes out to be false
2378:00 - so the else block will be executed
2378:01 - and in the else block whatever the node this children array at index 18
2378:09 - is pointing will simply traverse current to that node so it would look something like this
2378:16 - moving ahead
2378:20 - after incrementing the value of i by 1 it becomes 1
2378:26 - so now we'll insert o
2378:27 - we will evaluate index of o by subtracting a from o so index is 14
2378:40 - now we'll again provide an if block and we'll check the value in this tri node array at index
2378:46 - 14 so here you can see the value is not pointing to null it is pointing to a tri node therefore
2378:54 - the condition in if block comes out to be false and the else block will be executed
2379:02 - so in the else block whatever the value this tri node array at index 14 is pointing
2379:09 - will simply traverse current to that tri node so it would look something like this
2379:13 - now after incrementing i by 1 i becomes 2 so the condition in for loop comes out to be false
2379:29 - because 2 is not less than 2 so the for loop exits
2379:35 - and here is the most important part that as current is pointing to this tri node
2379:41 - and we have inserted this word completely into this tri we will mark the is what property
2379:47 - of this tri node to be true stating that this is the end of the word
2379:54 - so assigning the value true to this tri node we are telling tri that the word so is in the tri
2380:01 - so at the later point of time whenever we perform a search over in this tri
2380:06 - this boolean value will help us return a value true or false that whether
2380:11 - a particular word is present into a tri or not which we will be seeing in our upcoming tutorials
2380:22 - so friends in this tutorial we actually saw the demonstration of how to insert a word into a tri
2380:28 - step by step now let's go to eclipse and see the working of this code
2380:37 - hello friends in our previous tutorial we actually discussed how to insert a word in a tri
2380:44 - and we saw the demonstration of the algorithm step by step and also in our previous tutorial
2380:50 - we created one class by name tri and we implemented tri with the help of tri node class
2380:56 - so in this tutorial we will actually code a method which will insert a word into a tri
2381:05 - so here i have already created one method as insert which takes in a word and whose return
2381:10 - type is void so we need to insert this word into the tri so let's write the code for it
2381:20 - so in the first step we simply check
2381:22 - that whether word is equal to null or not and also we'll check that word is empty or not
2381:36 - because the word is equal to null or empty then we'll simply throw
2381:46 - illegal argument exception
2381:47 - saying invalid input
2381:57 - so friends these are the basic edge cases
2382:02 - and also friends in our previous tutorial we discussed that we will be storing
2382:06 - the english words into the tri so we have taken the size of this tri node array to be 26
2382:12 - so here we will be dealing with lower case letters
2382:19 - so we'll convert the word to lower case
2382:30 - and also friends before calling insert method we actually initialize
2382:33 - this tri class so root points to an empty tri node
2382:37 - so whenever we insert any word we basically start from the root
2382:44 - so we'll create a temporary tri node
2382:48 - and we'll assign a value of root to it
2382:52 - now we'll provide a for loop
2382:56 - which will iterate over this word character by character
2383:02 - so we'll start this traversing from zero to a value less than word dot length
2383:17 - and inside this for loop we'll insert this word character by character so we'll first fetch
2383:24 - the character at the value i by calling the caret method of the string
2383:35 - after getting the character value we will evaluate its index position
2383:43 - by subtracting caret from the value which c holds so this will give us back the index position
2383:52 - of this tri node array that where we want to insert this particular character
2383:59 - so after getting the index position we'll provide an if block
2384:05 - and inside this if block
2384:08 - we'll provide a condition that tri node array to a tri node which current points
2384:15 - and at its index value which we just evaluated we'll check whether it's equal to null or not
2384:24 - so if this value is null therefore we know that this character is not inserted into tri
2384:31 - so in order to insert this character into tri we'll first create a new tri node
2384:37 - and we will assign its value to a temporary node and after creating this new tri node
2384:56 - we will assign its value to the tri node array at the index which we just calculated
2385:10 - and after inserting this tri node into a tri will simply traverse
2385:19 - current to this newly created tri node by assigning the value of node to current
2385:22 - and also friend if the value is not equal to null then we'll simply provide an else block
2385:32 - and in this else block we'll simply traverse current
2385:39 - to a value this tri node array holds at the index so friends after inserting this
2385:47 - word character by character after the for loop we'll simply assign the value of this word to be true
2386:00 - stating that this is the end of the word
2386:04 - so from this is the code to insert a word into a tri so in order to call this insert method
2386:11 - in the main method we'll first create the instance of tri
2386:22 - so when we will create the instance of tri
2386:26 - into the tri constructor the root will be initialized to an empty tri node
2386:30 - and then we'll simply call the insert method by passing in few values say
2386:47 - cat cab sun
2387:00 - and so so these are the values which we actually discussed in our previous tutorial
2387:07 - so at last i will simply print
2387:17 - values inserted
2387:21 - successfully if i run this code now
2387:30 - you see it printed values inserted successfully
2387:36 - also friends in our upcoming tutorials when we'll actually perform the search
2387:39 - we can actually test the working of this insert method that whether these words are inserted
2387:44 - properly or not so friend in this tutorial we actually discussed how to insert a word into a tri
2387:53 - hi i hope you like this video thanks have a nice day
2388:03 - hello everyone so in this section of course we will be discussing about dynamic programming
2388:09 - and we'll see that how we can solve the problems related to dynamic programming
2388:18 - so in this lecture we'll simply see that what is dynamic programming
2388:22 - with a simple introduction
2388:27 - so friends what is dynamic programming so if you visited the website kohra
2388:33 - there was a question asked on how you can explain what is dynamic programming in a simple manner
2388:41 - and to that question a guy named jonathan paulson gave an amazing reply
2388:46 - so what analogy is demonstrated so let's say we write something this on a sheet of paper
2388:57 - and we ask that what's that equal to so your answer would be you will simply count each one
2389:06 - as one plus one two two plus one three three plus one four four plus one five six seven eight
2389:15 - so you simply reply eight
2389:19 - now let's say if we write one plus to the left of it and we ask what about that
2389:28 - so you will be quickly replying nine so initially you took some time to just add all those numbers
2389:36 - but when we simply added plus one to the left of it you straight away replied nine
2389:42 - so how would you know it was nine so fast so our basic answer would be that we simply
2389:50 - added one more and we didn't need to recount everything again because we remembered this
2389:56 - result which is equal to eight and we simply added plus one which became nine
2390:04 - so friends here you can see the dynamic programming is just a fancy way to say
2390:08 - remembering stuff to save time later so here what we do is let's say we calculated these values
2390:18 - and when we added plus one we didn't need to count everything again
2390:23 - and we knew that all these values were added to eight and we simply added plus one and we gave
2390:28 - the answer as nine and let's say if we do two plus to it then we wouldn't have counted everything
2390:35 - again we would have straight away replied eleven because nine plus two gave us eleven
2390:41 - so friends here dynamic programming also works the same let's say when we solve any small problem
2390:47 - so what we do is we simply store that result and when we encounter that same problem again
2390:54 - we simply take that stored result instead of recalculating the values in the problem
2390:59 - so friends this is our dynamic programming works let's say we are given a problem to solve
2391:07 - so what we do is we simply break that problem into smaller problems we solve those problems
2391:13 - and we store the result of those problems so while building up the solution to the last problem
2391:18 - if that smaller problem comes again we don't recalculate it we simply use the value which we
2391:25 - already computed so what it does is it simply saves our time and the problem takes less time
2391:32 - to compute what the exact value is so friends when we discuss dynamic programming in the world of
2391:41 - algorithms it is basically a technique in which a complex problem is solved by first breaking it
2391:51 - into smaller sub problems second solving those sub problems and simply storing their results
2392:03 - and third reuse those store results if sub problem occurs or overlaps again
2392:10 - so what it means that we are simply avoiding solving that sub problem again
2392:15 - and finally using solutions to smaller sub problems to build up the solution for the complex problem
2392:24 - so friends we saw an example in our previous slide that when we counted all the ones we came
2392:31 - to know that they are equal to eight so what we did was we simply remembered that all these ones
2392:37 - were equal to eight and when we added plus one we straight away came to an answer that now it's
2392:43 - equal to nine so here also we break the problem into smaller sub problems and we simply store
2392:50 - their results so that when those sub problems comes again we simply use that stored results
2392:58 - so that our time is saved and we are not recomputing those values and finally using
2393:04 - these steps we build a solution to the complex problem so friends if we use dynamic programming
2393:11 - then we can solve a complex problem very fast by simply breaking down into smaller sub problems
2393:19 - remembering the result of those sub problems and while building up the solution to complex problem
2393:25 - if those sub problems are coming again then we simply use those stored values instead of
2393:32 - recalculating those sub problems again and finally coming to a solution for the complex problem
2393:39 - so friends this is how we use the dynamic programming as a tool to optimize an algorithm
2393:47 - so friends in our next lecture we'll take a problem we will solve it without dynamic
2393:52 - programming we'll see the problem associated with it and then we'll introduce dynamic programming
2393:58 - and we'll see that how fast it makes the algorithm
2394:02 - hope you liked the lecture thanks have a nice day
2394:11 - hello everyone so friends in our previous lecture we discussed about what is dynamic
2394:16 - programming so in this lecture we will discuss more about dynamic programming
2394:22 - and its relationship with recursion we will see how recursion and dynamic programming go hand in hand
2394:32 - so here if you see we mostly use dynamic programming to provide an optimization over recursion
2394:41 - so here let's say we use recursion to solve any problem so usually it happens that when we solve
2394:48 - a recursive problem we tend to make the code inefficient which means using recursion we can
2394:55 - solve the problem but what it happens is the problem is solved but it tends to take more time
2395:04 - so in our previous lecture we discussed that how dynamic programming
2395:09 - usually help us to solve a complex problem by breaking it down into smaller sub problems
2395:15 - and then solving those sub problems and while solving those sub problems what we do is
2395:21 - we simply store the result of those sub problems and whenever that sub problems comes again into
2395:26 - picture we usually extract the stored result and we reuse rather than computing it again and again
2395:36 - so similarly when we solve any recursive problem what we do is we simply break it down to smaller
2395:43 - sub problems and we solve those sub problems and we store those results so whenever that sub
2395:50 - problem comes back into picture we usually use the stored result of that sub problem
2395:57 - and we avoid recalculating the solution to that sub problem so by doing that
2396:02 - a recursive problem gets optimized so if we see the basic definition of dynamic programming
2396:11 - is basically taking recursion plus memorization so here we tend to solve a problem recursively
2396:19 - and when we solve the sub problem we usually memorize those solutions
2396:24 - and later point of time if that sub problem comes again back into picture
2396:28 - we use the memorization solution rather than again calculating those sub problems
2396:34 - so friends in order to explain what is the problem with using recursion directly
2396:39 - and what's the advantage of bringing in dynamic programming with recursive solutions
2396:46 - we'll see an example
2396:50 - so we'll take the example of fibonacci series so what is fibonacci series so as per the definition
2396:59 - it is a series of numbers in which first two numbers are 0 and 1 after that each coming number
2397:06 - is the sum of the two preceding numbers so if we go by this definition
2397:13 - then this is the formula which comes out so here first two numbers are 0 and 1
2397:19 - so here you can see the fibonacci of 0 is 0 and fibonacci of 1 is 1 which means that first two
2397:27 - numbers are 0 and 1 after that each coming number is sum of the two preceding numbers
2397:34 - so let's say i want to calculate the nth fibonacci number so in order to calculate
2397:40 - the nth fibonacci number what i can do is i can simply do the sum of the n minus 1th fibonacci
2397:47 - number and n minus 2th fibonacci number so which means that we are simply doing the sum of
2397:56 - the two preceding numbers and getting the current number
2398:00 - so here you can see this is the fibonacci series of first few numbers where the first
2398:08 - two numbers are 0 and 1 which is this so let's say we want to calculate what's the fibonacci
2398:15 - number 2 so the fibonacci number 2 is the fibonacci number 1 plus the fibonacci number 0
2398:22 - so here you can see the fibonacci number 1 is 1 and fibonacci number 0 is 0 so if we do 0 plus 1
2398:31 - we get the number 1 if you want to calculate fibonacci number 3
2398:37 - we simply take the two preceding numbers which is 1 and 1 so when we do 1 plus 1 we get 2
2398:44 - and similarly 1 plus 2 will give 3 2 plus 3 will give 5 3 plus 5 will give 8 5 plus 8 will give 13
2398:57 - and 8 plus 13 will give 21 so this is how the series goes if you want to calculate any fibonacci
2399:04 - number we simply take the preceding two numbers we do the sum of it and we get the number so this
2399:11 - is the basic formula to calculate the fibonacci number so friends in our next lecture we'll take
2399:19 - this example of fibonacci series and we'll see that how plane recursion in calculating the fibonacci
2399:26 - number is less optimized and then we'll see that how we can bring dynamic programming more optimized
2399:33 - I hope you like this video thanks have a nice day
2399:42 - hello everyone so friends in our previous lecture we discussed that how recursion
2399:47 - and dynamic programming go hand in hand and we also discussed that dynamic programming
2399:53 - provides an optimization to recursion problems and we also discussed about the fibonacci series
2400:00 - and we saw that fibonacci series is nothing but a series where first two numbers are 0 and 1
2400:07 - and after that each number is the sum of two preceding numbers and we saw that we can calculate
2400:12 - the fibonacci number using this formula so in this lecture we'll take the example of fibonacci series
2400:20 - and we'll see that how recursion is less optimized when solving the problem of the fibonacci number
2400:26 - and then we'll see that how we can use dynamic programming to make this recursion problem
2400:34 - highly optimized
2400:38 - so friends in order to calculate the nth fibonacci number
2400:42 - this is the basic algorithm which uses the recursion so here you can see
2400:49 - that we are using this formula to calculate the nth fibonacci number
2400:56 - so you can see that when value of n is 0 we are simply
2401:01 - returning 0 when the value of n is 1 we are returning 1
2401:09 - and in order to calculate the nth fibonacci number we are recursively calling this fib function
2401:16 - with the value of n minus 1 and n minus 2 and we are simply doing the sum of it
2401:21 - to get the value of nth fibonacci number so here you can see that we are calling this
2401:28 - method recursively by passing n minus 1 and whatever is written from it we are storing in a
2401:36 - integer variable left and then we are calling recursively the fib function with the value n
2401:44 - minus 2 and we are simply storing it in the integer value right and finally we are doing
2401:50 - the sum of it because we know that we need to do the sum of the two preceding numbers
2401:56 - so which is these two numbers we are doing left plus right and we are simply returning the result
2402:03 - so this is the plain recursion without using any dynamic programming
2402:07 - so we'll see step by step how this algorithm goes
2402:11 - so let's say we want to calculate the fifth fibonacci number
2402:15 - so then you can see that the fib function will be called where n will be equal to 5
2402:24 - so we have called fib of 5 then we move ahead
2402:31 - n is equal to 5 therefore the condition if block comes out to be false we move ahead
2402:39 - n is not equal to 1 therefore the condition if block comes out to be false
2402:43 - so we move ahead
2402:47 - and here you can see now we are again calling the fib function with the value as n minus 1
2402:54 - which is nothing but 5 minus 1 4 and we are going to call this fib function recursively
2403:01 - so it would look something like this
2403:05 - that the fib function will be called again with a value of n as 4 like this
2403:13 - and then we'll move ahead
2403:16 - n is not equal to 0 so we move ahead
2403:21 - n is not equal to 1 so we simply move ahead
2403:27 - and then we again call the fib function with the value as n minus 1 which is 4 minus 1
2403:35 - so it would look something like this
2403:37 - the fib function will be called with a value as 3 like this
2403:46 - we move ahead the condition in if block comes out to be false because n is not equal to 0
2403:56 - similarly n is not equal to 1 so we move ahead
2404:00 - and here we again call the fib function with a value as 3 minus 1 which is 2
2404:10 - so it would look something like this the fib function will be called with a value as 2
2404:20 - n is not equal to 0 so we simply move ahead
2404:24 - n is not equal to 1 so we move ahead
2404:30 - now we are again calling the fib function recursively with a value as 2 minus 1
2404:36 - which is 1 so it would look something like this
2404:42 - the fib function will be called again with a value as 1 like this
2404:51 - so n is not equal to 0 so we simply move ahead
2404:55 - but now you can see that n is equal to 1 which is this
2405:03 - so we have encountered a base case where we want to return 1 now
2405:08 - so here fib of 1 is actually 1
2405:13 - so 1 will be returned from this fib of 1 to fib of 2
2405:20 - so it would look something like this
2405:21 - as we have left the fib of 2 at this point we will start executing from this point
2405:30 - where now left will get the value as 1 because we have returned 1
2405:36 - and now we will move ahead
2405:40 - so here you can see that n is 2 and when we do n minus 2 and call the fib function again
2405:47 - so it would look something like this that it will call fib of 0
2405:53 - so it would look something like this
2405:58 - now n is equal to 0 so now we will simply return 0 from here
2406:04 - so it would look something like this that 0 will be returned to fib of 2
2406:09 - and as we have left fib of 2 here we are again coming back to this point
2406:23 - and finally we will return left plus right which is 1 plus 0 which comes out to be 1
2406:32 - so from fib of 2 we will simply return 1
2406:39 - and as we have left fib of 3 at this point we will start executing now from this point
2406:50 - here n is 3 we will again call the fib of 3 minus 2 which is 1
2406:58 - so now fib of 1 will be called again it would look something like this
2407:04 - n is not equal to 0
2407:10 - n is equal to 1 so we will return 1 from here and as we have left fib of 3 from this line
2407:20 - we will start executing from this line
2407:24 - and we will simply return left plus right which is 1 plus 1
2407:30 - so from fib of 3 we are simply returning 2 to fib of 4
2407:40 - so we know that we had left fib of 4 at this point so we will start executing from this line
2407:49 - and then we will call again this fib function recursively with a value as 4 minus 2 which is 2
2407:56 - so now fib function will be called with a value as 2 so it would look something like this
2408:10 - so n is not equal to 0 so we'll simply move ahead
2408:15 - n is not equal to 1 so we'll simply move ahead
2408:20 - and then from fib of 2 we are again calling the fib function recursively because in order
2408:28 - to calculate the fib of 2 we need to do the sum of two preceding numbers which is fib of 1
2408:36 - and fib of 0 so first we are calling the fib of 1 because 2 minus 1 is 1
2408:44 - so it would look something like this the fib will be called with the n as 1
2408:51 - and it would look something like this
2408:55 - so we will now again calculate fib of 1
2409:02 - we know that n is not equal to 0 so we'll simply move ahead
2409:08 - and here we know that n is equal to 1 because we are calculating fib of 1
2409:14 - the conditional envelope comes out to be true and we are simply returning 1
2409:19 - so 1 will be written to fib of 2 and we had left fib of 2 from the left side
2409:31 - so 1 will be stored in left and then we'll simply move ahead
2409:36 - and then we'll go to its right by calling fib of n minus 2
2409:41 - so fib of 2 minus 2 is 0 so we'll simply call fib of 0 again
2409:49 - so it would look something like this that now we are going to its right
2409:55 - so here we know that n is equal to 0 so we'll simply return 0 from its right
2410:04 - so we'll go back to fib of 2
2410:06 - and as we are returning it from the right we start our execution from this point
2410:14 - where n is equal to 2 now
2410:19 - so finally we'll simply return left plus right which is 1 plus 0 so fib of 2 will be returning 1
2410:30 - to fib of 4 from its right
2410:37 - so as we are returning it from the right we'll start executing from this point
2410:41 - that we had left fib of 4 from the right side
2410:46 - so right will be having the value as 1 which we have returned it from fib of 2
2410:54 - and finally we'll return left plus right which is 2 plus 1
2410:59 - from the fib of 4 which is 3
2411:08 - so this 3 will return to fib of 5 which we had left from the left side
2411:12 - so we'll start our execution from this point
2411:17 - where n is 5 now
2411:21 - and now we'll go to its right by again calling fib of n minus 2 which is 5 minus 2 which is 3
2411:29 - so fib of 3 will be called again
2411:39 - n is not equal to 0
2411:43 - n is not equal to 1
2411:47 - now we'll go to its left because in order to calculate fib of 3
2411:52 - we need to calculate fib of 2 and fib of 1
2411:54 - so we'll call fib of n minus 1 which is 3 minus 1 2
2412:02 - so it would look something like this
2412:07 - n is not equal to 0
2412:09 - n is not equal to 1
2412:13 - and in order to calculate fib of 2
2412:17 - we'll first call fib again recursively by passing 2 minus 1 which is 1
2412:25 - so it would look something like this
2412:31 - n is not equal to 0
2412:35 - now here n is equal to 1
2412:37 - so we'll simply return 1 from fib of 1 to fib of 2
2412:42 - like this
2412:45 - and as we have left fib of 2 from its left we'll start our execution from this point
2412:55 - and we'll simply store 1 to the left because this is what is returned from fib of n minus 1
2413:04 - and now we'll simply go to its right by calling fib of n minus 2
2413:09 - which is 2 minus 2 which is fib of 0
2413:14 - so it would look something like this that fib of 0 will be called again
2413:18 - and here n is equal to 0 so we'll simply return 0
2413:29 - so as we are returning it from the right side we'll start our execution from this point
2413:33 - because 0 will be stored in right
2413:41 - and finally from fib of 2 we simply return left plus right which is 1 plus 0
2413:49 - so 1 will be returned from fib of 2
2413:56 - and as we have left fib of 3 from its left we'll start our execution from this point
2414:06 - and 1 will be stored in the left then we'll go to its right again by calling fib of n minus 2
2414:15 - which is 3 minus 2 which is 1
2414:21 - so fib of 1 will be called again
2414:27 - n is not equal to 0
2414:31 - n is equal to 1 so we'll simply return 1
2414:36 - so 1 will be returned to fib of 3
2414:39 - and as we are returning it from the right we'll start our execution from this point
2414:43 - where 1 will be stored in right
2414:50 - and finally from the fib of 3 we'll return left plus right which is 1 plus 1 which is equal to 2
2414:59 - so 2 will be returned from the fib of 3 to fib of 5
2415:04 - and as we have left fib of 5 from its right we'll start our execution from the right
2415:13 - where 2 will be stored in right
2415:18 - and finally we'll simply return left plus right from the fib of 5 which is 3 plus 2 which equals
2415:27 - to 5 so friends the fifth Fibonacci number has a value of 5 which we have returned finally from
2415:36 - fib of 5 so friends here you can see that we use plain recursion to calculate the fifth Fibonacci
2415:44 - number so this solves our problem but here you can see that it is very less efficient code
2415:53 - as you can see that we are calculating fib of 5, fib of 4, fib of 3, fib of 2, fib of 1 and fib of 0
2416:02 - but here you can see the boxes in blue color are recalculated again
2416:08 - so for example here you can see that fib of 3 we calculated the value as 2
2416:14 - and here we again calculated the value of fibonacci 3 as 2 so we went inside again
2416:22 - this tree which you see here and similarly you can see that fib of 2 we calculated here
2416:33 - then we calculated here and then we calculated here and similarly fib of 1 we calculated here
2416:42 - here here and here and same as fibonacci 0 we calculated it here here here so here you can see
2416:54 - the boxes in green were the actual calculation which you wanted to calculate but as we were
2417:02 - using this recursion we need to again recalculate everything here again in the blue boxes
2417:10 - so this makes this algorithm very less efficient so what dynamic programming says is
2417:18 - when we were computing fibonacci of 3, fibonacci 2, 1, 0 what if we stored those values somewhere
2417:26 - and later point of time when we wanted to recalculate fibonacci of 3, 2, 1, 0 we could
2417:32 - have used those values directly without going into again recalculating those values
2417:38 - so as per the dynamic programming definition a complex problem is solved by making it to
2417:46 - smaller sub problems we store those sub problems results somewhere and when we get those problems
2417:54 - again like here here here here instead of recalculating those things again and again
2418:01 - we can simply use the stored result and we can solve these problems very fast
2418:08 - so here you can see that dynamic programming basically provides an optimization to the
2418:14 - recursion and as we saw in the definition that it is basically an optimization over recursion
2418:22 - plus dynamic programming is nothing but recursion plus memorization
2418:28 - so here we use recursion but somewhere we memorize the solutions and we store it somewhere
2418:36 - so that when those sub problems comes again into picture we usually use the stored solutions
2418:42 - rather than recalculating them again and again so using this technique dynamic programming
2418:48 - provides an optimization over recursion so friend in this lecture we saw that how plain recursion
2418:55 - can be a problem in solving a complex problem so friends in the upcoming lecture
2419:02 - we'll see the demonstration of how we can use dynamic programming to use recursion with
2419:09 - memorization and we'll see that how we can solve the problems such as Fibonacci series very fast
2419:19 - i hope you like this video thanks have a nice day
2419:22 - hello everyone so friends in our previous lecture we saw an example to calculate the
2419:34 - nth Fibonacci number and we saw that how we can solve the problem using recursion
2419:41 - and we also saw that when we use recursion in calculating the nth Fibonacci number
2419:47 - the problem was solved but the solution was very less efficient
2419:52 - so friends in this lecture we'll discuss that how we can identify that a particular problem
2419:59 - comes under dynamic programming so usually dynamic programming problem has few characteristics
2420:08 - so one of the characteristics is optimal substructure
2420:17 - so what do we mean by optimal substructure
2420:21 - so here you can see that a given problem has optimal substructure property
2420:28 - if optimal solution of the given problem can be obtained by using the optimal solution of its
2420:33 - sub problems so which means we are given a complex problem and we want to solve that problem
2420:40 - and if that problem can be solved by breaking it down into smaller sub problems
2420:46 - and using the solution of those sub problems and obtaining the solution to the complex problem
2420:52 - gives the problem a property known as optimal substructure
2420:58 - so in our previous lecture we saw that how we can calculate the nth Fibonacci number
2421:03 - and we also saw that how we can solve the problem of nth Fibonacci number
2421:09 - by using the formulas if you want to calculate the nth Fibonacci number
2421:15 - you need to find the sum of its preceding Fibonacci numbers which is fib of n minus 1
2421:21 - and fib of n minus 2 so here you can see the complex problem has been broken down into smaller
2421:29 - sub problems which again gets broken down into more smaller sub problems which we saw in our
2421:36 - last lecture therefore as an example we can say that if you want to calculate the nth Fibonacci
2421:42 - number we can calculate by breaking it down into smaller sub problems thus this problem has
2421:50 - optimal substructure so in our last lecture we saw that in order to calculate the nth Fibonacci
2421:58 - number we can use the recursion and we can solve this problem so while using recursion we saw that
2422:05 - if you want to calculate let's say the fifth Fibonacci number so here in order to calculate
2422:12 - the fifth Fibonacci number we break this problem into two sub problems by first calculating the
2422:19 - fourth Fibonacci number and the third Fibonacci number so we further broke this problem into
2422:26 - sub problems and similarly it goes on like this so finally when we reach to a point
2422:34 - that a problem cannot be divided further so we usually encounter the base cases
2422:41 - which is n is equal to 0 and n is equal to 1 and then using the result of those base cases
2422:48 - we solve the sub problems then we use the solution to solve the bigger sub problem
2422:55 - and doing this we finally solve our main problem so here you can see that this complex problem
2423:05 - has a property of optimal substructure where a complex problem can be solved by breaking it
2423:11 - out into smaller sub problems and using its solutions to solve the main problem
2423:16 - so this one property optimal substructure helps us to identify that whether a problem
2423:25 - can be a dynamic programming problem or not so friends you know next lecture we'll see that
2423:31 - there is one more property combined with this property makes a problem a dynamic programming
2423:38 - problem so we'll discuss that property in our next lecture i hope you like this video thanks
2423:46 - have a nice day hello everyone so friends in our previous lecture we discussed that how to identify
2423:59 - a particular problem that whether it is a dynamic programming problem or not
2424:04 - we saw the dynamic programming has few characteristics
2424:09 - so one of the characteristics which we discussed in our last lecture was optimal substructure
2424:14 - so in this lecture we'll see that there is one more characteristic
2424:18 - which basically help us to identify that whether a particular problem is a dynamic programming
2424:24 - problem or not
2424:30 - so here the other characteristic is overlapping sub problems
2424:37 - so what is overlapping sub problems
2424:42 - so friend let's suppose we are given a problem and we want to identify
2424:47 - that whether the given problem has overlapping sub problems property or not
2424:52 - so we can simply identify the overlapping sub problems property by first taking the problem
2424:59 - and breaking it down into smaller sub problems and solving those sub problems to get the solution
2425:05 - of main problems now what this overlapping sub problems means so let's say if our solution
2425:12 - of a given problem is obtained by solving the same sub problems multiple times
2425:18 - so friends few lectures back we saw that when we solved the nth Fibonacci number problem using
2425:25 - recursion there we saw that in order to solve the nth Fibonacci number we first broke it down into
2425:32 - smaller sub problems using recursion and when we were building up the solution back by solving the
2425:40 - smaller sub problems we saw that those smaller sub problems were encountered multiple times
2425:48 - so here the example of calculating the nth Fibonacci number has few sub problems which are
2425:56 - overlapping to each other so here you can see that in one of our previous lecture we calculated
2426:04 - the nth Fibonacci number using recursion and here you can see that in order to solve
2426:11 - the fifth Fibonacci number we broke it down into smaller sub problems something like this
2426:19 - by using these properties that nth Fibonacci number is equal to n minus 1th Fibonacci number plus
2426:28 - n minus 2th Fibonacci number which is nothing but taking the sum of previous two Fibonacci numbers
2426:34 - so friends here you can see that when we solve this problem so in this diagram you can see
2426:42 - the boxes which are in blue color are basically the smaller sub problems which have occurred
2426:48 - multiple times so for example you can see that when we want to calculate the third Fibonacci
2426:54 - number we calculated second Fibonacci number first Fibonacci number
2427:00 - and again to get the value of second Fibonacci number we broke it down into smaller sub problems
2427:09 - by calculating the Fib of 1 and Fib of 0 if we see the tree of Fib of 3 this much
2427:22 - you can see that we have recalculated this tree here again
2427:25 - and also if you see the tree of Fib of 2 which is this much portion we have recalculated it here
2427:39 - and here
2427:44 - and similarly Fib of 1 we have recalculated it here here and here
2427:51 - and same goes with Fib of 0 we have calculated it here here here
2428:00 - so friends here you can see that when we solve this problem by breaking it down into smaller
2428:05 - sub problems we encountered that this problem has multiple overlapping sub problems here the same
2428:14 - problem overlapped with this this sub problem overlapped with this and this thus the problem
2428:25 - to calculate the nth Fibonacci number has overlapping sub problems and also friends you
2428:32 - can see that it also has optimal substructure where we are breaking it down into smaller sub
2428:37 - problems and solving those sub problems to get the solution to the main problem
2428:43 - so friend a problem is considered to be a dynamic programming problem when it follows the two
2428:49 - properties the optimal substructure which we discussed in our last lecture and overlapping
2428:56 - sub problems which we are discussing now so friends in our previous lectures we also discussed
2429:02 - that this solution is very less optimized because we are recalculating the values of the sub
2429:09 - problems multiple times so for example let's say we calculated Fib of 3 which has value 2
2429:18 - now what if i store this value somewhere and let's say when i encountered Fib of 3 again
2429:24 - instead of going to this deep tree i can just return 2 so i don't have to calculate this
2429:32 - tree again similarly with Fib of 2 if i store the value as 1 i can avoid recalculating this sub
2429:40 - tree and this sub tree thus you can see that if i calculate the values in green box once
2429:50 - i can store those values and simply i can reuse whenever these values are required again
2429:56 - therefore it's a perfect example of demonstrating that nth Fibonacci number is a dynamic programming
2430:03 - problem so friends in our next lecture we'll see that how we can store these values somewhere
2430:11 - and can reuse them again whenever the same sub problems occurs multiple times
2430:16 - so friends i hope you like this video thanks have a nice day
2430:26 - hello everyone so friends in our previous lecture we discussed about the two main characteristic
2430:34 - of a dynamic programming problem which was optimal substructure property
2430:39 - and overlapping sub problems property so friends till now we saw that how we can solve a problem
2430:46 - using recursion so in this lecture and in upcoming lecture we'll see that how we can solve a problem
2430:56 - using dynamic programming so friends there are two approaches to solve a dynamic programming problem
2431:02 - the first approach is bottom-up approach so what do we mean by it
2431:13 - in bottom-up approach we try to solve smaller sub problems first use their solution
2431:21 - to build on and arrive at the solution to bigger sub problems so which simply means
2431:28 - so let's say if you want to solve a complex problem
2431:32 - so instead of solving the complex problem at once what we do is we start with the smaller sub
2431:39 - problems we try to solve those sub problems we use those sub problems solution to arrive at a
2431:46 - solution to the bigger sub problems and this way we try to solve the bigger sub problems
2431:53 - and finally reach to the solution of our main problem
2432:00 - so the bottom-up approach is also called the tabulation method because in this approach
2432:05 - when we solve the smaller sub problems we usually store the result of those smaller sub problems
2432:12 - into a table and when those smaller sub problems are encountered again then we simply use the
2432:20 - values from the table to arrive the solution to the bigger sub problems
2432:25 - and this way solving the chain of sub problems we reach to the solution of the main problem
2432:34 - therefore the solution is built in a tabular form by using the solutions of smaller sub
2432:40 - problems iteratively and generating solutions to bigger sub problems
2432:44 - so friends in a previous lecture we saw that when we used recursion and when we solved
2432:52 - the nth Fibonacci number problem we saw that it was less efficient code because we were
2433:00 - recalculating the sub problems again and again so instead of recalculating the sub problems again
2433:06 - and again what we do is we store the results of those sub problems in a table and when those sub
2433:13 - problems are encountered again we simply use the values of those smaller sub problems from the
2433:20 - table itself without going to solve those sub problems again and again so friends now let's
2433:27 - look at the demonstration of bottom-up approach that how we can use the tabulation method to
2433:33 - memorize the solutions of the sub problems and reuse them later when those sub problems are
2433:39 - encountered again so here you can see that in this example we are simply calculating the nth
2433:47 - Fibonacci number and this time instead of using recursion we are using the bottom-up approach
2433:54 - which is nothing but solving it via one of the methods of dynamic programming
2434:01 - so let's say we want to calculate the fifth Fibonacci number
2434:04 - so here when we call this function fib the value of n will be 5
2434:17 - so in the first step what we do is we simply create a table which is nothing but an array
2434:23 - to store the result of the smaller sub problems so when we want to use the result of those sub
2434:30 - problems again we can simply refer this table pick up that value and simply reuse
2434:38 - so friends here we will simply create a table of length n plus 1 we will see why we are taking
2434:44 - the length as n plus 1 so it would look something like this that there will be an array by name
2434:52 - table having six elements from 0 to 5 and we are using n plus 1 because we know that array starts
2435:01 - from 0 and if you want to calculate the fifth Fibonacci number the value of fifth Fibonacci
2435:08 - number will be stored at the fifth index of the array so therefore we are using n plus 1
2435:14 - moving ahead so friends as we know that fibonacci series starts with 0 and 1
2435:24 - so here you can see we are simply assigning the value as 0 and 1 to the zeroth index
2435:31 - and the first index so we are assigning 0 to the zeroth index
2435:36 - and then we are assigning 1 to the first index
2435:47 - moving ahead
2435:51 - so friends here you can see that we want to calculate the fifth fibonacci number
2435:56 - which is this but we are starting from the bottom by using these base cases
2436:03 - therefore this approach is also called as bottom-up approach because we build our solution
2436:09 - by traversing from the bottom and we move up and finally we reach to our solution
2436:17 - so friends here you can see that we have calculated the value at zeroth index and at the first index
2436:24 - so now what we do is we provide a for loop we start from the second index
2436:29 - and this for loop will go till the value of i is less than equal to 5
2436:37 - so here you can see i becomes 2 and as i is equal to 2 here we can see that i is less than equal to 5
2436:47 - therefore the condition in for loop comes out to be true and the for loop executes
2436:51 - also friends we know that how we can calculate the fibonacci number
2437:00 - we simply do the sum of its two preceding numbers so here what we are simply doing
2437:07 - we have already stored the result of zeroth index and the first index
2437:12 - and when we want to calculate the second fibonacci number we simply do the addition of
2437:19 - the first preceding number which is i minus 1 and the second preceding number which is i minus 2
2437:26 - so this is nothing but we are doing the sum of its two preceding numbers because in this table
2437:33 - we are actually storing the fibonacci series and when we want to calculate the second fibonacci
2437:39 - number we simply do the addition of its two preceding numbers which is 0 and 1
2437:46 - so here you can see the value stored at table i minus 1 which is 2 minus 1 index has value 1
2437:56 - and the value stored at table i minus 2 which is 2 minus 2 has the value 0
2438:04 - so we'll simply add 1 plus 0 and store the value 1 at the second index here
2438:11 - so these are the two preceding numbers which we will add and store at this position
2438:23 - so now the valued second index becomes 1 moving ahead
2438:34 - now we'll increment i so i becomes 3
2438:36 - and now we want to calculate the value at the third index
2438:49 - so we'll simply do the sum of its two preceding numbers with i minus 1 and i minus 2
2438:57 - so i minus 1 gives the second index value and i minus 2 gives the first index value
2439:04 - we'll do its sum which is 2 and we'll store 2 at the third index so value 2 is nothing but
2439:14 - the third fibonacci number moving ahead
2439:21 - now when we increment i by 1 i becomes 4
2439:28 - now we want to calculate the value of the fourth fibonacci number
2439:34 - which is stored at fourth index and this value can be obtained by doing the sum of its two
2439:40 - preceding numbers which is at index 2 and 3 which can be obtained by taking the value of the table
2439:48 - i minus 1 plus i minus 2 so i minus 1 gives the value at third index i minus 2 gives the value at
2439:58 - 4 minus 2 which is the second index so we'll do its sum 1 plus 2 becomes 3
2440:06 - we store 3 at the fourth index moving ahead
2440:15 - now we'll increment i by 1 so i becomes 5
2440:22 - and then we'll simply calculate the fifth fibonacci number
2440:25 - by doing the sum of its two preceding numbers
2440:32 - which is nothing but i minus 1 which is 5 minus 1 equal to 4 the fourth index
2440:41 - and i minus 2 which is 5 minus 2 which is 3 and that is nothing but values stored at third index
2440:51 - so we'll do the sum of these two values which is 2 plus 3 equal to 5
2440:57 - and we'll store the 5 at the fifth index
2441:05 - and now we'll increment i again so i becomes 6 but here you can see that 6 is not less than equal
2441:13 - to 5 therefore the condition in for loop comes out to be false and for loop terminates
2441:21 - so friends we simply return the values stored at fifth index which is nothing but
2441:29 - our fifth fibonacci number which is 5
2441:37 - so friends here you can see that in our previous lecture we used recursion to solve the nth fibonacci
2441:44 - number problem and we saw the solution was very less efficient because we recalculated
2441:51 - the values of the sub problems again and again so here what we did we simply created a table
2441:59 - to store the results of the sub problems and when we wanted to use the values of the sub problems
2442:06 - again we simply referred this table use those solution and build up upon the solution to the
2442:13 - main problem so here we started from the bottom which is from the 0th index and the first index
2442:22 - and as we knew that a first two number of fibonacci series are 0 and 1
2442:27 - we simply used those two values to come up with the second fibonacci number
2442:33 - then we used the first fibonacci number and the second fibonacci number we did it sum
2442:39 - we got the value of the third fibonacci number and similarly we got the value of fifth fibonacci
2442:46 - number so friends here you can see that using this tabulation method we are storing the results of
2442:53 - the sub problems and we are not recalculating the values of those sub problems we are simply
2442:59 - referring to this array we are taking out the values and we are simply using to build up upon
2443:06 - the solution to the main problem so this is the bottom up approach to solve the problem of
2443:14 - calculating the nth fibonacci numbers so friends now let's go to eclipse and see the demonstration
2443:20 - of this code i hope you like this video thanks have a nice day
2443:25 - hello everyone so friends in this lecture we'll see how we can code a program to find
2443:38 - the nth fibonacci number using dynamic programming and in this lecture we will use the bottom up
2443:44 - approach so friends in our previous lecture we saw the algorithm of how to find the nth fibonacci
2443:51 - number using the bottom up approach we saw its animation and here in eclipse we'll actually
2443:58 - code the algorithm and using this main method we'll see it's working so here we'll create one
2444:07 - method as public which will return us back the nth fibonacci number so int will give the method
2444:16 - fib which will take the value of n for which we want to find the fibonacci number
2444:25 - so friends for the positive values of n we need to return the nth fibonacci number from this method
2444:33 - and as we are discussing the bottom up approach using dynamic programming we noted this approach
2444:40 - is nothing but the tabulation approach where we create the table and store the results of the
2444:45 - sub problems and when those sub problems comes again into picture instead of recalculating them
2444:52 - we simply reuse the values stored in the table so here we'll create an array
2445:01 - we'll give it a name as table
2445:03 - and the size of the array would be n plus one because as i erase index from zero
2445:14 - and we are using this table to store the individual fibonacci number so in order to get the
2445:21 - nth fibonacci number we need to create a table which can store n plus one items so that it will
2445:29 - start from zero to n and at the nth index we will have our nth fibonacci number
2445:42 - also friends what we discussed in our previous lectures
2445:45 - that the first two numbers of the fibonacci series are nothing but zero and one
2445:49 - so table at the zeroth index will have value as zero
2446:02 - and table at the first index will have value as one
2446:10 - and also friends we discussed that in fibonacci series if you want to know the current number
2446:17 - you just need to do the sum of its two previous numbers
2446:21 - so here we have these first two numbers if we do sum of these two numbers we'll get the second
2446:27 - number and similarly using this approach we can come to know that what is the nth number
2446:36 - so we are simply storing the fibonacci numbers in this table array so we have used the zeroth index
2446:42 - and one index so now we'll start from the second index we are starting from the second index
2447:02 - and as here you can see the table as size of n plus one
2447:07 - so we'll provide a boolean condition here that if i is less than equal to n
2447:12 - just iterate this for loop we'll do i plus plus
2447:19 - so friends here you can see the advantage of creating a table array
2447:24 - what we can do is simply
2447:30 - let's say if we want to calculate the ith fibonacci number
2447:34 - we simply do the sum of its two previous numbers
2447:51 - and whatever the value is computed from this
2447:54 - equation we simply store it into the table as ith index so thus this table helps us in
2448:01 - computing the nth fibonacci number from the bottom which is from the zeroth index
2448:09 - to the nth index so we have these first two values as index zero and one the second value is computed
2448:16 - by adding this value and this value which is i minus one and i minus two and storing it into
2448:24 - the second index and similarly the third index will be calculated by
2448:30 - adding the value at second index and the first index so this loop keeps on going ahead and
2448:36 - ahead taking previous two values doing their sum and storing it into the current ith position
2448:44 - and finally when this loop terminates the final value will be stored in the table
2448:49 - at the nth index
2448:55 - which we also saw in our previous lecture using the animation so we'll simply return that value
2449:08 - so here first we'll create the object of fibonacci number class
2449:19 - we'll provide a shout to print the nth fibonacci number
2449:29 - let's say we want to print the sixth fibonacci number
2449:41 - we simply call
2449:42 - the method fib
2449:51 - we'll pass the value of six
2449:56 - and now we'll simply run the program
2450:05 - so here you can see the sixth fibonacci number is eight
2450:07 - so which is something like this that series starts from zero one and then the rest of the
2450:17 - values are calculated by using the sum of its two previous numbers so zero plus one gives one
2450:24 - one plus one give two two plus one gives three three plus two gives five
2450:32 - and three plus five gives eight so the sixth fibonacci number which comes out is eight
2450:44 - so friend this was the demonstration of code to find the nth fibonacci number
2450:50 - using dynamic programming with a tabulation method which is nothing but bottom-up approach
2450:58 - i hope you like this video thanks have a nice day
2451:02 - hello everyone so friend in this lecture we will discuss about the top-down approach
2451:14 - so in our previous lecture we saw that how we can solve a problem using dynamic programming
2451:20 - with a bottom-up approach and in this lecture we'll see that how we can solve a problem using
2451:26 - top-down approach so what is top-down approach
2451:33 - so this method is also called as memoization so what it means is
2451:40 - that in this method we break the large problem into multiple sub problems
2451:46 - each of the sub problems are solved and solutions are remembered so by remembering the solutions
2451:53 - we treat it as a memorization and the term given to it as memoization
2452:00 - which means that something we are remembering to reuse it later
2452:06 - so how does it work is if the sub problem is solved already we simply reuse the answer
2452:13 - so here you can see that we are solving the sub problems and its solutions are remembered
2452:19 - so later point of time if that sub problem comes again into picture
2452:24 - we simply reuse the remembered answer or else what we do is we simply solve the sub problem
2452:31 - and store the result which simply means that we are remembering the solution somewhere
2452:39 - thus it memorizes the solution of the sub problem to avoid the recomputing
2452:44 - the value of sub problem is encountered again so friends in our previous lecture we also saw that
2452:50 - when we are doing recursion we can solve the problems by breaking it down into multiple sub
2452:55 - problems and if those sub problems are encountered again then instead of recalculating it again
2453:03 - we simply store the solution of that sub problem and when those sub problems are encountered again
2453:10 - we simply use those solutions rather than computing them again and again
2453:14 - thus it brings the optimization to our recursion so here we'll see a program
2453:22 - to find the nth Fibonacci number using top down approach
2453:28 - so here you can see this is the algorithm where we need to find the nth Fibonacci number
2453:34 - and here we are also passing an integer array which will simply help us in memorizing the
2453:39 - solutions of the sub problems and we will frequently check this integer array to see if
2453:46 - those sub problems are solved already or not so if those sub problems are not solved we proceed ahead
2453:52 - we solve those problems and we store it into this integer array and if the sub problems are solved
2453:59 - already we simply reuse the solution so this memo array help us in remembering the solutions
2454:06 - so that we can reuse those solutions if the same sub problem is encountered again
2454:12 - thus it provides the optimizations to our recursive solutions
2454:18 - so friend as this is the recursive solutions we will also see the demonstration using the call
2454:22 - stack so let's say we want to calculate the fifth Fibonacci number so we'll simply pass
2454:31 - an empty array with the sizes 5 plus 1 which is 6 because we know that the indexes of area are
2454:38 - starting from 0 and this memo table will store our Fibonacci numbers from 1 to 5
2454:47 - so the value stored at the fifth index will be our answer
2454:51 - so therefore we are creating an array of size 6
2454:54 - so in the first step it would look something like this
2455:00 - that we have an array of size 6 having the default value is 0
2455:09 - and on the call stack you will see the fib method has started its execution
2455:14 - with the value of an as 5 and with the integer array shown here having all the values as 0
2455:21 - so friends here you can see that as we are using the top down approach
2455:28 - we are starting from the fifth index which is the topmost index and then we are going to the bottom
2455:34 - in the bottom up approach we started from the zeroth index and we went till the fifth index
2455:40 - but here we are starting from fifth index and we are going to the bottom
2455:46 - so here we are simply checking if the value at fifth index is 0 or not
2455:51 - so here you can see the value of fifth index is 0
2455:55 - which in terms of this problem it is not solved
2455:59 - so the condition in if block comes out to be true and we need to calculate this value
2456:07 - so first we check whether the n is less than 2 or not
2456:10 - so here you can see the value of n is 5 which is not less than 2 so the condition in if block
2456:16 - comes out to be false and the else part gets executed so here we also know that in order to
2456:25 - calculate the fifth Fibonacci number we need to do the sum of its two previous numbers which is
2456:32 - the number stored at third index and the fourth index so in order to do that we simply call the
2456:39 - fifth function again passing in the memo array and the value is n-1 because we need to calculate
2456:47 - this value and this value and then do the sum of these two values to get this value
2456:54 - so here you can see that now this fifth function is called recursively
2456:59 - and we are leaving this fifth function on the call stack line number 6
2457:05 - so we'll simply add the line number 6 here so the later we can come to know that from which point
2457:10 - we need to restart this fifth function
2457:20 - so we have left this function and on the call stack there will be one more fifth function
2457:25 - with this memo array and the value of n is 4 because we are passing n-1 so 5-1 gives 4
2457:36 - so this function will be executed with n equal to 4 we check that whether value of fourth index
2457:44 - is computed or not so we know that is equal to 0 therefore it's not computed so then we go ahead
2457:51 - so then we go ahead and compute it 4 is not less than 2 so the condition in block comes out to be
2457:58 - false and now in the else block if you want to compute the value at fourth index
2458:06 - we need to compute the value at second and third index do their sum and get the value at fourth
2458:12 - index so friends here you can see that first we will need to calculate the value at third index
2458:20 - so we'll again call the fifth function passing in the array and the value as
2458:26 - n-1 which is 4-1 equal to 3 and we also know that we have to leave this fifth function
2458:35 - at line number 6 so we'll simply store the line number here
2458:41 - and then the fifth function will be called again and on the call stack you can see we have left
2458:48 - this fifth function and we have started executing this fifth function with the value of n as 3
2458:57 - we check whether the value of 3 is computed or not
2459:01 - so you can see the value of n is equal to 0 therefore it's not computed
2459:08 - we check whether n is less than 2 or not so 3 is not less than 2
2459:12 - and here in order to calculate the value of the third Fibonacci number
2459:20 - we need to first calculate the values of its two preceding numbers
2459:24 - so we again call the fifth function passing it the integer array and the value as 3-1 which is 2
2459:34 - and we are leaving this function at line number 6
2459:37 - so the fifth function will be called again with the value of n as 2
2459:46 - so on the call stack there will be another fifth function with the value as 2
2459:54 - we will see the value at second index is computed or not
2459:58 - so here it is equal to 0 therefore it's not computed
2460:01 - we check whether 2 is less than 2 or not so 2 is not less than 2
2460:10 - so we'll start executing the else part and here also in order to calculate the value at second
2460:16 - index we need to first calculate the value of its two preceding numbers do their sum and get the
2460:25 - value of second index so first we'll go to the n minus 1 part which is 2 minus 1 which is equal
2460:33 - to 1 so here now fifth function will be called again so we are leaving this fifth function at
2460:39 - line number 6 so we'll store the line number here and then fifth function will be called again with
2460:48 - the value of n as 1 so on the call stack it would look something like this
2460:58 - we see that value at first index is computed or not
2461:02 - so here you can see it is equal to 0 therefore it's not computed and we proceed ahead
2461:10 - now we check whether n is less than 2 or not so you can see the n is less than 2
2461:15 - because the value of n is 1 so friends here you can see that why we have provided is if block
2461:22 - so we know that the Fibonacci series starts from 0 and 1
2461:27 - so we are simply checking that whether n is less than 2 or not if it is less than 2
2461:34 - we are simply storing the value of n to the memo of n so here value of n is 1
2461:43 - so at the first index we are storing the value as 1
2461:47 - so it would look something like this so 1 is stored at 1th position so after this step
2461:57 - finally we return the value stored at first index
2462:03 - so friends here you can see that why we are returning this value 1 here because
2462:07 - we called this fib function from this fib function and we left at line number 6
2462:15 - so at line number 6 we had to calculate the value of 1 and then we have to calculate the value of
2462:21 - n-2 and then do the sum of these two values to get the value at second index
2462:28 - so therefore we have calculated the fib of n-1 which is 1 so we are simply returning the value 1
2462:37 - from this fib function to this fib function so it would look something like this
2462:44 - this fib function will be removed from the call stack
2462:48 - and the call will go to this fib function and we also know that we had left at line number 6
2462:54 - so we'll start executing from the line number 6
2462:59 - and whatever we return from this method will be stored in the left which is nothing but 1
2463:07 - so moving ahead
2463:12 - now here you can see that when we are executing this fib function the value of n is 2
2463:16 - we have computed one of its previous value which is n-1 and now we have to find the value n-2
2463:24 - so that we can do the sum of these two values and get the value at the second index
2463:30 - so therefore now we'll again call the fib function to calculate the n-2th value
2463:34 - so here you can see that now we are again calling fib function and we are leaving this fib function
2463:41 - at line number 7 so we'll simply update the line number 7 so that we can come to know the letter
2463:46 - that at which line we left this function so we updated the line number
2463:56 - and now this fib function will be called with the value as n-2 which is 2-2 which is equal to 0
2464:05 - so it is called for fib of 0
2464:12 - and here we check if the value at 0th index is computed or not
2464:15 - so it is equal to 0 therefore it's not computed
2464:20 - we check whether n is less than 2 or not so 0 is less than 2 therefore condition if block comes
2464:26 - out to be true and finally we'll store the value of n which is 0 to this memo table at index 0
2464:39 - so here at index 0 we'll simply storing the value as 0 because we know that the fibonacci series
2464:47 - starts from 0 and 1 so if the value of n is less than 2 we simply store that value into its index
2464:57 - so now we'll simply return this value because we need to get this value here
2465:05 - so this fib function will be removed from the call stack and 0 will be returned from here
2465:15 - and we know that we had left at line number 7 so we'll start executing from the line number 7
2465:20 - and this fib function has returned a value 0 so we'll store that value in the right
2465:31 - so 0 will be stored at the right
2465:35 - so for now you can see that in order to calculate the second fibonacci number
2465:42 - we need to do the sum of its two previous numbers so we have got the sum of its two
2465:48 - previous number as 1 and 0 we'll do the sum of it and we'll store at the second index
2465:55 - so 1 plus 0 is 1 so we'll simply store the value 1 here
2466:03 - and then from this fib function we'll simply return the value stored at second index
2466:09 - because value of n is 2 which is nothing but 1 so 1 will be returned from this method
2466:15 - and this method will be removed from the call stack
2466:22 - and now we'll start executing this fib function and we know that we had left at line number 6
2466:30 - so we'll start executing from the line number 6 and we also know that we had returned the value 1
2466:36 - from this fib function so 1 will be stored in the left integer variable
2466:45 - moving ahead now we have calculated the n minus 1th value which is this
2466:54 - and we need to calculate the n minus 2th value which is this in order to get the third fibonacci
2467:02 - number because value of n is 3 so we have computed one value we need to compute the other value
2467:09 - so here the fib function will be called again with the value as n minus 2
2467:14 - which is 3 minus 2 which is 1 and we know that we are leaving this fib function in line number 7
2467:23 - so we'll simply update the line number 7 here
2467:31 - so the fib function will be called again with the value of n as 1
2467:38 - here now we have to calculate the value of the first fibonacci number
2467:42 - so now you can see the advantage of using this memo table
2467:47 - we are checking that whether value at first index has been calculated or not
2467:54 - so this sub problem has been encountered again because we have already calculated
2467:59 - the value at first index which is 1 so by providing this simple check
2468:06 - that whether the memo of n is equal to 0 or not
2468:10 - so we have already calculated this value so we don't have to recalculate it again here or here
2468:18 - so therefore storing this result of the sub problems gives us an optimization over the recursion
2468:25 - here so instead of calculating it again here we are simply returning the value stored at the first
2468:31 - index so we are simply returning memo of 1 which is 1 so this fib function will return the value as 1
2468:46 - and we know that we had left and line number 7 so we'll start executing from this line
2468:52 - and as the return value is 1 the value stored in right would be 1
2468:57 - and finally we can come to know the third fibonacci number by simply doing the sum of
2469:08 - its two preceding values which is 1 and 1 and we'll simply store that value at the third index
2469:17 - so 1 plus 1 is 2 so we'll simply store the value 2 at the third index we move ahead
2469:27 - and we'll simply return the value 2 from this fib function
2469:35 - so this method will be removed from the call stack
2469:40 - and it will go to its previous fib function which we had left at line number 6 so we'll start
2469:46 - executing from the line number 6 and we know that we had returned the value of 2 from this fib
2469:53 - function so it will store in the left
2470:02 - and now we'll simply calculate the fib of n minus 2 to get the value of the right part
2470:11 - so on the call stack we are leaving this fib function at line number 7 so we'll update the
2470:15 - line number 7 this fib function will be called again and on the call stack
2470:25 - we will call fib with the value as 4 minus 4 minus 2 which is 2
2470:33 - moving ahead we'll simply check in this table that whether this sub problem which is fib of
2470:40 - 2 has been solved or not so we are simply checking this memo table and we are simply
2470:45 - checking at the second index whether the value is 0 or not so here you can see we have already
2470:52 - solved this problem and stored its result therefore we don't have to recalculate it again
2470:58 - so we are simply returning the value stored at the second index which is 1
2471:02 - and we are returning the value 1 from this fib function to this fib function
2471:14 - and as we know that we had left this fib function in line number 7
2471:17 - we'll start executing from the line number 7 and then we'll simply store the value
2471:23 - return from this function which is 1 into the right variable
2471:32 - finally we do sum of these two numbers and we'll store it in the fourth index
2471:40 - because in order to calculate the fourth fibonacci number we need to do the sum of
2471:45 - its two preceding numbers which is at index 2 and 3 stored in left and right
2471:51 - so 2 plus 1 gives 3 so we'll simply store 3 at the fourth index and finally we'll return
2472:02 - the value 3 from this fib function to this fib function
2472:11 - and we also know that we had left this fib function line number 6
2472:16 - so we'll start executing from the line number 6
2472:21 - we return the value 3 from this fib function we'll simply store it
2472:27 - into the left integer variable 3
2472:34 - and now in order to calculate the fifth fibonacci number which is our actual main problem
2472:41 - we had calculated one of its preceding value which is n minus 1 here we just need to calculate
2472:49 - n minus 2 value this value and then we can do the sum of its two values and get the solution
2472:56 - to our main problem so here we'll again call fib function passing in a value n minus 2
2473:06 - which is 5 minus 2 equal to 3 and we are leaving this fib function at line number 7 now
2473:14 - so we'll update the line number 7
2473:19 - so this fib function we'll call with the n as 3
2473:26 - and friends here you can see the advantage of this memo table
2473:31 - that we have already calculated the third fibonacci number because value stored at third index is not
2473:38 - equal to zero therefore we don't have to recalculate it again and again using this code
2473:44 - so finally we'll return the value stored at the third index which is 2
2473:52 - and we'll simply return from this method and go to its previous method
2474:01 - and we know that we had left at line number 7 so we'll start executing from the line number 7
2474:05 - and as 2 is returned from this fifth call we'll simply store it into the right integer variable
2474:19 - and then as we want to calculate the fifth fibonacci number
2474:23 - we got the fourth fibonacci number and the third fibonacci number stored in left and right
2474:29 - we'll do its sum and we'll store at the fifth index so 3 plus 2 gives us 5
2474:39 - so 5 is stored at the fifth index
2474:43 - and finally from this fib function we'll return the value stored at the fifth index
2474:51 - which is our actual answer the fifth fibonacci number has the value of 5
2474:59 - so we are simply returning the value 5 and this method will be removed from the call stack
2475:06 - and hence our problem is solved so friends here you can see that we started from the top
2475:12 - we moved to the bottom therefore it's top down approach and we also know that we have used this
2475:19 - memo array which helps us in memorizing the solutions of the sub problems so that those
2475:26 - sub problems when encountered again are not recalculated again so we are simply storing
2475:32 - those sub problems result here and when those sub problems are encountered again we don't have
2475:38 - to compute it again we simply take that value from this memo table and reuse it again therefore
2475:45 - using this memo table to our normal recursion we are providing an optimization and we also know
2475:54 - that dynamic programming is nothing but the optimization to our recursive problems
2476:02 - so friend in this lecture we saw the top down approach of dynamic programming that how we can
2476:08 - use that approach and solve a complex recursive problems efficiently now let's go to eclipse and
2476:14 - see the demonstration of this algorithm i hope you like this video thanks have a nice day
2476:26 - hello everyone so friends in our previous lecture we saw the animation for the top down approach
2476:36 - that how we can solve the problem related to finding the fibonacci number
2476:40 - using dynamic programming by top down approach
2476:45 - so in this lecture we'll code the algorithm to find the nth fibonacci number using top down
2476:51 - approach so here in eclipse you can see that few lectures back we saw the bottom up approach
2477:01 - and this approach is also a method in dynamic programming so in this lecture we'll see
2477:07 - the top down approach
2477:12 - so first we'll create a method which will return us back the nth fibonacci number
2477:19 - which is an integer and let's say the name of the method is fib
2477:26 - now as we discussed in our last lecture that to this fib function
2477:30 - we pass in a memo array which help us in storing the solutions to the sub problems
2477:39 - and when the sub problems are encountered again instead of recalculating it we just go to this
2477:45 - integer array into that particular index we pick up that value and reuse it
2477:53 - thus this integer array helps us in optimizing the recursion solutions
2478:00 - so this method also takes the value of n for which we want to find the fibonacci number
2478:10 - so friends in order to find the nth fibonacci number what we simply do is we simply first check
2478:15 - whether the mem of n is equal to zero or not so what it means that we are using this array
2478:30 - to store the fibonacci series and as you want to calculate the nth fibonacci number
2478:36 - we simply check that this array at index n is equal to zero or not so if it is equal to zero
2478:44 - we come to know that the nth fibonacci number has to be calculated so inside is if condition
2478:55 - we provide a if block where the condition is
2479:00 - if n is less than two then what we do is
2479:08 - we simply assign the value of n to the integer array at the index n
2479:14 - so why we do this because we know that the first two numbers of fibonacci series are zero
2479:21 - and one and as the array starts from zeroth index so this value will be stored at zeroth
2479:27 - index and this will be stored at the first index so we simply check whether n is less than
2479:32 - two or not so if value of n is zero then zero is stored at zeroth index and if the value of
2479:39 - n is one then one is stored at the first index and if n is not less than two then in the else
2479:48 - part what we do is so here we know that the fibonacci series has property the current number
2480:02 - is sum of its preceding two numbers
2480:10 - so based on these two properties what we come to know that if we want to calculate the nth
2480:15 - fibonacci number we need to know its two preceding numbers which is n minus one and n minus two
2480:23 - we do its sum and we get the current number so here let's say current number which you
2480:29 - want to calculate is nth number so what we do is
2480:35 - we first calculate
2480:40 - the fib of n minus one
2480:46 - so we call this fib function recursively which we also discussed in our
2480:52 - previous lecture so whatever the value it returns we store in the left
2480:58 - and then we again call the fib passing in the memo array and pass in n minus two
2481:14 - because if you want to calculate the nth fibonacci number
2481:17 - we need to know the n minus 1th fibonacci number and n minus 2th fibonacci number
2481:25 - and once we know these two values we can do their sum which is left plus right
2481:35 - and as we know left plus right we simply store this value at the nth index
2481:45 - because we know that this integer array basically stores the fibonacci numbers
2481:52 - and as we want to calculate the nth fibonacci number
2481:56 - we simply store the left plus right at the index n and finally we return
2482:07 - the answer which is the value stored at the nth index
2482:12 - so friends here you can see that this line is very much important because
2482:20 - because this line checks that whether the sub problem is solved again or not
2482:26 - so here what we do is if the mem of n is equal to zero
2482:31 - we come to know that the value of nth index has not been solved
2482:35 - so what we do is we go into a block and we calculate the value of nth index
2482:42 - and we simply store it here and what if the mem of n is not equal to zero then we know that
2482:49 - we have already solved this problem so then we simply return the value stored at the nth index
2482:56 - also friends in our previous lecture we saw the animation that how this line helps us in
2483:01 - optimizing the recursion so that we don't have to solve the sub problems again and again
2483:08 - and as we start from the value of n and then we slowly go to the bottom by doing n minus 1
2483:18 - n minus 2 and then again recursively moving down therefore this approach is also known as top down
2483:25 - approach because we start from the top and then go to the bottom and as we go to the bottom
2483:32 - we encounter these base cases where the first two values we store as 0 and 1
2483:39 - and after getting these two values we build up upon the solution
2483:43 - and finally we get the nth Fibonacci number so friend now let's see the demonstration
2483:51 - of this code in the main method so first we initialize the Fibonacci number class
2483:58 - and let's say we want to find the 6 Fibonacci number so here the value of n would be 6
2484:08 - and as we are calling this fifth function we need to pass an empty array whose size would be n plus
2484:14 - 1 which is 7 because we want to store the Fibonacci numbers from 0 to 6 and finally we need to return
2484:24 - the value of index 6 so as we are going from 0 to 6 we need to initialize the array of size 7
2484:34 - so we simply pass an empty array of size
2484:40 - 6 plus 1 and if i run this code now
2484:57 - so we get the answer as 8 because here you can see that in the array it will be stored
2485:03 - in this format 0 1 would be the starting values then we do the sum of these two values we get
2485:10 - this value then we do sum of 1 plus 1 we get 2 then 2 plus 1 we get 3 3 plus 2 we get 5
2485:19 - 5 plus 3 we get 8 so friend this is how we can use dynamic programming to solve this problem
2485:27 - to find the nth Fibonacci number and using this top-down approach we have solved this problem
2485:34 - very efficiently and whatever the solution we get is highly optimized
2485:43 - so friends i hope you like this video and in case you have any problem you can watch my previous
2485:48 - lecture where we go through this code step by step using the animation and in our next lecture
2485:55 - we see different problems associated with the dynamic programming thanks have a nice day
2486:04 - hello everyone so in this video we will be looking into a problem maximum sum sub array
2486:11 - and we will be looking into a specific algorithm which was provided by cadence to solve this
2486:17 - problem so before we start in case if you are new to my channel then please subscribe to my channel
2486:26 - and click the bell icon so that you never miss any update so here in this problem we are given
2486:32 - with an array with some random elements and it can have negative elements as well
2486:39 - we name it usually maximum sub array sum so here in this problem what we actually do is
2486:52 - we try to find any sub array such that if we do the sum of the elements of that sub array
2487:01 - and whichever is the maximum sum we simply find that out so for example let's say if i take these
2487:09 - two elements so a sub array is actually a smaller piece of array of the bigger array and the
2487:17 - elements are contiguous so if we do sum of these two elements we will get seven
2487:25 - so this is one such sub array one property of sub array is that it should be contiguous
2487:33 - so for example two we can't take two four five do their sum and find the maximum sum
2487:42 - because three is missing so a sub array is actually a smaller array which is contiguous
2487:51 - so here we saw that one of the sub array has sum to be seven now there can be multiple sub arrays
2488:00 - so we need to find the maximum sum of any particular sub array and we simply want to return that
2488:08 - sum so here you can see if we take this sub array four three minus two and six
2488:16 - we will get four plus three minus two plus six so it will give us eleven so this is one such sum
2488:26 - so we try to find that whether this array has any other sub array whose sum is maximum or not
2488:34 - so here if you see if we take these three elements seven plus minus one plus six so it
2488:41 - will give us twelve so it means we can discard this sum and this would be our answer so twelve is the
2488:51 - maximum sum of any sub array so in order to find such sum the brute force way would be
2488:59 - that we try to create each and every sub array we do their sum and we see which is the maximum
2489:06 - sum so usually this approach is not good so there is one such algorithm which was provided by
2489:12 - cadence which actually traverse this array once and figures out what is the maximum sum sub array
2489:21 - so here how we actually solve this problem is we usually create two variables current max
2489:35 - and the best sum or maximum so far now what this two variables denote we'll see later
2489:43 - and this algorithm we try to traverse from left to right so at the start we encounter four
2489:51 - now what we do here is let's say if our array had only one element four
2489:56 - so the maximum sum would have been four only and we would have returned from this array
2490:02 - saying that four is the max sum
2490:06 - so here you can see we will be traversing this array one element at a time and let's say at
2490:12 - this index for example we will be storing two things current max and the max so far
2490:21 - so what these two variables denote is that at index three what is the current max sum
2490:28 - and as we have traversed this array we would have encountered many sub arrays
2490:34 - so among those sub arrays which what's the max so far or what's the best sum so these two things
2490:40 - we keep track while traversing from left to right also when we traverse the elements one by one
2490:52 - at each element the element usually asks two questions that should I become part of the
2490:58 - current sub array which will give us the maximum sum or should I start my new sub array
2491:06 - so here we look into the demonstration and what these two questions actually mean
2491:11 - so here if you see at the start we encounter four at index zero so four will ask that should I
2491:19 - become part of the current sub array so here if you see current sub array is empty because there
2491:24 - are no element as this is the first element only should I become part of the current sub array so
2491:30 - that sum is maximum so at the start both these questions as there is only single element both
2491:38 - this question correspond to the same thing if four becomes part of the current sub array it would be
2491:44 - something like this or if four starts a new sub array it would be something like this
2491:50 - so usually at the start the current max is four and it has been formed by this sub array
2492:02 - and we simply take four as the max so far being formed by this sub array now we'll go to the
2492:12 - first index so at this index three will decide should I become part of the current sub array
2492:18 - so here if you see current sub array is four so if it becomes part of the current sub array
2492:24 - so sub array will become four three and sum will become seven or it will decide it should
2492:31 - I start a new sub array so if it decides new sub array sum will become three so among these
2492:39 - two questions three will see that it's better to become the part of the current sub array because
2492:47 - we are getting a maximum sum among these two sums so three will become part of the current
2492:54 - sub array so the sub array will go something like this these two elements are there and the current
2493:04 - max at this point would be seven which is being formed by four and three so here you can see now
2493:13 - this max so far this seven is greater than four so this max so far will be updated to seven
2493:26 - stating that it has been formed from the elements four and three moving ahead
2493:34 - now we encounter minus two
2493:38 - I'll just remove this
2493:43 - so minus two will think should I become part of the current sub array so if it becomes part of the current sub array
2493:53 - the sum would be seven because seven is the sum of the current sub array
2494:00 - plus minus two which will give it a value as five or it will decide should I start a new sub array
2494:09 - so if it starts a new sub array the sum will become minus two
2494:13 - because we will be discarding this sub array if we are starting a new sub array from here
2494:21 - so minus two sees that okay if I become part of the current sub array the sum will be five
2494:26 - and if I start my own we get minus two so it's better to go with the current sub array
2494:34 - and get the sum of five so here at this position the sum will become five
2494:44 - it has been formed by four three and minus two and this five is actually smaller than
2494:53 - seven so max so far will remain this only
2494:56 - it means that though we have taken up minus two into this sub array but the sum
2495:11 - is not actually greater than the maximum sum so far or the best sum so the best sum will actually
2495:17 - remain this so let's say if we had only this three elements in the array so the current max would
2495:23 - have been five and our answer would have been seven stating that we usually take four and three
2495:30 - and we will get the max sum we will discard minus two from the best sum and also here one
2495:37 - question arises why we are taking minus two into the consideration here why we are actually adding
2495:43 - minus two because because there could be a possibility let's say the current number here
2495:49 - is six so there could be possibility here number is thousand if we don't take minus two
2495:57 - then our current sub array will start from this because the sub array is contiguous
2496:04 - and if you are not taking any element it means we are discarding the previous sub array
2496:09 - so the sum would have become a thousand if we have not included minus two and now
2496:16 - if we include minus two so here we can see the sum came out to be five and let's suppose here
2496:24 - would have been thousand so we would have included thousand also and got one zero zero five so which
2496:31 - is much way better than thousand therefore we simply include minus two based on these two
2496:37 - questions because we are not sure what comes after this minus two it could be any negative
2496:43 - value or it could have been any maximum value so it's better to include minus two into this sub array
2496:58 - so now our sub array reaches like this that it has included everything four three and minus two
2497:09 - i will remove this
2497:14 - so now we encounter six
2497:19 - so here six will decide that okay should i become part of the current sub array
2497:27 - so if it becomes part of the current sub array so the sum will become five
2497:31 - because the sum is five plus six which will give us eleven or it decided should i start a new sub
2497:40 - array so if it discards this previous sub array and starts a new sub array from here
2497:47 - so the sum will be six only so the element six will decide okay i will go with the
2497:53 - current sub array because this gives the maximum sum
2498:01 - so here the current max will become 11
2498:11 - which will be the addition of these four elements of the sub array so now here you can see
2498:17 - that this 11 actually beats seven so max so far will take the maximum sum as 11 because it will
2498:24 - figure out that okay now i need to include four three minus two and six together because this is
2498:33 - giving me a maximum sum moving ahead we will remove this so now six has become part of our
2498:42 - sub array now we encounter minus 12 so minus 12 will decide should i become part of current sub
2498:51 - array so the current sub array is this so 11 plus minus 12 will give us minus one or it decides
2499:05 - should i start my new sub array so if it starts its new sub array the sum would be minus 12
2499:11 - so minus 12 sees that okay minus one is greater than minus 12 so it's better i should become
2499:19 - part of the current sub array so here now our current max become minus one being formed
2499:32 - like this but this minus one is very much less than 11 so max so far will remain the same
2499:41 - but let's suppose if our array would have ended here so the answer would have been 11
2499:53 - which has been formed from the elements four three minus two and six so this is the significance of
2500:00 - max so far it keeps the track of the maximum sum of any sub array so far
2500:07 - so i'll just simply remove this
2500:16 - and here minus 12 comes with the current sub array now we encounter seven so seven
2500:25 - will ask should i become part of the current sub array so it sees the current sub array is this
2500:31 - and its sum is minus one so minus one plus seven will give us six or it decides should
2500:39 - i start my own new sub array so if it started its own new sub array it has to discard this
2500:44 - sub array and if it starts a new sub array from here like this so the sum will be seven
2500:52 - so this element thinks that okay i should not go with the current sub array because it is giving
2500:58 - a sum only six but if i start my own it will be a maximum sum of seven so here is the critical step
2501:07 - where the current element decides that okay i won't go with the current sub array i will
2501:13 - start my own sub array which is a new sub array so here we simply discard this sub array
2501:21 - because current max will now be seven and it will be formed by only digit seven
2501:33 - but this seven is less than 11 so the max so far will remain the same
2501:47 - so now this sub array
2501:52 - is actually discarded and a new sub array will start from seven
2502:01 - so now we encounter minus one so minus one decides that okay should i become part of
2502:06 - the current sub array so seven plus minus one will give six or should i start my own sub array
2502:17 - so the sum will be minus one if it starts its own sub array so it decides that okay i will
2502:24 - be part of the current sub array because it is giving me a maximum sum so here now our current
2502:31 - max will become six because minus one has decided to go with the current sub array
2502:37 - seven comma minus one okay but this six is less than eleven so our max so far will still remain
2502:49 - the same moving ahead
2502:56 - so now our sub array has two elements seven and minus one so now the last element comes
2503:09 - which is six so six asks should i become part of current sub array so six
2503:16 - plus this six will give sum is 12 or should i start a new sub array so if it starts a new sub array
2503:28 - the sum will be six so this six decides is okay i will go with the current sub array because
2503:34 - it is giving me a maximum sum if i compare these two values so here now current sum will become 12
2503:41 - 7 minus 1 6
2503:51 - so this will be included like this and now you can see 12 is actually greater than the max sum
2503:58 - so far so max so far will see that okay i need to now discard this because we have found one more
2504:06 - sub array whose sum is actually maximum from the current max so far which is 12
2504:15 - formed by seven minus one and six and here there are no more elements left
2504:25 - so the answer would be our max so far which is 12 so this will get written
2504:35 - so friend in this video we saw that how we can solve the maximum sum
2504:44 - sub array problem using
2504:49 - Carden's algorithm in our next video we will actually see the demonstration of the algorithm
2504:55 - step by step that how we can use the code and come up with this logic we will see it via an
2505:02 - animation in our upcoming video i hope you must have liked this video and in case if you are new
2505:08 - to my channel then please subscribe to my channel thanks have a nice day
2505:16 - hello everyone so in our previous video we discussed about the idea behind how the
2505:21 - Carden's algorithm work in finding the maximum sum sub array so in our previous video we actually
2505:28 - discussed the idea behind the algorithm we saw that how current max and max so far
2505:35 - are the best sum help us in determining the maximum sum sub array in this given array
2505:43 - and we also saw that we traverse the array and on each element the element decides that should
2505:49 - it be part of the current sub array or should it start a new sub array so now let's see the
2505:55 - demonstration of this algorithm step by step so here you can see that we have been provided with
2506:01 - an algorithm which is the Carden's algorithm so usually the method name is max sub array sum
2506:09 - it takes an integer array and finds us a maximum sum for any sub array in this array so let's see
2506:17 - the demonstration of this algorithm step by step so before we start in case if you're new to my
2506:23 - channel then please subscribe to my channel and click the bell icon so that you never miss any
2506:28 - update so at the start let's say we provide an array as what we discussed in our previous example
2506:40 - so usually at the start the first element is simply taken as max so far and the current max
2506:47 - so max so far is four this value and current max also becomes four now the algorithm basically
2507:00 - starts with second element so here i starts from one and goes till array dot length
2507:07 - so here array dot length is eight so i will travel from one to seven because seven is less than eight
2507:21 - now on this point three has two choices either it should become a part of the current sub array
2507:28 - so the current sub array is this
2507:30 - or it should start its new sub array so as we discussed in our previous slide what we do is
2507:42 - we take current max
2507:47 - and we add the value stored at the index of i and we assign it to the current max
2507:54 - so here we are simply taking the current element value and we are adding it with the current max
2508:01 - and assigning it to the current max so it means three decided to go with the four
2508:07 - it means four plus three will give us seven so seven is assigned to the current max
2508:15 - so current max becomes seven now why we directly assigned it because in the next step
2508:20 - this current max is actually compared with the with the elements value so this is our second
2508:27 - question that should i start my new sub array here this part was where element decides to go
2508:36 - with the current sub array and in this if block there is our second question that should i start
2508:44 - my new sub array so if current max is less than the value of the current element then we simply
2508:52 - assign this value to the current max so here seven is compared with three because array of i is
2509:03 - three so whichever is the bigger value is simply assigned to the current max
2509:08 - so seven is the bigger value among these two values
2509:15 - so current max remains the same so from here you can see that when element decides to be a part of
2509:22 - current sub array we simply add it to the current max and here we are simply assigning it to the
2509:28 - current max because in the next step we will reassign it if current max is less than the
2509:34 - current elements value which means that three has decided to create its own sub array so this is
2509:41 - actually our question one and this is actually question two so whichever wins that value is
2509:48 - assigned to the current max and if this condition comes out to be false then we do nothing with the
2509:55 - current because we have already assigned current max plus array of i to current max which is four
2510:02 - plus three equal to seven to current max so now this value is included in the sub array so the
2510:12 - current max is seven being formed from the sub array four comma three which is these two elements
2510:23 - and now we'll simply compare this sum current max sum with the maximum sum so far so if max so
2510:29 - far is less than current max we simply assign the current max value to the max so far because
2510:36 - current max actually beats the maximum sum so far so here max so far is four and current max is seven
2510:45 - so this condition comes out to be true and max so far becomes seven so here this is current max
2510:55 - and this is max so far so at the start
2511:02 - it was four then it became seven taking in four comma three
2511:09 - moving ahead now we'll increment i by one so i points to the second index
2511:16 - now this minus two has two questions that should i become part of the current sub array
2511:27 - so we simply take their sum current max plus array of i it means we are including array of i
2511:34 - so here it will become seven which is the current max plus minus two so seven
2511:40 - which will give us five so current max will become five
2511:50 - and then this element simply asked that okay can i start my own sub array
2511:55 - so this check actually decides that that if current max which is five
2512:01 - so if it is less than array of i value which is minus two
2512:04 - so array of i value is simply assigned to current max so currently so this condition
2512:11 - comes out to be false because five is greater than minus two
2512:17 - then we simply check whether max so far is less than current max or not
2512:21 - so why we are doing this check is we are simply keeping the track of the maximum sum so far
2512:27 - so if at any step current max becomes greater than max so far it means
2512:32 - we have found the maximum sum so far so we simply assign current max to max so far
2512:38 - so as of now max over is seven and current max is five
2512:43 - therefore this condition comes out to be four because seven is not less than five
2512:50 - so here the current max will become five taking in four three and minus two
2512:57 - so here the current max will be five and max so far will remain same
2513:05 - so now we'll increment i and here you can see this element has been included in the current max
2513:13 - sub array so friends here you can see as we know that each element
2513:20 - asks two questions whether it should become part of the current sub array by simply adding its
2513:26 - value to the current max or they decide to create their own sub array so this
2513:36 - piece of code decides that so you can also think this piece of code is something like
2513:42 - current max equals we can also write something as math dot max
2513:48 - and the two values would be current max plus array of i or array of i so whichever is the
2514:02 - maximum value we simply assign to the current max so this is question one and this is question two
2514:10 - that should have become part of the current sub array if that is maximum that value is assigned
2514:15 - to the current max or if element decides to create its own sub array so it's simply its
2514:23 - value is assigned to the current max so either we can do this or we can do this that first we
2514:30 - directly assign current max plus array of i value to current max and then with this if block we
2514:36 - reassign the array of i value to current max if the value at i th index is actually greater
2514:45 - than the current max so it means this value is greater than current max plus array of i
2514:51 - so this value will be assigned or else we have already assigned this value to current max here
2514:57 - so now value at i th index is six so we simply assign
2515:01 - 5
2515:09 - plus 6 which is 11 to current max so current max becomes 11
2515:17 - and then we simply decide that whether current max which is 11 is less than the value 6 or not
2515:24 - so if it is less than 6 then we simply reassign current max to the array value at i th index
2515:34 - so this condition comes out to be false because 11 is greater than 6
2515:39 - so here 11 is our current max
2515:48 - we have taken these four values
2515:49 - now we'll simply compare that whether the maximum sum so far
2515:57 - is less than current max or not so here you can see 7 is less than 11 it means
2516:05 - we found a new max so far so we simply update current max to max so far so it becomes 11
2516:13 - 4 3 minus 2 and 6 so it means we have found a sub array of maximum as 11 having these four
2516:27 - elements so now we'll continue with the rest of the elements we'll increment i so i will now point
2516:36 - to the fourth index so here array of i is minus 12 so here we are simply adding current max which
2516:49 - is 11 it will give us minus 1 so current max will become minus 1 and then this element will decide
2517:01 - that can i start my own sub array so it will compare its value which is this part with the
2517:07 - current max which is minus 1 so minus 1 is greater than minus 12 so this condition comes out to be
2517:15 - false and the current max which is minus 1
2517:31 - is actually less than max so far so this condition also will come out to be false
2517:38 - so max so far will remain 11 which makes sense because a sub array whose maximum sum is 11
2517:44 - is being found from these four elements so here we simply write 11 only 4 3 minus 2 and 6
2517:55 - moving ahead so here minus 12 has been included in the current sub array
2518:03 - i will now point to index 5
2518:05 - so current max will become minus 1 plus 7 which is 6
2518:22 - so this is the part when array of i decides to go with the current max and then it checks okay can
2518:30 - i start my own sub array because my own value is 7 but if i go with the current sub array
2518:40 - the current max is 6 so therefore it decides that it's better i create my own sub array because
2518:49 - if i create my own sub array i will give a sum of 7 and if i go with the current sub array
2518:56 - the sum will be 6 so therefore this condition decides that the current max is 6 and it is
2519:03 - actually less than 7 so the current max will become 7 by simply assigning array of i to current max
2519:14 - which signifies that 7 is decided to go and create its own new sub array
2519:19 - so current max becomes 7 so now this sub array will be removed
2519:31 - and from here a new sub array will start and here we'll simply denote 7
2519:39 - by taking in only 7 and this current max doesn't beats the max so far
2519:49 - so this condition comes out to be false now we'll go to the next element which is minus 1
2519:58 - so here minus 1 will be added to the current max
2520:14 - it will give 6
2520:18 - so current max will become 6 now
2520:20 - and now this minus 1 will see that if i become part of the current sub array which is this
2520:28 - i am getting sum as 6 if i start my own sub array i will get sum as minus 1 because
2520:37 - this is the only element so it sees that okay it's better to go with the current sub array
2520:44 - so this condition comes out to be false because current max which is 6
2520:48 - is actually greater than minus 1 so here now our current max is 6
2520:58 - taking in 7 and minus 1 together now this 6 doesn't beats the 11 so it remains the same
2521:07 - now we'll increment i so now i will point to the 7th index
2521:20 - and here this current sub array has included minus 1 with it
2521:24 - now we'll simply add the value 6 which is this value with the current max so 6 plus 6 is 12
2521:44 - so current max will become 12
2521:45 - and this 6 also checks that if i start a new sub array from here what's the sum
2521:56 - so this is the only element so sum is 6 so it doesn't beats the actual current max
2522:02 - so this 6 decides to go with the current sub array by adding itself to the current max
2522:10 - so this condition comes out to be false because current max is 12 and it is
2522:14 - greater than 6 so now this element is included in the current sub array
2522:24 - so the current max is 12 taking in 7 minus 1 and 6
2522:33 - and here you can see that this current max 12 actually beats the max so far so this condition
2522:41 - comes out to be true because max over is less than current max so it means we simply update
2522:46 - the max so far which is 12 so this value is assigned to the max so far stating that this
2522:57 - sum was made from this sub array it becomes 12
2523:07 - we'll increment i
2523:11 - so this for loop will exit because the value of i is 8 and 8 is not less than array.length
2523:21 - it is equal to array.length so it means we have traversed this array completely and at the last
2523:29 - we will simply return 12 because this is the maximum sum so far created by a sub array this
2523:37 - is 7 minus 1 and 6
2523:44 - so this 12 is returned
2523:47 - so from here we saw that there was one sub array
2523:53 - 4 3 minus 2 and 6 which actually gave the sum as 11 so this sub array was max so far
2524:02 - for most of the time and at the end this sub array whose total sum came out to be 12
2524:12 - became the max so far so 7 minus 1 and 6 which gave the sum as 12
2524:19 - was the maximum sub array sum which we finally returned from this method
2524:25 - so friend this is how the curtains algorithm work
2524:27 - so here one more question arises that why we are actually taking in
2524:32 - the negative values in the current max like we did here
2524:38 - we included minus 2 and the current max became 5 from 7 because here you can see
2524:47 - that current max value is 5 after including minus 2 if this value would have been let's say 1000
2524:57 - so in the next iteration if we have included 1000 we would have got
2525:04 - 1005 because we will be adding 5 to 1000 but if we would have discarded this value
2525:12 - so from this part a new sub array would have been started which only would have given 1000
2525:20 - so we are not sure what next element is coming up so therefore we have included minus 2 because
2525:26 - this value is less than this value so therefore we have included minus 2 also because we are not
2525:34 - sure what is coming up there could be a very large maximum value which would have raised this sum
2525:41 - to 1005 and if we would have discarded minus 2 so this sub array would have been ended here
2525:48 - and a new sub array would have started here which only could have given a sum as 1000
2525:54 - I hope you must have liked this video and in case if you are new to my channel then please subscribe
2526:00 - to my channel and click the bell icon so that you never miss any update thanks have a nice day
2526:10 - hello everyone so in our previous video we saw that how cadence algorithm help us in finding
2526:17 - the maximum sum of a sub array in a given array we saw the demonstration of the algorithm step by
2526:24 - step now in this video we will actually code the algorithm and will test its working in the main
2526:30 - method so if you want to understand the algorithm more you watch the previous videos to this where
2526:38 - the algorithm is being explained in a very detailed manner so let's see the code of the cadence
2526:44 - algorithm so before we start in case if you're new to my channel then please subscribe to my
2526:50 - channel and click the bell icon so that you never miss any update so here we will be creating one
2526:59 - method as public static we'll give it a name as max sub array sum so this method will take
2527:13 - in an array and will return the maximum sum of any sub array so its return type is integer
2527:25 - so here code wise this algorithm is simple but to actually understand the concept behind it
2527:31 - is very much complex and you can watch my previous videos to it to understand more
2527:37 - so in this algorithm we simply create two variables one is current max
2527:45 - and we simply assign the first value to it which is the value stored at 0th index
2527:54 - and the other variable is max so far we also assign it a value of what the first element is holding
2528:03 - so here we are assuming that array is at least one element so the algorithm basically starts
2528:13 - from second element from i equal to 1 and i goes from 1 to array dot length
2528:24 - so in our previous video we discussed that when we are encountering the current element
2528:34 - this current element basically ask two questions that should i be part of the current sub array
2528:41 - which is the current max or should i start my own sub array so these two questions basically
2528:49 - decides what will be the value of current max so at the start we simply assign
2529:00 - array of i to current max so this is the question one where the element
2529:10 - becomes part of current sub array
2529:19 - so here we have taken the sum of current max and the value of the array at i th index
2529:27 - so this satisfied question one and we simply assign it to current max so in the next step
2529:35 - we can't directly go with the current max value with this sum this element will also ask the
2529:43 - question that can i start my own sub array by taking my own value so here we simply compare
2529:52 - current max with array of i
2529:57 - so if array of i is greater than this current max so it means
2530:03 - that this element has started its own sub array because this value has been assigned to current max
2530:18 - so here this is the question two where element decides to start its own sub array
2530:34 - so after evaluating the current max what we do is
2530:42 - we compare it with max so far
2530:46 - so if this current max beats our max so far so we simply assign current max to max so far
2530:57 - so friends you can watch my previous video to understand more about this logic
2531:03 - that usually at each iteration we ask these two questions and based on these two questions
2531:10 - current max value is decided and if this current max value is greater than max so far
2531:15 - so we simply assign current max to max so far and at the end we simply return max so far
2531:24 - because after this value will terminate whatever the value max so far is holding
2531:31 - it decides the maximum sum of any sub array in this array so now let's test its working in the
2531:39 - main method so this is the array which we discussed in our previous video as well in the slide
2531:48 - here we'll simply call max sub array sum method we pass in the array
2531:54 - and if i run the main method
2532:03 - so here you can see it return the maximum sum as 12
2532:10 - so which is being formed by this sub array 7 minus 1 and 6 if we add
2532:16 - all of these three values we'll get sum as 12
2532:19 - so friend this was all about the cadence algorithm i hope you must have liked this video
2532:29 - in case if you're new to my channel then please subscribe to my channel
2532:33 - and click the bell icon so that you never miss any update thanks have a nice day
2532:42 - hello friends welcome to my new data structures and algorithm in java
2532:45 - tutorial series video friends in this tutorial we will discuss the famous twosome problem in java
2532:55 - so here the problem is something like we are given an array of integers
2533:00 - and we need to return the indices of the two numbers such that they add up to a specific target
2533:06 - so if we take an example then let's say we have this array of integers 2 11 5 10 7 8 and let's
2533:17 - say we are given a target as 9 so we need to return the indices of two numbers such that they
2533:24 - add up to this target so here the problem states that we need to find two such numbers into this
2533:31 - complete array which will add up to the target so if we take the above example then the solution
2533:38 - would be the element at 0th position is 2 and the element at 4th position which is 7 so they add up
2533:45 - to the target so we need to return the indices of it so we need to return 0 and 4 so 0 is the index
2533:52 - position for the number 2 and 4 is the index position for the number 7 so let's move ahead and
2533:59 - see the demo of the algorithm so friends let's say we are given the array of integers
2534:07 - and we are denoting it with the variable name as numbers so here the array elements are 2 11 5 10
2534:15 - 7 8 which we saw in the previous slide and below are the index position of it
2534:21 - and if you see the below is the algorithm for finding two such numbers which add to make a
2534:26 - specific target now let's say we are given a target as 9 and we want to find two such numbers
2534:34 - which add to make the number as 9 so we know that 2 and 7 make up to 9 so in order to find those
2534:41 - two numbers that below is the algorithm for it so let's quickly see the demo of it
2534:49 - so as we need to return the indices of it we will store it in the integer array of having two
2534:54 - elements so we need to return the indices of two such numbers so we'll store it into the result
2535:00 - array so it would be something like this so first we'll create a hash map we'll see what the
2535:11 - significance of this hash map is so here we are encountering a for loop which traverses the complete
2535:21 - array so in the first iteration i value is 0 and numbers dot length is 6 because we have
2535:29 - the six integers as 2 11 5 10 7 8 so we'll traverse this array from 0th index to 5th index
2535:39 - and currently for the first iteration i points to 0 so i would be pointing to the 0th index
2535:45 - of the numbers array so friends the basic idea behind this algorithm is like we will traverse
2535:55 - each element one by one and we'll store the element into hash map with its index value
2536:00 - so that on traversing this complete array we'll take a particular number we'll subtract it from
2536:06 - this target and we'll find that whether this contains in the map or not so instead of adding
2536:11 - these two numbers and making it to a target we'll just subtract that particular number from the
2536:15 - target and we'll look up into this hash map and we'll see whether that particular number is there
2536:21 - or not so let's see how it works so here if you see we have this target is 9 and we have this
2536:29 - number at ith position which is number at ith position is 2 so what we'll do we'll just check
2536:35 - whether the our map contains 9 minus 2 which is 7 into this hash map or not so currently
2536:45 - the map dot contains key will comes comes out to be false because the hash map is empty
2536:50 - and if you do a reverse of it then this condition in if statement comes out to be true
2536:55 - therefore what we'll do we'll just put the number at ith position along with its index
2537:08 - so moving ahead
2537:14 - now i becomes 1
2537:16 - and if you see the i points to the index at first position and also 1 is less than 6
2537:26 - therefore this for loop will be executed
2537:31 - so now we'll again check whether target which is 9 and we'll subtract the number at ith position
2537:36 - so if we subtract 11 from 9 we'll get minus 2 and we'll check whether minus 2 is a key in this
2537:44 - hash map or not so currently minus 2 is not a key into this hash map therefore this condition
2537:51 - map dot contains key comes out to be false and if you make a reverse of it then it then the
2537:56 - if condition comes out to be true therefore the if statement will be executed
2538:03 - and we'll simply put the number at ith position along with an index value
2538:08 - so we'll put 11 and 1 so 11 is the number at ith position and value is the index position which is 1
2538:19 - so basically friends we are putting these numbers so that we can have a quick look up
2538:24 - into this hash map and we can come to know that whether there is a number whose addition with
2538:28 - this current number will make the target as 9 so moving ahead
2538:37 - so now i becomes 2 and it will point to the second index of the array
2538:51 - so we'll again check whether target which is 9 minus number at ith position so number at ith
2538:57 - position is 5 so we'll check whether 9 minus 5 which is 4 is present in this hash map or not
2539:04 - so number 4 is not present in the hash map therefore this condition map dot contains key
2539:09 - comes out to be false and if we do the reverse of it it comes out to be true
2539:15 - so the if condition comes out to be true
2539:19 - and we'll simply put the number at ith position along with the index value
2539:23 - in the hash map so we'll store 5 with 2 so 5 is the number at ith position which is 2 and
2539:30 - 2 is the index value moving ahead
2539:38 - now i becomes 3
2539:43 - so i will point at the third index
2539:48 - and we'll again check whether map contains target minus number at ith position
2539:53 - so target is 9 at number at ith position is 10 so we'll check whether 9 minus 10 which
2539:58 - is minus 1 is there in the hash map or not so currently it's not there
2540:05 - so map dot contains key comes out to be false and if we do the reverse of it
2540:09 - it comes out to be true so if block gets executed
2540:16 - and we'll simply put the number at ith position and the index value in the hash map
2540:22 - so we are storing 10 along with this index value moving ahead
2540:33 - so now i becomes 4 and here it points to the fourth index
2540:43 - now friends we'll again check whether map dot contains key
2540:47 - target minus number at ith position so target is 9 and number at ith position is 7
2540:54 - so we'll just check whether 9 minus 7 which is 2 present in the hash map or not
2541:00 - so if you see when we do 9 minus 7 it comes out to be 2 and 2 is present in the hash map
2541:08 - so it means that the first number is 7 and the other number is 2 so when we do 2 plus 7 we'll
2541:15 - get 9 so it's like a fast lookup into the hash map so currently 9 minus 7 which is 2
2541:25 - is present in the hash map therefore the map dot contains key comes out to be true
2541:30 - and the and if we do a reverse of it it comes out to be false
2541:34 - so it means we have found our two numbers which will add up to make a specific target
2541:39 - and now as we want to return the indices of those two values so first indices would be the
2541:47 - current value of i because 7 is one of the number so we'll store the index value and the result
2541:54 - array at the first position moving ahead and we need to store the index of the number 2
2542:06 - so what we'll do we'll just do a map dot get target minus number at i at position
2542:11 - so we are simply doing 9 minus number at i at position which is 7 so 9 minus 7 which comes
2542:18 - out to be 2 and we are passing the key as 2 and we are getting the value out of it from the hash
2542:24 - map so it comes out to be 0 and we are storing it into the result array so these are the two
2542:32 - indices which we found which is 0 and 4 and finally we'll just return the result
2542:41 - so friend this was the one of the way by which we can find the two numbers whose sum makes up to a
2542:47 - specific target value and suppose if you don't find any number then we can simply
2542:53 - either return a result array having the indices at 0 0 or we can throw an exception like illegal
2542:59 - argument exception so friend this was the demo of the algorithm now let's go to eclipse and see
2543:05 - the working code so friends let's code the algorithm what we saw in the slide so here
2543:14 - i have just created one class by name twosome and it has one method the main method so let's
2543:23 - give the method name as public static twosome
2543:33 - so the return type is the integer array because it will return back as the indices of the two
2543:38 - numbers and the method takes in an integer array which is the numbers array and it also takes
2543:49 - an integer my name target so in this method first we'll create a result array
2544:05 - so this result array will store the indices of the two numbers
2544:10 - and then we'll create a hash map which will store the integers as key value pair so map
2544:19 - so we can simply give the name as map new hash map we'll just import it
2544:37 - now we'll create the for loop
2544:38 - so we'll iterate the complete array from 0 to numbers dot length
2544:58 - so this will basically iterate each and every element in the numbers array
2545:02 - so in the for loop our first condition would be if
2545:09 - map dot contains key and here we'll provide target minus numbers at the height position
2545:25 - so we'll just we'll we'll just check whether the map contains the target minus number at
2545:34 - ith position key and if it doesn't contain then we'll simply put map dot put
2545:40 - the numbers at ith position
2545:52 - which is index value
2545:56 - and in the else now the else part will come when you found the two numbers so we'll just populate
2546:03 - the result array say at one will put the index
2546:14 - and at zeroth position will put map dot get target minus numbers at ith position
2546:27 - and finally we'll just return the result
2546:37 - and if suppose we haven't found the two numbers then we can either
2546:43 - throw an exception if we can throw an exception say illegal argument exception
2546:49 - the string as two numbers not found
2547:00 - so friend this is the code for finding the two numbers which add up to make a specific target
2547:08 - now let's see is working in this main method so here first we'll create the numbers array
2547:19 - so I will populate the values I had given in the slide two eleven five
2547:30 - ten seven and eight
2547:42 - now as and result array will be returned therefore created integer array variable
2547:47 - by name result and I will just call
2547:53 - twosome method by providing the numbers array and let's say we give target as nine
2548:01 - and let's say we print both the indices so the two indices are
2548:13 - result zero plus
2548:26 - result at one position so friends let's run this java code
2548:33 - so friends you see the two indices are zero and four
2548:44 - so at zero will find will find a number having the values two and at
2548:49 - index four we have found seven so if we add two and seven we get the values nine
2548:57 - so friend this was a tutorial about twosome problem I hope you like this video
2549:02 - please like comment share and subscribe my youtube channel thanks have a nice day
2549:11 - hello everyone so in this video we will be discussing about the twosome problem in java
2549:17 - so in one of our previous video we have actually seen
2549:21 - the solution to twosome problem where we used a hash map so in this video we will be looking into
2549:30 - yet another approach to solve the twosome problem
2549:36 - so before we start in case if you are new to my channel then please subscribe to my channel
2549:41 - and click the bell icon so that you never miss any update
2549:47 - so here if you see we are given an array of integers let's say having different values
2549:53 - two eleven five ten seven eight now the integers in this array are not repeated
2550:00 - and we are also given a target let's say nine so in this problem we have to write a function
2550:07 - where this array and this target will be given and we want to return a pair of numbers such that
2550:14 - they add up to a specific target which is nine so here if you see two plus seven will give the
2550:22 - value as nine which is equal to our target so we need to simply return two and seven
2550:29 - in a form of integer array so let's move ahead and see the demonstration of this algorithm step by
2550:35 - step so here's the algorithm which we will be using to find the pair of numbers which is equal
2550:43 - to our target so the method name is twosome it is taking in an array and a target and it is
2550:52 - returning an integer array so at the first step we usually call twosome method by passing in the
2550:59 - array and the target is nine so this method will start its execution this is the array
2551:10 - having values as eleven two zero ten seven and six so these are six elements from index zero to
2551:19 - five and the target we are providing it as nine so we want to find a pair of number such that if
2551:28 - we sum them we get the value nine moving ahead so here if you see as these numbers are in random
2551:40 - order so in order to find the pair two and seven which will be resulting to our target
2551:48 - we have to compare each element of this array to another element but doing so will be the
2551:54 - time consuming algorithm so what we do in the first step is we try to sort this array
2552:01 - we will see its significance later so after we sort this array
2552:08 - here you can see the elements are arranged in ascending order zero two six seven ten eleven
2552:16 - moving ahead now we'll see the significance that why we sorted this array so in order to
2552:24 - solve this problem what we actually do is we actually take two pointers one is the left pointer
2552:31 - and one is the right pointer so the left pointer usually points to index zero
2552:38 - and the right pointer usually points to the last index of this array so here if you see
2552:45 - we will be creating a variable left we'll assign a value zero to it so this zero signifies the
2552:52 - index so it would look something like this that left is pointing to index zero moving ahead
2553:03 - we'll create a right variable we'll assign the value as array dot length minus one
2553:09 - so if you see array dot length value is six and if we do minus one we'll get five
2553:14 - so right will point to fifth index moving ahead now what we do is as we want to return the pair
2553:26 - so we create a result array which will only take two values
2553:31 - so this is the result array so by default the values will be zero zero because we are taking
2553:39 - the integer array moving ahead
2553:44 - now here we actually did two things first we sorted the array in ascending order
2553:49 - then we created two pointers left and right now what we do is we provide a while loop
2553:56 - and inside this while loop we provide a condition as left should be less than right so here if you
2554:02 - see left is at 0th index and right is at fifth index so left is less than right now using these
2554:10 - two pointers what we do is we try to find out the pair so first number will be denoted by left
2554:18 - and second number will be denoted by right so these two pointers will help us in pointing
2554:24 - both the pairs so the condition is left should be less than right in the while loop
2554:30 - so at the start this while loop will execute because left is less than right
2554:36 - now at the first step what we do is we take the value associated with the left pointer
2554:43 - and with the right pointer and as we want to find the pair sum we usually do their sum so here if
2554:51 - you see we do 11 plus 0 which will give us 11 so sum will be 11
2555:00 - now what we do is we try to compare our sum with target to simply check that whether sum is equal
2555:06 - to target or not so here if you see target is 9 and our sum is 11 so 11 is not equal to 9 it means
2555:17 - this is not a valid sum so basically when we do this comparison there are three possibilities
2555:25 - sum is equal to target sum is less than target or sum is greater than target
2555:32 - so sum is not equal to target so the else part will be executed
2555:38 - and now here we will be checking whether sum is less than target or not
2555:42 - so here if you see sum is 11 and target is 9 so 11 is not less than target
2555:49 - now why we have provided this condition is because so here if you see that when we sorted
2555:55 - this array in ascending order now the advantage will come into picture at these two steps
2556:02 - so if 11 is not equal to 9 which means sum is not equal to target so there are two possibilities
2556:08 - either sum is less than target or sum is greater than target so here currently 11 is greater than
2556:15 - target and as we have this array in sorted form in ascending order we know that we need to reduce
2556:23 - this sum by 2 or whatever value so that it is equal to 9 so we have two choices either we traverse
2556:32 - left this side or we go right this side so here you can see if we go left this side
2556:40 - we will get a value greater than zero and if we go in this direction to right
2556:47 - we will get a value which is lesser than 11 and we want to reduce this sum
2556:53 - so here we can't go in this direction by moving left to this position because
2556:57 - in the next iteration when we will do sum we will get 11 plus 2 which will give us 13
2557:09 - 2 and 11 will give us 13 and 13 is way more far than 9 so we have only one choice to make
2557:18 - that we reduce the sum by moving right into this direction so here these are the two checks which
2557:25 - we perform so sum less than target so this condition comes out to be false because sum
2557:31 - value is 11 and target is 9 so the else part will be executed where you will see the significance
2557:41 - that why we are doing right minus minus because we need to shift right to this position which means
2557:49 - from fifth index we need to move to fourth index so we'll simply decrement value of right
2557:55 - so it would look something like this right becomes 4
2558:00 - and now it will point to the fourth index i'll simply remove this
2558:08 - now again our execution point will reach here we will check whether left is less than right or not
2558:14 - so left is less than right so the while loop will execute
2558:18 - we will again calculate the sum by taking in the values at left and at right pointers
2558:26 - so now our values would be 0 plus 10 so these are the values it will give us a value of 10
2558:36 - so sum will become 10 now
2558:40 - we will compare sum to the target so here we can see that sum is not equal to target
2558:46 - so the else part will be executed we will again check whether sum is less than target or not
2558:53 - so here you can see 10 is greater than 9 so therefore this if condition will come out to be
2559:01 - false because we can't move left to right because if we move left to right then we'll get a value
2559:09 - which will be more than 9 which is like 10 plus 2 which will give us 12 which will make us more far
2559:15 - from the target so what we do is we simply shift right by decrementing it by one position
2559:24 - because we know that as the array is sorted if we move right to this position we will get a number
2559:31 - lesser than 10 so the else part will be executed now right will point to 3 which is the third index
2559:46 - we'll again check in the while loop whether left is less than right or not so left is less than right
2559:52 - we'll again do the sum so this time it would be 0 plus 7 which will give us value 7
2560:04 - so sum becomes 7 we compare sum with the target so sum is not equal to target now again our
2560:12 - else block will be executed so here you can see now that sum is actually less than target
2560:18 - so initially sum was actually greater than target so we moved right pointer in this direction
2560:28 - because we wanted to decrease the actual sum but now sum is actually less than target
2560:36 - so what we need to do is if we move right again to this point so when this while loop will execute
2560:42 - again we will get 6 plus 0 which is like we are going to a more lesser value than target
2560:50 - so if sum is less than target we need to increase the sum so that we reach the target
2560:56 - so the only way we can increase the sum is by moving left to this point because we know that
2561:02 - here it value is 0 and this array is in ascending order so whatever value we'll get after that will
2561:08 - be greater than 0 so this condition is for that so else if part will be executed
2561:16 - and we'll simply increment left by one position so left becomes one now it will point to the first
2561:23 - index moving ahead we will check whether left is less than right or not so left is less than right
2561:33 - we will take their sum at their respective indexes so it will be 2 plus 7 which is 9
2561:43 - so sum will become 9 so for here you can see now sum is equal to target so it means we have reached
2561:52 - to a point where we can simply return this pair because we have found a pair whose sum is equal to
2562:00 - our target so this block will be executed because this condition came out to be true
2562:07 - so in the if part what we do is one value is 2 so we'll simply assign the value stored at left
2562:16 - pointer to the zeroth index of the result so this 2 will come here
2562:22 - and then we'll simply assign the value stored as right pointer to the first index of result
2562:31 - so here 7 will come to the first index so we have found our pair which is if we do the sum of
2562:42 - 2 plus 7 we will get 9 which is the value equal to our target
2562:47 - so at the last step we will simply return the result integer array
2562:59 - so friends here you saw the significance that why we sorted the array because if the array is not
2563:05 - sorted then we need to compare each element with every other element so this would have
2563:13 - given us a count time complexity of
2563:21 - o of n square which is a not a good time complexity so we actually sorted the array
2563:30 - so that we know that the first element is the smallest and the last element is the largest
2563:36 - so when we do the sorting we usually go to n log n time complexity and then using this while loop
2563:46 - we simply do one iteration and we find the pair using this two pointers because as the numbers
2563:53 - are sorted left starts from here and right starts from here and then we simply take these values
2564:03 - stored at right and the left pointer we do their sum and we try to compare it with our target
2564:09 - so if the sum is less than target what we do is we simply shift left by one position
2564:18 - we simply moved right to this direction by incrementing or decrementing respective variables
2564:27 - so friends i hope you have liked this video in case if you are new to my channel then please
2564:32 - subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day
2564:45 - hello everyone so in our previous video we saw an animation that how we can solve the
2564:51 - two sum problem in java now in this video we will actually code the algorithm
2564:56 - and we'll test its working in main method
2565:02 - so before we start in case if you're new to my channel then please subscribe to my channel
2565:07 - and click the bell icon so that you never miss any update
2565:12 - so here you can see that i have created one classes array util
2565:18 - and in one of our previous video we saw the two sum problem in that video we discussed
2565:24 - one of the solution to solve the two sum problem we basically took the help of
2565:31 - a hash map and we solved the problem now in this video we'll see one more way to solve this problem
2565:39 - so let's suppose i create one method here as public static
2565:46 - two sum two because we are discussing the second approach here so this method will take in an array
2566:00 - where we will be provided with different numbers and those numbers will be unique
2566:06 - and we will be also provided with a target and usually there will be one such pair
2566:11 - which will be equal to the target so we need to find that pair
2566:17 - and after finding that pair we'll simply return it in the form of an array of length 2
2566:25 - so in our previous video we discussed that how we can solve this problem we took the help of
2566:31 - sorting and two pointer approach so the first step we do is we sort the array
2566:45 - so using arrays.sort we will pass in the array so we'll get the sorted array
2566:53 - so here you can see this arrays class in java has a sort method where if we provide the array we get
2567:00 - the sorted array in ascending order so here you can use your own sorting algorithm or we can use
2567:07 - the sorting algorithm provided by java now after sorting this array what we'll do is we create two
2567:15 - pointers one is the left pointer which starts from 0th index of this array and one is the
2567:25 - right index which usually start from the end of the array so if you want to know the last index
2567:34 - of an array what we can do is we'll simply call array.length so this will give us complete length
2567:41 - and if we do minus one we'll get that particular index because array starts from zero index and
2567:48 - goes to array.length minus one index now after creating these two pointers as you want to return
2567:57 - the pair of numbers whose sum is equal to target we will create an array we'll name it as result
2568:08 - and this array will be of size 2 because it will take two numbers now after creating this array
2568:16 - we have these two variables left and right now these two variables will help us in finding that
2568:22 - pair of numbers whose sum is equal to the target now here we'll provide a while loop
2568:32 - and as left starting from 0th index and right is starting from the last index
2568:37 - this while loop will go on till left is less than right if left becomes right then we'll
2568:46 - simply break from this while loop so in the while loop what we'll do is we'll first calculate the sum
2568:55 - of the values stored in the left and the right index so we'll do array of left plus
2569:04 - array of right
2569:09 - now in our previous video we discussed that after calculating the sum
2569:13 - we try to compare it with the target so there are basically three possibilities so the first
2569:19 - possibility is if sum is equal to target it means we have found our target and we'll simply
2569:32 - store the both the values array of left and array of right into this result
2569:39 - and we'll simply return the result so here what we'll do is
2569:44 - this result at the 0th index we'll simply store
2569:52 - array of left and at the first index
2569:59 - we'll store array of right because these two are the numbers when we did the sum of it
2570:08 - it became equal to our target so we are storing both these values into the result array
2570:15 - and here we are simply returning result
2570:21 - now this is the first condition when sum is equal to target there could be two more conditions
2570:27 - let sum could be less than target or sum could be greater than target
2570:42 - so friends here is the significance that why we actually sorted the array
2570:46 - if our sum is less than the target then what we do is we need to increase our sum
2570:52 - in the next iteration so here we simply increment left by one position so let's say
2571:00 - if i take this example here let's say the sorted array comes out to be 0 2 6 7 10 11
2571:13 - so here you can see left will be pointing to 0 and right would be pointing to 11 so if we do
2571:20 - sum of it we will get value is 11 and let's say our target we want is 9 so here we know that 0 plus
2571:29 - 11 which is our sum is greater than target so what we do is we need to reduce the sum
2571:37 - so we have two possibilities either we traverse left towards the second value or we can traverse
2571:43 - right towards the second last value so here currently sum is 11 but if we traverse left to
2571:51 - the second position in the next iteration our sum will become 2 plus 11 which will give us 13
2571:59 - so we are going way more far than the target so here our only possibilities we move right
2572:05 - to the second last position because in the next iteration if we do the sum
2572:10 - we will get 10 plus 0 which would be 10 so 10 is pretty much close to the target
2572:18 - so these are the fls provided for that so if sum is less than target then we need to increase the
2572:25 - sum so that it matches target and the only way to increase the sum is by incrementing left
2572:32 - so that left can go to the higher values and if sum is greater than target
2572:39 - then we need to reduce the sum so for that what we need to do is we need to decrement right
2572:45 - because as the array is sorted if right is pointing here let's say to 11 if it goes to the
2572:51 - second last position we will get a value which is lesser than 11 so here we'll do right minus minus
2572:59 - this so after this while loop will terminate what we can do is we can simply return
2573:11 - our dummy integer array or we can throw an exception like we did here
2573:17 - the two numbers not found so now let's test it's working in the main method
2573:23 - so let's suppose we are provided with this array and here what we do is
2573:36 - we simply call to sum we pass in the array and let's say we pass in the target as 9
2573:46 - and we'll simply print the array
2573:48 - so if i run the main method now
2573:57 - so here you can see it returned two values two and seven so if we do two plus seven
2574:05 - we will get our target as nine so friend this was all about solving to some problem using the
2574:12 - sorting and two pointer technique i hope you must have liked this video
2574:19 - in case if you're new to my channel then please subscribe to my channel thanks have a nice day
2574:29 - hello everyone so in this video we will be discussing a subsequence problem in java
2574:37 - so first we will see what is a subsequence
2574:42 - before we start in case if you're new to my channel then please subscribe to my channel
2574:47 - and click the bell icon so that you never miss any update so usually a subsequence of a string
2574:55 - is actually a new string which is formed from the original string only and how it is formed
2575:04 - by deleting some or no characters and only thing to keep in mind is
2575:11 - we should not change the order of the remaining characters so what it means now let's see why
2575:18 - example let's suppose we are given with the original string a b c d e and we are given a sequence
2575:28 - a c e now we have to find whether a c e is a subsequence of a b c d e or not
2575:36 - so here you can see if we delete b and d and we don't change the order of the remaining elements
2575:45 - we actually get a c and e so therefore a c e is a subsequence of a b c d e
2575:53 - if we look into a e c so it is not a subsequence of a b c d e so here a e c is present in a b c d e
2576:10 - but if we remove b and d the remaining characters doesn't form a e c it actually forms a c and e
2576:19 - so the only thing we need to keep in mind is the order of the elements shouldn't get changed
2576:27 - so here c is actually coming before e but here e is coming before c so therefore the order of
2576:33 - the element has changed so therefore a e c is not a subsequence of a b c d e now if suppose we were
2576:41 - given a string as a b c d e so here you can see by deleting some or no characters so if we were
2576:51 - given this string this string also is a subsequence of a b c d e because we are not removing any
2576:58 - characters and we will be getting the same string back so this is a subsequence of a b c d e
2577:05 - so one other way to look into subsequence is we simply see in this direction in both the string
2577:19 - and we see whether those characters come into this order only or not so here first we encounter a
2577:27 - and here we see we have got a so we move ahead now we see c so here is b
2577:37 - so we simply move ahead we encounter c so we simply move ahead
2577:45 - we see e and here we see d so we simply discard it and we move ahead and at the last we find e
2577:51 - so therefore a c e is a subsequence of a b c d e now here
2578:02 - we see a a so we move ahead we go to e we go to b so these two are not equal so we discard it
2578:13 - we go here we see e and c we discard this we go here we find d and e we discard this
2578:26 - we come here we find e so e and e matches so now we move here but here you can see
2578:34 - complete string is exhausted and there are no more elements therefore we come to a conclusion
2578:40 - that a e c is not a subsequence of a b c d e so we will be applying this similar algorithm
2578:48 - to solve this problem so here you can see this is the algorithm where we will be provided with the
2578:57 - original string and a sequence we need to simply find out whether this sequence is actually a
2579:04 - subsequence of this string or not so let's see the demonstration of this algorithm step by step
2579:11 - so we'll call this subsequence method by passing in two strings one is the original string and
2579:18 - other is the sequence and here you can see the return type of this method is boolean
2579:24 - so we will either return true or false so at the first step a b c d e is our string
2579:35 - and the sequence is a c e so we are figuring out whether a c e is subsequence of a b c d e or not
2579:45 - so this is our original string and this is the sequence so here you can see that we have
2579:52 - represented a string in a form of a character array so in java string class has this method
2579:59 - character at where we pass in an index and we get a particular character present at particular
2580:07 - index so if we pass one we will get the character as b so we can use this method to simply get
2580:17 - a particular character at a particular index we can also use two char array method
2580:24 - which actually gives us the character array and then we can perform our logic on this character
2580:33 - array but here i will be simply using this charAt method and we will see the string in a form of a
2580:40 - character array moving ahead now what we discussed in our previous slide
2580:51 - that we simply look into this direction in both the string so for that we create two
2581:00 - pointers i and j
2581:05 - so i will simply traverse into the original string
2581:14 - and j will traverse into the sequence
2581:16 - now we want to simply check whether a c e is present in this particular order
2581:26 - into a b c d e or not so for that we have provided a while loop where the condition is
2581:34 - this while loop will continue till i is less than string's length so your string length is 5
2581:41 - and j should be less than sequence length so here i will be traveling from 0 to 4
2581:53 - and j will be traveling from 0 to 2 because the length of the sequence is 3 so this is the
2582:00 - condition we need to keep in mind so why we have provided this condition is i should be less than
2582:06 - string dot length is so if i goes beyond the length of the string then we need to break from
2582:12 - this while loop because there are no more characters left to be compared and similarly with the j
2582:21 - if j travels beyond the sequence then it simply signifies that we have found our sequence
2582:27 - and we should simply break from this while loop because this original string can have
2582:33 - n number of elements and as we have found our sequence we should break from this while loop
2582:39 - because we don't want to go further into the string so at the start i is less than 5 and j
2582:46 - is less than 3 so this condition comes out to be true the first step what we do is we simply
2582:55 - compare the character at i at index with a character of the sequence at jth index
2583:03 - so it means we are simply comparing this character with this character
2583:11 - so j is pointing to sequence so and j is also referring to the index 0 so this character is
2583:19 - compared with this character now if they are equal so currently a is equal to a
2583:29 - so this condition comes out to be true now what it signifies is one of the sequence character is
2583:36 - matched so now we can safely move j to the next index so we do j plus plus so j becomes one
2583:49 - moving ahead and after that we do i plus plus because now our second character should match
2583:58 - with the rest of the string which is this because this is already being matched so we do i plus plus
2584:07 - so i points to index one moving ahead i is less than five as one is less than five
2584:20 - and one is less than three because j is pointing to one so both condition comes out to be true
2584:29 - we again check whether character at i at index of string is it equal to the char at jth index
2584:36 - of the sequence so it simply means we are comparing b with c now here you can see b
2584:46 - is not equal to c therefore this condition comes out to be false now as this condition comes out
2584:53 - to be false we don't increment j because there could be a possibility c might come later in the
2585:02 - string so therefore condition in this block comes out to be false
2585:08 - and we only increment i so we don't touch j we only increment i so i becomes two
2585:19 - so i'll just remove everything
2585:24 - now we again check whether i is less than five so this condition comes out to be true
2585:31 - and we also check whether j is less than three because sequence dot length is three
2585:37 - so both this condition comes out to be true
2585:42 - we compare the respective characters at ith and jth index so here we are comparing
2585:49 - c with c because i and j are pointing to these two indexes so here you can see c is equal to c
2586:01 - so this condition comes out to be true it means our second character actually matched
2586:07 - with the character in the original string so we'll simply increment now j by one because
2586:15 - because we have matched our character and now we simply move to the next character
2586:20 - so j becomes two and we'll increment i because this character is already matched
2586:35 - five becomes three now here three is less than five and two is less than three so both
2586:43 - condition comes out to be true we compare the characters at these respective indexes
2586:53 - so it means we are comparing now d with e so here you can see d is not equal to e
2587:01 - therefore this condition comes out to be false and we don't increment j
2587:05 - and here as we discuss why we don't increment j because later in the string there could be
2587:14 - e coming up so here you can see e is here but but if here the character would have been different
2587:21 - so there could be a chance that e might have come later so we don't increment j we only increment i
2587:31 - so i becomes four
2587:35 - so i'll just remove this
2587:41 - so four is less than five this condition is true and two is less than three so this condition is
2587:48 - also true we'll compare e and e which is this character with this character
2587:58 - so this comes out to be true so we'll increment j because our character is matched
2588:10 - so j becomes three it means now j has crossed the limits of sequence
2588:17 - moving ahead will increment i so i becomes five it means i has also crossed the limit of the string
2588:29 - so now you can see value of i is five and five is not less than five so this condition comes
2588:36 - out to be false so the overall condition comes out to be false so this while loop will exit
2588:45 - so friends here at the last step this condition is pretty much important because
2588:49 - if value of j is actually equal to the sequence length it means j has traversed
2588:57 - this sequence complete and we have found our element so currently j value is three
2589:03 - and sequence length is three so three is actually equal to three therefore we will return true
2589:13 - because j is equal to sequence dot length and this expression returns true
2589:20 - as three is equal to three because when j will equal to the length of the sequence it means
2589:26 - it has traversed a c and e completely so here we are returning true so now we'll see one more example
2589:39 - let's say we call abc de with the sequence a ec
2589:44 - so we'll go over this example quickly i is zero and j is also zero
2590:00 - here string length is five and sequence length is three both the condition comes out to be true
2590:06 - because i is less than five and j is less than three
2590:12 - we compare the characters at the respective indexes of their respective strings
2590:19 - so we are comparing a with a which is true so we'll increment j j becomes one
2590:27 - and we'll increment i so i will become one both this condition is true because i is less than
2590:40 - five and j is less than three
2590:46 - we'll compare b with e by this expression so b is not equal to e so this condition
2590:54 - comes out to be false we won't increment j because there could be possibility e might lie
2591:01 - somewhere after b so we'll only increment i becomes two both the condition comes out to be true
2591:14 - i is less than five and j is less than three we'll compare c with e now
2591:21 - so this condition comes out to be false we'll increment i i becomes three
2591:32 - i is less than five and j is less than three
2591:38 - we'll compare d with e so they are not equal so we'll simply again increment i
2591:47 - i becomes four
2591:54 - i is less than five j is less than three
2591:59 - now we'll compare e with e so they are actually equal
2592:05 - so it means the if block condition came out to be true so we'll increment j so j becomes two
2592:12 - and we'll increment i so i becomes five so this is the important moment this i has become five
2592:23 - it means i has crossed the boundaries of this string
2592:30 - so here value of i is five and string length is five so therefore this condition
2592:37 - comes out to be false so this while loop will exit
2592:43 - so friends here you can see now value of j is two and sequence length is three
2592:53 - so this condition is very much important to figure out whether all the characters of the sequence
2592:59 - were traversed or not so here you can see j is two and two is not equal to three therefore aec
2593:10 - is not a subsequence of a b c d e so we'll simply return false
2593:17 - so friends i hope you must have liked this video in case if you are new to my channel
2593:21 - then please subscribe to my channel thanks have a nice day
2593:30 - hello everyone so in our previous video we discussed the problem of a subsequence
2593:37 - where we were given two strings one was the original string another was a sequence
2593:44 - and we need to find out that whether that sequence is actually a subsequence of that
2593:49 - original string or not so before going through this video you watch that animation so that you
2593:55 - get an idea that how we can find out that whether a sequence is a subsequence of any other string
2594:03 - so in this video we'll actually code the algorithm and we'll test its working in the main method
2594:10 - so before we start in case if you're new to my channel then please subscribe to my channel
2594:16 - and click the bell icon so that you never miss any update
2594:20 - so here you can see that i have created one class as string util and inside that class
2594:26 - we will be creating our method public static will give it a name as is sub c quence
2594:37 - now this method will take two strings
2594:47 - one is the original string
2594:52 - another is the sequence so we need to find out whether this sequence is actually a subsequence
2594:59 - of the string or not so the return type would be a boolean
2595:07 - so in our previous video where we saw the animation we actually used the two pointer
2595:12 - technique where we created two pointers i
2595:23 - nj so i usually traverse the string nj traverse the sequence
2595:38 - and usually we traverse both from left to right and we simply try to compare
2595:44 - the character present at that particular index which is being denoted by i and j
2595:52 - into their respective strings so we provide a while loop
2595:57 - and inside this while loop we provide the condition s this while loop will go on till
2596:08 - i is less than strings length and j is less than sequence length
2596:17 - because as we are traversing these two pointers from start to finish if any of the pointer crosses
2596:24 - the limit of their respective strings we simply break from this while loop so inside this while
2596:30 - loop we simply compare the character at i and jth index of their respective strings so here we do if
2596:39 - charit i is it equal to
2596:51 - sequence dot charit j so if they're equal so here let's say if we take the string as
2596:58 - a b c d e
2597:05 - and let's say we take the sequence as a c and e
2597:12 - so here you can see that j starts from zero and is starts from zero so we are simply comparing
2597:18 - the first element if they are equal it means we have found one of the character of the sequence
2597:26 - into the original string so we simply increment j by one because now we try to compare the next
2597:35 - element into the original string and after this if block we always increment i by one position
2597:44 - because we have matched this character with this character now c and e will be compared with the
2597:53 - rest of the string so in the next iteration you will see that b is compared with the c
2598:00 - via this condition so this condition comes out to be false because b is not equal to c
2598:06 - so we don't increment j we only increment i because there could be a possibility that c
2598:13 - might come later in the string because we are trying to find out the subsequence here
2598:19 - so we always increment i irrespective whether we have found our element or not because
2598:25 - if we have found our element here then we increment i because we have to compare
2598:33 - the rest of the sequence with the rest of the original string and if we don't find the matching
2598:39 - character which is here where we are comparing b with c so this condition comes out to be false
2598:46 - so we try to only increment i because there could be a possibility that next character
2598:52 - should match with the sequence character at jth index so this loop goes on and at the end
2599:00 - what happens either this condition comes out to be false or this condition comes out to be false
2599:07 - or both condition comes out to be false so this while loop will terminate so after this
2599:13 - while loop will terminate we simply return is j is equal to sequence dot length or not
2599:24 - so why we are doing this is because let's say if this condition
2599:30 - comes out to be false it means j is equal to sequence dot length which signifies that
2599:36 - if j is equal to sequence dot length we have found our subsequence we have found
2599:43 - that this sequence is actually a subsequence of this string because we have traversed each
2599:49 - and every element and we have found them to be true and at the last increment of j it will
2599:56 - actually reach to the sequence dot length so if j is equal to sequence dot length it means
2600:03 - this sequence is actually a subsequence of our original string and let's say friend if we provide
2600:11 - aec so this a would have matched with this a this e would have matched to this e
2600:21 - and after that j would have remained to c because our original string would have been exhausted here
2600:27 - as i would have become equal to string dot length so at that moment of time this condition
2600:36 - would have come out to be false which says that aec is not a subsequence of abcde
2600:45 - so friend this is the algorithm which help us in determining that whether any sequence
2600:51 - is a subsequence of the original string or not so now let's test it working in the main method here
2601:03 - we will simply print is subsequence let's say we pass the string as abcde
2601:10 - and we pass ac and e if i run the main method now
2601:25 - you will see it came out to be true now let's say
2601:30 - if i run it with a e and c
2601:45 - so it came out to be false so why because aec though it's present in a b c d but the order
2601:55 - of elements which constitutes the property of subsequence is not matched here you can see c
2602:02 - is coming before e but here e is coming before c therefore this cannot be the subsequence of this
2602:08 - string because the order matters in the subsequence so friends i hope you liked this video
2602:16 - and in case if you're new to my channel then please subscribe to my channel thanks have a nice day
2602:22 - hello everyone so in this video we will be discussing first non-repeating character problem
2602:31 - so this is a very famous interview question which is being asked by many companies
2602:37 - so we'll see what this problem is and we will see the demonstration of this algorithm step by step
2602:44 - so here you can see that we are given a string as which only has lowercase letters
2602:51 - now we need to return the index of first non-repeating character first non-repeating we
2602:58 - mean is the unique character which occurs first and if it doesn't occurs or doesn't exist
2603:06 - we can return minus one so we need to return the index let's see with an example
2603:12 - suppose the string provided is code for code so here you can see the answer is fourth index
2603:20 - the first non-repeating character is f and is found at index four so let's see how we actually
2603:28 - traverse the string from left to right because we need to find the first non-repeating character
2603:35 - so here you can see if you see c occurs here as well so this is not a unique character
2603:43 - we check o is here and here at three places so o is also not unique we see d d is here and here
2603:55 - so d is also not the unique character or first unique character e is here also so e is not the
2604:04 - first unique character now we see f so you can see f is not present in the rest of the string
2604:12 - so f is the first non-repeating or unique character in this string and the index is
2604:19 - let's say zero one two three four so four is the answer now let's suppose we have provided
2604:28 - with string as a a b b so here you can see a occurs twice and b is also occurring twice
2604:36 - so it doesn't have any non-repeating character so we simply return minus one
2604:43 - now let's see the algorithm for it and its demonstration step by step
2604:48 - so here you can see this is the algorithm to solve first non-repeating character problem
2604:55 - so before we start in case if you're new to my channel then please subscribe to my channel
2605:01 - and click the bell icon so that you never miss any update
2605:05 - so here let's say we call this method first non-repeating character we pass the string as
2605:11 - race cars so here the string is race cars something like this
2605:21 - so friends the basic idea behind this algorithm is we actually take the help of a hashing data
2605:26 - structure which is a hash map which basically has key and value so here key is unique which
2605:35 - is our character and the value is a integer which will actually hold the count of the character
2605:42 - occurring in the string and why we are taking a hash map is because if you see somewhere here we
2605:50 - are doing get now this get operation when we pass any character will return as the count for that
2605:56 - particular character and this happens in O of one time if we don't use hash map then the algorithm
2606:04 - will take multiple for loops and will increase the time complexity so therefore to get the
2606:10 - character count very fast we use this hashing data structure which is our hash map so we'll
2606:17 - see its significance when we see the algorithm step by step so first we will create a map
2606:23 - having key and value of type character and integer so here i am simply demonstrating it as key value
2606:31 - pair but internally this map uses a hash function to store this key value pair such that the retrieval
2606:39 - becomes faster you can watch my videos on hashing data structure and hash map but here i will be
2606:45 - simply demonstrating it with the values so here we have this string array scars now what we do is
2606:54 - as we need to find out a single character which is first non-repeating we first take this string
2607:02 - we call two char array method on it and this will return us a character array so this method is
2607:09 - present in a string class so it would look something like this that we have got our character array
2607:16 - where this array at each index holds one character like this moving ahead
2607:23 - now what we do is we iterate our each and every character one by one and we put it the character
2607:29 - into the map and we put it such a way that if that character is not present we put one and if the
2607:37 - character is present we take that value first and we add one to it so we'll see how this line works
2607:45 - but here you can see that we are putting the character because key is the character and as
2607:51 - the integer what we are doing is we are calling hash maps method get or default so when we do map
2607:59 - dot get or default if this character is already present then its corresponding value is returned
2608:06 - and we simply add one to it and we put it back into the map and if the character is not present
2608:13 - then we return a default value so its like get or default so for the default value
2608:19 - here you can see we provide zero which signifies that the particular character if it is not present
2608:26 - in the map it means just return the count as zero and why we are doing plus one and putting
2608:32 - it back into the map you will get more when we will see the working of this for loop so here
2608:39 - this for loop will iterate each character one by one so it will start with r
2608:47 - here we will put r and here you can see the map is empty it doesn't have r so the default value
2608:54 - of zero is returned and when zero is returned we do plus one to it so it becomes one and we put
2609:01 - it into the map so here it would look something like this we put r as our key and value as
2609:09 - so this one signifies that character r occurred one time as we are traversing from left to right
2609:17 - so at this moment r is occurred one time so therefore we are returning this zero
2609:22 - because we are adding one to it so if r again comes up we will do map dot get or default we
2609:29 - will get actually one because r is already present as a key so we add one to it which means the
2609:37 - count of r is two we extracted one and we added one to it so the count became two and if the value
2609:45 - is not present we add one to the zero and put it back into the map moving ahead now it will pick
2609:53 - the second character which is a it checks whether a is present or not so a is not present in the map
2610:01 - so it simply returns the default value zero we add one to it and we put a as a key and value as one
2610:10 - so it goes like this
2610:14 - it takes c now and similarly it puts c as a key and one as a value because c is also not
2610:24 - present in the map so get or default will return zero as a default value
2610:31 - now it takes the fourth character which is e
2610:35 - we put e also as one because the count is still one now it takes c
2610:45 - so here you can see when we will do map dot get or default now this time zero won't be returned
2610:51 - because c is already present and with a value as one so this one will be returned and we'll
2610:58 - simply do plus one and we put c with value as two so this complete expression gives us two for c
2611:09 - so here it becomes two and which makes sense because till this point we have encountered c
2611:15 - two times so we are simply storing the frequency of the character in the value field moving ahead
2611:23 - now it will pick a
2611:28 - a is also present so it will take this value it will add one to it and it will insert it back
2611:35 - so it will become two
2611:39 - it will pick r
2611:45 - so r also becomes two
2611:49 - and at the end it picks s
2611:53 - so here s is not present so therefore the default value zero will be returned
2612:01 - we do plus one and we put s with one
2612:07 - so now this for loop will end
2612:12 - so friends here you can see this is the character frequency map
2612:15 - so why we have done this is to simply count the number of occurrence of a particular character
2612:22 - so here you can see r occurred two times here and here a occurred two times here
2612:29 - and here c one year and one year and e and s occurred only once here and here
2612:39 - so now the next for loop will help us in deciding which is the first non-repeating character
2612:44 - so here we will again iterate the char array from zero index to the end
2612:53 - so initially i is zero and i is less than char.length which is eight so char.length is eight
2613:03 - so we pick the first character we provide index zero so r will be picked
2613:10 - and now we'll simply call map.get and we pass the character so when we do map.get
2613:20 - we will get its corresponding value because we are passing in the key
2613:24 - and this map will return us back the value associated with this key and dead to an o of
2613:30 - one time which is very fast so that's why we were using hashmap so here when we do map.get r
2613:39 - we will get the value as two so here you can see two is not equal to one it means r cannot be our
2613:49 - first non-repeating character because it has value two so we move ahead with the next character
2613:58 - i becomes one one is less than eight we take the next character which is a
2614:06 - as index one because value of i is one
2614:11 - we do map.get a
2614:15 - so we pass in the key as a and we get value as two it means a cannot be our first non-repeating
2614:21 - character we move ahead i becomes two two is less than eight we pick c now
2614:36 - we do map.get c
2614:40 - we get the value as two two is not equal to one so therefore c can't be our first non-repeating
2614:48 - character because it has value two it means it has occurred two times
2614:56 - we'll increment i to three we'll pick now e
2615:06 - now here you can see when we do map.get e we get a value as one so one is equal to one it means
2615:17 - this condition comes out to be true and which signifies that we have found our first non-repeating
2615:22 - character because we were traversing this for loop from this end and whichever value we found
2615:29 - to be one we simply return its index so here whatever the value i will have
2615:37 - we'll simply return it back so the answer would be three
2615:45 - so now let's see this example one more time with value is ab ab so we'll quickly go over it
2615:51 - string is ab ab we create a hash map like this
2615:57 - we convert this ab ab into character array by calling 2 char array so it comes out to be like
2616:06 - this now we literate each and every character and we put its frequency as a value in this hash map
2616:16 - so we start with a we check whether a is present or not by this it is not present so we return the
2616:25 - default value zero whatever value is returned we add one to it and we put a into the hash map
2616:33 - so the value would be one signifies that a has occurred one time
2616:39 - we go with the b and similarly b will have one because b is not present in the map
2616:47 - we take a and we see a is already present so we get this value out we add one to it
2616:58 - and we put it back so one plus one will give two and we put two back into the hash map
2617:08 - we take the last character b we see b is also present so we do one plus one
2617:15 - and add it back so occurrence of b is also two now this for loop will end
2617:25 - so here you can see looking into the hash map a occurred two times
2617:29 - here and here b occurred two times here and here so here we can see that in this string
2617:37 - no character has appeared once so this for loop will help us in figuring that out
2617:43 - we will start with i equal to zero index we go till cares dot length so cares dot length is four
2617:51 - zero is less than four we take first element which is a
2617:58 - so we do map dot get a we pass the a we get value as two so here we can see that
2618:05 - two is not equal to one so this condition comes out to be false
2618:09 - we increment i i becomes one one is less than four we take the first index character which is b
2618:23 - i'll remove this
2618:27 - we do map dot get b we pass the key b we get value as two so here two is not equal to one
2618:36 - so this condition comes out to be false
2618:41 - i becomes two two is less than four now we take the second index value which is a
2618:49 - we do map dot get a
2618:54 - it returns two two is not equal to one this condition comes out to be false
2619:00 - and similarly we do for the last character
2619:08 - we take b we do map dot get b it will return two two is not equal to one so this condition comes
2619:18 - out to be false so here now i will become four and four is not less than four so this for loop will
2619:28 - end and once this for loop will end if we haven't written anything from this condition
2619:38 - at the end we know that there are no characters in this string which are unique so we simply
2619:44 - return minus one so friends here we saw two examples in one we found the first non-repeating
2619:54 - character and in other we didn't found any non-repeating character so if i go to the previous
2620:00 - slide so here you can see that when we did race cars we actually saw that e and s both had a count
2620:10 - one but here e occurred before s so therefore this e was the first non-repeating character
2620:17 - not s so this is one thing we need to keep in mind that we need to find first non-repeating
2620:30 - character i hope you must have liked this video in case if you're new to my channel then please
2620:36 - subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice
2620:42 - day hello everyone so in our previous video we saw the detailed demonstration of the algorithm
2620:51 - to find first non-repeating character in a string where we were given a string in lower case letters
2620:59 - and we wanted to find the index of the first non-repeating character in it
2621:04 - so in case if you want to understand more you can watch my previous video
2621:09 - so in this video we will actually code the algorithm and we'll test it's working in the
2621:12 - main method so before we start in case if you're new to my channel then please subscribe to my
2621:19 - channel and click the bell icon so that you never miss any update so here in string util class
2621:27 - i will be creating the method as public static we'll give the method name as first non-repeating
2621:42 - character so this method will take a string
2621:49 - and it will return the index which is of integer type for the first non-repeating character
2621:57 - so friends here in order to find the first non-repeating character we first iterate this
2622:04 - string completely and we figure out the character frequency that how many times a particular
2622:10 - character has occurred so for that we are using the map postkey is character and values integer
2622:20 - which is the count of that particular character that how many times it has occurred so we can
2622:26 - give it a name as character frequency map new hash map now we want to iterate each and every
2622:40 - character of this string one by one so for that we take the string and we convert it into character
2622:51 - array by calling two char array method then we provide a for loop
2623:05 - so here we will iterate one one character in each iteration now here what we do is as you
2623:10 - want to count the character frequency that how many times it has occurred what we do is
2623:18 - we do character frequency map dot put we put the character as key and the value we put is
2623:28 - we first check that whether this character is present in the map or not so we do it by
2623:37 - method get or default we pass the key to it if that character is present the value corresponding
2623:45 - to it will be returned and if that character is not present so we can return a default value
2623:52 - because the method is get or default so we need to pass the default value to it which is
2623:57 - let's say if the character is not present we want it to return zero so here you can see default
2624:03 - value is zero and what we need to do is let's say if the string has a character a which is not
2624:10 - present so here we have encountered a so we need to put the count as one because a has occurred
2624:17 - once so we'll do plus one to it and let's say next time for example let's say our string
2624:26 - has something like a b a so for this map will have a as a key and value as one now when this
2624:36 - a will again occur so this get or default will return the previous value which is one
2624:42 - and we will add one to it so now map will have a as a key and value as two because a occurred two
2624:50 - times so this we do for each and every character and after doing that we provide another for loop
2625:06 - and we iterate this char array once again and now as you want to find the first
2625:19 - non-repeating character and we are starting from zero index so whichever character
2625:24 - value in this character frequency map will have one it means when we traverse this character array
2625:31 - completely that particular element was the one which had only occurrence one
2625:38 - and which was the first non-repeating character so here what we do is we take the char
2625:48 - from the ith index we provide a if check if
2625:56 - the character frequency map we do get
2625:59 - we pass the character and if the value returned is one it means this is our character which is
2626:11 - first and non-repeating so we simply return its corresponding index which is i and if we don't
2626:19 - find any such character whose frequency is one then at the end we simply return minus one
2626:29 - so now let's test it's working in the main method
2626:37 - here we will call first non-repeating character
2626:40 - let's say we pass the string what we saw in our previous video
2626:45 - raise cars so here you can see it should return 0 1 2 3 because e is the first non-repeating
2626:56 - character why because r a and c have occurred two times in this string so if i run this
2627:09 - so here you can see it return three
2627:13 - and let's say if we put a string
2627:18 - which doesn't have any unique character so here a has occurred three times v has also occurred
2627:24 - three times if i run it it should return minus one and let's say we provide a value here as e
2627:36 - so now we have e as a character which has occurred only once and it's the first non-repeating
2627:44 - character so if i do run it we will get its index as six because 0 1 2 3 4 5 6 so e is at
2627:56 - sixth index now let's say if i do in between i do f so now f is our first non-repeating character
2628:05 - because e comes later so now it should return three
2628:13 - so it comes out to be three so 0 1 2 and 3
2628:21 - so friend this was all about the algorithm to find the first non-repeating character in a string
2628:27 - string i hope you must have liked this video
2628:34 - in case if you're new to my channel then please subscribe to my channel
2628:38 - and click the bell icon so that you never miss any update thanks have a nice day
2628:46 - hello everyone so in this video we will be discussing a problem that how we can remove
2628:52 - vowels from a string so here we are given with a string and we need to remove the vowels from
2629:00 - that string and return that string and the string only contains the lowercase letters
2629:07 - so if we talk about vowels then there are five vowels a e i o u so let's suppose we are given
2629:16 - with this string what is your name so the output would be this a i o u a and e this will be removed
2629:31 - because those are vowels and this string will be written like this so now let's see the demonstration
2629:38 - of the algorithm step by step that how we can remove the vowels from a string
2629:42 - so before we start in case if you are new to my channel then please subscribe to my channel
2629:49 - and click the bell icon so that you never miss any update
2629:54 - so here you can see that this is the algorithm to remove vowels from a string
2629:59 - so now let's see the demonstration of this algorithm step by step with an example
2630:05 - so we'll call remove vowels method we'll pass the string as ice cream
2630:12 - so here string would be ice cream so here you can see that it has vowels like i e e and a
2630:27 - so here in order to remove the vowels from this string we take each character and we see whether
2630:33 - it's a vowel or not so for that first we create a set which we denote as vowels and this set
2630:41 - will only have the characters so this is a set of a e i o u and why we are taking it as a set
2630:50 - because here you can see that we are using for loop we are iterating over each character
2630:56 - of this string and we are checking whether this particular character is present in this
2631:03 - vowel set or not so this contains method is very fast and it has an average time complexity of
2631:10 - o of 1 which is nearly constant so therefore we are using set in order to know more about set
2631:18 - and hashing data structure you can watch my series on hashing so after creating the vowel set
2631:27 - we will be creating an instance of string builder now why we are taking string builder is because
2631:34 - when we will be removing the vowels from this string we will be creating a lot of intermediate
2631:40 - strings so to avoid that we are basically using string builder so string builder class is provided
2631:47 - by java which actually deals with the operations performed over the string and which help us in
2631:53 - generating a string without giving a performance hit moving ahead now this string has a method
2632:02 - to char array in java so when we call this method we will get a character array so this ice cream
2632:10 - will be separated out in a form of a character array so it would look something like this
2632:17 - that this is the character array going from index 0 to 8 because it is taking ice cream
2632:25 - one single character at a time so now we'll traverse each and every character one by one
2632:33 - using this for loop so this for loop tells that iterate over each character present in the char
2632:40 - array so when this for loop will start ch which is the character it will point to the first character
2632:48 - which is i so ch is i so we take this character and we search into our vowel set that whether
2633:01 - it contains ch or not so here you can see vowel set has character i so it means this is a vowel
2633:11 - and we don't want to include this into our final string so what we do is here you can see the
2633:17 - condition as vowels not contents will come out to be true and if we negate that it will become
2633:24 - false so this condition comes out to be false and we will simply skip i because it is a vowel
2633:34 - so now we'll go to the second character which is at index one
2633:38 - so ch will become c we check whether c is present in the vowel set or not so vowels
2633:49 - dot contents will return false because c is not present and if we negate that this will become
2633:56 - true it means c is not vowel so we need to include this c into our final string so this condition
2634:05 - comes out to be true so string builder has a method append where we will simply append the
2634:13 - character c so it would look something like this that c comes into the string builder moving ahead
2634:24 - we'll go to the third character which is e
2634:28 - now e is a vowel so vowel dot contents e will come out to be true and this condition after
2634:41 - negating becomes false so therefore we will skip e because e is a vowel
2634:47 - moving ahead now the fourth character is actually empty string or a blank character
2634:59 - so ch will point to this empty thing or space
2635:06 - so this condition vowel dot contents will come out to be false and if we negate that
2635:12 - it will come out to be true because this is not a vowel so we'll include this
2635:19 - so we'll simply append the space
2635:25 - moving ahead the fifth character is c so we'll simply include this because c is not a vowel
2635:35 - so c gets appended
2635:45 - now sixth character is r
2635:51 - so vowel dot contents r comes out to be false because r is not a vowel if we negate this
2636:00 - overall condition comes out to be true it means r is not a vowel and we need to include this
2636:08 - so we'll simply append r
2636:16 - the seventh character is e
2636:23 - so e is a vowel so vowel dot contents will return true and if we negate it
2636:30 - this condition will become false so we'll simply skip e because e is a vowel
2636:39 - now we will take the eighth character which is a
2636:45 - a is a vowel so we need to skip it
2636:52 - and at the last we will take m
2636:55 - so m is not a vowel so this condition is false and overall condition after
2637:06 - negating becomes true so we need to include m because m is not a vowel
2637:15 - so we have included m and after m there is no more character left so this for loop will terminate
2637:26 - so here you can see at the end whatever we collected into our string builder
2637:31 - if we do two string we will get a string like this and we'll simply return it from the
2637:40 - remove vowels method so friends in this video we saw the algorithm to remove vowels from a string
2637:50 - we took the help of the set and string builder to remove the vowels and return the final string
2638:00 - without these vowels i hope you must have liked this video and in case if you are new to my
2638:06 - channel then please subscribe to my channel and click the bell icon so that you never miss any
2638:11 - update thanks have a nice day hello everyone so in our previous video we saw an animation
2638:22 - and we discussed the problem that how we can remove the vowels from a string
2638:26 - so in this video we will be actually coding the algorithm and we'll test its working in the main
2638:31 - method so before we start in case if you're new to my channel then please subscribe to my channel
2638:38 - and click the bell icon so that you never miss any update
2638:43 - so here we have created one class as string util and inside that class i will be creating
2638:48 - one method as public static we'll give it a name as remove vowels this method will take a string
2639:01 - and this method will return back as a string without vowels so the input is a string with
2639:11 - vowels what we get in return is a string without vowels so here basic idea behind this algorithm
2639:18 - is we iterate over this string character by character and we figure out that which character
2639:24 - is vowel and which character is not so how can we figure that out first we will create
2639:34 - a set of vowels
2639:39 - using set dot of method
2639:43 - now this method will simply take the characters so we can provide the vowels as a
2639:50 - a e i o u also here this string will only contain the lowercase letters so we have only provided
2640:05 - the lowercase vowels now after creating the set of vowels what we can do is we will create string
2640:13 - builder class so this string builder class will help us in creating the string which we want to
2640:25 - return and this string builder class is performance efficient it has many utility methods by which we
2640:33 - can manipulate the string now in order to iterate the input string character by character what we
2640:41 - can do is we will call two char array method now this method basically return us a character
2640:52 - array so after getting the character array we will provide a for loop
2640:57 - where we will simply iterate over each character one by one so what we do is we provide a condition
2641:15 - if vowels contains the character so if vowel contains the character it means
2641:23 - this character is actually a vowel and we don't want to include it but if it is not a vowel then
2641:29 - we need to include that character into our final string so here what we do is we do the negation of
2641:36 - it so if character is present into this set this will return true and if we negate it we will we
2641:45 - are simply skipping the vowel and let's suppose character is something like c b j k for example
2641:55 - when we will call vowels dot contains this let's say c so it will return false this condition will
2642:02 - come out to be false and if we negate it it becomes true which means that if there is c
2642:10 - then we need to include that into our string so we'll simply append
2642:17 - the character to our string builder class so basically when we will encounter any vowel
2642:23 - this part will be skipped because vowels dot contains will return true and if we negate it
2642:30 - this condition comes out to be false and this part is skipped so after doing this for each
2642:35 - and every character at the end will simply return s b dot two string so this string builder
2642:44 - will simply append only the characters which are not vowels and at the end when we will call two
2642:50 - string it will convert everything into the string and it will return so this is the algorithm now
2642:57 - let's test it's working here we'll call remove vowels and let's say we provide string as
2643:11 - ice cream and if i run it
2643:14 - so here you can see all the vowels are removed i e e and a everything is removed and rest of
2643:31 - the string is returned also friends why we are using this set is because when we do contains
2643:40 - on a set this is a very faster operation the average time complexity of this operation is
2643:48 - o of one so basically it signifies that in o of n time we can simply find out the vowels
2643:56 - from the string and remove it so friends i hope you must have liked this video
2644:01 - in case if you are new to my channel then please subscribe to my channel
2644:04 - and click the bell icon so that you never miss any update thanks have a nice day
2644:11 - hello everyone so in this video we are going to discuss that how we can reverse an integer in
2644:16 - java so here let's suppose we are given an integer x now we need to return x with its digits reversed
2644:27 - so if you see an example here let's say if you are given with an integer as one two three four
2644:33 - so our output should be four three two one we are simply reversing the digits of this integer
2644:41 - similarly if you are given an integer which is negative one two three four so it should return
2644:49 - negative four three two one so the sign should be there with only digits being reversed
2644:57 - and let's say if you see example three here we are given an integer which is nothing but integer
2645:05 - dot max value which is two one four seven four eight three six four seven now when we reverse
2645:12 - this integer we get seven four six three eight four seven four one two so here you can see
2645:20 - that this is the integer's max value and if we reverse it this value may overflow
2645:31 - the integer range so we need to encounter this use case as well that when we are reversing
2645:37 - the max or the min value or any value of the integer which on its reversal may overflow
2645:45 - we need to encounter that use case as well so let's move ahead and see the demonstration
2645:51 - of the algorithm step by step so here you can see that we are given with a method as reverse
2645:57 - and we are passing in the number which we want to reverse so this method return type is long
2646:05 - now why we have kept the return type is long is because there may be a chance that let's suppose
2646:11 - this int value is maximum or any number which on its reversal may overflow the integer's maximum
2646:19 - range or minimum range so therefore in order to fit that particular range we are taking a long value
2646:27 - which will be returned from this method so here this long is basically handling our overflow case
2646:34 - because when we cross the integer's range the data type which can handle that overflow range
2646:42 - would be the long so now let's see the demonstration of this algorithm step by step
2646:51 - let's say we want to reverse a negative number one two three four
2646:56 - so here the number will be minus one two three four
2647:04 - so here you can see the first thing we do is we simply check that whether this number is negative
2647:08 - or not so if we provide this condition and whether number is less than zero or not so if number is
2647:14 - less than zero the is negative will have value as true currently number is less than zero
2647:22 - so the value of this negative will be true by this condition
2647:30 - and why we are evaluating whether number is less than zero or not
2647:34 - because when we are reversing the digits we need to take its absolute value without the sign
2647:40 - we'll see this later so for time being we just evaluate whether number is less than zero or not
2647:47 - if it is less than zero then we simply multiply it with minus one to make it a positive number
2647:56 - so now number will become one two three four so here minus one two three four
2648:03 - into minus one will give one two three four this minus minus becomes positive
2648:10 - so here we have the integer value
2648:17 - moving ahead now in order to store the reverse we are taking in a long value
2648:24 - and why we are taking it is a long values because
2648:31 - because this integer value number if we reverse the digits of it there may be a chance
2648:36 - the maximum or minimum range of the integer so therefore in order to accommodate this overflow
2648:42 - condition we are taking it as long because any value which crosses integers max or min range
2648:50 - can be fit into the long variable so at the start reverse is zero
2648:56 - so we will create the last digit integer value so this integer value will hold only one single
2649:06 - digit which would be the last digit which we will see later here
2649:14 - so friends in order to reverse this integer value these are the three main critical steps
2649:20 - we need to perform in a while loop this is one of the approach to reverse the integer value
2649:28 - now there can be one more approach we can simply take the string value of this number
2649:34 - convert it into the character array and then we simply reverse the characters in that particular
2649:39 - array so that could be one case but here we are taking the help of modulus operator and the division
2649:47 - operator because this modulus operator is very important when dealing with numbers
2649:54 - so here we will discuss what actually this modulus operator does and division operator does
2650:01 - so currently number is greater than zero so this while loop will execute till number is greater
2650:07 - than zero when number will be equal to zero or less than zero then this while loop will terminate
2650:12 - so friends here you can see that in order to reverse this number one two three four
2650:21 - it should become four three two one so what we need to do is we need to first take the last digit
2650:32 - bring to this position then second last digit bring to this position third last to this position
2650:39 - and fourth last to the last position so these are the things we need to do
2650:45 - so how we can extract the single single digits from this number is we can take the help of
2650:51 - modulus operator so here you can see let's say we want to divide 12 by 10 so 10 is the divisor
2651:01 - 12 is the dividend and in normal mathematics when we divide 12 by 10 we get quotient as 1
2651:10 - and the remainder as 2 so here this remainder is nothing but the result of the modulus operator
2651:17 - which you see here and this one is nothing but the result of the division which we do here
2651:25 - so using the simple mathematics we will evaluate the reverse of this number
2651:33 - and also friends here you can see that in order to get four when we divide any number by 10
2651:42 - whatever the remainder we get that would be our last digit so here if we divide one two three four
2651:50 - let's say if i do one two three four
2651:55 - and let's say divided by 10 so one
2652:05 - two
2652:13 - so here you can see that this is our quotient
2652:17 - and this is our remainder so when we are divided one two three four by ten
2652:22 - we get the remainder as four which is nothing but our last digit
2652:27 - and the quotient would be the remaining digits just before the last digit
2652:34 - so this is the crux of the algorithm that when we divide any number by 10 the remainder will
2652:41 - give the last digit and the quotient will give the remaining digits so here when we take the
2652:49 - remainder of the number which is one two three four the last digit will have value as four
2652:58 - because this is our remainder here moving ahead
2653:03 - now friends as we have extracted the last digit this would be our first digit when we do the
2653:09 - reversal so here if i reverse one two three four we get four three two one so this would be our
2653:16 - first digit now so in order to make it first digit what we do is whatever the value reverse
2653:22 - will hold we will simply multiply it by 10 and we will add the value stored in the last digit
2653:31 - we will see the importance of this part later so currently reverse is zero so zero into 10 will
2653:37 - give zero and when we will add four to it we get reverse as four so reverse will become four
2653:44 - four this part will be clear in the next iteration moving ahead now as we have extracted one digit
2653:56 - we need the rest of the digits now and how we can get the rest of the digit is the quotient
2654:05 - of this division so when we will do number divided by 10 we get the quotient as one two three
2654:14 - so the new number will become one two three
2654:20 - moving ahead so number is greater than zero one two three is greater than zero
2654:26 - so this condition comes out to be true now we need this last digit so what we need to do is
2654:34 - we need the remainder so when we will divide one two three by 10 because this is our new number
2654:49 - so here we'll get 10 one
2654:51 - so here you can see when we divide one two three by 10 we get remainder as three
2655:05 - and the quotient as 12 so this is a similar approach when we divide any number by 10
2655:13 - the last digit is our remainder and the remaining digit is our quotient
2655:18 - so now last digit will become three because we need three to simply append it here somehow
2655:29 - moving ahead so for us now as we have got three as last digit and we need to append it here
2655:38 - we can't directly add this three to the reverse what we do is whatever the value reverse will
2655:44 - hold if suppose this is four and if i multiply it by 10 we will get 40 and then if i add the last
2655:53 - digit which is three we will get 43 which is the stuff we want if it reverse one two three four
2656:04 - we should get four three two one so four and three should be next to each other so this is
2656:12 - the important step here that when we are multiplying the reverse by 10 we are simply shifting
2656:19 - the digit by one place and we are adding the last digit to it so that
2656:26 - both these numbers are next to each other so this is the important step
2656:42 - so here now reverse will become 43 what we discussed here
2656:52 - and as we are done with the digit three we need the remaining digits so the remaining digits we
2656:58 - get by number divided by 10 which will give us the quotient so number will become 12
2657:07 - and the number is still greater than zero so this condition comes out to be true
2657:15 - now we will take the last digit
2657:23 - and how we can get the last digit is we divide the number by 10
2657:28 - so this is our remainder
2657:38 - and this is our quotient so our last digit is 2 because number modulus 10 will give us the
2657:46 - remainder as 2 so 2 will be assigned to the last digit and now how we can append two just after
2657:56 - three is we need to create one space here and how we can create the spaces we simply
2658:04 - multiplied by 10 we get 430 and then we simply add two to it which is our last digit we get four
2658:13 - three two so this is the step which helps us in appending the last digit to the reverse
2658:22 - so after this line gets executed reverse will become four three two with this multiplication
2658:31 - and addition moving ahead we are done with two and now we simply need one so our new number will
2658:42 - become the new quotient by number divided by 10 so we'll get the new number as one
2658:49 - number is still greater than zero so this condition comes out to be true
2658:56 - now we need the last digit but here you can see one is the only digit left so here
2659:09 - when we will divide one by ten
2659:12 - we get remainder as one and quotient as zero because one is not divisible by ten
2659:22 - so one will be our remainder and quotient will be zero
2659:28 - so now last digit will become one this
2659:35 - and here
2659:36 - here how we can append this last digit to four three two is
2659:45 - four three two into ten it will give us four three two zero we will do plus one we get four three
2659:54 - two one so this is our last digit so by these two operations the reverse will become four three two
2660:03 - one and now we'll simply assign number divided by 10 value to number so here you can see when one
2660:14 - got divided by 10 the quotient was zero which is the result of our division so zero will be
2660:20 - assigned to the number so number became zero so now here you can see this while loop will terminate
2660:29 - because number is equal to zero and not greater than zero so this value will terminate and here
2660:37 - is the important step that why we are providing this condition is because we have used up all the
2660:45 - digits of our original number and we have reversed it so therefore this condition is very important
2660:53 - that number should be greater than zero because when number will be equal to zero
2661:00 - it means there is no value left in the number to be reversed
2661:05 - and at the last we simply check whether our original number was negative or not
2661:11 - so our original number here was negative so if it is negative then this condition will be executed
2661:20 - we will simply multiply reverse by minus one so four three two one into minus one will give
2661:31 - minus four three two one so minus four three two one will be returned from this reverse method
2661:40 - and if is negative would have been false then we would have simply written the reverse
2661:45 - so friends this is how we actually reverse an integer value there are three steps to remember
2661:54 - first we need to evaluate whether the number is less than zero or not the second is we need to
2662:00 - take this data type as long because when we reverse a bigger integer value there may be a chance
2662:08 - that its reversal may overflow the integer value
2662:12 - so if we take integer here then this reverse will only hold the garbage value
2662:18 - which we don't want so in order to accommodate the large overflow integer value we will store
2662:26 - it in the long because long can accommodate that value the other thing is this simple mathematics
2662:33 - which is very important when we divide any number by any value whatever is the remainder
2662:40 - if we want to achieve the remainder directly we can use the modulus operator which is here
2662:47 - and if we want to access the quotient we can simply take the value of the division here
2662:53 - and using these three steps we have actually performed the reversal of this integer
2662:58 - so friends i hope you must have liked this video in case if you're new to my channel then please
2663:05 - subscribe to my channel and click the bell icon so that you never miss any update thanks have a nice day
2663:15 - hello everyone so in this video we are going to discuss a lead code problem remove element
2663:22 - so friends before we start in case if you're new to my channel then please subscribe to my channel
2663:27 - and click the bell icon so that you never miss any update so in this problem we are given an
2663:32 - integer array and we are also given with a integer value now our task is to remove all the occurrences
2663:40 - of that value from the integer array and that too in place so what do we mean by in places
2663:46 - let's say if we take this example and this is our input array and this is the value given to us
2663:52 - which is 3 now our task is to remove all the occurrences of this value from this array dead
2663:58 - to in place so it means that we have to modify the given array in such a way that we have to
2664:04 - remove all the occurrences of this value we can't use additional data structure or an additional
2664:10 - array for this removal whatever operation we need to do we have to perform in the given array itself
2664:16 - and in this problem after removal of all the occurrences of the value it is okay that order
2664:22 - of the elements may change so for example in the second array when the value is 2
2664:28 - you can see after removing the 2 we are getting 0 1 4 0 3 now here we can also return something
2664:35 - like 4 1 0 0 3 so the order of the elements may get changed but our task is to just remove all
2664:44 - the occurrences of the given value and finally we have to return an integer value which is a count
2664:49 - of the elements which are not equal to the given value so here in the first example you can see
2664:53 - the array is 3 2 2 3 and the given value is 3 so after removing 3 we are only left with 2 2
2665:02 - so the output would be 2 because there are two values 1 and 2 similarly here let's say we are
2665:08 - given with this array and the value is 2 so after removal of all the occurrences of 2 we get 1 2
2665:18 - 3 4 5 so our output should be 5 now here we have to do two tasks first is we need to return
2665:28 - the count of the values which are not equal to well so which is our k and the second task is
2665:34 - we have to actually perform this removal in place in the given array so we have to remove all
2665:42 - occurrences of well in array and det2 in place so we have to perform this two tasks now if we
2665:58 - look into the problem this is the problem on lead code we have to do this two tasks so whatever the
2666:04 - array is given to us we have to modify the same array and we have to return the total number of
2666:09 - elements which are not equal to this value so for example in the first task case if the well is 3
2666:17 - and the array is 3 2 2 3 so we know that after removing 3 the number of elements which are not
2666:23 - equal to well is 2 1 and 2 so here if i directly return let's say 2 so this task should get passed
2666:32 - but if i run the code so here you can see that we have returned 2 which is our output but we
2666:40 - haven't modified the array in place so the lead code editor will also check our the given array
2666:47 - that we have removed all the occurrences of the given value from the given array
2666:52 - now let's see how we can approach the solution of this problem
2666:55 - so for example let's suppose we are given with this array 0 1 2 2 3 0 4 2 our task is to remove
2667:04 - all occurrences of 2 the output should be 5 because the total number of elements which are not equal to
2667:10 - 2 are 5 1 2 3 4 5 and the remaining element is shown blank because the task case doesn't look
2667:17 - beyond our output which is 5 so here how we can approach this problem is we can use two pointers
2667:23 - let's say i and j so let's suppose if this is our array
2667:30 - and we have to remove all the occurrences of 2 so this is our well now here two pointers will move
2667:37 - throughout this array in such a way that one is slow pointer and another is fast pointer
2667:42 - so let's say they both start at 0 the index and here let's suppose j is our fast pointer
2667:49 - and i is slow pointer so j will travel each and every element throughout this array so it's just
2667:59 - for iteration and here i will move slowly and its main purpose is to actually remove all the
2668:08 - occurrences of the given value so once it removes the occurrences of the given value it will then
2668:14 - move ahead slowly so here it helps to remove the element so here what do we do is as j is iterating
2668:24 - our complete array we simply compare the value at jth index with the value we want to remove
2668:30 - and i is actually helping us to remove that value so here if the value at jth index is not equal to
2668:36 - 2 it means we have found an element which we need to keep in the array so we simply take that value
2668:43 - and assign it to the ith index and then we actually increment i so let's see why an example
2668:49 - so currently the value at jth index is 0 it is not equal to 2 so 0 is not equal to 2 so it means
2668:57 - that we have found a value which we need to keep in this array and we know that i will help us in
2669:03 - keeping that value in the array so at the start we will assign 0 to the ith index so this value
2669:08 - stays here and we increment i to the next index so i comes here and j is actually traversing the
2669:17 - array so it will also get incremented now we again check that value at jth index 1 whether it is equal
2669:25 - to 2 or not so 1 is not equal to 2 so we assign the 1 to ith index it means the same value is
2669:32 - assigned to this index and we move ahead so i moves to this index and j also moves to the second
2669:41 - index now here the value at jth index is 2 and 2 is actually equal to 2 so here we know that we
2669:49 - have to remove this occurrence so i will actually point to the same index because its task is to
2669:54 - actually remove this element so when the value at jth index is equal to our value which we want to
2669:59 - remove we don't move the ith index we only move the jth index because i is actually helping us to
2670:05 - remove this value so here i stays at the same place and j moves so j comes here now again here
2670:13 - the value at jth index is 2 and 2 is equal to 2 and we have to remove this occurrence
2670:19 - via taking help of ith pointer so here i stays at the same place and j moves
2670:25 - so j comes to the fourth index now value at jth index is 3 and 3 is not equal to 2
2670:34 - so it means we have to move this value here so that this occurrence can be removed
2670:39 - so when we move 3 here it would look something like this the 2 is gone and 3 comes here
2670:46 - and after the assignment i will move to its next index
2670:49 - because its task is to remove all the occurrences of the given value and j usually moves ahead
2671:02 - so it goes to fifth index now here the jth index value is 0 and 0 is not equal to 2
2671:08 - so therefore we will assign this value at the ith index like this and here now value will become
2671:17 - 0 and now both the pointers will move ahead
2671:30 - now here value at jth index is 4 so here 4 is not equal to 2 so therefore we will assign this value
2671:38 - at the ith index so it would look something like this so 3 will be gone and here it will be 4
2671:46 - and both the pointers will move ahead so i will come here and j will come here so now the value
2671:54 - at jth index is 2 and 2 is equal to 2 so we do nothing here we simply increment j so now j is
2672:01 - traversed complete array and here you can see the ith index will be our answer because this
2672:08 - is the last place where we need to remove an element but we didn't find any more elements
2672:13 - so after removal of 2 our output came out to be 5 so if we put the index at 0 1 2 3 4 and 5
2672:23 - so this 5 is nothing but a value which is pointed by the ith index and this would be our answer
2672:29 - because till this point all the occurrences have been removed and after that there were no more
2672:36 - elements to be removed so therefore we have achieved two tasks one is we are returning the
2672:41 - output as 5 and another is we have modified the array in place and we have removed all the
2672:48 - occurrences of 2 so in this problem the basic ideas we are using these two pointers i and j
2672:55 - the purpose of j is to simply traverse the array compare the value at jth index with the value we
2673:01 - want to remove and the purpose of i is to actually remove the element via assignment when we actually
2673:07 - find a value at jth index not equal to the value which we want to remove now let's move ahead and
2673:13 - see the demonstration of this algorithm step by step so friends before we start in case if you're
2673:18 - new to my channel then please subscribe to my channel and click the bell icon so that you never
2673:23 - miss any update so here this is the code and let's say we are given with this array which we
2673:30 - discussed in our previous slide we are calling remove element method passing in this array
2673:36 - and the value is 2 for which we want to remove all the occurrences in this array
2673:43 - so we have num's array and the val as 2 now we are creating these two pointers i and j
2673:50 - so here i starts from 0 and as we know that the purpose of j is to simply traverse the array
2673:58 - and compare the value at jth index with the actual value we want to remove so we are using
2674:02 - a simple for loop here so j starts from 0 so at the start j is 0 and num's dot length is 8
2674:10 - because we have 8 elements 1 2 3 4 5 6 7 8 and 0 is less than 8 so this for loop will execute
2674:20 - and as we already discussed we have to simply provide one if check that whether value at jth
2674:26 - index whether it is equal to val or not so currently value at jth index is 0 and 0 is not equal to 2
2674:34 - so therefore this condition comes out to be true it means that we have found a value which is not
2674:40 - equal to 2 and which we need to keep in the array so the way we keep in the array is via ith pointer
2674:48 - so we simply assign num's of j to num's of i so num's of j is 0 is assigned to num's of i
2674:55 - which is at zeroth index so this value assigned to the same index like this
2675:02 - and the actual purpose of i is to actually remove the elements and keep only those elements which
2675:07 - are not equal to 2 so after putting a value which is not equal to our given value we move i to the
2675:13 - next index like this we will increment j j comes to index 1 and 1 is less than 8 so this for
2675:25 - loop will execute we again compare the value at jth index with the given value so the value at jth
2675:32 - index is 1 and 1 is not equal to 2 so therefore we have again found a value which is not equal to
2675:39 - the value which we want to remove so the condition in iflog comes out to be true
2675:44 - and we simply assign value at jth index to value at ith index so 1 is assigned to the same index
2675:50 - because i and j are pointing to the same index and after putting a value which is not equal to
2675:56 - 2 we simply increment i we increment j so value of j is 2 and 2 is less than num's dot length
2676:09 - which is 8 so this for loop will execute we again compare the value at jth index with the given
2676:16 - value so yet 2 is actually equal to 2 so the condition in iflog comes out to be false whenever
2676:24 - we are encountering a value which we want to keep in the array at that time we are doing this
2676:29 - assignment and as soon as we are finding a value at the jth index equal to the value which we want
2676:34 - to remove we do nothing and we simply increment j so i will actually remain at this position
2676:42 - because in the future there could be a values which we want to migrate to this index because
2676:48 - we want to remove this 2 so let's say in future there is 3 0 4 so 3 should come here and this 2
2676:55 - should get removed so this i should stay at the same place so now value of j is 3 3 is less than 8
2677:02 - so this for loop will execute now value at jth index again is 2 and 2 is equal to 2 so therefore
2677:09 - the condition in iflog comes out to be false and we do nothing we again increment j value
2677:17 - of j becomes 4 4 is less than 8 so this for loop will execute now the value at jth index is 3
2677:25 - so here 3 is not equal to 2 so it means we have found a value which is not equal to the given
2677:30 - value and we need to keep this value in the array and this index is not the right place for the
2677:35 - value 3 so therefore this i will actually help us in shifting of this 3 from here to here via
2677:42 - this assignment so the condition iflog comes out to be true we assign the value at jth index which
2677:48 - is 3 to ith index so now this 2 will go away and this 3 will come here like this
2677:59 - and after placing 3 at its correct spot now it's time to move i to the next index
2678:04 - because in the future there could be more values which can come here so we simply increment i
2678:10 - value of i becomes 3 we increment j j becomes 5 5 is less than 8 so this for loop will execute
2678:22 - now value at jth index is 0 and 0 is not equal to 2 so this condition comes out to be true
2678:29 - so it means we have to shift this 0 to its correct position which is being denoted by i
2678:36 - so here we simply assign value at jth index to value at ith index so 0 comes here with this
2678:43 - assignment and after placing 0 at its correct spot we will simply increment i
2678:53 - we will increment j j becomes 6 6 is less than 8 so this for loop will execute
2679:05 - so value at jth index is 4 4 is not equal to 2 so therefore this condition comes out to be true
2679:13 - and we simply shift this value 4 at index i so 4 comes here via this assignment
2679:23 - and then we simply increment i because we have placed 4 at its correct spot
2679:31 - we increment j j becomes 7 7 is less than 8 so this for loop will execute
2679:39 - so now here value at jth index is 2 2 is actually equal to 2 so therefore the condition in a block
2679:46 - comes out to be false so we do nothing and we simply increment j so value of j becomes 8 and 8
2679:54 - is not less than 8 so therefore this for loop will terminate and at the end we'll simply return
2680:04 - the value which is being hold by i which is 5 because this was the last place where we couldn't
2680:10 - remove the occurrence and before that we have removed all the occurrence and as the array
2680:15 - starts from zeroth index we have to return a value which is the total number of elements
2680:19 - which are not equal to our given value so here we had 0 1 3 0 4 which were not equal to 2
2680:28 - and if we count them we have 1 2 3 4 5 so whatever value i holds that will be our answer
2680:36 - so we simply return 5 and we have also modified the array in place by removing all the occurrences
2680:43 - of our given value which is 2 so friend this was all about the remove element problem
2680:50 - i hope you must have liked this video thanks have a nice day
2680:55 - hello everyone so in this video we are going to discuss a lead code problem
2681:00 - remove duplicates from sorted array
2681:04 - so friends before we start in case if you're new to my channel then please subscribe to my channel
2681:09 - and click the bell icon so that you never miss any update
2681:14 - so in this problem we are given with an integer array and the array is sorted in non-decreasing
2681:19 - order so as a input we are given with an integer array and the integer array is sorted in ascending
2681:25 - order now as the array is sorted in ascending order there may be duplicates now our task is
2681:32 - to remove the duplicates and that too in place so by in place we mean that we cannot use additional
2681:38 - array or any other data structure we have to modify the same array and we have to remove
2681:44 - the duplicate such that each element appears only once so for example let's say we have this input
2681:51 - array 1 1 2 so the array is sorted and here we have one duplicate which is 1 so we have to remove
2681:58 - this duplicate such that only one occurrence of an element occurs such that the element appears only
2682:06 - once so after removal of the duplicates we get two numbers 1 and 2 and this one is removed
2682:14 - so our output is 2 and the array is modified like this 1 2 and whatever elements are left over
2682:21 - those are ignored and one more thing we need to keep in mind is the relative order of the element
2682:26 - should be kept the same so we have to modify the input array in such a way that let's say we have
2682:31 - 1 1 and 2 so at the start there should be 1 and after that 2 should come it should not be like
2682:38 - this 2 comma 1 because we have to maintain the relative order of the elements so let's say if
2682:44 - you are taking the second example now if we remove the duplicates from this sorted array
2682:51 - so here we have 2 0 so 1 is removed because the element should appear only once after 0
2682:59 - if we see the relative order the next number is 1 and we have 3 1s so we have to remove this 2 1s
2683:07 - and we need to keep only one occurrence of 1 and after that we have 2 2s so we have to remove 1 2
2683:14 - and we have to keep only 1 2 then we have 2 3s so we have to remove 1 3 and at the end we have 4
2683:20 - so 4 is itself unique so after the removal of duplicates if we count the unique elements
2683:25 - so we get 1 2 3 4 and 5 elements so our output is 5 and we have to modify the array in place
2683:37 - so at the start 0 comes then 1 comes then 2 then 3 and then 4 so the relative order is maintained
2683:47 - and the rest of the elements are just ignored so let's move ahead and see how we can solve
2683:53 - this problem so suppose we are given with this array 0 0 1 1 1 2 2 3 3 4 now our task is to
2684:02 - remove the duplicates and keep only one occurrences of the element so let's say our array is 0 0 1 1
2684:09 - 1 2 2 3 3 4 so your first property is the array is sorted in ascending order
2684:19 - so it means whatever duplicates we have they are very adjacent to each other
2684:25 - so second property is duplicates
2684:33 - are adjacent to each other
2684:38 - now how we will solve this problem is we will take two pointers i and j
2684:43 - so here j will traverse each and every element of this array so therefore it's a fast pointer
2684:51 - and i will move slowly so it's a slow pointer now the purpose of j is to basically iterate
2685:00 - the array
2685:04 - and compare the duplicates
2685:07 - and the purpose of i is to actually remove
2685:16 - the duplicates
2685:21 - so as soon as i removes the duplicates from this array it will move slowly one step at a time
2685:28 - and j will simply traverse the array once so here both the pointers will start from first index i
2685:34 - and j so i start from first index because the 0th index already contains a unique element
2685:43 - and the next unique element should come here so i starts from here and its main purpose is to
2685:48 - remove the duplicates and after removal of duplicates it simply moves ahead now similarly
2685:54 - j starts from first index because it actually compares current element with previous element
2686:00 - so that it can figure out that these two numbers are duplicates so what it does is
2686:08 - we simply compare
2686:15 - value at jth index with value at j-1 index so therefore we have to start from the first index
2686:22 - so as soon as j moves ahead we simply compare the current element with its previous element
2686:27 - to figure out whether they are duplicates or not so at the start value at jth index is 0
2686:34 - and j-1 index is also 0 so here 0 is equal to 0 therefore this condition comes out to be false
2686:43 - so whenever this condition comes out to be false we actually do nothing and we simply traverse j
2686:49 - to its next index so j will come to the second index now value at jth index is 1
2686:58 - and j-1 index is 0 so 1 is not equal to 0 so this condition comes out to be true
2687:05 - so whenever this condition comes out to be true it means that we have found a unique element
2687:10 - because the element just before that is different from this so whenever this condition comes out to
2687:16 - be true it simply means that when we compare these two elements they were not equal so the
2687:23 - current integer is actually a unique integer which we need to keep in the array so what we
2687:29 - do is when this condition comes out to be true we simply assign
2687:38 - value at jth index to value at i-th index because the purpose of i is to actually remove the
2687:43 - duplicates and we know that 0 is a duplicate here so we simply assign value at j-th index to
2687:49 - value at i-th index so after this assignment 1 comes here after this assignment we know that
2687:57 - the next unique element should come here so we simply traverse i ahead so i comes here
2688:04 - and j will move to the third index so purpose of j is to simply traverse the array one element at
2688:12 - a time and compare the current integer with its previous integer so now value at jth index is 1
2688:20 - and value at j-1th index is also 1
2688:25 - so they are equal so this condition comes out to be false and we know that once this condition
2688:31 - comes out to be false we do nothing and we move simply j one step ahead because we didn't find
2688:38 - any other unique element so that we can replace it with i-th index we simply move j one step ahead
2688:46 - now again value at j-th index is 1 and value at j-1th index is also 1
2688:52 - so it means this condition comes out to be false and we do nothing we simply traverse j one step
2688:57 - ahead now here value at j-th index is 2 and value at j-1th index is 1 so 2 is not equal to 1 so
2689:10 - therefore this condition comes out to be true so when this condition comes out to be true
2689:15 - we know that we have found a unique element which we need to keep in the array and we know that we
2689:21 - are using this i-th pointer to simply put this value in the array so once this condition comes
2689:27 - out to be true we perform this step so value at j-th index we simply assign it to value at i-th
2689:34 - index so this two comes here and this one which is duplicate gets removed so two comes here
2689:42 - and after this assignment we do i++ because the next unique element will come here
2689:51 - so i comes here and j traverse ahead now value at j-th index is 2 and value at j-1th index is
2690:01 - also 2 so this condition comes out to be false so therefore we do nothing and we simply traverse
2690:11 - j ahead now here value at j-th index is 3 and value at j-1th index is 2 so 3 is not equal to 2
2690:22 - it means we have found one more element which is unique and which we need to keep in the array
2690:27 - once this condition comes out to be true the correct place for this three is we simply assign
2690:33 - the value at j-th index to value at i-th index so this three comes here so this one goes away
2690:41 - and three comes here and after this assignment we simply increment i because the next unique
2690:48 - element should come here so i moves here and j moves here now the value at j-th index is 3
2691:00 - and j-1th index is also 3 so therefore this condition comes out to be false
2691:06 - so we do nothing we simply traverse j to the next index
2691:14 - j comes here now value at j-th index is 4
2691:20 - and value at j-1th index is 3 so 4 is not equal to 3 so this condition comes out to be true
2691:28 - it means we have found one more unique element which we need to keep in the array
2691:33 - so we simply assign this value to nums of i so this four will come here and this one will go away
2691:43 - and after this assignment we move i one step ahead and j also one step ahead so now j is
2691:51 - actually traversed till the end of the array and we know that we have removed all the duplicates
2691:56 - till this point and if we count the number of elements we have one two three four five
2692:05 - so our output would be five and here as this is an array so this is zero index first second third
2692:14 - fourth and this is fifth so we simply return the value which is stored in i which is five
2692:21 - and rest of the elements can be ignored so this array can be ignored our task was to remove all
2692:28 - the duplicates such that each element appears only once so now let's move ahead and see the
2692:34 - demonstration of this algorithm step by step so friends before we start in case if you're new to
2692:40 - my channel then please subscribe to my channel and click the bell icon so that you never miss any
2692:45 - update so here this is the code and let's say we are given with this array which is sorted
2692:52 - in ascending order and our task is to remove the duplicates now as the array is sorted the
2692:58 - duplicates will be adjacent to each other so when we call this method the first thing we do is
2693:05 - we create these two pointers i and j where j is our fast pointer it traverses the array from index
2693:12 - one to index seven and i will start from one because this zero is already at its correct place
2693:20 - and unique so we don't touch the zeroth index and we start from the first index
2693:27 - so we start j also from the index one and why we are starting from j equal to one is
2693:33 - we simply compare the current and the previous element so we start from index one
2693:40 - and j will travel till num.length so num.length is eight so one is less than eight so this
2693:49 - condition comes out to be true and the for loop will execute now in the for loop what we do is
2693:56 - we simply compare the two adjacent values which is the value of jth index and the value of j
2694:02 - minus one-th index and we check whether they are duplicates or not so currently value of jth index
2694:09 - is zero and j minus one-th index is also zero so therefore this condition comes out to be false
2694:14 - because both the values are equal so when both the values are equal it means we have found a
2694:19 - duplicate and we do nothing we simply increment j j becomes two two is less than eight so the for
2694:32 - loop will execute value of j minus one-th index is zero and value of jth index is one
2694:40 - so zero is not equal to one so this condition comes out to be true it means we have found
2694:48 - one unique element which we need to keep in the array because the adjacent elements are different
2694:53 - it means this value is the first integer which is unique so we need to keep this value in the array
2695:00 - so the if block will execute and we know that index i will actually help us in placing this
2695:06 - value at its proper position so we simply assign nums of j to nums of i so one comes here
2695:16 - and we know that next unique element should come here so we simply increment i so i becomes two
2695:23 - we increment j so j becomes three three is less than eight
2695:32 - we compare these two values now and one is not equal to two so therefore this condition
2695:37 - comes out to be true it means we have found one more element which is two which is unique in this
2695:43 - array and which we need to actually keep in the array so the condition in if block comes out to
2695:48 - be true and we assign this value to nums of i because i is actually holding that place where
2695:55 - we can only insert a unique element so via this assignment two comes here
2696:03 - and next unique element should come here so we simply increment i i becomes three
2696:09 - we increment j j becomes four four is less than eight so this for loop will execute
2696:24 - so now we are comparing these two values so condition in if block comes out to be false
2696:28 - and we do nothing we increment j j becomes five five is less than eight so the for loop will
2696:39 - execute and now we are comparing these two elements so the condition in if block comes out to be false
2696:47 - we simply increment j j becomes six
2696:57 - and six is less than eight so this for loop will execute
2697:02 - and now we are comparing these two elements so two is not equal to four so this condition comes
2697:08 - out to be true and we have found one more element which is four which is unique and which we need
2697:14 - to keep in the array so the if block will execute and how we will keep this value four in the arrays
2697:21 - we simply assign value at j's index to value at i's index so this four will come here
2697:34 - and we know that the next unique element should come here so we simply increment i
2697:38 - i becomes four we simply increment j
2697:47 - j becomes seven seven is less than eight so this for loop will execute
2697:53 - now we'll compare these two elements so here both the elements are equal it means we haven't found
2697:58 - any unique element so the condition in if block comes out to be false
2698:02 - we increment j so j becomes eight and eight is not less than eight it means we have traversed
2698:13 - all the elements of this array so this for loop will terminate and here you can see whatever the
2698:20 - value i is holding that will be our answer so if we count the unique elements we have one two three
2698:28 - four and here we can see as the array starts from zeroth index so whatever the value i is holding
2698:34 - which is four will give the total number of elements which are unique in this array which
2698:40 - is four so we simply return four from this method but that is our answer and we have also modified
2698:47 - the array in place so friend this was all about remove duplicates from sorted array
2698:52 - i hope you must have liked this video thanks have a nice day
2698:59 - hello everyone so in this video we are going to discuss a very famous interview problem
2699:06 - which is threesome problem so in this problem we are given an array of distinct integers
2699:14 - now our task is to print all such triplets such that they add up to a specific target
2699:21 - and the triplet should be ordered in ascending order so let's say we are given an array of
2699:26 - integers now these are actually distinct integers two four three seven one eight nine zero we need
2699:37 - to print all such triplets such that they add up to a specific target so we have been provided with
2699:45 - the array and a target value the triplet should be ordered in ascending order so we need to find
2699:52 - three numbers such a way that when we add them we get a target of six and that two number should
2700:00 - mean ascending order so for example zero plus two plus four will give six and here zero two and four
2700:09 - are in ascending order one plus two plus three will also give us six one two three are in ascending
2700:16 - order so we need to find all such triplets with sum of two a specific target and they are ordered
2700:23 - in ascending order so let's see the demonstration of this algorithm step by step
2700:28 - so here this is the algorithm where method name is threesome we are given an array and a target
2700:43 - let's say we are given with an array having six elements
2700:47 - two four three seven one zero and a target let's say six so when we call threesome method
2700:56 - we pass the array and the target as six
2701:03 - so friends basic idea behind this algorithm is first we sort the array
2701:16 - second we use three pointers
2701:18 - so when we sort the array we can print the triplets in ascending order so that is one of
2701:30 - the use case and the second use case is when we sort the array we can use three pointers
2701:38 - which can provide us three numbers which add up to a specific target
2701:41 - and that too with a optimized time complexity so here the three pointers we use are i, j and k
2701:52 - which we will be seeing later here so these three pointers will give us three different numbers
2701:59 - from the array we will take up their sum and print it on the console if sum is equal to target
2702:06 - so let's see the demonstration of this algorithm step by step
2702:11 - so in the first step we are actually sorting the array in ascending order
2702:18 - so two four three seven one zero will be sorted and it will become zero one two three four seven
2702:27 - moving ahead now as we discussed that we will be using three pointers
2702:34 - i, j and k so for i it will start from zero and it will go to array.length minus two
2702:46 - so we will see why we are taking minus two later but it will start from zero and it will go to
2702:54 - index three which is array.length six minus two four so here less than means that it will go till
2703:05 - three we will see later that why we are taking array.length minus two so currently i will start
2703:15 - from zero it means it will be pointing to the zeroth index of the array
2703:24 - now as we need to find the three numbers which are distinct so the j pointer will start from
2703:30 - i plus one so here whenever this for loop will start with any value of i j will start from a
2703:38 - value just ahead of it so value of j will start from one
2703:46 - and we will take the k pointer we will start it from array.length minus one it means
2703:53 - the third pointer will start from the the last index which is array.length
2703:59 - six minus one which is five so k will start from five
2704:08 - we will see its significance that why we are starting it from array.length minus one
2704:13 - moving ahead so friends as we have now pointed i, j and k to three different indexes
2704:21 - we will try to find out the sum of these three numbers and then we will figure out
2704:27 - whether they are equal to the target or not so this for loop will actually help us in traversing
2704:33 - i and this while loop will help us in traversing j and k so as we want to find the three distinct
2704:41 - numbers we have provided a while loop and the condition is j should be less than k
2704:47 - so here j and k will traverse through this array j will traverse in this direction and
2704:53 - k will traverse in this direction covering up the elements so this while loop will go
2704:59 - till j is less than k because if j will be equal to k both j and k will point to the same number
2705:05 - which we don't want so j should be less than k in the first step what we are doing is we are
2705:15 - calculating the sum of array ith index at jth index and at the kth index because we need to
2705:23 - find out the triplets so i j and k will provide us that triplet so when we do sum of 0 1 and 7
2705:35 - we get 8 so sum will become 8
2705:41 - now we simply check whether sum is actually equal to our target or not
2705:45 - so our target is 6 and sum we want is 8 so this condition comes out to be false
2705:53 - so here as i is fixed at 0th index we have sorted the array in ascending order it means
2706:02 - whatever value will come after 1 will be greater than 1 and whatever value will come before 7
2706:09 - will be lesser than 7 because the array is sorted now when we compared sum with target
2706:15 - we found out that sum is actually greater than target sum value is 8 and it is greater than
2706:22 - target so somehow we need to reduce the value of sum in the next iteration so that it matches the
2706:30 - target so what we do is we provide these two conditions we check whether sum if it is not
2706:38 - equal to target we check whether it is less than target or it is greater than target
2706:44 - so currently if sum is greater than target it means we need to reduce the sum so here array
2706:50 - is sorted i is fixed the only option we have is to move j this direction or k this direction
2707:00 - if we move i this direction in the next iteration when we will do sum
2707:08 - the sum will become 0 plus 2 plus 7 which will give us 9 which is actually more than the current
2707:16 - sum and which we don't want so let's say if we move k this direction so k will come here
2707:26 - and if we do sum in the next iteration we will get 0 plus 1 plus 4 which will be equal to 5
2707:35 - which is actually reducing the sum to get it more closer to 6 so here as the array is sorted
2707:45 - when sum is greater than the target we actually move k to this direction so that in the next
2707:51 - iteration the sum will become closer to 6 which is our target and if sum is less than target
2707:59 - then we move j to this direction because that will only increase the sum
2708:04 - and then it will match our target so currently sum is greater than target so this condition
2708:10 - also comes out to be false so the only option we have is when sum is greater than target
2708:18 - we move k to this direction because in the next iteration it will help us in minimizing this sum
2708:25 - so here the condition is if sum is greater than target
2708:38 - move k left
2708:45 - if sum is less than target
2708:47 - move j to right so currently sum is greater than target so we will move k left
2709:04 - so k will become 4 we are simply moving it one position here
2709:09 - j is still less than k so this condition comes out to be true
2709:22 - we will evaluate sum again 0 plus 1 plus 4 will give sum as 5 so sum will become 5
2709:33 - we compare whether sum is equal to target or not so sum is not equal to target so this
2709:38 - condition comes out to be false and as the condition has come out to be false
2709:45 - we provide these two conditions we check whether sum is less than target or sum is greater than
2709:50 - target if sum is less than target then we move j to right because if we move j to right we will
2709:58 - get a value higher than the current value of array at jth index and when we will do sum in
2710:06 - the next iteration we will get 0 plus 2 plus 4 which will be equal to 6 so here when we need to
2710:17 - reduce the sum we move k to this direction when we need to increase the sum so that it matches
2710:24 - the target we move j to this direction so currently sum is less than target we need to increase the
2710:31 - sum so we do j plus plus j becomes 2 so j comes here j is less than k
2710:46 - now we will again evaluate the sum so 0 plus 2 plus 4 will give sum as
2710:52 - 6 so sum will become 6
2711:00 - so here you can see when we provide this condition
2711:04 - that whether sum is equal to target or not so this condition comes out to be true
2711:09 - it means we have found one of the triplet which is 0 2 and 4 whose sum is equal to the target
2711:18 - so we are simply printing the value at ith index jth index and kth index on the console
2711:27 - so it will print 0 2 4 0 2 4 and as i is fixed j value is used up k value is used up
2711:43 - so here what we do is we increment j and we decrement k because 0 2 4 is already being found
2711:50 - if we only increment j it will come to this position so 0 plus 3 plus 4 will never give us
2711:58 - a sum of 6 because 0 2 4 is already given as the sum of 6 and as these are the distinct integers
2712:06 - here value cannot be 2 it can be only greater than 2 so therefore if we increment j
2712:16 - we also decrement k because we will never find any such pair if it would have been duplicated
2712:22 - values and here would have been 2 then we have incremented only j so we would have found another
2712:28 - triplet 0 2 and 4 but here as these are the distinct integers therefore when we increment j
2712:38 - we will never find any such other triplet whose sum will be equal to target so 0 plus 3 plus 4
2712:46 - will give us sum as 7 so therefore to keep k at this position is also useless so we decrement k
2712:53 - also so first we will increment j j becomes 3 and then we decrement k
2713:07 - now here you can see j is actually equal to k so therefore this file loop will terminate because
2713:14 - we need to find a triplet which is unique so j and k cannot be pointing to the same number and
2713:21 - bringing up the sum so this file loop will terminate
2713:31 - so the call will reach here now we will simply increment i by one position by i plus plus
2713:39 - so i will become 1
2713:40 - now we have seen all such pairs which can form a triplet with a value 0 and we have used up index
2713:54 - 0 so when we will start i from 1 we will not go behind the value of i because that we have
2714:02 - already seen so the new j value will be i plus 1 which is 2 and k we will take as array dot length
2714:12 - minus 1 which is the last index j is less than k we will take some of these three values
2714:24 - value of i-th index j-th index and k-th index we will do their sum so 1 plus 2 will give 3
2714:32 - plus 7 will give 10 so sum will become 10 it is not equal to target
2714:40 - sum is not less than target so this condition also will come out to be false
2714:45 - sum is greater than target and array sorted so if we move k to left we will get a smaller number
2714:53 - so that in the next iteration this sum will be reduced and can match to the target because
2715:00 - currently sum is greater than target we need to reduce this sum currently the value is 7
2715:08 - which is being used up in forming the sum if we shift k this side we will get a lesser value
2715:14 - so in the next iteration our sum will be more closer to target so therefore we are decrementing k
2715:22 - so k becomes 4 j is less than k
2715:27 - we again do the sum so 1 plus 2 will give 3 3 plus 4 will give 7 so sum will become 7
2715:37 - so here you can see why we moved k to this direction is in this iteration
2715:43 - we actually reduce the sum from 10 to 7
2715:48 - sum is still not equal to target sum is not less than target so we need to reduce sum further down
2715:57 - so we simply do k minus minus so k will become 3
2716:08 - j is less than k j value is 2 and k value is 3 so j is less than k
2716:16 - now we will do sum of these three values 1 plus 2 plus 3 which will give us sum as 6
2716:23 - so sum is equal to target it means we have found one more triplet
2716:30 - so we will print it on the console 1 2 3 1 2 3 and then we simply increment j and decrement k
2716:43 - so j will become 3 and k will become 2
2716:57 - like this now this while loop will terminate because j is actually greater than k
2717:03 - we will increment i again i will become 2
2717:18 - we have used up these elements so jth pointer will become i plus 1
2717:24 - which will start from third index and k will start from the last index
2717:29 - j is less than k we will take the sum of these three indices at their respective array positions
2717:42 - 2 plus 3 plus 7 will give sum as 12
2717:48 - sum is not equal to target
2717:52 - sum is not less than target it is actually greater than target so we need to reduce the sum
2717:56 - and when we reduce the sum we simply decrement k
2718:03 - k will become 4
2718:07 - j is less than k the new sum will be 2 plus 3 5 plus 4 will give 9
2718:17 - so sum has reduced but still it is greater than target so sum is not equal to target
2718:22 - sum is not less than target it is actually greater than target so we again decrement k
2718:32 - so k will become 3
2718:39 - so here you can see j and k are now pointing to the third index
2718:42 - so therefore this while loop will terminate because j is actually equal to k
2718:46 - because we need to find triplets which are unique so all this pointer should point to
2718:54 - a different values of the array
2719:01 - we will increment i i becomes 3 we have used this position so here you can see
2719:10 - if we calculate array dot length we will get 6 if we do minus 2 we will get 4
2719:18 - so i is still less than 4 because it is pointing to third index
2719:23 - and here you can see that why we have provided this condition is
2719:28 - because we need to give space for the other two pointers as well
2719:33 - one can occupy this position other can occupy this position
2719:36 - if i would have traveled all the way across the array say for example
2719:46 - if i would have reached here so j would have started from here and k would have also started
2719:53 - from here which we don't want because we want j should be less than k so at least we need to
2719:59 - give space for two elements so therefore we are taking it as i should be less than
2720:05 - array dot length minus 2 we are doing minus 2 because one slot will be taken by j and other
2720:13 - slot can be taken up by k properly so this condition is still true that i is less than
2720:27 - array dot length minus 2 so j will start from fourth index k will start from the last index
2720:40 - j is less than k we will do the sum 3 plus 4 plus 7 will give 14
2720:51 - sum is not equal to target sum is not less than target
2720:58 - if we want to reduce the sum we have to decrement k
2721:04 - to reach here so k will become 4
2721:12 - and as we have decremented k j and k are pointing to the same index so therefore this while loop
2721:19 - will terminate and again when we will increment i i will become 4
2721:34 - so 4 is not less than array dot length minus 2 6 minus 2 is array dot length minus 2 which is 4
2721:42 - 4 is not less than 4 so therefore this for loop will terminate
2721:49 - and once this for loop will terminate our method will also get terminated and whatever we have
2721:56 - got as a triplet we have printed on the console which is 0 2 4 1 2 3 which are the three numbers
2722:06 - which add up to a target of 6 and they are in ascending order so friend this was all about
2722:14 - the threesome problem where we use the technique of sorting and three pointers to figure out which
2722:21 - are those triplets which add up to a target i hope you must have liked this video in case if
2722:29 - you're new to my channel then please subscribe to my channel and click the bell icon so that
2722:34 - you never miss any update thanks have a nice day hello everyone so in this video we are going to
2722:42 - discuss a problem product of array except self so let's see what this problem is and how to solve
2722:50 - this so in this problem we are given an array of integers we need to return an array result
2722:59 - such that value at index i is actually equal to the product of all elements of array except
2723:08 - the element at index i so in the result array let's say any index i we need to store the product of
2723:16 - all the elements of the given array leaving the element at that respective index so when we are
2723:23 - doing the product the values are given in such a way that product fits in the 32 bit integer
2723:30 - one constraint is the algorithm should run in o of n time and without using the division operator
2723:36 - so let's understand the problem with an example let's say we are given an array having four
2723:42 - elements one two three four now in the result array we need to store the product of all the
2723:49 - elements of array in such a way that let's say if we are on index one so this is zero index this
2723:58 - is one this is two and this is three so let's set index one we have value two so in the result
2724:09 - array we need to store at index one product of all the numbers in this array excluding two
2724:18 - so for example at index zero we have one so we can directly do the product of rest of the elements
2724:27 - two into three six six into four is 24 so we can directly place 24 here
2724:34 - we haven't included one into the product
2724:39 - now for index one at index one we are storing the product of rest of the elements excluding two
2724:48 - so one into three is three three into four is twelve so we are storing 12 here
2724:53 - for index two we will exclude three we will take the product of rest of the element which is
2724:59 - four into two eight eight into one eight so we are storing eight here
2725:06 - for the last index we will exclude four and we will take the product of rest of the elements
2725:12 - one into two is two two into three six so we are storing six here
2725:21 - so in this problem in the result array at any particular index let's say this index
2725:27 - we are storing the product of rest of the elements excluding the element at that particular index
2725:37 - so friends we don't have to use the division operator or as the problem would have been very
2725:41 - simple we could have multiplied all the numbers so for example if we take the product of all the
2725:47 - numbers we will get 24 now let's say if we want to fill for the index one excluding two
2725:54 - so we would have directly divided it by two it would have given two element we would have placed
2725:59 - 12 here so we don't have to use the division operator and secondly we need to solve this
2726:07 - problem in o of n time so here you can see if we use two for loops
2726:18 - the nested for loops the time complexity will be o of n square so the first for loop will traverse
2726:24 - the element one by one and the inner for loop will travel rest of the elements take their product
2726:31 - and store it at the respective index of the outer for loop iterator so the time complexity
2726:38 - would have been o of n square so we need to solve this problem in o of n time
2726:44 - so now let's see the algorithm and the demonstration of that algorithm step by step
2726:50 - so friends before we start in case if you are new to my channel then please subscribe to my channel
2726:55 - and click the bell icon so that you never miss any update now here we will call find product
2727:01 - method we will pass this array having four elements one two three four
2727:11 - so friends how we will solve this problem in o of n time is we will traverse this array two times
2727:18 - one in this direction and other in this direction and let's say this is our result array
2727:26 - so when we will traverse in this direction let's say if we take the example of index two this
2727:36 - element now at this index we need to exclude three and store the product of rest of the elements
2727:48 - but here you can see at index two we are doing the product of
2727:55 - these two elements which is on the left side and all the elements on the right side and excluding
2728:01 - three so when we will traverse the array from the left side in the result array we will store
2728:08 - the product of the left part of the array and when we will traverse from the right side we will
2728:14 - include the elements of the right part of this index so when we will traverse on the left we
2728:21 - will do the product of the left part store it here and when we will traverse on the right side
2728:28 - we will take this value whatever value is stored here we will do the product and we will place it
2728:33 - here so in the left part we are doing one into two we will place two here and when we are traveling
2728:42 - from the right we will take the value four multiplied with two
2728:50 - and store it here so this we will do for all the elements at the respective indexes
2728:57 - and finally we will get the result array so first we are traveling from the left direction
2729:05 - so at the start we are creating a temporary variable assigning it the value of one
2729:10 - we will see its significance later so temp is equal to one
2729:17 - we will create the result array
2729:25 - like this and as total length of array is four
2729:30 - we will initialize the result array with array.length which is four
2729:33 - now we will start the for loop from index zero and go till the end of the array
2729:42 - so at the start i will be equal to zero which is pointing to the zero index
2729:51 - now as we discussed when we are traveling in left direction
2729:55 - we will store the product of the left side elements so currently for index zero there are
2730:01 - no elements in the left side and here we have created a temporary variable assigned into value
2730:07 - one so we will directly store one here which is the value stored in temp because there are no
2730:14 - elements in the left part of index zero and we also know that anything multiplied
2730:24 - by one will give the same result so therefore we are initializing temp with one
2730:30 - so here we will get value as one moving ahead
2730:36 - now for the next index let's say for two we need to take the product of the left part
2730:44 - so here as we are assigning temp directly to the result at a particular index here what we are doing
2730:51 - is we are taking the product of temp with the previous value and then we are storing it in
2730:59 - the result array so for the next iteration we have to take product of the left part currently
2731:05 - here we have only one element which is one so we are multiplying temp with the value stored at index
2731:12 - i which is index zero so temp becomes one because one into one gives one
2731:22 - you will understand more about this step when we move ahead
2731:25 - so now we'll increment i, i becomes one
2731:34 - now as temp is storing the product of the previous elements we will directly take the value of temp
2731:40 - and store it in the result array at ith index so one will be stored here because value of temp is one
2731:49 - so for the next iteration i will reach here so for index two we need the product of left side
2731:59 - we need product of one and two so temp already has product of this part here we will multiply
2732:08 - it with array of i which is we will multiply it with two and we will get the product of these two
2732:13 - elements and that product we can safely store here because when we are traversing from the left side
2732:22 - for this particular index we will only store the product of these two elements
2732:27 - and currently as we have already stored the value of temp into result i which is one here
2732:34 - if we multiply temp with current element we will get the overall product of these two elements
2732:40 - so the new value of temp will be two into one which will give us two
2732:52 - we will increment i, i becomes two
2733:01 - and we know that temp already has the product of its two previous values which is one into two
2733:11 - so we will first directly store one into two which is two at index two of the result array
2733:19 - so this step does that so two comes here
2733:25 - now when we will move to the next element we need to include three also in the product
2733:31 - because for index three which is this index we need to take the product of these three elements
2733:38 - we already know the product of these two elements which is stored in a temp
2733:43 - if we multiply it with three which is the current element at index i we will get the product of three
2733:51 - elements previous to third index so therefore we are multiplying temp with the current index
2733:56 - value of array which is three here so three into two will give six
2734:08 - so temp becomes six which makes sense because one into two into three will give six
2734:14 - which we can use directly in the next iteration
2734:19 - so we'll increment i, i becomes three
2734:22 - so in the result array at third index we will first directly store the value of temp
2734:30 - which is six so here you can see for third index the product of its previous values is six
2734:37 - one into two into three six and we are storing six here and as we are traveling from the left
2734:43 - side we are only looking in the elements which are on the left part of the particular index
2734:52 - so as there are no more elements left this product makes no sense so temp into array of i
2735:04 - four into six will give 24 so temp will become 24 but it is of no use because there are no elements
2735:13 - going further so we'll increment i, i will become four and this for loop will terminate because four
2735:21 - is not less than array.length which is four so when we traverse from the left side in this
2735:32 - direction we store the product of the left part so now we'll again initialize temp with one
2735:40 - so temp becomes one and now we'll traverse from the right side so here i starting from array.length
2735:48 - which is four minus one which will give us three which means we are starting from the third index
2735:56 - and this loop will go till i is greater than or equal to zero
2736:04 - so friends we also discussed that let's say if we want to fill
2736:08 - for index two we need product of these two elements and whatever the product will come
2736:14 - which is two here we will multiply it with the right side elements which is four here so two
2736:22 - into four will give eight and we will store eight here so in the result array we are already having
2736:29 - the product of the left part of each index now we simply need to take the value of the right part
2736:38 - do their product and whichever value is stored here we simply need to multiply it with that value
2736:44 - so now that thing we will do when we are traversing from the right side
2736:51 - so at the result array at i as index so currently we are at the third index whatever value is stored
2736:59 - is actually stored of the product of its previous numbers and as index three has no elements to its
2737:07 - right we will simply multiply whatever value is stored here into temp which is one and store it
2737:18 - back into the result array so for index three at result of i we will take six which is this value
2737:27 - we will multiply it with temp which is one which will give us six and we will assign six back to
2737:33 - index three at the result array so it will remain six
2737:46 - so here we are doing the same steps for index two we need product of its elements which are
2737:54 - on its right side so temp value is one we will multiply it with four and we will get the product
2738:02 - of its right side elements so temp becomes four we will decrement i so i will come at index two
2738:20 - now at this index you will understand the algorithm more what we are trying to achieve is
2738:25 - in the result array for index two we need to store the product of the elements excluding index two
2738:34 - which is three so one into two which is on the left part excluding three
2738:43 - and taking in remaining element which is on the right part so one into two will give two two
2738:50 - into four which will give us eight so we need to store it here now in the result array we are
2738:59 - already having the product of the left part which is two here we need to simply multiply this two
2739:08 - with the product of its right part so currently it's four which is stored in the temp so result
2739:15 - of i which is two multiplied by four which is temp so value stored at result of i multiplied by
2739:23 - temp will give the actual product of all the elements excluding this index because temp
2739:32 - is already having product of its numbers on the right side so two into four will give eight
2739:40 - and we will assign eight back to the result array at index i so it will come here
2739:48 - now we will multiply three with temp which will give us 12 and we'll assign 12 to temp
2739:58 - so why we are doing it because
2740:00 - in the next iteration so when we will decrement i i will come to index one
2740:11 - now for this index we already have the product of its left element here in the result array
2740:20 - we need the product of its right part previous value of temp was four and we multiplied it with
2740:29 - three which gave us value as 12 so temp is currently having value 12 which is the product
2740:40 - of all the elements on the right side so for filling the value of index one we need product
2740:47 - of the left side which is one which we already calculated we will exclude this element
2740:54 - and we need the product of the right side which is already stored in the temp so value
2741:02 - at result array the ith index which is one will give product of the left part
2741:08 - temp will give product of the right part when we will multiply them
2741:14 - we will get one into 12 which is 12 so one
2741:18 - into 12 which is temp will give 12 so 12 will come here
2741:31 - and for the zeroth index we need product of the right part so temp already has product of three
2741:39 - and four which is 12 we will multiply it with the two which is the array element at index i
2741:47 - so temp will become 24 we will decrement i
2741:54 - so i will come as index zero now at index zero we need to simply put the product of all the
2742:03 - elements on the right side their product with product of the elements on the left side so left
2742:09 - side doesn't have any value because we have value is one here we will take value one
2742:18 - multiplied with value of temp which is 24 and we will assign it back to the result array
2742:24 - so here it will come 24 and then we will evaluate temp again which actually is of no use because
2742:32 - we have already filled all the positions here so the new value of temp will be
2742:38 - temp which is 24 into array of i which is 1 which will give 24
2742:50 - so now we will decrement i and this for loop will terminate because
2742:54 - value of i will become minus 1 and minus 1 is not greater than or equal to zero
2743:00 - so this for loop will terminate and at the end we will simply return the resultant array
2743:08 - so friends the basic idea behind solving this problem is we need to do two traversal one is
2743:14 - from the left side and one is from the right side when we are traversing from the left side we will
2743:21 - only see the elements which are on the left part of any particular index we will do their product
2743:29 - and we will store that value in the result array and that will be done from the left part
2743:36 - now when we are traversing on the right part
2743:39 - let's say for index two when we had completed from the left part
2743:45 - we had product of these two elements so in the result array the value would have been two
2743:50 - because one into two will give two when we are traversing from the right side
2743:55 - we need product of the right part so currently as there is only one element which is four
2744:01 - we will take four multiplied with two which will give us eight and we will store it back here
2744:09 - and this we will do for all the elements so it's very simple for any index i
2744:17 - this is left part this is right part we are excluding the current element
2744:23 - left into right and whatever we get value we will store back it here in the result array
2744:40 - so we are excluding this part we are taking left part we are taking right part product
2744:45 - we are doing their product and storing back out the respective index so friends i hope you
2744:51 - must have liked this video in case if you are new to my channel then please subscribe to my channel
2744:56 - and click the bell icon so that you never miss any update thanks have a nice day
2745:02 - hello everyone so in this video we are going to discuss sliding window maximum problem
2745:08 - so let's move ahead and see what this problem is and how to solve this
2745:13 - so in this problem we are given an array of integers and we are given a sliding window
2745:19 - of size k so it means we are given with this array and a value k which is the size of sliding
2745:26 - window now this sliding window is moving from very left of the array to very right so this
2745:33 - sliding window is starting from 0th index having a size of 3 and it is moving from left to right
2745:42 - and as it is moving from left to right we can only see that many numbers so at the start we
2745:47 - can see only 44 77 33 so it means we can only see k numbers of the array at a time
2745:55 - and this sliding window is moving into this direction by one-one position so first we will
2746:01 - see 44 77 33 then we will see 77 33 44 then we will see 33 44 88 and at the last we will see 44
2746:11 - 88 and 11 so for this array with the sliding window of size 3 what we need to find is for
2746:19 - every window which we saw so we need to find max among this three and then sliding window will
2746:26 - move ahead so then it will see these three elements and then we have to find the maximum
2746:32 - among these three so which is 77 again so similarly till the end we need to find the
2746:38 - maximum in the sliding window so this is the output for this array having the sliding window
2746:44 - of size 3 now how this output came here you can see in the first sliding window 44 77 33
2746:53 - the max value among this three element is 77 so for this sliding window the max is 77
2747:00 - then this sliding window will move ahead so 44 will go out and this 44 will come in
2747:09 - so now among these three elements 77 33 44 77 is max so in this sliding window the max would be 77
2747:19 - similarly sliding window will move ahead now we have 33 44 and 88 so among these three elements
2747:25 - 88 is max and at the end the sliding window will reach to the end of the array so among
2747:31 - these three elements 44 88 and 11 the max is 88 now let's move ahead and see that how we can solve
2747:39 - this problem suppose friends we are given with this array and we need to find the max in the
2747:46 - sliding window so here in order to solve this problem there are various solutions so one such
2747:52 - solution is is to find the next character element of each and every element in this array
2747:59 - so the problem of next character element we already discussed in one of our previous video
2748:04 - you can watch that video to understand more about this algorithm in this video i will be
2748:10 - demonstrating the next character element problem as well so here actually what we do is for each
2748:15 - and every element you see here we find its first next character element towards right
2748:22 - so if you see for 44 if we look in this side we just see the first next character element to 44
2748:30 - so currently 77 is greater than 44 so it becomes the first next character element of 44
2748:38 - like this then we look at 77 if we look in this direction 33 is less than 77 44 is less than 77
2748:48 - 88 is greater than 77 and it is first next character element towards right of 77
2748:56 - so here 88 becomes the first next character element to 77
2749:00 - and similarly for 33 if we look in this direction 44 and 88 both are greater than 33
2749:08 - but the first next greater is 44 so the answer will be 44 for 44 it will be 88
2749:15 - for 88 here we have only 11 so therefore there is no element in the right of 88 which is greater than
2749:23 - 88 so in our previous video we discussed that we simply return minus 1 because there are no
2749:28 - elements greater than 88 towards its right and similarly with 11 as it is the last element
2749:36 - there are no elements after that so for 11 also our answer becomes minus 1
2749:41 - so in that video this was our output and our answer so we will use the same algorithm here
2749:48 - but there will be a slight difference so here you can see below i have written the next character
2749:53 - element of each and every value of this array so in our previous video in the next character
2750:00 - element array we actually return this as our output but now instead of this as our output
2750:07 - first we will evaluate the indexes of this elements and we actually store the indexes
2750:12 - in the next character element array so for example for 77 if you see as index 1 so instead
2750:20 - of storing 77 we will store 1 like this so these are the indexes of this next greater elements
2750:28 - so for example for 77 our answer was 88 so if you see 88 is as index 4 so we are storing 4 here
2750:39 - i'll remove this here if you see for 33 its next greater is 44 which lies at index 3
2750:46 - so we are storing index 3 for 44 the next letter is 88 which lies at index 4 so we are storing 4
2750:53 - here and for 88 there is no greater element towards its right so therefore as we are storing
2751:01 - indexes here if you see the last index is fifth index so we are storing a greater value to 5
2751:09 - which signifies that we have gone out of the boundaries of this array so we are simply
2751:14 - storing 6 so this 6 is nothing but array dot length which signifies that for 88 there was no
2751:24 - greater element towards its right and for 11 as well so we are storing 6 6 and the value
2751:33 - we are taking as minus 1 and minus 1 here we need to store an index which is out of the boundaries
2751:40 - of this array so that we can justify that for 88 there is no greater element towards its right
2751:47 - and for 11 there is no greater element towards its right so we are storing the indexes array
2751:53 - dot length so here you can see if we are on at index 0 for example we see there is a value 44
2752:00 - now if we go to the index 0 of next greater element array we see there is a value 1 this
2752:08 - value is only for demo purposes i have written here but actually we will be playing with this
2752:12 - value and this value so at 0th index we have 44 and we need to find its next greater element
2752:20 - so what we do is we simply go to this array we see there is a value 1 and we know that this is
2752:26 - actually an index so what we do is we simply go to the original array at index 1
2752:31 - and whatever value here it is we simply say that this value 77 is next greater to 44
2752:39 - so it goes like this from here first we go here and then we go here to find the next greater
2752:46 - now similarly if you want to find that what's the next greater to 33 we simply go to index 2
2752:52 - we see there is a value 3 so we go back to index 3 and we find 44 and we know that 44 is
2752:59 - next greater to 33 so friends our problem is to find
2753:04 - the maximum in the sliding window so how this next letter element array is helping us in finding
2753:12 - that is let's say for example this is our sliding window here we have taken ks3 and let's say
2753:22 - after evaluating the maximum of the sliding window the sliding window reached here and
2753:29 - now let's say we want to find the max among these three elements and we actually know that it is 88
2753:36 - so here what we do is the step 1 is from where our sliding window is starting we take that element
2753:43 - so currently it is 33 we take 33 and assume that it is the max in this sliding window
2753:50 - and here you can see it is at index 2 but we know that 33 is not the max in this sliding window
2753:56 - so what we do is this is our assumption in the second step what we do is we simply
2754:03 - go to the next greater element array at index 2 and we see there is an index 3
2754:10 - which means that if we go to index 3 we will find an element which is greater than 33
2754:15 - so here what we do is if you see the window is starting from index 2
2754:21 - and the value of k we are taking as 3 for example so we know that this window will go till
2754:28 - 2 plus 3 minus 1 which is still fourth index this index so we are taking three elements
2754:37 - because value of k is 3 from index 2 to 4 so starting is 2 this is our k and if we do minus
2754:45 - 1 we'll reach the last index so when we find 3 here we first check whether this index
2754:53 - is in the range of this sliding window or not so here you can see 3 actually lies
2754:58 - in the range of sliding window so this point suggests that there is an element greater than
2755:04 - 33 and it lies in this sliding window which is 44 so therefore this 33 which was our assumption
2755:12 - is wrong and now what we do is we simply go to this element 44 and assume that now it is our
2755:20 - maximum so we reach here at the 44 but still we are not sure that 44 is max or not so what we do is
2755:30 - we simply go to the index 3 which is of 44 in the next greater element array here we find
2755:37 - our value as 4 which is the index 4 and we also see that 4 is actually in the boundaries of this
2755:45 - sliding window which suggests that at index 4 there is a next greater element to 44 and this
2755:54 - element is also in the range of this sliding window so our assumption that 44 was max is also wrong
2756:00 - so now what we do is we simply now go to 88 here and we assume that now 88 is our max
2756:09 - but now what we do is we simply go to the index 4 here and we see we have value as 6
2756:16 - and then what we do is we take this 6 and before going to the sixth index which is out of this
2756:24 - array what we first check is whether this 6 is in the boundaries of this sliding window or not
2756:32 - so the maximum range of this sliding window is 4 and we know that the next greater element to 88
2756:38 - is at index 6 which is out of the boundaries of this sliding window it means let's say at index
2756:45 - 6 here we have one element 100 like this so here for 88 we know that if we go to the index 6 we
2756:53 - will find 100 but this 100 is not lying in this sliding window and we need to find the maximum
2757:00 - in the sliding window so we know that for 88 its next greater is 100 but it is lying at index 6
2757:09 - it is not in this sliding window so it means we are 100 sure that 88 is max in this sliding window
2757:16 - so therefore we use this algorithm and we can come to know that 88 is max in this sliding window
2757:24 - so this approach we do for every sliding window like this
2757:33 - and what we do is we take the first element we assume it's the max in this sliding window
2757:39 - but to confirm that we take this index we go to the next greater array at index 2
2757:45 - we pick the index of the next greater to 33 which is
2757:51 - this index and the element is 44 and as the index is 3 we check whether this index 3
2758:00 - is actually in the range of the sliding window here it is from 2 to 4 and 3 actually lies between 2
2758:07 - to 4 so therefore we know that 33 cannot be our max in this sliding window because there is one
2758:15 - more element in this sliding window which is greater than 33 which is 44 and similarly with 44
2758:22 - we found that its next greater is 88 and this 88 is also lying in this sliding window range
2758:29 - so then we came to 88 and for 88 we found that its next greater is index 6 here index is out of the
2758:37 - range of this array but let's suppose even if the index is had any value let's say 100
2758:43 - but we know that we have to find the max in this sliding window
2758:47 - and the next greater to 88 is 100 which is out of this window so therefore our answer would be 88
2758:54 - for this window so friends here is the importance that why we are actually storing the indexes
2758:59 - instead of actual values because this window of size k is actually dealing with the indexes
2759:06 - and we need to find the index of the elements next greater so therefore instead of storing
2759:12 - the actual values in this array which we also saw in the previous video we are actually storing
2759:18 - the indexes now the algorithm is very much similar but the only difference is instead of
2759:24 - these numbers of next greater we are actually storing their indexes so let's move ahead and
2759:29 - see the demonstration of the algorithm step by step so friends before we start in case if you
2759:34 - want to master algorithms and data structures you can subscribe to my channel and click the
2759:39 - bell icon so that you never miss any update so here we will call the max sliding window
2759:45 - method by passing in the array so this is our array and the sliding window size is 3
2759:53 - so value of k is 3 so here the return type of this method is list because we need to
2760:00 - return the max of sliding windows among this array which we will store and we will return
2760:07 - so here at step one what we are doing is we are simply calling next greater element method
2760:12 - we are passing in the array so this algorithm we have already discussed in our previous video
2760:18 - i will also demonstrate one more time because the only difference is we are storing the indexes
2760:24 - in this array not the actual values so when this method will be called
2760:32 - this is our array so at step one we will create the result array now this result array will store
2760:39 - the next greater elements so now as we need to find the next greater elements of this array
2760:48 - what we do is we take the help of stack so first we create a stack so stack is
2760:55 - leafo data structure which means the element inserted last will be the first to be removed
2761:03 - so we will use this property and we will figure out the next greater element of all these elements
2761:10 - so now we will provide a for loop where this i will start from the last index
2761:16 - which is array dot length minus one and i will go till it is equal to zero it means it will travel
2761:22 - in this direction and it will reach till index zero and i will help us in placing the next
2761:30 - character element of each and every index so we are starting from the last index because
2761:35 - it will make our job easy to find the next character element towards right
2761:40 - so first we are actually finding the next greater element of 11 so as 11 is the last index
2761:49 - and we know that there is no next greater element to 11 so here we are providing this if block
2761:56 - we will discuss this later which says that we first check whether stack is empty or not
2762:01 - so currently stack is empty it means this condition comes out to be false
2762:06 - and actually this stack will hold the next letter elements in the stack for the remaining array
2762:13 - so as 11 is the last element we know that stack must be empty because there are no greater
2762:19 - elements towards its right so we first check whether stack is empty or not so if stack is empty
2762:27 - we simply put array dot length into the result of i why we are putting array dot length is because
2762:33 - array dot length is six and six suggests an index which is not in this array which also suggests that
2762:41 - for 11 there is no next greater elements towards its right and we will also see that how this index
2762:47 - will help us in later in the algorithm when we will find the max in the sliding window
2762:55 - so after the if else block now this 11 can be a next greater element for the remaining array
2763:02 - so for example instead of 88 let's say if the value would have been 9 so for 9 11 would be
2763:09 - the next letter element because 9 is less than 11 and 11 is the only element towards its right
2763:16 - which is greater than 9 so therefore we will push index 5 it means we are pushing 11 on the stack
2763:26 - like this so i will also write the values beside the index we are actually storing the index in the
2763:34 - stack because we need to get a result in the form of indexes and you can assume that we are
2763:41 - actually storing the values like 11 moving ahead we will decrement i now stack is not empty
2763:51 - so the first thing we do is we provide a while loop now inside this while loop what we are doing
2763:58 - we are first checking whether stack is empty or not so stack is not empty so this much condition
2764:03 - is true this condition is very important here what we are doing is we are first taking stack dot
2764:10 - peak value so if you see stack dot peak is five and if i do array of five and then i do whether
2764:20 - it is less than equal to array of four it means we are comparing whether 11 is less than equal
2764:29 - to 88 or not so this condition comes out to be true so the while loop will execute and what it
2764:36 - will do is this 88 will simply pop 11 out of the stack because we had placed 11 in the stack
2764:44 - thinking that there could be a lesser value here for which 11 could become the next greater element
2764:51 - but as soon as we figured 88 this 88 will discard this 11 because for the remaining array
2764:59 - even if we have any value here its next greater element will reach till 88 and it won't go beyond
2765:06 - because 88 is already greater than 11 and 11 cannot be the next element of any of the element
2765:13 - in the remaining array let's say if we had 9 here for example so for 9 also the next greater
2765:20 - would become 88 let's say if we had 10 here so for 10 also it would be 88 and let's say if we had 11
2765:28 - so for 11 also it would be 88 but there would be no such value here for which 11 can become
2765:34 - the next greater element because we have found one element which is already greater than 11
2765:39 - so therefore the job of a greater value here is to remove the smaller values out of the stack
2765:47 - because now they won't contribute in the next greater element so first we pop 5 out of the stack
2765:56 - so now stack becomes empty so this while loop will terminate
2766:01 - we check whether stack is empty or not and we know that if stack is empty
2766:05 - it means for this value 88 we didn't find any element which is greater than 88 because stack
2766:13 - is empty 88 will pop out the smaller elements and will stop till there are elements which
2766:20 - are greater than 88 and those elements will lie for sure in the stack but if stack is empty
2766:26 - after this while loop then for 88 there is no greater element towards its right
2766:32 - so we simply put array.length which we had placed for 11 which suggests that for 88 also
2766:39 - there are no greater element towards its right moving ahead so now 88 can become the next
2766:47 - greater element for remaining array till here so we'll push the index of 88 here which is 4
2766:54 - which corresponds to 88 will decrement i, i comes at index 3 and now we are figuring out
2767:04 - the next greater element to 44, stack is not empty so this condition comes out to be true
2767:12 - in the while loop stack is not empty and first we will take the stack.p which is 4 so array
2767:19 - of 4 will compare whether it is less than equal to array of i which is
2767:28 - 3 so here we are simply comparing whether 88 is less than equal to 44 or not so this condition
2767:37 - comes out to be false which suggests that 44 cannot pop 88 out of the stack because 44 is
2767:44 - less than 88 and we can't pop 88 out of the stack because 88 can become the next greater element
2767:51 - of the remaining array so here for example for 77 its next greater is 88 only so therefore if
2767:58 - a value is smaller it cannot pop this element out of the stack and if value is greater it can pop
2768:05 - the element out of the stack so this condition we need to keep in mind so 44 cannot pop this
2768:11 - element out of the stack because this condition came out to be false and now we simply check
2768:17 - whether stack is empty or not so stack is not empty so the else part will be executed
2768:23 - as stack is not empty which suggests that there would be some element in the stack
2768:28 - which is greater than 44 because 44 could not pop that element out of the stack and that element
2768:35 - will be for sure greater than 44 so at the result of i we store stack.p which is the index
2768:42 - or indirectly we are storing 88 so we are storing index here 4 and then we will put
2768:50 - value of i which is 3 on the stack like this because this 44 can become the next greater
2768:57 - element for the remaining array so for example for 33 88 is also next greater element 44 is also
2769:05 - next greater element but 44 is the first next greater element to 33 therefore we can't discard
2769:11 - 44 we have to put it on the stack like this we'll decrement i, i comes to index 2, stack is not empty
2769:24 - in the while loop stack is not empty and if we do stack.p we will get 3 so array
2769:33 - of 3 we are checking whether it is less than equal to array of i which is 2
2769:41 - so we are simply checking whether 44 is less than equal to 33 or not so this condition comes
2769:47 - out to be false which makes sense because 33 cannot pop 44 out of the stack because 44
2769:54 - is next greater to 33 and which is at the peak of the stack so therefore this while loop will
2770:02 - terminate stack is not empty so this condition comes out to be false in the else part whatever
2770:09 - is at the peak that will become the next greater to 33 so here we are storing stack.p which is 3
2770:17 - which suggests that we are storing a value 3 which is the third index value which is 44 this
2770:24 - and then we will push 2 on the stack like this so let's say we had 11 here so for 11 33 would
2770:35 - have become the next greater element so therefore we can't discard 33 we have to push it on the
2770:40 - stack so 2 comes here which is the index of 33 we'll decrement i, stack is not empty
2770:49 - so for now here one critical step comes stack is not empty in the while loop we are checking
2770:58 - array of 2 whether it is less than array of 1 or not so we are checking whether 33
2771:09 - is less than 77 or not which is true and we have already discussed here that if we find any value
2771:16 - which is greater than the peak value of the stack this value will simply pop the element out of the
2771:22 - stack because if we see the remaining elements in this direction let's say if we add more elements
2771:28 - here 33 cannot become the next greater element for the remaining array because for the remaining
2771:35 - array 77 can become the probable next greater element but 33 cannot because 33 is less than 77
2771:44 - and we need to find the next greater element so let's say if we add 2 here or let's say 33 here
2771:51 - so for 33 also the next greater would become 77 and for no value here 33 can become the next
2771:58 - greater because so for example if we add 87 so for 87 the next greater if it is not 77
2772:06 - then it will be 88 but we are 100% sure it won't be 33 because 33 is already lesser than 77
2772:14 - so therefore this condition comes out to be true and 77 will pop 33 out of the stack because
2772:22 - now we can safely discard this value it will play no role in finding the next greater element
2772:28 - 2 is popped out of the stack stack is still not empty and here if you say this condition
2772:35 - we are checking array and passing stack.peak which is 3 we are checking whether it is less than
2772:44 - array of 1 or not it means we are now checking 44 is less than 77 or not so this condition comes
2772:50 - out to be true it means 77 has rights to pop 44 also out of the stack because 44 also will not be
2772:58 - contributing in the next greater element because we have found already one value which is greater
2773:04 - than 33 and 44 so first we have popped out 33 now we are popping out 44 which is at index 3
2773:11 - so 3 will be popped out like this stack is still not empty so now here
2773:22 - array of stack.peak which is 4 we are checking whether it is less than
2773:27 - array of i so we are simply checking whether 88 is less than 77 or not so this condition comes
2773:35 - out to be false because 77 cannot pop 88 out of the stack because 88 can become a probable next
2773:44 - greater for the remaining elements in the array and in fact for 77 88 is the next greater element
2773:52 - so therefore 77 will not be able to pop 88 out of the stack so this value will terminate
2773:59 - because this condition comes out to be false stack is not empty so in the result array
2774:06 - we are simply putting stack.peak so if stack.peak is not empty and whatever is at the top
2774:13 - will become the next greater element for the current value which is 77 so we are storing 4
2774:18 - here which suggests that if you go to index 4 you will find 88 which is the next greater to 77
2774:27 - and similarly we'll push 1 on the stack which is we are pushing 77 on the stack
2774:37 - like this will decrement i, i comes to 0th index, stack is not empty this condition also comes out
2774:47 - to be false because 44 cannot pop 77 out of the stack because it is lesser than 77 so this value
2774:55 - will terminate stack is not empty so for 44 the next greater element would be whatever the element
2775:03 - is on the peak of the stack which is index 1 value 77 so we put stack.peak at the result array
2775:12 - at ith index like this and we push 0 on the stack
2775:20 - and if we decrement i it goes beyond the boundaries of this array
2775:24 - so therefore this value will terminate because i should be greater than or equal to 0
2775:32 - so then we will simply return the result which is actually storing the indexes of next greater elements
2775:38 - so this nge array will have the indexes and i have just written the values for these indexes
2775:49 - below that so 44 is at 0th index if we go to 0th index of next greater element array you will find
2775:56 - 1 which is the index so if we go to index 1 you will find 77 so i have written 77 directly here
2776:04 - so that you can just relate that at 4 we have 88 like this at 3 we have 44 like this
2776:17 - so now as we need to collect the max and sliding window we create a list by name
2776:23 - result like this so this is a list of integers and here you can see that now we will start
2776:31 - the for loop from i equal to 0 from here and this for loop will go till array.length minus k
2776:40 - why it is going till it is less than equal to array.length minus k if you see array.length
2776:47 - which is 6 if we do minus k which is 3 in our case so it will give 3 so it suggests that i will go
2776:55 - till index 3 because now in this for loop we are actually calculating the max in the sliding window
2777:02 - and the last window will start from when i will be equal to 3 because the value of k is 3
2777:09 - so this window will go till this index from 3 to 5 and beyond that this condition will come out to
2777:17 - be false and we will break from this for loop so i will travel till index 3 because the last window
2777:25 - will be this window which will actually cover the last window which is the last three elements of
2777:30 - this array and beyond that we don't have to go so i will travel till it is equal to 3 so when i
2777:38 - is equal to 0 we are looking at the first window which will be from 0 to k minus 1 which is 0 plus
2777:47 - 3 minus 1 which is 2 so it will go from 0 to 2 so this is the first window of size 3 and now our
2777:57 - target is to find the max in this window with the help of this next letter element array
2778:05 - so as we have already discussed what we do is in the first step the element which is the beginning
2778:11 - of this window we assume that it is the max in the sliding window so we are creating an integer
2778:18 - value j which is our assumption that it always starts from the first element of this window
2778:25 - so we are assuming 44 is max in this sliding window which is being denoted by j so j is also
2778:32 - pointing to 0th index like this because value of i is starting of this window from 0 so j is also
2778:41 - starting from 0th index and now as we discussed that we need to confirm this assumption
2778:48 - so what we do is we are providing this while loop and the condition in this while loop is
2778:55 - 444 which is at index 0 we simply go to this index we see there is one so we take this one out
2779:04 - and then we are checking whether this one whether this lie in the range of this sliding window or
2779:11 - not so here if you see if i do i plus k 0 plus 3 so this value will give 3 1 is less than 3
2779:22 - so it suggests that 444 which is at index 0 if we go to the next letter element array at index 0
2779:30 - we are finding a value 1 which suggests that 444 its next letter element lies at index 1
2779:39 - which is value 77 and this 77 is actually if you see it is in the range of our sliding window
2779:47 - it means our assumption that 44 is max in this sliding window is false because the next greater
2779:54 - element to 44 is 77 and this 77 is also in this sliding window so therefore now j will simply
2780:02 - travel to index 1 because now our next assumption is 77 is the max in this sliding window so here
2780:09 - we are doing that thing only 1 is less than 3 so this condition comes out to be true it means
2780:15 - the next letter element for j which is 44 is 77 which is at index 1 and this one is lying
2780:23 - in this sliding window so j will simply travel to that index which is the next letter element
2780:30 - array of j which is 1 so it means j will directly shift to 1 suggesting that now our assumption is
2780:37 - 77 is max in this sliding window so after this assignment j comes here and our assumption that
2780:45 - 44 is max in this sliding window comes out to be false and now our new assumption is 77 is max
2780:53 - in this sliding window but as this is a while loop we have to confirm that so now we are again
2780:59 - checking the next letter element array of j which is 1 which is 77 which is our assumption
2781:07 - we are going to this index we are finding a value 4 so now what we are doing this is giving us a
2781:14 - value 4 so we are checking whether 4 is in this sliding window range or not and how we can figure
2781:21 - out whether 4 lies in this sliding window is we know that sliding window starts from i so if it
2781:28 - goes to 0 plus 3 it will give 3 and we have to do less than that so it will go till second index
2781:37 - which is the first three elements from 0 to 2 but here 4 which we evaluated from this part
2781:44 - that 77 if we go to this index next letter element array of j is 4 so this 4 is we are checking
2781:53 - whether it is less than 3 or not so this condition comes out to be false which actually
2781:59 - proves that 77 is max in this sliding window because the next letter element to 77 is 88
2782:06 - which is at index 4 which is actually beyond the boundaries of this window which proves that
2782:13 - whatever element comes after the 77 in the sliding window will be lesser than 77 so therefore now
2782:20 - this while loop will terminate because this condition comes out to be false and we have found
2782:27 - the first max in the sliding window where window is starting on 0 and going till index 2
2782:34 - so in the result we have to store 77 and 77 lies at array of j
2782:41 - so here you can see our assumption was correct here so 77 becomes our first max in the sliding
2782:47 - window moving ahead now we'll increment i so i will come here at index 1 now we suggest that
2782:59 - our sliding window will shift by one position ahead so we are done with this value and sliding
2783:06 - window will shift by one position ahead like this i plus k minus 1 so 1 plus 3 will give 4
2783:15 - minus 1 will give index 3 so it will take three values index 1 index 2 and index 3 because the
2783:23 - size of this sliding window is k which is 3 and now we'll apply the same logic we assume that
2783:31 - the first value of this sliding window is maximum and j will point to that value so i and j at the
2783:39 - start are pointing to index 1 which is 77 so our assumption is 77 is max in this sliding window
2783:48 - now to confirm that what we do is next greater element array of j j is pointing to one so it
2783:54 - means we are going to this index now and here we are finding a value as 4 which means that at index
2784:02 - 4 we have 88 which is the next greater element of 77 and here you can see 88 is next greater to 77
2784:14 - but 88 is not in the sliding window range it is just outside the sliding window range
2784:22 - therefore we are 100 sure that whatever the elements are here which is 33 and 44
2784:30 - they will be 100 sure lesser than 77 which means for this window 77 will become our max
2784:39 - because the next greater element to 77 is 88 which is at index 4 and it is lying outside the
2784:47 - boundaries of this sliding window so this condition this part will give 4 we check whether it is less
2784:54 - than i plus k which is 1 plus 3 which is 4 so 4 is not less than 4 so this condition comes out to
2785:01 - be false it means that our assumption at the start only that 77 is max in this sliding window
2785:08 - comes out to be true so in the results list we will simply add the value at jth index
2785:15 - so array of j is 77 so it becomes like this
2785:24 - so we'll increment i, i comes to index 2 so our sliding window is shift ahead
2785:32 - from 2 plus 3 minus 1 which is from 2 to 4th index and now our task is to find the max in
2785:39 - this sliding window so now you will understand more about the problem in this step we assume
2785:47 - that 33 is our max in this sliding window which is being pointed by i so j starts from i
2785:56 - which is 33 so this is our assumption so now we will confirm this assumption based on this while
2786:03 - loop what we do is j is pointing to index 2, i is pointing to index 2 and we are assuming that 33
2786:11 - is max in this sliding window so what we do is we just check that at index 2 in the next greater
2786:18 - element array which index lies so we find 3 and if we go to index 3 you will find 44 which is
2786:27 - actually lying in this sliding window so it means the next greater element to 33 is 44 and it is also
2786:35 - lying in this sliding window therefore our assumption that 33 is max in this sliding window
2786:40 - comes out to be false and this condition comes out to be true because next greater element of array
2786:47 - of j which gives us value 3 we are checking whether this 3 is actually lying in the sliding
2786:54 - window or not via this comparison so we are checking whether it is less than i which is 2
2787:02 - plus 3 so we are checking whether 3 is less than 5 or not so this condition comes out to be true
2787:08 - which suggests that the next greater element to 33 which lies at index 3 is actually in the boundaries
2787:16 - of this sliding window so this condition comes out to be true and in the while loop j simply shifts
2787:22 - to 44 because our new assumption is 44 is max in this sliding window so i remains here and j comes
2787:31 - here like this and now again we need to confirm whether 44 is max in this sliding window or not
2787:40 - so what we do is j is pointing to third index so we simply go to the third index
2787:47 - we find a value 4 we check whether the value is index 4 which is 88 does 88 lie in this sliding
2787:55 - window or not so here if you see 88 is lying in this sliding window but this condition is
2788:01 - actually helping us figure that out 4 should be less than value of i is 2 2 plus 3 4 should be
2788:10 - less than 5 so this condition comes out to be true it suggests that the next greater element
2788:16 - to 44 which is at index 4 here is also part of this sliding window so the condition in while loop
2788:24 - comes out to be true and our assumption that 44 is max comes out to be false so now j will simply
2788:32 - shift to 88 via this assignment and now once again we need to confirm whether 88 is max in
2788:41 - this sliding window or not if we go to this index you will see the value 6 which suggests that
2788:49 - for 88 there are no greater element towards its right because the last index is 5
2788:54 - and therefore we were storing array.length here which suggests that there are no elements greater
2789:00 - than 88 so here this condition 6 should be less than 5 comes out to be false so this while loop
2789:06 - will terminate and we will simply add 88 into the result list like this so for the third window 88
2789:16 - becomes the max will increment i and i is actually equal to array.length minus k
2789:26 - which is 3 so this loop will run one more time because the sliding window will shift
2789:32 - by one position and now it will cover all the elements of the array we assume 44 is max
2789:42 - so j is pointing to 44 we go to this index we see the next greater to 44 is
2789:50 - lying at index 4 which is 88 here so we are simply checking whether 44 is max in this sliding window
2789:57 - or not so this will give us value 4 we are checking whether it is less than i plus k which is 3
2790:06 - plus 3 4 is less than 6 so this condition comes out to be true because 88 is max greater to 44
2790:14 - and it is lying in this range so therefore j is simply shift to 88 now via this assignment
2790:22 - like this and now we'll again confirm whether 88 is max in this sliding window or not
2790:31 - so we go to this index we find 6 we check whether it is less than i plus k which is 3 plus 3
2790:41 - so this condition comes out to be false it suggests that the next greater element to
2790:46 - 88 is beyond the boundaries of this array and our sliding window is still the last index
2790:52 - so our answer is 88 so this value will terminate and the results list we will add array of j
2791:01 - which is 88 so 88 comes here
2791:08 - so we'll increment i so i will come here but here you can see this condition comes out to be false
2791:16 - because there is no more window left of size 3 so therefore the for loop will terminate
2791:23 - and at the end we will return our result list storing the max in the sliding window
2791:31 - which is 77 77 88 88 so the first 77 is from here to here which is this value
2791:40 - the second 77 is from here to here the 88 is from this window to this window
2791:49 - and the last 88 is for last window which is from here to here so friend this was all about
2791:55 - the sliding window maximum problem i hope you must have liked this video in case if you are
2792:01 - new to my channel then please subscribe to my channel and click the bell icon so that you never
2792:06 - miss any update thanks have a nice day hello everyone so in this video we are going to discuss
2792:14 - a problem maximum sum sub array of size k now let's move ahead and see what this problem is
2792:20 - and how to solve this so here in this problem we are given an array of integers like this
2792:29 - and we are given a value of k which is an integer value now this k value you can treat it as a
2792:35 - sliding window of size k now this sliding window is moving from very left of the array to very
2792:42 - right and it is moving one one position in this direction so at the start if the value of k is
2792:48 - three it means the sliding window is taking in first three elements and these three elements
2792:55 - also form a sub array of size k now our task is to find maximum sum of any contiguous sub
2793:04 - array of size k now contiguous means that the element should be next to each other and we need
2793:11 - to take a sub array of size k only we need to evaluate their sum and whichever sub array has
2793:18 - the maximum sum we need to return that sum so let's say if we are given with this input array
2793:25 - and sliding window is of size k which is three so our output would be 16 now how this 16 came is
2793:33 - let's say our first contiguous sub array of size k is from zero index to second index so it is zero
2793:40 - one two three four and five from zero to two we have a window of size k this is our sub array and
2793:49 - the elements are contiguous to each other now if we take the sum of these three elements we will
2793:53 - get a value 12 now after that what we do is we move the sliding window to right by one position
2794:01 - so two goes out of the sliding window and five comes into the sliding window so now our three
2794:07 - elements are this seven three and five if we do the sum of these three elements we get the sum as
2794:14 - 15 then we move the sliding window ahead by one position so seven goes out of the sliding window
2794:22 - and eight comes into the sliding window so now this is our sliding window if we do sum of these
2794:27 - three elements we get sum as 16 and at the end the sliding window moves by one position
2794:35 - and reaches to the end of the array and this is our sliding window if we do sum of the three
2794:41 - elements the sum is 14 so here you can see we had six elements and if our sliding window is of size
2794:50 - three we saw there were four sub arrays of size three from zero to two from one to three from two
2794:58 - to four and from three to five and their sums are 12 15 16 and 14 so among these four sums
2795:09 - 16 is the max so our answer should be 16 it means we are telling that we have found one sub array
2795:16 - having three elements three five and eight if we do their sum we get a maximum sum of 16
2795:24 - and here window size is whatever the value of k so friends now let's move ahead and see that how
2795:30 - we can solve this problem so let's suppose we take this array and value of k is three
2795:37 - it means the sliding window size is three and it also means that at a time we can only see three
2795:43 - elements in the array and for those three elements we do their sum and we keep on doing their sum
2795:49 - for all the sliding windows and whichever sum is the maximum we simply return that sum
2795:55 - now here you can see one way to solve this problem is let's say we take a for loop
2796:01 - and inside there we take another for loop so the outer for loop
2796:08 - let's say it's point to zero index and the inner for loop will take three elements because value
2796:14 - of k is three so it takes two seven and three and do their sum so let's say j goes from zero to two
2796:24 - and do their sum so we get a value as 12 now after evaluating the first window
2796:31 - i will simply travel to this index
2796:34 - and j will take the next three elements so this this and this if we do their sum we get 15
2796:46 - and similarly it keeps on going till i reaches here for the last window
2796:51 - and do the sum and as we are evaluating the sum for each window
2796:56 - like this we compare that which is the maximum sum and at the end we simply return that sum
2797:05 - so for three five and eight this window the sum would be maximum which is 16
2797:11 - so if we solve the algorithm using two for loops this problem is very easy to solve
2797:16 - so this solution is roughly time complexity of o into n into k because we are traversing
2797:22 - the n each time we are taking k elements so the time complexity is o of n k so this time
2797:28 - complexity is not efficient we need to solve this problem in better time complexity let's say of o
2797:34 - of n so if i remove everything so here with this approach i was here and then we picked three
2797:42 - elements did their sum and then we moved i here and we then picked the three elements so here if
2797:50 - you see that for the first sliding window seven and three were part of the sum for next sliding
2798:01 - window this sliding window seven and three were part of the sum again and only five was included
2798:09 - and two was excluded so we did the sum again for these two elements and similarly for the second
2798:16 - window we took the sum of seven three and five like this but when we went to the third window
2798:29 - we again took the sum of three five so this much part
2798:34 - we are doing the sum again in the for loop so this is actually increasing our time complexity
2798:41 - now how to solve this problem in a better time complexity is
2798:46 - here you can see what we do is as we need to take the sub array
2798:52 - and it should be of size k so for the first window we take the sum directly we simply add two
2799:00 - seven and three and we get sum as twelve so this is our first window where we do the sum directly
2799:07 - now what happens is we shift the window to right by one position because we need to take
2799:13 - now the next sub array from index one to three so when we do this shifting what happens is
2799:20 - the window in blue becomes our new window and the window in yellow was our old window
2799:28 - but here you can see in both this window seven and three were included in the sum
2799:37 - so let's say if we do two plus seven plus three we get twelve and then we shift the window ahead
2799:42 - we do seven plus three plus five and we get sum as fifteen so here you can see with this nested
2799:49 - for loops we were evaluating this sum again which was in the middle of both the windows
2799:55 - now if we stop calculating this sum again and again we will get a better time complexity
2800:01 - here you can see when window was here we did a normal sum because we need at least
2800:08 - k size window so at the start we are doing the sum normally two plus seven plus three
2800:15 - we got twelve now when this window shifted ahead for the next sum here you can see two goes out of
2800:23 - the window so if you see the blue window two went out of the window and five comes into the window
2800:32 - so five comes into the blue area and two went out of the blue area because our current window
2800:39 - is from index one to three of size k now here you can see we know the sum of first three elements
2800:46 - which is 12 now as we are moving window ahead two goes out of the window we know the sum is 12
2800:52 - and if we do minus two our sum will be 10 which is the sum of these two elements
2801:01 - and if we add only five to it we get 15 which is the sum of our next three elements which is in
2801:09 - the blue area so using this property will reduce the time complexity of the algorithm so now what
2801:15 - we do is we simply perform three steps first we take sum of first k elements which is two plus
2801:23 - seven plus three so let's say it gives value as 12 now as we are shifting the window to the next
2801:30 - element so that we can evaluate the next window sum what we do is we don't have to recalculate
2801:36 - seven plus three plus five what we can do is we already know seven plus three is already in the sum
2801:43 - in the 12 we just subtract the element going out of the sliding window so the element which
2801:48 - is going out of the sliding window is two so we are subtracting two to get the sum of the remaining
2801:55 - elements in the previous window which is seven plus three which is 10 and the third step is
2802:02 - as five is getting into the window here we simply add the new element coming in the sliding window
2802:09 - so we are simply adding five which is our new element to 10 to get 15 so if you see seven plus
2802:17 - three plus five will give 15 which is the sum of our next window which starts from one to three
2802:25 - and similarly this window goes on like this one one element goes out of the window and new element
2802:32 - comes into the window so the element which is going out of the window we simply subtract
2802:37 - from the sum and the new element which is coming into the window we simply add that we also
2802:44 - compare 12 with 15 then with 16 then with 14 and add then we will figure out that 16 is the maximum
2802:52 - sum in the sub array of size k so this would be our answer and also friends here you can see the
2802:59 - value of k is 3 which is very small so here you can see these are only two elements coming
2803:04 - let's say value is k is 100 so if one element goes out of the stack we don't have to calculate
2803:11 - the 99 element sum again and again we can simply subtract one element and add another element
2803:18 - and we will get the sum of the next 100 elements so this makes our algorithm efficient
2803:25 - now let's move ahead and see the demonstration of this algorithm step by step
2803:28 - so before we start if you want to master data structures and algorithm then you can subscribe
2803:36 - to my channel and click the bell icon so that you never miss any update so here is the algorithm
2803:44 - the method name is max sub array sum which takes in the array and a value k which is the size of
2803:51 - our window so this is our array and value of k is 3 it means we are taking a sliding window of size
2804:01 - 3 as we want to evaluate the maximum sum in a sub array of size k we create an integer variable
2804:09 - max sum because we need to return an integer value from this method so here at the end we
2804:16 - will return the max sum so we initialize a variable max sum with zero then we create a
2804:23 - variable window sum so as we want to take the sum of sliding window of size k so let's say
2804:33 - this is a sliding window of size k so for these three elements whatever their sum will be
2804:39 - we store in the window sum and similarly for the next window sum we store in the window sum
2804:45 - so we create a variable window sum having value zero at the start
2804:51 - now we create an integer value start which will start from the zero index so this value
2804:58 - is basically an index value like this that the initial value is zero for start variable
2805:05 - we will see its significance later that why we have created this start
2805:09 - and now we provide a for loop and inside this for loop we will do the window sum
2805:17 - we'll compare the window sum of different windows of size k and whichever is the maximum sum
2805:24 - we simply evaluate here so what we do is we take a integer variable end we initialize it with zero
2805:32 - and this end will go till array dot length so array dot length will be six so end will go till
2805:39 - the last index which is fifth index so here end will start from the zero index so in our previous
2805:46 - slide we discussed the three steps the first step is we simply take the sum of first k elements
2805:57 - because the first window is of size k so at the start we need to include the first k elements
2806:06 - so that we can get a sum so here you can see the first window of size k will go from index zero
2806:13 - to two so it means for this window we will straight away calculate the sum
2806:20 - because we need to return the maximum sum of a sub array of size k so we need at least
2806:26 - k elements to evaluate the sum and then compare with the next windows so this if condition if you
2806:33 - see here will help us achieving that so value of end which is zero is less than six so this
2806:41 - condition comes out to be true now to our window sum as we need to evaluate the sum of first three
2806:48 - elements this will get stored in the window sum because this is our first window so what we do is
2806:54 - to window sum we add array of end which is the first element which is two so here initially the
2807:01 - value of window sum is zero plus we are doing array of end which is two we are adding the first
2807:08 - element and assigning it to window sum so window sum will become two like this and here you can see
2807:19 - that we need to evaluate the sum of first k elements so this condition if end is greater
2807:25 - than or equal to k minus one it means we are saying k minus one is two because value of k is three
2807:35 - if end is equal to two or greater than two then this if condition will come out to be true
2807:41 - so at the start value of end is zero so zero is not greater than two or equal to two
2807:50 - so it means this if condition comes out to be false and this if block won't get executed
2807:55 - so here you can see if end comes to index two here at that moment two will be
2808:01 - this condition will come out to be true so it means when end is reached here we have evaluated
2808:07 - the sum of first k elements already here we added the first element then we will add seven
2808:13 - and then we will add three so at that moment end will be at index two and when end will reach here
2808:19 - then only our main algorithm will run and then it will keep on running for every window we will
2808:26 - see that later so currently this condition comes out to be false because zero is not greater than
2808:32 - equal to two we will increment end so end comes to index one we take window sum two we add array
2808:45 - of end which is seven and we will assign it back to window sum so window sum will become nine now
2808:52 - this is the sum of first two elements we need at least first k elements to start comparing for the
2808:58 - maximum sum so this condition one is greater than equal to two still comes out to be false
2809:09 - we will increment end end comes to index two
2809:17 - we take window sum which is nine we simply add three to it so it becomes 12 like this
2809:24 - and now here you can see that our first sliding window is from index zero to two
2809:32 - it means we have taken the sum of first k elements which is two plus seven plus three which is 12
2809:40 - and now you can see end is at index two so value of end is two and it is greater than or equal to
2809:49 - k minus one which is three minus one which is two so this condition comes out to be true
2809:54 - so now if block gets executed so here as we have calculated the sum of first k elements
2810:02 - it means we know the sum of first sliding window of size k which is 12 at the start max sum is zero
2810:10 - so now what we do is we simply compare max sum and window sum and which is the maximum between
2810:16 - these two we simply assign to max sum so here what we are doing is as we have calculated the
2810:22 - sum of first k element which is the first window initially max sum is zero so you can think of
2810:27 - this condition is like we are doing if window sum is greater than max sum
2810:35 - then to max sum we are assigning window sum like this so currently maximum is zero
2810:49 - window sum is 12 so window sum is greater than maximum so this tells us that we need to discard
2810:56 - this maximum and our new maximum will become 12 so maximum value will become 12 like this
2811:05 - so as we discussed in our previous slide that after evaluating the sum of first k elements
2811:12 - this sliding window will shift ahead to get the sum of next k elements so two will go out of the
2811:20 - window and five will come into the window so we also know that the second step we
2811:25 - discussed that we need to subtract the element
2811:29 - which goes out of the window so here we are doing the same and here you can see this start
2811:38 - is actually helping us to know which is that first element of that window we know that start
2811:45 - we initialize with the zero and end move till the index two so if you see our window is from start
2811:52 - to end having three elements now when this window will shift ahead at whichever value start is
2811:58 - pointing that will go out of the sliding window which means two will go out of the sliding window
2812:04 - so what we are doing is we are not recalculating the sum now so here now what we are doing is
2812:11 - we are simply subtracting the element which is going out of the sliding window so we are taking
2812:16 - the window sum and we are simply subtracting the element which is at start index which is two
2812:22 - so our window sum will become 12 minus 2 which is 10 like this and this window
2812:31 - sum will have the sum of these two elements so for the next window we don't
2812:38 - have to calculate this window sum again we can simply reuse that so now as two
2812:44 - went out of the sliding window so for the next sliding window it will start
2812:49 - from index 1 so we simply increment start so start comes at index 1 we'll
2812:57 - increment end and comes to index 3 which suggests that now our new window will be
2813:04 - from start to end like this which means these three elements and we know that
2813:12 - when we shifted this window here 2 went out of the window and 5 came into the
2813:18 - window so here you can see 5 came into the window so our third step was we add
2813:24 - the element which comes in
2813:28 - so we are simply adding 5 to our previous evaluated window sum which is 10 so it
2813:35 - becomes 15 it means with just one sum we now have the sum of these three
2813:41 - elements we didn't evaluate it 7 plus 3 again we just added 5 to our previous
2813:46 - calculated sum which give us 15 this condition comes out to be true because
2813:53 - value of end is 3 3 is greater than equal to 2 and here you can see our window
2814:00 - sum is 15 max sum is 12 we simply compare these two values and if window
2814:06 - sum value is greater than max sum we simply assign that value to max sum so
2814:11 - here we are taking these two values which is 12 and 15 and whichever is the
2814:16 - max among these two we are assigning it to maximum because we need to return the
2814:22 - maximum sum of a sub-area of size k so we just evaluated the sum of second
2814:28 - sub-area of size k and we simply compared it with the maximum so we got
2814:34 - 15 from this sub-area so our maximum will become 15 from this statement like
2814:41 - this and now after we did the sum of this sliding window from here to here
2814:48 - we know that now this sliding window will move ahead and 7 will go out of the
2814:53 - sliding window which is which is the element to which start is pointing so
2814:58 - this will go out of the window and we know that we need to subtract the element
2815:03 - which goes out of the sliding window so that for the next sliding window we can
2815:07 - evaluate the sum easily so windows sum is 15 we do minus 7 so it will give 8
2815:14 - and once 7 will go out of the sliding window we know that now next sliding
2815:20 - window will start from index 2 so we do start++ so start will come at index 2
2815:27 - we will increment and and comes to index 4 which means now our window will start
2815:34 - from index 2 to 4 like this now yes 7 was excluded from the sliding window and
2815:43 - 8 was included in the sliding window because this sliding window shifted by
2815:47 - one position so 3 and 5 remained there and 8 was included we know that we need
2815:53 - to add that value which comes in so here we are doing the same thing we are
2815:57 - adding the value 8 into the previous calculated sum so 8 plus 8 will give 16
2816:05 - this condition is true because 4 is greater than equal to 2 the maximum is
2816:13 - 15 and this window has a sum of 16 8 plus 5 plus 3 will give 16 we know that
2816:21 - we have found one window whose sum is 16 which is greater than the previous
2816:25 - maximum so whichever value is greater among these two values we simply assign
2816:29 - to maximum so maximum will become 16 now we are done with this window so now
2816:36 - for the next window 3 will go out of the sliding window and one will come
2816:41 - into the sliding window so if 3 is going out of the sliding window we are taking
2816:46 - the sum which is 16 and we simply subtract 3 so it becomes 13 and as our
2816:54 - new sliding window will start from index 3 we simply do start plus plus so
2816:59 - start comes at index 3 will increment end and comes to index 5 it means now
2817:06 - our sliding window is from index 3 to 5 this is our last sliding window and one
2817:13 - was added to the sliding window so we simply do window sum which is 13 plus 1
2817:19 - which gives 14 we assign this 14 back to window sum so window sum will become
2817:24 - 14 this condition is true because value of end which is 5 is greater than equal
2817:33 - to 2 now our maximum is 16 and window sum is 14 so here you can see the maximum is
2817:42 - 16 window sum is 14 so we already have a maximum value in maximum so maximum
2817:49 - will remain to the 16 only because 14 is less than maximum and now for the
2817:55 - next sliding window we simply remove 5 from the sum so it becomes 9 we do start
2818:03 - plus plus because next window will start from index 4 but here you can see if we
2818:11 - do end plus plus so end will go out of the boundaries of this array which also
2818:17 - suggests that there is no window left of size k now so therefore this for loop
2818:22 - will terminate and here you can see at the end we are returning the maximum is
2818:29 - 16 so which is our answer so which came from this sub array of size k 3 plus 5
2818:39 - 8 8 plus 8 16 so from here you can see we used only one for loop and we evaluated
2818:45 - the maximum sum of a sub array of size k we need to keep these three steps in
2818:52 - mind that at the start we do the sum of first k elements and then based on this
2818:58 - condition we do our rest of the steps that one element goes out of the window
2819:04 - and one element comes into the window so the element which goes out of the window
2819:09 - which is array of start we subtract from the window sum and in the next iteration
2819:15 - of for loop which is our next window we simply add the element which just comes
2819:21 - into the sliding window and therefore this property help us in evaluating the
2819:26 - sum in a very efficient way we don't have to recalculate the sum of every k
2819:32 - elements so friends this was all about the problem I hope you must have liked
2819:36 - this video in case if you're new to my channel then please subscribe to my
2819:40 - channel and click the bell icon so that you never miss any update thanks have a
2819:44 - nice day hello everyone so in this video we are going to discuss a problem
2819:50 - longest substring without repeating characters so let's move ahead and see
2819:55 - what this problem is and how to solve this so in this problem we are given a
2820:00 - string like this our task is to find the length of longest substring without
2820:08 - repeating characters so first of all let's understand what is a substring so
2820:13 - let's suppose if you are given a string like this test so here a substring is a
2820:21 - part of the string in which we will take out the sequence of characters and
2820:25 - those sequence of characters should be contiguous it means there should be next
2820:29 - to each other so the property a substring has is first it should lie
2820:36 - within the string so it lies within the string second the sequence of characters
2820:45 - which we are taking those should be contiguous
2820:52 - which means they should be next to each other so for example if you want to find
2820:56 - that how many substrings are there in this string so if we start from T one
2821:02 - substring would be T other would be T E T E S T E S T here you can see this
2821:10 - substring should be within the string and it should be contiguous it means
2821:15 - they should lie next to each other so we can't take a substring like TT one T
2821:20 - here and another T here we need to take a part of a string which is contiguous
2821:26 - so if we start from E it would be E E S E S T if we take it from S it would be S S T
2821:36 - and if we take the last T it would be like this so if the length of the string
2821:42 - is let's say n so the total number of substring would be n into n plus 1 by 2
2821:49 - so here n is 4 so if we put 4 here we will get 4 into 4 plus 1 by 2 which is 4
2821:58 - into 5 by 2 which is 10 so you can see 1 2 3 4 5 6 7 8 9 10 so we need to keep in
2822:12 - mind a substring should lie within the string and the part of the string that
2822:17 - we are taking it should be contiguous so our task is to find the length of the
2822:22 - longest substring in such a way that character should not be repeated so if
2822:27 - you take this example here ABC has length 3 but as soon as A comes we get a
2822:34 - repeating character so we discard this A and if we take B C A the length is 3
2822:40 - because after that we have found 1 B and B is repeating in B C A so we discard
2822:46 - this B now we start from C so C A and B length is 3 we can't move ahead because
2822:55 - we have found a repeating character C so we discard this C and then we find A B
2823:02 - C and again we find a B so length remains 3 so after we find this B we can
2823:08 - discard this A and B together because they won't contribute to the longest
2823:13 - substring now so C and B will take two characters and then we find a repeating
2823:19 - character so we discard this C and B and at the end we will find 1 B so the length
2823:25 - of the longest substring without repeating character is 3 it can be
2823:29 - found from A B C B C A C A B A B C that's it because after that we are
2823:37 - getting a substring of length 2 like B C C B and at the end we are getting only
2823:43 - 1 B similarly in this example we have a string B B B B so the longest substring
2823:50 - without repeating character would be 1 because all the characters are repeating
2823:54 - here P W becomes 2 because we have found one W here which is repeating so we'll
2824:01 - discard this P and W then we'll go here and then we will find one W so this
2824:08 - length is 3 and as soon as we find W we discard this W and then we start our
2824:14 - substring from K we will find K E W which is length 3 so the length of the
2824:20 - longest substring without repeating character is 3 so let's move ahead and
2824:24 - see the demonstration of this algorithm step by step so before we start in case
2824:30 - if you're new to my channel then please subscribe to my channel and click the
2824:34 - bell icon so that you never miss any update so here is the algorithm to find
2824:39 - the length of the longest substring without repeating characters so method
2824:43 - name is length of longest substring it takes in a string S and returns the
2824:48 - length of the longest substring without repeating characters so let's say when
2824:53 - we call this method by passing this string so S will become like this P W W
2824:59 - K E W so if we see this string internally it will be a character array
2825:04 - like this so friends the basic idea behind this algorithm is we create a
2825:11 - hash map like this where key is the character and value is the integer so
2825:18 - here as we need to find the length of the longest substring without repeating
2825:21 - characters what we are doing is we will store the character along with its index
2825:26 - into this map so that when we encounter a repeating character we simply look up
2825:32 - into this hash map and we simply figure out that when that repeating character
2825:36 - last occurred so that we can start our new substring search from an index just
2825:41 - after that so you will understand more later in the algorithm as you want to
2825:49 - return the length of the longest substring without repeating characters
2825:52 - we will be storing it in the max length so at the start max length will be 0
2825:58 - like this so as we want to identify the length of the longest substring without
2826:05 - repeating characters we will process each character one by one from left to
2826:10 - right so let's say if we take these two characters P and W so the length of this
2826:17 - substring is 2 so in this algorithm we will take the help of two variables
2826:22 - start and end so this start and end will be actually referring to the indexes so
2826:31 - let's say for P W let's say start is here and end is here so if you see
2826:39 - closely start and end basically forms a window like this which has some
2826:44 - characters so this window is starting with this start variable and ending with
2826:50 - this end variable and those are pointing to the indexes so if you want to know
2826:55 - the length of this substring we can use the formula as end minus start plus 1 as
2827:04 - these are pointing to the indexes it could be 1 minus 0 plus 1 so we'll get
2827:10 - the answer is 2 which is the length of this substring so you can treat this as
2827:15 - a window from start to end why we are using this two pointer is we need to
2827:22 - identify the length of the longest substring without repeating characters
2827:27 - so we need to put start at a point from where we are evaluating the length of
2827:33 - the longest substring and we will move end in this direction so that as soon as
2827:38 - we encounter a repeating character we stop and there itself and using start
2827:44 - and end we can figure out the length of that particular substring with this
2827:49 - formula so we will understand more when we proceed ahead so as we haven't
2827:56 - processed any of the node so start will point to zero index like this and as we
2828:03 - discuss we will move end into this direction and start from 0 because now
2828:09 - we are processing this first character and end will go till the last index
2828:13 - which is 5 so in this string class we have a method charAt where if we pass
2828:20 - any index it will return back the character at that particular index so if
2828:25 - we call s.charAt 0 because end is at 0 index we will get a value as p which we
2828:32 - will be storing in the right char like this so here we are asking the string to
2828:39 - return the character at this index which is 0 index which is p and that p we are
2828:45 - storing in the right char like this so as end is moving in this direction we
2828:52 - have denoted it by right char so now the first thing we do is we simply find
2828:58 - whether right char is present in our hashmap or not so we provide this if
2829:04 - condition map.containsKey where we pass the right char and if the map contains
2829:10 - that key it will return true we will understand more about this part later so
2829:17 - currently map.containsKey will return false because this key is not present
2829:22 - in the hashmap so here for the first char we know that it's a substring and
2829:29 - it doesn't have any repeating character and we also know that in the hashmap we
2829:33 - put the char along with its index so we are putting char along with its index so
2829:40 - it would look something like this p and we are putting value as 0 which is end
2829:47 - so here you can see currently our window is here where start and end are pointing
2829:53 - to only single character and our max length is 0 because we haven't processed
2829:58 - any character so with this formula we will identify the number of characters
2830:04 - in this window so end minus start plus 1 so it would be 0 minus 0 plus 1 so the
2830:14 - length of the substring is 1 we are comparing it with max length that
2830:19 - whichever is the max we will directly store in the max length because at the
2830:23 - end we have to return the max length so for this small substring the max length
2830:29 - will become 1 because here it is 0 and this gives value as 1 so whichever is
2830:37 - the max we are storing in the max length so we will increment end so why
2830:48 - we are incrementing end because with the combination of p and w we can get a
2830:54 - substring which is of length 2 and it doesn't have a repeating character so
2831:00 - therefore start will remain at index 0 only and we will move only end in this
2831:05 - direction so first we will get the character at index 1 now so right care
2831:12 - will become w like this we will check whether w is present in this map or not
2831:20 - so this condition comes out to be false and we will simply put w along with its
2831:27 - index in the hash map so it would look something like this now here max length
2831:34 - is 1 and if we use this formula 1 minus 0 plus 1 it will give the value as 2 so
2831:45 - here you can see that we have a window of length 2 which is a substring pw
2831:50 - which doesn't have repeating character so this will give value as 2 so now our
2831:55 - max length will change it will become 2 will increment end so end will come to
2832:07 - index 2 so first we will identify the character at index 2 which is w so right
2832:14 - care will become w so friends here you can see that our hash map actually
2832:20 - contains w so when we will call map.contains key will pass the character
2832:26 - as w it will return a value true so this if condition comes out to be true
2832:31 - because we have w already in the hash map it means we have found a repeating
2832:37 - character and we can't include this w into this substring so here now what we
2832:45 - do is till this point we have found the length of the longest substring as 2
2832:49 - which is pw but as soon as we encounter w we can't include this w here because
2832:56 - we will have a repeating character so we need to move this start after w so that
2833:02 - we can discard one of the w and how we can do that is as w is present in this
2833:07 - hash map at index 1 we will first get that index it will be 1 so this index
2833:14 - will be returned and we have to just start after this index so we will add
2833:18 - plus 1 and currently start is at 0 index so we will take the max of start and
2833:24 - this value so 2 is greater than 0 so now our start will go to the index 2 like
2833:31 - this we suggest that we have found w here so the next longest substring will
2833:38 - include another w so we need to discard this w and start just after that so
2833:44 - therefore we are looking up into the hash map to see when this w occurred
2833:48 - last and then we start finding a new substring from index just after that
2833:54 - which is 1 plus 1 because w was found at index 1 so start comes here so it means
2834:01 - we can simply discard these two characters and start finding the length
2834:05 - of the longest substring from index 2 now so as we are starting from index 2
2834:13 - because start is pointing to index 2 we will put w along with its index in the
2834:17 - hash map so this value will be overridden to 2 and for this single
2834:26 - substring we know that max length is 2 which we already found as pw so 2 and
2834:34 - minus start plus 1 so 2 minus 2 plus 1 will give 1 so 1 so the length of the
2834:42 - longest substring without repeating characters till this point will remain
2834:46 - 2 we will increment and and comes to index 3 at index 3 we have a character
2834:58 - K so right care will become K K is not present in this hash map so this
2835:08 - condition comes out to be false so we will simply put K with index 3 into our
2835:16 - hash map like this the max length is 2 and is at index 3 and start is an index
2835:26 - 2 so 3 minus 2 plus 1 it will give 2 so the max length will still remain 2
2835:32 - because this part is 2 and max will return a maximum value between these two
2835:38 - so 2 will be assigned to max length like this will increment and and becomes
2835:49 - 4 the character at fourth index is E so right care will become E is not present
2836:00 - in this hash map so this condition comes out to be false so we will put E
2836:05 - into this hash map along with its index like this so here you can see max length
2836:13 - is 2 and minus 2 plus 1 it will give 3 so this part will give 3 so here you can see
2836:24 - we have found one substring W K E without repeating characters which has a length of
2836:31 - 3 so therefore now our max length will change because max.max will return a value 3 when
2836:38 - it's compared with 2 so max length will become 3 we suggest that we have found one substring
2836:45 - of length 3 without repeating characters will increment and and becomes 5 the character
2836:56 - at fifth index is W so right care will become W so friends here you can see that W is present
2837:05 - in this hash map so this condition comes out to be true and here what we are doing is with
2837:12 - this map dot get right care we are just figuring out that when this W occurred last in this
2837:19 - character array so this hash map will bring us that index that W occurred at index 2 so we
2837:25 - suggest that whatever the substring we found till this point we can't include W because if we
2837:31 - include W that will be repeating character so in order to include W for the rest of the string we
2837:38 - have to discard this W so for that we need to know the index so when we identify that index
2837:44 - we simply shift start to a character ahead then what we find from this map dot get right care so
2837:52 - here it gives 2 so we simply just shift by one position by adding plus 1 start was at 2 so
2838:00 - map dot max among 2 and 3 will give values 3 so start will now come to index 3 like this we
2838:08 - suggest that our new substring should start from this index so now we simply put W into the hash
2838:17 - map along with its index so the index value will be updated here it will become 5 and here you can
2838:27 - see max length is 3 and minus start plus 1 so 5 minus 3 plus 1 will give 3 so this comes out
2838:39 - to be 3 which suggests that one more substring is KEW which is longest and without any repeating
2838:47 - character but among these two lengths both are same so the max length will still remain 3 only
2838:57 - so now we'll increment end so end goes beyond the boundaries of this care array so this for loop
2839:04 - will terminate because end should go till it is less than s dot length so at the end we will
2839:11 - simply return a value 3 so friend let's suppose here if we had a value like a so this for loop
2839:18 - would have run one more time so here this a is not in this hash map so we simply put a here like
2839:25 - this a with index 6 and here our max length would have changed initially it was 3 and minus start
2839:33 - so 6 minus 3 plus 1 would have given 4 so this would have become 4 and our answer would have
2839:39 - become 4 which would suggest that the longest substring without repeating character is KEWA
2839:45 - so friend this was all about this problem we can solve this problem by keeping a sliding window of
2839:52 - variable size which has a range from start to end and whatever the characters are between start
2839:59 - to end those number of characters will give the length of that particular window and we can use
2840:06 - this hash map to figure out the repeating characters so that we can start our new window
2840:11 - from a different index by making a lookup into the hash map for the character which just got
2840:17 - repeated so friends one important thing to discuss is that why we are using math dot max and we are
2840:26 - taking whichever is the max from the start and from this statement so in order to understand
2840:33 - this let's suppose we are given with this string PWWP so the example which we took was like this
2840:40 - so in our previous example till this point everything remains the same the W we placed
2840:49 - last in the hash map at index 2 and after that we went to K so instead of K now we are going to P
2840:58 - so we will see what the difference is so when we will increment end will come to index 3 so here
2841:08 - instead of K now we are taking the right care as P by this and here you can see that map actually
2841:20 - contains P at index 0 so this condition comes out to be true so friends here you can see that if we
2841:28 - only provide this condition if we do map dot get right care will get value as 0 and if we add plus
2841:36 - 1 to it will get 1 so we can't discard this P and start from index 1 because then our substring
2841:45 - will have WWP and here currently the max length is 2 so when we will do end minus start plus 1 so
2841:54 - end is 3 and this start will come here so minus 1 plus 1 so our answer will be 3 so at the end we
2842:03 - will return max length as 3 so which is wrong because here we are playing with the indexes and
2842:08 - this algorithm doesn't know that we have encountered a W here and this is a substring with a repeated
2842:16 - character so one thing to keep in mind is if our start is an index 2 and we have found one character
2842:23 - which is an index 3 and when we look up this character in the hash map if that character
2842:31 - comes beyond our start which is the current case at 0 so this P last occurred at index 0 so we
2842:41 - don't have to consider this P or this index because currently we are processing this substring from
2842:47 - start to end and this P has occurred in this region so therefore if we do map dot get right
2842:54 - care we get index 0 if we add plus 1 we get this index 1 but our start is already at index 2
2843:04 - here so therefore we are doing this math dot max because we have to assign the maximum value
2843:11 - between these two statements to start so if start is already ahead of this statement then we don't
2843:19 - shift start back we keep the start at that point only so this is the one important thing to consider
2843:26 - for this algorithm now after this statement start remains at index 2 and we simply put
2843:33 - 3 here and here the max length is 2 if we do end minus start plus 1 we will get 3 minus 2 plus 1
2843:43 - which is equal to 2 so this is the length of that substring so when we will do math dot max
2843:50 - our answer will be still 2 because here you can see the longest substring without repeating
2843:55 - character is 2 this or this so therefore this is the important condition to keep in mind
2844:03 - so friends i hope you must have liked this video in case if you are new to my channel
2844:08 - then please subscribe to my channel and click the bell icon so that you never miss any update
2844:13 - thanks have a nice day hello everyone so in this video we are going to discuss a problem
2844:20 - symmetric tree so let's move ahead and see what this problem is and how to solve this
2844:27 - so in this problem we are given with the root of a binary tree like this which actually holds this
2844:33 - complete tree now our task is to check that whether this binary tree is mirror of itself
2844:39 - which means we need to check whether this binary tree is symmetric around its center or not
2844:45 - so let's suppose we are given with this binary tree and we need to check whether it's a symmetric
2844:50 - tree or not so for this binary tree if we draw a line like this so this line is nothing but a line
2844:57 - of symmetry so around this line if a binary tree is a mirror image of itself then we consider that
2845:04 - binary tree as a symmetric binary tree so usually when we talk about symmetrical images let's say
2845:10 - if i take a rectangle and if i want to find out whether it's a symmetrical image or not what we
2845:17 - can do is we can create a line of symmetry and if we rotate the image like this around this line
2845:27 - of symmetry let's say i denote this as a b c and d so if we rotate this image around this line of
2845:36 - symmetry you will see that a will come over b and c will come over d so if that is the case then this
2845:44 - shape is a symmetrical shape so if any shape is rotated around its line of symmetry if the left
2845:51 - part superimposes the right part then that shape is a symmetrical shape so here you can see for
2845:59 - this binary tree the line of symmetry goes from the root and we have to determine whether this
2846:07 - binary tree is a mirror of itself that is we need to check whether it's symmetric around its center
2846:14 - so this is the center so if we rotate this binary tree you will see that after the rotation
2846:21 - two will come over this two this four will come over this four and this three will come
2846:28 - over this three so we can come to know that this binary tree is symmetric around its center
2846:34 - because one will remain there itself and if we take this example here you can see that two will
2846:40 - superimpose two but as we are rotating this binary tree around the line of symmetry when
2846:48 - this two will superimpose this two this three will come like this it will not superimpose this three
2846:58 - so therefore this is not a symmetric binary tree because as we are folding this binary tree around
2847:04 - this line of symmetry when this two will superimpose this two this child at right will come
2847:12 - towards the left of it and so this three is not superimposing this three so therefore we can
2847:18 - consider that it's not a symmetrical shape also one thing to note here is the symmetrical shape
2847:24 - is actually equidistant from the line of symmetry so this two and this two both are at a equal
2847:31 - distance from the line of symmetry this four and this four both are equidistant from the
2847:37 - line of symmetry and similarly this three and this three but here you can see this two and this two
2847:45 - are equidistant from the line of symmetry this node three and this node three are not equidistant
2847:52 - from the line of symmetry therefore it's not a symmetric binary tree. So friends the basic
2847:58 - idea behind this algorithm is, if I remove this, so let's say if we are on root, and
2848:04 - this root has only one tree node, like this, so therefore we can directly consider that
2848:10 - it's a symmetric binary tree, because we need to find whether the binary tree is symmetric
2848:15 - around its center, so this is the center, if this root is null, then also will return
2848:24 - true, that it's a symmetric binary tree, so here now if binary tree is given like this,
2848:34 - so after the root, if we are going on the left, so we will reach to this node, and if
2848:42 - we look into the mirror, then this left should be equal to this right, so that we can come
2848:50 - to know that till this point, the image is symmetric, now when we reach here, and here,
2848:57 - if we are going towards left, then in the mirror it would look like we are going like
2849:04 - this, towards right, so we land here, we compare these values, and we know that till this point
2849:13 - also the tree is symmetric, now if we go towards right, so in the mirror it would look
2849:20 - like we are going towards left, and we reach to node 4, and we compare its values, so those
2849:27 - are same, so 2 is equal to 2, 3 is equal to 3, and 4 is equal to 4, and after that there
2849:33 - are no more nodes, so we can consider that this is a symmetric binary tree, so here let's
2849:40 - say if we are going towards left, then in the mirror we are going towards right, so
2849:45 - we reach here, we compare those values, they are equal, so now here we have a null value,
2849:53 - if we are going towards left, then in the mirror image we are going towards right, so
2849:58 - here we have reached to the null value, but here we have reached to an actual node having
2850:03 - value as 3, so when we will compare them, they won't be equal, so we can directly come
2850:09 - to know that this is not a symmetric binary tree, so one property to remember is, if we
2850:15 - have mirror here, and if we are going towards left, then in the mirror image you are going
2850:21 - towards right, and if we are going towards right, then in the mirror image we are going
2850:26 - towards left, so similar technique we will apply over the binary tree to figure out whether
2850:31 - it's a symmetric or not, so now let's move ahead and see the demonstration of this algorithm
2850:36 - step by step, so let's say if we are given with this binary tree, and we need to check
2850:48 - whether it is symmetric or not, so when we will call this method is symmetric by passing
2850:54 - in the root, it would look like this, that root is pointing to this binary tree, and
2851:00 - this method will return a boolean value stating that this binary tree is symmetric or not,
2851:08 - so here the first thing we check that whether root is equal to null or not, so if root is
2851:13 - equal to null, then we can directly return true, because there is no binary tree, and
2851:22 - there is no node, so the binary tree is actually symmetric around its center, so we are returning
2851:31 - so this condition comes out to be false, because root is pointing to a node having value as
2851:36 - 1, so friends we will use stack data structure to figure out whether this binary tree is
2851:43 - symmetric or not, so here we will initialize a stack like this, so stack is a leafo data
2851:50 - structure where the element inserted last will be the first to be removed, and we will
2851:56 - use this property to figure out whether the binary tree is symmetric or not, so we will
2852:01 - see that later, so here you can see if root is not equal to null, it means there is one
2852:07 - node till this point the tree is symmetric, and let's say if I draw the line of symmetry
2852:16 - like this, so we know one of the property of this line of symmetry is, let's say on
2852:21 - this side, if we are going towards right, then in the mirror image it would look like
2852:27 - that we are going in this direction, and similarly if we are going in this direction, then in
2852:32 - the mirror image it would look like we are going in this direction, so therefore in the
2852:38 - stack what we are doing is, we are pushing root.right which is true, so it means if we
2852:47 - look into its mirror image, then we need to put this two into the stack as well, because
2852:54 - we know that on this side if we are going towards right, it means on this side we are
2852:58 - going in this direction, so therefore we need to compare this two with this two, so if we
2853:05 - are going towards right on this side of mirror, then we are going towards left on this side
2853:10 - of mirror, so we are putting both the two's into the stack so that we can pop them out
2853:16 - in pair and compare them, so this thing we will do in the while loop, we will check whether
2853:22 - stack is empty or not, so currently stack is not empty, so the condition in while loop
2853:27 - comes out to be true, so here this two, so here first we place the right one, so this
2853:33 - is the right one and this is the left one, so we will create two nodes n1 and n2, we
2853:39 - will pop the nodes from the stack and assign it to n1 and n2, so first we will pop two
2853:44 - out which is on the left side and assign it to n1, then we will pop the right one and
2853:55 - assign it to n2, so after getting n1 and n2, we need to compare these two nodes now, so
2854:04 - the first thing we are checking is whether n1 and n2 both are null at the same time or
2854:09 - not, so if both n1 and n2 are null simultaneously, then we will continue with the while loop,
2854:16 - so let's say this is our line of symmetry and let's say this is our node 1 and this
2854:21 - is our node 2, so here both of them are null, it means the symmetric property holds true
2854:26 - for both of these nodes, so we will simply continue, but here you can see n1 is pointing
2854:33 - to 2, n2 is pointing to 2, so both of these conditions come out to be false and then
2854:41 - this condition is very important because it will directly return false that whether the
2854:45 - tree is symmetric or not, so here we check that whether n1 is equal to null and n2 is
2854:52 - equal to null, so if both of the conditions are true that n1 is null and n2 is null, so
2854:57 - we can continue, so if this condition comes out to be false, we suggest that there could
2855:02 - be a chance that either n1 or n2 can be null, so if n1 is null, we directly return false
2855:09 - because here we have already checked whether n1 and n2 both are null simultaneously or
2855:14 - not, so if this condition came out to be false, we are simply checking first that if n1 is
2855:20 - equal to null, then we can directly return false or if n2 is equal to null, we can directly
2855:25 - return false because these two cannot be null simultaneously based on this condition
2855:32 - or if their values are not equal, so currently n1 is not equal to null, n2 is not equal to
2855:38 - null, n1.well which is true is actually equal to n2.well, so this condition also comes out
2855:47 - to be false which proves that till this point, the tree is symmetric and these two and these
2855:53 - two are actually equidistant from the line of symmetry, so we simply move ahead and now
2856:02 - what we do is, as we are on n1 and we are done checking these two nodes n1 and n2, now
2856:09 - what we do is, if we want to proceed ahead in the binary tree to figure out the rest
2856:15 - of the elements are symmetric or not, we know that if we are going towards left from this
2856:20 - two to three, then in the mirror image it would look like we are going towards right
2856:28 - and if we are going towards right, then in the mirror image it would look like we are
2856:33 - going towards left, so these two nodes are symmetric, so now we have to compare n1's
2856:39 - left with n2's right and n1's right with n2's left and if those are equal, then we keep
2856:47 - on doing this thing till the complete binary tree is empty, so here in the stack what we
2856:53 - are doing is, we are pushing n1's left which is three, so this is the first node like this
2857:07 - and as we need to put them in pairs so that we can pop them out and compare with n1's
2857:12 - left, we need to put n2's right like this, so n2's right is three, so this is second
2857:25 - and then we will put n1's right which is null and along with we will push n2's left which
2857:37 - is the mirror image of n1's right, so null will come like this, this is the fourth push,
2857:49 - stack is not empty, so now we will pop in pairs and we will compare them, so when we
2857:56 - will do stack.pop, fourth node null will be popped out which is n2's left which is four,
2858:04 - so n1 will point to n2's left like this and then we will pop one more element which is
2858:16 - three which is n1's right, so n2 will point to n1's right like this, so here you can see
2858:27 - that now we are actually comparing the mirror images nodes comparing n1 and n2 which are
2858:33 - actually symmetric nodes across this line of symmetry, so if n1 is null and n2 is null then
2858:42 - we will simply continue, so currently n1 is null and n2 is null, so which proves that till this
2858:48 - point the tree is symmetric, so we will continue, stack is still not empty, we will pop the node
2858:58 - which is n2's right, so now n1 will point to n2's right which is this node and then we will pop one
2859:10 - more node which is n1's left, so n2 will point to n1's left and now we will simply compare them,
2859:22 - so here you can see that we are using the stack data structure which is popping the elements in
2859:27 - pairs and we have pushed in such a way that this is the line of symmetry that if you are pushing any
2859:33 - node in the left side then in the mirror image we have to push the right side node so that we can
2859:41 - compare them and come to know that whether they are symmetric or not, so n1 is not equal to null
2859:46 - and n2 is also not equal to null, here you can see n1 is not equal to null or n2 is also not equal to
2859:55 - null, n1 dot val is 3, n2 dot val is 3, so 3 not equal to 3 comes out to be false because 3 is equal
2860:03 - to 3, so this condition comes out to be false, so it means that till this point the tree is symmetric
2860:12 - and now what we do is we perform the same steps on this node and this node, so first we will push
2860:22 - n1's left, so n1's left like this, so if we are pushing n1's left we are going to the left, so on
2860:33 - this side we have to take its corresponding node on the right side like this, so we are putting n2's
2860:40 - right which is also null, then we will push n1's right which is this null and correspondingly we
2860:51 - have to push n2's left like this, stack is not empty, we will pop this null value which is n2's
2861:06 - left and assign it to n1, so n1 will come to n2's left like this, we will pop this null which is
2861:19 - n1's right, so n2 will come to previous n1's right here, so here you can see n1 is equal to null and
2861:31 - n2 is equal to null at the same time, so therefore we will simply continue, stack is still not empty,
2861:39 - so now we will pop both the nulls, so first we will pop n2's right, so n1 will point to previous n2's
2861:50 - right which is this and we will pop this null also which is n1's left, so previous n1 was here,
2862:01 - its left is this, so n2 will point to previous n1's left, n1 is null and n2 is null simultaneously,
2862:12 - so therefore this condition comes out to be true, so we will simply continue, we suggest that this
2862:22 - null and this null is symmetric, this null and this null is symmetric, stack is empty, it means there
2862:33 - are no more nodes in the binary tree to be traversed, so we will simply return true stating
2862:38 - that across this line of symmetry, this binary tree is symmetric, so friend let's suppose we
2862:45 - are given with this binary tree now, this is the line of symmetry and we need to check whether this
2862:51 - binary tree is symmetric or not, so we will perform the same steps till this while loop, root is not
2862:58 - equal to null, we will create a stack, root is not equal to null, so we will push roots right on this
2863:07 - side along with roots left which is a mirror image of this node in this side, so 2 will come
2863:16 - and this 2 will come, stack is not empty, we will pop 2 from the stack and assign to n1 like this,
2863:29 - we will pop another 2 and assign it to n2 like this, n1 is not equal to null and n2 is also not
2863:42 - equal to null, so this condition comes out to be false, n1 is not equal to null, n2 is not equal to
2863:49 - null, n1.well which is 2 is equal to n2.well, so this condition also comes out to be false and then
2863:58 - we will simply push n1's left which is null, so till this point the tree is symmetric and for this
2864:10 - node and this node we have to check whether it's child or symmetric or not, so if we are putting the
2864:16 - left part on the stack then on this side we are actually pushing n2's right which is 3 and then
2864:29 - we are pushing n1's right which is 3 and it's corresponding n2's left like this, stack is not
2864:42 - empty, we will pop null n2's left, so n1 will come to n2's left here, we will pop this 3 which is
2864:57 - n1's right, so n2 will go to n1's right like this, so n1 is equal to null and n2 is not equal to null,
2865:12 - so one of them is null but other is not null, so we can't continue, so this condition comes out to
2865:18 - be false, now here you can see as we need to compare these two nodes and they should be equal,
2865:25 - this condition proves that n1 and n2 both are not null but there could be a chance that n1 is null
2865:32 - or n2 is null, so if any of the node came out to be null we can directly return false because
2865:38 - instead of null we actually need a node 3 here so that this binary tree can be symmetric till
2865:45 - this point but as it's a null value here, so this condition comes out to be true and as it's a or
2865:53 - operator here we can directly return false, so from here only we will return false stating that
2865:59 - this is not a symmetric binary tree, so friend this was all about the symmetric binary tree,
2866:05 - I hope you must have liked this video, in case if you are new to my channel then please subscribe
2866:10 - to my channel and click the bell icon so that you never miss any update, thanks have a nice day.